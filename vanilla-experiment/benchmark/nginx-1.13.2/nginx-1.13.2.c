/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 197 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 46 "/tmp/llvm-project/virtualroot/lib/clang/11.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 270 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 277 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 32 "/tmp/llvm-project/virtualroot/lib/clang/11.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 29 "/usr/include/glob.h"
typedef unsigned long size_t___0;
#line 80
struct stat ;
#line 109
struct stat64 ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h"
struct iovec {
   void *iov_base ;
   size_t___0 iov_len ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 254 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t___0 msg_iovlen ;
   void *msg_control ;
   size_t___0 msg_controllen ;
   int msg_flags ;
};
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t___0 cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 119 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 78 "src/core/ngx_config.h"
typedef intptr_t ngx_int_t;
#line 79 "src/core/ngx_config.h"
typedef uintptr_t ngx_uint_t;
#line 15 "src/core/ngx_core.h"
struct ngx_module_s ;
#line 15 "src/core/ngx_core.h"
typedef struct ngx_module_s ngx_module_t;
#line 16
struct ngx_conf_s ;
#line 16 "src/core/ngx_core.h"
typedef struct ngx_conf_s ngx_conf_t;
#line 17
struct ngx_cycle_s ;
#line 17 "src/core/ngx_core.h"
typedef struct ngx_cycle_s ngx_cycle_t;
#line 18
struct ngx_pool_s ;
#line 18 "src/core/ngx_core.h"
typedef struct ngx_pool_s ngx_pool_t;
#line 19
struct ngx_chain_s ;
#line 19 "src/core/ngx_core.h"
typedef struct ngx_chain_s ngx_chain_t;
#line 20
struct ngx_log_s ;
#line 20 "src/core/ngx_core.h"
typedef struct ngx_log_s ngx_log_t;
#line 21
struct ngx_open_file_s ;
#line 21 "src/core/ngx_core.h"
typedef struct ngx_open_file_s ngx_open_file_t;
#line 22
struct ngx_command_s ;
#line 22 "src/core/ngx_core.h"
typedef struct ngx_command_s ngx_command_t;
#line 23
struct ngx_file_s ;
#line 23 "src/core/ngx_core.h"
typedef struct ngx_file_s ngx_file_t;
#line 24
struct ngx_event_s ;
#line 24 "src/core/ngx_core.h"
typedef struct ngx_event_s ngx_event_t;
#line 26
struct ngx_connection_s ;
#line 26 "src/core/ngx_core.h"
typedef struct ngx_connection_s ngx_connection_t;
#line 98 "src/os/unix/ngx_atomic.h"
typedef unsigned long ngx_atomic_uint_t;
#line 16 "src/core/ngx_rbtree.h"
typedef ngx_uint_t ngx_rbtree_key_t;
#line 20
struct ngx_rbtree_node_s ;
#line 20 "src/core/ngx_rbtree.h"
typedef struct ngx_rbtree_node_s ngx_rbtree_node_t;
#line 22 "src/core/ngx_rbtree.h"
struct ngx_rbtree_node_s {
   ngx_rbtree_key_t key ;
   ngx_rbtree_node_t *left ;
   ngx_rbtree_node_t *right ;
   ngx_rbtree_node_t *parent ;
   u_char color ;
   u_char data ;
};
#line 32
struct ngx_rbtree_s ;
#line 32 "src/core/ngx_rbtree.h"
typedef struct ngx_rbtree_s ngx_rbtree_t;
#line 37 "src/core/ngx_rbtree.h"
struct ngx_rbtree_s {
   ngx_rbtree_node_t *root ;
   ngx_rbtree_node_t *sentinel ;
   void (*insert)(ngx_rbtree_node_t *root , ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) ;
};
#line 16 "src/os/unix/ngx_time.h"
typedef ngx_rbtree_key_t ngx_msec_t;
#line 17 "src/os/unix/ngx_socket.h"
typedef int ngx_socket_t;
#line 16 "src/core/ngx_string.h"
struct __anonstruct_ngx_str_t_859632499 {
   size_t___0 len ;
   u_char *data ;
};
#line 16 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_str_t_859632499 ngx_str_t;
#line 16 "src/os/unix/ngx_files.h"
typedef int ngx_fd_t;
#line 17 "src/os/unix/ngx_files.h"
typedef struct stat ngx_file_info_t;
#line 50 "src/core/ngx_log.h"
struct ngx_log_s {
   ngx_uint_t log_level ;
   ngx_open_file_t *file ;
   ngx_atomic_uint_t connection ;
   time_t disk_full_time ;
   u_char *(*handler)(ngx_log_t *log , u_char *buf , size_t___0 len ) ;
   void *data ;
   void (*writer)(ngx_log_t *log , ngx_uint_t level , u_char *buf , size_t___0 len ) ;
   void *wdata ;
   char *action ;
   ngx_log_t *next ;
};
#line 32 "src/core/ngx_palloc.h"
struct ngx_pool_cleanup_s ;
#line 32 "src/core/ngx_palloc.h"
typedef struct ngx_pool_cleanup_s ngx_pool_cleanup_t;
#line 34 "src/core/ngx_palloc.h"
struct ngx_pool_cleanup_s {
   void (*handler)(void *data ) ;
   void *data ;
   ngx_pool_cleanup_t *next ;
};
#line 41
struct ngx_pool_large_s ;
#line 41 "src/core/ngx_palloc.h"
typedef struct ngx_pool_large_s ngx_pool_large_t;
#line 43 "src/core/ngx_palloc.h"
struct ngx_pool_large_s {
   ngx_pool_large_t *next ;
   void *alloc ;
};
#line 49 "src/core/ngx_palloc.h"
struct __anonstruct_ngx_pool_data_t_80412943 {
   u_char *last ;
   u_char *end ;
   ngx_pool_t *next ;
   ngx_uint_t failed ;
};
#line 49 "src/core/ngx_palloc.h"
typedef struct __anonstruct_ngx_pool_data_t_80412943 ngx_pool_data_t;
#line 57 "src/core/ngx_palloc.h"
struct ngx_pool_s {
   ngx_pool_data_t d ;
   size_t___0 max ;
   ngx_pool_t *current ;
   ngx_chain_t *chain ;
   ngx_pool_large_t *large ;
   ngx_pool_cleanup_t *cleanup ;
   ngx_log_t *log ;
};
#line 16 "src/core/ngx_buf.h"
typedef void *ngx_buf_tag_t;
#line 18
struct ngx_buf_s ;
#line 18 "src/core/ngx_buf.h"
typedef struct ngx_buf_s ngx_buf_t;
#line 20 "src/core/ngx_buf.h"
struct ngx_buf_s {
   u_char *pos ;
   u_char *last ;
   off_t file_pos ;
   off_t file_last ;
   u_char *start ;
   u_char *end ;
   ngx_buf_tag_t tag ;
   ngx_file_t *file ;
   ngx_buf_t *shadow ;
   unsigned int temporary : 1 ;
   unsigned int memory : 1 ;
   unsigned int mmap : 1 ;
   unsigned int recycled : 1 ;
   unsigned int in_file : 1 ;
   unsigned int flush : 1 ;
   unsigned int sync : 1 ;
   unsigned int last_buf : 1 ;
   unsigned int last_in_chain : 1 ;
   unsigned int last_shadow : 1 ;
   unsigned int temp_file : 1 ;
   int num ;
};
#line 59 "src/core/ngx_buf.h"
struct ngx_chain_s {
   ngx_buf_t *buf ;
   ngx_chain_t *next ;
};
#line 16 "src/core/ngx_queue.h"
struct ngx_queue_s ;
#line 16 "src/core/ngx_queue.h"
typedef struct ngx_queue_s ngx_queue_t;
#line 18 "src/core/ngx_queue.h"
struct ngx_queue_s {
   ngx_queue_t *prev ;
   ngx_queue_t *next ;
};
#line 16 "src/core/ngx_array.h"
struct __anonstruct_ngx_array_t_666055094 {
   void *elts ;
   ngx_uint_t nelts ;
   size_t___0 size ;
   ngx_uint_t nalloc ;
   ngx_pool_t *pool ;
};
#line 16 "src/core/ngx_array.h"
typedef struct __anonstruct_ngx_array_t_666055094 ngx_array_t;
#line 16 "src/core/ngx_list.h"
struct ngx_list_part_s ;
#line 16 "src/core/ngx_list.h"
typedef struct ngx_list_part_s ngx_list_part_t;
#line 18 "src/core/ngx_list.h"
struct ngx_list_part_s {
   void *elts ;
   ngx_uint_t nelts ;
   ngx_list_part_t *next ;
};
#line 25 "src/core/ngx_list.h"
struct __anonstruct_ngx_list_t_77896360 {
   ngx_list_part_t *last ;
   ngx_list_part_t part ;
   size_t___0 size ;
   ngx_uint_t nalloc ;
   ngx_pool_t *pool ;
};
#line 25 "src/core/ngx_list.h"
typedef struct __anonstruct_ngx_list_t_77896360 ngx_list_t;
#line 16 "src/core/ngx_file.h"
struct ngx_file_s {
   ngx_fd_t fd ;
   ngx_str_t name ;
   ngx_file_info_t info ;
   off_t offset ;
   off_t sys_offset ;
   ngx_log_t *log ;
   unsigned int valid_info : 1 ;
   unsigned int directio : 1 ;
};
#line 38 "src/core/ngx_cycle.h"
struct ngx_cycle_s {
   void ****conf_ctx ;
   ngx_pool_t *pool ;
   ngx_log_t *log ;
   ngx_log_t new_log ;
   ngx_uint_t log_use_stderr ;
   ngx_connection_t **files ;
   ngx_connection_t *free_connections ;
   ngx_uint_t free_connection_n ;
   ngx_module_t **modules ;
   ngx_uint_t modules_n ;
   ngx_uint_t modules_used ;
   ngx_queue_t reusable_connections_queue ;
   ngx_uint_t reusable_connections_n ;
   ngx_array_t listening ;
   ngx_array_t paths ;
   ngx_array_t config_dump ;
   ngx_rbtree_t config_dump_rbtree ;
   ngx_rbtree_node_t config_dump_sentinel ;
   ngx_list_t open_files ;
   ngx_list_t shared_memory ;
   ngx_uint_t connection_n ;
   ngx_uint_t files_n ;
   ngx_connection_t *connections ;
   ngx_event_t *read_events ;
   ngx_event_t *write_events ;
   ngx_cycle_t *old_cycle ;
   ngx_str_t conf_file ;
   ngx_str_t conf_param ;
   ngx_str_t conf_prefix ;
   ngx_str_t prefix ;
   ngx_str_t lock_file ;
   ngx_str_t hostname ;
};
#line 77 "src/core/ngx_conf_file.h"
struct ngx_command_s {
   ngx_str_t name ;
   ngx_uint_t type ;
   char *(*set)(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
   ngx_uint_t conf ;
   ngx_uint_t offset ;
   void *post ;
};
#line 89 "src/core/ngx_conf_file.h"
struct ngx_open_file_s {
   ngx_fd_t fd ;
   ngx_str_t name ;
   void (*flush)(ngx_open_file_t *file , ngx_log_t *log ) ;
   void *data ;
};
#line 98 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_file_t_725929674 {
   ngx_file_t file ;
   ngx_buf_t *buffer ;
   ngx_buf_t *dump ;
   ngx_uint_t line ;
};
#line 98 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_file_t_725929674 ngx_conf_file_t;
#line 116 "src/core/ngx_conf_file.h"
struct ngx_conf_s {
   char *name ;
   ngx_array_t *args ;
   ngx_cycle_t *cycle ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
   ngx_conf_file_t *conf_file ;
   ngx_log_t *log ;
   void *ctx ;
   ngx_uint_t module_type ;
   ngx_uint_t cmd_type ;
   char *(*handler)(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
   char *handler_conf ;
};
#line 222 "src/core/ngx_module.h"
struct ngx_module_s {
   ngx_uint_t ctx_index ;
   ngx_uint_t index ;
   char *name ;
   ngx_uint_t spare0 ;
   ngx_uint_t spare1 ;
   ngx_uint_t version ;
   char const   *signature ;
   void *ctx ;
   ngx_command_t *commands ;
   ngx_uint_t type ;
   ngx_int_t (*init_master)(ngx_log_t *log ) ;
   ngx_int_t (*init_module)(ngx_cycle_t *cycle ) ;
   ngx_int_t (*init_process)(ngx_cycle_t *cycle ) ;
   ngx_int_t (*init_thread)(ngx_cycle_t *cycle ) ;
   void (*exit_thread)(ngx_cycle_t *cycle ) ;
   void (*exit_process)(ngx_cycle_t *cycle ) ;
   void (*exit_master)(ngx_cycle_t *cycle ) ;
   uintptr_t spare_hook0 ;
   uintptr_t spare_hook1 ;
   uintptr_t spare_hook2 ;
   uintptr_t spare_hook3 ;
   uintptr_t spare_hook4 ;
   uintptr_t spare_hook5 ;
   uintptr_t spare_hook6 ;
   uintptr_t spare_hook7 ;
};
#line 16 "src/core/ngx_connection.h"
struct ngx_listening_s ;
#line 16 "src/core/ngx_connection.h"
typedef struct ngx_listening_s ngx_listening_t;
#line 18 "src/core/ngx_connection.h"
struct ngx_listening_s {
   ngx_socket_t fd ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   size_t___0 addr_text_max_len ;
   ngx_str_t addr_text ;
   int type ;
   int backlog ;
   int rcvbuf ;
   int sndbuf ;
   int keepidle ;
   int keepintvl ;
   int keepcnt ;
   void (*handler)(ngx_connection_t *c ) ;
   void *servers ;
   ngx_log_t log ;
   ngx_log_t *logp ;
   size_t___0 pool_size ;
   size_t___0 post_accept_buffer_size ;
   ngx_msec_t post_accept_timeout ;
   ngx_listening_t *previous ;
   ngx_connection_t *connection ;
   ngx_uint_t worker ;
   unsigned int open : 1 ;
   unsigned int remain : 1 ;
   unsigned int ignore : 1 ;
   unsigned int bound : 1 ;
   unsigned int inherited : 1 ;
   unsigned int nonblocking_accept : 1 ;
   unsigned int listen : 1 ;
   unsigned int nonblocking : 1 ;
   unsigned int shared : 1 ;
   unsigned int addr_ntop : 1 ;
   unsigned int wildcard : 1 ;
   unsigned int ipv6only : 1 ;
   unsigned int reuseport : 1 ;
   unsigned int add_reuseport : 1 ;
   unsigned int keepalive : 2 ;
   unsigned int deferred_accept : 1 ;
   unsigned int delete_deferred : 1 ;
   unsigned int add_deferred : 1 ;
   int fastopen ;
};
#line 121 "src/core/ngx_connection.h"
struct ngx_connection_s {
   void *data ;
   ngx_event_t *read ;
   ngx_event_t *write ;
   ngx_socket_t fd ;
   ssize_t (*recv)(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
   ssize_t (*send)(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
   ssize_t (*recv_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_chain_t *(*send_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_listening_t *listening ;
   off_t sent ;
   ngx_log_t *log ;
   ngx_pool_t *pool ;
   int type ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t addr_text ;
   ngx_str_t proxy_protocol_addr ;
   in_port_t proxy_protocol_port ;
   struct sockaddr *local_sockaddr ;
   socklen_t local_socklen ;
   ngx_buf_t *buffer ;
   ngx_queue_t queue ;
   ngx_atomic_uint_t number ;
   ngx_uint_t requests ;
   unsigned int buffered : 8 ;
   unsigned int log_error : 3 ;
   unsigned int timedout : 1 ;
   unsigned int error : 1 ;
   unsigned int destroyed : 1 ;
   unsigned int idle : 1 ;
   unsigned int reusable : 1 ;
   unsigned int close : 1 ;
   unsigned int shared : 1 ;
   unsigned int sendfile : 1 ;
   unsigned int sndlowat : 1 ;
   unsigned int tcp_nodelay : 2 ;
   unsigned int tcp_nopush : 2 ;
   unsigned int need_last_buf : 1 ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 50 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 211 "/usr/include/netinet/in.h"
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 211 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
union __anonunion_sem_t_1036346510 {
   char __size[32] ;
   long __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
typedef union __anonunion_sem_t_1036346510 sem_t;
#line 80 "src/core/ngx_config.h"
typedef intptr_t ngx_flag_t;
#line 16 "src/os/unix/ngx_errno.h"
typedef int ngx_err_t;
#line 106 "src/os/unix/ngx_atomic.h"
typedef ngx_atomic_uint_t volatile   ngx_atomic_t;
#line 28 "src/core/ngx_string.h"
struct __anonstruct_ngx_variable_value_t_97399873 {
   unsigned int len : 28 ;
   unsigned int valid : 1 ;
   unsigned int no_cacheable : 1 ;
   unsigned int not_found : 1 ;
   unsigned int escape : 1 ;
   u_char *data ;
};
#line 28 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_variable_value_t_97399873 ngx_variable_value_t;
#line 18 "src/os/unix/ngx_files.h"
typedef ino_t ngx_file_uniq_t;
#line 16 "src/os/unix/ngx_shmem.h"
struct __anonstruct_ngx_shm_t_362357203 {
   u_char *addr ;
   size_t___0 size ;
   ngx_str_t name ;
   ngx_log_t *log ;
   ngx_uint_t exists ;
};
#line 16 "src/os/unix/ngx_shmem.h"
typedef struct __anonstruct_ngx_shm_t_362357203 ngx_shm_t;
#line 65 "src/core/ngx_buf.h"
struct __anonstruct_ngx_bufs_t_1049923306 {
   ngx_int_t num ;
   size_t___0 size ;
};
#line 65 "src/core/ngx_buf.h"
typedef struct __anonstruct_ngx_bufs_t_1049923306 ngx_bufs_t;
#line 71
struct ngx_output_chain_ctx_s ;
#line 71 "src/core/ngx_buf.h"
typedef struct ngx_output_chain_ctx_s ngx_output_chain_ctx_t;
#line 78 "src/core/ngx_buf.h"
struct ngx_output_chain_ctx_s {
   ngx_buf_t *buf ;
   ngx_chain_t *in ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   unsigned int sendfile : 1 ;
   unsigned int directio : 1 ;
   unsigned int unaligned : 1 ;
   unsigned int need_in_memory : 1 ;
   unsigned int need_in_temp : 1 ;
   unsigned int aio : 1 ;
   off_t alignment ;
   ngx_pool_t *pool ;
   ngx_int_t allocated ;
   ngx_bufs_t bufs ;
   ngx_buf_tag_t tag ;
   ngx_int_t (*output_filter)(void *ctx , ngx_chain_t *in ) ;
   void *filter_ctx ;
};
#line 116 "src/core/ngx_buf.h"
struct __anonstruct_ngx_chain_writer_ctx_t_596895774 {
   ngx_chain_t *out ;
   ngx_chain_t **last ;
   ngx_connection_t *connection ;
   ngx_pool_t *pool ;
   off_t limit ;
};
#line 116 "src/core/ngx_buf.h"
typedef struct __anonstruct_ngx_chain_writer_ctx_t_596895774 ngx_chain_writer_ctx_t;
#line 16 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_elt_t_862044610 {
   void *value ;
   u_short len ;
   u_char name[1] ;
};
#line 16 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_elt_t_862044610 ngx_hash_elt_t;
#line 23 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_t_593807400 {
   ngx_hash_elt_t **buckets ;
   ngx_uint_t size ;
};
#line 23 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_t_593807400 ngx_hash_t;
#line 29 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_wildcard_t_627629529 {
   ngx_hash_t hash ;
   void *value ;
};
#line 29 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_wildcard_t_627629529 ngx_hash_wildcard_t;
#line 45 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_combined_t_696224875 {
   ngx_hash_t hash ;
   ngx_hash_wildcard_t *wc_head ;
   ngx_hash_wildcard_t *wc_tail ;
};
#line 45 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_combined_t_696224875 ngx_hash_combined_t;
#line 92 "src/core/ngx_hash.h"
struct __anonstruct_ngx_table_elt_t_827342826 {
   ngx_uint_t hash ;
   ngx_str_t key ;
   ngx_str_t value ;
   u_char *lowcase_key ;
};
#line 92 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_table_elt_t_827342826 ngx_table_elt_t;
#line 50 "src/core/ngx_file.h"
struct __anonstruct_ngx_path_t_1066595206 {
   ngx_str_t name ;
   size_t___0 len ;
   size_t___0 level[3] ;
   ngx_msec_t (*manager)(void *data ) ;
   ngx_msec_t (*purger)(void *data ) ;
   void (*loader)(void *data ) ;
   void *data ;
   u_char *conf_file ;
   ngx_uint_t line ;
};
#line 50 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_path_t_1066595206 ngx_path_t;
#line 71 "src/core/ngx_file.h"
struct __anonstruct_ngx_temp_file_t_541450303 {
   ngx_file_t file ;
   off_t offset ;
   ngx_path_t *path ;
   ngx_pool_t *pool ;
   char *warn ;
   ngx_uint_t access ;
   unsigned int log_level : 8 ;
   unsigned int persistent : 1 ;
   unsigned int clean : 1 ;
   unsigned int thread_write : 1 ;
};
#line 71 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_temp_file_t_541450303 ngx_temp_file_t;
#line 324 "/usr/include/pcre.h"
struct real_pcre ;
#line 325 "/usr/include/pcre.h"
typedef struct real_pcre pcre;
#line 376 "/usr/include/pcre.h"
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
#line 376 "/usr/include/pcre.h"
typedef struct pcre_extra pcre_extra;
#line 23 "src/core/ngx_regex.h"
struct __anonstruct_ngx_regex_t_771918542 {
   pcre *code ;
   pcre_extra *extra ;
};
#line 23 "src/core/ngx_regex.h"
typedef struct __anonstruct_ngx_regex_t_771918542 ngx_regex_t;
#line 16 "src/core/ngx_shmtx.h"
struct __anonstruct_ngx_shmtx_sh_t_406800305 {
   ngx_atomic_t lock ;
   ngx_atomic_t wait ;
};
#line 16 "src/core/ngx_shmtx.h"
typedef struct __anonstruct_ngx_shmtx_sh_t_406800305 ngx_shmtx_sh_t;
#line 24 "src/core/ngx_shmtx.h"
struct __anonstruct_ngx_shmtx_t_666101273 {
   ngx_atomic_t *lock ;
   ngx_atomic_t *wait ;
   ngx_uint_t semaphore ;
   sem_t sem ;
   ngx_uint_t spin ;
};
#line 24 "src/core/ngx_shmtx.h"
typedef struct __anonstruct_ngx_shmtx_t_666101273 ngx_shmtx_t;
#line 16 "src/core/ngx_slab.h"
struct ngx_slab_page_s ;
#line 16 "src/core/ngx_slab.h"
typedef struct ngx_slab_page_s ngx_slab_page_t;
#line 18 "src/core/ngx_slab.h"
struct ngx_slab_page_s {
   uintptr_t slab ;
   ngx_slab_page_t *next ;
   uintptr_t prev ;
};
#line 25 "src/core/ngx_slab.h"
struct __anonstruct_ngx_slab_stat_t_235141795 {
   ngx_uint_t total ;
   ngx_uint_t used ;
   ngx_uint_t reqs ;
   ngx_uint_t fails ;
};
#line 25 "src/core/ngx_slab.h"
typedef struct __anonstruct_ngx_slab_stat_t_235141795 ngx_slab_stat_t;
#line 34 "src/core/ngx_slab.h"
struct __anonstruct_ngx_slab_pool_t_216710741 {
   ngx_shmtx_sh_t lock ;
   size_t___0 min_size ;
   size_t___0 min_shift ;
   ngx_slab_page_t *pages ;
   ngx_slab_page_t *last ;
   ngx_slab_page_t free ;
   ngx_slab_stat_t *stats ;
   ngx_uint_t pfree ;
   u_char *start ;
   u_char *end ;
   ngx_shmtx_t mutex ;
   u_char *log_ctx ;
   u_char zero ;
   unsigned int log_nomem : 1 ;
   void *data ;
   void *addr ;
};
#line 34 "src/core/ngx_slab.h"
typedef struct __anonstruct_ngx_slab_pool_t_216710741 ngx_slab_pool_t;
#line 73 "src/core/ngx_inet.h"
struct __anonstruct_ngx_addr_t_686376295 {
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
};
#line 73 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_addr_t_686376295 ngx_addr_t;
#line 25 "src/core/ngx_cycle.h"
struct ngx_shm_zone_s ;
#line 25 "src/core/ngx_cycle.h"
typedef struct ngx_shm_zone_s ngx_shm_zone_t;
#line 29 "src/core/ngx_cycle.h"
struct ngx_shm_zone_s {
   void *data ;
   ngx_shm_t shm ;
   ngx_int_t (*init)(ngx_shm_zone_t *zone , void *data ) ;
   void *tag ;
   ngx_uint_t noreuse ;
};
#line 40 "src/core/ngx_resolver.h"
struct ngx_resolver_s ;
#line 40 "src/core/ngx_resolver.h"
typedef struct ngx_resolver_s ngx_resolver_t;
#line 56
struct ngx_resolver_ctx_s ;
#line 56 "src/core/ngx_resolver.h"
typedef struct ngx_resolver_ctx_s ngx_resolver_ctx_t;
#line 61 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_addr_t_277151541 {
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
   u_short priority ;
   u_short weight ;
};
#line 61 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_addr_t_277151541 ngx_resolver_addr_t;
#line 70 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_srv_t_201122451 {
   ngx_str_t name ;
   u_short priority ;
   u_short weight ;
   u_short port ;
};
#line 70 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_srv_t_201122451 ngx_resolver_srv_t;
#line 78 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_srv_name_t_52864061 {
   ngx_str_t name ;
   u_short priority ;
   u_short weight ;
   u_short port ;
   ngx_resolver_ctx_t *ctx ;
   ngx_int_t state ;
   ngx_uint_t naddrs ;
   ngx_addr_t *addrs ;
};
#line 78 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_srv_name_t_52864061 ngx_resolver_srv_name_t;
#line 92 "src/core/ngx_resolver.h"
union __anonunion_u_619887626 {
   in_addr_t addr ;
   in_addr_t *addrs ;
   u_char *cname ;
   ngx_resolver_srv_t *srvs ;
};
#line 92 "src/core/ngx_resolver.h"
union __anonunion_u6_1064289943 {
   struct in6_addr addr6 ;
   struct in6_addr *addrs6 ;
};
#line 92 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_node_t_112840452 {
   ngx_rbtree_node_t node ;
   ngx_queue_t queue ;
   u_char *name ;
   struct in6_addr addr6 ;
   u_short nlen ;
   u_short qlen ;
   u_char *query ;
   u_char *query6 ;
   union __anonunion_u_619887626 u ;
   u_char code ;
   u_short naddrs ;
   u_short nsrvs ;
   u_short cnlen ;
   union __anonunion_u6_1064289943 u6 ;
   u_short naddrs6 ;
   time_t expire ;
   time_t valid ;
   uint32_t ttl ;
   unsigned int tcp : 1 ;
   unsigned int tcp6 : 1 ;
   ngx_uint_t last_connection ;
   ngx_resolver_ctx_t *waiting ;
};
#line 92 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_node_t_112840452 ngx_resolver_node_t;
#line 148 "src/core/ngx_resolver.h"
struct ngx_resolver_s {
   ngx_event_t *event ;
   void *dummy ;
   ngx_log_t *log ;
   ngx_int_t ident ;
   ngx_array_t connections ;
   ngx_uint_t last_connection ;
   ngx_rbtree_t name_rbtree ;
   ngx_rbtree_node_t name_sentinel ;
   ngx_rbtree_t srv_rbtree ;
   ngx_rbtree_node_t srv_sentinel ;
   ngx_rbtree_t addr_rbtree ;
   ngx_rbtree_node_t addr_sentinel ;
   ngx_queue_t name_resend_queue ;
   ngx_queue_t srv_resend_queue ;
   ngx_queue_t addr_resend_queue ;
   ngx_queue_t name_expire_queue ;
   ngx_queue_t srv_expire_queue ;
   ngx_queue_t addr_expire_queue ;
   ngx_uint_t ipv6 ;
   ngx_rbtree_t addr6_rbtree ;
   ngx_rbtree_node_t addr6_sentinel ;
   ngx_queue_t addr6_resend_queue ;
   ngx_queue_t addr6_expire_queue ;
   time_t resend_timeout ;
   time_t tcp_timeout ;
   time_t expire ;
   time_t valid ;
   ngx_uint_t log_level ;
};
#line 195 "src/core/ngx_resolver.h"
struct ngx_resolver_ctx_s {
   ngx_resolver_ctx_t *next ;
   ngx_resolver_t *resolver ;
   ngx_resolver_node_t *node ;
   ngx_int_t ident ;
   ngx_int_t state ;
   ngx_str_t name ;
   ngx_str_t service ;
   time_t valid ;
   ngx_uint_t naddrs ;
   ngx_resolver_addr_t *addrs ;
   ngx_resolver_addr_t addr ;
   struct sockaddr_in sin ;
   ngx_uint_t count ;
   ngx_uint_t nsrvs ;
   ngx_resolver_srv_name_t *srvs ;
   void (*handler)(ngx_resolver_ctx_t *ctx ) ;
   void *data ;
   ngx_msec_t timeout ;
   unsigned int quick : 1 ;
   unsigned int async : 1 ;
   ngx_uint_t recursion ;
   ngx_event_t *event ;
};
#line 91 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_cache_t_962516213 {
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_queue_t expire_queue ;
   ngx_uint_t current ;
   ngx_uint_t max ;
   time_t inactive ;
};
#line 91 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_cache_t_962516213 ngx_open_file_cache_t;
#line 16 "src/http/ngx_http.h"
struct ngx_http_request_s ;
#line 16 "src/http/ngx_http.h"
typedef struct ngx_http_request_s ngx_http_request_t;
#line 17
struct ngx_http_upstream_s ;
#line 17 "src/http/ngx_http.h"
typedef struct ngx_http_upstream_s ngx_http_upstream_t;
#line 18
struct ngx_http_cache_s ;
#line 18 "src/http/ngx_http.h"
typedef struct ngx_http_cache_s ngx_http_cache_t;
#line 19
struct ngx_http_file_cache_s ;
#line 19 "src/http/ngx_http.h"
typedef struct ngx_http_file_cache_s ngx_http_file_cache_t;
#line 21
struct ngx_http_chunked_s ;
#line 21 "src/http/ngx_http.h"
typedef struct ngx_http_chunked_s ngx_http_chunked_t;
#line 22
struct ngx_http_v2_stream_s ;
#line 22 "src/http/ngx_http.h"
typedef struct ngx_http_v2_stream_s ngx_http_v2_stream_t;
#line 17 "src/http/ngx_http_variables.h"
typedef ngx_variable_value_t ngx_http_variable_value_t;
#line 64 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_regex_variable_t_930751596 {
   ngx_uint_t capture ;
   ngx_int_t index ;
};
#line 64 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_regex_variable_t_930751596 ngx_http_regex_variable_t;
#line 70 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_regex_t_589384264 {
   ngx_regex_t *regex ;
   ngx_uint_t ncaptures ;
   ngx_http_regex_variable_t *variables ;
   ngx_uint_t nvariables ;
   ngx_str_t name ;
};
#line 70 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_regex_t_589384264 ngx_http_regex_t;
#line 17 "src/http/ngx_http_config.h"
struct __anonstruct_ngx_http_conf_ctx_t_1021999983 {
   void **main_conf ;
   void **srv_conf ;
   void **loc_conf ;
};
#line 17 "src/http/ngx_http_config.h"
typedef struct __anonstruct_ngx_http_conf_ctx_t_1021999983 ngx_http_conf_ctx_t;
#line 24 "src/http/ngx_http_config.h"
struct __anonstruct_ngx_http_module_t_748027624 {
   ngx_int_t (*preconfiguration)(ngx_conf_t *cf ) ;
   ngx_int_t (*postconfiguration)(ngx_conf_t *cf ) ;
   void *(*create_main_conf)(ngx_conf_t *cf ) ;
   char *(*init_main_conf)(ngx_conf_t *cf , void *conf ) ;
   void *(*create_srv_conf)(ngx_conf_t *cf ) ;
   char *(*merge_srv_conf)(ngx_conf_t *cf , void *prev , void *conf ) ;
   void *(*create_loc_conf)(ngx_conf_t *cf ) ;
   char *(*merge_loc_conf)(ngx_conf_t *cf , void *prev , void *conf ) ;
};
#line 24 "src/http/ngx_http_config.h"
typedef struct __anonstruct_ngx_http_module_t_748027624 ngx_http_module_t;
#line 181 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_headers_in_t_653418768 {
   ngx_list_t headers ;
   ngx_table_elt_t *host ;
   ngx_table_elt_t *connection ;
   ngx_table_elt_t *if_modified_since ;
   ngx_table_elt_t *if_unmodified_since ;
   ngx_table_elt_t *if_match ;
   ngx_table_elt_t *if_none_match ;
   ngx_table_elt_t *user_agent ;
   ngx_table_elt_t *referer ;
   ngx_table_elt_t *content_length ;
   ngx_table_elt_t *content_range ;
   ngx_table_elt_t *content_type ;
   ngx_table_elt_t *range ;
   ngx_table_elt_t *if_range ;
   ngx_table_elt_t *transfer_encoding ;
   ngx_table_elt_t *expect ;
   ngx_table_elt_t *upgrade ;
   ngx_table_elt_t *accept_encoding ;
   ngx_table_elt_t *via ;
   ngx_table_elt_t *authorization ;
   ngx_table_elt_t *keep_alive ;
   ngx_array_t x_forwarded_for ;
   ngx_str_t user ;
   ngx_str_t passwd ;
   ngx_array_t cookies ;
   ngx_str_t server ;
   off_t content_length_n ;
   time_t keep_alive_n ;
   unsigned int connection_type : 2 ;
   unsigned int chunked : 1 ;
   unsigned int msie : 1 ;
   unsigned int msie6 : 1 ;
   unsigned int opera : 1 ;
   unsigned int gecko : 1 ;
   unsigned int chrome : 1 ;
   unsigned int safari : 1 ;
   unsigned int konqueror : 1 ;
};
#line 181 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_headers_in_t_653418768 ngx_http_headers_in_t;
#line 253 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_headers_out_t_484809816 {
   ngx_list_t headers ;
   ngx_list_t trailers ;
   ngx_uint_t status ;
   ngx_str_t status_line ;
   ngx_table_elt_t *server ;
   ngx_table_elt_t *date ;
   ngx_table_elt_t *content_length ;
   ngx_table_elt_t *content_encoding ;
   ngx_table_elt_t *location ;
   ngx_table_elt_t *refresh ;
   ngx_table_elt_t *last_modified ;
   ngx_table_elt_t *content_range ;
   ngx_table_elt_t *accept_ranges ;
   ngx_table_elt_t *www_authenticate ;
   ngx_table_elt_t *expires ;
   ngx_table_elt_t *etag ;
   ngx_str_t *override_charset ;
   size_t___0 content_type_len ;
   ngx_str_t content_type ;
   ngx_str_t charset ;
   u_char *content_type_lowcase ;
   ngx_uint_t content_type_hash ;
   ngx_array_t cache_control ;
   off_t content_length_n ;
   off_t content_offset ;
   time_t date_time ;
   time_t last_modified_time ;
};
#line 253 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_headers_out_t_484809816 ngx_http_headers_out_t;
#line 292 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_request_body_t_277727251 {
   ngx_temp_file_t *temp_file ;
   ngx_chain_t *bufs ;
   ngx_buf_t *buf ;
   off_t rest ;
   off_t received ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   ngx_http_chunked_t *chunked ;
   void (*post_handler)(ngx_http_request_t *r ) ;
};
#line 292 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_request_body_t_277727251 ngx_http_request_body_t;
#line 305
struct ngx_http_addr_conf_s ;
#line 305 "src/http/ngx_http_request.h"
typedef struct ngx_http_addr_conf_s ngx_http_addr_conf_t;
#line 307 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_connection_t_844069318 {
   ngx_http_addr_conf_t *addr_conf ;
   ngx_http_conf_ctx_t *conf_ctx ;
   ngx_chain_t *busy ;
   ngx_int_t nbusy ;
   ngx_chain_t *free ;
   unsigned int ssl : 1 ;
   unsigned int proxy_protocol : 1 ;
};
#line 307 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_connection_t_844069318 ngx_http_connection_t;
#line 328 "src/http/ngx_http_request.h"
typedef void (*ngx_http_cleanup_pt)(void *data );
#line 330
struct ngx_http_cleanup_s ;
#line 330 "src/http/ngx_http_request.h"
typedef struct ngx_http_cleanup_s ngx_http_cleanup_t;
#line 332 "src/http/ngx_http_request.h"
struct ngx_http_cleanup_s {
   void (*handler)(void *data ) ;
   void *data ;
   ngx_http_cleanup_t *next ;
};
#line 342 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_post_subrequest_t_1044399251 {
   ngx_int_t (*handler)(ngx_http_request_t *r , void *data , ngx_int_t rc ) ;
   void *data ;
};
#line 342 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_post_subrequest_t_1044399251 ngx_http_post_subrequest_t;
#line 348
struct ngx_http_postponed_request_s ;
#line 348 "src/http/ngx_http_request.h"
typedef struct ngx_http_postponed_request_s ngx_http_postponed_request_t;
#line 350 "src/http/ngx_http_request.h"
struct ngx_http_postponed_request_s {
   ngx_http_request_t *request ;
   ngx_chain_t *out ;
   ngx_http_postponed_request_t *next ;
};
#line 357
struct ngx_http_posted_request_s ;
#line 357 "src/http/ngx_http_request.h"
typedef struct ngx_http_posted_request_s ngx_http_posted_request_t;
#line 359 "src/http/ngx_http_request.h"
struct ngx_http_posted_request_s {
   ngx_http_request_t *request ;
   ngx_http_posted_request_t *next ;
};
#line 369 "src/http/ngx_http_request.h"
struct ngx_http_request_s {
   uint32_t signature ;
   ngx_connection_t *connection ;
   void **ctx ;
   void **main_conf ;
   void **srv_conf ;
   void **loc_conf ;
   void (*read_event_handler)(ngx_http_request_t *r ) ;
   void (*write_event_handler)(ngx_http_request_t *r ) ;
   ngx_http_cache_t *cache ;
   ngx_http_upstream_t *upstream ;
   ngx_array_t *upstream_states ;
   ngx_pool_t *pool ;
   ngx_buf_t *header_in ;
   ngx_http_headers_in_t headers_in ;
   ngx_http_headers_out_t headers_out ;
   ngx_http_request_body_t *request_body ;
   time_t lingering_time ;
   time_t start_sec ;
   ngx_msec_t start_msec ;
   ngx_uint_t method ;
   ngx_uint_t http_version ;
   ngx_str_t request_line ;
   ngx_str_t uri ;
   ngx_str_t args ;
   ngx_str_t exten ;
   ngx_str_t unparsed_uri ;
   ngx_str_t method_name ;
   ngx_str_t http_protocol ;
   ngx_chain_t *out ;
   ngx_http_request_t *main ;
   ngx_http_request_t *parent ;
   ngx_http_postponed_request_t *postponed ;
   ngx_http_post_subrequest_t *post_subrequest ;
   ngx_http_posted_request_t *posted_requests ;
   ngx_int_t phase_handler ;
   ngx_int_t (*content_handler)(ngx_http_request_t *r ) ;
   ngx_uint_t access_code ;
   ngx_http_variable_value_t *variables ;
   ngx_uint_t ncaptures ;
   int *captures ;
   u_char *captures_data ;
   size_t___0 limit_rate ;
   size_t___0 limit_rate_after ;
   size_t___0 header_size ;
   off_t request_length ;
   ngx_uint_t err_status ;
   ngx_http_connection_t *http_connection ;
   ngx_http_v2_stream_t *stream ;
   u_char *(*log_handler)(ngx_http_request_t *r , ngx_http_request_t *sr , u_char *buf ,
                          size_t___0 len ) ;
   ngx_http_cleanup_t *cleanup ;
   unsigned int count : 16 ;
   unsigned int subrequests : 8 ;
   unsigned int blocked : 8 ;
   unsigned int aio : 1 ;
   unsigned int http_state : 4 ;
   unsigned int complex_uri : 1 ;
   unsigned int quoted_uri : 1 ;
   unsigned int plus_in_uri : 1 ;
   unsigned int space_in_uri : 1 ;
   unsigned int invalid_header : 1 ;
   unsigned int add_uri_to_alias : 1 ;
   unsigned int valid_location : 1 ;
   unsigned int valid_unparsed_uri : 1 ;
   unsigned int uri_changed : 1 ;
   unsigned int uri_changes : 4 ;
   unsigned int request_body_in_single_buf : 1 ;
   unsigned int request_body_in_file_only : 1 ;
   unsigned int request_body_in_persistent_file : 1 ;
   unsigned int request_body_in_clean_file : 1 ;
   unsigned int request_body_file_group_access : 1 ;
   unsigned int request_body_file_log_level : 3 ;
   unsigned int request_body_no_buffering : 1 ;
   unsigned int subrequest_in_memory : 1 ;
   unsigned int waited : 1 ;
   unsigned int cached : 1 ;
   unsigned int gzip_tested : 1 ;
   unsigned int gzip_ok : 1 ;
   unsigned int gzip_vary : 1 ;
   unsigned int proxy : 1 ;
   unsigned int bypass_cache : 1 ;
   unsigned int no_cache : 1 ;
   unsigned int limit_conn_set : 1 ;
   unsigned int limit_req_set : 1 ;
   unsigned int pipeline : 1 ;
   unsigned int chunked : 1 ;
   unsigned int header_only : 1 ;
   unsigned int expect_trailers : 1 ;
   unsigned int keepalive : 1 ;
   unsigned int lingering_close : 1 ;
   unsigned int discard_body : 1 ;
   unsigned int reading_body : 1 ;
   unsigned int internal : 1 ;
   unsigned int error_page : 1 ;
   unsigned int filter_finalize : 1 ;
   unsigned int post_action : 1 ;
   unsigned int request_complete : 1 ;
   unsigned int request_output : 1 ;
   unsigned int header_sent : 1 ;
   unsigned int expect_tested : 1 ;
   unsigned int root_tested : 1 ;
   unsigned int done : 1 ;
   unsigned int logged : 1 ;
   unsigned int buffered : 4 ;
   unsigned int main_filter_need_in_memory : 1 ;
   unsigned int filter_need_in_memory : 1 ;
   unsigned int filter_need_temporary : 1 ;
   unsigned int allow_ranges : 1 ;
   unsigned int subrequest_ranges : 1 ;
   unsigned int single_range : 1 ;
   unsigned int disable_not_modified : 1 ;
   unsigned int stat_reading : 1 ;
   unsigned int stat_writing : 1 ;
   unsigned int stat_processing : 1 ;
   unsigned int background : 1 ;
   unsigned int health_check : 1 ;
   ngx_uint_t state ;
   ngx_uint_t header_hash ;
   ngx_uint_t lowcase_index ;
   u_char lowcase_header[32] ;
   u_char *header_name_start ;
   u_char *header_name_end ;
   u_char *header_start ;
   u_char *header_end ;
   u_char *uri_start ;
   u_char *uri_end ;
   u_char *uri_ext ;
   u_char *args_start ;
   u_char *request_start ;
   u_char *request_end ;
   u_char *method_end ;
   u_char *schema_start ;
   u_char *schema_end ;
   u_char *host_start ;
   u_char *host_end ;
   u_char *port_start ;
   u_char *port_end ;
   unsigned int http_minor : 16 ;
   unsigned int http_major : 16 ;
};
#line 66 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_complex_value_t_249277118 {
   ngx_str_t value ;
   ngx_uint_t *flushes ;
   void *lengths ;
   void *values ;
};
#line 66 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_complex_value_t_249277118 ngx_http_complex_value_t;
#line 30 "src/event/ngx_event.h"
struct ngx_event_s {
   void *data ;
   unsigned int write : 1 ;
   unsigned int accept : 1 ;
   unsigned int instance : 1 ;
   unsigned int active : 1 ;
   unsigned int disabled : 1 ;
   unsigned int ready : 1 ;
   unsigned int oneshot : 1 ;
   unsigned int complete : 1 ;
   unsigned int eof : 1 ;
   unsigned int error : 1 ;
   unsigned int timedout : 1 ;
   unsigned int timer_set : 1 ;
   unsigned int delayed : 1 ;
   unsigned int deferred_accept : 1 ;
   unsigned int pending_eof : 1 ;
   unsigned int posted : 1 ;
   unsigned int closed : 1 ;
   unsigned int channel : 1 ;
   unsigned int resolver : 1 ;
   unsigned int cancelable : 1 ;
   unsigned int available : 1 ;
   void (*handler)(ngx_event_t *ev ) ;
   ngx_uint_t index ;
   ngx_log_t *log ;
   ngx_rbtree_node_t timer ;
   ngx_queue_t queue ;
};
#line 22 "src/event/ngx_event_connect.h"
struct ngx_peer_connection_s ;
#line 22 "src/event/ngx_event_connect.h"
typedef struct ngx_peer_connection_s ngx_peer_connection_t;
#line 36 "src/event/ngx_event_connect.h"
struct ngx_peer_connection_s {
   ngx_connection_t *connection ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t *name ;
   ngx_uint_t tries ;
   ngx_msec_t start_time ;
   ngx_int_t (*get)(ngx_peer_connection_t *pc , void *data ) ;
   void (*free)(ngx_peer_connection_t *pc , void *data , ngx_uint_t state ) ;
   void (*notify)(ngx_peer_connection_t *pc , void *data , ngx_uint_t type ) ;
   void *data ;
   ngx_addr_t *local ;
   int type ;
   int rcvbuf ;
   ngx_log_t *log ;
   unsigned int cached : 1 ;
   unsigned int transparent : 1 ;
   unsigned int log_error : 2 ;
};
#line 17 "src/event/ngx_event_pipe.h"
struct ngx_event_pipe_s ;
#line 17 "src/event/ngx_event_pipe.h"
typedef struct ngx_event_pipe_s ngx_event_pipe_t;
#line 25 "src/event/ngx_event_pipe.h"
struct ngx_event_pipe_s {
   ngx_connection_t *upstream ;
   ngx_connection_t *downstream ;
   ngx_chain_t *free_raw_bufs ;
   ngx_chain_t *in ;
   ngx_chain_t **last_in ;
   ngx_chain_t *writing ;
   ngx_chain_t *out ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   ngx_int_t (*input_filter)(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
   void *input_ctx ;
   ngx_int_t (*output_filter)(void *data , ngx_chain_t *chain ) ;
   void *output_ctx ;
   unsigned int read : 1 ;
   unsigned int cacheable : 1 ;
   unsigned int single_buf : 1 ;
   unsigned int free_bufs : 1 ;
   unsigned int upstream_done : 1 ;
   unsigned int upstream_error : 1 ;
   unsigned int upstream_eof : 1 ;
   unsigned int upstream_blocked : 1 ;
   unsigned int downstream_done : 1 ;
   unsigned int downstream_error : 1 ;
   unsigned int cyclic_temp_file : 1 ;
   unsigned int aio : 1 ;
   ngx_int_t allocated ;
   ngx_bufs_t bufs ;
   ngx_buf_tag_t tag ;
   ssize_t busy_size ;
   off_t read_length ;
   off_t length ;
   off_t max_temp_file_size ;
   ssize_t temp_file_write_size ;
   ngx_msec_t read_timeout ;
   ngx_msec_t send_timeout ;
   ssize_t send_lowat ;
   ngx_pool_t *pool ;
   ngx_log_t *log ;
   ngx_chain_t *preread_bufs ;
   size_t___0 preread_size ;
   ngx_buf_t *buf_to_file ;
   size_t___0 limit_rate ;
   time_t start_sec ;
   ngx_temp_file_t *temp_file ;
   int num ;
};
#line 59 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_state_t_950604219 {
   ngx_uint_t status ;
   ngx_msec_t response_time ;
   ngx_msec_t connect_time ;
   ngx_msec_t header_time ;
   off_t response_length ;
   off_t bytes_received ;
   ngx_str_t *peer ;
};
#line 59 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_state_t_950604219 ngx_http_upstream_state_t;
#line 71 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_main_conf_t_514482127 {
   ngx_hash_t headers_in_hash ;
   ngx_array_t upstreams ;
};
#line 71 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_main_conf_t_514482127 ngx_http_upstream_main_conf_t;
#line 77
struct ngx_http_upstream_srv_conf_s ;
#line 77 "src/http/ngx_http_upstream.h"
typedef struct ngx_http_upstream_srv_conf_s ngx_http_upstream_srv_conf_t;
#line 85 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_peer_t_351060886 {
   ngx_int_t (*init_upstream)(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
   ngx_int_t (*init)(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
   void *data ;
};
#line 85 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_peer_t_351060886 ngx_http_upstream_peer_t;
#line 119 "src/http/ngx_http_upstream.h"
struct ngx_http_upstream_srv_conf_s {
   ngx_http_upstream_peer_t peer ;
   void **srv_conf ;
   ngx_array_t *servers ;
   ngx_uint_t flags ;
   ngx_str_t host ;
   u_char *file_name ;
   ngx_uint_t line ;
   in_port_t port ;
   ngx_uint_t no_port ;
   ngx_shm_zone_t *shm_zone ;
};
#line 138 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_local_t_334498064 {
   ngx_addr_t *addr ;
   ngx_http_complex_value_t *value ;
   ngx_uint_t transparent ;
};
#line 138 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_local_t_334498064 ngx_http_upstream_local_t;
#line 147 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_conf_t_898524950 {
   ngx_http_upstream_srv_conf_t *upstream ;
   ngx_msec_t connect_timeout ;
   ngx_msec_t send_timeout ;
   ngx_msec_t read_timeout ;
   ngx_msec_t next_upstream_timeout ;
   size_t___0 send_lowat ;
   size_t___0 buffer_size ;
   size_t___0 limit_rate ;
   size_t___0 busy_buffers_size ;
   size_t___0 max_temp_file_size ;
   size_t___0 temp_file_write_size ;
   size_t___0 busy_buffers_size_conf ;
   size_t___0 max_temp_file_size_conf ;
   size_t___0 temp_file_write_size_conf ;
   ngx_bufs_t bufs ;
   ngx_uint_t ignore_headers ;
   ngx_uint_t next_upstream ;
   ngx_uint_t store_access ;
   ngx_uint_t next_upstream_tries ;
   ngx_flag_t buffering ;
   ngx_flag_t request_buffering ;
   ngx_flag_t pass_request_headers ;
   ngx_flag_t pass_request_body ;
   ngx_flag_t ignore_client_abort ;
   ngx_flag_t intercept_errors ;
   ngx_flag_t cyclic_temp_file ;
   ngx_flag_t force_ranges ;
   ngx_path_t *temp_path ;
   ngx_hash_t hide_headers_hash ;
   ngx_array_t *hide_headers ;
   ngx_array_t *pass_headers ;
   ngx_http_upstream_local_t *local ;
   ngx_shm_zone_t *cache_zone ;
   ngx_http_complex_value_t *cache_value ;
   ngx_uint_t cache_min_uses ;
   ngx_uint_t cache_use_stale ;
   ngx_uint_t cache_methods ;
   off_t cache_max_range_offset ;
   ngx_flag_t cache_lock ;
   ngx_msec_t cache_lock_timeout ;
   ngx_msec_t cache_lock_age ;
   ngx_flag_t cache_revalidate ;
   ngx_flag_t cache_convert_head ;
   ngx_flag_t cache_background_update ;
   ngx_array_t *cache_valid ;
   ngx_array_t *cache_bypass ;
   ngx_array_t *cache_purge ;
   ngx_array_t *no_cache ;
   ngx_array_t *store_lengths ;
   ngx_array_t *store_values ;
   int cache : 2 ;
   int store : 2 ;
   unsigned int intercept_404 : 1 ;
   unsigned int change_buffering : 1 ;
   ngx_str_t module ;
};
#line 147 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_conf_t_898524950 ngx_http_upstream_conf_t;
#line 251 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_headers_in_t_557770884 {
   ngx_list_t headers ;
   ngx_uint_t status_n ;
   ngx_str_t status_line ;
   ngx_table_elt_t *status ;
   ngx_table_elt_t *date ;
   ngx_table_elt_t *server ;
   ngx_table_elt_t *connection ;
   ngx_table_elt_t *expires ;
   ngx_table_elt_t *etag ;
   ngx_table_elt_t *x_accel_expires ;
   ngx_table_elt_t *x_accel_redirect ;
   ngx_table_elt_t *x_accel_limit_rate ;
   ngx_table_elt_t *content_type ;
   ngx_table_elt_t *content_length ;
   ngx_table_elt_t *last_modified ;
   ngx_table_elt_t *location ;
   ngx_table_elt_t *accept_ranges ;
   ngx_table_elt_t *www_authenticate ;
   ngx_table_elt_t *transfer_encoding ;
   ngx_table_elt_t *vary ;
   ngx_table_elt_t *content_encoding ;
   ngx_array_t cache_control ;
   ngx_array_t cookies ;
   off_t content_length_n ;
   time_t last_modified_time ;
   unsigned int connection_close : 1 ;
   unsigned int chunked : 1 ;
};
#line 251 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_headers_in_t_557770884 ngx_http_upstream_headers_in_t;
#line 293 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_resolved_t_119826169 {
   ngx_str_t host ;
   in_port_t port ;
   ngx_uint_t no_port ;
   ngx_uint_t naddrs ;
   ngx_resolver_addr_t *addrs ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
   ngx_resolver_ctx_t *ctx ;
};
#line 293 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_resolved_t_119826169 ngx_http_upstream_resolved_t;
#line 313 "src/http/ngx_http_upstream.h"
struct ngx_http_upstream_s {
   void (*read_event_handler)(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
   void (*write_event_handler)(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
   ngx_peer_connection_t peer ;
   ngx_event_pipe_t *pipe ;
   ngx_chain_t *request_bufs ;
   ngx_output_chain_ctx_t output ;
   ngx_chain_writer_ctx_t writer ;
   ngx_http_upstream_conf_t *conf ;
   ngx_http_upstream_srv_conf_t *upstream ;
   ngx_array_t *caches ;
   ngx_http_upstream_headers_in_t headers_in ;
   ngx_http_upstream_resolved_t *resolved ;
   ngx_buf_t from_client ;
   ngx_buf_t buffer ;
   off_t length ;
   ngx_chain_t *out_bufs ;
   ngx_chain_t *busy_bufs ;
   ngx_chain_t *free_bufs ;
   ngx_int_t (*input_filter_init)(void *data ) ;
   ngx_int_t (*input_filter)(void *data , ssize_t bytes ) ;
   void *input_filter_ctx ;
   ngx_int_t (*create_key)(ngx_http_request_t *r ) ;
   ngx_int_t (*create_request)(ngx_http_request_t *r ) ;
   ngx_int_t (*reinit_request)(ngx_http_request_t *r ) ;
   ngx_int_t (*process_header)(ngx_http_request_t *r ) ;
   void (*abort_request)(ngx_http_request_t *r ) ;
   void (*finalize_request)(ngx_http_request_t *r , ngx_int_t rc ) ;
   ngx_int_t (*rewrite_redirect)(ngx_http_request_t *r , ngx_table_elt_t *h , size_t___0 prefix ) ;
   ngx_int_t (*rewrite_cookie)(ngx_http_request_t *r , ngx_table_elt_t *h ) ;
   ngx_msec_t timeout ;
   ngx_http_upstream_state_t *state ;
   ngx_str_t method ;
   ngx_str_t schema ;
   ngx_str_t uri ;
   ngx_http_cleanup_pt *cleanup ;
   unsigned int store : 1 ;
   unsigned int cacheable : 1 ;
   unsigned int accel : 1 ;
   unsigned int ssl : 1 ;
   unsigned int cache_status : 3 ;
   unsigned int buffering : 1 ;
   unsigned int keepalive : 1 ;
   unsigned int upgrade : 1 ;
   unsigned int request_sent : 1 ;
   unsigned int request_body_sent : 1 ;
   unsigned int header_sent : 1 ;
};
#line 17 "src/http/ngx_http_upstream_round_robin.h"
struct ngx_http_upstream_rr_peer_s ;
#line 17 "src/http/ngx_http_upstream_round_robin.h"
typedef struct ngx_http_upstream_rr_peer_s ngx_http_upstream_rr_peer_t;
#line 19 "src/http/ngx_http_upstream_round_robin.h"
struct ngx_http_upstream_rr_peer_s {
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
   ngx_str_t server ;
   ngx_int_t current_weight ;
   ngx_int_t effective_weight ;
   ngx_int_t weight ;
   ngx_uint_t conns ;
   ngx_uint_t max_conns ;
   ngx_uint_t fails ;
   time_t accessed ;
   time_t checked ;
   ngx_uint_t max_fails ;
   time_t fail_timeout ;
   ngx_msec_t slow_start ;
   ngx_msec_t start_time ;
   ngx_uint_t down ;
   ngx_atomic_t lock ;
   ngx_http_upstream_rr_peer_t *next ;
};
#line 59
struct ngx_http_upstream_rr_peers_s ;
#line 59 "src/http/ngx_http_upstream_round_robin.h"
typedef struct ngx_http_upstream_rr_peers_s ngx_http_upstream_rr_peers_t;
#line 61 "src/http/ngx_http_upstream_round_robin.h"
struct ngx_http_upstream_rr_peers_s {
   ngx_uint_t number ;
   ngx_slab_pool_t *shpool ;
   ngx_atomic_t rwlock ;
   ngx_http_upstream_rr_peers_t *zone_next ;
   ngx_uint_t total_weight ;
   unsigned int single : 1 ;
   unsigned int weighted : 1 ;
   ngx_str_t *name ;
   ngx_http_upstream_rr_peers_t *next ;
   ngx_http_upstream_rr_peer_t *peer ;
};
#line 63 "src/http/ngx_http_core_module.h"
struct ngx_http_location_tree_node_s ;
#line 63 "src/http/ngx_http_core_module.h"
typedef struct ngx_http_location_tree_node_s ngx_http_location_tree_node_t;
#line 64
struct ngx_http_core_loc_conf_s ;
#line 64 "src/http/ngx_http_core_module.h"
typedef struct ngx_http_core_loc_conf_s ngx_http_core_loc_conf_t;
#line 181 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_core_srv_conf_t_130441436 {
   ngx_array_t server_names ;
   ngx_http_conf_ctx_t *ctx ;
   ngx_str_t server_name ;
   size_t___0 connection_pool_size ;
   size_t___0 request_pool_size ;
   size_t___0 client_header_buffer_size ;
   ngx_bufs_t large_client_header_buffers ;
   ngx_msec_t client_header_timeout ;
   ngx_flag_t ignore_invalid_headers ;
   ngx_flag_t merge_slashes ;
   ngx_flag_t underscores_in_headers ;
   unsigned int listen : 1 ;
   unsigned int captures : 1 ;
   ngx_http_core_loc_conf_t **named_locations ;
};
#line 181 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_core_srv_conf_t_130441436 ngx_http_core_srv_conf_t;
#line 214 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_server_name_t_740032302 {
   ngx_http_regex_t *regex ;
   ngx_http_core_srv_conf_t *server ;
   ngx_str_t name ;
};
#line 214 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_server_name_t_740032302 ngx_http_server_name_t;
#line 223 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_virtual_names_t_784591887 {
   ngx_hash_combined_t names ;
   ngx_uint_t nregex ;
   ngx_http_server_name_t *regex ;
};
#line 223 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_virtual_names_t_784591887 ngx_http_virtual_names_t;
#line 231 "src/http/ngx_http_core_module.h"
struct ngx_http_addr_conf_s {
   ngx_http_core_srv_conf_t *default_server ;
   ngx_http_virtual_names_t *virtual_names ;
   unsigned int ssl : 1 ;
   unsigned int http2 : 1 ;
   unsigned int proxy_protocol : 1 ;
};
#line 299 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_try_file_t_52872619 {
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_str_t name ;
   unsigned int code : 10 ;
   unsigned int test_dir : 1 ;
};
#line 299 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_try_file_t_52872619 ngx_http_try_file_t;
#line 309 "src/http/ngx_http_core_module.h"
struct ngx_http_core_loc_conf_s {
   ngx_str_t name ;
   ngx_http_regex_t *regex ;
   unsigned int noname : 1 ;
   unsigned int lmt_excpt : 1 ;
   unsigned int named : 1 ;
   unsigned int exact_match : 1 ;
   unsigned int noregex : 1 ;
   unsigned int auto_redirect : 1 ;
   unsigned int gzip_disable_msie6 : 2 ;
   unsigned int gzip_disable_degradation : 2 ;
   ngx_http_location_tree_node_t *static_locations ;
   ngx_http_core_loc_conf_t **regex_locations ;
   void **loc_conf ;
   uint32_t limit_except ;
   void **limit_except_loc_conf ;
   ngx_int_t (*handler)(ngx_http_request_t *r ) ;
   size_t___0 alias ;
   ngx_str_t root ;
   ngx_str_t post_action ;
   ngx_array_t *root_lengths ;
   ngx_array_t *root_values ;
   ngx_array_t *types ;
   ngx_hash_t types_hash ;
   ngx_str_t default_type ;
   off_t client_max_body_size ;
   off_t directio ;
   off_t directio_alignment ;
   size_t___0 client_body_buffer_size ;
   size_t___0 send_lowat ;
   size_t___0 postpone_output ;
   size_t___0 limit_rate ;
   size_t___0 limit_rate_after ;
   size_t___0 sendfile_max_chunk ;
   size_t___0 read_ahead ;
   ngx_msec_t client_body_timeout ;
   ngx_msec_t send_timeout ;
   ngx_msec_t keepalive_timeout ;
   ngx_msec_t lingering_time ;
   ngx_msec_t lingering_timeout ;
   ngx_msec_t resolver_timeout ;
   ngx_resolver_t *resolver ;
   time_t keepalive_header ;
   ngx_uint_t keepalive_requests ;
   ngx_uint_t keepalive_disable ;
   ngx_uint_t satisfy ;
   ngx_uint_t lingering_close ;
   ngx_uint_t if_modified_since ;
   ngx_uint_t max_ranges ;
   ngx_uint_t client_body_in_file_only ;
   ngx_flag_t client_body_in_single_buffer ;
   ngx_flag_t internal ;
   ngx_flag_t sendfile ;
   ngx_flag_t aio ;
   ngx_flag_t aio_write ;
   ngx_flag_t tcp_nopush ;
   ngx_flag_t tcp_nodelay ;
   ngx_flag_t reset_timedout_connection ;
   ngx_flag_t absolute_redirect ;
   ngx_flag_t server_name_in_redirect ;
   ngx_flag_t port_in_redirect ;
   ngx_flag_t msie_padding ;
   ngx_flag_t msie_refresh ;
   ngx_flag_t log_not_found ;
   ngx_flag_t log_subrequest ;
   ngx_flag_t recursive_error_pages ;
   ngx_uint_t server_tokens ;
   ngx_flag_t chunked_transfer_encoding ;
   ngx_flag_t etag ;
   ngx_flag_t gzip_vary ;
   ngx_uint_t gzip_http_version ;
   ngx_uint_t gzip_proxied ;
   ngx_array_t *gzip_disable ;
   ngx_uint_t disable_symlinks ;
   ngx_http_complex_value_t *disable_symlinks_from ;
   ngx_array_t *error_pages ;
   ngx_http_try_file_t *try_files ;
   ngx_path_t *client_body_temp_path ;
   ngx_open_file_cache_t *open_file_cache ;
   time_t open_file_cache_valid ;
   ngx_uint_t open_file_cache_min_uses ;
   ngx_flag_t open_file_cache_errors ;
   ngx_flag_t open_file_cache_events ;
   ngx_log_t *error_log ;
   ngx_uint_t types_hash_max_size ;
   ngx_uint_t types_hash_bucket_size ;
   ngx_queue_t *locations ;
};
#line 462 "src/http/ngx_http_core_module.h"
struct ngx_http_location_tree_node_s {
   ngx_http_location_tree_node_t *left ;
   ngx_http_location_tree_node_t *right ;
   ngx_http_location_tree_node_t *tree ;
   ngx_http_core_loc_conf_t *exact ;
   ngx_http_core_loc_conf_t *inclusive ;
   u_char auto_redirect ;
   u_char len ;
   u_char name[1] ;
};
#line 39 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_file_cache_node_t_348431269 {
   ngx_rbtree_node_t node ;
   ngx_queue_t queue ;
   u_char key[16UL - sizeof(ngx_rbtree_key_t )] ;
   unsigned int count : 20 ;
   unsigned int uses : 10 ;
   unsigned int valid_msec : 10 ;
   unsigned int error : 10 ;
   unsigned int exists : 1 ;
   unsigned int updating : 1 ;
   unsigned int deleting : 1 ;
   unsigned int purged : 1 ;
   ngx_file_uniq_t uniq ;
   time_t expire ;
   time_t valid_sec ;
   size_t___0 body_start ;
   off_t fs_size ;
   ngx_msec_t lock_time ;
};
#line 39 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_file_cache_node_t_348431269 ngx_http_file_cache_node_t;
#line 65 "src/http/ngx_http_cache.h"
struct ngx_http_cache_s {
   ngx_file_t file ;
   ngx_array_t keys ;
   uint32_t crc32 ;
   u_char key[16] ;
   u_char main[16] ;
   ngx_file_uniq_t uniq ;
   time_t valid_sec ;
   time_t updating_sec ;
   time_t error_sec ;
   time_t last_modified ;
   time_t date ;
   ngx_str_t etag ;
   ngx_str_t vary ;
   u_char variant[16] ;
   size_t___0 header_start ;
   size_t___0 body_start ;
   off_t length ;
   off_t fs_size ;
   ngx_uint_t min_uses ;
   ngx_uint_t error ;
   ngx_uint_t valid_msec ;
   ngx_uint_t vary_tag ;
   ngx_buf_t *buf ;
   ngx_http_file_cache_t *file_cache ;
   ngx_http_file_cache_node_t *node ;
   ngx_msec_t lock_timeout ;
   ngx_msec_t lock_age ;
   ngx_msec_t lock_time ;
   ngx_msec_t wait_time ;
   ngx_event_t wait_event ;
   unsigned int lock : 1 ;
   unsigned int waiting : 1 ;
   unsigned int updated : 1 ;
   unsigned int updating : 1 ;
   unsigned int exists : 1 ;
   unsigned int temp_file : 1 ;
   unsigned int purged : 1 ;
   unsigned int reading : 1 ;
   unsigned int secondary : 1 ;
   unsigned int background : 1 ;
   unsigned int stale_updating : 1 ;
   unsigned int stale_error : 1 ;
};
#line 145 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_file_cache_sh_t_652564465 {
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_queue_t queue ;
   ngx_atomic_t cold ;
   ngx_atomic_t loading ;
   off_t size ;
   ngx_uint_t count ;
   ngx_uint_t watermark ;
};
#line 145 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_file_cache_sh_t_652564465 ngx_http_file_cache_sh_t;
#line 157 "src/http/ngx_http_cache.h"
struct ngx_http_file_cache_s {
   ngx_http_file_cache_sh_t *sh ;
   ngx_slab_pool_t *shpool ;
   ngx_path_t *path ;
   off_t max_size ;
   size_t___0 bsize ;
   time_t inactive ;
   time_t fail_time ;
   ngx_uint_t files ;
   ngx_uint_t loader_files ;
   ngx_msec_t last ;
   ngx_msec_t loader_sleep ;
   ngx_msec_t loader_threshold ;
   ngx_uint_t manager_files ;
   ngx_msec_t manager_sleep ;
   ngx_msec_t manager_threshold ;
   ngx_shm_zone_t *shm_zone ;
   ngx_uint_t use_temp_path ;
};
#line 59 "src/http/ngx_http.h"
struct ngx_http_chunked_s {
   ngx_uint_t state ;
   off_t size ;
   off_t length ;
};
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in6 ;
#line 79
struct sockaddr_un ;
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 34 "src/core/ngx_inet.h"
union __anonunion_ngx_sockaddr_t_227193170 {
   struct sockaddr sockaddr ;
   struct sockaddr_in sockaddr_in ;
   struct sockaddr_in6 sockaddr_in6 ;
   struct sockaddr_un sockaddr_un ;
};
#line 34 "src/core/ngx_inet.h"
typedef union __anonunion_ngx_sockaddr_t_227193170 ngx_sockaddr_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
struct __anonstruct_ngx_http_upstream_keepalive_srv_conf_t_594354406 {
   ngx_uint_t max_cached ;
   ngx_queue_t cache ;
   ngx_queue_t free ;
   ngx_int_t (*original_init_upstream)(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
   ngx_int_t (*original_init_peer)(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
typedef struct __anonstruct_ngx_http_upstream_keepalive_srv_conf_t_594354406 ngx_http_upstream_keepalive_srv_conf_t;
#line 25 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
struct __anonstruct_ngx_http_upstream_keepalive_cache_t_570962639 {
   ngx_http_upstream_keepalive_srv_conf_t *conf ;
   ngx_queue_t queue ;
   ngx_connection_t *connection ;
   socklen_t socklen ;
   ngx_sockaddr_t sockaddr ;
};
#line 25 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
typedef struct __anonstruct_ngx_http_upstream_keepalive_cache_t_570962639 ngx_http_upstream_keepalive_cache_t;
#line 37 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
struct __anonstruct_ngx_http_upstream_keepalive_peer_data_t_972597598 {
   ngx_http_upstream_keepalive_srv_conf_t *conf ;
   ngx_http_upstream_t *upstream ;
   void *data ;
   ngx_int_t (*original_get_peer)(ngx_peer_connection_t *pc , void *data ) ;
   void (*original_free_peer)(ngx_peer_connection_t *pc , void *data , ngx_uint_t state ) ;
};
#line 37 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
typedef struct __anonstruct_ngx_http_upstream_keepalive_peer_data_t_972597598 ngx_http_upstream_keepalive_peer_data_t;
#line 16 "src/core/ngx_times.h"
struct __anonstruct_ngx_time_t_1024184318 {
   time_t sec ;
   ngx_uint_t msec ;
   ngx_int_t gmtoff ;
};
#line 16 "src/core/ngx_times.h"
typedef struct __anonstruct_ngx_time_t_1024184318 ngx_time_t;
#line 127 "src/http/ngx_http_upstream_round_robin.h"
struct __anonstruct_ngx_http_upstream_rr_peer_data_t_807182193 {
   ngx_uint_t config ;
   ngx_http_upstream_rr_peers_t *peers ;
   ngx_http_upstream_rr_peer_t *current ;
   uintptr_t *tried ;
   uintptr_t data ;
};
#line 127 "src/http/ngx_http_upstream_round_robin.h"
typedef struct __anonstruct_ngx_http_upstream_rr_peer_data_t_807182193 ngx_http_upstream_rr_peer_data_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
struct __anonstruct_ngx_http_upstream_ip_hash_peer_data_t_1055986603 {
   ngx_http_upstream_rr_peer_data_t rrp ;
   ngx_uint_t hash ;
   u_char addrlen ;
   u_char *addr ;
   u_char tries ;
   ngx_int_t (*get_rr_peer)(ngx_peer_connection_t *pc , void *data ) ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_ip_hash_peer_data_t_1055986603 ngx_http_upstream_ip_hash_peer_data_t;
#line 74 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_compile_complex_value_t_321102929 {
   ngx_conf_t *cf ;
   ngx_str_t *value ;
   ngx_http_complex_value_t *complex_value ;
   unsigned int zero : 1 ;
   unsigned int conf_prefix : 1 ;
   unsigned int root_prefix : 1 ;
};
#line 74 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_compile_complex_value_t_321102929 ngx_http_compile_complex_value_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_chash_point_t_177938903 {
   uint32_t hash ;
   ngx_str_t *server ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_chash_point_t_177938903 ngx_http_upstream_chash_point_t;
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_chash_points_t_380952773 {
   ngx_uint_t number ;
   ngx_http_upstream_chash_point_t point[1] ;
};
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_chash_points_t_380952773 ngx_http_upstream_chash_points_t;
#line 25 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_hash_srv_conf_t_996850520 {
   ngx_http_complex_value_t key ;
   ngx_http_upstream_chash_points_t *points ;
};
#line 25 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_hash_srv_conf_t_996850520 ngx_http_upstream_hash_srv_conf_t;
#line 31 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_hash_peer_data_t_480527305 {
   ngx_http_upstream_rr_peer_data_t rrp ;
   ngx_http_upstream_hash_srv_conf_t *conf ;
   ngx_str_t key ;
   ngx_uint_t tries ;
   ngx_uint_t rehash ;
   uint32_t hash ;
   ngx_int_t (*get_rr_peer)(ngx_peer_connection_t *pc , void *data ) ;
};
#line 31 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_hash_peer_data_t_480527305 ngx_http_upstream_hash_peer_data_t;
#line 291 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
union __anonunion_prev_hash_923928396 {
   uint32_t value ;
   u_char byte[4] ;
};
#line 21 "src/http/ngx_http_variables.h"
struct ngx_http_variable_s ;
#line 21 "src/http/ngx_http_variables.h"
typedef struct ngx_http_variable_s ngx_http_variable_t;
#line 37 "src/http/ngx_http_variables.h"
struct ngx_http_variable_s {
   ngx_str_t name ;
   void (*set_handler)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ) ;
   ngx_int_t (*get_handler)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                            uintptr_t data ) ;
   uintptr_t data ;
   ngx_uint_t flags ;
   ngx_uint_t index ;
};
#line 24 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
struct __anonstruct_ngx_http_modern_browser_mask_t_248359410 {
   u_char browser[12] ;
   size_t___0 skip ;
   size_t___0 add ;
   u_char name[12] ;
};
#line 24 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
typedef struct __anonstruct_ngx_http_modern_browser_mask_t_248359410 ngx_http_modern_browser_mask_t;
#line 32 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
struct __anonstruct_ngx_http_modern_browser_t_396915611 {
   ngx_uint_t version ;
   size_t___0 skip ;
   size_t___0 add ;
   u_char name[12] ;
};
#line 32 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
typedef struct __anonstruct_ngx_http_modern_browser_t_396915611 ngx_http_modern_browser_t;
#line 40 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
struct __anonstruct_ngx_http_browser_variable_t_498815663 {
   ngx_str_t name ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ) ;
   uintptr_t data ;
};
#line 40 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
typedef struct __anonstruct_ngx_http_browser_variable_t_498815663 ngx_http_browser_variable_t;
#line 47 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
struct __anonstruct_ngx_http_browser_conf_t_424224669 {
   ngx_array_t *modern_browsers ;
   ngx_array_t *ancient_browsers ;
   ngx_http_variable_value_t *modern_browser_value ;
   ngx_http_variable_value_t *ancient_browser_value ;
   unsigned int modern_unlisted_browsers : 1 ;
   unsigned int netscape4 : 1 ;
};
#line 47 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
typedef struct __anonstruct_ngx_http_browser_conf_t_424224669 ngx_http_browser_conf_t;
#line 80 "src/core/ngx_inet.h"
struct __anonstruct_ngx_url_t_632175798 {
   ngx_str_t url ;
   ngx_str_t host ;
   ngx_str_t port_text ;
   ngx_str_t uri ;
   in_port_t port ;
   in_port_t default_port ;
   int family ;
   unsigned int listen : 1 ;
   unsigned int uri_part : 1 ;
   unsigned int no_resolve : 1 ;
   unsigned int no_port : 1 ;
   unsigned int wildcard : 1 ;
   socklen_t socklen ;
   ngx_sockaddr_t sockaddr ;
   ngx_addr_t *addrs ;
   ngx_uint_t naddrs ;
   char *err ;
};
#line 80 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_url_t_632175798 ngx_url_t;
#line 165 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_bitmask_t_584295444 {
   ngx_str_t name ;
   ngx_uint_t mask ;
};
#line 165 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_bitmask_t_584295444 ngx_conf_bitmask_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
struct __anonstruct_ngx_http_memcached_loc_conf_t_615053319 {
   ngx_http_upstream_conf_t upstream ;
   ngx_int_t index ;
   ngx_uint_t gzip_flag ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
typedef struct __anonstruct_ngx_http_memcached_loc_conf_t_615053319 ngx_http_memcached_loc_conf_t;
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
struct __anonstruct_ngx_http_memcached_ctx_t_444934823 {
   size_t___0 rest ;
   ngx_http_request_t *request ;
   ngx_str_t key ;
};
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
typedef struct __anonstruct_ngx_http_memcached_ctx_t_444934823 ngx_http_memcached_ctx_t;
#line 22 "src/core/ngx_string.h"
struct __anonstruct_ngx_keyval_t_694638417 {
   ngx_str_t key ;
   ngx_str_t value ;
};
#line 22 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_keyval_t_694638417 ngx_keyval_t;
#line 35 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_key_t_70286332 {
   ngx_str_t key ;
   ngx_uint_t key_hash ;
   void *value ;
};
#line 35 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_key_t_70286332 ngx_hash_key_t;
#line 52 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_init_t_533024749 {
   ngx_hash_t *hash ;
   ngx_uint_t (*key)(u_char *data , size_t___0 len ) ;
   ngx_uint_t max_size ;
   ngx_uint_t bucket_size ;
   char *name ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
};
#line 52 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_init_t_533024749 ngx_hash_init_t;
#line 65 "src/core/ngx_file.h"
struct __anonstruct_ngx_path_init_t_68096344 {
   ngx_str_t name ;
   size_t___0 level[3] ;
};
#line 65 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_path_init_t_68096344 ngx_path_init_t;
#line 17 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_engine_t_417757341 {
   u_char *ip ;
   u_char *pos ;
   ngx_http_variable_value_t *sp ;
   ngx_str_t buf ;
   ngx_str_t line ;
   u_char *args ;
   unsigned int flushed : 1 ;
   unsigned int skip : 1 ;
   unsigned int quote : 1 ;
   unsigned int is_args : 1 ;
   unsigned int log : 1 ;
   ngx_int_t status ;
   ngx_http_request_t *request ;
};
#line 17 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_engine_t_417757341 ngx_http_script_engine_t;
#line 39 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_compile_t_940111379 {
   ngx_conf_t *cf ;
   ngx_str_t *source ;
   ngx_array_t **flushes ;
   ngx_array_t **lengths ;
   ngx_array_t **values ;
   ngx_uint_t variables ;
   ngx_uint_t ncaptures ;
   ngx_uint_t captures_mask ;
   ngx_uint_t size ;
   void *main ;
   unsigned int compile_args : 1 ;
   unsigned int complete_lengths : 1 ;
   unsigned int complete_values : 1 ;
   unsigned int zero : 1 ;
   unsigned int conf_prefix : 1 ;
   unsigned int root_prefix : 1 ;
   unsigned int dup_capture : 1 ;
   unsigned int args : 1 ;
};
#line 39 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_compile_t_940111379 ngx_http_script_compile_t;
#line 85 "src/http/ngx_http_script.h"
typedef void (*ngx_http_script_code_pt)(ngx_http_script_engine_t *e );
#line 86 "src/http/ngx_http_script.h"
typedef size_t___0 (*ngx_http_script_len_code_pt)(ngx_http_script_engine_t *e );
#line 89 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_copy_code_t_609967266 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t len ;
};
#line 89 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_copy_code_t_609967266 ngx_http_script_copy_code_t;
#line 241 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_header_t_821276377 {
   ngx_str_t name ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_table_elt_t *h , ngx_uint_t offset ) ;
   ngx_uint_t offset ;
   ngx_int_t (*copy_handler)(ngx_http_request_t *r , ngx_table_elt_t *h , ngx_uint_t offset ) ;
   ngx_uint_t conf ;
   ngx_uint_t redirect ;
};
#line 241 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_header_t_821276377 ngx_http_upstream_header_t;
#line 401 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_param_t_1029621126 {
   ngx_str_t key ;
   ngx_str_t value ;
   ngx_uint_t skip_empty ;
};
#line 401 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_param_t_1029621126 ngx_http_upstream_param_t;
#line 66 "src/http/ngx_http.h"
struct __anonstruct_ngx_http_status_t_966881929 {
   ngx_uint_t http_version ;
   ngx_uint_t code ;
   ngx_uint_t count ;
   u_char *start ;
   u_char *end ;
};
#line 66 "src/http/ngx_http.h"
typedef struct __anonstruct_ngx_http_status_t_966881929 ngx_http_status_t;
#line 14 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
struct __anonstruct_ngx_http_scgi_main_conf_t_1073212358 {
   ngx_array_t caches ;
};
#line 14 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
typedef struct __anonstruct_ngx_http_scgi_main_conf_t_1073212358 ngx_http_scgi_main_conf_t;
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
struct __anonstruct_ngx_http_scgi_params_t_536392549 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_uint_t number ;
   ngx_hash_t hash ;
};
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
typedef struct __anonstruct_ngx_http_scgi_params_t_536392549 ngx_http_scgi_params_t;
#line 28 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
struct __anonstruct_ngx_http_scgi_loc_conf_t_814143571 {
   ngx_http_upstream_conf_t upstream ;
   ngx_http_scgi_params_t params ;
   ngx_http_scgi_params_t params_cache ;
   ngx_array_t *params_source ;
   ngx_array_t *scgi_lengths ;
   ngx_array_t *scgi_values ;
   ngx_http_complex_value_t cache_key ;
};
#line 28 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
typedef struct __anonstruct_ngx_http_scgi_loc_conf_t_814143571 ngx_http_scgi_loc_conf_t;
#line 150 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_num_bounds_t_551271724 {
   char *(*post_handler)(ngx_conf_t *cf , void *data , void *conf ) ;
   ngx_int_t low ;
   ngx_int_t high ;
};
#line 150 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_num_bounds_t_551271724 ngx_conf_num_bounds_t;
#line 15 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
struct __anonstruct_ngx_http_uwsgi_main_conf_t_1073212358 {
   ngx_array_t caches ;
};
#line 15 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
typedef struct __anonstruct_ngx_http_uwsgi_main_conf_t_1073212358 ngx_http_uwsgi_main_conf_t;
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
struct __anonstruct_ngx_http_uwsgi_params_t_536392549 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_uint_t number ;
   ngx_hash_t hash ;
};
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
typedef struct __anonstruct_ngx_http_uwsgi_params_t_536392549 ngx_http_uwsgi_params_t;
#line 29 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
struct __anonstruct_ngx_http_uwsgi_loc_conf_t_380978601 {
   ngx_http_upstream_conf_t upstream ;
   ngx_http_uwsgi_params_t params ;
   ngx_http_uwsgi_params_t params_cache ;
   ngx_array_t *params_source ;
   ngx_array_t *uwsgi_lengths ;
   ngx_array_t *uwsgi_values ;
   ngx_http_complex_value_t cache_key ;
   ngx_str_t uwsgi_string ;
   ngx_uint_t modifier1 ;
   ngx_uint_t modifier2 ;
};
#line 29 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
typedef struct __anonstruct_ngx_http_uwsgi_loc_conf_t_380978601 ngx_http_uwsgi_loc_conf_t;
#line 29 "src/core/ngx_regex.h"
struct __anonstruct_ngx_regex_compile_t_482431367 {
   ngx_str_t pattern ;
   ngx_pool_t *pool ;
   ngx_int_t options ;
   ngx_regex_t *regex ;
   int captures ;
   int named_captures ;
   int name_size ;
   u_char *names ;
   ngx_str_t err ;
};
#line 29 "src/core/ngx_regex.h"
typedef struct __anonstruct_ngx_regex_compile_t_482431367 ngx_regex_compile_t;
#line 138 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_post_t_18280801 {
   char *(*post_handler)(ngx_conf_t *cf , void *data , void *conf ) ;
};
#line 138 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_post_t_18280801 ngx_conf_post_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_main_conf_t_1073212358 {
   ngx_array_t caches ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_main_conf_t_1073212358 ngx_http_fastcgi_main_conf_t;
#line 18 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_params_t_536392549 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_uint_t number ;
   ngx_hash_t hash ;
};
#line 18 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_params_t_536392549 ngx_http_fastcgi_params_t;
#line 27 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_loc_conf_t_936255276 {
   ngx_http_upstream_conf_t upstream ;
   ngx_str_t index ;
   ngx_http_fastcgi_params_t params ;
   ngx_http_fastcgi_params_t params_cache ;
   ngx_array_t *params_source ;
   ngx_array_t *catch_stderr ;
   ngx_array_t *fastcgi_lengths ;
   ngx_array_t *fastcgi_values ;
   ngx_flag_t keep_conn ;
   ngx_http_complex_value_t cache_key ;
   ngx_regex_t *split_regex ;
   ngx_str_t split_name ;
};
#line 27 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_loc_conf_t_936255276 ngx_http_fastcgi_loc_conf_t;
#line 56
enum __anonenum_ngx_http_fastcgi_state_e_10842969 {
    ngx_http_fastcgi_st_version = 0,
    ngx_http_fastcgi_st_type = 1,
    ngx_http_fastcgi_st_request_id_hi = 2,
    ngx_http_fastcgi_st_request_id_lo = 3,
    ngx_http_fastcgi_st_content_length_hi = 4,
    ngx_http_fastcgi_st_content_length_lo = 5,
    ngx_http_fastcgi_st_padding_length = 6,
    ngx_http_fastcgi_st_reserved = 7,
    ngx_http_fastcgi_st_data = 8,
    ngx_http_fastcgi_st_padding = 9
} ;
#line 56 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef enum __anonenum_ngx_http_fastcgi_state_e_10842969 ngx_http_fastcgi_state_e;
#line 70 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_split_part_t_101917599 {
   u_char *start ;
   u_char *end ;
};
#line 70 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_split_part_t_101917599 ngx_http_fastcgi_split_part_t;
#line 76 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_ctx_t_742909384 {
   ngx_http_fastcgi_state_e state ;
   u_char *pos ;
   u_char *last ;
   ngx_uint_t type ;
   size_t___0 length ;
   size_t___0 padding ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   unsigned int fastcgi_stdout : 1 ;
   unsigned int large_stderr : 1 ;
   unsigned int header_sent : 1 ;
   ngx_array_t *split_parts ;
   ngx_str_t script_name ;
   ngx_str_t path_info ;
};
#line 76 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_ctx_t_742909384 ngx_http_fastcgi_ctx_t;
#line 112 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_header_t_858055202 {
   u_char version ;
   u_char type ;
   u_char request_id_hi ;
   u_char request_id_lo ;
   u_char content_length_hi ;
   u_char content_length_lo ;
   u_char padding_length ;
   u_char reserved ;
};
#line 112 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_header_t_858055202 ngx_http_fastcgi_header_t;
#line 124 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_begin_request_t_1020671504 {
   u_char role_hi ;
   u_char role_lo ;
   u_char flags ;
   u_char reserved[5] ;
};
#line 124 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_begin_request_t_1020671504 ngx_http_fastcgi_begin_request_t;
#line 132 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_header_small_t_1020671505 {
   u_char version ;
   u_char type ;
   u_char request_id_hi ;
   u_char request_id_lo ;
};
#line 132 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_header_small_t_1020671505 ngx_http_fastcgi_header_small_t;
#line 140 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_request_start_t_882069487 {
   ngx_http_fastcgi_header_t h0 ;
   ngx_http_fastcgi_begin_request_t br ;
   ngx_http_fastcgi_header_small_t h1 ;
};
#line 140 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_request_start_t_882069487 ngx_http_fastcgi_request_start_t;
#line 157 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_enum_t_584295443 {
   ngx_str_t name ;
   ngx_uint_t value ;
};
#line 157 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_enum_t_584295443 ngx_conf_enum_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_main_conf_t_1073212358 {
   ngx_array_t caches ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_main_conf_t_1073212358 ngx_http_proxy_main_conf_t;
#line 18
struct ngx_http_proxy_rewrite_s ;
#line 18 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
typedef struct ngx_http_proxy_rewrite_s ngx_http_proxy_rewrite_t;
#line 24 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
union __anonunion_pattern_462752986 {
   ngx_http_complex_value_t complex ;
   ngx_http_regex_t *regex ;
};
#line 24 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
struct ngx_http_proxy_rewrite_s {
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_table_elt_t *h , size_t___0 prefix ,
                        size_t___0 len , ngx_http_proxy_rewrite_t *pr ) ;
   union __anonunion_pattern_462752986 pattern ;
   ngx_http_complex_value_t replacement ;
};
#line 38 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_vars_t_333241226 {
   ngx_str_t key_start ;
   ngx_str_t schema ;
   ngx_str_t host_header ;
   ngx_str_t port ;
   ngx_str_t uri ;
};
#line 38 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_vars_t_333241226 ngx_http_proxy_vars_t;
#line 47 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_headers_t_867081419 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_hash_t hash ;
};
#line 47 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_headers_t_867081419 ngx_http_proxy_headers_t;
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_loc_conf_t_510597942 {
   ngx_http_upstream_conf_t upstream ;
   ngx_array_t *body_flushes ;
   ngx_array_t *body_lengths ;
   ngx_array_t *body_values ;
   ngx_str_t body_source ;
   ngx_http_proxy_headers_t headers ;
   ngx_http_proxy_headers_t headers_cache ;
   ngx_array_t *headers_source ;
   ngx_array_t *proxy_lengths ;
   ngx_array_t *proxy_values ;
   ngx_array_t *redirects ;
   ngx_array_t *cookie_domains ;
   ngx_array_t *cookie_paths ;
   ngx_http_complex_value_t *method ;
   ngx_str_t location ;
   ngx_str_t url ;
   ngx_http_complex_value_t cache_key ;
   ngx_http_proxy_vars_t vars ;
   ngx_flag_t redirect ;
   ngx_uint_t http_version ;
   ngx_uint_t headers_hash_max_size ;
   ngx_uint_t headers_hash_bucket_size ;
};
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_loc_conf_t_510597942 ngx_http_proxy_loc_conf_t;
#line 107 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_ctx_t_1064436058 {
   ngx_http_status_t status ;
   ngx_http_chunked_t chunked ;
   ngx_http_proxy_vars_t vars ;
   off_t internal_body_length ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   unsigned int head : 1 ;
   unsigned int internal_chunked : 1 ;
   unsigned int header_sent : 1 ;
};
#line 107 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_ctx_t_1064436058 ngx_http_proxy_ctx_t;
#line 75 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_keys_arrays_t_675679399 {
   ngx_uint_t hsize ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
   ngx_array_t keys ;
   ngx_array_t *keys_hash ;
   ngx_array_t dns_wc_head ;
   ngx_array_t *dns_wc_head_hash ;
   ngx_array_t dns_wc_tail ;
   ngx_array_t *dns_wc_tail_hash ;
};
#line 75 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_keys_arrays_t_675679399 ngx_hash_keys_arrays_t;
#line 365 "src/http/ngx_http_request.h"
typedef ngx_int_t (*ngx_http_handler_pt)(ngx_http_request_t *r );
#line 95 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_var_code_t_609967267 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t index ;
};
#line 95 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_var_code_t_609967267 ngx_http_script_var_code_t;
#line 101 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_var_handler_code_t_379692993 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   void (*handler)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ) ;
   uintptr_t data ;
};
#line 101 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_var_handler_code_t_379692993 ngx_http_script_var_handler_code_t;
#line 116 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_regex_code_t_376150190 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   ngx_http_regex_t *regex ;
   ngx_array_t *lengths ;
   uintptr_t size ;
   uintptr_t status ;
   uintptr_t next ;
   unsigned int test : 1 ;
   unsigned int negative_test : 1 ;
   unsigned int uri : 1 ;
   unsigned int args : 1 ;
   unsigned int add_args : 1 ;
   unsigned int redirect : 1 ;
   unsigned int break_cycle : 1 ;
   ngx_str_t name ;
};
#line 116 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_regex_code_t_376150190 ngx_http_script_regex_code_t;
#line 139 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_regex_end_code_t_831059364 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   unsigned int uri : 1 ;
   unsigned int args : 1 ;
   unsigned int add_args : 1 ;
   unsigned int redirect : 1 ;
};
#line 139 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_regex_end_code_t_831059364 ngx_http_script_regex_end_code_t;
#line 160 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_return_code_t_978385028 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t status ;
   ngx_http_complex_value_t text ;
};
#line 160 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_return_code_t_978385028 ngx_http_script_return_code_t;
#line 179 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_file_code_t_1064107609 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t op ;
};
#line 179 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_file_code_t_1064107609 ngx_http_script_file_code_t;
#line 185 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_if_code_t_881232241 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t next ;
   void **loc_conf ;
};
#line 185 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_if_code_t_881232241 ngx_http_script_if_code_t;
#line 192 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_complex_value_code_t_911888742 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   ngx_array_t *lengths ;
};
#line 192 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_complex_value_code_t_911888742 ngx_http_script_complex_value_code_t;
#line 198 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_value_code_t_46162250 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t value ;
   uintptr_t text_len ;
   uintptr_t text_data ;
};
#line 198 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_value_code_t_46162250 ngx_http_script_value_code_t;
#line 128 "src/http/ngx_http_core_module.h"
struct ngx_http_phase_handler_s ;
#line 128 "src/http/ngx_http_core_module.h"
typedef struct ngx_http_phase_handler_s ngx_http_phase_handler_t;
#line 133 "src/http/ngx_http_core_module.h"
struct ngx_http_phase_handler_s {
   ngx_int_t (*checker)(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
   ngx_int_t (*handler)(ngx_http_request_t *r ) ;
   ngx_uint_t next ;
};
#line 140 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_phase_engine_t_211833854 {
   ngx_http_phase_handler_t *handlers ;
   ngx_uint_t server_rewrite_index ;
   ngx_uint_t location_rewrite_index ;
};
#line 140 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_phase_engine_t_211833854 ngx_http_phase_engine_t;
#line 147 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_phase_t_168482411 {
   ngx_array_t handlers ;
};
#line 147 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_phase_t_168482411 ngx_http_phase_t;
#line 152 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_core_main_conf_t_316410545 {
   ngx_array_t servers ;
   ngx_http_phase_engine_t phase_engine ;
   ngx_hash_t headers_in_hash ;
   ngx_hash_t variables_hash ;
   ngx_array_t variables ;
   ngx_array_t prefix_variables ;
   ngx_uint_t ncaptures ;
   ngx_uint_t server_names_hash_max_size ;
   ngx_uint_t server_names_hash_bucket_size ;
   ngx_uint_t variables_hash_max_size ;
   ngx_uint_t variables_hash_bucket_size ;
   ngx_hash_keys_arrays_t *variables_keys ;
   ngx_array_t *ports ;
   ngx_uint_t try_files ;
   ngx_http_phase_t phases[11] ;
};
#line 152 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_core_main_conf_t_316410545 ngx_http_core_main_conf_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
struct __anonstruct_ngx_http_rewrite_loc_conf_t_848989882 {
   ngx_array_t *codes ;
   ngx_uint_t stack_size ;
   ngx_flag_t log ;
   ngx_flag_t uninitialized_variable_warn ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
typedef struct __anonstruct_ngx_http_rewrite_loc_conf_t_848989882 ngx_http_rewrite_loc_conf_t;
#line 43 "src/core/ngx_regex.h"
struct __anonstruct_ngx_regex_elt_t_763262579 {
   ngx_regex_t *regex ;
   u_char *name ;
};
#line 43 "src/core/ngx_regex.h"
typedef struct __anonstruct_ngx_regex_elt_t_763262579 ngx_regex_elt_t;
#line 16 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
struct __anonstruct_ngx_http_referer_conf_t_468208144 {
   ngx_hash_combined_t hash ;
   ngx_array_t *regex ;
   ngx_array_t *server_name_regex ;
   ngx_flag_t no_referer ;
   ngx_flag_t blocked_referer ;
   ngx_flag_t server_names ;
   ngx_hash_keys_arrays_t *keys ;
   ngx_uint_t referer_hash_max_size ;
   ngx_uint_t referer_hash_bucket_size ;
};
#line 16 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
typedef struct __anonstruct_ngx_http_referer_conf_t_468208144 ngx_http_referer_conf_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
struct __anonstruct_ngx_http_split_clients_part_t_221822067 {
   uint32_t percent ;
   ngx_http_variable_value_t value ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
typedef struct __anonstruct_ngx_http_split_clients_part_t_221822067 ngx_http_split_clients_part_t;
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
struct __anonstruct_ngx_http_split_clients_ctx_t_105103443 {
   ngx_http_complex_value_t value ;
   ngx_array_t parts ;
};
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
typedef struct __anonstruct_ngx_http_split_clients_ctx_t_105103443 ngx_http_split_clients_ctx_t;
#line 79 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_map_regex_t_940469046 {
   ngx_http_regex_t *regex ;
   void *value ;
};
#line 79 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_map_regex_t_940469046 ngx_http_map_regex_t;
#line 93 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_map_t_391897702 {
   ngx_hash_combined_t hash ;
   ngx_http_map_regex_t *regex ;
   ngx_uint_t nregex ;
};
#line 93 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_map_t_391897702 ngx_http_map_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
struct __anonstruct_ngx_http_map_conf_t_1073212358 {
   ngx_uint_t hash_max_size ;
   ngx_uint_t hash_bucket_size ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
typedef struct __anonstruct_ngx_http_map_conf_t_1073212358 ngx_http_map_conf_t;
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
struct __anonstruct_ngx_http_map_conf_ctx_t_206330790 {
   ngx_hash_keys_arrays_t keys ;
   ngx_array_t *values_hash ;
   ngx_array_t regexes ;
   ngx_http_variable_value_t *default_value ;
   ngx_conf_t *cf ;
   unsigned int hostnames : 1 ;
   unsigned int no_cacheable : 1 ;
};
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
typedef struct __anonstruct_ngx_http_map_conf_ctx_t_206330790 ngx_http_map_conf_ctx_t;
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
struct __anonstruct_ngx_http_map_ctx_t_891507046 {
   ngx_http_map_t map ;
   ngx_http_complex_value_t value ;
   ngx_http_variable_value_t *default_value ;
   ngx_uint_t hostnames ;
};
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
typedef struct __anonstruct_ngx_http_map_ctx_t_891507046 ngx_http_map_ctx_t;
#line 213 "src/core/ngx_string.h"
struct __anonstruct_ngx_str_node_t_1069181676 {
   ngx_rbtree_node_t node ;
   ngx_str_t str ;
};
#line 213 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_str_node_t_1069181676 ngx_str_node_t;
#line 21 "src/os/unix/ngx_files.h"
struct __anonstruct_ngx_file_mapping_t_303926449 {
   u_char *name ;
   size_t___0 size ;
   void *addr ;
   ngx_fd_t fd ;
   ngx_log_t *log ;
};
#line 21 "src/os/unix/ngx_files.h"
typedef struct __anonstruct_ngx_file_mapping_t_303926449 ngx_file_mapping_t;
#line 18 "src/core/ngx_radix_tree.h"
struct ngx_radix_node_s ;
#line 18 "src/core/ngx_radix_tree.h"
typedef struct ngx_radix_node_s ngx_radix_node_t;
#line 20 "src/core/ngx_radix_tree.h"
struct ngx_radix_node_s {
   ngx_radix_node_t *right ;
   ngx_radix_node_t *left ;
   ngx_radix_node_t *parent ;
   uintptr_t value ;
};
#line 28 "src/core/ngx_radix_tree.h"
struct __anonstruct_ngx_radix_tree_t_127338236 {
   ngx_radix_node_t *root ;
   ngx_pool_t *pool ;
   ngx_radix_node_t *free ;
   char *start ;
   size_t___0 size ;
};
#line 28 "src/core/ngx_radix_tree.h"
typedef struct __anonstruct_ngx_radix_tree_t_127338236 ngx_radix_tree_t;
#line 46 "src/core/ngx_inet.h"
struct __anonstruct_ngx_in_cidr_t_55576696 {
   in_addr_t addr ;
   in_addr_t mask ;
};
#line 46 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_in_cidr_t_55576696 ngx_in_cidr_t;
#line 54 "src/core/ngx_inet.h"
struct __anonstruct_ngx_in6_cidr_t_1064289942 {
   struct in6_addr addr ;
   struct in6_addr mask ;
};
#line 54 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_in6_cidr_t_1064289942 ngx_in6_cidr_t;
#line 62 "src/core/ngx_inet.h"
union __anonunion_u_1007262957 {
   ngx_in_cidr_t in ;
   ngx_in6_cidr_t in6 ;
};
#line 62 "src/core/ngx_inet.h"
struct __anonstruct_ngx_cidr_t_617599043 {
   ngx_uint_t family ;
   union __anonunion_u_1007262957 u ;
};
#line 62 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_cidr_t_617599043 ngx_cidr_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_range_t_1049490180 {
   ngx_http_variable_value_t *value ;
   u_short start ;
   u_short end ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_range_t_1049490180 ngx_http_geo_range_t;
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_trees_t_95385268 {
   ngx_radix_tree_t *tree ;
   ngx_radix_tree_t *tree6 ;
};
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_trees_t_95385268 ngx_http_geo_trees_t;
#line 28 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_high_ranges_t_93225350 {
   ngx_http_geo_range_t **low ;
   ngx_http_variable_value_t *default_value ;
};
#line 28 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_high_ranges_t_93225350 ngx_http_geo_high_ranges_t;
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_variable_value_node_t_785163022 {
   ngx_str_node_t sn ;
   ngx_http_variable_value_t *value ;
   size_t___0 offset ;
};
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_variable_value_node_t_785163022 ngx_http_geo_variable_value_node_t;
#line 41 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_conf_ctx_t_816371636 {
   ngx_http_variable_value_t *value ;
   ngx_str_t *net ;
   ngx_http_geo_high_ranges_t high ;
   ngx_radix_tree_t *tree ;
   ngx_radix_tree_t *tree6 ;
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_array_t *proxies ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
   size_t___0 data_size ;
   ngx_str_t include_name ;
   ngx_uint_t includes ;
   ngx_uint_t entries ;
   unsigned int ranges : 1 ;
   unsigned int outside_entries : 1 ;
   unsigned int allow_binary_include : 1 ;
   unsigned int binary_include : 1 ;
   unsigned int proxy_recursive : 1 ;
};
#line 41 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_conf_ctx_t_816371636 ngx_http_geo_conf_ctx_t;
#line 69 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
union __anonunion_u_802116933 {
   ngx_http_geo_trees_t trees ;
   ngx_http_geo_high_ranges_t high ;
};
#line 69 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_ctx_t_742184210 {
   union __anonunion_u_802116933 u ;
   ngx_array_t *proxies ;
   unsigned int proxy_recursive : 1 ;
   ngx_int_t index ;
};
#line 69 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_ctx_t_742184210 ngx_http_geo_ctx_t;
#line 157 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_header_t_1060077174 {
   u_char GEORNG[6] ;
   u_char version ;
   u_char ptr_size ;
   uint32_t endianness ;
   uint32_t crc32 ;
};
#line 157 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_header_t_1060077174 ngx_http_geo_header_t;
#line 17 "src/core/ngx_rbtree.h"
typedef ngx_int_t ngx_rbtree_key_int_t;
#line 17 "src/os/unix/ngx_time.h"
typedef ngx_rbtree_key_int_t ngx_msec_int_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_node_t_754772556 {
   u_char color ;
   u_char dummy ;
   u_short len ;
   ngx_queue_t queue ;
   ngx_msec_t last ;
   ngx_uint_t excess ;
   ngx_uint_t count ;
   u_char data[1] ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_node_t_754772556 ngx_http_limit_req_node_t;
#line 26 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_shctx_t_637006230 {
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_queue_t queue ;
};
#line 26 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_shctx_t_637006230 ngx_http_limit_req_shctx_t;
#line 33 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_ctx_t_280562251 {
   ngx_http_limit_req_shctx_t *sh ;
   ngx_slab_pool_t *shpool ;
   ngx_uint_t rate ;
   ngx_http_complex_value_t key ;
   ngx_http_limit_req_node_t *node ;
};
#line 33 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_ctx_t_280562251 ngx_http_limit_req_ctx_t;
#line 43 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_limit_t_720718294 {
   ngx_shm_zone_t *shm_zone ;
   ngx_uint_t burst ;
   ngx_uint_t nodelay ;
};
#line 43 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_limit_t_720718294 ngx_http_limit_req_limit_t;
#line 51 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_conf_t_613942701 {
   ngx_array_t limits ;
   ngx_uint_t limit_log_level ;
   ngx_uint_t delay_log_level ;
   ngx_uint_t status_code ;
};
#line 51 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_conf_t_613942701 ngx_http_limit_req_conf_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_node_t_667403500 {
   u_char color ;
   u_char len ;
   u_short conn ;
   u_char data[1] ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_node_t_667403500 ngx_http_limit_conn_node_t;
#line 21 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_cleanup_t_664388213 {
   ngx_shm_zone_t *shm_zone ;
   ngx_rbtree_node_t *node ;
};
#line 21 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_cleanup_t_664388213 ngx_http_limit_conn_cleanup_t;
#line 27 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_ctx_t_786637687 {
   ngx_rbtree_t *rbtree ;
   ngx_http_complex_value_t key ;
};
#line 27 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_ctx_t_786637687 ngx_http_limit_conn_ctx_t;
#line 33 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_limit_t_514729299 {
   ngx_shm_zone_t *shm_zone ;
   ngx_uint_t conn ;
};
#line 33 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_limit_t_514729299 ngx_http_limit_conn_limit_t;
#line 39 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_conf_t_184183304 {
   ngx_array_t limits ;
   ngx_uint_t log_level ;
   ngx_uint_t status_code ;
};
#line 39 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_conf_t_184183304 ngx_http_limit_conn_conf_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_rule_t_693947891 {
   in_addr_t mask ;
   in_addr_t addr ;
   ngx_uint_t deny ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_rule_t_693947891 ngx_http_access_rule_t;
#line 21 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_rule6_t_369292760 {
   struct in6_addr addr ;
   struct in6_addr mask ;
   ngx_uint_t deny ;
};
#line 21 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_rule6_t_369292760 ngx_http_access_rule6_t;
#line 31 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_rule_un_t_44223403 {
   ngx_uint_t deny ;
};
#line 31 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_rule_un_t_44223403 ngx_http_access_rule_un_t;
#line 37 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_loc_conf_t_857105290 {
   ngx_array_t *rules ;
   ngx_array_t *rules6 ;
   ngx_array_t *rules_un ;
};
#line 37 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_loc_conf_t_857105290 ngx_http_access_loc_conf_t;
#line 17 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
struct __anonstruct_ngx_http_auth_basic_ctx_t_871081928 {
   ngx_str_t passwd ;
};
#line 17 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
typedef struct __anonstruct_ngx_http_auth_basic_ctx_t_871081928 ngx_http_auth_basic_ctx_t;
#line 22 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
struct __anonstruct_ngx_http_auth_basic_loc_conf_t_587006047 {
   ngx_http_complex_value_t *realm ;
   ngx_http_complex_value_t user_file ;
};
#line 22 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
typedef struct __anonstruct_ngx_http_auth_basic_loc_conf_t_587006047 ngx_http_auth_basic_loc_conf_t;
#line 109
enum __anonenum_state_88255402 {
    sw_login = 0,
    sw_passwd = 1,
    sw_skip = 2
} ;
#line 19 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_info_t_765995005 {
   ngx_fd_t fd ;
   ngx_file_uniq_t uniq ;
   time_t mtime ;
   off_t size ;
   off_t fs_size ;
   off_t directio ;
   size_t___0 read_ahead ;
   ngx_err_t err ;
   char *failed ;
   time_t valid ;
   ngx_uint_t min_uses ;
   size_t___0 disable_symlinks_from ;
   unsigned int disable_symlinks : 2 ;
   unsigned int test_dir : 1 ;
   unsigned int test_only : 1 ;
   unsigned int log : 1 ;
   unsigned int errors : 1 ;
   unsigned int events : 1 ;
   unsigned int is_dir : 1 ;
   unsigned int is_file : 1 ;
   unsigned int is_link : 1 ;
   unsigned int is_exec : 1 ;
   unsigned int is_directio : 1 ;
};
#line 19 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_info_t_765995005 ngx_open_file_info_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
struct __anonstruct_ngx_http_index_t_333798902 {
   ngx_str_t name ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
typedef struct __anonstruct_ngx_http_index_t_333798902 ngx_http_index_t;
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
struct __anonstruct_ngx_http_index_loc_conf_t_228765339 {
   ngx_array_t *indices ;
   size_t___0 max_index_len ;
};
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
typedef struct __anonstruct_ngx_http_index_loc_conf_t_228765339 ngx_http_index_loc_conf_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 19 "src/os/unix/ngx_time.h"
typedef struct tm ngx_tm_t;
#line 30 "src/os/unix/ngx_files.h"
struct __anonstruct_ngx_dir_t_78447930 {
   DIR *dir ;
   struct dirent *de ;
   struct stat info ;
   unsigned int type : 8 ;
   unsigned int valid_info : 1 ;
};
#line 30 "src/os/unix/ngx_files.h"
typedef struct __anonstruct_ngx_dir_t_78447930 ngx_dir_t;
#line 26 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
struct __anonstruct_ngx_http_autoindex_entry_t_100513729 {
   ngx_str_t name ;
   size_t___0 utf_len ;
   size_t___0 escape ;
   size_t___0 escape_html ;
   unsigned int dir : 1 ;
   unsigned int file : 1 ;
   time_t mtime ;
   off_t size ;
};
#line 26 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
typedef struct __anonstruct_ngx_http_autoindex_entry_t_100513729 ngx_http_autoindex_entry_t;
#line 40 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
struct __anonstruct_ngx_http_autoindex_loc_conf_t_911072624 {
   ngx_flag_t enable ;
   ngx_uint_t format ;
   ngx_flag_t localtime ;
   ngx_flag_t exact_size ;
};
#line 40 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
typedef struct __anonstruct_ngx_http_autoindex_loc_conf_t_911072624 ngx_http_autoindex_loc_conf_t;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
struct __anonstruct_ngx_http_copy_filter_conf_t_106385943 {
   ngx_bufs_t bufs ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
typedef struct __anonstruct_ngx_http_copy_filter_conf_t_106385943 ngx_http_copy_filter_conf_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
struct ngx_http_header_val_s ;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
typedef struct ngx_http_header_val_s ngx_http_header_val_t;
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
struct __anonstruct_ngx_http_set_header_t_506216175 {
   ngx_str_t name ;
   ngx_uint_t offset ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_http_header_val_t *hv , ngx_str_t *value ) ;
};
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
typedef struct __anonstruct_ngx_http_set_header_t_506216175 ngx_http_set_header_t;
#line 26 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
struct ngx_http_header_val_s {
   ngx_http_complex_value_t value ;
   ngx_str_t key ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_http_header_val_t *hv , ngx_str_t *value ) ;
   ngx_uint_t offset ;
   ngx_uint_t always ;
};
#line 35
enum __anonenum_ngx_http_expires_t_671256561 {
    NGX_HTTP_EXPIRES_OFF = 0,
    NGX_HTTP_EXPIRES_EPOCH = 1,
    NGX_HTTP_EXPIRES_MAX = 2,
    NGX_HTTP_EXPIRES_ACCESS = 3,
    NGX_HTTP_EXPIRES_MODIFIED = 4,
    NGX_HTTP_EXPIRES_DAILY = 5,
    NGX_HTTP_EXPIRES_UNSET = 6
} ;
#line 35 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
typedef enum __anonenum_ngx_http_expires_t_671256561 ngx_http_expires_t;
#line 46 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
struct __anonstruct_ngx_http_headers_conf_t_308353714 {
   ngx_http_expires_t expires ;
   time_t expires_time ;
   ngx_http_complex_value_t *expires_value ;
   ngx_array_t *headers ;
   ngx_array_t *trailers ;
};
#line 46 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
typedef struct __anonstruct_ngx_http_headers_conf_t_308353714 ngx_http_headers_conf_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 16 "src/os/unix/ngx_process.h"
typedef pid_t ngx_pid_t;
#line 22 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
struct __anonstruct_ngx_http_userid_conf_t_842819208 {
   ngx_uint_t enable ;
   ngx_int_t service ;
   ngx_str_t name ;
   ngx_str_t domain ;
   ngx_str_t path ;
   ngx_str_t p3p ;
   time_t expires ;
   u_char mark ;
};
#line 22 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
typedef struct __anonstruct_ngx_http_userid_conf_t_842819208 ngx_http_userid_conf_t;
#line 38 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
struct __anonstruct_ngx_http_userid_ctx_t_809601003 {
   uint32_t uid_got[4] ;
   uint32_t uid_set[4] ;
   ngx_str_t cookie ;
   ngx_uint_t reset ;
};
#line 38 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
typedef struct __anonstruct_ngx_http_userid_ctx_t_809601003 ngx_http_userid_ctx_t;
#line 23 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_t_460057101 {
   u_char **tables ;
   ngx_str_t name ;
   unsigned int length : 16 ;
   unsigned int utf8 : 1 ;
};
#line 23 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_t_460057101 ngx_http_charset_t;
#line 32 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_recode_t_807739687 {
   ngx_int_t src ;
   ngx_int_t dst ;
};
#line 32 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_recode_t_807739687 ngx_http_charset_recode_t;
#line 38 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_tables_t_801435360 {
   ngx_int_t src ;
   ngx_int_t dst ;
   u_char *src2dst ;
   u_char *dst2src ;
};
#line 38 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_tables_t_801435360 ngx_http_charset_tables_t;
#line 46 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_main_conf_t_857105290 {
   ngx_array_t charsets ;
   ngx_array_t tables ;
   ngx_array_t recodes ;
};
#line 46 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_main_conf_t_857105290 ngx_http_charset_main_conf_t;
#line 53 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_loc_conf_t_188859742 {
   ngx_int_t charset ;
   ngx_int_t source_charset ;
   ngx_flag_t override_charset ;
   ngx_hash_t types ;
   ngx_array_t *types_keys ;
};
#line 53 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_loc_conf_t_188859742 ngx_http_charset_loc_conf_t;
#line 63 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_ctx_t_680836602 {
   u_char *table ;
   ngx_int_t charset ;
   ngx_str_t charset_name ;
   ngx_chain_t *busy ;
   ngx_chain_t *free_bufs ;
   ngx_chain_t *free_buffers ;
   size_t___0 saved_len ;
   u_char saved[4] ;
   unsigned int length : 16 ;
   unsigned int from_utf8 : 1 ;
   unsigned int to_utf8 : 1 ;
};
#line 63 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_ctx_t_680836602 ngx_http_charset_ctx_t;
#line 81 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_conf_ctx_t_366051915 {
   ngx_http_charset_tables_t *table ;
   ngx_http_charset_t *charset ;
   ngx_uint_t characters ;
};
#line 81 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_conf_ctx_t_366051915 ngx_http_charset_conf_ctx_t;
#line 33 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_main_conf_t_863974746 {
   ngx_hash_t hash ;
   ngx_hash_keys_arrays_t commands ;
};
#line 33 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_main_conf_t_863974746 ngx_http_ssi_main_conf_t;
#line 39 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_ctx_t_644725096 {
   ngx_buf_t *buf ;
   u_char *pos ;
   u_char *copy_start ;
   u_char *copy_end ;
   ngx_uint_t key ;
   ngx_str_t command ;
   ngx_array_t params ;
   ngx_table_elt_t *param ;
   ngx_table_elt_t params_array[4] ;
   ngx_chain_t *in ;
   ngx_chain_t *out ;
   ngx_chain_t **last_out ;
   ngx_chain_t *busy ;
   ngx_chain_t *free ;
   ngx_uint_t state ;
   ngx_uint_t saved_state ;
   size_t___0 saved ;
   size_t___0 looked ;
   size_t___0 value_len ;
   ngx_list_t *variables ;
   ngx_array_t *blocks ;
   ngx_uint_t ncaptures ;
   int *captures ;
   u_char *captures_data ;
   unsigned int conditional : 2 ;
   unsigned int encoding : 2 ;
   unsigned int block : 1 ;
   unsigned int output : 1 ;
   unsigned int output_chosen : 1 ;
   ngx_http_request_t *wait ;
   void *value_buf ;
   ngx_str_t timefmt ;
   ngx_str_t errmsg ;
};
#line 39 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_ctx_t_644725096 ngx_http_ssi_ctx_t;
#line 91 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_param_t_830121471 {
   ngx_str_t name ;
   ngx_uint_t index ;
   unsigned int mandatory : 1 ;
   unsigned int multiple : 1 ;
};
#line 91 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_param_t_830121471 ngx_http_ssi_param_t;
#line 100 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_command_t_292167609 {
   ngx_str_t name ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx , ngx_str_t ** ) ;
   ngx_http_ssi_param_t *params ;
   unsigned int conditional : 2 ;
   unsigned int block : 1 ;
   unsigned int flush : 1 ;
};
#line 100 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_command_t_292167609 ngx_http_ssi_command_t;
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
struct __anonstruct_ngx_http_ssi_loc_conf_t_288367901 {
   ngx_flag_t enable ;
   ngx_flag_t silent_errors ;
   ngx_flag_t ignore_recycled_buffers ;
   ngx_flag_t last_modified ;
   ngx_hash_t types ;
   size_t___0 min_file_chunk ;
   size_t___0 value_len ;
   ngx_array_t *types_keys ;
};
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
typedef struct __anonstruct_ngx_http_ssi_loc_conf_t_288367901 ngx_http_ssi_loc_conf_t;
#line 35 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
struct __anonstruct_ngx_http_ssi_var_t_185579926 {
   ngx_str_t name ;
   ngx_uint_t key ;
   ngx_str_t value ;
};
#line 35 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
typedef struct __anonstruct_ngx_http_ssi_var_t_185579926 ngx_http_ssi_var_t;
#line 42 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
struct __anonstruct_ngx_http_ssi_block_t_243178861 {
   ngx_str_t name ;
   ngx_chain_t *bufs ;
   ngx_uint_t count ;
};
#line 42 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
typedef struct __anonstruct_ngx_http_ssi_block_t_243178861 ngx_http_ssi_block_t;
#line 49
enum __anonenum_ngx_http_ssi_state_e_88273087 {
    ssi_start_state = 0,
    ssi_tag_state = 1,
    ssi_comment0_state = 2,
    ssi_comment1_state = 3,
    ssi_sharp_state = 4,
    ssi_precommand_state = 5,
    ssi_command_state = 6,
    ssi_preparam_state = 7,
    ssi_param_state = 8,
    ssi_preequal_state = 9,
    ssi_prevalue_state = 10,
    ssi_double_quoted_value_state = 11,
    ssi_quoted_value_state = 12,
    ssi_quoted_symbol_state = 13,
    ssi_postparam_state = 14,
    ssi_comment_end0_state = 15,
    ssi_comment_end1_state = 16,
    ssi_error_state = 17,
    ssi_error_end0_state = 18,
    ssi_error_end1_state = 19
} ;
#line 49 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
typedef enum __anonenum_ngx_http_ssi_state_e_88273087 ngx_http_ssi_state_e;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 84 "/usr/include/zlib.h"
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 86 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 15 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
struct __anonstruct_ngx_http_gzip_conf_t_365325227 {
   ngx_flag_t enable ;
   ngx_flag_t no_buffer ;
   ngx_hash_t types ;
   ngx_bufs_t bufs ;
   size_t___0 postpone_gzipping ;
   ngx_int_t level ;
   size_t___0 wbits ;
   size_t___0 memlevel ;
   ssize_t min_length ;
   ngx_array_t *types_keys ;
};
#line 15 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
typedef struct __anonstruct_ngx_http_gzip_conf_t_365325227 ngx_http_gzip_conf_t;
#line 33 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
struct __anonstruct_ngx_http_gzip_ctx_t_30638051 {
   ngx_chain_t *in ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   ngx_chain_t *out ;
   ngx_chain_t **last_out ;
   ngx_chain_t *copied ;
   ngx_chain_t *copy_buf ;
   ngx_buf_t *in_buf ;
   ngx_buf_t *out_buf ;
   ngx_int_t bufs ;
   void *preallocated ;
   char *free_mem ;
   ngx_uint_t allocated ;
   int wbits ;
   int memlevel ;
   unsigned int flush : 4 ;
   unsigned int redo : 1 ;
   unsigned int done : 1 ;
   unsigned int nomem : 1 ;
   unsigned int gzheader : 1 ;
   unsigned int buffering : 1 ;
   size_t___0 zin ;
   size_t___0 zout ;
   uint32_t crc32 ;
   z_stream zstream ;
   ngx_http_request_t *request ;
};
#line 33 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
typedef struct __anonstruct_ngx_http_gzip_ctx_t_30638051 ngx_http_gzip_ctx_t;
#line 72 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
struct gztrailer {
   uint32_t crc32 ;
   uint32_t zlen ;
};
#line 48 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
struct __anonstruct_ngx_http_range_t_237441574 {
   off_t start ;
   off_t end ;
   ngx_str_t content_range ;
};
#line 48 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
typedef struct __anonstruct_ngx_http_range_t_237441574 ngx_http_range_t;
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
struct __anonstruct_ngx_http_range_filter_ctx_t_690125858 {
   off_t offset ;
   ngx_str_t boundary_header ;
   ngx_array_t ranges ;
};
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
typedef struct __anonstruct_ngx_http_range_filter_ctx_t_690125858 ngx_http_range_filter_ctx_t;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
struct __anonstruct_ngx_http_chunked_filter_ctx_t_827024780 {
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
typedef struct __anonstruct_ngx_http_chunked_filter_ctx_t_827024780 ngx_http_chunked_filter_ctx_t;
#line 175 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_header_out_t_1021999984 {
   ngx_str_t name ;
   ngx_uint_t offset ;
};
#line 175 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_header_out_t_1021999984 ngx_http_header_out_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 87 "src/core/ngx_file.h"
struct __anonstruct_ngx_ext_rename_file_t_37896740 {
   ngx_uint_t access ;
   ngx_uint_t path_access ;
   time_t time ;
   ngx_fd_t fd ;
   unsigned int create_path : 1 ;
   unsigned int delete_file : 1 ;
   ngx_log_t *log ;
};
#line 87 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_ext_rename_file_t_37896740 ngx_ext_rename_file_t;
#line 111
struct ngx_tree_ctx_s ;
#line 111 "src/core/ngx_file.h"
typedef struct ngx_tree_ctx_s ngx_tree_ctx_t;
#line 116 "src/core/ngx_file.h"
struct ngx_tree_ctx_s {
   off_t size ;
   off_t fs_size ;
   ngx_uint_t access ;
   time_t mtime ;
   ngx_int_t (*init_handler)(void *ctx , void *prev ) ;
   ngx_int_t (*file_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   ngx_int_t (*pre_tree_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   ngx_int_t (*post_tree_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   ngx_int_t (*spec_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   void *data ;
   size_t___0 alloc ;
   ngx_log_t *log ;
};
#line 20 "src/http/ngx_http.h"
struct ngx_http_log_ctx_s ;
#line 20 "src/http/ngx_http.h"
typedef struct ngx_http_log_ctx_s ngx_http_log_ctx_t;
#line 33 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_cache_valid_t_574206330 {
   ngx_uint_t status ;
   time_t valid ;
};
#line 33 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_cache_valid_t_574206330 ngx_http_cache_valid_t;
#line 126 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_file_cache_header_t_133808268 {
   ngx_uint_t version ;
   time_t valid_sec ;
   time_t updating_sec ;
   time_t error_sec ;
   time_t last_modified ;
   time_t date ;
   uint32_t crc32 ;
   u_short valid_msec ;
   u_short header_start ;
   u_short body_start ;
   u_char etag_len ;
   u_char etag[128] ;
   u_char vary_len ;
   u_char vary[128] ;
   u_char variant[16] ;
};
#line 126 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_file_cache_header_t_133808268 ngx_http_file_cache_header_t;
#line 52 "src/http/ngx_http.h"
struct ngx_http_log_ctx_s {
   ngx_connection_t *connection ;
   ngx_http_request_t *request ;
   ngx_http_request_t *current_request ;
};
#line 16 "src/core/ngx_md5.h"
struct __anonstruct_ngx_md5_t_70555764 {
   uint64_t bytes ;
   uint32_t a ;
   uint32_t b ;
   uint32_t c ;
   uint32_t d ;
   u_char buffer[64] ;
};
#line 16 "src/core/ngx_md5.h"
typedef struct __anonstruct_ngx_md5_t_70555764 ngx_md5_t;
#line 92 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_server_t_363367844 {
   ngx_str_t name ;
   ngx_addr_t *addrs ;
   ngx_uint_t naddrs ;
   ngx_uint_t weight ;
   ngx_uint_t max_conns ;
   ngx_uint_t max_fails ;
   time_t fail_timeout ;
   ngx_msec_t slow_start ;
   unsigned int down : 1 ;
   unsigned int backup : 1 ;
};
#line 92 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_server_t_363367844 ngx_http_upstream_server_t;
#line 177 "src/event/ngx_event.h"
struct __anonstruct_ngx_event_actions_t_911516659 {
   ngx_int_t (*add)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*del)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*enable)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*disable)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*add_conn)(ngx_connection_t *c ) ;
   ngx_int_t (*del_conn)(ngx_connection_t *c , ngx_uint_t flags ) ;
   ngx_int_t (*notify)(void (*handler)(ngx_event_t *ev ) ) ;
   ngx_int_t (*process_events)(ngx_cycle_t *cycle , ngx_msec_t timer , ngx_uint_t flags ) ;
   ngx_int_t (*init)(ngx_cycle_t *cycle , ngx_msec_t timer ) ;
   void (*done)(ngx_cycle_t *cycle ) ;
};
#line 177 "src/event/ngx_event.h"
typedef struct __anonstruct_ngx_event_actions_t_911516659 ngx_event_actions_t;
#line 395 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_next_t_199679288 {
   ngx_uint_t status ;
   ngx_uint_t mask ;
};
#line 395 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_next_t_199679288 ngx_http_upstream_next_t;
#line 291 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_err_page_t_401737588 {
   ngx_int_t status ;
   ngx_int_t overwrite ;
   ngx_http_complex_value_t value ;
   ngx_str_t args ;
};
#line 291 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_err_page_t_401737588 ngx_http_err_page_t;
#line 108 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_copy_capture_code_t_609967268 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t n ;
};
#line 108 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_copy_capture_code_t_609967268 ngx_http_script_copy_capture_code_t;
#line 154 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_full_name_code_t_831059365 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t conf_prefix ;
};
#line 154 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_full_name_code_t_831059365 ngx_http_script_full_name_code_t;
#line 215 "/usr/include/netinet/tcp.h"
struct tcp_info {
   uint8_t tcpi_state ;
   uint8_t tcpi_ca_state ;
   uint8_t tcpi_retransmits ;
   uint8_t tcpi_probes ;
   uint8_t tcpi_backoff ;
   uint8_t tcpi_options ;
   uint8_t tcpi_snd_wscale : 4 ;
   uint8_t tcpi_rcv_wscale : 4 ;
   uint32_t tcpi_rto ;
   uint32_t tcpi_ato ;
   uint32_t tcpi_snd_mss ;
   uint32_t tcpi_rcv_mss ;
   uint32_t tcpi_unacked ;
   uint32_t tcpi_sacked ;
   uint32_t tcpi_lost ;
   uint32_t tcpi_retrans ;
   uint32_t tcpi_fackets ;
   uint32_t tcpi_last_data_sent ;
   uint32_t tcpi_last_ack_sent ;
   uint32_t tcpi_last_data_recv ;
   uint32_t tcpi_last_ack_recv ;
   uint32_t tcpi_pmtu ;
   uint32_t tcpi_rcv_ssthresh ;
   uint32_t tcpi_rtt ;
   uint32_t tcpi_rttvar ;
   uint32_t tcpi_snd_ssthresh ;
   uint32_t tcpi_snd_cwnd ;
   uint32_t tcpi_advmss ;
   uint32_t tcpi_reordering ;
   uint32_t tcpi_rcv_rtt ;
   uint32_t tcpi_rcv_space ;
   uint32_t tcpi_total_retrans ;
};
#line 11 "src/core/ngx_syslog.h"
struct __anonstruct_ngx_syslog_peer_t_559301615 {
   ngx_pool_t *pool ;
   ngx_uint_t facility ;
   ngx_uint_t severity ;
   ngx_str_t tag ;
   ngx_addr_t server ;
   ngx_connection_t conn ;
   unsigned int busy : 1 ;
   unsigned int nohostname : 1 ;
};
#line 11 "src/core/ngx_syslog.h"
typedef struct __anonstruct_ngx_syslog_peer_t_559301615 ngx_syslog_peer_t;
#line 17 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct ngx_http_log_op_s ;
#line 17 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct ngx_http_log_op_s ngx_http_log_op_t;
#line 26 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct ngx_http_log_op_s {
   size_t___0 len ;
   size_t___0 (*getlen)(ngx_http_request_t *r , uintptr_t data ) ;
   u_char *(*run)(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
   uintptr_t data ;
};
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_fmt_t_333798902 {
   ngx_str_t name ;
   ngx_array_t *flushes ;
   ngx_array_t *ops ;
};
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_fmt_t_333798902 ngx_http_log_fmt_t;
#line 41 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_main_conf_t_840469406 {
   ngx_array_t formats ;
   ngx_uint_t combined_used ;
};
#line 41 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_main_conf_t_840469406 ngx_http_log_main_conf_t;
#line 47 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_buf_t_233313827 {
   u_char *start ;
   u_char *pos ;
   u_char *last ;
   ngx_event_t *event ;
   ngx_msec_t flush ;
   ngx_int_t gzip ;
};
#line 47 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_buf_t_233313827 ngx_http_log_buf_t;
#line 58 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_script_t_795656836 {
   ngx_array_t *lengths ;
   ngx_array_t *values ;
};
#line 58 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_script_t_795656836 ngx_http_log_script_t;
#line 64 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_t_572101553 {
   ngx_open_file_t *file ;
   ngx_http_log_script_t *script ;
   time_t disk_full_time ;
   time_t error_log_time ;
   ngx_syslog_peer_t *syslog_peer ;
   ngx_http_log_fmt_t *format ;
   ngx_http_complex_value_t *filter ;
};
#line 64 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_t_572101553 ngx_http_log_t;
#line 75 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_loc_conf_t_436097340 {
   ngx_array_t *logs ;
   ngx_open_file_cache_t *open_file_cache ;
   time_t open_file_cache_valid ;
   ngx_uint_t open_file_cache_min_uses ;
   ngx_uint_t off ;
};
#line 75 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_loc_conf_t_436097340 ngx_http_log_loc_conf_t;
#line 86 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_var_t_938104600 {
   ngx_str_t name ;
   size_t___0 len ;
   u_char *(*run)(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
};
#line 86 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_var_t_938104600 ngx_http_log_var_t;
#line 107 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
enum __anonenum_state_67232969 {
    sw_start = 0,
    sw_method = 1,
    sw_spaces_before_uri = 2,
    sw_schema = 3,
    sw_schema_slash = 4,
    sw_schema_slash_slash = 5,
    sw_host_start = 6,
    sw_host = 7,
    sw_host_end = 8,
    sw_host_ip_literal = 9,
    sw_port = 10,
    sw_host_http_09 = 11,
    sw_after_slash_in_uri = 12,
    sw_check_uri = 13,
    sw_check_uri_http_09 = 14,
    sw_uri = 15,
    sw_http_09 = 16,
    sw_http_H = 17,
    sw_http_HT = 18,
    sw_http_HTT = 19,
    sw_http_HTTP = 20,
    sw_first_major_digit = 21,
    sw_major_digit = 22,
    sw_first_minor_digit = 23,
    sw_minor_digit = 24,
    sw_spaces_after_digit = 25,
    sw_almost_done = 26
} ;
#line 846
enum __anonenum_state_940472761 {
    sw_start___0 = 0,
    sw_name = 1,
    sw_space_before_value = 2,
    sw_value = 3,
    sw_space_after_value = 4,
    sw_ignore_line = 5,
    sw_almost_done___0 = 6,
    sw_header_almost_done = 7
} ;
#line 1113
enum __anonenum_state_43130286 {
    sw_start___1 = 0,
    sw_after_slash_in_uri___0 = 1,
    sw_check_uri___0 = 2,
    sw_uri___0 = 3
} ;
#line 1261
enum __anonenum_state_861259954 {
    sw_usual = 0,
    sw_slash = 1,
    sw_dot = 2,
    sw_dot_dot = 3,
    sw_quoted = 4,
    sw_quoted_second = 5
} ;
#line 1605
enum __anonenum_state_695160250 {
    sw_start___2 = 0,
    sw_H = 1,
    sw_HT = 2,
    sw_HTT = 3,
    sw_HTTP = 4,
    sw_first_major_digit___0 = 5,
    sw_major_digit___0 = 6,
    sw_first_minor_digit___0 = 7,
    sw_minor_digit___0 = 8,
    sw_status = 9,
    sw_space_after_status = 10,
    sw_status_text = 11,
    sw_almost_done___1 = 12
} ;
#line 2132
enum __anonenum_state_962966958 {
    sw_chunk_start = 0,
    sw_chunk_size = 1,
    sw_chunk_extension = 2,
    sw_chunk_extension_almost_done = 3,
    sw_chunk_data = 4,
    sw_after_data = 5,
    sw_after_data_almost_done = 6,
    sw_last_chunk_extension = 7,
    sw_last_chunk_extension_almost_done = 8,
    sw_trailer = 9,
    sw_trailer_almost_done = 10,
    sw_trailer_header = 11,
    sw_trailer_header_almost_done = 12
} ;
#line 444 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 168 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_header_t_923240469 {
   ngx_str_t name ;
   ngx_uint_t offset ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_table_elt_t *h , ngx_uint_t offset ) ;
};
#line 168 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_header_t_923240469 ngx_http_header_t;
#line 588 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_ephemeral_t_889258449 {
   ngx_http_posted_request_t terminal_posted_request ;
};
#line 588 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_ephemeral_t_889258449 ngx_http_ephemeral_t;
#line 243 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_in_addr_t_123280881 {
   in_addr_t addr ;
   ngx_http_addr_conf_t conf ;
};
#line 243 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_in_addr_t_123280881 ngx_http_in_addr_t;
#line 251 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_in6_addr_t_345044526 {
   struct in6_addr addr6 ;
   ngx_http_addr_conf_t conf ;
};
#line 251 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_in6_addr_t_345044526 ngx_http_in6_addr_t;
#line 259 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_port_t_994908779 {
   void *addrs ;
   ngx_uint_t naddrs ;
};
#line 259 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_port_t_994908779 ngx_http_port_t;
#line 1960 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
enum __anonenum_state_207726914 {
    sw_usual___0 = 0,
    sw_literal = 1,
    sw_rest = 2
} ;
#line 26 "src/os/unix/ngx_os.h"
struct __anonstruct_ngx_os_io_t_341591794 {
   ssize_t (*recv)(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
   ssize_t (*recv_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ssize_t (*udp_recv)(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
   ssize_t (*send)(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
   ssize_t (*udp_send)(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
   ngx_chain_t *(*udp_send_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_chain_t *(*send_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_uint_t flags ;
};
#line 26 "src/os/unix/ngx_os.h"
typedef struct __anonstruct_ngx_os_io_t_341591794 ngx_os_io_t;
#line 67 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_listen_opt_t_30748437 {
   ngx_sockaddr_t sockaddr ;
   socklen_t socklen ;
   unsigned int set : 1 ;
   unsigned int default_server : 1 ;
   unsigned int bind : 1 ;
   unsigned int wildcard : 1 ;
   unsigned int ssl : 1 ;
   unsigned int http2 : 1 ;
   unsigned int ipv6only : 1 ;
   unsigned int deferred_accept : 1 ;
   unsigned int reuseport : 1 ;
   unsigned int so_keepalive : 2 ;
   unsigned int proxy_protocol : 1 ;
   int backlog ;
   int rcvbuf ;
   int sndbuf ;
   int fastopen ;
   int tcp_keepidle ;
   int tcp_keepintvl ;
   int tcp_keepcnt ;
   u_char addr[((sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path))) + 1UL] ;
};
#line 67 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_listen_opt_t_30748437 ngx_http_listen_opt_t;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
struct __anonstruct_ngx_http_method_name_t_396046808 {
   u_char *name ;
   uint32_t method ;
};
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
typedef struct __anonstruct_ngx_http_method_name_t_396046808 ngx_http_method_name_t;
#line 260 "src/core/ngx_module.h"
struct __anonstruct_ngx_core_module_t_386460957 {
   ngx_str_t name ;
   void *(*create_conf)(ngx_cycle_t *cycle ) ;
   char *(*init_conf)(ngx_cycle_t *cycle , void *conf ) ;
};
#line 260 "src/core/ngx_module.h"
typedef struct __anonstruct_ngx_core_module_t_386460957 ngx_core_module_t;
#line 266 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_conf_port_t_898932045 {
   ngx_int_t family ;
   in_port_t port ;
   ngx_array_t addrs ;
};
#line 266 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_conf_port_t_898932045 ngx_http_conf_port_t;
#line 273 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_conf_addr_t_1073212357 {
   ngx_http_listen_opt_t opt ;
   ngx_hash_t hash ;
   ngx_hash_wildcard_t *wc_head ;
   ngx_hash_wildcard_t *wc_tail ;
   ngx_uint_t nregex ;
   ngx_http_server_name_t *regex ;
   ngx_http_core_srv_conf_t *default_server ;
   ngx_array_t servers ;
};
#line 273 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_conf_addr_t_1073212357 ngx_http_conf_addr_t;
#line 451 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_location_queue_t_658223662 {
   ngx_queue_t queue ;
   ngx_http_core_loc_conf_t *exact ;
   ngx_http_core_loc_conf_t *inclusive ;
   ngx_str_t *name ;
   u_char *file_name ;
   ngx_uint_t line ;
   ngx_queue_t list ;
};
#line 451 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_location_queue_t_658223662 ngx_http_location_queue_t;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
struct __anonstruct_ngx_regex_conf_t_1016720635 {
   ngx_flag_t pcre_jit ;
};
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
typedef struct __anonstruct_ngx_regex_conf_t_1016720635 ngx_regex_conf_t;
#line 64 "src/os/unix/ngx_os.h"
struct __anonstruct_ngx_iovec_t_52866111 {
   struct iovec *iovs ;
   ngx_uint_t count ;
   size_t___0 size ;
   ngx_uint_t nalloc ;
};
#line 64 "src/os/unix/ngx_os.h"
typedef struct __anonstruct_ngx_iovec_t_52866111 ngx_iovec_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
#line 75 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
typedef union epoll_data epoll_data_t;
#line 83 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
#line 457 "src/event/ngx_event.h"
struct __anonstruct_ngx_event_module_t_1020940069 {
   ngx_str_t *name ;
   void *(*create_conf)(ngx_cycle_t *cycle ) ;
   char *(*init_conf)(ngx_cycle_t *cycle , void *conf ) ;
   ngx_event_actions_t actions ;
};
#line 457 "src/event/ngx_event.h"
typedef struct __anonstruct_ngx_event_module_t_1020940069 ngx_event_module_t;
#line 98 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
struct __anonstruct_ngx_epoll_conf_t_199679288 {
   ngx_uint_t events ;
   ngx_uint_t aio_requests ;
};
#line 98 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
typedef struct __anonstruct_ngx_epoll_conf_t_199679288 ngx_epoll_conf_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 146 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/time.h"
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 104 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 115 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim64_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 187
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 40 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef unsigned long __cpu_mask;
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 39 "/usr/include/x86_64-linux-gnu/bits/cpu-set.h"
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
#line 16 "src/os/unix/ngx_setaffinity.h"
typedef cpu_set_t ngx_cpuset_t;
#line 22 "src/os/unix/ngx_process.h"
struct __anonstruct_ngx_process_t_434836114 {
   ngx_pid_t pid ;
   int status ;
   ngx_socket_t channel[2] ;
   void (*proc)(ngx_cycle_t *cycle , void *data ) ;
   void *data ;
   char *name ;
   unsigned int respawn : 1 ;
   unsigned int just_spawn : 1 ;
   unsigned int detached : 1 ;
   unsigned int exiting : 1 ;
   unsigned int exited : 1 ;
};
#line 22 "src/os/unix/ngx_process.h"
typedef struct __anonstruct_ngx_process_t_434836114 ngx_process_t;
#line 16 "src/os/unix/ngx_user.h"
typedef uid_t ngx_uid_t;
#line 17 "src/os/unix/ngx_user.h"
typedef gid_t ngx_gid_t;
#line 86 "src/core/ngx_cycle.h"
struct __anonstruct_ngx_core_conf_t_803994434 {
   ngx_flag_t daemon ;
   ngx_flag_t master ;
   ngx_msec_t timer_resolution ;
   ngx_msec_t shutdown_timeout ;
   ngx_int_t worker_processes ;
   ngx_int_t debug_points ;
   ngx_int_t rlimit_nofile ;
   off_t rlimit_core ;
   int priority ;
   ngx_uint_t cpu_affinity_auto ;
   ngx_uint_t cpu_affinity_n ;
   ngx_cpuset_t *cpu_affinity ;
   char *username ;
   ngx_uid_t user ;
   ngx_gid_t group ;
   ngx_str_t working_directory ;
   ngx_str_t lock_file ;
   ngx_str_t pid ;
   ngx_str_t oldpid ;
   ngx_array_t env ;
   char **environment ;
};
#line 86 "src/core/ngx_cycle.h"
typedef struct __anonstruct_ngx_core_conf_t_803994434 ngx_core_conf_t;
#line 30 "src/os/unix/ngx_process_cycle.h"
struct __anonstruct_ngx_cache_manager_ctx_t_40702914 {
   void (*handler)(ngx_event_t *ev ) ;
   char *name ;
   ngx_msec_t delay ;
};
#line 30 "src/os/unix/ngx_process_cycle.h"
typedef struct __anonstruct_ngx_cache_manager_ctx_t_40702914 ngx_cache_manager_ctx_t;
#line 17 "src/os/unix/ngx_channel.h"
struct __anonstruct_ngx_channel_t_810932128 {
   ngx_uint_t command ;
   ngx_pid_t pid ;
   ngx_int_t slot ;
   ngx_fd_t fd ;
};
#line 17 "src/os/unix/ngx_channel.h"
typedef struct __anonstruct_ngx_channel_t_810932128 ngx_channel_t;
#line 46 "/usr/include/crypt.h"
struct crypt_data {
   char keysched[128] ;
   char sb0[32768] ;
   char sb1[32768] ;
   char sb2[32768] ;
   char sb3[32768] ;
   char crypt_3_buf[14] ;
   char current_salt[2] ;
   long current_saltbits ;
   int direction ;
   int initialized ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_727042362 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_672892844 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_727042362 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_243330693 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_324526951 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_672892844 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_243330693 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_105608722 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_324526951 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_105608722 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 39 "src/os/unix/ngx_process.h"
struct __anonstruct_ngx_exec_ctx_t_343724373 {
   char *path ;
   char *name ;
   char * const  *argv ;
   char * const  *envp ;
};
#line 39 "src/os/unix/ngx_process.h"
typedef struct __anonstruct_ngx_exec_ctx_t_343724373 ngx_exec_ctx_t;
#line 14 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
struct __anonstruct_ngx_signal_t_987201191 {
   int signo ;
   char *signame ;
   char *name ;
   void (*handler)(int signo , siginfo_t *siginfo , void *ucontext ) ;
};
#line 14 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
typedef struct __anonstruct_ngx_signal_t_987201191 ngx_signal_t;
#line 191 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 24 "/tmp/nginx-1.13.2/src/os/unix/ngx_channel.c"
union __anonunion_cmsg_918060065 {
   struct cmsghdr cm ;
   char space[(((sizeof(int ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
};
#line 104 "/tmp/nginx-1.13.2/src/os/unix/ngx_channel.c"
union __anonunion_cmsg_918060066 {
   struct cmsghdr cm ;
   char space[(((sizeof(int ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
};
#line 157 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 536 "/usr/include/netinet/in.h"
struct in6_pktinfo {
   struct in6_addr ipi6_addr ;
   unsigned int ipi6_ifindex ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 143 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 176 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 179 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 27 "/usr/include/glob.h"
typedef unsigned long __size_t;
#line 82 "/usr/include/glob.h"
struct __anonstruct_glob_t_785670244 {
   __size_t gl_pathc ;
   char **gl_pathv ;
   __size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , struct stat * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , struct stat * __restrict   ) ;
};
#line 82 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_785670244 glob_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 40 "src/os/unix/ngx_files.h"
struct __anonstruct_ngx_glob_t_14760394 {
   size_t___0 n ;
   glob_t pglob ;
   u_char *pattern ;
   ngx_log_t *log ;
   ngx_uint_t test ;
};
#line 40 "src/os/unix/ngx_files.h"
typedef struct __anonstruct_ngx_glob_t_14760394 ngx_glob_t;
#line 440 "src/event/ngx_event.h"
struct __anonstruct_ngx_event_conf_t_74764414 {
   ngx_uint_t connections ;
   ngx_uint_t use ;
   ngx_flag_t multi_accept ;
   ngx_flag_t accept_mutex ;
   ngx_msec_t accept_mutex_delay ;
   u_char *name ;
};
#line 440 "src/event/ngx_event.h"
typedef struct __anonstruct_ngx_event_conf_t_74764414 ngx_event_conf_t;
#line 97 "src/os/unix/ngx_atomic.h"
typedef long ngx_atomic_int_t;
#line 16 "src/core/ngx_sha1.h"
struct __anonstruct_ngx_sha1_t_70555765 {
   uint64_t bytes ;
   uint32_t a ;
   uint32_t b ;
   uint32_t c ;
   uint32_t d ;
   uint32_t e ;
   uint32_t f ;
   u_char buffer[64] ;
};
#line 16 "src/core/ngx_sha1.h"
typedef struct __anonstruct_ngx_sha1_t_70555765 ngx_sha1_t;
#line 68 "src/core/ngx_palloc.h"
struct __anonstruct_ngx_pool_cleanup_file_t_510948481 {
   ngx_fd_t fd ;
   u_char *name ;
   ngx_log_t *log ;
};
#line 68 "src/core/ngx_palloc.h"
typedef struct __anonstruct_ngx_pool_cleanup_file_t_510948481 ngx_pool_cleanup_file_t;
#line 54 "src/core/ngx_open_file_cache.h"
struct ngx_cached_open_file_s ;
#line 54 "src/core/ngx_open_file_cache.h"
typedef struct ngx_cached_open_file_s ngx_cached_open_file_t;
#line 56 "src/core/ngx_open_file_cache.h"
struct ngx_cached_open_file_s {
   ngx_rbtree_node_t node ;
   ngx_queue_t queue ;
   u_char *name ;
   time_t created ;
   time_t accessed ;
   ngx_fd_t fd ;
   ngx_file_uniq_t uniq ;
   time_t mtime ;
   off_t size ;
   ngx_err_t err ;
   uint32_t uses ;
   size_t___0 disable_symlinks_from ;
   unsigned int disable_symlinks : 2 ;
   unsigned int count : 24 ;
   unsigned int close : 1 ;
   unsigned int use_event : 1 ;
   unsigned int is_dir : 1 ;
   unsigned int is_file : 1 ;
   unsigned int is_link : 1 ;
   unsigned int is_exec : 1 ;
   unsigned int is_directio : 1 ;
   ngx_event_t *event ;
};
#line 102 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_cache_cleanup_t_397028010 {
   ngx_open_file_cache_t *cache ;
   ngx_cached_open_file_t *file ;
   ngx_uint_t min_uses ;
   ngx_log_t *log ;
};
#line 102 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_cache_cleanup_t_397028010 ngx_open_file_cache_cleanup_t;
#line 110 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_cache_event_t_985486638 {
   void *data ;
   ngx_event_t *read ;
   ngx_event_t *write ;
   ngx_fd_t fd ;
   ngx_cached_open_file_t *file ;
   ngx_open_file_cache_t *cache ;
};
#line 110 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_cache_event_t_985486638 ngx_open_file_cache_event_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 43 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_connection_t_598954628 {
   ngx_connection_t *udp ;
   ngx_connection_t *tcp ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t server ;
   ngx_log_t log ;
   ngx_buf_t *read_buf ;
   ngx_buf_t *write_buf ;
   ngx_resolver_t *resolver ;
};
#line 43 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_connection_t_598954628 ngx_resolver_connection_t;
#line 19 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
struct __anonstruct_ngx_resolver_hdr_t_137382250 {
   u_char ident_hi ;
   u_char ident_lo ;
   u_char flags_hi ;
   u_char flags_lo ;
   u_char nqs_hi ;
   u_char nqs_lo ;
   u_char nan_hi ;
   u_char nan_lo ;
   u_char nns_hi ;
   u_char nns_lo ;
   u_char nar_hi ;
   u_char nar_lo ;
};
#line 19 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
typedef struct __anonstruct_ngx_resolver_hdr_t_137382250 ngx_resolver_hdr_t;
#line 35 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
struct __anonstruct_ngx_resolver_qs_t_1020671504 {
   u_char type_hi ;
   u_char type_lo ;
   u_char class_hi ;
   u_char class_lo ;
};
#line 35 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
typedef struct __anonstruct_ngx_resolver_qs_t_1020671504 ngx_resolver_qs_t;
#line 43 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
struct __anonstruct_ngx_resolver_an_t_373592045 {
   u_char type_hi ;
   u_char type_lo ;
   u_char class_hi ;
   u_char class_lo ;
   u_char ttl[4] ;
   u_char len_hi ;
   u_char len_lo ;
};
#line 43 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
typedef struct __anonstruct_ngx_resolver_an_t_373592045 ngx_resolver_an_t;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list___0;
#line 106 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_dump_t_393872104 {
   ngx_str_t name ;
   ngx_buf_t *buffer ;
};
#line 106 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_dump_t_393872104 ngx_conf_dump_t;
#line 143 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_deprecated_t_420994267 {
   char *(*post_handler)(ngx_conf_t *cf , void *data , void *conf ) ;
   char *old_name ;
   char *new_name ;
};
#line 143 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_deprecated_t_420994267 ngx_conf_deprecated_t;
#line 165 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
enum __anonenum_type_207765989 {
    parse_file = 0,
    parse_block = 1,
    parse_param = 2
} ;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 100 "src/core/ngx_file.h"
struct __anonstruct_ngx_copy_file_t_569747160 {
   off_t size ;
   size_t___0 buf_size ;
   ngx_uint_t access ;
   time_t time ;
   ngx_log_t *log ;
};
#line 100 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_copy_file_t_569747160 ngx_copy_file_t;
#line 565 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 21 "/tmp/nginx-1.13.2/src/core/ngx_parse_time.c"
enum __anonenum_fmt_28532488 {
    no = 0,
    rfc822 = 1,
    rfc850 = 2,
    isoc = 3
} ;
#line 118 "/tmp/nginx-1.13.2/src/core/ngx_parse.c"
enum __anonenum_step_271427946 {
    st_start = 0,
    st_year = 1,
    st_month = 2,
    st_week = 3,
    st_day = 4,
    st_hour = 5,
    st_min = 6,
    st_sec = 7,
    st_msec = 8,
    st_last = 9
} ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __int64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int64_t int64_t;
#line 1597 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
enum __anonenum_state_948761466 {
    sw_usual___1 = 0,
    sw_quoted___0 = 1,
    sw_quoted_second___0 = 2
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                         unsigned int __minor )  __attribute__((__const__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major = (unsigned int )((unsigned long )__major | ((__dev & 0xfffff00000000000UL) >> 32));
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor = (unsigned int )((unsigned long )__minor | ((__dev & 17592184995840UL) >> 12));
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                         unsigned int __minor )  __attribute__((__const__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                           unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 333
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
#line 484
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 495
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 496
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 506
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 524
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 603
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 616
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 38
  return (tmp);
}
}
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  {
#line 46
  tmp = _IO_getc(stdin);
  }
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 55
  if (tmp___3) {
    {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
    }
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 72
  if (tmp___3) {
    {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
    }
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  {
#line 81
  tmp = _IO_putc(__c, stdout);
  }
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 90
  if (tmp___4) {
    {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
    }
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 107
  if (tmp___4) {
    {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
    }
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 114 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  {
#line 117
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 117
  return (tmp);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 117
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
#line 360
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 360 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 363
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 363
  return ((int )tmp);
}
}
#line 365
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 365 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 368
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 368
  return (tmp);
}
}
#line 372
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 372 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  {
#line 375
  tmp = strtoll((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
                10);
  }
#line 375
  return (tmp);
}
}
#line 817
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
#line 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  {
#line 27
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
#line 27
  return (tmp);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 206
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 206 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      tmp = __ctype_tolower_loc();
#line 209
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 209
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 209
    tmp___0 = (__int32_t const   )__c;
  }
#line 209
  return ((int )tmp___0);
}
}
#line 212
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 212 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      tmp = __ctype_toupper_loc();
#line 215
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 215
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 215
    tmp___0 = (__int32_t const   )__c;
  }
#line 215
  return ((int )tmp___0);
}
}
#line 213 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 216
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 224
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
#line 239
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
#line 249
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
#line 263
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 272
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 406
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf )  __asm__("__fxstat64")  ;
#line 409
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf )  __asm__("__xstat64")  ;
#line 412
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf )  __asm__("__lxstat64")  ;
#line 415
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag )  __asm__("__fxstatat64")  ;
#line 428
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
#line 448
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
#line 448 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 451
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 451
  return (tmp);
}
}
#line 455
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
#line 455 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 458
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 458
  return (tmp);
}
}
#line 462
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
#line 462 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 465
  tmp = __fxstat(1, __fd, __statbuf);
  }
#line 465
  return (tmp);
}
}
#line 469
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
#line 469 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  {
#line 473
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  }
#line 473
  return (tmp);
}
}
#line 478
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 478 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 481
  tmp = __xmknod(0, __path, __mode, & __dev);
  }
#line 481
  return (tmp);
}
}
#line 486
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 486 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 490
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 490
  return (tmp);
}
}
#line 497
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 497 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 500
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 500
  return (tmp);
}
}
#line 504
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 504 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 507
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 507
  return (tmp);
}
}
#line 511
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
#line 511 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 514
  tmp = __fxstat64(1, __fd, __statbuf);
  }
#line 514
  return (tmp);
}
}
#line 518
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
#line 518 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  {
#line 522
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  }
#line 522
  return (tmp);
}
}
#line 302 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
#line 308
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
#line 308 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
#line 311
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 313
    return ((struct cmsghdr *)0);
  }
#line 315
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)));
#line 317
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 322
    return ((struct cmsghdr *)0);
  } else
#line 317
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 322
    return ((struct cmsghdr *)0);
  }
#line 323
  return (__cmsg);
}
}
#line 264 "src/core/ngx_log.h"
ngx_module_t ngx_errlog_module ;
#line 138 "src/core/ngx_cycle.h"
ngx_module_t ngx_core_module ;
#line 277 "src/core/ngx_module.h"
ngx_module_t *ngx_modules[49] ;
#line 280
char *ngx_module_names[49] ;
#line 9 "/tmp/nginx-1.13.2/objs/ngx_modules.c"
ngx_module_t ngx_conf_module ;
#line 10
ngx_module_t ngx_regex_module ;
#line 11
ngx_module_t ngx_events_module ;
#line 12
ngx_module_t ngx_event_core_module ;
#line 13
ngx_module_t ngx_epoll_module ;
#line 14
ngx_module_t ngx_http_module ;
#line 15
ngx_module_t ngx_http_core_module ;
#line 16
ngx_module_t ngx_http_log_module ;
#line 17
ngx_module_t ngx_http_upstream_module ;
#line 18
ngx_module_t ngx_http_static_module ;
#line 19
ngx_module_t ngx_http_autoindex_module ;
#line 20
ngx_module_t ngx_http_index_module ;
#line 21
ngx_module_t ngx_http_auth_basic_module ;
#line 22
ngx_module_t ngx_http_access_module ;
#line 23
ngx_module_t ngx_http_limit_conn_module ;
#line 24
ngx_module_t ngx_http_limit_req_module ;
#line 25
ngx_module_t ngx_http_geo_module ;
#line 26
ngx_module_t ngx_http_map_module ;
#line 27
ngx_module_t ngx_http_split_clients_module ;
#line 28
ngx_module_t ngx_http_referer_module ;
#line 29
ngx_module_t ngx_http_rewrite_module ;
#line 30
ngx_module_t ngx_http_proxy_module ;
#line 31
ngx_module_t ngx_http_fastcgi_module ;
#line 32
ngx_module_t ngx_http_uwsgi_module ;
#line 33
ngx_module_t ngx_http_scgi_module ;
#line 34
ngx_module_t ngx_http_memcached_module ;
#line 35
ngx_module_t ngx_http_empty_gif_module ;
#line 36
ngx_module_t ngx_http_browser_module ;
#line 37
ngx_module_t ngx_http_upstream_hash_module ;
#line 38
ngx_module_t ngx_http_upstream_ip_hash_module ;
#line 39
ngx_module_t ngx_http_upstream_least_conn_module ;
#line 40
ngx_module_t ngx_http_upstream_keepalive_module ;
#line 41
ngx_module_t ngx_http_upstream_zone_module ;
#line 42
ngx_module_t ngx_http_write_filter_module ;
#line 43
ngx_module_t ngx_http_header_filter_module ;
#line 44
ngx_module_t ngx_http_chunked_filter_module ;
#line 45
ngx_module_t ngx_http_range_header_filter_module ;
#line 46
ngx_module_t ngx_http_gzip_filter_module ;
#line 47
ngx_module_t ngx_http_postpone_filter_module ;
#line 48
ngx_module_t ngx_http_ssi_filter_module ;
#line 49
ngx_module_t ngx_http_charset_filter_module ;
#line 50
ngx_module_t ngx_http_userid_filter_module ;
#line 51
ngx_module_t ngx_http_headers_filter_module ;
#line 52
ngx_module_t ngx_http_copy_filter_module ;
#line 53
ngx_module_t ngx_http_range_body_filter_module ;
#line 54
ngx_module_t ngx_http_not_modified_filter_module ;
#line 56 "/tmp/nginx-1.13.2/objs/ngx_modules.c"
ngx_module_t *ngx_modules[49]  = 
#line 56
  {      & ngx_core_module,      & ngx_errlog_module,      & ngx_conf_module,      & ngx_regex_module, 
        & ngx_events_module,      & ngx_event_core_module,      & ngx_epoll_module,      & ngx_http_module, 
        & ngx_http_core_module,      & ngx_http_log_module,      & ngx_http_upstream_module,      & ngx_http_static_module, 
        & ngx_http_autoindex_module,      & ngx_http_index_module,      & ngx_http_auth_basic_module,      & ngx_http_access_module, 
        & ngx_http_limit_conn_module,      & ngx_http_limit_req_module,      & ngx_http_geo_module,      & ngx_http_map_module, 
        & ngx_http_split_clients_module,      & ngx_http_referer_module,      & ngx_http_rewrite_module,      & ngx_http_proxy_module, 
        & ngx_http_fastcgi_module,      & ngx_http_uwsgi_module,      & ngx_http_scgi_module,      & ngx_http_memcached_module, 
        & ngx_http_empty_gif_module,      & ngx_http_browser_module,      & ngx_http_upstream_hash_module,      & ngx_http_upstream_ip_hash_module, 
        & ngx_http_upstream_least_conn_module,      & ngx_http_upstream_keepalive_module,      & ngx_http_upstream_zone_module,      & ngx_http_write_filter_module, 
        & ngx_http_header_filter_module,      & ngx_http_chunked_filter_module,      & ngx_http_range_header_filter_module,      & ngx_http_gzip_filter_module, 
        & ngx_http_postpone_filter_module,      & ngx_http_ssi_filter_module,      & ngx_http_charset_filter_module,      & ngx_http_userid_filter_module, 
        & ngx_http_headers_filter_module,      & ngx_http_copy_filter_module,      & ngx_http_range_body_filter_module,      & ngx_http_not_modified_filter_module, 
        (ngx_module_t *)((void *)0)};
#line 108 "/tmp/nginx-1.13.2/objs/ngx_modules.c"
char *ngx_module_names[49]  = 
#line 108
  {      (char *)"ngx_core_module",      (char *)"ngx_errlog_module",      (char *)"ngx_conf_module",      (char *)"ngx_regex_module", 
        (char *)"ngx_events_module",      (char *)"ngx_event_core_module",      (char *)"ngx_epoll_module",      (char *)"ngx_http_module", 
        (char *)"ngx_http_core_module",      (char *)"ngx_http_log_module",      (char *)"ngx_http_upstream_module",      (char *)"ngx_http_static_module", 
        (char *)"ngx_http_autoindex_module",      (char *)"ngx_http_index_module",      (char *)"ngx_http_auth_basic_module",      (char *)"ngx_http_access_module", 
        (char *)"ngx_http_limit_conn_module",      (char *)"ngx_http_limit_req_module",      (char *)"ngx_http_geo_module",      (char *)"ngx_http_map_module", 
        (char *)"ngx_http_split_clients_module",      (char *)"ngx_http_referer_module",      (char *)"ngx_http_rewrite_module",      (char *)"ngx_http_proxy_module", 
        (char *)"ngx_http_fastcgi_module",      (char *)"ngx_http_uwsgi_module",      (char *)"ngx_http_scgi_module",      (char *)"ngx_http_memcached_module", 
        (char *)"ngx_http_empty_gif_module",      (char *)"ngx_http_browser_module",      (char *)"ngx_http_upstream_hash_module",      (char *)"ngx_http_upstream_ip_hash_module", 
        (char *)"ngx_http_upstream_least_conn_module",      (char *)"ngx_http_upstream_keepalive_module",      (char *)"ngx_http_upstream_zone_module",      (char *)"ngx_http_write_filter_module", 
        (char *)"ngx_http_header_filter_module",      (char *)"ngx_http_chunked_filter_module",      (char *)"ngx_http_range_header_filter_module",      (char *)"ngx_http_gzip_filter_module", 
        (char *)"ngx_http_postpone_filter_module",      (char *)"ngx_http_ssi_filter_module",      (char *)"ngx_http_charset_filter_module",      (char *)"ngx_http_userid_filter_module", 
        (char *)"ngx_http_headers_filter_module",      (char *)"ngx_http_copy_filter_module",      (char *)"ngx_http_range_body_filter_module",      (char *)"ngx_http_not_modified_filter_module", 
        (char *)((void *)0)};
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 149 "src/core/ngx_string.h"
u_char *ngx_sprintf(u_char *buf , char const   *fmt  , ...) ;
#line 16 "src/core/ngx_parse.h"
ssize_t ngx_parse_size(ngx_str_t *line ) ;
#line 40 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize ;
#line 63 "src/core/ngx_slab.h"
void *ngx_slab_alloc(ngx_slab_pool_t *pool , size_t___0 size ) ;
#line 66
void *ngx_slab_calloc_locked(ngx_slab_pool_t *pool , size_t___0 size ) ;
#line 131 "src/core/ngx_cycle.h"
ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf , ngx_str_t *name , size_t___0 size ,
                                      void *tag ) ;
#line 276 "src/core/ngx_conf_file.h"
void ngx_conf_log_error(ngx_uint_t level , ngx_conf_t *cf , ngx_err_t err , char const   *fmt 
                        , ...) ;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_zone_module.c"
static char *ngx_http_upstream_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 15
static ngx_int_t ngx_http_upstream_init_zone(ngx_shm_zone_t *shm_zone , void *data ) ;
#line 17
static ngx_http_upstream_rr_peers_t *ngx_http_upstream_zone_copy_peers(ngx_slab_pool_t *shpool ,
                                                                       ngx_http_upstream_srv_conf_t *uscf ) ;
#line 21 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_command_t ngx_http_upstream_zone_commands[2]  = {      {{sizeof("zone") - 1UL, (u_char *)"zone"}, (ngx_uint_t )268435462, & ngx_http_upstream_zone,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_http_module_t ngx_http_upstream_zone_module_ctx  = 
#line 34
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 49 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_zone_module.c"
ngx_module_t ngx_http_upstream_zone_module  = 
#line 49
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_zone_module_ctx),
    ngx_http_upstream_zone_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 65 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_zone_module.c"
static char *ngx_http_upstream_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ssize_t size ;
  ngx_str_t *value ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_main_conf_t *umcf ;

  {
#line 73
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 74
  umcf = (ngx_http_upstream_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_upstream_module.ctx_index);
#line 76
  value = (ngx_str_t *)(cf->args)->elts;
#line 78
  if (! (value + 1)->len) {
    {
#line 79
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone name \"%V\"", value + 1);
    }
#line 81
    return ((char *)((void *)-1));
  }
#line 84
  if ((cf->args)->nelts == 3UL) {
    {
#line 85
    size = ngx_parse_size(value + 2);
    }
#line 87
    if (size == -1L) {
      {
#line 88
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + 2);
      }
#line 90
      return ((char *)((void *)-1));
    }
#line 93
    if (size < (ssize_t )(8UL * ngx_pagesize)) {
      {
#line 94
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "zone \"%V\" is too small", value + 1);
      }
#line 96
      return ((char *)((void *)-1));
    }
  } else {
#line 100
    size = (ssize_t )0;
  }
  {
#line 103
  uscf->shm_zone = ngx_shared_memory_add(cf, value + 1, (size_t___0 )size, (void *)(& ngx_http_upstream_module));
  }
#line 105
  if ((unsigned long )uscf->shm_zone == (unsigned long )((void *)0)) {
#line 106
    return ((char *)((void *)-1));
  }
#line 109
  (uscf->shm_zone)->init = & ngx_http_upstream_init_zone;
#line 110
  (uscf->shm_zone)->data = (void *)umcf;
#line 112
  (uscf->shm_zone)->noreuse = (ngx_uint_t )1;
#line 114
  return ((char *)((void *)0));
}
}
#line 118 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_int_t ngx_http_upstream_init_zone(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_slab_pool_t *shpool ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peers_t **peersp ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;

  {
#line 128
  shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 129
  umcf = (ngx_http_upstream_main_conf_t *)shm_zone->data;
#line 130
  uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 132
  if (shm_zone->shm.exists) {
#line 133
    peers = (ngx_http_upstream_rr_peers_t *)shpool->data;
#line 135
    i = (ngx_uint_t )0;
    {
#line 135
    while (1) {
      while_continue: /* CIL Label */ ;
#line 135
      if (! (i < umcf->upstreams.nelts)) {
#line 135
        goto while_break;
      }
#line 136
      uscf = *(uscfp + i);
#line 138
      if ((unsigned long )uscf->shm_zone != (unsigned long )shm_zone) {
#line 139
        goto __Cont;
      }
#line 142
      uscf->peer.data = (void *)peers;
#line 143
      peers = peers->zone_next;
      __Cont: /* CIL Label */ 
#line 135
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 146
    return ((ngx_int_t )0);
  }
  {
#line 149
  len = sizeof(" in upstream zone \"\"") + shm_zone->shm.name.len;
#line 151
  tmp = ngx_slab_alloc(shpool, len);
#line 151
  shpool->log_ctx = (u_char *)tmp;
  }
#line 152
  if ((unsigned long )shpool->log_ctx == (unsigned long )((void *)0)) {
#line 153
    return ((ngx_int_t )-1);
  }
  {
#line 156
  ngx_sprintf(shpool->log_ctx, " in upstream zone \"%V\"%Z", & shm_zone->shm.name);
#line 162
  peersp = (ngx_http_upstream_rr_peers_t **)((void *)(& shpool->data));
#line 164
  i = (ngx_uint_t )0;
  }
  {
#line 164
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 164
    if (! (i < umcf->upstreams.nelts)) {
#line 164
      goto while_break___0;
    }
#line 165
    uscf = *(uscfp + i);
#line 167
    if ((unsigned long )uscf->shm_zone != (unsigned long )shm_zone) {
#line 168
      goto __Cont___0;
    }
    {
#line 171
    peers = ngx_http_upstream_zone_copy_peers(shpool, uscf);
    }
#line 172
    if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 173
      return ((ngx_int_t )-1);
    }
#line 176
    *peersp = peers;
#line 177
    peersp = & peers->zone_next;
    __Cont___0: /* CIL Label */ 
#line 164
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 180
  return ((ngx_int_t )0);
}
}
#line 184 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_http_upstream_rr_peers_t *ngx_http_upstream_zone_copy_peers(ngx_slab_pool_t *shpool ,
                                                                       ngx_http_upstream_srv_conf_t *uscf ) 
{ 
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t **peerp ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peers_t *backup ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 191
  tmp = ngx_slab_alloc(shpool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 191
  peers = (ngx_http_upstream_rr_peers_t *)tmp;
  }
#line 192
  if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 193
    return ((ngx_http_upstream_rr_peers_t *)((void *)0));
  }
  {
#line 196
  memcpy((void */* __restrict  */)peers, (void const   */* __restrict  */)uscf->peer.data,
         sizeof(ngx_http_upstream_rr_peers_t ));
#line 198
  peers->shpool = shpool;
#line 200
  peerp = & peers->peer;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! *peerp) {
#line 200
      goto while_break;
    }
    {
#line 202
    tmp___0 = ngx_slab_calloc_locked(shpool, sizeof(ngx_http_upstream_rr_peer_t ));
#line 202
    peer = (ngx_http_upstream_rr_peer_t *)tmp___0;
    }
#line 204
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 205
      return ((ngx_http_upstream_rr_peers_t *)((void *)0));
    }
    {
#line 208
    memcpy((void */* __restrict  */)peer, (void const   */* __restrict  */)*peerp,
           sizeof(ngx_http_upstream_rr_peer_t ));
#line 210
    *peerp = peer;
#line 200
    peerp = & peer->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if ((unsigned long )peers->next == (unsigned long )((void *)0)) {
#line 214
    goto done;
  }
  {
#line 217
  tmp___1 = ngx_slab_alloc(shpool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 217
  backup = (ngx_http_upstream_rr_peers_t *)tmp___1;
  }
#line 218
  if ((unsigned long )backup == (unsigned long )((void *)0)) {
#line 219
    return ((ngx_http_upstream_rr_peers_t *)((void *)0));
  }
  {
#line 222
  memcpy((void */* __restrict  */)backup, (void const   */* __restrict  */)peers->next,
         sizeof(ngx_http_upstream_rr_peers_t ));
#line 224
  backup->shpool = shpool;
#line 226
  peerp = & backup->peer;
  }
  {
#line 226
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 226
    if (! *peerp) {
#line 226
      goto while_break___0;
    }
    {
#line 228
    tmp___2 = ngx_slab_calloc_locked(shpool, sizeof(ngx_http_upstream_rr_peer_t ));
#line 228
    peer = (ngx_http_upstream_rr_peer_t *)tmp___2;
    }
#line 230
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 231
      return ((ngx_http_upstream_rr_peers_t *)((void *)0));
    }
    {
#line 234
    memcpy((void */* __restrict  */)peer, (void const   */* __restrict  */)*peerp,
           sizeof(ngx_http_upstream_rr_peer_t ));
#line 236
    *peerp = peer;
#line 226
    peerp = & peer->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 239
  peers->next = backup;
  done: 
#line 243
  uscf->peer.data = (void *)peers;
#line 245
  return (peers);
}
}
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 145 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t___0 __n , int __flags ) ;
#line 52 "src/core/ngx_rbtree.h"
void ngx_rbtree_delete(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) ;
#line 168 "src/core/ngx_string.h"
ngx_int_t ngx_memn2cmp(u_char *s1 , u_char *s2 , size_t___0 n1 , size_t___0 n2 ) ;
#line 172
ngx_int_t ngx_atoi(u_char *line , size_t___0 n ) ;
#line 76 "src/core/ngx_palloc.h"
void ngx_destroy_pool(ngx_pool_t *pool ) ;
#line 79
void *ngx_palloc(ngx_pool_t *pool , size_t___0 size ) ;
#line 81
void *ngx_pcalloc(ngx_pool_t *pool , size_t___0 size ) ;
#line 136 "src/core/ngx_cycle.h"
ngx_cycle_t volatile   *ngx_cycle ;
#line 47 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_exiting ;
#line 54
sig_atomic_t ngx_terminate ;
#line 213 "src/core/ngx_connection.h"
void ngx_close_connection(ngx_connection_t *c ) ;
#line 515 "src/event/ngx_event.h"
ngx_int_t ngx_handle_read_event(ngx_event_t *rev , ngx_uint_t flags ) ;
#line 28 "src/event/ngx_event_timer.h"
ngx_rbtree_t ngx_event_timer_rbtree ;
#line 31 "src/event/ngx_event_timer.h"
__inline static void ngx_event_del_timer(ngx_event_t *ev ) 
{ 


  {
  {
#line 38
  ngx_rbtree_delete(& ngx_event_timer_rbtree, & ev->timer);
#line 46
  ev->timer_set = 0U;
  }
#line 47
  return;
}
}
#line 136 "src/http/ngx_http_upstream_round_robin.h"
ngx_int_t ngx_http_upstream_init_round_robin(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_init_keepalive_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 57
static ngx_int_t ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc ,
                                                      void *data ) ;
#line 59
static void ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc , void *data ,
                                                  ngx_uint_t state ) ;
#line 62
static void ngx_http_upstream_keepalive_dummy_handler(ngx_event_t *ev ) ;
#line 63
static void ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev ) ;
#line 64
static void ngx_http_upstream_keepalive_close(ngx_connection_t *c ) ;
#line 73
static void *ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf ) ;
#line 74
static char *ngx_http_upstream_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 78 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_command_t ngx_http_upstream_keepalive_commands[2]  = {      {{sizeof("keepalive") - 1UL, (u_char *)"keepalive"}, (ngx_uint_t )268435458,
      & ngx_http_upstream_keepalive, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 91 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_http_module_t ngx_http_upstream_keepalive_module_ctx  = 
#line 91
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    & ngx_http_upstream_keepalive_create_conf, (char *(*)(ngx_conf_t *cf , void *prev ,
                                                          void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 106 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
ngx_module_t ngx_http_upstream_keepalive_module  = 
#line 106
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_keepalive_module_ctx),
    ngx_http_upstream_keepalive_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 122 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_init_keepalive(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_uint_t i ;
  ngx_http_upstream_keepalive_srv_conf_t *kcf ;
  ngx_http_upstream_keepalive_cache_t *cached ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
  {
#line 133
  kcf = (ngx_http_upstream_keepalive_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_keepalive_module.ctx_index);
#line 136
  tmp = (*(kcf->original_init_upstream))(cf, us);
  }
#line 136
  if (tmp != 0L) {
#line 137
    return ((ngx_int_t )-1);
  }
  {
#line 140
  kcf->original_init_peer = us->peer.init;
#line 142
  us->peer.init = & ngx_http_upstream_init_keepalive_peer;
#line 146
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_keepalive_cache_t ) * kcf->max_cached);
#line 146
  cached = (ngx_http_upstream_keepalive_cache_t *)tmp___0;
  }
#line 148
  if ((unsigned long )cached == (unsigned long )((void *)0)) {
#line 149
    return ((ngx_int_t )-1);
  }
#line 152
  kcf->cache.prev = & kcf->cache;
#line 152
  kcf->cache.next = & kcf->cache;
#line 153
  kcf->free.prev = & kcf->free;
#line 153
  kcf->free.next = & kcf->free;
#line 155
  i = (ngx_uint_t )0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i < kcf->max_cached)) {
#line 155
      goto while_break;
    }
#line 156
    (cached + i)->queue.next = kcf->free.next;
#line 156
    ((cached + i)->queue.next)->prev = & (cached + i)->queue;
#line 156
    (cached + i)->queue.prev = & kcf->free;
#line 156
    kcf->free.next = & (cached + i)->queue;
#line 157
    (cached + i)->conf = kcf;
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return ((ngx_int_t )0);
}
}
#line 164 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_init_keepalive_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_http_upstream_keepalive_peer_data_t *kp ;
  ngx_http_upstream_keepalive_srv_conf_t *kcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 174
  kcf = (ngx_http_upstream_keepalive_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_keepalive_module.ctx_index);
#line 177
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_keepalive_peer_data_t ));
#line 177
  kp = (ngx_http_upstream_keepalive_peer_data_t *)tmp;
  }
#line 178
  if ((unsigned long )kp == (unsigned long )((void *)0)) {
#line 179
    return ((ngx_int_t )-1);
  }
  {
#line 182
  tmp___0 = (*(kcf->original_init_peer))(r, us);
  }
#line 182
  if (tmp___0 != 0L) {
#line 183
    return ((ngx_int_t )-1);
  }
#line 186
  kp->conf = kcf;
#line 187
  kp->upstream = r->upstream;
#line 188
  kp->data = (r->upstream)->peer.data;
#line 189
  kp->original_get_peer = (r->upstream)->peer.get;
#line 190
  kp->original_free_peer = (r->upstream)->peer.free;
#line 192
  (r->upstream)->peer.data = (void *)kp;
#line 193
  (r->upstream)->peer.get = & ngx_http_upstream_get_keepalive_peer;
#line 194
  (r->upstream)->peer.free = & ngx_http_upstream_free_keepalive_peer;
#line 203
  return ((ngx_int_t )0);
}
}
#line 207 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc ,
                                                      void *data ) 
{ 
  ngx_http_upstream_keepalive_peer_data_t *kp ;
  ngx_http_upstream_keepalive_cache_t *item ;
  ngx_int_t rc ;
  ngx_queue_t *q ;
  ngx_queue_t *cache ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
  {
#line 210
  kp = (ngx_http_upstream_keepalive_peer_data_t *)data;
#line 222
  rc = (*(kp->original_get_peer))(pc, kp->data);
  }
#line 224
  if (rc != 0L) {
#line 225
    return (rc);
  }
#line 230
  cache = & (kp->conf)->cache;
#line 232
  q = cache->next;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! ((unsigned long )q != (unsigned long )cache)) {
#line 232
      goto while_break;
    }
    {
#line 236
    item = (ngx_http_upstream_keepalive_cache_t *)((u_char *)q - (unsigned long )(& ((ngx_http_upstream_keepalive_cache_t *)0)->queue));
#line 237
    c = item->connection;
#line 239
    tmp = ngx_memn2cmp((u_char *)(& item->sockaddr), (u_char *)pc->sockaddr, (size_t___0 )item->socklen,
                       (size_t___0 )pc->socklen);
    }
#line 239
    if (tmp == 0L) {
#line 243
      (q->next)->prev = q->prev;
#line 243
      (q->prev)->next = q->next;
#line 244
      q->next = (kp->conf)->free.next;
#line 244
      (q->next)->prev = q;
#line 244
      q->prev = & (kp->conf)->free;
#line 244
      (kp->conf)->free.next = q;
#line 246
      goto found;
    }
#line 232
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return ((ngx_int_t )0);
  found: 
#line 257
  c->idle = 0U;
#line 258
  c->sent = (off_t )0;
#line 259
  c->log = pc->log;
#line 260
  (c->read)->log = pc->log;
#line 261
  (c->write)->log = pc->log;
#line 262
  (c->pool)->log = pc->log;
#line 264
  pc->connection = c;
#line 265
  pc->cached = 1U;
#line 267
  return ((ngx_int_t )-4);
}
}
#line 271 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc , void *data ,
                                                  ngx_uint_t state ) 
{ 
  ngx_http_upstream_keepalive_peer_data_t *kp ;
  ngx_http_upstream_keepalive_cache_t *item ;
  ngx_queue_t *q ;
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;

  {
#line 275
  kp = (ngx_http_upstream_keepalive_peer_data_t *)data;
#line 287
  u = kp->upstream;
#line 288
  c = pc->connection;
#line 290
  if (state & 4UL) {
#line 298
    goto invalid;
  } else
#line 290
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->read)->eof) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->read)->error) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->read)->timedout) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->write)->error) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->write)->timedout) {
#line 298
    goto invalid;
  }
#line 301
  if (! u->keepalive) {
#line 302
    goto invalid;
  }
#line 305
  if (! u->request_body_sent) {
#line 306
    goto invalid;
  }
#line 309
  if (ngx_terminate) {
#line 310
    goto invalid;
  } else
#line 309
  if (ngx_exiting) {
#line 310
    goto invalid;
  }
  {
#line 313
  tmp = ngx_handle_read_event(c->read, (ngx_uint_t )0);
  }
#line 313
  if (tmp != 0L) {
#line 314
    goto invalid;
  }
#line 320
  if ((unsigned long )(& (kp->conf)->free) == (unsigned long )(kp->conf)->free.prev) {
    {
#line 322
    q = (kp->conf)->cache.prev;
#line 323
    (q->next)->prev = q->prev;
#line 323
    (q->prev)->next = q->next;
#line 325
    item = (ngx_http_upstream_keepalive_cache_t *)((u_char *)q - (unsigned long )(& ((ngx_http_upstream_keepalive_cache_t *)0)->queue));
#line 327
    ngx_http_upstream_keepalive_close(item->connection);
    }
  } else {
#line 330
    q = (kp->conf)->free.next;
#line 331
    (q->next)->prev = q->prev;
#line 331
    (q->prev)->next = q->next;
#line 333
    item = (ngx_http_upstream_keepalive_cache_t *)((u_char *)q - (unsigned long )(& ((ngx_http_upstream_keepalive_cache_t *)0)->queue));
  }
#line 336
  q->next = (kp->conf)->cache.next;
#line 336
  (q->next)->prev = q;
#line 336
  q->prev = & (kp->conf)->cache;
#line 336
  (kp->conf)->cache.next = q;
#line 338
  item->connection = c;
#line 340
  pc->connection = (ngx_connection_t *)((void *)0);
#line 342
  if ((c->read)->timer_set) {
    {
#line 343
    ngx_event_del_timer(c->read);
    }
  }
#line 345
  if ((c->write)->timer_set) {
    {
#line 346
    ngx_event_del_timer(c->write);
    }
  }
  {
#line 349
  (c->write)->handler = & ngx_http_upstream_keepalive_dummy_handler;
#line 350
  (c->read)->handler = & ngx_http_upstream_keepalive_close_handler;
#line 352
  c->data = (void *)item;
#line 353
  c->idle = 1U;
#line 354
  c->log = (ngx_log_t *)ngx_cycle->log;
#line 355
  (c->read)->log = (ngx_log_t *)ngx_cycle->log;
#line 356
  (c->write)->log = (ngx_log_t *)ngx_cycle->log;
#line 357
  (c->pool)->log = (ngx_log_t *)ngx_cycle->log;
#line 359
  item->socklen = pc->socklen;
#line 360
  memcpy((void */* __restrict  */)(& item->sockaddr), (void const   */* __restrict  */)pc->sockaddr,
         (size_t )pc->socklen);
  }
#line 362
  if ((c->read)->ready) {
    {
#line 363
    ngx_http_upstream_keepalive_close_handler(c->read);
    }
  }
  invalid: 
  {
#line 368
  (*(kp->original_free_peer))(pc, kp->data, state);
  }
#line 369
  return;
}
}
#line 372 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_keepalive_dummy_handler(ngx_event_t *ev ) 
{ 


  {
#line 377
  return;
}
}
#line 380 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev ) 
{ 
  ngx_http_upstream_keepalive_srv_conf_t *conf ;
  ngx_http_upstream_keepalive_cache_t *item ;
  int n ;
  char buf[1] ;
  ngx_connection_t *c ;
  ssize_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;

  {
#line 393
  c = (ngx_connection_t *)ev->data;
#line 395
  if (c->close) {
#line 396
    goto close;
  }
  {
#line 399
  tmp = recv(c->fd, (void *)(buf), (size_t___0 )1, 2);
#line 399
  n = (int )tmp;
  }
#line 401
  if (n == -1) {
    {
#line 401
    tmp___1 = __errno_location();
    }
#line 401
    if (*tmp___1 == 11) {
      {
#line 402
      ev->ready = 0U;
#line 404
      tmp___0 = ngx_handle_read_event(c->read, (ngx_uint_t )0);
      }
#line 404
      if (tmp___0 != 0L) {
#line 405
        goto close;
      }
#line 408
      return;
    }
  }
  close: 
  {
#line 413
  item = (ngx_http_upstream_keepalive_cache_t *)c->data;
#line 414
  conf = item->conf;
#line 416
  ngx_http_upstream_keepalive_close(c);
#line 418
  (item->queue.next)->prev = item->queue.prev;
#line 418
  (item->queue.prev)->next = item->queue.next;
#line 419
  item->queue.next = conf->free.next;
#line 419
  (item->queue.next)->prev = & item->queue;
#line 419
  item->queue.prev = & conf->free;
#line 419
  conf->free.next = & item->queue;
  }
#line 420
  return;
}
}
#line 423 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_keepalive_close(ngx_connection_t *c ) 
{ 


  {
  {
#line 441
  ngx_destroy_pool(c->pool);
#line 442
  ngx_close_connection(c);
  }
#line 443
  return;
}
}
#line 469 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void *ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_upstream_keepalive_srv_conf_t *conf ;
  void *tmp ;

  {
  {
#line 474
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_keepalive_srv_conf_t ));
#line 474
  conf = (ngx_http_upstream_keepalive_srv_conf_t *)tmp;
  }
#line 476
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 477
    return ((void *)0);
  }
#line 488
  return ((void *)conf);
}
}
#line 492 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_keepalive_module.c"
static char *ngx_http_upstream_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_keepalive_srv_conf_t *kcf ;
  ngx_int_t n ;
  ngx_str_t *value ;

  {
#line 496
  kcf = (ngx_http_upstream_keepalive_srv_conf_t *)conf;
#line 501
  if (kcf->max_cached) {
#line 502
    return ((char *)"is duplicate");
  }
  {
#line 507
  value = (ngx_str_t *)(cf->args)->elts;
#line 509
  n = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 511
  if (n == -1L) {
    {
#line 512
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\" in \"%V\" directive",
                       value + 1, & cmd->name);
    }
#line 515
    return ((char *)((void *)-1));
  } else
#line 511
  if (n == 0L) {
    {
#line 512
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\" in \"%V\" directive",
                       value + 1, & cmd->name);
    }
#line 515
    return ((char *)((void *)-1));
  }
#line 518
  kcf->max_cached = (ngx_uint_t )n;
#line 520
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 522
  if (uscf->peer.init_upstream) {
#line 522
    kcf->original_init_upstream = uscf->peer.init_upstream;
  } else {
#line 522
    kcf->original_init_upstream = & ngx_http_upstream_init_round_robin;
  }
#line 526
  uscf->peer.init_upstream = & ngx_http_upstream_init_keepalive;
#line 528
  return ((char *)((void *)0));
}
}
#line 34 "src/core/ngx_times.h"
ngx_time_t volatile   *ngx_cached_time ;
#line 16 "src/core/ngx_rwlock.h"
void ngx_rwlock_wlock(ngx_atomic_t *lock ) ;
#line 18
void ngx_rwlock_unlock(ngx_atomic_t *lock ) ;
#line 138 "src/http/ngx_http_upstream_round_robin.h"
ngx_int_t ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 142
ngx_int_t ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 15
static ngx_int_t ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc ,
                                                       void *data ) ;
#line 17
static char *ngx_http_upstream_least_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 21 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_command_t ngx_http_upstream_least_conn_commands[2]  = {      {{sizeof("least_conn") - 1UL, (u_char *)"least_conn"}, (ngx_uint_t )268435457,
      & ngx_http_upstream_least_conn, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 34 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_http_module_t ngx_http_upstream_least_conn_module_ctx  = 
#line 34
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 49 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
ngx_module_t ngx_http_upstream_least_conn_module  = 
#line 49
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_least_conn_module_ctx),
    ngx_http_upstream_least_conn_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 65 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_init_least_conn(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 72
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 72
  if (tmp != 0L) {
#line 73
    return ((ngx_int_t )-1);
  }
#line 76
  us->peer.init = & ngx_http_upstream_init_least_conn_peer;
#line 78
  return ((ngx_int_t )0);
}
}
#line 82 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 89
  tmp = ngx_http_upstream_init_round_robin_peer(r, us);
  }
#line 89
  if (tmp != 0L) {
#line 90
    return ((ngx_int_t )-1);
  }
#line 93
  (r->upstream)->peer.get = & ngx_http_upstream_get_least_conn_peer;
#line 95
  return ((ngx_int_t )0);
}
}
#line 99 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc ,
                                                       void *data ) 
{ 
  ngx_http_upstream_rr_peer_data_t *rrp ;
  time_t now ;
  uintptr_t m ;
  ngx_int_t rc ;
  ngx_int_t total ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_uint_t many ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t *best ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_int_t tmp ;

  {
#line 102
  rrp = (ngx_http_upstream_rr_peer_data_t *)data;
#line 114
  if ((rrp->peers)->single) {
    {
#line 115
    tmp = ngx_http_upstream_get_round_robin_peer(pc, (void *)rrp);
    }
#line 115
    return (tmp);
  }
#line 118
  pc->cached = 0U;
#line 119
  pc->connection = (ngx_connection_t *)((void *)0);
#line 121
  now = (time_t )ngx_cached_time->sec;
#line 123
  peers = rrp->peers;
#line 125
  if (peers->shpool) {
    {
#line 125
    ngx_rwlock_wlock(& peers->rwlock);
    }
  }
#line 127
  best = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 128
  total = (ngx_int_t )0;
#line 131
  many = (ngx_uint_t )0;
#line 132
  p = (ngx_uint_t )0;
#line 135
  peer = peers->peer;
#line 135
  i = (ngx_uint_t )0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! peer) {
#line 135
      goto while_break;
    }
#line 139
    n = i / (8UL * sizeof(uintptr_t ));
#line 140
    m = 1UL << i % (8UL * sizeof(uintptr_t ));
#line 142
    if (*(rrp->tried + n) & m) {
#line 143
      goto __Cont;
    }
#line 146
    if (peer->down) {
#line 147
      goto __Cont;
    }
#line 150
    if (peer->max_fails) {
#line 150
      if (peer->fails >= peer->max_fails) {
#line 150
        if (now - peer->checked <= peer->fail_timeout) {
#line 154
          goto __Cont;
        }
      }
    }
#line 157
    if (peer->max_conns) {
#line 157
      if (peer->conns >= peer->max_conns) {
#line 158
        goto __Cont;
      }
    }
#line 167
    if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 170
      best = peer;
#line 171
      many = (ngx_uint_t )0;
#line 172
      p = i;
    } else
#line 167
    if (peer->conns * (ngx_uint_t )best->weight < best->conns * (ngx_uint_t )peer->weight) {
#line 170
      best = peer;
#line 171
      many = (ngx_uint_t )0;
#line 172
      p = i;
    } else
#line 174
    if (peer->conns * (ngx_uint_t )best->weight == best->conns * (ngx_uint_t )peer->weight) {
#line 175
      many = (ngx_uint_t )1;
    }
    __Cont: /* CIL Label */ 
#line 135
    peer = peer->next;
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 183
    goto failed;
  }
#line 186
  if (many) {
#line 190
    peer = best;
#line 190
    i = p;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! peer) {
#line 190
        goto while_break___0;
      }
#line 194
      n = i / (8UL * sizeof(uintptr_t ));
#line 195
      m = 1UL << i % (8UL * sizeof(uintptr_t ));
#line 197
      if (*(rrp->tried + n) & m) {
#line 198
        goto __Cont___0;
      }
#line 201
      if (peer->down) {
#line 202
        goto __Cont___0;
      }
#line 205
      if (peer->conns * (ngx_uint_t )best->weight != best->conns * (ngx_uint_t )peer->weight) {
#line 206
        goto __Cont___0;
      }
#line 209
      if (peer->max_fails) {
#line 209
        if (peer->fails >= peer->max_fails) {
#line 209
          if (now - peer->checked <= peer->fail_timeout) {
#line 213
            goto __Cont___0;
          }
        }
      }
#line 216
      if (peer->max_conns) {
#line 216
        if (peer->conns >= peer->max_conns) {
#line 217
          goto __Cont___0;
        }
      }
#line 220
      peer->current_weight += peer->effective_weight;
#line 221
      total += peer->effective_weight;
#line 223
      if (peer->effective_weight < peer->weight) {
#line 224
        (peer->effective_weight) ++;
      }
#line 227
      if (peer->current_weight > best->current_weight) {
#line 228
        best = peer;
#line 229
        p = i;
      }
      __Cont___0: /* CIL Label */ 
#line 190
      peer = peer->next;
#line 190
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 234
  best->current_weight -= total;
#line 236
  if (now - best->checked > best->fail_timeout) {
#line 237
    best->checked = now;
  }
#line 240
  pc->sockaddr = best->sockaddr;
#line 241
  pc->socklen = best->socklen;
#line 242
  pc->name = & best->name;
#line 244
  (best->conns) ++;
#line 246
  rrp->current = best;
#line 248
  n = p / (8UL * sizeof(uintptr_t ));
#line 249
  m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 251
  *(rrp->tried + n) |= m;
#line 253
  if (peers->shpool) {
    {
#line 253
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 255
  return ((ngx_int_t )0);
  failed: 
#line 259
  if (peers->next) {
#line 263
    rrp->peers = peers->next;
#line 265
    n = ((rrp->peers)->number + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 268
    i = (ngx_uint_t )0;
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (i < n)) {
#line 268
        goto while_break___1;
      }
#line 269
      *(rrp->tried + i) = (uintptr_t )0;
#line 268
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 272
    if (peers->shpool) {
      {
#line 272
      ngx_rwlock_unlock(& peers->rwlock);
      }
    }
    {
#line 274
    rc = ngx_http_upstream_get_least_conn_peer(pc, (void *)rrp);
    }
#line 276
    if (rc != -3L) {
#line 277
      return (rc);
    }
#line 280
    if (peers->shpool) {
      {
#line 280
      ngx_rwlock_wlock(& peers->rwlock);
      }
    }
  }
#line 283
  if (peers->shpool) {
    {
#line 283
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 285
  pc->name = peers->name;
#line 287
  return ((ngx_int_t )-3);
}
}
#line 291 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_least_conn_module.c"
static char *ngx_http_upstream_least_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;

  {
#line 296
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 298
  if (uscf->peer.init_upstream) {
    {
#line 299
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "load balancing method redefined");
    }
  }
#line 303
  uscf->peer.init_upstream = & ngx_http_upstream_init_least_conn;
#line 305
  uscf->flags = (ngx_uint_t )319;
#line 313
  return ((char *)((void *)0));
}
}
#line 28 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 30
static ngx_int_t ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 32
static char *ngx_http_upstream_ip_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 36 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_command_t ngx_http_upstream_ip_hash_commands[2]  = {      {{sizeof("ip_hash") - 1UL, (u_char *)"ip_hash"}, (ngx_uint_t )268435457, & ngx_http_upstream_ip_hash,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 49 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_http_module_t ngx_http_upstream_ip_hash_module_ctx  = 
#line 49
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 64 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
ngx_module_t ngx_http_upstream_ip_hash_module  = 
#line 64
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_ip_hash_module_ctx),
    ngx_http_upstream_ip_hash_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 80 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static u_char ngx_http_upstream_ip_hash_pseudo_addr[3]  ;
#line 83 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_init_ip_hash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 86
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 86
  if (tmp != 0L) {
#line 87
    return ((ngx_int_t )-1);
  }
#line 90
  us->peer.init = & ngx_http_upstream_init_ip_hash_peer;
#line 92
  return ((ngx_int_t )0);
}
}
#line 96 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  ngx_http_upstream_ip_hash_peer_data_t *iphp ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 106
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_ip_hash_peer_data_t ));
#line 106
  iphp = (ngx_http_upstream_ip_hash_peer_data_t *)tmp;
  }
#line 107
  if ((unsigned long )iphp == (unsigned long )((void *)0)) {
#line 108
    return ((ngx_int_t )-1);
  }
  {
#line 111
  (r->upstream)->peer.data = (void *)(& iphp->rrp);
#line 113
  tmp___0 = ngx_http_upstream_init_round_robin_peer(r, us);
  }
#line 113
  if (tmp___0 != 0L) {
#line 114
    return ((ngx_int_t )-1);
  }
#line 117
  (r->upstream)->peer.get = & ngx_http_upstream_get_ip_hash_peer;
  {
#line 121
  if ((int )((r->connection)->sockaddr)->sa_family == 2) {
#line 121
    goto case_2;
  }
#line 128
  if ((int )((r->connection)->sockaddr)->sa_family == 10) {
#line 128
    goto case_10;
  }
#line 135
  goto switch_default;
  case_2: /* CIL Label */ 
#line 122
  sin = (struct sockaddr_in *)(r->connection)->sockaddr;
#line 123
  iphp->addr = (u_char *)(& sin->sin_addr.s_addr);
#line 124
  iphp->addrlen = (u_char )3;
#line 125
  goto switch_break;
  case_10: /* CIL Label */ 
#line 129
  sin6 = (struct sockaddr_in6 *)(r->connection)->sockaddr;
#line 130
  iphp->addr = (u_char *)(& sin6->sin6_addr.__in6_u.__u6_addr8);
#line 131
  iphp->addrlen = (u_char )16;
#line 132
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 136
  iphp->addr = ngx_http_upstream_ip_hash_pseudo_addr;
#line 137
  iphp->addrlen = (u_char )3;
  switch_break: /* CIL Label */ ;
  }
#line 140
  iphp->hash = (ngx_uint_t )89;
#line 141
  iphp->tries = (u_char )0;
#line 142
  iphp->get_rr_peer = & ngx_http_upstream_get_round_robin_peer;
#line 144
  return ((ngx_int_t )0);
}
}
#line 148 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_ip_hash_peer_data_t *iphp ;
  time_t now ;
  ngx_int_t w ;
  uintptr_t m ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_uint_t hash ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 151
  iphp = (ngx_http_upstream_ip_hash_peer_data_t *)data;
#line 164
  if ((iphp->rrp.peers)->shpool) {
    {
#line 164
    ngx_rwlock_wlock(& (iphp->rrp.peers)->rwlock);
    }
  }
#line 166
  if ((int )iphp->tries > 20) {
#line 166
    goto _L;
  } else
#line 166
  if ((iphp->rrp.peers)->single) {
    _L: /* CIL Label */ 
#line 167
    if ((iphp->rrp.peers)->shpool) {
      {
#line 167
      ngx_rwlock_unlock(& (iphp->rrp.peers)->rwlock);
      }
    }
    {
#line 168
    tmp = (*(iphp->get_rr_peer))(pc, (void *)(& iphp->rrp));
    }
#line 168
    return (tmp);
  }
#line 171
  now = (time_t )ngx_cached_time->sec;
#line 173
  pc->cached = 0U;
#line 174
  pc->connection = (ngx_connection_t *)((void *)0);
#line 176
  hash = iphp->hash;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    i = (ngx_uint_t )0;
    {
#line 180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 180
      if (! (i < (ngx_uint_t )iphp->addrlen)) {
#line 180
        goto while_break___0;
      }
#line 181
      hash = (hash * 113UL + (ngx_uint_t )*(iphp->addr + i)) % 6271UL;
#line 180
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    w = (ngx_int_t )(hash % (iphp->rrp.peers)->total_weight);
#line 185
    peer = (iphp->rrp.peers)->peer;
#line 186
    p = (ngx_uint_t )0;
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 188
      if (! (w >= peer->weight)) {
#line 188
        goto while_break___1;
      }
#line 189
      w -= peer->weight;
#line 190
      peer = peer->next;
#line 191
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 194
    n = p / (8UL * sizeof(uintptr_t ));
#line 195
    m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 197
    if (*(iphp->rrp.tried + n) & m) {
#line 198
      goto next;
    }
#line 204
    if (peer->down) {
#line 205
      goto next;
    }
#line 208
    if (peer->max_fails) {
#line 208
      if (peer->fails >= peer->max_fails) {
#line 208
        if (now - peer->checked <= peer->fail_timeout) {
#line 212
          goto next;
        }
      }
    }
#line 215
    if (peer->max_conns) {
#line 215
      if (peer->conns >= peer->max_conns) {
#line 216
        goto next;
      }
    }
#line 219
    goto while_break;
    next: 
#line 223
    iphp->tries = (u_char )((int )iphp->tries + 1);
#line 223
    if ((int )iphp->tries > 20) {
#line 224
      if ((iphp->rrp.peers)->shpool) {
        {
#line 224
        ngx_rwlock_unlock(& (iphp->rrp.peers)->rwlock);
        }
      }
      {
#line 225
      tmp___0 = (*(iphp->get_rr_peer))(pc, (void *)(& iphp->rrp));
      }
#line 225
      return (tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  iphp->rrp.current = peer;
#line 231
  pc->sockaddr = peer->sockaddr;
#line 232
  pc->socklen = peer->socklen;
#line 233
  pc->name = & peer->name;
#line 235
  (peer->conns) ++;
#line 237
  if (now - peer->checked > peer->fail_timeout) {
#line 238
    peer->checked = now;
  }
#line 241
  if ((iphp->rrp.peers)->shpool) {
    {
#line 241
    ngx_rwlock_unlock(& (iphp->rrp.peers)->rwlock);
    }
  }
#line 243
  *(iphp->rrp.tried + n) |= m;
#line 244
  iphp->hash = hash;
#line 246
  return ((ngx_int_t )0);
}
}
#line 250 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static char *ngx_http_upstream_ip_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;

  {
#line 255
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 257
  if (uscf->peer.init_upstream) {
    {
#line 258
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "load balancing method redefined");
    }
  }
#line 262
  uscf->peer.init_upstream = & ngx_http_upstream_init_ip_hash;
#line 264
  uscf->flags = (ngx_uint_t )287;
#line 271
  return ((char *)((void *)0));
}
}
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 158 "src/core/ngx_string.h"
ngx_int_t ngx_strncasecmp(u_char *s1 , u_char *s2 , size_t___0 n ) ;
#line 17 "src/core/ngx_crc32.h"
uint32_t ngx_crc32_table256[256] ;
#line 38 "src/core/ngx_crc32.h"
__inline static uint32_t ngx_crc32_long(u_char *p , size_t___0 len ) 
{ 
  uint32_t crc ;
  u_char *tmp ;
  size_t___0 tmp___0 ;

  {
#line 43
  crc = 4294967295U;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    tmp___0 = len;
#line 45
    len --;
#line 45
    if (! tmp___0) {
#line 45
      goto while_break;
    }
#line 46
    tmp = p;
#line 46
    p ++;
#line 46
    crc = ngx_crc32_table256[(crc ^ (unsigned int )*tmp) & 255U] ^ (crc >> 8);
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return (crc ^ 4294967295U);
}
}
#line 57 "src/core/ngx_crc32.h"
__inline static void ngx_crc32_update(uint32_t *crc , u_char *p , size_t___0 len ) 
{ 
  uint32_t c ;
  u_char *tmp ;
  size_t___0 tmp___0 ;

  {
#line 62
  c = *crc;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    tmp___0 = len;
#line 64
    len --;
#line 64
    if (! tmp___0) {
#line 64
      goto while_break;
    }
#line 65
    tmp = p;
#line 65
    p ++;
#line 65
    c = ngx_crc32_table256[(c ^ (unsigned int )*tmp) & 255U] ^ (c >> 8);
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  *crc = c;
#line 69
  return;
}
}
#line 17 "src/core/ngx_rwlock.h"
void ngx_rwlock_rlock(ngx_atomic_t *lock ) ;
#line 208 "src/http/ngx_http_script.h"
ngx_int_t ngx_http_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ,
                                 ngx_str_t *value ) ;
#line 210
ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv ) ;
#line 43 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_hash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
#line 45
static ngx_int_t ngx_http_upstream_init_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 47
static ngx_int_t ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 50
static ngx_int_t ngx_http_upstream_init_chash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
#line 52
static int ngx_http_upstream_chash_cmp_points(void const   *one , void const   *two ) ;
#line 54
static ngx_uint_t ngx_http_upstream_find_chash_point(ngx_http_upstream_chash_points_t *points ,
                                                     uint32_t hash ) ;
#line 56
static ngx_int_t ngx_http_upstream_init_chash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 58
static ngx_int_t ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 61
static void *ngx_http_upstream_hash_create_conf(ngx_conf_t *cf ) ;
#line 62
static char *ngx_http_upstream_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 66 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_command_t ngx_http_upstream_hash_commands[2]  = {      {{sizeof("hash") - 1UL, (u_char *)"hash"}, (ngx_uint_t )268435462, & ngx_http_upstream_hash,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 79 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_http_module_t ngx_http_upstream_hash_module_ctx  = 
#line 79
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    & ngx_http_upstream_hash_create_conf, (char *(*)(ngx_conf_t *cf , void *prev ,
                                                     void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 94 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
ngx_module_t ngx_http_upstream_hash_module  = 
#line 94
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_hash_module_ctx),
    ngx_http_upstream_hash_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 110 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_hash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 113
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 113
  if (tmp != 0L) {
#line 114
    return ((ngx_int_t )-1);
  }
#line 117
  us->peer.init = & ngx_http_upstream_init_hash_peer;
#line 119
  return ((ngx_int_t )0);
}
}
#line 123 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  ngx_http_upstream_hash_peer_data_t *hp ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 130
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_hash_peer_data_t ));
#line 130
  hp = (ngx_http_upstream_hash_peer_data_t *)tmp;
  }
#line 131
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 132
    return ((ngx_int_t )-1);
  }
  {
#line 135
  (r->upstream)->peer.data = (void *)(& hp->rrp);
#line 137
  tmp___0 = ngx_http_upstream_init_round_robin_peer(r, us);
  }
#line 137
  if (tmp___0 != 0L) {
#line 138
    return ((ngx_int_t )-1);
  }
  {
#line 141
  (r->upstream)->peer.get = & ngx_http_upstream_get_hash_peer;
#line 143
  hcf = (ngx_http_upstream_hash_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_hash_module.ctx_index);
#line 145
  tmp___1 = ngx_http_complex_value(r, & hcf->key, & hp->key);
  }
#line 145
  if (tmp___1 != 0L) {
#line 146
    return ((ngx_int_t )-1);
  }
#line 152
  hp->conf = hcf;
#line 153
  hp->tries = (ngx_uint_t )0;
#line 154
  hp->rehash = (ngx_uint_t )0;
#line 155
  hp->hash = (uint32_t )0;
#line 156
  hp->get_rr_peer = & ngx_http_upstream_get_round_robin_peer;
#line 158
  return ((ngx_int_t )0);
}
}
#line 162 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_hash_peer_data_t *hp ;
  time_t now ;
  u_char buf[sizeof("-9223372036854775808") - 1UL] ;
  size_t___0 size ;
  uint32_t hash ;
  ngx_int_t w ;
  uintptr_t m ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 165
  hp = (ngx_http_upstream_hash_peer_data_t *)data;
#line 179
  if ((hp->rrp.peers)->shpool) {
    {
#line 179
    ngx_rwlock_wlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 181
  if (hp->tries > 20UL) {
#line 181
    goto _L;
  } else
#line 181
  if ((hp->rrp.peers)->single) {
    _L: /* CIL Label */ 
#line 182
    if ((hp->rrp.peers)->shpool) {
      {
#line 182
      ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
      }
    }
    {
#line 183
    tmp = (*(hp->get_rr_peer))(pc, (void *)(& hp->rrp));
    }
#line 183
    return (tmp);
  }
#line 186
  now = (time_t )ngx_cached_time->sec;
#line 188
  pc->cached = 0U;
#line 189
  pc->connection = (ngx_connection_t *)((void *)0);
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    hash = 4294967295U;
#line 201
    if (hp->rehash > 0UL) {
      {
#line 202
      tmp___0 = ngx_sprintf(buf, "%ui", hp->rehash);
#line 202
      size = (size_t___0 )(tmp___0 - buf);
#line 203
      ngx_crc32_update(& hash, buf, size);
      }
    }
    {
#line 206
    ngx_crc32_update(& hash, hp->key.data, hp->key.len);
#line 207
    hash ^= 4294967295U;
#line 209
    hash = (hash >> 16) & 32767U;
#line 211
    hp->hash += hash;
#line 212
    (hp->rehash) ++;
#line 214
    w = (ngx_int_t )((unsigned long )hp->hash % (hp->rrp.peers)->total_weight);
#line 215
    peer = (hp->rrp.peers)->peer;
#line 216
    p = (ngx_uint_t )0;
    }
    {
#line 218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 218
      if (! (w >= peer->weight)) {
#line 218
        goto while_break___0;
      }
#line 219
      w -= peer->weight;
#line 220
      peer = peer->next;
#line 221
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    n = p / (8UL * sizeof(uintptr_t ));
#line 225
    m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 227
    if (*(hp->rrp.tried + n) & m) {
#line 228
      goto next;
    }
#line 234
    if (peer->down) {
#line 235
      goto next;
    }
#line 238
    if (peer->max_fails) {
#line 238
      if (peer->fails >= peer->max_fails) {
#line 238
        if (now - peer->checked <= peer->fail_timeout) {
#line 242
          goto next;
        }
      }
    }
#line 245
    if (peer->max_conns) {
#line 245
      if (peer->conns >= peer->max_conns) {
#line 246
        goto next;
      }
    }
#line 249
    goto while_break;
    next: 
#line 253
    (hp->tries) ++;
#line 253
    if (hp->tries > 20UL) {
#line 254
      if ((hp->rrp.peers)->shpool) {
        {
#line 254
        ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
        }
      }
      {
#line 255
      tmp___1 = (*(hp->get_rr_peer))(pc, (void *)(& hp->rrp));
      }
#line 255
      return (tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  hp->rrp.current = peer;
#line 261
  pc->sockaddr = peer->sockaddr;
#line 262
  pc->socklen = peer->socklen;
#line 263
  pc->name = & peer->name;
#line 265
  (peer->conns) ++;
#line 267
  if (now - peer->checked > peer->fail_timeout) {
#line 268
    peer->checked = now;
  }
#line 271
  if ((hp->rrp.peers)->shpool) {
    {
#line 271
    ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 273
  *(hp->rrp.tried + n) |= m;
#line 275
  return ((ngx_int_t )0);
}
}
#line 279 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_chash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  u_char *host ;
  u_char *port ;
  u_char c ;
  size_t___0 host_len ;
  size_t___0 port_len ;
  size_t___0 size ;
  uint32_t hash ;
  uint32_t base_hash ;
  ngx_str_t *server ;
  ngx_uint_t npoints ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_chash_points_t *points ;
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  union __anonunion_prev_hash_923928396 prev_hash ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 296
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 296
  if (tmp != 0L) {
#line 297
    return ((ngx_int_t )-1);
  }
  {
#line 300
  us->peer.init = & ngx_http_upstream_init_chash_peer;
#line 302
  peers = (ngx_http_upstream_rr_peers_t *)us->peer.data;
#line 303
  npoints = peers->total_weight * 160UL;
#line 305
  size = sizeof(ngx_http_upstream_chash_points_t ) + sizeof(ngx_http_upstream_chash_point_t ) * (npoints - 1UL);
#line 308
  tmp___0 = ngx_palloc(cf->pool, size);
#line 308
  points = (ngx_http_upstream_chash_points_t *)tmp___0;
  }
#line 309
  if ((unsigned long )points == (unsigned long )((void *)0)) {
#line 310
    return ((ngx_int_t )-1);
  }
#line 313
  points->number = (ngx_uint_t )0;
#line 315
  peer = peers->peer;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! peer) {
#line 315
      goto while_break;
    }
#line 316
    server = & peer->server;
#line 323
    if (server->len >= 5UL) {
      {
#line 323
      tmp___1 = ngx_strncasecmp(server->data, (u_char *)"unix:", (size_t___0 )5);
      }
#line 323
      if (tmp___1 == 0L) {
#line 326
        host = server->data + 5;
#line 327
        host_len = server->len - 5UL;
#line 328
        port = (u_char *)((void *)0);
#line 329
        port_len = (size_t___0 )0;
#line 330
        goto done;
      }
    }
#line 333
    j = (ngx_uint_t )0;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! (j < server->len)) {
#line 333
        goto while_break___0;
      }
#line 334
      c = *(server->data + ((server->len - j) - 1UL));
#line 336
      if ((int )c == 58) {
#line 337
        host = server->data;
#line 338
        host_len = (server->len - j) - 1UL;
#line 339
        port = (server->data + server->len) - j;
#line 340
        port_len = j;
#line 341
        goto done;
      }
#line 344
      if ((int )c < 48) {
#line 345
        goto while_break___0;
      } else
#line 344
      if ((int )c > 57) {
#line 345
        goto while_break___0;
      }
#line 333
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 349
    host = server->data;
#line 350
    host_len = server->len;
#line 351
    port = (u_char *)((void *)0);
#line 352
    port_len = (size_t___0 )0;
    done: 
    {
#line 356
    base_hash = 4294967295U;
#line 357
    ngx_crc32_update(& base_hash, host, host_len);
#line 358
    ngx_crc32_update(& base_hash, (u_char *)"", (size_t___0 )1);
#line 359
    ngx_crc32_update(& base_hash, port, port_len);
#line 361
    prev_hash.value = (uint32_t )0;
#line 362
    npoints = (ngx_uint_t )(peer->weight * 160L);
#line 364
    j = (ngx_uint_t )0;
    }
    {
#line 364
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! (j < npoints)) {
#line 364
        goto while_break___1;
      }
      {
#line 365
      hash = base_hash;
#line 367
      ngx_crc32_update(& hash, prev_hash.byte, (size_t___0 )4);
#line 368
      hash ^= 4294967295U;
#line 370
      points->point[points->number].hash = hash;
#line 371
      points->point[points->number].server = server;
#line 372
      (points->number) ++;
#line 375
      prev_hash.value = hash;
#line 364
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 315
    peer = peer->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  qsort((void *)(points->point), points->number, sizeof(ngx_http_upstream_chash_point_t ),
        & ngx_http_upstream_chash_cmp_points);
#line 390
  i = (ngx_uint_t )0;
#line 390
  j = (ngx_uint_t )1;
  }
  {
#line 390
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 390
    if (! (j < points->number)) {
#line 390
      goto while_break___2;
    }
#line 391
    if (points->point[i].hash != points->point[j].hash) {
#line 392
      i ++;
#line 392
      points->point[i] = points->point[j];
    }
#line 390
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 396
  points->number = i + 1UL;
#line 398
  hcf = (ngx_http_upstream_hash_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_hash_module.ctx_index);
#line 399
  hcf->points = points;
#line 401
  return ((ngx_int_t )0);
}
}
#line 405 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static int ngx_http_upstream_chash_cmp_points(void const   *one , void const   *two ) 
{ 
  ngx_http_upstream_chash_point_t *first ;
  ngx_http_upstream_chash_point_t *second ;

  {
#line 408
  first = (ngx_http_upstream_chash_point_t *)one;
#line 410
  second = (ngx_http_upstream_chash_point_t *)two;
#line 413
  if (first->hash < second->hash) {
#line 414
    return (-1);
  } else
#line 416
  if (first->hash > second->hash) {
#line 417
    return (1);
  } else {
#line 420
    return (0);
  }
}
}
#line 425 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_uint_t ngx_http_upstream_find_chash_point(ngx_http_upstream_chash_points_t *points ,
                                                     uint32_t hash ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t k ;
  ngx_http_upstream_chash_point_t *point ;

  {
#line 434
  point = & points->point[0];
#line 436
  i = (ngx_uint_t )0;
#line 437
  j = points->number;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! (i < j)) {
#line 439
      goto while_break;
    }
#line 440
    k = (i + j) / 2UL;
#line 442
    if (hash > (point + k)->hash) {
#line 443
      i = k + 1UL;
    } else
#line 445
    if (hash < (point + k)->hash) {
#line 446
      j = k;
    } else {
#line 449
      return (k);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return (i);
}
}
#line 457 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_chash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  uint32_t hash ;
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  ngx_http_upstream_hash_peer_data_t *hp ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;

  {
  {
#line 465
  tmp = ngx_http_upstream_init_hash_peer(r, us);
  }
#line 465
  if (tmp != 0L) {
#line 466
    return ((ngx_int_t )-1);
  }
  {
#line 469
  (r->upstream)->peer.get = & ngx_http_upstream_get_chash_peer;
#line 471
  hp = (ngx_http_upstream_hash_peer_data_t *)(r->upstream)->peer.data;
#line 472
  hcf = (ngx_http_upstream_hash_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_hash_module.ctx_index);
#line 474
  hash = ngx_crc32_long(hp->key.data, hp->key.len);
  }
#line 476
  if ((hp->rrp.peers)->shpool) {
    {
#line 476
    ngx_rwlock_rlock(& (hp->rrp.peers)->rwlock);
    }
  }
  {
#line 478
  tmp___0 = ngx_http_upstream_find_chash_point(hcf->points, hash);
#line 478
  hp->hash = (uint32_t )tmp___0;
  }
#line 480
  if ((hp->rrp.peers)->shpool) {
    {
#line 480
    ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 482
  return ((ngx_int_t )0);
}
}
#line 486 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_hash_peer_data_t *hp ;
  time_t now ;
  intptr_t m ;
  ngx_str_t *server ;
  ngx_int_t total ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t best_i ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t *best ;
  ngx_http_upstream_chash_point_t *point ;
  ngx_http_upstream_chash_points_t *points ;
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  int tmp ;

  {
#line 489
  hp = (ngx_http_upstream_hash_peer_data_t *)data;
#line 504
  if ((hp->rrp.peers)->shpool) {
    {
#line 504
    ngx_rwlock_wlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 506
  pc->cached = 0U;
#line 507
  pc->connection = (ngx_connection_t *)((void *)0);
#line 509
  now = (time_t )ngx_cached_time->sec;
#line 510
  hcf = hp->conf;
#line 512
  points = hcf->points;
#line 513
  point = & points->point[0];
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    server = (point + (unsigned long )hp->hash % points->number)->server;
#line 522
    best = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 523
    best_i = (ngx_uint_t )0;
#line 524
    total = (ngx_int_t )0;
#line 526
    peer = (hp->rrp.peers)->peer;
#line 526
    i = (ngx_uint_t )0;
    {
#line 526
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 526
      if (! peer) {
#line 526
        goto while_break___0;
      }
#line 530
      n = i / (8UL * sizeof(uintptr_t ));
#line 531
      m = (intptr_t )(1UL << i % (8UL * sizeof(uintptr_t )));
#line 533
      if (*(hp->rrp.tried + n) & (unsigned long )m) {
#line 534
        goto __Cont;
      }
#line 537
      if (peer->down) {
#line 538
        goto __Cont;
      }
#line 541
      if (peer->server.len != server->len) {
#line 545
        goto __Cont;
      } else {
        {
#line 541
        tmp = strncmp((char const   *)peer->server.data, (char const   *)server->data,
                      server->len);
        }
#line 541
        if (tmp != 0) {
#line 545
          goto __Cont;
        }
      }
#line 548
      if (peer->max_fails) {
#line 548
        if (peer->fails >= peer->max_fails) {
#line 548
          if (now - peer->checked <= peer->fail_timeout) {
#line 552
            goto __Cont;
          }
        }
      }
#line 555
      if (peer->max_conns) {
#line 555
        if (peer->conns >= peer->max_conns) {
#line 556
          goto __Cont;
        }
      }
#line 559
      peer->current_weight += peer->effective_weight;
#line 560
      total += peer->effective_weight;
#line 562
      if (peer->effective_weight < peer->weight) {
#line 563
        (peer->effective_weight) ++;
      }
#line 566
      if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 567
        best = peer;
#line 568
        best_i = i;
      } else
#line 566
      if (peer->current_weight > best->current_weight) {
#line 567
        best = peer;
#line 568
        best_i = i;
      }
      __Cont: /* CIL Label */ 
#line 526
      peer = peer->next;
#line 526
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 572
    if (best) {
#line 573
      best->current_weight -= total;
#line 574
      goto found;
    }
#line 577
    (hp->hash) ++;
#line 578
    (hp->tries) ++;
#line 580
    if (hp->tries >= points->number) {
#line 581
      pc->name = (hp->rrp.peers)->name;
#line 582
      if ((hp->rrp.peers)->shpool) {
        {
#line 582
        ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
        }
      }
#line 583
      return ((ngx_int_t )-3);
    }
  }
  while_break: /* CIL Label */ ;
  }
  found: 
#line 589
  hp->rrp.current = best;
#line 591
  pc->sockaddr = best->sockaddr;
#line 592
  pc->socklen = best->socklen;
#line 593
  pc->name = & best->name;
#line 595
  (best->conns) ++;
#line 597
  if (now - best->checked > best->fail_timeout) {
#line 598
    best->checked = now;
  }
#line 601
  if ((hp->rrp.peers)->shpool) {
    {
#line 601
    ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 603
  n = best_i / (8UL * sizeof(uintptr_t ));
#line 604
  m = (intptr_t )(1UL << best_i % (8UL * sizeof(uintptr_t )));
#line 606
  *(hp->rrp.tried + n) |= (unsigned long )m;
#line 608
  return ((ngx_int_t )0);
}
}
#line 612 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static void *ngx_http_upstream_hash_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_upstream_hash_srv_conf_t *conf ;
  void *tmp ;

  {
  {
#line 617
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_upstream_hash_srv_conf_t ));
#line 617
  conf = (ngx_http_upstream_hash_srv_conf_t *)tmp;
  }
#line 618
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 619
    return ((void *)0);
  }
#line 622
  conf->points = (ngx_http_upstream_chash_points_t *)((void *)0);
#line 624
  return ((void *)conf);
}
}
#line 628 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_upstream_hash_module.c"
static char *ngx_http_upstream_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  ngx_str_t *value ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  int tmp___0 ;

  {
  {
#line 631
  hcf = (ngx_http_upstream_hash_srv_conf_t *)conf;
#line 637
  value = (ngx_str_t *)(cf->args)->elts;
#line 639
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 641
  ccv.cf = cf;
#line 642
  ccv.value = value + 1;
#line 643
  ccv.complex_value = & hcf->key;
#line 645
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 645
  if (tmp != 0L) {
#line 646
    return ((char *)((void *)-1));
  }
#line 649
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 651
  if (uscf->peer.init_upstream) {
    {
#line 652
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "load balancing method redefined");
    }
  }
#line 656
  uscf->flags = (ngx_uint_t )287;
#line 663
  if ((cf->args)->nelts == 2UL) {
#line 664
    uscf->peer.init_upstream = & ngx_http_upstream_init_hash;
  } else {
    {
#line 666
    tmp___0 = strcmp((char const   *)(value + 2)->data, "consistent");
    }
#line 666
    if (tmp___0 == 0) {
#line 667
      uscf->peer.init_upstream = & ngx_http_upstream_init_chash;
    } else {
      {
#line 670
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 2);
      }
#line 672
      return ((char *)((void *)-1));
    }
  }
#line 675
  return ((char *)((void *)0));
}
}
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 147 "src/core/ngx_string.h"
u_char *ngx_cpystrn(u_char *dst , u_char *src , size_t___0 n ) ;
#line 157
ngx_int_t ngx_strcasecmp(u_char *s1 , u_char *s2 ) ;
#line 25 "src/core/ngx_array.h"
ngx_array_t *ngx_array_create(ngx_pool_t *p , ngx_uint_t n , size_t___0 size ) ;
#line 27
void *ngx_array_push(ngx_array_t *a ) ;
#line 47 "src/http/ngx_http_variables.h"
ngx_http_variable_t *ngx_http_add_variable(ngx_conf_t *cf , ngx_str_t *name , ngx_uint_t flags ) ;
#line 110
ngx_http_variable_value_t ngx_http_variable_null_value ;
#line 111
ngx_http_variable_value_t ngx_http_variable_true_value ;
#line 58 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_msie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 60
static ngx_int_t ngx_http_browser_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 63
static ngx_uint_t ngx_http_browser(ngx_http_request_t *r , ngx_http_browser_conf_t *cf ) ;
#line 66
static ngx_int_t ngx_http_browser_add_variable(ngx_conf_t *cf ) ;
#line 67
static void *ngx_http_browser_create_conf(ngx_conf_t *cf ) ;
#line 68
static char *ngx_http_browser_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 70
static int ngx_http_modern_browser_sort(void const   *one , void const   *two ) ;
#line 72
static char *ngx_http_modern_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 74
static char *ngx_http_ancient_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 76
static char *ngx_http_modern_browser_value(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 78
static char *ngx_http_ancient_browser_value(ngx_conf_t *cf , ngx_command_t *cmd ,
                                            void *conf ) ;
#line 82 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_command_t ngx_http_browser_commands[5]  = {      {{sizeof("modern_browser") - 1UL, (u_char *)"modern_browser"}, (ngx_uint_t )234881030,
      & ngx_http_modern_browser, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("ancient_browser") - 1UL, (u_char *)"ancient_browser"}, (ngx_uint_t )234883072,
      & ngx_http_ancient_browser, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("modern_browser_value") - 1UL, (u_char *)"modern_browser_value"}, (ngx_uint_t )234881026,
      & ngx_http_modern_browser_value, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("ancient_browser_value") - 1UL, (u_char *)"ancient_browser_value"},
      (ngx_uint_t )234881026, & ngx_http_ancient_browser_value, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 116 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_http_module_t ngx_http_browser_module_ctx  = 
#line 116
     {& ngx_http_browser_add_variable, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_browser_create_conf, & ngx_http_browser_merge_conf};
#line 131 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
ngx_module_t ngx_http_browser_module  = 
#line 131
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_browser_module_ctx),
    ngx_http_browser_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 147 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_http_modern_browser_mask_t ngx_http_modern_browser_masks[6]  = {      {{(u_char )'o', (u_char )'p', (u_char )'e', (u_char )'r', (u_char )'a', (u_char )'\000'},
      (size_t___0 )0, sizeof("Opera ") - 1UL, {(u_char )'O', (u_char )'p', (u_char )'e',
                                               (u_char )'r', (u_char )'a', (u_char )'\000'}}, 
        {{(u_char )'m',
       (u_char )'s', (u_char )'i', (u_char )'e', (u_char )'\000'}, sizeof("Mozilla/4.0 (compatible; ") - 1UL,
      sizeof("MSIE ") - 1UL, {(u_char )'M', (u_char )'S', (u_char )'I', (u_char )'E',
                              (u_char )' ', (u_char )'\000'}}, 
        {{(u_char )'g', (u_char )'e', (u_char )'c', (u_char )'k', (u_char )'o', (u_char )'\000'},
      sizeof("Mozilla/5.0 (") - 1UL, sizeof("rv:") - 1UL, {(u_char )'r', (u_char )'v',
                                                           (u_char )':', (u_char )'\000'}}, 
        {{(u_char )'s',
       (u_char )'a', (u_char )'f', (u_char )'a', (u_char )'r', (u_char )'i', (u_char )'\000'},
      sizeof("Mozilla/5.0 (") - 1UL, sizeof("Safari/") - 1UL, {(u_char )'S', (u_char )'a',
                                                               (u_char )'f', (u_char )'a',
                                                               (u_char )'r', (u_char )'i',
                                                               (u_char )'/', (u_char )'\000'}}, 
        {{(u_char )'k',
       (u_char )'o', (u_char )'n', (u_char )'q', (u_char )'u', (u_char )'e', (u_char )'r',
       (u_char )'o', (u_char )'r', (u_char )'\000'}, sizeof("Mozilla/5.0 (compatible; ") - 1UL,
      sizeof("Konqueror/") - 1UL, {(u_char )'K', (u_char )'o', (u_char )'n', (u_char )'q',
                                   (u_char )'u', (u_char )'e', (u_char )'r', (u_char )'o',
                                   (u_char )'r', (u_char )'/', (u_char )'\000'}}, 
        {{(u_char )'\000'}, (size_t___0 )0, (size_t___0 )0, {(u_char )'\000'}}};
#line 221 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_http_browser_variable_t ngx_http_browsers[4]  = {      {{sizeof("msie") - 1UL, (u_char *)"msie"}, & ngx_http_msie_variable, (uintptr_t )0}, 
        {{sizeof("modern_browser") - 1UL,
       (u_char *)"modern_browser"}, & ngx_http_browser_variable, (uintptr_t )0}, 
        {{sizeof("ancient_browser") - 1UL, (u_char *)"ancient_browser"}, & ngx_http_browser_variable,
      (uintptr_t )1}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ))((void *)0),
      (uintptr_t )0}};
#line 231 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_browser_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_uint_t rc ;
  ngx_http_browser_conf_t *cf ;

  {
  {
#line 238
  cf = (ngx_http_browser_conf_t *)*(r->loc_conf + ngx_http_browser_module.ctx_index);
#line 240
  rc = ngx_http_browser(r, cf);
  }
#line 242
  if (data == 0UL) {
#line 242
    if (rc == 0UL) {
#line 243
      *v = *(cf->modern_browser_value);
#line 244
      return ((ngx_int_t )0);
    }
  }
#line 247
  if (data == 1UL) {
#line 247
    if (rc == 1UL) {
#line 248
      *v = *(cf->ancient_browser_value);
#line 249
      return ((ngx_int_t )0);
    }
  }
#line 252
  *v = ngx_http_variable_null_value;
#line 253
  return ((ngx_int_t )0);
}
}
#line 257 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_uint_t ngx_http_browser(ngx_http_request_t *r , ngx_http_browser_conf_t *cf ) 
{ 
  size_t___0 len ;
  u_char *name ;
  u_char *ua ;
  u_char *last ;
  u_char c ;
  ngx_str_t *ancient ;
  ngx_uint_t i ;
  ngx_uint_t version ;
  ngx_uint_t ver ;
  ngx_uint_t scale ;
  ngx_http_modern_browser_t *modern ;
  char *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 266
  if ((unsigned long )r->headers_in.user_agent == (unsigned long )((void *)0)) {
#line 267
    if (cf->modern_unlisted_browsers) {
#line 268
      return ((ngx_uint_t )0);
    }
#line 271
    return ((ngx_uint_t )1);
  }
#line 274
  ua = (r->headers_in.user_agent)->value.data;
#line 275
  len = (r->headers_in.user_agent)->value.len;
#line 276
  last = ua + len;
#line 278
  if (cf->modern_browsers) {
#line 279
    modern = (ngx_http_modern_browser_t *)(cf->modern_browsers)->elts;
#line 281
    i = (ngx_uint_t )0;
    {
#line 281
    while (1) {
      while_continue: /* CIL Label */ ;
#line 281
      if (! (i < (cf->modern_browsers)->nelts)) {
#line 281
        goto while_break;
      }
#line 282
      name = ua + (modern + i)->skip;
#line 284
      if ((unsigned long )name >= (unsigned long )last) {
#line 285
        goto __Cont;
      }
      {
#line 288
      tmp = strstr((char const   *)name, (char const   *)((modern + i)->name));
#line 288
      name = (u_char *)tmp;
      }
#line 290
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 291
        goto __Cont;
      }
#line 297
      name += (modern + i)->add;
#line 299
      if ((unsigned long )name >= (unsigned long )last) {
#line 300
        goto __Cont;
      }
#line 306
      version = (ngx_uint_t )0;
#line 307
      ver = (ngx_uint_t )0;
#line 308
      scale = (ngx_uint_t )1000000;
      {
#line 310
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 310
        if (! ((unsigned long )name < (unsigned long )last)) {
#line 310
          goto while_break___0;
        }
#line 312
        tmp___0 = name;
#line 312
        name ++;
#line 312
        c = *tmp___0;
#line 314
        if ((int )c >= 48) {
#line 314
          if ((int )c <= 57) {
#line 315
            ver = ver * 10UL + (ngx_uint_t )((int )c - 48);
#line 316
            goto while_continue___0;
          }
        }
#line 319
        if ((int )c == 46) {
#line 320
          version += ver * scale;
#line 326
          if (version > (modern + i)->version) {
#line 327
            return ((ngx_uint_t )0);
          }
#line 330
          ver = (ngx_uint_t )0;
#line 331
          scale /= 100UL;
#line 332
          goto while_continue___0;
        }
#line 335
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 338
      version += ver * scale;
#line 344
      if (version >= (modern + i)->version) {
#line 345
        return ((ngx_uint_t )0);
      }
#line 348
      return ((ngx_uint_t )1);
      __Cont: /* CIL Label */ 
#line 281
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 351
    if (! cf->modern_unlisted_browsers) {
#line 352
      return ((ngx_uint_t )1);
    }
  }
#line 356
  if (cf->netscape4) {
#line 357
    if (len > sizeof("Mozilla/4.72 ") - 1UL) {
      {
#line 357
      tmp___1 = strncmp((char const   *)ua, "Mozilla/", sizeof("Mozilla/") - 1UL);
      }
#line 357
      if (tmp___1 == 0) {
#line 357
        if ((int )*(ua + 8) > 48) {
#line 357
          if ((int )*(ua + 8) < 53) {
#line 361
            return ((ngx_uint_t )1);
          }
        }
      }
    }
  }
#line 365
  if (cf->ancient_browsers) {
#line 366
    ancient = (ngx_str_t *)(cf->ancient_browsers)->elts;
#line 368
    i = (ngx_uint_t )0;
    {
#line 368
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 368
      if (! (i < (cf->ancient_browsers)->nelts)) {
#line 368
        goto while_break___1;
      }
#line 369
      if (len >= (ancient + i)->len) {
        {
#line 369
        tmp___2 = strstr((char const   *)ua, (char const   *)(ancient + i)->data);
        }
#line 369
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 372
          return ((ngx_uint_t )1);
        }
      }
#line 368
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 377
  if (cf->modern_unlisted_browsers) {
#line 378
    return ((ngx_uint_t )0);
  }
#line 381
  return ((ngx_uint_t )1);
}
}
#line 385 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_msie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 


  {
#line 389
  if (r->headers_in.msie) {
#line 390
    *v = ngx_http_variable_true_value;
#line 391
    return ((ngx_int_t )0);
  }
#line 394
  *v = ngx_http_variable_null_value;
#line 395
  return ((ngx_int_t )0);
}
}
#line 399 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_browser_add_variable(ngx_conf_t *cf ) 
{ 
  ngx_http_browser_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 405
  var = ngx_http_browsers;
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 405
    if (! var->name.len) {
#line 405
      goto while_break;
    }
    {
#line 407
    v = ngx_http_add_variable(cf, & var->name, (ngx_uint_t )1);
    }
#line 408
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 409
      return ((ngx_int_t )-1);
    }
#line 412
    v->get_handler = var->handler;
#line 413
    v->data = var->data;
#line 405
    var ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return ((ngx_int_t )0);
}
}
#line 420 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static void *ngx_http_browser_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_browser_conf_t *conf ;
  void *tmp ;

  {
  {
#line 425
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_browser_conf_t ));
#line 425
  conf = (ngx_http_browser_conf_t *)tmp;
  }
#line 426
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 427
    return ((void *)0);
  }
#line 442
  return ((void *)conf);
}
}
#line 446 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_browser_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_browser_conf_t *prev ;
  ngx_http_browser_conf_t *conf ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_modern_browser_t *browsers ;
  ngx_http_modern_browser_t *opera ;
  void *tmp ;

  {
#line 449
  prev = (ngx_http_browser_conf_t *)parent;
#line 450
  conf = (ngx_http_browser_conf_t *)child;
#line 461
  if ((unsigned long )conf->modern_browsers == (unsigned long )((void *)0)) {
#line 461
    if (conf->modern_unlisted_browsers == 0U) {
#line 462
      conf->modern_browsers = prev->modern_browsers;
#line 463
      conf->modern_unlisted_browsers = prev->modern_unlisted_browsers;
    } else {
#line 461
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 465
  if ((unsigned long )conf->modern_browsers != (unsigned long )((void *)0)) {
#line 466
    browsers = (ngx_http_modern_browser_t *)(conf->modern_browsers)->elts;
#line 468
    i = (ngx_uint_t )0;
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      if (! (i < (conf->modern_browsers)->nelts)) {
#line 468
        goto while_break;
      }
#line 469
      if ((browsers + i)->skip == 0UL) {
#line 470
        goto found;
      }
#line 468
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 479
    tmp = ngx_array_push(conf->modern_browsers);
#line 479
    opera = (ngx_http_modern_browser_t *)tmp;
    }
#line 480
    if ((unsigned long )opera == (unsigned long )((void *)0)) {
#line 481
      return ((char *)((void *)-1));
    }
#line 484
    opera->skip = (size_t___0 )0;
#line 485
    opera->version = (ngx_uint_t )4001000000U;
#line 487
    browsers = (ngx_http_modern_browser_t *)(conf->modern_browsers)->elts;
    found: 
    {
#line 491
    qsort((void *)browsers, (conf->modern_browsers)->nelts, sizeof(ngx_http_modern_browser_t ),
          & ngx_http_modern_browser_sort);
#line 495
    i = (ngx_uint_t )0;
    }
    {
#line 495
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 495
      if (! (i < (conf->modern_browsers)->nelts)) {
#line 495
        goto while_break___0;
      }
      {
#line 496
      n = (browsers + i)->skip;
#line 498
      (browsers + i)->skip = ngx_http_modern_browser_masks[n].skip;
#line 499
      (browsers + i)->add = ngx_http_modern_browser_masks[n].add;
#line 500
      ngx_cpystrn((browsers + i)->name, ngx_http_modern_browser_masks[n].name, (size_t___0 )12);
#line 495
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 505
  if ((unsigned long )conf->ancient_browsers == (unsigned long )((void *)0)) {
#line 505
    if (conf->netscape4 == 0U) {
#line 506
      conf->ancient_browsers = prev->ancient_browsers;
#line 507
      conf->netscape4 = prev->netscape4;
    }
  }
#line 510
  if ((unsigned long )conf->modern_browser_value == (unsigned long )((void *)0)) {
#line 511
    conf->modern_browser_value = prev->modern_browser_value;
  }
#line 514
  if ((unsigned long )conf->modern_browser_value == (unsigned long )((void *)0)) {
#line 515
    conf->modern_browser_value = & ngx_http_variable_true_value;
  }
#line 518
  if ((unsigned long )conf->ancient_browser_value == (unsigned long )((void *)0)) {
#line 519
    conf->ancient_browser_value = prev->ancient_browser_value;
  }
#line 522
  if ((unsigned long )conf->ancient_browser_value == (unsigned long )((void *)0)) {
#line 523
    conf->ancient_browser_value = & ngx_http_variable_true_value;
  }
#line 526
  return ((char *)((void *)0));
}
}
#line 530 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static int ngx_http_modern_browser_sort(void const   *one , void const   *two ) 
{ 
  ngx_http_modern_browser_t *first ;
  ngx_http_modern_browser_t *second ;

  {
#line 533
  first = (ngx_http_modern_browser_t *)one;
#line 534
  second = (ngx_http_modern_browser_t *)two;
#line 536
  return ((int )(first->skip - second->skip));
}
}
#line 540 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_modern_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  u_char c ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t version ;
  ngx_uint_t ver ;
  ngx_uint_t scale ;
  ngx_http_modern_browser_t *browser ;
  ngx_http_modern_browser_mask_t *mask ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 543
  bcf = (ngx_http_browser_conf_t *)conf;
#line 551
  value = (ngx_str_t *)(cf->args)->elts;
#line 553
  if ((cf->args)->nelts == 2UL) {
    {
#line 554
    tmp = strcmp((char const   *)(value + 1)->data, "unlisted");
    }
#line 554
    if (tmp == 0) {
#line 555
      bcf->modern_unlisted_browsers = 1U;
#line 556
      return ((char *)((void *)0));
    }
#line 559
    return ((char *)((void *)-1));
  }
#line 562
  if ((unsigned long )bcf->modern_browsers == (unsigned long )((void *)0)) {
    {
#line 563
    bcf->modern_browsers = ngx_array_create(cf->pool, (ngx_uint_t )5, sizeof(ngx_http_modern_browser_t ));
    }
#line 565
    if ((unsigned long )bcf->modern_browsers == (unsigned long )((void *)0)) {
#line 566
      return ((char *)((void *)-1));
    }
  }
  {
#line 570
  tmp___0 = ngx_array_push(bcf->modern_browsers);
#line 570
  browser = (ngx_http_modern_browser_t *)tmp___0;
  }
#line 571
  if ((unsigned long )browser == (unsigned long )((void *)0)) {
#line 572
    return ((char *)((void *)-1));
  }
#line 575
  mask = ngx_http_modern_browser_masks;
#line 577
  n = (ngx_uint_t )0;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! ((int )(mask + n)->browser[0] != 0)) {
#line 577
      goto while_break;
    }
    {
#line 578
    tmp___1 = ngx_strcasecmp((mask + n)->browser, (value + 1)->data);
    }
#line 578
    if (tmp___1 == 0L) {
#line 579
      goto found;
    }
#line 577
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 583
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown browser name \"%V\"", value + 1);
  }
#line 586
  return ((char *)((void *)-1));
  found: 
#line 596
  browser->skip = n;
#line 598
  version = (ngx_uint_t )0;
#line 599
  ver = (ngx_uint_t )0;
#line 600
  scale = (ngx_uint_t )1000000;
#line 602
  i = (ngx_uint_t )0;
  {
#line 602
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 602
    if (! (i < (value + 2)->len)) {
#line 602
      goto while_break___0;
    }
#line 604
    c = *((value + 2)->data + i);
#line 606
    if ((int )c >= 48) {
#line 606
      if ((int )c <= 57) {
#line 607
        ver = ver * 10UL + (ngx_uint_t )((int )c - 48);
#line 608
        goto __Cont;
      }
    }
#line 611
    if ((int )c == 46) {
#line 612
      version += ver * scale;
#line 613
      ver = (ngx_uint_t )0;
#line 614
      scale /= 100UL;
#line 615
      goto __Cont;
    }
    {
#line 618
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid browser version \"%V\"", value + 2);
    }
#line 621
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 602
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 624
  version += ver * scale;
#line 626
  browser->version = version;
#line 628
  return ((char *)((void *)0));
}
}
#line 632 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_ancient_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  ngx_str_t *value ;
  ngx_str_t *browser ;
  ngx_uint_t i ;
  int tmp ;
  void *tmp___0 ;

  {
#line 635
  bcf = (ngx_http_browser_conf_t *)conf;
#line 640
  value = (ngx_str_t *)(cf->args)->elts;
#line 642
  i = (ngx_uint_t )1;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! (i < (cf->args)->nelts)) {
#line 642
      goto while_break;
    }
    {
#line 643
    tmp = strcmp((char const   *)(value + i)->data, "netscape4");
    }
#line 643
    if (tmp == 0) {
#line 644
      bcf->netscape4 = 1U;
#line 645
      goto __Cont;
    }
#line 648
    if ((unsigned long )bcf->ancient_browsers == (unsigned long )((void *)0)) {
      {
#line 649
      bcf->ancient_browsers = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
      }
#line 651
      if ((unsigned long )bcf->ancient_browsers == (unsigned long )((void *)0)) {
#line 652
        return ((char *)((void *)-1));
      }
    }
    {
#line 656
    tmp___0 = ngx_array_push(bcf->ancient_browsers);
#line 656
    browser = (ngx_str_t *)tmp___0;
    }
#line 657
    if ((unsigned long )browser == (unsigned long )((void *)0)) {
#line 658
      return ((char *)((void *)-1));
    }
#line 661
    *browser = *(value + i);
    __Cont: /* CIL Label */ 
#line 642
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  return ((char *)((void *)0));
}
}
#line 668 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_modern_browser_value(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  ngx_str_t *value ;
  void *tmp ;

  {
  {
#line 671
  bcf = (ngx_http_browser_conf_t *)conf;
#line 675
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_variable_value_t ));
#line 675
  bcf->modern_browser_value = (ngx_http_variable_value_t *)tmp;
  }
#line 677
  if ((unsigned long )bcf->modern_browser_value == (unsigned long )((void *)0)) {
#line 678
    return ((char *)((void *)-1));
  }
#line 681
  value = (ngx_str_t *)(cf->args)->elts;
#line 683
  (bcf->modern_browser_value)->len = (unsigned int )(value + 1)->len;
#line 684
  (bcf->modern_browser_value)->valid = 1U;
#line 685
  (bcf->modern_browser_value)->no_cacheable = 0U;
#line 686
  (bcf->modern_browser_value)->not_found = 0U;
#line 687
  (bcf->modern_browser_value)->data = (value + 1)->data;
#line 689
  return ((char *)((void *)0));
}
}
#line 693 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_ancient_browser_value(ngx_conf_t *cf , ngx_command_t *cmd ,
                                            void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  ngx_str_t *value ;
  void *tmp ;

  {
  {
#line 696
  bcf = (ngx_http_browser_conf_t *)conf;
#line 700
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_variable_value_t ));
#line 700
  bcf->ancient_browser_value = (ngx_http_variable_value_t *)tmp;
  }
#line 702
  if ((unsigned long )bcf->ancient_browser_value == (unsigned long )((void *)0)) {
#line 703
    return ((char *)((void *)-1));
  }
#line 706
  value = (ngx_str_t *)(cf->args)->elts;
#line 708
  (bcf->ancient_browser_value)->len = (unsigned int )(value + 1)->len;
#line 709
  (bcf->ancient_browser_value)->valid = 1U;
#line 710
  (bcf->ancient_browser_value)->no_cacheable = 0U;
#line 711
  (bcf->ancient_browser_value)->not_found = 0U;
#line 712
  (bcf->ancient_browser_value)->data = (value + 1)->data;
#line 714
  return ((char *)((void *)0));
}
}
#line 500 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_send_response(ngx_http_request_t *r , ngx_uint_t status , ngx_str_t *ct ,
                                 ngx_http_complex_value_t *cv ) ;
#line 12 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
static char *ngx_http_empty_gif(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 15 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_command_t ngx_http_empty_gif_commands[2]  = {      {{sizeof("empty_gif") - 1UL, (u_char *)"empty_gif"}, (ngx_uint_t )134217729,
      & ngx_http_empty_gif, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 30 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
static u_char ngx_empty_gif[43]  = 
#line 30
  {      (u_char )'G',      (u_char )'I',      (u_char )'F',      (u_char )'8', 
        (u_char )'9',      (u_char )'a',      (u_char )1,      (u_char )0, 
        (u_char )1,      (u_char )0,      (u_char )128,      (u_char )1, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )255,      (u_char )255,      (u_char )255,      (u_char )33, 
        (u_char )249,      (u_char )4,      (u_char )1,      (u_char )0, 
        (u_char )0,      (u_char )1,      (u_char )0,      (u_char )44, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )1,      (u_char )0,      (u_char )1,      (u_char )0, 
        (u_char )0,      (u_char )2,      (u_char )2,      (u_char )76, 
        (u_char )1,      (u_char )0,      (u_char )59};
#line 78 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_http_module_t ngx_http_empty_gif_module_ctx  = 
#line 78
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 93 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
ngx_module_t ngx_http_empty_gif_module  = 
#line 93
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_empty_gif_module_ctx),
    ngx_http_empty_gif_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 109 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_str_t ngx_http_gif_type  =    {sizeof("image/gif") - 1UL, (u_char *)"image/gif"};
#line 112 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_int_t ngx_http_empty_gif_handler(ngx_http_request_t *r ) 
{ 
  ngx_http_complex_value_t cv ;
  ngx_int_t tmp ;

  {
#line 117
  if (! (r->method & 6UL)) {
#line 118
    return ((ngx_int_t )405);
  }
  {
#line 121
  memset((void *)(& cv), 0, sizeof(ngx_http_complex_value_t ));
#line 123
  cv.value.len = sizeof(ngx_empty_gif);
#line 124
  cv.value.data = ngx_empty_gif;
#line 125
  r->headers_out.last_modified_time = (time_t )23349600;
#line 127
  tmp = ngx_http_send_response(r, (ngx_uint_t )200, & ngx_http_gif_type, & cv);
  }
#line 127
  return (tmp);
}
}
#line 131 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_empty_gif_module.c"
static char *ngx_http_empty_gif(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 136
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 137
  clcf->handler = & ngx_http_empty_gif_handler;
#line 139
  return ((char *)((void *)0));
}
}
#line 175 "src/core/ngx_string.h"
off_t ngx_atoof(u_char *line , size_t___0 n ) ;
#line 206
uintptr_t ngx_escape_uri(u_char *dst , u_char *src , size_t___0 size , ngx_uint_t type ) ;
#line 88 "src/core/ngx_log.h"
void ngx_log_error_core(ngx_uint_t level , ngx_log_t *log , ngx_err_t err , char const   *fmt 
                        , ...) ;
#line 143 "src/core/ngx_buf.h"
ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool , size_t___0 size ) ;
#line 150
ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool ) ;
#line 162
ngx_chain_t *ngx_chain_get_free_buf(ngx_pool_t *p , ngx_chain_t **free___0 ) ;
#line 80 "src/core/ngx_list.h"
void *ngx_list_push(ngx_list_t *l ) ;
#line 285 "src/core/ngx_conf_file.h"
char *ngx_conf_set_num_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 286
char *ngx_conf_set_size_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 288
char *ngx_conf_set_msec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 292
char *ngx_conf_set_bitmask_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 49 "src/http/ngx_http_variables.h"
ngx_int_t ngx_http_get_variable_index(ngx_conf_t *cf , ngx_str_t *name ) ;
#line 50
ngx_http_variable_value_t *ngx_http_get_indexed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) ;
#line 408 "src/http/ngx_http_upstream.h"
ngx_int_t ngx_http_upstream_create(ngx_http_request_t *r ) ;
#line 409
void ngx_http_upstream_init(ngx_http_request_t *r ) ;
#line 410
ngx_http_upstream_srv_conf_t *ngx_http_upstream_add(ngx_conf_t *cf , ngx_url_t *u ,
                                                    ngx_uint_t flags ) ;
#line 412
char *ngx_http_upstream_bind_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 496 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r ) ;
#line 148 "src/http/ngx_http.h"
ngx_int_t ngx_http_discard_request_body(ngx_http_request_t *r ) ;
#line 27 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_create_request(ngx_http_request_t *r ) ;
#line 28
static ngx_int_t ngx_http_memcached_reinit_request(ngx_http_request_t *r ) ;
#line 29
static ngx_int_t ngx_http_memcached_process_header(ngx_http_request_t *r ) ;
#line 30
static ngx_int_t ngx_http_memcached_filter_init(void *data ) ;
#line 31
static ngx_int_t ngx_http_memcached_filter(void *data , ssize_t bytes ) ;
#line 32
static void ngx_http_memcached_abort_request(ngx_http_request_t *r ) ;
#line 33
static void ngx_http_memcached_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 36
static void *ngx_http_memcached_create_loc_conf(ngx_conf_t *cf ) ;
#line 37
static char *ngx_http_memcached_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 40
static char *ngx_http_memcached_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 44 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_conf_bitmask_t ngx_http_memcached_next_upstream_masks[6]  = {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_response") - 1UL, (u_char *)"invalid_response"}, (ngx_uint_t )8}, 
        {{sizeof("not_found") - 1UL,
       (u_char *)"not_found"}, (ngx_uint_t )512}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 54 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_command_t ngx_http_memcached_commands[11]  = 
#line 54
  {      {{sizeof("memcached_pass") - 1UL, (u_char *)"memcached_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_memcached_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("memcached_bind") - 1UL, (u_char *)"memcached_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("memcached_connect_timeout") - 1UL,
       (u_char *)"memcached_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("memcached_send_timeout") - 1UL, (u_char *)"memcached_send_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("memcached_buffer_size") - 1UL, (u_char *)"memcached_buffer_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("memcached_read_timeout") - 1UL, (u_char *)"memcached_read_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("memcached_next_upstream") - 1UL, (u_char *)"memcached_next_upstream"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_memcached_next_upstream_masks)}, 
        {{sizeof("memcached_next_upstream_tries") - 1UL, (u_char *)"memcached_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("memcached_next_upstream_timeout") - 1UL, (u_char *)"memcached_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("memcached_gzip_flag") - 1UL, (u_char *)"memcached_gzip_flag"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->gzip_flag), (void *)0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 130 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_http_module_t ngx_http_memcached_module_ctx  = 
#line 130
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_memcached_create_loc_conf, & ngx_http_memcached_merge_loc_conf};
#line 145 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
ngx_module_t ngx_http_memcached_module  = 
#line 145
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_memcached_module_ctx),
    ngx_http_memcached_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 161 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_str_t ngx_http_memcached_key  =    {sizeof("memcached_key") - 1UL, (u_char *)"memcached_key"};
#line 165 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static u_char ngx_http_memcached_end[8]  = 
#line 165
  {      (u_char )'\r',      (u_char )'\n',      (u_char )'E',      (u_char )'N', 
        (u_char )'D',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 168 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_memcached_loc_conf_t *mlcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
#line 176
  if (! (r->method & 6UL)) {
#line 177
    return ((ngx_int_t )405);
  }
  {
#line 180
  rc = ngx_http_discard_request_body(r);
  }
#line 182
  if (rc != 0L) {
#line 183
    return (rc);
  }
  {
#line 186
  tmp = ngx_http_set_content_type(r);
  }
#line 186
  if (tmp != 0L) {
#line 187
    return ((ngx_int_t )500);
  }
  {
#line 190
  tmp___0 = ngx_http_upstream_create(r);
  }
#line 190
  if (tmp___0 != 0L) {
#line 191
    return ((ngx_int_t )500);
  }
  {
#line 194
  u = r->upstream;
#line 196
  u->schema.len = sizeof("memcached://") - 1UL;
#line 196
  u->schema.data = (u_char *)"memcached://";
#line 197
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_memcached_module);
#line 199
  mlcf = (ngx_http_memcached_loc_conf_t *)*(r->loc_conf + ngx_http_memcached_module.ctx_index);
#line 201
  u->conf = & mlcf->upstream;
#line 203
  u->create_request = & ngx_http_memcached_create_request;
#line 204
  u->reinit_request = & ngx_http_memcached_reinit_request;
#line 205
  u->process_header = & ngx_http_memcached_process_header;
#line 206
  u->abort_request = & ngx_http_memcached_abort_request;
#line 207
  u->finalize_request = & ngx_http_memcached_finalize_request;
#line 209
  tmp___1 = ngx_palloc(r->pool, sizeof(ngx_http_memcached_ctx_t ));
#line 209
  ctx = (ngx_http_memcached_ctx_t *)tmp___1;
  }
#line 210
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 211
    return ((ngx_int_t )500);
  }
  {
#line 214
  ctx->request = r;
#line 216
  *(r->ctx + ngx_http_memcached_module.ctx_index) = (void *)ctx;
#line 218
  u->input_filter_init = & ngx_http_memcached_filter_init;
#line 219
  u->input_filter = & ngx_http_memcached_filter;
#line 220
  u->input_filter_ctx = (void *)ctx;
#line 222
  ((r->main)->count) ++;
#line 224
  ngx_http_upstream_init(r);
  }
#line 226
  return ((ngx_int_t )-4);
}
}
#line 230 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_create_request(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  uintptr_t escape___0 ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_variable_value_t *vv ;
  ngx_http_memcached_loc_conf_t *mlcf ;
  uintptr_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  void *tmp___4 ;
  uintptr_t tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;

  {
  {
#line 241
  mlcf = (ngx_http_memcached_loc_conf_t *)*(r->loc_conf + ngx_http_memcached_module.ctx_index);
#line 243
  vv = ngx_http_get_indexed_variable(r, (ngx_uint_t )mlcf->index);
  }
#line 245
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 245
    goto _L;
  } else
#line 245
  if (vv->not_found) {
#line 245
    goto _L;
  } else
#line 245
  if (vv->len == 0U) {
    _L: /* CIL Label */ 
#line 246
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 246
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the \"$memcached_key\" variable is not set");
      }
    }
#line 248
    return ((ngx_int_t )-1);
  }
  {
#line 251
  tmp = ngx_escape_uri((u_char *)((void *)0), vv->data, (size_t___0 )vv->len, (ngx_uint_t )5);
#line 251
  escape___0 = 2UL * tmp;
#line 253
  len = ((((sizeof("get ") - 1UL) + (unsigned long )vv->len) + escape___0) + sizeof("\r\n")) - 1UL;
#line 255
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 256
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 257
    return ((ngx_int_t )-1);
  }
  {
#line 260
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 261
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 262
    return ((ngx_int_t )-1);
  }
#line 265
  cl->buf = b;
#line 266
  cl->next = (ngx_chain_t *)((void *)0);
#line 268
  (r->upstream)->request_bufs = cl;
#line 270
  tmp___0 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___0 = (u_char )'g';
#line 270
  tmp___1 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___1 = (u_char )'e';
#line 270
  tmp___2 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___2 = (u_char )'t';
#line 270
  tmp___3 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___3 = (u_char )' ';
#line 272
  ctx = (ngx_http_memcached_ctx_t *)*(r->ctx + ngx_http_memcached_module.ctx_index);
#line 274
  ctx->key.data = b->last;
#line 276
  if (escape___0 == 0UL) {
    {
#line 277
    tmp___4 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)vv->data,
                     (size_t )vv->len);
#line 277
    b->last = (u_char *)tmp___4 + vv->len;
    }
  } else {
    {
#line 280
    tmp___5 = ngx_escape_uri(b->last, vv->data, (size_t___0 )vv->len, (ngx_uint_t )5);
#line 280
    b->last = (u_char *)tmp___5;
    }
  }
#line 284
  ctx->key.len = (size_t___0 )(b->last - ctx->key.data);
#line 289
  tmp___6 = b->last;
#line 289
  (b->last) ++;
#line 289
  *tmp___6 = (u_char )'\r';
#line 289
  tmp___7 = b->last;
#line 289
  (b->last) ++;
#line 289
  *tmp___7 = (u_char )'\n';
#line 291
  return ((ngx_int_t )0);
}
}
#line 295 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_reinit_request(ngx_http_request_t *r ) 
{ 


  {
#line 298
  return ((ngx_int_t )0);
}
}
#line 302 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_process_header(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *start ;
  ngx_str_t line ;
  ngx_uint_t flags ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_memcached_loc_conf_t *mlcf ;
  int tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 313
  u = r->upstream;
#line 315
  p = u->buffer.pos;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! ((unsigned long )p < (unsigned long )u->buffer.last)) {
#line 315
      goto while_break;
    }
#line 316
    if ((int )*p == 10) {
#line 317
      goto found;
    }
#line 315
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return ((ngx_int_t )-2);
  found: 
#line 325
  line.data = u->buffer.pos;
#line 326
  line.len = (size_t___0 )(p - u->buffer.pos);
#line 328
  if (line.len == 0UL) {
#line 329
    goto no_valid;
  } else
#line 328
  if ((int )*(p - 1) != 13) {
#line 329
    goto no_valid;
  }
  {
#line 332
  *p = (u_char )'\000';
#line 333
  (line.len) --;
#line 338
  p = u->buffer.pos;
#line 340
  ctx = (ngx_http_memcached_ctx_t *)*(r->ctx + ngx_http_memcached_module.ctx_index);
#line 341
  mlcf = (ngx_http_memcached_loc_conf_t *)*(r->loc_conf + ngx_http_memcached_module.ctx_index);
#line 343
  tmp___4 = strncmp((char const   *)p, "VALUE ", sizeof("VALUE ") - 1UL);
  }
#line 343
  if (tmp___4 == 0) {
    {
#line 345
    p += sizeof("VALUE ") - 1UL;
#line 347
    tmp = strncmp((char const   *)p, (char const   *)ctx->key.data, ctx->key.len);
    }
#line 347
    if (tmp != 0) {
#line 348
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 348
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid key in response \"%V\" for key \"%V\"",
                           & line, & ctx->key);
        }
      }
#line 353
      return ((ngx_int_t )40);
    }
#line 356
    p += ctx->key.len;
#line 358
    tmp___0 = p;
#line 358
    p ++;
#line 358
    if ((int )*tmp___0 != 32) {
#line 359
      goto no_valid;
    }
#line 364
    start = p;
    {
#line 366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 366
      if (! *p) {
#line 366
        goto while_break___0;
      }
#line 367
      tmp___1 = p;
#line 367
      p ++;
#line 367
      if ((int )*tmp___1 == 32) {
#line 368
        if (mlcf->gzip_flag) {
#line 369
          goto flags;
        } else {
#line 371
          goto length;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 376
    goto no_valid;
    flags: 
    {
#line 380
    tmp___2 = ngx_atoi(start, (size_t___0 )((p - start) - 1L));
#line 380
    flags = (ngx_uint_t )tmp___2;
    }
#line 382
    if (flags == 0xffffffffffffffffUL) {
#line 383
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 383
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid flags in response \"%V\" for key \"%V\"",
                           & line, & ctx->key);
        }
      }
#line 387
      return ((ngx_int_t )40);
    }
#line 390
    if (flags & mlcf->gzip_flag) {
      {
#line 391
      tmp___3 = ngx_list_push(& r->headers_out.headers);
#line 391
      h = (ngx_table_elt_t *)tmp___3;
      }
#line 392
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 393
        return ((ngx_int_t )-1);
      }
#line 396
      h->hash = (ngx_uint_t )1;
#line 397
      h->key.len = sizeof("Content-Encoding") - 1UL;
#line 397
      h->key.data = (u_char *)"Content-Encoding";
#line 398
      h->value.len = sizeof("gzip") - 1UL;
#line 398
      h->value.data = (u_char *)"gzip";
#line 399
      r->headers_out.content_encoding = h;
    }
    length: 
    {
#line 404
    start = p;
#line 405
    p = line.data + line.len;
#line 407
    u->headers_in.content_length_n = ngx_atoof(start, (size_t___0 )(p - start));
    }
#line 408
    if (u->headers_in.content_length_n == -1L) {
#line 409
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 409
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid length in response \"%V\" for key \"%V\"",
                           & line, & ctx->key);
        }
      }
#line 413
      return ((ngx_int_t )40);
    }
#line 416
    u->headers_in.status_n = (ngx_uint_t )200;
#line 417
    (u->state)->status = (ngx_uint_t )200;
#line 418
    u->buffer.pos = (p + sizeof("\r\n")) - 1;
#line 420
    return ((ngx_int_t )0);
  }
  {
#line 423
  tmp___5 = strcmp((char const   *)p, "END\r");
  }
#line 423
  if (tmp___5 == 0) {
#line 424
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 424
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "key: \"%V\" was not found by memcached",
                         & ctx->key);
      }
    }
#line 427
    u->headers_in.content_length_n = (off_t )0;
#line 428
    u->headers_in.status_n = (ngx_uint_t )404;
#line 429
    (u->state)->status = (ngx_uint_t )404;
#line 430
    u->buffer.pos = (p + sizeof("END\r\n")) - 1;
#line 431
    u->keepalive = 1U;
#line 433
    return ((ngx_int_t )0);
  }
  no_valid: 
#line 438
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 438
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid response: \"%V\"",
                       & line);
    }
  }
#line 441
  return ((ngx_int_t )40);
}
}
#line 445 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_filter_init(void *data ) 
{ 
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_upstream_t *u ;

  {
#line 448
  ctx = (ngx_http_memcached_ctx_t *)data;
#line 452
  u = (ctx->request)->upstream;
#line 454
  if (u->headers_in.status_n != 404UL) {
#line 455
    u->length = (off_t )((unsigned long )u->headers_in.content_length_n + (sizeof(ngx_http_memcached_end) - 1UL));
#line 456
    ctx->rest = sizeof(ngx_http_memcached_end) - 1UL;
  } else {
#line 459
    u->length = (off_t )0;
  }
#line 462
  return ((ngx_int_t )0);
}
}
#line 466 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_memcached_ctx_t *ctx ;
  u_char *last ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;
  int tmp ;
  int tmp___0 ;

  {
#line 469
  ctx = (ngx_http_memcached_ctx_t *)data;
#line 476
  u = (ctx->request)->upstream;
#line 477
  b = & u->buffer;
#line 479
  if (u->length == (ssize_t )ctx->rest) {
    {
#line 481
    tmp = strncmp((char const   *)b->last, ((char const   *)(ngx_http_memcached_end) + (sizeof(ngx_http_memcached_end) - 1UL)) - ctx->rest,
                  (size_t )bytes);
    }
#line 481
    if (tmp != 0) {
#line 486
      if ((((ctx->request)->connection)->log)->log_level >= 4UL) {
        {
#line 486
        ngx_log_error_core((ngx_uint_t )4, ((ctx->request)->connection)->log, 0, "memcached sent invalid trailer");
        }
      }
#line 489
      u->length = (off_t )0;
#line 490
      ctx->rest = (size_t___0 )0;
#line 492
      return ((ngx_int_t )0);
    }
#line 495
    u->length -= bytes;
#line 496
    ctx->rest -= (size_t___0 )bytes;
#line 498
    if (u->length == 0L) {
#line 499
      u->keepalive = 1U;
    }
#line 502
    return ((ngx_int_t )0);
  }
#line 505
  cl = u->out_bufs;
#line 505
  ll = & u->out_bufs;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! cl) {
#line 505
      goto while_break;
    }
#line 506
    ll = & cl->next;
#line 505
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  cl = ngx_chain_get_free_buf((ctx->request)->pool, & u->free_bufs);
  }
#line 510
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 511
    return ((ngx_int_t )-1);
  }
#line 514
  (cl->buf)->flush = 1U;
#line 515
  (cl->buf)->memory = 1U;
#line 517
  *ll = cl;
#line 519
  last = b->last;
#line 520
  (cl->buf)->pos = last;
#line 521
  b->last += bytes;
#line 522
  (cl->buf)->last = b->last;
#line 523
  (cl->buf)->tag = u->output.tag;
#line 529
  if (bytes <= (ssize_t )((unsigned long )u->length - (sizeof(ngx_http_memcached_end) - 1UL))) {
#line 530
    u->length -= bytes;
#line 531
    return ((ngx_int_t )0);
  }
  {
#line 534
  last += (unsigned long )u->length - (sizeof(ngx_http_memcached_end) - 1UL);
#line 536
  tmp___0 = strncmp((char const   *)last, (char const   *)(ngx_http_memcached_end),
                    (size_t )(b->last - last));
  }
#line 536
  if (tmp___0 != 0) {
#line 537
    if ((((ctx->request)->connection)->log)->log_level >= 4UL) {
      {
#line 537
      ngx_log_error_core((ngx_uint_t )4, ((ctx->request)->connection)->log, 0, "memcached sent invalid trailer");
      }
    }
#line 540
    b->last = last;
#line 541
    (cl->buf)->last = last;
#line 542
    u->length = (off_t )0;
#line 543
    ctx->rest = (size_t___0 )0;
#line 545
    return ((ngx_int_t )0);
  }
#line 548
  ctx->rest -= (size_t___0 )(b->last - last);
#line 549
  b->last = last;
#line 550
  (cl->buf)->last = last;
#line 551
  u->length = (off_t )ctx->rest;
#line 553
  if (u->length == 0L) {
#line 554
    u->keepalive = 1U;
  }
#line 557
  return ((ngx_int_t )0);
}
}
#line 561 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static void ngx_http_memcached_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 566
  return;
}
}
#line 570 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static void ngx_http_memcached_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 575
  return;
}
}
#line 579 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static void *ngx_http_memcached_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_memcached_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 584
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_memcached_loc_conf_t ));
#line 584
  conf = (ngx_http_memcached_loc_conf_t *)tmp;
  }
#line 585
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 586
    return ((void *)0);
  }
#line 599
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 600
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 601
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 602
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 603
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 604
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 606
  conf->upstream.buffer_size = (size_t___0 )-1;
#line 609
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 610
  conf->upstream.buffering = (ngx_flag_t )0;
#line 611
  conf->upstream.ignore_client_abort = (ngx_flag_t )0;
#line 612
  conf->upstream.send_lowat = (size_t___0 )0;
#line 613
  conf->upstream.bufs.num = (ngx_int_t )0;
#line 614
  conf->upstream.busy_buffers_size = (size_t___0 )0;
#line 615
  conf->upstream.max_temp_file_size = (size_t___0 )0;
#line 616
  conf->upstream.temp_file_write_size = (size_t___0 )0;
#line 617
  conf->upstream.intercept_errors = (ngx_flag_t )1;
#line 618
  conf->upstream.intercept_404 = 1U;
#line 619
  conf->upstream.pass_request_headers = (ngx_flag_t )0;
#line 620
  conf->upstream.pass_request_body = (ngx_flag_t )0;
#line 621
  conf->upstream.force_ranges = (ngx_flag_t )1;
#line 623
  conf->index = (ngx_int_t )-1;
#line 624
  conf->gzip_flag = (ngx_uint_t )-1;
#line 626
  return ((void *)conf);
}
}
#line 630 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static char *ngx_http_memcached_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_memcached_loc_conf_t *prev ;
  ngx_http_memcached_loc_conf_t *conf ;

  {
#line 633
  prev = (ngx_http_memcached_loc_conf_t *)parent;
#line 634
  conf = (ngx_http_memcached_loc_conf_t *)child;
#line 636
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 636
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 636
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 636
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 639
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 639
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 639
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 639
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 642
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 642
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 642
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 642
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 645
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 645
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 645
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 645
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 648
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 648
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 648
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 648
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 651
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 651
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 651
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 651
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 654
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 654
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 654
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 654
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 658
  if (conf->upstream.next_upstream == 0UL) {
#line 658
    if (prev->upstream.next_upstream == 0UL) {
#line 658
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 658
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 664
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 665
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
#line 669
  if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 670
    conf->upstream.upstream = prev->upstream.upstream;
  }
#line 673
  if (conf->index == -1L) {
#line 674
    conf->index = prev->index;
  }
#line 677
  if (conf->gzip_flag == 0xffffffffffffffffUL) {
#line 677
    if (prev->gzip_flag == 0xffffffffffffffffUL) {
#line 677
      conf->gzip_flag = (ngx_uint_t )0;
    } else {
#line 677
      conf->gzip_flag = prev->gzip_flag;
    }
  }
#line 679
  return ((char *)((void *)0));
}
}
#line 683 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_memcached_module.c"
static char *ngx_http_memcached_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_memcached_loc_conf_t *mlcf ;
  ngx_str_t *value ;
  ngx_url_t u ;
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 686
  mlcf = (ngx_http_memcached_loc_conf_t *)conf;
#line 692
  if (mlcf->upstream.upstream) {
#line 693
    return ((char *)"is duplicate");
  }
  {
#line 696
  value = (ngx_str_t *)(cf->args)->elts;
#line 698
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 700
  u.url = *(value + 1);
#line 701
  u.no_resolve = 1U;
#line 703
  mlcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 704
  if ((unsigned long )mlcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 705
    return ((char *)((void *)-1));
  }
#line 708
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 710
  clcf->handler = & ngx_http_memcached_handler;
#line 712
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 713
    clcf->auto_redirect = 1U;
  }
  {
#line 716
  mlcf->index = ngx_http_get_variable_index(cf, & ngx_http_memcached_key);
  }
#line 718
  if (mlcf->index == -1L) {
#line 719
    return ((char *)((void *)-1));
  }
#line 722
  return ((char *)((void *)0));
}
}
#line 50 "src/core/ngx_string.h"
void ngx_strlow(u_char *dst , u_char *src , size_t___0 n ) ;
#line 42 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_cacheline_size ;
#line 80 "src/core/ngx_palloc.h"
void *ngx_pnalloc(ngx_pool_t *pool , size_t___0 size ) ;
#line 28 "src/core/ngx_array.h"
void *ngx_array_push_n(ngx_array_t *a , ngx_uint_t n ) ;
#line 31 "src/core/ngx_array.h"
__inline static ngx_int_t ngx_array_init(ngx_array_t *array , ngx_pool_t *pool , ngx_uint_t n ,
                                         size_t___0 size ) 
{ 


  {
  {
#line 39
  array->nelts = (ngx_uint_t )0;
#line 40
  array->size = size;
#line 41
  array->nalloc = n;
#line 42
  array->pool = pool;
#line 44
  array->elts = ngx_palloc(pool, n * size);
  }
#line 45
  if ((unsigned long )array->elts == (unsigned long )((void *)0)) {
#line 46
    return ((ngx_int_t )-1);
  }
#line 49
  return ((ngx_int_t )0);
}
}
#line 100 "src/core/ngx_hash.h"
void *ngx_hash_find(ngx_hash_t *hash , ngx_uint_t key , u_char *name , size_t___0 len ) ;
#line 106
ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names , ngx_uint_t nelts ) ;
#line 113
ngx_uint_t ngx_hash_key_lc(u_char *data , size_t___0 len ) ;
#line 154 "src/core/ngx_file.h"
char *ngx_conf_set_path_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 155
char *ngx_conf_merge_path_value(ngx_conf_t *cf , ngx_path_t **path , ngx_path_t *prev ,
                                ngx_path_init_t *init ) ;
#line 157
char *ngx_conf_set_access_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 121 "src/core/ngx_inet.h"
ngx_int_t ngx_parse_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 280 "src/core/ngx_conf_file.h"
char *ngx_conf_set_flag_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 282
char *ngx_conf_set_str_array_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 287
char *ngx_conf_set_off_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 290
char *ngx_conf_set_bufs_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 217 "src/http/ngx_http_script.h"
char *ngx_http_set_predicate_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 220
ngx_uint_t ngx_http_script_variables_count(ngx_str_t *value ) ;
#line 221
ngx_int_t ngx_http_script_compile(ngx_http_script_compile_t *sc ) ;
#line 222
u_char *ngx_http_script_run(ngx_http_request_t *r , ngx_str_t *value , void *code_lengths ,
                            size_t___0 len , void *code_values ) ;
#line 224
void ngx_http_script_flush_no_cacheable_variables(ngx_http_request_t *r , ngx_array_t *indices ) ;
#line 231
size_t___0 ngx_http_script_copy_len_code(ngx_http_script_engine_t *e ) ;
#line 232
void ngx_http_script_copy_code(ngx_http_script_engine_t *e ) ;
#line 103 "src/event/ngx_event_pipe.h"
ngx_int_t ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 414 "src/http/ngx_http_upstream.h"
char *ngx_http_upstream_param_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 416
ngx_int_t ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf , ngx_http_upstream_conf_t *conf ,
                                              ngx_http_upstream_conf_t *prev , ngx_str_t *default_hide_headers ,
                                              ngx_hash_init_t *hash ) ;
#line 426
ngx_conf_bitmask_t ngx_http_upstream_cache_method_mask[4] ;
#line 427
ngx_conf_bitmask_t ngx_http_upstream_ignore_headers_masks[10] ;
#line 198 "src/http/ngx_http_cache.h"
char *ngx_http_file_cache_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 200
char *ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 96 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_status_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_status_t *status ) ;
#line 100
ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_uint_t allow_underscores ) ;
#line 136
ngx_int_t ngx_http_read_client_request_body(ngx_http_request_t *r , void (*post_handler)(ngx_http_request_t *r ) ) ;
#line 46 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_eval(ngx_http_request_t *r , ngx_http_scgi_loc_conf_t *scf ) ;
#line 48
static ngx_int_t ngx_http_scgi_create_request(ngx_http_request_t *r ) ;
#line 49
static ngx_int_t ngx_http_scgi_reinit_request(ngx_http_request_t *r ) ;
#line 50
static ngx_int_t ngx_http_scgi_process_status_line(ngx_http_request_t *r ) ;
#line 51
static ngx_int_t ngx_http_scgi_process_header(ngx_http_request_t *r ) ;
#line 52
static void ngx_http_scgi_abort_request(ngx_http_request_t *r ) ;
#line 53
static void ngx_http_scgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 55
static void *ngx_http_scgi_create_main_conf(ngx_conf_t *cf ) ;
#line 56
static void *ngx_http_scgi_create_loc_conf(ngx_conf_t *cf ) ;
#line 57
static char *ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 59
static ngx_int_t ngx_http_scgi_init_params(ngx_conf_t *cf , ngx_http_scgi_loc_conf_t *conf ,
                                           ngx_http_scgi_params_t *params , ngx_keyval_t *default_params ) ;
#line 63
static char *ngx_http_scgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64
static char *ngx_http_scgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 68
static ngx_int_t ngx_http_scgi_create_key(ngx_http_request_t *r ) ;
#line 69
static char *ngx_http_scgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 71
static char *ngx_http_scgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 76 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_conf_bitmask_t ngx_http_scgi_next_upstream_masks[12]  = 
#line 76
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 95 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_command_t ngx_http_scgi_commands[44]  = 
#line 95
  {      {{sizeof("scgi_pass") - 1UL, (u_char *)"scgi_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_scgi_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_store") - 1UL, (u_char *)"scgi_store"}, (ngx_uint_t )234881026,
      & ngx_http_scgi_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_store_access") - 1UL, (u_char *)"scgi_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("scgi_buffering") - 1UL, (u_char *)"scgi_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.buffering), (void *)0}, 
        {{sizeof("scgi_request_buffering") - 1UL,
       (u_char *)"scgi_request_buffering"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("scgi_ignore_client_abort") - 1UL, (u_char *)"scgi_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("scgi_bind") - 1UL, (u_char *)"scgi_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("scgi_connect_timeout") - 1UL,
       (u_char *)"scgi_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("scgi_send_timeout") - 1UL, (u_char *)"scgi_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("scgi_buffer_size") - 1UL, (u_char *)"scgi_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.buffer_size), (void *)0}, 
        {{sizeof("scgi_pass_request_headers") - 1UL,
       (u_char *)"scgi_pass_request_headers"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("scgi_pass_request_body") - 1UL, (u_char *)"scgi_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("scgi_intercept_errors") - 1UL, (u_char *)"scgi_intercept_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("scgi_read_timeout") - 1UL, (u_char *)"scgi_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("scgi_buffers") - 1UL, (u_char *)"scgi_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("scgi_busy_buffers_size") - 1UL,
       (u_char *)"scgi_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("scgi_force_ranges") - 1UL, (u_char *)"scgi_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("scgi_limit_rate") - 1UL, (u_char *)"scgi_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.limit_rate), (void *)0}, 
        {{sizeof("scgi_cache") - 1UL,
       (u_char *)"scgi_cache"}, (ngx_uint_t )234881026, & ngx_http_scgi_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_cache_key") - 1UL, (u_char *)"scgi_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_scgi_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_cache_path") - 1UL, (u_char *)"scgi_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_scgi_main_conf_t *)0)->caches), (void *)(& ngx_http_scgi_module)}, 
        {{sizeof("scgi_cache_bypass") - 1UL,
       (u_char *)"scgi_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("scgi_no_cache") - 1UL, (u_char *)"scgi_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("scgi_cache_valid") - 1UL,
       (u_char *)"scgi_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("scgi_cache_min_uses") - 1UL, (u_char *)"scgi_cache_min_uses"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("scgi_cache_max_range_offset") - 1UL, (u_char *)"scgi_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("scgi_cache_use_stale") - 1UL, (u_char *)"scgi_cache_use_stale"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_scgi_next_upstream_masks)}, 
        {{sizeof("scgi_cache_methods") - 1UL, (u_char *)"scgi_cache_methods"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("scgi_cache_lock") - 1UL, (u_char *)"scgi_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_lock), (void *)0}, 
        {{sizeof("scgi_cache_lock_timeout") - 1UL,
       (u_char *)"scgi_cache_lock_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("scgi_cache_lock_age") - 1UL, (u_char *)"scgi_cache_lock_age"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("scgi_cache_revalidate") - 1UL, (u_char *)"scgi_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("scgi_cache_background_update") - 1UL, (u_char *)"scgi_cache_background_update"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("scgi_temp_path") - 1UL, (u_char *)"scgi_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.temp_path), (void *)0}, 
        {{sizeof("scgi_max_temp_file_size") - 1UL,
       (u_char *)"scgi_max_temp_file_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("scgi_temp_file_write_size") - 1UL, (u_char *)"scgi_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("scgi_next_upstream") - 1UL, (u_char *)"scgi_next_upstream"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_scgi_next_upstream_masks)}, 
        {{sizeof("scgi_next_upstream_tries") - 1UL, (u_char *)"scgi_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("scgi_next_upstream_timeout") - 1UL, (u_char *)"scgi_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("scgi_param") - 1UL, (u_char *)"scgi_param"}, (ngx_uint_t )234881036,
      & ngx_http_upstream_param_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->params_source), (void *)0}, 
        {{sizeof("scgi_pass_header") - 1UL,
       (u_char *)"scgi_pass_header"}, (ngx_uint_t )234881026, & ngx_conf_set_str_array_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("scgi_hide_header") - 1UL, (u_char *)"scgi_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("scgi_ignore_headers") - 1UL, (u_char *)"scgi_ignore_headers"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 406 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_http_module_t ngx_http_scgi_module_ctx  = 
#line 406
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_scgi_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_scgi_create_loc_conf, & ngx_http_scgi_merge_loc_conf};
#line 421 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
ngx_module_t ngx_http_scgi_module  = 
#line 421
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_scgi_module_ctx),
    ngx_http_scgi_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 437 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_str_t ngx_http_scgi_hide_headers[7]  = {      {sizeof("Status") - 1UL, (u_char *)"Status"}, 
        {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}};
#line 450 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_keyval_t ngx_http_scgi_cache_headers[7]  = {      {{sizeof("HTTP_IF_MODIFIED_SINCE") - 1UL, (u_char *)"HTTP_IF_MODIFIED_SINCE"},
      {sizeof("$upstream_cache_last_modified") - 1UL, (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("HTTP_IF_UNMODIFIED_SINCE") - 1UL,
       (u_char *)"HTTP_IF_UNMODIFIED_SINCE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_NONE_MATCH") - 1UL, (u_char *)"HTTP_IF_NONE_MATCH"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                             (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("HTTP_IF_MATCH") - 1UL,
       (u_char *)"HTTP_IF_MATCH"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_RANGE") - 1UL, (u_char *)"HTTP_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_RANGE") - 1UL,
       (u_char *)"HTTP_IF_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, {(size_t___0 )0, (u_char *)((void *)0)}}};
#line 464 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_path_init_t ngx_http_scgi_temp_path  =    {{sizeof("scgi_temp") - 1UL, (u_char *)"scgi_temp"}, {(size_t___0 )1, (size_t___0 )2,
                                                         (size_t___0 )0}};
#line 469 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_http_scgi_main_conf_t *smcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 480
  tmp = ngx_http_upstream_create(r);
  }
#line 480
  if (tmp != 0L) {
#line 481
    return ((ngx_int_t )500);
  }
  {
#line 484
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t ));
#line 484
  status = (ngx_http_status_t *)tmp___0;
  }
#line 485
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 486
    return ((ngx_int_t )500);
  }
#line 489
  *(r->ctx + ngx_http_scgi_module.ctx_index) = (void *)status;
#line 491
  scf = (ngx_http_scgi_loc_conf_t *)*(r->loc_conf + ngx_http_scgi_module.ctx_index);
#line 493
  if (scf->scgi_lengths) {
    {
#line 494
    tmp___1 = ngx_http_scgi_eval(r, scf);
    }
#line 494
    if (tmp___1 != 0L) {
#line 495
      return ((ngx_int_t )500);
    }
  }
  {
#line 499
  u = r->upstream;
#line 501
  u->schema.len = sizeof("scgi://") - 1UL;
#line 501
  u->schema.data = (u_char *)"scgi://";
#line 502
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_scgi_module);
#line 504
  u->conf = & scf->upstream;
#line 507
  smcf = (ngx_http_scgi_main_conf_t *)*(r->main_conf + ngx_http_scgi_module.ctx_index);
#line 509
  u->caches = & smcf->caches;
#line 510
  u->create_key = & ngx_http_scgi_create_key;
#line 513
  u->create_request = & ngx_http_scgi_create_request;
#line 514
  u->reinit_request = & ngx_http_scgi_reinit_request;
#line 515
  u->process_header = & ngx_http_scgi_process_status_line;
#line 516
  u->abort_request = & ngx_http_scgi_abort_request;
#line 517
  u->finalize_request = & ngx_http_scgi_finalize_request;
#line 518
  r->state = (ngx_uint_t )0;
#line 520
  u->buffering = (unsigned int )scf->upstream.buffering;
#line 522
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 522
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 523
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 524
    return ((ngx_int_t )500);
  }
#line 527
  (u->pipe)->input_filter = & ngx_event_pipe_copy_input_filter;
#line 528
  (u->pipe)->input_ctx = (void *)r;
#line 530
  if (! scf->upstream.request_buffering) {
#line 530
    if (scf->upstream.pass_request_body) {
#line 530
      if (! r->headers_in.chunked) {
#line 534
        r->request_body_no_buffering = 1U;
      }
    }
  }
  {
#line 537
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 539
  if (rc >= 300L) {
#line 540
    return (rc);
  }
#line 543
  return ((ngx_int_t )-4);
}
}
#line 547 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_eval(ngx_http_request_t *r , ngx_http_scgi_loc_conf_t *scf ) 
{ 
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 553
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 555
  tmp = ngx_http_script_run(r, & url.url, (scf->scgi_lengths)->elts, (size_t___0 )0,
                            (scf->scgi_values)->elts);
  }
#line 555
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 559
    return ((ngx_int_t )-1);
  }
  {
#line 562
  url.no_resolve = 1U;
#line 564
  tmp___0 = ngx_parse_url(r->pool, & url);
  }
#line 564
  if (tmp___0 != 0L) {
#line 565
    if (url.err) {
#line 566
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 566
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 570
    return ((ngx_int_t )-1);
  }
  {
#line 573
  u = r->upstream;
#line 575
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 575
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___1;
  }
#line 576
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 577
    return ((ngx_int_t )-1);
  }
#line 580
  if (url.addrs) {
#line 581
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 582
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 583
    (u->resolved)->name = (url.addrs + 0)->name;
#line 584
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 587
  (u->resolved)->host = url.host;
#line 588
  (u->resolved)->port = url.port;
#line 589
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 591
  return ((ngx_int_t )0);
}
}
#line 597 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_create_key(ngx_http_request_t *r ) 
{ 
  ngx_str_t *key ;
  ngx_http_scgi_loc_conf_t *scf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 603
  tmp = ngx_array_push(& (r->cache)->keys);
#line 603
  key = (ngx_str_t *)tmp;
  }
#line 604
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 605
    return ((ngx_int_t )-1);
  }
  {
#line 608
  scf = (ngx_http_scgi_loc_conf_t *)*(r->loc_conf + ngx_http_scgi_module.ctx_index);
#line 610
  tmp___0 = ngx_http_complex_value(r, & scf->cache_key, key);
  }
#line 610
  if (tmp___0 != 0L) {
#line 611
    return ((ngx_int_t )-1);
  }
#line 614
  return ((ngx_int_t )0);
}
}
#line 620 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_create_request(ngx_http_request_t *r ) 
{ 
  off_t content_length_n ;
  u_char ch ;
  u_char *key ;
  u_char *val ;
  u_char *lowcase_key ;
  size_t___0 len ;
  size_t___0 key_len ;
  size_t___0 val_len ;
  size_t___0 allocated ;
  ngx_buf_t *b ;
  ngx_str_t content_length ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_uint_t skip_empty ;
  ngx_uint_t header_params ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_table_elt_t **ignored ;
  ngx_http_scgi_params_t *params ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_scgi_loc_conf_t *scf ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  u_char buffer___0[sizeof("-9223372036854775808") - 1UL] ;
  off_t tmp ;
  u_char *tmp___0 ;
  size_t___0 tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_uint_t tmp___4 ;
  void *tmp___5 ;
  size_t___0 tmp___6 ;
  u_char *tmp___7 ;
  void *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  void *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  void *tmp___14 ;

  {
#line 639
  content_length_n = (off_t )0;
#line 640
  body = (r->upstream)->request_bufs;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! body) {
#line 642
      goto while_break;
    }
#line 643
    if ((body->buf)->temporary) {
#line 643
      tmp = (body->buf)->last - (body->buf)->pos;
    } else
#line 643
    if ((body->buf)->memory) {
#line 643
      tmp = (body->buf)->last - (body->buf)->pos;
    } else
#line 643
    if ((body->buf)->mmap) {
#line 643
      tmp = (body->buf)->last - (body->buf)->pos;
    } else {
#line 643
      tmp = (body->buf)->file_last - (body->buf)->file_pos;
    }
#line 643
    content_length_n += tmp;
#line 644
    body = body->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 647
  content_length.data = buffer___0;
#line 648
  tmp___0 = ngx_sprintf(buffer___0, "%O", content_length_n);
#line 648
  content_length.len = (size_t___0 )(tmp___0 - buffer___0);
#line 650
  len = (sizeof("CONTENT_LENGTH") + content_length.len) + 1UL;
#line 652
  header_params = (ngx_uint_t )0;
#line 653
  ignored = (ngx_table_elt_t **)((void *)0);
#line 655
  scf = (ngx_http_scgi_loc_conf_t *)*(r->loc_conf + ngx_http_scgi_module.ctx_index);
  }
#line 658
  if ((r->upstream)->cacheable) {
#line 658
    params = & scf->params_cache;
  } else {
#line 658
    params = & scf->params;
  }
#line 663
  if (params->lengths) {
    {
#line 664
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 666
    ngx_http_script_flush_no_cacheable_variables(r, params->flushes);
#line 667
    le.flushed = 1U;
#line 669
    le.ip = (u_char *)(params->lengths)->elts;
#line 670
    le.request = r;
    }
    {
#line 672
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 672
      if (! *((uintptr_t *)le.ip)) {
#line 672
        goto while_break___0;
      }
      {
#line 674
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 675
      key_len = (*lcode)(& le);
#line 677
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 678
      skip_empty = (*lcode)(& le);
#line 680
      val_len = (size_t___0 )0;
      }
      {
#line 680
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 680
        if (! *((uintptr_t *)le.ip)) {
#line 680
          goto while_break___1;
        }
        {
#line 681
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 680
        tmp___1 = (*lcode)(& le);
#line 680
        val_len += tmp___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 683
      le.ip += sizeof(uintptr_t );
#line 685
      if (skip_empty) {
#line 685
        if (val_len == 0UL) {
#line 686
          goto while_continue___0;
        }
      }
#line 689
      len += (key_len + val_len) + 1UL;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 693
  if (scf->upstream.pass_request_headers) {
#line 695
    allocated = (size_t___0 )0;
#line 696
    lowcase_key = (u_char *)((void *)0);
#line 698
    if (params->number) {
#line 699
      n = (ngx_uint_t )0;
#line 700
      part = & r->headers_in.headers.part;
      {
#line 702
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 702
        if (! part) {
#line 702
          goto while_break___2;
        }
#line 703
        n += part->nelts;
#line 704
        part = part->next;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 707
      tmp___2 = ngx_palloc(r->pool, n * sizeof(void *));
#line 707
      ignored = (ngx_table_elt_t **)tmp___2;
      }
#line 708
      if ((unsigned long )ignored == (unsigned long )((void *)0)) {
#line 709
        return ((ngx_int_t )-1);
      }
    }
#line 713
    part = & r->headers_in.headers.part;
#line 714
    header___0 = (ngx_table_elt_t *)part->elts;
#line 716
    i = (ngx_uint_t )0;
    {
#line 716
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 718
      if (i >= part->nelts) {
#line 719
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 720
          goto while_break___3;
        }
#line 723
        part = part->next;
#line 724
        header___0 = (ngx_table_elt_t *)part->elts;
#line 725
        i = (ngx_uint_t )0;
      }
#line 728
      if (params->number) {
#line 729
        if (allocated < (header___0 + i)->key.len) {
          {
#line 730
          allocated = (header___0 + i)->key.len + 16UL;
#line 731
          tmp___3 = ngx_pnalloc(r->pool, allocated);
#line 731
          lowcase_key = (u_char *)tmp___3;
          }
#line 732
          if ((unsigned long )lowcase_key == (unsigned long )((void *)0)) {
#line 733
            return ((ngx_int_t )-1);
          }
        }
#line 737
        hash = (ngx_uint_t )0;
#line 739
        n = (ngx_uint_t )0;
        {
#line 739
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 739
          if (! (n < (header___0 + i)->key.len)) {
#line 739
            goto while_break___4;
          }
#line 740
          ch = *((header___0 + i)->key.data + n);
#line 742
          if ((int )ch >= 65) {
#line 742
            if ((int )ch <= 90) {
#line 743
              ch = (u_char )((int )ch | 32);
            } else {
#line 742
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 745
          if ((int )ch == 45) {
#line 746
            ch = (u_char )'_';
          }
#line 749
          hash = hash * 31UL + (ngx_uint_t )ch;
#line 750
          *(lowcase_key + n) = ch;
#line 739
          n ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 753
        tmp___5 = ngx_hash_find(& params->hash, hash, lowcase_key, n);
        }
#line 753
        if (tmp___5) {
#line 754
          tmp___4 = header_params;
#line 754
          header_params ++;
#line 754
          *(ignored + tmp___4) = header___0 + i;
#line 755
          goto __Cont;
        }
      }
#line 759
      len += ((((sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len) + 1UL) + (header___0 + i)->value.len) + 1UL;
      __Cont: /* CIL Label */ 
#line 716
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 766
  b = ngx_create_temp_buf(r->pool, (((sizeof("-9223372036854775808") - 1UL) + 1UL) + len) + 1UL);
  }
#line 767
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 768
    return ((ngx_int_t )-1);
  }
  {
#line 771
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 772
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 773
    return ((ngx_int_t )-1);
  }
  {
#line 776
  cl->buf = b;
#line 778
  b->last = ngx_sprintf(b->last, "%ui:CONTENT_LENGTH%Z%V%Z", len, & content_length);
  }
#line 781
  if (params->lengths) {
    {
#line 782
    memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 784
    e.ip = (u_char *)(params->values)->elts;
#line 785
    e.pos = b->last;
#line 786
    e.request = r;
#line 787
    e.flushed = 1U;
#line 789
    le.ip = (u_char *)(params->lengths)->elts;
    }
    {
#line 791
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 791
      if (! *((uintptr_t *)le.ip)) {
#line 791
        goto while_break___5;
      }
      {
#line 793
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 794
      (*lcode)(& le);
#line 796
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 797
      skip_empty = (*lcode)(& le);
#line 799
      val_len = (size_t___0 )0;
      }
      {
#line 799
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 799
        if (! *((uintptr_t *)le.ip)) {
#line 799
          goto while_break___6;
        }
        {
#line 800
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 799
        tmp___6 = (*lcode)(& le);
#line 799
        val_len += tmp___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 802
      le.ip += sizeof(uintptr_t );
#line 804
      if (skip_empty) {
#line 804
        if (val_len == 0UL) {
#line 805
          e.skip = 1U;
          {
#line 807
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 807
            if (! *((uintptr_t *)e.ip)) {
#line 807
              goto while_break___7;
            }
            {
#line 808
            code = *((ngx_http_script_code_pt *)e.ip);
#line 809
            (*code)(& e);
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 811
          e.ip += sizeof(uintptr_t );
#line 813
          e.skip = 0U;
#line 815
          goto while_continue___5;
        }
      }
      {
#line 821
      code = *((ngx_http_script_code_pt *)e.ip);
#line 822
      (*code)(& e);
      }
      {
#line 827
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 827
        if (! *((uintptr_t *)e.ip)) {
#line 827
          goto while_break___8;
        }
        {
#line 828
        code = *((ngx_http_script_code_pt *)e.ip);
#line 829
        (*code)(& e);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 831
      tmp___7 = e.pos;
#line 831
      (e.pos) ++;
#line 831
      *tmp___7 = (u_char )'\000';
#line 832
      e.ip += sizeof(uintptr_t );
    }
    while_break___5: /* CIL Label */ ;
    }
#line 838
    b->last = e.pos;
  }
#line 841
  if (scf->upstream.pass_request_headers) {
#line 843
    part = & r->headers_in.headers.part;
#line 844
    header___0 = (ngx_table_elt_t *)part->elts;
#line 846
    i = (ngx_uint_t )0;
    {
#line 846
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 848
      if (i >= part->nelts) {
#line 849
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 850
          goto while_break___9;
        }
#line 853
        part = part->next;
#line 854
        header___0 = (ngx_table_elt_t *)part->elts;
#line 855
        i = (ngx_uint_t )0;
      }
#line 858
      n = (ngx_uint_t )0;
      {
#line 858
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 858
        if (! (n < header_params)) {
#line 858
          goto while_break___10;
        }
#line 859
        if ((unsigned long )(header___0 + i) == (unsigned long )*(ignored + n)) {
#line 860
          goto next;
        }
#line 858
        n ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 864
      key = b->last;
#line 865
      tmp___8 = memcpy((void */* __restrict  */)key, (void const   */* __restrict  */)"HTTP_",
                       sizeof("HTTP_") - 1UL);
#line 865
      b->last = (u_char *)tmp___8 + (sizeof("HTTP_") - 1UL);
#line 867
      n = (ngx_uint_t )0;
      }
      {
#line 867
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 867
        if (! (n < (header___0 + i)->key.len)) {
#line 867
          goto while_break___11;
        }
#line 868
        ch = *((header___0 + i)->key.data + n);
#line 870
        if ((int )ch >= 97) {
#line 870
          if ((int )ch <= 122) {
#line 871
            ch = (u_char )((int )ch & -33);
          } else {
#line 870
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 873
        if ((int )ch == 45) {
#line 874
          ch = (u_char )'_';
        }
#line 877
        tmp___9 = b->last;
#line 877
        (b->last) ++;
#line 877
        *tmp___9 = ch;
#line 867
        n ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 880
      tmp___10 = b->last;
#line 880
      (b->last) ++;
#line 880
      *tmp___10 = (u_char )0;
#line 882
      val = b->last;
#line 883
      tmp___11 = memcpy((void */* __restrict  */)val, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        (header___0 + i)->value.len);
#line 883
      b->last = (u_char *)tmp___11 + (header___0 + i)->value.len;
#line 884
      tmp___12 = b->last;
#line 884
      (b->last) ++;
#line 884
      *tmp___12 = (u_char )0;
      }
      next: 
#line 891
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 846
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 895
  tmp___13 = b->last;
#line 895
  (b->last) ++;
#line 895
  *tmp___13 = (u_char )',';
#line 897
  if (r->request_body_no_buffering) {
#line 898
    (r->upstream)->request_bufs = cl;
  } else
#line 900
  if (scf->upstream.pass_request_body) {
#line 901
    body = (r->upstream)->request_bufs;
#line 902
    (r->upstream)->request_bufs = cl;
    {
#line 904
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 904
      if (! body) {
#line 904
        goto while_break___12;
      }
      {
#line 905
      tmp___14 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 905
      b = (ngx_buf_t *)tmp___14;
      }
#line 906
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 907
        return ((ngx_int_t )-1);
      }
      {
#line 910
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
             sizeof(ngx_buf_t ));
#line 912
      cl->next = ngx_alloc_chain_link(r->pool);
      }
#line 913
      if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 914
        return ((ngx_int_t )-1);
      }
#line 917
      cl = cl->next;
#line 918
      cl->buf = b;
#line 920
      body = body->next;
    }
    while_break___12: /* CIL Label */ ;
    }
  } else {
#line 924
    (r->upstream)->request_bufs = cl;
  }
#line 927
  cl->next = (ngx_chain_t *)((void *)0);
#line 929
  return ((ngx_int_t )0);
}
}
#line 933 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_status_t *status ;

  {
#line 938
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_scgi_module.ctx_index);
#line 940
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 941
    return ((ngx_int_t )0);
  }
#line 944
  status->code = (ngx_uint_t )0;
#line 945
  status->count = (ngx_uint_t )0;
#line 946
  status->start = (u_char *)((void *)0);
#line 947
  status->end = (u_char *)((void *)0);
#line 949
  (r->upstream)->process_header = & ngx_http_scgi_process_status_line;
#line 950
  r->state = (ngx_uint_t )0;
#line 952
  return ((ngx_int_t )0);
}
}
#line 956 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_process_status_line(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 964
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_scgi_module.ctx_index);
#line 966
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 967
    return ((ngx_int_t )-1);
  }
  {
#line 970
  u = r->upstream;
#line 972
  rc = ngx_http_parse_status_line(r, & u->buffer, status);
  }
#line 974
  if (rc == -2L) {
#line 975
    return (rc);
  }
#line 978
  if (rc == -1L) {
    {
#line 979
    u->process_header = & ngx_http_scgi_process_header;
#line 980
    tmp = ngx_http_scgi_process_header(r);
    }
#line 980
    return (tmp);
  }
#line 983
  if (u->state) {
#line 983
    if ((u->state)->status == 0UL) {
#line 984
      (u->state)->status = status->code;
    }
  }
  {
#line 987
  u->headers_in.status_n = status->code;
#line 989
  len = (size_t___0 )(status->end - status->start);
#line 990
  u->headers_in.status_line.len = len;
#line 992
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 992
  u->headers_in.status_line.data = (u_char *)tmp___0;
  }
#line 993
  if ((unsigned long )u->headers_in.status_line.data == (unsigned long )((void *)0)) {
#line 994
    return ((ngx_int_t )-1);
  }
  {
#line 997
  memcpy((void */* __restrict  */)u->headers_in.status_line.data, (void const   */* __restrict  */)status->start,
         len);
#line 1003
  u->process_header = & ngx_http_scgi_process_header;
#line 1005
  tmp___1 = ngx_http_scgi_process_header(r);
  }
#line 1005
  return (tmp___1);
}
}
#line 1009 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_process_header(ngx_http_request_t *r ) 
{ 
  ngx_str_t *status_line ;
  ngx_int_t rc ;
  ngx_int_t status ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1019
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
  {
#line 1021
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1023
    rc = ngx_http_parse_header_line(r, & (r->upstream)->buffer, (ngx_uint_t )1);
    }
#line 1025
    if (rc == 0L) {
      {
#line 1029
      tmp = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1029
      h = (ngx_table_elt_t *)tmp;
      }
#line 1030
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1031
        return ((ngx_int_t )-1);
      }
      {
#line 1034
      h->hash = r->header_hash;
#line 1036
      h->key.len = (size_t___0 )(r->header_name_end - r->header_name_start);
#line 1037
      h->value.len = (size_t___0 )(r->header_end - r->header_start);
#line 1039
      tmp___0 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1039
      h->key.data = (u_char *)tmp___0;
      }
#line 1042
      if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1043
        h->hash = (ngx_uint_t )0;
#line 1044
        return ((ngx_int_t )-1);
      }
      {
#line 1047
      h->value.data = (h->key.data + h->key.len) + 1;
#line 1048
      h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1050
      memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
             h->key.len);
#line 1051
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1052
      memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
             h->value.len);
#line 1053
      *(h->value.data + h->value.len) = (u_char )'\000';
      }
#line 1055
      if (h->key.len == r->lowcase_index) {
        {
#line 1056
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1059
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1062
      tmp___1 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1062
      hh = (ngx_http_upstream_header_t *)tmp___1;
      }
#line 1065
      if (hh) {
        {
#line 1065
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1065
        if (tmp___2 != 0L) {
#line 1066
          return ((ngx_int_t )-1);
        }
      }
#line 1072
      goto __Cont;
    }
#line 1075
    if (rc == 1L) {
#line 1082
      u = r->upstream;
#line 1084
      if (u->headers_in.status_n) {
#line 1085
        goto done;
      }
#line 1088
      if (u->headers_in.status) {
        {
#line 1089
        status_line = & (u->headers_in.status)->value;
#line 1091
        status = ngx_atoi(status_line->data, (size_t___0 )3);
        }
#line 1092
        if (status == -1L) {
#line 1093
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1093
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid status \"%V\"",
                               status_line);
            }
          }
#line 1096
          return ((ngx_int_t )40);
        }
#line 1099
        u->headers_in.status_n = (ngx_uint_t )status;
#line 1100
        u->headers_in.status_line = *status_line;
      } else
#line 1102
      if (u->headers_in.location) {
#line 1103
        u->headers_in.status_n = (ngx_uint_t )302;
#line 1104
        u->headers_in.status_line.len = sizeof("302 Moved Temporarily") - 1UL;
#line 1104
        u->headers_in.status_line.data = (u_char *)"302 Moved Temporarily";
      } else {
#line 1108
        u->headers_in.status_n = (ngx_uint_t )200;
#line 1109
        u->headers_in.status_line.len = sizeof("200 OK") - 1UL;
#line 1109
        u->headers_in.status_line.data = (u_char *)"200 OK";
      }
#line 1112
      if (u->state) {
#line 1112
        if ((u->state)->status == 0UL) {
#line 1113
          (u->state)->status = u->headers_in.status_n;
        }
      }
      done: 
#line 1118
      if (u->headers_in.status_n == 101UL) {
#line 1118
        if (r->headers_in.upgrade) {
#line 1121
          u->upgrade = 1U;
        }
      }
#line 1124
      return ((ngx_int_t )0);
    }
#line 1127
    if (rc == -2L) {
#line 1128
      return ((ngx_int_t )-2);
    }
#line 1133
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1133
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
      }
    }
#line 1136
    return ((ngx_int_t )40);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1141 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static void ngx_http_scgi_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 1147
  return;
}
}
#line 1151 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static void ngx_http_scgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 1157
  return;
}
}
#line 1161 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static void *ngx_http_scgi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_scgi_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1166
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_scgi_main_conf_t ));
#line 1166
  conf = (ngx_http_scgi_main_conf_t *)tmp;
  }
#line 1167
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1168
    return ((void *)0);
  }
  {
#line 1172
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 1172
  if (tmp___0 != 0L) {
#line 1176
    return ((void *)0);
  }
#line 1180
  return ((void *)conf);
}
}
#line 1184 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static void *ngx_http_scgi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_scgi_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1189
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_scgi_loc_conf_t ));
#line 1189
  conf = (ngx_http_scgi_loc_conf_t *)tmp;
  }
#line 1190
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1191
    return ((void *)0);
  }
#line 1194
  conf->upstream.store = -1;
#line 1195
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 1196
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 1197
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 1198
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 1199
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 1200
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 1202
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 1204
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 1205
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 1206
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 1207
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 1209
  conf->upstream.send_lowat = (size_t___0 )-1;
#line 1210
  conf->upstream.buffer_size = (size_t___0 )-1;
#line 1211
  conf->upstream.limit_rate = (size_t___0 )-1;
#line 1213
  conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
#line 1214
  conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
#line 1215
  conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
#line 1217
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 1218
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 1221
  conf->upstream.cache = -1;
#line 1222
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 1223
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 1224
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 1225
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 1226
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 1227
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 1228
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 1229
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 1230
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 1231
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 1234
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 1235
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 1237
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 1240
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 1242
  conf->upstream.change_buffering = 1U;
#line 1244
  conf->upstream.module.len = sizeof("scgi") - 1UL;
#line 1244
  conf->upstream.module.data = (u_char *)"scgi";
#line 1246
  return ((void *)conf);
}
}
#line 1250 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_scgi_loc_conf_t *prev ;
  ngx_http_scgi_loc_conf_t *conf ;
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  ngx_int_t tmp___0 ;

  {
#line 1253
  prev = (ngx_http_scgi_loc_conf_t *)parent;
#line 1254
  conf = (ngx_http_scgi_loc_conf_t *)child;
#line 1263
  if (conf->upstream.store > 0) {
#line 1264
    conf->upstream.cache = 0;
  }
#line 1267
  if (conf->upstream.cache > 0) {
#line 1268
    conf->upstream.store = 0;
  }
#line 1273
  if (conf->upstream.store == -1) {
#line 1274
    if (conf->upstream.store == -1) {
#line 1274
      if (prev->upstream.store == -1) {
#line 1274
        conf->upstream.store = 0;
      } else {
#line 1274
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 1276
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 1277
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 1280
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 1280
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 1280
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 1280
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 1283
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1283
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1283
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 1283
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 1286
  if (conf->upstream.buffering == -1L) {
#line 1286
    if (prev->upstream.buffering == -1L) {
#line 1286
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 1286
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 1289
  if (conf->upstream.request_buffering == -1L) {
#line 1289
    if (prev->upstream.request_buffering == -1L) {
#line 1289
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 1289
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 1292
  if (conf->upstream.ignore_client_abort == -1L) {
#line 1292
    if (prev->upstream.ignore_client_abort == -1L) {
#line 1292
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 1292
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 1295
  if (conf->upstream.force_ranges == -1L) {
#line 1295
    if (prev->upstream.force_ranges == -1L) {
#line 1295
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 1295
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 1298
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 1298
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 1298
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 1298
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 1301
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1301
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1301
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 1301
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 1304
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1304
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1304
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 1304
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 1307
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1307
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1307
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 1307
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 1310
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1310
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1310
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 1310
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 1313
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1313
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1313
      conf->upstream.send_lowat = (size_t___0 )0;
    } else {
#line 1313
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 1316
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1316
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1316
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 1316
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 1320
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1320
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1320
      conf->upstream.limit_rate = (size_t___0 )0;
    } else {
#line 1320
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 1324
  if (conf->upstream.bufs.num == 0L) {
#line 1324
    if (prev->upstream.bufs.num) {
#line 1324
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 1324
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 1324
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 1324
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 1327
  if (conf->upstream.bufs.num < 2L) {
    {
#line 1328
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"scgi_buffers\"");
    }
#line 1330
    return ((char *)((void *)-1));
  }
#line 1334
  size = conf->upstream.buffer_size;
#line 1335
  if (size < conf->upstream.bufs.size) {
#line 1336
    size = conf->upstream.bufs.size;
  }
#line 1340
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1340
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1340
      conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
    } else {
#line 1340
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 1344
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1345
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 1347
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 1351
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 1352
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"scgi_buffer_size\" and one of the \"scgi_buffers\"");
    }
#line 1357
    return ((char *)((void *)-1));
  }
#line 1360
  if (conf->upstream.busy_buffers_size > (size_t___0 )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 1363
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_busy_buffers_size\" must be less than the size of all \"scgi_buffers\" minus one buffer");
    }
#line 1367
    return ((char *)((void *)-1));
  }
#line 1371
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1371
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1371
      conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
    } else {
#line 1371
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 1375
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1376
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 1378
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 1382
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 1383
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"scgi_buffer_size\" and one of the \"scgi_buffers\"");
    }
#line 1388
    return ((char *)((void *)-1));
  }
#line 1392
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1392
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1392
      conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
    } else {
#line 1392
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 1396
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1397
    conf->upstream.max_temp_file_size = (size_t___0 )1073741824;
  } else {
#line 1399
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 1403
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 1403
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 1406
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"scgi_buffer_size\" and one of the \"scgi_buffers\"");
      }
#line 1412
      return ((char *)((void *)-1));
    }
  }
#line 1416
  if (conf->upstream.ignore_headers == 0UL) {
#line 1416
    if (prev->upstream.ignore_headers == 0UL) {
#line 1416
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 1416
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 1421
  if (conf->upstream.next_upstream == 0UL) {
#line 1421
    if (prev->upstream.next_upstream == 0UL) {
#line 1421
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 1421
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 1427
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 1428
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 1432
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_scgi_temp_path);
  }
#line 1432
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1437
    return ((char *)((void *)-1));
  }
#line 1442
  if (conf->upstream.cache == -1) {
#line 1443
    if (conf->upstream.cache == -1) {
#line 1443
      if (prev->upstream.cache == -1) {
#line 1443
        conf->upstream.cache = 0;
      } else {
#line 1443
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 1446
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 1447
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 1450
  if (conf->upstream.cache_zone) {
#line 1450
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 1453
      shm_zone = conf->upstream.cache_zone;
#line 1455
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 1459
      return ((char *)((void *)-1));
    }
  }
#line 1462
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1462
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1462
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 1462
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 1465
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 1465
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 1465
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 1465
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 1469
  if (conf->upstream.cache_use_stale == 0UL) {
#line 1469
    if (prev->upstream.cache_use_stale == 0UL) {
#line 1469
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 1469
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 1474
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 1475
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 1479
  if (conf->upstream.cache_use_stale & 2UL) {
#line 1480
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 1483
  if (conf->upstream.cache_methods == 0UL) {
#line 1484
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 1487
  conf->upstream.cache_methods |= 6UL;
#line 1489
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1489
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1489
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 1489
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 1492
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1492
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1492
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 1492
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 1495
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1495
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1495
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 1495
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 1498
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 1499
    conf->cache_key = prev->cache_key;
  }
#line 1502
  if (conf->upstream.cache) {
#line 1502
    if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
      {
#line 1503
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no \"scgi_cache_key\" for \"scgi_cache\"");
      }
    }
  }
#line 1507
  if (conf->upstream.cache_lock == -1L) {
#line 1507
    if (prev->upstream.cache_lock == -1L) {
#line 1507
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 1507
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 1510
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1510
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1510
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 1510
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 1513
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1513
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1513
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 1513
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 1516
  if (conf->upstream.cache_revalidate == -1L) {
#line 1516
    if (prev->upstream.cache_revalidate == -1L) {
#line 1516
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 1516
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 1519
  if (conf->upstream.cache_background_update == -1L) {
#line 1519
    if (prev->upstream.cache_background_update == -1L) {
#line 1519
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 1519
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 1524
  if (conf->upstream.pass_request_headers == -1L) {
#line 1524
    if (prev->upstream.pass_request_headers == -1L) {
#line 1524
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 1524
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 1526
  if (conf->upstream.pass_request_body == -1L) {
#line 1526
    if (prev->upstream.pass_request_body == -1L) {
#line 1526
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 1526
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 1529
  if (conf->upstream.intercept_errors == -1L) {
#line 1529
    if (prev->upstream.intercept_errors == -1L) {
#line 1529
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 1529
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
  {
#line 1532
  hash.max_size = (ngx_uint_t )512;
#line 1533
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 1534
  hash.name = (char *)"scgi_hide_headers_hash";
#line 1536
  tmp___0 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_scgi_hide_headers, & hash);
  }
#line 1536
  if (tmp___0 != 0L) {
#line 1540
    return ((char *)((void *)-1));
  }
#line 1543
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1545
  if (clcf->noname) {
#line 1545
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 1545
      if ((unsigned long )conf->scgi_lengths == (unsigned long )((void *)0)) {
#line 1548
        conf->upstream.upstream = prev->upstream.upstream;
#line 1549
        conf->scgi_lengths = prev->scgi_lengths;
#line 1550
        conf->scgi_values = prev->scgi_values;
      }
    }
  }
#line 1553
  if (clcf->lmt_excpt) {
#line 1553
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 1553
      if (conf->upstream.upstream) {
#line 1556
        clcf->handler = & ngx_http_scgi_handler;
      } else
#line 1553
      if (conf->scgi_lengths) {
#line 1556
        clcf->handler = & ngx_http_scgi_handler;
      }
    }
  }
#line 1559
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1560
    conf->params = prev->params;
#line 1562
    conf->params_cache = prev->params_cache;
#line 1564
    conf->params_source = prev->params_source;
  }
  {
#line 1567
  rc = ngx_http_scgi_init_params(cf, conf, & conf->params, (ngx_keyval_t *)((void *)0));
  }
#line 1568
  if (rc != 0L) {
#line 1569
    return ((char *)((void *)-1));
  }
#line 1574
  if (conf->upstream.cache) {
    {
#line 1575
    rc = ngx_http_scgi_init_params(cf, conf, & conf->params_cache, ngx_http_scgi_cache_headers);
    }
#line 1577
    if (rc != 0L) {
#line 1578
      return ((char *)((void *)-1));
    }
  }
#line 1589
  if ((unsigned long )prev->params.hash.buckets == (unsigned long )((void *)0)) {
#line 1589
    if ((unsigned long )conf->params_source == (unsigned long )prev->params_source) {
#line 1592
      prev->params = conf->params;
#line 1594
      prev->params_cache = conf->params_cache;
    }
  }
#line 1598
  return ((char *)((void *)0));
}
}
#line 1602 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_init_params(ngx_conf_t *cf , ngx_http_scgi_loc_conf_t *conf ,
                                           ngx_http_scgi_params_t *params , ngx_keyval_t *default_params ) 
{ 
  u_char *p ;
  size_t___0 size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_uint_t nsrc ;
  ngx_array_t headers_names ;
  ngx_array_t params_merged ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_upstream_param_t *src ;
  ngx_http_upstream_param_t *s ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;

  {
#line 1618
  if (params->hash.buckets) {
#line 1619
    return ((ngx_int_t )0);
  }
#line 1622
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1622
    if ((unsigned long )default_params == (unsigned long )((void *)0)) {
#line 1623
      params->hash.buckets = (ngx_hash_elt_t **)((void *)1);
#line 1624
      return ((ngx_int_t )0);
    }
  }
  {
#line 1627
  params->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t___0 )1);
  }
#line 1628
  if ((unsigned long )params->lengths == (unsigned long )((void *)0)) {
#line 1629
    return ((ngx_int_t )-1);
  }
  {
#line 1632
  params->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t___0 )1);
  }
#line 1633
  if ((unsigned long )params->values == (unsigned long )((void *)0)) {
#line 1634
    return ((ngx_int_t )-1);
  }
  {
#line 1637
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 1637
  if (tmp != 0L) {
#line 1640
    return ((ngx_int_t )-1);
  }
#line 1643
  if (conf->params_source) {
#line 1644
    src = (ngx_http_upstream_param_t *)(conf->params_source)->elts;
#line 1645
    nsrc = (conf->params_source)->nelts;
  } else {
#line 1648
    src = (ngx_http_upstream_param_t *)((void *)0);
#line 1649
    nsrc = (ngx_uint_t )0;
  }
#line 1652
  if (default_params) {
    {
#line 1653
    tmp___0 = ngx_array_init(& params_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 1653
    if (tmp___0 != 0L) {
#line 1657
      return ((ngx_int_t )-1);
    }
#line 1660
    i = (ngx_uint_t )0;
    {
#line 1660
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1660
      if (! (i < nsrc)) {
#line 1660
        goto while_break;
      }
      {
#line 1662
      tmp___1 = ngx_array_push(& params_merged);
#line 1662
      s = (ngx_http_upstream_param_t *)tmp___1;
      }
#line 1663
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1664
        return ((ngx_int_t )-1);
      }
#line 1667
      *s = *(src + i);
#line 1660
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1670
    h = default_params;
    {
#line 1672
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1672
      if (! h->key.len) {
#line 1672
        goto while_break___0;
      }
#line 1674
      src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1675
      nsrc = params_merged.nelts;
#line 1677
      i = (ngx_uint_t )0;
      {
#line 1677
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1677
        if (! (i < nsrc)) {
#line 1677
          goto while_break___1;
        }
        {
#line 1678
        tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
        }
#line 1678
        if (tmp___2 == 0L) {
#line 1679
          goto next;
        }
#line 1677
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1683
      tmp___3 = ngx_array_push(& params_merged);
#line 1683
      s = (ngx_http_upstream_param_t *)tmp___3;
      }
#line 1684
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1685
        return ((ngx_int_t )-1);
      }
#line 1688
      s->key = h->key;
#line 1689
      s->value = h->value;
#line 1690
      s->skip_empty = (ngx_uint_t )1;
      next: 
#line 1694
      h ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1697
    src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1698
    nsrc = params_merged.nelts;
  }
#line 1701
  i = (ngx_uint_t )0;
  {
#line 1701
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1701
    if (! (i < nsrc)) {
#line 1701
      goto while_break___2;
    }
#line 1703
    if ((src + i)->key.len > sizeof("HTTP_") - 1UL) {
      {
#line 1703
      tmp___5 = strncmp((char const   *)(src + i)->key.data, "HTTP_", sizeof("HTTP_") - 1UL);
      }
#line 1703
      if (tmp___5 == 0) {
        {
#line 1706
        tmp___4 = ngx_array_push(& headers_names);
#line 1706
        hk = (ngx_hash_key_t *)tmp___4;
        }
#line 1707
        if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 1708
          return ((ngx_int_t )-1);
        }
        {
#line 1711
        hk->key.len = (src + i)->key.len - 5UL;
#line 1712
        hk->key.data = (src + i)->key.data + 5;
#line 1713
        hk->key_hash = ngx_hash_key_lc(hk->key.data, hk->key.len);
#line 1714
        hk->value = (void *)1;
        }
#line 1716
        if ((src + i)->value.len == 0UL) {
#line 1717
          goto __Cont;
        }
      }
    }
    {
#line 1721
    tmp___6 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1721
    copy = (ngx_http_script_copy_code_t *)tmp___6;
    }
#line 1723
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1724
      return ((ngx_int_t )-1);
    }
    {
#line 1727
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 1728
    copy->len = (src + i)->key.len + 1UL;
#line 1730
    tmp___7 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1730
    copy = (ngx_http_script_copy_code_t *)tmp___7;
    }
#line 1732
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1733
      return ((ngx_int_t )-1);
    }
    {
#line 1736
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 1737
    copy->len = (src + i)->skip_empty;
#line 1740
    size = ((((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + 1UL) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 1744
    tmp___8 = ngx_array_push_n(params->values, size);
#line 1744
    copy = (ngx_http_script_copy_code_t *)tmp___8;
    }
#line 1745
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1746
      return ((ngx_int_t )-1);
    }
    {
#line 1749
    copy->code = & ngx_http_script_copy_code;
#line 1750
    copy->len = (src + i)->key.len + 1UL;
#line 1752
    p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 1753
    ngx_cpystrn(p, (src + i)->key.data, (src + i)->key.len + 1UL);
#line 1756
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1758
    sc.cf = cf;
#line 1759
    sc.source = & (src + i)->value;
#line 1760
    sc.flushes = & params->flushes;
#line 1761
    sc.lengths = & params->lengths;
#line 1762
    sc.values = & params->values;
#line 1764
    tmp___9 = ngx_http_script_compile(& sc);
    }
#line 1764
    if (tmp___9 != 0L) {
#line 1765
      return ((ngx_int_t )-1);
    }
    {
#line 1768
    tmp___10 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 1768
    code = (uintptr_t *)tmp___10;
    }
#line 1769
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1770
      return ((ngx_int_t )-1);
    }
    {
#line 1773
    *code = (uintptr_t )((void *)0);
#line 1776
    tmp___11 = ngx_array_push_n(params->values, sizeof(uintptr_t ));
#line 1776
    code = (uintptr_t *)tmp___11;
    }
#line 1777
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1778
      return ((ngx_int_t )-1);
    }
#line 1781
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 1701
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1784
  tmp___12 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 1784
  code = (uintptr_t *)tmp___12;
  }
#line 1785
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1786
    return ((ngx_int_t )-1);
  }
  {
#line 1789
  *code = (uintptr_t )((void *)0);
#line 1791
  params->number = headers_names.nelts;
#line 1793
  hash.hash = & params->hash;
#line 1794
  hash.key = & ngx_hash_key_lc;
#line 1795
  hash.max_size = (ngx_uint_t )512;
#line 1796
  hash.bucket_size = (ngx_uint_t )64;
#line 1797
  hash.name = (char *)"scgi_params_hash";
#line 1798
  hash.pool = cf->pool;
#line 1799
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 1801
  tmp___13 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 1801
  return (tmp___13);
}
}
#line 1805 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_url_t u ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;

  {
#line 1808
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1816
  if (scf->upstream.upstream) {
#line 1817
    return ((char *)"is duplicate");
  } else
#line 1816
  if (scf->scgi_lengths) {
#line 1817
    return ((char *)"is duplicate");
  }
  {
#line 1820
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1821
  clcf->handler = & ngx_http_scgi_handler;
#line 1823
  value = (ngx_str_t *)(cf->args)->elts;
#line 1825
  url = value + 1;
#line 1827
  n = ngx_http_script_variables_count(url);
  }
#line 1829
  if (n) {
    {
#line 1831
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1833
    sc.cf = cf;
#line 1834
    sc.source = url;
#line 1835
    sc.lengths = & scf->scgi_lengths;
#line 1836
    sc.values = & scf->scgi_values;
#line 1837
    sc.variables = n;
#line 1838
    sc.complete_lengths = 1U;
#line 1839
    sc.complete_values = 1U;
#line 1841
    tmp = ngx_http_script_compile(& sc);
    }
#line 1841
    if (tmp != 0L) {
#line 1842
      return ((char *)((void *)-1));
    }
#line 1845
    return ((char *)((void *)0));
  }
  {
#line 1848
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 1850
  u.url = *(value + 1);
#line 1851
  u.no_resolve = 1U;
#line 1853
  scf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 1854
  if ((unsigned long )scf->upstream.upstream == (unsigned long )((void *)0)) {
#line 1855
    return ((char *)((void *)-1));
  }
#line 1858
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 1859
    clcf->auto_redirect = 1U;
  }
#line 1862
  return ((char *)((void *)0));
}
}
#line 1866 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1869
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1874
  if (scf->upstream.store != -1) {
#line 1875
    return ((char *)"is duplicate");
  }
  {
#line 1878
  value = (ngx_str_t *)(cf->args)->elts;
#line 1880
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 1880
  if (tmp == 0) {
#line 1881
    scf->upstream.store = 0;
#line 1882
    return ((char *)((void *)0));
  }
#line 1886
  if (scf->upstream.cache > 0) {
#line 1887
    return ((char *)"is incompatible with \"scgi_cache\"");
  }
  {
#line 1891
  scf->upstream.store = 1;
#line 1893
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 1893
  if (tmp___0 == 0) {
#line 1894
    return ((char *)((void *)0));
  }
  {
#line 1898
  ((value + 1)->len) ++;
#line 1900
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1902
  sc.cf = cf;
#line 1903
  sc.source = value + 1;
#line 1904
  sc.lengths = & scf->upstream.store_lengths;
#line 1905
  sc.values = & scf->upstream.store_values;
#line 1906
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 1907
  sc.complete_lengths = 1U;
#line 1908
  sc.complete_values = 1U;
#line 1910
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 1910
  if (tmp___1 != 0L) {
#line 1911
    return ((char *)((void *)-1));
  }
#line 1914
  return ((char *)((void *)0));
}
}
#line 1920 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
#line 1923
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1929
  value = (ngx_str_t *)(cf->args)->elts;
#line 1931
  if (scf->upstream.cache != -1) {
#line 1932
    return ((char *)"is duplicate");
  }
  {
#line 1935
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 1935
  if (tmp == 0) {
#line 1936
    scf->upstream.cache = 0;
#line 1937
    return ((char *)((void *)0));
  }
#line 1940
  if (scf->upstream.store > 0) {
#line 1941
    return ((char *)"is incompatible with \"scgi_store\"");
  }
  {
#line 1944
  scf->upstream.cache = 1;
#line 1946
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 1948
  ccv.cf = cf;
#line 1949
  ccv.value = value + 1;
#line 1950
  ccv.complex_value = & cv;
#line 1952
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 1952
  if (tmp___0 != 0L) {
#line 1953
    return ((char *)((void *)-1));
  }
#line 1956
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 1958
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 1958
    scf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 1960
    if ((unsigned long )scf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 1961
      return ((char *)((void *)-1));
    }
#line 1964
    *(scf->upstream.cache_value) = cv;
#line 1966
    return ((char *)((void *)0));
  }
  {
#line 1969
  scf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t___0 )0,
                                                   (void *)(& ngx_http_scgi_module));
  }
#line 1971
  if ((unsigned long )scf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 1972
    return ((char *)((void *)-1));
  }
#line 1975
  return ((char *)((void *)0));
}
}
#line 1979 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;

  {
#line 1982
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1987
  value = (ngx_str_t *)(cf->args)->elts;
#line 1989
  if (scf->cache_key.value.data) {
#line 1990
    return ((char *)"is duplicate");
  }
  {
#line 1993
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 1995
  ccv.cf = cf;
#line 1996
  ccv.value = value + 1;
#line 1997
  ccv.complex_value = & scf->cache_key;
#line 1999
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 1999
  if (tmp != 0L) {
#line 2000
    return ((char *)((void *)-1));
  }
#line 2003
  return ((char *)((void *)0));
}
}
#line 173 "src/core/ngx_conf_file.h"
char *ngx_conf_check_num_bounds(ngx_conf_t *cf , void *post , void *data ) ;
#line 281
char *ngx_conf_set_str_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_eval(ngx_http_request_t *r , ngx_http_uwsgi_loc_conf_t *uwcf ) ;
#line 66
static ngx_int_t ngx_http_uwsgi_create_request(ngx_http_request_t *r ) ;
#line 67
static ngx_int_t ngx_http_uwsgi_reinit_request(ngx_http_request_t *r ) ;
#line 68
static ngx_int_t ngx_http_uwsgi_process_status_line(ngx_http_request_t *r ) ;
#line 69
static ngx_int_t ngx_http_uwsgi_process_header(ngx_http_request_t *r ) ;
#line 70
static void ngx_http_uwsgi_abort_request(ngx_http_request_t *r ) ;
#line 71
static void ngx_http_uwsgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 74
static void *ngx_http_uwsgi_create_main_conf(ngx_conf_t *cf ) ;
#line 75
static void *ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf ) ;
#line 76
static char *ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 78
static ngx_int_t ngx_http_uwsgi_init_params(ngx_conf_t *cf , ngx_http_uwsgi_loc_conf_t *conf ,
                                            ngx_http_uwsgi_params_t *params , ngx_keyval_t *default_params ) ;
#line 82
static char *ngx_http_uwsgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 84
static char *ngx_http_uwsgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 88
static ngx_int_t ngx_http_uwsgi_create_key(ngx_http_request_t *r ) ;
#line 89
static char *ngx_http_uwsgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 91
static char *ngx_http_uwsgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 103 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_conf_num_bounds_t ngx_http_uwsgi_modifier_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )0, (ngx_int_t )255};
#line 108 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_conf_bitmask_t ngx_http_uwsgi_next_upstream_masks[12]  = 
#line 108
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 142 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_command_t ngx_http_uwsgi_commands[47]  = 
#line 142
  {      {{sizeof("uwsgi_pass") - 1UL, (u_char *)"uwsgi_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_uwsgi_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_modifier1") - 1UL, (u_char *)"uwsgi_modifier1"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->modifier1), (void *)(& ngx_http_uwsgi_modifier_bounds)}, 
        {{sizeof("uwsgi_modifier2") - 1UL,
       (u_char *)"uwsgi_modifier2"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->modifier2),
      (void *)(& ngx_http_uwsgi_modifier_bounds)}, 
        {{sizeof("uwsgi_store") - 1UL, (u_char *)"uwsgi_store"}, (ngx_uint_t )234881026,
      & ngx_http_uwsgi_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_store_access") - 1UL, (u_char *)"uwsgi_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("uwsgi_buffering") - 1UL, (u_char *)"uwsgi_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.buffering), (void *)0}, 
        {{sizeof("uwsgi_request_buffering") - 1UL,
       (u_char *)"uwsgi_request_buffering"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("uwsgi_ignore_client_abort") - 1UL, (u_char *)"uwsgi_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("uwsgi_bind") - 1UL, (u_char *)"uwsgi_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("uwsgi_connect_timeout") - 1UL,
       (u_char *)"uwsgi_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_send_timeout") - 1UL, (u_char *)"uwsgi_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_buffer_size") - 1UL, (u_char *)"uwsgi_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("uwsgi_pass_request_headers") - 1UL, (u_char *)"uwsgi_pass_request_headers"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("uwsgi_pass_request_body") - 1UL, (u_char *)"uwsgi_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("uwsgi_intercept_errors") - 1UL, (u_char *)"uwsgi_intercept_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("uwsgi_read_timeout") - 1UL, (u_char *)"uwsgi_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_buffers") - 1UL, (u_char *)"uwsgi_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("uwsgi_busy_buffers_size") - 1UL,
       (u_char *)"uwsgi_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("uwsgi_force_ranges") - 1UL, (u_char *)"uwsgi_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("uwsgi_limit_rate") - 1UL, (u_char *)"uwsgi_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.limit_rate), (void *)0}, 
        {{sizeof("uwsgi_cache") - 1UL,
       (u_char *)"uwsgi_cache"}, (ngx_uint_t )234881026, & ngx_http_uwsgi_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_cache_key") - 1UL, (u_char *)"uwsgi_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_uwsgi_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_cache_path") - 1UL, (u_char *)"uwsgi_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_uwsgi_main_conf_t *)0)->caches), (void *)(& ngx_http_uwsgi_module)}, 
        {{sizeof("uwsgi_cache_bypass") - 1UL,
       (u_char *)"uwsgi_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("uwsgi_no_cache") - 1UL, (u_char *)"uwsgi_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("uwsgi_cache_valid") - 1UL,
       (u_char *)"uwsgi_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("uwsgi_cache_min_uses") - 1UL, (u_char *)"uwsgi_cache_min_uses"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("uwsgi_cache_max_range_offset") - 1UL, (u_char *)"uwsgi_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("uwsgi_cache_use_stale") - 1UL, (u_char *)"uwsgi_cache_use_stale"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_uwsgi_next_upstream_masks)}, 
        {{sizeof("uwsgi_cache_methods") - 1UL, (u_char *)"uwsgi_cache_methods"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("uwsgi_cache_lock") - 1UL, (u_char *)"uwsgi_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_lock), (void *)0}, 
        {{sizeof("uwsgi_cache_lock_timeout") - 1UL,
       (u_char *)"uwsgi_cache_lock_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_cache_lock_age") - 1UL, (u_char *)"uwsgi_cache_lock_age"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("uwsgi_cache_revalidate") - 1UL, (u_char *)"uwsgi_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("uwsgi_cache_background_update") - 1UL, (u_char *)"uwsgi_cache_background_update"},
      (ngx_uint_t )234881026, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("uwsgi_temp_path") - 1UL, (u_char *)"uwsgi_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.temp_path), (void *)0}, 
        {{sizeof("uwsgi_max_temp_file_size") - 1UL,
       (u_char *)"uwsgi_max_temp_file_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("uwsgi_temp_file_write_size") - 1UL, (u_char *)"uwsgi_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("uwsgi_next_upstream") - 1UL, (u_char *)"uwsgi_next_upstream"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_uwsgi_next_upstream_masks)}, 
        {{sizeof("uwsgi_next_upstream_tries") - 1UL, (u_char *)"uwsgi_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("uwsgi_next_upstream_timeout") - 1UL, (u_char *)"uwsgi_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_param") - 1UL, (u_char *)"uwsgi_param"}, (ngx_uint_t )234881036,
      & ngx_http_upstream_param_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->params_source), (void *)0}, 
        {{sizeof("uwsgi_string") - 1UL,
       (u_char *)"uwsgi_string"}, (ngx_uint_t )234881026, & ngx_conf_set_str_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->uwsgi_string),
      (void *)0}, 
        {{sizeof("uwsgi_pass_header") - 1UL, (u_char *)"uwsgi_pass_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("uwsgi_hide_header") - 1UL, (u_char *)"uwsgi_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("uwsgi_ignore_headers") - 1UL, (u_char *)"uwsgi_ignore_headers"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 562 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_http_module_t ngx_http_uwsgi_module_ctx  = 
#line 562
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_uwsgi_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_uwsgi_create_loc_conf, & ngx_http_uwsgi_merge_loc_conf};
#line 577 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
ngx_module_t ngx_http_uwsgi_module  = 
#line 577
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_uwsgi_module_ctx),
    ngx_http_uwsgi_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 593 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_str_t ngx_http_uwsgi_hide_headers[6]  = {      {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}};
#line 605 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_keyval_t ngx_http_uwsgi_cache_headers[7]  = {      {{sizeof("HTTP_IF_MODIFIED_SINCE") - 1UL, (u_char *)"HTTP_IF_MODIFIED_SINCE"},
      {sizeof("$upstream_cache_last_modified") - 1UL, (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("HTTP_IF_UNMODIFIED_SINCE") - 1UL,
       (u_char *)"HTTP_IF_UNMODIFIED_SINCE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_NONE_MATCH") - 1UL, (u_char *)"HTTP_IF_NONE_MATCH"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                             (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("HTTP_IF_MATCH") - 1UL,
       (u_char *)"HTTP_IF_MATCH"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_RANGE") - 1UL, (u_char *)"HTTP_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_RANGE") - 1UL,
       (u_char *)"HTTP_IF_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, {(size_t___0 )0, (u_char *)((void *)0)}}};
#line 619 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_path_init_t ngx_http_uwsgi_temp_path  =    {{sizeof("uwsgi_temp") - 1UL, (u_char *)"uwsgi_temp"}, {(size_t___0 )1, (size_t___0 )2,
                                                           (size_t___0 )0}};
#line 624 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_http_uwsgi_main_conf_t *uwmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 635
  tmp = ngx_http_upstream_create(r);
  }
#line 635
  if (tmp != 0L) {
#line 636
    return ((ngx_int_t )500);
  }
  {
#line 639
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t ));
#line 639
  status = (ngx_http_status_t *)tmp___0;
  }
#line 640
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 641
    return ((ngx_int_t )500);
  }
#line 644
  *(r->ctx + ngx_http_uwsgi_module.ctx_index) = (void *)status;
#line 646
  uwcf = (ngx_http_uwsgi_loc_conf_t *)*(r->loc_conf + ngx_http_uwsgi_module.ctx_index);
#line 648
  u = r->upstream;
#line 650
  if ((unsigned long )uwcf->uwsgi_lengths == (unsigned long )((void *)0)) {
#line 662
    u->schema.len = sizeof("uwsgi://") - 1UL;
#line 662
    u->schema.data = (u_char *)"uwsgi://";
  } else {
    {
#line 666
    tmp___1 = ngx_http_uwsgi_eval(r, uwcf);
    }
#line 666
    if (tmp___1 != 0L) {
#line 667
      return ((ngx_int_t )500);
    }
  }
  {
#line 671
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_uwsgi_module);
#line 673
  u->conf = & uwcf->upstream;
#line 676
  uwmcf = (ngx_http_uwsgi_main_conf_t *)*(r->main_conf + ngx_http_uwsgi_module.ctx_index);
#line 678
  u->caches = & uwmcf->caches;
#line 679
  u->create_key = & ngx_http_uwsgi_create_key;
#line 682
  u->create_request = & ngx_http_uwsgi_create_request;
#line 683
  u->reinit_request = & ngx_http_uwsgi_reinit_request;
#line 684
  u->process_header = & ngx_http_uwsgi_process_status_line;
#line 685
  u->abort_request = & ngx_http_uwsgi_abort_request;
#line 686
  u->finalize_request = & ngx_http_uwsgi_finalize_request;
#line 687
  r->state = (ngx_uint_t )0;
#line 689
  u->buffering = (unsigned int )uwcf->upstream.buffering;
#line 691
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 691
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 692
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 693
    return ((ngx_int_t )500);
  }
#line 696
  (u->pipe)->input_filter = & ngx_event_pipe_copy_input_filter;
#line 697
  (u->pipe)->input_ctx = (void *)r;
#line 699
  if (! uwcf->upstream.request_buffering) {
#line 699
    if (uwcf->upstream.pass_request_body) {
#line 699
      if (! r->headers_in.chunked) {
#line 703
        r->request_body_no_buffering = 1U;
      }
    }
  }
  {
#line 706
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 708
  if (rc >= 300L) {
#line 709
    return (rc);
  }
#line 712
  return ((ngx_int_t )-4);
}
}
#line 716 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_eval(ngx_http_request_t *r , ngx_http_uwsgi_loc_conf_t *uwcf ) 
{ 
  size_t___0 add ;
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 723
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 725
  tmp = ngx_http_script_run(r, & url.url, (uwcf->uwsgi_lengths)->elts, (size_t___0 )0,
                            (uwcf->uwsgi_values)->elts);
  }
#line 725
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 729
    return ((ngx_int_t )-1);
  }
#line 732
  if (url.url.len > 8UL) {
    {
#line 732
    tmp___1 = ngx_strncasecmp(url.url.data, (u_char *)"uwsgi://", (size_t___0 )8);
    }
#line 732
    if (tmp___1 == 0L) {
#line 735
      add = (size_t___0 )8;
    } else {
#line 732
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 737
  if (url.url.len > 9UL) {
    {
#line 737
    tmp___0 = ngx_strncasecmp(url.url.data, (u_char *)"suwsgi://", (size_t___0 )9);
    }
#line 737
    if (tmp___0 == 0L) {
#line 745
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 745
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "suwsgi protocol requires SSL support");
        }
      }
#line 747
      return ((ngx_int_t )-1);
    } else {
#line 751
      add = (size_t___0 )0;
    }
  } else {
#line 751
    add = (size_t___0 )0;
  }
#line 754
  u = r->upstream;
#line 756
  if (add) {
#line 757
    u->schema.len = add;
#line 758
    u->schema.data = url.url.data;
#line 760
    url.url.data += add;
#line 761
    url.url.len -= add;
  } else {
#line 764
    u->schema.len = sizeof("uwsgi://") - 1UL;
#line 764
    u->schema.data = (u_char *)"uwsgi://";
  }
  {
#line 767
  url.no_resolve = 1U;
#line 769
  tmp___2 = ngx_parse_url(r->pool, & url);
  }
#line 769
  if (tmp___2 != 0L) {
#line 770
    if (url.err) {
#line 771
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 771
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 775
    return ((ngx_int_t )-1);
  }
  {
#line 778
  tmp___3 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 778
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___3;
  }
#line 779
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 780
    return ((ngx_int_t )-1);
  }
#line 783
  if (url.addrs) {
#line 784
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 785
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 786
    (u->resolved)->name = (url.addrs + 0)->name;
#line 787
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 790
  (u->resolved)->host = url.host;
#line 791
  (u->resolved)->port = url.port;
#line 792
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 794
  return ((ngx_int_t )0);
}
}
#line 800 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_create_key(ngx_http_request_t *r ) 
{ 
  ngx_str_t *key ;
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 806
  tmp = ngx_array_push(& (r->cache)->keys);
#line 806
  key = (ngx_str_t *)tmp;
  }
#line 807
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 808
    return ((ngx_int_t )-1);
  }
  {
#line 811
  uwcf = (ngx_http_uwsgi_loc_conf_t *)*(r->loc_conf + ngx_http_uwsgi_module.ctx_index);
#line 813
  tmp___0 = ngx_http_complex_value(r, & uwcf->cache_key, key);
  }
#line 813
  if (tmp___0 != 0L) {
#line 814
    return ((ngx_int_t )-1);
  }
#line 817
  return ((ngx_int_t )0);
}
}
#line 823 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_create_request(ngx_http_request_t *r ) 
{ 
  u_char ch ;
  u_char *lowcase_key ;
  size_t___0 key_len ;
  size_t___0 val_len ;
  size_t___0 len ;
  size_t___0 allocated ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_uint_t skip_empty ;
  ngx_uint_t header_params ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_table_elt_t **ignored ;
  ngx_http_uwsgi_params_t *params ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  size_t___0 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_uint_t tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  size_t___0 tmp___8 ;
  size_t___0 tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  void *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;

  {
#line 839
  len = (size_t___0 )0;
#line 840
  header_params = (ngx_uint_t )0;
#line 841
  ignored = (ngx_table_elt_t **)((void *)0);
#line 843
  uwcf = (ngx_http_uwsgi_loc_conf_t *)*(r->loc_conf + ngx_http_uwsgi_module.ctx_index);
#line 846
  if ((r->upstream)->cacheable) {
#line 846
    params = & uwcf->params_cache;
  } else {
#line 846
    params = & uwcf->params;
  }
#line 851
  if (params->lengths) {
    {
#line 852
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 854
    ngx_http_script_flush_no_cacheable_variables(r, params->flushes);
#line 855
    le.flushed = 1U;
#line 857
    le.ip = (u_char *)(params->lengths)->elts;
#line 858
    le.request = r;
    }
    {
#line 860
    while (1) {
      while_continue: /* CIL Label */ ;
#line 860
      if (! *((uintptr_t *)le.ip)) {
#line 860
        goto while_break;
      }
      {
#line 862
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 863
      key_len = (*lcode)(& le);
#line 865
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 866
      skip_empty = (*lcode)(& le);
#line 868
      val_len = (size_t___0 )0;
      }
      {
#line 868
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 868
        if (! *((uintptr_t *)le.ip)) {
#line 868
          goto while_break___0;
        }
        {
#line 869
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 868
        tmp = (*lcode)(& le);
#line 868
        val_len += tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 871
      le.ip += sizeof(uintptr_t );
#line 873
      if (skip_empty) {
#line 873
        if (val_len == 0UL) {
#line 874
          goto while_continue;
        }
      }
#line 877
      len += ((2UL + key_len) + 2UL) + val_len;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 881
  if (uwcf->upstream.pass_request_headers) {
#line 883
    allocated = (size_t___0 )0;
#line 884
    lowcase_key = (u_char *)((void *)0);
#line 886
    if (params->number) {
#line 887
      n = (ngx_uint_t )0;
#line 888
      part = & r->headers_in.headers.part;
      {
#line 890
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 890
        if (! part) {
#line 890
          goto while_break___1;
        }
#line 891
        n += part->nelts;
#line 892
        part = part->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 895
      tmp___0 = ngx_palloc(r->pool, n * sizeof(void *));
#line 895
      ignored = (ngx_table_elt_t **)tmp___0;
      }
#line 896
      if ((unsigned long )ignored == (unsigned long )((void *)0)) {
#line 897
        return ((ngx_int_t )-1);
      }
    }
#line 901
    part = & r->headers_in.headers.part;
#line 902
    header___0 = (ngx_table_elt_t *)part->elts;
#line 904
    i = (ngx_uint_t )0;
    {
#line 904
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 906
      if (i >= part->nelts) {
#line 907
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 908
          goto while_break___2;
        }
#line 911
        part = part->next;
#line 912
        header___0 = (ngx_table_elt_t *)part->elts;
#line 913
        i = (ngx_uint_t )0;
      }
#line 916
      if (params->number) {
#line 917
        if (allocated < (header___0 + i)->key.len) {
          {
#line 918
          allocated = (header___0 + i)->key.len + 16UL;
#line 919
          tmp___1 = ngx_pnalloc(r->pool, allocated);
#line 919
          lowcase_key = (u_char *)tmp___1;
          }
#line 920
          if ((unsigned long )lowcase_key == (unsigned long )((void *)0)) {
#line 921
            return ((ngx_int_t )-1);
          }
        }
#line 925
        hash = (ngx_uint_t )0;
#line 927
        n = (ngx_uint_t )0;
        {
#line 927
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 927
          if (! (n < (header___0 + i)->key.len)) {
#line 927
            goto while_break___3;
          }
#line 928
          ch = *((header___0 + i)->key.data + n);
#line 930
          if ((int )ch >= 65) {
#line 930
            if ((int )ch <= 90) {
#line 931
              ch = (u_char )((int )ch | 32);
            } else {
#line 930
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 933
          if ((int )ch == 45) {
#line 934
            ch = (u_char )'_';
          }
#line 937
          hash = hash * 31UL + (ngx_uint_t )ch;
#line 938
          *(lowcase_key + n) = ch;
#line 927
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 941
        tmp___3 = ngx_hash_find(& params->hash, hash, lowcase_key, n);
        }
#line 941
        if (tmp___3) {
#line 942
          tmp___2 = header_params;
#line 942
          header_params ++;
#line 942
          *(ignored + tmp___2) = header___0 + i;
#line 943
          goto __Cont;
        }
      }
#line 947
      len += ((((2UL + sizeof("HTTP_")) - 1UL) + (header___0 + i)->key.len) + 2UL) + (header___0 + i)->value.len;
      __Cont: /* CIL Label */ 
#line 904
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 952
  len += uwcf->uwsgi_string.len;
#line 963
  b = ngx_create_temp_buf(r->pool, len + 4UL);
  }
#line 964
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 965
    return ((ngx_int_t )-1);
  }
  {
#line 968
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 969
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 970
    return ((ngx_int_t )-1);
  }
#line 973
  cl->buf = b;
#line 975
  tmp___4 = b->last;
#line 975
  (b->last) ++;
#line 975
  *tmp___4 = (u_char )uwcf->modifier1;
#line 976
  tmp___5 = b->last;
#line 976
  (b->last) ++;
#line 976
  *tmp___5 = (u_char )(len & 255UL);
#line 977
  tmp___6 = b->last;
#line 977
  (b->last) ++;
#line 977
  *tmp___6 = (u_char )((len >> 8) & 255UL);
#line 978
  tmp___7 = b->last;
#line 978
  (b->last) ++;
#line 978
  *tmp___7 = (u_char )uwcf->modifier2;
#line 980
  if (params->lengths) {
    {
#line 981
    memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 983
    e.ip = (u_char *)(params->values)->elts;
#line 984
    e.pos = b->last;
#line 985
    e.request = r;
#line 986
    e.flushed = 1U;
#line 988
    le.ip = (u_char *)(params->lengths)->elts;
    }
    {
#line 990
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 990
      if (! *((uintptr_t *)le.ip)) {
#line 990
        goto while_break___4;
      }
      {
#line 992
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 993
      tmp___8 = (*lcode)(& le);
#line 993
      key_len = (size_t___0 )((u_char )tmp___8);
#line 995
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 996
      skip_empty = (*lcode)(& le);
#line 998
      val_len = (size_t___0 )0;
      }
      {
#line 998
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 998
        if (! *((uintptr_t *)le.ip)) {
#line 998
          goto while_break___5;
        }
        {
#line 999
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 998
        tmp___9 = (*lcode)(& le);
#line 998
        val_len += tmp___9;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1001
      le.ip += sizeof(uintptr_t );
#line 1003
      if (skip_empty) {
#line 1003
        if (val_len == 0UL) {
#line 1004
          e.skip = 1U;
          {
#line 1006
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1006
            if (! *((uintptr_t *)e.ip)) {
#line 1006
              goto while_break___6;
            }
            {
#line 1007
            code = *((ngx_http_script_code_pt *)e.ip);
#line 1008
            (*code)(& e);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1010
          e.ip += sizeof(uintptr_t );
#line 1012
          e.skip = 0U;
#line 1014
          goto while_continue___4;
        }
      }
      {
#line 1017
      tmp___10 = e.pos;
#line 1017
      (e.pos) ++;
#line 1017
      *tmp___10 = (u_char )(key_len & 255UL);
#line 1018
      tmp___11 = e.pos;
#line 1018
      (e.pos) ++;
#line 1018
      *tmp___11 = (u_char )((key_len >> 8) & 255UL);
#line 1020
      code = *((ngx_http_script_code_pt *)e.ip);
#line 1021
      (*code)(& e);
#line 1023
      tmp___12 = e.pos;
#line 1023
      (e.pos) ++;
#line 1023
      *tmp___12 = (u_char )(val_len & 255UL);
#line 1024
      tmp___13 = e.pos;
#line 1024
      (e.pos) ++;
#line 1024
      *tmp___13 = (u_char )((val_len >> 8) & 255UL);
      }
      {
#line 1026
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1026
        if (! *((uintptr_t *)e.ip)) {
#line 1026
          goto while_break___7;
        }
        {
#line 1027
        code = *((ngx_http_script_code_pt *)e.ip);
#line 1028
        (*code)(& e);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1031
      e.ip += sizeof(uintptr_t );
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1039
    b->last = e.pos;
  }
#line 1042
  if (uwcf->upstream.pass_request_headers) {
#line 1044
    part = & r->headers_in.headers.part;
#line 1045
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1047
    i = (ngx_uint_t )0;
    {
#line 1047
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1049
      if (i >= part->nelts) {
#line 1050
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1051
          goto while_break___8;
        }
#line 1054
        part = part->next;
#line 1055
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1056
        i = (ngx_uint_t )0;
      }
#line 1059
      n = (ngx_uint_t )0;
      {
#line 1059
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1059
        if (! (n < header_params)) {
#line 1059
          goto while_break___9;
        }
#line 1060
        if ((unsigned long )(header___0 + i) == (unsigned long )*(ignored + n)) {
#line 1061
          goto next;
        }
#line 1059
        n ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1065
      key_len = (sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len;
#line 1066
      tmp___14 = b->last;
#line 1066
      (b->last) ++;
#line 1066
      *tmp___14 = (u_char )(key_len & 255UL);
#line 1067
      tmp___15 = b->last;
#line 1067
      (b->last) ++;
#line 1067
      *tmp___15 = (u_char )((key_len >> 8) & 255UL);
#line 1069
      tmp___16 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"HTTP_",
                        sizeof("HTTP_") - 1UL);
#line 1069
      b->last = (u_char *)tmp___16 + (sizeof("HTTP_") - 1UL);
#line 1070
      n = (ngx_uint_t )0;
      }
      {
#line 1070
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1070
        if (! (n < (header___0 + i)->key.len)) {
#line 1070
          goto while_break___10;
        }
#line 1071
        ch = *((header___0 + i)->key.data + n);
#line 1073
        if ((int )ch >= 97) {
#line 1073
          if ((int )ch <= 122) {
#line 1074
            ch = (u_char )((int )ch & -33);
          } else {
#line 1073
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1076
        if ((int )ch == 45) {
#line 1077
          ch = (u_char )'_';
        }
#line 1080
        tmp___17 = b->last;
#line 1080
        (b->last) ++;
#line 1080
        *tmp___17 = ch;
#line 1070
        n ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1083
      val_len = (header___0 + i)->value.len;
#line 1084
      tmp___18 = b->last;
#line 1084
      (b->last) ++;
#line 1084
      *tmp___18 = (u_char )(val_len & 255UL);
#line 1085
      tmp___19 = b->last;
#line 1085
      (b->last) ++;
#line 1085
      *tmp___19 = (u_char )((val_len >> 8) & 255UL);
#line 1086
      tmp___20 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        val_len);
#line 1086
      b->last = (u_char *)tmp___20 + val_len;
      }
      next: 
#line 1094
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1047
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 1098
  tmp___21 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)uwcf->uwsgi_string.data,
                    uwcf->uwsgi_string.len);
#line 1098
  b->last = (u_char *)tmp___21 + uwcf->uwsgi_string.len;
  }
#line 1101
  if (r->request_body_no_buffering) {
#line 1102
    (r->upstream)->request_bufs = cl;
  } else
#line 1104
  if (uwcf->upstream.pass_request_body) {
#line 1105
    body = (r->upstream)->request_bufs;
#line 1106
    (r->upstream)->request_bufs = cl;
    {
#line 1108
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1108
      if (! body) {
#line 1108
        goto while_break___11;
      }
      {
#line 1109
      tmp___22 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 1109
      b = (ngx_buf_t *)tmp___22;
      }
#line 1110
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1111
        return ((ngx_int_t )-1);
      }
      {
#line 1114
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
             sizeof(ngx_buf_t ));
#line 1116
      cl->next = ngx_alloc_chain_link(r->pool);
      }
#line 1117
      if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1118
        return ((ngx_int_t )-1);
      }
#line 1121
      cl = cl->next;
#line 1122
      cl->buf = b;
#line 1124
      body = body->next;
    }
    while_break___11: /* CIL Label */ ;
    }
  } else {
#line 1128
    (r->upstream)->request_bufs = cl;
  }
#line 1131
  cl->next = (ngx_chain_t *)((void *)0);
#line 1133
  return ((ngx_int_t )0);
}
}
#line 1137 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_status_t *status ;

  {
#line 1142
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_uwsgi_module.ctx_index);
#line 1144
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 1145
    return ((ngx_int_t )0);
  }
#line 1148
  status->code = (ngx_uint_t )0;
#line 1149
  status->count = (ngx_uint_t )0;
#line 1150
  status->start = (u_char *)((void *)0);
#line 1151
  status->end = (u_char *)((void *)0);
#line 1153
  (r->upstream)->process_header = & ngx_http_uwsgi_process_status_line;
#line 1154
  r->state = (ngx_uint_t )0;
#line 1156
  return ((ngx_int_t )0);
}
}
#line 1160 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_process_status_line(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1168
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_uwsgi_module.ctx_index);
#line 1170
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 1171
    return ((ngx_int_t )-1);
  }
  {
#line 1174
  u = r->upstream;
#line 1176
  rc = ngx_http_parse_status_line(r, & u->buffer, status);
  }
#line 1178
  if (rc == -2L) {
#line 1179
    return (rc);
  }
#line 1182
  if (rc == -1L) {
    {
#line 1183
    u->process_header = & ngx_http_uwsgi_process_header;
#line 1184
    tmp = ngx_http_uwsgi_process_header(r);
    }
#line 1184
    return (tmp);
  }
#line 1187
  if (u->state) {
#line 1187
    if ((u->state)->status == 0UL) {
#line 1188
      (u->state)->status = status->code;
    }
  }
  {
#line 1191
  u->headers_in.status_n = status->code;
#line 1193
  len = (size_t___0 )(status->end - status->start);
#line 1194
  u->headers_in.status_line.len = len;
#line 1196
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 1196
  u->headers_in.status_line.data = (u_char *)tmp___0;
  }
#line 1197
  if ((unsigned long )u->headers_in.status_line.data == (unsigned long )((void *)0)) {
#line 1198
    return ((ngx_int_t )-1);
  }
  {
#line 1201
  memcpy((void */* __restrict  */)u->headers_in.status_line.data, (void const   */* __restrict  */)status->start,
         len);
#line 1207
  u->process_header = & ngx_http_uwsgi_process_header;
#line 1209
  tmp___1 = ngx_http_uwsgi_process_header(r);
  }
#line 1209
  return (tmp___1);
}
}
#line 1213 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_process_header(ngx_http_request_t *r ) 
{ 
  ngx_str_t *status_line ;
  ngx_int_t rc ;
  ngx_int_t status ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1223
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
  {
#line 1225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1227
    rc = ngx_http_parse_header_line(r, & (r->upstream)->buffer, (ngx_uint_t )1);
    }
#line 1229
    if (rc == 0L) {
      {
#line 1233
      tmp = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1233
      h = (ngx_table_elt_t *)tmp;
      }
#line 1234
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1235
        return ((ngx_int_t )-1);
      }
      {
#line 1238
      h->hash = r->header_hash;
#line 1240
      h->key.len = (size_t___0 )(r->header_name_end - r->header_name_start);
#line 1241
      h->value.len = (size_t___0 )(r->header_end - r->header_start);
#line 1243
      tmp___0 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1243
      h->key.data = (u_char *)tmp___0;
      }
#line 1246
      if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1247
        h->hash = (ngx_uint_t )0;
#line 1248
        return ((ngx_int_t )-1);
      }
      {
#line 1251
      h->value.data = (h->key.data + h->key.len) + 1;
#line 1252
      h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1254
      memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
             h->key.len);
#line 1255
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1256
      memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
             h->value.len);
#line 1257
      *(h->value.data + h->value.len) = (u_char )'\000';
      }
#line 1259
      if (h->key.len == r->lowcase_index) {
        {
#line 1260
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1263
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1266
      tmp___1 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1266
      hh = (ngx_http_upstream_header_t *)tmp___1;
      }
#line 1269
      if (hh) {
        {
#line 1269
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1269
        if (tmp___2 != 0L) {
#line 1270
          return ((ngx_int_t )-1);
        }
      }
#line 1276
      goto __Cont;
    }
#line 1279
    if (rc == 1L) {
#line 1286
      u = r->upstream;
#line 1288
      if (u->headers_in.status_n) {
#line 1289
        goto done;
      }
#line 1292
      if (u->headers_in.status) {
        {
#line 1293
        status_line = & (u->headers_in.status)->value;
#line 1295
        status = ngx_atoi(status_line->data, (size_t___0 )3);
        }
#line 1296
        if (status == -1L) {
#line 1297
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1297
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid status \"%V\"",
                               status_line);
            }
          }
#line 1300
          return ((ngx_int_t )40);
        }
#line 1303
        u->headers_in.status_n = (ngx_uint_t )status;
#line 1304
        u->headers_in.status_line = *status_line;
      } else
#line 1306
      if (u->headers_in.location) {
#line 1307
        u->headers_in.status_n = (ngx_uint_t )302;
#line 1308
        u->headers_in.status_line.len = sizeof("302 Moved Temporarily") - 1UL;
#line 1308
        u->headers_in.status_line.data = (u_char *)"302 Moved Temporarily";
      } else {
#line 1312
        u->headers_in.status_n = (ngx_uint_t )200;
#line 1313
        u->headers_in.status_line.len = sizeof("200 OK") - 1UL;
#line 1313
        u->headers_in.status_line.data = (u_char *)"200 OK";
      }
#line 1316
      if (u->state) {
#line 1316
        if ((u->state)->status == 0UL) {
#line 1317
          (u->state)->status = u->headers_in.status_n;
        }
      }
      done: 
#line 1322
      if (u->headers_in.status_n == 101UL) {
#line 1322
        if (r->headers_in.upgrade) {
#line 1325
          u->upgrade = 1U;
        }
      }
#line 1328
      return ((ngx_int_t )0);
    }
#line 1331
    if (rc == -2L) {
#line 1332
      return ((ngx_int_t )-2);
    }
#line 1337
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1337
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
      }
    }
#line 1340
    return ((ngx_int_t )40);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1345 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static void ngx_http_uwsgi_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 1351
  return;
}
}
#line 1355 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static void ngx_http_uwsgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 1361
  return;
}
}
#line 1365 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static void *ngx_http_uwsgi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_uwsgi_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1370
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_uwsgi_main_conf_t ));
#line 1370
  conf = (ngx_http_uwsgi_main_conf_t *)tmp;
  }
#line 1371
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1372
    return ((void *)0);
  }
  {
#line 1376
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 1376
  if (tmp___0 != 0L) {
#line 1380
    return ((void *)0);
  }
#line 1384
  return ((void *)conf);
}
}
#line 1388 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static void *ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1393
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_uwsgi_loc_conf_t ));
#line 1393
  conf = (ngx_http_uwsgi_loc_conf_t *)tmp;
  }
#line 1394
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1395
    return ((void *)0);
  }
#line 1398
  conf->modifier1 = (ngx_uint_t )-1;
#line 1399
  conf->modifier2 = (ngx_uint_t )-1;
#line 1401
  conf->upstream.store = -1;
#line 1402
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 1403
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 1404
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 1405
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 1406
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 1407
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 1409
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 1411
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 1412
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 1413
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 1414
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 1416
  conf->upstream.send_lowat = (size_t___0 )-1;
#line 1417
  conf->upstream.buffer_size = (size_t___0 )-1;
#line 1418
  conf->upstream.limit_rate = (size_t___0 )-1;
#line 1420
  conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
#line 1421
  conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
#line 1422
  conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
#line 1424
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 1425
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 1428
  conf->upstream.cache = -1;
#line 1429
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 1430
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 1431
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 1432
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 1433
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 1434
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 1435
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 1436
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 1437
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 1438
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 1441
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 1442
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 1444
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 1455
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 1457
  conf->upstream.change_buffering = 1U;
#line 1459
  conf->upstream.module.len = sizeof("uwsgi") - 1UL;
#line 1459
  conf->upstream.module.data = (u_char *)"uwsgi";
#line 1461
  return ((void *)conf);
}
}
#line 1465 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_uwsgi_loc_conf_t *prev ;
  ngx_http_uwsgi_loc_conf_t *conf ;
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  ngx_int_t tmp___0 ;

  {
#line 1468
  prev = (ngx_http_uwsgi_loc_conf_t *)parent;
#line 1469
  conf = (ngx_http_uwsgi_loc_conf_t *)child;
#line 1478
  if (conf->upstream.store > 0) {
#line 1479
    conf->upstream.cache = 0;
  }
#line 1482
  if (conf->upstream.cache > 0) {
#line 1483
    conf->upstream.store = 0;
  }
#line 1488
  if (conf->upstream.store == -1) {
#line 1489
    if (conf->upstream.store == -1) {
#line 1489
      if (prev->upstream.store == -1) {
#line 1489
        conf->upstream.store = 0;
      } else {
#line 1489
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 1491
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 1492
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 1495
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 1495
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 1495
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 1495
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 1498
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1498
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1498
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 1498
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 1501
  if (conf->upstream.buffering == -1L) {
#line 1501
    if (prev->upstream.buffering == -1L) {
#line 1501
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 1501
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 1504
  if (conf->upstream.request_buffering == -1L) {
#line 1504
    if (prev->upstream.request_buffering == -1L) {
#line 1504
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 1504
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 1507
  if (conf->upstream.ignore_client_abort == -1L) {
#line 1507
    if (prev->upstream.ignore_client_abort == -1L) {
#line 1507
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 1507
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 1510
  if (conf->upstream.force_ranges == -1L) {
#line 1510
    if (prev->upstream.force_ranges == -1L) {
#line 1510
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 1510
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 1513
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 1513
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 1513
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 1513
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 1516
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1516
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1516
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 1516
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 1519
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1519
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1519
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 1519
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 1522
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1522
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1522
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 1522
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 1525
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1525
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1525
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 1525
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 1528
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1528
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1528
      conf->upstream.send_lowat = (size_t___0 )0;
    } else {
#line 1528
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 1531
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1531
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1531
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 1531
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 1535
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1535
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1535
      conf->upstream.limit_rate = (size_t___0 )0;
    } else {
#line 1535
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 1539
  if (conf->upstream.bufs.num == 0L) {
#line 1539
    if (prev->upstream.bufs.num) {
#line 1539
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 1539
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 1539
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 1539
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 1542
  if (conf->upstream.bufs.num < 2L) {
    {
#line 1543
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"uwsgi_buffers\"");
    }
#line 1545
    return ((char *)((void *)-1));
  }
#line 1549
  size = conf->upstream.buffer_size;
#line 1550
  if (size < conf->upstream.bufs.size) {
#line 1551
    size = conf->upstream.bufs.size;
  }
#line 1555
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1555
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1555
      conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
    } else {
#line 1555
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 1559
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1560
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 1562
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 1566
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 1567
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"uwsgi_buffer_size\" and one of the \"uwsgi_buffers\"");
    }
#line 1572
    return ((char *)((void *)-1));
  }
#line 1575
  if (conf->upstream.busy_buffers_size > (size_t___0 )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 1578
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_busy_buffers_size\" must be less than the size of all \"uwsgi_buffers\" minus one buffer");
    }
#line 1582
    return ((char *)((void *)-1));
  }
#line 1586
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1586
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1586
      conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
    } else {
#line 1586
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 1590
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1591
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 1593
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 1597
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 1598
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"uwsgi_buffer_size\" and one of the \"uwsgi_buffers\"");
    }
#line 1603
    return ((char *)((void *)-1));
  }
#line 1607
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1607
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1607
      conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
    } else {
#line 1607
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 1611
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1612
    conf->upstream.max_temp_file_size = (size_t___0 )1073741824;
  } else {
#line 1614
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 1618
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 1618
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 1621
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"uwsgi_buffer_size\" and one of the \"uwsgi_buffers\"");
      }
#line 1627
      return ((char *)((void *)-1));
    }
  }
#line 1631
  if (conf->upstream.ignore_headers == 0UL) {
#line 1631
    if (prev->upstream.ignore_headers == 0UL) {
#line 1631
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 1631
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 1636
  if (conf->upstream.next_upstream == 0UL) {
#line 1636
    if (prev->upstream.next_upstream == 0UL) {
#line 1636
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 1636
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 1642
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 1643
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 1647
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_uwsgi_temp_path);
  }
#line 1647
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1652
    return ((char *)((void *)-1));
  }
#line 1657
  if (conf->upstream.cache == -1) {
#line 1658
    if (conf->upstream.cache == -1) {
#line 1658
      if (prev->upstream.cache == -1) {
#line 1658
        conf->upstream.cache = 0;
      } else {
#line 1658
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 1661
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 1662
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 1665
  if (conf->upstream.cache_zone) {
#line 1665
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 1668
      shm_zone = conf->upstream.cache_zone;
#line 1670
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 1674
      return ((char *)((void *)-1));
    }
  }
#line 1677
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1677
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1677
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 1677
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 1680
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 1680
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 1680
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 1680
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 1684
  if (conf->upstream.cache_use_stale == 0UL) {
#line 1684
    if (prev->upstream.cache_use_stale == 0UL) {
#line 1684
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 1684
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 1689
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 1690
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 1694
  if (conf->upstream.cache_use_stale & 2UL) {
#line 1695
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 1698
  if (conf->upstream.cache_methods == 0UL) {
#line 1699
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 1702
  conf->upstream.cache_methods |= 6UL;
#line 1704
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1704
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1704
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 1704
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 1707
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1707
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1707
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 1707
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 1710
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1710
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1710
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 1710
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 1713
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 1714
    conf->cache_key = prev->cache_key;
  }
#line 1717
  if (conf->upstream.cache) {
#line 1717
    if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
      {
#line 1718
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no \"uwsgi_cache_key\" for \"uwsgi_cache\"");
      }
    }
  }
#line 1722
  if (conf->upstream.cache_lock == -1L) {
#line 1722
    if (prev->upstream.cache_lock == -1L) {
#line 1722
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 1722
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 1725
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1725
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1725
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 1725
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 1728
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1728
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1728
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 1728
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 1731
  if (conf->upstream.cache_revalidate == -1L) {
#line 1731
    if (prev->upstream.cache_revalidate == -1L) {
#line 1731
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 1731
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 1734
  if (conf->upstream.cache_background_update == -1L) {
#line 1734
    if (prev->upstream.cache_background_update == -1L) {
#line 1734
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 1734
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 1739
  if (conf->upstream.pass_request_headers == -1L) {
#line 1739
    if (prev->upstream.pass_request_headers == -1L) {
#line 1739
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 1739
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 1741
  if (conf->upstream.pass_request_body == -1L) {
#line 1741
    if (prev->upstream.pass_request_body == -1L) {
#line 1741
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 1741
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 1744
  if (conf->upstream.intercept_errors == -1L) {
#line 1744
    if (prev->upstream.intercept_errors == -1L) {
#line 1744
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 1744
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
#line 1785
  if ((unsigned long )conf->uwsgi_string.data == (unsigned long )((void *)0)) {
#line 1785
    if (prev->uwsgi_string.data) {
#line 1785
      conf->uwsgi_string.len = prev->uwsgi_string.len;
#line 1785
      conf->uwsgi_string.data = prev->uwsgi_string.data;
    } else {
#line 1785
      conf->uwsgi_string.len = sizeof("") - 1UL;
#line 1785
      conf->uwsgi_string.data = (u_char *)"";
    }
  }
  {
#line 1787
  hash.max_size = (ngx_uint_t )512;
#line 1788
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 1789
  hash.name = (char *)"uwsgi_hide_headers_hash";
#line 1791
  tmp___0 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_uwsgi_hide_headers, & hash);
  }
#line 1791
  if (tmp___0 != 0L) {
#line 1795
    return ((char *)((void *)-1));
  }
#line 1798
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1800
  if (clcf->noname) {
#line 1800
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 1800
      if ((unsigned long )conf->uwsgi_lengths == (unsigned long )((void *)0)) {
#line 1803
        conf->upstream.upstream = prev->upstream.upstream;
#line 1805
        conf->uwsgi_lengths = prev->uwsgi_lengths;
#line 1806
        conf->uwsgi_values = prev->uwsgi_values;
      }
    }
  }
#line 1813
  if (clcf->lmt_excpt) {
#line 1813
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 1813
      if (conf->upstream.upstream) {
#line 1816
        clcf->handler = & ngx_http_uwsgi_handler;
      } else
#line 1813
      if (conf->uwsgi_lengths) {
#line 1816
        clcf->handler = & ngx_http_uwsgi_handler;
      }
    }
  }
#line 1819
  if (conf->modifier1 == 0xffffffffffffffffUL) {
#line 1819
    if (prev->modifier1 == 0xffffffffffffffffUL) {
#line 1819
      conf->modifier1 = (ngx_uint_t )0;
    } else {
#line 1819
      conf->modifier1 = prev->modifier1;
    }
  }
#line 1820
  if (conf->modifier2 == 0xffffffffffffffffUL) {
#line 1820
    if (prev->modifier2 == 0xffffffffffffffffUL) {
#line 1820
      conf->modifier2 = (ngx_uint_t )0;
    } else {
#line 1820
      conf->modifier2 = prev->modifier2;
    }
  }
#line 1822
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1823
    conf->params = prev->params;
#line 1825
    conf->params_cache = prev->params_cache;
#line 1827
    conf->params_source = prev->params_source;
  }
  {
#line 1830
  rc = ngx_http_uwsgi_init_params(cf, conf, & conf->params, (ngx_keyval_t *)((void *)0));
  }
#line 1831
  if (rc != 0L) {
#line 1832
    return ((char *)((void *)-1));
  }
#line 1837
  if (conf->upstream.cache) {
    {
#line 1838
    rc = ngx_http_uwsgi_init_params(cf, conf, & conf->params_cache, ngx_http_uwsgi_cache_headers);
    }
#line 1840
    if (rc != 0L) {
#line 1841
      return ((char *)((void *)-1));
    }
  }
#line 1852
  if ((unsigned long )prev->params.hash.buckets == (unsigned long )((void *)0)) {
#line 1852
    if ((unsigned long )conf->params_source == (unsigned long )prev->params_source) {
#line 1855
      prev->params = conf->params;
#line 1857
      prev->params_cache = conf->params_cache;
    }
  }
#line 1861
  return ((char *)((void *)0));
}
}
#line 1865 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_init_params(ngx_conf_t *cf , ngx_http_uwsgi_loc_conf_t *conf ,
                                            ngx_http_uwsgi_params_t *params , ngx_keyval_t *default_params ) 
{ 
  u_char *p ;
  size_t___0 size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_uint_t nsrc ;
  ngx_array_t headers_names ;
  ngx_array_t params_merged ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_upstream_param_t *src ;
  ngx_http_upstream_param_t *s ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;

  {
#line 1881
  if (params->hash.buckets) {
#line 1882
    return ((ngx_int_t )0);
  }
#line 1885
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1885
    if ((unsigned long )default_params == (unsigned long )((void *)0)) {
#line 1886
      params->hash.buckets = (ngx_hash_elt_t **)((void *)1);
#line 1887
      return ((ngx_int_t )0);
    }
  }
  {
#line 1890
  params->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t___0 )1);
  }
#line 1891
  if ((unsigned long )params->lengths == (unsigned long )((void *)0)) {
#line 1892
    return ((ngx_int_t )-1);
  }
  {
#line 1895
  params->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t___0 )1);
  }
#line 1896
  if ((unsigned long )params->values == (unsigned long )((void *)0)) {
#line 1897
    return ((ngx_int_t )-1);
  }
  {
#line 1900
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 1900
  if (tmp != 0L) {
#line 1903
    return ((ngx_int_t )-1);
  }
#line 1906
  if (conf->params_source) {
#line 1907
    src = (ngx_http_upstream_param_t *)(conf->params_source)->elts;
#line 1908
    nsrc = (conf->params_source)->nelts;
  } else {
#line 1911
    src = (ngx_http_upstream_param_t *)((void *)0);
#line 1912
    nsrc = (ngx_uint_t )0;
  }
#line 1915
  if (default_params) {
    {
#line 1916
    tmp___0 = ngx_array_init(& params_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 1916
    if (tmp___0 != 0L) {
#line 1920
      return ((ngx_int_t )-1);
    }
#line 1923
    i = (ngx_uint_t )0;
    {
#line 1923
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1923
      if (! (i < nsrc)) {
#line 1923
        goto while_break;
      }
      {
#line 1925
      tmp___1 = ngx_array_push(& params_merged);
#line 1925
      s = (ngx_http_upstream_param_t *)tmp___1;
      }
#line 1926
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1927
        return ((ngx_int_t )-1);
      }
#line 1930
      *s = *(src + i);
#line 1923
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1933
    h = default_params;
    {
#line 1935
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1935
      if (! h->key.len) {
#line 1935
        goto while_break___0;
      }
#line 1937
      src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1938
      nsrc = params_merged.nelts;
#line 1940
      i = (ngx_uint_t )0;
      {
#line 1940
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1940
        if (! (i < nsrc)) {
#line 1940
          goto while_break___1;
        }
        {
#line 1941
        tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
        }
#line 1941
        if (tmp___2 == 0L) {
#line 1942
          goto next;
        }
#line 1940
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1946
      tmp___3 = ngx_array_push(& params_merged);
#line 1946
      s = (ngx_http_upstream_param_t *)tmp___3;
      }
#line 1947
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1948
        return ((ngx_int_t )-1);
      }
#line 1951
      s->key = h->key;
#line 1952
      s->value = h->value;
#line 1953
      s->skip_empty = (ngx_uint_t )1;
      next: 
#line 1957
      h ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1960
    src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1961
    nsrc = params_merged.nelts;
  }
#line 1964
  i = (ngx_uint_t )0;
  {
#line 1964
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1964
    if (! (i < nsrc)) {
#line 1964
      goto while_break___2;
    }
#line 1966
    if ((src + i)->key.len > sizeof("HTTP_") - 1UL) {
      {
#line 1966
      tmp___5 = strncmp((char const   *)(src + i)->key.data, "HTTP_", sizeof("HTTP_") - 1UL);
      }
#line 1966
      if (tmp___5 == 0) {
        {
#line 1969
        tmp___4 = ngx_array_push(& headers_names);
#line 1969
        hk = (ngx_hash_key_t *)tmp___4;
        }
#line 1970
        if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 1971
          return ((ngx_int_t )-1);
        }
        {
#line 1974
        hk->key.len = (src + i)->key.len - 5UL;
#line 1975
        hk->key.data = (src + i)->key.data + 5;
#line 1976
        hk->key_hash = ngx_hash_key_lc(hk->key.data, hk->key.len);
#line 1977
        hk->value = (void *)1;
        }
#line 1979
        if ((src + i)->value.len == 0UL) {
#line 1980
          goto __Cont;
        }
      }
    }
    {
#line 1984
    tmp___6 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1984
    copy = (ngx_http_script_copy_code_t *)tmp___6;
    }
#line 1986
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1987
      return ((ngx_int_t )-1);
    }
    {
#line 1990
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 1991
    copy->len = (src + i)->key.len;
#line 1993
    tmp___7 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1993
    copy = (ngx_http_script_copy_code_t *)tmp___7;
    }
#line 1995
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1996
      return ((ngx_int_t )-1);
    }
    {
#line 1999
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 2000
    copy->len = (src + i)->skip_empty;
#line 2003
    size = (((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 2007
    tmp___8 = ngx_array_push_n(params->values, size);
#line 2007
    copy = (ngx_http_script_copy_code_t *)tmp___8;
    }
#line 2008
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 2009
      return ((ngx_int_t )-1);
    }
    {
#line 2012
    copy->code = & ngx_http_script_copy_code;
#line 2013
    copy->len = (src + i)->key.len;
#line 2015
    p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 2016
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->key.data,
           (src + i)->key.len);
#line 2019
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 2021
    sc.cf = cf;
#line 2022
    sc.source = & (src + i)->value;
#line 2023
    sc.flushes = & params->flushes;
#line 2024
    sc.lengths = & params->lengths;
#line 2025
    sc.values = & params->values;
#line 2027
    tmp___9 = ngx_http_script_compile(& sc);
    }
#line 2027
    if (tmp___9 != 0L) {
#line 2028
      return ((ngx_int_t )-1);
    }
    {
#line 2031
    tmp___10 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 2031
    code = (uintptr_t *)tmp___10;
    }
#line 2032
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 2033
      return ((ngx_int_t )-1);
    }
    {
#line 2036
    *code = (uintptr_t )((void *)0);
#line 2039
    tmp___11 = ngx_array_push_n(params->values, sizeof(uintptr_t ));
#line 2039
    code = (uintptr_t *)tmp___11;
    }
#line 2040
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 2041
      return ((ngx_int_t )-1);
    }
#line 2044
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 1964
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2047
  tmp___12 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 2047
  code = (uintptr_t *)tmp___12;
  }
#line 2048
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 2049
    return ((ngx_int_t )-1);
  }
  {
#line 2052
  *code = (uintptr_t )((void *)0);
#line 2054
  params->number = headers_names.nelts;
#line 2056
  hash.hash = & params->hash;
#line 2057
  hash.key = & ngx_hash_key_lc;
#line 2058
  hash.max_size = (ngx_uint_t )512;
#line 2059
  hash.bucket_size = (ngx_uint_t )64;
#line 2060
  hash.name = (char *)"uwsgi_params_hash";
#line 2061
  hash.pool = cf->pool;
#line 2062
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2064
  tmp___13 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 2064
  return (tmp___13);
}
}
#line 2068 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  size_t___0 add ;
  ngx_url_t u ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 2071
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2080
  if (uwcf->upstream.upstream) {
#line 2081
    return ((char *)"is duplicate");
  } else
#line 2080
  if (uwcf->uwsgi_lengths) {
#line 2081
    return ((char *)"is duplicate");
  }
  {
#line 2084
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 2085
  clcf->handler = & ngx_http_uwsgi_handler;
#line 2087
  value = (ngx_str_t *)(cf->args)->elts;
#line 2089
  url = value + 1;
#line 2091
  n = ngx_http_script_variables_count(url);
  }
#line 2093
  if (n) {
    {
#line 2095
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 2097
    sc.cf = cf;
#line 2098
    sc.source = url;
#line 2099
    sc.lengths = & uwcf->uwsgi_lengths;
#line 2100
    sc.values = & uwcf->uwsgi_values;
#line 2101
    sc.variables = n;
#line 2102
    sc.complete_lengths = 1U;
#line 2103
    sc.complete_values = 1U;
#line 2105
    tmp = ngx_http_script_compile(& sc);
    }
#line 2105
    if (tmp != 0L) {
#line 2106
      return ((char *)((void *)-1));
    }
#line 2113
    return ((char *)((void *)0));
  }
  {
#line 2116
  tmp___1 = ngx_strncasecmp(url->data, (u_char *)"uwsgi://", (size_t___0 )8);
  }
#line 2116
  if (tmp___1 == 0L) {
#line 2117
    add = (size_t___0 )8;
  } else {
    {
#line 2119
    tmp___0 = ngx_strncasecmp(url->data, (u_char *)"suwsgi://", (size_t___0 )9);
    }
#line 2119
    if (tmp___0 == 0L) {
      {
#line 2125
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "suwsgi protocol requires SSL support");
      }
#line 2127
      return ((char *)((void *)-1));
    } else {
#line 2131
      add = (size_t___0 )0;
    }
  }
  {
#line 2134
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 2136
  u.url.len = url->len - add;
#line 2137
  u.url.data = url->data + add;
#line 2138
  u.no_resolve = 1U;
#line 2140
  uwcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 2141
  if ((unsigned long )uwcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 2142
    return ((char *)((void *)-1));
  }
#line 2145
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 2146
    clcf->auto_redirect = 1U;
  }
#line 2149
  return ((char *)((void *)0));
}
}
#line 2153 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 2156
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2161
  if (uwcf->upstream.store != -1) {
#line 2162
    return ((char *)"is duplicate");
  }
  {
#line 2165
  value = (ngx_str_t *)(cf->args)->elts;
#line 2167
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 2167
  if (tmp == 0) {
#line 2168
    uwcf->upstream.store = 0;
#line 2169
    return ((char *)((void *)0));
  }
#line 2174
  if (uwcf->upstream.cache > 0) {
#line 2175
    return ((char *)"is incompatible with \"uwsgi_cache\"");
  }
  {
#line 2180
  uwcf->upstream.store = 1;
#line 2182
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 2182
  if (tmp___0 == 0) {
#line 2183
    return ((char *)((void *)0));
  }
  {
#line 2187
  ((value + 1)->len) ++;
#line 2189
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 2191
  sc.cf = cf;
#line 2192
  sc.source = value + 1;
#line 2193
  sc.lengths = & uwcf->upstream.store_lengths;
#line 2194
  sc.values = & uwcf->upstream.store_values;
#line 2195
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 2196
  sc.complete_lengths = 1U;
#line 2197
  sc.complete_values = 1U;
#line 2199
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 2199
  if (tmp___1 != 0L) {
#line 2200
    return ((char *)((void *)-1));
  }
#line 2203
  return ((char *)((void *)0));
}
}
#line 2209 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
#line 2212
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2218
  value = (ngx_str_t *)(cf->args)->elts;
#line 2220
  if (uwcf->upstream.cache != -1) {
#line 2221
    return ((char *)"is duplicate");
  }
  {
#line 2224
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 2224
  if (tmp == 0) {
#line 2225
    uwcf->upstream.cache = 0;
#line 2226
    return ((char *)((void *)0));
  }
#line 2229
  if (uwcf->upstream.store > 0) {
#line 2230
    return ((char *)"is incompatible with \"uwsgi_store\"");
  }
  {
#line 2233
  uwcf->upstream.cache = 1;
#line 2235
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 2237
  ccv.cf = cf;
#line 2238
  ccv.value = value + 1;
#line 2239
  ccv.complex_value = & cv;
#line 2241
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 2241
  if (tmp___0 != 0L) {
#line 2242
    return ((char *)((void *)-1));
  }
#line 2245
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 2247
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 2247
    uwcf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 2249
    if ((unsigned long )uwcf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 2250
      return ((char *)((void *)-1));
    }
#line 2253
    *(uwcf->upstream.cache_value) = cv;
#line 2255
    return ((char *)((void *)0));
  }
  {
#line 2258
  uwcf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t___0 )0,
                                                    (void *)(& ngx_http_uwsgi_module));
  }
#line 2260
  if ((unsigned long )uwcf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 2261
    return ((char *)((void *)-1));
  }
#line 2264
  return ((char *)((void *)0));
}
}
#line 2268 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;

  {
#line 2271
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2276
  value = (ngx_str_t *)(cf->args)->elts;
#line 2278
  if (uwcf->cache_key.value.data) {
#line 2279
    return ((char *)"is duplicate");
  }
  {
#line 2282
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 2284
  ccv.cf = cf;
#line 2285
  ccv.value = value + 1;
#line 2286
  ccv.complex_value = & uwcf->cache_key;
#line 2288
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 2288
  if (tmp != 0L) {
#line 2289
    return ((char *)((void *)-1));
  }
#line 2292
  return ((char *)((void *)0));
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 160 "src/core/ngx_string.h"
u_char *ngx_strnstr(u_char *s1 , char *s2 , size_t___0 len ) ;
#line 158 "src/core/ngx_buf.h"
ngx_int_t ngx_chain_writer(void *data , ngx_chain_t *in ) ;
#line 163
void ngx_chain_update_chains(ngx_pool_t *p , ngx_chain_t **free___0 , ngx_chain_t **busy ,
                             ngx_chain_t **out , ngx_buf_tag_t tag ) ;
#line 573 "/usr/include/pcre.h"
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
#line 50 "src/core/ngx_regex.h"
ngx_int_t ngx_regex_compile(ngx_regex_compile_t *rc ) ;
#line 104 "src/event/ngx_event_pipe.h"
ngx_int_t ngx_event_pipe_add_free_buf(ngx_event_pipe_t *p , ngx_buf_t *b ) ;
#line 147 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_eval(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) ;
#line 150
static ngx_int_t ngx_http_fastcgi_create_key(ngx_http_request_t *r ) ;
#line 152
static ngx_int_t ngx_http_fastcgi_create_request(ngx_http_request_t *r ) ;
#line 153
static ngx_int_t ngx_http_fastcgi_reinit_request(ngx_http_request_t *r ) ;
#line 154
static ngx_int_t ngx_http_fastcgi_body_output_filter(void *data , ngx_chain_t *in ) ;
#line 156
static ngx_int_t ngx_http_fastcgi_process_header(ngx_http_request_t *r ) ;
#line 157
static ngx_int_t ngx_http_fastcgi_input_filter_init(void *data ) ;
#line 158
static ngx_int_t ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 160
static ngx_int_t ngx_http_fastcgi_non_buffered_filter(void *data , ssize_t bytes ) ;
#line 162
static ngx_int_t ngx_http_fastcgi_process_record(ngx_http_request_t *r , ngx_http_fastcgi_ctx_t *f ) ;
#line 164
static void ngx_http_fastcgi_abort_request(ngx_http_request_t *r ) ;
#line 165
static void ngx_http_fastcgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 168
static ngx_int_t ngx_http_fastcgi_add_variables(ngx_conf_t *cf ) ;
#line 169
static void *ngx_http_fastcgi_create_main_conf(ngx_conf_t *cf ) ;
#line 170
static void *ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf ) ;
#line 171
static char *ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 173
static ngx_int_t ngx_http_fastcgi_init_params(ngx_conf_t *cf , ngx_http_fastcgi_loc_conf_t *conf ,
                                              ngx_http_fastcgi_params_t *params ,
                                              ngx_keyval_t *default_params ) ;
#line 177
static ngx_int_t ngx_http_fastcgi_script_name_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 179
static ngx_int_t ngx_http_fastcgi_path_info_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 181
static ngx_http_fastcgi_ctx_t *ngx_http_fastcgi_split(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) ;
#line 184
static char *ngx_http_fastcgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 186
static char *ngx_http_fastcgi_split_path_info(ngx_conf_t *cf , ngx_command_t *cmd ,
                                              void *conf ) ;
#line 188
static char *ngx_http_fastcgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 191
static char *ngx_http_fastcgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 193
static char *ngx_http_fastcgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 197
static char *ngx_http_fastcgi_lowat_check(ngx_conf_t *cf , void *post , void *data ) ;
#line 201 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_conf_post_t ngx_http_fastcgi_lowat_post  =    {& ngx_http_fastcgi_lowat_check};
#line 205 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_conf_bitmask_t ngx_http_fastcgi_next_upstream_masks[12]  = 
#line 205
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 224 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_command_t ngx_http_fastcgi_commands[49]  = 
#line 224
  {      {{sizeof("fastcgi_pass") - 1UL, (u_char *)"fastcgi_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_fastcgi_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_index") - 1UL, (u_char *)"fastcgi_index"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->index), (void *)0}, 
        {{sizeof("fastcgi_split_path_info") - 1UL, (u_char *)"fastcgi_split_path_info"},
      (ngx_uint_t )234881026, & ngx_http_fastcgi_split_path_info, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_store") - 1UL, (u_char *)"fastcgi_store"}, (ngx_uint_t )234881026,
      & ngx_http_fastcgi_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_store_access") - 1UL, (u_char *)"fastcgi_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("fastcgi_buffering") - 1UL, (u_char *)"fastcgi_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.buffering),
      (void *)0}, 
        {{sizeof("fastcgi_request_buffering") - 1UL, (u_char *)"fastcgi_request_buffering"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("fastcgi_ignore_client_abort") - 1UL, (u_char *)"fastcgi_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("fastcgi_bind") - 1UL, (u_char *)"fastcgi_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("fastcgi_connect_timeout") - 1UL,
       (u_char *)"fastcgi_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_send_timeout") - 1UL, (u_char *)"fastcgi_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_send_lowat") - 1UL, (u_char *)"fastcgi_send_lowat"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.send_lowat),
      (void *)(& ngx_http_fastcgi_lowat_post)}, 
        {{sizeof("fastcgi_buffer_size") - 1UL, (u_char *)"fastcgi_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("fastcgi_pass_request_headers") - 1UL, (u_char *)"fastcgi_pass_request_headers"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("fastcgi_pass_request_body") - 1UL, (u_char *)"fastcgi_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("fastcgi_intercept_errors") - 1UL, (u_char *)"fastcgi_intercept_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("fastcgi_read_timeout") - 1UL, (u_char *)"fastcgi_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_buffers") - 1UL, (u_char *)"fastcgi_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("fastcgi_busy_buffers_size") - 1UL,
       (u_char *)"fastcgi_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("fastcgi_force_ranges") - 1UL, (u_char *)"fastcgi_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("fastcgi_limit_rate") - 1UL, (u_char *)"fastcgi_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.limit_rate),
      (void *)0}, 
        {{sizeof("fastcgi_cache") - 1UL, (u_char *)"fastcgi_cache"}, (ngx_uint_t )234881026,
      & ngx_http_fastcgi_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_cache_key") - 1UL, (u_char *)"fastcgi_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_fastcgi_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_cache_path") - 1UL, (u_char *)"fastcgi_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_fastcgi_main_conf_t *)0)->caches), (void *)(& ngx_http_fastcgi_module)}, 
        {{sizeof("fastcgi_cache_bypass") - 1UL,
       (u_char *)"fastcgi_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("fastcgi_no_cache") - 1UL, (u_char *)"fastcgi_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("fastcgi_cache_valid") - 1UL,
       (u_char *)"fastcgi_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("fastcgi_cache_min_uses") - 1UL, (u_char *)"fastcgi_cache_min_uses"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("fastcgi_cache_max_range_offset") - 1UL, (u_char *)"fastcgi_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("fastcgi_cache_use_stale") - 1UL, (u_char *)"fastcgi_cache_use_stale"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_fastcgi_next_upstream_masks)}, 
        {{sizeof("fastcgi_cache_methods") - 1UL, (u_char *)"fastcgi_cache_methods"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("fastcgi_cache_lock") - 1UL, (u_char *)"fastcgi_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_lock),
      (void *)0}, 
        {{sizeof("fastcgi_cache_lock_timeout") - 1UL, (u_char *)"fastcgi_cache_lock_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_cache_lock_age") - 1UL, (u_char *)"fastcgi_cache_lock_age"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("fastcgi_cache_revalidate") - 1UL, (u_char *)"fastcgi_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("fastcgi_cache_background_update") - 1UL, (u_char *)"fastcgi_cache_background_update"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("fastcgi_temp_path") - 1UL, (u_char *)"fastcgi_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.temp_path),
      (void *)0}, 
        {{sizeof("fastcgi_max_temp_file_size") - 1UL, (u_char *)"fastcgi_max_temp_file_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("fastcgi_temp_file_write_size") - 1UL, (u_char *)"fastcgi_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("fastcgi_next_upstream") - 1UL, (u_char *)"fastcgi_next_upstream"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_fastcgi_next_upstream_masks)}, 
        {{sizeof("fastcgi_next_upstream_tries") - 1UL, (u_char *)"fastcgi_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("fastcgi_next_upstream_timeout") - 1UL, (u_char *)"fastcgi_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_param") - 1UL, (u_char *)"fastcgi_param"}, (ngx_uint_t )234881036,
      & ngx_http_upstream_param_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->params_source), (void *)0}, 
        {{sizeof("fastcgi_pass_header") - 1UL,
       (u_char *)"fastcgi_pass_header"}, (ngx_uint_t )234881026, & ngx_conf_set_str_array_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("fastcgi_hide_header") - 1UL, (u_char *)"fastcgi_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("fastcgi_ignore_headers") - 1UL, (u_char *)"fastcgi_ignore_headers"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{sizeof("fastcgi_catch_stderr") - 1UL, (u_char *)"fastcgi_catch_stderr"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->catch_stderr), (void *)0}, 
        {{sizeof("fastcgi_keep_conn") - 1UL,
       (u_char *)"fastcgi_keep_conn"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->keep_conn),
      (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 570 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_module_t ngx_http_fastcgi_module_ctx  = 
#line 570
     {& ngx_http_fastcgi_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_fastcgi_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_fastcgi_create_loc_conf, & ngx_http_fastcgi_merge_loc_conf};
#line 585 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
ngx_module_t ngx_http_fastcgi_module  = 
#line 585
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_fastcgi_module_ctx),
    ngx_http_fastcgi_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 601 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_fastcgi_request_start_t ngx_http_fastcgi_request_start  =    {{(u_char )1, (u_char )1, (u_char )0, (u_char )1, (u_char )0, (u_char )sizeof(ngx_http_fastcgi_begin_request_t ),
     (u_char )0, (u_char )0}, {(u_char )0, (u_char )1, (u_char )0, {(u_char )0, (u_char )0,
                                                                    (u_char )0, (u_char )0,
                                                                    (u_char )0}},
    {(u_char )1, (u_char )4, (u_char )0, (u_char )1}};
#line 624 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_variable_t ngx_http_fastcgi_vars[3]  = {      {{sizeof("fastcgi_script_name") - 1UL, (u_char *)"fastcgi_script_name"}, (void (*)(ngx_http_request_t *r ,
                                                                                        ngx_http_variable_value_t *v ,
                                                                                        uintptr_t data ))((void *)0),
      & ngx_http_fastcgi_script_name_variable, (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{sizeof("fastcgi_path_info") - 1UL,
       (u_char *)"fastcgi_path_info"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ))((void *)0), & ngx_http_fastcgi_path_info_variable,
      (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                         uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 638 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_str_t ngx_http_fastcgi_hide_headers[7]  = {      {sizeof("Status") - 1UL, (u_char *)"Status"}, 
        {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}};
#line 651 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_keyval_t ngx_http_fastcgi_cache_headers[7]  = {      {{sizeof("HTTP_IF_MODIFIED_SINCE") - 1UL, (u_char *)"HTTP_IF_MODIFIED_SINCE"},
      {sizeof("$upstream_cache_last_modified") - 1UL, (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("HTTP_IF_UNMODIFIED_SINCE") - 1UL,
       (u_char *)"HTTP_IF_UNMODIFIED_SINCE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_NONE_MATCH") - 1UL, (u_char *)"HTTP_IF_NONE_MATCH"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                             (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("HTTP_IF_MATCH") - 1UL,
       (u_char *)"HTTP_IF_MATCH"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_RANGE") - 1UL, (u_char *)"HTTP_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_RANGE") - 1UL,
       (u_char *)"HTTP_IF_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, {(size_t___0 )0, (u_char *)((void *)0)}}};
#line 665 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_path_init_t ngx_http_fastcgi_temp_path  =    {{sizeof("fastcgi_temp") - 1UL, (u_char *)"fastcgi_temp"}, {(size_t___0 )1, (size_t___0 )2,
                                                               (size_t___0 )0}};
#line 670 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_http_fastcgi_main_conf_t *fmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 681
  tmp = ngx_http_upstream_create(r);
  }
#line 681
  if (tmp != 0L) {
#line 682
    return ((ngx_int_t )500);
  }
  {
#line 685
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_fastcgi_ctx_t ));
#line 685
  f = (ngx_http_fastcgi_ctx_t *)tmp___0;
  }
#line 686
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 687
    return ((ngx_int_t )500);
  }
#line 690
  *(r->ctx + ngx_http_fastcgi_module.ctx_index) = (void *)f;
#line 692
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 694
  if (flcf->fastcgi_lengths) {
    {
#line 695
    tmp___1 = ngx_http_fastcgi_eval(r, flcf);
    }
#line 695
    if (tmp___1 != 0L) {
#line 696
      return ((ngx_int_t )500);
    }
  }
  {
#line 700
  u = r->upstream;
#line 702
  u->schema.len = sizeof("fastcgi://") - 1UL;
#line 702
  u->schema.data = (u_char *)"fastcgi://";
#line 703
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_module);
#line 705
  u->conf = & flcf->upstream;
#line 708
  fmcf = (ngx_http_fastcgi_main_conf_t *)*(r->main_conf + ngx_http_fastcgi_module.ctx_index);
#line 710
  u->caches = & fmcf->caches;
#line 711
  u->create_key = & ngx_http_fastcgi_create_key;
#line 714
  u->create_request = & ngx_http_fastcgi_create_request;
#line 715
  u->reinit_request = & ngx_http_fastcgi_reinit_request;
#line 716
  u->process_header = & ngx_http_fastcgi_process_header;
#line 717
  u->abort_request = & ngx_http_fastcgi_abort_request;
#line 718
  u->finalize_request = & ngx_http_fastcgi_finalize_request;
#line 719
  r->state = (ngx_uint_t )0;
#line 721
  u->buffering = (unsigned int )flcf->upstream.buffering;
#line 723
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 723
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 724
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 725
    return ((ngx_int_t )500);
  }
#line 728
  (u->pipe)->input_filter = & ngx_http_fastcgi_input_filter;
#line 729
  (u->pipe)->input_ctx = (void *)r;
#line 731
  u->input_filter_init = & ngx_http_fastcgi_input_filter_init;
#line 732
  u->input_filter = & ngx_http_fastcgi_non_buffered_filter;
#line 733
  u->input_filter_ctx = (void *)r;
#line 735
  if (! flcf->upstream.request_buffering) {
#line 735
    if (flcf->upstream.pass_request_body) {
#line 738
      r->request_body_no_buffering = 1U;
    }
  }
  {
#line 741
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 743
  if (rc >= 300L) {
#line 744
    return (rc);
  }
#line 747
  return ((ngx_int_t )-4);
}
}
#line 751 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_eval(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) 
{ 
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 757
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 759
  tmp = ngx_http_script_run(r, & url.url, (flcf->fastcgi_lengths)->elts, (size_t___0 )0,
                            (flcf->fastcgi_values)->elts);
  }
#line 759
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 763
    return ((ngx_int_t )-1);
  }
  {
#line 766
  url.no_resolve = 1U;
#line 768
  tmp___0 = ngx_parse_url(r->pool, & url);
  }
#line 768
  if (tmp___0 != 0L) {
#line 769
    if (url.err) {
#line 770
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 770
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 774
    return ((ngx_int_t )-1);
  }
  {
#line 777
  u = r->upstream;
#line 779
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 779
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___1;
  }
#line 780
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 781
    return ((ngx_int_t )-1);
  }
#line 784
  if (url.addrs) {
#line 785
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 786
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 787
    (u->resolved)->name = (url.addrs + 0)->name;
#line 788
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 791
  (u->resolved)->host = url.host;
#line 792
  (u->resolved)->port = url.port;
#line 793
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 795
  return ((ngx_int_t )0);
}
}
#line 801 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_create_key(ngx_http_request_t *r ) 
{ 
  ngx_str_t *key ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 807
  tmp = ngx_array_push(& (r->cache)->keys);
#line 807
  key = (ngx_str_t *)tmp;
  }
#line 808
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 809
    return ((ngx_int_t )-1);
  }
  {
#line 812
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 814
  tmp___0 = ngx_http_complex_value(r, & flcf->cache_key, key);
  }
#line 814
  if (tmp___0 != 0L) {
#line 815
    return ((ngx_int_t )-1);
  }
#line 818
  return ((ngx_int_t )0);
}
}
#line 824 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_create_request(ngx_http_request_t *r ) 
{ 
  off_t file_pos ;
  u_char ch ;
  u_char *pos ;
  u_char *lowcase_key ;
  size_t___0 size ;
  size_t___0 len ;
  size_t___0 key_len ;
  size_t___0 val_len ;
  size_t___0 padding ;
  size_t___0 allocated ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t next ;
  ngx_uint_t hash ;
  ngx_uint_t skip_empty ;
  ngx_uint_t header_params ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_table_elt_t **ignored ;
  ngx_http_upstream_t *u ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_fastcgi_header_t *h ;
  ngx_http_fastcgi_params_t *params ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  size_t___0 tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_uint_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t___0 tmp___7 ;
  size_t___0 tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  u_char *tmp___23 ;
  u_char *tmp___24 ;
  void *tmp___25 ;
  u_char *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;

  {
#line 844
  len = (size_t___0 )0;
#line 845
  header_params = (ngx_uint_t )0;
#line 846
  ignored = (ngx_table_elt_t **)((void *)0);
#line 848
  u = r->upstream;
#line 850
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 853
  if (u->cacheable) {
#line 853
    params = & flcf->params_cache;
  } else {
#line 853
    params = & flcf->params;
  }
#line 858
  if (params->lengths) {
    {
#line 859
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 861
    ngx_http_script_flush_no_cacheable_variables(r, params->flushes);
#line 862
    le.flushed = 1U;
#line 864
    le.ip = (u_char *)(params->lengths)->elts;
#line 865
    le.request = r;
    }
    {
#line 867
    while (1) {
      while_continue: /* CIL Label */ ;
#line 867
      if (! *((uintptr_t *)le.ip)) {
#line 867
        goto while_break;
      }
      {
#line 869
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 870
      key_len = (*lcode)(& le);
#line 872
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 873
      skip_empty = (*lcode)(& le);
#line 875
      val_len = (size_t___0 )0;
      }
      {
#line 875
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 875
        if (! *((uintptr_t *)le.ip)) {
#line 875
          goto while_break___0;
        }
        {
#line 876
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 875
        tmp = (*lcode)(& le);
#line 875
        val_len += tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 878
      le.ip += sizeof(uintptr_t );
#line 880
      if (skip_empty) {
#line 880
        if (val_len == 0UL) {
#line 881
          goto while_continue;
        }
      }
#line 884
      if (val_len > 127UL) {
#line 884
        tmp___0 = 4;
      } else {
#line 884
        tmp___0 = 1;
      }
#line 884
      len += ((1UL + key_len) + (size_t___0 )tmp___0) + val_len;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 888
  if (flcf->upstream.pass_request_headers) {
#line 890
    allocated = (size_t___0 )0;
#line 891
    lowcase_key = (u_char *)((void *)0);
#line 893
    if (params->number) {
#line 894
      n = (ngx_uint_t )0;
#line 895
      part = & r->headers_in.headers.part;
      {
#line 897
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 897
        if (! part) {
#line 897
          goto while_break___1;
        }
#line 898
        n += part->nelts;
#line 899
        part = part->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 902
      tmp___1 = ngx_palloc(r->pool, n * sizeof(void *));
#line 902
      ignored = (ngx_table_elt_t **)tmp___1;
      }
#line 903
      if ((unsigned long )ignored == (unsigned long )((void *)0)) {
#line 904
        return ((ngx_int_t )-1);
      }
    }
#line 908
    part = & r->headers_in.headers.part;
#line 909
    header___0 = (ngx_table_elt_t *)part->elts;
#line 911
    i = (ngx_uint_t )0;
    {
#line 911
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 913
      if (i >= part->nelts) {
#line 914
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 915
          goto while_break___2;
        }
#line 918
        part = part->next;
#line 919
        header___0 = (ngx_table_elt_t *)part->elts;
#line 920
        i = (ngx_uint_t )0;
      }
#line 923
      if (params->number) {
#line 924
        if (allocated < (header___0 + i)->key.len) {
          {
#line 925
          allocated = (header___0 + i)->key.len + 16UL;
#line 926
          tmp___2 = ngx_pnalloc(r->pool, allocated);
#line 926
          lowcase_key = (u_char *)tmp___2;
          }
#line 927
          if ((unsigned long )lowcase_key == (unsigned long )((void *)0)) {
#line 928
            return ((ngx_int_t )-1);
          }
        }
#line 932
        hash = (ngx_uint_t )0;
#line 934
        n = (ngx_uint_t )0;
        {
#line 934
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 934
          if (! (n < (header___0 + i)->key.len)) {
#line 934
            goto while_break___3;
          }
#line 935
          ch = *((header___0 + i)->key.data + n);
#line 937
          if ((int )ch >= 65) {
#line 937
            if ((int )ch <= 90) {
#line 938
              ch = (u_char )((int )ch | 32);
            } else {
#line 937
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 940
          if ((int )ch == 45) {
#line 941
            ch = (u_char )'_';
          }
#line 944
          hash = hash * 31UL + (ngx_uint_t )ch;
#line 945
          *(lowcase_key + n) = ch;
#line 934
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 948
        tmp___4 = ngx_hash_find(& params->hash, hash, lowcase_key, n);
        }
#line 948
        if (tmp___4) {
#line 949
          tmp___3 = header_params;
#line 949
          header_params ++;
#line 949
          *(ignored + tmp___3) = header___0 + i;
#line 950
          goto __Cont;
        }
#line 953
        n += sizeof("HTTP_") - 1UL;
      } else {
#line 956
        n = (sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len;
      }
#line 959
      if (n > 127UL) {
#line 959
        tmp___5 = 4;
      } else {
#line 959
        tmp___5 = 1;
      }
#line 959
      if ((header___0 + i)->value.len > 127UL) {
#line 959
        tmp___6 = 4;
      } else {
#line 959
        tmp___6 = 1;
      }
#line 959
      len += ((ngx_uint_t )(tmp___5 + tmp___6) + n) + (header___0 + i)->value.len;
      __Cont: /* CIL Label */ 
#line 911
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 965
  if (len > 65535UL) {
#line 966
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 966
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "fastcgi request record is too big: %uz",
                         len);
      }
    }
#line 968
    return ((ngx_int_t )-1);
  }
#line 972
  padding = 8UL - len % 8UL;
#line 973
  if (padding == 8UL) {
#line 973
    padding = (size_t___0 )0;
  } else {
#line 973
    padding = padding;
  }
  {
#line 976
  size = (((((sizeof(ngx_http_fastcgi_header_t ) + sizeof(ngx_http_fastcgi_begin_request_t )) + sizeof(ngx_http_fastcgi_header_t )) + len) + padding) + sizeof(ngx_http_fastcgi_header_t )) + sizeof(ngx_http_fastcgi_header_t );
#line 986
  b = ngx_create_temp_buf(r->pool, size);
  }
#line 987
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 988
    return ((ngx_int_t )-1);
  }
  {
#line 991
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 992
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 993
    return ((ngx_int_t )-1);
  }
#line 996
  cl->buf = b;
#line 998
  if (flcf->keep_conn) {
#line 998
    ngx_http_fastcgi_request_start.br.flags = (u_char )1;
  } else {
#line 998
    ngx_http_fastcgi_request_start.br.flags = (u_char )0;
  }
  {
#line 1001
  memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)(& ngx_http_fastcgi_request_start),
         sizeof(ngx_http_fastcgi_request_start_t ));
#line 1004
  h = (ngx_http_fastcgi_header_t *)((b->pos + sizeof(ngx_http_fastcgi_header_t )) + sizeof(ngx_http_fastcgi_begin_request_t ));
#line 1008
  h->content_length_hi = (u_char )((len >> 8) & 255UL);
#line 1009
  h->content_length_lo = (u_char )(len & 255UL);
#line 1010
  h->padding_length = (u_char )padding;
#line 1011
  h->reserved = (u_char )0;
#line 1013
  b->last = ((b->pos + sizeof(ngx_http_fastcgi_header_t )) + sizeof(ngx_http_fastcgi_begin_request_t )) + sizeof(ngx_http_fastcgi_header_t );
  }
#line 1018
  if (params->lengths) {
    {
#line 1019
    memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 1021
    e.ip = (u_char *)(params->values)->elts;
#line 1022
    e.pos = b->last;
#line 1023
    e.request = r;
#line 1024
    e.flushed = 1U;
#line 1026
    le.ip = (u_char *)(params->lengths)->elts;
    }
    {
#line 1028
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1028
      if (! *((uintptr_t *)le.ip)) {
#line 1028
        goto while_break___4;
      }
      {
#line 1030
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1031
      tmp___7 = (*lcode)(& le);
#line 1031
      key_len = (size_t___0 )((u_char )tmp___7);
#line 1033
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1034
      skip_empty = (*lcode)(& le);
#line 1036
      val_len = (size_t___0 )0;
      }
      {
#line 1036
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1036
        if (! *((uintptr_t *)le.ip)) {
#line 1036
          goto while_break___5;
        }
        {
#line 1037
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1036
        tmp___8 = (*lcode)(& le);
#line 1036
        val_len += tmp___8;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1039
      le.ip += sizeof(uintptr_t );
#line 1041
      if (skip_empty) {
#line 1041
        if (val_len == 0UL) {
#line 1042
          e.skip = 1U;
          {
#line 1044
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1044
            if (! *((uintptr_t *)e.ip)) {
#line 1044
              goto while_break___6;
            }
            {
#line 1045
            code = *((ngx_http_script_code_pt *)e.ip);
#line 1046
            (*code)(& e);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1048
          e.ip += sizeof(uintptr_t );
#line 1050
          e.skip = 0U;
#line 1052
          goto while_continue___4;
        }
      }
#line 1055
      tmp___9 = e.pos;
#line 1055
      (e.pos) ++;
#line 1055
      *tmp___9 = (u_char )key_len;
#line 1057
      if (val_len > 127UL) {
#line 1058
        tmp___10 = e.pos;
#line 1058
        (e.pos) ++;
#line 1058
        *tmp___10 = (u_char )(((val_len >> 24) & 127UL) | 128UL);
#line 1059
        tmp___11 = e.pos;
#line 1059
        (e.pos) ++;
#line 1059
        *tmp___11 = (u_char )((val_len >> 16) & 255UL);
#line 1060
        tmp___12 = e.pos;
#line 1060
        (e.pos) ++;
#line 1060
        *tmp___12 = (u_char )((val_len >> 8) & 255UL);
#line 1061
        tmp___13 = e.pos;
#line 1061
        (e.pos) ++;
#line 1061
        *tmp___13 = (u_char )(val_len & 255UL);
      } else {
#line 1064
        tmp___14 = e.pos;
#line 1064
        (e.pos) ++;
#line 1064
        *tmp___14 = (u_char )val_len;
      }
      {
#line 1067
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1067
        if (! *((uintptr_t *)e.ip)) {
#line 1067
          goto while_break___7;
        }
        {
#line 1068
        code = *((ngx_http_script_code_pt *)e.ip);
#line 1069
        (*code)(& e);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1071
      e.ip += sizeof(uintptr_t );
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1079
    b->last = e.pos;
  }
#line 1083
  if (flcf->upstream.pass_request_headers) {
#line 1085
    part = & r->headers_in.headers.part;
#line 1086
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1088
    i = (ngx_uint_t )0;
    {
#line 1088
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1090
      if (i >= part->nelts) {
#line 1091
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1092
          goto while_break___8;
        }
#line 1095
        part = part->next;
#line 1096
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1097
        i = (ngx_uint_t )0;
      }
#line 1100
      n = (ngx_uint_t )0;
      {
#line 1100
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1100
        if (! (n < header_params)) {
#line 1100
          goto while_break___9;
        }
#line 1101
        if ((unsigned long )(header___0 + i) == (unsigned long )*(ignored + n)) {
#line 1102
          goto next;
        }
#line 1100
        n ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1106
      key_len = (sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len;
#line 1107
      if (key_len > 127UL) {
#line 1108
        tmp___15 = b->last;
#line 1108
        (b->last) ++;
#line 1108
        *tmp___15 = (u_char )(((key_len >> 24) & 127UL) | 128UL);
#line 1109
        tmp___16 = b->last;
#line 1109
        (b->last) ++;
#line 1109
        *tmp___16 = (u_char )((key_len >> 16) & 255UL);
#line 1110
        tmp___17 = b->last;
#line 1110
        (b->last) ++;
#line 1110
        *tmp___17 = (u_char )((key_len >> 8) & 255UL);
#line 1111
        tmp___18 = b->last;
#line 1111
        (b->last) ++;
#line 1111
        *tmp___18 = (u_char )(key_len & 255UL);
      } else {
#line 1114
        tmp___19 = b->last;
#line 1114
        (b->last) ++;
#line 1114
        *tmp___19 = (u_char )key_len;
      }
#line 1117
      val_len = (header___0 + i)->value.len;
#line 1118
      if (val_len > 127UL) {
#line 1119
        tmp___20 = b->last;
#line 1119
        (b->last) ++;
#line 1119
        *tmp___20 = (u_char )(((val_len >> 24) & 127UL) | 128UL);
#line 1120
        tmp___21 = b->last;
#line 1120
        (b->last) ++;
#line 1120
        *tmp___21 = (u_char )((val_len >> 16) & 255UL);
#line 1121
        tmp___22 = b->last;
#line 1121
        (b->last) ++;
#line 1121
        *tmp___22 = (u_char )((val_len >> 8) & 255UL);
#line 1122
        tmp___23 = b->last;
#line 1122
        (b->last) ++;
#line 1122
        *tmp___23 = (u_char )(val_len & 255UL);
      } else {
#line 1125
        tmp___24 = b->last;
#line 1125
        (b->last) ++;
#line 1125
        *tmp___24 = (u_char )val_len;
      }
      {
#line 1128
      tmp___25 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"HTTP_",
                        sizeof("HTTP_") - 1UL);
#line 1128
      b->last = (u_char *)tmp___25 + (sizeof("HTTP_") - 1UL);
#line 1130
      n = (ngx_uint_t )0;
      }
      {
#line 1130
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1130
        if (! (n < (header___0 + i)->key.len)) {
#line 1130
          goto while_break___10;
        }
#line 1131
        ch = *((header___0 + i)->key.data + n);
#line 1133
        if ((int )ch >= 97) {
#line 1133
          if ((int )ch <= 122) {
#line 1134
            ch = (u_char )((int )ch & -33);
          } else {
#line 1133
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1136
        if ((int )ch == 45) {
#line 1137
          ch = (u_char )'_';
        }
#line 1140
        tmp___26 = b->last;
#line 1140
        (b->last) ++;
#line 1140
        *tmp___26 = ch;
#line 1130
        n ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1143
      tmp___27 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        val_len);
#line 1143
      b->last = (u_char *)tmp___27 + val_len;
      }
      next: 
#line 1151
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1088
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 1156
  if (padding) {
    {
#line 1157
    memset((void *)b->last, 0, padding);
#line 1158
    b->last += padding;
    }
  }
#line 1162
  h = (ngx_http_fastcgi_header_t *)b->last;
#line 1163
  b->last += sizeof(ngx_http_fastcgi_header_t );
#line 1165
  h->version = (u_char )1;
#line 1166
  h->type = (u_char )4;
#line 1167
  h->request_id_hi = (u_char )0;
#line 1168
  h->request_id_lo = (u_char )1;
#line 1169
  h->content_length_hi = (u_char )0;
#line 1170
  h->content_length_lo = (u_char )0;
#line 1171
  h->padding_length = (u_char )0;
#line 1172
  h->reserved = (u_char )0;
#line 1174
  if (r->request_body_no_buffering) {
#line 1176
    u->request_bufs = cl;
#line 1178
    u->output.output_filter = & ngx_http_fastcgi_body_output_filter;
#line 1179
    u->output.filter_ctx = (void *)r;
  } else
#line 1181
  if (flcf->upstream.pass_request_body) {
#line 1183
    body = u->request_bufs;
#line 1184
    u->request_bufs = cl;
#line 1187
    file_pos = (off_t )0;
#line 1188
    pos = (u_char *)((void *)0);
    {
#line 1191
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1191
      if (! body) {
#line 1191
        goto while_break___11;
      }
#line 1193
      if ((body->buf)->flush) {
#line 1193
        goto _L___1;
      } else
#line 1193
      if ((body->buf)->last_buf) {
#line 1193
        goto _L___1;
      } else
#line 1193
      if ((body->buf)->sync) {
        _L___1: /* CIL Label */ 
#line 1193
        if (! (body->buf)->temporary) {
#line 1193
          if (! (body->buf)->memory) {
#line 1193
            if (! (body->buf)->mmap) {
#line 1193
              if (! (body->buf)->in_file) {
#line 1194
                body = body->next;
#line 1195
                goto while_continue___11;
              }
            }
          }
        }
      }
#line 1198
      if ((body->buf)->in_file) {
#line 1199
        file_pos = (body->buf)->file_pos;
      } else {
#line 1202
        pos = (body->buf)->pos;
      }
#line 1205
      next = (ngx_uint_t )0;
      {
#line 1207
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1208
        tmp___28 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 1208
        b = (ngx_buf_t *)tmp___28;
        }
#line 1209
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1210
          return ((ngx_int_t )-1);
        }
        {
#line 1213
        memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
               sizeof(ngx_buf_t ));
        }
#line 1215
        if ((body->buf)->in_file) {
#line 1216
          b->file_pos = file_pos;
#line 1217
          file_pos += 32768L;
#line 1219
          if (file_pos >= (body->buf)->file_last) {
#line 1220
            file_pos = (body->buf)->file_last;
#line 1221
            next = (ngx_uint_t )1;
          }
#line 1224
          b->file_last = file_pos;
#line 1225
          len = (ngx_uint_t )(file_pos - b->file_pos);
        } else {
#line 1228
          b->pos = pos;
#line 1229
          b->start = pos;
#line 1230
          pos += 32768;
#line 1232
          if ((unsigned long )pos >= (unsigned long )(body->buf)->last) {
#line 1233
            pos = (body->buf)->last;
#line 1234
            next = (ngx_uint_t )1;
          }
#line 1237
          b->last = pos;
#line 1238
          len = (ngx_uint_t )(pos - b->pos);
        }
#line 1241
        padding = 8UL - len % 8UL;
#line 1242
        if (padding == 8UL) {
#line 1242
          padding = (size_t___0 )0;
        } else {
#line 1242
          padding = padding;
        }
        {
#line 1244
        h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1245
        (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1247
        h->version = (u_char )1;
#line 1248
        h->type = (u_char )5;
#line 1249
        h->request_id_hi = (u_char )0;
#line 1250
        h->request_id_lo = (u_char )1;
#line 1251
        h->content_length_hi = (u_char )((len >> 8) & 255UL);
#line 1252
        h->content_length_lo = (u_char )(len & 255UL);
#line 1253
        h->padding_length = (u_char )padding;
#line 1254
        h->reserved = (u_char )0;
#line 1256
        cl->next = ngx_alloc_chain_link(r->pool);
        }
#line 1257
        if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1258
          return ((ngx_int_t )-1);
        }
        {
#line 1261
        cl = cl->next;
#line 1262
        cl->buf = b;
#line 1264
        b = ngx_create_temp_buf(r->pool, sizeof(ngx_http_fastcgi_header_t ) + padding);
        }
#line 1267
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1268
          return ((ngx_int_t )-1);
        }
#line 1271
        if (padding) {
          {
#line 1272
          memset((void *)b->last, 0, padding);
#line 1273
          b->last += padding;
          }
        }
        {
#line 1276
        cl->next = ngx_alloc_chain_link(r->pool);
        }
#line 1277
        if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1278
          return ((ngx_int_t )-1);
        }
#line 1281
        cl = cl->next;
#line 1282
        cl->buf = b;
#line 1207
        if (! (! next)) {
#line 1207
          goto while_break___12;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1286
      body = body->next;
    }
    while_break___11: /* CIL Label */ ;
    }
  } else {
#line 1290
    u->request_bufs = cl;
  }
#line 1293
  if (! r->request_body_no_buffering) {
#line 1294
    h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1295
    (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1297
    h->version = (u_char )1;
#line 1298
    h->type = (u_char )5;
#line 1299
    h->request_id_hi = (u_char )0;
#line 1300
    h->request_id_lo = (u_char )1;
#line 1301
    h->content_length_hi = (u_char )0;
#line 1302
    h->content_length_lo = (u_char )0;
#line 1303
    h->padding_length = (u_char )0;
#line 1304
    h->reserved = (u_char )0;
  }
#line 1307
  cl->next = (ngx_chain_t *)((void *)0);
#line 1309
  return ((ngx_int_t )0);
}
}
#line 1313 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_fastcgi_ctx_t *f ;

  {
#line 1318
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 1320
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1321
    return ((ngx_int_t )0);
  }
#line 1324
  f->state = (ngx_http_fastcgi_state_e )0;
#line 1325
  f->fastcgi_stdout = 0U;
#line 1326
  f->large_stderr = 0U;
#line 1328
  if (f->split_parts) {
#line 1329
    (f->split_parts)->nelts = (ngx_uint_t )0;
  }
#line 1332
  r->state = (ngx_uint_t )0;
#line 1334
  return ((ngx_int_t )0);
}
}
#line 1338 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_body_output_filter(void *data , ngx_chain_t *in ) 
{ 
  ngx_http_request_t *r ;
  off_t file_pos ;
  u_char *pos ;
  u_char *start ;
  size_t___0 len ;
  size_t___0 padding ;
  ngx_buf_t *b ;
  ngx_int_t rc ;
  ngx_uint_t next ;
  ngx_uint_t last ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_header_t *h ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1341
  r = (ngx_http_request_t *)data;
#line 1356
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 1358
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1359
    out = in;
#line 1360
    goto out;
  }
#line 1363
  out = (ngx_chain_t *)((void *)0);
#line 1364
  ll = & out;
#line 1366
  if (! f->header_sent) {
    {
#line 1372
    f->header_sent = 1U;
#line 1374
    tl = ngx_alloc_chain_link(r->pool);
    }
#line 1375
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1376
      return ((ngx_int_t )-1);
    }
#line 1379
    tl->buf = in->buf;
#line 1380
    *ll = tl;
#line 1381
    ll = & tl->next;
#line 1383
    in = in->next;
#line 1385
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1386
      tl->next = (ngx_chain_t *)((void *)0);
#line 1387
      goto out;
    }
  }
  {
#line 1391
  cl = ngx_chain_get_free_buf(r->pool, & f->free);
  }
#line 1392
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1393
    return ((ngx_int_t )-1);
  }
#line 1396
  b = cl->buf;
#line 1398
  b->tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter);
#line 1399
  b->temporary = 1U;
#line 1401
  if ((unsigned long )b->start == (unsigned long )((void *)0)) {
    {
#line 1404
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_fastcgi_header_t ) + 7UL);
#line 1404
    b->start = (u_char *)tmp;
    }
#line 1406
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 1407
      return ((ngx_int_t )-1);
    }
#line 1410
    b->pos = b->start;
#line 1411
    b->last = b->start;
#line 1413
    b->end = (b->start + sizeof(ngx_http_fastcgi_header_t )) + 7;
  }
#line 1416
  *ll = cl;
#line 1418
  last = (ngx_uint_t )0;
#line 1419
  padding = (size_t___0 )0;
#line 1422
  file_pos = (off_t )0;
#line 1423
  pos = (u_char *)((void *)0);
  {
#line 1426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1426
    if (! in) {
#line 1426
      goto while_break;
    }
#line 1438
    if ((in->buf)->last_buf) {
#line 1439
      last = (ngx_uint_t )1;
    }
#line 1442
    if ((in->buf)->flush) {
#line 1442
      goto _L;
    } else
#line 1442
    if ((in->buf)->last_buf) {
#line 1442
      goto _L;
    } else
#line 1442
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 1442
      if (! (in->buf)->temporary) {
#line 1442
        if (! (in->buf)->memory) {
#line 1442
          if (! (in->buf)->mmap) {
#line 1442
            if (! (in->buf)->in_file) {
#line 1443
              in = in->next;
#line 1444
              goto while_continue;
            }
          }
        }
      }
    }
#line 1447
    if ((in->buf)->in_file) {
#line 1448
      file_pos = (in->buf)->file_pos;
    } else {
#line 1451
      pos = (in->buf)->pos;
    }
#line 1454
    next = (ngx_uint_t )0;
    {
#line 1456
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1457
      tl = ngx_chain_get_free_buf(r->pool, & f->free);
      }
#line 1458
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1459
        return ((ngx_int_t )-1);
      }
      {
#line 1462
      b = tl->buf;
#line 1463
      start = b->start;
#line 1465
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)in->buf,
             sizeof(ngx_buf_t ));
#line 1472
      b->start = start;
      }
#line 1474
      if ((in->buf)->in_file) {
#line 1475
        b->file_pos = file_pos;
#line 1476
        file_pos += 32768L;
#line 1478
        if (file_pos >= (in->buf)->file_last) {
#line 1479
          file_pos = (in->buf)->file_last;
#line 1480
          next = (ngx_uint_t )1;
        }
#line 1483
        b->file_last = file_pos;
#line 1484
        len = (ngx_uint_t )(file_pos - b->file_pos);
      } else {
#line 1487
        b->pos = pos;
#line 1488
        pos += 32768;
#line 1490
        if ((unsigned long )pos >= (unsigned long )(in->buf)->last) {
#line 1491
          pos = (in->buf)->last;
#line 1492
          next = (ngx_uint_t )1;
        }
#line 1495
        b->last = pos;
#line 1496
        len = (ngx_uint_t )(pos - b->pos);
      }
#line 1499
      b->tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter);
#line 1500
      b->shadow = in->buf;
#line 1501
      b->last_shadow = (unsigned int )next;
#line 1503
      b->last_buf = 0U;
#line 1504
      b->last_in_chain = 0U;
#line 1506
      padding = 8UL - len % 8UL;
#line 1507
      if (padding == 8UL) {
#line 1507
        padding = (size_t___0 )0;
      } else {
#line 1507
        padding = padding;
      }
      {
#line 1509
      h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1510
      (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1512
      h->version = (u_char )1;
#line 1513
      h->type = (u_char )5;
#line 1514
      h->request_id_hi = (u_char )0;
#line 1515
      h->request_id_lo = (u_char )1;
#line 1516
      h->content_length_hi = (u_char )((len >> 8) & 255UL);
#line 1517
      h->content_length_lo = (u_char )(len & 255UL);
#line 1518
      h->padding_length = (u_char )padding;
#line 1519
      h->reserved = (u_char )0;
#line 1521
      cl->next = tl;
#line 1522
      cl = tl;
#line 1524
      tl = ngx_chain_get_free_buf(r->pool, & f->free);
      }
#line 1525
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1526
        return ((ngx_int_t )-1);
      }
#line 1529
      b = tl->buf;
#line 1531
      b->tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter);
#line 1532
      b->temporary = 1U;
#line 1534
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 1537
        tmp___0 = ngx_palloc(r->pool, sizeof(ngx_http_fastcgi_header_t ) + 7UL);
#line 1537
        b->start = (u_char *)tmp___0;
        }
#line 1539
        if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 1540
          return ((ngx_int_t )-1);
        }
#line 1543
        b->pos = b->start;
#line 1544
        b->last = b->start;
#line 1546
        b->end = (b->start + sizeof(ngx_http_fastcgi_header_t )) + 7;
      }
#line 1549
      if (padding) {
        {
#line 1550
        memset((void *)b->last, 0, padding);
#line 1551
        b->last += padding;
        }
      }
#line 1554
      cl->next = tl;
#line 1555
      cl = tl;
#line 1456
      if (! (! next)) {
#line 1456
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1559
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1562
  if (last) {
#line 1563
    h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1564
    (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1566
    h->version = (u_char )1;
#line 1567
    h->type = (u_char )5;
#line 1568
    h->request_id_hi = (u_char )0;
#line 1569
    h->request_id_lo = (u_char )1;
#line 1570
    h->content_length_hi = (u_char )0;
#line 1571
    h->content_length_lo = (u_char )0;
#line 1572
    h->padding_length = (u_char )0;
#line 1573
    h->reserved = (u_char )0;
#line 1575
    (cl->buf)->last_buf = 1U;
  } else
#line 1577
  if (padding == 0UL) {
#line 1579
    (cl->buf)->temporary = 0U;
#line 1580
    (cl->buf)->sync = 1U;
  }
#line 1583
  cl->next = (ngx_chain_t *)((void *)0);
  out: 
  {
#line 1603
  rc = ngx_chain_writer((void *)(& (r->upstream)->writer), out);
#line 1605
  ngx_chain_update_chains(r->pool, & f->free, & f->busy, & out, (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter));
#line 1608
  cl = f->free;
  }
  {
#line 1608
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1608
    if (! cl) {
#line 1608
      goto while_break___1;
    }
#line 1612
    if ((cl->buf)->shadow) {
#line 1613
      if ((cl->buf)->last_shadow) {
#line 1614
        b = (cl->buf)->shadow;
#line 1615
        b->pos = b->last;
      }
#line 1618
      (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
    }
#line 1608
    cl = cl->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1622
  return (rc);
}
}
#line 1626 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_process_header(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *msg ;
  u_char *start ;
  u_char *last ;
  u_char *part_start ;
  u_char *part_end ;
  size_t___0 size ;
  ngx_str_t *status_line ;
  ngx_str_t *pattern ;
  ngx_int_t rc ;
  ngx_int_t status ;
  ngx_buf_t buf ;
  ngx_uint_t i ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_http_fastcgi_split_part_t *part ;
  ngx_http_upstream_main_conf_t *umcf ;
  u_char *tmp ;
  ssize_t len ;
  ngx_http_fastcgi_header_t *fh ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;

  {
#line 1644
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 1646
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
#line 1648
  u = r->upstream;
  {
#line 1650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1652
    if ((unsigned int )f->state < 8U) {
      {
#line 1654
      f->pos = u->buffer.pos;
#line 1655
      f->last = u->buffer.last;
#line 1657
      rc = ngx_http_fastcgi_process_record(r, f);
#line 1659
      u->buffer.pos = f->pos;
#line 1660
      u->buffer.last = f->last;
      }
#line 1662
      if (rc == -2L) {
#line 1663
        return ((ngx_int_t )-2);
      }
#line 1666
      if (rc == -1L) {
#line 1667
        return ((ngx_int_t )40);
      }
#line 1670
      if (f->type != 6UL) {
#line 1670
        if (f->type != 7UL) {
#line 1673
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1673
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unexpected FastCGI record: %ui",
                               f->type);
            }
          }
#line 1677
          return ((ngx_int_t )40);
        }
      }
#line 1680
      if (f->type == 6UL) {
#line 1680
        if (f->length == 0UL) {
#line 1681
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1681
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream prematurely closed FastCGI stdout");
            }
          }
#line 1684
          return ((ngx_int_t )40);
        }
      }
    }
#line 1688
    if ((unsigned int )f->state == 9U) {
#line 1690
      if ((unsigned long )(u->buffer.pos + f->padding) < (unsigned long )u->buffer.last) {
#line 1691
        f->state = (ngx_http_fastcgi_state_e )0;
#line 1692
        u->buffer.pos += f->padding;
#line 1694
        goto __Cont;
      }
#line 1697
      if ((unsigned long )(u->buffer.pos + f->padding) == (unsigned long )u->buffer.last) {
#line 1698
        f->state = (ngx_http_fastcgi_state_e )0;
#line 1699
        u->buffer.pos = u->buffer.last;
#line 1701
        return ((ngx_int_t )-2);
      }
#line 1704
      f->padding -= (size_t___0 )(u->buffer.last - u->buffer.pos);
#line 1705
      u->buffer.pos = u->buffer.last;
#line 1707
      return ((ngx_int_t )-2);
    }
#line 1713
    if (f->type == 7UL) {
#line 1715
      if (f->length) {
#line 1716
        msg = u->buffer.pos;
#line 1718
        if ((unsigned long )(u->buffer.pos + f->length) <= (unsigned long )u->buffer.last) {
#line 1719
          u->buffer.pos += f->length;
#line 1720
          f->length = (size_t___0 )0;
#line 1721
          f->state = (ngx_http_fastcgi_state_e )9;
        } else {
#line 1724
          f->length -= (size_t___0 )(u->buffer.last - u->buffer.pos);
#line 1725
          u->buffer.pos = u->buffer.last;
        }
#line 1728
        p = u->buffer.pos - 1;
        {
#line 1728
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1728
          if (! ((unsigned long )msg < (unsigned long )p)) {
#line 1728
            goto while_break___0;
          }
#line 1729
          if ((int )*p != 10) {
#line 1729
            if ((int )*p != 13) {
#line 1729
              if ((int )*p != 46) {
#line 1729
                if ((int )*p != 32) {
#line 1730
                  goto while_break___0;
                }
              }
            }
          }
#line 1728
          p --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1734
        p ++;
#line 1736
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 1736
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "FastCGI sent in stderr: \"%*s\"",
                             p - msg, msg);
          }
        }
#line 1739
        flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 1741
        if (flcf->catch_stderr) {
#line 1742
          pattern = (ngx_str_t *)(flcf->catch_stderr)->elts;
#line 1744
          i = (ngx_uint_t )0;
          {
#line 1744
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1744
            if (! (i < (flcf->catch_stderr)->nelts)) {
#line 1744
              goto while_break___1;
            }
            {
#line 1745
            tmp = ngx_strnstr(msg, (char *)(pattern + i)->data, (size_t___0 )(p - msg));
            }
#line 1745
            if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1749
              return ((ngx_int_t )40);
            }
#line 1744
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1754
        if ((unsigned long )u->buffer.pos == (unsigned long )u->buffer.last) {
#line 1756
          if (! f->fastcgi_stdout) {
#line 1764
            if (r->cache) {
#line 1765
              u->buffer.pos = u->buffer.start + (r->cache)->header_start;
            } else {
#line 1768
              u->buffer.pos = u->buffer.start;
            }
#line 1773
            u->buffer.last = u->buffer.pos;
#line 1774
            f->large_stderr = 1U;
          }
#line 1777
          return ((ngx_int_t )-2);
        }
      } else {
#line 1781
        f->state = (ngx_http_fastcgi_state_e )9;
      }
#line 1784
      goto __Cont;
    }
#line 1792
    if (f->large_stderr) {
#line 1792
      if (r->cache) {
#line 1796
        start = u->buffer.start + (r->cache)->header_start;
#line 1798
        len = (ssize_t )((unsigned long )(u->buffer.pos - start) - 2UL * sizeof(ngx_http_fastcgi_header_t ));
#line 1808
        if (len >= 0L) {
#line 1809
          fh = (ngx_http_fastcgi_header_t *)start;
#line 1810
          fh->version = (u_char )1;
#line 1811
          fh->type = (u_char )7;
#line 1812
          fh->request_id_hi = (u_char )0;
#line 1813
          fh->request_id_lo = (u_char )1;
#line 1814
          fh->content_length_hi = (u_char )((len >> 8) & 255L);
#line 1815
          fh->content_length_lo = (u_char )(len & 255L);
#line 1816
          fh->padding_length = (u_char )0;
#line 1817
          fh->reserved = (u_char )0;
        } else {
#line 1820
          (r->cache)->header_start += (unsigned long )(u->buffer.pos - start) - sizeof(ngx_http_fastcgi_header_t );
        }
#line 1824
        f->large_stderr = 0U;
      }
    }
#line 1829
    f->fastcgi_stdout = 1U;
#line 1831
    start = u->buffer.pos;
#line 1833
    if ((unsigned long )(u->buffer.pos + f->length) < (unsigned long )u->buffer.last) {
#line 1840
      last = u->buffer.last;
#line 1841
      u->buffer.last = u->buffer.pos + f->length;
    } else {
#line 1844
      last = (u_char *)((void *)0);
    }
    {
#line 1847
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1849
      part_start = u->buffer.pos;
#line 1850
      part_end = u->buffer.last;
#line 1852
      rc = ngx_http_parse_header_line(r, & u->buffer, (ngx_uint_t )1);
      }
#line 1857
      if (rc == -2L) {
#line 1858
        goto while_break___2;
      }
#line 1861
      if (rc == 0L) {
        {
#line 1865
        tmp___0 = ngx_list_push(& u->headers_in.headers);
#line 1865
        h = (ngx_table_elt_t *)tmp___0;
        }
#line 1866
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1867
          return ((ngx_int_t )-1);
        }
#line 1870
        if (f->split_parts) {
#line 1870
          if ((f->split_parts)->nelts) {
#line 1872
            part = (ngx_http_fastcgi_split_part_t *)(f->split_parts)->elts;
#line 1873
            size = (size_t___0 )(u->buffer.pos - part_start);
#line 1875
            i = (ngx_uint_t )0;
            {
#line 1875
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1875
              if (! (i < (f->split_parts)->nelts)) {
#line 1875
                goto while_break___3;
              }
#line 1876
              size += (size_t___0 )((part + i)->end - (part + i)->start);
#line 1875
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 1879
            tmp___1 = ngx_pnalloc(r->pool, size);
#line 1879
            p = (u_char *)tmp___1;
            }
#line 1880
            if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1881
              h->hash = (ngx_uint_t )0;
#line 1882
              return ((ngx_int_t )-1);
            }
#line 1885
            buf.pos = p;
#line 1887
            i = (ngx_uint_t )0;
            {
#line 1887
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1887
              if (! (i < (f->split_parts)->nelts)) {
#line 1887
                goto while_break___4;
              }
              {
#line 1888
              tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(part + i)->start,
                               (size_t )((part + i)->end - (part + i)->start));
#line 1888
              p = (u_char *)tmp___2 + ((part + i)->end - (part + i)->start);
#line 1887
              i ++;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 1892
            tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)part_start,
                             (size_t )(u->buffer.pos - part_start));
#line 1892
            p = (u_char *)tmp___3 + (u->buffer.pos - part_start);
#line 1894
            buf.last = p;
#line 1896
            (f->split_parts)->nelts = (ngx_uint_t )0;
#line 1898
            rc = ngx_http_parse_header_line(r, & buf, (ngx_uint_t )1);
            }
#line 1900
            if (rc != 0L) {
#line 1901
              if (((r->connection)->log)->log_level >= 2UL) {
                {
#line 1901
                ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "invalid header after joining FastCGI records");
                }
              }
#line 1904
              h->hash = (ngx_uint_t )0;
#line 1905
              return ((ngx_int_t )-1);
            }
            {
#line 1908
            h->key.len = (size_t___0 )(r->header_name_end - r->header_name_start);
#line 1909
            h->key.data = r->header_name_start;
#line 1910
            *(h->key.data + h->key.len) = (u_char )'\000';
#line 1912
            h->value.len = (size_t___0 )(r->header_end - r->header_start);
#line 1913
            h->value.data = r->header_start;
#line 1914
            *(h->value.data + h->value.len) = (u_char )'\000';
#line 1916
            tmp___4 = ngx_pnalloc(r->pool, h->key.len);
#line 1916
            h->lowcase_key = (u_char *)tmp___4;
            }
#line 1917
            if ((unsigned long )h->lowcase_key == (unsigned long )((void *)0)) {
#line 1918
              return ((ngx_int_t )-1);
            }
          } else {
#line 1870
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1923
          h->key.len = (size_t___0 )(r->header_name_end - r->header_name_start);
#line 1924
          h->value.len = (size_t___0 )(r->header_end - r->header_start);
#line 1926
          tmp___5 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1926
          h->key.data = (u_char *)tmp___5;
          }
#line 1929
          if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1930
            h->hash = (ngx_uint_t )0;
#line 1931
            return ((ngx_int_t )-1);
          }
          {
#line 1934
          h->value.data = (h->key.data + h->key.len) + 1;
#line 1935
          h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1938
          memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
                 h->key.len);
#line 1939
          *(h->key.data + h->key.len) = (u_char )'\000';
#line 1940
          memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
                 h->value.len);
#line 1941
          *(h->value.data + h->value.len) = (u_char )'\000';
          }
        }
#line 1944
        h->hash = r->header_hash;
#line 1946
        if (h->key.len == r->lowcase_index) {
          {
#line 1947
          memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
                 h->key.len);
          }
        } else {
          {
#line 1950
          ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
          }
        }
        {
#line 1953
        tmp___6 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key,
                                h->key.len);
#line 1953
        hh = (ngx_http_upstream_header_t *)tmp___6;
        }
#line 1956
        if (hh) {
          {
#line 1956
          tmp___7 = (*(hh->handler))(r, h, hh->offset);
          }
#line 1956
          if (tmp___7 != 0L) {
#line 1957
            return ((ngx_int_t )-1);
          }
        }
#line 1964
        if ((unsigned long )u->buffer.pos < (unsigned long )u->buffer.last) {
#line 1965
          goto __Cont___0;
        }
#line 1970
        goto while_break___2;
      }
#line 1973
      if (rc == 1L) {
#line 1980
        if (u->headers_in.status) {
          {
#line 1981
          status_line = & (u->headers_in.status)->value;
#line 1983
          status = ngx_atoi(status_line->data, (size_t___0 )3);
          }
#line 1985
          if (status == -1L) {
#line 1986
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 1986
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid status \"%V\"",
                                 status_line);
              }
            }
#line 1989
            return ((ngx_int_t )40);
          }
#line 1992
          u->headers_in.status_n = (ngx_uint_t )status;
#line 1993
          u->headers_in.status_line = *status_line;
        } else
#line 1995
        if (u->headers_in.location) {
#line 1996
          u->headers_in.status_n = (ngx_uint_t )302;
#line 1997
          u->headers_in.status_line.len = sizeof("302 Moved Temporarily") - 1UL;
#line 1997
          u->headers_in.status_line.data = (u_char *)"302 Moved Temporarily";
        } else {
#line 2001
          u->headers_in.status_n = (ngx_uint_t )200;
#line 2002
          u->headers_in.status_line.len = sizeof("200 OK") - 1UL;
#line 2002
          u->headers_in.status_line.data = (u_char *)"200 OK";
        }
#line 2005
        if (u->state) {
#line 2005
          if ((u->state)->status == 0UL) {
#line 2006
            (u->state)->status = u->headers_in.status_n;
          }
        }
#line 2009
        goto while_break___2;
      }
#line 2014
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2014
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
        }
      }
#line 2017
      return ((ngx_int_t )40);
      __Cont___0: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2020
    if (last) {
#line 2021
      u->buffer.last = last;
    }
#line 2024
    f->length -= (size_t___0 )(u->buffer.pos - start);
#line 2026
    if (f->length == 0UL) {
#line 2027
      f->state = (ngx_http_fastcgi_state_e )9;
    }
#line 2030
    if (rc == 1L) {
#line 2031
      return ((ngx_int_t )0);
    }
#line 2034
    if (rc == 0L) {
#line 2035
      goto __Cont;
    }
#line 2043
    if ((unsigned long )f->split_parts == (unsigned long )((void *)0)) {
      {
#line 2044
      f->split_parts = ngx_array_create(r->pool, (ngx_uint_t )1, sizeof(ngx_http_fastcgi_split_part_t ));
      }
#line 2046
      if ((unsigned long )f->split_parts == (unsigned long )((void *)0)) {
#line 2047
        return ((ngx_int_t )-1);
      }
    }
    {
#line 2051
    tmp___8 = ngx_array_push(f->split_parts);
#line 2051
    part = (ngx_http_fastcgi_split_part_t *)tmp___8;
    }
#line 2052
    if ((unsigned long )part == (unsigned long )((void *)0)) {
#line 2053
      return ((ngx_int_t )-1);
    }
#line 2056
    part->start = part_start;
#line 2057
    part->end = part_end;
#line 2059
    if ((unsigned long )u->buffer.pos < (unsigned long )u->buffer.last) {
#line 2060
      goto __Cont;
    }
#line 2063
    return ((ngx_int_t )-2);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2068 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_input_filter_init(void *data ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_fastcgi_loc_conf_t *flcf ;

  {
#line 2071
  r = (ngx_http_request_t *)data;
#line 2074
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 2076
  if (flcf->keep_conn) {
#line 2076
    ((r->upstream)->pipe)->length = (off_t )sizeof(ngx_http_fastcgi_header_t );
  } else {
#line 2076
    ((r->upstream)->pipe)->length = (off_t )-1;
  }
#line 2079
  return ((ngx_int_t )0);
}
}
#line 2083 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  u_char *m ;
  u_char *msg ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t **prev ;
  ngx_chain_t *cl ;
  ngx_http_request_t *r ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_int_t tmp ;

  {
#line 2094
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 2095
    return ((ngx_int_t )0);
  }
#line 2098
  r = (ngx_http_request_t *)p->input_ctx;
#line 2099
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 2100
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 2102
  b = (ngx_buf_t *)((void *)0);
#line 2103
  prev = & buf->shadow;
#line 2105
  f->pos = buf->pos;
#line 2106
  f->last = buf->last;
  {
#line 2108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2109
    if ((unsigned int )f->state < 8U) {
      {
#line 2111
      rc = ngx_http_fastcgi_process_record(r, f);
      }
#line 2113
      if (rc == -2L) {
#line 2114
        goto while_break;
      }
#line 2117
      if (rc == -1L) {
#line 2118
        return ((ngx_int_t )-1);
      }
#line 2121
      if (f->type == 6UL) {
#line 2121
        if (f->length == 0UL) {
#line 2122
          f->state = (ngx_http_fastcgi_state_e )9;
#line 2124
          if (! flcf->keep_conn) {
#line 2125
            p->upstream_done = 1U;
          }
#line 2131
          goto __Cont;
        }
      }
#line 2134
      if (f->type == 3UL) {
#line 2139
        if (! flcf->keep_conn) {
#line 2140
          p->upstream_done = 1U;
#line 2141
          goto while_break;
        }
#line 2144
        goto __Cont;
      }
    }
#line 2149
    if ((unsigned int )f->state == 9U) {
#line 2151
      if (f->type == 3UL) {
#line 2153
        if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2154
          p->upstream_done = 1U;
#line 2155
          goto while_break;
        }
#line 2158
        if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2159
          p->upstream_done = 1U;
#line 2160
          (r->upstream)->keepalive = 1U;
#line 2161
          goto while_break;
        }
#line 2164
        f->padding -= (size_t___0 )(f->last - f->pos);
#line 2166
        goto while_break;
      }
#line 2169
      if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2170
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2171
        f->pos += f->padding;
#line 2173
        goto __Cont;
      }
#line 2176
      if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2177
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2179
        goto while_break;
      }
#line 2182
      f->padding -= (size_t___0 )(f->last - f->pos);
#line 2184
      goto while_break;
    }
#line 2190
    if (f->type == 7UL) {
#line 2192
      if (f->length) {
#line 2194
        if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2195
          goto while_break;
        }
#line 2198
        msg = f->pos;
#line 2200
        if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2201
          f->pos += f->length;
#line 2202
          f->length = (size_t___0 )0;
#line 2203
          f->state = (ngx_http_fastcgi_state_e )9;
        } else {
#line 2206
          f->length -= (size_t___0 )(f->last - f->pos);
#line 2207
          f->pos = f->last;
        }
#line 2210
        m = f->pos - 1;
        {
#line 2210
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2210
          if (! ((unsigned long )msg < (unsigned long )m)) {
#line 2210
            goto while_break___0;
          }
#line 2211
          if ((int )*m != 10) {
#line 2211
            if ((int )*m != 13) {
#line 2211
              if ((int )*m != 46) {
#line 2211
                if ((int )*m != 32) {
#line 2212
                  goto while_break___0;
                }
              }
            }
          }
#line 2210
          m --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2216
        if ((p->log)->log_level >= 4UL) {
          {
#line 2216
          ngx_log_error_core((ngx_uint_t )4, p->log, 0, "FastCGI sent in stderr: \"%*s\"",
                             (m + 1) - msg, msg);
          }
        }
      } else {
#line 2221
        f->state = (ngx_http_fastcgi_state_e )9;
      }
#line 2224
      goto __Cont;
    }
#line 2227
    if (f->type == 3UL) {
#line 2229
      if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2230
        f->state = (ngx_http_fastcgi_state_e )9;
#line 2231
        f->pos += f->length;
#line 2233
        goto __Cont;
      }
#line 2236
      f->length -= (size_t___0 )(f->last - f->pos);
#line 2238
      goto while_break;
    }
#line 2244
    if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2245
      goto while_break;
    }
    {
#line 2248
    cl = ngx_chain_get_free_buf(p->pool, & p->free);
    }
#line 2249
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2250
      return ((ngx_int_t )-1);
    }
    {
#line 2253
    b = cl->buf;
#line 2255
    memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 2257
    b->pos = f->pos;
#line 2258
    b->start = buf->start;
#line 2259
    b->end = buf->end;
#line 2260
    b->tag = p->tag;
#line 2261
    b->temporary = 1U;
#line 2262
    b->recycled = 1U;
#line 2264
    *prev = b;
#line 2265
    prev = & b->shadow;
    }
#line 2267
    if (p->in) {
#line 2268
      *(p->last_in) = cl;
    } else {
#line 2270
      p->in = cl;
    }
#line 2272
    p->last_in = & cl->next;
#line 2275
    b->num = buf->num;
#line 2280
    if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2281
      f->state = (ngx_http_fastcgi_state_e )9;
#line 2282
      f->pos += f->length;
#line 2283
      b->last = f->pos;
#line 2285
      goto __Cont;
    }
#line 2288
    f->length -= (size_t___0 )(f->last - f->pos);
#line 2290
    b->last = f->last;
#line 2292
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2296
  if (flcf->keep_conn) {
#line 2300
    if ((unsigned int )f->state < 8U) {
#line 2301
      p->length = (off_t )1;
    } else
#line 2303
    if ((unsigned int )f->state == 9U) {
#line 2304
      p->length = (off_t )f->padding;
    } else {
#line 2309
      p->length = (off_t )f->length;
    }
  }
#line 2313
  if (b) {
#line 2314
    b->shadow = buf;
#line 2315
    b->last_shadow = 1U;
#line 2320
    return ((ngx_int_t )0);
  }
  {
#line 2325
  tmp = ngx_event_pipe_add_free_buf(p, buf);
  }
#line 2325
  if (tmp != 0L) {
#line 2326
    return ((ngx_int_t )-1);
  }
#line 2329
  return ((ngx_int_t )0);
}
}
#line 2333 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_non_buffered_filter(void *data , ssize_t bytes ) 
{ 
  u_char *m ;
  u_char *msg ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;
  ngx_http_fastcgi_ctx_t *f ;
  void *tmp ;

  {
#line 2344
  r = (ngx_http_request_t *)data;
#line 2345
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 2347
  u = r->upstream;
#line 2348
  buf = & u->buffer;
#line 2350
  buf->pos = buf->last;
#line 2351
  buf->last += bytes;
#line 2353
  cl = u->out_bufs;
#line 2353
  ll = & u->out_bufs;
  {
#line 2353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2353
    if (! cl) {
#line 2353
      goto while_break;
    }
#line 2354
    ll = & cl->next;
#line 2353
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2357
  f->pos = buf->pos;
#line 2358
  f->last = buf->last;
  {
#line 2360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2361
    if ((unsigned int )f->state < 8U) {
      {
#line 2363
      rc = ngx_http_fastcgi_process_record(r, f);
      }
#line 2365
      if (rc == -2L) {
#line 2366
        goto while_break___0;
      }
#line 2369
      if (rc == -1L) {
#line 2370
        return ((ngx_int_t )-1);
      }
#line 2373
      if (f->type == 6UL) {
#line 2373
        if (f->length == 0UL) {
#line 2374
          f->state = (ngx_http_fastcgi_state_e )9;
#line 2379
          goto __Cont;
        }
      }
    }
#line 2383
    if ((unsigned int )f->state == 9U) {
#line 2385
      if (f->type == 3UL) {
#line 2387
        if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2388
          u->length = (off_t )0;
#line 2389
          goto while_break___0;
        }
#line 2392
        if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2393
          u->length = (off_t )0;
#line 2394
          u->keepalive = 1U;
#line 2395
          goto while_break___0;
        }
#line 2398
        f->padding -= (size_t___0 )(f->last - f->pos);
#line 2400
        goto while_break___0;
      }
#line 2403
      if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2404
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2405
        f->pos += f->padding;
#line 2407
        goto __Cont;
      }
#line 2410
      if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2411
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2413
        goto while_break___0;
      }
#line 2416
      f->padding -= (size_t___0 )(f->last - f->pos);
#line 2418
      goto while_break___0;
    }
#line 2424
    if (f->type == 7UL) {
#line 2426
      if (f->length) {
#line 2428
        if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2429
          goto while_break___0;
        }
#line 2432
        msg = f->pos;
#line 2434
        if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2435
          f->pos += f->length;
#line 2436
          f->length = (size_t___0 )0;
#line 2437
          f->state = (ngx_http_fastcgi_state_e )9;
        } else {
#line 2440
          f->length -= (size_t___0 )(f->last - f->pos);
#line 2441
          f->pos = f->last;
        }
#line 2444
        m = f->pos - 1;
        {
#line 2444
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2444
          if (! ((unsigned long )msg < (unsigned long )m)) {
#line 2444
            goto while_break___1;
          }
#line 2445
          if ((int )*m != 10) {
#line 2445
            if ((int )*m != 13) {
#line 2445
              if ((int )*m != 46) {
#line 2445
                if ((int )*m != 32) {
#line 2446
                  goto while_break___1;
                }
              }
            }
          }
#line 2444
          m --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2450
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 2450
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "FastCGI sent in stderr: \"%*s\"",
                             (m + 1) - msg, msg);
          }
        }
      } else {
#line 2455
        f->state = (ngx_http_fastcgi_state_e )9;
      }
#line 2458
      goto __Cont;
    }
#line 2461
    if (f->type == 3UL) {
#line 2463
      if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2464
        f->state = (ngx_http_fastcgi_state_e )9;
#line 2465
        f->pos += f->length;
#line 2467
        goto __Cont;
      }
#line 2470
      f->length -= (size_t___0 )(f->last - f->pos);
#line 2472
      goto while_break___0;
    }
#line 2478
    if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2479
      goto while_break___0;
    }
    {
#line 2482
    cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
    }
#line 2483
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2484
      return ((ngx_int_t )-1);
    }
#line 2487
    *ll = cl;
#line 2488
    ll = & cl->next;
#line 2490
    b = cl->buf;
#line 2492
    b->flush = 1U;
#line 2493
    b->memory = 1U;
#line 2495
    b->pos = f->pos;
#line 2496
    b->tag = u->output.tag;
#line 2501
    if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2502
      f->state = (ngx_http_fastcgi_state_e )9;
#line 2503
      f->pos += f->length;
#line 2504
      b->last = f->pos;
#line 2506
      goto __Cont;
    }
#line 2509
    f->length -= (size_t___0 )(f->last - f->pos);
#line 2510
    b->last = f->last;
#line 2512
    goto while_break___0;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2517
  if (r->subrequest_in_memory) {
#line 2519
    cl = u->out_bufs;
#line 2521
    if (cl) {
#line 2522
      buf->pos = (cl->buf)->pos;
    }
#line 2525
    buf->last = buf->pos;
#line 2527
    cl = u->out_bufs;
    {
#line 2527
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2527
      if (! cl) {
#line 2527
        goto while_break___2;
      }
#line 2532
      if ((unsigned long )buf->last == (unsigned long )(cl->buf)->pos) {
#line 2533
        buf->last = (cl->buf)->last;
#line 2534
        goto __Cont___0;
      }
      {
#line 2537
      tmp = memmove((void *)buf->last, (void const   *)(cl->buf)->pos, (size_t )((cl->buf)->last - (cl->buf)->pos));
#line 2537
      buf->last = (u_char *)tmp + ((cl->buf)->last - (cl->buf)->pos);
#line 2540
      (cl->buf)->pos = buf->last - ((cl->buf)->last - (cl->buf)->pos);
#line 2541
      (cl->buf)->last = buf->last;
      }
      __Cont___0: /* CIL Label */ 
#line 2527
      cl = cl->next;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2545
  return ((ngx_int_t )0);
}
}
#line 2549 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_process_record(ngx_http_request_t *r , ngx_http_fastcgi_ctx_t *f ) 
{ 
  u_char ch ;
  u_char *p ;
  ngx_http_fastcgi_state_e state ;

  {
#line 2556
  state = f->state;
#line 2558
  p = f->pos;
  {
#line 2558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2558
    if (! ((unsigned long )p < (unsigned long )f->last)) {
#line 2558
      goto while_break;
    }
#line 2560
    ch = *p;
    {
#line 2567
    if ((unsigned int )state == 0U) {
#line 2567
      goto case_0;
    }
#line 2577
    if ((unsigned int )state == 1U) {
#line 2577
      goto case_1;
    }
#line 2596
    if ((unsigned int )state == 2U) {
#line 2596
      goto case_2;
    }
#line 2606
    if ((unsigned int )state == 3U) {
#line 2606
      goto case_3___0;
    }
#line 2616
    if ((unsigned int )state == 4U) {
#line 2616
      goto case_4;
    }
#line 2621
    if ((unsigned int )state == 5U) {
#line 2621
      goto case_5;
    }
#line 2626
    if ((unsigned int )state == 6U) {
#line 2626
      goto case_6___0;
    }
#line 2631
    if ((unsigned int )state == 7U) {
#line 2631
      goto case_7___0;
    }
#line 2644
    if ((unsigned int )state == 9U) {
#line 2644
      goto case_9;
    }
#line 2644
    if ((unsigned int )state == 8U) {
#line 2644
      goto case_9;
    }
#line 2565
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2568
    if ((int )ch != 1) {
#line 2569
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2569
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unsupported FastCGI protocol version: %d",
                           (int )ch);
        }
      }
#line 2572
      return ((ngx_int_t )-1);
    }
#line 2574
    state = (ngx_http_fastcgi_state_e )1;
#line 2575
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 2581
    if ((int )ch == 3) {
#line 2581
      goto case_3;
    }
#line 2581
    if ((int )ch == 7) {
#line 2581
      goto case_3;
    }
#line 2581
    if ((int )ch == 6) {
#line 2581
      goto case_3;
    }
#line 2584
    goto switch_default;
    case_3: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 2582
    f->type = (ngx_uint_t )ch;
#line 2583
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 2585
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2585
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid FastCGI record type: %d",
                         (int )ch);
      }
    }
#line 2588
    return ((ngx_int_t )-1);
    switch_break___0: /* CIL Label */ ;
    }
#line 2591
    state = (ngx_http_fastcgi_state_e )2;
#line 2592
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2597
    if ((int )ch != 0) {
#line 2598
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2598
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unexpected FastCGI request id high byte: %d",
                           (int )ch);
        }
      }
#line 2601
      return ((ngx_int_t )-1);
    }
#line 2603
    state = (ngx_http_fastcgi_state_e )3;
#line 2604
    goto switch_break;
    case_3___0: /* CIL Label */ 
#line 2607
    if ((int )ch != 1) {
#line 2608
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2608
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unexpected FastCGI request id low byte: %d",
                           (int )ch);
        }
      }
#line 2611
      return ((ngx_int_t )-1);
    }
#line 2613
    state = (ngx_http_fastcgi_state_e )4;
#line 2614
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2617
    f->length = (size_t___0 )((int )ch << 8);
#line 2618
    state = (ngx_http_fastcgi_state_e )5;
#line 2619
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2622
    f->length |= (size_t___0 )ch;
#line 2623
    state = (ngx_http_fastcgi_state_e )6;
#line 2624
    goto switch_break;
    case_6___0: /* CIL Label */ 
#line 2627
    f->padding = (size_t___0 )ch;
#line 2628
    state = (ngx_http_fastcgi_state_e )7;
#line 2629
    goto switch_break;
    case_7___0: /* CIL Label */ 
#line 2632
    state = (ngx_http_fastcgi_state_e )8;
#line 2637
    f->pos = p + 1;
#line 2638
    f->state = state;
#line 2640
    return ((ngx_int_t )0);
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 2645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2558
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2649
  f->state = state;
#line 2651
  return ((ngx_int_t )-2);
}
}
#line 2655 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static void ngx_http_fastcgi_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 2661
  return;
}
}
#line 2665 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static void ngx_http_fastcgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 2671
  return;
}
}
#line 2675 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 2680
  v = ngx_http_fastcgi_vars;
  {
#line 2680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2680
    if (! v->name.len) {
#line 2680
      goto while_break;
    }
    {
#line 2681
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 2682
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2683
      return ((ngx_int_t )-1);
    }
#line 2686
    var->get_handler = v->get_handler;
#line 2687
    var->data = v->data;
#line 2680
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2690
  return ((ngx_int_t )0);
}
}
#line 2694 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static void *ngx_http_fastcgi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_fastcgi_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2699
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_fastcgi_main_conf_t ));
#line 2699
  conf = (ngx_http_fastcgi_main_conf_t *)tmp;
  }
#line 2700
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2701
    return ((void *)0);
  }
  {
#line 2705
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 2705
  if (tmp___0 != 0L) {
#line 2709
    return ((void *)0);
  }
#line 2713
  return ((void *)conf);
}
}
#line 2717 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static void *ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 2722
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_fastcgi_loc_conf_t ));
#line 2722
  conf = (ngx_http_fastcgi_loc_conf_t *)tmp;
  }
#line 2723
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2724
    return ((void *)0);
  }
#line 2746
  conf->upstream.store = -1;
#line 2747
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 2748
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 2749
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 2750
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 2751
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 2752
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 2754
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 2756
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 2757
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 2758
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 2759
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 2761
  conf->upstream.send_lowat = (size_t___0 )-1;
#line 2762
  conf->upstream.buffer_size = (size_t___0 )-1;
#line 2763
  conf->upstream.limit_rate = (size_t___0 )-1;
#line 2765
  conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
#line 2766
  conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
#line 2767
  conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
#line 2769
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 2770
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 2773
  conf->upstream.cache = -1;
#line 2774
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 2775
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 2776
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 2777
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 2778
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 2779
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 2780
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 2781
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 2782
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 2783
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 2786
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 2787
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 2789
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 2792
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 2794
  conf->upstream.change_buffering = 1U;
#line 2796
  conf->catch_stderr = (ngx_array_t *)((void *)-1);
#line 2798
  conf->keep_conn = (ngx_flag_t )-1;
#line 2800
  conf->upstream.module.len = sizeof("fastcgi") - 1UL;
#line 2800
  conf->upstream.module.data = (u_char *)"fastcgi";
#line 2802
  return ((void *)conf);
}
}
#line 2806 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_fastcgi_loc_conf_t *prev ;
  ngx_http_fastcgi_loc_conf_t *conf ;
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  ngx_int_t tmp___0 ;

  {
#line 2809
  prev = (ngx_http_fastcgi_loc_conf_t *)parent;
#line 2810
  conf = (ngx_http_fastcgi_loc_conf_t *)child;
#line 2819
  if (conf->upstream.store > 0) {
#line 2820
    conf->upstream.cache = 0;
  }
#line 2823
  if (conf->upstream.cache > 0) {
#line 2824
    conf->upstream.store = 0;
  }
#line 2829
  if (conf->upstream.store == -1) {
#line 2830
    if (conf->upstream.store == -1) {
#line 2830
      if (prev->upstream.store == -1) {
#line 2830
        conf->upstream.store = 0;
      } else {
#line 2830
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 2833
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 2834
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 2837
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 2837
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 2837
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 2837
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 2840
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2840
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2840
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 2840
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 2843
  if (conf->upstream.buffering == -1L) {
#line 2843
    if (prev->upstream.buffering == -1L) {
#line 2843
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 2843
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 2846
  if (conf->upstream.request_buffering == -1L) {
#line 2846
    if (prev->upstream.request_buffering == -1L) {
#line 2846
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 2846
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 2849
  if (conf->upstream.ignore_client_abort == -1L) {
#line 2849
    if (prev->upstream.ignore_client_abort == -1L) {
#line 2849
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 2849
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 2852
  if (conf->upstream.force_ranges == -1L) {
#line 2852
    if (prev->upstream.force_ranges == -1L) {
#line 2852
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 2852
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 2855
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 2855
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 2855
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 2855
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 2858
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2858
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2858
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 2858
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 2861
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2861
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2861
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 2861
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 2864
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2864
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2864
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 2864
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 2867
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2867
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2867
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 2867
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 2870
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2870
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2870
      conf->upstream.send_lowat = (size_t___0 )0;
    } else {
#line 2870
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 2873
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 2873
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 2873
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 2873
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 2877
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 2877
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 2877
      conf->upstream.limit_rate = (size_t___0 )0;
    } else {
#line 2877
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 2881
  if (conf->upstream.bufs.num == 0L) {
#line 2881
    if (prev->upstream.bufs.num) {
#line 2881
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 2881
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 2881
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 2881
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 2884
  if (conf->upstream.bufs.num < 2L) {
    {
#line 2885
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"fastcgi_buffers\"");
    }
#line 2887
    return ((char *)((void *)-1));
  }
#line 2891
  size = conf->upstream.buffer_size;
#line 2892
  if (size < conf->upstream.bufs.size) {
#line 2893
    size = conf->upstream.bufs.size;
  }
#line 2897
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 2897
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 2897
      conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
    } else {
#line 2897
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 2901
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 2902
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 2904
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 2908
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 2909
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"fastcgi_buffer_size\" and one of the \"fastcgi_buffers\"");
    }
#line 2914
    return ((char *)((void *)-1));
  }
#line 2917
  if (conf->upstream.busy_buffers_size > (size_t___0 )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 2920
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_busy_buffers_size\" must be less than the size of all \"fastcgi_buffers\" minus one buffer");
    }
#line 2924
    return ((char *)((void *)-1));
  }
#line 2928
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 2928
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 2928
      conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
    } else {
#line 2928
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 2932
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 2933
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 2935
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 2939
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 2940
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"fastcgi_buffer_size\" and one of the \"fastcgi_buffers\"");
    }
#line 2945
    return ((char *)((void *)-1));
  }
#line 2949
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 2949
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 2949
      conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
    } else {
#line 2949
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 2953
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 2954
    conf->upstream.max_temp_file_size = (size_t___0 )1073741824;
  } else {
#line 2956
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 2960
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 2960
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 2963
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"fastcgi_buffer_size\" and one of the \"fastcgi_buffers\"");
      }
#line 2969
      return ((char *)((void *)-1));
    }
  }
#line 2973
  if (conf->upstream.ignore_headers == 0UL) {
#line 2973
    if (prev->upstream.ignore_headers == 0UL) {
#line 2973
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 2973
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 2978
  if (conf->upstream.next_upstream == 0UL) {
#line 2978
    if (prev->upstream.next_upstream == 0UL) {
#line 2978
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 2978
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 2984
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 2985
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 2989
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_fastcgi_temp_path);
  }
#line 2989
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 2994
    return ((char *)((void *)-1));
  }
#line 2999
  if (conf->upstream.cache == -1) {
#line 3000
    if (conf->upstream.cache == -1) {
#line 3000
      if (prev->upstream.cache == -1) {
#line 3000
        conf->upstream.cache = 0;
      } else {
#line 3000
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 3003
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 3004
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 3007
  if (conf->upstream.cache_zone) {
#line 3007
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 3010
      shm_zone = conf->upstream.cache_zone;
#line 3012
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 3016
      return ((char *)((void *)-1));
    }
  }
#line 3019
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3019
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3019
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 3019
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 3022
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 3022
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 3022
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 3022
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 3026
  if (conf->upstream.cache_use_stale == 0UL) {
#line 3026
    if (prev->upstream.cache_use_stale == 0UL) {
#line 3026
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 3026
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 3031
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 3032
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 3036
  if (conf->upstream.cache_use_stale & 2UL) {
#line 3037
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 3040
  if (conf->upstream.cache_methods == 0UL) {
#line 3041
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 3044
  conf->upstream.cache_methods |= 6UL;
#line 3046
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3046
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3046
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 3046
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 3049
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3049
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3049
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 3049
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 3052
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3052
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3052
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 3052
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 3055
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 3056
    conf->cache_key = prev->cache_key;
  }
#line 3059
  if (conf->upstream.cache) {
#line 3059
    if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
      {
#line 3060
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no \"fastcgi_cache_key\" for \"fastcgi_cache\"");
      }
    }
  }
#line 3064
  if (conf->upstream.cache_lock == -1L) {
#line 3064
    if (prev->upstream.cache_lock == -1L) {
#line 3064
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 3064
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 3067
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3067
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3067
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 3067
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 3070
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3070
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3070
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 3070
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 3073
  if (conf->upstream.cache_revalidate == -1L) {
#line 3073
    if (prev->upstream.cache_revalidate == -1L) {
#line 3073
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 3073
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 3076
  if (conf->upstream.cache_background_update == -1L) {
#line 3076
    if (prev->upstream.cache_background_update == -1L) {
#line 3076
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 3076
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 3081
  if (conf->upstream.pass_request_headers == -1L) {
#line 3081
    if (prev->upstream.pass_request_headers == -1L) {
#line 3081
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 3081
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 3083
  if (conf->upstream.pass_request_body == -1L) {
#line 3083
    if (prev->upstream.pass_request_body == -1L) {
#line 3083
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 3083
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 3086
  if (conf->upstream.intercept_errors == -1L) {
#line 3086
    if (prev->upstream.intercept_errors == -1L) {
#line 3086
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 3086
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
#line 3089
  if ((unsigned long )conf->catch_stderr == (unsigned long )((void *)-1)) {
#line 3089
    if ((unsigned long )prev->catch_stderr == (unsigned long )((void *)-1)) {
#line 3089
      conf->catch_stderr = (ngx_array_t *)((void *)0);
    } else {
#line 3089
      conf->catch_stderr = prev->catch_stderr;
    }
  }
#line 3091
  if (conf->keep_conn == -1L) {
#line 3091
    if (prev->keep_conn == -1L) {
#line 3091
      conf->keep_conn = (ngx_flag_t )0;
    } else {
#line 3091
      conf->keep_conn = prev->keep_conn;
    }
  }
#line 3094
  if ((unsigned long )conf->index.data == (unsigned long )((void *)0)) {
#line 3094
    if (prev->index.data) {
#line 3094
      conf->index.len = prev->index.len;
#line 3094
      conf->index.data = prev->index.data;
    } else {
#line 3094
      conf->index.len = sizeof("") - 1UL;
#line 3094
      conf->index.data = (u_char *)"";
    }
  }
  {
#line 3096
  hash.max_size = (ngx_uint_t )512;
#line 3097
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3098
  hash.name = (char *)"fastcgi_hide_headers_hash";
#line 3100
  tmp___0 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_fastcgi_hide_headers, & hash);
  }
#line 3100
  if (tmp___0 != 0L) {
#line 3104
    return ((char *)((void *)-1));
  }
#line 3107
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3109
  if (clcf->noname) {
#line 3109
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3109
      if ((unsigned long )conf->fastcgi_lengths == (unsigned long )((void *)0)) {
#line 3112
        conf->upstream.upstream = prev->upstream.upstream;
#line 3113
        conf->fastcgi_lengths = prev->fastcgi_lengths;
#line 3114
        conf->fastcgi_values = prev->fastcgi_values;
      }
    }
  }
#line 3117
  if (clcf->lmt_excpt) {
#line 3117
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 3117
      if (conf->upstream.upstream) {
#line 3120
        clcf->handler = & ngx_http_fastcgi_handler;
      } else
#line 3117
      if (conf->fastcgi_lengths) {
#line 3120
        clcf->handler = & ngx_http_fastcgi_handler;
      }
    }
  }
#line 3124
  if ((unsigned long )conf->split_regex == (unsigned long )((void *)0)) {
#line 3125
    conf->split_regex = prev->split_regex;
#line 3126
    conf->split_name = prev->split_name;
  }
#line 3130
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 3131
    conf->params = prev->params;
#line 3133
    conf->params_cache = prev->params_cache;
#line 3135
    conf->params_source = prev->params_source;
  }
  {
#line 3138
  rc = ngx_http_fastcgi_init_params(cf, conf, & conf->params, (ngx_keyval_t *)((void *)0));
  }
#line 3139
  if (rc != 0L) {
#line 3140
    return ((char *)((void *)-1));
  }
#line 3145
  if (conf->upstream.cache) {
    {
#line 3146
    rc = ngx_http_fastcgi_init_params(cf, conf, & conf->params_cache, ngx_http_fastcgi_cache_headers);
    }
#line 3148
    if (rc != 0L) {
#line 3149
      return ((char *)((void *)-1));
    }
  }
#line 3160
  if ((unsigned long )prev->params.hash.buckets == (unsigned long )((void *)0)) {
#line 3160
    if ((unsigned long )conf->params_source == (unsigned long )prev->params_source) {
#line 3163
      prev->params = conf->params;
#line 3165
      prev->params_cache = conf->params_cache;
    }
  }
#line 3169
  return ((char *)((void *)0));
}
}
#line 3173 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_init_params(ngx_conf_t *cf , ngx_http_fastcgi_loc_conf_t *conf ,
                                              ngx_http_fastcgi_params_t *params ,
                                              ngx_keyval_t *default_params ) 
{ 
  u_char *p ;
  size_t___0 size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_uint_t nsrc ;
  ngx_array_t headers_names ;
  ngx_array_t params_merged ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_upstream_param_t *src ;
  ngx_http_upstream_param_t *s ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;

  {
#line 3189
  if (params->hash.buckets) {
#line 3190
    return ((ngx_int_t )0);
  }
#line 3193
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 3193
    if ((unsigned long )default_params == (unsigned long )((void *)0)) {
#line 3194
      params->hash.buckets = (ngx_hash_elt_t **)((void *)1);
#line 3195
      return ((ngx_int_t )0);
    }
  }
  {
#line 3198
  params->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t___0 )1);
  }
#line 3199
  if ((unsigned long )params->lengths == (unsigned long )((void *)0)) {
#line 3200
    return ((ngx_int_t )-1);
  }
  {
#line 3203
  params->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t___0 )1);
  }
#line 3204
  if ((unsigned long )params->values == (unsigned long )((void *)0)) {
#line 3205
    return ((ngx_int_t )-1);
  }
  {
#line 3208
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 3208
  if (tmp != 0L) {
#line 3211
    return ((ngx_int_t )-1);
  }
#line 3214
  if (conf->params_source) {
#line 3215
    src = (ngx_http_upstream_param_t *)(conf->params_source)->elts;
#line 3216
    nsrc = (conf->params_source)->nelts;
  } else {
#line 3219
    src = (ngx_http_upstream_param_t *)((void *)0);
#line 3220
    nsrc = (ngx_uint_t )0;
  }
#line 3223
  if (default_params) {
    {
#line 3224
    tmp___0 = ngx_array_init(& params_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 3224
    if (tmp___0 != 0L) {
#line 3228
      return ((ngx_int_t )-1);
    }
#line 3231
    i = (ngx_uint_t )0;
    {
#line 3231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3231
      if (! (i < nsrc)) {
#line 3231
        goto while_break;
      }
      {
#line 3233
      tmp___1 = ngx_array_push(& params_merged);
#line 3233
      s = (ngx_http_upstream_param_t *)tmp___1;
      }
#line 3234
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3235
        return ((ngx_int_t )-1);
      }
#line 3238
      *s = *(src + i);
#line 3231
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3241
    h = default_params;
    {
#line 3243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3243
      if (! h->key.len) {
#line 3243
        goto while_break___0;
      }
#line 3245
      src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 3246
      nsrc = params_merged.nelts;
#line 3248
      i = (ngx_uint_t )0;
      {
#line 3248
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3248
        if (! (i < nsrc)) {
#line 3248
          goto while_break___1;
        }
        {
#line 3249
        tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
        }
#line 3249
        if (tmp___2 == 0L) {
#line 3250
          goto next;
        }
#line 3248
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 3254
      tmp___3 = ngx_array_push(& params_merged);
#line 3254
      s = (ngx_http_upstream_param_t *)tmp___3;
      }
#line 3255
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3256
        return ((ngx_int_t )-1);
      }
#line 3259
      s->key = h->key;
#line 3260
      s->value = h->value;
#line 3261
      s->skip_empty = (ngx_uint_t )1;
      next: 
#line 3265
      h ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3268
    src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 3269
    nsrc = params_merged.nelts;
  }
#line 3272
  i = (ngx_uint_t )0;
  {
#line 3272
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3272
    if (! (i < nsrc)) {
#line 3272
      goto while_break___2;
    }
#line 3274
    if ((src + i)->key.len > sizeof("HTTP_") - 1UL) {
      {
#line 3274
      tmp___5 = strncmp((char const   *)(src + i)->key.data, "HTTP_", sizeof("HTTP_") - 1UL);
      }
#line 3274
      if (tmp___5 == 0) {
        {
#line 3277
        tmp___4 = ngx_array_push(& headers_names);
#line 3277
        hk = (ngx_hash_key_t *)tmp___4;
        }
#line 3278
        if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 3279
          return ((ngx_int_t )-1);
        }
        {
#line 3282
        hk->key.len = (src + i)->key.len - 5UL;
#line 3283
        hk->key.data = (src + i)->key.data + 5;
#line 3284
        hk->key_hash = ngx_hash_key_lc(hk->key.data, hk->key.len);
#line 3285
        hk->value = (void *)1;
        }
#line 3287
        if ((src + i)->value.len == 0UL) {
#line 3288
          goto __Cont;
        }
      }
    }
    {
#line 3292
    tmp___6 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3292
    copy = (ngx_http_script_copy_code_t *)tmp___6;
    }
#line 3294
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3295
      return ((ngx_int_t )-1);
    }
    {
#line 3298
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3299
    copy->len = (src + i)->key.len;
#line 3301
    tmp___7 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3301
    copy = (ngx_http_script_copy_code_t *)tmp___7;
    }
#line 3303
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3304
      return ((ngx_int_t )-1);
    }
    {
#line 3307
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3308
    copy->len = (src + i)->skip_empty;
#line 3311
    size = (((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 3315
    tmp___8 = ngx_array_push_n(params->values, size);
#line 3315
    copy = (ngx_http_script_copy_code_t *)tmp___8;
    }
#line 3316
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3317
      return ((ngx_int_t )-1);
    }
    {
#line 3320
    copy->code = & ngx_http_script_copy_code;
#line 3321
    copy->len = (src + i)->key.len;
#line 3323
    p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 3324
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->key.data,
           (src + i)->key.len);
#line 3327
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3329
    sc.cf = cf;
#line 3330
    sc.source = & (src + i)->value;
#line 3331
    sc.flushes = & params->flushes;
#line 3332
    sc.lengths = & params->lengths;
#line 3333
    sc.values = & params->values;
#line 3335
    tmp___9 = ngx_http_script_compile(& sc);
    }
#line 3335
    if (tmp___9 != 0L) {
#line 3336
      return ((ngx_int_t )-1);
    }
    {
#line 3339
    tmp___10 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 3339
    code = (uintptr_t *)tmp___10;
    }
#line 3340
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3341
      return ((ngx_int_t )-1);
    }
    {
#line 3344
    *code = (uintptr_t )((void *)0);
#line 3347
    tmp___11 = ngx_array_push_n(params->values, sizeof(uintptr_t ));
#line 3347
    code = (uintptr_t *)tmp___11;
    }
#line 3348
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3349
      return ((ngx_int_t )-1);
    }
#line 3352
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 3272
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 3355
  tmp___12 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 3355
  code = (uintptr_t *)tmp___12;
  }
#line 3356
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3357
    return ((ngx_int_t )-1);
  }
  {
#line 3360
  *code = (uintptr_t )((void *)0);
#line 3362
  params->number = headers_names.nelts;
#line 3364
  hash.hash = & params->hash;
#line 3365
  hash.key = & ngx_hash_key_lc;
#line 3366
  hash.max_size = (ngx_uint_t )512;
#line 3367
  hash.bucket_size = (ngx_uint_t )64;
#line 3368
  hash.name = (char *)"fastcgi_params_hash";
#line 3369
  hash.pool = cf->pool;
#line 3370
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3372
  tmp___13 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 3372
  return (tmp___13);
}
}
#line 3376 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_script_name_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 3384
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 3386
  f = ngx_http_fastcgi_split(r, flcf);
  }
#line 3388
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 3389
    return ((ngx_int_t )-1);
  }
#line 3392
  if (f->script_name.len == 0UL) {
#line 3392
    goto _L;
  } else
#line 3392
  if ((int )*(f->script_name.data + (f->script_name.len - 1UL)) != 47) {
    _L: /* CIL Label */ 
#line 3395
    v->len = (unsigned int )f->script_name.len;
#line 3396
    v->valid = 1U;
#line 3397
    v->no_cacheable = 0U;
#line 3398
    v->not_found = 0U;
#line 3399
    v->data = f->script_name.data;
#line 3401
    return ((ngx_int_t )0);
  }
  {
#line 3404
  v->len = (unsigned int )(f->script_name.len + flcf->index.len);
#line 3406
  tmp = ngx_pnalloc(r->pool, (size_t___0 )v->len);
#line 3406
  v->data = (u_char *)tmp;
  }
#line 3407
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 3408
    return ((ngx_int_t )-1);
  }
  {
#line 3411
  tmp___0 = memcpy((void */* __restrict  */)v->data, (void const   */* __restrict  */)f->script_name.data,
                   f->script_name.len);
#line 3411
  p = (u_char *)tmp___0 + f->script_name.len;
#line 3412
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)flcf->index.data,
         flcf->index.len);
  }
#line 3414
  return ((ngx_int_t )0);
}
}
#line 3418 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_path_info_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;

  {
  {
#line 3425
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 3427
  f = ngx_http_fastcgi_split(r, flcf);
  }
#line 3429
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 3430
    return ((ngx_int_t )-1);
  }
#line 3433
  v->len = (unsigned int )f->path_info.len;
#line 3434
  v->valid = 1U;
#line 3435
  v->no_cacheable = 0U;
#line 3436
  v->not_found = 0U;
#line 3437
  v->data = f->path_info.data;
#line 3439
  return ((ngx_int_t )0);
}
}
#line 3443 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_fastcgi_ctx_t *ngx_http_fastcgi_split(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) 
{ 
  ngx_http_fastcgi_ctx_t *f ;
  ngx_int_t n ;
  int captures[9] ;
  void *tmp ;
  int tmp___0 ;

  {
#line 3451
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 3453
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 3454
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_fastcgi_ctx_t ));
#line 3454
    f = (ngx_http_fastcgi_ctx_t *)tmp;
    }
#line 3455
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 3456
      return ((ngx_http_fastcgi_ctx_t *)((void *)0));
    }
#line 3459
    *(r->ctx + ngx_http_fastcgi_module.ctx_index) = (void *)f;
  }
#line 3462
  if (f->script_name.len) {
#line 3463
    return (f);
  }
#line 3466
  if ((unsigned long )flcf->split_regex == (unsigned long )((void *)0)) {
#line 3467
    f->script_name = r->uri;
#line 3468
    return (f);
  }
  {
#line 3471
  tmp___0 = pcre_exec((pcre const   *)(flcf->split_regex)->code, (pcre_extra const   *)(flcf->split_regex)->extra,
                      (char const   *)r->uri.data, (int )r->uri.len, 0, 0, captures,
                      9);
#line 3471
  n = (ngx_int_t )tmp___0;
  }
#line 3473
  if (n >= 0L) {
#line 3474
    f->script_name.len = (size_t___0 )(captures[3] - captures[2]);
#line 3475
    f->script_name.data = r->uri.data + captures[2];
#line 3477
    f->path_info.len = (size_t___0 )(captures[5] - captures[4]);
#line 3478
    f->path_info.data = r->uri.data + captures[4];
#line 3480
    return (f);
  }
#line 3483
  if (n == -1L) {
#line 3484
    f->script_name = r->uri;
#line 3485
    return (f);
  }
#line 3488
  if (((r->connection)->log)->log_level >= 2UL) {
    {
#line 3488
    ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "pcre_exec() failed: %i on \"%V\" using \"%V\"",
                       n, & r->uri, & flcf->split_name);
    }
  }
#line 3491
  return ((ngx_http_fastcgi_ctx_t *)((void *)0));
}
}
#line 3514 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_url_t u ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;

  {
#line 3517
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3525
  if (flcf->upstream.upstream) {
#line 3526
    return ((char *)"is duplicate");
  } else
#line 3525
  if (flcf->fastcgi_lengths) {
#line 3526
    return ((char *)"is duplicate");
  }
#line 3529
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3531
  clcf->handler = & ngx_http_fastcgi_handler;
#line 3533
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 3534
    clcf->auto_redirect = 1U;
  }
  {
#line 3537
  value = (ngx_str_t *)(cf->args)->elts;
#line 3539
  url = value + 1;
#line 3541
  n = ngx_http_script_variables_count(url);
  }
#line 3543
  if (n) {
    {
#line 3545
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3547
    sc.cf = cf;
#line 3548
    sc.source = url;
#line 3549
    sc.lengths = & flcf->fastcgi_lengths;
#line 3550
    sc.values = & flcf->fastcgi_values;
#line 3551
    sc.variables = n;
#line 3552
    sc.complete_lengths = 1U;
#line 3553
    sc.complete_values = 1U;
#line 3555
    tmp = ngx_http_script_compile(& sc);
    }
#line 3555
    if (tmp != 0L) {
#line 3556
      return ((char *)((void *)-1));
    }
#line 3559
    return ((char *)((void *)0));
  }
  {
#line 3562
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 3564
  u.url = *(value + 1);
#line 3565
  u.no_resolve = 1U;
#line 3567
  flcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 3568
  if ((unsigned long )flcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3569
    return ((char *)((void *)-1));
  }
#line 3572
  return ((char *)((void *)0));
}
}
#line 3576 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_split_path_info(ngx_conf_t *cf , ngx_command_t *cmd ,
                                              void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  ngx_int_t tmp ;

  {
  {
#line 3580
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3586
  value = (ngx_str_t *)(cf->args)->elts;
#line 3588
  flcf->split_name = *(value + 1);
#line 3590
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 3592
  rc.pattern = *(value + 1);
#line 3593
  rc.pool = cf->pool;
#line 3594
  rc.err.len = (size_t___0 )1024;
#line 3595
  rc.err.data = errstr;
#line 3597
  tmp = ngx_regex_compile(& rc);
  }
#line 3597
  if (tmp != 0L) {
    {
#line 3598
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc.err);
    }
#line 3599
    return ((char *)((void *)-1));
  }
#line 3602
  if (rc.captures != 2) {
    {
#line 3603
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "pattern \"%V\" must have 2 captures",
                       value + 1);
    }
#line 3605
    return ((char *)((void *)-1));
  }
#line 3608
  flcf->split_regex = rc.regex;
#line 3610
  return ((char *)((void *)0));
}
}
#line 3622 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 3625
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3630
  if (flcf->upstream.store != -1) {
#line 3631
    return ((char *)"is duplicate");
  }
  {
#line 3634
  value = (ngx_str_t *)(cf->args)->elts;
#line 3636
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 3636
  if (tmp == 0) {
#line 3637
    flcf->upstream.store = 0;
#line 3638
    return ((char *)((void *)0));
  }
#line 3642
  if (flcf->upstream.cache > 0) {
#line 3643
    return ((char *)"is incompatible with \"fastcgi_cache\"");
  }
  {
#line 3647
  flcf->upstream.store = 1;
#line 3649
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 3649
  if (tmp___0 == 0) {
#line 3650
    return ((char *)((void *)0));
  }
  {
#line 3654
  ((value + 1)->len) ++;
#line 3656
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3658
  sc.cf = cf;
#line 3659
  sc.source = value + 1;
#line 3660
  sc.lengths = & flcf->upstream.store_lengths;
#line 3661
  sc.values = & flcf->upstream.store_values;
#line 3662
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 3663
  sc.complete_lengths = 1U;
#line 3664
  sc.complete_values = 1U;
#line 3666
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 3666
  if (tmp___1 != 0L) {
#line 3667
    return ((char *)((void *)-1));
  }
#line 3670
  return ((char *)((void *)0));
}
}
#line 3676 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
#line 3679
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3685
  value = (ngx_str_t *)(cf->args)->elts;
#line 3687
  if (flcf->upstream.cache != -1) {
#line 3688
    return ((char *)"is duplicate");
  }
  {
#line 3691
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 3691
  if (tmp == 0) {
#line 3692
    flcf->upstream.cache = 0;
#line 3693
    return ((char *)((void *)0));
  }
#line 3696
  if (flcf->upstream.store > 0) {
#line 3697
    return ((char *)"is incompatible with \"fastcgi_store\"");
  }
  {
#line 3700
  flcf->upstream.cache = 1;
#line 3702
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3704
  ccv.cf = cf;
#line 3705
  ccv.value = value + 1;
#line 3706
  ccv.complex_value = & cv;
#line 3708
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 3708
  if (tmp___0 != 0L) {
#line 3709
    return ((char *)((void *)-1));
  }
#line 3712
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 3714
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 3714
    flcf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 3716
    if ((unsigned long )flcf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 3717
      return ((char *)((void *)-1));
    }
#line 3720
    *(flcf->upstream.cache_value) = cv;
#line 3722
    return ((char *)((void *)0));
  }
  {
#line 3725
  flcf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t___0 )0,
                                                    (void *)(& ngx_http_fastcgi_module));
  }
#line 3727
  if ((unsigned long )flcf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 3728
    return ((char *)((void *)-1));
  }
#line 3731
  return ((char *)((void *)0));
}
}
#line 3735 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;

  {
#line 3738
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3743
  value = (ngx_str_t *)(cf->args)->elts;
#line 3745
  if (flcf->cache_key.value.data) {
#line 3746
    return ((char *)"is duplicate");
  }
  {
#line 3749
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3751
  ccv.cf = cf;
#line 3752
  ccv.value = value + 1;
#line 3753
  ccv.complex_value = & flcf->cache_key;
#line 3755
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 3755
  if (tmp != 0L) {
#line 3756
    return ((char *)((void *)-1));
  }
#line 3759
  return ((char *)((void *)0));
}
}
#line 3765 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_lowat_check(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ssize_t *np ;

  {
  {
#line 3781
  np = (ssize_t *)data;
#line 3783
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"fastcgi_send_lowat\" is not supported, ignored");
#line 3786
  *np = (ssize_t )0;
  }
#line 3790
  return ((char *)((void *)0));
}
}
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 163 "src/core/ngx_string.h"
u_char *ngx_strcasestrn(u_char *s1 , char *s2 , size_t___0 n ) ;
#line 166
ngx_int_t ngx_rstrncmp(u_char *s1 , u_char *s2 , size_t___0 n ) ;
#line 167
ngx_int_t ngx_rstrncasecmp(u_char *s1 , u_char *s2 , size_t___0 n ) ;
#line 284 "src/core/ngx_conf_file.h"
char *ngx_conf_set_keyval_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 291
char *ngx_conf_set_enum_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 85 "src/http/ngx_http_variables.h"
ngx_http_regex_t *ngx_http_regex_compile(ngx_conf_t *cf , ngx_regex_compile_t *rc ) ;
#line 87
ngx_int_t ngx_http_regex_exec(ngx_http_request_t *r , ngx_http_regex_t *re , ngx_str_t *s ) ;
#line 211 "src/http/ngx_http_script.h"
char *ngx_http_set_complex_value_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 110 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_chunked(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_chunked_t *ctx ) ;
#line 122 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_eval(ngx_http_request_t *r , ngx_http_proxy_ctx_t *ctx ,
                                     ngx_http_proxy_loc_conf_t *plcf ) ;
#line 125
static ngx_int_t ngx_http_proxy_create_key(ngx_http_request_t *r ) ;
#line 127
static ngx_int_t ngx_http_proxy_create_request(ngx_http_request_t *r ) ;
#line 128
static ngx_int_t ngx_http_proxy_reinit_request(ngx_http_request_t *r ) ;
#line 129
static ngx_int_t ngx_http_proxy_body_output_filter(void *data , ngx_chain_t *in ) ;
#line 130
static ngx_int_t ngx_http_proxy_process_status_line(ngx_http_request_t *r ) ;
#line 131
static ngx_int_t ngx_http_proxy_process_header(ngx_http_request_t *r ) ;
#line 132
static ngx_int_t ngx_http_proxy_input_filter_init(void *data ) ;
#line 133
static ngx_int_t ngx_http_proxy_copy_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 135
static ngx_int_t ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 137
static ngx_int_t ngx_http_proxy_non_buffered_copy_filter(void *data , ssize_t bytes ) ;
#line 139
static ngx_int_t ngx_http_proxy_non_buffered_chunked_filter(void *data , ssize_t bytes ) ;
#line 141
static void ngx_http_proxy_abort_request(ngx_http_request_t *r ) ;
#line 142
static void ngx_http_proxy_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 145
static ngx_int_t ngx_http_proxy_host_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 147
static ngx_int_t ngx_http_proxy_port_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 149
static ngx_int_t ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r ,
                                                             ngx_http_variable_value_t *v ,
                                                             uintptr_t data ) ;
#line 152
static ngx_int_t ngx_http_proxy_internal_body_length_variable(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ) ;
#line 155
static ngx_int_t ngx_http_proxy_internal_chunked_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) ;
#line 157
static ngx_int_t ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                 size_t___0 prefix ) ;
#line 159
static ngx_int_t ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ) ;
#line 161
static ngx_int_t ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     u_char *value , ngx_array_t *rewrites ) ;
#line 163
static ngx_int_t ngx_http_proxy_rewrite(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                        size_t___0 prefix , size_t___0 len , ngx_str_t *replacement ) ;
#line 166
static ngx_int_t ngx_http_proxy_add_variables(ngx_conf_t *cf ) ;
#line 167
static void *ngx_http_proxy_create_main_conf(ngx_conf_t *cf ) ;
#line 168
static void *ngx_http_proxy_create_loc_conf(ngx_conf_t *cf ) ;
#line 169
static char *ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 171
static ngx_int_t ngx_http_proxy_init_headers(ngx_conf_t *cf , ngx_http_proxy_loc_conf_t *conf ,
                                             ngx_http_proxy_headers_t *headers , ngx_keyval_t *default_headers ) ;
#line 175
static char *ngx_http_proxy_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 177
static char *ngx_http_proxy_redirect(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 179
static char *ngx_http_proxy_cookie_domain(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 181
static char *ngx_http_proxy_cookie_path(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 183
static char *ngx_http_proxy_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 186
static char *ngx_http_proxy_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 188
static char *ngx_http_proxy_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 196
static char *ngx_http_proxy_lowat_check(ngx_conf_t *cf , void *post , void *data ) ;
#line 198
static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf , ngx_http_proxy_rewrite_t *pr ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) ;
#line 205
static void ngx_http_proxy_set_vars(ngx_url_t *u , ngx_http_proxy_vars_t *v ) ;
#line 208 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_conf_post_t ngx_http_proxy_lowat_post  =    {& ngx_http_proxy_lowat_check};
#line 212 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_conf_bitmask_t ngx_http_proxy_next_upstream_masks[14]  = 
#line 212
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_502") - 1UL, (u_char *)"http_502"}, (ngx_uint_t )32}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_504") - 1UL, (u_char *)"http_504"}, (ngx_uint_t )128}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 245 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_conf_enum_t ngx_http_proxy_http_version[3]  = {      {{sizeof("1.0") - 1UL, (u_char *)"1.0"}, (ngx_uint_t )1000}, 
        {{sizeof("1.1") - 1UL, (u_char *)"1.1"}, (ngx_uint_t )1001}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 255 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_command_t ngx_http_proxy_commands[54]  = 
#line 255
  {      {{sizeof("proxy_pass") - 1UL, (u_char *)"proxy_pass"}, (ngx_uint_t )3355443202U,
      & ngx_http_proxy_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_redirect") - 1UL, (u_char *)"proxy_redirect"}, (ngx_uint_t )234881030,
      & ngx_http_proxy_redirect, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cookie_domain") - 1UL, (u_char *)"proxy_cookie_domain"}, (ngx_uint_t )234881030,
      & ngx_http_proxy_cookie_domain, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cookie_path") - 1UL, (u_char *)"proxy_cookie_path"}, (ngx_uint_t )234881030,
      & ngx_http_proxy_cookie_path, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_store") - 1UL, (u_char *)"proxy_store"}, (ngx_uint_t )234881026,
      & ngx_http_proxy_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_store_access") - 1UL, (u_char *)"proxy_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("proxy_buffering") - 1UL, (u_char *)"proxy_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.buffering), (void *)0}, 
        {{sizeof("proxy_request_buffering") - 1UL,
       (u_char *)"proxy_request_buffering"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("proxy_ignore_client_abort") - 1UL, (u_char *)"proxy_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("proxy_bind") - 1UL, (u_char *)"proxy_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("proxy_connect_timeout") - 1UL,
       (u_char *)"proxy_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("proxy_send_timeout") - 1UL, (u_char *)"proxy_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("proxy_send_lowat") - 1UL, (u_char *)"proxy_send_lowat"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.send_lowat), (void *)(& ngx_http_proxy_lowat_post)}, 
        {{sizeof("proxy_intercept_errors") - 1UL,
       (u_char *)"proxy_intercept_errors"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("proxy_set_header") - 1UL, (u_char *)"proxy_set_header"}, (ngx_uint_t )234881028,
      & ngx_conf_set_keyval_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->headers_source), (void *)0}, 
        {{sizeof("proxy_headers_hash_max_size") - 1UL,
       (u_char *)"proxy_headers_hash_max_size"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->headers_hash_max_size),
      (void *)0}, 
        {{sizeof("proxy_headers_hash_bucket_size") - 1UL, (u_char *)"proxy_headers_hash_bucket_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->headers_hash_bucket_size),
      (void *)0}, 
        {{sizeof("proxy_set_body") - 1UL, (u_char *)"proxy_set_body"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->body_source), (void *)0}, 
        {{sizeof("proxy_method") - 1UL,
       (u_char *)"proxy_method"}, (ngx_uint_t )234881026, & ngx_http_set_complex_value_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->method),
      (void *)0}, 
        {{sizeof("proxy_pass_request_headers") - 1UL, (u_char *)"proxy_pass_request_headers"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("proxy_pass_request_body") - 1UL, (u_char *)"proxy_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("proxy_buffer_size") - 1UL, (u_char *)"proxy_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("proxy_read_timeout") - 1UL, (u_char *)"proxy_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("proxy_buffers") - 1UL, (u_char *)"proxy_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("proxy_busy_buffers_size") - 1UL,
       (u_char *)"proxy_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("proxy_force_ranges") - 1UL, (u_char *)"proxy_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("proxy_limit_rate") - 1UL, (u_char *)"proxy_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.limit_rate), (void *)0}, 
        {{sizeof("proxy_cache") - 1UL,
       (u_char *)"proxy_cache"}, (ngx_uint_t )234881026, & ngx_http_proxy_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cache_key") - 1UL, (u_char *)"proxy_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_proxy_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cache_path") - 1UL, (u_char *)"proxy_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_proxy_main_conf_t *)0)->caches), (void *)(& ngx_http_proxy_module)}, 
        {{sizeof("proxy_cache_bypass") - 1UL,
       (u_char *)"proxy_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("proxy_no_cache") - 1UL, (u_char *)"proxy_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("proxy_cache_valid") - 1UL,
       (u_char *)"proxy_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("proxy_cache_min_uses") - 1UL, (u_char *)"proxy_cache_min_uses"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("proxy_cache_max_range_offset") - 1UL, (u_char *)"proxy_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("proxy_cache_use_stale") - 1UL, (u_char *)"proxy_cache_use_stale"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_proxy_next_upstream_masks)}, 
        {{sizeof("proxy_cache_methods") - 1UL, (u_char *)"proxy_cache_methods"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("proxy_cache_lock") - 1UL, (u_char *)"proxy_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_lock), (void *)0}, 
        {{sizeof("proxy_cache_lock_timeout") - 1UL,
       (u_char *)"proxy_cache_lock_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("proxy_cache_lock_age") - 1UL, (u_char *)"proxy_cache_lock_age"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("proxy_cache_revalidate") - 1UL, (u_char *)"proxy_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("proxy_cache_convert_head") - 1UL, (u_char *)"proxy_cache_convert_head"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_convert_head),
      (void *)0}, 
        {{sizeof("proxy_cache_background_update") - 1UL, (u_char *)"proxy_cache_background_update"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("proxy_temp_path") - 1UL, (u_char *)"proxy_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.temp_path), (void *)0}, 
        {{sizeof("proxy_max_temp_file_size") - 1UL,
       (u_char *)"proxy_max_temp_file_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("proxy_temp_file_write_size") - 1UL, (u_char *)"proxy_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("proxy_next_upstream") - 1UL, (u_char *)"proxy_next_upstream"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_proxy_next_upstream_masks)}, 
        {{sizeof("proxy_next_upstream_tries") - 1UL, (u_char *)"proxy_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("proxy_next_upstream_timeout") - 1UL, (u_char *)"proxy_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("proxy_pass_header") - 1UL, (u_char *)"proxy_pass_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("proxy_hide_header") - 1UL, (u_char *)"proxy_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("proxy_ignore_headers") - 1UL, (u_char *)"proxy_ignore_headers"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{sizeof("proxy_http_version") - 1UL, (u_char *)"proxy_http_version"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->http_version), (void *)(& ngx_http_proxy_http_version)}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 724 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_http_module_t ngx_http_proxy_module_ctx  = 
#line 724
     {& ngx_http_proxy_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_proxy_create_main_conf,
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_proxy_create_loc_conf,
    & ngx_http_proxy_merge_loc_conf};
#line 739 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
ngx_module_t ngx_http_proxy_module  = 
#line 739
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_proxy_module_ctx),
    ngx_http_proxy_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 755 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char ngx_http_proxy_version[12]  = 
#line 755
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'0',      (char )'\r',      (char )'\n',      (char )'\000'};
#line 756 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char ngx_http_proxy_version_11[12]  = 
#line 756
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'1',      (char )'\r',      (char )'\n',      (char )'\000'};
#line 759 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_keyval_t ngx_http_proxy_headers[9]  = 
#line 759
  {      {{sizeof("Host") - 1UL, (u_char *)"Host"}, {sizeof("$proxy_host") - 1UL, (u_char *)"$proxy_host"}}, 
        {{sizeof("Connection") - 1UL,
       (u_char *)"Connection"}, {sizeof("close") - 1UL, (u_char *)"close"}}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, {sizeof("$proxy_internal_body_length") - 1UL,
                                                                     (u_char *)"$proxy_internal_body_length"}}, 
        {{sizeof("Transfer-Encoding") - 1UL,
       (u_char *)"Transfer-Encoding"}, {sizeof("$proxy_internal_chunked") - 1UL, (u_char *)"$proxy_internal_chunked"}}, 
        {{sizeof("TE") - 1UL,
       (u_char *)"TE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Keep-Alive") - 1UL, (u_char *)"Keep-Alive"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Expect") - 1UL,
       (u_char *)"Expect"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Upgrade") - 1UL, (u_char *)"Upgrade"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, {(size_t___0 )0, (u_char *)((void *)0)}}};
#line 772 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_str_t ngx_http_proxy_hide_headers[9]  = 
#line 772
  {      {sizeof("Date") - 1UL, (u_char *)"Date"}, 
        {sizeof("Server") - 1UL, (u_char *)"Server"}, 
        {sizeof("X-Pad") - 1UL, (u_char *)"X-Pad"}, 
        {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}};
#line 787 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_keyval_t ngx_http_proxy_cache_headers[15]  = 
#line 787
  {      {{sizeof("Host") - 1UL, (u_char *)"Host"}, {sizeof("$proxy_host") - 1UL, (u_char *)"$proxy_host"}}, 
        {{sizeof("Connection") - 1UL,
       (u_char *)"Connection"}, {sizeof("close") - 1UL, (u_char *)"close"}}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, {sizeof("$proxy_internal_body_length") - 1UL,
                                                                     (u_char *)"$proxy_internal_body_length"}}, 
        {{sizeof("Transfer-Encoding") - 1UL,
       (u_char *)"Transfer-Encoding"}, {sizeof("$proxy_internal_chunked") - 1UL, (u_char *)"$proxy_internal_chunked"}}, 
        {{sizeof("TE") - 1UL,
       (u_char *)"TE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Keep-Alive") - 1UL, (u_char *)"Keep-Alive"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Expect") - 1UL,
       (u_char *)"Expect"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Upgrade") - 1UL, (u_char *)"Upgrade"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("If-Modified-Since") - 1UL,
       (u_char *)"If-Modified-Since"}, {sizeof("$upstream_cache_last_modified") - 1UL,
                                        (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("If-Unmodified-Since") - 1UL,
       (u_char *)"If-Unmodified-Since"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("If-None-Match") - 1UL, (u_char *)"If-None-Match"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                   (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("If-Match") - 1UL,
       (u_char *)"If-Match"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Range") - 1UL, (u_char *)"Range"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("If-Range") - 1UL,
       (u_char *)"If-Range"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, {(size_t___0 )0, (u_char *)((void *)0)}}};
#line 809 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_http_variable_t ngx_http_proxy_vars[6]  = {      {{sizeof("proxy_host") - 1UL, (u_char *)"proxy_host"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_proxy_host_variable, (uintptr_t )0, (ngx_uint_t )11, (ngx_uint_t )0}, 
        {{sizeof("proxy_port") - 1UL,
       (u_char *)"proxy_port"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_proxy_port_variable,
      (uintptr_t )0, (ngx_uint_t )11, (ngx_uint_t )0}, 
        {{sizeof("proxy_add_x_forwarded_for") - 1UL, (u_char *)"proxy_add_x_forwarded_for"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_proxy_add_x_forwarded_for_variable, (uintptr_t )0, (ngx_uint_t )8,
      (ngx_uint_t )0}, 
        {{sizeof("proxy_internal_body_length") - 1UL, (u_char *)"proxy_internal_body_length"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_proxy_internal_body_length_variable, (uintptr_t )0, (ngx_uint_t )10,
      (ngx_uint_t )0}, 
        {{sizeof("proxy_internal_chunked") - 1UL, (u_char *)"proxy_internal_chunked"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_proxy_internal_chunked_variable, (uintptr_t )0, (ngx_uint_t )10,
      (ngx_uint_t )0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                         uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 836 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_path_init_t ngx_http_proxy_temp_path  =    {{sizeof("proxy_temp") - 1UL, (u_char *)"proxy_temp"}, {(size_t___0 )1, (size_t___0 )2,
                                                           (size_t___0 )0}};
#line 841 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_http_proxy_main_conf_t *pmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 852
  tmp = ngx_http_upstream_create(r);
  }
#line 852
  if (tmp != 0L) {
#line 853
    return ((ngx_int_t )500);
  }
  {
#line 856
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_proxy_ctx_t ));
#line 856
  ctx = (ngx_http_proxy_ctx_t *)tmp___0;
  }
#line 857
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 858
    return ((ngx_int_t )500);
  }
#line 861
  *(r->ctx + ngx_http_proxy_module.ctx_index) = (void *)ctx;
#line 863
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 865
  u = r->upstream;
#line 867
  if ((unsigned long )plcf->proxy_lengths == (unsigned long )((void *)0)) {
#line 868
    ctx->vars = plcf->vars;
#line 869
    u->schema = plcf->vars.schema;
  } else {
    {
#line 875
    tmp___1 = ngx_http_proxy_eval(r, ctx, plcf);
    }
#line 875
    if (tmp___1 != 0L) {
#line 876
      return ((ngx_int_t )500);
    }
  }
#line 880
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_proxy_module);
#line 882
  u->conf = & plcf->upstream;
#line 885
  pmcf = (ngx_http_proxy_main_conf_t *)*(r->main_conf + ngx_http_proxy_module.ctx_index);
#line 887
  u->caches = & pmcf->caches;
#line 888
  u->create_key = & ngx_http_proxy_create_key;
#line 891
  u->create_request = & ngx_http_proxy_create_request;
#line 892
  u->reinit_request = & ngx_http_proxy_reinit_request;
#line 893
  u->process_header = & ngx_http_proxy_process_status_line;
#line 894
  u->abort_request = & ngx_http_proxy_abort_request;
#line 895
  u->finalize_request = & ngx_http_proxy_finalize_request;
#line 896
  r->state = (ngx_uint_t )0;
#line 898
  if (plcf->redirects) {
#line 899
    u->rewrite_redirect = & ngx_http_proxy_rewrite_redirect;
  }
#line 902
  if (plcf->cookie_domains) {
#line 903
    u->rewrite_cookie = & ngx_http_proxy_rewrite_cookie;
  } else
#line 902
  if (plcf->cookie_paths) {
#line 903
    u->rewrite_cookie = & ngx_http_proxy_rewrite_cookie;
  }
  {
#line 906
  u->buffering = (unsigned int )plcf->upstream.buffering;
#line 908
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 908
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 909
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 910
    return ((ngx_int_t )500);
  }
#line 913
  (u->pipe)->input_filter = & ngx_http_proxy_copy_filter;
#line 914
  (u->pipe)->input_ctx = (void *)r;
#line 916
  u->input_filter_init = & ngx_http_proxy_input_filter_init;
#line 917
  u->input_filter = & ngx_http_proxy_non_buffered_copy_filter;
#line 918
  u->input_filter_ctx = (void *)r;
#line 920
  u->accel = 1U;
#line 922
  if (! plcf->upstream.request_buffering) {
#line 922
    if ((unsigned long )plcf->body_values == (unsigned long )((void *)0)) {
#line 922
      if (plcf->upstream.pass_request_body) {
#line 922
        if (! r->headers_in.chunked) {
#line 927
          r->request_body_no_buffering = 1U;
        } else
#line 922
        if (plcf->http_version == 1001UL) {
#line 927
          r->request_body_no_buffering = 1U;
        }
      }
    }
  }
  {
#line 930
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 932
  if (rc >= 300L) {
#line 933
    return (rc);
  }
#line 936
  return ((ngx_int_t )-4);
}
}
#line 940 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_eval(ngx_http_request_t *r , ngx_http_proxy_ctx_t *ctx ,
                                     ngx_http_proxy_loc_conf_t *plcf ) 
{ 
  u_char *p ;
  size_t___0 add ;
  u_short port ;
  ngx_str_t proxy ;
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 951
  tmp = ngx_http_script_run(r, & proxy, (plcf->proxy_lengths)->elts, (size_t___0 )0,
                            (plcf->proxy_values)->elts);
  }
#line 951
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 955
    return ((ngx_int_t )-1);
  }
#line 958
  if (proxy.len > 7UL) {
    {
#line 958
    tmp___0 = ngx_strncasecmp(proxy.data, (u_char *)"http://", (size_t___0 )7);
    }
#line 958
    if (tmp___0 == 0L) {
#line 961
      add = (size_t___0 )7;
#line 962
      port = (u_short )80;
    } else {
#line 958
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 976
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 976
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid URL prefix in \"%V\"",
                         & proxy);
      }
    }
#line 978
    return ((ngx_int_t )-1);
  }
  {
#line 981
  u = r->upstream;
#line 983
  u->schema.len = add;
#line 984
  u->schema.data = proxy.data;
#line 986
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 988
  url.url.len = proxy.len - add;
#line 989
  url.url.data = proxy.data + add;
#line 990
  url.default_port = port;
#line 991
  url.uri_part = 1U;
#line 992
  url.no_resolve = 1U;
#line 994
  tmp___1 = ngx_parse_url(r->pool, & url);
  }
#line 994
  if (tmp___1 != 0L) {
#line 995
    if (url.err) {
#line 996
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 996
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 1000
    return ((ngx_int_t )-1);
  }
#line 1003
  if (url.uri.len) {
#line 1004
    if ((int )*(url.uri.data + 0) == 63) {
      {
#line 1005
      tmp___2 = ngx_pnalloc(r->pool, url.uri.len + 1UL);
#line 1005
      p = (u_char *)tmp___2;
      }
#line 1006
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1007
        return ((ngx_int_t )-1);
      }
      {
#line 1010
      tmp___3 = p;
#line 1010
      p ++;
#line 1010
      *tmp___3 = (u_char )'/';
#line 1011
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)url.uri.data,
             url.uri.len);
#line 1013
      (url.uri.len) ++;
#line 1014
      url.uri.data = p - 1;
      }
    }
  }
  {
#line 1018
  ctx->vars.key_start = u->schema;
#line 1020
  ngx_http_proxy_set_vars(& url, & ctx->vars);
#line 1022
  tmp___4 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 1022
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___4;
  }
#line 1023
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 1024
    return ((ngx_int_t )-1);
  }
#line 1027
  if (url.addrs) {
#line 1028
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 1029
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 1030
    (u->resolved)->name = (url.addrs + 0)->name;
#line 1031
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 1034
  (u->resolved)->host = url.host;
#line 1035
  if (url.no_port) {
#line 1035
    tmp___5 = (int )port;
  } else {
#line 1035
    tmp___5 = (int )url.port;
  }
#line 1035
  (u->resolved)->port = (in_port_t )tmp___5;
#line 1036
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 1038
  return ((ngx_int_t )0);
}
}
#line 1044 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_create_key(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  size_t___0 loc_len ;
  u_char *p ;
  uintptr_t escape___0 ;
  ngx_str_t *key ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_http_proxy_loc_conf_t *plcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  uintptr_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 1055
  u = r->upstream;
#line 1057
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 1059
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1061
  tmp = ngx_array_push(& (r->cache)->keys);
#line 1061
  key = (ngx_str_t *)tmp;
  }
#line 1062
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 1063
    return ((ngx_int_t )-1);
  }
#line 1066
  if (plcf->cache_key.value.data) {
    {
#line 1068
    tmp___0 = ngx_http_complex_value(r, & plcf->cache_key, key);
    }
#line 1068
    if (tmp___0 != 0L) {
#line 1069
      return ((ngx_int_t )-1);
    }
#line 1072
    return ((ngx_int_t )0);
  }
  {
#line 1075
  *key = ctx->vars.key_start;
#line 1077
  tmp___1 = ngx_array_push(& (r->cache)->keys);
#line 1077
  key = (ngx_str_t *)tmp___1;
  }
#line 1078
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 1079
    return ((ngx_int_t )-1);
  }
#line 1082
  if (plcf->proxy_lengths) {
#line 1082
    if (ctx->vars.uri.len) {
#line 1084
      *key = ctx->vars.uri;
#line 1085
      u->uri = ctx->vars.uri;
#line 1087
      return ((ngx_int_t )0);
    } else {
#line 1082
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1089
  if (ctx->vars.uri.len == 0UL) {
#line 1089
    if (r->valid_unparsed_uri) {
#line 1089
      if ((unsigned long )r == (unsigned long )r->main) {
#line 1091
        *key = r->unparsed_uri;
#line 1092
        u->uri = r->unparsed_uri;
#line 1094
        return ((ngx_int_t )0);
      }
    }
  }
#line 1097
  if (r->valid_location) {
#line 1097
    if (ctx->vars.uri.len) {
#line 1097
      loc_len = plcf->location.len;
    } else {
#line 1097
      loc_len = (size_t___0 )0;
    }
  } else {
#line 1097
    loc_len = (size_t___0 )0;
  }
#line 1099
  if (r->quoted_uri) {
    {
#line 1100
    tmp___2 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                             (ngx_uint_t )0);
#line 1100
    escape___0 = 2UL * tmp___2;
    }
  } else
#line 1099
  if (r->internal) {
    {
#line 1100
    tmp___2 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                             (ngx_uint_t )0);
#line 1100
    escape___0 = 2UL * tmp___2;
    }
  } else {
#line 1103
    escape___0 = (uintptr_t )0;
  }
  {
#line 1106
  len = (((((ctx->vars.uri.len + r->uri.len) - loc_len) + escape___0) + sizeof("?")) - 1UL) + r->args.len;
#line 1109
  tmp___3 = ngx_pnalloc(r->pool, len);
#line 1109
  p = (u_char *)tmp___3;
  }
#line 1110
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1111
    return ((ngx_int_t )-1);
  }
#line 1114
  key->data = p;
#line 1116
  if (r->valid_location) {
    {
#line 1117
    tmp___4 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ctx->vars.uri.data,
                     ctx->vars.uri.len);
#line 1117
    p = (u_char *)tmp___4 + ctx->vars.uri.len;
    }
  }
#line 1120
  if (escape___0) {
    {
#line 1121
    ngx_escape_uri(p, r->uri.data + loc_len, r->uri.len - loc_len, (ngx_uint_t )0);
#line 1123
    p += (r->uri.len - loc_len) + escape___0;
    }
  } else {
    {
#line 1126
    tmp___5 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(r->uri.data + loc_len),
                     r->uri.len - loc_len);
#line 1126
    p = (u_char *)tmp___5 + (r->uri.len - loc_len);
    }
  }
#line 1129
  if (r->args.len > 0UL) {
    {
#line 1130
    tmp___6 = p;
#line 1130
    p ++;
#line 1130
    *tmp___6 = (u_char )'?';
#line 1131
    tmp___7 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)r->args.data,
                     r->args.len);
#line 1131
    p = (u_char *)tmp___7 + r->args.len;
    }
  }
#line 1134
  key->len = (size_t___0 )(p - key->data);
#line 1135
  u->uri = *key;
#line 1137
  return ((ngx_int_t )0);
}
}
#line 1143 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_create_request(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  size_t___0 uri_len ;
  size_t___0 loc_len ;
  size_t___0 body_len ;
  uintptr_t escape___0 ;
  ngx_buf_t *b ;
  ngx_str_t method ;
  ngx_uint_t i ;
  ngx_uint_t unparsed_uri ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_proxy_headers_t *headers ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_proxy_loc_conf_t *plcf ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  uintptr_t tmp___1 ;
  size_t___0 tmp___2 ;
  size_t___0 tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  u_char *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  size_t___0 tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  void *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  u_char *tmp___23 ;
  u_char *tmp___24 ;
  void *tmp___25 ;

  {
#line 1162
  u = r->upstream;
#line 1164
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 1167
  if (u->cacheable) {
#line 1167
    headers = & plcf->headers_cache;
  } else {
#line 1167
    headers = & plcf->headers;
  }
#line 1172
  if (u->method.len) {
#line 1174
    method = u->method;
  } else
#line 1176
  if (plcf->method) {
    {
#line 1177
    tmp = ngx_http_complex_value(r, plcf->method, & method);
    }
#line 1177
    if (tmp != 0L) {
#line 1178
      return ((ngx_int_t )-1);
    }
  } else {
#line 1182
    method = r->method_name;
  }
#line 1185
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1187
  if (method.len == 4UL) {
    {
#line 1187
    tmp___0 = ngx_strncasecmp(method.data, (u_char *)"HEAD", (size_t___0 )4);
    }
#line 1187
    if (tmp___0 == 0L) {
#line 1190
      ctx->head = 1U;
    }
  }
#line 1193
  len = ((((method.len + 1UL) + sizeof(ngx_http_proxy_version)) - 1UL) + sizeof("\r\n")) - 1UL;
#line 1196
  escape___0 = (uintptr_t )0;
#line 1197
  loc_len = (size_t___0 )0;
#line 1198
  unparsed_uri = (ngx_uint_t )0;
#line 1200
  if (plcf->proxy_lengths) {
#line 1200
    if (ctx->vars.uri.len) {
#line 1201
      uri_len = ctx->vars.uri.len;
    } else {
#line 1200
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1203
  if (ctx->vars.uri.len == 0UL) {
#line 1203
    if (r->valid_unparsed_uri) {
#line 1203
      if ((unsigned long )r == (unsigned long )r->main) {
#line 1205
        unparsed_uri = (ngx_uint_t )1;
#line 1206
        uri_len = r->unparsed_uri.len;
      } else {
#line 1203
        goto _L___0;
      }
    } else {
#line 1203
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1209
    if (r->valid_location) {
#line 1209
      if (ctx->vars.uri.len) {
#line 1209
        loc_len = plcf->location.len;
      } else {
#line 1209
        loc_len = (size_t___0 )0;
      }
    } else {
#line 1209
      loc_len = (size_t___0 )0;
    }
#line 1212
    if (r->quoted_uri) {
      {
#line 1213
      tmp___1 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                               (ngx_uint_t )0);
#line 1213
      escape___0 = 2UL * tmp___1;
      }
    } else
#line 1212
    if (r->space_in_uri) {
      {
#line 1213
      tmp___1 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                               (ngx_uint_t )0);
#line 1213
      escape___0 = 2UL * tmp___1;
      }
    } else
#line 1212
    if (r->internal) {
      {
#line 1213
      tmp___1 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                               (ngx_uint_t )0);
#line 1213
      escape___0 = 2UL * tmp___1;
      }
    }
#line 1217
    uri_len = (((((ctx->vars.uri.len + r->uri.len) - loc_len) + escape___0) + sizeof("?")) - 1UL) + r->args.len;
  }
#line 1221
  if (uri_len == 0UL) {
#line 1222
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1222
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "zero length URI to proxy");
      }
    }
#line 1224
    return ((ngx_int_t )-1);
  }
  {
#line 1227
  len += uri_len;
#line 1229
  memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 1231
  ngx_http_script_flush_no_cacheable_variables(r, plcf->body_flushes);
#line 1232
  ngx_http_script_flush_no_cacheable_variables(r, headers->flushes);
  }
#line 1234
  if (plcf->body_lengths) {
#line 1235
    le.ip = (u_char *)(plcf->body_lengths)->elts;
#line 1236
    le.request = r;
#line 1237
    le.flushed = 1U;
#line 1238
    body_len = (size_t___0 )0;
    {
#line 1240
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1240
      if (! *((uintptr_t *)le.ip)) {
#line 1240
        goto while_break;
      }
      {
#line 1241
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1242
      tmp___2 = (*lcode)(& le);
#line 1242
      body_len += tmp___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1245
    ctx->internal_body_length = (off_t )body_len;
#line 1246
    len += body_len;
  } else
#line 1248
  if (r->headers_in.chunked) {
#line 1248
    if (r->reading_body) {
#line 1249
      ctx->internal_body_length = (off_t )-1;
#line 1250
      ctx->internal_chunked = 1U;
    } else {
#line 1253
      ctx->internal_body_length = r->headers_in.content_length_n;
    }
  } else {
#line 1253
    ctx->internal_body_length = r->headers_in.content_length_n;
  }
#line 1256
  le.ip = (u_char *)(headers->lengths)->elts;
#line 1257
  le.request = r;
#line 1258
  le.flushed = 1U;
  {
#line 1260
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1260
    if (! *((uintptr_t *)le.ip)) {
#line 1260
      goto while_break___0;
    }
    {
#line 1261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1261
      if (! *((uintptr_t *)le.ip)) {
#line 1261
        goto while_break___1;
      }
      {
#line 1262
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1263
      tmp___3 = (*lcode)(& le);
#line 1263
      len += tmp___3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1265
    le.ip += sizeof(uintptr_t );
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1269
  if (plcf->upstream.pass_request_headers) {
#line 1270
    part = & r->headers_in.headers.part;
#line 1271
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1273
    i = (ngx_uint_t )0;
    {
#line 1273
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1275
      if (i >= part->nelts) {
#line 1276
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1277
          goto while_break___2;
        }
#line 1280
        part = part->next;
#line 1281
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1282
        i = (ngx_uint_t )0;
      }
      {
#line 1285
      tmp___4 = ngx_hash_find(& headers->hash, (header___0 + i)->hash, (header___0 + i)->lowcase_key,
                              (header___0 + i)->key.len);
      }
#line 1285
      if (tmp___4) {
#line 1288
        goto __Cont;
      }
#line 1291
      len += (((((header___0 + i)->key.len + sizeof(": ")) - 1UL) + (header___0 + i)->value.len) + sizeof("\r\n")) - 1UL;
      __Cont: /* CIL Label */ 
#line 1273
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1297
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 1298
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1299
    return ((ngx_int_t )-1);
  }
  {
#line 1302
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 1303
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1304
    return ((ngx_int_t )-1);
  }
  {
#line 1307
  cl->buf = b;
#line 1312
  tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)method.data,
                   method.len);
#line 1312
  b->last = (u_char *)tmp___5 + method.len;
#line 1313
  tmp___6 = b->last;
#line 1313
  (b->last) ++;
#line 1313
  *tmp___6 = (u_char )' ';
#line 1315
  u->uri.data = b->last;
  }
#line 1317
  if (plcf->proxy_lengths) {
#line 1317
    if (ctx->vars.uri.len) {
      {
#line 1318
      tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->vars.uri.data,
                       ctx->vars.uri.len);
#line 1318
      b->last = (u_char *)tmp___7 + ctx->vars.uri.len;
      }
    } else {
#line 1317
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1320
  if (unparsed_uri) {
    {
#line 1321
    tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->unparsed_uri.data,
                     r->unparsed_uri.len);
#line 1321
    b->last = (u_char *)tmp___8 + r->unparsed_uri.len;
    }
  } else {
#line 1324
    if (r->valid_location) {
      {
#line 1325
      tmp___9 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->vars.uri.data,
                       ctx->vars.uri.len);
#line 1325
      b->last = (u_char *)tmp___9 + ctx->vars.uri.len;
      }
    }
#line 1328
    if (escape___0) {
      {
#line 1329
      ngx_escape_uri(b->last, r->uri.data + loc_len, r->uri.len - loc_len, (ngx_uint_t )0);
#line 1331
      b->last += (r->uri.len - loc_len) + escape___0;
      }
    } else {
      {
#line 1334
      tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(r->uri.data + loc_len),
                        r->uri.len - loc_len);
#line 1334
      b->last = (u_char *)tmp___10 + (r->uri.len - loc_len);
      }
    }
#line 1338
    if (r->args.len > 0UL) {
      {
#line 1339
      tmp___11 = b->last;
#line 1339
      (b->last) ++;
#line 1339
      *tmp___11 = (u_char )'?';
#line 1340
      tmp___12 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->args.data,
                        r->args.len);
#line 1340
      b->last = (u_char *)tmp___12 + r->args.len;
      }
    }
  }
#line 1344
  u->uri.len = (size_t___0 )(b->last - u->uri.data);
#line 1346
  if (plcf->http_version == 1001UL) {
    {
#line 1347
    tmp___13 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(ngx_http_proxy_version_11),
                      sizeof(ngx_http_proxy_version_11) - 1UL);
#line 1347
    b->last = (u_char *)tmp___13 + (sizeof(ngx_http_proxy_version_11) - 1UL);
    }
  } else {
    {
#line 1351
    tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(ngx_http_proxy_version),
                      sizeof(ngx_http_proxy_version) - 1UL);
#line 1351
    b->last = (u_char *)tmp___14 + (sizeof(ngx_http_proxy_version) - 1UL);
    }
  }
  {
#line 1355
  memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 1357
  e.ip = (u_char *)(headers->values)->elts;
#line 1358
  e.pos = b->last;
#line 1359
  e.request = r;
#line 1360
  e.flushed = 1U;
#line 1362
  le.ip = (u_char *)(headers->lengths)->elts;
  }
  {
#line 1364
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1364
    if (! *((uintptr_t *)le.ip)) {
#line 1364
      goto while_break___3;
    }
    {
#line 1365
    lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1368
    (*lcode)(& le);
    }
#line 1370
    if (*((ngx_http_script_len_code_pt *)le.ip)) {
#line 1372
      len = (size_t___0 )0;
      {
#line 1372
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1372
        if (! *((uintptr_t *)le.ip)) {
#line 1372
          goto while_break___4;
        }
        {
#line 1373
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1372
        tmp___15 = (*lcode)(& le);
#line 1372
        len += tmp___15;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1376
      if (len == sizeof("\r\n") - 1UL) {
#line 1376
        e.skip = 1U;
      } else {
#line 1376
        e.skip = 0U;
      }
    } else {
#line 1379
      e.skip = 0U;
    }
#line 1382
    le.ip += sizeof(uintptr_t );
    {
#line 1384
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1384
      if (! *((uintptr_t *)e.ip)) {
#line 1384
        goto while_break___5;
      }
      {
#line 1385
      code = *((ngx_http_script_code_pt *)e.ip);
#line 1386
      (*code)(& e);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1388
    e.ip += sizeof(uintptr_t );
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1391
  b->last = e.pos;
#line 1394
  if (plcf->upstream.pass_request_headers) {
#line 1395
    part = & r->headers_in.headers.part;
#line 1396
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1398
    i = (ngx_uint_t )0;
    {
#line 1398
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1400
      if (i >= part->nelts) {
#line 1401
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1402
          goto while_break___6;
        }
#line 1405
        part = part->next;
#line 1406
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1407
        i = (ngx_uint_t )0;
      }
      {
#line 1410
      tmp___16 = ngx_hash_find(& headers->hash, (header___0 + i)->hash, (header___0 + i)->lowcase_key,
                               (header___0 + i)->key.len);
      }
#line 1410
      if (tmp___16) {
#line 1413
        goto __Cont___0;
      }
      {
#line 1416
      tmp___17 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->key.data,
                        (header___0 + i)->key.len);
#line 1416
      b->last = (u_char *)tmp___17 + (header___0 + i)->key.len;
#line 1418
      tmp___18 = b->last;
#line 1418
      (b->last) ++;
#line 1418
      *tmp___18 = (u_char )':';
#line 1418
      tmp___19 = b->last;
#line 1418
      (b->last) ++;
#line 1418
      *tmp___19 = (u_char )' ';
#line 1420
      tmp___20 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        (header___0 + i)->value.len);
#line 1420
      b->last = (u_char *)tmp___20 + (header___0 + i)->value.len;
#line 1423
      tmp___21 = b->last;
#line 1423
      (b->last) ++;
#line 1423
      *tmp___21 = (u_char )'\r';
#line 1423
      tmp___22 = b->last;
#line 1423
      (b->last) ++;
#line 1423
      *tmp___22 = (u_char )'\n';
      }
      __Cont___0: /* CIL Label */ 
#line 1398
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1433
  tmp___23 = b->last;
#line 1433
  (b->last) ++;
#line 1433
  *tmp___23 = (u_char )'\r';
#line 1433
  tmp___24 = b->last;
#line 1433
  (b->last) ++;
#line 1433
  *tmp___24 = (u_char )'\n';
#line 1435
  if (plcf->body_values) {
#line 1436
    e.ip = (u_char *)(plcf->body_values)->elts;
#line 1437
    e.pos = b->last;
#line 1438
    e.skip = 0U;
    {
#line 1440
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1440
      if (! *((uintptr_t *)e.ip)) {
#line 1440
        goto while_break___7;
      }
      {
#line 1441
      code = *((ngx_http_script_code_pt *)e.ip);
#line 1442
      (*code)(& e);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1445
    b->last = e.pos;
  }
#line 1452
  if (r->request_body_no_buffering) {
#line 1454
    u->request_bufs = cl;
#line 1456
    if (ctx->internal_chunked) {
#line 1457
      u->output.output_filter = & ngx_http_proxy_body_output_filter;
#line 1458
      u->output.filter_ctx = (void *)r;
    }
  } else
#line 1461
  if ((unsigned long )plcf->body_values == (unsigned long )((void *)0)) {
#line 1461
    if (plcf->upstream.pass_request_body) {
#line 1463
      body = u->request_bufs;
#line 1464
      u->request_bufs = cl;
      {
#line 1466
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1466
        if (! body) {
#line 1466
          goto while_break___8;
        }
        {
#line 1467
        tmp___25 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 1467
        b = (ngx_buf_t *)tmp___25;
        }
#line 1468
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1469
          return ((ngx_int_t )-1);
        }
        {
#line 1472
        memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
               sizeof(ngx_buf_t ));
#line 1474
        cl->next = ngx_alloc_chain_link(r->pool);
        }
#line 1475
        if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1476
          return ((ngx_int_t )-1);
        }
#line 1479
        cl = cl->next;
#line 1480
        cl->buf = b;
#line 1482
        body = body->next;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else {
#line 1486
      u->request_bufs = cl;
    }
  } else {
#line 1486
    u->request_bufs = cl;
  }
#line 1489
  b->flush = 1U;
#line 1490
  cl->next = (ngx_chain_t *)((void *)0);
#line 1492
  return ((ngx_int_t )0);
}
}
#line 1496 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 1501
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1503
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1504
    return ((ngx_int_t )0);
  }
#line 1507
  ctx->status.code = (ngx_uint_t )0;
#line 1508
  ctx->status.count = (ngx_uint_t )0;
#line 1509
  ctx->status.start = (u_char *)((void *)0);
#line 1510
  ctx->status.end = (u_char *)((void *)0);
#line 1511
  ctx->chunked.state = (ngx_uint_t )0;
#line 1513
  (r->upstream)->process_header = & ngx_http_proxy_process_status_line;
#line 1514
  ((r->upstream)->pipe)->input_filter = & ngx_http_proxy_copy_filter;
#line 1515
  (r->upstream)->input_filter = & ngx_http_proxy_non_buffered_copy_filter;
#line 1516
  r->state = (ngx_uint_t )0;
#line 1518
  return ((ngx_int_t )0);
}
}
#line 1522 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_body_output_filter(void *data , ngx_chain_t *in ) 
{ 
  ngx_http_request_t *r ;
  off_t size ;
  u_char *chunk ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_chain_t **fl ;
  ngx_http_proxy_ctx_t *ctx ;
  off_t tmp ;
  void *tmp___0 ;

  {
#line 1525
  r = (ngx_http_request_t *)data;
#line 1537
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1539
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1540
    out = in;
#line 1541
    goto out;
  }
#line 1544
  out = (ngx_chain_t *)((void *)0);
#line 1545
  ll = & out;
#line 1547
  if (! ctx->header_sent) {
    {
#line 1553
    ctx->header_sent = 1U;
#line 1555
    tl = ngx_alloc_chain_link(r->pool);
    }
#line 1556
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1557
      return ((ngx_int_t )-1);
    }
#line 1560
    tl->buf = in->buf;
#line 1561
    *ll = tl;
#line 1562
    ll = & tl->next;
#line 1564
    in = in->next;
#line 1566
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1567
      tl->next = (ngx_chain_t *)((void *)0);
#line 1568
      goto out;
    }
  }
#line 1572
  size = (off_t )0;
#line 1573
  cl = in;
#line 1574
  fl = ll;
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1580
    if ((cl->buf)->temporary) {
#line 1580
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 1580
    if ((cl->buf)->memory) {
#line 1580
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 1580
    if ((cl->buf)->mmap) {
#line 1580
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 1580
      tmp = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 1580
    size += tmp;
#line 1582
    if ((cl->buf)->flush) {
#line 1582
      goto _L;
    } else
#line 1582
    if ((cl->buf)->sync) {
#line 1582
      goto _L;
    } else
#line 1582
    if ((cl->buf)->temporary) {
#line 1582
      goto _L;
    } else
#line 1582
    if ((cl->buf)->memory) {
#line 1582
      goto _L;
    } else
#line 1582
    if ((cl->buf)->mmap) {
#line 1582
      goto _L;
    } else
#line 1582
    if ((cl->buf)->in_file) {
      _L: /* CIL Label */ 
      {
#line 1587
      tl = ngx_alloc_chain_link(r->pool);
      }
#line 1588
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1589
        return ((ngx_int_t )-1);
      }
#line 1592
      tl->buf = cl->buf;
#line 1593
      *ll = tl;
#line 1594
      ll = & tl->next;
    }
#line 1597
    if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1598
      goto while_break;
    }
#line 1601
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1604
  if (size) {
    {
#line 1605
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 1606
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1607
      return ((ngx_int_t )-1);
    }
#line 1610
    b = tl->buf;
#line 1611
    chunk = b->start;
#line 1613
    if ((unsigned long )chunk == (unsigned long )((void *)0)) {
      {
#line 1616
      tmp___0 = ngx_palloc(r->pool, sizeof("0000000000000000\r\n") - 1UL);
#line 1616
      chunk = (u_char *)tmp___0;
      }
#line 1617
      if ((unsigned long )chunk == (unsigned long )((void *)0)) {
#line 1618
        return ((ngx_int_t )-1);
      }
#line 1621
      b->start = chunk;
#line 1622
      b->end = (chunk + sizeof("0000000000000000\r\n")) - 1;
    }
    {
#line 1625
    b->tag = (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter);
#line 1626
    b->memory = 0U;
#line 1627
    b->temporary = 1U;
#line 1628
    b->pos = chunk;
#line 1629
    b->last = ngx_sprintf(chunk, "%xO\r\n", size);
#line 1631
    tl->next = *fl;
#line 1632
    *fl = tl;
    }
  }
#line 1635
  if ((cl->buf)->last_buf) {
    {
#line 1636
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 1637
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1638
      return ((ngx_int_t )-1);
    }
#line 1641
    b = tl->buf;
#line 1643
    b->tag = (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter);
#line 1644
    b->temporary = 0U;
#line 1645
    b->memory = 1U;
#line 1646
    b->last_buf = 1U;
#line 1647
    b->pos = (u_char *)"\r\n0\r\n\r\n";
#line 1648
    b->last = b->pos + 7;
#line 1650
    (cl->buf)->last_buf = 0U;
#line 1652
    *ll = tl;
#line 1654
    if (size == 0L) {
#line 1655
      b->pos += 2;
    }
  } else
#line 1658
  if (size > 0L) {
    {
#line 1659
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 1660
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1661
      return ((ngx_int_t )-1);
    }
#line 1664
    b = tl->buf;
#line 1666
    b->tag = (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter);
#line 1667
    b->temporary = 0U;
#line 1668
    b->memory = 1U;
#line 1669
    b->pos = (u_char *)"\r\n";
#line 1670
    b->last = b->pos + 2;
#line 1672
    *ll = tl;
  } else {
#line 1675
    *ll = (ngx_chain_t *)((void *)0);
  }
  out: 
  {
#line 1680
  rc = ngx_chain_writer((void *)(& (r->upstream)->writer), out);
#line 1682
  ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & out, (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter));
  }
#line 1685
  return (rc);
}
}
#line 1689 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_process_status_line(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1697
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1699
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1700
    return ((ngx_int_t )-1);
  }
  {
#line 1703
  u = r->upstream;
#line 1705
  rc = ngx_http_parse_status_line(r, & u->buffer, & ctx->status);
  }
#line 1707
  if (rc == -2L) {
#line 1708
    return (rc);
  }
#line 1711
  if (rc == -1L) {
#line 1715
    if (r->cache) {
#line 1716
      r->http_version = (ngx_uint_t )9;
#line 1717
      return ((ngx_int_t )0);
    }
#line 1722
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1722
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent no valid HTTP/1.0 header");
      }
    }
#line 1731
    r->http_version = (ngx_uint_t )9;
#line 1732
    (u->state)->status = (ngx_uint_t )200;
#line 1733
    u->headers_in.connection_close = 1U;
#line 1735
    return ((ngx_int_t )0);
  }
#line 1738
  if (u->state) {
#line 1738
    if ((u->state)->status == 0UL) {
#line 1739
      (u->state)->status = ctx->status.code;
    }
  }
  {
#line 1742
  u->headers_in.status_n = ctx->status.code;
#line 1744
  len = (size_t___0 )(ctx->status.end - ctx->status.start);
#line 1745
  u->headers_in.status_line.len = len;
#line 1747
  tmp = ngx_pnalloc(r->pool, len);
#line 1747
  u->headers_in.status_line.data = (u_char *)tmp;
  }
#line 1748
  if ((unsigned long )u->headers_in.status_line.data == (unsigned long )((void *)0)) {
#line 1749
    return ((ngx_int_t )-1);
  }
  {
#line 1752
  memcpy((void */* __restrict  */)u->headers_in.status_line.data, (void const   */* __restrict  */)ctx->status.start,
         len);
  }
#line 1758
  if (ctx->status.http_version < 1001UL) {
#line 1759
    u->headers_in.connection_close = 1U;
  }
  {
#line 1762
  u->process_header = & ngx_http_proxy_process_header;
#line 1764
  tmp___0 = ngx_http_proxy_process_header(r);
  }
#line 1764
  return (tmp___0);
}
}
#line 1768 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_process_header(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 1778
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1782
    rc = ngx_http_parse_header_line(r, & (r->upstream)->buffer, (ngx_uint_t )1);
    }
#line 1784
    if (rc == 0L) {
      {
#line 1788
      tmp = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1788
      h = (ngx_table_elt_t *)tmp;
      }
#line 1789
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1790
        return ((ngx_int_t )-1);
      }
      {
#line 1793
      h->hash = r->header_hash;
#line 1795
      h->key.len = (size_t___0 )(r->header_name_end - r->header_name_start);
#line 1796
      h->value.len = (size_t___0 )(r->header_end - r->header_start);
#line 1798
      tmp___0 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1798
      h->key.data = (u_char *)tmp___0;
      }
#line 1800
      if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1801
        h->hash = (ngx_uint_t )0;
#line 1802
        return ((ngx_int_t )-1);
      }
      {
#line 1805
      h->value.data = (h->key.data + h->key.len) + 1;
#line 1806
      h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1808
      memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
             h->key.len);
#line 1809
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1810
      memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
             h->value.len);
#line 1811
      *(h->value.data + h->value.len) = (u_char )'\000';
      }
#line 1813
      if (h->key.len == r->lowcase_index) {
        {
#line 1814
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1817
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1820
      tmp___1 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1820
      hh = (ngx_http_upstream_header_t *)tmp___1;
      }
#line 1823
      if (hh) {
        {
#line 1823
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1823
        if (tmp___2 != 0L) {
#line 1824
          return ((ngx_int_t )-1);
        }
      }
#line 1831
      goto __Cont;
    }
#line 1834
    if (rc == 1L) {
#line 1846
      if ((unsigned long )(r->upstream)->headers_in.server == (unsigned long )((void *)0)) {
        {
#line 1847
        tmp___3 = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1847
        h = (ngx_table_elt_t *)tmp___3;
        }
#line 1848
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1849
          return ((ngx_int_t )-1);
        }
#line 1852
        h->hash = 3389140803UL;
#line 1855
        h->key.len = sizeof("Server") - 1UL;
#line 1855
        h->key.data = (u_char *)"Server";
#line 1856
        h->value.len = (size_t___0 )0;
#line 1856
        h->value.data = (u_char *)((void *)0);
#line 1857
        h->lowcase_key = (u_char *)"server";
      }
#line 1860
      if ((unsigned long )(r->upstream)->headers_in.date == (unsigned long )((void *)0)) {
        {
#line 1861
        tmp___4 = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1861
        h = (ngx_table_elt_t *)tmp___4;
        }
#line 1862
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1863
          return ((ngx_int_t )-1);
        }
#line 1866
        h->hash = 3076014UL;
#line 1868
        h->key.len = sizeof("Date") - 1UL;
#line 1868
        h->key.data = (u_char *)"Date";
#line 1869
        h->value.len = (size_t___0 )0;
#line 1869
        h->value.data = (u_char *)((void *)0);
#line 1870
        h->lowcase_key = (u_char *)"date";
      }
#line 1875
      u = r->upstream;
#line 1877
      if (u->headers_in.chunked) {
#line 1878
        u->headers_in.content_length_n = (off_t )-1;
      }
#line 1886
      ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1888
      if (u->headers_in.status_n == 204UL) {
#line 1894
        u->keepalive = (unsigned int )(! u->headers_in.connection_close);
      } else
#line 1888
      if (u->headers_in.status_n == 304UL) {
#line 1894
        u->keepalive = (unsigned int )(! u->headers_in.connection_close);
      } else
#line 1888
      if (ctx->head) {
#line 1894
        u->keepalive = (unsigned int )(! u->headers_in.connection_close);
      } else
#line 1888
      if (! u->headers_in.chunked) {
#line 1888
        if (u->headers_in.content_length_n == 0L) {
#line 1894
          u->keepalive = (unsigned int )(! u->headers_in.connection_close);
        }
      }
#line 1897
      if (u->headers_in.status_n == 101UL) {
#line 1898
        u->keepalive = 0U;
#line 1900
        if (r->headers_in.upgrade) {
#line 1901
          u->upgrade = 1U;
        }
      }
#line 1905
      return ((ngx_int_t )0);
    }
#line 1908
    if (rc == -2L) {
#line 1909
      return ((ngx_int_t )-2);
    }
#line 1914
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1914
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
      }
    }
#line 1917
    return ((ngx_int_t )40);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1922 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_input_filter_init(void *data ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 1925
  r = (ngx_http_request_t *)data;
#line 1929
  u = r->upstream;
#line 1930
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1932
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1933
    return ((ngx_int_t )-1);
  }
#line 1943
  if (u->headers_in.status_n == 204UL) {
#line 1950
    (u->pipe)->length = (off_t )0;
#line 1951
    u->length = (off_t )0;
#line 1952
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else
#line 1943
  if (u->headers_in.status_n == 304UL) {
#line 1950
    (u->pipe)->length = (off_t )0;
#line 1951
    u->length = (off_t )0;
#line 1952
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else
#line 1943
  if (ctx->head) {
#line 1950
    (u->pipe)->length = (off_t )0;
#line 1951
    u->length = (off_t )0;
#line 1952
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else
#line 1954
  if (u->headers_in.chunked) {
#line 1957
    (u->pipe)->input_filter = & ngx_http_proxy_chunked_filter;
#line 1958
    (u->pipe)->length = (off_t )3;
#line 1960
    u->input_filter = & ngx_http_proxy_non_buffered_chunked_filter;
#line 1961
    u->length = (off_t )1;
  } else
#line 1963
  if (u->headers_in.content_length_n == 0L) {
#line 1966
    (u->pipe)->length = (off_t )0;
#line 1967
    u->length = (off_t )0;
#line 1968
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else {
#line 1973
    (u->pipe)->length = u->headers_in.content_length_n;
#line 1974
    u->length = u->headers_in.content_length_n;
  }
#line 1977
  return ((ngx_int_t )0);
}
}
#line 1981 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_copy_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_request_t *r ;

  {
#line 1988
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 1989
    return ((ngx_int_t )0);
  }
  {
#line 1992
  cl = ngx_chain_get_free_buf(p->pool, & p->free);
  }
#line 1993
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1994
    return ((ngx_int_t )-1);
  }
  {
#line 1997
  b = cl->buf;
#line 1999
  memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)buf, sizeof(ngx_buf_t ));
#line 2000
  b->shadow = buf;
#line 2001
  b->tag = p->tag;
#line 2002
  b->last_shadow = 1U;
#line 2003
  b->recycled = 1U;
#line 2004
  buf->shadow = b;
  }
#line 2008
  if (p->in) {
#line 2009
    *(p->last_in) = cl;
  } else {
#line 2011
    p->in = cl;
  }
#line 2013
  p->last_in = & cl->next;
#line 2015
  if (p->length == -1L) {
#line 2016
    return ((ngx_int_t )0);
  }
#line 2019
  p->length -= b->last - b->pos;
#line 2021
  if (p->length == 0L) {
#line 2022
    r = (ngx_http_request_t *)p->input_ctx;
#line 2023
    p->upstream_done = 1U;
#line 2024
    (r->upstream)->keepalive = (unsigned int )(! (r->upstream)->headers_in.connection_close);
  } else
#line 2026
  if (p->length < 0L) {
#line 2027
    r = (ngx_http_request_t *)p->input_ctx;
#line 2028
    p->upstream_done = 1U;
#line 2030
    if (((r->connection)->log)->log_level >= 5UL) {
      {
#line 2030
      ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "upstream sent more data than specified in \"Content-Length\" header");
      }
    }
  }
#line 2035
  return ((ngx_int_t )0);
}
}
#line 2039 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t **prev ;
  ngx_chain_t *cl ;
  ngx_http_request_t *r ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_int_t tmp ;

  {
#line 2048
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 2049
    return ((ngx_int_t )0);
  }
#line 2052
  r = (ngx_http_request_t *)p->input_ctx;
#line 2053
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2055
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2056
    return ((ngx_int_t )-1);
  }
#line 2059
  b = (ngx_buf_t *)((void *)0);
#line 2060
  prev = & buf->shadow;
  {
#line 2062
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2064
    rc = ngx_http_parse_chunked(r, buf, & ctx->chunked);
    }
#line 2066
    if (rc == 0L) {
      {
#line 2070
      cl = ngx_chain_get_free_buf(p->pool, & p->free);
      }
#line 2071
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2072
        return ((ngx_int_t )-1);
      }
      {
#line 2075
      b = cl->buf;
#line 2077
      memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 2079
      b->pos = buf->pos;
#line 2080
      b->start = buf->start;
#line 2081
      b->end = buf->end;
#line 2082
      b->tag = p->tag;
#line 2083
      b->temporary = 1U;
#line 2084
      b->recycled = 1U;
#line 2086
      *prev = b;
#line 2087
      prev = & b->shadow;
      }
#line 2089
      if (p->in) {
#line 2090
        *(p->last_in) = cl;
      } else {
#line 2092
        p->in = cl;
      }
#line 2094
      p->last_in = & cl->next;
#line 2096
      b->num = buf->num;
#line 2101
      if (buf->last - buf->pos >= ctx->chunked.size) {
#line 2103
        buf->pos += (size_t___0 )ctx->chunked.size;
#line 2104
        b->last = buf->pos;
#line 2105
        ctx->chunked.size = (off_t )0;
#line 2107
        goto __Cont;
      }
#line 2110
      ctx->chunked.size -= buf->last - buf->pos;
#line 2111
      buf->pos = buf->last;
#line 2112
      b->last = buf->last;
#line 2114
      goto __Cont;
    }
#line 2117
    if (rc == -4L) {
#line 2121
      p->upstream_done = 1U;
#line 2122
      (r->upstream)->keepalive = (unsigned int )(! (r->upstream)->headers_in.connection_close);
#line 2124
      goto while_break;
    }
#line 2127
    if (rc == -2L) {
#line 2131
      p->length = ctx->chunked.length;
#line 2133
      goto while_break;
    }
#line 2138
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2138
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid chunked response");
      }
    }
#line 2141
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2148
  if (b) {
#line 2149
    b->shadow = buf;
#line 2150
    b->last_shadow = 1U;
#line 2155
    return ((ngx_int_t )0);
  }
  {
#line 2160
  tmp = ngx_event_pipe_add_free_buf(p, buf);
  }
#line 2160
  if (tmp != 0L) {
#line 2161
    return ((ngx_int_t )-1);
  }
#line 2164
  return ((ngx_int_t )0);
}
}
#line 2168 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_non_buffered_copy_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_request_t *r ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;

  {
#line 2171
  r = (ngx_http_request_t *)data;
#line 2177
  u = r->upstream;
#line 2179
  cl = u->out_bufs;
#line 2179
  ll = & u->out_bufs;
  {
#line 2179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2179
    if (! cl) {
#line 2179
      goto while_break;
    }
#line 2180
    ll = & cl->next;
#line 2179
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2183
  cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
  }
#line 2184
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2185
    return ((ngx_int_t )-1);
  }
#line 2188
  *ll = cl;
#line 2190
  (cl->buf)->flush = 1U;
#line 2191
  (cl->buf)->memory = 1U;
#line 2193
  b = & u->buffer;
#line 2195
  (cl->buf)->pos = b->last;
#line 2196
  b->last += bytes;
#line 2197
  (cl->buf)->last = b->last;
#line 2198
  (cl->buf)->tag = u->output.tag;
#line 2200
  if (u->length == -1L) {
#line 2201
    return ((ngx_int_t )0);
  }
#line 2204
  u->length -= bytes;
#line 2206
  if (u->length == 0L) {
#line 2207
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  }
#line 2210
  return ((ngx_int_t )0);
}
}
#line 2214 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_non_buffered_chunked_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_request_t *r ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  void *tmp ;

  {
#line 2217
  r = (ngx_http_request_t *)data;
#line 2225
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2227
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2228
    return ((ngx_int_t )-1);
  }
#line 2231
  u = r->upstream;
#line 2232
  buf = & u->buffer;
#line 2234
  buf->pos = buf->last;
#line 2235
  buf->last += bytes;
#line 2237
  cl = u->out_bufs;
#line 2237
  ll = & u->out_bufs;
  {
#line 2237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2237
    if (! cl) {
#line 2237
      goto while_break;
    }
#line 2238
    ll = & cl->next;
#line 2237
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2241
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2243
    rc = ngx_http_parse_chunked(r, buf, & ctx->chunked);
    }
#line 2245
    if (rc == 0L) {
      {
#line 2249
      cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
      }
#line 2250
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2251
        return ((ngx_int_t )-1);
      }
#line 2254
      *ll = cl;
#line 2255
      ll = & cl->next;
#line 2257
      b = cl->buf;
#line 2259
      b->flush = 1U;
#line 2260
      b->memory = 1U;
#line 2262
      b->pos = buf->pos;
#line 2263
      b->tag = u->output.tag;
#line 2265
      if (buf->last - buf->pos >= ctx->chunked.size) {
#line 2266
        buf->pos += (size_t___0 )ctx->chunked.size;
#line 2267
        b->last = buf->pos;
#line 2268
        ctx->chunked.size = (off_t )0;
      } else {
#line 2271
        ctx->chunked.size -= buf->last - buf->pos;
#line 2272
        buf->pos = buf->last;
#line 2273
        b->last = buf->last;
      }
#line 2280
      goto __Cont;
    }
#line 2283
    if (rc == -4L) {
#line 2287
      u->keepalive = (unsigned int )(! u->headers_in.connection_close);
#line 2288
      u->length = (off_t )0;
#line 2290
      goto while_break___0;
    }
#line 2293
    if (rc == -2L) {
#line 2294
      goto while_break___0;
    }
#line 2299
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2299
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid chunked response");
      }
    }
#line 2302
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2307
  if (r->subrequest_in_memory) {
#line 2309
    cl = u->out_bufs;
#line 2311
    if (cl) {
#line 2312
      buf->pos = (cl->buf)->pos;
    }
#line 2315
    buf->last = buf->pos;
#line 2317
    cl = u->out_bufs;
    {
#line 2317
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2317
      if (! cl) {
#line 2317
        goto while_break___1;
      }
#line 2322
      if ((unsigned long )buf->last == (unsigned long )(cl->buf)->pos) {
#line 2323
        buf->last = (cl->buf)->last;
#line 2324
        goto __Cont___0;
      }
      {
#line 2327
      tmp = memmove((void *)buf->last, (void const   *)(cl->buf)->pos, (size_t )((cl->buf)->last - (cl->buf)->pos));
#line 2327
      buf->last = (u_char *)tmp + ((cl->buf)->last - (cl->buf)->pos);
#line 2330
      (cl->buf)->pos = buf->last - ((cl->buf)->last - (cl->buf)->pos);
#line 2331
      (cl->buf)->last = buf->last;
      }
      __Cont___0: /* CIL Label */ 
#line 2317
      cl = cl->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2335
  return ((ngx_int_t )0);
}
}
#line 2339 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static void ngx_http_proxy_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 2345
  return;
}
}
#line 2349 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static void ngx_http_proxy_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 2355
  return;
}
}
#line 2359 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_host_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 2365
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2367
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2368
    v->not_found = 1U;
#line 2369
    return ((ngx_int_t )0);
  }
#line 2372
  v->len = (unsigned int )ctx->vars.host_header.len;
#line 2373
  v->valid = 1U;
#line 2374
  v->no_cacheable = 0U;
#line 2375
  v->not_found = 0U;
#line 2376
  v->data = ctx->vars.host_header.data;
#line 2378
  return ((ngx_int_t )0);
}
}
#line 2382 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_port_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 2388
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2390
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2391
    v->not_found = 1U;
#line 2392
    return ((ngx_int_t )0);
  }
#line 2395
  v->len = (unsigned int )ctx->vars.port.len;
#line 2396
  v->valid = 1U;
#line 2397
  v->no_cacheable = 0U;
#line 2398
  v->not_found = 0U;
#line 2399
  v->data = ctx->vars.port.data;
#line 2401
  return ((ngx_int_t )0);
}
}
#line 2405 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r ,
                                                             ngx_http_variable_value_t *v ,
                                                             uintptr_t data ) 
{ 
  size_t___0 len ;
  u_char *p ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_table_elt_t **h ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 2414
  v->valid = 1U;
#line 2415
  v->no_cacheable = 0U;
#line 2416
  v->not_found = 0U;
#line 2418
  n = r->headers_in.x_forwarded_for.nelts;
#line 2419
  h = (ngx_table_elt_t **)r->headers_in.x_forwarded_for.elts;
#line 2421
  len = (size_t___0 )0;
#line 2423
  i = (ngx_uint_t )0;
  {
#line 2423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2423
    if (! (i < n)) {
#line 2423
      goto while_break;
    }
#line 2424
    len += ((*(h + i))->value.len + sizeof(", ")) - 1UL;
#line 2423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2427
  if (len == 0UL) {
#line 2428
    v->len = (unsigned int )(r->connection)->addr_text.len;
#line 2429
    v->data = (r->connection)->addr_text.data;
#line 2430
    return ((ngx_int_t )0);
  }
  {
#line 2433
  len += (r->connection)->addr_text.len;
#line 2435
  tmp = ngx_pnalloc(r->pool, len);
#line 2435
  p = (u_char *)tmp;
  }
#line 2436
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2437
    return ((ngx_int_t )-1);
  }
#line 2440
  v->len = (unsigned int )len;
#line 2441
  v->data = p;
#line 2443
  i = (ngx_uint_t )0;
  {
#line 2443
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2443
    if (! (i < n)) {
#line 2443
      goto while_break___0;
    }
    {
#line 2444
    tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(*(h + i))->value.data,
                     (*(h + i))->value.len);
#line 2444
    p = (u_char *)tmp___0 + (*(h + i))->value.len;
#line 2445
    tmp___1 = p;
#line 2445
    p ++;
#line 2445
    *tmp___1 = (u_char )',';
#line 2445
    tmp___2 = p;
#line 2445
    p ++;
#line 2445
    *tmp___2 = (u_char )' ';
#line 2443
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2448
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(r->connection)->addr_text.data,
         (r->connection)->addr_text.len);
  }
#line 2450
  return ((ngx_int_t )0);
}
}
#line 2454 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_internal_body_length_variable(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 2460
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2462
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2463
    v->not_found = 1U;
#line 2464
    return ((ngx_int_t )0);
  } else
#line 2462
  if (ctx->internal_body_length < 0L) {
#line 2463
    v->not_found = 1U;
#line 2464
    return ((ngx_int_t )0);
  }
  {
#line 2467
  v->valid = 1U;
#line 2468
  v->no_cacheable = 0U;
#line 2469
  v->not_found = 0U;
#line 2471
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2471
  v->data = (u_char *)tmp;
  }
#line 2473
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 2474
    return ((ngx_int_t )-1);
  }
  {
#line 2477
  tmp___0 = ngx_sprintf(v->data, "%O", ctx->internal_body_length);
#line 2477
  v->len = (unsigned int )(tmp___0 - v->data);
  }
#line 2479
  return ((ngx_int_t )0);
}
}
#line 2483 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_internal_chunked_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 2489
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2491
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2492
    v->not_found = 1U;
#line 2493
    return ((ngx_int_t )0);
  } else
#line 2491
  if (! ctx->internal_chunked) {
#line 2492
    v->not_found = 1U;
#line 2493
    return ((ngx_int_t )0);
  }
#line 2496
  v->valid = 1U;
#line 2497
  v->no_cacheable = 0U;
#line 2498
  v->not_found = 0U;
#line 2500
  v->data = (u_char *)"chunked";
#line 2501
  v->len = (unsigned int )(sizeof("chunked") - 1UL);
#line 2503
  return ((ngx_int_t )0);
}
}
#line 2507 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                 size_t___0 prefix ) 
{ 
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_proxy_loc_conf_t *plcf ;

  {
#line 2517
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 2519
  pr = (ngx_http_proxy_rewrite_t *)(plcf->redirects)->elts;
#line 2521
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2522
    return ((ngx_int_t )-5);
  }
#line 2525
  len = h->value.len - prefix;
#line 2527
  i = (ngx_uint_t )0;
  {
#line 2527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2527
    if (! (i < (plcf->redirects)->nelts)) {
#line 2527
      goto while_break;
    }
    {
#line 2528
    rc = (*((pr + i)->handler))(r, h, prefix, len, pr + i);
    }
#line 2530
    if (rc != -5L) {
#line 2531
      return (rc);
    }
#line 2527
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2535
  return ((ngx_int_t )-5);
}
}
#line 2539 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ) 
{ 
  size_t___0 prefix ;
  u_char *p ;
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_http_proxy_loc_conf_t *plcf ;
  char *tmp ;

  {
  {
#line 2547
  tmp = strchr((char const   *)h->value.data, ';');
#line 2547
  p = (u_char *)tmp;
  }
#line 2548
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2549
    return ((ngx_int_t )-5);
  }
#line 2552
  prefix = (size_t___0 )((p + 1) - h->value.data);
#line 2554
  rv = (ngx_int_t )-5;
#line 2556
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 2558
  if (plcf->cookie_domains) {
    {
#line 2559
    p = ngx_strcasestrn(h->value.data + prefix, (char *)"domain=", (size_t___0 )6);
    }
#line 2561
    if (p) {
      {
#line 2562
      rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 7, plcf->cookie_domains);
      }
#line 2564
      if (rc == -1L) {
#line 2565
        return ((ngx_int_t )-1);
      }
#line 2568
      if (rc != -5L) {
#line 2569
        rv = rc;
      }
    }
  }
#line 2574
  if (plcf->cookie_paths) {
    {
#line 2575
    p = ngx_strcasestrn(h->value.data + prefix, (char *)"path=", (size_t___0 )4);
    }
#line 2577
    if (p) {
      {
#line 2578
      rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 5, plcf->cookie_paths);
      }
#line 2580
      if (rc == -1L) {
#line 2581
        return ((ngx_int_t )-1);
      }
#line 2584
      if (rc != -5L) {
#line 2585
        rv = rc;
      }
    }
  }
#line 2590
  return (rv);
}
}
#line 2594 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     u_char *value , ngx_array_t *rewrites ) 
{ 
  size_t___0 len ;
  size_t___0 prefix ;
  u_char *p ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_http_proxy_rewrite_t *pr ;
  char *tmp ;

  {
  {
#line 2604
  prefix = (size_t___0 )(value - h->value.data);
#line 2606
  tmp = strchr((char const   *)value, ';');
#line 2606
  p = (u_char *)tmp;
  }
#line 2608
  if (p) {
#line 2608
    len = (size_t___0 )(p - value);
  } else {
#line 2608
    len = h->value.len - prefix;
  }
#line 2610
  pr = (ngx_http_proxy_rewrite_t *)rewrites->elts;
#line 2612
  i = (ngx_uint_t )0;
  {
#line 2612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2612
    if (! (i < rewrites->nelts)) {
#line 2612
      goto while_break;
    }
    {
#line 2613
    rc = (*((pr + i)->handler))(r, h, prefix, len, pr + i);
    }
#line 2615
    if (rc != -5L) {
#line 2616
      return (rc);
    }
#line 2612
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2620
  return ((ngx_int_t )-5);
}
}
#line 2624 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                        size_t___0 prefix , size_t___0 len ,
                                                        ngx_http_proxy_rewrite_t *pr ) 
{ 
  ngx_str_t pattern ;
  ngx_str_t replacement ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 2630
  tmp = ngx_http_complex_value(r, & pr->pattern.complex, & pattern);
  }
#line 2630
  if (tmp != 0L) {
#line 2631
    return ((ngx_int_t )-1);
  }
#line 2634
  if (pattern.len > len) {
#line 2638
    return ((ngx_int_t )-5);
  } else {
    {
#line 2634
    tmp___0 = ngx_rstrncmp(h->value.data + prefix, pattern.data, pattern.len);
    }
#line 2634
    if (tmp___0 != 0L) {
#line 2638
      return ((ngx_int_t )-5);
    }
  }
  {
#line 2641
  tmp___1 = ngx_http_complex_value(r, & pr->replacement, & replacement);
  }
#line 2641
  if (tmp___1 != 0L) {
#line 2642
    return ((ngx_int_t )-1);
  }
  {
#line 2645
  tmp___2 = ngx_http_proxy_rewrite(r, h, prefix, pattern.len, & replacement);
  }
#line 2645
  return (tmp___2);
}
}
#line 2651 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      size_t___0 prefix , size_t___0 len ,
                                                      ngx_http_proxy_rewrite_t *pr ) 
{ 
  ngx_str_t pattern ;
  ngx_str_t replacement ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 2657
  pattern.len = len;
#line 2658
  pattern.data = h->value.data + prefix;
#line 2660
  tmp = ngx_http_regex_exec(r, pr->pattern.regex, & pattern);
  }
#line 2660
  if (tmp != 0L) {
#line 2661
    return ((ngx_int_t )-5);
  }
  {
#line 2664
  tmp___0 = ngx_http_complex_value(r, & pr->replacement, & replacement);
  }
#line 2664
  if (tmp___0 != 0L) {
#line 2665
    return ((ngx_int_t )-1);
  }
#line 2668
  if (prefix == 0UL) {
#line 2668
    if (h->value.len == len) {
#line 2669
      h->value = replacement;
#line 2670
      return ((ngx_int_t )0);
    }
  }
  {
#line 2673
  tmp___1 = ngx_http_proxy_rewrite(r, h, prefix, len, & replacement);
  }
#line 2673
  return (tmp___1);
}
}
#line 2679 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                       size_t___0 prefix , size_t___0 len ,
                                                       ngx_http_proxy_rewrite_t *pr ) 
{ 
  u_char *p ;
  ngx_str_t pattern ;
  ngx_str_t replacement ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 2686
  tmp = ngx_http_complex_value(r, & pr->pattern.complex, & pattern);
  }
#line 2686
  if (tmp != 0L) {
#line 2687
    return ((ngx_int_t )-1);
  }
#line 2690
  p = h->value.data + prefix;
#line 2692
  if ((int )*(p + 0) == 46) {
#line 2693
    p ++;
#line 2694
    prefix ++;
#line 2695
    len --;
  }
#line 2698
  if (pattern.len != len) {
#line 2699
    return ((ngx_int_t )-5);
  } else {
    {
#line 2698
    tmp___0 = ngx_rstrncasecmp(pattern.data, p, len);
    }
#line 2698
    if (tmp___0 != 0L) {
#line 2699
      return ((ngx_int_t )-5);
    }
  }
  {
#line 2702
  tmp___1 = ngx_http_complex_value(r, & pr->replacement, & replacement);
  }
#line 2702
  if (tmp___1 != 0L) {
#line 2703
    return ((ngx_int_t )-1);
  }
  {
#line 2706
  tmp___2 = ngx_http_proxy_rewrite(r, h, prefix, len, & replacement);
  }
#line 2706
  return (tmp___2);
}
}
#line 2710 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                        size_t___0 prefix , size_t___0 len , ngx_str_t *replacement ) 
{ 
  u_char *p ;
  u_char *data ;
  size_t___0 new_len ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2717
  new_len = (replacement->len + h->value.len) - len;
#line 2719
  if (replacement->len > len) {
    {
#line 2721
    tmp = ngx_pnalloc(r->pool, new_len + 1UL);
#line 2721
    data = (u_char *)tmp;
    }
#line 2722
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 2723
      return ((ngx_int_t )-1);
    }
    {
#line 2726
    tmp___0 = memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)h->value.data,
                     prefix);
#line 2726
    p = (u_char *)tmp___0 + prefix;
#line 2727
    tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)replacement->data,
                     replacement->len);
#line 2727
    p = (u_char *)tmp___1 + replacement->len;
#line 2729
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((h->value.data + prefix) + len),
           ((h->value.len - len) - prefix) + 1UL);
#line 2732
    h->value.data = data;
    }
  } else {
    {
#line 2735
    tmp___2 = memcpy((void */* __restrict  */)(h->value.data + prefix), (void const   */* __restrict  */)replacement->data,
                     replacement->len);
#line 2735
    p = (u_char *)tmp___2 + replacement->len;
#line 2738
    memmove((void *)p, (void const   *)((h->value.data + prefix) + len), ((h->value.len - len) - prefix) + 1UL);
    }
  }
#line 2742
  h->value.len = new_len;
#line 2744
  return ((ngx_int_t )0);
}
}
#line 2748 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 2753
  v = ngx_http_proxy_vars;
  {
#line 2753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2753
    if (! v->name.len) {
#line 2753
      goto while_break;
    }
    {
#line 2754
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 2755
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2756
      return ((ngx_int_t )-1);
    }
#line 2759
    var->get_handler = v->get_handler;
#line 2760
    var->data = v->data;
#line 2753
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2763
  return ((ngx_int_t )0);
}
}
#line 2767 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static void *ngx_http_proxy_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_proxy_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2772
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_main_conf_t ));
#line 2772
  conf = (ngx_http_proxy_main_conf_t *)tmp;
  }
#line 2773
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2774
    return ((void *)0);
  }
  {
#line 2778
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 2778
  if (tmp___0 != 0L) {
#line 2782
    return ((void *)0);
  }
#line 2786
  return ((void *)conf);
}
}
#line 2790 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static void *ngx_http_proxy_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_proxy_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 2795
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_loc_conf_t ));
#line 2795
  conf = (ngx_http_proxy_loc_conf_t *)tmp;
  }
#line 2796
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2797
    return ((void *)0);
  }
#line 2838
  conf->upstream.store = -1;
#line 2839
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 2840
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 2841
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 2842
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 2843
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 2844
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 2846
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 2848
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 2849
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 2850
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 2851
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 2853
  conf->upstream.send_lowat = (size_t___0 )-1;
#line 2854
  conf->upstream.buffer_size = (size_t___0 )-1;
#line 2855
  conf->upstream.limit_rate = (size_t___0 )-1;
#line 2857
  conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
#line 2858
  conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
#line 2859
  conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
#line 2861
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 2862
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 2865
  conf->upstream.cache = -1;
#line 2866
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 2867
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 2868
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 2869
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 2870
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 2871
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 2872
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 2873
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 2874
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 2875
  conf->upstream.cache_convert_head = (ngx_flag_t )-1;
#line 2876
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 2879
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 2880
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 2882
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 2893
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 2895
  conf->redirect = (ngx_flag_t )-1;
#line 2896
  conf->upstream.change_buffering = 1U;
#line 2898
  conf->cookie_domains = (ngx_array_t *)((void *)-1);
#line 2899
  conf->cookie_paths = (ngx_array_t *)((void *)-1);
#line 2901
  conf->http_version = (ngx_uint_t )-1;
#line 2903
  conf->headers_hash_max_size = (ngx_uint_t )-1;
#line 2904
  conf->headers_hash_bucket_size = (ngx_uint_t )-1;
#line 2906
  conf->upstream.module.len = sizeof("proxy") - 1UL;
#line 2906
  conf->upstream.module.data = (u_char *)"proxy";
#line 2908
  return ((void *)conf);
}
}
#line 2912 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_proxy_loc_conf_t *prev ;
  ngx_http_proxy_loc_conf_t *conf ;
  u_char *p ;
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_script_compile_t sc ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 2915
  prev = (ngx_http_proxy_loc_conf_t *)parent;
#line 2916
  conf = (ngx_http_proxy_loc_conf_t *)child;
#line 2928
  if (conf->upstream.store > 0) {
#line 2929
    conf->upstream.cache = 0;
  }
#line 2932
  if (conf->upstream.cache > 0) {
#line 2933
    conf->upstream.store = 0;
  }
#line 2938
  if (conf->upstream.store == -1) {
#line 2939
    if (conf->upstream.store == -1) {
#line 2939
      if (prev->upstream.store == -1) {
#line 2939
        conf->upstream.store = 0;
      } else {
#line 2939
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 2942
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 2943
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 2946
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 2946
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 2946
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 2946
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 2949
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2949
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2949
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 2949
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 2952
  if (conf->upstream.buffering == -1L) {
#line 2952
    if (prev->upstream.buffering == -1L) {
#line 2952
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 2952
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 2955
  if (conf->upstream.request_buffering == -1L) {
#line 2955
    if (prev->upstream.request_buffering == -1L) {
#line 2955
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 2955
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 2958
  if (conf->upstream.ignore_client_abort == -1L) {
#line 2958
    if (prev->upstream.ignore_client_abort == -1L) {
#line 2958
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 2958
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 2961
  if (conf->upstream.force_ranges == -1L) {
#line 2961
    if (prev->upstream.force_ranges == -1L) {
#line 2961
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 2961
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 2964
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 2964
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 2964
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 2964
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 2967
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2967
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2967
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 2967
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 2970
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2970
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2970
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 2970
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 2973
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2973
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2973
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 2973
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 2976
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2976
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2976
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 2976
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 2979
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2979
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2979
      conf->upstream.send_lowat = (size_t___0 )0;
    } else {
#line 2979
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 2982
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 2982
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 2982
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 2982
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 2986
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 2986
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 2986
      conf->upstream.limit_rate = (size_t___0 )0;
    } else {
#line 2986
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 2989
  if (conf->upstream.bufs.num == 0L) {
#line 2989
    if (prev->upstream.bufs.num) {
#line 2989
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 2989
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 2989
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 2989
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 2992
  if (conf->upstream.bufs.num < 2L) {
    {
#line 2993
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"proxy_buffers\"");
    }
#line 2995
    return ((char *)((void *)-1));
  }
#line 2999
  size = conf->upstream.buffer_size;
#line 3000
  if (size < conf->upstream.bufs.size) {
#line 3001
    size = conf->upstream.bufs.size;
  }
#line 3005
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 3005
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 3005
      conf->upstream.busy_buffers_size_conf = (size_t___0 )-1;
    } else {
#line 3005
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 3009
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 3010
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 3012
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 3016
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 3017
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"proxy_buffer_size\" and one of the \"proxy_buffers\"");
    }
#line 3022
    return ((char *)((void *)-1));
  }
#line 3025
  if (conf->upstream.busy_buffers_size > (size_t___0 )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 3028
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_busy_buffers_size\" must be less than the size of all \"proxy_buffers\" minus one buffer");
    }
#line 3032
    return ((char *)((void *)-1));
  }
#line 3036
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 3036
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 3036
      conf->upstream.temp_file_write_size_conf = (size_t___0 )-1;
    } else {
#line 3036
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 3040
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 3041
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 3043
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 3047
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 3048
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"proxy_buffer_size\" and one of the \"proxy_buffers\"");
    }
#line 3053
    return ((char *)((void *)-1));
  }
#line 3056
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 3056
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 3056
      conf->upstream.max_temp_file_size_conf = (size_t___0 )-1;
    } else {
#line 3056
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 3060
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 3061
    conf->upstream.max_temp_file_size = (size_t___0 )1073741824;
  } else {
#line 3063
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 3067
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 3067
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 3070
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"proxy_buffer_size\" and one of the \"proxy_buffers\"");
      }
#line 3076
      return ((char *)((void *)-1));
    }
  }
#line 3080
  if (conf->upstream.ignore_headers == 0UL) {
#line 3080
    if (prev->upstream.ignore_headers == 0UL) {
#line 3080
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 3080
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 3085
  if (conf->upstream.next_upstream == 0UL) {
#line 3085
    if (prev->upstream.next_upstream == 0UL) {
#line 3085
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 3085
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 3091
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 3092
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 3096
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_proxy_temp_path);
  }
#line 3096
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 3101
    return ((char *)((void *)-1));
  }
#line 3107
  if (conf->upstream.cache == -1) {
#line 3108
    if (conf->upstream.cache == -1) {
#line 3108
      if (prev->upstream.cache == -1) {
#line 3108
        conf->upstream.cache = 0;
      } else {
#line 3108
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 3111
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 3112
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 3115
  if (conf->upstream.cache_zone) {
#line 3115
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 3118
      shm_zone = conf->upstream.cache_zone;
#line 3120
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 3124
      return ((char *)((void *)-1));
    }
  }
#line 3127
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3127
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3127
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 3127
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 3130
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 3130
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 3130
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 3130
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 3134
  if (conf->upstream.cache_use_stale == 0UL) {
#line 3134
    if (prev->upstream.cache_use_stale == 0UL) {
#line 3134
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 3134
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 3139
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 3140
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 3144
  if (conf->upstream.cache_use_stale & 2UL) {
#line 3145
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 3148
  if (conf->upstream.cache_methods == 0UL) {
#line 3149
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 3152
  conf->upstream.cache_methods |= 6UL;
#line 3154
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3154
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3154
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 3154
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 3157
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3157
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3157
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 3157
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 3160
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3160
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3160
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 3160
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 3163
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 3164
    conf->cache_key = prev->cache_key;
  }
#line 3167
  if (conf->upstream.cache_lock == -1L) {
#line 3167
    if (prev->upstream.cache_lock == -1L) {
#line 3167
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 3167
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 3170
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3170
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3170
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 3170
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 3173
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3173
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3173
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 3173
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 3176
  if (conf->upstream.cache_revalidate == -1L) {
#line 3176
    if (prev->upstream.cache_revalidate == -1L) {
#line 3176
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 3176
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 3179
  if (conf->upstream.cache_convert_head == -1L) {
#line 3179
    if (prev->upstream.cache_convert_head == -1L) {
#line 3179
      conf->upstream.cache_convert_head = (ngx_flag_t )1;
    } else {
#line 3179
      conf->upstream.cache_convert_head = prev->upstream.cache_convert_head;
    }
  }
#line 3182
  if (conf->upstream.cache_background_update == -1L) {
#line 3182
    if (prev->upstream.cache_background_update == -1L) {
#line 3182
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 3182
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 3187
  if ((unsigned long )conf->method == (unsigned long )((void *)0)) {
#line 3188
    conf->method = prev->method;
  }
#line 3191
  if (conf->upstream.pass_request_headers == -1L) {
#line 3191
    if (prev->upstream.pass_request_headers == -1L) {
#line 3191
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 3191
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 3193
  if (conf->upstream.pass_request_body == -1L) {
#line 3193
    if (prev->upstream.pass_request_body == -1L) {
#line 3193
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 3193
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 3196
  if (conf->upstream.intercept_errors == -1L) {
#line 3196
    if (prev->upstream.intercept_errors == -1L) {
#line 3196
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 3196
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
#line 3237
  if (conf->redirect == -1L) {
#line 3237
    if (prev->redirect == -1L) {
#line 3237
      conf->redirect = (ngx_flag_t )1;
    } else {
#line 3237
      conf->redirect = prev->redirect;
    }
  }
#line 3239
  if (conf->redirect) {
#line 3241
    if ((unsigned long )conf->redirects == (unsigned long )((void *)0)) {
#line 3242
      conf->redirects = prev->redirects;
    }
#line 3245
    if ((unsigned long )conf->redirects == (unsigned long )((void *)0)) {
#line 3245
      if (conf->url.data) {
        {
#line 3247
        conf->redirects = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
        }
#line 3249
        if ((unsigned long )conf->redirects == (unsigned long )((void *)0)) {
#line 3250
          return ((char *)((void *)-1));
        }
        {
#line 3253
        tmp___0 = ngx_array_push(conf->redirects);
#line 3253
        pr = (ngx_http_proxy_rewrite_t *)tmp___0;
        }
#line 3254
        if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 3255
          return ((char *)((void *)-1));
        }
        {
#line 3258
        memset((void *)(& pr->pattern.complex), 0, sizeof(ngx_http_complex_value_t ));
#line 3261
        memset((void *)(& pr->replacement), 0, sizeof(ngx_http_complex_value_t ));
#line 3263
        pr->handler = & ngx_http_proxy_rewrite_complex_handler;
        }
#line 3265
        if (conf->vars.uri.len) {
#line 3266
          pr->pattern.complex.value = conf->url;
#line 3267
          pr->replacement.value = conf->location;
        } else {
          {
#line 3270
          pr->pattern.complex.value.len = (conf->url.len + sizeof("/")) - 1UL;
#line 3273
          tmp___1 = ngx_pnalloc(cf->pool, pr->pattern.complex.value.len);
#line 3273
          p = (u_char *)tmp___1;
          }
#line 3274
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3275
            return ((char *)((void *)-1));
          }
          {
#line 3278
          pr->pattern.complex.value.data = p;
#line 3280
          tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)conf->url.data,
                           conf->url.len);
#line 3280
          p = (u_char *)tmp___2 + conf->url.len;
#line 3281
          *p = (u_char )'/';
#line 3283
          pr->replacement.value.len = sizeof("/") - 1UL;
#line 3283
          pr->replacement.value.data = (u_char *)"/";
          }
        }
      }
    }
  }
#line 3288
  if ((unsigned long )conf->cookie_domains == (unsigned long )((void *)-1)) {
#line 3288
    if ((unsigned long )prev->cookie_domains == (unsigned long )((void *)-1)) {
#line 3288
      conf->cookie_domains = (ngx_array_t *)((void *)0);
    } else {
#line 3288
      conf->cookie_domains = prev->cookie_domains;
    }
  }
#line 3290
  if ((unsigned long )conf->cookie_paths == (unsigned long )((void *)-1)) {
#line 3290
    if ((unsigned long )prev->cookie_paths == (unsigned long )((void *)-1)) {
#line 3290
      conf->cookie_paths = (ngx_array_t *)((void *)0);
    } else {
#line 3290
      conf->cookie_paths = prev->cookie_paths;
    }
  }
#line 3292
  if (conf->http_version == 0xffffffffffffffffUL) {
#line 3292
    if (prev->http_version == 0xffffffffffffffffUL) {
#line 3292
      conf->http_version = (ngx_uint_t )1000;
    } else {
#line 3292
      conf->http_version = prev->http_version;
    }
  }
#line 3295
  if (conf->headers_hash_max_size == 0xffffffffffffffffUL) {
#line 3295
    if (prev->headers_hash_max_size == 0xffffffffffffffffUL) {
#line 3295
      conf->headers_hash_max_size = (ngx_uint_t )512;
    } else {
#line 3295
      conf->headers_hash_max_size = prev->headers_hash_max_size;
    }
  }
#line 3298
  if (conf->headers_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3298
    if (prev->headers_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3298
      conf->headers_hash_bucket_size = (ngx_uint_t )64;
    } else {
#line 3298
      conf->headers_hash_bucket_size = prev->headers_hash_bucket_size;
    }
  }
  {
#line 3301
  conf->headers_hash_bucket_size = (conf->headers_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3304
  hash.max_size = conf->headers_hash_max_size;
#line 3305
  hash.bucket_size = conf->headers_hash_bucket_size;
#line 3306
  hash.name = (char *)"proxy_headers_hash";
#line 3308
  tmp___3 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_proxy_hide_headers, & hash);
  }
#line 3308
  if (tmp___3 != 0L) {
#line 3312
    return ((char *)((void *)-1));
  }
#line 3315
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3317
  if (clcf->noname) {
#line 3317
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3317
      if ((unsigned long )conf->proxy_lengths == (unsigned long )((void *)0)) {
#line 3320
        conf->upstream.upstream = prev->upstream.upstream;
#line 3321
        conf->location = prev->location;
#line 3322
        conf->vars = prev->vars;
#line 3324
        conf->proxy_lengths = prev->proxy_lengths;
#line 3325
        conf->proxy_values = prev->proxy_values;
      }
    }
  }
#line 3332
  if (clcf->lmt_excpt) {
#line 3332
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 3332
      if (conf->upstream.upstream) {
#line 3335
        clcf->handler = & ngx_http_proxy_handler;
      } else
#line 3332
      if (conf->proxy_lengths) {
#line 3335
        clcf->handler = & ngx_http_proxy_handler;
      }
    }
  }
#line 3338
  if ((unsigned long )conf->body_source.data == (unsigned long )((void *)0)) {
#line 3339
    conf->body_flushes = prev->body_flushes;
#line 3340
    conf->body_source = prev->body_source;
#line 3341
    conf->body_lengths = prev->body_lengths;
#line 3342
    conf->body_values = prev->body_values;
  }
#line 3345
  if (conf->body_source.data) {
#line 3345
    if ((unsigned long )conf->body_lengths == (unsigned long )((void *)0)) {
      {
#line 3347
      memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3349
      sc.cf = cf;
#line 3350
      sc.source = & conf->body_source;
#line 3351
      sc.flushes = & conf->body_flushes;
#line 3352
      sc.lengths = & conf->body_lengths;
#line 3353
      sc.values = & conf->body_values;
#line 3354
      sc.complete_lengths = 1U;
#line 3355
      sc.complete_values = 1U;
#line 3357
      tmp___4 = ngx_http_script_compile(& sc);
      }
#line 3357
      if (tmp___4 != 0L) {
#line 3358
        return ((char *)((void *)-1));
      }
    }
  }
#line 3362
  if ((unsigned long )conf->headers_source == (unsigned long )((void *)0)) {
#line 3363
    conf->headers = prev->headers;
#line 3365
    conf->headers_cache = prev->headers_cache;
#line 3367
    conf->headers_source = prev->headers_source;
  }
  {
#line 3370
  rc = ngx_http_proxy_init_headers(cf, conf, & conf->headers, ngx_http_proxy_headers);
  }
#line 3372
  if (rc != 0L) {
#line 3373
    return ((char *)((void *)-1));
  }
#line 3378
  if (conf->upstream.cache) {
    {
#line 3379
    rc = ngx_http_proxy_init_headers(cf, conf, & conf->headers_cache, ngx_http_proxy_cache_headers);
    }
#line 3381
    if (rc != 0L) {
#line 3382
      return ((char *)((void *)-1));
    }
  }
#line 3393
  if ((unsigned long )prev->headers.hash.buckets == (unsigned long )((void *)0)) {
#line 3393
    if ((unsigned long )conf->headers_source == (unsigned long )prev->headers_source) {
#line 3396
      prev->headers = conf->headers;
#line 3398
      prev->headers_cache = conf->headers_cache;
    }
  }
#line 3402
  return ((char *)((void *)0));
}
}
#line 3406 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_init_headers(ngx_conf_t *cf , ngx_http_proxy_loc_conf_t *conf ,
                                             ngx_http_proxy_headers_t *headers , ngx_keyval_t *default_headers ) 
{ 
  u_char *p ;
  size_t___0 size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_array_t headers_names ;
  ngx_array_t headers_merged ;
  ngx_keyval_t *src ;
  ngx_keyval_t *s ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  void *tmp___10 ;
  u_char *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  u_char *tmp___15 ;
  ngx_int_t tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  u_char *tmp___19 ;
  ngx_uint_t tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  ngx_int_t tmp___24 ;

  {
#line 3421
  if (headers->hash.buckets) {
#line 3422
    return ((ngx_int_t )0);
  }
  {
#line 3425
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 3425
  if (tmp != 0L) {
#line 3428
    return ((ngx_int_t )-1);
  }
  {
#line 3431
  tmp___0 = ngx_array_init(& headers_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_keyval_t ));
  }
#line 3431
  if (tmp___0 != 0L) {
#line 3434
    return ((ngx_int_t )-1);
  }
  {
#line 3437
  headers->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t___0 )1);
  }
#line 3438
  if ((unsigned long )headers->lengths == (unsigned long )((void *)0)) {
#line 3439
    return ((ngx_int_t )-1);
  }
  {
#line 3442
  headers->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t___0 )1);
  }
#line 3443
  if ((unsigned long )headers->values == (unsigned long )((void *)0)) {
#line 3444
    return ((ngx_int_t )-1);
  }
#line 3447
  if (conf->headers_source) {
#line 3449
    src = (ngx_keyval_t *)(conf->headers_source)->elts;
#line 3450
    i = (ngx_uint_t )0;
    {
#line 3450
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3450
      if (! (i < (conf->headers_source)->nelts)) {
#line 3450
        goto while_break;
      }
      {
#line 3452
      tmp___1 = ngx_array_push(& headers_merged);
#line 3452
      s = (ngx_keyval_t *)tmp___1;
      }
#line 3453
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3454
        return ((ngx_int_t )-1);
      }
#line 3457
      *s = *(src + i);
#line 3450
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3461
  h = default_headers;
  {
#line 3463
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3463
    if (! h->key.len) {
#line 3463
      goto while_break___0;
    }
#line 3465
    src = (ngx_keyval_t *)headers_merged.elts;
#line 3466
    i = (ngx_uint_t )0;
    {
#line 3466
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3466
      if (! (i < headers_merged.nelts)) {
#line 3466
        goto while_break___1;
      }
      {
#line 3467
      tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
      }
#line 3467
      if (tmp___2 == 0L) {
#line 3468
        goto next;
      }
#line 3466
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3472
    tmp___3 = ngx_array_push(& headers_merged);
#line 3472
    s = (ngx_keyval_t *)tmp___3;
    }
#line 3473
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3474
      return ((ngx_int_t )-1);
    }
#line 3477
    *s = *h;
    next: 
#line 3481
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3485
  src = (ngx_keyval_t *)headers_merged.elts;
#line 3486
  i = (ngx_uint_t )0;
  {
#line 3486
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3486
    if (! (i < headers_merged.nelts)) {
#line 3486
      goto while_break___2;
    }
    {
#line 3488
    tmp___4 = ngx_array_push(& headers_names);
#line 3488
    hk = (ngx_hash_key_t *)tmp___4;
    }
#line 3489
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 3490
      return ((ngx_int_t )-1);
    }
    {
#line 3493
    hk->key = (src + i)->key;
#line 3494
    hk->key_hash = ngx_hash_key_lc((src + i)->key.data, (src + i)->key.len);
#line 3495
    hk->value = (void *)1;
    }
#line 3497
    if ((src + i)->value.len == 0UL) {
#line 3498
      goto __Cont;
    }
    {
#line 3501
    tmp___20 = ngx_http_script_variables_count(& (src + i)->value);
    }
#line 3501
    if (tmp___20 == 0UL) {
      {
#line 3502
      tmp___5 = ngx_array_push_n(headers->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3502
      copy = (ngx_http_script_copy_code_t *)tmp___5;
      }
#line 3504
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3505
        return ((ngx_int_t )-1);
      }
      {
#line 3508
      copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3510
      copy->len = (((((src + i)->key.len + sizeof(": ")) - 1UL) + (src + i)->value.len) + sizeof("\r\n")) - 1UL;
#line 3514
      size = ((((((((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + sizeof(": ")) - 1UL) + (src + i)->value.len) + sizeof("\r\n")) - 1UL) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 3520
      tmp___6 = ngx_array_push_n(headers->values, size);
#line 3520
      copy = (ngx_http_script_copy_code_t *)tmp___6;
      }
#line 3521
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3522
        return ((ngx_int_t )-1);
      }
      {
#line 3525
      copy->code = & ngx_http_script_copy_code;
#line 3526
      copy->len = (((((src + i)->key.len + sizeof(": ")) - 1UL) + (src + i)->value.len) + sizeof("\r\n")) - 1UL;
#line 3529
      p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 3531
      tmp___7 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->key.data,
                       (src + i)->key.len);
#line 3531
      p = (u_char *)tmp___7 + (src + i)->key.len;
#line 3532
      tmp___8 = p;
#line 3532
      p ++;
#line 3532
      *tmp___8 = (u_char )':';
#line 3532
      tmp___9 = p;
#line 3532
      p ++;
#line 3532
      *tmp___9 = (u_char )' ';
#line 3533
      tmp___10 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->value.data,
                        (src + i)->value.len);
#line 3533
      p = (u_char *)tmp___10 + (src + i)->value.len;
#line 3534
      tmp___11 = p;
#line 3534
      p ++;
#line 3534
      *tmp___11 = (u_char )'\r';
#line 3534
      *p = (u_char )'\n';
      }
    } else {
      {
#line 3537
      tmp___12 = ngx_array_push_n(headers->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3537
      copy = (ngx_http_script_copy_code_t *)tmp___12;
      }
#line 3539
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3540
        return ((ngx_int_t )-1);
      }
      {
#line 3543
      copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3545
      copy->len = ((src + i)->key.len + sizeof(": ")) - 1UL;
#line 3548
      size = (((((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + sizeof(": ")) - 1UL) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 3552
      tmp___13 = ngx_array_push_n(headers->values, size);
#line 3552
      copy = (ngx_http_script_copy_code_t *)tmp___13;
      }
#line 3553
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3554
        return ((ngx_int_t )-1);
      }
      {
#line 3557
      copy->code = & ngx_http_script_copy_code;
#line 3558
      copy->len = ((src + i)->key.len + sizeof(": ")) - 1UL;
#line 3560
      p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 3561
      tmp___14 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->key.data,
                        (src + i)->key.len);
#line 3561
      p = (u_char *)tmp___14 + (src + i)->key.len;
#line 3562
      tmp___15 = p;
#line 3562
      p ++;
#line 3562
      *tmp___15 = (u_char )':';
#line 3562
      *p = (u_char )' ';
#line 3565
      memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3567
      sc.cf = cf;
#line 3568
      sc.source = & (src + i)->value;
#line 3569
      sc.flushes = & headers->flushes;
#line 3570
      sc.lengths = & headers->lengths;
#line 3571
      sc.values = & headers->values;
#line 3573
      tmp___16 = ngx_http_script_compile(& sc);
      }
#line 3573
      if (tmp___16 != 0L) {
#line 3574
        return ((ngx_int_t )-1);
      }
      {
#line 3578
      tmp___17 = ngx_array_push_n(headers->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3578
      copy = (ngx_http_script_copy_code_t *)tmp___17;
      }
#line 3580
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3581
        return ((ngx_int_t )-1);
      }
      {
#line 3584
      copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3586
      copy->len = sizeof("\r\n") - 1UL;
#line 3589
      size = ((((sizeof(ngx_http_script_copy_code_t ) + sizeof("\r\n")) - 1UL) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 3593
      tmp___18 = ngx_array_push_n(headers->values, size);
#line 3593
      copy = (ngx_http_script_copy_code_t *)tmp___18;
      }
#line 3594
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3595
        return ((ngx_int_t )-1);
      }
#line 3598
      copy->code = & ngx_http_script_copy_code;
#line 3599
      copy->len = sizeof("\r\n") - 1UL;
#line 3601
      p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 3602
      tmp___19 = p;
#line 3602
      p ++;
#line 3602
      *tmp___19 = (u_char )'\r';
#line 3602
      *p = (u_char )'\n';
    }
    {
#line 3605
    tmp___21 = ngx_array_push_n(headers->lengths, sizeof(uintptr_t ));
#line 3605
    code = (uintptr_t *)tmp___21;
    }
#line 3606
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3607
      return ((ngx_int_t )-1);
    }
    {
#line 3610
    *code = (uintptr_t )((void *)0);
#line 3612
    tmp___22 = ngx_array_push_n(headers->values, sizeof(uintptr_t ));
#line 3612
    code = (uintptr_t *)tmp___22;
    }
#line 3613
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3614
      return ((ngx_int_t )-1);
    }
#line 3617
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 3486
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 3620
  tmp___23 = ngx_array_push_n(headers->lengths, sizeof(uintptr_t ));
#line 3620
  code = (uintptr_t *)tmp___23;
  }
#line 3621
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3622
    return ((ngx_int_t )-1);
  }
  {
#line 3625
  *code = (uintptr_t )((void *)0);
#line 3628
  hash.hash = & headers->hash;
#line 3629
  hash.key = & ngx_hash_key_lc;
#line 3630
  hash.max_size = conf->headers_hash_max_size;
#line 3631
  hash.bucket_size = conf->headers_hash_bucket_size;
#line 3632
  hash.name = (char *)"proxy_headers_hash";
#line 3633
  hash.pool = cf->pool;
#line 3634
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3636
  tmp___24 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 3636
  return (tmp___24);
}
}
#line 3640 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  size_t___0 add ;
  u_short port ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_url_t u ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 3643
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 3653
  if (plcf->upstream.upstream) {
#line 3654
    return ((char *)"is duplicate");
  } else
#line 3653
  if (plcf->proxy_lengths) {
#line 3654
    return ((char *)"is duplicate");
  }
#line 3657
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3659
  clcf->handler = & ngx_http_proxy_handler;
#line 3661
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 3662
    clcf->auto_redirect = 1U;
  }
  {
#line 3665
  value = (ngx_str_t *)(cf->args)->elts;
#line 3667
  url = value + 1;
#line 3669
  n = ngx_http_script_variables_count(url);
  }
#line 3671
  if (n) {
    {
#line 3673
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3675
    sc.cf = cf;
#line 3676
    sc.source = url;
#line 3677
    sc.lengths = & plcf->proxy_lengths;
#line 3678
    sc.values = & plcf->proxy_values;
#line 3679
    sc.variables = n;
#line 3680
    sc.complete_lengths = 1U;
#line 3681
    sc.complete_values = 1U;
#line 3683
    tmp = ngx_http_script_compile(& sc);
    }
#line 3683
    if (tmp != 0L) {
#line 3684
      return ((char *)((void *)-1));
    }
#line 3691
    return ((char *)((void *)0));
  }
  {
#line 3694
  tmp___1 = ngx_strncasecmp(url->data, (u_char *)"http://", (size_t___0 )7);
  }
#line 3694
  if (tmp___1 == 0L) {
#line 3695
    add = (size_t___0 )7;
#line 3696
    port = (u_short )80;
  } else {
    {
#line 3698
    tmp___0 = ngx_strncasecmp(url->data, (u_char *)"https://", (size_t___0 )8);
    }
#line 3698
    if (tmp___0 == 0L) {
      {
#line 3706
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "https protocol requires SSL support");
      }
#line 3708
      return ((char *)((void *)-1));
    } else {
      {
#line 3712
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid URL prefix");
      }
#line 3713
      return ((char *)((void *)-1));
    }
  }
  {
#line 3716
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 3718
  u.url.len = url->len - add;
#line 3719
  u.url.data = url->data + add;
#line 3720
  u.default_port = port;
#line 3721
  u.uri_part = 1U;
#line 3722
  u.no_resolve = 1U;
#line 3724
  plcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 3725
  if ((unsigned long )plcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3726
    return ((char *)((void *)-1));
  }
  {
#line 3729
  plcf->vars.schema.len = add;
#line 3730
  plcf->vars.schema.data = url->data;
#line 3731
  plcf->vars.key_start = plcf->vars.schema;
#line 3733
  ngx_http_proxy_set_vars(& u, & plcf->vars);
#line 3735
  plcf->location = clcf->name;
  }
#line 3737
  if (clcf->named) {
#line 3737
    goto _L;
  } else
#line 3737
  if (clcf->regex) {
#line 3737
    goto _L;
  } else
#line 3737
  if (clcf->noname) {
    _L: /* CIL Label */ 
#line 3743
    if (plcf->vars.uri.len) {
      {
#line 3744
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_pass\" cannot have URI part in location given by regular expression, or inside named location, or inside \"if\" statement, or inside \"limit_except\" block");
      }
#line 3750
      return ((char *)((void *)-1));
    }
#line 3753
    plcf->location.len = (size_t___0 )0;
  }
#line 3756
  plcf->url = *url;
#line 3758
  return ((char *)((void *)0));
}
}
#line 3762 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_redirect(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 3765
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 3772
  if (plcf->redirect == 0L) {
#line 3773
    return ((char *)((void *)0));
  }
#line 3776
  plcf->redirect = (ngx_flag_t )1;
#line 3778
  value = (ngx_str_t *)(cf->args)->elts;
#line 3780
  if ((cf->args)->nelts == 2UL) {
    {
#line 3781
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 3781
    if (tmp == 0) {
#line 3782
      plcf->redirect = (ngx_flag_t )0;
#line 3783
      plcf->redirects = (ngx_array_t *)((void *)0);
#line 3784
      return ((char *)((void *)0));
    }
    {
#line 3787
    tmp___0 = strcmp((char const   *)(value + 1)->data, "false");
    }
#line 3787
    if (tmp___0 == 0) {
      {
#line 3788
      ngx_conf_log_error((ngx_uint_t )4, cf, 0, "invalid parameter \"false\", use \"off\" instead");
#line 3790
      plcf->redirect = (ngx_flag_t )0;
#line 3791
      plcf->redirects = (ngx_array_t *)((void *)0);
      }
#line 3792
      return ((char *)((void *)0));
    }
    {
#line 3795
    tmp___1 = strcmp((char const   *)(value + 1)->data, "default");
    }
#line 3795
    if (tmp___1 != 0) {
      {
#line 3796
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
      }
#line 3798
      return ((char *)((void *)-1));
    }
  }
#line 3802
  if ((unsigned long )plcf->redirects == (unsigned long )((void *)0)) {
    {
#line 3803
    plcf->redirects = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
    }
#line 3805
    if ((unsigned long )plcf->redirects == (unsigned long )((void *)0)) {
#line 3806
      return ((char *)((void *)-1));
    }
  }
  {
#line 3810
  tmp___2 = ngx_array_push(plcf->redirects);
#line 3810
  pr = (ngx_http_proxy_rewrite_t *)tmp___2;
  }
#line 3811
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 3812
    return ((char *)((void *)-1));
  }
  {
#line 3815
  tmp___5 = strcmp((char const   *)(value + 1)->data, "default");
  }
#line 3815
  if (tmp___5 == 0) {
#line 3816
    if (plcf->proxy_lengths) {
      {
#line 3817
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_redirect default\" cannot be used with \"proxy_pass\" directive with variables");
      }
#line 3820
      return ((char *)((void *)-1));
    }
#line 3823
    if ((unsigned long )plcf->url.data == (unsigned long )((void *)0)) {
      {
#line 3824
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_redirect default\" should be placed after the \"proxy_pass\" directive");
      }
#line 3827
      return ((char *)((void *)-1));
    }
    {
#line 3830
    pr->handler = & ngx_http_proxy_rewrite_complex_handler;
#line 3832
    memset((void *)(& pr->pattern.complex), 0, sizeof(ngx_http_complex_value_t ));
#line 3834
    memset((void *)(& pr->replacement), 0, sizeof(ngx_http_complex_value_t ));
    }
#line 3836
    if (plcf->vars.uri.len) {
#line 3837
      pr->pattern.complex.value = plcf->url;
#line 3838
      pr->replacement.value = plcf->location;
    } else {
      {
#line 3841
      pr->pattern.complex.value.len = (plcf->url.len + sizeof("/")) - 1UL;
#line 3843
      tmp___3 = ngx_pnalloc(cf->pool, pr->pattern.complex.value.len);
#line 3843
      p = (u_char *)tmp___3;
      }
#line 3844
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3845
        return ((char *)((void *)-1));
      }
      {
#line 3848
      pr->pattern.complex.value.data = p;
#line 3850
      tmp___4 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)plcf->url.data,
                       plcf->url.len);
#line 3850
      p = (u_char *)tmp___4 + plcf->url.len;
#line 3851
      *p = (u_char )'/';
#line 3853
      pr->replacement.value.len = sizeof("/") - 1UL;
#line 3853
      pr->replacement.value.data = (u_char *)"/";
      }
    }
#line 3856
    return ((char *)((void *)0));
  }
#line 3860
  if ((int )*((value + 1)->data + 0) == 126) {
#line 3861
    ((value + 1)->len) --;
#line 3862
    ((value + 1)->data) ++;
#line 3864
    if ((int )*((value + 1)->data + 0) == 42) {
      {
#line 3865
      ((value + 1)->len) --;
#line 3866
      ((value + 1)->data) ++;
#line 3868
      tmp___6 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )1);
      }
#line 3868
      if (tmp___6 != 0L) {
#line 3869
        return ((char *)((void *)-1));
      }
    } else {
      {
#line 3873
      tmp___7 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )0);
      }
#line 3873
      if (tmp___7 != 0L) {
#line 3874
        return ((char *)((void *)-1));
      }
    }
  } else {
    {
#line 3880
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3882
    ccv.cf = cf;
#line 3883
    ccv.value = value + 1;
#line 3884
    ccv.complex_value = & pr->pattern.complex;
#line 3886
    tmp___8 = ngx_http_compile_complex_value(& ccv);
    }
#line 3886
    if (tmp___8 != 0L) {
#line 3887
      return ((char *)((void *)-1));
    }
#line 3890
    pr->handler = & ngx_http_proxy_rewrite_complex_handler;
  }
  {
#line 3894
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3896
  ccv.cf = cf;
#line 3897
  ccv.value = value + 2;
#line 3898
  ccv.complex_value = & pr->replacement;
#line 3900
  tmp___9 = ngx_http_compile_complex_value(& ccv);
  }
#line 3900
  if (tmp___9 != 0L) {
#line 3901
    return ((char *)((void *)-1));
  }
#line 3904
  return ((char *)((void *)0));
}
}
#line 3908 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cookie_domain(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 3911
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 3917
  if ((unsigned long )plcf->cookie_domains == (unsigned long )((void *)0)) {
#line 3918
    return ((char *)((void *)0));
  }
#line 3921
  value = (ngx_str_t *)(cf->args)->elts;
#line 3923
  if ((cf->args)->nelts == 2UL) {
    {
#line 3925
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 3925
    if (tmp == 0) {
#line 3926
      plcf->cookie_domains = (ngx_array_t *)((void *)0);
#line 3927
      return ((char *)((void *)0));
    }
    {
#line 3930
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
    }
#line 3932
    return ((char *)((void *)-1));
  }
#line 3935
  if ((unsigned long )plcf->cookie_domains == (unsigned long )((void *)-1)) {
    {
#line 3936
    plcf->cookie_domains = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
    }
#line 3938
    if ((unsigned long )plcf->cookie_domains == (unsigned long )((void *)0)) {
#line 3939
      return ((char *)((void *)-1));
    }
  }
  {
#line 3943
  tmp___0 = ngx_array_push(plcf->cookie_domains);
#line 3943
  pr = (ngx_http_proxy_rewrite_t *)tmp___0;
  }
#line 3944
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 3945
    return ((char *)((void *)-1));
  }
#line 3948
  if ((int )*((value + 1)->data + 0) == 126) {
    {
#line 3949
    ((value + 1)->len) --;
#line 3950
    ((value + 1)->data) ++;
#line 3952
    tmp___1 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )1);
    }
#line 3952
    if (tmp___1 != 0L) {
#line 3953
      return ((char *)((void *)-1));
    }
  } else {
#line 3958
    if ((int )*((value + 1)->data + 0) == 46) {
#line 3959
      ((value + 1)->len) --;
#line 3960
      ((value + 1)->data) ++;
    }
    {
#line 3963
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3965
    ccv.cf = cf;
#line 3966
    ccv.value = value + 1;
#line 3967
    ccv.complex_value = & pr->pattern.complex;
#line 3969
    tmp___2 = ngx_http_compile_complex_value(& ccv);
    }
#line 3969
    if (tmp___2 != 0L) {
#line 3970
      return ((char *)((void *)-1));
    }
#line 3973
    pr->handler = & ngx_http_proxy_rewrite_domain_handler;
#line 3975
    if ((int )*((value + 2)->data + 0) == 46) {
#line 3976
      ((value + 2)->len) --;
#line 3977
      ((value + 2)->data) ++;
    }
  }
  {
#line 3981
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3983
  ccv.cf = cf;
#line 3984
  ccv.value = value + 2;
#line 3985
  ccv.complex_value = & pr->replacement;
#line 3987
  tmp___3 = ngx_http_compile_complex_value(& ccv);
  }
#line 3987
  if (tmp___3 != 0L) {
#line 3988
    return ((char *)((void *)-1));
  }
#line 3991
  return ((char *)((void *)0));
}
}
#line 3995 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cookie_path(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 3998
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 4004
  if ((unsigned long )plcf->cookie_paths == (unsigned long )((void *)0)) {
#line 4005
    return ((char *)((void *)0));
  }
#line 4008
  value = (ngx_str_t *)(cf->args)->elts;
#line 4010
  if ((cf->args)->nelts == 2UL) {
    {
#line 4012
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 4012
    if (tmp == 0) {
#line 4013
      plcf->cookie_paths = (ngx_array_t *)((void *)0);
#line 4014
      return ((char *)((void *)0));
    }
    {
#line 4017
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
    }
#line 4019
    return ((char *)((void *)-1));
  }
#line 4022
  if ((unsigned long )plcf->cookie_paths == (unsigned long )((void *)-1)) {
    {
#line 4023
    plcf->cookie_paths = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
    }
#line 4025
    if ((unsigned long )plcf->cookie_paths == (unsigned long )((void *)0)) {
#line 4026
      return ((char *)((void *)-1));
    }
  }
  {
#line 4030
  tmp___0 = ngx_array_push(plcf->cookie_paths);
#line 4030
  pr = (ngx_http_proxy_rewrite_t *)tmp___0;
  }
#line 4031
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 4032
    return ((char *)((void *)-1));
  }
#line 4035
  if ((int )*((value + 1)->data + 0) == 126) {
#line 4036
    ((value + 1)->len) --;
#line 4037
    ((value + 1)->data) ++;
#line 4039
    if ((int )*((value + 1)->data + 0) == 42) {
      {
#line 4040
      ((value + 1)->len) --;
#line 4041
      ((value + 1)->data) ++;
#line 4043
      tmp___1 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )1);
      }
#line 4043
      if (tmp___1 != 0L) {
#line 4044
        return ((char *)((void *)-1));
      }
    } else {
      {
#line 4048
      tmp___2 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )0);
      }
#line 4048
      if (tmp___2 != 0L) {
#line 4049
        return ((char *)((void *)-1));
      }
    }
  } else {
    {
#line 4055
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4057
    ccv.cf = cf;
#line 4058
    ccv.value = value + 1;
#line 4059
    ccv.complex_value = & pr->pattern.complex;
#line 4061
    tmp___3 = ngx_http_compile_complex_value(& ccv);
    }
#line 4061
    if (tmp___3 != 0L) {
#line 4062
      return ((char *)((void *)-1));
    }
#line 4065
    pr->handler = & ngx_http_proxy_rewrite_complex_handler;
  }
  {
#line 4068
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4070
  ccv.cf = cf;
#line 4071
  ccv.value = value + 2;
#line 4072
  ccv.complex_value = & pr->replacement;
#line 4074
  tmp___4 = ngx_http_compile_complex_value(& ccv);
  }
#line 4074
  if (tmp___4 != 0L) {
#line 4075
    return ((char *)((void *)-1));
  }
#line 4078
  return ((char *)((void *)0));
}
}
#line 4082 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf , ngx_http_proxy_rewrite_t *pr ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) 
{ 
  u_char errstr[1024] ;
  ngx_regex_compile_t rc ;

  {
  {
#line 4090
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 4092
  rc.pattern = *regex;
#line 4093
  rc.err.len = (size_t___0 )1024;
#line 4094
  rc.err.data = errstr;
  }
#line 4096
  if (caseless) {
#line 4097
    rc.options = (ngx_int_t )1;
  }
  {
#line 4100
  pr->pattern.regex = ngx_http_regex_compile(cf, & rc);
  }
#line 4101
  if ((unsigned long )pr->pattern.regex == (unsigned long )((void *)0)) {
#line 4102
    return ((ngx_int_t )-1);
  }
#line 4105
  pr->handler = & ngx_http_proxy_rewrite_regex_handler;
#line 4107
  return ((ngx_int_t )0);
}
}
#line 4119 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 4122
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 4127
  if (plcf->upstream.store != -1) {
#line 4128
    return ((char *)"is duplicate");
  }
  {
#line 4131
  value = (ngx_str_t *)(cf->args)->elts;
#line 4133
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4133
  if (tmp == 0) {
#line 4134
    plcf->upstream.store = 0;
#line 4135
    return ((char *)((void *)0));
  }
#line 4139
  if (plcf->upstream.cache > 0) {
#line 4140
    return ((char *)"is incompatible with \"proxy_cache\"");
  }
  {
#line 4144
  plcf->upstream.store = 1;
#line 4146
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 4146
  if (tmp___0 == 0) {
#line 4147
    return ((char *)((void *)0));
  }
  {
#line 4151
  ((value + 1)->len) ++;
#line 4153
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 4155
  sc.cf = cf;
#line 4156
  sc.source = value + 1;
#line 4157
  sc.lengths = & plcf->upstream.store_lengths;
#line 4158
  sc.values = & plcf->upstream.store_values;
#line 4159
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 4160
  sc.complete_lengths = 1U;
#line 4161
  sc.complete_values = 1U;
#line 4163
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 4163
  if (tmp___1 != 0L) {
#line 4164
    return ((char *)((void *)-1));
  }
#line 4167
  return ((char *)((void *)0));
}
}
#line 4173 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
#line 4176
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 4182
  value = (ngx_str_t *)(cf->args)->elts;
#line 4184
  if (plcf->upstream.cache != -1) {
#line 4185
    return ((char *)"is duplicate");
  }
  {
#line 4188
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4188
  if (tmp == 0) {
#line 4189
    plcf->upstream.cache = 0;
#line 4190
    return ((char *)((void *)0));
  }
#line 4193
  if (plcf->upstream.store > 0) {
#line 4194
    return ((char *)"is incompatible with \"proxy_store\"");
  }
  {
#line 4197
  plcf->upstream.cache = 1;
#line 4199
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4201
  ccv.cf = cf;
#line 4202
  ccv.value = value + 1;
#line 4203
  ccv.complex_value = & cv;
#line 4205
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 4205
  if (tmp___0 != 0L) {
#line 4206
    return ((char *)((void *)-1));
  }
#line 4209
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 4211
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 4211
    plcf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 4213
    if ((unsigned long )plcf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 4214
      return ((char *)((void *)-1));
    }
#line 4217
    *(plcf->upstream.cache_value) = cv;
#line 4219
    return ((char *)((void *)0));
  }
  {
#line 4222
  plcf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t___0 )0,
                                                    (void *)(& ngx_http_proxy_module));
  }
#line 4224
  if ((unsigned long )plcf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 4225
    return ((char *)((void *)-1));
  }
#line 4228
  return ((char *)((void *)0));
}
}
#line 4232 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;

  {
#line 4235
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 4240
  value = (ngx_str_t *)(cf->args)->elts;
#line 4242
  if (plcf->cache_key.value.data) {
#line 4243
    return ((char *)"is duplicate");
  }
  {
#line 4246
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4248
  ccv.cf = cf;
#line 4249
  ccv.value = value + 1;
#line 4250
  ccv.complex_value = & plcf->cache_key;
#line 4252
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 4252
  if (tmp != 0L) {
#line 4253
    return ((char *)((void *)-1));
  }
#line 4256
  return ((char *)((void *)0));
}
}
#line 4289 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_lowat_check(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ssize_t *np ;

  {
  {
#line 4305
  np = (ssize_t *)data;
#line 4307
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"proxy_send_lowat\" is not supported, ignored");
#line 4310
  *np = (ssize_t )0;
  }
#line 4314
  return ((char *)((void *)0));
}
}
#line 4395 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_proxy_module.c"
static void ngx_http_proxy_set_vars(ngx_url_t *u , ngx_http_proxy_vars_t *v ) 
{ 


  {
#line 4398
  if (u->family != 1) {
#line 4400
    if (u->no_port) {
#line 4400
      goto _L;
    } else
#line 4400
    if ((int )u->port == (int )u->default_port) {
      _L: /* CIL Label */ 
#line 4402
      v->host_header = u->host;
#line 4404
      if ((int )u->default_port == 80) {
#line 4405
        v->port.len = sizeof("80") - 1UL;
#line 4405
        v->port.data = (u_char *)"80";
      } else {
#line 4408
        v->port.len = sizeof("443") - 1UL;
#line 4408
        v->port.data = (u_char *)"443";
      }
    } else {
#line 4412
      v->host_header.len = (u->host.len + 1UL) + u->port_text.len;
#line 4413
      v->host_header.data = u->host.data;
#line 4414
      v->port = u->port_text;
    }
#line 4417
    v->key_start.len += v->host_header.len;
  } else {
#line 4420
    v->host_header.len = sizeof("localhost") - 1UL;
#line 4420
    v->host_header.data = (u_char *)"localhost";
#line 4421
    v->port.len = (size_t___0 )0;
#line 4421
    v->port.data = (u_char *)((void *)0);
#line 4422
    v->key_start.len += ((sizeof("unix:") - 1UL) + u->host.len) + 1UL;
  }
#line 4425
  v->uri = u->uri;
#line 4426
  return;
}
}
#line 269 "src/core/ngx_conf_file.h"
char *ngx_conf_parse(ngx_conf_t *cf , ngx_str_t *filename ) ;
#line 227 "src/http/ngx_http_script.h"
void *ngx_http_script_start_code(ngx_pool_t *pool , ngx_array_t **codes , size_t___0 size ) ;
#line 229
void *ngx_http_script_add_code(ngx_array_t *codes , size_t___0 size , void *code ) ;
#line 240
void ngx_http_script_regex_start_code(ngx_http_script_engine_t *e ) ;
#line 241
void ngx_http_script_regex_end_code(ngx_http_script_engine_t *e ) ;
#line 243
void ngx_http_script_return_code(ngx_http_script_engine_t *e ) ;
#line 244
void ngx_http_script_break_code(ngx_http_script_engine_t *e ) ;
#line 245
void ngx_http_script_if_code(ngx_http_script_engine_t *e ) ;
#line 246
void ngx_http_script_equal_code(ngx_http_script_engine_t *e ) ;
#line 247
void ngx_http_script_not_equal_code(ngx_http_script_engine_t *e ) ;
#line 248
void ngx_http_script_file_code(ngx_http_script_engine_t *e ) ;
#line 249
void ngx_http_script_complex_value_code(ngx_http_script_engine_t *e ) ;
#line 250
void ngx_http_script_value_code(ngx_http_script_engine_t *e ) ;
#line 251
void ngx_http_script_set_var_code(ngx_http_script_engine_t *e ) ;
#line 252
void ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e ) ;
#line 253
void ngx_http_script_var_code(ngx_http_script_engine_t *e ) ;
#line 544 "src/http/ngx_http_core_module.h"
ngx_uint_t ngx_http_max_module ;
#line 79 "src/http/ngx_http.h"
ngx_int_t ngx_http_add_location(ngx_conf_t *cf , ngx_queue_t **locations , ngx_http_core_loc_conf_t *clcf ) ;
#line 23 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf ) ;
#line 24
static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 26
static ngx_int_t ngx_http_rewrite_init(ngx_conf_t *cf ) ;
#line 27
static char *ngx_http_rewrite(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 28
static char *ngx_http_rewrite_return(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 30
static char *ngx_http_rewrite_break(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 32
static char *ngx_http_rewrite_if(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 34
static char *ngx_http_rewrite_if_condition(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ) ;
#line 36
static char *ngx_http_rewrite_variable(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                       ngx_str_t *value ) ;
#line 38
static char *ngx_http_rewrite_set(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 40
static char *ngx_http_rewrite_value(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                    ngx_str_t *value ) ;
#line 44 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static ngx_command_t ngx_http_rewrite_commands[8]  = 
#line 44
  {      {{sizeof("rewrite") - 1UL, (u_char *)"rewrite"}, (ngx_uint_t )1811939340, & ngx_http_rewrite,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("return") - 1UL,
       (u_char *)"return"}, (ngx_uint_t )1811939334, & ngx_http_rewrite_return, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("break") - 1UL, (u_char *)"break"}, (ngx_uint_t )1811939329, & ngx_http_rewrite_break,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("if") - 1UL,
       (u_char *)"if"}, (ngx_uint_t )201328896, & ngx_http_rewrite_if, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("set") - 1UL, (u_char *)"set"}, (ngx_uint_t )1811939332, & ngx_http_rewrite_set,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("rewrite_log") - 1UL,
       (u_char *)"rewrite_log"}, (ngx_uint_t )1845494272, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_rewrite_loc_conf_t *)0)->log),
      (void *)0}, 
        {{sizeof("uninitialized_variable_warn") - 1UL, (u_char *)"uninitialized_variable_warn"},
      (ngx_uint_t )1845494272, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_rewrite_loc_conf_t *)0)->uninitialized_variable_warn),
      (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 105 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static ngx_http_module_t ngx_http_rewrite_module_ctx  = 
#line 105
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_rewrite_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_rewrite_create_loc_conf,
    & ngx_http_rewrite_merge_loc_conf};
#line 120 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
ngx_module_t ngx_http_rewrite_module  = 
#line 120
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_rewrite_module_ctx),
    ngx_http_rewrite_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 136 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static ngx_int_t ngx_http_rewrite_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t index___0 ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t *e ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_http_rewrite_loc_conf_t *rlcf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 146
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 147
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 148
  index___0 = (ngx_int_t )cmcf->phase_engine.location_rewrite_index;
#line 150
  if (r->phase_handler == index___0) {
#line 150
    if ((unsigned long )r->loc_conf == (unsigned long )(cscf->ctx)->loc_conf) {
#line 152
      return ((ngx_int_t )-5);
    }
  }
#line 155
  rlcf = (ngx_http_rewrite_loc_conf_t *)*(r->loc_conf + ngx_http_rewrite_module.ctx_index);
#line 157
  if ((unsigned long )rlcf->codes == (unsigned long )((void *)0)) {
#line 158
    return ((ngx_int_t )-5);
  }
  {
#line 161
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_script_engine_t ));
#line 161
  e = (ngx_http_script_engine_t *)tmp;
  }
#line 162
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 163
    return ((ngx_int_t )500);
  }
  {
#line 166
  tmp___0 = ngx_pcalloc(r->pool, rlcf->stack_size * sizeof(ngx_http_variable_value_t ));
#line 166
  e->sp = (ngx_http_variable_value_t *)tmp___0;
  }
#line 168
  if ((unsigned long )e->sp == (unsigned long )((void *)0)) {
#line 169
    return ((ngx_int_t )500);
  }
#line 172
  e->ip = (u_char *)(rlcf->codes)->elts;
#line 173
  e->request = r;
#line 174
  e->quote = 1U;
#line 175
  e->log = (unsigned int )rlcf->log;
#line 176
  e->status = (ngx_int_t )-5;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! *((uintptr_t *)e->ip)) {
#line 178
      goto while_break;
    }
    {
#line 179
    code = *((ngx_http_script_code_pt *)e->ip);
#line 180
    (*code)(e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (e->status < 400L) {
#line 184
    return (e->status);
  }
#line 187
  if (r->err_status == 0UL) {
#line 188
    return (e->status);
  }
#line 191
  return ((ngx_int_t )r->err_status);
}
}
#line 195 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static ngx_int_t ngx_http_rewrite_var(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                      uintptr_t data ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_http_rewrite_loc_conf_t *rlcf ;

  {
#line 203
  rlcf = (ngx_http_rewrite_loc_conf_t *)*(r->loc_conf + ngx_http_rewrite_module.ctx_index);
#line 205
  if (rlcf->uninitialized_variable_warn == 0L) {
#line 206
    *v = ngx_http_variable_null_value;
#line 207
    return ((ngx_int_t )0);
  }
#line 210
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 212
  var = (ngx_http_variable_t *)cmcf->variables.elts;
#line 220
  if (((r->connection)->log)->log_level >= 5UL) {
    {
#line 220
    ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "using uninitialized \"%V\" variable",
                       & (var + data)->name);
    }
  }
#line 223
  *v = ngx_http_variable_null_value;
#line 225
  return ((ngx_int_t )0);
}
}
#line 229 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_rewrite_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 234
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_rewrite_loc_conf_t ));
#line 234
  conf = (ngx_http_rewrite_loc_conf_t *)tmp;
  }
#line 235
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 236
    return ((void *)0);
  }
#line 239
  conf->stack_size = (ngx_uint_t )-1;
#line 240
  conf->log = (ngx_flag_t )-1;
#line 241
  conf->uninitialized_variable_warn = (ngx_flag_t )-1;
#line 243
  return ((void *)conf);
}
}
#line 247 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_rewrite_loc_conf_t *prev ;
  ngx_http_rewrite_loc_conf_t *conf ;
  uintptr_t *code ;
  void *tmp ;

  {
#line 250
  prev = (ngx_http_rewrite_loc_conf_t *)parent;
#line 251
  conf = (ngx_http_rewrite_loc_conf_t *)child;
#line 255
  if (conf->log == -1L) {
#line 255
    if (prev->log == -1L) {
#line 255
      conf->log = (ngx_flag_t )0;
    } else {
#line 255
      conf->log = prev->log;
    }
  }
#line 256
  if (conf->uninitialized_variable_warn == -1L) {
#line 256
    if (prev->uninitialized_variable_warn == -1L) {
#line 256
      conf->uninitialized_variable_warn = (ngx_flag_t )1;
    } else {
#line 256
      conf->uninitialized_variable_warn = prev->uninitialized_variable_warn;
    }
  }
#line 258
  if (conf->stack_size == 0xffffffffffffffffUL) {
#line 258
    if (prev->stack_size == 0xffffffffffffffffUL) {
#line 258
      conf->stack_size = (ngx_uint_t )10;
    } else {
#line 258
      conf->stack_size = prev->stack_size;
    }
  }
#line 260
  if ((unsigned long )conf->codes == (unsigned long )((void *)0)) {
#line 261
    return ((char *)((void *)0));
  }
#line 264
  if ((unsigned long )conf->codes == (unsigned long )prev->codes) {
#line 265
    return ((char *)((void *)0));
  }
  {
#line 268
  tmp = ngx_array_push_n(conf->codes, sizeof(uintptr_t ));
#line 268
  code = (uintptr_t *)tmp;
  }
#line 269
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 270
    return ((char *)((void *)-1));
  }
#line 273
  *code = (uintptr_t )((void *)0);
#line 275
  return ((char *)((void *)0));
}
}
#line 279 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static ngx_int_t ngx_http_rewrite_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 285
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 287
  tmp = ngx_array_push(& cmcf->phases[1].handlers);
#line 287
  h = (ngx_http_handler_pt *)tmp;
  }
#line 288
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 289
    return ((ngx_int_t )-1);
  }
  {
#line 292
  *h = & ngx_http_rewrite_handler;
#line 294
  tmp___0 = ngx_array_push(& cmcf->phases[3].handlers);
#line 294
  h = (ngx_http_handler_pt *)tmp___0;
  }
#line 295
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 296
    return ((ngx_int_t )-1);
  }
#line 299
  *h = & ngx_http_rewrite_handler;
#line 301
  return ((ngx_int_t )0);
}
}
#line 305 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  ngx_str_t *value ;
  ngx_uint_t last ;
  ngx_regex_compile_t rc ;
  ngx_http_script_code_pt *code ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_regex_code_t *regex ;
  ngx_http_script_regex_end_code_t *regex_end ;
  u_char errstr[1024] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 308
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 319
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_regex_code_t ));
#line 319
  regex = (ngx_http_script_regex_code_t *)tmp;
  }
#line 321
  if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 322
    return ((char *)((void *)-1));
  }
  {
#line 325
  memset((void *)regex, 0, sizeof(ngx_http_script_regex_code_t ));
#line 327
  value = (ngx_str_t *)(cf->args)->elts;
#line 329
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 331
  rc.pattern = *(value + 1);
#line 332
  rc.err.len = (size_t___0 )1024;
#line 333
  rc.err.data = errstr;
#line 337
  regex->regex = ngx_http_regex_compile(cf, & rc);
  }
#line 338
  if ((unsigned long )regex->regex == (unsigned long )((void *)0)) {
#line 339
    return ((char *)((void *)-1));
  }
#line 342
  regex->code = & ngx_http_script_regex_start_code;
#line 343
  regex->uri = 1U;
#line 344
  regex->name = *(value + 1);
#line 346
  if ((int )*((value + 2)->data + ((value + 2)->len - 1UL)) == 63) {
#line 349
    ((value + 2)->len) --;
  } else {
#line 352
    regex->add_args = 1U;
  }
  {
#line 355
  last = (ngx_uint_t )0;
#line 357
  tmp___0 = strncmp((char const   *)(value + 2)->data, "http://", sizeof("http://") - 1UL);
  }
#line 357
  if (tmp___0 == 0) {
#line 361
    regex->status = (uintptr_t )302;
#line 362
    regex->redirect = 1U;
#line 363
    last = (ngx_uint_t )1;
  } else {
    {
#line 357
    tmp___1 = strncmp((char const   *)(value + 2)->data, "https://", sizeof("https://") - 1UL);
    }
#line 357
    if (tmp___1 == 0) {
#line 361
      regex->status = (uintptr_t )302;
#line 362
      regex->redirect = 1U;
#line 363
      last = (ngx_uint_t )1;
    } else {
      {
#line 357
      tmp___2 = strncmp((char const   *)(value + 2)->data, "$scheme", sizeof("$scheme") - 1UL);
      }
#line 357
      if (tmp___2 == 0) {
#line 361
        regex->status = (uintptr_t )302;
#line 362
        regex->redirect = 1U;
#line 363
        last = (ngx_uint_t )1;
      }
    }
  }
#line 366
  if ((cf->args)->nelts == 4UL) {
    {
#line 367
    tmp___6 = strcmp((char const   *)(value + 3)->data, "last");
    }
#line 367
    if (tmp___6 == 0) {
#line 368
      last = (ngx_uint_t )1;
    } else {
      {
#line 370
      tmp___5 = strcmp((char const   *)(value + 3)->data, "break");
      }
#line 370
      if (tmp___5 == 0) {
#line 371
        regex->break_cycle = 1U;
#line 372
        last = (ngx_uint_t )1;
      } else {
        {
#line 374
        tmp___4 = strcmp((char const   *)(value + 3)->data, "redirect");
        }
#line 374
        if (tmp___4 == 0) {
#line 375
          regex->status = (uintptr_t )302;
#line 376
          regex->redirect = 1U;
#line 377
          last = (ngx_uint_t )1;
        } else {
          {
#line 379
          tmp___3 = strcmp((char const   *)(value + 3)->data, "permanent");
          }
#line 379
          if (tmp___3 == 0) {
#line 380
            regex->status = (uintptr_t )301;
#line 381
            regex->redirect = 1U;
#line 382
            last = (ngx_uint_t )1;
          } else {
            {
#line 385
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"",
                               value + 3);
            }
#line 387
            return ((char *)((void *)-1));
          }
        }
      }
    }
  }
  {
#line 391
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 393
  sc.cf = cf;
#line 394
  sc.source = value + 2;
#line 395
  sc.lengths = & regex->lengths;
#line 396
  sc.values = & lcf->codes;
#line 397
  sc.variables = ngx_http_script_variables_count(value + 2);
#line 398
  sc.main = (void *)regex;
#line 399
  sc.complete_lengths = 1U;
#line 400
  sc.compile_args = (unsigned int )(! regex->redirect);
#line 402
  tmp___7 = ngx_http_script_compile(& sc);
  }
#line 402
  if (tmp___7 != 0L) {
#line 403
    return ((char *)((void *)-1));
  }
#line 406
  regex = (ngx_http_script_regex_code_t *)sc.main;
#line 408
  regex->size = sc.size;
#line 409
  regex->args = sc.args;
#line 411
  if (sc.variables == 0UL) {
#line 411
    if (! sc.dup_capture) {
#line 412
      regex->lengths = (ngx_array_t *)((void *)0);
    }
  }
  {
#line 415
  tmp___8 = ngx_http_script_add_code(lcf->codes, sizeof(ngx_http_script_regex_end_code_t ),
                                     (void *)(& regex));
#line 415
  regex_end = (ngx_http_script_regex_end_code_t *)tmp___8;
  }
#line 418
  if ((unsigned long )regex_end == (unsigned long )((void *)0)) {
#line 419
    return ((char *)((void *)-1));
  }
#line 422
  regex_end->code = & ngx_http_script_regex_end_code;
#line 423
  regex_end->uri = regex->uri;
#line 424
  regex_end->args = regex->args;
#line 425
  regex_end->add_args = regex->add_args;
#line 426
  regex_end->redirect = regex->redirect;
#line 428
  if (last) {
    {
#line 429
    tmp___9 = ngx_http_script_add_code(lcf->codes, sizeof(uintptr_t ), (void *)(& regex));
#line 429
    code = (ngx_http_script_code_pt *)tmp___9;
    }
#line 430
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 431
      return ((char *)((void *)-1));
    }
#line 434
    *code = (ngx_http_script_code_pt )((void *)0);
  }
#line 437
  regex->next = (uintptr_t )(((u_char *)(lcf->codes)->elts + (lcf->codes)->nelts) - (u_char *)regex);
#line 440
  return ((char *)((void *)0));
}
}
#line 444 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_return(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_str_t *v ;
  ngx_http_script_return_code_t *ret ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;

  {
  {
#line 447
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 454
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_return_code_t ));
#line 454
  ret = (ngx_http_script_return_code_t *)tmp;
  }
#line 456
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 457
    return ((char *)((void *)-1));
  }
  {
#line 460
  value = (ngx_str_t *)(cf->args)->elts;
#line 462
  memset((void *)ret, 0, sizeof(ngx_http_script_return_code_t ));
#line 464
  ret->code = & ngx_http_script_return_code;
#line 466
  p = (value + 1)->data;
#line 468
  tmp___0 = ngx_atoi(p, (value + 1)->len);
#line 468
  ret->status = (uintptr_t )tmp___0;
  }
#line 470
  if (ret->status == 0xffffffffffffffffUL) {
#line 472
    if ((cf->args)->nelts == 2UL) {
      {
#line 472
      tmp___1 = strncmp((char const   *)p, "http://", sizeof("http://") - 1UL);
      }
#line 472
      if (tmp___1 == 0) {
#line 477
        ret->status = (uintptr_t )302;
#line 478
        v = value + 1;
      } else {
        {
#line 472
        tmp___2 = strncmp((char const   *)p, "https://", sizeof("https://") - 1UL);
        }
#line 472
        if (tmp___2 == 0) {
#line 477
          ret->status = (uintptr_t )302;
#line 478
          v = value + 1;
        } else {
          {
#line 472
          tmp___3 = strncmp((char const   *)p, "$scheme", sizeof("$scheme") - 1UL);
          }
#line 472
          if (tmp___3 == 0) {
#line 477
            ret->status = (uintptr_t )302;
#line 478
            v = value + 1;
          } else {
            {
#line 481
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid return code \"%V\"",
                               value + 1);
            }
#line 483
            return ((char *)((void *)-1));
          }
        }
      }
    } else {
      {
#line 481
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid return code \"%V\"", value + 1);
      }
#line 483
      return ((char *)((void *)-1));
    }
  } else {
#line 488
    if (ret->status > 999UL) {
      {
#line 489
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid return code \"%V\"", value + 1);
      }
#line 491
      return ((char *)((void *)-1));
    }
#line 494
    if ((cf->args)->nelts == 2UL) {
#line 495
      return ((char *)((void *)0));
    }
#line 498
    v = value + 2;
  }
  {
#line 501
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 503
  ccv.cf = cf;
#line 504
  ccv.value = v;
#line 505
  ccv.complex_value = & ret->text;
#line 507
  tmp___4 = ngx_http_compile_complex_value(& ccv);
  }
#line 507
  if (tmp___4 != 0L) {
#line 508
    return ((char *)((void *)-1));
  }
#line 511
  return ((char *)((void *)0));
}
}
#line 515 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_break(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  ngx_http_script_code_pt *code ;
  void *tmp ;

  {
  {
#line 518
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 522
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(uintptr_t ));
#line 522
  code = (ngx_http_script_code_pt *)tmp;
  }
#line 523
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 524
    return ((char *)((void *)-1));
  }
#line 527
  *code = & ngx_http_script_break_code;
#line 529
  return ((char *)((void *)0));
}
}
#line 533 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_if(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  void *mconf ;
  char *rv ;
  u_char *elts ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *pctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_loc_conf_t *pclcf ;
  ngx_http_script_if_code_t *if_code ;
  ngx_http_rewrite_loc_conf_t *nlcf ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 536
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 549
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 549
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 550
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 551
    return ((char *)((void *)-1));
  }
  {
#line 554
  pctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 555
  ctx->main_conf = pctx->main_conf;
#line 556
  ctx->srv_conf = pctx->srv_conf;
#line 558
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 558
  ctx->loc_conf = (void **)tmp___0;
  }
#line 559
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 560
    return ((char *)((void *)-1));
  }
#line 563
  i = (ngx_uint_t )0;
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! *((cf->cycle)->modules + i)) {
#line 563
      goto while_break;
    }
#line 564
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 565
      goto __Cont;
    }
#line 568
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 570
    if (module->create_loc_conf) {
      {
#line 572
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 573
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 574
        return ((char *)((void *)-1));
      }
#line 577
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
    __Cont: /* CIL Label */ 
#line 563
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  pclcf = (ngx_http_core_loc_conf_t *)*(pctx->loc_conf + ngx_http_core_module.ctx_index);
#line 583
  clcf = (ngx_http_core_loc_conf_t *)*(ctx->loc_conf + ngx_http_core_module.ctx_index);
#line 584
  clcf->loc_conf = ctx->loc_conf;
#line 585
  clcf->name = pclcf->name;
#line 586
  clcf->noname = 1U;
#line 588
  tmp___1 = ngx_http_add_location(cf, & pclcf->locations, clcf);
  }
#line 588
  if (tmp___1 != 0L) {
#line 589
    return ((char *)((void *)-1));
  }
  {
#line 592
  tmp___2 = ngx_http_rewrite_if_condition(cf, lcf);
  }
#line 592
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 593
    return ((char *)((void *)-1));
  }
  {
#line 596
  tmp___3 = ngx_array_push_n(lcf->codes, sizeof(ngx_http_script_if_code_t ));
#line 596
  if_code = (ngx_http_script_if_code_t *)tmp___3;
  }
#line 597
  if ((unsigned long )if_code == (unsigned long )((void *)0)) {
#line 598
    return ((char *)((void *)-1));
  }
#line 601
  if_code->code = & ngx_http_script_if_code;
#line 603
  elts = (u_char *)(lcf->codes)->elts;
#line 608
  nlcf = (ngx_http_rewrite_loc_conf_t *)*(ctx->loc_conf + ngx_http_rewrite_module.ctx_index);
#line 609
  nlcf->codes = lcf->codes;
#line 612
  save = *cf;
#line 613
  cf->ctx = (void *)ctx;
#line 615
  if (cf->cmd_type == 67108864UL) {
#line 616
    if_code->loc_conf = (void **)((void *)0);
#line 617
    cf->cmd_type = (ngx_uint_t )536870912;
  } else {
#line 620
    if_code->loc_conf = ctx->loc_conf;
#line 621
    cf->cmd_type = (ngx_uint_t )1073741824;
  }
  {
#line 624
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 626
  *cf = save;
  }
#line 628
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 629
    return (rv);
  }
#line 633
  if ((unsigned long )elts != (unsigned long )(lcf->codes)->elts) {
#line 634
    if_code = (ngx_http_script_if_code_t *)((u_char *)if_code + ((u_char *)(lcf->codes)->elts - elts));
  }
#line 638
  if_code->next = (uintptr_t )(((u_char *)(lcf->codes)->elts + (lcf->codes)->nelts) - (u_char *)if_code);
#line 643
  nlcf->codes = (ngx_array_t *)((void *)0);
#line 645
  return ((char *)((void *)0));
}
}
#line 649 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_if_condition(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_str_t *value ;
  ngx_uint_t cur ;
  ngx_uint_t last ;
  ngx_regex_compile_t rc ;
  ngx_http_script_code_pt *code ;
  ngx_http_script_file_code_t *fop ;
  ngx_http_script_regex_code_t *regex ;
  u_char errstr[1024] ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;

  {
#line 662
  value = (ngx_str_t *)(cf->args)->elts;
#line 663
  last = (cf->args)->nelts - 1UL;
#line 665
  if ((value + 1)->len < 1UL) {
    {
#line 666
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + 1);
    }
#line 668
    return ((char *)((void *)-1));
  } else
#line 665
  if ((int )*((value + 1)->data + 0) != 40) {
    {
#line 666
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + 1);
    }
#line 668
    return ((char *)((void *)-1));
  }
#line 671
  if ((value + 1)->len == 1UL) {
#line 672
    cur = (ngx_uint_t )2;
  } else {
#line 675
    cur = (ngx_uint_t )1;
#line 676
    ((value + 1)->len) --;
#line 677
    ((value + 1)->data) ++;
  }
#line 680
  if ((value + last)->len < 1UL) {
    {
#line 681
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + last);
    }
#line 683
    return ((char *)((void *)-1));
  } else
#line 680
  if ((int )*((value + last)->data + ((value + last)->len - 1UL)) != 41) {
    {
#line 681
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + last);
    }
#line 683
    return ((char *)((void *)-1));
  }
#line 686
  if ((value + last)->len == 1UL) {
#line 687
    last --;
  } else {
#line 690
    ((value + last)->len) --;
#line 691
    *((value + last)->data + (value + last)->len) = (u_char )'\000';
  }
#line 694
  len = (value + cur)->len;
#line 695
  p = (value + cur)->data;
#line 697
  if (len > 1UL) {
#line 697
    if ((int )*(p + 0) == 36) {
#line 699
      if (cur != last) {
#line 699
        if (cur + 2UL != last) {
          {
#line 700
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
          }
#line 702
          return ((char *)((void *)-1));
        }
      }
      {
#line 705
      tmp = ngx_http_rewrite_variable(cf, lcf, value + cur);
      }
#line 705
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 706
        return ((char *)((void *)-1));
      }
#line 709
      if (cur == last) {
#line 710
        return ((char *)((void *)0));
      }
#line 713
      cur ++;
#line 715
      len = (value + cur)->len;
#line 716
      p = (value + cur)->data;
#line 718
      if (len == 1UL) {
#line 718
        if ((int )*(p + 0) == 61) {
          {
#line 720
          tmp___0 = ngx_http_rewrite_value(cf, lcf, value + last);
          }
#line 720
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 721
            return ((char *)((void *)-1));
          }
          {
#line 724
          tmp___1 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(uintptr_t ));
#line 724
          code = (ngx_http_script_code_pt *)tmp___1;
          }
#line 726
          if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 727
            return ((char *)((void *)-1));
          }
#line 730
          *code = & ngx_http_script_equal_code;
#line 732
          return ((char *)((void *)0));
        }
      }
#line 735
      if (len == 2UL) {
#line 735
        if ((int )*(p + 0) == 33) {
#line 735
          if ((int )*(p + 1) == 61) {
            {
#line 737
            tmp___2 = ngx_http_rewrite_value(cf, lcf, value + last);
            }
#line 737
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 738
              return ((char *)((void *)-1));
            }
            {
#line 741
            tmp___3 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(uintptr_t ));
#line 741
            code = (ngx_http_script_code_pt *)tmp___3;
            }
#line 743
            if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 744
              return ((char *)((void *)-1));
            }
#line 747
            *code = & ngx_http_script_not_equal_code;
#line 748
            return ((char *)((void *)0));
          }
        }
      }
#line 751
      if (len == 1UL) {
#line 751
        if ((int )*(p + 0) == 126) {
#line 751
          goto _L;
        } else {
#line 751
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 751
      if (len == 2UL) {
#line 751
        if ((int )*(p + 0) == 126) {
#line 751
          if ((int )*(p + 1) == 42) {
#line 751
            goto _L;
          } else {
#line 751
            goto _L___3;
          }
        } else {
#line 751
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 751
      if (len == 2UL) {
#line 751
        if ((int )*(p + 0) == 33) {
#line 751
          if ((int )*(p + 1) == 126) {
#line 751
            goto _L;
          } else {
#line 751
            goto _L___1;
          }
        } else {
#line 751
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 751
      if (len == 3UL) {
#line 751
        if ((int )*(p + 0) == 33) {
#line 751
          if ((int )*(p + 1) == 126) {
#line 751
            if ((int )*(p + 2) == 42) {
              _L: /* CIL Label */ 
              {
#line 756
              tmp___4 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_regex_code_t ));
#line 756
              regex = (ngx_http_script_regex_code_t *)tmp___4;
              }
#line 758
              if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 759
                return ((char *)((void *)-1));
              }
              {
#line 762
              memset((void *)regex, 0, sizeof(ngx_http_script_regex_code_t ));
#line 764
              memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 766
              rc.pattern = *(value + last);
              }
#line 767
              if ((int )*(p + (len - 1UL)) == 42) {
#line 767
                rc.options = (ngx_int_t )1;
              } else {
#line 767
                rc.options = (ngx_int_t )0;
              }
              {
#line 768
              rc.err.len = (size_t___0 )1024;
#line 769
              rc.err.data = errstr;
#line 771
              regex->regex = ngx_http_regex_compile(cf, & rc);
              }
#line 772
              if ((unsigned long )regex->regex == (unsigned long )((void *)0)) {
#line 773
                return ((char *)((void *)-1));
              }
#line 776
              regex->code = & ngx_http_script_regex_start_code;
#line 777
              regex->next = sizeof(ngx_http_script_regex_code_t );
#line 778
              regex->test = 1U;
#line 779
              if ((int )*(p + 0) == 33) {
#line 780
                regex->negative_test = 1U;
              }
#line 782
              regex->name = *(value + last);
#line 784
              return ((char *)((void *)0));
            }
          }
        }
      }
      {
#line 787
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"%V\" in condition",
                         value + cur);
      }
#line 789
      return ((char *)((void *)-1));
    } else {
#line 697
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 791
  if (len == 2UL) {
#line 791
    if ((int )*(p + 0) == 45) {
#line 791
      goto _L___5;
    } else {
#line 791
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 791
  if (len == 3UL) {
#line 791
    if ((int )*(p + 0) == 33) {
#line 791
      if ((int )*(p + 1) == 45) {
        _L___5: /* CIL Label */ 
#line 794
        if (cur + 1UL != last) {
          {
#line 795
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
          }
#line 797
          return ((char *)((void *)-1));
        }
        {
#line 800
        *((value + last)->data + (value + last)->len) = (u_char )'\000';
#line 801
        ((value + last)->len) ++;
#line 803
        tmp___5 = ngx_http_rewrite_value(cf, lcf, value + last);
        }
#line 803
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 804
          return ((char *)((void *)-1));
        }
        {
#line 807
        tmp___6 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_file_code_t ));
#line 807
        fop = (ngx_http_script_file_code_t *)tmp___6;
        }
#line 809
        if ((unsigned long )fop == (unsigned long )((void *)0)) {
#line 810
          return ((char *)((void *)-1));
        }
#line 813
        fop->code = & ngx_http_script_file_code;
#line 815
        if ((int )*(p + 1) == 102) {
#line 816
          fop->op = (uintptr_t )0;
#line 817
          return ((char *)((void *)0));
        }
#line 820
        if ((int )*(p + 1) == 100) {
#line 821
          fop->op = (uintptr_t )2;
#line 822
          return ((char *)((void *)0));
        }
#line 825
        if ((int )*(p + 1) == 101) {
#line 826
          fop->op = (uintptr_t )4;
#line 827
          return ((char *)((void *)0));
        }
#line 830
        if ((int )*(p + 1) == 120) {
#line 831
          fop->op = (uintptr_t )6;
#line 832
          return ((char *)((void *)0));
        }
#line 835
        if ((int )*(p + 0) == 33) {
#line 836
          if ((int )*(p + 2) == 102) {
#line 837
            fop->op = (uintptr_t )1;
#line 838
            return ((char *)((void *)0));
          }
#line 841
          if ((int )*(p + 2) == 100) {
#line 842
            fop->op = (uintptr_t )3;
#line 843
            return ((char *)((void *)0));
          }
#line 846
          if ((int )*(p + 2) == 101) {
#line 847
            fop->op = (uintptr_t )5;
#line 848
            return ((char *)((void *)0));
          }
#line 851
          if ((int )*(p + 2) == 120) {
#line 852
            fop->op = (uintptr_t )7;
#line 853
            return ((char *)((void *)0));
          }
        }
        {
#line 857
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
        }
#line 859
        return ((char *)((void *)-1));
      }
    }
  }
  {
#line 862
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
  }
#line 865
  return ((char *)((void *)-1));
}
}
#line 869 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_variable(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                       ngx_str_t *value ) 
{ 
  ngx_int_t index___0 ;
  ngx_http_script_var_code_t *var_code ;
  void *tmp ;

  {
  {
#line 876
  (value->len) --;
#line 877
  (value->data) ++;
#line 879
  index___0 = ngx_http_get_variable_index(cf, value);
  }
#line 881
  if (index___0 == -1L) {
#line 882
    return ((char *)((void *)-1));
  }
  {
#line 885
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_var_code_t ));
#line 885
  var_code = (ngx_http_script_var_code_t *)tmp;
  }
#line 887
  if ((unsigned long )var_code == (unsigned long )((void *)0)) {
#line 888
    return ((char *)((void *)-1));
  }
#line 891
  var_code->code = & ngx_http_script_var_code;
#line 892
  var_code->index = (uintptr_t )index___0;
#line 894
  return ((char *)((void *)0));
}
}
#line 898 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_set(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  ngx_int_t index___0 ;
  ngx_str_t *value ;
  ngx_http_variable_t *v ;
  ngx_http_script_var_code_t *vcode ;
  ngx_http_script_var_handler_code_t *vhcode ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 901
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 909
  value = (ngx_str_t *)(cf->args)->elts;
#line 911
  if ((int )*((value + 1)->data + 0) != 36) {
    {
#line 912
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", value + 1);
    }
#line 914
    return ((char *)((void *)-1));
  }
  {
#line 917
  ((value + 1)->len) --;
#line 918
  ((value + 1)->data) ++;
#line 920
  v = ngx_http_add_variable(cf, value + 1, (ngx_uint_t )17);
  }
#line 922
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 923
    return ((char *)((void *)-1));
  }
  {
#line 926
  index___0 = ngx_http_get_variable_index(cf, value + 1);
  }
#line 927
  if (index___0 == -1L) {
#line 928
    return ((char *)((void *)-1));
  }
#line 931
  if ((unsigned long )v->get_handler == (unsigned long )((void *)0)) {
#line 932
    v->get_handler = & ngx_http_rewrite_var;
#line 933
    v->data = (uintptr_t )index___0;
  }
  {
#line 936
  tmp = ngx_http_rewrite_value(cf, lcf, value + 2);
  }
#line 936
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 937
    return ((char *)((void *)-1));
  }
#line 940
  if (v->set_handler) {
    {
#line 941
    tmp___0 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_var_handler_code_t ));
#line 941
    vhcode = (ngx_http_script_var_handler_code_t *)tmp___0;
    }
#line 943
    if ((unsigned long )vhcode == (unsigned long )((void *)0)) {
#line 944
      return ((char *)((void *)-1));
    }
#line 947
    vhcode->code = & ngx_http_script_var_set_handler_code;
#line 948
    vhcode->handler = v->set_handler;
#line 949
    vhcode->data = v->data;
#line 951
    return ((char *)((void *)0));
  }
  {
#line 954
  tmp___1 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_var_code_t ));
#line 954
  vcode = (ngx_http_script_var_code_t *)tmp___1;
  }
#line 956
  if ((unsigned long )vcode == (unsigned long )((void *)0)) {
#line 957
    return ((char *)((void *)-1));
  }
#line 960
  vcode->code = & ngx_http_script_set_var_code;
#line 961
  vcode->index = (uintptr_t )index___0;
#line 963
  return ((char *)((void *)0));
}
}
#line 967 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_value(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                    ngx_str_t *value ) 
{ 
  ngx_int_t n ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_value_code_t *val ;
  ngx_http_script_complex_value_code_t *complex ;
  ngx_uint_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 976
  tmp = ngx_http_script_variables_count(value);
#line 976
  n = (ngx_int_t )tmp;
  }
#line 978
  if (n == 0L) {
    {
#line 979
    tmp___0 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_value_code_t ));
#line 979
    val = (ngx_http_script_value_code_t *)tmp___0;
    }
#line 981
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 982
      return ((char *)((void *)-1));
    }
    {
#line 985
    n = ngx_atoi(value->data, value->len);
    }
#line 987
    if (n == -1L) {
#line 988
      n = (ngx_int_t )0;
    }
#line 991
    val->code = & ngx_http_script_value_code;
#line 992
    val->value = (uintptr_t )n;
#line 993
    val->text_len = value->len;
#line 994
    val->text_data = (uintptr_t )value->data;
#line 996
    return ((char *)((void *)0));
  }
  {
#line 999
  tmp___1 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_complex_value_code_t ));
#line 999
  complex = (ngx_http_script_complex_value_code_t *)tmp___1;
  }
#line 1001
  if ((unsigned long )complex == (unsigned long )((void *)0)) {
#line 1002
    return ((char *)((void *)-1));
  }
  {
#line 1005
  complex->code = & ngx_http_script_complex_value_code;
#line 1006
  complex->lengths = (ngx_array_t *)((void *)0);
#line 1008
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1010
  sc.cf = cf;
#line 1011
  sc.source = value;
#line 1012
  sc.lengths = & complex->lengths;
#line 1013
  sc.values = & lcf->codes;
#line 1014
  sc.variables = (ngx_uint_t )n;
#line 1015
  sc.complete_lengths = 1U;
#line 1017
  tmp___2 = ngx_http_script_compile(& sc);
  }
#line 1017
  if (tmp___2 != 0L) {
#line 1018
    return ((char *)((void *)-1));
  }
#line 1021
  return ((char *)((void *)0));
}
}
#line 169 "src/core/ngx_string.h"
ngx_int_t ngx_dns_strcmp(u_char *s1 , u_char *s2 ) ;
#line 103 "src/core/ngx_hash.h"
void *ngx_hash_find_combined(ngx_hash_combined_t *hash , ngx_uint_t key , u_char *name ,
                             size_t___0 len ) ;
#line 108
ngx_int_t ngx_hash_wildcard_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names ,
                                 ngx_uint_t nelts ) ;
#line 117
ngx_int_t ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha , ngx_uint_t type ) ;
#line 118
ngx_int_t ngx_hash_add_key(ngx_hash_keys_arrays_t *ha , ngx_str_t *key , void *value ,
                           ngx_uint_t flags ) ;
#line 57 "src/core/ngx_regex.h"
ngx_int_t ngx_regex_exec_array(ngx_array_t *a , ngx_str_t *s , ngx_log_t *log ) ;
#line 35 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static void *ngx_http_referer_create_conf(ngx_conf_t *cf ) ;
#line 36
static char *ngx_http_referer_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 38
static char *ngx_http_valid_referers(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 40
static ngx_int_t ngx_http_add_referer(ngx_conf_t *cf , ngx_hash_keys_arrays_t *keys ,
                                      ngx_str_t *value , ngx_str_t *uri___0 ) ;
#line 42
static ngx_int_t ngx_http_add_regex_referer(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                            ngx_str_t *name ) ;
#line 45
static ngx_int_t ngx_http_add_regex_server_name(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                                ngx_http_regex_t *regex ) ;
#line 48
static int ngx_http_cmp_referer_wildcards(void const   *one , void const   *two ) ;
#line 52 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static ngx_command_t ngx_http_referer_commands[4]  = {      {{sizeof("valid_referers") - 1UL, (u_char *)"valid_referers"}, (ngx_uint_t )201328640,
      & ngx_http_valid_referers, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("referer_hash_max_size") - 1UL, (u_char *)"referer_hash_max_size"},
      (ngx_uint_t )201326594, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_referer_conf_t *)0)->referer_hash_max_size), (void *)0}, 
        {{sizeof("referer_hash_bucket_size") - 1UL,
       (u_char *)"referer_hash_bucket_size"}, (ngx_uint_t )201326594, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_referer_conf_t *)0)->referer_hash_bucket_size),
      (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 79 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static ngx_http_module_t ngx_http_referer_module_ctx  = 
#line 79
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_referer_create_conf, & ngx_http_referer_merge_conf};
#line 94 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
ngx_module_t ngx_http_referer_module  = 
#line 94
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_referer_module_ctx),
    ngx_http_referer_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 110 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_referer_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  u_char *p ;
  u_char *ref ;
  u_char *last ;
  size_t___0 len ;
  ngx_str_t *uri___0 ;
  ngx_uint_t i ;
  ngx_uint_t key ;
  ngx_http_referer_conf_t *rlcf ;
  u_char buf[256] ;
  ngx_int_t rc ;
  ngx_str_t referer ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_uint_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 125
  rlcf = (ngx_http_referer_conf_t *)*(r->loc_conf + ngx_http_referer_module.ctx_index);
#line 127
  if ((unsigned long )rlcf->hash.hash.buckets == (unsigned long )((void *)0)) {
#line 127
    if ((unsigned long )rlcf->hash.wc_head == (unsigned long )((void *)0)) {
#line 127
      if ((unsigned long )rlcf->hash.wc_tail == (unsigned long )((void *)0)) {
#line 127
        if ((unsigned long )rlcf->regex == (unsigned long )((void *)0)) {
#line 127
          if ((unsigned long )rlcf->server_name_regex == (unsigned long )((void *)0)) {
#line 136
            goto valid;
          }
        }
      }
    }
  }
#line 139
  if ((unsigned long )r->headers_in.referer == (unsigned long )((void *)0)) {
#line 140
    if (rlcf->no_referer) {
#line 141
      goto valid;
    }
#line 144
    goto invalid;
  }
#line 147
  len = (r->headers_in.referer)->value.len;
#line 148
  ref = (r->headers_in.referer)->value.data;
#line 150
  if (len >= sizeof("http://i.ru") - 1UL) {
    {
#line 151
    last = ref + len;
#line 153
    tmp___0 = ngx_strncasecmp(ref, (u_char *)"http://", (size_t___0 )7);
    }
#line 153
    if (tmp___0 == 0L) {
#line 154
      ref += 7;
#line 155
      len -= 7UL;
#line 156
      goto valid_scheme;
    } else {
      {
#line 158
      tmp = ngx_strncasecmp(ref, (u_char *)"https://", (size_t___0 )8);
      }
#line 158
      if (tmp == 0L) {
#line 159
        ref += 8;
#line 160
        len -= 8UL;
#line 161
        goto valid_scheme;
      }
    }
  }
#line 165
  if (rlcf->blocked_referer) {
#line 166
    goto valid;
  }
#line 169
  goto invalid;
  valid_scheme: 
#line 173
  i = (ngx_uint_t )0;
#line 174
  key = (ngx_uint_t )0;
#line 176
  p = ref;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 176
      goto while_break;
    }
#line 177
    if ((int )*p == 47) {
#line 178
      goto while_break;
    } else
#line 177
    if ((int )*p == 58) {
#line 178
      goto while_break;
    }
#line 181
    if (i == 256UL) {
#line 182
      goto invalid;
    }
#line 185
    if ((int )*p >= 65) {
#line 185
      if ((int )*p <= 90) {
#line 185
        tmp___1 = (int )*p | 32;
      } else {
#line 185
        tmp___1 = (int )*p;
      }
    } else {
#line 185
      tmp___1 = (int )*p;
    }
#line 185
    buf[i] = (u_char )tmp___1;
#line 186
    tmp___2 = i;
#line 186
    i ++;
#line 186
    key = key * 31UL + (ngx_uint_t )buf[tmp___2];
#line 176
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  tmp___3 = ngx_hash_find_combined(& rlcf->hash, key, buf, (size_t___0 )(p - ref));
#line 189
  uri___0 = (ngx_str_t *)tmp___3;
  }
#line 191
  if (uri___0) {
#line 192
    goto uri;
  }
#line 197
  if (rlcf->server_name_regex) {
    {
#line 198
    referer.len = (size_t___0 )(p - ref);
#line 199
    referer.data = buf;
#line 201
    rc = ngx_regex_exec_array(rlcf->server_name_regex, & referer, (r->connection)->log);
    }
#line 204
    if (rc == 0L) {
#line 205
      goto valid;
    }
#line 208
    if (rc == -1L) {
#line 209
      return (rc);
    }
  }
#line 215
  if (rlcf->regex) {
    {
#line 216
    referer.len = len;
#line 217
    referer.data = ref;
#line 219
    rc = ngx_regex_exec_array(rlcf->regex, & referer, (r->connection)->log);
    }
#line 221
    if (rc == 0L) {
#line 222
      goto valid;
    }
#line 225
    if (rc == -1L) {
#line 226
      return (rc);
    }
  }
  invalid: 
#line 236
  *v = ngx_http_variable_true_value;
#line 238
  return ((ngx_int_t )0);
  uri: 
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 242
      goto while_break___0;
    }
#line 243
    if ((int )*p == 47) {
#line 244
      goto while_break___0;
    }
#line 242
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 248
  len = (size_t___0 )(last - p);
#line 250
  if ((unsigned long )uri___0 == (unsigned long )((void *)4)) {
#line 251
    goto valid;
  }
#line 254
  if (len < uri___0->len) {
#line 255
    goto invalid;
  } else {
    {
#line 254
    tmp___4 = strncmp((char const   *)uri___0->data, (char const   *)p, uri___0->len);
    }
#line 254
    if (tmp___4 != 0) {
#line 255
      goto invalid;
    }
  }
  valid: 
#line 260
  *v = ngx_http_variable_null_value;
#line 262
  return ((ngx_int_t )0);
}
}
#line 266 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static void *ngx_http_referer_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_referer_conf_t *conf ;
  void *tmp ;

  {
  {
#line 271
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_referer_conf_t ));
#line 271
  conf = (ngx_http_referer_conf_t *)tmp;
  }
#line 272
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 273
    return ((void *)0);
  }
#line 285
  conf->regex = (ngx_array_t *)((void *)-1);
#line 286
  conf->server_name_regex = (ngx_array_t *)((void *)-1);
#line 289
  conf->no_referer = (ngx_flag_t )-1;
#line 290
  conf->blocked_referer = (ngx_flag_t )-1;
#line 291
  conf->referer_hash_max_size = (ngx_uint_t )-1;
#line 292
  conf->referer_hash_bucket_size = (ngx_uint_t )-1;
#line 294
  return ((void *)conf);
}
}
#line 298 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static char *ngx_http_referer_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_referer_conf_t *prev ;
  ngx_http_referer_conf_t *conf ;
  ngx_uint_t n ;
  ngx_hash_init_t hash ;
  ngx_http_server_name_t *sn ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 301
  prev = (ngx_http_referer_conf_t *)parent;
#line 302
  conf = (ngx_http_referer_conf_t *)child;
#line 309
  if ((unsigned long )conf->keys == (unsigned long )((void *)0)) {
#line 310
    conf->hash = prev->hash;
#line 313
    if ((unsigned long )conf->regex == (unsigned long )((void *)-1)) {
#line 313
      if ((unsigned long )prev->regex == (unsigned long )((void *)-1)) {
#line 313
        conf->regex = (ngx_array_t *)((void *)0);
      } else {
#line 313
        conf->regex = prev->regex;
      }
    }
#line 314
    if ((unsigned long )conf->server_name_regex == (unsigned long )((void *)-1)) {
#line 314
      if ((unsigned long )prev->server_name_regex == (unsigned long )((void *)-1)) {
#line 314
        conf->server_name_regex = (ngx_array_t *)((void *)0);
      } else {
#line 314
        conf->server_name_regex = prev->server_name_regex;
      }
    }
#line 317
    if (conf->no_referer == -1L) {
#line 317
      if (prev->no_referer == -1L) {
#line 317
        conf->no_referer = (ngx_flag_t )0;
      } else {
#line 317
        conf->no_referer = prev->no_referer;
      }
    }
#line 318
    if (conf->blocked_referer == -1L) {
#line 318
      if (prev->blocked_referer == -1L) {
#line 318
        conf->blocked_referer = (ngx_flag_t )0;
      } else {
#line 318
        conf->blocked_referer = prev->blocked_referer;
      }
    }
#line 319
    if (conf->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 319
      if (prev->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 319
        conf->referer_hash_max_size = (ngx_uint_t )2048;
      } else {
#line 319
        conf->referer_hash_max_size = prev->referer_hash_max_size;
      }
    }
#line 321
    if (conf->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 321
      if (prev->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 321
        conf->referer_hash_bucket_size = (ngx_uint_t )64;
      } else {
#line 321
        conf->referer_hash_bucket_size = prev->referer_hash_bucket_size;
      }
    }
#line 324
    return ((char *)((void *)0));
  }
#line 327
  if (conf->server_names == 1L) {
#line 328
    cscf = (ngx_http_core_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_core_module.ctx_index);
#line 330
    sn = (ngx_http_server_name_t *)cscf->server_names.elts;
#line 331
    n = (ngx_uint_t )0;
    {
#line 331
    while (1) {
      while_continue: /* CIL Label */ ;
#line 331
      if (! (n < cscf->server_names.nelts)) {
#line 331
        goto while_break;
      }
#line 334
      if ((sn + n)->regex) {
        {
#line 336
        tmp = ngx_http_add_regex_server_name(cf, conf, (sn + n)->regex);
        }
#line 336
        if (tmp != 0L) {
#line 339
          return ((char *)((void *)-1));
        }
#line 342
        goto __Cont;
      }
      {
#line 346
      tmp___0 = ngx_http_add_referer(cf, conf->keys, & (sn + n)->name, (ngx_str_t *)((void *)0));
      }
#line 346
      if (tmp___0 != 0L) {
#line 349
        return ((char *)((void *)-1));
      }
      __Cont: /* CIL Label */ 
#line 331
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 354
  if (conf->no_referer == 1L) {
#line 354
    goto _L;
  } else
#line 354
  if (conf->blocked_referer == 1L) {
    _L: /* CIL Label */ 
#line 354
    if ((conf->keys)->keys.nelts == 0UL) {
#line 354
      if ((conf->keys)->dns_wc_head.nelts == 0UL) {
#line 354
        if ((conf->keys)->dns_wc_tail.nelts == 0UL) {
#line 359
          if ((cf->log)->log_level >= 1UL) {
            {
#line 359
            ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "the \"none\" or \"blocked\" referers are specified in the \"valid_referers\" directive without any valid referer");
            }
          }
#line 363
          return ((char *)((void *)-1));
        }
      }
    }
  }
#line 366
  if (conf->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 366
    if (prev->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 366
      conf->referer_hash_max_size = (ngx_uint_t )2048;
    } else {
#line 366
      conf->referer_hash_max_size = prev->referer_hash_max_size;
    }
  }
#line 368
  if (conf->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 368
    if (prev->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 368
      conf->referer_hash_bucket_size = (ngx_uint_t )64;
    } else {
#line 368
      conf->referer_hash_bucket_size = prev->referer_hash_bucket_size;
    }
  }
#line 370
  conf->referer_hash_bucket_size = (conf->referer_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 373
  hash.key = & ngx_hash_key_lc;
#line 374
  hash.max_size = conf->referer_hash_max_size;
#line 375
  hash.bucket_size = conf->referer_hash_bucket_size;
#line 376
  hash.name = (char *)"referer_hash";
#line 377
  hash.pool = cf->pool;
#line 379
  if ((conf->keys)->keys.nelts) {
    {
#line 380
    hash.hash = & conf->hash.hash;
#line 381
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 383
    tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)(conf->keys)->keys.elts, (conf->keys)->keys.nelts);
    }
#line 383
    if (tmp___1 != 0L) {
#line 386
      return ((char *)((void *)-1));
    }
  }
#line 390
  if ((conf->keys)->dns_wc_head.nelts) {
    {
#line 392
    qsort((conf->keys)->dns_wc_head.elts, (conf->keys)->dns_wc_head.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_cmp_referer_wildcards);
#line 397
    hash.hash = (ngx_hash_t *)((void *)0);
#line 398
    hash.temp_pool = cf->temp_pool;
#line 400
    tmp___2 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)(conf->keys)->dns_wc_head.elts,
                                     (conf->keys)->dns_wc_head.nelts);
    }
#line 400
    if (tmp___2 != 0L) {
#line 404
      return ((char *)((void *)-1));
    }
#line 407
    conf->hash.wc_head = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 410
  if ((conf->keys)->dns_wc_tail.nelts) {
    {
#line 412
    qsort((conf->keys)->dns_wc_tail.elts, (conf->keys)->dns_wc_tail.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_cmp_referer_wildcards);
#line 417
    hash.hash = (ngx_hash_t *)((void *)0);
#line 418
    hash.temp_pool = cf->temp_pool;
#line 420
    tmp___3 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)(conf->keys)->dns_wc_tail.elts,
                                     (conf->keys)->dns_wc_tail.nelts);
    }
#line 420
    if (tmp___3 != 0L) {
#line 424
      return ((char *)((void *)-1));
    }
#line 427
    conf->hash.wc_tail = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 431
  if ((unsigned long )conf->regex == (unsigned long )((void *)-1)) {
#line 431
    if ((unsigned long )prev->regex == (unsigned long )((void *)-1)) {
#line 431
      conf->regex = (ngx_array_t *)((void *)0);
    } else {
#line 431
      conf->regex = prev->regex;
    }
  }
#line 432
  if ((unsigned long )conf->server_name_regex == (unsigned long )((void *)-1)) {
#line 432
    if ((unsigned long )prev->server_name_regex == (unsigned long )((void *)-1)) {
#line 432
      conf->server_name_regex = (ngx_array_t *)((void *)0);
    } else {
#line 432
      conf->server_name_regex = prev->server_name_regex;
    }
  }
#line 436
  if (conf->no_referer == -1L) {
#line 437
    conf->no_referer = (ngx_flag_t )0;
  }
#line 440
  if (conf->blocked_referer == -1L) {
#line 441
    conf->blocked_referer = (ngx_flag_t )0;
  }
#line 444
  conf->keys = (ngx_hash_keys_arrays_t *)((void *)0);
#line 446
  return ((char *)((void *)0));
}
}
#line 450 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static char *ngx_http_valid_referers(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_referer_conf_t *rlcf ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_str_t uri___0 ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_http_variable_t *var ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  char *tmp___5 ;
  ngx_int_t tmp___6 ;

  {
  {
#line 453
  rlcf = (ngx_http_referer_conf_t *)conf;
#line 460
  name.len = sizeof("invalid_referer") - 1UL;
#line 460
  name.data = (u_char *)"invalid_referer";
#line 462
  var = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
  }
#line 463
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 464
    return ((char *)((void *)-1));
  }
#line 467
  var->get_handler = & ngx_http_referer_variable;
#line 469
  if ((unsigned long )rlcf->keys == (unsigned long )((void *)0)) {
    {
#line 470
    tmp = ngx_pcalloc(cf->temp_pool, sizeof(ngx_hash_keys_arrays_t ));
#line 470
    rlcf->keys = (ngx_hash_keys_arrays_t *)tmp;
    }
#line 471
    if ((unsigned long )rlcf->keys == (unsigned long )((void *)0)) {
#line 472
      return ((char *)((void *)-1));
    }
    {
#line 475
    (rlcf->keys)->pool = cf->pool;
#line 476
    (rlcf->keys)->temp_pool = cf->pool;
#line 478
    tmp___0 = ngx_hash_keys_array_init(rlcf->keys, (ngx_uint_t )1);
    }
#line 478
    if (tmp___0 != 0L) {
#line 479
      return ((char *)((void *)-1));
    }
  }
#line 483
  value = (ngx_str_t *)(cf->args)->elts;
#line 485
  i = (ngx_uint_t )1;
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < (cf->args)->nelts)) {
#line 485
      goto while_break;
    }
#line 486
    if ((value + i)->len == 0UL) {
      {
#line 487
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid referer \"%V\"", value + i);
      }
#line 489
      return ((char *)((void *)-1));
    }
    {
#line 492
    tmp___1 = strcmp((char const   *)(value + i)->data, "none");
    }
#line 492
    if (tmp___1 == 0) {
#line 493
      rlcf->no_referer = (ngx_flag_t )1;
#line 494
      goto __Cont;
    }
    {
#line 497
    tmp___2 = strcmp((char const   *)(value + i)->data, "blocked");
    }
#line 497
    if (tmp___2 == 0) {
#line 498
      rlcf->blocked_referer = (ngx_flag_t )1;
#line 499
      goto __Cont;
    }
    {
#line 502
    tmp___3 = strcmp((char const   *)(value + i)->data, "server_names");
    }
#line 502
    if (tmp___3 == 0) {
#line 503
      rlcf->server_names = (ngx_flag_t )1;
#line 504
      goto __Cont;
    }
#line 507
    if ((int )*((value + i)->data + 0) == 126) {
      {
#line 508
      tmp___4 = ngx_http_add_regex_referer(cf, rlcf, value + i);
      }
#line 508
      if (tmp___4 != 0L) {
#line 509
        return ((char *)((void *)-1));
      }
#line 512
      goto __Cont;
    }
    {
#line 515
    uri___0.len = (size_t___0 )0;
#line 515
    uri___0.data = (u_char *)((void *)0);
#line 517
    tmp___5 = strchr((char const   *)(value + i)->data, '/');
#line 517
    p = (u_char *)tmp___5;
    }
#line 519
    if (p) {
#line 520
      uri___0.len = (size_t___0 )(((value + i)->data + (value + i)->len) - p);
#line 521
      uri___0.data = p;
#line 522
      (value + i)->len = (size_t___0 )(p - (value + i)->data);
    }
    {
#line 525
    tmp___6 = ngx_http_add_referer(cf, rlcf->keys, value + i, & uri___0);
    }
#line 525
    if (tmp___6 != 0L) {
#line 526
      return ((char *)((void *)-1));
    }
    __Cont: /* CIL Label */ 
#line 485
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 530
  return ((char *)((void *)0));
}
}
#line 534 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_add_referer(ngx_conf_t *cf , ngx_hash_keys_arrays_t *keys ,
                                      ngx_str_t *value , ngx_str_t *uri___0 ) 
{ 
  ngx_int_t rc ;
  ngx_str_t *u ;
  void *tmp ;

  {
#line 541
  if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 542
    u = (ngx_str_t *)((void *)4);
  } else
#line 541
  if (uri___0->len == 0UL) {
#line 542
    u = (ngx_str_t *)((void *)4);
  } else {
    {
#line 545
    tmp = ngx_palloc(cf->pool, sizeof(ngx_str_t ));
#line 545
    u = (ngx_str_t *)tmp;
    }
#line 546
    if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 547
      return ((ngx_int_t )-1);
    }
#line 550
    *u = *uri___0;
  }
  {
#line 553
  rc = ngx_hash_add_key(keys, value, (void *)u, (ngx_uint_t )1);
  }
#line 555
  if (rc == 0L) {
#line 556
    return ((ngx_int_t )0);
  }
#line 559
  if (rc == -5L) {
    {
#line 560
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid hostname or wildcard \"%V\"",
                       value);
    }
  }
#line 564
  if (rc == -3L) {
    {
#line 565
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting parameter \"%V\"", value);
    }
  }
#line 569
  return ((ngx_int_t )-1);
}
}
#line 573 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_add_regex_referer(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                            ngx_str_t *name ) 
{ 
  ngx_regex_elt_t *re ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 582
  if (name->len == 1UL) {
    {
#line 583
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "empty regex in \"%V\"", name);
    }
#line 584
    return ((ngx_int_t )-1);
  }
#line 587
  if ((unsigned long )rlcf->regex == (unsigned long )((void *)-1)) {
    {
#line 588
    rlcf->regex = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_regex_elt_t ));
    }
#line 589
    if ((unsigned long )rlcf->regex == (unsigned long )((void *)0)) {
#line 590
      return ((ngx_int_t )-1);
    }
  }
  {
#line 594
  tmp = ngx_array_push(rlcf->regex);
#line 594
  re = (ngx_regex_elt_t *)tmp;
  }
#line 595
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 596
    return ((ngx_int_t )-1);
  }
  {
#line 599
  (name->len) --;
#line 600
  (name->data) ++;
#line 602
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 604
  rc.pattern = *name;
#line 605
  rc.pool = cf->pool;
#line 606
  rc.options = (ngx_int_t )1;
#line 607
  rc.err.len = (size_t___0 )1024;
#line 608
  rc.err.data = errstr;
#line 610
  tmp___0 = ngx_regex_compile(& rc);
  }
#line 610
  if (tmp___0 != 0L) {
    {
#line 611
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc.err);
    }
#line 612
    return ((ngx_int_t )-1);
  }
#line 615
  re->regex = rc.regex;
#line 616
  re->name = name->data;
#line 618
  return ((ngx_int_t )0);
}
}
#line 634 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_add_regex_server_name(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                                ngx_http_regex_t *regex ) 
{ 
  ngx_regex_elt_t *re ;
  void *tmp ;

  {
#line 640
  if ((unsigned long )rlcf->server_name_regex == (unsigned long )((void *)-1)) {
    {
#line 641
    rlcf->server_name_regex = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_regex_elt_t ));
    }
#line 643
    if ((unsigned long )rlcf->server_name_regex == (unsigned long )((void *)0)) {
#line 644
      return ((ngx_int_t )-1);
    }
  }
  {
#line 648
  tmp = ngx_array_push(rlcf->server_name_regex);
#line 648
  re = (ngx_regex_elt_t *)tmp;
  }
#line 649
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 650
    return ((ngx_int_t )-1);
  }
#line 653
  re->regex = regex->regex;
#line 654
  re->name = regex->name.data;
#line 656
  return ((ngx_int_t )0);
}
}
#line 662 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_referer_module.c"
static int ngx_http_cmp_referer_wildcards(void const   *one , void const   *two ) 
{ 
  ngx_hash_key_t *first ;
  ngx_hash_key_t *second ;
  ngx_int_t tmp ;

  {
  {
#line 667
  first = (ngx_hash_key_t *)one;
#line 668
  second = (ngx_hash_key_t *)two;
#line 670
  tmp = ngx_dns_strcmp(first->key.data, second->key.data);
  }
#line 670
  return ((int )tmp);
}
}
#line 173 "src/core/ngx_string.h"
ngx_int_t ngx_atofp(u_char *line , size_t___0 n , size_t___0 point ) ;
#line 16 "src/core/ngx_murmurhash.h"
uint32_t ngx_murmur_hash2(u_char *data , size_t___0 len ) ;
#line 25 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
static char *ngx_conf_split_clients_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 27
static char *ngx_http_split_clients(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 30 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
static ngx_command_t ngx_http_split_clients_commands[2]  = {      {{sizeof("split_clients") - 1UL, (u_char *)"split_clients"}, (ngx_uint_t )33554692,
      & ngx_conf_split_clients_block, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 43 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
static ngx_http_module_t ngx_http_split_clients_module_ctx  = 
#line 43
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 58 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
ngx_module_t ngx_http_split_clients_module  = 
#line 58
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_split_clients_module_ctx),
    ngx_http_split_clients_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 74 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
static ngx_int_t ngx_http_split_clients_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  ngx_http_split_clients_ctx_t *ctx ;
  uint32_t hash ;
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_http_split_clients_part_t *part ;
  ngx_int_t tmp ;

  {
  {
#line 78
  ctx = (ngx_http_split_clients_ctx_t *)data;
#line 85
  *v = ngx_http_variable_null_value;
#line 87
  tmp = ngx_http_complex_value(r, & ctx->value, & val);
  }
#line 87
  if (tmp != 0L) {
#line 88
    return ((ngx_int_t )0);
  }
  {
#line 91
  hash = ngx_murmur_hash2(val.data, val.len);
#line 93
  part = (ngx_http_split_clients_part_t *)ctx->parts.elts;
#line 95
  i = (ngx_uint_t )0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < ctx->parts.nelts)) {
#line 95
      goto while_break;
    }
#line 100
    if (hash < (part + i)->percent) {
#line 101
      *v = (part + i)->value;
#line 102
      return ((ngx_int_t )0);
    } else
#line 100
    if ((part + i)->percent == 0U) {
#line 101
      *v = (part + i)->value;
#line 102
      return ((ngx_int_t )0);
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return ((ngx_int_t )0);
}
}
#line 110 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
static char *ngx_conf_split_clients_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  uint32_t sum ;
  uint32_t last ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_variable_t *var ;
  ngx_http_split_clients_ctx_t *ctx ;
  ngx_http_split_clients_part_t *part ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 123
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_split_clients_ctx_t ));
#line 123
  ctx = (ngx_http_split_clients_ctx_t *)tmp;
  }
#line 124
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 125
    return ((char *)((void *)-1));
  }
  {
#line 128
  value = (ngx_str_t *)(cf->args)->elts;
#line 130
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 132
  ccv.cf = cf;
#line 133
  ccv.value = value + 1;
#line 134
  ccv.complex_value = & ctx->value;
#line 136
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 136
  if (tmp___0 != 0L) {
#line 137
    return ((char *)((void *)-1));
  }
#line 140
  name = *(value + 2);
#line 142
  if ((int )*(name.data + 0) != 36) {
    {
#line 143
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
    }
#line 145
    return ((char *)((void *)-1));
  }
  {
#line 148
  (name.len) --;
#line 149
  (name.data) ++;
#line 151
  var = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
  }
#line 152
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 153
    return ((char *)((void *)-1));
  }
  {
#line 156
  var->get_handler = & ngx_http_split_clients_variable;
#line 157
  var->data = (uintptr_t )ctx;
#line 159
  tmp___1 = ngx_array_init(& ctx->parts, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_split_clients_part_t ));
  }
#line 159
  if (tmp___1 != 0L) {
#line 163
    return ((char *)((void *)-1));
  }
  {
#line 166
  save = *cf;
#line 167
  cf->ctx = (void *)ctx;
#line 168
  cf->handler = & ngx_http_split_clients;
#line 169
  cf->handler_conf = (char *)conf;
#line 171
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 173
  *cf = save;
  }
#line 175
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 176
    return (rv);
  }
#line 179
  sum = (uint32_t )0;
#line 180
  last = (uint32_t )0;
#line 181
  part = (ngx_http_split_clients_part_t *)ctx->parts.elts;
#line 183
  i = (ngx_uint_t )0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < ctx->parts.nelts)) {
#line 183
      goto while_break;
    }
#line 184
    if ((part + i)->percent) {
#line 184
      sum += (part + i)->percent;
    } else {
#line 184
      sum = (uint32_t )10000;
    }
#line 185
    if (sum > 10000U) {
      {
#line 186
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "percent total is greater than 100%%");
      }
#line 188
      return ((char *)((void *)-1));
    }
#line 191
    if ((part + i)->percent) {
#line 192
      last = (uint32_t )((uint64_t )last + ((uint64_t )(part + i)->percent * 4294967295UL) / 10000UL);
#line 193
      (part + i)->percent = last;
    }
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (rv);
}
}
#line 201 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_split_clients_module.c"
static char *ngx_http_split_clients(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  ngx_int_t n ;
  ngx_str_t *value ;
  ngx_http_split_clients_ctx_t *ctx ;
  ngx_http_split_clients_part_t *part ;
  void *tmp ;

  {
  {
#line 209
  ctx = (ngx_http_split_clients_ctx_t *)cf->ctx;
#line 210
  value = (ngx_str_t *)(cf->args)->elts;
#line 212
  tmp = ngx_array_push(& ctx->parts);
#line 212
  part = (ngx_http_split_clients_part_t *)tmp;
  }
#line 213
  if ((unsigned long )part == (unsigned long )((void *)0)) {
#line 214
    return ((char *)((void *)-1));
  }
#line 217
  if ((value + 0)->len == 1UL) {
#line 217
    if ((int )*((value + 0)->data + 0) == 42) {
#line 218
      part->percent = (uint32_t )0;
    } else {
#line 217
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 221
    if ((value + 0)->len == 0UL) {
#line 222
      goto invalid;
    } else
#line 221
    if ((int )*((value + 0)->data + ((value + 0)->len - 1UL)) != 37) {
#line 222
      goto invalid;
    }
    {
#line 225
    n = ngx_atofp((value + 0)->data, (value + 0)->len - 1UL, (size_t___0 )2);
    }
#line 226
    if (n == -1L) {
#line 227
      goto invalid;
    } else
#line 226
    if (n == 0L) {
#line 227
      goto invalid;
    }
#line 230
    part->percent = (uint32_t )n;
  }
#line 233
  part->value.len = (unsigned int )(value + 1)->len;
#line 234
  part->value.valid = 1U;
#line 235
  part->value.no_cacheable = 0U;
#line 236
  part->value.not_found = 0U;
#line 237
  part->value.data = (value + 1)->data;
#line 239
  return ((char *)((void *)0));
  invalid: 
  {
#line 243
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid percent value \"%V\"", value + 0);
  }
#line 245
  return ((char *)((void *)-1));
}
}
#line 148 "src/core/ngx_string.h"
u_char *ngx_pstrdup(ngx_pool_t *pool , ngx_str_t *src ) ;
#line 75 "src/core/ngx_palloc.h"
ngx_pool_t *ngx_create_pool(size_t___0 size , ngx_log_t *log ) ;
#line 270 "src/core/ngx_conf_file.h"
char *ngx_conf_include(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 102 "src/http/ngx_http_variables.h"
void *ngx_http_map_find(ngx_http_request_t *r , ngx_http_map_t *map___0 , ngx_str_t *match ) ;
#line 42 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static int ngx_http_map_cmp_dns_wildcards(void const   *one , void const   *two ) ;
#line 44
static void *ngx_http_map_create_conf(ngx_conf_t *cf ) ;
#line 45
static char *ngx_http_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 46
static char *ngx_http_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 49 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static ngx_command_t ngx_http_map_commands[4]  = {      {{sizeof("map") - 1UL, (u_char *)"map"}, (ngx_uint_t )33554692, & ngx_http_map_block,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("map_hash_max_size") - 1UL,
       (u_char *)"map_hash_max_size"}, (ngx_uint_t )33554434, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (unsigned long )(& ((ngx_http_map_conf_t *)0)->hash_max_size),
      (void *)0}, 
        {{sizeof("map_hash_bucket_size") - 1UL, (u_char *)"map_hash_bucket_size"}, (ngx_uint_t )33554434,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_map_conf_t *)0)->hash_bucket_size), (void *)0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 76 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static ngx_http_module_t ngx_http_map_module_ctx  = 
#line 76
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_map_create_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 91 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
ngx_module_t ngx_http_map_module  = 
#line 91
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_map_module_ctx),
    ngx_http_map_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 107 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static ngx_int_t ngx_http_map_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) 
{ 
  ngx_http_map_ctx_t *map___0 ;
  ngx_str_t val ;
  ngx_str_t str ;
  ngx_http_complex_value_t *cv ;
  ngx_http_variable_value_t *value ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 111
  map___0 = (ngx_http_map_ctx_t *)data;
#line 120
  tmp = ngx_http_complex_value(r, & map___0->value, & val);
  }
#line 120
  if (tmp != 0L) {
#line 121
    return ((ngx_int_t )-1);
  }
#line 124
  if (map___0->hostnames) {
#line 124
    if (val.len > 0UL) {
#line 124
      if ((int )*(val.data + (val.len - 1UL)) == 46) {
#line 125
        (val.len) --;
      }
    }
  }
  {
#line 128
  tmp___0 = ngx_http_map_find(r, & map___0->map, & val);
#line 128
  value = (ngx_http_variable_value_t *)tmp___0;
  }
#line 130
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 131
    value = map___0->default_value;
  }
#line 134
  if (! value->valid) {
    {
#line 135
    cv = (ngx_http_complex_value_t *)value->data;
#line 137
    tmp___1 = ngx_http_complex_value(r, cv, & str);
    }
#line 137
    if (tmp___1 != 0L) {
#line 138
      return ((ngx_int_t )-1);
    }
#line 141
    v->valid = 1U;
#line 142
    v->no_cacheable = 0U;
#line 143
    v->not_found = 0U;
#line 144
    v->len = (unsigned int )str.len;
#line 145
    v->data = str.data;
  } else {
#line 148
    *v = *value;
  }
#line 154
  return ((ngx_int_t )0);
}
}
#line 158 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static void *ngx_http_map_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_map_conf_t *mcf ;
  void *tmp ;

  {
  {
#line 163
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_map_conf_t ));
#line 163
  mcf = (ngx_http_map_conf_t *)tmp;
  }
#line 164
  if ((unsigned long )mcf == (unsigned long )((void *)0)) {
#line 165
    return ((void *)0);
  }
#line 168
  mcf->hash_max_size = (ngx_uint_t )-1;
#line 169
  mcf->hash_bucket_size = (ngx_uint_t )-1;
#line 171
  return ((void *)mcf);
}
}
#line 175 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static char *ngx_http_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_map_conf_t *mcf ;
  char *rv ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_conf_t save ;
  ngx_pool_t *pool ;
  ngx_hash_init_t hash ;
  ngx_http_map_ctx_t *map___0 ;
  ngx_http_variable_t *var ;
  ngx_http_map_conf_ctx_t ctx ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;

  {
#line 178
  mcf = (ngx_http_map_conf_t *)conf;
#line 190
  if (mcf->hash_max_size == 0xffffffffffffffffUL) {
#line 191
    mcf->hash_max_size = (ngx_uint_t )2048;
  }
#line 194
  if (mcf->hash_bucket_size == 0xffffffffffffffffUL) {
#line 195
    mcf->hash_bucket_size = ngx_cacheline_size;
  } else {
#line 198
    mcf->hash_bucket_size = (mcf->hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
  }
  {
#line 202
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_map_ctx_t ));
#line 202
  map___0 = (ngx_http_map_ctx_t *)tmp;
  }
#line 203
  if ((unsigned long )map___0 == (unsigned long )((void *)0)) {
#line 204
    return ((char *)((void *)-1));
  }
  {
#line 207
  value = (ngx_str_t *)(cf->args)->elts;
#line 209
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 211
  ccv.cf = cf;
#line 212
  ccv.value = value + 1;
#line 213
  ccv.complex_value = & map___0->value;
#line 215
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 215
  if (tmp___0 != 0L) {
#line 216
    return ((char *)((void *)-1));
  }
#line 219
  name = *(value + 2);
#line 221
  if ((int )*(name.data + 0) != 36) {
    {
#line 222
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
    }
#line 224
    return ((char *)((void *)-1));
  }
  {
#line 227
  (name.len) --;
#line 228
  (name.data) ++;
#line 230
  var = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
  }
#line 231
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 232
    return ((char *)((void *)-1));
  }
  {
#line 235
  var->get_handler = & ngx_http_map_variable;
#line 236
  var->data = (uintptr_t )map___0;
#line 238
  pool = ngx_create_pool((size_t___0 )16384, cf->log);
  }
#line 239
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 240
    return ((char *)((void *)-1));
  }
  {
#line 243
  ctx.keys.pool = cf->pool;
#line 244
  ctx.keys.temp_pool = pool;
#line 246
  tmp___1 = ngx_hash_keys_array_init(& ctx.keys, (ngx_uint_t )2);
  }
#line 246
  if (tmp___1 != 0L) {
    {
#line 247
    ngx_destroy_pool(pool);
    }
#line 248
    return ((char *)((void *)-1));
  }
  {
#line 251
  tmp___2 = ngx_pcalloc(pool, sizeof(ngx_array_t ) * ctx.keys.hsize);
#line 251
  ctx.values_hash = (ngx_array_t *)tmp___2;
  }
#line 252
  if ((unsigned long )ctx.values_hash == (unsigned long )((void *)0)) {
    {
#line 253
    ngx_destroy_pool(pool);
    }
#line 254
    return ((char *)((void *)-1));
  }
  {
#line 258
  tmp___3 = ngx_array_init(& ctx.regexes, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_map_regex_t ));
  }
#line 258
  if (tmp___3 != 0L) {
    {
#line 261
    ngx_destroy_pool(pool);
    }
#line 262
    return ((char *)((void *)-1));
  }
  {
#line 266
  ctx.default_value = (ngx_http_variable_value_t *)((void *)0);
#line 267
  ctx.cf = & save;
#line 268
  ctx.hostnames = 0U;
#line 269
  ctx.no_cacheable = 0U;
#line 271
  save = *cf;
#line 272
  cf->pool = pool;
#line 273
  cf->ctx = (void *)(& ctx);
#line 274
  cf->handler = & ngx_http_map;
#line 275
  cf->handler_conf = (char *)conf;
#line 277
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 279
  *cf = save;
  }
#line 281
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
    {
#line 282
    ngx_destroy_pool(pool);
    }
#line 283
    return (rv);
  }
#line 286
  if (ctx.no_cacheable) {
#line 287
    var->flags |= 2UL;
  }
#line 290
  if (ctx.default_value) {
#line 290
    map___0->default_value = ctx.default_value;
  } else {
#line 290
    map___0->default_value = & ngx_http_variable_null_value;
  }
#line 293
  map___0->hostnames = (ngx_uint_t )ctx.hostnames;
#line 295
  hash.key = & ngx_hash_key_lc;
#line 296
  hash.max_size = mcf->hash_max_size;
#line 297
  hash.bucket_size = mcf->hash_bucket_size;
#line 298
  hash.name = (char *)"map_hash";
#line 299
  hash.pool = cf->pool;
#line 301
  if (ctx.keys.keys.nelts) {
    {
#line 302
    hash.hash = & map___0->map.hash.hash;
#line 303
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 305
    tmp___4 = ngx_hash_init(& hash, (ngx_hash_key_t *)ctx.keys.keys.elts, ctx.keys.keys.nelts);
    }
#line 305
    if (tmp___4 != 0L) {
      {
#line 308
      ngx_destroy_pool(pool);
      }
#line 309
      return ((char *)((void *)-1));
    }
  }
#line 313
  if (ctx.keys.dns_wc_head.nelts) {
    {
#line 315
    qsort(ctx.keys.dns_wc_head.elts, ctx.keys.dns_wc_head.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_map_cmp_dns_wildcards);
#line 319
    hash.hash = (ngx_hash_t *)((void *)0);
#line 320
    hash.temp_pool = pool;
#line 322
    tmp___5 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ctx.keys.dns_wc_head.elts,
                                     ctx.keys.dns_wc_head.nelts);
    }
#line 322
    if (tmp___5 != 0L) {
      {
#line 326
      ngx_destroy_pool(pool);
      }
#line 327
      return ((char *)((void *)-1));
    }
#line 330
    map___0->map.hash.wc_head = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 333
  if (ctx.keys.dns_wc_tail.nelts) {
    {
#line 335
    qsort(ctx.keys.dns_wc_tail.elts, ctx.keys.dns_wc_tail.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_map_cmp_dns_wildcards);
#line 339
    hash.hash = (ngx_hash_t *)((void *)0);
#line 340
    hash.temp_pool = pool;
#line 342
    tmp___6 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ctx.keys.dns_wc_tail.elts,
                                     ctx.keys.dns_wc_tail.nelts);
    }
#line 342
    if (tmp___6 != 0L) {
      {
#line 346
      ngx_destroy_pool(pool);
      }
#line 347
      return ((char *)((void *)-1));
    }
#line 350
    map___0->map.hash.wc_tail = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 355
  if (ctx.regexes.nelts) {
#line 356
    map___0->map.regex = (ngx_http_map_regex_t *)ctx.regexes.elts;
#line 357
    map___0->map.nregex = ctx.regexes.nelts;
  }
  {
#line 362
  ngx_destroy_pool(pool);
  }
#line 364
  return (rv);
}
}
#line 368 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static int ngx_http_map_cmp_dns_wildcards(void const   *one , void const   *two ) 
{ 
  ngx_hash_key_t *first ;
  ngx_hash_key_t *second ;
  ngx_int_t tmp ;

  {
  {
#line 373
  first = (ngx_hash_key_t *)one;
#line 374
  second = (ngx_hash_key_t *)two;
#line 376
  tmp = ngx_dns_strcmp(first->key.data, second->key.data);
  }
#line 376
  return ((int )tmp);
}
}
#line 380 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_map_module.c"
static char *ngx_http_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  u_char *data ;
  size_t___0 len ;
  ngx_int_t rv ;
  ngx_str_t *value ;
  ngx_str_t v ;
  ngx_uint_t i ;
  ngx_uint_t key ;
  ngx_http_map_conf_ctx_t *ctx ;
  ngx_http_complex_value_t cv ;
  ngx_http_complex_value_t *cvp ;
  ngx_http_variable_value_t *var ;
  ngx_http_variable_value_t **vp ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  ngx_regex_compile_t rc ;
  ngx_http_map_regex_t *regex ;
  u_char errstr[1024] ;
  void *tmp___10 ;
  int tmp___11 ;

  {
#line 393
  ctx = (ngx_http_map_conf_ctx_t *)cf->ctx;
#line 395
  value = (ngx_str_t *)(cf->args)->elts;
#line 397
  if ((cf->args)->nelts == 1UL) {
    {
#line 397
    tmp = strcmp((char const   *)(value + 0)->data, "hostnames");
    }
#line 397
    if (tmp == 0) {
#line 400
      ctx->hostnames = 1U;
#line 401
      return ((char *)((void *)0));
    }
  }
#line 404
  if ((cf->args)->nelts == 1UL) {
    {
#line 404
    tmp___0 = strcmp((char const   *)(value + 0)->data, "volatile");
    }
#line 404
    if (tmp___0 == 0) {
#line 407
      ctx->no_cacheable = 1U;
#line 408
      return ((char *)((void *)0));
    }
  }
#line 411
  if ((cf->args)->nelts != 2UL) {
    {
#line 412
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of the map parameters");
    }
#line 414
    return ((char *)((void *)-1));
  }
  {
#line 417
  tmp___2 = strcmp((char const   *)(value + 0)->data, "include");
  }
#line 417
  if (tmp___2 == 0) {
    {
#line 418
    tmp___1 = ngx_conf_include(cf, dummy, conf);
    }
#line 418
    return (tmp___1);
  }
#line 421
  key = (ngx_uint_t )0;
#line 423
  i = (ngx_uint_t )0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i < (value + 1)->len)) {
#line 423
      goto while_break;
    }
#line 424
    key = key * 31UL + (ngx_uint_t )*((value + 1)->data + i);
#line 423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  key %= ctx->keys.hsize;
#line 429
  vp = (ngx_http_variable_value_t **)(ctx->values_hash + key)->elts;
#line 431
  if (vp) {
#line 432
    i = (ngx_uint_t )0;
    {
#line 432
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 432
      if (! (i < (ctx->values_hash + key)->nelts)) {
#line 432
        goto while_break___0;
      }
#line 434
      if ((*(vp + i))->valid) {
#line 435
        data = (*(vp + i))->data;
#line 436
        len = (size_t___0 )(*(vp + i))->len;
      } else {
#line 439
        cvp = (ngx_http_complex_value_t *)(*(vp + i))->data;
#line 440
        data = cvp->value.data;
#line 441
        len = cvp->value.len;
      }
#line 444
      if ((value + 1)->len != len) {
#line 445
        goto __Cont;
      }
      {
#line 448
      tmp___3 = strncmp((char const   *)(value + 1)->data, (char const   *)data, len);
      }
#line 448
      if (tmp___3 == 0) {
#line 449
        var = *(vp + i);
#line 450
        goto found;
      }
      __Cont: /* CIL Label */ 
#line 432
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 455
    tmp___4 = ngx_array_init(ctx->values_hash + key, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_variable_value_t *));
    }
#line 455
    if (tmp___4 != 0L) {
#line 459
      return ((char *)((void *)-1));
    }
  }
  {
#line 463
  tmp___5 = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t ));
#line 463
  var = (ngx_http_variable_value_t *)tmp___5;
  }
#line 464
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 465
    return ((char *)((void *)-1));
  }
  {
#line 468
  v.len = (value + 1)->len;
#line 469
  v.data = ngx_pstrdup(ctx->keys.pool, value + 1);
  }
#line 470
  if ((unsigned long )v.data == (unsigned long )((void *)0)) {
#line 471
    return ((char *)((void *)-1));
  }
  {
#line 474
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 476
  ccv.cf = ctx->cf;
#line 477
  ccv.value = & v;
#line 478
  ccv.complex_value = & cv;
#line 480
  tmp___6 = ngx_http_compile_complex_value(& ccv);
  }
#line 480
  if (tmp___6 != 0L) {
#line 481
    return ((char *)((void *)-1));
  }
#line 484
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 485
    tmp___7 = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_complex_value_t ));
#line 485
    cvp = (ngx_http_complex_value_t *)tmp___7;
    }
#line 486
    if ((unsigned long )cvp == (unsigned long )((void *)0)) {
#line 487
      return ((char *)((void *)-1));
    }
#line 490
    *cvp = cv;
#line 492
    var->len = 0U;
#line 493
    var->data = (u_char *)cvp;
#line 494
    var->valid = 0U;
  } else {
#line 497
    var->len = (unsigned int )v.len;
#line 498
    var->data = v.data;
#line 499
    var->valid = 1U;
  }
  {
#line 502
  var->no_cacheable = 0U;
#line 503
  var->not_found = 0U;
#line 505
  tmp___8 = ngx_array_push(ctx->values_hash + key);
#line 505
  vp = (ngx_http_variable_value_t **)tmp___8;
  }
#line 506
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 507
    return ((char *)((void *)-1));
  }
#line 510
  *vp = var;
  found: 
  {
#line 514
  tmp___9 = strcmp((char const   *)(value + 0)->data, "default");
  }
#line 514
  if (tmp___9 == 0) {
#line 516
    if (ctx->default_value) {
      {
#line 517
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate default map parameter");
      }
#line 519
      return ((char *)((void *)-1));
    }
#line 522
    ctx->default_value = var;
#line 524
    return ((char *)((void *)0));
  }
#line 529
  if ((value + 0)->len) {
#line 529
    if ((int )*((value + 0)->data + 0) == 126) {
      {
#line 534
      tmp___10 = ngx_array_push(& ctx->regexes);
#line 534
      regex = (ngx_http_map_regex_t *)tmp___10;
      }
#line 535
      if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 536
        return ((char *)((void *)-1));
      }
      {
#line 539
      ((value + 0)->len) --;
#line 540
      ((value + 0)->data) ++;
#line 542
      memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
      }
#line 544
      if ((int )*((value + 0)->data + 0) == 42) {
#line 545
        ((value + 0)->len) --;
#line 546
        ((value + 0)->data) ++;
#line 547
        rc.options = (ngx_int_t )1;
      }
      {
#line 550
      rc.pattern = *(value + 0);
#line 551
      rc.err.len = (size_t___0 )1024;
#line 552
      rc.err.data = errstr;
#line 554
      regex->regex = ngx_http_regex_compile(ctx->cf, & rc);
      }
#line 555
      if ((unsigned long )regex->regex == (unsigned long )((void *)0)) {
#line 556
        return ((char *)((void *)-1));
      }
#line 559
      regex->value = (void *)var;
#line 561
      return ((char *)((void *)0));
    }
  }
#line 566
  if ((value + 0)->len) {
#line 566
    if ((int )*((value + 0)->data + 0) == 92) {
#line 567
      ((value + 0)->len) --;
#line 568
      ((value + 0)->data) ++;
    }
  }
#line 571
  if (ctx->hostnames) {
#line 571
    tmp___11 = 1;
  } else {
#line 571
    tmp___11 = 0;
  }
  {
#line 571
  rv = ngx_hash_add_key(& ctx->keys, value + 0, (void *)var, (ngx_uint_t )tmp___11);
  }
#line 574
  if (rv == 0L) {
#line 575
    return ((char *)((void *)0));
  }
#line 578
  if (rv == -5L) {
    {
#line 579
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid hostname or wildcard \"%V\"",
                       value + 0);
    }
  }
#line 583
  if (rv == -3L) {
    {
#line 584
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting parameter \"%V\"", value + 0);
    }
  }
#line 588
  return ((char *)((void *)-1));
}
}
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 160 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 51 "src/core/ngx_rbtree.h"
void ngx_rbtree_insert(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) ;
#line 65 "src/core/ngx_string.h"
__inline static u_char *ngx_strlchr(u_char *p , u_char *last , u_char c ) 
{ 


  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 68
      goto while_break;
    }
#line 70
    if ((int )*p == (int )c) {
#line 71
      return (p);
    }
#line 74
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return ((u_char *)((void *)0));
}
}
#line 219
void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                 ngx_rbtree_node_t *sentinel ) ;
#line 221
ngx_str_node_t *ngx_str_rbtree_lookup(ngx_rbtree_t *rbtree , ngx_str_t *val , uint32_t hash ) ;
#line 122 "src/os/unix/ngx_files.h"
ssize_t ngx_read_file(ngx_file_t *file , u_char *buf , size_t___0 size , off_t offset ) ;
#line 193
ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm ) ;
#line 194
void ngx_close_file_mapping(ngx_file_mapping_t *fm ) ;
#line 77 "src/core/ngx_palloc.h"
void ngx_reset_pool(ngx_pool_t *pool ) ;
#line 37 "src/core/ngx_radix_tree.h"
ngx_radix_tree_t *ngx_radix_tree_create(ngx_pool_t *pool , ngx_int_t preallocate ) ;
#line 40
ngx_int_t ngx_radix32tree_insert(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ,
                                 uintptr_t value ) ;
#line 42
ngx_int_t ngx_radix32tree_delete(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ) ;
#line 44
uintptr_t ngx_radix32tree_find(ngx_radix_tree_t *tree , uint32_t key ) ;
#line 47
ngx_int_t ngx_radix128tree_insert(ngx_radix_tree_t *tree , u_char *key , u_char *mask ,
                                  uintptr_t value ) ;
#line 49
ngx_int_t ngx_radix128tree_delete(ngx_radix_tree_t *tree , u_char *key , u_char *mask ) ;
#line 51
uintptr_t ngx_radix128tree_find(ngx_radix_tree_t *tree , u_char *key ) ;
#line 107 "src/core/ngx_inet.h"
in_addr_t ngx_inet_addr(u_char *text , size_t___0 len ) ;
#line 115
ngx_int_t ngx_ptocidr(ngx_str_t *text , ngx_cidr_t *cidr ) ;
#line 117
ngx_int_t ngx_parse_addr(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text , size_t___0 len ) ;
#line 273 "src/core/ngx_conf_file.h"
ngx_int_t ngx_conf_full_name(ngx_cycle_t *cycle , ngx_str_t *name , ngx_uint_t conf_prefix ) ;
#line 52 "src/http/ngx_http_variables.h"
ngx_http_variable_value_t *ngx_http_get_flushed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) ;
#line 537 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r , ngx_addr_t *addr , ngx_array_t *headers ,
                                      ngx_str_t *value , ngx_array_t *proxies , int recursive ) ;
#line 82 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                   ngx_addr_t *addr ) ;
#line 84
static ngx_int_t ngx_http_geo_real_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                        ngx_addr_t *addr ) ;
#line 86
static char *ngx_http_geo_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 87
static char *ngx_http_geo(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 88
static char *ngx_http_geo_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) ;
#line 90
static char *ngx_http_geo_add_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    in_addr_t start , in_addr_t end ) ;
#line 92
static ngx_uint_t ngx_http_geo_delete_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                            in_addr_t start , in_addr_t end ) ;
#line 94
static char *ngx_http_geo_cidr(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) ;
#line 96
static char *ngx_http_geo_cidr_add(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                   ngx_cidr_t *cidr , ngx_str_t *value , ngx_str_t *net ) ;
#line 98
static ngx_http_variable_value_t *ngx_http_geo_value(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                     ngx_str_t *value ) ;
#line 100
static char *ngx_http_geo_add_proxy(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    ngx_cidr_t *cidr ) ;
#line 102
static ngx_int_t ngx_http_geo_cidr_value(ngx_conf_t *cf , ngx_str_t *net , ngx_cidr_t *cidr ) ;
#line 104
static char *ngx_http_geo_include(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                  ngx_str_t *name ) ;
#line 106
static ngx_int_t ngx_http_geo_include_binary_base(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                  ngx_str_t *name ) ;
#line 108
static void ngx_http_geo_create_binary_base(ngx_http_geo_conf_ctx_t *ctx ) ;
#line 109
static u_char *ngx_http_geo_copy_values(u_char *base , u_char *p , ngx_rbtree_node_t *node ,
                                        ngx_rbtree_node_t *sentinel ) ;
#line 113 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_command_t ngx_http_geo_commands[2]  = {      {{sizeof("geo") - 1UL, (u_char *)"geo"}, (ngx_uint_t )33554694, & ngx_http_geo_block,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 126 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_http_module_t ngx_http_geo_module_ctx  = 
#line 126
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 141 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
ngx_module_t ngx_http_geo_module  = 
#line 141
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_geo_module_ctx),
    ngx_http_geo_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 166 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_http_geo_header_t ngx_http_geo_header  =    {{(u_char )'G', (u_char )'E', (u_char )'O', (u_char )'R', (u_char )'N', (u_char )'G'},
    (u_char )0, (u_char )sizeof(void *), (uint32_t )305419896, (uint32_t )0};
#line 173 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_cidr_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) 
{ 
  ngx_http_geo_ctx_t *ctx ;
  in_addr_t inaddr ;
  ngx_addr_t addr ;
  struct sockaddr_in *sin ;
  ngx_http_variable_value_t *vv ;
  u_char *p ;
  struct in6_addr *inaddr6 ;
  uintptr_t tmp ;
  ngx_int_t tmp___0 ;
  uintptr_t tmp___1 ;
  uintptr_t tmp___2 ;
  struct in6_addr  const  *__a ;
  unsigned int __v ;
  unsigned int __x ;
  int tmp___3 ;
  unsigned int __v___0 ;
  unsigned int __x___0 ;
  uintptr_t tmp___4 ;

  {
  {
#line 177
  ctx = (ngx_http_geo_ctx_t *)data;
#line 188
  tmp___0 = ngx_http_geo_addr(r, ctx, & addr);
  }
#line 188
  if (tmp___0 != 0L) {
    {
#line 189
    tmp = ngx_radix32tree_find(ctx->u.trees.tree, 4294967295U);
#line 189
    vv = (ngx_http_variable_value_t *)tmp;
    }
#line 191
    goto done;
  }
  {
#line 197
  if ((int )(addr.sockaddr)->sa_family == 10) {
#line 197
    goto case_10;
  }
#line 218
  goto switch_default;
  case_10: /* CIL Label */ 
#line 198
  inaddr6 = & ((struct sockaddr_in6 *)addr.sockaddr)->sin6_addr;
#line 199
  p = inaddr6->__in6_u.__u6_addr8;
#line 201
  __a = (struct in6_addr  const  *)inaddr6;
#line 201
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 201
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 201
      __x = 65535U;
#line 201
      __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 201
      if (__a->__in6_u.__u6_addr32[2] == __v) {
#line 201
        tmp___3 = 1;
      } else {
#line 201
        tmp___3 = 0;
      }
    } else {
#line 201
      tmp___3 = 0;
    }
  } else {
#line 201
    tmp___3 = 0;
  }
#line 201
  if (tmp___3) {
    {
#line 202
    inaddr = (in_addr_t )((int )*(p + 12) << 24);
#line 203
    inaddr += (in_addr_t )((int )*(p + 13) << 16);
#line 204
    inaddr += (in_addr_t )((int )*(p + 14) << 8);
#line 205
    inaddr += (in_addr_t )*(p + 15);
#line 207
    tmp___1 = ngx_radix32tree_find(ctx->u.trees.tree, inaddr);
#line 207
    vv = (ngx_http_variable_value_t *)tmp___1;
    }
  } else {
    {
#line 211
    tmp___2 = ngx_radix128tree_find(ctx->u.trees.tree6, p);
#line 211
    vv = (ngx_http_variable_value_t *)tmp___2;
    }
  }
#line 215
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 219
  sin = (struct sockaddr_in *)addr.sockaddr;
#line 220
  __x___0 = sin->sin_addr.s_addr;
#line 220
  __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 220
  inaddr = __v___0;
#line 222
  tmp___4 = ngx_radix32tree_find(ctx->u.trees.tree, inaddr);
#line 222
  vv = (ngx_http_variable_value_t *)tmp___4;
  }
#line 225
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  done: 
#line 230
  *v = *vv;
#line 235
  return ((ngx_int_t )0);
}
}
#line 239 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_range_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                             uintptr_t data ) 
{ 
  ngx_http_geo_ctx_t *ctx ;
  in_addr_t inaddr ;
  ngx_addr_t addr ;
  ngx_uint_t n ;
  struct sockaddr_in *sin ;
  ngx_http_geo_range_t *range ;
  u_char *p ;
  struct in6_addr *inaddr6 ;
  struct in6_addr  const  *__a ;
  unsigned int __v ;
  unsigned int __x ;
  int tmp ;
  unsigned int __v___0 ;
  unsigned int __x___0 ;
  ngx_int_t tmp___0 ;

  {
  {
#line 243
  ctx = (ngx_http_geo_ctx_t *)data;
#line 255
  *v = *(ctx->u.high.default_value);
#line 257
  tmp___0 = ngx_http_geo_addr(r, ctx, & addr);
  }
#line 257
  if (tmp___0 == 0L) {
    {
#line 262
    if ((int )(addr.sockaddr)->sa_family == 10) {
#line 262
      goto case_10;
    }
#line 280
    goto switch_default;
    case_10: /* CIL Label */ 
#line 263
    inaddr6 = & ((struct sockaddr_in6 *)addr.sockaddr)->sin6_addr;
#line 265
    __a = (struct in6_addr  const  *)inaddr6;
#line 265
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 265
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 265
        __x = 65535U;
#line 265
        __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 265
        if (__a->__in6_u.__u6_addr32[2] == __v) {
#line 265
          tmp = 1;
        } else {
#line 265
          tmp = 0;
        }
      } else {
#line 265
        tmp = 0;
      }
    } else {
#line 265
      tmp = 0;
    }
#line 265
    if (tmp) {
#line 266
      p = inaddr6->__in6_u.__u6_addr8;
#line 268
      inaddr = (in_addr_t )((int )*(p + 12) << 24);
#line 269
      inaddr += (in_addr_t )((int )*(p + 13) << 16);
#line 270
      inaddr += (in_addr_t )((int )*(p + 14) << 8);
#line 271
      inaddr += (in_addr_t )*(p + 15);
    } else {
#line 274
      inaddr = 4294967295U;
    }
#line 277
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 281
    sin = (struct sockaddr_in *)addr.sockaddr;
#line 282
    __x___0 = sin->sin_addr.s_addr;
#line 282
    __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 282
    inaddr = __v___0;
#line 283
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 287
    inaddr = 4294967295U;
  }
#line 290
  if (ctx->u.high.low) {
#line 291
    range = *(ctx->u.high.low + (inaddr >> 16));
#line 293
    if (range) {
#line 294
      n = (ngx_uint_t )(inaddr & 65535U);
      {
#line 295
      while (1) {
        while_continue: /* CIL Label */ ;
#line 296
        if (n >= (ngx_uint_t )range->start) {
#line 296
          if (n <= (ngx_uint_t )range->end) {
#line 299
            *v = *(range->value);
#line 300
            goto while_break;
          }
        }
#line 295
        range ++;
#line 295
        if (! range->value) {
#line 295
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 309
  return ((ngx_int_t )0);
}
}
#line 313 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                   ngx_addr_t *addr ) 
{ 
  ngx_array_t *xfwd ;
  ngx_int_t tmp ;

  {
  {
#line 319
  tmp = ngx_http_geo_real_addr(r, ctx, addr);
  }
#line 319
  if (tmp != 0L) {
#line 320
    return ((ngx_int_t )-1);
  }
#line 323
  xfwd = & r->headers_in.x_forwarded_for;
#line 325
  if (xfwd->nelts > 0UL) {
#line 325
    if ((unsigned long )ctx->proxies != (unsigned long )((void *)0)) {
      {
#line 326
      ngx_http_get_forwarded_addr(r, addr, xfwd, (ngx_str_t *)((void *)0), ctx->proxies,
                                  (int )ctx->proxy_recursive);
      }
    }
  }
#line 330
  return ((ngx_int_t )0);
}
}
#line 334 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_real_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                        ngx_addr_t *addr ) 
{ 
  ngx_http_variable_value_t *v ;
  ngx_int_t tmp ;

  {
#line 340
  if (ctx->index == -1L) {
#line 344
    addr->sockaddr = (r->connection)->sockaddr;
#line 345
    addr->socklen = (r->connection)->socklen;
#line 348
    return ((ngx_int_t )0);
  }
  {
#line 351
  v = ngx_http_get_flushed_variable(r, (ngx_uint_t )ctx->index);
  }
#line 353
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 357
    return ((ngx_int_t )-1);
  } else
#line 353
  if (v->not_found) {
#line 357
    return ((ngx_int_t )-1);
  }
  {
#line 363
  tmp = ngx_parse_addr(r->pool, addr, v->data, (size_t___0 )v->len);
  }
#line 363
  if (tmp == 0L) {
#line 364
    return ((ngx_int_t )0);
  }
#line 367
  return ((ngx_int_t )-1);
}
}
#line 385 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static struct in6_addr zero  ;
#line 371 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  size_t___0 len ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_pool_t *pool ;
  ngx_array_t *a ;
  ngx_http_variable_t *var ;
  ngx_http_geo_ctx_t *geo ;
  ngx_http_geo_conf_ctx_t ctx ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 388
  value = (ngx_str_t *)(cf->args)->elts;
#line 390
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_geo_ctx_t ));
#line 390
  geo = (ngx_http_geo_ctx_t *)tmp;
  }
#line 391
  if ((unsigned long )geo == (unsigned long )((void *)0)) {
#line 392
    return ((char *)((void *)-1));
  }
#line 395
  name = *(value + 1);
#line 397
  if ((int )*(name.data + 0) != 36) {
    {
#line 398
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
    }
#line 400
    return ((char *)((void *)-1));
  }
#line 403
  (name.len) --;
#line 404
  (name.data) ++;
#line 406
  if ((cf->args)->nelts == 3UL) {
    {
#line 408
    geo->index = ngx_http_get_variable_index(cf, & name);
    }
#line 409
    if (geo->index == -1L) {
#line 410
      return ((char *)((void *)-1));
    }
#line 413
    name = *(value + 2);
#line 415
    if ((int )*(name.data + 0) != 36) {
      {
#line 416
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
      }
#line 418
      return ((char *)((void *)-1));
    }
#line 421
    (name.len) --;
#line 422
    (name.data) ++;
  } else {
#line 425
    geo->index = (ngx_int_t )-1;
  }
  {
#line 428
  var = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
  }
#line 429
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 430
    return ((char *)((void *)-1));
  }
  {
#line 433
  pool = ngx_create_pool((size_t___0 )16384, cf->log);
  }
#line 434
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 435
    return ((char *)((void *)-1));
  }
  {
#line 438
  memset((void *)(& ctx), 0, sizeof(ngx_http_geo_conf_ctx_t ));
#line 440
  ctx.temp_pool = ngx_create_pool((size_t___0 )16384, cf->log);
  }
#line 441
  if ((unsigned long )ctx.temp_pool == (unsigned long )((void *)0)) {
#line 442
    return ((char *)((void *)-1));
  }
  {
#line 445
  ctx.sentinel.color = (u_char )0;
#line 445
  ctx.rbtree.root = & ctx.sentinel;
#line 445
  ctx.rbtree.sentinel = & ctx.sentinel;
#line 445
  ctx.rbtree.insert = & ngx_str_rbtree_insert_value;
#line 447
  ctx.pool = cf->pool;
#line 448
  ctx.data_size = (sizeof(ngx_http_geo_header_t ) + sizeof(ngx_http_variable_value_t )) + 65536UL * sizeof(ngx_http_geo_range_t *);
#line 451
  ctx.allow_binary_include = 1U;
#line 453
  save = *cf;
#line 454
  cf->pool = pool;
#line 455
  cf->ctx = (void *)(& ctx);
#line 456
  cf->handler = & ngx_http_geo;
#line 457
  cf->handler_conf = (char *)conf;
#line 459
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 461
  *cf = save;
#line 463
  geo->proxies = ctx.proxies;
#line 464
  geo->proxy_recursive = ctx.proxy_recursive;
  }
#line 466
  if (ctx.ranges) {
#line 468
    if (ctx.high.low) {
#line 468
      if (! ctx.binary_include) {
#line 469
        i = (ngx_uint_t )0;
        {
#line 469
        while (1) {
          while_continue: /* CIL Label */ ;
#line 469
          if (! (i < 65536UL)) {
#line 469
            goto while_break;
          }
#line 470
          a = (ngx_array_t *)*(ctx.high.low + i);
#line 472
          if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 473
            goto __Cont;
          }
#line 476
          if (a->nelts == 0UL) {
#line 477
            *(ctx.high.low + i) = (ngx_http_geo_range_t *)((void *)0);
#line 478
            goto __Cont;
          }
          {
#line 481
          len = a->nelts * sizeof(ngx_http_geo_range_t );
#line 483
          tmp___0 = ngx_palloc(cf->pool, len + sizeof(void *));
#line 483
          *(ctx.high.low + i) = (ngx_http_geo_range_t *)tmp___0;
          }
#line 484
          if ((unsigned long )*(ctx.high.low + i) == (unsigned long )((void *)0)) {
#line 485
            return ((char *)((void *)-1));
          }
          {
#line 488
          memcpy((void */* __restrict  */)*(ctx.high.low + i), (void const   */* __restrict  */)a->elts,
                 len);
#line 489
          (*(ctx.high.low + i) + a->nelts)->value = (ngx_http_variable_value_t *)((void *)0);
#line 490
          ctx.data_size += len + sizeof(void *);
          }
          __Cont: /* CIL Label */ 
#line 469
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 493
        if (ctx.allow_binary_include) {
#line 493
          if (! ctx.outside_entries) {
#line 493
            if (ctx.entries > 100000UL) {
#line 493
              if (ctx.includes == 1UL) {
                {
#line 498
                ngx_http_geo_create_binary_base(& ctx);
                }
              }
            }
          }
        }
      }
    }
#line 502
    if ((unsigned long )ctx.high.default_value == (unsigned long )((void *)0)) {
#line 503
      ctx.high.default_value = & ngx_http_variable_null_value;
    }
    {
#line 506
    geo->u.high = ctx.high;
#line 508
    var->get_handler = & ngx_http_geo_range_variable;
#line 509
    var->data = (uintptr_t )geo;
#line 511
    ngx_destroy_pool(ctx.temp_pool);
#line 512
    ngx_destroy_pool(pool);
    }
  } else {
#line 515
    if ((unsigned long )ctx.tree == (unsigned long )((void *)0)) {
      {
#line 516
      ctx.tree = ngx_radix_tree_create(cf->pool, (ngx_int_t )-1);
      }
#line 517
      if ((unsigned long )ctx.tree == (unsigned long )((void *)0)) {
#line 518
        return ((char *)((void *)-1));
      }
    }
#line 522
    geo->u.trees.tree = ctx.tree;
#line 525
    if ((unsigned long )ctx.tree6 == (unsigned long )((void *)0)) {
      {
#line 526
      ctx.tree6 = ngx_radix_tree_create(cf->pool, (ngx_int_t )-1);
      }
#line 527
      if ((unsigned long )ctx.tree6 == (unsigned long )((void *)0)) {
#line 528
        return ((char *)((void *)-1));
      }
    }
    {
#line 532
    geo->u.trees.tree6 = ctx.tree6;
#line 535
    var->get_handler = & ngx_http_geo_cidr_variable;
#line 536
    var->data = (uintptr_t )geo;
#line 538
    ngx_destroy_pool(ctx.temp_pool);
#line 539
    ngx_destroy_pool(pool);
#line 541
    tmp___1 = ngx_radix32tree_insert(ctx.tree, (uint32_t )0, (uint32_t )0, (uintptr_t )(& ngx_http_variable_null_value));
    }
#line 541
    if (tmp___1 == -1L) {
#line 545
      return ((char *)((void *)-1));
    }
    {
#line 551
    tmp___2 = ngx_radix128tree_insert(ctx.tree6, zero.__in6_u.__u6_addr8, zero.__in6_u.__u6_addr8,
                                      (uintptr_t )(& ngx_http_variable_null_value));
    }
#line 551
    if (tmp___2 == -1L) {
#line 555
      return ((char *)((void *)-1));
    }
  }
#line 560
  return (rv);
}
}
#line 564 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  char *rv ;
  ngx_str_t *value ;
  ngx_cidr_t cidr ;
  ngx_http_geo_conf_ctx_t *ctx ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 572
  ctx = (ngx_http_geo_conf_ctx_t *)cf->ctx;
#line 574
  value = (ngx_str_t *)(cf->args)->elts;
#line 576
  if ((cf->args)->nelts == 1UL) {
    {
#line 578
    tmp___0 = strcmp((char const   *)(value + 0)->data, "ranges");
    }
#line 578
    if (tmp___0 == 0) {
#line 580
      if (ctx->tree) {
        {
#line 586
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"ranges\" directive must be the first directive inside \"geo\" block");
        }
#line 589
        goto failed;
      } else
#line 580
      if (ctx->tree6) {
        {
#line 586
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"ranges\" directive must be the first directive inside \"geo\" block");
        }
#line 589
        goto failed;
      }
#line 592
      ctx->ranges = 1U;
#line 594
      rv = (char *)((void *)0);
#line 596
      goto done;
    } else {
      {
#line 599
      tmp = strcmp((char const   *)(value + 0)->data, "proxy_recursive");
      }
#line 599
      if (tmp == 0) {
#line 600
        ctx->proxy_recursive = 1U;
#line 601
        rv = (char *)((void *)0);
#line 602
        goto done;
      }
    }
  }
#line 606
  if ((cf->args)->nelts != 2UL) {
    {
#line 607
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of the geo parameters");
    }
#line 609
    goto failed;
  }
  {
#line 612
  tmp___3 = strcmp((char const   *)(value + 0)->data, "include");
  }
#line 612
  if (tmp___3 == 0) {
    {
#line 614
    rv = ngx_http_geo_include(cf, ctx, value + 1);
    }
#line 616
    goto done;
  } else {
    {
#line 618
    tmp___2 = strcmp((char const   *)(value + 0)->data, "proxy");
    }
#line 618
    if (tmp___2 == 0) {
      {
#line 620
      tmp___1 = ngx_http_geo_cidr_value(cf, value + 1, & cidr);
      }
#line 620
      if (tmp___1 != 0L) {
#line 621
        goto failed;
      }
      {
#line 624
      rv = ngx_http_geo_add_proxy(cf, ctx, & cidr);
      }
#line 626
      goto done;
    }
  }
#line 629
  if (ctx->ranges) {
    {
#line 630
    rv = ngx_http_geo_range(cf, ctx, value);
    }
  } else {
    {
#line 633
    rv = ngx_http_geo_cidr(cf, ctx, value);
    }
  }
  done: 
  {
#line 638
  ngx_reset_pool(cf->pool);
  }
#line 640
  return (rv);
  failed: 
  {
#line 644
  ngx_reset_pool(cf->pool);
  }
#line 646
  return ((char *)((void *)-1));
}
}
#line 650 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) 
{ 
  u_char *p ;
  u_char *last ;
  in_addr_t start ;
  in_addr_t end ;
  ngx_str_t *net ;
  ngx_uint_t del ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned int __v ;
  unsigned int __x ;
  unsigned int __v___0 ;
  unsigned int __x___0 ;
  ngx_uint_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 659
  tmp = strcmp((char const   *)(value + 0)->data, "default");
  }
#line 659
  if (tmp == 0) {
#line 661
    if (ctx->high.default_value) {
      {
#line 662
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate default geo range value: \"%V\", old value: \"%v\"",
                         value + 1, ctx->high.default_value);
      }
    }
    {
#line 667
    ctx->high.default_value = ngx_http_geo_value(cf, ctx, value + 1);
    }
#line 668
    if ((unsigned long )ctx->high.default_value == (unsigned long )((void *)0)) {
#line 669
      return ((char *)((void *)-1));
    }
#line 672
    return ((char *)((void *)0));
  }
#line 675
  if (ctx->binary_include) {
    {
#line 676
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "binary geo range base \"%s\" cannot be mixed with usual entries",
                       ctx->include_name.data);
    }
#line 679
    return ((char *)((void *)-1));
  }
#line 682
  if ((unsigned long )ctx->high.low == (unsigned long )((void *)0)) {
    {
#line 683
    tmp___0 = ngx_pcalloc(ctx->pool, 65536UL * sizeof(ngx_http_geo_range_t *));
#line 683
    ctx->high.low = (ngx_http_geo_range_t **)tmp___0;
    }
#line 685
    if ((unsigned long )ctx->high.low == (unsigned long )((void *)0)) {
#line 686
      return ((char *)((void *)-1));
    }
  }
  {
#line 690
  (ctx->entries) ++;
#line 691
  ctx->outside_entries = 1U;
#line 693
  tmp___1 = strcmp((char const   *)(value + 0)->data, "delete");
  }
#line 693
  if (tmp___1 == 0) {
#line 694
    net = value + 1;
#line 695
    del = (ngx_uint_t )1;
  } else {
#line 698
    net = value + 0;
#line 699
    del = (ngx_uint_t )0;
  }
  {
#line 702
  last = net->data + net->len;
#line 704
  p = ngx_strlchr(net->data, last, (u_char )'-');
  }
#line 706
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 707
    goto invalid;
  }
  {
#line 710
  start = ngx_inet_addr(net->data, (size_t___0 )(p - net->data));
  }
#line 712
  if (start == 4294967295U) {
#line 713
    goto invalid;
  }
  {
#line 716
  __x = start;
#line 716
  __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 716
  start = __v;
#line 718
  p ++;
#line 720
  end = ngx_inet_addr(p, (size_t___0 )(last - p));
  }
#line 722
  if (end == 4294967295U) {
#line 723
    goto invalid;
  }
#line 726
  __x___0 = end;
#line 726
  __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 726
  end = __v___0;
#line 728
  if (start > end) {
#line 729
    goto invalid;
  }
#line 732
  if (del) {
    {
#line 733
    tmp___2 = ngx_http_geo_delete_range(cf, ctx, start, end);
    }
#line 733
    if (tmp___2) {
      {
#line 734
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no address range \"%V\" to delete",
                         net);
      }
    }
#line 738
    return ((char *)((void *)0));
  }
  {
#line 741
  ctx->value = ngx_http_geo_value(cf, ctx, value + 1);
  }
#line 743
  if ((unsigned long )ctx->value == (unsigned long )((void *)0)) {
#line 744
    return ((char *)((void *)-1));
  }
  {
#line 747
  ctx->net = net;
#line 749
  tmp___3 = ngx_http_geo_add_range(cf, ctx, start, end);
  }
#line 749
  return (tmp___3);
  invalid: 
  {
#line 753
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid range \"%V\"", net);
  }
#line 755
  return ((char *)((void *)-1));
}
}
#line 761 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_add_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    in_addr_t start , in_addr_t end ) 
{ 
  in_addr_t n ;
  ngx_uint_t h ;
  ngx_uint_t i ;
  ngx_uint_t s ;
  ngx_uint_t e ;
  ngx_array_t *a ;
  ngx_http_geo_range_t *range ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 770
  n = start;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (n <= end)) {
#line 770
      goto while_break;
    }
#line 772
    h = (ngx_uint_t )(n >> 16);
#line 774
    if (n == start) {
#line 775
      s = (ngx_uint_t )(n & 65535U);
    } else {
#line 777
      s = (ngx_uint_t )0;
    }
#line 780
    if ((n | 65535U) > end) {
#line 781
      e = (ngx_uint_t )(end & 65535U);
    } else {
#line 784
      e = (ngx_uint_t )65535;
    }
#line 787
    a = (ngx_array_t *)*(ctx->high.low + h);
#line 789
    if ((unsigned long )a == (unsigned long )((void *)0)) {
      {
#line 790
      a = ngx_array_create(ctx->temp_pool, (ngx_uint_t )64, sizeof(ngx_http_geo_range_t ));
      }
#line 792
      if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 793
        return ((char *)((void *)-1));
      }
#line 796
      *(ctx->high.low + h) = (ngx_http_geo_range_t *)a;
    }
#line 799
    i = a->nelts;
#line 800
    range = (ngx_http_geo_range_t *)a->elts;
    {
#line 802
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 802
      if (! i) {
#line 802
        goto while_break___0;
      }
#line 804
      i --;
#line 806
      if (e < (ngx_uint_t )(range + i)->start) {
#line 807
        goto while_continue___0;
      }
#line 810
      if (s > (ngx_uint_t )(range + i)->end) {
        {
#line 814
        tmp = ngx_array_push(a);
#line 814
        range = (ngx_http_geo_range_t *)tmp;
        }
#line 815
        if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 816
          return ((char *)((void *)-1));
        }
        {
#line 819
        range = (ngx_http_geo_range_t *)a->elts;
#line 821
        memmove((void *)(range + (i + 2UL)), (void const   *)(range + (i + 1UL)),
                ((a->nelts - 2UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 824
        (range + (i + 1UL))->start = (u_short )s;
#line 825
        (range + (i + 1UL))->end = (u_short )e;
#line 826
        (range + (i + 1UL))->value = ctx->value;
        }
#line 828
        goto next;
      }
#line 831
      if (s == (ngx_uint_t )(range + i)->start) {
#line 831
        if (e == (ngx_uint_t )(range + i)->end) {
          {
#line 834
          ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate range \"%V\", value: \"%v\", old value: \"%v\"",
                             ctx->net, ctx->value, (range + i)->value);
#line 838
          (range + i)->value = ctx->value;
          }
#line 840
          goto next;
        }
      }
#line 843
      if (s > (ngx_uint_t )(range + i)->start) {
#line 843
        if (e < (ngx_uint_t )(range + i)->end) {
          {
#line 848
          tmp___0 = ngx_array_push(a);
#line 848
          range = (ngx_http_geo_range_t *)tmp___0;
          }
#line 849
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 850
            return ((char *)((void *)-1));
          }
          {
#line 853
          tmp___1 = ngx_array_push(a);
#line 853
          range = (ngx_http_geo_range_t *)tmp___1;
          }
#line 854
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 855
            return ((char *)((void *)-1));
          }
          {
#line 858
          range = (ngx_http_geo_range_t *)a->elts;
#line 860
          memmove((void *)(range + (i + 3UL)), (void const   *)(range + (i + 1UL)),
                  ((a->nelts - 3UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 863
          (range + (i + 2UL))->start = (u_short )(e + 1UL);
#line 864
          (range + (i + 2UL))->end = (range + i)->end;
#line 865
          (range + (i + 2UL))->value = (range + i)->value;
#line 867
          (range + (i + 1UL))->start = (u_short )s;
#line 868
          (range + (i + 1UL))->end = (u_short )e;
#line 869
          (range + (i + 1UL))->value = ctx->value;
#line 871
          (range + i)->end = (u_short )(s - 1UL);
          }
#line 873
          goto next;
        }
      }
#line 876
      if (s == (ngx_uint_t )(range + i)->start) {
#line 876
        if (e < (ngx_uint_t )(range + i)->end) {
          {
#line 881
          tmp___2 = ngx_array_push(a);
#line 881
          range = (ngx_http_geo_range_t *)tmp___2;
          }
#line 882
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 883
            return ((char *)((void *)-1));
          }
          {
#line 886
          range = (ngx_http_geo_range_t *)a->elts;
#line 888
          memmove((void *)(range + (i + 1UL)), (void const   *)(range + i), ((a->nelts - 1UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 891
          (range + (i + 1UL))->start = (u_short )(e + 1UL);
#line 893
          (range + i)->start = (u_short )s;
#line 894
          (range + i)->end = (u_short )e;
#line 895
          (range + i)->value = ctx->value;
          }
#line 897
          goto next;
        }
      }
#line 900
      if (s > (ngx_uint_t )(range + i)->start) {
#line 900
        if (e == (ngx_uint_t )(range + i)->end) {
          {
#line 905
          tmp___3 = ngx_array_push(a);
#line 905
          range = (ngx_http_geo_range_t *)tmp___3;
          }
#line 906
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 907
            return ((char *)((void *)-1));
          }
          {
#line 910
          range = (ngx_http_geo_range_t *)a->elts;
#line 912
          memmove((void *)(range + (i + 2UL)), (void const   *)(range + (i + 1UL)),
                  ((a->nelts - 2UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 915
          (range + (i + 1UL))->start = (u_short )s;
#line 916
          (range + (i + 1UL))->end = (u_short )e;
#line 917
          (range + (i + 1UL))->value = ctx->value;
#line 919
          (range + i)->end = (u_short )(s - 1UL);
          }
#line 921
          goto next;
        }
      }
      {
#line 924
      s = (ngx_uint_t )(range + i)->start;
#line 925
      e = (ngx_uint_t )(range + i)->end;
#line 927
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "range \"%V\" overlaps \"%d.%d.%d.%d-%d.%d.%d.%d\"",
                         ctx->net, h >> 8, h & 255UL, s >> 8, s & 255UL, h >> 8, h & 255UL,
                         e >> 8, e & 255UL);
      }
#line 933
      return ((char *)((void *)-1));
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 938
    tmp___4 = ngx_array_push(a);
#line 938
    range = (ngx_http_geo_range_t *)tmp___4;
    }
#line 939
    if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 940
      return ((char *)((void *)-1));
    }
    {
#line 943
    range = (ngx_http_geo_range_t *)a->elts;
#line 945
    memmove((void *)(range + 1), (void const   *)(range + 0), (a->nelts - 1UL) * sizeof(ngx_http_geo_range_t ));
#line 948
    (range + 0)->start = (u_short )s;
#line 949
    (range + 0)->end = (u_short )e;
#line 950
    (range + 0)->value = ctx->value;
    }
    next: 
#line 954
    if (h == 65535UL) {
#line 955
      goto while_break;
    }
#line 770
    n = (n + 65536U) & 4294901760U;
  }
  while_break: /* CIL Label */ ;
  }
#line 959
  return ((char *)((void *)0));
}
}
#line 963 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_uint_t ngx_http_geo_delete_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                            in_addr_t start , in_addr_t end ) 
{ 
  in_addr_t n ;
  ngx_uint_t h ;
  ngx_uint_t i ;
  ngx_uint_t s ;
  ngx_uint_t e ;
  ngx_uint_t warn ;
  ngx_array_t *a ;
  ngx_http_geo_range_t *range ;

  {
#line 972
  warn = (ngx_uint_t )0;
#line 974
  n = start;
  {
#line 974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    if (! (n <= end)) {
#line 974
      goto while_break;
    }
#line 976
    h = (ngx_uint_t )(n >> 16);
#line 978
    if (n == start) {
#line 979
      s = (ngx_uint_t )(n & 65535U);
    } else {
#line 981
      s = (ngx_uint_t )0;
    }
#line 984
    if ((n | 65535U) > end) {
#line 985
      e = (ngx_uint_t )(end & 65535U);
    } else {
#line 988
      e = (ngx_uint_t )65535;
    }
#line 991
    a = (ngx_array_t *)*(ctx->high.low + h);
#line 993
    if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 994
      warn = (ngx_uint_t )1;
#line 995
      goto next;
    } else
#line 993
    if (a->nelts == 0UL) {
#line 994
      warn = (ngx_uint_t )1;
#line 995
      goto next;
    }
#line 998
    range = (ngx_http_geo_range_t *)a->elts;
#line 999
    i = (ngx_uint_t )0;
    {
#line 999
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 999
      if (! (i < a->nelts)) {
#line 999
        goto while_break___0;
      }
#line 1001
      if (s == (ngx_uint_t )(range + i)->start) {
#line 1001
        if (e == (ngx_uint_t )(range + i)->end) {
          {
#line 1004
          memmove((void *)(range + i), (void const   *)(range + (i + 1UL)), ((a->nelts - 1UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 1007
          (a->nelts) --;
          }
#line 1009
          goto while_break___0;
        }
      }
#line 1012
      if (i == a->nelts - 1UL) {
#line 1013
        warn = (ngx_uint_t )1;
      }
#line 999
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    next: 
#line 1019
    if (h == 65535UL) {
#line 1020
      goto while_break;
    }
#line 974
    n = (n + 65536U) & 4294901760U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  return (warn);
}
}
#line 1028 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_cidr(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) 
{ 
  char *rv ;
  ngx_int_t rc ;
  ngx_int_t del ;
  ngx_str_t *net ;
  ngx_cidr_t cidr ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  unsigned int __v ;
  unsigned int __x ;
  unsigned int __v___0 ;
  unsigned int __x___0 ;
  char *tmp___2 ;

  {
#line 1037
  if ((unsigned long )ctx->tree == (unsigned long )((void *)0)) {
    {
#line 1038
    ctx->tree = ngx_radix_tree_create(ctx->pool, (ngx_int_t )-1);
    }
#line 1039
    if ((unsigned long )ctx->tree == (unsigned long )((void *)0)) {
#line 1040
      return ((char *)((void *)-1));
    }
  }
#line 1045
  if ((unsigned long )ctx->tree6 == (unsigned long )((void *)0)) {
    {
#line 1046
    ctx->tree6 = ngx_radix_tree_create(ctx->pool, (ngx_int_t )-1);
    }
#line 1047
    if ((unsigned long )ctx->tree6 == (unsigned long )((void *)0)) {
#line 1048
      return ((char *)((void *)-1));
    }
  }
  {
#line 1053
  tmp = strcmp((char const   *)(value + 0)->data, "default");
  }
#line 1053
  if (tmp == 0) {
    {
#line 1054
    cidr.family = (ngx_uint_t )2;
#line 1055
    cidr.u.in.addr = (in_addr_t )0;
#line 1056
    cidr.u.in.mask = (in_addr_t )0;
#line 1058
    rv = ngx_http_geo_cidr_add(cf, ctx, & cidr, value + 1, value + 0);
    }
#line 1060
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 1061
      return (rv);
    }
    {
#line 1065
    cidr.family = (ngx_uint_t )10;
#line 1066
    memset((void *)(& cidr.u.in6), 0, sizeof(ngx_in6_cidr_t ));
#line 1068
    rv = ngx_http_geo_cidr_add(cf, ctx, & cidr, value + 1, value + 0);
    }
#line 1070
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 1071
      return (rv);
    }
#line 1075
    return ((char *)((void *)0));
  }
  {
#line 1078
  tmp___0 = strcmp((char const   *)(value + 0)->data, "delete");
  }
#line 1078
  if (tmp___0 == 0) {
#line 1079
    net = value + 1;
#line 1080
    del = (ngx_int_t )1;
  } else {
#line 1083
    net = value + 0;
#line 1084
    del = (ngx_int_t )0;
  }
  {
#line 1087
  tmp___1 = ngx_http_geo_cidr_value(cf, net, & cidr);
  }
#line 1087
  if (tmp___1 != 0L) {
#line 1088
    return ((char *)((void *)-1));
  }
#line 1091
  if (cidr.family == 2UL) {
#line 1092
    __x = cidr.u.in.addr;
#line 1092
    __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 1092
    cidr.u.in.addr = __v;
#line 1093
    __x___0 = cidr.u.in.mask;
#line 1093
    __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 1093
    cidr.u.in.mask = __v___0;
  }
#line 1096
  if (del) {
    {
#line 1100
    if (cidr.family == 10UL) {
#line 1100
      goto case_10;
    }
#line 1107
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 1101
    rc = ngx_radix128tree_delete(ctx->tree6, cidr.u.in6.addr.__in6_u.__u6_addr8, cidr.u.in6.mask.__in6_u.__u6_addr8);
    }
#line 1104
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1108
    rc = ngx_radix32tree_delete(ctx->tree, cidr.u.in.addr, cidr.u.in.mask);
    }
#line 1110
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1113
    if (rc != 0L) {
      {
#line 1114
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no network \"%V\" to delete", net);
      }
    }
#line 1118
    return ((char *)((void *)0));
  }
  {
#line 1121
  tmp___2 = ngx_http_geo_cidr_add(cf, ctx, & cidr, value + 1, net);
  }
#line 1121
  return (tmp___2);
}
}
#line 1125 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_cidr_add(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                   ngx_cidr_t *cidr , ngx_str_t *value , ngx_str_t *net ) 
{ 
  ngx_int_t rc ;
  ngx_http_variable_value_t *val ;
  ngx_http_variable_value_t *old ;
  uintptr_t tmp ;
  uintptr_t tmp___0 ;

  {
  {
#line 1132
  val = ngx_http_geo_value(cf, ctx, value);
  }
#line 1134
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1135
    return ((char *)((void *)-1));
  }
  {
#line 1141
  if (cidr->family == 10UL) {
#line 1141
    goto case_10;
  }
#line 1180
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1142
  rc = ngx_radix128tree_insert(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8, cidr->u.in6.mask.__in6_u.__u6_addr8,
                               (uintptr_t )val);
  }
#line 1146
  if (rc == 0L) {
#line 1147
    return ((char *)((void *)0));
  }
#line 1150
  if (rc == -1L) {
#line 1151
    return ((char *)((void *)-1));
  }
  {
#line 1156
  tmp = ngx_radix128tree_find(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8);
#line 1156
  old = (ngx_http_variable_value_t *)tmp;
#line 1160
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate network \"%V\", value: \"%v\", old value: \"%v\"",
                     net, val, old);
#line 1164
  rc = ngx_radix128tree_delete(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8, cidr->u.in6.mask.__in6_u.__u6_addr8);
  }
#line 1168
  if (rc == -1L) {
    {
#line 1169
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid radix tree");
    }
#line 1170
    return ((char *)((void *)-1));
  }
  {
#line 1173
  rc = ngx_radix128tree_insert(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8, cidr->u.in6.mask.__in6_u.__u6_addr8,
                               (uintptr_t )val);
  }
#line 1177
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1181
  rc = ngx_radix32tree_insert(ctx->tree, cidr->u.in.addr, cidr->u.in.mask, (uintptr_t )val);
  }
#line 1184
  if (rc == 0L) {
#line 1185
    return ((char *)((void *)0));
  }
#line 1188
  if (rc == -1L) {
#line 1189
    return ((char *)((void *)-1));
  }
  {
#line 1194
  tmp___0 = ngx_radix32tree_find(ctx->tree, cidr->u.in.addr);
#line 1194
  old = (ngx_http_variable_value_t *)tmp___0;
#line 1197
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate network \"%V\", value: \"%v\", old value: \"%v\"",
                     net, val, old);
#line 1201
  rc = ngx_radix32tree_delete(ctx->tree, cidr->u.in.addr, cidr->u.in.mask);
  }
#line 1204
  if (rc == -1L) {
    {
#line 1205
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid radix tree");
    }
#line 1206
    return ((char *)((void *)-1));
  }
  {
#line 1209
  rc = ngx_radix32tree_insert(ctx->tree, cidr->u.in.addr, cidr->u.in.mask, (uintptr_t )val);
  }
#line 1212
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1215
  if (rc == 0L) {
#line 1216
    return ((char *)((void *)0));
  }
#line 1219
  return ((char *)((void *)-1));
}
}
#line 1223 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_http_variable_value_t *ngx_http_geo_value(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                     ngx_str_t *value ) 
{ 
  uint32_t hash ;
  ngx_http_variable_value_t *val ;
  ngx_http_geo_variable_value_node_t *gvvn ;
  ngx_str_node_t *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1231
  hash = ngx_crc32_long(value->data, value->len);
#line 1233
  tmp = ngx_str_rbtree_lookup(& ctx->rbtree, value, hash);
#line 1233
  gvvn = (ngx_http_geo_variable_value_node_t *)tmp;
  }
#line 1236
  if (gvvn) {
#line 1237
    return (gvvn->value);
  }
  {
#line 1240
  tmp___0 = ngx_palloc(ctx->pool, sizeof(ngx_http_variable_value_t ));
#line 1240
  val = (ngx_http_variable_value_t *)tmp___0;
  }
#line 1241
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1242
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 1245
  val->len = (unsigned int )value->len;
#line 1246
  val->data = ngx_pstrdup(ctx->pool, value);
  }
#line 1247
  if ((unsigned long )val->data == (unsigned long )((void *)0)) {
#line 1248
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 1251
  val->valid = 1U;
#line 1252
  val->no_cacheable = 0U;
#line 1253
  val->not_found = 0U;
#line 1255
  tmp___1 = ngx_palloc(ctx->temp_pool, sizeof(ngx_http_geo_variable_value_node_t ));
#line 1255
  gvvn = (ngx_http_geo_variable_value_node_t *)tmp___1;
  }
#line 1257
  if ((unsigned long )gvvn == (unsigned long )((void *)0)) {
#line 1258
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 1261
  gvvn->sn.node.key = (ngx_rbtree_key_t )hash;
#line 1262
  gvvn->sn.str.len = (size_t___0 )val->len;
#line 1263
  gvvn->sn.str.data = val->data;
#line 1264
  gvvn->value = val;
#line 1265
  gvvn->offset = (size_t___0 )0;
#line 1267
  ngx_rbtree_insert(& ctx->rbtree, & gvvn->sn.node);
#line 1269
  ctx->data_size += ((sizeof(ngx_http_variable_value_t ) + value->len) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL);
  }
#line 1272
  return (val);
}
}
#line 1276 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_add_proxy(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    ngx_cidr_t *cidr ) 
{ 
  ngx_cidr_t *c ;
  void *tmp ;

  {
#line 1282
  if ((unsigned long )ctx->proxies == (unsigned long )((void *)0)) {
    {
#line 1283
    ctx->proxies = ngx_array_create(ctx->pool, (ngx_uint_t )4, sizeof(ngx_cidr_t ));
    }
#line 1284
    if ((unsigned long )ctx->proxies == (unsigned long )((void *)0)) {
#line 1285
      return ((char *)((void *)-1));
    }
  }
  {
#line 1289
  tmp = ngx_array_push(ctx->proxies);
#line 1289
  c = (ngx_cidr_t *)tmp;
  }
#line 1290
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1291
    return ((char *)((void *)-1));
  }
#line 1294
  *c = *cidr;
#line 1296
  return ((char *)((void *)0));
}
}
#line 1300 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_cidr_value(ngx_conf_t *cf , ngx_str_t *net , ngx_cidr_t *cidr ) 
{ 
  ngx_int_t rc ;
  int tmp ;

  {
  {
#line 1305
  tmp = strcmp((char const   *)net->data, "255.255.255.255");
  }
#line 1305
  if (tmp == 0) {
#line 1306
    cidr->family = (ngx_uint_t )2;
#line 1307
    cidr->u.in.addr = 4294967295U;
#line 1308
    cidr->u.in.mask = 4294967295U;
#line 1310
    return ((ngx_int_t )0);
  }
  {
#line 1313
  rc = ngx_ptocidr(net, cidr);
  }
#line 1315
  if (rc == -1L) {
    {
#line 1316
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid network \"%V\"", net);
    }
#line 1317
    return ((ngx_int_t )-1);
  }
#line 1320
  if (rc == -4L) {
    {
#line 1321
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "low address bits of %V are meaningless",
                       net);
    }
  }
#line 1325
  return ((ngx_int_t )0);
}
}
#line 1329 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_include(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                  ngx_str_t *name ) 
{ 
  char *rv ;
  ngx_str_t file ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 1336
  file.len = name->len + 4UL;
#line 1337
  tmp = ngx_pnalloc(ctx->temp_pool, name->len + 5UL);
#line 1337
  file.data = (u_char *)tmp;
  }
#line 1338
  if ((unsigned long )file.data == (unsigned long )((void *)0)) {
#line 1339
    return ((char *)((void *)-1));
  }
  {
#line 1342
  ngx_sprintf(file.data, "%V.bin%Z", name);
#line 1344
  tmp___0 = ngx_conf_full_name(cf->cycle, & file, (ngx_uint_t )1);
  }
#line 1344
  if (tmp___0 != 0L) {
#line 1345
    return ((char *)((void *)-1));
  }
#line 1348
  if (ctx->ranges) {
    {
#line 1351
    tmp___1 = ngx_http_geo_include_binary_base(cf, ctx, & file);
    }
    {
#line 1352
    if (tmp___1 == 0L) {
#line 1352
      goto case_0;
    }
#line 1354
    if (tmp___1 == -1L) {
#line 1354
      goto case_neg_1;
    }
#line 1356
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1353
    return ((char *)((void *)0));
    case_neg_1: /* CIL Label */ 
#line 1355
    return ((char *)((void *)-1));
    switch_default: /* CIL Label */ 
#line 1357
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1361
  file.len -= 4UL;
#line 1362
  *(file.data + file.len) = (u_char )'\000';
#line 1364
  ctx->include_name = file;
#line 1366
  if (ctx->outside_entries) {
#line 1367
    ctx->allow_binary_include = 0U;
  }
  {
#line 1372
  rv = ngx_conf_parse(cf, & file);
#line 1374
  (ctx->includes) ++;
#line 1375
  ctx->outside_entries = 0U;
  }
#line 1377
  return (rv);
}
}
#line 1381 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_include_binary_base(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                  ngx_str_t *name ) 
{ 
  u_char *base ;
  u_char ch ;
  time_t mtime ;
  size_t___0 size ;
  size_t___0 len ;
  ssize_t n ;
  uint32_t crc32___0 ;
  ngx_err_t err ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_file_t file ;
  ngx_file_info_t fi ;
  ngx_http_geo_range_t *range ;
  ngx_http_geo_range_t **ranges ;
  ngx_http_geo_header_t *header___0 ;
  ngx_http_variable_value_t *vv ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1399
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 1400
  file.name = *name;
#line 1401
  file.log = cf->log;
#line 1403
  file.fd = open((char const   *)name->data, 0, 0);
  }
#line 1404
  if (file.fd == -1) {
    {
#line 1405
    tmp = __errno_location();
#line 1405
    err = *tmp;
    }
#line 1406
    if (err != 2) {
      {
#line 1407
      ngx_conf_log_error((ngx_uint_t )3, cf, err, "open() \"%s\" failed", name->data);
      }
    }
#line 1410
    return ((ngx_int_t )-5);
  }
#line 1413
  if (ctx->outside_entries) {
    {
#line 1414
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "binary geo range base \"%s\" cannot be mixed with usual entries",
                       name->data);
#line 1417
    rc = (ngx_int_t )-1;
    }
#line 1418
    goto done;
  }
#line 1421
  if (ctx->binary_include) {
    {
#line 1422
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "second binary geo range base \"%s\" cannot be mixed with \"%s\"",
                       name->data, ctx->include_name.data);
#line 1425
    rc = (ngx_int_t )-1;
    }
#line 1426
    goto done;
  }
  {
#line 1429
  tmp___1 = fstat(file.fd, & fi);
  }
#line 1429
  if (tmp___1 == -1) {
    {
#line 1430
    tmp___0 = __errno_location();
#line 1430
    ngx_conf_log_error((ngx_uint_t )3, cf, *tmp___0, "fstat() \"%s\" failed", name->data);
    }
#line 1432
    goto failed;
  }
  {
#line 1435
  size = (size_t___0 )fi.st_size;
#line 1436
  mtime = fi.st_mtim.tv_sec;
#line 1438
  ch = *(name->data + (name->len - 4UL));
#line 1439
  *(name->data + (name->len - 4UL)) = (u_char )'\000';
#line 1441
  tmp___3 = stat((char const   */* __restrict  */)((char const   *)name->data), (struct stat */* __restrict  */)(& fi));
  }
#line 1441
  if (tmp___3 == -1) {
    {
#line 1442
    tmp___2 = __errno_location();
#line 1442
    ngx_conf_log_error((ngx_uint_t )3, cf, *tmp___2, "stat() \"%s\" failed", name->data);
    }
#line 1444
    goto failed;
  }
#line 1447
  *(name->data + (name->len - 4UL)) = ch;
#line 1449
  if (mtime < fi.st_mtim.tv_sec) {
    {
#line 1450
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "stale binary geo range base \"%s\"",
                       name->data);
    }
#line 1452
    goto failed;
  }
  {
#line 1455
  tmp___4 = ngx_palloc(ctx->pool, size);
#line 1455
  base = (u_char *)tmp___4;
  }
#line 1456
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 1457
    goto failed;
  }
  {
#line 1460
  n = ngx_read_file(& file, base, size, (off_t )0);
  }
#line 1462
  if (n == -1L) {
    {
#line 1463
    tmp___5 = __errno_location();
#line 1463
    ngx_conf_log_error((ngx_uint_t )3, cf, *tmp___5, "pread() \"%s\" failed", name->data);
    }
#line 1465
    goto failed;
  }
#line 1468
  if ((size_t___0 )n != size) {
    {
#line 1469
    ngx_conf_log_error((ngx_uint_t )3, cf, 0, "pread() \"%s\" returned only %z bytes instead of %z",
                       name->data, n, size);
    }
#line 1472
    goto failed;
  }
#line 1475
  header___0 = (ngx_http_geo_header_t *)base;
#line 1477
  if (size < 16UL) {
    {
#line 1478
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "incompatible binary geo range base \"%s\"",
                       name->data);
    }
#line 1480
    goto failed;
  } else {
    {
#line 1477
    tmp___6 = memcmp((void const   *)((char const   *)(& ngx_http_geo_header)), (void const   *)((char const   *)header___0),
                     (size_t )12);
    }
#line 1477
    if (tmp___6 != 0) {
      {
#line 1478
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "incompatible binary geo range base \"%s\"",
                         name->data);
      }
#line 1480
      goto failed;
    }
  }
#line 1483
  crc32___0 = 4294967295U;
#line 1485
  vv = (ngx_http_variable_value_t *)(base + sizeof(ngx_http_geo_header_t ));
  {
#line 1487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1487
    if (! vv->data) {
#line 1487
      goto while_break;
    }
    {
#line 1488
    len = ((sizeof(ngx_http_variable_value_t ) + (unsigned long )vv->len) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL);
#line 1490
    ngx_crc32_update(& crc32___0, (u_char *)vv, len);
#line 1491
    vv->data += (size_t___0 )base;
#line 1492
    vv = (ngx_http_variable_value_t *)((u_char *)vv + len);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1494
  ngx_crc32_update(& crc32___0, (u_char *)vv, sizeof(ngx_http_variable_value_t ));
#line 1495
  vv ++;
#line 1497
  ranges = (ngx_http_geo_range_t **)vv;
#line 1499
  i = (ngx_uint_t )0;
  }
  {
#line 1499
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1499
    if (! (i < 65536UL)) {
#line 1499
      goto while_break___0;
    }
    {
#line 1500
    ngx_crc32_update(& crc32___0, (u_char *)(ranges + i), sizeof(void *));
    }
#line 1501
    if (*(ranges + i)) {
#line 1502
      *(ranges + i) = (ngx_http_geo_range_t *)((u_char *)*(ranges + i) + (size_t___0 )base);
    }
#line 1499
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1507
  range = (ngx_http_geo_range_t *)(ranges + 65536);
  {
#line 1509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1509
    if (! ((unsigned long )((u_char *)range) < (unsigned long )(base + size))) {
#line 1509
      goto while_break___1;
    }
    {
#line 1510
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1510
      if (! range->value) {
#line 1510
        goto while_break___2;
      }
      {
#line 1511
      ngx_crc32_update(& crc32___0, (u_char *)range, sizeof(ngx_http_geo_range_t ));
#line 1513
      range->value = (ngx_http_variable_value_t *)((u_char *)range->value + (size_t___0 )base);
#line 1515
      range ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1517
    ngx_crc32_update(& crc32___0, (u_char *)range, sizeof(void *));
#line 1518
    range = (ngx_http_geo_range_t *)((u_char *)range + sizeof(void *));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1521
  crc32___0 ^= 4294967295U;
#line 1523
  if (crc32___0 != header___0->crc32) {
    {
#line 1524
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "CRC32 mismatch in binary geo range base \"%s\"",
                       name->data);
    }
#line 1526
    goto failed;
  }
  {
#line 1529
  ngx_conf_log_error((ngx_uint_t )6, cf, 0, "using binary geo range base \"%s\"",
                     name->data);
#line 1532
  ctx->include_name = *name;
#line 1533
  ctx->binary_include = 1U;
#line 1534
  ctx->high.low = ranges;
#line 1535
  rc = (ngx_int_t )0;
  }
#line 1537
  goto done;
  failed: 
#line 1541
  rc = (ngx_int_t )-5;
  done: 
  {
#line 1545
  tmp___8 = close(file.fd);
  }
#line 1545
  if (tmp___8 == -1) {
#line 1546
    if ((cf->log)->log_level >= 2UL) {
      {
#line 1546
      tmp___7 = __errno_location();
#line 1546
      ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___7, "close() \"%s\" failed",
                         name->data);
      }
    }
  }
#line 1550
  return (rc);
}
}
#line 1554 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static void ngx_http_geo_create_binary_base(ngx_http_geo_conf_ctx_t *ctx ) 
{ 
  u_char *p ;
  uint32_t hash ;
  ngx_str_t s ;
  ngx_uint_t i ;
  ngx_file_mapping_t fm ;
  ngx_http_geo_range_t *r ;
  ngx_http_geo_range_t *range ;
  ngx_http_geo_range_t **ranges ;
  ngx_http_geo_header_t *header___0 ;
  ngx_http_geo_variable_value_node_t *gvvn ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_str_node_t *tmp___2 ;

  {
  {
#line 1566
  tmp = ngx_pnalloc(ctx->temp_pool, ctx->include_name.len + 5UL);
#line 1566
  fm.name = (u_char *)tmp;
  }
#line 1567
  if ((unsigned long )fm.name == (unsigned long )((void *)0)) {
#line 1568
    return;
  }
  {
#line 1571
  ngx_sprintf(fm.name, "%V.bin%Z", & ctx->include_name);
#line 1573
  fm.size = ctx->data_size;
#line 1574
  fm.log = (ctx->pool)->log;
  }
#line 1576
  if ((fm.log)->log_level >= 6UL) {
    {
#line 1576
    ngx_log_error_core((ngx_uint_t )6, fm.log, 0, "creating binary geo range base \"%s\"",
                       fm.name);
    }
  }
  {
#line 1579
  tmp___0 = ngx_create_file_mapping(& fm);
  }
#line 1579
  if (tmp___0 != 0L) {
#line 1580
    return;
  }
  {
#line 1583
  tmp___1 = memcpy((void */* __restrict  */)fm.addr, (void const   */* __restrict  */)(& ngx_http_geo_header),
                   sizeof(ngx_http_geo_header_t ));
#line 1583
  p = (u_char *)tmp___1 + sizeof(ngx_http_geo_header_t );
#line 1586
  p = ngx_http_geo_copy_values((u_char *)fm.addr, p, ctx->rbtree.root, ctx->rbtree.sentinel);
#line 1589
  p += sizeof(ngx_http_variable_value_t );
#line 1591
  ranges = (ngx_http_geo_range_t **)p;
#line 1593
  p += 65536UL * sizeof(ngx_http_geo_range_t *);
#line 1595
  i = (ngx_uint_t )0;
  }
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1595
    if (! (i < 65536UL)) {
#line 1595
      goto while_break;
    }
#line 1596
    r = *(ctx->high.low + i);
#line 1597
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1598
      goto __Cont;
    }
#line 1601
    range = (ngx_http_geo_range_t *)p;
#line 1602
    *(ranges + i) = (ngx_http_geo_range_t *)(p - (u_char *)fm.addr);
    {
#line 1604
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1605
      s.len = (size_t___0 )(r->value)->len;
#line 1606
      s.data = (r->value)->data;
#line 1607
      hash = ngx_crc32_long(s.data, s.len);
#line 1608
      tmp___2 = ngx_str_rbtree_lookup(& ctx->rbtree, & s, hash);
#line 1608
      gvvn = (ngx_http_geo_variable_value_node_t *)tmp___2;
#line 1611
      range->value = (ngx_http_variable_value_t *)gvvn->offset;
#line 1612
      range->start = r->start;
#line 1613
      range->end = r->end;
#line 1614
      range ++;
#line 1604
      r ++;
      }
#line 1604
      if (! r->value) {
#line 1604
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1618
    range->value = (ngx_http_variable_value_t *)((void *)0);
#line 1620
    p = (u_char *)range + sizeof(void *);
    __Cont: /* CIL Label */ 
#line 1595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1623
  header___0 = (ngx_http_geo_header_t *)fm.addr;
#line 1624
  header___0->crc32 = ngx_crc32_long((u_char *)fm.addr + sizeof(ngx_http_geo_header_t ),
                                     fm.size - sizeof(ngx_http_geo_header_t ));
#line 1628
  ngx_close_file_mapping(& fm);
  }
#line 1629
  return;
}
}
#line 1632 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_geo_module.c"
static u_char *ngx_http_geo_copy_values(u_char *base , u_char *p , ngx_rbtree_node_t *node ,
                                        ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_http_variable_value_t *vv ;
  ngx_http_geo_variable_value_node_t *gvvn ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1639
  if ((unsigned long )node == (unsigned long )sentinel) {
#line 1640
    return (p);
  }
  {
#line 1643
  gvvn = (ngx_http_geo_variable_value_node_t *)node;
#line 1644
  gvvn->offset = (size_t___0 )(p - base);
#line 1646
  vv = (ngx_http_variable_value_t *)p;
#line 1647
  *vv = *(gvvn->value);
#line 1648
  p += sizeof(ngx_http_variable_value_t );
#line 1649
  vv->data = (u_char *)(p - base);
#line 1651
  tmp = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)gvvn->sn.str.data,
               gvvn->sn.str.len);
#line 1651
  p = (u_char *)tmp + gvvn->sn.str.len;
#line 1653
  p = (u_char *)(((uintptr_t )p + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL));
#line 1655
  p = ngx_http_geo_copy_values(base, p, node->left, sentinel);
#line 1657
  tmp___0 = ngx_http_geo_copy_values(base, p, node->right, sentinel);
  }
#line 1657
  return (tmp___0);
}
}
#line 16 "src/core/ngx_crc32.h"
uint32_t *ngx_crc32_table_short ;
#line 20 "src/core/ngx_crc32.h"
__inline static uint32_t ngx_crc32_short(u_char *p , size_t___0 len ) 
{ 
  u_char c ;
  uint32_t crc ;
  u_char *tmp ;
  size_t___0 tmp___0 ;

  {
#line 26
  crc = 4294967295U;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    tmp___0 = len;
#line 28
    len --;
#line 28
    if (! tmp___0) {
#line 28
      goto while_break;
    }
#line 29
    tmp = p;
#line 29
    p ++;
#line 29
    c = *tmp;
#line 30
    crc = *(ngx_crc32_table_short + ((crc ^ (unsigned int )((int )c & 15)) & 15U)) ^ (crc >> 4);
#line 31
    crc = *(ngx_crc32_table_short + ((crc ^ (unsigned int )((int )c >> 4)) & 15U)) ^ (crc >> 4);
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return (crc ^ 4294967295U);
}
}
#line 49 "src/core/ngx_times.h"
ngx_msec_t volatile   ngx_current_msec ;
#line 44 "src/core/ngx_shmtx.h"
void ngx_shmtx_lock(ngx_shmtx_t *mtx ) ;
#line 45
void ngx_shmtx_unlock(ngx_shmtx_t *mtx ) ;
#line 64 "src/core/ngx_slab.h"
void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool , size_t___0 size ) ;
#line 68
void ngx_slab_free_locked(ngx_slab_pool_t *pool , void *p ) ;
#line 516 "src/event/ngx_event.h"
ngx_int_t ngx_handle_write_event(ngx_event_t *wev , size_t___0 lowat ) ;
#line 50 "src/event/ngx_event_timer.h"
__inline static void ngx_event_add_timer(ngx_event_t *ev , ngx_msec_t timer ) 
{ 
  ngx_msec_t key ;
  ngx_msec_int_t diff ;
  ngx_msec_int_t tmp ;

  {
#line 56
  key = (ngx_msec_t )(ngx_current_msec + (ngx_msec_t volatile   )timer);
#line 58
  if (ev->timer_set) {
#line 66
    diff = (ngx_msec_int_t )(key - ev->timer.key);
#line 68
    if (diff >= 0L) {
#line 68
      tmp = diff;
    } else {
#line 68
      tmp = - diff;
    }
#line 68
    if (tmp < 300L) {
#line 72
      return;
    }
    {
#line 75
    ngx_event_del_timer(ev);
    }
  }
  {
#line 78
  ev->timer.key = key;
#line 84
  ngx_rbtree_insert(& ngx_event_timer_rbtree, & ev->timer);
#line 86
  ev->timer_set = 1U;
  }
#line 87
  return;
}
}
#line 476 "src/http/ngx_http_core_module.h"
void ngx_http_core_run_phases(ngx_http_request_t *r ) ;
#line 123 "src/http/ngx_http.h"
void ngx_http_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 150
void ngx_http_block_reading(ngx_http_request_t *r ) ;
#line 151
void ngx_http_test_reading(ngx_http_request_t *r ) ;
#line 59 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_delay(ngx_http_request_t *r ) ;
#line 60
static ngx_int_t ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit , ngx_uint_t hash ,
                                           ngx_str_t *key , ngx_uint_t *ep___0 , ngx_uint_t account ) ;
#line 62
static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits ,
                                             ngx_uint_t n , ngx_uint_t *ep___0 , ngx_http_limit_req_limit_t **limit ) ;
#line 64
static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx , ngx_uint_t n ) ;
#line 67
static void *ngx_http_limit_req_create_conf(ngx_conf_t *cf ) ;
#line 68
static char *ngx_http_limit_req_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 70
static char *ngx_http_limit_req_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 72
static char *ngx_http_limit_req(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 74
static ngx_int_t ngx_http_limit_req_init(ngx_conf_t *cf ) ;
#line 77 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_conf_enum_t ngx_http_limit_req_log_levels[5]  = {      {{sizeof("info") - 1UL, (u_char *)"info"}, (ngx_uint_t )7}, 
        {{sizeof("notice") - 1UL, (u_char *)"notice"}, (ngx_uint_t )6}, 
        {{sizeof("warn") - 1UL, (u_char *)"warn"}, (ngx_uint_t )5}, 
        {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )4}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 86 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_conf_num_bounds_t ngx_http_limit_req_status_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )400, (ngx_int_t )599};
#line 91 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_command_t ngx_http_limit_req_commands[5]  = {      {{sizeof("limit_req_zone") - 1UL, (u_char *)"limit_req_zone"}, (ngx_uint_t )33554440,
      & ngx_http_limit_req_zone, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_req") - 1UL, (u_char *)"limit_req"}, (ngx_uint_t )234881038,
      & ngx_http_limit_req, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_req_log_level") - 1UL, (u_char *)"limit_req_log_level"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_limit_req_conf_t *)0)->limit_log_level), (void *)(& ngx_http_limit_req_log_levels)}, 
        {{sizeof("limit_req_status") - 1UL,
       (u_char *)"limit_req_status"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_limit_req_conf_t *)0)->status_code),
      (void *)(& ngx_http_limit_req_status_bounds)}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 125 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_http_module_t ngx_http_limit_req_module_ctx  = 
#line 125
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_limit_req_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_limit_req_create_conf,
    & ngx_http_limit_req_merge_conf};
#line 140 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
ngx_module_t ngx_http_limit_req_module  = 
#line 140
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_limit_req_module_ctx),
    ngx_http_limit_req_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 156 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_handler(ngx_http_request_t *r ) 
{ 
  uint32_t hash ;
  ngx_str_t key ;
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_uint_t excess ;
  ngx_msec_t delay ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_limit_req_conf_t *lrcf ;
  ngx_http_limit_req_limit_t *limit ;
  ngx_http_limit_req_limit_t *limits ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 168
  if ((r->main)->limit_req_set) {
#line 169
    return ((ngx_int_t )-5);
  }
#line 172
  lrcf = (ngx_http_limit_req_conf_t *)*(r->loc_conf + ngx_http_limit_req_module.ctx_index);
#line 173
  limits = (ngx_http_limit_req_limit_t *)lrcf->limits.elts;
#line 175
  excess = (ngx_uint_t )0;
#line 177
  rc = (ngx_int_t )-5;
#line 180
  limit = (ngx_http_limit_req_limit_t *)((void *)0);
#line 183
  n = (ngx_uint_t )0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (n < lrcf->limits.nelts)) {
#line 183
      goto while_break;
    }
    {
#line 185
    limit = limits + n;
#line 187
    ctx = (ngx_http_limit_req_ctx_t *)(limit->shm_zone)->data;
#line 189
    tmp = ngx_http_complex_value(r, & ctx->key, & key);
    }
#line 189
    if (tmp != 0L) {
#line 190
      return ((ngx_int_t )500);
    }
#line 193
    if (key.len == 0UL) {
#line 194
      goto __Cont;
    }
#line 197
    if (key.len > 65535UL) {
#line 198
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 198
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the value of the \"%V\" key is more than 65535 bytes: \"%V\"",
                           & ctx->key.value, & key);
        }
      }
#line 202
      goto __Cont;
    }
    {
#line 205
    hash = ngx_crc32_short(key.data, key.len);
#line 207
    ngx_shmtx_lock(& (ctx->shpool)->mutex);
#line 209
    rc = ngx_http_limit_req_lookup(limit, (ngx_uint_t )hash, & key, & excess, (ngx_uint_t )(n == lrcf->limits.nelts - 1UL));
#line 212
    ngx_shmtx_unlock(& (ctx->shpool)->mutex);
    }
#line 218
    if (rc != -2L) {
#line 219
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 183
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (rc == -5L) {
#line 224
    return ((ngx_int_t )-5);
  }
#line 227
  (r->main)->limit_req_set = 1U;
#line 229
  if (rc == -3L) {
#line 229
    goto _L;
  } else
#line 229
  if (rc == -1L) {
    _L: /* CIL Label */ 
#line 231
    if (rc == -3L) {
#line 232
      if (((r->connection)->log)->log_level >= lrcf->limit_log_level) {
        {
#line 232
        ngx_log_error_core(lrcf->limit_log_level, (r->connection)->log, 0, "limiting requests, excess: %ui.%03ui by zone \"%V\"",
                           excess / 1000UL, excess % 1000UL, & (limit->shm_zone)->shm.name);
        }
      }
    }
    {
#line 238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 238
      tmp___0 = n;
#line 238
      n --;
#line 238
      if (! tmp___0) {
#line 238
        goto while_break___0;
      }
#line 239
      ctx = (ngx_http_limit_req_ctx_t *)((limits + n)->shm_zone)->data;
#line 241
      if ((unsigned long )ctx->node == (unsigned long )((void *)0)) {
#line 242
        goto while_continue___0;
      }
      {
#line 245
      ngx_shmtx_lock(& (ctx->shpool)->mutex);
#line 247
      ((ctx->node)->count) --;
#line 249
      ngx_shmtx_unlock(& (ctx->shpool)->mutex);
#line 251
      ctx->node = (ngx_http_limit_req_node_t *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    return ((ngx_int_t )lrcf->status_code);
  }
#line 259
  if (rc == -2L) {
#line 260
    excess = (ngx_uint_t )0;
  }
  {
#line 263
  delay = ngx_http_limit_req_account(limits, n, & excess, & limit);
  }
#line 265
  if (! delay) {
#line 266
    return ((ngx_int_t )-5);
  }
#line 269
  if (((r->connection)->log)->log_level >= lrcf->delay_log_level) {
    {
#line 269
    ngx_log_error_core(lrcf->delay_log_level, (r->connection)->log, 0, "delaying request, excess: %ui.%03ui, by zone \"%V\"",
                       excess / 1000UL, excess % 1000UL, & (limit->shm_zone)->shm.name);
    }
  }
  {
#line 273
  tmp___1 = ngx_handle_read_event((r->connection)->read, (ngx_uint_t )0);
  }
#line 273
  if (tmp___1 != 0L) {
#line 274
    return ((ngx_int_t )500);
  }
  {
#line 277
  r->read_event_handler = & ngx_http_test_reading;
#line 278
  r->write_event_handler = & ngx_http_limit_req_delay;
#line 280
  ((r->connection)->write)->delayed = 1U;
#line 281
  ngx_event_add_timer((r->connection)->write, delay);
  }
#line 283
  return ((ngx_int_t )-2);
}
}
#line 287 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_delay(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 295
  wev = (r->connection)->write;
#line 297
  if (wev->delayed) {
    {
#line 299
    tmp = ngx_handle_write_event(wev, (size_t___0 )0);
    }
#line 299
    if (tmp != 0L) {
      {
#line 300
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
    }
#line 303
    return;
  }
  {
#line 306
  tmp___0 = ngx_handle_read_event((r->connection)->read, (ngx_uint_t )0);
  }
#line 306
  if (tmp___0 != 0L) {
    {
#line 307
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 308
    return;
  }
  {
#line 311
  r->read_event_handler = & ngx_http_block_reading;
#line 312
  r->write_event_handler = & ngx_http_core_run_phases;
#line 314
  ngx_http_core_run_phases(r);
  }
#line 315
  return;
}
}
#line 318 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                   ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_http_limit_req_node_t *lrn ;
  ngx_http_limit_req_node_t *lrnt ;
  ngx_int_t tmp___0 ;

  {
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (node->key < temp->key) {
#line 329
      p = & temp->left;
    } else
#line 331
    if (node->key > temp->key) {
#line 333
      p = & temp->right;
    } else {
      {
#line 337
      lrn = (ngx_http_limit_req_node_t *)(& node->color);
#line 338
      lrnt = (ngx_http_limit_req_node_t *)(& temp->color);
#line 340
      tmp___0 = ngx_memn2cmp(lrn->data, lrnt->data, (size_t___0 )lrn->len, (size_t___0 )lrnt->len);
      }
#line 340
      if (tmp___0 < 0L) {
#line 340
        p = & temp->left;
      } else {
#line 340
        p = & temp->right;
      }
    }
#line 344
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 345
      goto while_break;
    }
#line 348
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  *p = node;
#line 352
  node->parent = temp;
#line 353
  node->left = sentinel;
#line 354
  node->right = sentinel;
#line 355
  node->color = (u_char )1;
#line 356
  return;
}
}
#line 359 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit , ngx_uint_t hash ,
                                           ngx_str_t *key , ngx_uint_t *ep___0 , ngx_uint_t account ) 
{ 
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_int_t excess ;
  ngx_msec_t now ;
  ngx_msec_int_t ms ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_limit_req_node_t *lr ;
  ngx_msec_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 371
  now = (ngx_msec_t )ngx_current_msec;
#line 373
  ctx = (ngx_http_limit_req_ctx_t *)(limit->shm_zone)->data;
#line 375
  node = (ctx->sh)->rbtree.root;
#line 376
  sentinel = (ctx->sh)->rbtree.sentinel;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 378
      goto while_break;
    }
#line 380
    if (hash < node->key) {
#line 381
      node = node->left;
#line 382
      goto while_continue;
    }
#line 385
    if (hash > node->key) {
#line 386
      node = node->right;
#line 387
      goto while_continue;
    }
    {
#line 392
    lr = (ngx_http_limit_req_node_t *)(& node->color);
#line 394
    rc = ngx_memn2cmp(key->data, lr->data, key->len, (size_t___0 )lr->len);
    }
#line 396
    if (rc == 0L) {
#line 397
      (lr->queue.next)->prev = lr->queue.prev;
#line 397
      (lr->queue.prev)->next = lr->queue.next;
#line 398
      lr->queue.next = (ctx->sh)->queue.next;
#line 398
      (lr->queue.next)->prev = & lr->queue;
#line 398
      lr->queue.prev = & (ctx->sh)->queue;
#line 398
      (ctx->sh)->queue.next = & lr->queue;
#line 400
      ms = (ngx_msec_int_t )(now - lr->last);
#line 402
      if (ms >= 0L) {
#line 402
        tmp = ms;
      } else {
#line 402
        tmp = - ms;
      }
#line 402
      excess = (ngx_int_t )((lr->excess - (ctx->rate * (ngx_uint_t )tmp) / 1000UL) + 1000UL);
#line 404
      if (excess < 0L) {
#line 405
        excess = (ngx_int_t )0;
      }
#line 408
      *ep___0 = (ngx_uint_t )excess;
#line 410
      if ((ngx_uint_t )excess > limit->burst) {
#line 411
        return ((ngx_int_t )-3);
      }
#line 414
      if (account) {
#line 415
        lr->excess = (ngx_uint_t )excess;
#line 416
        lr->last = now;
#line 417
        return ((ngx_int_t )0);
      }
#line 420
      (lr->count) ++;
#line 422
      ctx->node = lr;
#line 424
      return ((ngx_int_t )-2);
    }
#line 427
    if (rc < 0L) {
#line 427
      node = node->left;
    } else {
#line 427
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  *ep___0 = (ngx_uint_t )0;
#line 432
  size = ((unsigned long )(& ((ngx_rbtree_node_t *)0)->color) + (unsigned long )(& ((ngx_http_limit_req_node_t *)0)->data)) + key->len;
#line 436
  ngx_http_limit_req_expire(ctx, (ngx_uint_t )1);
#line 438
  tmp___0 = ngx_slab_alloc_locked(ctx->shpool, size);
#line 438
  node = (ngx_rbtree_node_t *)tmp___0;
  }
#line 440
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 441
    ngx_http_limit_req_expire(ctx, (ngx_uint_t )0);
#line 443
    tmp___1 = ngx_slab_alloc_locked(ctx->shpool, size);
#line 443
    node = (ngx_rbtree_node_t *)tmp___1;
    }
#line 444
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 445
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 445
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "could not allocate node%s",
                           (ctx->shpool)->log_ctx);
        }
      }
#line 447
      return ((ngx_int_t )-1);
    }
  }
  {
#line 451
  node->key = hash;
#line 453
  lr = (ngx_http_limit_req_node_t *)(& node->color);
#line 455
  lr->len = (u_short )key->len;
#line 456
  lr->excess = (ngx_uint_t )0;
#line 458
  memcpy((void */* __restrict  */)(lr->data), (void const   */* __restrict  */)key->data,
         key->len);
#line 460
  ngx_rbtree_insert(& (ctx->sh)->rbtree, node);
#line 462
  lr->queue.next = (ctx->sh)->queue.next;
#line 462
  (lr->queue.next)->prev = & lr->queue;
#line 462
  lr->queue.prev = & (ctx->sh)->queue;
#line 462
  (ctx->sh)->queue.next = & lr->queue;
  }
#line 464
  if (account) {
#line 465
    lr->last = now;
#line 466
    lr->count = (ngx_uint_t )0;
#line 467
    return ((ngx_int_t )0);
  }
#line 470
  lr->last = (ngx_msec_t )0;
#line 471
  lr->count = (ngx_uint_t )1;
#line 473
  ctx->node = lr;
#line 475
  return ((ngx_int_t )-2);
}
}
#line 479 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits ,
                                             ngx_uint_t n , ngx_uint_t *ep___0 , ngx_http_limit_req_limit_t **limit ) 
{ 
  ngx_int_t excess ;
  ngx_msec_t now ;
  ngx_msec_t delay ;
  ngx_msec_t max_delay ;
  ngx_msec_int_t ms ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_limit_req_node_t *lr ;
  ngx_msec_int_t tmp ;
  ngx_uint_t tmp___0 ;

  {
#line 489
  excess = (ngx_int_t )*ep___0;
#line 491
  if (excess == 0L) {
#line 492
    max_delay = (ngx_msec_t )0;
  } else
#line 491
  if ((*limit)->nodelay) {
#line 492
    max_delay = (ngx_msec_t )0;
  } else {
#line 495
    ctx = (ngx_http_limit_req_ctx_t *)((*limit)->shm_zone)->data;
#line 496
    max_delay = (ngx_uint_t )(excess * 1000L) / ctx->rate;
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    tmp___0 = n;
#line 499
    n --;
#line 499
    if (! tmp___0) {
#line 499
      goto while_break;
    }
#line 500
    ctx = (ngx_http_limit_req_ctx_t *)((limits + n)->shm_zone)->data;
#line 501
    lr = ctx->node;
#line 503
    if ((unsigned long )lr == (unsigned long )((void *)0)) {
#line 504
      goto while_continue;
    }
    {
#line 507
    ngx_shmtx_lock(& (ctx->shpool)->mutex);
#line 509
    now = (ngx_msec_t )ngx_current_msec;
#line 510
    ms = (ngx_msec_int_t )(now - lr->last);
    }
#line 512
    if (ms >= 0L) {
#line 512
      tmp = ms;
    } else {
#line 512
      tmp = - ms;
    }
#line 512
    excess = (ngx_int_t )((lr->excess - (ctx->rate * (ngx_uint_t )tmp) / 1000UL) + 1000UL);
#line 514
    if (excess < 0L) {
#line 515
      excess = (ngx_int_t )0;
    }
    {
#line 518
    lr->last = now;
#line 519
    lr->excess = (ngx_uint_t )excess;
#line 520
    (lr->count) --;
#line 522
    ngx_shmtx_unlock(& (ctx->shpool)->mutex);
#line 524
    ctx->node = (ngx_http_limit_req_node_t *)((void *)0);
    }
#line 526
    if ((limits + n)->nodelay) {
#line 527
      goto while_continue;
    }
#line 530
    delay = (ngx_uint_t )(excess * 1000L) / ctx->rate;
#line 532
    if (delay > max_delay) {
#line 533
      max_delay = delay;
#line 534
      *ep___0 = (ngx_uint_t )excess;
#line 535
      *limit = limits + n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return (max_delay);
}
}
#line 543 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx , ngx_uint_t n ) 
{ 
  ngx_int_t excess ;
  ngx_msec_t now ;
  ngx_queue_t *q ;
  ngx_msec_int_t ms ;
  ngx_rbtree_node_t *node ;
  ngx_http_limit_req_node_t *lr ;
  ngx_uint_t tmp ;

  {
#line 553
  now = (ngx_msec_t )ngx_current_msec;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! (n < 3UL)) {
#line 561
      goto while_break;
    }
#line 563
    if ((unsigned long )(& (ctx->sh)->queue) == (unsigned long )(ctx->sh)->queue.prev) {
#line 564
      return;
    }
#line 567
    q = (ctx->sh)->queue.prev;
#line 569
    lr = (ngx_http_limit_req_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_limit_req_node_t *)0)->queue));
#line 571
    if (lr->count) {
#line 578
      return;
    }
#line 581
    tmp = n;
#line 581
    n ++;
#line 581
    if (tmp != 0UL) {
#line 583
      ms = (ngx_msec_int_t )(now - lr->last);
#line 584
      if (ms >= 0L) {
#line 584
        ms = ms;
      } else {
#line 584
        ms = - ms;
      }
#line 586
      if (ms < 60000L) {
#line 587
        return;
      }
#line 590
      excess = (ngx_int_t )(lr->excess - (ctx->rate * (ngx_uint_t )ms) / 1000UL);
#line 592
      if (excess > 0L) {
#line 593
        return;
      }
    }
    {
#line 597
    (q->next)->prev = q->prev;
#line 597
    (q->prev)->next = q->next;
#line 599
    node = (ngx_rbtree_node_t *)((u_char *)lr - (unsigned long )(& ((ngx_rbtree_node_t *)0)->color));
#line 602
    ngx_rbtree_delete(& (ctx->sh)->rbtree, node);
#line 604
    ngx_slab_free_locked(ctx->shpool, (void *)node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  return;
}
}
#line 609 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_init_zone(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  ngx_http_limit_req_ctx_t *octx ;
  size_t___0 len ;
  ngx_http_limit_req_ctx_t *ctx ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 612
  octx = (ngx_http_limit_req_ctx_t *)data;
#line 617
  ctx = (ngx_http_limit_req_ctx_t *)shm_zone->data;
#line 619
  if (octx) {
#line 620
    if (ctx->key.value.len != octx->key.value.len) {
#line 620
      goto _L;
    } else {
      {
#line 620
      tmp = strncmp((char const   *)ctx->key.value.data, (char const   *)octx->key.value.data,
                    ctx->key.value.len);
      }
#line 620
      if (tmp != 0) {
        _L: /* CIL Label */ 
#line 625
        if ((shm_zone->shm.log)->log_level >= 1UL) {
          {
#line 625
          ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "limit_req \"%V\" uses the \"%V\" key while previously it used the \"%V\" key",
                             & shm_zone->shm.name, & ctx->key.value, & octx->key.value);
          }
        }
#line 630
        return ((ngx_int_t )-1);
      }
    }
#line 633
    ctx->sh = octx->sh;
#line 634
    ctx->shpool = octx->shpool;
#line 636
    return ((ngx_int_t )0);
  }
#line 639
  ctx->shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 641
  if (shm_zone->shm.exists) {
#line 642
    ctx->sh = (ngx_http_limit_req_shctx_t *)(ctx->shpool)->data;
#line 644
    return ((ngx_int_t )0);
  }
  {
#line 647
  tmp___0 = ngx_slab_alloc(ctx->shpool, sizeof(ngx_http_limit_req_shctx_t ));
#line 647
  ctx->sh = (ngx_http_limit_req_shctx_t *)tmp___0;
  }
#line 648
  if ((unsigned long )ctx->sh == (unsigned long )((void *)0)) {
#line 649
    return ((ngx_int_t )-1);
  }
  {
#line 652
  (ctx->shpool)->data = (void *)ctx->sh;
#line 654
  (ctx->sh)->sentinel.color = (u_char )0;
#line 654
  (ctx->sh)->rbtree.root = & (ctx->sh)->sentinel;
#line 654
  (ctx->sh)->rbtree.sentinel = & (ctx->sh)->sentinel;
#line 654
  (ctx->sh)->rbtree.insert = & ngx_http_limit_req_rbtree_insert_value;
#line 657
  (ctx->sh)->queue.prev = & (ctx->sh)->queue;
#line 657
  (ctx->sh)->queue.next = & (ctx->sh)->queue;
#line 659
  len = sizeof(" in limit_req zone \"\"") + shm_zone->shm.name.len;
#line 661
  tmp___1 = ngx_slab_alloc(ctx->shpool, len);
#line 661
  (ctx->shpool)->log_ctx = (u_char *)tmp___1;
  }
#line 662
  if ((unsigned long )(ctx->shpool)->log_ctx == (unsigned long )((void *)0)) {
#line 663
    return ((ngx_int_t )-1);
  }
  {
#line 666
  ngx_sprintf((ctx->shpool)->log_ctx, " in limit_req zone \"%V\"%Z", & shm_zone->shm.name);
#line 669
  (ctx->shpool)->log_nomem = 0U;
  }
#line 671
  return ((ngx_int_t )0);
}
}
#line 675 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static void *ngx_http_limit_req_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_limit_req_conf_t *conf ;
  void *tmp ;

  {
  {
#line 680
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_req_conf_t ));
#line 680
  conf = (ngx_http_limit_req_conf_t *)tmp;
  }
#line 681
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 682
    return ((void *)0);
  }
#line 691
  conf->limit_log_level = (ngx_uint_t )-1;
#line 692
  conf->status_code = (ngx_uint_t )-1;
#line 694
  return ((void *)conf);
}
}
#line 698 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static char *ngx_http_limit_req_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_limit_req_conf_t *prev ;
  ngx_http_limit_req_conf_t *conf ;

  {
#line 701
  prev = (ngx_http_limit_req_conf_t *)parent;
#line 702
  conf = (ngx_http_limit_req_conf_t *)child;
#line 704
  if ((unsigned long )conf->limits.elts == (unsigned long )((void *)0)) {
#line 705
    conf->limits = prev->limits;
  }
#line 708
  if (conf->limit_log_level == 0xffffffffffffffffUL) {
#line 708
    if (prev->limit_log_level == 0xffffffffffffffffUL) {
#line 708
      conf->limit_log_level = (ngx_uint_t )4;
    } else {
#line 708
      conf->limit_log_level = prev->limit_log_level;
    }
  }
#line 711
  if (conf->limit_log_level == 7UL) {
#line 711
    conf->delay_log_level = (ngx_uint_t )7;
  } else {
#line 711
    conf->delay_log_level = conf->limit_log_level + 1UL;
  }
#line 714
  if (conf->status_code == 0xffffffffffffffffUL) {
#line 714
    if (prev->status_code == 0xffffffffffffffffUL) {
#line 714
      conf->status_code = (ngx_uint_t )503;
    } else {
#line 714
      conf->status_code = prev->status_code;
    }
  }
#line 717
  return ((char *)((void *)0));
}
}
#line 721 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static char *ngx_http_limit_req_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ssize_t size ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_str_t s ;
  ngx_int_t rate ;
  ngx_int_t scale ;
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 734
  value = (ngx_str_t *)(cf->args)->elts;
#line 736
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_req_ctx_t ));
#line 736
  ctx = (ngx_http_limit_req_ctx_t *)tmp;
  }
#line 737
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 738
    return ((char *)((void *)-1));
  }
  {
#line 741
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 743
  ccv.cf = cf;
#line 744
  ccv.value = value + 1;
#line 745
  ccv.complex_value = & ctx->key;
#line 747
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 747
  if (tmp___0 != 0L) {
#line 748
    return ((char *)((void *)-1));
  }
#line 751
  size = (ssize_t )0;
#line 752
  rate = (ngx_int_t )1;
#line 753
  scale = (ngx_int_t )1;
#line 754
  name.len = (size_t___0 )0;
#line 756
  i = (ngx_uint_t )2;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 756
    if (! (i < (cf->args)->nelts)) {
#line 756
      goto while_break;
    }
    {
#line 758
    tmp___2 = strncmp((char const   *)(value + i)->data, "zone=", (size_t )5);
    }
#line 758
    if (tmp___2 == 0) {
      {
#line 760
      name.data = (value + i)->data + 5;
#line 762
      tmp___1 = strchr((char const   *)name.data, ':');
#line 762
      p = (u_char *)tmp___1;
      }
#line 764
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 765
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 767
        return ((char *)((void *)-1));
      }
      {
#line 770
      name.len = (size_t___0 )(p - name.data);
#line 772
      s.data = p + 1;
#line 773
      s.len = (size_t___0 )(((value + i)->data + (value + i)->len) - s.data);
#line 775
      size = ngx_parse_size(& s);
      }
#line 777
      if (size == -1L) {
        {
#line 778
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 780
        return ((char *)((void *)-1));
      }
#line 783
      if (size < (ssize_t )(8UL * ngx_pagesize)) {
        {
#line 784
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "zone \"%V\" is too small", value + i);
        }
#line 786
        return ((char *)((void *)-1));
      }
#line 789
      goto __Cont;
    }
    {
#line 792
    tmp___5 = strncmp((char const   *)(value + i)->data, "rate=", (size_t )5);
    }
#line 792
    if (tmp___5 == 0) {
      {
#line 794
      len = (value + i)->len;
#line 795
      p = ((value + i)->data + len) - 3;
#line 797
      tmp___4 = strncmp((char const   *)p, "r/s", (size_t )3);
      }
#line 797
      if (tmp___4 == 0) {
#line 798
        scale = (ngx_int_t )1;
#line 799
        len -= 3UL;
      } else {
        {
#line 801
        tmp___3 = strncmp((char const   *)p, "r/m", (size_t )3);
        }
#line 801
        if (tmp___3 == 0) {
#line 802
          scale = (ngx_int_t )60;
#line 803
          len -= 3UL;
        }
      }
      {
#line 806
      rate = ngx_atoi((value + i)->data + 5, len - 5UL);
      }
#line 807
      if (rate <= 0L) {
        {
#line 808
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid rate \"%V\"", value + i);
        }
#line 810
        return ((char *)((void *)-1));
      }
#line 813
      goto __Cont;
    }
    {
#line 816
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 818
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 756
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  if (name.len == 0UL) {
    {
#line 822
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"zone\" parameter",
                       & cmd->name);
    }
#line 825
    return ((char *)((void *)-1));
  }
  {
#line 828
  ctx->rate = (ngx_uint_t )((rate * 1000L) / scale);
#line 830
  shm_zone = ngx_shared_memory_add(cf, & name, (size_t___0 )size, (void *)(& ngx_http_limit_req_module));
  }
#line 832
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 833
    return ((char *)((void *)-1));
  }
#line 836
  if (shm_zone->data) {
    {
#line 837
    ctx = (ngx_http_limit_req_ctx_t *)shm_zone->data;
#line 839
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V \"%V\" is already bound to key \"%V\"",
                       & cmd->name, & name, & ctx->key.value);
    }
#line 842
    return ((char *)((void *)-1));
  }
#line 845
  shm_zone->init = & ngx_http_limit_req_init_zone;
#line 846
  shm_zone->data = (void *)ctx;
#line 848
  return ((char *)((void *)0));
}
}
#line 852 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static char *ngx_http_limit_req(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_limit_req_conf_t *lrcf ;
  ngx_int_t burst ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_uint_t i ;
  ngx_uint_t nodelay ;
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_req_limit_t *limit ;
  ngx_http_limit_req_limit_t *limits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;

  {
#line 855
  lrcf = (ngx_http_limit_req_conf_t *)conf;
#line 863
  value = (ngx_str_t *)(cf->args)->elts;
#line 865
  shm_zone = (ngx_shm_zone_t *)((void *)0);
#line 866
  burst = (ngx_int_t )0;
#line 867
  nodelay = (ngx_uint_t )0;
#line 869
  i = (ngx_uint_t )1;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! (i < (cf->args)->nelts)) {
#line 869
      goto while_break;
    }
    {
#line 871
    tmp = strncmp((char const   *)(value + i)->data, "zone=", (size_t )5);
    }
#line 871
    if (tmp == 0) {
      {
#line 873
      s.len = (value + i)->len - 5UL;
#line 874
      s.data = (value + i)->data + 5;
#line 876
      shm_zone = ngx_shared_memory_add(cf, & s, (size_t___0 )0, (void *)(& ngx_http_limit_req_module));
      }
#line 878
      if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 879
        return ((char *)((void *)-1));
      }
#line 882
      goto __Cont;
    }
    {
#line 885
    tmp___0 = strncmp((char const   *)(value + i)->data, "burst=", (size_t )6);
    }
#line 885
    if (tmp___0 == 0) {
      {
#line 887
      burst = ngx_atoi((value + i)->data + 6, (value + i)->len - 6UL);
      }
#line 888
      if (burst <= 0L) {
        {
#line 889
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid burst rate \"%V\"", value + i);
        }
#line 891
        return ((char *)((void *)-1));
      }
#line 894
      goto __Cont;
    }
    {
#line 897
    tmp___1 = strcmp((char const   *)(value + i)->data, "nodelay");
    }
#line 897
    if (tmp___1 == 0) {
#line 898
      nodelay = (ngx_uint_t )1;
#line 899
      goto __Cont;
    }
    {
#line 902
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 904
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 869
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 907
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
    {
#line 908
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"zone\" parameter",
                       & cmd->name);
    }
#line 911
    return ((char *)((void *)-1));
  }
#line 914
  limits = (ngx_http_limit_req_limit_t *)lrcf->limits.elts;
#line 916
  if ((unsigned long )limits == (unsigned long )((void *)0)) {
    {
#line 917
    tmp___2 = ngx_array_init(& lrcf->limits, cf->pool, (ngx_uint_t )1, sizeof(ngx_http_limit_req_limit_t ));
    }
#line 917
    if (tmp___2 != 0L) {
#line 921
      return ((char *)((void *)-1));
    }
  }
#line 925
  i = (ngx_uint_t )0;
  {
#line 925
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 925
    if (! (i < lrcf->limits.nelts)) {
#line 925
      goto while_break___0;
    }
#line 926
    if ((unsigned long )shm_zone == (unsigned long )(limits + i)->shm_zone) {
#line 927
      return ((char *)"is duplicate");
    }
#line 925
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 931
  tmp___3 = ngx_array_push(& lrcf->limits);
#line 931
  limit = (ngx_http_limit_req_limit_t *)tmp___3;
  }
#line 932
  if ((unsigned long )limit == (unsigned long )((void *)0)) {
#line 933
    return ((char *)((void *)-1));
  }
#line 936
  limit->shm_zone = shm_zone;
#line 937
  limit->burst = (ngx_uint_t )(burst * 1000L);
#line 938
  limit->nodelay = nodelay;
#line 940
  return ((char *)((void *)0));
}
}
#line 944 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 950
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 952
  tmp = ngx_array_push(& cmcf->phases[5].handlers);
#line 952
  h = (ngx_http_handler_pt *)tmp;
  }
#line 953
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 954
    return ((ngx_int_t )-1);
  }
#line 957
  *h = & ngx_http_limit_req_handler;
#line 959
  return ((ngx_int_t )0);
}
}
#line 86 "src/core/ngx_palloc.h"
ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p , size_t___0 size ) ;
#line 46 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_rbtree_node_t *ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree , ngx_str_t *key ,
                                                     uint32_t hash ) ;
#line 48
static void ngx_http_limit_conn_cleanup(void *data ) ;
#line 49
__inline static void ngx_http_limit_conn_cleanup_all(ngx_pool_t *pool ) ;
#line 51
static void *ngx_http_limit_conn_create_conf(ngx_conf_t *cf ) ;
#line 52
static char *ngx_http_limit_conn_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 54
static char *ngx_http_limit_conn_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 56
static char *ngx_http_limit_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 58
static ngx_int_t ngx_http_limit_conn_init(ngx_conf_t *cf ) ;
#line 61 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_conf_enum_t ngx_http_limit_conn_log_levels[5]  = {      {{sizeof("info") - 1UL, (u_char *)"info"}, (ngx_uint_t )7}, 
        {{sizeof("notice") - 1UL, (u_char *)"notice"}, (ngx_uint_t )6}, 
        {{sizeof("warn") - 1UL, (u_char *)"warn"}, (ngx_uint_t )5}, 
        {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )4}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 70 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_conf_num_bounds_t ngx_http_limit_conn_status_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )400, (ngx_int_t )599};
#line 75 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_command_t ngx_http_limit_conn_commands[5]  = {      {{sizeof("limit_conn_zone") - 1UL, (u_char *)"limit_conn_zone"}, (ngx_uint_t )33554436,
      & ngx_http_limit_conn_zone, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_conn") - 1UL, (u_char *)"limit_conn"}, (ngx_uint_t )234881028,
      & ngx_http_limit_conn, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_conn_log_level") - 1UL, (u_char *)"limit_conn_log_level"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_limit_conn_conf_t *)0)->log_level), (void *)(& ngx_http_limit_conn_log_levels)}, 
        {{sizeof("limit_conn_status") - 1UL,
       (u_char *)"limit_conn_status"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_limit_conn_conf_t *)0)->status_code),
      (void *)(& ngx_http_limit_conn_status_bounds)}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 109 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_http_module_t ngx_http_limit_conn_module_ctx  = 
#line 109
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_limit_conn_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_limit_conn_create_conf,
    & ngx_http_limit_conn_merge_conf};
#line 124 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
ngx_module_t ngx_http_limit_conn_module  = 
#line 124
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_limit_conn_module_ctx),
    ngx_http_limit_conn_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 140 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_int_t ngx_http_limit_conn_handler(ngx_http_request_t *r ) 
{ 
  size_t___0 n ;
  uint32_t hash ;
  ngx_str_t key ;
  ngx_uint_t i ;
  ngx_slab_pool_t *shpool ;
  ngx_rbtree_node_t *node ;
  ngx_pool_cleanup_t *cln ;
  ngx_http_limit_conn_ctx_t *ctx ;
  ngx_http_limit_conn_node_t *lc ;
  ngx_http_limit_conn_conf_t *lccf ;
  ngx_http_limit_conn_limit_t *limits ;
  ngx_http_limit_conn_cleanup_t *lccln ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
#line 156
  if ((r->main)->limit_conn_set) {
#line 157
    return ((ngx_int_t )-5);
  }
#line 160
  lccf = (ngx_http_limit_conn_conf_t *)*(r->loc_conf + ngx_http_limit_conn_module.ctx_index);
#line 161
  limits = (ngx_http_limit_conn_limit_t *)lccf->limits.elts;
#line 163
  i = (ngx_uint_t )0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < lccf->limits.nelts)) {
#line 163
      goto while_break;
    }
    {
#line 164
    ctx = (ngx_http_limit_conn_ctx_t *)((limits + i)->shm_zone)->data;
#line 166
    tmp = ngx_http_complex_value(r, & ctx->key, & key);
    }
#line 166
    if (tmp != 0L) {
#line 167
      return ((ngx_int_t )500);
    }
#line 170
    if (key.len == 0UL) {
#line 171
      goto __Cont;
    }
#line 174
    if (key.len > 255UL) {
#line 175
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 175
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the value of the \"%V\" key is more than 255 bytes: \"%V\"",
                           & ctx->key.value, & key);
        }
      }
#line 179
      goto __Cont;
    }
    {
#line 182
    (r->main)->limit_conn_set = 1U;
#line 184
    hash = ngx_crc32_short(key.data, key.len);
#line 186
    shpool = (ngx_slab_pool_t *)((limits + i)->shm_zone)->shm.addr;
#line 188
    ngx_shmtx_lock(& shpool->mutex);
#line 190
    node = ngx_http_limit_conn_lookup(ctx->rbtree, & key, hash);
    }
#line 192
    if ((unsigned long )node == (unsigned long )((void *)0)) {
      {
#line 194
      n = ((unsigned long )(& ((ngx_rbtree_node_t *)0)->color) + (unsigned long )(& ((ngx_http_limit_conn_node_t *)0)->data)) + key.len;
#line 198
      tmp___0 = ngx_slab_alloc_locked(shpool, n);
#line 198
      node = (ngx_rbtree_node_t *)tmp___0;
      }
#line 200
      if ((unsigned long )node == (unsigned long )((void *)0)) {
        {
#line 201
        ngx_shmtx_unlock(& shpool->mutex);
#line 202
        ngx_http_limit_conn_cleanup_all(r->pool);
        }
#line 203
        return ((ngx_int_t )lccf->status_code);
      }
      {
#line 206
      lc = (ngx_http_limit_conn_node_t *)(& node->color);
#line 208
      node->key = (ngx_rbtree_key_t )hash;
#line 209
      lc->len = (u_char )key.len;
#line 210
      lc->conn = (u_short )1;
#line 211
      memcpy((void */* __restrict  */)(lc->data), (void const   */* __restrict  */)key.data,
             key.len);
#line 213
      ngx_rbtree_insert(ctx->rbtree, node);
      }
    } else {
#line 217
      lc = (ngx_http_limit_conn_node_t *)(& node->color);
#line 219
      if ((ngx_uint_t )lc->conn >= (limits + i)->conn) {
        {
#line 221
        ngx_shmtx_unlock(& shpool->mutex);
        }
#line 223
        if (((r->connection)->log)->log_level >= lccf->log_level) {
          {
#line 223
          ngx_log_error_core(lccf->log_level, (r->connection)->log, 0, "limiting connections by zone \"%V\"",
                             & ((limits + i)->shm_zone)->shm.name);
          }
        }
        {
#line 227
        ngx_http_limit_conn_cleanup_all(r->pool);
        }
#line 228
        return ((ngx_int_t )lccf->status_code);
      }
#line 231
      lc->conn = (u_short )((int )lc->conn + 1);
    }
    {
#line 237
    ngx_shmtx_unlock(& shpool->mutex);
#line 239
    cln = ngx_pool_cleanup_add(r->pool, sizeof(ngx_http_limit_conn_cleanup_t ));
    }
#line 241
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 242
      return ((ngx_int_t )500);
    }
#line 245
    cln->handler = & ngx_http_limit_conn_cleanup;
#line 246
    lccln = (ngx_http_limit_conn_cleanup_t *)cln->data;
#line 248
    lccln->shm_zone = (limits + i)->shm_zone;
#line 249
    lccln->node = node;
    __Cont: /* CIL Label */ 
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return ((ngx_int_t )-5);
}
}
#line 256 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static void ngx_http_limit_conn_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_http_limit_conn_node_t *lcn ;
  ngx_http_limit_conn_node_t *lcnt ;
  ngx_int_t tmp___0 ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (node->key < temp->key) {
#line 267
      p = & temp->left;
    } else
#line 269
    if (node->key > temp->key) {
#line 271
      p = & temp->right;
    } else {
      {
#line 275
      lcn = (ngx_http_limit_conn_node_t *)(& node->color);
#line 276
      lcnt = (ngx_http_limit_conn_node_t *)(& temp->color);
#line 278
      tmp___0 = ngx_memn2cmp(lcn->data, lcnt->data, (size_t___0 )lcn->len, (size_t___0 )lcnt->len);
      }
#line 278
      if (tmp___0 < 0L) {
#line 278
        p = & temp->left;
      } else {
#line 278
        p = & temp->right;
      }
    }
#line 282
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 283
      goto while_break;
    }
#line 286
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  *p = node;
#line 290
  node->parent = temp;
#line 291
  node->left = sentinel;
#line 292
  node->right = sentinel;
#line 293
  node->color = (u_char )1;
#line 294
  return;
}
}
#line 297 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_rbtree_node_t *ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree , ngx_str_t *key ,
                                                     uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_limit_conn_node_t *lcn ;

  {
#line 304
  node = rbtree->root;
#line 305
  sentinel = rbtree->sentinel;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 307
      goto while_break;
    }
#line 309
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 310
      node = node->left;
#line 311
      goto while_continue;
    }
#line 314
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 315
      node = node->right;
#line 316
      goto while_continue;
    }
    {
#line 321
    lcn = (ngx_http_limit_conn_node_t *)(& node->color);
#line 323
    rc = ngx_memn2cmp(key->data, lcn->data, key->len, (size_t___0 )lcn->len);
    }
#line 325
    if (rc == 0L) {
#line 326
      return (node);
    }
#line 329
    if (rc < 0L) {
#line 329
      node = node->left;
    } else {
#line 329
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  return ((ngx_rbtree_node_t *)((void *)0));
}
}
#line 336 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static void ngx_http_limit_conn_cleanup(void *data ) 
{ 
  ngx_http_limit_conn_cleanup_t *lccln ;
  ngx_slab_pool_t *shpool ;
  ngx_rbtree_node_t *node ;
  ngx_http_limit_conn_ctx_t *ctx ;
  ngx_http_limit_conn_node_t *lc ;

  {
  {
#line 339
  lccln = (ngx_http_limit_conn_cleanup_t *)data;
#line 346
  ctx = (ngx_http_limit_conn_ctx_t *)(lccln->shm_zone)->data;
#line 347
  shpool = (ngx_slab_pool_t *)(lccln->shm_zone)->shm.addr;
#line 348
  node = lccln->node;
#line 349
  lc = (ngx_http_limit_conn_node_t *)(& node->color);
#line 351
  ngx_shmtx_lock(& shpool->mutex);
#line 356
  lc->conn = (u_short )((int )lc->conn - 1);
  }
#line 358
  if ((int )lc->conn == 0) {
    {
#line 359
    ngx_rbtree_delete(ctx->rbtree, node);
#line 360
    ngx_slab_free_locked(shpool, (void *)node);
    }
  }
  {
#line 363
  ngx_shmtx_unlock(& shpool->mutex);
  }
#line 364
  return;
}
}
#line 367 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
__inline static void ngx_http_limit_conn_cleanup_all(ngx_pool_t *pool ) 
{ 
  ngx_pool_cleanup_t *cln ;

  {
#line 372
  cln = pool->cleanup;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (cln) {
#line 374
      if (! ((unsigned long )cln->handler == (unsigned long )(& ngx_http_limit_conn_cleanup))) {
#line 374
        goto while_break;
      }
    } else {
#line 374
      goto while_break;
    }
    {
#line 375
    ngx_http_limit_conn_cleanup(cln->data);
#line 376
    cln = cln->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  pool->cleanup = cln;
#line 380
  return;
}
}
#line 383 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_int_t ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  ngx_http_limit_conn_ctx_t *octx ;
  size_t___0 len ;
  ngx_slab_pool_t *shpool ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_limit_conn_ctx_t *ctx ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 386
  octx = (ngx_http_limit_conn_ctx_t *)data;
#line 393
  ctx = (ngx_http_limit_conn_ctx_t *)shm_zone->data;
#line 395
  if (octx) {
#line 396
    if (ctx->key.value.len != octx->key.value.len) {
#line 396
      goto _L;
    } else {
      {
#line 396
      tmp = strncmp((char const   *)ctx->key.value.data, (char const   *)octx->key.value.data,
                    ctx->key.value.len);
      }
#line 396
      if (tmp != 0) {
        _L: /* CIL Label */ 
#line 401
        if ((shm_zone->shm.log)->log_level >= 1UL) {
          {
#line 401
          ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "limit_conn_zone \"%V\" uses the \"%V\" key while previously it used the \"%V\" key",
                             & shm_zone->shm.name, & ctx->key.value, & octx->key.value);
          }
        }
#line 406
        return ((ngx_int_t )-1);
      }
    }
#line 409
    ctx->rbtree = octx->rbtree;
#line 411
    return ((ngx_int_t )0);
  }
#line 414
  shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 416
  if (shm_zone->shm.exists) {
#line 417
    ctx->rbtree = (ngx_rbtree_t *)shpool->data;
#line 419
    return ((ngx_int_t )0);
  }
  {
#line 422
  tmp___0 = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_t ));
#line 422
  ctx->rbtree = (ngx_rbtree_t *)tmp___0;
  }
#line 423
  if ((unsigned long )ctx->rbtree == (unsigned long )((void *)0)) {
#line 424
    return ((ngx_int_t )-1);
  }
  {
#line 427
  shpool->data = (void *)ctx->rbtree;
#line 429
  tmp___1 = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_node_t ));
#line 429
  sentinel = (ngx_rbtree_node_t *)tmp___1;
  }
#line 430
  if ((unsigned long )sentinel == (unsigned long )((void *)0)) {
#line 431
    return ((ngx_int_t )-1);
  }
  {
#line 434
  sentinel->color = (u_char )0;
#line 434
  (ctx->rbtree)->root = sentinel;
#line 434
  (ctx->rbtree)->sentinel = sentinel;
#line 434
  (ctx->rbtree)->insert = & ngx_http_limit_conn_rbtree_insert_value;
#line 437
  len = sizeof(" in limit_conn_zone \"\"") + shm_zone->shm.name.len;
#line 439
  tmp___2 = ngx_slab_alloc(shpool, len);
#line 439
  shpool->log_ctx = (u_char *)tmp___2;
  }
#line 440
  if ((unsigned long )shpool->log_ctx == (unsigned long )((void *)0)) {
#line 441
    return ((ngx_int_t )-1);
  }
  {
#line 444
  ngx_sprintf(shpool->log_ctx, " in limit_conn_zone \"%V\"%Z", & shm_zone->shm.name);
  }
#line 447
  return ((ngx_int_t )0);
}
}
#line 451 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static void *ngx_http_limit_conn_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_limit_conn_conf_t *conf ;
  void *tmp ;

  {
  {
#line 456
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_conn_conf_t ));
#line 456
  conf = (ngx_http_limit_conn_conf_t *)tmp;
  }
#line 457
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 458
    return ((void *)0);
  }
#line 467
  conf->log_level = (ngx_uint_t )-1;
#line 468
  conf->status_code = (ngx_uint_t )-1;
#line 470
  return ((void *)conf);
}
}
#line 474 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static char *ngx_http_limit_conn_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_limit_conn_conf_t *prev ;
  ngx_http_limit_conn_conf_t *conf ;

  {
#line 477
  prev = (ngx_http_limit_conn_conf_t *)parent;
#line 478
  conf = (ngx_http_limit_conn_conf_t *)child;
#line 480
  if ((unsigned long )conf->limits.elts == (unsigned long )((void *)0)) {
#line 481
    conf->limits = prev->limits;
  }
#line 484
  if (conf->log_level == 0xffffffffffffffffUL) {
#line 484
    if (prev->log_level == 0xffffffffffffffffUL) {
#line 484
      conf->log_level = (ngx_uint_t )4;
    } else {
#line 484
      conf->log_level = prev->log_level;
    }
  }
#line 485
  if (conf->status_code == 0xffffffffffffffffUL) {
#line 485
    if (prev->status_code == 0xffffffffffffffffUL) {
#line 485
      conf->status_code = (ngx_uint_t )503;
    } else {
#line 485
      conf->status_code = prev->status_code;
    }
  }
#line 488
  return ((char *)((void *)0));
}
}
#line 492 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static char *ngx_http_limit_conn_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  u_char *p ;
  ssize_t size ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_str_t s ;
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_conn_ctx_t *ctx ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 503
  value = (ngx_str_t *)(cf->args)->elts;
#line 505
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_conn_ctx_t ));
#line 505
  ctx = (ngx_http_limit_conn_ctx_t *)tmp;
  }
#line 506
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 507
    return ((char *)((void *)-1));
  }
  {
#line 510
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 512
  ccv.cf = cf;
#line 513
  ccv.value = value + 1;
#line 514
  ccv.complex_value = & ctx->key;
#line 516
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 516
  if (tmp___0 != 0L) {
#line 517
    return ((char *)((void *)-1));
  }
#line 520
  size = (ssize_t )0;
#line 521
  name.len = (size_t___0 )0;
#line 523
  i = (ngx_uint_t )2;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (i < (cf->args)->nelts)) {
#line 523
      goto while_break;
    }
    {
#line 525
    tmp___2 = strncmp((char const   *)(value + i)->data, "zone=", (size_t )5);
    }
#line 525
    if (tmp___2 == 0) {
      {
#line 527
      name.data = (value + i)->data + 5;
#line 529
      tmp___1 = strchr((char const   *)name.data, ':');
#line 529
      p = (u_char *)tmp___1;
      }
#line 531
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 532
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 534
        return ((char *)((void *)-1));
      }
      {
#line 537
      name.len = (size_t___0 )(p - name.data);
#line 539
      s.data = p + 1;
#line 540
      s.len = (size_t___0 )(((value + i)->data + (value + i)->len) - s.data);
#line 542
      size = ngx_parse_size(& s);
      }
#line 544
      if (size == -1L) {
        {
#line 545
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 547
        return ((char *)((void *)-1));
      }
#line 550
      if (size < (ssize_t )(8UL * ngx_pagesize)) {
        {
#line 551
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "zone \"%V\" is too small", value + i);
        }
#line 553
        return ((char *)((void *)-1));
      }
#line 556
      goto __Cont;
    }
    {
#line 559
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 561
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  if (name.len == 0UL) {
    {
#line 565
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"zone\" parameter",
                       & cmd->name);
    }
#line 568
    return ((char *)((void *)-1));
  }
  {
#line 571
  shm_zone = ngx_shared_memory_add(cf, & name, (size_t___0 )size, (void *)(& ngx_http_limit_conn_module));
  }
#line 573
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 574
    return ((char *)((void *)-1));
  }
#line 577
  if (shm_zone->data) {
    {
#line 578
    ctx = (ngx_http_limit_conn_ctx_t *)shm_zone->data;
#line 580
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V \"%V\" is already bound to key \"%V\"",
                       & cmd->name, & name, & ctx->key.value);
    }
#line 583
    return ((char *)((void *)-1));
  }
#line 586
  shm_zone->init = & ngx_http_limit_conn_init_zone;
#line 587
  shm_zone->data = (void *)ctx;
#line 589
  return ((char *)((void *)0));
}
}
#line 593 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static char *ngx_http_limit_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_conn_conf_t *lccf ;
  ngx_http_limit_conn_limit_t *limit ;
  ngx_http_limit_conn_limit_t *limits ;
  ngx_str_t *value ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
  {
#line 597
  lccf = (ngx_http_limit_conn_conf_t *)conf;
#line 604
  value = (ngx_str_t *)(cf->args)->elts;
#line 606
  shm_zone = ngx_shared_memory_add(cf, value + 1, (size_t___0 )0, (void *)(& ngx_http_limit_conn_module));
  }
#line 608
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 609
    return ((char *)((void *)-1));
  }
#line 612
  limits = (ngx_http_limit_conn_limit_t *)lccf->limits.elts;
#line 614
  if ((unsigned long )limits == (unsigned long )((void *)0)) {
    {
#line 615
    tmp = ngx_array_init(& lccf->limits, cf->pool, (ngx_uint_t )1, sizeof(ngx_http_limit_conn_limit_t ));
    }
#line 615
    if (tmp != 0L) {
#line 619
      return ((char *)((void *)-1));
    }
  }
#line 623
  i = (ngx_uint_t )0;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! (i < lccf->limits.nelts)) {
#line 623
      goto while_break;
    }
#line 624
    if ((unsigned long )shm_zone == (unsigned long )(limits + i)->shm_zone) {
#line 625
      return ((char *)"is duplicate");
    }
#line 623
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 629
  n = ngx_atoi((value + 2)->data, (value + 2)->len);
  }
#line 630
  if (n <= 0L) {
    {
#line 631
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of connections \"%V\"",
                       value + 2);
    }
#line 633
    return ((char *)((void *)-1));
  }
#line 636
  if (n > 65535L) {
    {
#line 637
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "connection limit must be less 65536");
    }
#line 639
    return ((char *)((void *)-1));
  }
  {
#line 642
  tmp___0 = ngx_array_push(& lccf->limits);
#line 642
  limit = (ngx_http_limit_conn_limit_t *)tmp___0;
  }
#line 643
  if ((unsigned long )limit == (unsigned long )((void *)0)) {
#line 644
    return ((char *)((void *)-1));
  }
#line 647
  limit->conn = (ngx_uint_t )n;
#line 648
  limit->shm_zone = shm_zone;
#line 650
  return ((char *)((void *)0));
}
}
#line 654 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_int_t ngx_http_limit_conn_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 660
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 662
  tmp = ngx_array_push(& cmcf->phases[5].handlers);
#line 662
  h = (ngx_http_handler_pt *)tmp;
  }
#line 663
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 664
    return ((ngx_int_t )-1);
  }
#line 667
  *h = & ngx_http_limit_conn_handler;
#line 669
  return ((ngx_int_t )0);
}
}
#line 48 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_handler(ngx_http_request_t *r ) ;
#line 49
static ngx_int_t ngx_http_access_inet(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                      in_addr_t addr ) ;
#line 52
static ngx_int_t ngx_http_access_inet6(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                       u_char *p ) ;
#line 56
static ngx_int_t ngx_http_access_unix(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ) ;
#line 59
static ngx_int_t ngx_http_access_found(ngx_http_request_t *r , ngx_uint_t deny ) ;
#line 60
static char *ngx_http_access_rule(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 62
static void *ngx_http_access_create_loc_conf(ngx_conf_t *cf ) ;
#line 63
static char *ngx_http_access_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 65
static ngx_int_t ngx_http_access_init(ngx_conf_t *cf ) ;
#line 68 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_command_t ngx_http_access_commands[3]  = {      {{sizeof("allow") - 1UL, (u_char *)"allow"}, (ngx_uint_t )2382364674U, & ngx_http_access_rule,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("deny") - 1UL,
       (u_char *)"deny"}, (ngx_uint_t )2382364674U, & ngx_http_access_rule, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 91 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_http_module_t ngx_http_access_module_ctx  = 
#line 91
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_access_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_access_create_loc_conf,
    & ngx_http_access_merge_loc_conf};
#line 106 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
ngx_module_t ngx_http_access_module  = 
#line 106
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_access_module_ctx),
    ngx_http_access_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 122 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_handler(ngx_http_request_t *r ) 
{ 
  struct sockaddr_in *sin ;
  ngx_http_access_loc_conf_t *alcf ;
  u_char *p ;
  in_addr_t addr ;
  struct sockaddr_in6 *sin6 ;
  ngx_int_t tmp ;
  unsigned int __v ;
  unsigned int __x ;
  ngx_int_t tmp___0 ;
  struct in6_addr  const  *__a ;
  unsigned int __v___0 ;
  unsigned int __x___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 133
  alcf = (ngx_http_access_loc_conf_t *)*(r->loc_conf + ngx_http_access_module.ctx_index);
  {
#line 137
  if ((int )((r->connection)->sockaddr)->sa_family == 2) {
#line 137
    goto case_2;
  }
#line 146
  if ((int )((r->connection)->sockaddr)->sa_family == 10) {
#line 146
    goto case_10;
  }
#line 168
  if ((int )((r->connection)->sockaddr)->sa_family == 1) {
#line 168
    goto case_1;
  }
#line 135
  goto switch_break;
  case_2: /* CIL Label */ 
#line 138
  if (alcf->rules) {
    {
#line 139
    sin = (struct sockaddr_in *)(r->connection)->sockaddr;
#line 140
    tmp = ngx_http_access_inet(r, alcf, sin->sin_addr.s_addr);
    }
#line 140
    return (tmp);
  }
#line 142
  goto switch_break;
  case_10: /* CIL Label */ 
#line 147
  sin6 = (struct sockaddr_in6 *)(r->connection)->sockaddr;
#line 148
  p = sin6->sin6_addr.__in6_u.__u6_addr8;
#line 150
  if (alcf->rules) {
#line 150
    __a = (struct in6_addr  const  *)(& sin6->sin6_addr);
#line 150
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 150
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 150
        __x___0 = 65535U;
#line 150
        __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 150
        if (__a->__in6_u.__u6_addr32[2] == __v___0) {
#line 150
          tmp___1 = 1;
        } else {
#line 150
          tmp___1 = 0;
        }
      } else {
#line 150
        tmp___1 = 0;
      }
    } else {
#line 150
      tmp___1 = 0;
    }
#line 150
    if (tmp___1) {
      {
#line 151
      addr = (in_addr_t )((int )*(p + 12) << 24);
#line 152
      addr += (in_addr_t )((int )*(p + 13) << 16);
#line 153
      addr += (in_addr_t )((int )*(p + 14) << 8);
#line 154
      addr += (in_addr_t )*(p + 15);
#line 155
      __x = addr;
#line 155
      __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 155
      tmp___0 = ngx_http_access_inet(r, alcf, __v);
      }
#line 155
      return (tmp___0);
    }
  }
#line 158
  if (alcf->rules6) {
    {
#line 159
    tmp___2 = ngx_http_access_inet6(r, alcf, p);
    }
#line 159
    return (tmp___2);
  }
#line 162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 169
  if (alcf->rules_un) {
    {
#line 170
    tmp___3 = ngx_http_access_unix(r, alcf);
    }
#line 170
    return (tmp___3);
  }
#line 173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 178
  return ((ngx_int_t )-5);
}
}
#line 182 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_inet(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                      in_addr_t addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_access_rule_t *rule ;
  ngx_int_t tmp ;

  {
#line 189
  rule = (ngx_http_access_rule_t *)(alcf->rules)->elts;
#line 190
  i = (ngx_uint_t )0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < (alcf->rules)->nelts)) {
#line 190
      goto while_break;
    }
#line 196
    if ((addr & (rule + i)->mask) == (rule + i)->addr) {
      {
#line 197
      tmp = ngx_http_access_found(r, (rule + i)->deny);
      }
#line 197
      return (tmp);
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return ((ngx_int_t )-5);
}
}
#line 207 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_inet6(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                       u_char *p ) 
{ 
  ngx_uint_t n ;
  ngx_uint_t i ;
  ngx_http_access_rule6_t *rule6 ;
  ngx_int_t tmp ;

  {
#line 215
  rule6 = (ngx_http_access_rule6_t *)(alcf->rules6)->elts;
#line 216
  i = (ngx_uint_t )0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < (alcf->rules6)->nelts)) {
#line 216
      goto while_break;
    }
#line 234
    n = (ngx_uint_t )0;
    {
#line 234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 234
      if (! (n < 16UL)) {
#line 234
        goto while_break___0;
      }
#line 235
      if (((int )*(p + n) & (int )(rule6 + i)->mask.__in6_u.__u6_addr8[n]) != (int )(rule6 + i)->addr.__in6_u.__u6_addr8[n]) {
#line 236
        goto next;
      }
#line 234
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 240
    tmp = ngx_http_access_found(r, (rule6 + i)->deny);
    }
#line 240
    return (tmp);
    next: 
#line 243
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return ((ngx_int_t )-5);
}
}
#line 254 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_unix(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ) 
{ 
  ngx_uint_t i ;
  ngx_http_access_rule_un_t *rule_un ;
  ngx_int_t tmp ;

  {
#line 260
  rule_un = (ngx_http_access_rule_un_t *)(alcf->rules_un)->elts;
#line 261
  i = (ngx_uint_t )0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < (alcf->rules_un)->nelts)) {
#line 261
      goto while_break;
    }
    {
#line 265
    tmp = ngx_http_access_found(r, (rule_un + i)->deny);
    }
#line 265
    return (tmp);
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return ((ngx_int_t )-5);
}
}
#line 275 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_found(ngx_http_request_t *r , ngx_uint_t deny ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 280
  if (deny) {
#line 281
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 283
    if (clcf->satisfy == 0UL) {
#line 284
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 284
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "access forbidden by rule");
        }
      }
    }
#line 288
    return ((ngx_int_t )403);
  }
#line 291
  return ((ngx_int_t )0);
}
}
#line 295 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static char *ngx_http_access_rule(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_access_loc_conf_t *alcf ;
  ngx_int_t rc ;
  ngx_uint_t all ;
  ngx_str_t *value ;
  ngx_cidr_t cidr ;
  ngx_http_access_rule_t *rule ;
  ngx_http_access_rule6_t *rule6 ;
  ngx_http_access_rule_un_t *rule_un ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 298
  alcf = (ngx_http_access_loc_conf_t *)conf;
#line 312
  all = (ngx_uint_t )0;
#line 313
  memset((void *)(& cidr), 0, sizeof(ngx_cidr_t ));
#line 315
  value = (ngx_str_t *)(cf->args)->elts;
  }
#line 317
  if ((value + 1)->len == 3UL) {
    {
#line 317
    tmp___0 = strcmp((char const   *)(value + 1)->data, "all");
    }
#line 317
    if (tmp___0 == 0) {
#line 318
      all = (ngx_uint_t )1;
    } else {
#line 317
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 321
  if ((value + 1)->len == 5UL) {
    {
#line 321
    tmp = strcmp((char const   *)(value + 1)->data, "unix:");
    }
#line 321
    if (tmp == 0) {
#line 322
      cidr.family = (ngx_uint_t )1;
    } else {
#line 321
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 326
    rc = ngx_ptocidr(value + 1, & cidr);
    }
#line 328
    if (rc == -1L) {
      {
#line 329
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
      }
#line 331
      return ((char *)((void *)-1));
    }
#line 334
    if (rc == -4L) {
      {
#line 335
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "low address bits of %V are meaningless",
                         value + 1);
      }
    }
  }
#line 340
  if (cidr.family == 2UL) {
#line 340
    goto _L___1;
  } else
#line 340
  if (all) {
    _L___1: /* CIL Label */ 
#line 342
    if ((unsigned long )alcf->rules == (unsigned long )((void *)0)) {
      {
#line 343
      alcf->rules = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_access_rule_t ));
      }
#line 345
      if ((unsigned long )alcf->rules == (unsigned long )((void *)0)) {
#line 346
        return ((char *)((void *)-1));
      }
    }
    {
#line 350
    tmp___1 = ngx_array_push(alcf->rules);
#line 350
    rule = (ngx_http_access_rule_t *)tmp___1;
    }
#line 351
    if ((unsigned long )rule == (unsigned long )((void *)0)) {
#line 352
      return ((char *)((void *)-1));
    }
#line 355
    rule->mask = cidr.u.in.mask;
#line 356
    rule->addr = cidr.u.in.addr;
#line 357
    if ((int )*((value + 0)->data + 0) == 100) {
#line 357
      rule->deny = (ngx_uint_t )1;
    } else {
#line 357
      rule->deny = (ngx_uint_t )0;
    }
  }
#line 361
  if (cidr.family == 10UL) {
#line 361
    goto _L___2;
  } else
#line 361
  if (all) {
    _L___2: /* CIL Label */ 
#line 363
    if ((unsigned long )alcf->rules6 == (unsigned long )((void *)0)) {
      {
#line 364
      alcf->rules6 = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_access_rule6_t ));
      }
#line 366
      if ((unsigned long )alcf->rules6 == (unsigned long )((void *)0)) {
#line 367
        return ((char *)((void *)-1));
      }
    }
    {
#line 371
    tmp___2 = ngx_array_push(alcf->rules6);
#line 371
    rule6 = (ngx_http_access_rule6_t *)tmp___2;
    }
#line 372
    if ((unsigned long )rule6 == (unsigned long )((void *)0)) {
#line 373
      return ((char *)((void *)-1));
    }
#line 376
    rule6->mask = cidr.u.in6.mask;
#line 377
    rule6->addr = cidr.u.in6.addr;
#line 378
    if ((int )*((value + 0)->data + 0) == 100) {
#line 378
      rule6->deny = (ngx_uint_t )1;
    } else {
#line 378
      rule6->deny = (ngx_uint_t )0;
    }
  }
#line 383
  if (cidr.family == 1UL) {
#line 383
    goto _L___3;
  } else
#line 383
  if (all) {
    _L___3: /* CIL Label */ 
#line 385
    if ((unsigned long )alcf->rules_un == (unsigned long )((void *)0)) {
      {
#line 386
      alcf->rules_un = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_access_rule_un_t ));
      }
#line 388
      if ((unsigned long )alcf->rules_un == (unsigned long )((void *)0)) {
#line 389
        return ((char *)((void *)-1));
      }
    }
    {
#line 393
    tmp___3 = ngx_array_push(alcf->rules_un);
#line 393
    rule_un = (ngx_http_access_rule_un_t *)tmp___3;
    }
#line 394
    if ((unsigned long )rule_un == (unsigned long )((void *)0)) {
#line 395
      return ((char *)((void *)-1));
    }
#line 398
    if ((int )*((value + 0)->data + 0) == 100) {
#line 398
      rule_un->deny = (ngx_uint_t )1;
    } else {
#line 398
      rule_un->deny = (ngx_uint_t )0;
    }
  }
#line 402
  return ((char *)((void *)0));
}
}
#line 406 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static void *ngx_http_access_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_access_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 411
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_access_loc_conf_t ));
#line 411
  conf = (ngx_http_access_loc_conf_t *)tmp;
  }
#line 412
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 413
    return ((void *)0);
  }
#line 416
  return ((void *)conf);
}
}
#line 420 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static char *ngx_http_access_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_access_loc_conf_t *prev ;
  ngx_http_access_loc_conf_t *conf ;

  {
#line 423
  prev = (ngx_http_access_loc_conf_t *)parent;
#line 424
  conf = (ngx_http_access_loc_conf_t *)child;
#line 426
  if ((unsigned long )conf->rules == (unsigned long )((void *)0)) {
#line 426
    if ((unsigned long )conf->rules6 == (unsigned long )((void *)0)) {
#line 426
      if ((unsigned long )conf->rules_un == (unsigned long )((void *)0)) {
#line 434
        conf->rules = prev->rules;
#line 436
        conf->rules6 = prev->rules6;
#line 439
        conf->rules_un = prev->rules_un;
      }
    }
  }
#line 443
  return ((char *)((void *)0));
}
}
#line 447 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 453
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 455
  tmp = ngx_array_push(& cmcf->phases[6].handlers);
#line 455
  h = (ngx_http_handler_pt *)tmp;
  }
#line 456
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 457
    return ((ngx_int_t )-1);
  }
#line 460
  *h = & ngx_http_access_handler;
#line 462
  return ((ngx_int_t )0);
}
}
#line 504 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_auth_basic_user(ngx_http_request_t *r ) ;
#line 16 "src/core/ngx_crypt.h"
ngx_int_t ngx_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 28 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_handler(ngx_http_request_t *r ) ;
#line 29
static ngx_int_t ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r , ngx_http_auth_basic_ctx_t *ctx ,
                                                   ngx_str_t *passwd , ngx_str_t *realm ) ;
#line 31
static ngx_int_t ngx_http_auth_basic_set_realm(ngx_http_request_t *r , ngx_str_t *realm ) ;
#line 33
static void ngx_http_auth_basic_close(ngx_file_t *file ) ;
#line 34
static void *ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf ) ;
#line 35
static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 37
static ngx_int_t ngx_http_auth_basic_init(ngx_conf_t *cf ) ;
#line 38
static char *ngx_http_auth_basic_user_file(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 42 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_command_t ngx_http_auth_basic_commands[3]  = {      {{sizeof("auth_basic") - 1UL, (u_char *)"auth_basic"}, (ngx_uint_t )2382364674U,
      & ngx_http_set_complex_value_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_auth_basic_loc_conf_t *)0)->realm), (void *)0}, 
        {{sizeof("auth_basic_user_file") - 1UL,
       (u_char *)"auth_basic_user_file"}, (ngx_uint_t )2382364674U, & ngx_http_auth_basic_user_file,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_auth_basic_loc_conf_t *)0)->user_file),
      (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 64 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_http_module_t ngx_http_auth_basic_module_ctx  = 
#line 64
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_auth_basic_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_auth_basic_create_loc_conf,
    & ngx_http_auth_basic_merge_loc_conf};
#line 79 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
ngx_module_t ngx_http_auth_basic_module  = 
#line 79
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_auth_basic_module_ctx),
    ngx_http_auth_basic_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 95 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_handler(ngx_http_request_t *r ) 
{ 
  off_t offset ;
  ssize_t n ;
  ngx_fd_t fd ;
  ngx_int_t rc ;
  ngx_err_t err ;
  ngx_str_t pwd ;
  ngx_str_t realm ;
  ngx_str_t user_file ;
  ngx_uint_t i ;
  ngx_uint_t level ;
  ngx_uint_t login ;
  ngx_uint_t left ;
  ngx_uint_t passwd ;
  ngx_file_t file ;
  ngx_http_auth_basic_ctx_t *ctx ;
  ngx_http_auth_basic_loc_conf_t *alcf ;
  u_char buf[2048] ;
  enum __anonenum_state_88255402 state ;
  ngx_int_t tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  int *tmp___4 ;
  ngx_int_t tmp___5 ;
  void *tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;

  {
#line 115
  alcf = (ngx_http_auth_basic_loc_conf_t *)*(r->loc_conf + ngx_http_auth_basic_module.ctx_index);
#line 117
  if ((unsigned long )alcf->realm == (unsigned long )((void *)0)) {
#line 118
    return ((ngx_int_t )-5);
  } else
#line 117
  if ((unsigned long )alcf->user_file.value.data == (unsigned long )((void *)0)) {
#line 118
    return ((ngx_int_t )-5);
  }
  {
#line 121
  tmp = ngx_http_complex_value(r, alcf->realm, & realm);
  }
#line 121
  if (tmp != 0L) {
#line 122
    return ((ngx_int_t )-1);
  }
#line 125
  if (realm.len == 3UL) {
    {
#line 125
    tmp___0 = strncmp((char const   *)realm.data, "off", (size_t )3);
    }
#line 125
    if (tmp___0 == 0) {
#line 126
      return ((ngx_int_t )-5);
    }
  }
#line 129
  ctx = (ngx_http_auth_basic_ctx_t *)*(r->ctx + ngx_http_auth_basic_module.ctx_index);
#line 131
  if (ctx) {
    {
#line 132
    tmp___1 = ngx_http_auth_basic_crypt_handler(r, ctx, & ctx->passwd, & realm);
    }
#line 132
    return (tmp___1);
  }
  {
#line 136
  rc = ngx_http_auth_basic_user(r);
  }
#line 138
  if (rc == -5L) {
#line 140
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 140
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "no user/password was provided for basic authentication");
      }
    }
    {
#line 143
    tmp___2 = ngx_http_auth_basic_set_realm(r, & realm);
    }
#line 143
    return (tmp___2);
  }
#line 146
  if (rc == -1L) {
#line 147
    return ((ngx_int_t )500);
  }
  {
#line 150
  tmp___3 = ngx_http_complex_value(r, & alcf->user_file, & user_file);
  }
#line 150
  if (tmp___3 != 0L) {
#line 151
    return ((ngx_int_t )-1);
  }
  {
#line 154
  fd = open((char const   *)user_file.data, 0, 0);
  }
#line 156
  if (fd == -1) {
    {
#line 157
    tmp___4 = __errno_location();
#line 157
    err = *tmp___4;
    }
#line 159
    if (err == 2) {
#line 160
      level = (ngx_uint_t )4;
#line 161
      rc = (ngx_int_t )403;
    } else {
#line 164
      level = (ngx_uint_t )3;
#line 165
      rc = (ngx_int_t )500;
    }
#line 168
    if (((r->connection)->log)->log_level >= level) {
      {
#line 168
      ngx_log_error_core(level, (r->connection)->log, err, "open() \"%s\" failed",
                         user_file.data);
      }
    }
#line 171
    return (rc);
  }
  {
#line 174
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 176
  file.fd = fd;
#line 177
  file.name = user_file;
#line 178
  file.log = (r->connection)->log;
#line 180
  state = (enum __anonenum_state_88255402 )0;
#line 181
  passwd = (ngx_uint_t )0;
#line 182
  login = (ngx_uint_t )0;
#line 183
  left = (ngx_uint_t )0;
#line 184
  offset = (off_t )0;
  }
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 187
    i = left;
#line 189
    n = ngx_read_file(& file, buf + left, 2048UL - left, offset);
    }
#line 192
    if (n == -1L) {
      {
#line 193
      ngx_http_auth_basic_close(& file);
      }
#line 194
      return ((ngx_int_t )500);
    }
#line 197
    if (n == 0L) {
#line 198
      goto while_break;
    }
#line 201
    i = left;
    {
#line 201
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 201
      if (! (i < left + (ngx_uint_t )n)) {
#line 201
        goto while_break___0;
      }
      {
#line 204
      if ((unsigned int )state == 0U) {
#line 204
        goto case_0;
      }
#line 231
      if ((unsigned int )state == 1U) {
#line 231
        goto case_1;
      }
#line 246
      if ((unsigned int )state == 2U) {
#line 246
        goto case_2;
      }
#line 202
      goto switch_break;
      case_0: /* CIL Label */ 
#line 205
      if (login == 0UL) {
#line 207
        if ((int )buf[i] == 35) {
#line 208
          state = (enum __anonenum_state_88255402 )2;
#line 209
          goto switch_break;
        } else
#line 207
        if ((int )buf[i] == 13) {
#line 208
          state = (enum __anonenum_state_88255402 )2;
#line 209
          goto switch_break;
        }
#line 212
        if ((int )buf[i] == 10) {
#line 213
          goto switch_break;
        }
      }
#line 217
      if ((int )buf[i] != (int )*(r->headers_in.user.data + login)) {
#line 218
        state = (enum __anonenum_state_88255402 )2;
#line 219
        goto switch_break;
      }
#line 222
      if (login == r->headers_in.user.len) {
#line 223
        state = (enum __anonenum_state_88255402 )1;
#line 224
        passwd = i + 1UL;
      }
#line 227
      login ++;
#line 229
      goto switch_break;
      case_1: /* CIL Label */ 
#line 232
      if ((int )buf[i] == 10) {
#line 232
        goto _L;
      } else
#line 232
      if ((int )buf[i] == 13) {
#line 232
        goto _L;
      } else
#line 232
      if ((int )buf[i] == 58) {
        _L: /* CIL Label */ 
        {
#line 233
        buf[i] = (u_char )'\000';
#line 235
        ngx_http_auth_basic_close(& file);
#line 237
        pwd.len = i - passwd;
#line 238
        pwd.data = & buf[passwd];
#line 240
        tmp___5 = ngx_http_auth_basic_crypt_handler(r, (ngx_http_auth_basic_ctx_t *)((void *)0),
                                                    & pwd, & realm);
        }
#line 240
        return (tmp___5);
      }
#line 244
      goto switch_break;
      case_2: /* CIL Label */ 
#line 247
      if ((int )buf[i] == 10) {
#line 248
        state = (enum __anonenum_state_88255402 )0;
#line 249
        login = (ngx_uint_t )0;
      }
#line 252
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 201
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    if ((unsigned int )state == 1U) {
      {
#line 257
      left = (left + (ngx_uint_t )n) - passwd;
#line 258
      memmove((void *)(buf), (void const   *)(& buf[passwd]), left);
#line 259
      passwd = (ngx_uint_t )0;
      }
    } else {
#line 262
      left = (ngx_uint_t )0;
    }
#line 265
    offset += n;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 268
  ngx_http_auth_basic_close(& file);
  }
#line 270
  if ((unsigned int )state == 1U) {
    {
#line 271
    pwd.len = i - passwd;
#line 272
    tmp___6 = ngx_pnalloc(r->pool, pwd.len + 1UL);
#line 272
    pwd.data = (u_char *)tmp___6;
    }
#line 273
    if ((unsigned long )pwd.data == (unsigned long )((void *)0)) {
#line 274
      return ((ngx_int_t )500);
    }
    {
#line 277
    ngx_cpystrn(pwd.data, & buf[passwd], pwd.len + 1UL);
#line 279
    tmp___7 = ngx_http_auth_basic_crypt_handler(r, (ngx_http_auth_basic_ctx_t *)((void *)0),
                                                & pwd, & realm);
    }
#line 279
    return (tmp___7);
  }
#line 282
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 282
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "user \"%V\" was not found in \"%V\"",
                       & r->headers_in.user, & user_file);
    }
  }
  {
#line 286
  tmp___8 = ngx_http_auth_basic_set_realm(r, & realm);
  }
#line 286
  return (tmp___8);
}
}
#line 290 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r , ngx_http_auth_basic_ctx_t *ctx ,
                                                   ngx_str_t *passwd , ngx_str_t *realm ) 
{ 
  ngx_int_t rc ;
  u_char *encrypted ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 297
  rc = ngx_crypt(r->pool, r->headers_in.passwd.data, passwd->data, & encrypted);
  }
#line 304
  if (rc == 0L) {
    {
#line 305
    tmp = strcmp((char const   *)encrypted, (char const   *)passwd->data);
    }
#line 305
    if (tmp == 0) {
#line 306
      return ((ngx_int_t )0);
    }
#line 312
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 312
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "user \"%V\": password mismatch",
                         & r->headers_in.user);
      }
    }
    {
#line 316
    tmp___0 = ngx_http_auth_basic_set_realm(r, realm);
    }
#line 316
    return (tmp___0);
  }
#line 319
  if (rc == -1L) {
#line 320
    return ((ngx_int_t )500);
  }
#line 325
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 326
    tmp___1 = ngx_palloc(r->pool, sizeof(ngx_http_auth_basic_ctx_t ));
#line 326
    ctx = (ngx_http_auth_basic_ctx_t *)tmp___1;
    }
#line 327
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 328
      return ((ngx_int_t )500);
    }
    {
#line 331
    *(r->ctx + ngx_http_auth_basic_module.ctx_index) = (void *)ctx;
#line 333
    ctx->passwd.len = passwd->len;
#line 334
    (passwd->len) ++;
#line 336
    ctx->passwd.data = ngx_pstrdup(r->pool, passwd);
    }
#line 337
    if ((unsigned long )ctx->passwd.data == (unsigned long )((void *)0)) {
#line 338
      return ((ngx_int_t )500);
    }
  }
#line 345
  return (rc);
}
}
#line 349 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_set_realm(ngx_http_request_t *r , ngx_str_t *realm ) 
{ 
  size_t___0 len ;
  u_char *basic ;
  u_char *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 355
  tmp = ngx_list_push(& r->headers_out.headers);
#line 355
  r->headers_out.www_authenticate = (ngx_table_elt_t *)tmp;
  }
#line 356
  if ((unsigned long )r->headers_out.www_authenticate == (unsigned long )((void *)0)) {
#line 357
    return ((ngx_int_t )500);
  }
  {
#line 360
  len = (sizeof("Basic realm=\"\"") - 1UL) + realm->len;
#line 362
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 362
  basic = (u_char *)tmp___0;
  }
#line 363
  if ((unsigned long )basic == (unsigned long )((void *)0)) {
#line 364
    (r->headers_out.www_authenticate)->hash = (ngx_uint_t )0;
#line 365
    r->headers_out.www_authenticate = (ngx_table_elt_t *)((void *)0);
#line 366
    return ((ngx_int_t )500);
  }
  {
#line 369
  tmp___1 = memcpy((void */* __restrict  */)basic, (void const   */* __restrict  */)"Basic realm=\"",
                   sizeof("Basic realm=\"") - 1UL);
#line 369
  p = (u_char *)tmp___1 + (sizeof("Basic realm=\"") - 1UL);
#line 370
  tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)realm->data,
                   realm->len);
#line 370
  p = (u_char *)tmp___2 + realm->len;
#line 371
  *p = (u_char )'\"';
#line 373
  (r->headers_out.www_authenticate)->hash = (ngx_uint_t )1;
#line 374
  (r->headers_out.www_authenticate)->key.len = sizeof("WWW-Authenticate") - 1UL;
#line 374
  (r->headers_out.www_authenticate)->key.data = (u_char *)"WWW-Authenticate";
#line 375
  (r->headers_out.www_authenticate)->value.data = basic;
#line 376
  (r->headers_out.www_authenticate)->value.len = len;
  }
#line 378
  return ((ngx_int_t )401);
}
}
#line 381 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static void ngx_http_auth_basic_close(ngx_file_t *file ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 384
  tmp___0 = close(file->fd);
  }
#line 384
  if (tmp___0 == -1) {
#line 385
    if ((file->log)->log_level >= 2UL) {
      {
#line 385
      tmp = __errno_location();
#line 385
      ngx_log_error_core((ngx_uint_t )2, file->log, *tmp, "close() \"%s\" failed",
                         file->name.data);
      }
    }
  }
#line 388
  return;
}
}
#line 391 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static void *ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_auth_basic_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 396
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_auth_basic_loc_conf_t ));
#line 396
  conf = (ngx_http_auth_basic_loc_conf_t *)tmp;
  }
#line 397
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 398
    return ((void *)0);
  }
#line 401
  return ((void *)conf);
}
}
#line 405 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_auth_basic_loc_conf_t *prev ;
  ngx_http_auth_basic_loc_conf_t *conf ;

  {
#line 408
  prev = (ngx_http_auth_basic_loc_conf_t *)parent;
#line 409
  conf = (ngx_http_auth_basic_loc_conf_t *)child;
#line 411
  if ((unsigned long )conf->realm == (unsigned long )((void *)0)) {
#line 412
    conf->realm = prev->realm;
  }
#line 415
  if ((unsigned long )conf->user_file.value.data == (unsigned long )((void *)0)) {
#line 416
    conf->user_file = prev->user_file;
  }
#line 419
  return ((char *)((void *)0));
}
}
#line 423 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 429
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 431
  tmp = ngx_array_push(& cmcf->phases[6].handlers);
#line 431
  h = (ngx_http_handler_pt *)tmp;
  }
#line 432
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 433
    return ((ngx_int_t )-1);
  }
#line 436
  *h = & ngx_http_auth_basic_handler;
#line 438
  return ((ngx_int_t )0);
}
}
#line 442 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_auth_basic_module.c"
static char *ngx_http_auth_basic_user_file(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_auth_basic_loc_conf_t *alcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;

  {
#line 445
  alcf = (ngx_http_auth_basic_loc_conf_t *)conf;
#line 450
  if (alcf->user_file.value.data) {
#line 451
    return ((char *)"is duplicate");
  }
  {
#line 454
  value = (ngx_str_t *)(cf->args)->elts;
#line 456
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 458
  ccv.cf = cf;
#line 459
  ccv.value = value + 1;
#line 460
  ccv.complex_value = & alcf->user_file;
#line 461
  ccv.zero = 1U;
#line 462
  ccv.conf_prefix = 1U;
#line 464
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 464
  if (tmp != 0L) {
#line 465
    return ((char *)((void *)-1));
  }
#line 468
  return ((char *)((void *)0));
}
}
#line 125 "src/core/ngx_open_file_cache.h"
ngx_int_t ngx_open_cached_file(ngx_open_file_cache_t *cache , ngx_str_t *name , ngx_open_file_info_t *of ,
                               ngx_pool_t *pool ) ;
#line 502 "src/http/ngx_http_core_module.h"
u_char *ngx_http_map_uri_to_path(ngx_http_request_t *r , ngx_str_t *path , size_t___0 *root_length ,
                                 size_t___0 reserved ) ;
#line 513
ngx_int_t ngx_http_internal_redirect(ngx_http_request_t *r , ngx_str_t *uri___0 ,
                                     ngx_str_t *args___0 ) ;
#line 534
ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                        ngx_str_t *path , ngx_open_file_info_t *of ) ;
#line 29 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_test_dir(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                         u_char *path , u_char *last ) ;
#line 31
static ngx_int_t ngx_http_index_error(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                      u_char *file , ngx_err_t err ) ;
#line 34
static ngx_int_t ngx_http_index_init(ngx_conf_t *cf ) ;
#line 35
static void *ngx_http_index_create_loc_conf(ngx_conf_t *cf ) ;
#line 36
static char *ngx_http_index_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 38
static char *ngx_http_index_set_index(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 42 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static ngx_command_t ngx_http_index_commands[2]  = {      {{sizeof("index") - 1UL, (u_char *)"index"}, (ngx_uint_t )234883072, & ngx_http_index_set_index,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static ngx_http_module_t ngx_http_index_module_ctx  = 
#line 55
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_index_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_index_create_loc_conf,
    & ngx_http_index_merge_loc_conf};
#line 70 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
ngx_module_t ngx_http_index_module  = 
#line 70
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_index_module_ctx),
    ngx_http_index_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 96 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_handler(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *name ;
  size_t___0 len ;
  size_t___0 root ;
  size_t___0 reserve ;
  size_t___0 allocated ;
  ngx_int_t rc ;
  ngx_str_t path ;
  ngx_str_t uri___0 ;
  ngx_uint_t i ;
  ngx_uint_t dir_tested ;
  ngx_http_index_t *index___0 ;
  ngx_open_file_info_t of ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_index_loc_conf_t *ilcf ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_int_t tmp ;
  size_t___0 tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  ngx_int_t tmp___7 ;

  {
#line 112
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) != 47) {
#line 113
    return ((ngx_int_t )-5);
  }
#line 116
  if (! (r->method & 14UL)) {
#line 117
    return ((ngx_int_t )-5);
  }
#line 120
  ilcf = (ngx_http_index_loc_conf_t *)*(r->loc_conf + ngx_http_index_module.ctx_index);
#line 121
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 123
  allocated = (size_t___0 )0;
#line 124
  root = (size_t___0 )0;
#line 125
  dir_tested = (ngx_uint_t )0;
#line 126
  name = (u_char *)((void *)0);
#line 128
  path.data = (u_char *)((void *)0);
#line 130
  index___0 = (ngx_http_index_t *)(ilcf->indices)->elts;
#line 131
  i = (ngx_uint_t )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < (ilcf->indices)->nelts)) {
#line 131
      goto while_break;
    }
#line 133
    if ((unsigned long )(index___0 + i)->lengths == (unsigned long )((void *)0)) {
#line 135
      if ((int )*((index___0 + i)->name.data + 0) == 47) {
        {
#line 136
        tmp = ngx_http_internal_redirect(r, & (index___0 + i)->name, & r->args);
        }
#line 136
        return (tmp);
      }
#line 139
      reserve = ilcf->max_index_len;
#line 140
      len = (index___0 + i)->name.len;
    } else {
      {
#line 143
      memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 145
      e.ip = (u_char *)((index___0 + i)->lengths)->elts;
#line 146
      e.request = r;
#line 147
      e.flushed = 1U;
#line 150
      len = (size_t___0 )1;
      }
      {
#line 152
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 152
        if (! *((uintptr_t *)e.ip)) {
#line 152
          goto while_break___0;
        }
        {
#line 153
        lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 154
        tmp___0 = (*lcode)(& e);
#line 154
        len += tmp___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 159
      reserve = len + 16UL;
    }
#line 162
    if (reserve > allocated) {
      {
#line 164
      name = ngx_http_map_uri_to_path(r, & path, & root, reserve);
      }
#line 165
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 166
        return ((ngx_int_t )-1);
      }
#line 169
      allocated = (size_t___0 )((path.data + path.len) - name);
    }
#line 172
    if ((unsigned long )(index___0 + i)->values == (unsigned long )((void *)0)) {
      {
#line 176
      memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)(index___0 + i)->name.data,
             (index___0 + i)->name.len);
#line 178
      path.len = (size_t___0 )(((name + (index___0 + i)->name.len) - 1) - path.data);
      }
    } else {
#line 181
      e.ip = (u_char *)((index___0 + i)->values)->elts;
#line 182
      e.pos = name;
      {
#line 184
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 184
        if (! *((uintptr_t *)e.ip)) {
#line 184
          goto while_break___1;
        }
        {
#line 185
        code = *((ngx_http_script_code_pt *)e.ip);
#line 186
        (*code)(& e);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 189
      if ((int )*name == 47) {
        {
#line 190
        uri___0.len = len - 1UL;
#line 191
        uri___0.data = name;
#line 192
        tmp___1 = ngx_http_internal_redirect(r, & uri___0, & r->args);
        }
#line 192
        return (tmp___1);
      }
#line 195
      path.len = (size_t___0 )(e.pos - path.data);
#line 197
      *(e.pos) = (u_char )'\000';
    }
    {
#line 203
    memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 205
    of.read_ahead = clcf->read_ahead;
#line 206
    of.directio = clcf->directio;
#line 207
    of.valid = clcf->open_file_cache_valid;
#line 208
    of.min_uses = clcf->open_file_cache_min_uses;
#line 209
    of.test_only = 1U;
#line 210
    of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 211
    of.events = (unsigned int )clcf->open_file_cache_events;
#line 213
    tmp___2 = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
    }
#line 213
    if (tmp___2 != 0L) {
#line 214
      return ((ngx_int_t )500);
    }
    {
#line 217
    tmp___4 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
    }
#line 217
    if (tmp___4 != 0L) {
#line 220
      if (of.err == 0) {
#line 221
        return ((ngx_int_t )500);
      }
#line 228
      if (of.err == 31) {
#line 231
        return ((ngx_int_t )403);
      } else
#line 228
      if (of.err == 40) {
#line 231
        return ((ngx_int_t )403);
      }
#line 235
      if (of.err == 20) {
        {
#line 239
        tmp___3 = ngx_http_index_error(r, clcf, path.data, of.err);
        }
#line 239
        return (tmp___3);
      } else
#line 235
      if (of.err == 36) {
        {
#line 239
        tmp___3 = ngx_http_index_error(r, clcf, path.data, of.err);
        }
#line 239
        return (tmp___3);
      } else
#line 235
      if (of.err == 13) {
        {
#line 239
        tmp___3 = ngx_http_index_error(r, clcf, path.data, of.err);
        }
#line 239
        return (tmp___3);
      }
#line 242
      if (! dir_tested) {
        {
#line 243
        rc = ngx_http_index_test_dir(r, clcf, path.data, name - 1);
        }
#line 245
        if (rc != 0L) {
#line 246
          return (rc);
        }
#line 249
        dir_tested = (ngx_uint_t )1;
      }
#line 252
      if (of.err == 2) {
#line 253
        goto __Cont;
      }
#line 256
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 256
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                           of.failed, path.data);
        }
      }
#line 259
      return ((ngx_int_t )500);
    }
#line 262
    uri___0.len = (r->uri.len + len) - 1UL;
#line 264
    if (! clcf->alias) {
#line 265
      uri___0.data = path.data + root;
    } else {
      {
#line 268
      tmp___5 = ngx_pnalloc(r->pool, uri___0.len);
#line 268
      uri___0.data = (u_char *)tmp___5;
      }
#line 269
      if ((unsigned long )uri___0.data == (unsigned long )((void *)0)) {
#line 270
        return ((ngx_int_t )500);
      }
      {
#line 273
      tmp___6 = memcpy((void */* __restrict  */)uri___0.data, (void const   */* __restrict  */)r->uri.data,
                       r->uri.len);
#line 273
      p = (u_char *)tmp___6 + r->uri.len;
#line 274
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)name, len - 1UL);
      }
    }
    {
#line 277
    tmp___7 = ngx_http_internal_redirect(r, & uri___0, & r->args);
    }
#line 277
    return (tmp___7);
    __Cont: /* CIL Label */ 
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return ((ngx_int_t )-5);
}
}
#line 284 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_test_dir(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                         u_char *path , u_char *last ) 
{ 
  u_char c ;
  ngx_str_t dir ;
  ngx_open_file_info_t of ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 292
  c = *last;
#line 293
  if ((int )c != 47) {
#line 295
    last ++;
#line 295
    c = *last;
  } else
#line 293
  if ((unsigned long )path == (unsigned long )last) {
#line 295
    last ++;
#line 295
    c = *last;
  }
  {
#line 297
  *last = (u_char )'\000';
#line 299
  dir.len = (size_t___0 )(last - path);
#line 300
  dir.data = path;
#line 305
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 307
  of.test_dir = 1U;
#line 308
  of.test_only = 1U;
#line 309
  of.valid = clcf->open_file_cache_valid;
#line 310
  of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 312
  tmp = ngx_http_set_disable_symlinks(r, clcf, & dir, & of);
  }
#line 312
  if (tmp != 0L) {
#line 313
    return ((ngx_int_t )500);
  }
  {
#line 316
  tmp___1 = ngx_open_cached_file(clcf->open_file_cache, & dir, & of, r->pool);
  }
#line 316
  if (tmp___1 != 0L) {
#line 319
    if (of.err) {
#line 322
      if (of.err == 31) {
#line 325
        return ((ngx_int_t )403);
      } else
#line 322
      if (of.err == 40) {
#line 325
        return ((ngx_int_t )403);
      }
#line 329
      if (of.err == 2) {
        {
#line 330
        *last = c;
#line 331
        tmp___0 = ngx_http_index_error(r, clcf, dir.data, 2);
        }
#line 331
        return (tmp___0);
      }
#line 334
      if (of.err == 13) {
#line 336
        *last = c;
#line 344
        return ((ngx_int_t )0);
      }
#line 347
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 347
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                           of.failed, dir.data);
        }
      }
    }
#line 351
    return ((ngx_int_t )500);
  }
#line 354
  *last = c;
#line 356
  if (of.is_dir) {
#line 357
    return ((ngx_int_t )0);
  }
#line 360
  if (((r->connection)->log)->log_level >= 2UL) {
    {
#line 360
    ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "\"%s\" is not a directory",
                       dir.data);
    }
  }
#line 363
  return ((ngx_int_t )500);
}
}
#line 367 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_error(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                      u_char *file , ngx_err_t err ) 
{ 


  {
#line 371
  if (err == 13) {
#line 372
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 372
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, err, "\"%s\" is forbidden",
                         file);
      }
    }
#line 375
    return ((ngx_int_t )403);
  }
#line 378
  if (clcf->log_not_found) {
#line 379
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 379
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, err, "\"%s\" is not found",
                         file);
      }
    }
  }
#line 383
  return ((ngx_int_t )404);
}
}
#line 387 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static void *ngx_http_index_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_index_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 392
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_index_loc_conf_t ));
#line 392
  conf = (ngx_http_index_loc_conf_t *)tmp;
  }
#line 393
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 394
    return ((void *)0);
  }
#line 397
  conf->indices = (ngx_array_t *)((void *)0);
#line 398
  conf->max_index_len = (size_t___0 )0;
#line 400
  return ((void *)conf);
}
}
#line 404 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static char *ngx_http_index_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_index_loc_conf_t *prev ;
  ngx_http_index_loc_conf_t *conf ;
  ngx_http_index_t *index___0 ;
  void *tmp ;

  {
#line 407
  prev = (ngx_http_index_loc_conf_t *)parent;
#line 408
  conf = (ngx_http_index_loc_conf_t *)child;
#line 412
  if ((unsigned long )conf->indices == (unsigned long )((void *)0)) {
#line 413
    conf->indices = prev->indices;
#line 414
    conf->max_index_len = prev->max_index_len;
  }
#line 417
  if ((unsigned long )conf->indices == (unsigned long )((void *)0)) {
    {
#line 418
    conf->indices = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_index_t ));
    }
#line 419
    if ((unsigned long )conf->indices == (unsigned long )((void *)0)) {
#line 420
      return ((char *)((void *)-1));
    }
    {
#line 423
    tmp = ngx_array_push(conf->indices);
#line 423
    index___0 = (ngx_http_index_t *)tmp;
    }
#line 424
    if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 425
      return ((char *)((void *)-1));
    }
#line 428
    index___0->name.len = sizeof("index.html");
#line 429
    index___0->name.data = (u_char *)"index.html";
#line 430
    index___0->lengths = (ngx_array_t *)((void *)0);
#line 431
    index___0->values = (ngx_array_t *)((void *)0);
#line 433
    conf->max_index_len = sizeof("index.html");
#line 435
    return ((char *)((void *)0));
  }
#line 438
  return ((char *)((void *)0));
}
}
#line 442 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 448
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 450
  tmp = ngx_array_push(& cmcf->phases[9].handlers);
#line 450
  h = (ngx_http_handler_pt *)tmp;
  }
#line 451
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 452
    return ((ngx_int_t )-1);
  }
#line 455
  *h = & ngx_http_index_handler;
#line 457
  return ((ngx_int_t )0);
}
}
#line 463 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_index_module.c"
static char *ngx_http_index_set_index(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_index_loc_conf_t *ilcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_index_t *index___0 ;
  ngx_http_script_compile_t sc ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 466
  ilcf = (ngx_http_index_loc_conf_t *)conf;
#line 473
  if ((unsigned long )ilcf->indices == (unsigned long )((void *)0)) {
    {
#line 474
    ilcf->indices = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_http_index_t ));
    }
#line 475
    if ((unsigned long )ilcf->indices == (unsigned long )((void *)0)) {
#line 476
      return ((char *)((void *)-1));
    }
  }
#line 480
  value = (ngx_str_t *)(cf->args)->elts;
#line 482
  i = (ngx_uint_t )1;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (i < (cf->args)->nelts)) {
#line 482
      goto while_break;
    }
#line 484
    if ((int )*((value + i)->data + 0) == 47) {
#line 484
      if (i != (cf->args)->nelts - 1UL) {
        {
#line 485
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "only the last index in \"index\" directive should be absolute");
        }
      }
    }
#line 490
    if ((value + i)->len == 0UL) {
      {
#line 491
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "index \"%V\" in \"index\" directive is invalid",
                         value + 1);
      }
#line 494
      return ((char *)((void *)-1));
    }
    {
#line 497
    tmp = ngx_array_push(ilcf->indices);
#line 497
    index___0 = (ngx_http_index_t *)tmp;
    }
#line 498
    if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 499
      return ((char *)((void *)-1));
    }
    {
#line 502
    index___0->name.len = (value + i)->len;
#line 503
    index___0->name.data = (value + i)->data;
#line 504
    index___0->lengths = (ngx_array_t *)((void *)0);
#line 505
    index___0->values = (ngx_array_t *)((void *)0);
#line 507
    n = ngx_http_script_variables_count(value + i);
    }
#line 509
    if (n == 0UL) {
#line 510
      if (ilcf->max_index_len < index___0->name.len) {
#line 511
        ilcf->max_index_len = index___0->name.len;
      }
#line 514
      if ((int )*(index___0->name.data + 0) == 47) {
#line 515
        goto __Cont;
      }
#line 519
      (index___0->name.len) ++;
#line 521
      goto __Cont;
    }
    {
#line 524
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 526
    sc.cf = cf;
#line 527
    sc.source = value + i;
#line 528
    sc.lengths = & index___0->lengths;
#line 529
    sc.values = & index___0->values;
#line 530
    sc.variables = n;
#line 531
    sc.complete_lengths = 1U;
#line 532
    sc.complete_values = 1U;
#line 534
    tmp___0 = ngx_http_script_compile(& sc);
    }
#line 534
    if (tmp___0 != 0L) {
#line 535
      return ((char *)((void *)-1));
    }
    __Cont: /* CIL Label */ 
#line 482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return ((char *)((void *)0));
}
}
#line 384 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 149 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 191 "src/core/ngx_string.h"
size_t___0 ngx_utf8_length(u_char *p , size_t___0 n ) ;
#line 192
u_char *ngx_utf8_cpystrn(u_char *dst , u_char *src , size_t___0 n , size_t___0 len ) ;
#line 209
uintptr_t ngx_escape_html(u_char *dst , u_char *src , size_t___0 size ) ;
#line 210
uintptr_t ngx_escape_json(u_char *dst , u_char *src , size_t___0 size ) ;
#line 219 "src/os/unix/ngx_files.h"
ngx_int_t ngx_open_dir(ngx_str_t *name , ngx_dir_t *dir ) ;
#line 227
ngx_int_t ngx_read_dir(ngx_dir_t *dir ) ;
#line 249 "src/os/unix/ngx_files.h"
__inline static ngx_int_t ngx_de_info(u_char *name , ngx_dir_t *dir ) 
{ 
  int tmp ;

  {
  {
#line 252
  dir->type = 0U;
#line 253
  tmp = stat((char const   */* __restrict  */)((char const   *)name), (struct stat */* __restrict  */)(& dir->info));
  }
#line 253
  return ((ngx_int_t )tmp);
}
}
#line 26 "src/core/ngx_times.h"
u_char *ngx_http_time(u_char *buf , time_t t ) ;
#line 28
void ngx_gmtime(time_t t , ngx_tm_t *tp ) ;
#line 528 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_output_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 106 "src/http/ngx_http.h"
ngx_int_t ngx_http_arg(ngx_http_request_t *r , u_char *name , size_t___0 len , ngx_str_t *value ) ;
#line 140
ngx_int_t ngx_http_send_header(ngx_http_request_t *r ) ;
#line 58 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_html(ngx_http_request_t *r , ngx_array_t *entries ) ;
#line 60
static ngx_buf_t *ngx_http_autoindex_json(ngx_http_request_t *r , ngx_array_t *entries ,
                                          ngx_str_t *callback ) ;
#line 62
static ngx_int_t ngx_http_autoindex_jsonp_callback(ngx_http_request_t *r , ngx_str_t *callback ) ;
#line 64
static ngx_buf_t *ngx_http_autoindex_xml(ngx_http_request_t *r , ngx_array_t *entries ) ;
#line 67
static int ngx_http_autoindex_cmp_entries(void const   *one , void const   *two ) ;
#line 69
static ngx_int_t ngx_http_autoindex_error(ngx_http_request_t *r , ngx_dir_t *dir ,
                                          ngx_str_t *name ) ;
#line 72
static ngx_int_t ngx_http_autoindex_init(ngx_conf_t *cf ) ;
#line 73
static void *ngx_http_autoindex_create_loc_conf(ngx_conf_t *cf ) ;
#line 74
static char *ngx_http_autoindex_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 78 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_conf_enum_t ngx_http_autoindex_format[5]  = {      {{sizeof("html") - 1UL, (u_char *)"html"}, (ngx_uint_t )0}, 
        {{sizeof("json") - 1UL, (u_char *)"json"}, (ngx_uint_t )1}, 
        {{sizeof("jsonp") - 1UL, (u_char *)"jsonp"}, (ngx_uint_t )2}, 
        {{sizeof("xml") - 1UL, (u_char *)"xml"}, (ngx_uint_t )3}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 87 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_command_t ngx_http_autoindex_commands[5]  = {      {{sizeof("autoindex") - 1UL, (u_char *)"autoindex"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->enable), (void *)0}, 
        {{sizeof("autoindex_format") - 1UL,
       (u_char *)"autoindex_format"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->format),
      (void *)(& ngx_http_autoindex_format)}, 
        {{sizeof("autoindex_localtime") - 1UL, (u_char *)"autoindex_localtime"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->localtime), (void *)0}, 
        {{sizeof("autoindex_exact_size") - 1UL,
       (u_char *)"autoindex_exact_size"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->exact_size),
      (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 121 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_http_module_t ngx_http_autoindex_module_ctx  = 
#line 121
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_autoindex_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_autoindex_create_loc_conf,
    & ngx_http_autoindex_merge_loc_conf};
#line 136 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
ngx_module_t ngx_http_autoindex_module  = 
#line 136
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_autoindex_module_ctx),
    ngx_http_autoindex_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 152 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_handler(ngx_http_request_t *r ) 
{ 
  u_char *last ;
  u_char *filename ;
  size_t___0 len ;
  size_t___0 allocated ;
  size_t___0 root ;
  ngx_err_t err ;
  ngx_buf_t *b ;
  ngx_int_t rc ;
  ngx_str_t path ;
  ngx_str_t callback ;
  ngx_dir_t dir ;
  ngx_uint_t level ;
  ngx_uint_t format ;
  ngx_pool_t *pool ;
  ngx_chain_t out ;
  ngx_array_t entries ;
  ngx_http_autoindex_entry_t *entry ;
  ngx_http_autoindex_loc_conf_t *alcf ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  ngx_int_t tmp___11 ;
  u_char *tmp___12 ;
  int *tmp___13 ;
  ngx_int_t tmp___14 ;
  int *tmp___15 ;
  ngx_int_t tmp___16 ;
  int tmp___17 ;
  ngx_int_t tmp___18 ;
  void *tmp___19 ;
  ngx_int_t tmp___20 ;
  void *tmp___21 ;
  ngx_int_t tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;
  ngx_int_t tmp___25 ;

  {
#line 169
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) != 47) {
#line 170
    return ((ngx_int_t )-5);
  }
#line 173
  if (! (r->method & 6UL)) {
#line 174
    return ((ngx_int_t )-5);
  }
#line 177
  alcf = (ngx_http_autoindex_loc_conf_t *)*(r->loc_conf + ngx_http_autoindex_module.ctx_index);
#line 179
  if (! alcf->enable) {
#line 180
    return ((ngx_int_t )-5);
  }
  {
#line 185
  last = ngx_http_map_uri_to_path(r, & path, & root, (size_t___0 )50);
  }
#line 187
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 188
    return ((ngx_int_t )500);
  }
#line 191
  allocated = path.len;
#line 192
  path.len = (size_t___0 )(last - path.data);
#line 193
  if (path.len > 1UL) {
#line 194
    (path.len) --;
  }
#line 196
  *(path.data + path.len) = (u_char )'\000';
#line 201
  format = alcf->format;
#line 203
  if (format == 2UL) {
    {
#line 204
    tmp = ngx_http_autoindex_jsonp_callback(r, & callback);
    }
#line 204
    if (tmp != 0L) {
#line 205
      return ((ngx_int_t )400);
    }
#line 208
    if (callback.len == 0UL) {
#line 209
      format = (ngx_uint_t )1;
    }
  }
  {
#line 213
  tmp___1 = ngx_open_dir(& path, & dir);
  }
#line 213
  if (tmp___1 == -1L) {
    {
#line 214
    tmp___0 = __errno_location();
#line 214
    err = *tmp___0;
    }
#line 216
    if (err == 2) {
#line 220
      level = (ngx_uint_t )4;
#line 221
      rc = (ngx_int_t )404;
    } else
#line 216
    if (err == 20) {
#line 220
      level = (ngx_uint_t )4;
#line 221
      rc = (ngx_int_t )404;
    } else
#line 216
    if (err == 36) {
#line 220
      level = (ngx_uint_t )4;
#line 221
      rc = (ngx_int_t )404;
    } else
#line 223
    if (err == 13) {
#line 224
      level = (ngx_uint_t )4;
#line 225
      rc = (ngx_int_t )403;
    } else {
#line 228
      level = (ngx_uint_t )3;
#line 229
      rc = (ngx_int_t )500;
    }
#line 232
    if (((r->connection)->log)->log_level >= level) {
      {
#line 232
      ngx_log_error_core(level, (r->connection)->log, err, "opendir() \"%s\" failed",
                         path.data);
      }
    }
#line 235
    return (rc);
  }
  {
#line 241
  memset((void *)(& entries), 0, sizeof(ngx_array_t ));
#line 246
  pool = r->pool;
#line 248
  tmp___3 = ngx_array_init(& entries, pool, (ngx_uint_t )40, sizeof(ngx_http_autoindex_entry_t ));
  }
#line 248
  if (tmp___3 != 0L) {
    {
#line 251
    tmp___2 = ngx_http_autoindex_error(r, & dir, & path);
    }
#line 251
    return (tmp___2);
  }
#line 254
  r->headers_out.status = (ngx_uint_t )200;
  {
#line 258
  if (format == 1UL) {
#line 258
    goto case_1;
  }
#line 262
  if (format == 2UL) {
#line 262
    goto case_2;
  }
#line 266
  if (format == 3UL) {
#line 266
    goto case_3;
  }
#line 271
  goto switch_default;
  case_1: /* CIL Label */ 
#line 259
  r->headers_out.content_type.len = sizeof("application/json") - 1UL;
#line 259
  r->headers_out.content_type.data = (u_char *)"application/json";
#line 260
  goto switch_break;
  case_2: /* CIL Label */ 
#line 263
  r->headers_out.content_type.len = sizeof("application/javascript") - 1UL;
#line 263
  r->headers_out.content_type.data = (u_char *)"application/javascript";
#line 264
  goto switch_break;
  case_3: /* CIL Label */ 
#line 267
  r->headers_out.content_type.len = sizeof("text/xml") - 1UL;
#line 267
  r->headers_out.content_type.data = (u_char *)"text/xml";
#line 268
  r->headers_out.charset.len = sizeof("utf-8") - 1UL;
#line 268
  r->headers_out.charset.data = (u_char *)"utf-8";
#line 269
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 272
  r->headers_out.content_type.len = sizeof("text/html") - 1UL;
#line 272
  r->headers_out.content_type.data = (u_char *)"text/html";
#line 273
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 276
  r->headers_out.content_type_len = r->headers_out.content_type.len;
#line 277
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 279
  rc = ngx_http_send_header(r);
  }
#line 281
  if (rc == -1L) {
#line 281
    goto _L;
  } else
#line 281
  if (rc > 0L) {
#line 281
    goto _L;
  } else
#line 281
  if (r->header_only) {
    _L: /* CIL Label */ 
    {
#line 282
    tmp___5 = closedir(dir.dir);
    }
#line 282
    if (tmp___5 == -1) {
#line 283
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 283
        tmp___4 = __errno_location();
#line 283
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp___4, "closedir() \"%V\" failed",
                           & path);
        }
      }
    }
#line 287
    return (rc);
  }
#line 290
  filename = path.data;
#line 291
  *(filename + path.len) = (u_char )'/';
  {
#line 293
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    tmp___6 = __errno_location();
#line 294
    *tmp___6 = 0;
#line 296
    tmp___9 = ngx_read_dir(& dir);
    }
#line 296
    if (tmp___9 == -1L) {
      {
#line 297
      tmp___7 = __errno_location();
#line 297
      err = *tmp___7;
      }
#line 299
      if (err != 0) {
#line 300
        if (((r->connection)->log)->log_level >= 3UL) {
          {
#line 300
          ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, err, "readdir() \"%V\" failed",
                             & path);
          }
        }
        {
#line 302
        tmp___8 = ngx_http_autoindex_error(r, & dir, & path);
        }
#line 302
        return (tmp___8);
      }
#line 305
      goto while_break;
    }
    {
#line 311
    len = strlen((char const   *)((dir.de)->d_name));
    }
#line 313
    if ((int )*((u_char *)((dir.de)->d_name) + 0) == 46) {
#line 314
      goto __Cont;
    }
#line 317
    if (! dir.valid_info) {
#line 321
      if (((path.len + 1UL) + len) + 1UL > allocated) {
        {
#line 322
        allocated = (((path.len + 1UL) + len) + 1UL) + 50UL;
#line 325
        tmp___10 = ngx_pnalloc(pool, allocated);
#line 325
        filename = (u_char *)tmp___10;
        }
#line 326
        if ((unsigned long )filename == (unsigned long )((void *)0)) {
          {
#line 327
          tmp___11 = ngx_http_autoindex_error(r, & dir, & path);
          }
#line 327
          return (tmp___11);
        }
        {
#line 330
        last = ngx_cpystrn(filename, path.data, path.len + 1UL);
#line 331
        tmp___12 = last;
#line 331
        last ++;
#line 331
        *tmp___12 = (u_char )'/';
        }
      }
      {
#line 334
      ngx_cpystrn(last, (u_char *)((dir.de)->d_name), len + 1UL);
#line 336
      tmp___18 = ngx_de_info(filename, & dir);
      }
#line 336
      if (tmp___18 == -1L) {
        {
#line 337
        tmp___13 = __errno_location();
#line 337
        err = *tmp___13;
        }
#line 339
        if (err != 2) {
#line 339
          if (err != 40) {
#line 340
            if (((r->connection)->log)->log_level >= 3UL) {
              {
#line 340
              ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, err, "stat() \"%s\" failed",
                                 filename);
              }
            }
#line 343
            if (err == 13) {
#line 344
              goto __Cont;
            }
            {
#line 347
            tmp___14 = ngx_http_autoindex_error(r, & dir, & path);
            }
#line 347
            return (tmp___14);
          }
        }
        {
#line 350
        tmp___17 = lstat((char const   */* __restrict  */)((char const   *)filename),
                         (struct stat */* __restrict  */)(& dir.info));
        }
#line 350
        if (tmp___17 == -1) {
#line 351
          if (((r->connection)->log)->log_level >= 3UL) {
            {
#line 351
            tmp___15 = __errno_location();
#line 351
            ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___15, "lstat() \"%s\" failed",
                               filename);
            }
          }
          {
#line 354
          tmp___16 = ngx_http_autoindex_error(r, & dir, & path);
          }
#line 354
          return (tmp___16);
        }
      }
    }
    {
#line 359
    tmp___19 = ngx_array_push(& entries);
#line 359
    entry = (ngx_http_autoindex_entry_t *)tmp___19;
    }
#line 360
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
      {
#line 361
      tmp___20 = ngx_http_autoindex_error(r, & dir, & path);
      }
#line 361
      return (tmp___20);
    }
    {
#line 364
    entry->name.len = len;
#line 366
    tmp___21 = ngx_pnalloc(pool, len + 1UL);
#line 366
    entry->name.data = (u_char *)tmp___21;
    }
#line 367
    if ((unsigned long )entry->name.data == (unsigned long )((void *)0)) {
      {
#line 368
      tmp___22 = ngx_http_autoindex_error(r, & dir, & path);
      }
#line 368
      return (tmp___22);
    }
    {
#line 371
    ngx_cpystrn(entry->name.data, (u_char *)((dir.de)->d_name), len + 1UL);
    }
#line 373
    if (dir.type) {
#line 373
      entry->dir = (unsigned int )(dir.type == 4U);
    } else {
#line 373
      entry->dir = (unsigned int )((dir.info.st_mode & 61440U) == 16384U);
    }
#line 374
    if (dir.type) {
#line 374
      entry->file = (unsigned int )(dir.type == 8U);
    } else {
#line 374
      entry->file = (unsigned int )((dir.info.st_mode & 61440U) == 32768U);
    }
#line 375
    entry->mtime = dir.info.st_mtim.tv_sec;
#line 376
    entry->size = dir.info.st_size;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  tmp___24 = closedir(dir.dir);
  }
#line 379
  if (tmp___24 == -1) {
#line 380
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 380
      tmp___23 = __errno_location();
#line 380
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp___23, "closedir() \"%V\" failed",
                         & path);
      }
    }
  }
#line 384
  if (entries.nelts > 1UL) {
    {
#line 385
    qsort(entries.elts, entries.nelts, sizeof(ngx_http_autoindex_entry_t ), & ngx_http_autoindex_cmp_entries);
    }
  }
  {
#line 392
  if (format == 1UL) {
#line 392
    goto case_1___0;
  }
#line 396
  if (format == 2UL) {
#line 396
    goto case_2___0;
  }
#line 400
  if (format == 3UL) {
#line 400
    goto case_3___0;
  }
#line 404
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 393
  b = ngx_http_autoindex_json(r, & entries, (ngx_str_t *)((void *)0));
  }
#line 394
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 397
  b = ngx_http_autoindex_json(r, & entries, & callback);
  }
#line 398
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 401
  b = ngx_http_autoindex_xml(r, & entries);
  }
#line 402
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 405
  b = ngx_http_autoindex_html(r, & entries);
  }
#line 406
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 409
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 410
    return ((ngx_int_t )-1);
  }
#line 415
  if ((unsigned long )r == (unsigned long )r->main) {
#line 416
    b->last_buf = 1U;
  }
  {
#line 419
  b->last_in_chain = 1U;
#line 421
  out.buf = b;
#line 422
  out.next = (ngx_chain_t *)((void *)0);
#line 424
  tmp___25 = ngx_http_output_filter(r, & out);
  }
#line 424
  return (tmp___25);
}
}
#line 442 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static u_char title[31]  = 
#line 442
  {      (u_char )'<',      (u_char )'h',      (u_char )'t',      (u_char )'m', 
        (u_char )'l',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'h',      (u_char )'e',      (u_char )'a', 
        (u_char )'d',      (u_char )'>',      (u_char )'<',      (u_char )'t', 
        (u_char )'i',      (u_char )'t',      (u_char )'l',      (u_char )'e', 
        (u_char )'>',      (u_char )'I',      (u_char )'n',      (u_char )'d', 
        (u_char )'e',      (u_char )'x',      (u_char )' ',      (u_char )'o', 
        (u_char )'f',      (u_char )' ',      (u_char )'\000'};
#line 447 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static u_char header[55]  = 
#line 447
  {      (u_char )'<',      (u_char )'/',      (u_char )'t',      (u_char )'i', 
        (u_char )'t',      (u_char )'l',      (u_char )'e',      (u_char )'>', 
        (u_char )'<',      (u_char )'/',      (u_char )'h',      (u_char )'e', 
        (u_char )'a',      (u_char )'d',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )' ',      (u_char )'b', 
        (u_char )'g',      (u_char )'c',      (u_char )'o',      (u_char )'l', 
        (u_char )'o',      (u_char )'r',      (u_char )'=',      (u_char )'\"', 
        (u_char )'w',      (u_char )'h',      (u_char )'i',      (u_char )'t', 
        (u_char )'e',      (u_char )'\"',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'h',      (u_char )'1', 
        (u_char )'>',      (u_char )'I',      (u_char )'n',      (u_char )'d', 
        (u_char )'e',      (u_char )'x',      (u_char )' ',      (u_char )'o', 
        (u_char )'f',      (u_char )' ',      (u_char )'\000'};
#line 453 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static u_char tail[19]  = 
#line 453
  {      (u_char )'<',      (u_char )'/',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'/',      (u_char )'h', 
        (u_char )'t',      (u_char )'m',      (u_char )'l',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 458 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static char *months[12]  = 
#line 458
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 428 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_html(ngx_http_request_t *r , ngx_array_t *entries ) 
{ 
  u_char *last ;
  u_char scale ;
  off_t length ;
  size_t___0 len ;
  size_t___0 char_len ;
  size_t___0 escape_html ;
  ngx_tm_t tm ;
  ngx_buf_t *b ;
  ngx_int_t size ;
  ngx_uint_t i ;
  ngx_uint_t utf8 ;
  ngx_time_t *tp ;
  ngx_http_autoindex_entry_t *entry ;
  ngx_http_autoindex_loc_conf_t *alcf ;
  ngx_int_t tmp ;
  uintptr_t tmp___0 ;
  void *tmp___1 ;
  uintptr_t tmp___2 ;
  void *tmp___3 ;
  uintptr_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  uintptr_t tmp___15 ;
  uintptr_t tmp___16 ;
  void *tmp___17 ;
  u_char *tmp___18 ;
  void *tmp___19 ;
  u_char *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  u_char *tmp___23 ;
  u_char *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;

  {
#line 461
  if (r->headers_out.charset.len == 5UL) {
    {
#line 461
    tmp = ngx_strncasecmp(r->headers_out.charset.data, (u_char *)"utf-8", (size_t___0 )5);
    }
#line 461
    if (tmp == 0L) {
#line 465
      utf8 = (ngx_uint_t )1;
    } else {
#line 468
      utf8 = (ngx_uint_t )0;
    }
  } else {
#line 468
    utf8 = (ngx_uint_t )0;
  }
  {
#line 471
  escape_html = ngx_escape_html((u_char *)((void *)0), r->uri.data, r->uri.len);
#line 473
  len = ((((((((((((((sizeof(title) - 1UL) + r->uri.len) + escape_html) + sizeof(header)) - 1UL) + r->uri.len) + escape_html) + sizeof("</h1>")) - 1UL) + sizeof("<hr><pre><a href=\"../\">../</a>\r\n")) - 1UL) + sizeof("</pre><hr>")) - 1UL) + sizeof(tail)) - 1UL;
#line 482
  entry = (ngx_http_autoindex_entry_t *)entries->elts;
#line 483
  i = (ngx_uint_t )0;
  }
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (! (i < entries->nelts)) {
#line 483
      goto while_break;
    }
    {
#line 484
    tmp___0 = ngx_escape_uri((u_char *)((void *)0), (entry + i)->name.data, (entry + i)->name.len,
                             (ngx_uint_t )2);
#line 484
    (entry + i)->escape = 2UL * tmp___0;
#line 488
    (entry + i)->escape_html = ngx_escape_html((u_char *)((void *)0), (entry + i)->name.data,
                                               (entry + i)->name.len);
    }
#line 491
    if (utf8) {
      {
#line 492
      (entry + i)->utf_len = ngx_utf8_length((entry + i)->name.data, (entry + i)->name.len);
      }
    } else {
#line 495
      (entry + i)->utf_len = (entry + i)->name.len;
    }
#line 498
    len += (((((((((((((((((sizeof("<a href=\"") - 1UL) + (entry + i)->name.len) + (entry + i)->escape) + 1UL) + sizeof("\">")) - 1UL) + (entry + i)->name.len) - (entry + i)->utf_len) + (entry + i)->escape_html) + 50UL) + sizeof("&gt;")) - 2UL) + sizeof("</a>")) - 1UL) + sizeof(" 28-Sep-1970 12:00 ")) - 1UL) + 20UL) + 2UL;
#line 483
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 512
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 513
    return ((ngx_buf_t *)((void *)0));
  }
  {
#line 516
  tmp___1 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(title),
                   sizeof(title) - 1UL);
#line 516
  b->last = (u_char *)tmp___1 + (sizeof(title) - 1UL);
  }
#line 518
  if (escape_html) {
    {
#line 519
    tmp___2 = ngx_escape_html(b->last, r->uri.data, r->uri.len);
#line 519
    b->last = (u_char *)tmp___2;
#line 520
    tmp___3 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header),
                     sizeof(header) - 1UL);
#line 520
    b->last = (u_char *)tmp___3 + (sizeof(header) - 1UL);
#line 521
    tmp___4 = ngx_escape_html(b->last, r->uri.data, r->uri.len);
#line 521
    b->last = (u_char *)tmp___4;
    }
  } else {
    {
#line 524
    tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->uri.data,
                     r->uri.len);
#line 524
    b->last = (u_char *)tmp___5 + r->uri.len;
#line 525
    tmp___6 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header),
                     sizeof(header) - 1UL);
#line 525
    b->last = (u_char *)tmp___6 + (sizeof(header) - 1UL);
#line 526
    tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->uri.data,
                     r->uri.len);
#line 526
    b->last = (u_char *)tmp___7 + r->uri.len;
    }
  }
  {
#line 529
  tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"</h1>",
                   sizeof("</h1>") - 1UL);
#line 529
  b->last = (u_char *)tmp___8 + (sizeof("</h1>") - 1UL);
#line 531
  tmp___9 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"<hr><pre><a href=\"../\">../</a>\r\n",
                   sizeof("<hr><pre><a href=\"../\">../</a>\r\n") - 1UL);
#line 531
  b->last = (u_char *)tmp___9 + (sizeof("<hr><pre><a href=\"../\">../</a>\r\n") - 1UL);
#line 534
  alcf = (ngx_http_autoindex_loc_conf_t *)*(r->loc_conf + ngx_http_autoindex_module.ctx_index);
#line 535
  tp = (ngx_time_t *)ngx_cached_time;
#line 537
  i = (ngx_uint_t )0;
  }
  {
#line 537
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 537
    if (! (i < entries->nelts)) {
#line 537
      goto while_break___0;
    }
    {
#line 538
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"<a href=\"",
                      sizeof("<a href=\"") - 1UL);
#line 538
    b->last = (u_char *)tmp___10 + (sizeof("<a href=\"") - 1UL);
    }
#line 540
    if ((entry + i)->escape) {
      {
#line 541
      ngx_escape_uri(b->last, (entry + i)->name.data, (entry + i)->name.len, (ngx_uint_t )2);
#line 544
      b->last += (entry + i)->name.len + (entry + i)->escape;
      }
    } else {
      {
#line 547
      tmp___11 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(entry + i)->name.data,
                        (entry + i)->name.len);
#line 547
      b->last = (u_char *)tmp___11 + (entry + i)->name.len;
      }
    }
#line 551
    if ((entry + i)->dir) {
#line 552
      tmp___12 = b->last;
#line 552
      (b->last) ++;
#line 552
      *tmp___12 = (u_char )'/';
    }
#line 555
    tmp___13 = b->last;
#line 555
    (b->last) ++;
#line 555
    *tmp___13 = (u_char )'\"';
#line 556
    tmp___14 = b->last;
#line 556
    (b->last) ++;
#line 556
    *tmp___14 = (u_char )'>';
#line 558
    len = (entry + i)->utf_len;
#line 560
    if ((entry + i)->name.len != len) {
#line 561
      if (len > 50UL) {
#line 562
        char_len = (size_t___0 )48;
      } else {
#line 565
        char_len = (size_t___0 )51;
      }
      {
#line 568
      last = b->last;
#line 569
      b->last = ngx_utf8_cpystrn(b->last, (entry + i)->name.data, char_len, (entry + i)->name.len + 1UL);
      }
#line 572
      if ((entry + i)->escape_html) {
        {
#line 573
        tmp___15 = ngx_escape_html(last, (entry + i)->name.data, (size_t___0 )(b->last - last));
#line 573
        b->last = (u_char *)tmp___15;
        }
      }
#line 577
      last = b->last;
    } else
#line 580
    if ((entry + i)->escape_html) {
#line 581
      if (len > 50UL) {
#line 582
        char_len = (size_t___0 )47;
      } else {
#line 585
        char_len = len;
      }
      {
#line 588
      tmp___16 = ngx_escape_html(b->last, (entry + i)->name.data, char_len);
#line 588
      b->last = (u_char *)tmp___16;
#line 590
      last = b->last;
      }
    } else {
      {
#line 593
      b->last = ngx_cpystrn(b->last, (entry + i)->name.data, (size_t___0 )51);
#line 595
      last = b->last - 3;
      }
    }
#line 599
    if (len > 50UL) {
      {
#line 600
      tmp___17 = memcpy((void */* __restrict  */)last, (void const   */* __restrict  */)"..&gt;</a>",
                        sizeof("..&gt;</a>") - 1UL);
#line 600
      b->last = (u_char *)tmp___17 + (sizeof("..&gt;</a>") - 1UL);
      }
    } else {
#line 603
      if ((entry + i)->dir) {
#line 603
        if (50UL - len > 0UL) {
#line 604
          tmp___18 = b->last;
#line 604
          (b->last) ++;
#line 604
          *tmp___18 = (u_char )'/';
#line 605
          len ++;
        }
      }
      {
#line 608
      tmp___19 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"</a>",
                        sizeof("</a>") - 1UL);
#line 608
      b->last = (u_char *)tmp___19 + (sizeof("</a>") - 1UL);
      }
#line 610
      if (50UL - len > 0UL) {
        {
#line 611
        memset((void *)b->last, ' ', 50UL - len);
#line 612
        b->last += 50UL - len;
        }
      }
    }
    {
#line 616
    tmp___20 = b->last;
#line 616
    (b->last) ++;
#line 616
    *tmp___20 = (u_char )' ';
#line 618
    ngx_gmtime((entry + i)->mtime + (tp->gmtoff * 60L) * alcf->localtime, & tm);
#line 620
    b->last = ngx_sprintf(b->last, "%02d-%s-%d %02d:%02d ", tm.tm_mday, months[tm.tm_mon - 1],
                          tm.tm_year, tm.tm_hour, tm.tm_min);
    }
#line 627
    if (alcf->exact_size) {
#line 628
      if ((entry + i)->dir) {
        {
#line 629
        tmp___21 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"                  -",
                          sizeof("                  -") - 1UL);
#line 629
        b->last = (u_char *)tmp___21 + (sizeof("                  -") - 1UL);
        }
      } else {
        {
#line 632
        b->last = ngx_sprintf(b->last, "%19O", (entry + i)->size);
        }
      }
    } else
#line 636
    if ((entry + i)->dir) {
      {
#line 637
      tmp___22 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"      -",
                        sizeof("      -") - 1UL);
#line 637
      b->last = (u_char *)tmp___22 + (sizeof("      -") - 1UL);
      }
    } else {
#line 641
      length = (entry + i)->size;
#line 643
      if (length > 1073741823L) {
#line 644
        size = length / 1073741824L;
#line 645
        if (length % 1073741824L > 536870911L) {
#line 648
          size ++;
        }
#line 650
        scale = (u_char )'G';
      } else
#line 652
      if (length > 1048575L) {
#line 653
        size = length / 1048576L;
#line 654
        if (length % 1048576L > 524287L) {
#line 655
          size ++;
        }
#line 657
        scale = (u_char )'M';
      } else
#line 659
      if (length > 9999L) {
#line 660
        size = length / 1024L;
#line 661
        if (length % 1024L > 511L) {
#line 662
          size ++;
        }
#line 664
        scale = (u_char )'K';
      } else {
#line 667
        size = length;
#line 668
        scale = (u_char )'\000';
      }
#line 671
      if (scale) {
        {
#line 672
        b->last = ngx_sprintf(b->last, "%6i%c", size, (int )scale);
        }
      } else {
        {
#line 675
        b->last = ngx_sprintf(b->last, " %6i", size);
        }
      }
    }
#line 680
    tmp___23 = b->last;
#line 680
    (b->last) ++;
#line 680
    *tmp___23 = (u_char )'\r';
#line 681
    tmp___24 = b->last;
#line 681
    (b->last) ++;
#line 681
    *tmp___24 = (u_char )'\n';
#line 537
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 684
  tmp___25 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"</pre><hr>",
                    sizeof("</pre><hr>") - 1UL);
#line 684
  b->last = (u_char *)tmp___25 + (sizeof("</pre><hr>") - 1UL);
#line 686
  tmp___26 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(tail),
                    sizeof(tail) - 1UL);
#line 686
  b->last = (u_char *)tmp___26 + (sizeof(tail) - 1UL);
  }
#line 688
  return (b);
}
}
#line 692 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_json(ngx_http_request_t *r , ngx_array_t *entries ,
                                          ngx_str_t *callback ) 
{ 
  size_t___0 len ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_http_autoindex_entry_t *entry ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  uintptr_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  u_char *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;

  {
#line 701
  len = sizeof("[\r\n\r\n]") - 1UL;
#line 703
  if (callback) {
#line 704
    len += (sizeof("/* callback */\r\n();") - 1UL) + callback->len;
  }
#line 707
  entry = (ngx_http_autoindex_entry_t *)entries->elts;
#line 709
  i = (ngx_uint_t )0;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! (i < entries->nelts)) {
#line 709
      goto while_break;
    }
    {
#line 710
    (entry + i)->escape = ngx_escape_json((u_char *)((void *)0), (entry + i)->name.data,
                                          (entry + i)->name.len);
#line 713
    len += ((((((((sizeof("{  },\r\n") - 1UL) + sizeof("\"name\":\"\"")) - 1UL) + (entry + i)->name.len) + (entry + i)->escape) + sizeof(", \"type\":\"directory\"")) - 1UL) + sizeof(", \"mtime\":\"Wed, 31 Dec 1986 10:00:00 GMT\"")) - 1UL;
    }
#line 719
    if ((entry + i)->file) {
#line 720
      len += (sizeof(", \"size\":") - 1UL) + (sizeof("-9223372036854775808") - 1UL);
    }
#line 709
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 724
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 725
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 726
    return ((ngx_buf_t *)((void *)0));
  }
#line 729
  if (callback) {
    {
#line 730
    tmp = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"/* callback */\r\n",
                 sizeof("/* callback */\r\n") - 1UL);
#line 730
    b->last = (u_char *)tmp + (sizeof("/* callback */\r\n") - 1UL);
#line 733
    tmp___0 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)callback->data,
                     callback->len);
#line 733
    b->last = (u_char *)tmp___0 + callback->len;
#line 735
    tmp___1 = b->last;
#line 735
    (b->last) ++;
#line 735
    *tmp___1 = (u_char )'(';
    }
  }
#line 738
  tmp___2 = b->last;
#line 738
  (b->last) ++;
#line 738
  *tmp___2 = (u_char )'[';
#line 740
  i = (ngx_uint_t )0;
  {
#line 740
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 740
    if (! (i < entries->nelts)) {
#line 740
      goto while_break___0;
    }
    {
#line 741
    tmp___3 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\r\n{ \"name\":\"",
                     sizeof("\r\n{ \"name\":\"") - 1UL);
#line 741
    b->last = (u_char *)tmp___3 + (sizeof("\r\n{ \"name\":\"") - 1UL);
    }
#line 744
    if ((entry + i)->escape) {
      {
#line 745
      tmp___4 = ngx_escape_json(b->last, (entry + i)->name.data, (entry + i)->name.len);
#line 745
      b->last = (u_char *)tmp___4;
      }
    } else {
      {
#line 748
      tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(entry + i)->name.data,
                       (entry + i)->name.len);
#line 748
      b->last = (u_char *)tmp___5 + (entry + i)->name.len;
      }
    }
    {
#line 752
    tmp___6 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\", \"type\":\"",
                     sizeof("\", \"type\":\"") - 1UL);
#line 752
    b->last = (u_char *)tmp___6 + (sizeof("\", \"type\":\"") - 1UL);
    }
#line 755
    if ((entry + i)->dir) {
      {
#line 756
      tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"directory",
                       sizeof("directory") - 1UL);
#line 756
      b->last = (u_char *)tmp___7 + (sizeof("directory") - 1UL);
      }
    } else
#line 758
    if ((entry + i)->file) {
      {
#line 759
      tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"file",
                       sizeof("file") - 1UL);
#line 759
      b->last = (u_char *)tmp___8 + (sizeof("file") - 1UL);
      }
    } else {
      {
#line 762
      tmp___9 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"other",
                       sizeof("other") - 1UL);
#line 762
      b->last = (u_char *)tmp___9 + (sizeof("other") - 1UL);
      }
    }
    {
#line 765
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\", \"mtime\":\"",
                      sizeof("\", \"mtime\":\"") - 1UL);
#line 765
    b->last = (u_char *)tmp___10 + (sizeof("\", \"mtime\":\"") - 1UL);
#line 768
    b->last = ngx_http_time(b->last, (entry + i)->mtime);
    }
#line 770
    if ((entry + i)->file) {
      {
#line 771
      tmp___11 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\", \"size\":",
                        sizeof("\", \"size\":") - 1UL);
#line 771
      b->last = (u_char *)tmp___11 + (sizeof("\", \"size\":") - 1UL);
#line 773
      b->last = ngx_sprintf(b->last, "%O", (entry + i)->size);
      }
    } else {
#line 776
      tmp___12 = b->last;
#line 776
      (b->last) ++;
#line 776
      *tmp___12 = (u_char )'\"';
    }
    {
#line 779
    tmp___13 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)" },",
                      sizeof(" },") - 1UL);
#line 779
    b->last = (u_char *)tmp___13 + (sizeof(" },") - 1UL);
#line 740
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 782
  if (i > 0UL) {
#line 783
    (b->last) --;
  }
  {
#line 786
  tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\r\n]",
                    sizeof("\r\n]") - 1UL);
#line 786
  b->last = (u_char *)tmp___14 + (sizeof("\r\n]") - 1UL);
  }
#line 788
  if (callback) {
#line 789
    tmp___15 = b->last;
#line 789
    (b->last) ++;
#line 789
    *tmp___15 = (u_char )')';
#line 789
    tmp___16 = b->last;
#line 789
    (b->last) ++;
#line 789
    *tmp___16 = (u_char )';';
  }
#line 792
  return (b);
}
}
#line 796 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_jsonp_callback(ngx_http_request_t *r , ngx_str_t *callback ) 
{ 
  u_char *p ;
  u_char c ;
  u_char ch ;
  ngx_uint_t i ;
  ngx_int_t tmp ;

  {
  {
#line 802
  tmp = ngx_http_arg(r, (u_char *)"callback", (size_t___0 )8, callback);
  }
#line 802
  if (tmp != 0L) {
#line 803
    callback->len = (size_t___0 )0;
#line 804
    return ((ngx_int_t )0);
  }
#line 807
  if (callback->len > 128UL) {
#line 808
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 808
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent too long callback name: \"%V\"",
                         callback);
      }
    }
#line 810
    return ((ngx_int_t )-5);
  }
#line 813
  p = callback->data;
#line 815
  i = (ngx_uint_t )0;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! (i < callback->len)) {
#line 815
      goto while_break;
    }
#line 816
    ch = *(p + i);
#line 818
    c = (u_char )((int )ch | 32);
#line 819
    if ((int )c >= 97) {
#line 819
      if ((int )c <= 122) {
#line 820
        goto __Cont;
      }
    }
#line 823
    if ((int )ch >= 48) {
#line 823
      if ((int )ch <= 57) {
#line 824
        goto __Cont;
      } else {
#line 823
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 823
    if ((int )ch == 95) {
#line 824
      goto __Cont;
    } else
#line 823
    if ((int )ch == 46) {
#line 824
      goto __Cont;
    }
#line 827
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 827
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid callback name: \"%V\"",
                         callback);
      }
    }
#line 830
    return ((ngx_int_t )-5);
    __Cont: /* CIL Label */ 
#line 815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 833
  return ((ngx_int_t )0);
}
}
#line 847 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static u_char head[32]  = 
#line 847
  {      (u_char )'<',      (u_char )'?',      (u_char )'x',      (u_char )'m', 
        (u_char )'l',      (u_char )' ',      (u_char )'v',      (u_char )'e', 
        (u_char )'r',      (u_char )'s',      (u_char )'i',      (u_char )'o', 
        (u_char )'n',      (u_char )'=',      (u_char )'\"',      (u_char )'1', 
        (u_char )'.',      (u_char )'0',      (u_char )'\"',      (u_char )'?', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'l',      (u_char )'i',      (u_char )'s',      (u_char )'t', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 848 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static u_char tail___0[10]  = 
#line 848
  {      (u_char )'<',      (u_char )'/',      (u_char )'l',      (u_char )'i', 
        (u_char )'s',      (u_char )'t',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'\000'};
#line 837 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_xml(ngx_http_request_t *r , ngx_array_t *entries ) 
{ 
  size_t___0 len ;
  ngx_tm_t tm ;
  ngx_buf_t *b ;
  ngx_str_t type ;
  ngx_uint_t i ;
  ngx_http_autoindex_entry_t *entry ;
  void *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  uintptr_t tmp___6 ;
  void *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  void *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  void *tmp___14 ;

  {
#line 850
  len = ((sizeof(head) - 1UL) + sizeof(tail___0)) - 1UL;
#line 852
  entry = (ngx_http_autoindex_entry_t *)entries->elts;
#line 854
  i = (ngx_uint_t )0;
  {
#line 854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 854
    if (! (i < entries->nelts)) {
#line 854
      goto while_break;
    }
    {
#line 855
    (entry + i)->escape = ngx_escape_html((u_char *)((void *)0), (entry + i)->name.data,
                                          (entry + i)->name.len);
#line 858
    len += ((((sizeof("<directory></directory>\r\n") - 1UL) + (entry + i)->name.len) + (entry + i)->escape) + sizeof(" mtime=\"1986-12-31T10:00:00Z\"")) - 1UL;
    }
#line 862
    if ((entry + i)->file) {
#line 863
      len += (sizeof(" size=\"\"") - 1UL) + (sizeof("-9223372036854775808") - 1UL);
    }
#line 854
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 867
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 868
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 869
    return ((ngx_buf_t *)((void *)0));
  }
  {
#line 872
  tmp = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(head),
               sizeof(head) - 1UL);
#line 872
  b->last = (u_char *)tmp + (sizeof(head) - 1UL);
#line 874
  i = (ngx_uint_t )0;
  }
  {
#line 874
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 874
    if (! (i < entries->nelts)) {
#line 874
      goto while_break___0;
    }
#line 875
    tmp___0 = b->last;
#line 875
    (b->last) ++;
#line 875
    *tmp___0 = (u_char )'<';
#line 877
    if ((entry + i)->dir) {
#line 878
      type.len = sizeof("directory") - 1UL;
#line 878
      type.data = (u_char *)"directory";
    } else
#line 880
    if ((entry + i)->file) {
#line 881
      type.len = sizeof("file") - 1UL;
#line 881
      type.data = (u_char *)"file";
    } else {
#line 884
      type.len = sizeof("other") - 1UL;
#line 884
      type.data = (u_char *)"other";
    }
    {
#line 887
    tmp___1 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)type.data,
                     type.len);
#line 887
    b->last = (u_char *)tmp___1 + type.len;
#line 889
    tmp___2 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)" mtime=\"",
                     sizeof(" mtime=\"") - 1UL);
#line 889
    b->last = (u_char *)tmp___2 + (sizeof(" mtime=\"") - 1UL);
#line 891
    ngx_gmtime((entry + i)->mtime, & tm);
#line 893
    b->last = ngx_sprintf(b->last, "%4d-%02d-%02dT%02d:%02d:%02dZ", tm.tm_year, tm.tm_mon,
                          tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
    }
#line 898
    if ((entry + i)->file) {
      {
#line 899
      tmp___3 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\" size=\"",
                       sizeof("\" size=\"") - 1UL);
#line 899
      b->last = (u_char *)tmp___3 + (sizeof("\" size=\"") - 1UL);
#line 901
      b->last = ngx_sprintf(b->last, "%O", (entry + i)->size);
      }
    }
#line 904
    tmp___4 = b->last;
#line 904
    (b->last) ++;
#line 904
    *tmp___4 = (u_char )'\"';
#line 904
    tmp___5 = b->last;
#line 904
    (b->last) ++;
#line 904
    *tmp___5 = (u_char )'>';
#line 906
    if ((entry + i)->escape) {
      {
#line 907
      tmp___6 = ngx_escape_html(b->last, (entry + i)->name.data, (entry + i)->name.len);
#line 907
      b->last = (u_char *)tmp___6;
      }
    } else {
      {
#line 910
      tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(entry + i)->name.data,
                       (entry + i)->name.len);
#line 910
      b->last = (u_char *)tmp___7 + (entry + i)->name.len;
      }
    }
    {
#line 914
    tmp___8 = b->last;
#line 914
    (b->last) ++;
#line 914
    *tmp___8 = (u_char )'<';
#line 914
    tmp___9 = b->last;
#line 914
    (b->last) ++;
#line 914
    *tmp___9 = (u_char )'/';
#line 916
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)type.data,
                      type.len);
#line 916
    b->last = (u_char *)tmp___10 + type.len;
#line 918
    tmp___11 = b->last;
#line 918
    (b->last) ++;
#line 918
    *tmp___11 = (u_char )'>';
#line 920
    tmp___12 = b->last;
#line 920
    (b->last) ++;
#line 920
    *tmp___12 = (u_char )'\r';
#line 920
    tmp___13 = b->last;
#line 920
    (b->last) ++;
#line 920
    *tmp___13 = (u_char )'\n';
#line 874
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 923
  tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(tail___0),
                    sizeof(tail___0) - 1UL);
#line 923
  b->last = (u_char *)tmp___14 + (sizeof(tail___0) - 1UL);
  }
#line 925
  return (b);
}
}
#line 929 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static int ngx_http_autoindex_cmp_entries(void const   *one , void const   *two ) 
{ 
  ngx_http_autoindex_entry_t *first ;
  ngx_http_autoindex_entry_t *second ;
  int tmp ;

  {
#line 932
  first = (ngx_http_autoindex_entry_t *)one;
#line 933
  second = (ngx_http_autoindex_entry_t *)two;
#line 935
  if (first->dir) {
#line 935
    if (! second->dir) {
#line 937
      return (-1);
    }
  }
#line 940
  if (! first->dir) {
#line 940
    if (second->dir) {
#line 942
      return (1);
    }
  }
  {
#line 945
  tmp = strcmp((char const   *)first->name.data, (char const   *)second->name.data);
  }
#line 945
  return (tmp);
}
}
#line 987 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_error(ngx_http_request_t *r , ngx_dir_t *dir ,
                                          ngx_str_t *name ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 990
  tmp___0 = closedir(dir->dir);
  }
#line 990
  if (tmp___0 == -1) {
#line 991
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 991
      tmp = __errno_location();
#line 991
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp, "closedir() \"%V\" failed",
                         name);
      }
    }
  }
#line 995
  if (r->header_sent) {
#line 995
    tmp___1 = -1;
  } else {
#line 995
    tmp___1 = 500;
  }
#line 995
  return ((ngx_int_t )tmp___1);
}
}
#line 999 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static void *ngx_http_autoindex_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_autoindex_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1004
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_autoindex_loc_conf_t ));
#line 1004
  conf = (ngx_http_autoindex_loc_conf_t *)tmp;
  }
#line 1005
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1006
    return ((void *)0);
  }
#line 1009
  conf->enable = (ngx_flag_t )-1;
#line 1010
  conf->format = (ngx_uint_t )-1;
#line 1011
  conf->localtime = (ngx_flag_t )-1;
#line 1012
  conf->exact_size = (ngx_flag_t )-1;
#line 1014
  return ((void *)conf);
}
}
#line 1018 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static char *ngx_http_autoindex_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_autoindex_loc_conf_t *prev ;
  ngx_http_autoindex_loc_conf_t *conf ;

  {
#line 1021
  prev = (ngx_http_autoindex_loc_conf_t *)parent;
#line 1022
  conf = (ngx_http_autoindex_loc_conf_t *)child;
#line 1024
  if (conf->enable == -1L) {
#line 1024
    if (prev->enable == -1L) {
#line 1024
      conf->enable = (ngx_flag_t )0;
    } else {
#line 1024
      conf->enable = prev->enable;
    }
  }
#line 1025
  if (conf->format == 0xffffffffffffffffUL) {
#line 1025
    if (prev->format == 0xffffffffffffffffUL) {
#line 1025
      conf->format = (ngx_uint_t )0;
    } else {
#line 1025
      conf->format = prev->format;
    }
  }
#line 1027
  if (conf->localtime == -1L) {
#line 1027
    if (prev->localtime == -1L) {
#line 1027
      conf->localtime = (ngx_flag_t )0;
    } else {
#line 1027
      conf->localtime = prev->localtime;
    }
  }
#line 1028
  if (conf->exact_size == -1L) {
#line 1028
    if (prev->exact_size == -1L) {
#line 1028
      conf->exact_size = (ngx_flag_t )1;
    } else {
#line 1028
      conf->exact_size = prev->exact_size;
    }
  }
#line 1030
  return ((char *)((void *)0));
}
}
#line 1034 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 1040
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 1042
  tmp = ngx_array_push(& cmcf->phases[9].handlers);
#line 1042
  h = (ngx_http_handler_pt *)tmp;
  }
#line 1043
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1044
    return ((ngx_int_t )-1);
  }
#line 1047
  *h = & ngx_http_autoindex_handler;
#line 1049
  return ((ngx_int_t )0);
}
}
#line 498 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_set_etag(ngx_http_request_t *r ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_static_module.c"
static ngx_int_t ngx_http_static_handler(ngx_http_request_t *r ) ;
#line 14
static ngx_int_t ngx_http_static_init(ngx_conf_t *cf ) ;
#line 17 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_static_module.c"
static ngx_http_module_t ngx_http_static_module_ctx  = 
#line 17
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_static_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 32 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_static_module.c"
ngx_module_t ngx_http_static_module  = 
#line 32
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_static_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 48 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_static_module.c"
static ngx_int_t ngx_http_static_handler(ngx_http_request_t *r ) 
{ 
  u_char *last ;
  u_char *location ;
  size_t___0 root ;
  size_t___0 len ;
  ngx_str_t path ;
  ngx_int_t rc ;
  ngx_uint_t level ;
  ngx_log_t *log ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_open_file_info_t of ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 62
  if (! (r->method & 14UL)) {
#line 63
    return ((ngx_int_t )405);
  }
#line 66
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) == 47) {
#line 67
    return ((ngx_int_t )-5);
  }
  {
#line 70
  log = (r->connection)->log;
#line 77
  last = ngx_http_map_uri_to_path(r, & path, & root, (size_t___0 )0);
  }
#line 78
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 79
    return ((ngx_int_t )500);
  }
  {
#line 82
  path.len = (size_t___0 )(last - path.data);
#line 87
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 89
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 91
  of.read_ahead = clcf->read_ahead;
#line 92
  of.directio = clcf->directio;
#line 93
  of.valid = clcf->open_file_cache_valid;
#line 94
  of.min_uses = clcf->open_file_cache_min_uses;
#line 95
  of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 96
  of.events = (unsigned int )clcf->open_file_cache_events;
#line 98
  tmp = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
  }
#line 98
  if (tmp != 0L) {
#line 99
    return ((ngx_int_t )500);
  }
  {
#line 102
  tmp___0 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
  }
#line 102
  if (tmp___0 != 0L) {
    {
#line 107
    if (of.err == 0) {
#line 107
      goto case_0;
    }
#line 112
    if (of.err == 36) {
#line 112
      goto case_36;
    }
#line 112
    if (of.err == 20) {
#line 112
      goto case_36;
    }
#line 112
    if (of.err == 2) {
#line 112
      goto case_36;
    }
#line 121
    if (of.err == 40) {
#line 121
      goto case_40;
    }
#line 121
    if (of.err == 31) {
#line 121
      goto case_40;
    }
#line 121
    if (of.err == 13) {
#line 121
      goto case_40;
    }
#line 128
    goto switch_default;
    case_0: /* CIL Label */ 
#line 108
    return ((ngx_int_t )500);
    case_36: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 114
    level = (ngx_uint_t )4;
#line 115
    rc = (ngx_int_t )404;
#line 116
    goto switch_break;
    case_40: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 124
    level = (ngx_uint_t )4;
#line 125
    rc = (ngx_int_t )403;
#line 126
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 130
    level = (ngx_uint_t )3;
#line 131
    rc = (ngx_int_t )500;
#line 132
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 135
    if (rc != 404L) {
#line 135
      goto _L;
    } else
#line 135
    if (clcf->log_not_found) {
      _L: /* CIL Label */ 
#line 136
      if (log->log_level >= level) {
        {
#line 136
        ngx_log_error_core(level, log, of.err, "%s \"%s\" failed", of.failed, path.data);
        }
      }
    }
#line 140
    return (rc);
  }
#line 143
  r->root_tested = (unsigned int )(! r->error_page);
#line 147
  if (of.is_dir) {
#line 151
    if (r->headers_out.location) {
#line 151
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 151
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 153
    tmp___1 = ngx_list_push(& r->headers_out.headers);
#line 153
    r->headers_out.location = (ngx_table_elt_t *)tmp___1;
    }
#line 154
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
#line 155
      return ((ngx_int_t )500);
    }
#line 158
    len = r->uri.len + 1UL;
#line 160
    if (! clcf->alias) {
#line 160
      if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
#line 160
        if (r->args.len == 0UL) {
#line 161
          location = path.data + clcf->root.len;
#line 163
          *last = (u_char )'/';
        } else {
#line 160
          goto _L___1;
        }
      } else {
#line 160
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 166
      if (r->args.len) {
#line 167
        len += r->args.len + 1UL;
      }
      {
#line 170
      tmp___2 = ngx_pnalloc(r->pool, len);
#line 170
      location = (u_char *)tmp___2;
      }
#line 171
      if ((unsigned long )location == (unsigned long )((void *)0)) {
#line 172
        if (r->headers_out.location) {
#line 172
          (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 172
          r->headers_out.location = (ngx_table_elt_t *)((void *)0);
        }
#line 173
        return ((ngx_int_t )500);
      }
      {
#line 176
      tmp___3 = memcpy((void */* __restrict  */)location, (void const   */* __restrict  */)r->uri.data,
                       r->uri.len);
#line 176
      last = (u_char *)tmp___3 + r->uri.len;
#line 178
      *last = (u_char )'/';
      }
#line 180
      if (r->args.len) {
        {
#line 181
        last ++;
#line 181
        *last = (u_char )'?';
#line 182
        last ++;
#line 182
        memcpy((void */* __restrict  */)last, (void const   */* __restrict  */)r->args.data,
               r->args.len);
        }
      }
    }
#line 186
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 187
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 187
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 188
    (r->headers_out.location)->value.len = len;
#line 189
    (r->headers_out.location)->value.data = location;
#line 191
    return ((ngx_int_t )301);
  }
#line 196
  if (! of.is_file) {
#line 197
    if (log->log_level >= 3UL) {
      {
#line 197
      ngx_log_error_core((ngx_uint_t )3, log, 0, "\"%s\" is not a regular file", path.data);
      }
    }
#line 200
    return ((ngx_int_t )404);
  }
#line 205
  if (r->method == 8UL) {
#line 206
    return ((ngx_int_t )405);
  }
  {
#line 209
  rc = ngx_http_discard_request_body(r);
  }
#line 211
  if (rc != 0L) {
#line 212
    return (rc);
  }
  {
#line 215
  log->action = (char *)"sending response to client";
#line 217
  r->headers_out.status = (ngx_uint_t )200;
#line 218
  r->headers_out.content_length_n = of.size;
#line 219
  r->headers_out.last_modified_time = of.mtime;
#line 221
  tmp___4 = ngx_http_set_etag(r);
  }
#line 221
  if (tmp___4 != 0L) {
#line 222
    return ((ngx_int_t )500);
  }
  {
#line 225
  tmp___5 = ngx_http_set_content_type(r);
  }
#line 225
  if (tmp___5 != 0L) {
#line 226
    return ((ngx_int_t )500);
  }
#line 229
  if ((unsigned long )r != (unsigned long )r->main) {
#line 229
    if (of.size == 0L) {
      {
#line 230
      tmp___6 = ngx_http_send_header(r);
      }
#line 230
      return (tmp___6);
    }
  }
  {
#line 233
  r->allow_ranges = 1U;
#line 237
  tmp___7 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 237
  b = (ngx_buf_t *)tmp___7;
  }
#line 238
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 239
    return ((ngx_int_t )500);
  }
  {
#line 242
  tmp___8 = ngx_pcalloc(r->pool, sizeof(ngx_file_t ));
#line 242
  b->file = (ngx_file_t *)tmp___8;
  }
#line 243
  if ((unsigned long )b->file == (unsigned long )((void *)0)) {
#line 244
    return ((ngx_int_t )500);
  }
  {
#line 247
  rc = ngx_http_send_header(r);
  }
#line 249
  if (rc == -1L) {
#line 250
    return (rc);
  } else
#line 249
  if (rc > 0L) {
#line 250
    return (rc);
  } else
#line 249
  if (r->header_only) {
#line 250
    return (rc);
  }
#line 253
  b->file_pos = (off_t )0;
#line 254
  b->file_last = of.size;
#line 256
  if (b->file_last) {
#line 256
    b->in_file = 1U;
  } else {
#line 256
    b->in_file = 0U;
  }
#line 257
  if ((unsigned long )r == (unsigned long )r->main) {
#line 257
    b->last_buf = 1U;
  } else {
#line 257
    b->last_buf = 0U;
  }
  {
#line 258
  b->last_in_chain = 1U;
#line 260
  (b->file)->fd = of.fd;
#line 261
  (b->file)->name = path;
#line 262
  (b->file)->log = log;
#line 263
  (b->file)->directio = of.is_directio;
#line 265
  out.buf = b;
#line 266
  out.next = (ngx_chain_t *)((void *)0);
#line 268
  tmp___9 = ngx_http_output_filter(r, & out);
  }
#line 268
  return (tmp___9);
}
}
#line 272 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_static_module.c"
static ngx_int_t ngx_http_static_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 278
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 280
  tmp = ngx_array_push(& cmcf->phases[9].handlers);
#line 280
  h = (ngx_http_handler_pt *)tmp;
  }
#line 281
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 282
    return ((ngx_int_t )-1);
  }
#line 285
  *h = & ngx_http_static_handler;
#line 287
  return ((ngx_int_t )0);
}
}
#line 16 "src/core/ngx_parse_time.h"
time_t ngx_parse_http_time(u_char *value , size_t___0 len ) ;
#line 143 "src/http/ngx_http.h"
ngx_int_t ngx_http_filter_finalize_request(ngx_http_request_t *r , ngx_module_t *m ,
                                           ngx_int_t error ) ;
#line 171
ngx_int_t (*ngx_http_top_header_filter)(ngx_http_request_t *r ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_unmodified(ngx_http_request_t *r ) ;
#line 14
static ngx_uint_t ngx_http_test_if_modified(ngx_http_request_t *r ) ;
#line 15
static ngx_uint_t ngx_http_test_if_match(ngx_http_request_t *r , ngx_table_elt_t *header___0 ,
                                         ngx_uint_t weak ) ;
#line 17
static ngx_int_t ngx_http_not_modified_filter_init(ngx_conf_t *cf ) ;
#line 20 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_http_module_t ngx_http_not_modified_filter_module_ctx  = 
#line 20
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_not_modified_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 35 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
ngx_module_t ngx_http_not_modified_filter_module  = 
#line 35
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_not_modified_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 51 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter)(ngx_http_request_t *r )  ;
#line 54 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_int_t ngx_http_not_modified_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_uint_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_uint_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_uint_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 57
  if (r->headers_out.status != 200UL) {
    {
#line 61
    tmp = (*ngx_http_next_header_filter)(r);
    }
#line 61
    return (tmp);
  } else
#line 57
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 61
    tmp = (*ngx_http_next_header_filter)(r);
    }
#line 61
    return (tmp);
  } else
#line 57
  if (r->disable_not_modified) {
    {
#line 61
    tmp = (*ngx_http_next_header_filter)(r);
    }
#line 61
    return (tmp);
  }
#line 64
  if (r->headers_in.if_unmodified_since) {
    {
#line 64
    tmp___1 = ngx_http_test_if_unmodified(r);
    }
#line 64
    if (! tmp___1) {
      {
#line 67
      tmp___0 = ngx_http_filter_finalize_request(r, (ngx_module_t *)((void *)0), (ngx_int_t )412);
      }
#line 67
      return (tmp___0);
    }
  }
#line 71
  if (r->headers_in.if_match) {
    {
#line 71
    tmp___3 = ngx_http_test_if_match(r, r->headers_in.if_match, (ngx_uint_t )0);
    }
#line 71
    if (! tmp___3) {
      {
#line 74
      tmp___2 = ngx_http_filter_finalize_request(r, (ngx_module_t *)((void *)0), (ngx_int_t )412);
      }
#line 74
      return (tmp___2);
    }
  }
#line 78
  if (r->headers_in.if_modified_since) {
#line 78
    goto _L;
  } else
#line 78
  if (r->headers_in.if_none_match) {
    _L: /* CIL Label */ 
#line 80
    if (r->headers_in.if_modified_since) {
      {
#line 80
      tmp___5 = ngx_http_test_if_modified(r);
      }
#line 80
      if (tmp___5) {
        {
#line 83
        tmp___4 = (*ngx_http_next_header_filter)(r);
        }
#line 83
        return (tmp___4);
      }
    }
#line 86
    if (r->headers_in.if_none_match) {
      {
#line 86
      tmp___7 = ngx_http_test_if_match(r, r->headers_in.if_none_match, (ngx_uint_t )1);
      }
#line 86
      if (! tmp___7) {
        {
#line 89
        tmp___6 = (*ngx_http_next_header_filter)(r);
        }
#line 89
        return (tmp___6);
      }
    }
#line 94
    r->headers_out.status = (ngx_uint_t )304;
#line 95
    r->headers_out.status_line.len = (size_t___0 )0;
#line 96
    r->headers_out.content_type.len = (size_t___0 )0;
#line 97
    r->headers_out.content_length_n = (off_t )-1;
#line 97
    if (r->headers_out.content_length) {
#line 97
      (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 97
      r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
    }
#line 98
    r->allow_ranges = 0U;
#line 98
    if (r->headers_out.accept_ranges) {
#line 98
      (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 98
      r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
    }
#line 100
    if (r->headers_out.content_encoding) {
#line 101
      (r->headers_out.content_encoding)->hash = (ngx_uint_t )0;
#line 102
      r->headers_out.content_encoding = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 105
    tmp___8 = (*ngx_http_next_header_filter)(r);
    }
#line 105
    return (tmp___8);
  }
  {
#line 108
  tmp___9 = (*ngx_http_next_header_filter)(r);
  }
#line 108
  return (tmp___9);
}
}
#line 112 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_unmodified(ngx_http_request_t *r ) 
{ 
  time_t iums ;

  {
#line 117
  if (r->headers_out.last_modified_time == -1L) {
#line 118
    return ((ngx_uint_t )0);
  }
  {
#line 121
  iums = ngx_parse_http_time((r->headers_in.if_unmodified_since)->value.data, (r->headers_in.if_unmodified_since)->value.len);
  }
#line 127
  if (iums >= r->headers_out.last_modified_time) {
#line 128
    return ((ngx_uint_t )1);
  }
#line 131
  return ((ngx_uint_t )0);
}
}
#line 135 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_modified(ngx_http_request_t *r ) 
{ 
  time_t ims ;
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 141
  if (r->headers_out.last_modified_time == -1L) {
#line 142
    return ((ngx_uint_t )1);
  }
#line 145
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 147
  if (clcf->if_modified_since == 0UL) {
#line 148
    return ((ngx_uint_t )1);
  }
  {
#line 151
  ims = ngx_parse_http_time((r->headers_in.if_modified_since)->value.data, (r->headers_in.if_modified_since)->value.len);
  }
#line 157
  if (ims == r->headers_out.last_modified_time) {
#line 158
    return ((ngx_uint_t )0);
  }
#line 161
  if (clcf->if_modified_since == 1UL) {
#line 164
    return ((ngx_uint_t )1);
  } else
#line 161
  if (ims < r->headers_out.last_modified_time) {
#line 164
    return ((ngx_uint_t )1);
  }
#line 167
  return ((ngx_uint_t )0);
}
}
#line 171 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_match(ngx_http_request_t *r , ngx_table_elt_t *header___0 ,
                                         ngx_uint_t weak ) 
{ 
  u_char *start ;
  u_char *end ;
  u_char ch ;
  ngx_str_t etag ;
  ngx_str_t *list ;
  int tmp ;

  {
#line 178
  list = & header___0->value;
#line 180
  if (list->len == 1UL) {
#line 180
    if ((int )*(list->data + 0) == 42) {
#line 181
      return ((ngx_uint_t )1);
    }
  }
#line 184
  if ((unsigned long )r->headers_out.etag == (unsigned long )((void *)0)) {
#line 185
    return ((ngx_uint_t )0);
  }
#line 188
  etag = (r->headers_out.etag)->value;
#line 193
  if (weak) {
#line 193
    if (etag.len > 2UL) {
#line 193
      if ((int )*(etag.data + 0) == 87) {
#line 193
        if ((int )*(etag.data + 1) == 47) {
#line 198
          etag.len -= 2UL;
#line 199
          etag.data += 2;
        }
      }
    }
  }
#line 202
  start = list->data;
#line 203
  end = list->data + list->len;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 205
      goto while_break;
    }
#line 207
    if (weak) {
#line 207
      if (end - start > 2L) {
#line 207
        if ((int )*(start + 0) == 87) {
#line 207
          if ((int )*(start + 1) == 47) {
#line 212
            start += 2;
          }
        }
      }
    }
#line 215
    if (etag.len > (size_t___0 )(end - start)) {
#line 216
      return ((ngx_uint_t )0);
    }
    {
#line 219
    tmp = strncmp((char const   *)start, (char const   *)etag.data, etag.len);
    }
#line 219
    if (tmp != 0) {
#line 220
      goto skip;
    }
#line 223
    start += etag.len;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 225
        goto while_break___0;
      }
#line 226
      ch = *start;
#line 228
      if ((int )ch == 32) {
#line 229
        start ++;
#line 230
        goto while_continue___0;
      } else
#line 228
      if ((int )ch == 9) {
#line 229
        start ++;
#line 230
        goto while_continue___0;
      }
#line 233
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 236
    if ((unsigned long )start == (unsigned long )end) {
#line 237
      return ((ngx_uint_t )1);
    } else
#line 236
    if ((int )*start == 44) {
#line 237
      return ((ngx_uint_t )1);
    }
    skip: 
    {
#line 242
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 242
      if ((unsigned long )start < (unsigned long )end) {
#line 242
        if (! ((int )*start != 44)) {
#line 242
          goto while_break___1;
        }
      } else {
#line 242
        goto while_break___1;
      }
#line 242
      start ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 243
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 243
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 243
        goto while_break___2;
      }
#line 244
      ch = *start;
#line 246
      if ((int )ch == 32) {
#line 247
        start ++;
#line 248
        goto while_continue___2;
      } else
#line 246
      if ((int )ch == 9) {
#line 247
        start ++;
#line 248
        goto while_continue___2;
      } else
#line 246
      if ((int )ch == 44) {
#line 247
        start ++;
#line 248
        goto while_continue___2;
      }
#line 251
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((ngx_uint_t )0);
}
}
#line 259 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_int_t ngx_http_not_modified_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 262
  ngx_http_next_header_filter = ngx_http_top_header_filter;
#line 263
  ngx_http_top_header_filter = & ngx_http_not_modified_header_filter;
#line 265
  return ((ngx_int_t )0);
}
}
#line 157 "src/core/ngx_buf.h"
ngx_int_t ngx_output_chain(ngx_output_chain_ctx_t *ctx , ngx_chain_t *in ) ;
#line 172 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain ) ;
#line 33 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static void *ngx_http_copy_filter_create_conf(ngx_conf_t *cf ) ;
#line 34
static char *ngx_http_copy_filter_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 36
static ngx_int_t ngx_http_copy_filter_init(ngx_conf_t *cf ) ;
#line 39 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static ngx_command_t ngx_http_copy_filter_commands[2]  = {      {{sizeof("output_buffers") - 1UL, (u_char *)"output_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_copy_filter_conf_t *)0)->bufs), (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 52 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static ngx_http_module_t ngx_http_copy_filter_module_ctx  = 
#line 52
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_copy_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_copy_filter_create_conf,
    & ngx_http_copy_filter_merge_conf};
#line 67 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
ngx_module_t ngx_http_copy_filter_module  = 
#line 67
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_copy_filter_module_ctx),
    ngx_http_copy_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 83 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 86 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static ngx_int_t ngx_http_copy_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;
  ngx_output_chain_ctx_t *ctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_copy_filter_conf_t *conf ;
  void *tmp ;
  int tmp___0 ;
  off_t tmp___1 ;

  {
#line 95
  c = r->connection;
#line 100
  ctx = (ngx_output_chain_ctx_t *)*(r->ctx + ngx_http_copy_filter_module.ctx_index);
#line 102
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 103
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_output_chain_ctx_t ));
#line 103
    ctx = (ngx_output_chain_ctx_t *)tmp;
    }
#line 104
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 105
      return ((ngx_int_t )-1);
    }
#line 108
    *(r->ctx + ngx_http_copy_filter_module.ctx_index) = (void *)ctx;
#line 110
    conf = (ngx_http_copy_filter_conf_t *)*(r->loc_conf + ngx_http_copy_filter_module.ctx_index);
#line 111
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 113
    ctx->sendfile = c->sendfile;
#line 114
    if (r->main_filter_need_in_memory) {
#line 114
      tmp___0 = 1;
    } else
#line 114
    if (r->filter_need_in_memory) {
#line 114
      tmp___0 = 1;
    } else {
#line 114
      tmp___0 = 0;
    }
#line 114
    ctx->need_in_memory = (unsigned int )tmp___0;
#line 116
    ctx->need_in_temp = r->filter_need_temporary;
#line 118
    ctx->alignment = clcf->directio_alignment;
#line 120
    ctx->pool = r->pool;
#line 121
    ctx->bufs = conf->bufs;
#line 122
    ctx->tag = (ngx_buf_tag_t )(& ngx_http_copy_filter_module);
#line 124
    ctx->output_filter = (ngx_int_t (*)(void *ctx , ngx_chain_t *in ))ngx_http_next_body_filter;
#line 126
    ctx->filter_ctx = (void *)r;
#line 143
    if (in) {
#line 143
      if (in->buf) {
#line 143
        if ((in->buf)->temporary) {
#line 143
          tmp___1 = (in->buf)->last - (in->buf)->pos;
        } else
#line 143
        if ((in->buf)->memory) {
#line 143
          tmp___1 = (in->buf)->last - (in->buf)->pos;
        } else
#line 143
        if ((in->buf)->mmap) {
#line 143
          tmp___1 = (in->buf)->last - (in->buf)->pos;
        } else {
#line 143
          tmp___1 = (in->buf)->file_last - (in->buf)->file_pos;
        }
#line 143
        if (tmp___1) {
#line 144
          r->request_output = 1U;
        }
      }
    }
  }
  {
#line 152
  rc = ngx_output_chain(ctx, in);
  }
#line 154
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 155
    r->buffered &= 4294967291U;
  } else {
#line 158
    r->buffered |= 4U;
  }
#line 164
  return (rc);
}
}
#line 344 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static void *ngx_http_copy_filter_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_copy_filter_conf_t *conf ;
  void *tmp ;

  {
  {
#line 349
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_copy_filter_conf_t ));
#line 349
  conf = (ngx_http_copy_filter_conf_t *)tmp;
  }
#line 350
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 351
    return ((void *)0);
  }
#line 354
  conf->bufs.num = (ngx_int_t )0;
#line 356
  return ((void *)conf);
}
}
#line 360 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static char *ngx_http_copy_filter_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_copy_filter_conf_t *prev ;
  ngx_http_copy_filter_conf_t *conf ;

  {
#line 363
  prev = (ngx_http_copy_filter_conf_t *)parent;
#line 364
  conf = (ngx_http_copy_filter_conf_t *)child;
#line 366
  if (conf->bufs.num == 0L) {
#line 366
    if (prev->bufs.num) {
#line 366
      conf->bufs.num = prev->bufs.num;
#line 366
      conf->bufs.size = prev->bufs.size;
    } else {
#line 366
      conf->bufs.num = (ngx_int_t )2;
#line 366
      conf->bufs.size = (size_t___0 )32768;
    }
  }
#line 368
  return ((char *)((void *)0));
}
}
#line 372 "/tmp/nginx-1.13.2/src/http/ngx_http_copy_filter_module.c"
static ngx_int_t ngx_http_copy_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 375
  ngx_http_next_body_filter = ngx_http_top_body_filter;
#line 376
  ngx_http_top_body_filter = & ngx_http_copy_filter;
#line 378
  return ((ngx_int_t )0);
}
}
#line 18 "src/core/ngx_parse.h"
ngx_int_t ngx_parse_time(ngx_str_t *line , ngx_uint_t is_sec ) ;
#line 30 "src/core/ngx_times.h"
time_t ngx_next_time(time_t when ) ;
#line 40
ngx_str_t volatile   ngx_cached_http_time ;
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_expires(ngx_http_request_t *r , ngx_http_headers_conf_t *conf ) ;
#line 57
static ngx_int_t ngx_http_parse_expires(ngx_str_t *value , ngx_http_expires_t *expires___0 ,
                                        time_t *expires_time , char **err ) ;
#line 59
static ngx_int_t ngx_http_add_cache_control(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) ;
#line 61
static ngx_int_t ngx_http_add_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                     ngx_str_t *value ) ;
#line 63
static ngx_int_t ngx_http_set_last_modified(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) ;
#line 65
static ngx_int_t ngx_http_set_response_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                              ngx_str_t *value ) ;
#line 68
static void *ngx_http_headers_create_conf(ngx_conf_t *cf ) ;
#line 69
static char *ngx_http_headers_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 71
static ngx_int_t ngx_http_headers_filter_init(ngx_conf_t *cf ) ;
#line 72
static char *ngx_http_headers_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 74
static char *ngx_http_headers_add(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 78 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_http_set_header_t ngx_http_set_headers[4]  = {      {{sizeof("Cache-Control") - 1UL, (u_char *)"Cache-Control"}, (ngx_uint_t )0,
      & ngx_http_add_cache_control}, 
        {{sizeof("Last-Modified") - 1UL, (u_char *)"Last-Modified"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->last_modified),
      & ngx_http_set_last_modified}, 
        {{sizeof("ETag") - 1UL, (u_char *)"ETag"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->etag),
      & ngx_http_set_response_header}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                                              ngx_http_header_val_t *hv ,
                                                                              ngx_str_t *value ))((void *)0)}};
#line 94 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_command_t ngx_http_headers_filter_commands[4]  = {      {{sizeof("expires") - 1UL, (u_char *)"expires"}, (ngx_uint_t )1308622854, & ngx_http_headers_expires,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("add_header") - 1UL,
       (u_char *)"add_header"}, (ngx_uint_t )1308622860, & ngx_http_headers_add, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_headers_conf_t *)0)->headers), (void *)0}, 
        {{sizeof("add_trailer") - 1UL, (u_char *)"add_trailer"}, (ngx_uint_t )1308622860,
      & ngx_http_headers_add, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_headers_conf_t *)0)->trailers), (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 124 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_http_module_t ngx_http_headers_filter_module_ctx  = 
#line 124
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_headers_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_headers_create_conf,
    & ngx_http_headers_merge_conf};
#line 139 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
ngx_module_t ngx_http_headers_filter_module  = 
#line 139
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_headers_filter_module_ctx),
    ngx_http_headers_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 155 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___0)(ngx_http_request_t *r )  ;
#line 156 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___0)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 159 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_headers_filter(ngx_http_request_t *r ) 
{ 
  ngx_str_t value ;
  ngx_uint_t i ;
  ngx_uint_t safe_status ;
  ngx_http_header_val_t *h ;
  ngx_http_headers_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 167
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 168
    tmp = (*ngx_http_next_header_filter___0)(r);
    }
#line 168
    return (tmp);
  }
#line 171
  conf = (ngx_http_headers_conf_t *)*(r->loc_conf + ngx_http_headers_filter_module.ctx_index);
#line 173
  if ((unsigned int )conf->expires == 0U) {
#line 173
    if ((unsigned long )conf->headers == (unsigned long )((void *)0)) {
#line 173
      if ((unsigned long )conf->trailers == (unsigned long )((void *)0)) {
        {
#line 177
        tmp___0 = (*ngx_http_next_header_filter___0)(r);
        }
#line 177
        return (tmp___0);
      }
    }
  }
  {
#line 191
  if (r->headers_out.status == 308UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 307UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 304UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 303UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 302UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 301UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 206UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 204UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 201UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 200UL) {
#line 191
    goto case_308;
  }
#line 195
  goto switch_default;
  case_308: /* CIL Label */ 
  case_307: /* CIL Label */ 
  case_304: /* CIL Label */ 
  case_303: /* CIL Label */ 
  case_302: /* CIL Label */ 
  case_301: /* CIL Label */ 
  case_206: /* CIL Label */ 
  case_204: /* CIL Label */ 
  case_201: /* CIL Label */ 
  case_200: /* CIL Label */ 
#line 192
  safe_status = (ngx_uint_t )1;
#line 193
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 196
  safe_status = (ngx_uint_t )0;
#line 197
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 200
  if ((unsigned int )conf->expires != 0U) {
#line 200
    if (safe_status) {
      {
#line 201
      tmp___1 = ngx_http_set_expires(r, conf);
      }
#line 201
      if (tmp___1 != 0L) {
#line 202
        return ((ngx_int_t )-1);
      }
    }
  }
#line 206
  if (conf->headers) {
#line 207
    h = (ngx_http_header_val_t *)(conf->headers)->elts;
#line 208
    i = (ngx_uint_t )0;
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 208
      if (! (i < (conf->headers)->nelts)) {
#line 208
        goto while_break;
      }
#line 210
      if (! safe_status) {
#line 210
        if (! (h + i)->always) {
#line 211
          goto __Cont;
        }
      }
      {
#line 214
      tmp___2 = ngx_http_complex_value(r, & (h + i)->value, & value);
      }
#line 214
      if (tmp___2 != 0L) {
#line 215
        return ((ngx_int_t )-1);
      }
      {
#line 218
      tmp___3 = (*((h + i)->handler))(r, h + i, & value);
      }
#line 218
      if (tmp___3 != 0L) {
#line 219
        return ((ngx_int_t )-1);
      }
      __Cont: /* CIL Label */ 
#line 208
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 224
  if (conf->trailers) {
#line 225
    h = (ngx_http_header_val_t *)(conf->trailers)->elts;
#line 226
    i = (ngx_uint_t )0;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! (i < (conf->trailers)->nelts)) {
#line 226
        goto while_break___0;
      }
#line 228
      if (! safe_status) {
#line 228
        if (! (h + i)->always) {
#line 229
          goto __Cont___0;
        }
      }
#line 232
      r->expect_trailers = 1U;
#line 233
      goto while_break___0;
      __Cont___0: /* CIL Label */ 
#line 226
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 237
  tmp___4 = (*ngx_http_next_header_filter___0)(r);
  }
#line 237
  return (tmp___4);
}
}
#line 241 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_trailers_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_str_t value ;
  ngx_uint_t i ;
  ngx_uint_t safe_status ;
  ngx_chain_t *cl ;
  ngx_table_elt_t *t ;
  ngx_http_header_val_t *h ;
  ngx_http_headers_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 251
  conf = (ngx_http_headers_conf_t *)*(r->loc_conf + ngx_http_headers_filter_module.ctx_index);
#line 253
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  } else
#line 253
  if ((unsigned long )conf->trailers == (unsigned long )((void *)0)) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  } else
#line 253
  if (! r->expect_trailers) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  } else
#line 253
  if (r->header_only) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  }
#line 261
  cl = in;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! cl) {
#line 261
      goto while_break;
    }
#line 262
    if ((cl->buf)->last_buf) {
#line 263
      goto while_break;
    }
#line 261
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
    {
#line 268
    tmp___0 = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 268
    return (tmp___0);
  }
  {
#line 282
  if (r->headers_out.status == 308UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 307UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 304UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 303UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 302UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 301UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 206UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 204UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 201UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 200UL) {
#line 282
    goto case_308;
  }
#line 286
  goto switch_default;
  case_308: /* CIL Label */ 
  case_307: /* CIL Label */ 
  case_304: /* CIL Label */ 
  case_303: /* CIL Label */ 
  case_302: /* CIL Label */ 
  case_301: /* CIL Label */ 
  case_206: /* CIL Label */ 
  case_204: /* CIL Label */ 
  case_201: /* CIL Label */ 
  case_200: /* CIL Label */ 
#line 283
  safe_status = (ngx_uint_t )1;
#line 284
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 287
  safe_status = (ngx_uint_t )0;
#line 288
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 291
  h = (ngx_http_header_val_t *)(conf->trailers)->elts;
#line 292
  i = (ngx_uint_t )0;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! (i < (conf->trailers)->nelts)) {
#line 292
      goto while_break___0;
    }
#line 294
    if (! safe_status) {
#line 294
      if (! (h + i)->always) {
#line 295
        goto __Cont;
      }
    }
    {
#line 298
    tmp___1 = ngx_http_complex_value(r, & (h + i)->value, & value);
    }
#line 298
    if (tmp___1 != 0L) {
#line 299
      return ((ngx_int_t )-1);
    }
#line 302
    if (value.len) {
      {
#line 303
      tmp___2 = ngx_list_push(& r->headers_out.trailers);
#line 303
      t = (ngx_table_elt_t *)tmp___2;
      }
#line 304
      if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 305
        return ((ngx_int_t )-1);
      }
#line 308
      t->key = (h + i)->key;
#line 309
      t->value = value;
#line 310
      t->hash = (ngx_uint_t )1;
    }
    __Cont: /* CIL Label */ 
#line 292
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 314
  tmp___3 = (*ngx_http_next_body_filter___0)(r, in);
  }
#line 314
  return (tmp___3);
}
}
#line 318 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_expires(ngx_http_request_t *r , ngx_http_headers_conf_t *conf ) 
{ 
  char *err ;
  size_t___0 len ;
  time_t now ;
  time_t expires_time ;
  time_t max_age ;
  ngx_str_t value ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_table_elt_t *e ;
  ngx_table_elt_t *cc ;
  ngx_table_elt_t **ccp ;
  ngx_http_expires_t expires___0 ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 330
  expires___0 = conf->expires;
#line 331
  expires_time = conf->expires_time;
#line 333
  if ((unsigned long )conf->expires_value != (unsigned long )((void *)0)) {
    {
#line 335
    tmp = ngx_http_complex_value(r, conf->expires_value, & value);
    }
#line 335
    if (tmp != 0L) {
#line 336
      return ((ngx_int_t )-1);
    }
    {
#line 339
    rc = ngx_http_parse_expires(& value, & expires___0, & expires_time, & err);
    }
#line 341
    if (rc != 0L) {
#line 342
      return ((ngx_int_t )0);
    }
#line 345
    if ((unsigned int )expires___0 == 0U) {
#line 346
      return ((ngx_int_t )0);
    }
  }
#line 350
  e = r->headers_out.expires;
#line 352
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 354
    tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 354
    e = (ngx_table_elt_t *)tmp___0;
    }
#line 355
    if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 356
      return ((ngx_int_t )-1);
    }
#line 359
    r->headers_out.expires = e;
#line 361
    e->hash = (ngx_uint_t )1;
#line 362
    e->key.len = sizeof("Expires") - 1UL;
#line 362
    e->key.data = (u_char *)"Expires";
  }
#line 365
  len = sizeof("Mon, 28 Sep 1970 06:00:00 GMT");
#line 366
  e->value.len = len - 1UL;
#line 368
  ccp = (ngx_table_elt_t **)r->headers_out.cache_control.elts;
#line 370
  if ((unsigned long )ccp == (unsigned long )((void *)0)) {
    {
#line 372
    tmp___1 = ngx_array_init(& r->headers_out.cache_control, r->pool, (ngx_uint_t )1,
                             sizeof(ngx_table_elt_t *));
    }
#line 372
    if (tmp___1 != 0L) {
#line 376
      return ((ngx_int_t )-1);
    }
    {
#line 379
    tmp___2 = ngx_list_push(& r->headers_out.headers);
#line 379
    cc = (ngx_table_elt_t *)tmp___2;
    }
#line 380
    if ((unsigned long )cc == (unsigned long )((void *)0)) {
#line 381
      return ((ngx_int_t )-1);
    }
    {
#line 384
    cc->hash = (ngx_uint_t )1;
#line 385
    cc->key.len = sizeof("Cache-Control") - 1UL;
#line 385
    cc->key.data = (u_char *)"Cache-Control";
#line 387
    tmp___3 = ngx_array_push(& r->headers_out.cache_control);
#line 387
    ccp = (ngx_table_elt_t **)tmp___3;
    }
#line 388
    if ((unsigned long )ccp == (unsigned long )((void *)0)) {
#line 389
      return ((ngx_int_t )-1);
    }
#line 392
    *ccp = cc;
  } else {
#line 395
    i = (ngx_uint_t )1;
    {
#line 395
    while (1) {
      while_continue: /* CIL Label */ ;
#line 395
      if (! (i < r->headers_out.cache_control.nelts)) {
#line 395
        goto while_break;
      }
#line 396
      (*(ccp + i))->hash = (ngx_uint_t )0;
#line 395
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 399
    cc = *(ccp + 0);
  }
#line 402
  if ((unsigned int )expires___0 == 1U) {
#line 403
    e->value.data = (u_char *)"Thu, 01 Jan 1970 00:00:01 GMT";
#line 404
    cc->value.len = sizeof("no-cache") - 1UL;
#line 404
    cc->value.data = (u_char *)"no-cache";
#line 405
    return ((ngx_int_t )0);
  }
#line 408
  if ((unsigned int )expires___0 == 2U) {
#line 409
    e->value.data = (u_char *)"Thu, 31 Dec 2037 23:55:55 GMT";
#line 411
    cc->value.len = sizeof("max-age=315360000") - 1UL;
#line 411
    cc->value.data = (u_char *)"max-age=315360000";
#line 412
    return ((ngx_int_t )0);
  }
  {
#line 415
  tmp___4 = ngx_pnalloc(r->pool, len);
#line 415
  e->value.data = (u_char *)tmp___4;
  }
#line 416
  if ((unsigned long )e->value.data == (unsigned long )((void *)0)) {
#line 417
    return ((ngx_int_t )-1);
  }
#line 420
  if (expires_time == 0L) {
#line 420
    if ((unsigned int )expires___0 != 5U) {
      {
#line 421
      memcpy((void */* __restrict  */)e->value.data, (void const   */* __restrict  */)ngx_cached_http_time.data,
             (size_t )(ngx_cached_http_time.len + (size_t___0 volatile   )1));
#line 423
      cc->value.len = sizeof("max-age=0") - 1UL;
#line 423
      cc->value.data = (u_char *)"max-age=0";
      }
#line 424
      return ((ngx_int_t )0);
    }
  }
#line 427
  now = (time_t )ngx_cached_time->sec;
#line 429
  if ((unsigned int )expires___0 == 5U) {
    {
#line 430
    expires_time = ngx_next_time(expires_time);
#line 431
    max_age = expires_time - now;
    }
  } else
#line 433
  if ((unsigned int )expires___0 == 3U) {
#line 436
    max_age = expires_time;
#line 437
    expires_time += now;
  } else
#line 433
  if (r->headers_out.last_modified_time == -1L) {
#line 436
    max_age = expires_time;
#line 437
    expires_time += now;
  } else {
#line 440
    expires_time += r->headers_out.last_modified_time;
#line 441
    max_age = expires_time - now;
  }
  {
#line 444
  ngx_http_time(e->value.data, expires_time);
  }
#line 446
  if (conf->expires_time < 0L) {
#line 447
    cc->value.len = sizeof("no-cache") - 1UL;
#line 447
    cc->value.data = (u_char *)"no-cache";
#line 448
    return ((ngx_int_t )0);
  } else
#line 446
  if (max_age < 0L) {
#line 447
    cc->value.len = sizeof("no-cache") - 1UL;
#line 447
    cc->value.data = (u_char *)"no-cache";
#line 448
    return ((ngx_int_t )0);
  }
  {
#line 451
  tmp___5 = ngx_pnalloc(r->pool, (sizeof("max-age=") + (sizeof("-9223372036854775808") - 1UL)) + 1UL);
#line 451
  cc->value.data = (u_char *)tmp___5;
  }
#line 453
  if ((unsigned long )cc->value.data == (unsigned long )((void *)0)) {
#line 454
    return ((ngx_int_t )-1);
  }
  {
#line 457
  tmp___6 = ngx_sprintf(cc->value.data, "max-age=%T", max_age);
#line 457
  cc->value.len = (size_t___0 )(tmp___6 - cc->value.data);
  }
#line 460
  return ((ngx_int_t )0);
}
}
#line 464 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_parse_expires(ngx_str_t *value , ngx_http_expires_t *expires___0 ,
                                        time_t *expires_time , char **err ) 
{ 
  ngx_uint_t minus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 470
  if ((unsigned int )*expires___0 != 4U) {
#line 472
    if (value->len == 5UL) {
      {
#line 472
      tmp = strncmp((char const   *)value->data, "epoch", (size_t )5);
      }
#line 472
      if (tmp == 0) {
#line 473
        *expires___0 = (ngx_http_expires_t )1;
#line 474
        return ((ngx_int_t )0);
      }
    }
#line 477
    if (value->len == 3UL) {
      {
#line 477
      tmp___0 = strncmp((char const   *)value->data, "max", (size_t )3);
      }
#line 477
      if (tmp___0 == 0) {
#line 478
        *expires___0 = (ngx_http_expires_t )2;
#line 479
        return ((ngx_int_t )0);
      }
    }
#line 482
    if (value->len == 3UL) {
      {
#line 482
      tmp___1 = strncmp((char const   *)value->data, "off", (size_t )3);
      }
#line 482
      if (tmp___1 == 0) {
#line 483
        *expires___0 = (ngx_http_expires_t )0;
#line 484
        return ((ngx_int_t )0);
      }
    }
  }
#line 488
  if (value->len) {
#line 488
    if ((int )*(value->data + 0) == 64) {
#line 489
      (value->data) ++;
#line 490
      (value->len) --;
#line 491
      minus = (ngx_uint_t )0;
#line 493
      if ((unsigned int )*expires___0 == 4U) {
#line 494
        *err = (char *)"daily time cannot be used with \"modified\" parameter";
#line 495
        return ((ngx_int_t )-1);
      }
#line 498
      *expires___0 = (ngx_http_expires_t )5;
    } else {
#line 488
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 500
  if (value->len) {
#line 500
    if ((int )*(value->data + 0) == 43) {
#line 501
      (value->data) ++;
#line 502
      (value->len) --;
#line 503
      minus = (ngx_uint_t )0;
    } else {
#line 500
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 505
  if (value->len) {
#line 505
    if ((int )*(value->data + 0) == 45) {
#line 506
      (value->data) ++;
#line 507
      (value->len) --;
#line 508
      minus = (ngx_uint_t )1;
    } else {
#line 511
      minus = (ngx_uint_t )0;
    }
  } else {
#line 511
    minus = (ngx_uint_t )0;
  }
  {
#line 514
  *expires_time = ngx_parse_time(value, (ngx_uint_t )1);
  }
#line 516
  if (*expires_time == -1L) {
#line 517
    *err = (char *)"invalid value";
#line 518
    return ((ngx_int_t )-1);
  }
#line 521
  if ((unsigned int )*expires___0 == 5U) {
#line 521
    if (*expires_time > 86400L) {
#line 524
      *err = (char *)"daily time value must be less than 24 hours";
#line 525
      return ((ngx_int_t )-1);
    }
  }
#line 528
  if (minus) {
#line 529
    *expires_time = - *expires_time;
  }
#line 532
  return ((ngx_int_t )0);
}
}
#line 536 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_add_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                     ngx_str_t *value ) 
{ 
  ngx_table_elt_t *h ;
  void *tmp ;

  {
#line 542
  if (value->len) {
    {
#line 543
    tmp = ngx_list_push(& r->headers_out.headers);
#line 543
    h = (ngx_table_elt_t *)tmp;
    }
#line 544
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 545
      return ((ngx_int_t )-1);
    }
#line 548
    h->hash = (ngx_uint_t )1;
#line 549
    h->key = hv->key;
#line 550
    h->value = *value;
  }
#line 553
  return ((ngx_int_t )0);
}
}
#line 557 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_add_cache_control(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) 
{ 
  ngx_table_elt_t *cc ;
  ngx_table_elt_t **ccp ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 563
  if (value->len == 0UL) {
#line 564
    return ((ngx_int_t )0);
  }
#line 567
  ccp = (ngx_table_elt_t **)r->headers_out.cache_control.elts;
#line 569
  if ((unsigned long )ccp == (unsigned long )((void *)0)) {
    {
#line 571
    tmp = ngx_array_init(& r->headers_out.cache_control, r->pool, (ngx_uint_t )1,
                         sizeof(ngx_table_elt_t *));
    }
#line 571
    if (tmp != 0L) {
#line 575
      return ((ngx_int_t )-1);
    }
  }
  {
#line 579
  tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 579
  cc = (ngx_table_elt_t *)tmp___0;
  }
#line 580
  if ((unsigned long )cc == (unsigned long )((void *)0)) {
#line 581
    return ((ngx_int_t )-1);
  }
  {
#line 584
  cc->hash = (ngx_uint_t )1;
#line 585
  cc->key.len = sizeof("Cache-Control") - 1UL;
#line 585
  cc->key.data = (u_char *)"Cache-Control";
#line 586
  cc->value = *value;
#line 588
  tmp___1 = ngx_array_push(& r->headers_out.cache_control);
#line 588
  ccp = (ngx_table_elt_t **)tmp___1;
  }
#line 589
  if ((unsigned long )ccp == (unsigned long )((void *)0)) {
#line 590
    return ((ngx_int_t )-1);
  }
#line 593
  *ccp = cc;
#line 595
  return ((ngx_int_t )0);
}
}
#line 599 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_last_modified(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) 
{ 
  ngx_int_t tmp ;
  time_t tmp___0 ;

  {
  {
#line 603
  tmp = ngx_http_set_response_header(r, hv, value);
  }
#line 603
  if (tmp != 0L) {
#line 604
    return ((ngx_int_t )-1);
  }
#line 607
  if (value->len) {
    {
#line 607
    tmp___0 = ngx_parse_http_time(value->data, value->len);
#line 607
    r->headers_out.last_modified_time = tmp___0;
    }
  } else {
#line 607
    r->headers_out.last_modified_time = (time_t )-1;
  }
#line 610
  return ((ngx_int_t )0);
}
}
#line 614 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_response_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                              ngx_str_t *value ) 
{ 
  ngx_table_elt_t *h ;
  ngx_table_elt_t **old ;
  void *tmp ;

  {
#line 620
  old = (ngx_table_elt_t **)((char *)(& r->headers_out) + hv->offset);
#line 622
  if (value->len == 0UL) {
#line 623
    if (*old) {
#line 624
      (*old)->hash = (ngx_uint_t )0;
#line 625
      *old = (ngx_table_elt_t *)((void *)0);
    }
#line 628
    return ((ngx_int_t )0);
  }
#line 631
  if (*old) {
#line 632
    h = *old;
  } else {
    {
#line 635
    tmp = ngx_list_push(& r->headers_out.headers);
#line 635
    h = (ngx_table_elt_t *)tmp;
    }
#line 636
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 637
      return ((ngx_int_t )-1);
    }
#line 640
    *old = h;
  }
#line 643
  h->hash = (ngx_uint_t )1;
#line 644
  h->key = hv->key;
#line 645
  h->value = *value;
#line 647
  return ((ngx_int_t )0);
}
}
#line 651 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static void *ngx_http_headers_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_headers_conf_t *conf ;
  void *tmp ;

  {
  {
#line 656
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_headers_conf_t ));
#line 656
  conf = (ngx_http_headers_conf_t *)tmp;
  }
#line 657
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 658
    return ((void *)0);
  }
#line 670
  conf->expires = (ngx_http_expires_t )6;
#line 672
  return ((void *)conf);
}
}
#line 676 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static char *ngx_http_headers_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_headers_conf_t *prev ;
  ngx_http_headers_conf_t *conf ;

  {
#line 679
  prev = (ngx_http_headers_conf_t *)parent;
#line 680
  conf = (ngx_http_headers_conf_t *)child;
#line 682
  if ((unsigned int )conf->expires == 6U) {
#line 683
    conf->expires = prev->expires;
#line 684
    conf->expires_time = prev->expires_time;
#line 685
    conf->expires_value = prev->expires_value;
#line 687
    if ((unsigned int )conf->expires == 6U) {
#line 688
      conf->expires = (ngx_http_expires_t )0;
    }
  }
#line 692
  if ((unsigned long )conf->headers == (unsigned long )((void *)0)) {
#line 693
    conf->headers = prev->headers;
  }
#line 696
  if ((unsigned long )conf->trailers == (unsigned long )((void *)0)) {
#line 697
    conf->trailers = prev->trailers;
  }
#line 700
  return ((char *)((void *)0));
}
}
#line 704 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_headers_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 707
  ngx_http_next_header_filter___0 = ngx_http_top_header_filter;
#line 708
  ngx_http_top_header_filter = & ngx_http_headers_filter;
#line 710
  ngx_http_next_body_filter___0 = ngx_http_top_body_filter;
#line 711
  ngx_http_top_body_filter = & ngx_http_trailers_filter;
#line 713
  return ((ngx_int_t )0);
}
}
#line 717 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static char *ngx_http_headers_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_headers_conf_t *hcf ;
  char *err ;
  ngx_str_t *value ;
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
#line 720
  hcf = (ngx_http_headers_conf_t *)conf;
#line 729
  if ((unsigned int )hcf->expires != 6U) {
#line 730
    return ((char *)"is duplicate");
  }
#line 733
  value = (ngx_str_t *)(cf->args)->elts;
#line 735
  if ((cf->args)->nelts == 2UL) {
#line 737
    hcf->expires = (ngx_http_expires_t )3;
#line 739
    n = (ngx_uint_t )1;
  } else {
    {
#line 743
    tmp = strcmp((char const   *)(value + 1)->data, "modified");
    }
#line 743
    if (tmp != 0) {
#line 744
      return ((char *)"invalid value");
    }
#line 747
    hcf->expires = (ngx_http_expires_t )4;
#line 749
    n = (ngx_uint_t )2;
  }
  {
#line 752
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 754
  ccv.cf = cf;
#line 755
  ccv.value = value + n;
#line 756
  ccv.complex_value = & cv;
#line 758
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 758
  if (tmp___0 != 0L) {
#line 759
    return ((char *)((void *)-1));
  }
#line 762
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 764
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 764
    hcf->expires_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 766
    if ((unsigned long )hcf->expires_value == (unsigned long )((void *)0)) {
#line 767
      return ((char *)((void *)-1));
    }
#line 770
    *(hcf->expires_value) = cv;
#line 772
    return ((char *)((void *)0));
  }
  {
#line 775
  rc = ngx_http_parse_expires(value + n, & hcf->expires, & hcf->expires_time, & err);
  }
#line 777
  if (rc != 0L) {
#line 778
    return (err);
  }
#line 781
  return ((char *)((void *)0));
}
}
#line 785 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_headers_filter_module.c"
static char *ngx_http_headers_add(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_headers_conf_t *hcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_array_t **headers ;
  ngx_http_header_val_t *hv ;
  ngx_http_set_header_t *set ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;

  {
#line 788
  hcf = (ngx_http_headers_conf_t *)conf;
#line 797
  value = (ngx_str_t *)(cf->args)->elts;
#line 799
  headers = (ngx_array_t **)((char *)hcf + cmd->offset);
#line 801
  if ((unsigned long )*headers == (unsigned long )((void *)0)) {
    {
#line 802
    *headers = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_header_val_t ));
    }
#line 804
    if ((unsigned long )*headers == (unsigned long )((void *)0)) {
#line 805
      return ((char *)((void *)-1));
    }
  }
  {
#line 809
  tmp = ngx_array_push(*headers);
#line 809
  hv = (ngx_http_header_val_t *)tmp;
  }
#line 810
  if ((unsigned long )hv == (unsigned long )((void *)0)) {
#line 811
    return ((char *)((void *)-1));
  }
#line 814
  hv->key = *(value + 1);
#line 815
  hv->handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                               ngx_str_t *value ))((void *)0);
#line 816
  hv->offset = (ngx_uint_t )0;
#line 817
  hv->always = (ngx_uint_t )0;
#line 819
  if ((unsigned long )headers == (unsigned long )(& hcf->headers)) {
#line 820
    hv->handler = & ngx_http_add_header;
#line 822
    set = ngx_http_set_headers;
#line 823
    i = (ngx_uint_t )0;
    {
#line 823
    while (1) {
      while_continue: /* CIL Label */ ;
#line 823
      if (! (set + i)->name.len) {
#line 823
        goto while_break;
      }
      {
#line 824
      tmp___0 = ngx_strcasecmp((value + 1)->data, (set + i)->name.data);
      }
#line 824
      if (tmp___0 != 0L) {
#line 825
        goto __Cont;
      }
#line 828
      hv->offset = (set + i)->offset;
#line 829
      hv->handler = (set + i)->handler;
#line 831
      goto while_break;
      __Cont: /* CIL Label */ 
#line 823
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 835
  if ((value + 2)->len == 0UL) {
    {
#line 836
    memset((void *)(& hv->value), 0, sizeof(ngx_http_complex_value_t ));
    }
  } else {
    {
#line 839
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 841
    ccv.cf = cf;
#line 842
    ccv.value = value + 2;
#line 843
    ccv.complex_value = & hv->value;
#line 845
    tmp___1 = ngx_http_compile_complex_value(& ccv);
    }
#line 845
    if (tmp___1 != 0L) {
#line 846
      return ((char *)((void *)-1));
    }
  }
#line 850
  if ((cf->args)->nelts == 3UL) {
#line 851
    return ((char *)((void *)0));
  }
  {
#line 854
  tmp___2 = strcmp((char const   *)(value + 3)->data, "always");
  }
#line 854
  if (tmp___2 != 0) {
    {
#line 855
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 3);
    }
#line 857
    return ((char *)((void *)-1));
  }
#line 860
  hv->always = (ngx_uint_t )1;
#line 862
  return ((char *)((void *)0));
}
}
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 185 "src/core/ngx_string.h"
void ngx_encode_base64(ngx_str_t *dst , ngx_str_t *src ) ;
#line 187
ngx_int_t ngx_decode_base64(ngx_str_t *dst , ngx_str_t *src ) ;
#line 81 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_pid ;
#line 27 "src/core/ngx_times.h"
u_char *ngx_http_cookie_time(u_char *buf , time_t t ) ;
#line 215 "src/core/ngx_connection.h"
ngx_int_t ngx_connection_local_sockaddr(ngx_connection_t *c , ngx_str_t *s , ngx_uint_t port ) ;
#line 102 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers , ngx_str_t *name ,
                                            ngx_str_t *value ) ;
#line 46 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_http_userid_ctx_t *ngx_http_userid_get_uid(ngx_http_request_t *r , ngx_http_userid_conf_t *conf ) ;
#line 48
static ngx_int_t ngx_http_userid_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          ngx_str_t *name , uint32_t *uid ) ;
#line 50
static ngx_int_t ngx_http_userid_set_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                         ngx_http_userid_conf_t *conf ) ;
#line 52
static ngx_int_t ngx_http_userid_create_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                            ngx_http_userid_conf_t *conf ) ;
#line 55
static ngx_int_t ngx_http_userid_add_variables(ngx_conf_t *cf ) ;
#line 56
static ngx_int_t ngx_http_userid_init(ngx_conf_t *cf ) ;
#line 57
static void *ngx_http_userid_create_conf(ngx_conf_t *cf ) ;
#line 58
static char *ngx_http_userid_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 60
static char *ngx_http_userid_domain(ngx_conf_t *cf , void *post , void *data ) ;
#line 61
static char *ngx_http_userid_path(ngx_conf_t *cf , void *post , void *data ) ;
#line 62
static char *ngx_http_userid_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64
static char *ngx_http_userid_p3p(ngx_conf_t *cf , void *post , void *data ) ;
#line 65
static char *ngx_http_userid_mark(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 67
static ngx_int_t ngx_http_userid_init_worker(ngx_cycle_t *cycle ) ;
#line 71 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static uint32_t start_value  ;
#line 72 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static uint32_t sequencer_v1  =    (uint32_t )1;
#line 73 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static uint32_t sequencer_v2  =    (uint32_t )50529026;
#line 76 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static u_char expires[38]  = 
#line 76
  {      (u_char )';',      (u_char )' ',      (u_char )'e',      (u_char )'x', 
        (u_char )'p',      (u_char )'i',      (u_char )'r',      (u_char )'e', 
        (u_char )'s',      (u_char )'=',      (u_char )'T',      (u_char )'h', 
        (u_char )'u',      (u_char )',',      (u_char )' ',      (u_char )'3', 
        (u_char )'1',      (u_char )'-',      (u_char )'D',      (u_char )'e', 
        (u_char )'c',      (u_char )'-',      (u_char )'3',      (u_char )'7', 
        (u_char )' ',      (u_char )'2',      (u_char )'3',      (u_char )':', 
        (u_char )'5',      (u_char )'5',      (u_char )':',      (u_char )'5', 
        (u_char )'5',      (u_char )' ',      (u_char )'G',      (u_char )'M', 
        (u_char )'T',      (u_char )'\000'};
#line 79 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___1)(ngx_http_request_t *r )  ;
#line 82 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_conf_enum_t ngx_http_userid_state[5]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("log") - 1UL, (u_char *)"log"}, (ngx_uint_t )1}, 
        {{sizeof("v1") - 1UL, (u_char *)"v1"}, (ngx_uint_t )2}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )3}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 91 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *(*ngx_http_userid_domain_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_userid_domain;
#line 93 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *(*ngx_http_userid_path_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_userid_path;
#line 94 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *(*ngx_http_userid_p3p_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_userid_p3p;
#line 97 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_command_t ngx_http_userid_commands[9]  = 
#line 97
  {      {{sizeof("userid") - 1UL, (u_char *)"userid"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_userid_conf_t *)0)->enable),
      (void *)(ngx_http_userid_state)}, 
        {{sizeof("userid_service") - 1UL, (u_char *)"userid_service"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->service), (void *)0}, 
        {{sizeof("userid_name") - 1UL, (u_char *)"userid_name"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->name), (void *)0}, 
        {{sizeof("userid_domain") - 1UL, (u_char *)"userid_domain"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->domain), (void *)(& ngx_http_userid_domain_p)}, 
        {{sizeof("userid_path") - 1UL,
       (u_char *)"userid_path"}, (ngx_uint_t )234881026, & ngx_conf_set_str_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_userid_conf_t *)0)->path),
      (void *)(& ngx_http_userid_path_p)}, 
        {{sizeof("userid_expires") - 1UL, (u_char *)"userid_expires"}, (ngx_uint_t )234881026,
      & ngx_http_userid_expires, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("userid_p3p") - 1UL, (u_char *)"userid_p3p"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->p3p), (void *)(& ngx_http_userid_p3p_p)}, 
        {{sizeof("userid_mark") - 1UL,
       (u_char *)"userid_mark"}, (ngx_uint_t )234881026, & ngx_http_userid_mark, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 159 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_http_module_t ngx_http_userid_filter_module_ctx  = 
#line 159
     {& ngx_http_userid_add_variables, & ngx_http_userid_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_userid_create_conf,
    & ngx_http_userid_merge_conf};
#line 174 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
ngx_module_t ngx_http_userid_filter_module  = 
#line 174
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_userid_filter_module_ctx),
    ngx_http_userid_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), & ngx_http_userid_init_worker,
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 190 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_str_t ngx_http_userid_got  =    {sizeof("uid_got") - 1UL, (u_char *)"uid_got"};
#line 191 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_str_t ngx_http_userid_set  =    {sizeof("uid_set") - 1UL, (u_char *)"uid_set"};
#line 192 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_str_t ngx_http_userid_reset  =    {sizeof("uid_reset") - 1UL, (u_char *)"uid_reset"};
#line 193 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_uint_t ngx_http_userid_reset_index  ;
#line 196 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_filter(ngx_http_request_t *r ) 
{ 
  ngx_http_userid_ctx_t *ctx ;
  ngx_http_userid_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 202
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 203
    tmp = (*ngx_http_next_header_filter___1)(r);
    }
#line 203
    return (tmp);
  }
#line 206
  conf = (ngx_http_userid_conf_t *)*(r->loc_conf + ngx_http_userid_filter_module.ctx_index);
#line 208
  if (conf->enable < 2UL) {
    {
#line 209
    tmp___0 = (*ngx_http_next_header_filter___1)(r);
    }
#line 209
    return (tmp___0);
  }
  {
#line 212
  ctx = ngx_http_userid_get_uid(r, conf);
  }
#line 214
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 215
    return ((ngx_int_t )-1);
  }
  {
#line 218
  tmp___2 = ngx_http_userid_set_uid(r, ctx, conf);
  }
#line 218
  if (tmp___2 == 0L) {
    {
#line 219
    tmp___1 = (*ngx_http_next_header_filter___1)(r);
    }
#line 219
    return (tmp___1);
  }
#line 222
  return ((ngx_int_t )-1);
}
}
#line 226 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_got_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_userid_ctx_t *ctx ;
  ngx_http_userid_conf_t *conf ;
  ngx_int_t tmp ;

  {
#line 233
  conf = (ngx_http_userid_conf_t *)*((r->main)->loc_conf + ngx_http_userid_filter_module.ctx_index);
#line 235
  if (conf->enable == 0UL) {
#line 236
    v->not_found = 1U;
#line 237
    return ((ngx_int_t )0);
  }
  {
#line 240
  ctx = ngx_http_userid_get_uid(r->main, conf);
  }
#line 242
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 243
    return ((ngx_int_t )-1);
  }
#line 246
  if (ctx->uid_got[3] != 0U) {
    {
#line 247
    tmp = ngx_http_userid_variable(r->main, v, & conf->name, ctx->uid_got);
    }
#line 247
    return (tmp);
  }
#line 250
  v->not_found = 1U;
#line 252
  return ((ngx_int_t )0);
}
}
#line 256 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_set_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_userid_ctx_t *ctx ;
  ngx_http_userid_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 263
  conf = (ngx_http_userid_conf_t *)*((r->main)->loc_conf + ngx_http_userid_filter_module.ctx_index);
#line 265
  if (conf->enable < 2UL) {
#line 266
    v->not_found = 1U;
#line 267
    return ((ngx_int_t )0);
  }
  {
#line 270
  ctx = ngx_http_userid_get_uid(r->main, conf);
  }
#line 272
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 273
    return ((ngx_int_t )-1);
  }
  {
#line 276
  tmp = ngx_http_userid_create_uid(r->main, ctx, conf);
  }
#line 276
  if (tmp != 0L) {
#line 277
    return ((ngx_int_t )-1);
  }
#line 280
  if (ctx->uid_set[3] == 0U) {
#line 281
    v->not_found = 1U;
#line 282
    return ((ngx_int_t )0);
  }
  {
#line 285
  tmp___0 = ngx_http_userid_variable(r->main, v, & conf->name, ctx->uid_set);
  }
#line 285
  return (tmp___0);
}
}
#line 289 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_http_userid_ctx_t *ngx_http_userid_get_uid(ngx_http_request_t *r , ngx_http_userid_conf_t *conf ) 
{ 
  ngx_int_t n ;
  ngx_str_t src ;
  ngx_str_t dst ;
  ngx_table_elt_t **cookies ;
  ngx_http_userid_ctx_t *ctx ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 297
  ctx = (ngx_http_userid_ctx_t *)*(r->ctx + ngx_http_userid_filter_module.ctx_index);
#line 299
  if (ctx) {
#line 300
    return (ctx);
  }
#line 303
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 304
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t ));
#line 304
    ctx = (ngx_http_userid_ctx_t *)tmp;
    }
#line 305
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 306
      return ((ngx_http_userid_ctx_t *)((void *)0));
    }
#line 309
    *(r->ctx + ngx_http_userid_filter_module.ctx_index) = (void *)ctx;
  }
  {
#line 312
  n = ngx_http_parse_multi_header_lines(& r->headers_in.cookies, & conf->name, & ctx->cookie);
  }
#line 314
  if (n == -5L) {
#line 315
    return (ctx);
  }
#line 321
  if (ctx->cookie.len < 22UL) {
#line 322
    cookies = (ngx_table_elt_t **)r->headers_in.cookies.elts;
#line 323
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 323
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent too short userid cookie \"%V\"",
                         & (*(cookies + n))->value);
      }
    }
#line 326
    return (ctx);
  }
  {
#line 329
  src = ctx->cookie;
#line 338
  src.len = (size_t___0 )22;
#line 340
  dst.data = (u_char *)(ctx->uid_got);
#line 342
  tmp___0 = ngx_decode_base64(& dst, & src);
  }
#line 342
  if (tmp___0 == -1L) {
#line 343
    cookies = (ngx_table_elt_t **)r->headers_in.cookies.elts;
#line 344
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 344
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent invalid userid cookie \"%V\"",
                         & (*(cookies + n))->value);
      }
    }
#line 347
    return (ctx);
  }
#line 355
  return (ctx);
}
}
#line 359 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_set_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                         ngx_http_userid_conf_t *conf ) 
{ 
  u_char *cookie ;
  u_char *p ;
  size_t___0 len ;
  ngx_str_t src ;
  ngx_str_t dst ;
  ngx_table_elt_t *set_cookie ;
  ngx_table_elt_t *p3p ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;

  {
  {
#line 368
  tmp = ngx_http_userid_create_uid(r, ctx, conf);
  }
#line 368
  if (tmp != 0L) {
#line 369
    return ((ngx_int_t )-1);
  }
#line 372
  if (ctx->uid_set[3] == 0U) {
#line 373
    return ((ngx_int_t )0);
  }
#line 376
  len = ((conf->name.len + 1UL) + 24UL) + conf->path.len;
#line 378
  if (conf->expires) {
#line 379
    len += (sizeof(expires) - 1UL) + 2UL;
  }
#line 382
  if (conf->domain.len) {
#line 383
    len += conf->domain.len;
  }
  {
#line 386
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 386
  cookie = (u_char *)tmp___0;
  }
#line 387
  if ((unsigned long )cookie == (unsigned long )((void *)0)) {
#line 388
    return ((ngx_int_t )-1);
  }
  {
#line 391
  tmp___1 = memcpy((void */* __restrict  */)cookie, (void const   */* __restrict  */)conf->name.data,
                   conf->name.len);
#line 391
  p = (u_char *)tmp___1 + conf->name.len;
#line 392
  tmp___2 = p;
#line 392
  p ++;
#line 392
  *tmp___2 = (u_char )'=';
  }
#line 394
  if (ctx->uid_got[3] == 0U) {
#line 394
    goto _L;
  } else
#line 394
  if (ctx->reset) {
    _L: /* CIL Label */ 
    {
#line 395
    src.len = (size_t___0 )16;
#line 396
    src.data = (u_char *)(ctx->uid_set);
#line 397
    dst.data = p;
#line 399
    ngx_encode_base64(& dst, & src);
#line 401
    p += dst.len;
    }
#line 403
    if (conf->mark) {
#line 404
      *(p - 2) = conf->mark;
    }
  } else {
    {
#line 408
    tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ctx->cookie.data,
                     (size_t )22);
#line 408
    p = (u_char *)tmp___3 + 22;
#line 409
    tmp___4 = p;
#line 409
    p ++;
#line 409
    *tmp___4 = conf->mark;
#line 410
    tmp___5 = p;
#line 410
    p ++;
#line 410
    *tmp___5 = (u_char )'=';
    }
  }
#line 413
  if (conf->expires == 2145916555L) {
    {
#line 414
    tmp___6 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(expires),
                     sizeof(expires) - 1UL);
#line 414
    p = (u_char *)tmp___6 + (sizeof(expires) - 1UL);
    }
  } else
#line 416
  if (conf->expires) {
    {
#line 417
    tmp___7 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(expires),
                     sizeof("; expires=") - 1UL);
#line 417
    p = (u_char *)tmp___7 + (sizeof("; expires=") - 1UL);
#line 418
    p = ngx_http_cookie_time(p, (time_t )(ngx_cached_time->sec + (time_t volatile   )conf->expires));
    }
  }
  {
#line 421
  tmp___8 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)conf->domain.data,
                   conf->domain.len);
#line 421
  p = (u_char *)tmp___8 + conf->domain.len;
#line 423
  tmp___9 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)conf->path.data,
                   conf->path.len);
#line 423
  p = (u_char *)tmp___9 + conf->path.len;
#line 425
  tmp___10 = ngx_list_push(& r->headers_out.headers);
#line 425
  set_cookie = (ngx_table_elt_t *)tmp___10;
  }
#line 426
  if ((unsigned long )set_cookie == (unsigned long )((void *)0)) {
#line 427
    return ((ngx_int_t )-1);
  }
#line 430
  set_cookie->hash = (ngx_uint_t )1;
#line 431
  set_cookie->key.len = sizeof("Set-Cookie") - 1UL;
#line 431
  set_cookie->key.data = (u_char *)"Set-Cookie";
#line 432
  set_cookie->value.len = (size_t___0 )(p - cookie);
#line 433
  set_cookie->value.data = cookie;
#line 438
  if (conf->p3p.len == 0UL) {
#line 439
    return ((ngx_int_t )0);
  }
  {
#line 442
  tmp___11 = ngx_list_push(& r->headers_out.headers);
#line 442
  p3p = (ngx_table_elt_t *)tmp___11;
  }
#line 443
  if ((unsigned long )p3p == (unsigned long )((void *)0)) {
#line 444
    return ((ngx_int_t )-1);
  }
#line 447
  p3p->hash = (ngx_uint_t )1;
#line 448
  p3p->key.len = sizeof("P3P") - 1UL;
#line 448
  p3p->key.data = (u_char *)"P3P";
#line 449
  p3p->value = conf->p3p;
#line 451
  return ((ngx_int_t )0);
}
}
#line 455 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_create_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                            ngx_http_userid_conf_t *conf ) 
{ 
  ngx_connection_t *c ;
  struct sockaddr_in *sin ;
  ngx_http_variable_value_t *vv ;
  u_char *p ;
  struct sockaddr_in6 *sin6 ;
  int tmp ;
  ngx_int_t tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  unsigned int __v ;
  unsigned int __x ;
  unsigned int __v___0 ;
  unsigned int __x___0 ;
  unsigned int __v___1 ;
  unsigned int __x___1 ;
  unsigned int __v___2 ;
  unsigned int __x___2 ;

  {
#line 467
  if (ctx->uid_set[3] != 0U) {
#line 468
    return ((ngx_int_t )0);
  }
#line 471
  if (ctx->uid_got[3] != 0U) {
    {
#line 473
    vv = ngx_http_get_indexed_variable(r, ngx_http_userid_reset_index);
    }
#line 475
    if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 476
      return ((ngx_int_t )-1);
    } else
#line 475
    if (vv->not_found) {
#line 476
      return ((ngx_int_t )-1);
    }
#line 479
    if (vv->len == 0U) {
#line 479
      goto _L;
    } else
#line 479
    if (vv->len == 1U) {
#line 479
      if ((int )*(vv->data + 0) == 48) {
        _L: /* CIL Label */ 
#line 481
        if ((int )conf->mark == 0) {
#line 486
          return ((ngx_int_t )0);
        } else
#line 481
        if (ctx->cookie.len > 23UL) {
#line 481
          if ((int )*(ctx->cookie.data + 22) == (int )conf->mark) {
#line 481
            if ((int )*(ctx->cookie.data + 23) == 61) {
#line 486
              return ((ngx_int_t )0);
            }
          }
        }
#line 489
        ctx->uid_set[0] = ctx->uid_got[0];
#line 490
        ctx->uid_set[1] = ctx->uid_got[1];
#line 491
        ctx->uid_set[2] = ctx->uid_got[2];
#line 492
        ctx->uid_set[3] = ctx->uid_got[3];
#line 494
        return ((ngx_int_t )0);
      } else {
#line 479
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 497
      ctx->reset = (ngx_uint_t )1;
#line 499
      if (vv->len == 3U) {
        {
#line 499
        tmp = strncmp((char const   *)vv->data, "log", (size_t )3);
        }
#line 499
        if (tmp == 0) {
#line 500
          if (((r->connection)->log)->log_level >= 6UL) {
            {
#line 500
            ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "userid cookie \"%V=%08XD%08XD%08XD%08XD\" was reset",
                               & conf->name, ctx->uid_got[0], ctx->uid_got[1], ctx->uid_got[2],
                               ctx->uid_got[3]);
            }
          }
        }
      }
    }
  }
#line 513
  if (conf->enable == 2UL) {
#line 514
    if (conf->service == -1L) {
#line 515
      ctx->uid_set[0] = (uint32_t )0;
    } else {
#line 517
      ctx->uid_set[0] = (uint32_t )conf->service;
    }
#line 519
    ctx->uid_set[1] = (uint32_t )ngx_cached_time->sec;
#line 520
    ctx->uid_set[2] = start_value;
#line 521
    ctx->uid_set[3] = sequencer_v1;
#line 522
    sequencer_v1 += 256U;
  } else {
#line 525
    if (conf->service == -1L) {
      {
#line 527
      c = r->connection;
#line 529
      tmp___0 = ngx_connection_local_sockaddr(c, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
      }
#line 529
      if (tmp___0 != 0L) {
#line 530
        return ((ngx_int_t )-1);
      }
      {
#line 536
      if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 536
        goto case_10;
      }
#line 548
      goto switch_default;
      case_10: /* CIL Label */ 
#line 537
      sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 539
      p = (u_char *)(& ctx->uid_set[0]);
#line 541
      tmp___1 = p;
#line 541
      p ++;
#line 541
      *tmp___1 = sin6->sin6_addr.__in6_u.__u6_addr8[12];
#line 542
      tmp___2 = p;
#line 542
      p ++;
#line 542
      *tmp___2 = sin6->sin6_addr.__in6_u.__u6_addr8[13];
#line 543
      tmp___3 = p;
#line 543
      p ++;
#line 543
      *tmp___3 = sin6->sin6_addr.__in6_u.__u6_addr8[14];
#line 544
      *p = sin6->sin6_addr.__in6_u.__u6_addr8[15];
#line 546
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 549
      sin = (struct sockaddr_in *)c->local_sockaddr;
#line 550
      ctx->uid_set[0] = sin->sin_addr.s_addr;
#line 551
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 555
      __x = (unsigned int )conf->service;
#line 555
      __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 555
      ctx->uid_set[0] = __v;
    }
#line 558
    __x___0 = (uint32_t )ngx_cached_time->sec;
#line 558
    __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 558
    ctx->uid_set[1] = __v___0;
#line 559
    __x___1 = start_value;
#line 559
    __asm__  ("bswap %0": "=r" (__v___1): "0" (__x___1));
#line 559
    ctx->uid_set[2] = __v___1;
#line 560
    __x___2 = sequencer_v2;
#line 560
    __asm__  ("bswap %0": "=r" (__v___2): "0" (__x___2));
#line 560
    ctx->uid_set[3] = __v___2;
#line 561
    sequencer_v2 += 256U;
#line 562
    if (sequencer_v2 < 50529026U) {
#line 563
      sequencer_v2 = (uint32_t )50529026;
    }
  }
#line 567
  return ((ngx_int_t )0);
}
}
#line 571 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          ngx_str_t *name , uint32_t *uid ) 
{ 
  void *tmp ;

  {
  {
#line 575
  v->len = (unsigned int )((name->len + sizeof("=00001111222233334444555566667777")) - 1UL);
#line 576
  tmp = ngx_pnalloc(r->pool, (size_t___0 )v->len);
#line 576
  v->data = (u_char *)tmp;
  }
#line 577
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 578
    return ((ngx_int_t )-1);
  }
  {
#line 581
  v->valid = 1U;
#line 582
  v->no_cacheable = 0U;
#line 583
  v->not_found = 0U;
#line 585
  ngx_sprintf(v->data, "%V=%08XD%08XD%08XD%08XD", name, *(uid + 0), *(uid + 1), *(uid + 2),
              *(uid + 3));
  }
#line 588
  return ((ngx_int_t )0);
}
}
#line 592 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_reset_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 


  {
#line 596
  *v = ngx_http_variable_null_value;
#line 598
  return ((ngx_int_t )0);
}
}
#line 602 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_int_t n ;
  ngx_http_variable_t *var ;

  {
  {
#line 608
  var = ngx_http_add_variable(cf, & ngx_http_userid_got, (ngx_uint_t )0);
  }
#line 609
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 610
    return ((ngx_int_t )-1);
  }
  {
#line 613
  var->get_handler = & ngx_http_userid_got_variable;
#line 615
  var = ngx_http_add_variable(cf, & ngx_http_userid_set, (ngx_uint_t )0);
  }
#line 616
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 617
    return ((ngx_int_t )-1);
  }
  {
#line 620
  var->get_handler = & ngx_http_userid_set_variable;
#line 622
  var = ngx_http_add_variable(cf, & ngx_http_userid_reset, (ngx_uint_t )1);
  }
#line 624
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 625
    return ((ngx_int_t )-1);
  }
  {
#line 628
  var->get_handler = & ngx_http_userid_reset_variable;
#line 630
  n = ngx_http_get_variable_index(cf, & ngx_http_userid_reset);
  }
#line 631
  if (n == -1L) {
#line 632
    return ((ngx_int_t )-1);
  }
#line 635
  ngx_http_userid_reset_index = (ngx_uint_t )n;
#line 637
  return ((ngx_int_t )0);
}
}
#line 641 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static void *ngx_http_userid_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_userid_conf_t *conf ;
  void *tmp ;

  {
  {
#line 646
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_userid_conf_t ));
#line 646
  conf = (ngx_http_userid_conf_t *)tmp;
  }
#line 647
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 648
    return ((void *)0);
  }
#line 660
  conf->enable = (ngx_uint_t )-1;
#line 661
  conf->service = (ngx_int_t )-1;
#line 662
  conf->expires = (time_t )-1;
#line 663
  conf->mark = (u_char )'\377';
#line 665
  return ((void *)conf);
}
}
#line 669 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_userid_conf_t *prev ;
  ngx_http_userid_conf_t *conf ;

  {
#line 672
  prev = (ngx_http_userid_conf_t *)parent;
#line 673
  conf = (ngx_http_userid_conf_t *)child;
#line 675
  if (conf->enable == 0xffffffffffffffffUL) {
#line 675
    if (prev->enable == 0xffffffffffffffffUL) {
#line 675
      conf->enable = (ngx_uint_t )0;
    } else {
#line 675
      conf->enable = prev->enable;
    }
  }
#line 678
  if ((unsigned long )conf->name.data == (unsigned long )((void *)0)) {
#line 678
    if (prev->name.data) {
#line 678
      conf->name.len = prev->name.len;
#line 678
      conf->name.data = prev->name.data;
    } else {
#line 678
      conf->name.len = sizeof("uid") - 1UL;
#line 678
      conf->name.data = (u_char *)"uid";
    }
  }
#line 679
  if ((unsigned long )conf->domain.data == (unsigned long )((void *)0)) {
#line 679
    if (prev->domain.data) {
#line 679
      conf->domain.len = prev->domain.len;
#line 679
      conf->domain.data = prev->domain.data;
    } else {
#line 679
      conf->domain.len = sizeof("") - 1UL;
#line 679
      conf->domain.data = (u_char *)"";
    }
  }
#line 680
  if ((unsigned long )conf->path.data == (unsigned long )((void *)0)) {
#line 680
    if (prev->path.data) {
#line 680
      conf->path.len = prev->path.len;
#line 680
      conf->path.data = prev->path.data;
    } else {
#line 680
      conf->path.len = sizeof("; path=/") - 1UL;
#line 680
      conf->path.data = (u_char *)"; path=/";
    }
  }
#line 681
  if ((unsigned long )conf->p3p.data == (unsigned long )((void *)0)) {
#line 681
    if (prev->p3p.data) {
#line 681
      conf->p3p.len = prev->p3p.len;
#line 681
      conf->p3p.data = prev->p3p.data;
    } else {
#line 681
      conf->p3p.len = sizeof("") - 1UL;
#line 681
      conf->p3p.data = (u_char *)"";
    }
  }
#line 683
  if (conf->service == -1L) {
#line 683
    if (prev->service == -1L) {
#line 683
      conf->service = (ngx_int_t )-1;
    } else {
#line 683
      conf->service = prev->service;
    }
  }
#line 684
  if (conf->expires == -1L) {
#line 684
    if (prev->expires == -1L) {
#line 684
      conf->expires = (time_t )0;
    } else {
#line 684
      conf->expires = prev->expires;
    }
  }
#line 686
  if ((int )conf->mark == 255) {
#line 687
    if ((int )prev->mark == 255) {
#line 688
      conf->mark = (u_char )'\000';
    } else {
#line 690
      conf->mark = prev->mark;
    }
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 698 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_init(ngx_conf_t *cf ) 
{ 


  {
#line 701
  ngx_http_next_header_filter___1 = ngx_http_top_header_filter;
#line 702
  ngx_http_top_header_filter = & ngx_http_userid_filter;
#line 704
  return ((ngx_int_t )0);
}
}
#line 708 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_domain(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_str_t *domain ;
  u_char *p ;
  u_char *new ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 711
  domain = (ngx_str_t *)data;
#line 715
  tmp = strcmp((char const   *)domain->data, "none");
  }
#line 715
  if (tmp == 0) {
#line 716
    domain->len = sizeof("") - 1UL;
#line 716
    domain->data = (u_char *)"";
#line 717
    return ((char *)((void *)0));
  }
  {
#line 720
  tmp___0 = ngx_pnalloc(cf->pool, (sizeof("; domain=") - 1UL) + domain->len);
#line 720
  new = (u_char *)tmp___0;
  }
#line 721
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 722
    return ((char *)((void *)-1));
  }
  {
#line 725
  tmp___1 = memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)"; domain=",
                   sizeof("; domain=") - 1UL);
#line 725
  p = (u_char *)tmp___1 + (sizeof("; domain=") - 1UL);
#line 726
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)domain->data,
         domain->len);
#line 728
  domain->len += sizeof("; domain=") - 1UL;
#line 729
  domain->data = new;
  }
#line 731
  return ((char *)((void *)0));
}
}
#line 735 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_path(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_str_t *path ;
  u_char *p ;
  u_char *new ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 738
  path = (ngx_str_t *)data;
#line 742
  tmp = ngx_pnalloc(cf->pool, (sizeof("; path=") - 1UL) + path->len);
#line 742
  new = (u_char *)tmp;
  }
#line 743
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 744
    return ((char *)((void *)-1));
  }
  {
#line 747
  tmp___0 = memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)"; path=",
                   sizeof("; path=") - 1UL);
#line 747
  p = (u_char *)tmp___0 + (sizeof("; path=") - 1UL);
#line 748
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)path->data,
         path->len);
#line 750
  path->len += sizeof("; path=") - 1UL;
#line 751
  path->data = new;
  }
#line 753
  return ((char *)((void *)0));
}
}
#line 757 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_userid_conf_t *ucf ;
  ngx_str_t *value ;
  int tmp ;
  int tmp___0 ;

  {
#line 760
  ucf = (ngx_http_userid_conf_t *)conf;
#line 764
  if (ucf->expires != -1L) {
#line 765
    return ((char *)"is duplicate");
  }
  {
#line 768
  value = (ngx_str_t *)(cf->args)->elts;
#line 770
  tmp = strcmp((char const   *)(value + 1)->data, "max");
  }
#line 770
  if (tmp == 0) {
#line 771
    ucf->expires = (time_t )2145916555;
#line 772
    return ((char *)((void *)0));
  }
  {
#line 775
  tmp___0 = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 775
  if (tmp___0 == 0) {
#line 776
    ucf->expires = (time_t )0;
#line 777
    return ((char *)((void *)0));
  }
  {
#line 780
  ucf->expires = ngx_parse_time(value + 1, (ngx_uint_t )1);
  }
#line 781
  if (ucf->expires == -1L) {
#line 782
    return ((char *)"invalid value");
  }
#line 785
  return ((char *)((void *)0));
}
}
#line 789 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_p3p(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_str_t *p3p ;
  int tmp ;

  {
  {
#line 792
  p3p = (ngx_str_t *)data;
#line 794
  tmp = strcmp((char const   *)p3p->data, "none");
  }
#line 794
  if (tmp == 0) {
#line 795
    p3p->len = sizeof("") - 1UL;
#line 795
    p3p->data = (u_char *)"";
  }
#line 798
  return ((char *)((void *)0));
}
}
#line 802 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_mark(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_userid_conf_t *ucf ;
  ngx_str_t *value ;
  int tmp ;

  {
#line 805
  ucf = (ngx_http_userid_conf_t *)conf;
#line 809
  if ((int )ucf->mark != 255) {
#line 810
    return ((char *)"is duplicate");
  }
  {
#line 813
  value = (ngx_str_t *)(cf->args)->elts;
#line 815
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 815
  if (tmp == 0) {
#line 816
    ucf->mark = (u_char )'\000';
#line 817
    return ((char *)((void *)0));
  }
#line 820
  if ((value + 1)->len != 1UL) {
#line 826
    return ((char *)"value must be \"off\" or a single letter, digit or \"=\"");
  } else
#line 820
  if ((int )*((value + 1)->data + 0) >= 48) {
#line 820
    if (! ((int )*((value + 1)->data + 0) <= 57)) {
#line 820
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 820
  if ((int )*((value + 1)->data + 0) >= 65) {
#line 820
    if (! ((int )*((value + 1)->data + 0) <= 90)) {
#line 820
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 820
  if ((int )*((value + 1)->data + 0) >= 97) {
#line 820
    if (! ((int )*((value + 1)->data + 0) <= 122)) {
#line 820
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 820
  if (! ((int )*((value + 1)->data + 0) == 61)) {
#line 826
    return ((char *)"value must be \"off\" or a single letter, digit or \"=\"");
  }
#line 829
  ucf->mark = *((value + 1)->data + 0);
#line 831
  return ((char *)((void *)0));
}
}
#line 835 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_init_worker(ngx_cycle_t *cycle ) 
{ 
  struct timeval tp ;

  {
  {
#line 840
  gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 843
  start_value = ((uint32_t )tp.tv_usec / 20U << 16) | (unsigned int )ngx_pid;
  }
#line 845
  return ((ngx_int_t )0);
}
}
#line 177 "src/core/ngx_string.h"
ngx_int_t ngx_hextoi(u_char *line , size_t___0 n ) ;
#line 190
uint32_t ngx_utf8_decode(u_char **p , size_t___0 n ) ;
#line 495 "src/http/ngx_http_core_module.h"
void *ngx_http_test_content_type(ngx_http_request_t *r , ngx_hash_t *types_hash ) ;
#line 154 "src/http/ngx_http.h"
char *ngx_http_types_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 155
char *ngx_http_merge_types(ngx_conf_t *cf , ngx_array_t **keys , ngx_hash_t *types_hash ,
                           ngx_array_t **prev_keys , ngx_hash_t *prev_types_hash ,
                           ngx_str_t *default_types ) ;
#line 88 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_destination_charset(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 90
static ngx_int_t ngx_http_main_request_charset(ngx_http_request_t *r , ngx_str_t *src ) ;
#line 92
static ngx_int_t ngx_http_source_charset(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 94
static ngx_int_t ngx_http_get_charset(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 95
__inline static void ngx_http_set_charset(ngx_http_request_t *r , ngx_str_t *charset ) ;
#line 97
static ngx_int_t ngx_http_charset_ctx(ngx_http_request_t *r , ngx_http_charset_t *charsets ,
                                      ngx_int_t charset , ngx_int_t source_charset ) ;
#line 99
static ngx_uint_t ngx_http_charset_recode(ngx_buf_t *b , u_char *table ) ;
#line 100
static ngx_chain_t *ngx_http_charset_recode_from_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                      ngx_http_charset_ctx_t *ctx ) ;
#line 102
static ngx_chain_t *ngx_http_charset_recode_to_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                    ngx_http_charset_ctx_t *ctx ) ;
#line 105
static ngx_chain_t *ngx_http_charset_get_buf(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ) ;
#line 107
static ngx_chain_t *ngx_http_charset_get_buffer(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ,
                                                size_t___0 size ) ;
#line 110
static char *ngx_http_charset_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 112
static char *ngx_http_charset_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 115
static char *ngx_http_set_charset_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 117
static ngx_int_t ngx_http_add_charset(ngx_array_t *charsets , ngx_str_t *name ) ;
#line 119
static void *ngx_http_charset_create_main_conf(ngx_conf_t *cf ) ;
#line 120
static void *ngx_http_charset_create_loc_conf(ngx_conf_t *cf ) ;
#line 121
static char *ngx_http_charset_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 123
static ngx_int_t ngx_http_charset_postconfiguration(ngx_conf_t *cf ) ;
#line 126 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_str_t ngx_http_charset_default_types[7]  = {      {sizeof("text/html") - 1UL, (u_char *)"text/html"}, 
        {sizeof("text/xml") - 1UL, (u_char *)"text/xml"}, 
        {sizeof("text/plain") - 1UL, (u_char *)"text/plain"}, 
        {sizeof("text/vnd.wap.wml") - 1UL, (u_char *)"text/vnd.wap.wml"}, 
        {sizeof("application/javascript") - 1UL, (u_char *)"application/javascript"}, 
        {sizeof("application/rss+xml") - 1UL,
      (u_char *)"application/rss+xml"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}};
#line 137 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_command_t ngx_http_charset_filter_commands[6]  = {      {{sizeof("charset") - 1UL, (u_char *)"charset"}, (ngx_uint_t )1308622850, & ngx_http_set_charset_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->charset),
      (void *)0}, 
        {{sizeof("source_charset") - 1UL, (u_char *)"source_charset"}, (ngx_uint_t )1308622850,
      & ngx_http_set_charset_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->source_charset), (void *)0}, 
        {{sizeof("override_charset") - 1UL,
       (u_char *)"override_charset"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->override_charset),
      (void *)0}, 
        {{sizeof("charset_types") - 1UL, (u_char *)"charset_types"}, (ngx_uint_t )234883072,
      & ngx_http_types_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->types_keys), (void *)(& ngx_http_charset_default_types[0])}, 
        {{sizeof("charset_map") - 1UL,
       (u_char *)"charset_map"}, (ngx_uint_t )33554692, & ngx_http_charset_map_block,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 181 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_http_module_t ngx_http_charset_filter_module_ctx  = 
#line 181
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_charset_postconfiguration,
    & ngx_http_charset_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_charset_create_loc_conf, & ngx_http_charset_merge_loc_conf};
#line 196 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
ngx_module_t ngx_http_charset_filter_module  = 
#line 196
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_charset_filter_module_ctx),
    ngx_http_charset_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 212 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___2)(ngx_http_request_t *r )  ;
#line 213 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___1)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 216 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_int_t charset ;
  ngx_int_t source_charset ;
  ngx_str_t dst ;
  ngx_str_t src ;
  ngx_http_charset_t *charsets ;
  ngx_http_charset_main_conf_t *mcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;

  {
#line 224
  if ((unsigned long )r == (unsigned long )r->main) {
    {
#line 225
    charset = ngx_http_destination_charset(r, & dst);
    }
  } else {
    {
#line 228
    charset = ngx_http_main_request_charset(r, & dst);
    }
  }
#line 231
  if (charset == -1L) {
#line 232
    return ((ngx_int_t )-1);
  }
#line 235
  if (charset == -5L) {
    {
#line 236
    tmp = (*ngx_http_next_header_filter___2)(r);
    }
#line 236
    return (tmp);
  }
  {
#line 241
  source_charset = ngx_http_source_charset(r, & src);
  }
#line 243
  if (source_charset == -1L) {
#line 244
    return ((ngx_int_t )-1);
  }
#line 255
  if (source_charset == -2L) {
    {
#line 256
    ngx_http_set_charset(r, & dst);
#line 258
    tmp___0 = (*ngx_http_next_header_filter___2)(r);
    }
#line 258
    return (tmp___0);
  }
#line 261
  if (charset == -3L) {
#line 261
    goto _L;
  } else
#line 261
  if (source_charset == -3L) {
    _L: /* CIL Label */ 
#line 264
    if (source_charset != charset) {
#line 267
      goto no_charset_map;
    } else {
      {
#line 264
      tmp___1 = ngx_strncasecmp(dst.data, src.data, dst.len);
      }
#line 264
      if (tmp___1 != 0L) {
#line 267
        goto no_charset_map;
      }
    }
    {
#line 270
    ngx_http_set_charset(r, & dst);
#line 272
    tmp___2 = (*ngx_http_next_header_filter___2)(r);
    }
#line 272
    return (tmp___2);
  }
#line 275
  if (source_charset == charset) {
    {
#line 276
    r->headers_out.content_type.len = r->headers_out.content_type_len;
#line 278
    ngx_http_set_charset(r, & dst);
#line 280
    tmp___3 = (*ngx_http_next_header_filter___2)(r);
    }
#line 280
    return (tmp___3);
  }
#line 285
  if (r->headers_out.content_encoding) {
#line 285
    if ((r->headers_out.content_encoding)->value.len) {
      {
#line 288
      tmp___4 = (*ngx_http_next_header_filter___2)(r);
      }
#line 288
      return (tmp___4);
    }
  }
#line 291
  mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 292
  charsets = (ngx_http_charset_t *)mcf->charsets.elts;
#line 294
  if ((unsigned long )(charsets + source_charset)->tables == (unsigned long )((void *)0)) {
#line 297
    goto no_charset_map;
  } else
#line 294
  if ((unsigned long )*((charsets + source_charset)->tables + charset) == (unsigned long )((void *)0)) {
#line 297
    goto no_charset_map;
  }
  {
#line 300
  r->headers_out.content_type.len = r->headers_out.content_type_len;
#line 302
  ngx_http_set_charset(r, & dst);
#line 304
  tmp___5 = ngx_http_charset_ctx(r, charsets, charset, source_charset);
  }
#line 304
  return (tmp___5);
  no_charset_map: 
#line 308
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 308
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no \"charset_map\" between the charsets \"%V\" and \"%V\"",
                       & src, & dst);
    }
  }
  {
#line 312
  tmp___6 = (*ngx_http_next_header_filter___2)(r);
  }
#line 312
  return (tmp___6);
}
}
#line 316 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_destination_charset(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_int_t charset ;
  ngx_http_charset_t *charsets ;
  ngx_http_variable_value_t *vv ;
  ngx_http_charset_loc_conf_t *mlcf ;
  ngx_http_charset_main_conf_t *mcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 325
  if (r->headers_out.content_type.len == 0UL) {
#line 326
    return ((ngx_int_t )-5);
  }
#line 329
  if (r->headers_out.override_charset) {
#line 329
    if ((r->headers_out.override_charset)->len) {
      {
#line 332
      *name = *(r->headers_out.override_charset);
#line 334
      charset = ngx_http_get_charset(r, name);
      }
#line 336
      if (charset != -3L) {
#line 337
        return (charset);
      }
#line 340
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 340
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unknown charset \"%V\" to override",
                           name);
        }
      }
#line 343
      return ((ngx_int_t )-5);
    }
  }
#line 346
  mlcf = (ngx_http_charset_loc_conf_t *)*(r->loc_conf + ngx_http_charset_filter_module.ctx_index);
#line 347
  charset = mlcf->charset;
#line 349
  if (charset == -2L) {
#line 350
    return ((ngx_int_t )-5);
  }
#line 353
  if (r->headers_out.charset.len) {
#line 354
    if (mlcf->override_charset == 0L) {
#line 355
      return ((ngx_int_t )-5);
    }
  } else {
    {
#line 359
    tmp = ngx_http_test_content_type(r, & mlcf->types);
    }
#line 359
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 360
      return ((ngx_int_t )-5);
    }
  }
#line 364
  if (charset < 65536L) {
#line 365
    mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 366
    charsets = (ngx_http_charset_t *)mcf->charsets.elts;
#line 367
    *name = (charsets + charset)->name;
#line 368
    return (charset);
  }
  {
#line 371
  vv = ngx_http_get_indexed_variable(r, (ngx_uint_t )(charset - 65536L));
  }
#line 373
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 374
    return ((ngx_int_t )-1);
  } else
#line 373
  if (vv->not_found) {
#line 374
    return ((ngx_int_t )-1);
  }
  {
#line 377
  name->len = (size_t___0 )vv->len;
#line 378
  name->data = vv->data;
#line 380
  tmp___0 = ngx_http_get_charset(r, name);
  }
#line 380
  return (tmp___0);
}
}
#line 384 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_main_request_charset(ngx_http_request_t *r , ngx_str_t *src ) 
{ 
  ngx_int_t charset ;
  ngx_str_t *main_charset ;
  ngx_http_charset_ctx_t *ctx ;
  void *tmp ;

  {
#line 391
  ctx = (ngx_http_charset_ctx_t *)*((r->main)->ctx + ngx_http_charset_filter_module.ctx_index);
#line 393
  if (ctx) {
#line 394
    *src = ctx->charset_name;
#line 395
    return (ctx->charset);
  }
#line 398
  main_charset = & (r->main)->headers_out.charset;
#line 400
  if (main_charset->len == 0UL) {
#line 401
    return ((ngx_int_t )-5);
  }
  {
#line 404
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_charset_ctx_t ));
#line 404
  ctx = (ngx_http_charset_ctx_t *)tmp;
  }
#line 405
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 406
    return ((ngx_int_t )-1);
  }
  {
#line 409
  *((r->main)->ctx + ngx_http_charset_filter_module.ctx_index) = (void *)ctx;
#line 411
  charset = ngx_http_get_charset(r, main_charset);
#line 413
  ctx->charset = charset;
#line 414
  ctx->charset_name = *main_charset;
#line 415
  *src = *main_charset;
  }
#line 417
  return (charset);
}
}
#line 421 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_source_charset(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_int_t charset ;
  ngx_http_charset_t *charsets ;
  ngx_http_variable_value_t *vv ;
  ngx_http_charset_loc_conf_t *lcf ;
  ngx_http_charset_main_conf_t *mcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 430
  if (r->headers_out.charset.len) {
    {
#line 431
    *name = r->headers_out.charset;
#line 432
    tmp = ngx_http_get_charset(r, name);
    }
#line 432
    return (tmp);
  }
#line 435
  lcf = (ngx_http_charset_loc_conf_t *)*(r->loc_conf + ngx_http_charset_filter_module.ctx_index);
#line 437
  charset = lcf->source_charset;
#line 439
  if (charset == -2L) {
#line 440
    name->len = (size_t___0 )0;
#line 441
    return (charset);
  }
#line 444
  if (charset < 65536L) {
#line 445
    mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 446
    charsets = (ngx_http_charset_t *)mcf->charsets.elts;
#line 447
    *name = (charsets + charset)->name;
#line 448
    return (charset);
  }
  {
#line 451
  vv = ngx_http_get_indexed_variable(r, (ngx_uint_t )(charset - 65536L));
  }
#line 453
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 454
    return ((ngx_int_t )-1);
  } else
#line 453
  if (vv->not_found) {
#line 454
    return ((ngx_int_t )-1);
  }
  {
#line 457
  name->len = (size_t___0 )vv->len;
#line 458
  name->data = vv->data;
#line 460
  tmp___0 = ngx_http_get_charset(r, name);
  }
#line 460
  return (tmp___0);
}
}
#line 464 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_get_charset(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_charset_t *charset ;
  ngx_http_charset_main_conf_t *mcf ;
  ngx_int_t tmp ;

  {
#line 471
  mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 473
  charset = (ngx_http_charset_t *)mcf->charsets.elts;
#line 474
  n = mcf->charsets.nelts;
#line 476
  i = (ngx_uint_t )0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (i < n)) {
#line 476
      goto while_break;
    }
#line 477
    if ((charset + i)->name.len != name->len) {
#line 478
      goto __Cont;
    }
    {
#line 481
    tmp = ngx_strncasecmp((charset + i)->name.data, name->data, name->len);
    }
#line 481
    if (tmp == 0L) {
#line 482
      return ((ngx_int_t )i);
    }
    __Cont: /* CIL Label */ 
#line 476
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return ((ngx_int_t )-3);
}
}
#line 490 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
__inline static void ngx_http_set_charset(ngx_http_request_t *r , ngx_str_t *charset ) 
{ 


  {
#line 493
  if ((unsigned long )r != (unsigned long )r->main) {
#line 494
    return;
  }
#line 497
  if (r->headers_out.status == 301UL) {
#line 505
    r->headers_out.charset.len = (size_t___0 )0;
#line 506
    return;
  } else
#line 497
  if (r->headers_out.status == 302UL) {
#line 505
    r->headers_out.charset.len = (size_t___0 )0;
#line 506
    return;
  }
#line 509
  r->headers_out.charset = *charset;
#line 510
  return;
}
}
#line 513 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_ctx(ngx_http_request_t *r , ngx_http_charset_t *charsets ,
                                      ngx_int_t charset , ngx_int_t source_charset ) 
{ 
  ngx_http_charset_ctx_t *ctx ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 519
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_charset_ctx_t ));
#line 519
  ctx = (ngx_http_charset_ctx_t *)tmp;
  }
#line 520
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 521
    return ((ngx_int_t )-1);
  }
#line 524
  *(r->ctx + ngx_http_charset_filter_module.ctx_index) = (void *)ctx;
#line 526
  ctx->table = *((charsets + source_charset)->tables + charset);
#line 527
  ctx->charset = charset;
#line 528
  ctx->charset_name = (charsets + charset)->name;
#line 529
  ctx->length = (charsets + charset)->length;
#line 530
  ctx->from_utf8 = (charsets + source_charset)->utf8;
#line 531
  ctx->to_utf8 = (charsets + charset)->utf8;
#line 533
  r->filter_need_in_memory = 1U;
#line 535
  if (ctx->to_utf8) {
#line 535
    goto _L;
  } else
#line 535
  if (ctx->from_utf8) {
    _L: /* CIL Label */ 
#line 535
    if ((unsigned long )r == (unsigned long )r->main) {
#line 536
      r->headers_out.content_length_n = (off_t )-1;
#line 536
      if (r->headers_out.content_length) {
#line 536
        (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 536
        r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
      }
    } else {
#line 539
      r->filter_need_temporary = 1U;
    }
  } else {
#line 539
    r->filter_need_temporary = 1U;
  }
  {
#line 542
  tmp___0 = (*ngx_http_next_header_filter___2)(r);
  }
#line 542
  return (tmp___0);
}
}
#line 546 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_http_charset_ctx_t *ctx ;
  ngx_int_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 554
  ctx = (ngx_http_charset_ctx_t *)*(r->ctx + ngx_http_charset_filter_module.ctx_index);
#line 556
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 557
    tmp = (*ngx_http_next_body_filter___1)(r, in);
    }
#line 557
    return (tmp);
  } else
#line 556
  if ((unsigned long )ctx->table == (unsigned long )((void *)0)) {
    {
#line 557
    tmp = (*ngx_http_next_body_filter___1)(r, in);
    }
#line 557
    return (tmp);
  }
#line 560
  if (ctx->to_utf8) {
#line 560
    goto _L;
  } else
#line 560
  if (ctx->from_utf8) {
#line 560
    goto _L;
  } else
#line 560
  if (ctx->busy) {
    _L: /* CIL Label */ 
#line 562
    out = (ngx_chain_t *)((void *)0);
#line 563
    ll = & out;
#line 565
    cl = in;
    {
#line 565
    while (1) {
      while_continue: /* CIL Label */ ;
#line 565
      if (! cl) {
#line 565
        goto while_break;
      }
#line 566
      b = cl->buf;
#line 568
      if (b->temporary) {
#line 568
        tmp___0 = b->last - b->pos;
      } else
#line 568
      if (b->memory) {
#line 568
        tmp___0 = b->last - b->pos;
      } else
#line 568
      if (b->mmap) {
#line 568
        tmp___0 = b->last - b->pos;
      } else {
#line 568
        tmp___0 = b->file_last - b->file_pos;
      }
#line 568
      if (tmp___0 == 0L) {
        {
#line 570
        *ll = ngx_alloc_chain_link(r->pool);
        }
#line 571
        if ((unsigned long )*ll == (unsigned long )((void *)0)) {
#line 572
          return ((ngx_int_t )-1);
        }
#line 575
        (*ll)->buf = b;
#line 576
        (*ll)->next = (ngx_chain_t *)((void *)0);
#line 578
        ll = & (*ll)->next;
#line 580
        goto __Cont;
      }
#line 583
      if (ctx->to_utf8) {
        {
#line 584
        *ll = ngx_http_charset_recode_to_utf8(r->pool, b, ctx);
        }
      } else {
        {
#line 587
        *ll = ngx_http_charset_recode_from_utf8(r->pool, b, ctx);
        }
      }
#line 590
      if ((unsigned long )*ll == (unsigned long )((void *)0)) {
#line 591
        return ((ngx_int_t )-1);
      }
      {
#line 594
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 594
        if (! *ll) {
#line 594
          goto while_break___0;
        }
#line 595
        ll = & (*ll)->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 565
      cl = cl->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 599
    rc = (*ngx_http_next_body_filter___1)(r, out);
    }
#line 601
    if (out) {
#line 602
      if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 603
        ctx->busy = out;
      } else {
#line 606
        cl = ctx->busy;
        {
#line 606
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 606
          if (! cl->next) {
#line 606
            goto while_break___1;
          }
#line 606
          cl = cl->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 607
        cl->next = out;
      }
    }
    {
#line 611
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 611
      if (! ctx->busy) {
#line 611
        goto while_break___2;
      }
#line 613
      cl = ctx->busy;
#line 614
      b = cl->buf;
#line 616
      if (b->temporary) {
#line 616
        tmp___1 = b->last - b->pos;
      } else
#line 616
      if (b->memory) {
#line 616
        tmp___1 = b->last - b->pos;
      } else
#line 616
      if (b->mmap) {
#line 616
        tmp___1 = b->last - b->pos;
      } else {
#line 616
        tmp___1 = b->file_last - b->file_pos;
      }
#line 616
      if (tmp___1 != 0L) {
#line 617
        goto while_break___2;
      }
#line 620
      ctx->busy = cl->next;
#line 622
      if ((unsigned long )b->tag != (unsigned long )((ngx_buf_tag_t )(& ngx_http_charset_filter_module))) {
#line 623
        goto while_continue___2;
      }
#line 626
      if (b->shadow) {
#line 627
        (b->shadow)->pos = (b->shadow)->last;
      }
#line 630
      if (b->pos) {
#line 631
        cl->next = ctx->free_buffers;
#line 632
        ctx->free_buffers = cl;
#line 633
        goto while_continue___2;
      }
#line 636
      cl->next = ctx->free_bufs;
#line 637
      ctx->free_bufs = cl;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 640
    return (rc);
  }
#line 643
  cl = in;
  {
#line 643
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 643
    if (! cl) {
#line 643
      goto while_break___3;
    }
    {
#line 644
    ngx_http_charset_recode(cl->buf, ctx->table);
#line 643
    cl = cl->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 647
  tmp___2 = (*ngx_http_next_body_filter___1)(r, in);
  }
#line 647
  return (tmp___2);
}
}
#line 651 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_uint_t ngx_http_charset_recode(ngx_buf_t *b , u_char *table ) 
{ 
  u_char *p ;
  u_char *last ;

  {
#line 656
  last = b->last;
#line 658
  p = b->pos;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 658
      goto while_break;
    }
#line 660
    if ((int )*p != (int )*(table + *p)) {
#line 661
      goto recode;
    }
#line 658
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 665
  return ((ngx_uint_t )0);
  recode: 
  {
#line 669
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 670
    if ((int )*p != (int )*(table + *p)) {
#line 671
      *p = *(table + *p);
    }
#line 674
    p ++;
#line 669
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 669
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 678
  b->in_file = 0U;
#line 680
  return ((ngx_uint_t )1);
}
}
#line 684 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_recode_from_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                      ngx_http_charset_ctx_t *ctx ) 
{ 
  size_t___0 len ;
  size_t___0 size ;
  u_char c ;
  u_char *p ;
  u_char *src ;
  u_char *dst ;
  u_char *saved ;
  u_char **table ;
  uint32_t n ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 695
  src = buf->pos;
#line 697
  if (ctx->saved_len == 0UL) {
    {
#line 699
    while (1) {
      while_continue: /* CIL Label */ ;
#line 699
      if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 699
        goto while_break;
      }
#line 701
      if ((int )*src < 128) {
#line 702
        goto __Cont;
      }
#line 705
      len = (size_t___0 )(src - buf->pos);
#line 707
      if (len > 512UL) {
        {
#line 708
        out = ngx_http_charset_get_buf(pool, ctx);
        }
#line 709
        if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 710
          return ((ngx_chain_t *)((void *)0));
        }
        {
#line 713
        b = out->buf;
#line 715
        b->temporary = buf->temporary;
#line 716
        b->memory = buf->memory;
#line 717
        b->mmap = buf->mmap;
#line 718
        b->flush = buf->flush;
#line 720
        b->pos = buf->pos;
#line 721
        b->last = src;
#line 723
        out->buf = b;
#line 724
        out->next = (ngx_chain_t *)((void *)0);
#line 726
        size = (size_t___0 )(buf->last - src);
#line 728
        saved = src;
#line 729
        n = ngx_utf8_decode(& saved, size);
        }
#line 731
        if (n == 4294967294U) {
          {
#line 734
          memcpy((void */* __restrict  */)(ctx->saved), (void const   */* __restrict  */)src,
                 size);
#line 735
          ctx->saved_len = size;
#line 737
          b->shadow = buf;
          }
#line 739
          return (out);
        }
      } else {
#line 743
        out = (ngx_chain_t *)((void *)0);
#line 744
        size = (size_t___0 )((buf->last + len) - src);
#line 745
        src = buf->pos;
      }
#line 748
      if (size < sizeof("&#1114111;") - 1UL) {
#line 749
        size += sizeof("&#1114111;") - 1UL;
      }
      {
#line 752
      cl = ngx_http_charset_get_buffer(pool, ctx, size);
      }
#line 753
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 754
        return ((ngx_chain_t *)((void *)0));
      }
#line 757
      if (out) {
#line 758
        out->next = cl;
      } else {
#line 761
        out = cl;
      }
#line 764
      b = cl->buf;
#line 765
      dst = b->pos;
#line 767
      goto recode;
      __Cont: /* CIL Label */ 
#line 699
      src ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 770
    out = ngx_alloc_chain_link(pool);
    }
#line 771
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 772
      return ((ngx_chain_t *)((void *)0));
    }
#line 775
    out->buf = buf;
#line 776
    out->next = (ngx_chain_t *)((void *)0);
#line 778
    return (out);
  }
#line 786
  p = src;
#line 788
  i = ctx->saved_len;
  {
#line 788
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 788
    if (! (i < 4UL)) {
#line 788
      goto while_break___0;
    }
#line 789
    tmp = p;
#line 789
    p ++;
#line 789
    ctx->saved[i] = *tmp;
#line 791
    if ((unsigned long )p == (unsigned long )buf->last) {
#line 792
      goto while_break___0;
    }
#line 788
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 796
  saved = ctx->saved;
#line 797
  n = ngx_utf8_decode(& saved, i);
#line 799
  c = (u_char )'\000';
  }
#line 801
  if (n < 65536U) {
#line 802
    table = (u_char **)ctx->table;
#line 803
    p = *(table + (n >> 8));
#line 805
    if (p) {
#line 806
      c = *(p + (n & 255U));
    }
  } else
#line 809
  if (n == 4294967294U) {
#line 813
    if (i < 4UL) {
      {
#line 814
      out = ngx_http_charset_get_buf(pool, ctx);
      }
#line 815
      if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 816
        return ((ngx_chain_t *)((void *)0));
      }
      {
#line 819
      b = out->buf;
#line 821
      b->pos = buf->pos;
#line 822
      b->last = buf->last;
#line 823
      b->sync = 1U;
#line 824
      b->shadow = buf;
#line 826
      memcpy((void */* __restrict  */)(& ctx->saved[ctx->saved_len]), (void const   */* __restrict  */)src,
             i);
#line 827
      ctx->saved_len += i;
      }
#line 829
      return (out);
    }
  }
#line 833
  size = (size_t___0 )(buf->last - buf->pos);
#line 835
  if (size < sizeof("&#1114111;") - 1UL) {
#line 836
    size += sizeof("&#1114111;") - 1UL;
  }
  {
#line 839
  cl = ngx_http_charset_get_buffer(pool, ctx, size);
  }
#line 840
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 841
    return ((ngx_chain_t *)((void *)0));
  }
#line 844
  out = cl;
#line 846
  b = cl->buf;
#line 847
  dst = b->pos;
#line 849
  if (c) {
#line 850
    tmp___0 = dst;
#line 850
    dst ++;
#line 850
    *tmp___0 = c;
  } else
#line 852
  if (n == 4294967294U) {
#line 853
    tmp___1 = dst;
#line 853
    dst ++;
#line 853
    *tmp___1 = (u_char )'?';
#line 858
    saved = & ctx->saved[4];
  } else
#line 860
  if (n > 1114111U) {
#line 861
    tmp___2 = dst;
#line 861
    dst ++;
#line 861
    *tmp___2 = (u_char )'?';
  } else {
    {
#line 867
    dst = ngx_sprintf(dst, "&#%uD;", n);
    }
  }
#line 870
  src += (size_t___0 )(saved - ctx->saved) - ctx->saved_len;
#line 871
  ctx->saved_len = (size_t___0 )0;
  recode: 
#line 875
  ll = & cl->next;
#line 877
  table = (u_char **)ctx->table;
  {
#line 879
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 879
    if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 879
      goto while_break___1;
    }
#line 881
    if ((size_t___0 )(b->end - dst) < sizeof("&#1114111;") - 1UL) {
      {
#line 882
      b->last = dst;
#line 884
      size = (unsigned long )(buf->last - src) + (sizeof("&#1114111;") - 1UL);
#line 886
      cl = ngx_http_charset_get_buffer(pool, ctx, size);
      }
#line 887
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 888
        return ((ngx_chain_t *)((void *)0));
      }
#line 891
      *ll = cl;
#line 892
      ll = & cl->next;
#line 894
      b = cl->buf;
#line 895
      dst = b->pos;
    }
#line 898
    if ((int )*src < 128) {
#line 899
      tmp___3 = dst;
#line 899
      dst ++;
#line 899
      tmp___4 = src;
#line 899
      src ++;
#line 899
      *tmp___3 = *tmp___4;
#line 900
      goto while_continue___1;
    }
    {
#line 903
    len = (size_t___0 )(buf->last - src);
#line 905
    n = ngx_utf8_decode(& src, len);
    }
#line 907
    if (n < 65536U) {
#line 909
      p = *(table + (n >> 8));
#line 911
      if (p) {
#line 912
        c = *(p + (n & 255U));
#line 914
        if (c) {
#line 915
          tmp___5 = dst;
#line 915
          dst ++;
#line 915
          *tmp___5 = c;
#line 916
          goto while_continue___1;
        }
      }
      {
#line 920
      dst = ngx_sprintf(dst, "&#%uD;", n);
      }
#line 922
      goto while_continue___1;
    }
#line 925
    if (n == 4294967294U) {
      {
#line 928
      memcpy((void */* __restrict  */)(ctx->saved), (void const   */* __restrict  */)src,
             len);
#line 929
      ctx->saved_len = len;
      }
#line 931
      if ((unsigned long )b->pos == (unsigned long )dst) {
#line 932
        b->sync = 1U;
#line 933
        b->temporary = 0U;
      }
#line 936
      goto while_break___1;
    }
#line 939
    if (n > 1114111U) {
#line 940
      tmp___6 = dst;
#line 940
      dst ++;
#line 940
      *tmp___6 = (u_char )'?';
#line 945
      goto while_continue___1;
    }
    {
#line 950
    dst = ngx_sprintf(dst, "&#%uD;", n);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 953
  b->last = dst;
#line 955
  b->last_buf = buf->last_buf;
#line 956
  b->last_in_chain = buf->last_in_chain;
#line 957
  b->flush = buf->flush;
#line 959
  b->shadow = buf;
#line 961
  return (out);
}
}
#line 965 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_recode_to_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                    ngx_http_charset_ctx_t *ctx ) 
{ 
  size_t___0 len ;
  size_t___0 size ;
  u_char *p ;
  u_char *src ;
  u_char *dst ;
  u_char *table ;
  ngx_buf_t *b ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 974
  table = ctx->table;
#line 976
  src = buf->pos;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 976
      goto while_break;
    }
#line 977
    if ((int )*(table + (int )*src * 4) == 1) {
#line 978
      goto __Cont;
    }
#line 981
    goto recode;
    __Cont: /* CIL Label */ 
#line 976
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 984
  out = ngx_alloc_chain_link(pool);
  }
#line 985
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 986
    return ((ngx_chain_t *)((void *)0));
  }
#line 989
  out->buf = buf;
#line 990
  out->next = (ngx_chain_t *)((void *)0);
#line 992
  return (out);
  recode: 
#line 1001
  len = (size_t___0 )(src - buf->pos);
#line 1003
  if (len > 512UL) {
    {
#line 1004
    out = ngx_http_charset_get_buf(pool, ctx);
    }
#line 1005
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 1006
      return ((ngx_chain_t *)((void *)0));
    }
#line 1009
    b = out->buf;
#line 1011
    b->temporary = buf->temporary;
#line 1012
    b->memory = buf->memory;
#line 1013
    b->mmap = buf->mmap;
#line 1014
    b->flush = buf->flush;
#line 1016
    b->pos = buf->pos;
#line 1017
    b->last = src;
#line 1019
    out->buf = b;
#line 1020
    out->next = (ngx_chain_t *)((void *)0);
#line 1022
    size = (size_t___0 )(buf->last - src);
#line 1023
    size = size / 2UL + (size / 2UL) * (size_t___0 )ctx->length;
  } else {
#line 1026
    out = (ngx_chain_t *)((void *)0);
#line 1028
    size = (size_t___0 )(buf->last - src);
#line 1029
    size = (len + size / 2UL) + (size / 2UL) * (size_t___0 )ctx->length;
#line 1031
    src = buf->pos;
  }
  {
#line 1034
  cl = ngx_http_charset_get_buffer(pool, ctx, size);
  }
#line 1035
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1036
    return ((ngx_chain_t *)((void *)0));
  }
#line 1039
  if (out) {
#line 1040
    out->next = cl;
  } else {
#line 1043
    out = cl;
  }
#line 1046
  ll = & cl->next;
#line 1048
  b = cl->buf;
#line 1049
  dst = b->pos;
  {
#line 1051
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1051
    if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 1051
      goto while_break___0;
    }
#line 1053
    tmp = src;
#line 1053
    src ++;
#line 1053
    p = table + (int )*tmp * 4;
#line 1054
    tmp___0 = p;
#line 1054
    p ++;
#line 1054
    len = (size_t___0 )*tmp___0;
#line 1056
    if ((size_t___0 )(b->end - dst) < len) {
      {
#line 1057
      b->last = dst;
#line 1059
      size = (size_t___0 )(buf->last - src);
#line 1060
      size = (len + size / 2UL) + (size / 2UL) * (size_t___0 )ctx->length;
#line 1062
      cl = ngx_http_charset_get_buffer(pool, ctx, size);
      }
#line 1063
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1064
        return ((ngx_chain_t *)((void *)0));
      }
#line 1067
      *ll = cl;
#line 1068
      ll = & cl->next;
#line 1070
      b = cl->buf;
#line 1071
      dst = b->pos;
    }
    {
#line 1074
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1074
      if (! len) {
#line 1074
        goto while_break___1;
      }
#line 1075
      tmp___1 = dst;
#line 1075
      dst ++;
#line 1075
      tmp___2 = p;
#line 1075
      p ++;
#line 1075
      *tmp___1 = *tmp___2;
#line 1076
      len --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1080
  b->last = dst;
#line 1082
  b->last_buf = buf->last_buf;
#line 1083
  b->last_in_chain = buf->last_in_chain;
#line 1084
  b->flush = buf->flush;
#line 1086
  b->shadow = buf;
#line 1088
  return (out);
}
}
#line 1092 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_get_buf(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;
  void *tmp ;

  {
#line 1097
  cl = ctx->free_bufs;
#line 1099
  if (cl) {
#line 1100
    ctx->free_bufs = cl->next;
#line 1102
    (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
#line 1103
    cl->next = (ngx_chain_t *)((void *)0);
#line 1105
    return (cl);
  }
  {
#line 1108
  cl = ngx_alloc_chain_link(pool);
  }
#line 1109
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1110
    return ((ngx_chain_t *)((void *)0));
  }
  {
#line 1113
  tmp = ngx_pcalloc(pool, sizeof(ngx_buf_t ));
#line 1113
  cl->buf = (ngx_buf_t *)tmp;
  }
#line 1114
  if ((unsigned long )cl->buf == (unsigned long )((void *)0)) {
#line 1115
    return ((ngx_chain_t *)((void *)0));
  }
#line 1118
  cl->next = (ngx_chain_t *)((void *)0);
#line 1120
  (cl->buf)->tag = (ngx_buf_tag_t )(& ngx_http_charset_filter_module);
#line 1122
  return (cl);
}
}
#line 1126 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_get_buffer(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ,
                                                size_t___0 size ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;

  {
#line 1133
  ll = & ctx->free_buffers;
#line 1133
  cl = ctx->free_buffers;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! cl) {
#line 1133
      goto while_break;
    }
#line 1137
    b = cl->buf;
#line 1139
    if ((size_t___0 )(b->end - b->start) >= size) {
#line 1140
      *ll = cl->next;
#line 1141
      cl->next = (ngx_chain_t *)((void *)0);
#line 1143
      b->pos = b->start;
#line 1144
      b->temporary = 1U;
#line 1145
      b->shadow = (ngx_buf_t *)((void *)0);
#line 1147
      return (cl);
    }
#line 1133
    ll = & cl->next;
#line 1133
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1151
  cl = ngx_alloc_chain_link(pool);
  }
#line 1152
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1153
    return ((ngx_chain_t *)((void *)0));
  }
  {
#line 1156
  cl->buf = ngx_create_temp_buf(pool, size);
  }
#line 1157
  if ((unsigned long )cl->buf == (unsigned long )((void *)0)) {
#line 1158
    return ((ngx_chain_t *)((void *)0));
  }
#line 1161
  cl->next = (ngx_chain_t *)((void *)0);
#line 1163
  (cl->buf)->temporary = 1U;
#line 1164
  (cl->buf)->tag = (ngx_buf_tag_t )(& ngx_http_charset_filter_module);
#line 1166
  return (cl);
}
}
#line 1170 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_charset_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_charset_main_conf_t *mcf ;
  char *rv ;
  u_char *p ;
  u_char *dst2src ;
  u_char **pp ;
  ngx_int_t src ;
  ngx_int_t dst ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_str_t *value ;
  ngx_conf_t pvcf ;
  ngx_http_charset_t *charset ;
  ngx_http_charset_tables_t *table ;
  ngx_http_charset_conf_ctx_t ctx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_int_t tmp___5 ;

  {
  {
#line 1173
  mcf = (ngx_http_charset_main_conf_t *)conf;
#line 1185
  value = (ngx_str_t *)(cf->args)->elts;
#line 1187
  src = ngx_http_add_charset(& mcf->charsets, value + 1);
  }
#line 1188
  if (src == -1L) {
#line 1189
    return ((char *)((void *)-1));
  }
  {
#line 1192
  dst = ngx_http_add_charset(& mcf->charsets, value + 2);
  }
#line 1193
  if (dst == -1L) {
#line 1194
    return ((char *)((void *)-1));
  }
#line 1197
  if (src == dst) {
    {
#line 1198
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"charset_map\" between the same charsets \"%V\" and \"%V\"",
                       value + 1, value + 2);
    }
#line 1201
    return ((char *)((void *)-1));
  }
#line 1204
  table = (ngx_http_charset_tables_t *)mcf->tables.elts;
#line 1205
  i = (ngx_uint_t )0;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1205
    if (! (i < mcf->tables.nelts)) {
#line 1205
      goto while_break;
    }
#line 1206
    if (src == table->src) {
#line 1206
      if (dst == table->dst) {
        {
#line 1209
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate \"charset_map\" between \"%V\" and \"%V\"",
                           value + 1, value + 2);
        }
#line 1212
        return ((char *)((void *)-1));
      } else {
#line 1206
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1206
    if (src == table->dst) {
#line 1206
      if (dst == table->src) {
        {
#line 1209
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate \"charset_map\" between \"%V\" and \"%V\"",
                           value + 1, value + 2);
        }
#line 1212
        return ((char *)((void *)-1));
      }
    }
#line 1205
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1216
  tmp = ngx_array_push(& mcf->tables);
#line 1216
  table = (ngx_http_charset_tables_t *)tmp;
  }
#line 1217
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 1218
    return ((char *)((void *)-1));
  }
  {
#line 1221
  table->src = src;
#line 1222
  table->dst = dst;
#line 1224
  tmp___5 = ngx_strcasecmp((value + 2)->data, (u_char *)"utf-8");
  }
#line 1224
  if (tmp___5 == 0L) {
    {
#line 1225
    tmp___0 = ngx_pcalloc(cf->pool, (size_t___0 )1024);
#line 1225
    table->src2dst = (u_char *)tmp___0;
    }
#line 1226
    if ((unsigned long )table->src2dst == (unsigned long )((void *)0)) {
#line 1227
      return ((char *)((void *)-1));
    }
    {
#line 1230
    tmp___1 = ngx_pcalloc(cf->pool, 256UL * sizeof(void *));
#line 1230
    table->dst2src = (u_char *)tmp___1;
    }
#line 1231
    if ((unsigned long )table->dst2src == (unsigned long )((void *)0)) {
#line 1232
      return ((char *)((void *)-1));
    }
    {
#line 1235
    tmp___2 = ngx_pcalloc(cf->pool, (size_t___0 )256);
#line 1235
    dst2src = (u_char *)tmp___2;
    }
#line 1236
    if ((unsigned long )dst2src == (unsigned long )((void *)0)) {
#line 1237
      return ((char *)((void *)-1));
    }
#line 1240
    pp = (u_char **)(table->dst2src + 0);
#line 1241
    *(pp + 0) = dst2src;
#line 1243
    i = (ngx_uint_t )0;
    {
#line 1243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1243
      if (! (i < 128UL)) {
#line 1243
        goto while_break___0;
      }
#line 1244
      p = table->src2dst + i * 4UL;
#line 1245
      *(p + 0) = (u_char )'\001';
#line 1246
      *(p + 1) = (u_char )i;
#line 1247
      *(dst2src + i) = (u_char )i;
#line 1243
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1250
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1250
      if (! (i < 256UL)) {
#line 1250
        goto while_break___1;
      }
#line 1251
      p = table->src2dst + i * 4UL;
#line 1252
      *(p + 0) = (u_char )'\001';
#line 1253
      *(p + 1) = (u_char )'?';
#line 1250
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1257
    tmp___3 = ngx_palloc(cf->pool, (size_t___0 )256);
#line 1257
    table->src2dst = (u_char *)tmp___3;
    }
#line 1258
    if ((unsigned long )table->src2dst == (unsigned long )((void *)0)) {
#line 1259
      return ((char *)((void *)-1));
    }
    {
#line 1262
    tmp___4 = ngx_palloc(cf->pool, (size_t___0 )256);
#line 1262
    table->dst2src = (u_char *)tmp___4;
    }
#line 1263
    if ((unsigned long )table->dst2src == (unsigned long )((void *)0)) {
#line 1264
      return ((char *)((void *)-1));
    }
#line 1267
    i = (ngx_uint_t )0;
    {
#line 1267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1267
      if (! (i < 128UL)) {
#line 1267
        goto while_break___2;
      }
#line 1268
      *(table->src2dst + i) = (u_char )i;
#line 1269
      *(table->dst2src + i) = (u_char )i;
#line 1267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1272
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1272
      if (! (i < 256UL)) {
#line 1272
        goto while_break___3;
      }
#line 1273
      *(table->src2dst + i) = (u_char )'?';
#line 1274
      *(table->dst2src + i) = (u_char )'?';
#line 1272
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1278
  charset = (ngx_http_charset_t *)mcf->charsets.elts;
#line 1280
  ctx.table = table;
#line 1281
  ctx.charset = charset + dst;
#line 1282
  ctx.characters = (ngx_uint_t )0;
#line 1284
  pvcf = *cf;
#line 1285
  cf->ctx = (void *)(& ctx);
#line 1286
  cf->handler = & ngx_http_charset_map;
#line 1287
  cf->handler_conf = (char *)conf;
#line 1289
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 1291
  *cf = pvcf;
  }
#line 1293
  if (ctx.characters) {
#line 1294
    n = (ngx_uint_t )(ctx.charset)->length;
#line 1295
    (ctx.charset)->length = (unsigned int )((ngx_uint_t )(ctx.charset)->length / ctx.characters);
#line 1297
    if (((n * 10UL) / ctx.characters) % 10UL > 4UL) {
#line 1298
      ((ctx.charset)->length) ++;
    }
  }
#line 1302
  return (rv);
}
}
#line 1306 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_charset_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  u_char *p ;
  u_char *dst2src ;
  u_char **pp ;
  uint32_t n ;
  ngx_int_t src ;
  ngx_int_t dst ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_charset_tables_t *table ;
  ngx_http_charset_conf_ctx_t *ctx ;
  u_char *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;

  {
#line 1317
  if ((cf->args)->nelts != 2UL) {
    {
#line 1318
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameters number");
    }
#line 1319
    return ((char *)((void *)-1));
  }
  {
#line 1322
  value = (ngx_str_t *)(cf->args)->elts;
#line 1324
  src = ngx_hextoi((value + 0)->data, (value + 0)->len);
  }
#line 1325
  if (src == -1L) {
    {
#line 1326
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 0);
    }
#line 1328
    return ((char *)((void *)-1));
  } else
#line 1325
  if (src > 255L) {
    {
#line 1326
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 0);
    }
#line 1328
    return ((char *)((void *)-1));
  }
#line 1331
  ctx = (ngx_http_charset_conf_ctx_t *)cf->ctx;
#line 1332
  table = ctx->table;
#line 1334
  if ((ctx->charset)->utf8) {
#line 1335
    p = table->src2dst + src * 4L;
#line 1337
    tmp = p;
#line 1337
    p ++;
#line 1337
    *tmp = (u_char )((value + 1)->len / 2UL);
#line 1339
    i = (ngx_uint_t )0;
    {
#line 1339
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1339
      if (! (i < (value + 1)->len)) {
#line 1339
        goto while_break;
      }
      {
#line 1340
      dst = ngx_hextoi((value + 1)->data + i, (size_t___0 )2);
      }
#line 1341
      if (dst == -1L) {
        {
#line 1342
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
        }
#line 1344
        return ((char *)((void *)-1));
      } else
#line 1341
      if (dst > 255L) {
        {
#line 1342
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
        }
#line 1344
        return ((char *)((void *)-1));
      }
#line 1347
      tmp___0 = p;
#line 1347
      p ++;
#line 1347
      *tmp___0 = (u_char )dst;
#line 1339
      i += 2UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1350
    i /= 2UL;
#line 1352
    (ctx->charset)->length = (unsigned int )((ngx_uint_t )(ctx->charset)->length + i);
#line 1353
    (ctx->characters) ++;
#line 1355
    p = (table->src2dst + src * 4L) + 1;
#line 1357
    n = ngx_utf8_decode(& p, i);
    }
#line 1359
    if (n > 65535U) {
      {
#line 1360
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
      }
#line 1362
      return ((char *)((void *)-1));
    }
#line 1365
    pp = (u_char **)(table->dst2src + 0);
#line 1367
    dst2src = *(pp + (n >> 8));
#line 1369
    if ((unsigned long )dst2src == (unsigned long )((void *)0)) {
      {
#line 1370
      tmp___1 = ngx_pcalloc(cf->pool, (size_t___0 )256);
#line 1370
      dst2src = (u_char *)tmp___1;
      }
#line 1371
      if ((unsigned long )dst2src == (unsigned long )((void *)0)) {
#line 1372
        return ((char *)((void *)-1));
      }
#line 1375
      *(pp + (n >> 8)) = dst2src;
    }
#line 1378
    *(dst2src + (n & 255U)) = (u_char )src;
  } else {
    {
#line 1381
    dst = ngx_hextoi((value + 1)->data, (value + 1)->len);
    }
#line 1382
    if (dst == -1L) {
      {
#line 1383
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
      }
#line 1385
      return ((char *)((void *)-1));
    } else
#line 1382
    if (dst > 255L) {
      {
#line 1383
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
      }
#line 1385
      return ((char *)((void *)-1));
    }
#line 1388
    *(table->src2dst + src) = (u_char )dst;
#line 1389
    *(table->dst2src + dst) = (u_char )src;
  }
#line 1392
  return ((char *)((void *)0));
}
}
#line 1396 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_set_charset_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_int_t *cp ;
  ngx_str_t *value ;
  ngx_str_t var ;
  ngx_http_charset_main_conf_t *mcf ;
  int tmp ;

  {
#line 1399
  p = (char *)conf;
#line 1405
  cp = (ngx_int_t *)(p + cmd->offset);
#line 1407
  if (*cp != -1L) {
#line 1408
    return ((char *)"is duplicate");
  }
#line 1411
  value = (ngx_str_t *)(cf->args)->elts;
#line 1413
  if (cmd->offset == (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->charset)) {
    {
#line 1413
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 1413
    if (tmp == 0) {
#line 1416
      *cp = (ngx_int_t )-2;
#line 1417
      return ((char *)((void *)0));
    }
  }
#line 1421
  if ((int )*((value + 1)->data + 0) == 36) {
    {
#line 1422
    var.len = (value + 1)->len - 1UL;
#line 1423
    var.data = (value + 1)->data + 1;
#line 1425
    *cp = ngx_http_get_variable_index(cf, & var);
    }
#line 1427
    if (*cp == -1L) {
#line 1428
      return ((char *)((void *)-1));
    }
#line 1431
    *cp += 65536L;
#line 1433
    return ((char *)((void *)0));
  }
  {
#line 1436
  mcf = (ngx_http_charset_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 1439
  *cp = ngx_http_add_charset(& mcf->charsets, value + 1);
  }
#line 1440
  if (*cp == -1L) {
#line 1441
    return ((char *)((void *)-1));
  }
#line 1444
  return ((char *)((void *)0));
}
}
#line 1448 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_add_charset(ngx_array_t *charsets , ngx_str_t *name ) 
{ 
  ngx_uint_t i ;
  ngx_http_charset_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1454
  c = (ngx_http_charset_t *)charsets->elts;
#line 1455
  i = (ngx_uint_t )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (i < charsets->nelts)) {
#line 1455
      goto while_break;
    }
#line 1456
    if (name->len != (c + i)->name.len) {
#line 1457
      goto __Cont;
    }
    {
#line 1460
    tmp = ngx_strcasecmp(name->data, (c + i)->name.data);
    }
#line 1460
    if (tmp == 0L) {
#line 1461
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 1455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1465
  if (i < charsets->nelts) {
#line 1466
    return ((ngx_int_t )i);
  }
  {
#line 1469
  tmp___0 = ngx_array_push(charsets);
#line 1469
  c = (ngx_http_charset_t *)tmp___0;
  }
#line 1470
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1471
    return ((ngx_int_t )-1);
  }
  {
#line 1474
  c->tables = (u_char **)((void *)0);
#line 1475
  c->name = *name;
#line 1476
  c->length = 0U;
#line 1478
  tmp___1 = ngx_strcasecmp(name->data, (u_char *)"utf-8");
  }
#line 1478
  if (tmp___1 == 0L) {
#line 1479
    c->utf8 = 1U;
  } else {
#line 1482
    c->utf8 = 0U;
  }
#line 1485
  return ((ngx_int_t )i);
}
}
#line 1489 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static void *ngx_http_charset_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_charset_main_conf_t *mcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 1494
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_charset_main_conf_t ));
#line 1494
  mcf = (ngx_http_charset_main_conf_t *)tmp;
  }
#line 1495
  if ((unsigned long )mcf == (unsigned long )((void *)0)) {
#line 1496
    return ((void *)0);
  }
  {
#line 1499
  tmp___0 = ngx_array_init(& mcf->charsets, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_charset_t ));
  }
#line 1499
  if (tmp___0 != 0L) {
#line 1502
    return ((void *)0);
  }
  {
#line 1505
  tmp___1 = ngx_array_init(& mcf->tables, cf->pool, (ngx_uint_t )1, sizeof(ngx_http_charset_tables_t ));
  }
#line 1505
  if (tmp___1 != 0L) {
#line 1509
    return ((void *)0);
  }
  {
#line 1512
  tmp___2 = ngx_array_init(& mcf->recodes, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_charset_recode_t ));
  }
#line 1512
  if (tmp___2 != 0L) {
#line 1516
    return ((void *)0);
  }
#line 1519
  return ((void *)mcf);
}
}
#line 1523 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static void *ngx_http_charset_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_charset_loc_conf_t *lcf ;
  void *tmp ;

  {
  {
#line 1528
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_charset_loc_conf_t ));
#line 1528
  lcf = (ngx_http_charset_loc_conf_t *)tmp;
  }
#line 1529
  if ((unsigned long )lcf == (unsigned long )((void *)0)) {
#line 1530
    return ((void *)0);
  }
#line 1540
  lcf->charset = (ngx_int_t )-1;
#line 1541
  lcf->source_charset = (ngx_int_t )-1;
#line 1542
  lcf->override_charset = (ngx_flag_t )-1;
#line 1544
  return ((void *)lcf);
}
}
#line 1548 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_charset_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_charset_loc_conf_t *prev ;
  ngx_http_charset_loc_conf_t *conf ;
  ngx_uint_t i ;
  ngx_http_charset_recode_t *recode ;
  ngx_http_charset_main_conf_t *mcf ;
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 1551
  prev = (ngx_http_charset_loc_conf_t *)parent;
#line 1552
  conf = (ngx_http_charset_loc_conf_t *)child;
#line 1558
  tmp = ngx_http_merge_types(cf, & conf->types_keys, & conf->types, & prev->types_keys,
                             & prev->types, ngx_http_charset_default_types);
  }
#line 1558
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1563
    return ((char *)((void *)-1));
  }
#line 1566
  if (conf->override_charset == -1L) {
#line 1566
    if (prev->override_charset == -1L) {
#line 1566
      conf->override_charset = (ngx_flag_t )0;
    } else {
#line 1566
      conf->override_charset = prev->override_charset;
    }
  }
#line 1567
  if (conf->charset == -1L) {
#line 1567
    if (prev->charset == -1L) {
#line 1567
      conf->charset = (ngx_int_t )-2;
    } else {
#line 1567
      conf->charset = prev->charset;
    }
  }
#line 1568
  if (conf->source_charset == -1L) {
#line 1568
    if (prev->source_charset == -1L) {
#line 1568
      conf->source_charset = (ngx_int_t )-2;
    } else {
#line 1568
      conf->source_charset = prev->source_charset;
    }
  }
#line 1571
  if (conf->charset == -2L) {
#line 1575
    return ((char *)((void *)0));
  } else
#line 1571
  if (conf->source_charset == -2L) {
#line 1575
    return ((char *)((void *)0));
  } else
#line 1571
  if (conf->charset == conf->source_charset) {
#line 1575
    return ((char *)((void *)0));
  }
#line 1578
  if (conf->source_charset >= 65536L) {
#line 1581
    return ((char *)((void *)0));
  } else
#line 1578
  if (conf->charset >= 65536L) {
#line 1581
    return ((char *)((void *)0));
  }
#line 1584
  mcf = (ngx_http_charset_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 1586
  recode = (ngx_http_charset_recode_t *)mcf->recodes.elts;
#line 1587
  i = (ngx_uint_t )0;
  {
#line 1587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1587
    if (! (i < mcf->recodes.nelts)) {
#line 1587
      goto while_break;
    }
#line 1588
    if (conf->source_charset == (recode + i)->src) {
#line 1588
      if (conf->charset == (recode + i)->dst) {
#line 1591
        return ((char *)((void *)0));
      }
    }
#line 1587
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1595
  tmp___0 = ngx_array_push(& mcf->recodes);
#line 1595
  recode = (ngx_http_charset_recode_t *)tmp___0;
  }
#line 1596
  if ((unsigned long )recode == (unsigned long )((void *)0)) {
#line 1597
    return ((char *)((void *)-1));
  }
#line 1600
  recode->src = conf->source_charset;
#line 1601
  recode->dst = conf->charset;
#line 1603
  return ((char *)((void *)0));
}
}
#line 1607 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_postconfiguration(ngx_conf_t *cf ) 
{ 
  u_char **src ;
  u_char **dst ;
  ngx_int_t c ;
  ngx_uint_t i ;
  ngx_uint_t t ;
  ngx_http_charset_t *charset ;
  ngx_http_charset_recode_t *recode ;
  ngx_http_charset_tables_t *tables ;
  ngx_http_charset_main_conf_t *mcf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1618
  mcf = (ngx_http_charset_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 1621
  recode = (ngx_http_charset_recode_t *)mcf->recodes.elts;
#line 1622
  tables = (ngx_http_charset_tables_t *)mcf->tables.elts;
#line 1623
  charset = (ngx_http_charset_t *)mcf->charsets.elts;
#line 1625
  i = (ngx_uint_t )0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if (! (i < mcf->recodes.nelts)) {
#line 1625
      goto while_break;
    }
#line 1627
    c = (recode + i)->src;
#line 1629
    t = (ngx_uint_t )0;
    {
#line 1629
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1629
      if (! (t < mcf->tables.nelts)) {
#line 1629
        goto while_break___0;
      }
#line 1631
      if (c == (tables + t)->src) {
#line 1631
        if ((recode + i)->dst == (tables + t)->dst) {
#line 1632
          goto next;
        }
      }
#line 1635
      if (c == (tables + t)->dst) {
#line 1635
        if ((recode + i)->dst == (tables + t)->src) {
#line 1636
          goto next;
        }
      }
#line 1629
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1640
    if ((cf->log)->log_level >= 1UL) {
      {
#line 1640
      ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "no \"charset_map\" between the charsets \"%V\" and \"%V\"",
                         & (charset + c)->name, & (charset + (recode + i)->dst)->name);
      }
    }
#line 1643
    return ((ngx_int_t )-1);
    next: 
#line 1646
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1625
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1650
  t = (ngx_uint_t )0;
  {
#line 1650
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1650
    if (! (t < mcf->tables.nelts)) {
#line 1650
      goto while_break___1;
    }
#line 1652
    src = (charset + (tables + t)->src)->tables;
#line 1654
    if ((unsigned long )src == (unsigned long )((void *)0)) {
      {
#line 1655
      tmp = ngx_pcalloc(cf->pool, sizeof(u_char *) * mcf->charsets.nelts);
#line 1655
      src = (u_char **)tmp;
      }
#line 1656
      if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1657
        return ((ngx_int_t )-1);
      }
#line 1660
      (charset + (tables + t)->src)->tables = src;
    }
#line 1663
    dst = (charset + (tables + t)->dst)->tables;
#line 1665
    if ((unsigned long )dst == (unsigned long )((void *)0)) {
      {
#line 1666
      tmp___0 = ngx_pcalloc(cf->pool, sizeof(u_char *) * mcf->charsets.nelts);
#line 1666
      dst = (u_char **)tmp___0;
      }
#line 1667
      if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1668
        return ((ngx_int_t )-1);
      }
#line 1671
      (charset + (tables + t)->dst)->tables = dst;
    }
#line 1674
    *(src + (tables + t)->dst) = (tables + t)->src2dst;
#line 1675
    *(dst + (tables + t)->src) = (tables + t)->dst2src;
#line 1650
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1678
  ngx_http_next_header_filter___2 = ngx_http_top_header_filter;
#line 1679
  ngx_http_top_header_filter = & ngx_http_charset_header_filter;
#line 1681
  ngx_http_next_body_filter___1 = ngx_http_top_body_filter;
#line 1682
  ngx_http_top_body_filter = & ngx_http_charset_body_filter;
#line 1684
  return ((ngx_int_t )0);
}
}
#line 88 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t___0 strftime(char * __restrict  __s ,
                                                         size_t___0 __maxsize , char const   * __restrict  __format ,
                                                         struct tm  const  * __restrict  __tp ) ;
#line 58 "src/os/unix/ngx_time.h"
void ngx_libc_localtime(time_t s , struct tm *tm ) ;
#line 59
void ngx_libc_gmtime(time_t s , struct tm *tm ) ;
#line 67 "src/os/unix/ngx_process.h"
void ngx_debug_point(void) ;
#line 160 "src/core/ngx_buf.h"
ngx_int_t ngx_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain , ngx_chain_t *in ) ;
#line 34 "src/core/ngx_list.h"
ngx_list_t *ngx_list_create(ngx_pool_t *pool , ngx_uint_t n , size_t___0 size ) ;
#line 112 "src/core/ngx_hash.h"
ngx_uint_t ngx_hash_key(u_char *data , size_t___0 len ) ;
#line 114
ngx_uint_t ngx_hash_strlow(u_char *dst , u_char *src , size_t___0 n ) ;
#line 55 "src/http/ngx_http_variables.h"
ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                                 ngx_uint_t key ) ;
#line 499 "src/http/ngx_http_core_module.h"
void ngx_http_weak_etag(ngx_http_request_t *r ) ;
#line 510
ngx_int_t ngx_http_subrequest(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                              ngx_http_request_t **psr , ngx_http_post_subrequest_t *ps ,
                              ngx_uint_t flags ) ;
#line 98 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                                    ngx_uint_t *flags ) ;
#line 168
ngx_str_t ngx_http_html_default_types[2] ;
#line 73 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_output(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) ;
#line 75
static void ngx_http_ssi_buffered(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) ;
#line 77
static ngx_int_t ngx_http_ssi_parse(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) ;
#line 79
static ngx_str_t *ngx_http_ssi_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                            ngx_uint_t key ) ;
#line 81
static ngx_int_t ngx_http_ssi_evaluate_string(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                              ngx_str_t *text , ngx_uint_t flags ) ;
#line 83
static ngx_int_t ngx_http_ssi_regex_match(ngx_http_request_t *r , ngx_str_t *pattern ,
                                          ngx_str_t *str ) ;
#line 86
static ngx_int_t ngx_http_ssi_include(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                      ngx_str_t **params ) ;
#line 88
static ngx_int_t ngx_http_ssi_stub_output(ngx_http_request_t *r , void *data , ngx_int_t rc ) ;
#line 90
static ngx_int_t ngx_http_ssi_set_variable(ngx_http_request_t *r , void *data , ngx_int_t rc ) ;
#line 92
static ngx_int_t ngx_http_ssi_echo(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) ;
#line 94
static ngx_int_t ngx_http_ssi_config(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                     ngx_str_t **params ) ;
#line 96
static ngx_int_t ngx_http_ssi_set(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                  ngx_str_t **params ) ;
#line 98
static ngx_int_t ngx_http_ssi_if(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                 ngx_str_t **params ) ;
#line 100
static ngx_int_t ngx_http_ssi_else(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) ;
#line 102
static ngx_int_t ngx_http_ssi_endif(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) ;
#line 104
static ngx_int_t ngx_http_ssi_block(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) ;
#line 106
static ngx_int_t ngx_http_ssi_endblock(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                       ngx_str_t **params ) ;
#line 109
static ngx_int_t ngx_http_ssi_date_gmt_local_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t gmt ) ;
#line 112
static ngx_int_t ngx_http_ssi_preconfiguration(ngx_conf_t *cf ) ;
#line 113
static void *ngx_http_ssi_create_main_conf(ngx_conf_t *cf ) ;
#line 114
static char *ngx_http_ssi_init_main_conf(ngx_conf_t *cf , void *conf ) ;
#line 115
static void *ngx_http_ssi_create_loc_conf(ngx_conf_t *cf ) ;
#line 116
static char *ngx_http_ssi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 118
static ngx_int_t ngx_http_ssi_filter_init(ngx_conf_t *cf ) ;
#line 121 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_command_t ngx_http_ssi_filter_commands[8]  = 
#line 121
  {      {{sizeof("ssi") - 1UL, (u_char *)"ssi"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->enable),
      (void *)0}, 
        {{sizeof("ssi_silent_errors") - 1UL, (u_char *)"ssi_silent_errors"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->silent_errors), (void *)0}, 
        {{sizeof("ssi_ignore_recycled_buffers") - 1UL,
       (u_char *)"ssi_ignore_recycled_buffers"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->ignore_recycled_buffers),
      (void *)0}, 
        {{sizeof("ssi_min_file_chunk") - 1UL, (u_char *)"ssi_min_file_chunk"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->min_file_chunk), (void *)0}, 
        {{sizeof("ssi_value_length") - 1UL,
       (u_char *)"ssi_value_length"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->value_len),
      (void *)0}, 
        {{sizeof("ssi_types") - 1UL, (u_char *)"ssi_types"}, (ngx_uint_t )234883072,
      & ngx_http_types_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->types_keys), (void *)(& ngx_http_html_default_types[0])}, 
        {{sizeof("ssi_last_modified") - 1UL,
       (u_char *)"ssi_last_modified"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->last_modified),
      (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 178 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_module_t ngx_http_ssi_filter_module_ctx  = 
#line 178
     {& ngx_http_ssi_preconfiguration, & ngx_http_ssi_filter_init, & ngx_http_ssi_create_main_conf,
    & ngx_http_ssi_init_main_conf, (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf ,
                                                                                       void *prev ,
                                                                                       void *conf ))((void *)0),
    & ngx_http_ssi_create_loc_conf, & ngx_http_ssi_merge_loc_conf};
#line 193 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
ngx_module_t ngx_http_ssi_filter_module  = 
#line 193
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_ssi_filter_module_ctx),
    ngx_http_ssi_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 209 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___3)(ngx_http_request_t *r )  ;
#line 210 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___2)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 213 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static u_char ngx_http_ssi_string[5]  = {      (u_char )'<',      (u_char )'!',      (u_char )'-',      (u_char )'-', 
        (u_char )'\000'};
#line 215 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t ngx_http_ssi_none  =    {sizeof("(none)") - 1UL, (u_char *)"(none)"};
#line 216 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t ngx_http_ssi_timefmt  =    {sizeof("%A, %d-%b-%Y %H:%M:%S %Z") - 1UL, (u_char *)"%A, %d-%b-%Y %H:%M:%S %Z"};
#line 217 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t ngx_http_ssi_null_string  =    {(size_t___0 )0, (u_char *)((void *)0)};
#line 241 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_include_params[6]  = {      {{sizeof("virtual") - 1UL, (u_char *)"virtual"}, (ngx_uint_t )0, 0U, 0U}, 
        {{sizeof("file") - 1UL, (u_char *)"file"}, (ngx_uint_t )1, 0U, 0U}, 
        {{sizeof("wait") - 1UL, (u_char *)"wait"}, (ngx_uint_t )2, 0U, 0U}, 
        {{sizeof("set") - 1UL, (u_char *)"set"}, (ngx_uint_t )3, 0U, 0U}, 
        {{sizeof("stub") - 1UL, (u_char *)"stub"}, (ngx_uint_t )4, 0U, 0U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 251 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_echo_params[4]  = {      {{sizeof("var") - 1UL, (u_char *)"var"}, (ngx_uint_t )0, 1U, 0U}, 
        {{sizeof("default") - 1UL, (u_char *)"default"}, (ngx_uint_t )1, 0U, 0U}, 
        {{sizeof("encoding") - 1UL, (u_char *)"encoding"}, (ngx_uint_t )2, 0U, 0U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 259 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_config_params[3]  = {      {{sizeof("errmsg") - 1UL, (u_char *)"errmsg"}, (ngx_uint_t )0, 0U, 0U}, 
        {{sizeof("timefmt") - 1UL, (u_char *)"timefmt"}, (ngx_uint_t )1, 0U, 0U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 266 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_set_params[3]  = {      {{sizeof("var") - 1UL, (u_char *)"var"}, (ngx_uint_t )0, 1U, 0U}, 
        {{sizeof("value") - 1UL, (u_char *)"value"}, (ngx_uint_t )1, 1U, 0U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 273 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_if_params[2]  = {      {{sizeof("expr") - 1UL, (u_char *)"expr"}, (ngx_uint_t )0, 1U, 0U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 279 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_block_params[2]  = {      {{sizeof("name") - 1UL, (u_char *)"name"}, (ngx_uint_t )0, 1U, 0U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 285 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_no_params[1]  = {      {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 290 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_command_t ngx_http_ssi_commands[11]  = 
#line 290
  {      {{sizeof("include") - 1UL, (u_char *)"include"}, & ngx_http_ssi_include, ngx_http_ssi_include_params,
      0U, 0U, 1U}, 
        {{sizeof("echo") - 1UL, (u_char *)"echo"}, & ngx_http_ssi_echo, ngx_http_ssi_echo_params,
      0U, 0U, 0U}, 
        {{sizeof("config") - 1UL, (u_char *)"config"}, & ngx_http_ssi_config, ngx_http_ssi_config_params,
      0U, 0U, 0U}, 
        {{sizeof("set") - 1UL, (u_char *)"set"}, & ngx_http_ssi_set, ngx_http_ssi_set_params,
      0U, 0U, 0U}, 
        {{sizeof("if") - 1UL, (u_char *)"if"}, & ngx_http_ssi_if, ngx_http_ssi_if_params,
      0U, 0U, 0U}, 
        {{sizeof("elif") - 1UL, (u_char *)"elif"}, & ngx_http_ssi_if, ngx_http_ssi_if_params,
      1U, 0U, 0U}, 
        {{sizeof("else") - 1UL, (u_char *)"else"}, & ngx_http_ssi_else, ngx_http_ssi_no_params,
      1U, 0U, 0U}, 
        {{sizeof("endif") - 1UL, (u_char *)"endif"}, & ngx_http_ssi_endif, ngx_http_ssi_no_params,
      2U, 0U, 0U}, 
        {{sizeof("block") - 1UL, (u_char *)"block"}, & ngx_http_ssi_block, ngx_http_ssi_block_params,
      0U, 0U, 0U}, 
        {{sizeof("endblock") - 1UL, (u_char *)"endblock"}, & ngx_http_ssi_endblock, ngx_http_ssi_no_params,
      0U, 1U, 0U}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                              ngx_http_ssi_ctx_t *ctx ,
                                                              ngx_str_t ** ))((void *)0),
      (ngx_http_ssi_param_t *)((void *)0), 0U, 0U, 0U}};
#line 316 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_variable_t ngx_http_ssi_vars[3]  = {      {{sizeof("date_local") - 1UL, (u_char *)"date_local"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_ssi_date_gmt_local_variable, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("date_gmt") - 1UL,
       (u_char *)"date_gmt"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ))((void *)0), & ngx_http_ssi_date_gmt_local_variable,
      (uintptr_t )1, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                         uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 329 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_http_ssi_ctx_t *ctx ;
  ngx_http_ssi_loc_conf_t *slcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 335
  slcf = (ngx_http_ssi_loc_conf_t *)*(r->loc_conf + ngx_http_ssi_filter_module.ctx_index);
#line 337
  if (! slcf->enable) {
    {
#line 341
    tmp = (*ngx_http_next_header_filter___3)(r);
    }
#line 341
    return (tmp);
  } else
#line 337
  if (r->headers_out.content_length_n == 0L) {
    {
#line 341
    tmp = (*ngx_http_next_header_filter___3)(r);
    }
#line 341
    return (tmp);
  } else {
    {
#line 337
    tmp___0 = ngx_http_test_content_type(r, & slcf->types);
    }
#line 337
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 341
      tmp = (*ngx_http_next_header_filter___3)(r);
      }
#line 341
      return (tmp);
    }
  }
  {
#line 344
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_ssi_ctx_t ));
#line 344
  ctx = (ngx_http_ssi_ctx_t *)tmp___1;
  }
#line 345
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 346
    return ((ngx_int_t )-1);
  }
#line 349
  *(r->ctx + ngx_http_ssi_filter_module.ctx_index) = (void *)ctx;
#line 352
  ctx->value_len = slcf->value_len;
#line 353
  ctx->last_out = & ctx->out;
#line 355
  ctx->encoding = 2U;
#line 356
  ctx->output = 1U;
#line 358
  ctx->params.elts = (void *)(ctx->params_array);
#line 359
  ctx->params.size = sizeof(ngx_table_elt_t );
#line 360
  ctx->params.nalloc = (ngx_uint_t )4;
#line 361
  ctx->params.pool = r->pool;
#line 363
  ctx->timefmt = ngx_http_ssi_timefmt;
#line 364
  ctx->errmsg.len = sizeof("[an error occurred while processing the directive]") - 1UL;
#line 364
  ctx->errmsg.data = (u_char *)"[an error occurred while processing the directive]";
#line 367
  r->filter_need_in_memory = 1U;
#line 369
  if ((unsigned long )r == (unsigned long )r->main) {
#line 370
    r->headers_out.content_length_n = (off_t )-1;
#line 370
    if (r->headers_out.content_length) {
#line 370
      (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 370
      r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
    }
#line 371
    r->allow_ranges = 0U;
#line 371
    if (r->headers_out.accept_ranges) {
#line 371
      (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 371
      r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
    }
#line 373
    if (! slcf->last_modified) {
#line 374
      r->headers_out.last_modified_time = (time_t )-1;
#line 374
      if (r->headers_out.last_modified) {
#line 374
        (r->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 374
        r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
      }
#line 375
      if (r->headers_out.etag) {
#line 375
        (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 375
        r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
      }
    } else {
      {
#line 378
      ngx_http_weak_etag(r);
      }
    }
  }
  {
#line 382
  tmp___2 = (*ngx_http_next_header_filter___3)(r);
  }
#line 382
  return (tmp___2);
}
}
#line 386 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_uint_t index___0 ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_table_elt_t *param ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_http_ssi_ctx_t *mctx ;
  ngx_http_ssi_block_t *bl ;
  ngx_http_ssi_param_t *prm ;
  ngx_http_ssi_command_t *cmd ;
  ngx_http_ssi_loc_conf_t *slcf ;
  ngx_http_ssi_main_conf_t *smcf ;
  ngx_str_t *params[17] ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  void *tmp___12 ;
  u_char *tmp___13 ;
  void *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  void *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  int tmp___23 ;
  ngx_int_t tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  ngx_int_t tmp___27 ;

  {
#line 403
  ctx = (ngx_http_ssi_ctx_t *)*(r->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 405
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 411
    tmp = (*ngx_http_next_body_filter___2)(r, in);
    }
#line 411
    return (tmp);
  } else
#line 405
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 405
    if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
#line 405
      if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 405
        if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
          {
#line 411
          tmp = (*ngx_http_next_body_filter___2)(r, in);
          }
#line 411
          return (tmp);
        }
      }
    }
  }
#line 416
  if (in) {
    {
#line 417
    tmp___0 = ngx_chain_add_copy(r->pool, & ctx->in, in);
    }
#line 417
    if (tmp___0 != 0L) {
#line 418
      return ((ngx_int_t )-1);
    }
  }
#line 425
  if (ctx->wait) {
#line 427
    if ((unsigned long )r != (unsigned long )(r->connection)->data) {
#line 432
      return ((ngx_int_t )-2);
    }
#line 435
    if ((ctx->wait)->done) {
#line 440
      ctx->wait = (ngx_http_request_t *)((void *)0);
    } else {
      {
#line 447
      tmp___1 = (*ngx_http_next_body_filter___2)(r, (ngx_chain_t *)((void *)0));
      }
#line 447
      return (tmp___1);
    }
  }
#line 451
  slcf = (ngx_http_ssi_loc_conf_t *)*(r->loc_conf + ngx_http_ssi_filter_module.ctx_index);
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! ctx->in) {
#line 453
      if (! ctx->buf) {
#line 453
        goto while_break;
      }
    }
#line 455
    if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
#line 456
      ctx->buf = (ctx->in)->buf;
#line 457
      ctx->in = (ctx->in)->next;
#line 458
      ctx->pos = (ctx->buf)->pos;
    }
#line 461
    if (ctx->state == 0UL) {
#line 462
      ctx->copy_start = ctx->pos;
#line 463
      ctx->copy_end = ctx->pos;
    }
#line 466
    b = (ngx_buf_t *)((void *)0);
    {
#line 468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 468
      if (! ((unsigned long )ctx->pos < (unsigned long )(ctx->buf)->last)) {
#line 468
        goto while_break___0;
      }
      {
#line 473
      rc = ngx_http_ssi_parse(r, ctx);
      }
#line 479
      if (rc == -1L) {
#line 480
        return (rc);
      }
#line 483
      if ((unsigned long )ctx->copy_start != (unsigned long )ctx->copy_end) {
#line 485
        if (ctx->output) {
#line 490
          if (ctx->saved) {
#line 492
            if (ctx->free) {
              {
#line 493
              cl = ctx->free;
#line 494
              ctx->free = (ctx->free)->next;
#line 495
              b = cl->buf;
#line 496
              memset((void *)b, 0, sizeof(ngx_buf_t ));
              }
            } else {
              {
#line 499
              tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 499
              b = (ngx_buf_t *)tmp___2;
              }
#line 500
              if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 501
                return ((ngx_int_t )-1);
              }
              {
#line 504
              cl = ngx_alloc_chain_link(r->pool);
              }
#line 505
              if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 506
                return ((ngx_int_t )-1);
              }
#line 509
              cl->buf = b;
            }
#line 512
            b->memory = 1U;
#line 513
            b->pos = ngx_http_ssi_string;
#line 514
            b->last = ngx_http_ssi_string + ctx->saved;
#line 516
            *(ctx->last_out) = cl;
#line 517
            ctx->last_out = & cl->next;
#line 519
            ctx->saved = (size_t___0 )0;
          }
#line 522
          if (ctx->free) {
#line 523
            cl = ctx->free;
#line 524
            ctx->free = (ctx->free)->next;
#line 525
            b = cl->buf;
          } else {
            {
#line 528
            tmp___3 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 528
            b = (ngx_buf_t *)tmp___3;
            }
#line 529
            if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 530
              return ((ngx_int_t )-1);
            }
            {
#line 533
            cl = ngx_alloc_chain_link(r->pool);
            }
#line 534
            if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 535
              return ((ngx_int_t )-1);
            }
#line 538
            cl->buf = b;
          }
          {
#line 541
          memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)ctx->buf,
                 sizeof(ngx_buf_t ));
#line 543
          b->pos = ctx->copy_start;
#line 544
          b->last = ctx->copy_end;
#line 545
          b->shadow = (ngx_buf_t *)((void *)0);
#line 546
          b->last_buf = 0U;
#line 547
          b->recycled = 0U;
          }
#line 549
          if (b->in_file) {
#line 550
            if (slcf->min_file_chunk < (size_t___0 )(b->last - b->pos)) {
#line 552
              b->file_last = b->file_pos + (b->last - (ctx->buf)->pos);
#line 554
              b->file_pos += b->pos - (ctx->buf)->pos;
            } else {
#line 557
              b->in_file = 0U;
            }
          }
#line 561
          cl->next = (ngx_chain_t *)((void *)0);
#line 562
          *(ctx->last_out) = cl;
#line 563
          ctx->last_out = & cl->next;
        } else {
#line 566
          if (ctx->block) {
#line 566
            if (ctx->saved + (size_t___0 )(ctx->copy_end - ctx->copy_start)) {
              {
#line 569
              b = ngx_create_temp_buf(r->pool, ctx->saved + (size_t___0 )(ctx->copy_end - ctx->copy_start));
              }
#line 572
              if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 573
                return ((ngx_int_t )-1);
              }
#line 576
              if (ctx->saved) {
                {
#line 577
                tmp___4 = memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)(ngx_http_ssi_string),
                                 ctx->saved);
#line 577
                b->last = (u_char *)tmp___4 + ctx->saved;
                }
              }
              {
#line 581
              tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->copy_start,
                               (size_t )(ctx->copy_end - ctx->copy_start));
#line 581
              b->last = (u_char *)tmp___5 + (ctx->copy_end - ctx->copy_start);
#line 584
              cl = ngx_alloc_chain_link(r->pool);
              }
#line 585
              if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 586
                return ((ngx_int_t )-1);
              }
#line 589
              cl->buf = b;
#line 590
              cl->next = (ngx_chain_t *)((void *)0);
#line 592
              b = (ngx_buf_t *)((void *)0);
#line 594
              mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 596
              bl = (ngx_http_ssi_block_t *)(mctx->blocks)->elts;
#line 597
              ll = & (bl + ((mctx->blocks)->nelts - 1UL))->bufs;
              {
#line 597
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 597
                if (! *ll) {
#line 597
                  goto while_break___1;
                }
#line 597
                ll = & (*ll)->next;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 604
              *ll = cl;
            }
          }
#line 607
          ctx->saved = (size_t___0 )0;
        }
      }
#line 611
      if (ctx->state == 0UL) {
#line 612
        ctx->copy_start = ctx->pos;
#line 613
        ctx->copy_end = ctx->pos;
      } else {
#line 616
        ctx->copy_start = (u_char *)((void *)0);
#line 617
        ctx->copy_end = (u_char *)((void *)0);
      }
#line 620
      if (rc == -2L) {
#line 621
        goto while_continue___0;
      }
#line 625
      b = (ngx_buf_t *)((void *)0);
#line 627
      if (rc == 0L) {
        {
#line 629
        smcf = (ngx_http_ssi_main_conf_t *)*(r->main_conf + ngx_http_ssi_filter_module.ctx_index);
#line 632
        tmp___6 = ngx_hash_find(& smcf->hash, ctx->key, ctx->command.data, ctx->command.len);
#line 632
        cmd = (ngx_http_ssi_command_t *)tmp___6;
        }
#line 635
        if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 636
          if (ctx->output) {
#line 637
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 637
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid SSI command: \"%V\"",
                                 & ctx->command);
              }
            }
#line 640
            goto ssi_error;
          }
#line 643
          goto while_continue___0;
        }
#line 646
        if (! ctx->output) {
#line 646
          if (! cmd->block) {
#line 648
            if (ctx->block) {
#line 652
              len = (5UL + ctx->command.len) + 4UL;
#line 654
              param = (ngx_table_elt_t *)ctx->params.elts;
#line 655
              i = (ngx_uint_t )0;
              {
#line 655
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 655
                if (! (i < ctx->params.nelts)) {
#line 655
                  goto while_break___2;
                }
#line 656
                len += (((1UL + (param + i)->key.len) + 2UL) + (param + i)->value.len) + 1UL;
#line 655
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 660
              b = ngx_create_temp_buf(r->pool, len);
              }
#line 662
              if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 663
                return ((ngx_int_t )-1);
              }
              {
#line 666
              cl = ngx_alloc_chain_link(r->pool);
              }
#line 667
              if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 668
                return ((ngx_int_t )-1);
              }
              {
#line 671
              cl->buf = b;
#line 672
              cl->next = (ngx_chain_t *)((void *)0);
#line 674
              tmp___7 = b->last;
#line 674
              (b->last) ++;
#line 674
              *tmp___7 = (u_char )'<';
#line 675
              tmp___8 = b->last;
#line 675
              (b->last) ++;
#line 675
              *tmp___8 = (u_char )'!';
#line 676
              tmp___9 = b->last;
#line 676
              (b->last) ++;
#line 676
              *tmp___9 = (u_char )'-';
#line 677
              tmp___10 = b->last;
#line 677
              (b->last) ++;
#line 677
              *tmp___10 = (u_char )'-';
#line 678
              tmp___11 = b->last;
#line 678
              (b->last) ++;
#line 678
              *tmp___11 = (u_char )'#';
#line 680
              tmp___12 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->command.data,
                                ctx->command.len);
#line 680
              b->last = (u_char *)tmp___12 + ctx->command.len;
#line 683
              i = (ngx_uint_t )0;
              }
              {
#line 683
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 683
                if (! (i < ctx->params.nelts)) {
#line 683
                  goto while_break___3;
                }
                {
#line 684
                tmp___13 = b->last;
#line 684
                (b->last) ++;
#line 684
                *tmp___13 = (u_char )' ';
#line 685
                tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(param + i)->key.data,
                                  (param + i)->key.len);
#line 685
                b->last = (u_char *)tmp___14 + (param + i)->key.len;
#line 687
                tmp___15 = b->last;
#line 687
                (b->last) ++;
#line 687
                *tmp___15 = (u_char )'=';
#line 688
                tmp___16 = b->last;
#line 688
                (b->last) ++;
#line 688
                *tmp___16 = (u_char )'\"';
#line 689
                tmp___17 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(param + i)->value.data,
                                  (param + i)->value.len);
#line 689
                b->last = (u_char *)tmp___17 + (param + i)->value.len;
#line 691
                tmp___18 = b->last;
#line 691
                (b->last) ++;
#line 691
                *tmp___18 = (u_char )'\"';
#line 683
                i ++;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 694
              tmp___19 = b->last;
#line 694
              (b->last) ++;
#line 694
              *tmp___19 = (u_char )' ';
#line 695
              tmp___20 = b->last;
#line 695
              (b->last) ++;
#line 695
              *tmp___20 = (u_char )'-';
#line 696
              tmp___21 = b->last;
#line 696
              (b->last) ++;
#line 696
              *tmp___21 = (u_char )'-';
#line 697
              tmp___22 = b->last;
#line 697
              (b->last) ++;
#line 697
              *tmp___22 = (u_char )'>';
#line 699
              mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 701
              bl = (ngx_http_ssi_block_t *)(mctx->blocks)->elts;
#line 702
              ll = & (bl + ((mctx->blocks)->nelts - 1UL))->bufs;
              {
#line 702
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 702
                if (! *ll) {
#line 702
                  goto while_break___4;
                }
#line 702
                ll = & (*ll)->next;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 709
              *ll = cl;
#line 711
              b = (ngx_buf_t *)((void *)0);
#line 713
              goto while_continue___0;
            }
#line 716
            if (cmd->conditional == 0U) {
#line 717
              goto while_continue___0;
            }
          }
        }
#line 721
        if (cmd->conditional) {
#line 721
          if (ctx->conditional == 0U) {
#line 721
            goto _L;
          } else
#line 721
          if (ctx->conditional > cmd->conditional) {
            _L: /* CIL Label */ 
#line 725
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 725
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid context of SSI command: \"%V\"",
                                 & ctx->command);
              }
            }
#line 728
            goto ssi_error;
          }
        }
#line 731
        if (ctx->params.nelts > 16UL) {
#line 732
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 732
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too many SSI command parameters: \"%V\"",
                               & ctx->command);
            }
          }
#line 735
          goto ssi_error;
        }
        {
#line 738
        memset((void *)(params), 0, 17UL * sizeof(ngx_str_t *));
#line 741
        param = (ngx_table_elt_t *)ctx->params.elts;
#line 743
        i = (ngx_uint_t )0;
        }
        {
#line 743
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 743
          if (! (i < ctx->params.nelts)) {
#line 743
            goto while_break___5;
          }
#line 745
          prm = cmd->params;
          {
#line 745
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 745
            if (! prm->name.len) {
#line 745
              goto while_break___6;
            }
#line 747
            if ((param + i)->key.len != prm->name.len) {
#line 751
              goto __Cont;
            } else {
              {
#line 747
              tmp___23 = strncmp((char const   *)(param + i)->key.data, (char const   *)prm->name.data,
                                 prm->name.len);
              }
#line 747
              if (tmp___23 != 0) {
#line 751
                goto __Cont;
              }
            }
#line 754
            if (! prm->multiple) {
#line 755
              if (params[prm->index]) {
#line 756
                if (((r->connection)->log)->log_level >= 4UL) {
                  {
#line 756
                  ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "duplicate \"%V\" parameter in \"%V\" SSI command",
                                     & (param + i)->key, & ctx->command);
                  }
                }
#line 762
                goto ssi_error;
              }
#line 765
              params[prm->index] = & (param + i)->value;
#line 767
              goto while_break___6;
            }
#line 770
            index___0 = prm->index;
            {
#line 770
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 770
              if (! params[index___0]) {
#line 770
                goto while_break___7;
              }
#line 770
              index___0 ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 774
            params[index___0] = & (param + i)->value;
#line 776
            goto while_break___6;
            __Cont: /* CIL Label */ 
#line 745
            prm ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 779
          if (prm->name.len == 0UL) {
#line 780
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 780
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid parameter name: \"%V\" in \"%V\" SSI command",
                                 & (param + i)->key, & ctx->command);
              }
            }
#line 785
            goto ssi_error;
          }
#line 743
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 789
        prm = cmd->params;
        {
#line 789
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 789
          if (! prm->name.len) {
#line 789
            goto while_break___8;
          }
#line 790
          if (prm->mandatory) {
#line 790
            if ((unsigned long )params[prm->index] == (unsigned long )((ngx_str_t *)0)) {
#line 791
              if (((r->connection)->log)->log_level >= 4UL) {
                {
#line 791
                ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "mandatory \"%V\" parameter is absent in \"%V\" SSI command",
                                   & prm->name, & ctx->command);
                }
              }
#line 796
              goto ssi_error;
            }
          }
#line 789
          prm ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 800
        if (cmd->flush) {
#line 800
          if (ctx->out) {
            {
#line 805
            tmp___24 = ngx_http_ssi_output(r, ctx);
            }
#line 805
            if (tmp___24 == -1L) {
#line 806
              return ((ngx_int_t )-1);
            }
          }
        }
        {
#line 810
        rc = (*(cmd->handler))(r, ctx, params);
        }
#line 812
        if (rc == 0L) {
#line 813
          goto while_continue___0;
        }
#line 816
        if (rc == -4L) {
          {
#line 817
          ngx_http_ssi_buffered(r, ctx);
          }
#line 818
          return (rc);
        } else
#line 816
        if (rc == -2L) {
          {
#line 817
          ngx_http_ssi_buffered(r, ctx);
          }
#line 818
          return (rc);
        } else
#line 816
        if (rc == -1L) {
          {
#line 817
          ngx_http_ssi_buffered(r, ctx);
          }
#line 818
          return (rc);
        }
      }
      ssi_error: 
#line 827
      if (slcf->silent_errors) {
#line 828
        goto while_continue___0;
      }
#line 831
      if (ctx->free) {
        {
#line 832
        cl = ctx->free;
#line 833
        ctx->free = (ctx->free)->next;
#line 834
        b = cl->buf;
#line 835
        memset((void *)b, 0, sizeof(ngx_buf_t ));
        }
      } else {
        {
#line 838
        tmp___25 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 838
        b = (ngx_buf_t *)tmp___25;
        }
#line 839
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 840
          return ((ngx_int_t )-1);
        }
        {
#line 843
        cl = ngx_alloc_chain_link(r->pool);
        }
#line 844
        if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 845
          return ((ngx_int_t )-1);
        }
#line 848
        cl->buf = b;
      }
#line 851
      b->memory = 1U;
#line 852
      b->pos = ctx->errmsg.data;
#line 853
      b->last = ctx->errmsg.data + ctx->errmsg.len;
#line 855
      cl->next = (ngx_chain_t *)((void *)0);
#line 856
      *(ctx->last_out) = cl;
#line 857
      ctx->last_out = & cl->next;
#line 859
      goto while_continue___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 862
    if ((ctx->buf)->last_buf) {
#line 862
      goto _L___1;
    } else
#line 862
    if ((ctx->buf)->temporary) {
#line 862
      goto _L___1;
    } else
#line 862
    if ((ctx->buf)->memory) {
#line 862
      goto _L___1;
    } else
#line 862
    if ((ctx->buf)->mmap) {
      _L___1: /* CIL Label */ 
#line 863
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 864
        if (ctx->free) {
          {
#line 865
          cl = ctx->free;
#line 866
          ctx->free = (ctx->free)->next;
#line 867
          b = cl->buf;
#line 868
          memset((void *)b, 0, sizeof(ngx_buf_t ));
          }
        } else {
          {
#line 871
          tmp___26 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 871
          b = (ngx_buf_t *)tmp___26;
          }
#line 872
          if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 873
            return ((ngx_int_t )-1);
          }
          {
#line 876
          cl = ngx_alloc_chain_link(r->pool);
          }
#line 877
          if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 878
            return ((ngx_int_t )-1);
          }
#line 881
          cl->buf = b;
        }
#line 884
        b->sync = 1U;
#line 886
        cl->next = (ngx_chain_t *)((void *)0);
#line 887
        *(ctx->last_out) = cl;
#line 888
        ctx->last_out = & cl->next;
      }
#line 891
      b->last_buf = (ctx->buf)->last_buf;
#line 892
      b->shadow = ctx->buf;
#line 894
      if (slcf->ignore_recycled_buffers == 0L) {
#line 895
        b->recycled = (ctx->buf)->recycled;
      }
    }
#line 899
    ctx->buf = (ngx_buf_t *)((void *)0);
#line 901
    ctx->saved = ctx->looked;
  }
  while_break: /* CIL Label */ ;
  }
#line 904
  if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
#line 904
    if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 905
      return ((ngx_int_t )0);
    }
  }
  {
#line 908
  tmp___27 = ngx_http_ssi_output(r, ctx);
  }
#line 908
  return (tmp___27);
}
}
#line 912 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_output(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  off_t tmp ;

  {
#line 920
  b = (ngx_buf_t *)((void *)0);
#line 921
  cl = ctx->out;
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 921
    if (! cl) {
#line 921
      goto while_break;
    }
#line 924
    if ((unsigned long )cl->buf == (unsigned long )b) {
#line 925
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 925
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "the same buf was used in ssi");
        }
      }
      {
#line 927
      ngx_debug_point();
      }
#line 928
      return ((ngx_int_t )-1);
    }
#line 930
    b = cl->buf;
#line 921
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 934
  rc = (*ngx_http_next_body_filter___2)(r, ctx->out);
  }
#line 936
  if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 937
    ctx->busy = ctx->out;
  } else {
#line 940
    cl = ctx->busy;
    {
#line 940
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 940
      if (! cl->next) {
#line 940
        goto while_break___0;
      }
#line 940
      cl = cl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 941
    cl->next = ctx->out;
  }
#line 944
  ctx->out = (ngx_chain_t *)((void *)0);
#line 945
  ctx->last_out = & ctx->out;
  {
#line 947
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 947
    if (! ctx->busy) {
#line 947
      goto while_break___1;
    }
#line 949
    cl = ctx->busy;
#line 950
    b = cl->buf;
#line 952
    if (b->temporary) {
#line 952
      tmp = b->last - b->pos;
    } else
#line 952
    if (b->memory) {
#line 952
      tmp = b->last - b->pos;
    } else
#line 952
    if (b->mmap) {
#line 952
      tmp = b->last - b->pos;
    } else {
#line 952
      tmp = b->file_last - b->file_pos;
    }
#line 952
    if (tmp != 0L) {
#line 953
      goto while_break___1;
    }
#line 956
    if (b->shadow) {
#line 957
      (b->shadow)->pos = (b->shadow)->last;
    }
#line 960
    ctx->busy = cl->next;
#line 962
    if (b->temporary) {
#line 965
      cl->next = ctx->free;
#line 966
      ctx->free = cl;
    } else
#line 962
    if (b->memory) {
#line 965
      cl->next = ctx->free;
#line 966
      ctx->free = cl;
    } else
#line 962
    if (b->mmap) {
#line 965
      cl->next = ctx->free;
#line 966
      ctx->free = cl;
    } else
#line 962
    if (b->in_file) {
#line 965
      cl->next = ctx->free;
#line 966
      ctx->free = cl;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 970
  ngx_http_ssi_buffered(r, ctx);
  }
#line 972
  return (rc);
}
}
#line 976 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static void ngx_http_ssi_buffered(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) 
{ 


  {
#line 979
  if (ctx->in) {
#line 980
    r->buffered |= 1U;
  } else
#line 979
  if (ctx->buf) {
#line 980
    r->buffered |= 1U;
  } else {
#line 983
    r->buffered &= 4294967294U;
  }
#line 985
  return;
}
}
#line 988 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_parse(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) 
{ 
  u_char *p ;
  u_char *value ;
  u_char *last ;
  u_char *copy_end ;
  u_char ch ;
  size_t___0 looked ;
  ngx_http_ssi_state_e state ;
  void *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t___0 tmp___4 ;
  size_t___0 tmp___5 ;
  size_t___0 tmp___6 ;
  size_t___0 tmp___7 ;
  size_t___0 tmp___8 ;
  void *tmp___9 ;

  {
#line 995
  state = (ngx_http_ssi_state_e )ctx->state;
#line 996
  looked = ctx->looked;
#line 997
  last = (ctx->buf)->last;
#line 998
  copy_end = ctx->copy_end;
#line 1000
  p = ctx->pos;
  {
#line 1000
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1000
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 1000
      goto while_break;
    }
#line 1002
    ch = *p;
#line 1004
    if ((unsigned int )state == 0U) {
      {
#line 1008
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1009
        if ((int )ch == 60) {
#line 1010
          copy_end = p;
#line 1011
          looked = (size_t___0 )1;
#line 1012
          state = (ngx_http_ssi_state_e )1;
#line 1014
          goto tag_started;
        }
#line 1017
        p ++;
#line 1017
        if ((unsigned long )p == (unsigned long )last) {
#line 1018
          goto while_break___0;
        }
#line 1021
        ch = *p;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1024
      ctx->state = (ngx_uint_t )state;
#line 1025
      ctx->pos = p;
#line 1026
      ctx->looked = looked;
#line 1027
      ctx->copy_end = p;
#line 1029
      if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1030
        ctx->copy_start = (ctx->buf)->pos;
      }
#line 1033
      return ((ngx_int_t )-2);
      tag_started: 
#line 1037
      goto __Cont;
    }
    {
#line 1042
    if ((unsigned int )state == 0U) {
#line 1042
      goto case_0;
    }
#line 1046
    if ((unsigned int )state == 1U) {
#line 1046
      goto case_1;
    }
#line 1066
    if ((unsigned int )state == 2U) {
#line 1066
      goto case_2;
    }
#line 1088
    if ((unsigned int )state == 3U) {
#line 1088
      goto case_3;
    }
#line 1110
    if ((unsigned int )state == 4U) {
#line 1110
      goto case_4;
    }
#line 1135
    if ((unsigned int )state == 5U) {
#line 1135
      goto case_5;
    }
#line 1164
    if ((unsigned int )state == 6U) {
#line 1164
      goto case_6;
    }
#line 1193
    if ((unsigned int )state == 7U) {
#line 1193
      goto case_7;
    }
#line 1239
    if ((unsigned int )state == 8U) {
#line 1239
      goto case_8;
    }
#line 1276
    if ((unsigned int )state == 9U) {
#line 1276
      goto case_9___3;
    }
#line 1304
    if ((unsigned int )state == 10U) {
#line 1304
      goto case_10___4;
    }
#line 1336
    if ((unsigned int )state == 11U) {
#line 1336
      goto case_11;
    }
#line 1364
    if ((unsigned int )state == 12U) {
#line 1364
      goto case_12;
    }
#line 1392
    if ((unsigned int )state == 13U) {
#line 1392
      goto case_13___5;
    }
#line 1409
    if ((unsigned int )state == 14U) {
#line 1409
      goto case_14;
    }
#line 1451
    if ((unsigned int )state == 15U) {
#line 1451
      goto case_15;
    }
#line 1467
    if ((unsigned int )state == 16U) {
#line 1467
      goto case_16;
    }
#line 1491
    if ((unsigned int )state == 17U) {
#line 1491
      goto case_17;
    }
#line 1503
    if ((unsigned int )state == 18U) {
#line 1503
      goto case_18;
    }
#line 1516
    if ((unsigned int )state == 19U) {
#line 1516
      goto case_19;
    }
#line 1040
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1044
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1048
    if ((int )ch == 33) {
#line 1048
      goto case_33;
    }
#line 1053
    if ((int )ch == 60) {
#line 1053
      goto case_60;
    }
#line 1057
    goto switch_default;
    case_33: /* CIL Label */ 
#line 1049
    looked = (size_t___0 )2;
#line 1050
    state = (ngx_http_ssi_state_e )2;
#line 1051
    goto switch_break___0;
    case_60: /* CIL Label */ 
#line 1054
    copy_end = p;
#line 1055
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1058
    copy_end = p;
#line 1059
    looked = (size_t___0 )0;
#line 1060
    state = (ngx_http_ssi_state_e )0;
#line 1061
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1064
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1068
    if ((int )ch == 45) {
#line 1068
      goto case_45;
    }
#line 1073
    if ((int )ch == 60) {
#line 1073
      goto case_60___0;
    }
#line 1079
    goto switch_default___0;
    case_45: /* CIL Label */ 
#line 1069
    looked = (size_t___0 )3;
#line 1070
    state = (ngx_http_ssi_state_e )3;
#line 1071
    goto switch_break___1;
    case_60___0: /* CIL Label */ 
#line 1074
    copy_end = p;
#line 1075
    looked = (size_t___0 )1;
#line 1076
    state = (ngx_http_ssi_state_e )1;
#line 1077
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 1080
    copy_end = p;
#line 1081
    looked = (size_t___0 )0;
#line 1082
    state = (ngx_http_ssi_state_e )0;
#line 1083
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1086
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1090
    if ((int )ch == 45) {
#line 1090
      goto case_45___0;
    }
#line 1095
    if ((int )ch == 60) {
#line 1095
      goto case_60___1;
    }
#line 1101
    goto switch_default___1;
    case_45___0: /* CIL Label */ 
#line 1091
    looked = (size_t___0 )4;
#line 1092
    state = (ngx_http_ssi_state_e )4;
#line 1093
    goto switch_break___2;
    case_60___1: /* CIL Label */ 
#line 1096
    copy_end = p;
#line 1097
    looked = (size_t___0 )1;
#line 1098
    state = (ngx_http_ssi_state_e )1;
#line 1099
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 1102
    copy_end = p;
#line 1103
    looked = (size_t___0 )0;
#line 1104
    state = (ngx_http_ssi_state_e )0;
#line 1105
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1108
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1112
    if ((int )ch == 35) {
#line 1112
      goto case_35;
    }
#line 1120
    if ((int )ch == 60) {
#line 1120
      goto case_60___2;
    }
#line 1126
    goto switch_default___2;
    case_35: /* CIL Label */ 
#line 1113
    if (p - ctx->pos < 4L) {
#line 1114
      ctx->saved = (size_t___0 )0;
    }
#line 1116
    looked = (size_t___0 )0;
#line 1117
    state = (ngx_http_ssi_state_e )5;
#line 1118
    goto switch_break___3;
    case_60___2: /* CIL Label */ 
#line 1121
    copy_end = p;
#line 1122
    looked = (size_t___0 )1;
#line 1123
    state = (ngx_http_ssi_state_e )1;
#line 1124
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 1127
    copy_end = p;
#line 1128
    looked = (size_t___0 )0;
#line 1129
    state = (ngx_http_ssi_state_e )0;
#line 1130
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1133
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1140
    if ((int )ch == 9) {
#line 1140
      goto case_9;
    }
#line 1140
    if ((int )ch == 10) {
#line 1140
      goto case_9;
    }
#line 1140
    if ((int )ch == 13) {
#line 1140
      goto case_9;
    }
#line 1140
    if ((int )ch == 32) {
#line 1140
      goto case_9;
    }
#line 1143
    goto switch_default___3;
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1141
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 1144
    ctx->command.len = (size_t___0 )1;
#line 1145
    tmp = ngx_pnalloc(r->pool, (size_t___0 )32);
#line 1145
    ctx->command.data = (u_char *)tmp;
    }
#line 1147
    if ((unsigned long )ctx->command.data == (unsigned long )((void *)0)) {
#line 1148
      return ((ngx_int_t )-1);
    }
#line 1151
    *(ctx->command.data + 0) = ch;
#line 1153
    ctx->key = (ngx_uint_t )0;
#line 1154
    ctx->key = ctx->key * 31UL + (ngx_uint_t )ch;
#line 1156
    ctx->params.nelts = (ngx_uint_t )0;
#line 1158
    state = (ngx_http_ssi_state_e )6;
#line 1159
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1162
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1169
    if ((int )ch == 9) {
#line 1169
      goto case_9___0;
    }
#line 1169
    if ((int )ch == 10) {
#line 1169
      goto case_9___0;
    }
#line 1169
    if ((int )ch == 13) {
#line 1169
      goto case_9___0;
    }
#line 1169
    if ((int )ch == 32) {
#line 1169
      goto case_9___0;
    }
#line 1173
    if ((int )ch == 45) {
#line 1173
      goto case_45___1;
    }
#line 1177
    goto switch_default___4;
    case_9___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
#line 1170
    state = (ngx_http_ssi_state_e )7;
#line 1171
    goto switch_break___5;
    case_45___1: /* CIL Label */ 
#line 1174
    state = (ngx_http_ssi_state_e )15;
#line 1175
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
#line 1178
    if (ctx->command.len == 32UL) {
#line 1179
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1179
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the \"%V%c...\" SSI command is too long",
                           & ctx->command, (int )ch);
        }
      }
#line 1183
      state = (ngx_http_ssi_state_e )17;
#line 1184
      goto switch_break___5;
    }
#line 1187
    tmp___0 = ctx->command.len;
#line 1187
    (ctx->command.len) ++;
#line 1187
    *(ctx->command.data + tmp___0) = ch;
#line 1188
    ctx->key = ctx->key * 31UL + (ngx_uint_t )ch;
    switch_break___5: /* CIL Label */ ;
    }
#line 1191
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1198
    if ((int )ch == 9) {
#line 1198
      goto case_9___1;
    }
#line 1198
    if ((int )ch == 10) {
#line 1198
      goto case_9___1;
    }
#line 1198
    if ((int )ch == 13) {
#line 1198
      goto case_9___1;
    }
#line 1198
    if ((int )ch == 32) {
#line 1198
      goto case_9___1;
    }
#line 1201
    if ((int )ch == 45) {
#line 1201
      goto case_45___2;
    }
#line 1205
    goto switch_default___5;
    case_9___1: /* CIL Label */ 
    case_10___1: /* CIL Label */ 
    case_13___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
#line 1199
    goto switch_break___6;
    case_45___2: /* CIL Label */ 
#line 1202
    state = (ngx_http_ssi_state_e )15;
#line 1203
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 1206
    tmp___1 = ngx_array_push(& ctx->params);
#line 1206
    ctx->param = (ngx_table_elt_t *)tmp___1;
    }
#line 1207
    if ((unsigned long )ctx->param == (unsigned long )((void *)0)) {
#line 1208
      return ((ngx_int_t )-1);
    }
    {
#line 1211
    (ctx->param)->key.len = (size_t___0 )1;
#line 1212
    tmp___2 = ngx_pnalloc(r->pool, (size_t___0 )32);
#line 1212
    (ctx->param)->key.data = (u_char *)tmp___2;
    }
#line 1214
    if ((unsigned long )(ctx->param)->key.data == (unsigned long )((void *)0)) {
#line 1215
      return ((ngx_int_t )-1);
    }
#line 1218
    *((ctx->param)->key.data + 0) = ch;
#line 1220
    (ctx->param)->value.len = (size_t___0 )0;
#line 1222
    if ((unsigned long )ctx->value_buf == (unsigned long )((void *)0)) {
      {
#line 1223
      tmp___3 = ngx_pnalloc(r->pool, ctx->value_len + 1UL);
#line 1223
      (ctx->param)->value.data = (u_char *)tmp___3;
      }
#line 1225
      if ((unsigned long )(ctx->param)->value.data == (unsigned long )((void *)0)) {
#line 1226
        return ((ngx_int_t )-1);
      }
    } else {
#line 1230
      (ctx->param)->value.data = (u_char *)ctx->value_buf;
    }
#line 1233
    state = (ngx_http_ssi_state_e )8;
#line 1234
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
#line 1237
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1244
    if ((int )ch == 9) {
#line 1244
      goto case_9___2;
    }
#line 1244
    if ((int )ch == 10) {
#line 1244
      goto case_9___2;
    }
#line 1244
    if ((int )ch == 13) {
#line 1244
      goto case_9___2;
    }
#line 1244
    if ((int )ch == 32) {
#line 1244
      goto case_9___2;
    }
#line 1248
    if ((int )ch == 61) {
#line 1248
      goto case_61;
    }
#line 1252
    if ((int )ch == 45) {
#line 1252
      goto case_45___3;
    }
#line 1261
    goto switch_default___6;
    case_9___2: /* CIL Label */ 
    case_10___2: /* CIL Label */ 
    case_13___2: /* CIL Label */ 
    case_32___2: /* CIL Label */ 
#line 1245
    state = (ngx_http_ssi_state_e )9;
#line 1246
    goto switch_break___7;
    case_61: /* CIL Label */ 
#line 1249
    state = (ngx_http_ssi_state_e )10;
#line 1250
    goto switch_break___7;
    case_45___3: /* CIL Label */ 
#line 1253
    state = (ngx_http_ssi_state_e )18;
#line 1255
    tmp___4 = (ctx->param)->key.len;
#line 1255
    ((ctx->param)->key.len) ++;
#line 1255
    *((ctx->param)->key.data + tmp___4) = ch;
#line 1256
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1256
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid \"%V\" parameter in \"%V\" SSI command",
                         & (ctx->param)->key, & ctx->command);
      }
    }
#line 1259
    goto switch_break___7;
    switch_default___6: /* CIL Label */ 
#line 1262
    if ((ctx->param)->key.len == 32UL) {
#line 1263
      state = (ngx_http_ssi_state_e )17;
#line 1264
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1264
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" parameter in \"%V\" SSI command",
                           & (ctx->param)->key, (int )ch, & ctx->command);
        }
      }
#line 1268
      goto switch_break___7;
    }
#line 1271
    tmp___5 = (ctx->param)->key.len;
#line 1271
    ((ctx->param)->key.len) ++;
#line 1271
    *((ctx->param)->key.data + tmp___5) = ch;
    switch_break___7: /* CIL Label */ ;
    }
#line 1274
    goto switch_break;
    case_9___3: /* CIL Label */ 
    {
#line 1281
    if ((int )ch == 9) {
#line 1281
      goto case_9___4;
    }
#line 1281
    if ((int )ch == 10) {
#line 1281
      goto case_9___4;
    }
#line 1281
    if ((int )ch == 13) {
#line 1281
      goto case_9___4;
    }
#line 1281
    if ((int )ch == 32) {
#line 1281
      goto case_9___4;
    }
#line 1284
    if ((int )ch == 61) {
#line 1284
      goto case_61___0;
    }
#line 1288
    goto switch_default___7;
    case_9___4: /* CIL Label */ 
    case_10___3: /* CIL Label */ 
    case_13___3: /* CIL Label */ 
    case_32___3: /* CIL Label */ 
#line 1282
    goto switch_break___8;
    case_61___0: /* CIL Label */ 
#line 1285
    state = (ngx_http_ssi_state_e )10;
#line 1286
    goto switch_break___8;
    switch_default___7: /* CIL Label */ 
#line 1289
    if ((int )ch == 45) {
#line 1290
      state = (ngx_http_ssi_state_e )18;
    } else {
#line 1292
      state = (ngx_http_ssi_state_e )17;
    }
#line 1295
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1295
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol after \"%V\" parameter in \"%V\" SSI command",
                         (int )ch, & (ctx->param)->key, & ctx->command);
      }
    }
#line 1299
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 1302
    goto switch_break;
    case_10___4: /* CIL Label */ 
    {
#line 1309
    if ((int )ch == 9) {
#line 1309
      goto case_9___5;
    }
#line 1309
    if ((int )ch == 10) {
#line 1309
      goto case_9___5;
    }
#line 1309
    if ((int )ch == 13) {
#line 1309
      goto case_9___5;
    }
#line 1309
    if ((int )ch == 32) {
#line 1309
      goto case_9___5;
    }
#line 1312
    if ((int )ch == 34) {
#line 1312
      goto case_34;
    }
#line 1316
    if ((int )ch == 39) {
#line 1316
      goto case_39;
    }
#line 1320
    goto switch_default___8;
    case_9___5: /* CIL Label */ 
    case_10___5: /* CIL Label */ 
    case_13___4: /* CIL Label */ 
    case_32___4: /* CIL Label */ 
#line 1310
    goto switch_break___9;
    case_34: /* CIL Label */ 
#line 1313
    state = (ngx_http_ssi_state_e )11;
#line 1314
    goto switch_break___9;
    case_39: /* CIL Label */ 
#line 1317
    state = (ngx_http_ssi_state_e )12;
#line 1318
    goto switch_break___9;
    switch_default___8: /* CIL Label */ 
#line 1321
    if ((int )ch == 45) {
#line 1322
      state = (ngx_http_ssi_state_e )18;
    } else {
#line 1324
      state = (ngx_http_ssi_state_e )17;
    }
#line 1327
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1327
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol before value of \"%V\" parameter in \"%V\" SSI command",
                         (int )ch, & (ctx->param)->key, & ctx->command);
      }
    }
#line 1331
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
#line 1334
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1338
    if ((int )ch == 34) {
#line 1338
      goto case_34___0;
    }
#line 1342
    if ((int )ch == 92) {
#line 1342
      goto case_92;
    }
#line 1348
    goto switch_default___9;
    case_34___0: /* CIL Label */ 
#line 1339
    state = (ngx_http_ssi_state_e )14;
#line 1340
    goto switch_break___10;
    case_92: /* CIL Label */ 
#line 1343
    ctx->saved_state = (ngx_uint_t )11;
#line 1344
    state = (ngx_http_ssi_state_e )13;
    switch_default___9: /* CIL Label */ 
#line 1349
    if ((ctx->param)->value.len == ctx->value_len) {
#line 1350
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1350
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" value of \"%V\" parameter in \"%V\" SSI command",
                           & (ctx->param)->value, (int )ch, & (ctx->param)->key, & ctx->command);
        }
      }
#line 1355
      state = (ngx_http_ssi_state_e )17;
#line 1356
      goto switch_break___10;
    }
#line 1359
    tmp___6 = (ctx->param)->value.len;
#line 1359
    ((ctx->param)->value.len) ++;
#line 1359
    *((ctx->param)->value.data + tmp___6) = ch;
    switch_break___10: /* CIL Label */ ;
    }
#line 1362
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1366
    if ((int )ch == 39) {
#line 1366
      goto case_39___0;
    }
#line 1370
    if ((int )ch == 92) {
#line 1370
      goto case_92___0;
    }
#line 1376
    goto switch_default___10;
    case_39___0: /* CIL Label */ 
#line 1367
    state = (ngx_http_ssi_state_e )14;
#line 1368
    goto switch_break___11;
    case_92___0: /* CIL Label */ 
#line 1371
    ctx->saved_state = (ngx_uint_t )12;
#line 1372
    state = (ngx_http_ssi_state_e )13;
    switch_default___10: /* CIL Label */ 
#line 1377
    if ((ctx->param)->value.len == ctx->value_len) {
#line 1378
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1378
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" value of \"%V\" parameter in \"%V\" SSI command",
                           & (ctx->param)->value, (int )ch, & (ctx->param)->key, & ctx->command);
        }
      }
#line 1383
      state = (ngx_http_ssi_state_e )17;
#line 1384
      goto switch_break___11;
    }
#line 1387
    tmp___7 = (ctx->param)->value.len;
#line 1387
    ((ctx->param)->value.len) ++;
#line 1387
    *((ctx->param)->value.data + tmp___7) = ch;
    switch_break___11: /* CIL Label */ ;
    }
#line 1390
    goto switch_break;
    case_13___5: /* CIL Label */ 
#line 1393
    state = (ngx_http_ssi_state_e )ctx->saved_state;
#line 1395
    if ((ctx->param)->value.len == ctx->value_len) {
#line 1396
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1396
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" value of \"%V\" parameter in \"%V\" SSI command",
                           & (ctx->param)->value, (int )ch, & (ctx->param)->key, & ctx->command);
        }
      }
#line 1401
      state = (ngx_http_ssi_state_e )17;
#line 1402
      goto switch_break;
    }
#line 1405
    tmp___8 = (ctx->param)->value.len;
#line 1405
    ((ctx->param)->value.len) ++;
#line 1405
    *((ctx->param)->value.data + tmp___8) = ch;
#line 1407
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1411
    if ((ctx->param)->value.len + 1UL < ctx->value_len / 2UL) {
      {
#line 1412
      tmp___9 = ngx_pnalloc(r->pool, (ctx->param)->value.len + 1UL);
#line 1412
      value = (u_char *)tmp___9;
      }
#line 1413
      if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1414
        return ((ngx_int_t )-1);
      }
      {
#line 1417
      memcpy((void */* __restrict  */)value, (void const   */* __restrict  */)(ctx->param)->value.data,
             (ctx->param)->value.len);
#line 1420
      ctx->value_buf = (void *)(ctx->param)->value.data;
#line 1421
      (ctx->param)->value.data = value;
      }
    } else {
#line 1424
      ctx->value_buf = (void *)0;
    }
    {
#line 1431
    if ((int )ch == 9) {
#line 1431
      goto case_9___6;
    }
#line 1431
    if ((int )ch == 10) {
#line 1431
      goto case_9___6;
    }
#line 1431
    if ((int )ch == 13) {
#line 1431
      goto case_9___6;
    }
#line 1431
    if ((int )ch == 32) {
#line 1431
      goto case_9___6;
    }
#line 1435
    if ((int )ch == 45) {
#line 1435
      goto case_45___4;
    }
#line 1439
    goto switch_default___11;
    case_9___6: /* CIL Label */ 
    case_10___6: /* CIL Label */ 
    case_13___6: /* CIL Label */ 
    case_32___5: /* CIL Label */ 
#line 1432
    state = (ngx_http_ssi_state_e )7;
#line 1433
    goto switch_break___12;
    case_45___4: /* CIL Label */ 
#line 1436
    state = (ngx_http_ssi_state_e )15;
#line 1437
    goto switch_break___12;
    switch_default___11: /* CIL Label */ 
#line 1440
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1440
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol after \"%V\" value of \"%V\" parameter in \"%V\" SSI command",
                         (int )ch, & (ctx->param)->value, & (ctx->param)->key, & ctx->command);
      }
    }
#line 1445
    state = (ngx_http_ssi_state_e )17;
#line 1446
    goto switch_break___12;
    switch_break___12: /* CIL Label */ ;
    }
#line 1449
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1453
    if ((int )ch == 45) {
#line 1453
      goto case_45___5;
    }
#line 1457
    goto switch_default___12;
    case_45___5: /* CIL Label */ 
#line 1454
    state = (ngx_http_ssi_state_e )16;
#line 1455
    goto switch_break___13;
    switch_default___12: /* CIL Label */ 
#line 1458
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1458
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol in \"%V\" SSI command",
                         (int )ch, & ctx->command);
      }
    }
#line 1461
    state = (ngx_http_ssi_state_e )17;
#line 1462
    goto switch_break___13;
    switch_break___13: /* CIL Label */ ;
    }
#line 1465
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1469
    if ((int )ch == 62) {
#line 1469
      goto case_62;
    }
#line 1481
    goto switch_default___13;
    case_62: /* CIL Label */ 
#line 1470
    ctx->state = (ngx_uint_t )0;
#line 1471
    ctx->pos = p + 1;
#line 1472
    ctx->looked = looked;
#line 1473
    ctx->copy_end = copy_end;
#line 1475
    if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1475
      if (copy_end) {
#line 1476
        ctx->copy_start = (ctx->buf)->pos;
      }
    }
#line 1479
    return ((ngx_int_t )0);
    switch_default___13: /* CIL Label */ 
#line 1482
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1482
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol in \"%V\" SSI command",
                         (int )ch, & ctx->command);
      }
    }
#line 1485
    state = (ngx_http_ssi_state_e )17;
#line 1486
    goto switch_break___14;
    switch_break___14: /* CIL Label */ ;
    }
#line 1489
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 1493
    if ((int )ch == 45) {
#line 1493
      goto case_45___6;
    }
#line 1497
    goto switch_default___14;
    case_45___6: /* CIL Label */ 
#line 1494
    state = (ngx_http_ssi_state_e )18;
#line 1495
    goto switch_break___15;
    switch_default___14: /* CIL Label */ 
#line 1498
    goto switch_break___15;
    switch_break___15: /* CIL Label */ ;
    }
#line 1501
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 1505
    if ((int )ch == 45) {
#line 1505
      goto case_45___7;
    }
#line 1509
    goto switch_default___15;
    case_45___7: /* CIL Label */ 
#line 1506
    state = (ngx_http_ssi_state_e )19;
#line 1507
    goto switch_break___16;
    switch_default___15: /* CIL Label */ 
#line 1510
    state = (ngx_http_ssi_state_e )17;
#line 1511
    goto switch_break___16;
    switch_break___16: /* CIL Label */ ;
    }
#line 1514
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1518
    if ((int )ch == 62) {
#line 1518
      goto case_62___0;
    }
#line 1530
    goto switch_default___16;
    case_62___0: /* CIL Label */ 
#line 1519
    ctx->state = (ngx_uint_t )0;
#line 1520
    ctx->pos = p + 1;
#line 1521
    ctx->looked = looked;
#line 1522
    ctx->copy_end = copy_end;
#line 1524
    if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1524
      if (copy_end) {
#line 1525
        ctx->copy_start = (ctx->buf)->pos;
      }
    }
#line 1528
    return ((ngx_int_t )1);
    switch_default___16: /* CIL Label */ 
#line 1531
    state = (ngx_http_ssi_state_e )17;
#line 1532
    goto switch_break___17;
    switch_break___17: /* CIL Label */ ;
    }
#line 1535
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1000
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1539
  ctx->state = (ngx_uint_t )state;
#line 1540
  ctx->pos = p;
#line 1541
  ctx->looked = looked;
#line 1543
  if ((unsigned int )state == 0U) {
#line 1543
    ctx->copy_end = p;
  } else {
#line 1543
    ctx->copy_end = copy_end;
  }
#line 1545
  if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1545
    if (ctx->copy_end) {
#line 1546
      ctx->copy_start = (ctx->buf)->pos;
    }
  }
#line 1549
  return ((ngx_int_t )-2);
}
}
#line 1553 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t *ngx_http_ssi_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                            ngx_uint_t key ) 
{ 
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_http_ssi_var_t *var ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_str_t *value ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1562
  ctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 1568
  if (key >= 48UL) {
#line 1568
    if (key <= 57UL) {
#line 1569
      i = key - 48UL;
#line 1571
      if (i < ctx->ncaptures) {
        {
#line 1572
        tmp = ngx_palloc(r->pool, sizeof(ngx_str_t ));
#line 1572
        value = (ngx_str_t *)tmp;
        }
#line 1573
        if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1574
          return ((ngx_str_t *)((void *)0));
        }
#line 1577
        i *= 2UL;
#line 1579
        value->data = ctx->captures_data + *(ctx->captures + i);
#line 1580
        value->len = (size_t___0 )(*(ctx->captures + (i + 1UL)) - *(ctx->captures + i));
#line 1582
        return (value);
      }
    }
  }
#line 1588
  if ((unsigned long )ctx->variables == (unsigned long )((void *)0)) {
#line 1589
    return ((ngx_str_t *)((void *)0));
  }
#line 1592
  part = & (ctx->variables)->part;
#line 1593
  var = (ngx_http_ssi_var_t *)part->elts;
#line 1595
  i = (ngx_uint_t )0;
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1597
    if (i >= part->nelts) {
#line 1598
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1599
        goto while_break;
      }
#line 1602
      part = part->next;
#line 1603
      var = (ngx_http_ssi_var_t *)part->elts;
#line 1604
      i = (ngx_uint_t )0;
    }
#line 1607
    if (name->len != (var + i)->name.len) {
#line 1608
      goto __Cont;
    }
#line 1611
    if (key != (var + i)->key) {
#line 1612
      goto __Cont;
    }
    {
#line 1615
    tmp___0 = strncmp((char const   *)name->data, (char const   *)(var + i)->name.data,
                      name->len);
    }
#line 1615
    if (tmp___0 == 0) {
#line 1616
      return (& (var + i)->value);
    }
    __Cont: /* CIL Label */ 
#line 1595
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1620
  return ((ngx_str_t *)((void *)0));
}
}
#line 1624 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_evaluate_string(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                              ngx_str_t *text , ngx_uint_t flags ) 
{ 
  u_char ch ;
  u_char *p ;
  u_char **value ;
  u_char *data ;
  u_char *part_data ;
  size_t___0 *size ;
  size_t___0 len ;
  size_t___0 prefix ;
  size_t___0 part_len ;
  ngx_str_t var ;
  ngx_str_t *val ;
  ngx_int_t key ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t bracket ;
  ngx_uint_t quoted ;
  ngx_array_t lengths ;
  ngx_array_t values ;
  ngx_http_variable_value_t *vv ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_uint_t tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
  {
#line 1636
  n = ngx_http_script_variables_count(text);
  }
#line 1638
  if (n == 0UL) {
#line 1640
    data = text->data;
#line 1641
    p = data;
#line 1643
    if (flags & 1UL) {
#line 1643
      if ((int )*(text->data + 0) != 47) {
#line 1645
        prefix = r->uri.len;
        {
#line 1645
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1645
          if (! prefix) {
#line 1645
            goto while_break;
          }
#line 1646
          if ((int )*(r->uri.data + (prefix - 1UL)) == 47) {
#line 1647
            goto while_break;
          }
#line 1645
          prefix --;
        }
        while_break: /* CIL Label */ ;
        }
#line 1651
        if (prefix) {
          {
#line 1652
          len = prefix + text->len;
#line 1654
          tmp = ngx_pnalloc(r->pool, len);
#line 1654
          data = (u_char *)tmp;
          }
#line 1655
          if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1656
            return ((ngx_int_t )-1);
          }
          {
#line 1659
          tmp___0 = memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)r->uri.data,
                           prefix);
#line 1659
          p = (u_char *)tmp___0 + prefix;
          }
        }
      }
    }
#line 1663
    quoted = (ngx_uint_t )0;
#line 1665
    i = (ngx_uint_t )0;
    {
#line 1665
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1665
      if (! (i < text->len)) {
#line 1665
        goto while_break___0;
      }
#line 1666
      ch = *(text->data + i);
#line 1668
      if (! quoted) {
#line 1670
        if ((int )ch == 92) {
#line 1671
          quoted = (ngx_uint_t )1;
#line 1672
          goto __Cont;
        }
      } else {
#line 1676
        quoted = (ngx_uint_t )0;
#line 1678
        if ((int )ch != 92) {
#line 1678
          if ((int )ch != 39) {
#line 1678
            if ((int )ch != 34) {
#line 1678
              if ((int )ch != 36) {
#line 1679
                tmp___1 = p;
#line 1679
                p ++;
#line 1679
                *tmp___1 = (u_char )'\\';
              }
            }
          }
        }
      }
#line 1683
      tmp___2 = p;
#line 1683
      p ++;
#line 1683
      *tmp___2 = ch;
      __Cont: /* CIL Label */ 
#line 1665
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1686
    text->len = (size_t___0 )(p - data);
#line 1687
    text->data = data;
#line 1689
    return ((ngx_int_t )0);
  }
  {
#line 1692
  tmp___3 = ngx_array_init(& lengths, r->pool, (ngx_uint_t )8, sizeof(size_t___0 *));
  }
#line 1692
  if (tmp___3 != 0L) {
#line 1693
    return ((ngx_int_t )-1);
  }
  {
#line 1696
  tmp___4 = ngx_array_init(& values, r->pool, (ngx_uint_t )8, sizeof(u_char *));
  }
#line 1696
  if (tmp___4 != 0L) {
#line 1697
    return ((ngx_int_t )-1);
  }
#line 1700
  len = (size_t___0 )0;
#line 1701
  i = (ngx_uint_t )0;
  {
#line 1703
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1703
    if (! (i < text->len)) {
#line 1703
      goto while_break___1;
    }
#line 1705
    if ((int )*(text->data + i) == 36) {
#line 1707
      var.len = (size_t___0 )0;
#line 1709
      i ++;
#line 1709
      if (i == text->len) {
#line 1710
        goto invalid_variable;
      }
#line 1713
      if ((int )*(text->data + i) == 123) {
#line 1714
        bracket = (ngx_uint_t )1;
#line 1716
        i ++;
#line 1716
        if (i == text->len) {
#line 1717
          goto invalid_variable;
        }
#line 1720
        var.data = text->data + i;
      } else {
#line 1723
        bracket = (ngx_uint_t )0;
#line 1724
        var.data = text->data + i;
      }
      {
#line 1727
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1727
        if (! (i < text->len)) {
#line 1727
          goto while_break___2;
        }
#line 1728
        ch = *(text->data + i);
#line 1730
        if ((int )ch == 125) {
#line 1730
          if (bracket) {
#line 1731
            i ++;
#line 1732
            bracket = (ngx_uint_t )0;
#line 1733
            goto while_break___2;
          }
        }
#line 1736
        if ((int )ch >= 65) {
#line 1736
          if ((int )ch <= 90) {
#line 1741
            goto __Cont___0;
          } else {
#line 1736
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1736
        if ((int )ch >= 97) {
#line 1736
          if ((int )ch <= 122) {
#line 1741
            goto __Cont___0;
          } else {
#line 1736
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1736
        if ((int )ch >= 48) {
#line 1736
          if ((int )ch <= 57) {
#line 1741
            goto __Cont___0;
          } else {
#line 1736
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1736
        if ((int )ch == 95) {
#line 1741
          goto __Cont___0;
        }
#line 1744
        goto while_break___2;
        __Cont___0: /* CIL Label */ 
#line 1727
        i ++;
#line 1727
        (var.len) ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1747
      if (bracket) {
#line 1748
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 1748
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the closing bracket in \"%V\" variable is missing",
                             & var);
          }
        }
#line 1751
        return ((ngx_int_t )1);
      }
#line 1754
      if (var.len == 0UL) {
#line 1755
        goto invalid_variable;
      }
      {
#line 1758
      tmp___5 = ngx_hash_strlow(var.data, var.data, var.len);
#line 1758
      key = (ngx_int_t )tmp___5;
#line 1760
      val = ngx_http_ssi_get_variable(r, & var, (ngx_uint_t )key);
      }
#line 1762
      if ((unsigned long )val == (unsigned long )((void *)0)) {
        {
#line 1763
        vv = ngx_http_get_variable(r, & var, (ngx_uint_t )key);
        }
#line 1764
        if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 1765
          return ((ngx_int_t )-1);
        }
#line 1768
        if (vv->not_found) {
#line 1769
          goto while_continue___1;
        }
#line 1772
        part_data = vv->data;
#line 1773
        part_len = (size_t___0 )vv->len;
      } else {
#line 1776
        part_data = val->data;
#line 1777
        part_len = val->len;
      }
    } else {
#line 1781
      part_data = text->data + i;
#line 1782
      quoted = (ngx_uint_t )0;
#line 1784
      p = part_data;
      {
#line 1784
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1784
        if (! (i < text->len)) {
#line 1784
          goto while_break___3;
        }
#line 1785
        ch = *(text->data + i);
#line 1787
        if (! quoted) {
#line 1789
          if ((int )ch == 92) {
#line 1790
            quoted = (ngx_uint_t )1;
#line 1791
            goto __Cont___1;
          }
#line 1794
          if ((int )ch == 36) {
#line 1795
            goto while_break___3;
          }
        } else {
#line 1799
          quoted = (ngx_uint_t )0;
#line 1801
          if ((int )ch != 92) {
#line 1801
            if ((int )ch != 39) {
#line 1801
              if ((int )ch != 34) {
#line 1801
                if ((int )ch != 36) {
#line 1802
                  tmp___6 = p;
#line 1802
                  p ++;
#line 1802
                  *tmp___6 = (u_char )'\\';
                }
              }
            }
          }
        }
#line 1806
        tmp___7 = p;
#line 1806
        p ++;
#line 1806
        *tmp___7 = ch;
        __Cont___1: /* CIL Label */ 
#line 1784
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1809
      part_len = (size_t___0 )(p - part_data);
    }
    {
#line 1812
    len += part_len;
#line 1814
    tmp___8 = ngx_array_push(& lengths);
#line 1814
    size = (size_t___0 *)tmp___8;
    }
#line 1815
    if ((unsigned long )size == (unsigned long )((void *)0)) {
#line 1816
      return ((ngx_int_t )-1);
    }
    {
#line 1819
    *size = part_len;
#line 1821
    tmp___9 = ngx_array_push(& values);
#line 1821
    value = (u_char **)tmp___9;
    }
#line 1822
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1823
      return ((ngx_int_t )-1);
    }
#line 1826
    *value = part_data;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1829
  prefix = (size_t___0 )0;
#line 1831
  size = (size_t___0 *)lengths.elts;
#line 1832
  value = (u_char **)values.elts;
#line 1834
  if (flags & 1UL) {
#line 1835
    i = (ngx_uint_t )0;
    {
#line 1835
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1835
      if (! (i < values.nelts)) {
#line 1835
        goto while_break___4;
      }
#line 1836
      if (*(size + i) != 0UL) {
#line 1837
        if ((int )*(*(value + i)) != 47) {
#line 1838
          prefix = r->uri.len;
          {
#line 1838
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1838
            if (! prefix) {
#line 1838
              goto while_break___5;
            }
#line 1839
            if ((int )*(r->uri.data + (prefix - 1UL)) == 47) {
#line 1840
              len += prefix;
#line 1841
              goto while_break___5;
            }
#line 1838
            prefix --;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 1846
        goto while_break___4;
      }
#line 1835
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1851
  if (flags & 2UL) {
#line 1851
    tmp___10 = 1;
  } else {
#line 1851
    tmp___10 = 0;
  }
  {
#line 1851
  tmp___11 = ngx_pnalloc(r->pool, len + (size_t___0 )tmp___10);
#line 1851
  p = (u_char *)tmp___11;
  }
#line 1852
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1853
    return ((ngx_int_t )-1);
  }
  {
#line 1856
  text->len = len;
#line 1857
  text->data = p;
#line 1859
  tmp___12 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)r->uri.data,
                    prefix);
#line 1859
  p = (u_char *)tmp___12 + prefix;
#line 1861
  i = (ngx_uint_t )0;
  }
  {
#line 1861
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1861
    if (! (i < values.nelts)) {
#line 1861
      goto while_break___6;
    }
    {
#line 1862
    tmp___13 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)*(value + i),
                      *(size + i));
#line 1862
    p = (u_char *)tmp___13 + *(size + i);
#line 1861
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1865
  return ((ngx_int_t )0);
  invalid_variable: 
#line 1869
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 1869
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid variable name in \"%V\"",
                       text);
    }
  }
#line 1872
  return ((ngx_int_t )1);
}
}
#line 1876 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_regex_match(ngx_http_request_t *r , ngx_str_t *pattern ,
                                          ngx_str_t *str ) 
{ 
  int rc ;
  int *captures ;
  u_char *p ;
  u_char errstr[1024] ;
  size_t___0 size ;
  ngx_int_t key ;
  ngx_str_t *vv ;
  ngx_str_t name ;
  ngx_str_t value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_http_ssi_var_t *var ;
  ngx_regex_compile_t rgc ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_uint_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1891
  memset((void *)(& rgc), 0, sizeof(ngx_regex_compile_t ));
#line 1893
  rgc.pattern = *pattern;
#line 1894
  rgc.pool = r->pool;
#line 1895
  rgc.err.len = (size_t___0 )1024;
#line 1896
  rgc.err.data = errstr;
#line 1898
  tmp = ngx_regex_compile(& rgc);
  }
#line 1898
  if (tmp != 0L) {
#line 1899
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1899
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%V", & rgc.err);
      }
    }
#line 1900
    return ((ngx_int_t )1);
  }
  {
#line 1903
  n = (ngx_uint_t )((rgc.captures + 1) * 3);
#line 1905
  tmp___0 = ngx_palloc(r->pool, n * sizeof(int ));
#line 1905
  captures = (int *)tmp___0;
  }
#line 1906
  if ((unsigned long )captures == (unsigned long )((void *)0)) {
#line 1907
    return ((ngx_int_t )-1);
  }
  {
#line 1910
  rc = pcre_exec((pcre const   *)(rgc.regex)->code, (pcre_extra const   *)(rgc.regex)->extra,
                 (char const   *)str->data, (int )str->len, 0, 0, captures, (int )n);
  }
#line 1912
  if (rc < -1) {
#line 1913
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 1913
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "pcre_exec() failed: %d on \"%V\" using \"%V\"",
                         rc, str, pattern);
      }
    }
#line 1916
    return ((ngx_int_t )1);
  }
#line 1919
  if (rc == -1) {
#line 1920
    return ((ngx_int_t )-5);
  }
#line 1923
  ctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 1925
  ctx->ncaptures = (ngx_uint_t )rc;
#line 1926
  ctx->captures = captures;
#line 1927
  ctx->captures_data = str->data;
#line 1929
  if (rgc.named_captures > 0) {
#line 1931
    if ((unsigned long )ctx->variables == (unsigned long )((void *)0)) {
      {
#line 1932
      ctx->variables = ngx_list_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_var_t ));
      }
#line 1934
      if ((unsigned long )ctx->variables == (unsigned long )((void *)0)) {
#line 1935
        return ((ngx_int_t )-1);
      }
    }
#line 1939
    size = (size_t___0 )rgc.name_size;
#line 1940
    p = rgc.names;
#line 1942
    i = (ngx_uint_t )0;
    {
#line 1942
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1942
      if (! (i < (ngx_uint_t )rgc.named_captures)) {
#line 1942
        goto while_break;
      }
      {
#line 1944
      name.data = p + 2;
#line 1945
      name.len = strlen((char const   *)name.data);
#line 1947
      n = (ngx_uint_t )(2 * (((int )*(p + 0) << 8) + (int )*(p + 1)));
#line 1949
      value.data = str->data + *(captures + n);
#line 1950
      value.len = (size_t___0 )(*(captures + (n + 1UL)) - *(captures + n));
#line 1952
      tmp___1 = ngx_hash_strlow(name.data, name.data, name.len);
#line 1952
      key = (ngx_int_t )tmp___1;
#line 1954
      vv = ngx_http_ssi_get_variable(r, & name, (ngx_uint_t )key);
      }
#line 1956
      if (vv) {
#line 1957
        *vv = value;
#line 1958
        goto __Cont;
      }
      {
#line 1961
      tmp___2 = ngx_list_push(ctx->variables);
#line 1961
      var = (ngx_http_ssi_var_t *)tmp___2;
      }
#line 1962
      if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 1963
        return ((ngx_int_t )-1);
      }
#line 1966
      var->name = name;
#line 1967
      var->key = (ngx_uint_t )key;
#line 1968
      var->value = value;
      __Cont: /* CIL Label */ 
#line 1942
      i ++;
#line 1942
      p += size;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1972
  return ((ngx_int_t )0);
}
}
#line 1985 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_include(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                      ngx_str_t **params ) 
{ 
  ngx_int_t rc ;
  ngx_int_t key ;
  ngx_str_t *uri___0 ;
  ngx_str_t *file ;
  ngx_str_t *wait___0 ;
  ngx_str_t *set ;
  ngx_str_t *stub ;
  ngx_str_t args___0 ;
  ngx_buf_t *b ;
  ngx_uint_t flags ;
  ngx_uint_t i ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_chain_t *out ;
  ngx_http_request_t *sr ;
  ngx_http_ssi_var_t *var ;
  ngx_http_ssi_ctx_t *mctx ;
  ngx_http_ssi_block_t *bl ;
  ngx_http_post_subrequest_t *psr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_uint_t tmp___5 ;
  ngx_uint_t tmp___6 ;
  void *tmp___7 ;
  ngx_str_t *tmp___8 ;
  void *tmp___9 ;
  ngx_int_t tmp___10 ;

  {
#line 2000
  uri___0 = *(params + 0);
#line 2001
  file = *(params + 1);
#line 2002
  wait___0 = *(params + 2);
#line 2003
  set = *(params + 3);
#line 2004
  stub = *(params + 4);
#line 2006
  if (uri___0) {
#line 2006
    if (file) {
#line 2007
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2007
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "inclusion may be either virtual=\"%V\" or file=\"%V\"",
                           uri___0, file);
        }
      }
#line 2010
      return ((ngx_int_t )1);
    }
  }
#line 2013
  if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 2013
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 2014
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2014
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no parameter in \"include\" SSI command");
        }
      }
#line 2016
      return ((ngx_int_t )1);
    }
  }
#line 2019
  if (set) {
#line 2019
    if (stub) {
#line 2020
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2020
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "\"set\" and \"stub\" cannot be used together in \"include\" SSI command");
        }
      }
#line 2023
      return ((ngx_int_t )1);
    }
  }
#line 2026
  if (wait___0) {
#line 2027
    if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 2028
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2028
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "\"wait\" cannot be used with file=\"%V\"",
                           file);
        }
      }
#line 2030
      return ((ngx_int_t )1);
    }
#line 2033
    if (wait___0->len == 2UL) {
      {
#line 2033
      tmp___0 = ngx_strncasecmp(wait___0->data, (u_char *)"no", (size_t___0 )2);
      }
#line 2033
      if (tmp___0 == 0L) {
#line 2036
        wait___0 = (ngx_str_t *)((void *)0);
      } else {
#line 2033
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2038
    if (wait___0->len != 3UL) {
#line 2038
      goto _L;
    } else {
      {
#line 2038
      tmp = ngx_strncasecmp(wait___0->data, (u_char *)"yes", (size_t___0 )3);
      }
#line 2038
      if (tmp != 0L) {
        _L: /* CIL Label */ 
#line 2041
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 2041
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid value \"%V\" in the \"wait\" parameter",
                             wait___0);
          }
        }
#line 2044
        return ((ngx_int_t )1);
      }
    }
  }
#line 2048
  if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 2049
    uri___0 = file;
#line 2050
    wait___0 = (ngx_str_t *)-1;
  }
  {
#line 2053
  rc = ngx_http_ssi_evaluate_string(r, ctx, uri___0, (ngx_uint_t )1);
  }
#line 2055
  if (rc != 0L) {
#line 2056
    return (rc);
  }
  {
#line 2062
  args___0.len = (size_t___0 )0;
#line 2062
  args___0.data = (u_char *)((void *)0);
#line 2063
  flags = (ngx_uint_t )1;
#line 2065
  tmp___1 = ngx_http_parse_unsafe_uri(r, uri___0, & args___0, & flags);
  }
#line 2065
  if (tmp___1 != 0L) {
#line 2066
    return ((ngx_int_t )1);
  }
#line 2069
  psr = (ngx_http_post_subrequest_t *)((void *)0);
#line 2071
  mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2073
  if (stub) {
#line 2074
    if (mctx->blocks) {
#line 2075
      bl = (ngx_http_ssi_block_t *)(mctx->blocks)->elts;
#line 2076
      i = (ngx_uint_t )0;
      {
#line 2076
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2076
        if (! (i < (mctx->blocks)->nelts)) {
#line 2076
          goto while_break;
        }
#line 2077
        if (stub->len == (bl + i)->name.len) {
          {
#line 2077
          tmp___2 = strncmp((char const   *)stub->data, (char const   *)(bl + i)->name.data,
                            stub->len);
          }
#line 2077
          if (tmp___2 == 0) {
#line 2080
            goto found;
          }
        }
#line 2076
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 2085
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2085
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "\"stub\"=\"%V\" for \"include\" not found",
                         stub);
      }
    }
#line 2087
    return ((ngx_int_t )1);
    found: 
    {
#line 2091
    tmp___3 = ngx_palloc(r->pool, sizeof(ngx_http_post_subrequest_t ));
#line 2091
    psr = (ngx_http_post_subrequest_t *)tmp___3;
    }
#line 2092
    if ((unsigned long )psr == (unsigned long )((void *)0)) {
#line 2093
      return ((ngx_int_t )-1);
    }
#line 2096
    psr->handler = & ngx_http_ssi_stub_output;
#line 2098
    tmp___5 = (bl + i)->count;
#line 2098
    ((bl + i)->count) ++;
#line 2098
    if (tmp___5) {
#line 2100
      out = (ngx_chain_t *)((void *)0);
#line 2101
      ll = & out;
#line 2103
      tl = (bl + i)->bufs;
      {
#line 2103
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2103
        if (! tl) {
#line 2103
          goto while_break___0;
        }
#line 2105
        if (ctx->free) {
#line 2106
          cl = ctx->free;
#line 2107
          ctx->free = (ctx->free)->next;
#line 2108
          b = cl->buf;
        } else {
          {
#line 2111
          tmp___4 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 2111
          b = (ngx_buf_t *)tmp___4;
          }
#line 2112
          if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 2113
            return ((ngx_int_t )-1);
          }
          {
#line 2116
          cl = ngx_alloc_chain_link(r->pool);
          }
#line 2117
          if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2118
            return ((ngx_int_t )-1);
          }
#line 2121
          cl->buf = b;
        }
        {
#line 2124
        memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)tl->buf,
               sizeof(ngx_buf_t ));
#line 2126
        b->pos = b->start;
#line 2128
        *ll = cl;
#line 2129
        cl->next = (ngx_chain_t *)((void *)0);
#line 2130
        ll = & cl->next;
#line 2103
        tl = tl->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2133
      psr->data = (void *)out;
    } else {
#line 2136
      psr->data = (void *)(bl + i)->bufs;
    }
  }
#line 2140
  if (wait___0) {
#line 2141
    flags |= 4UL;
  }
#line 2144
  if (set) {
    {
#line 2145
    tmp___6 = ngx_hash_strlow(set->data, set->data, set->len);
#line 2145
    key = (ngx_int_t )tmp___6;
#line 2147
    tmp___7 = ngx_palloc(r->pool, sizeof(ngx_http_post_subrequest_t ));
#line 2147
    psr = (ngx_http_post_subrequest_t *)tmp___7;
    }
#line 2148
    if ((unsigned long )psr == (unsigned long )((void *)0)) {
#line 2149
      return ((ngx_int_t )-1);
    }
    {
#line 2152
    psr->handler = & ngx_http_ssi_set_variable;
#line 2153
    tmp___8 = ngx_http_ssi_get_variable(r, set, (ngx_uint_t )key);
#line 2153
    psr->data = (void *)tmp___8;
    }
#line 2155
    if ((unsigned long )psr->data == (unsigned long )((void *)0)) {
#line 2157
      if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
        {
#line 2158
        mctx->variables = ngx_list_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_var_t ));
        }
#line 2160
        if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
#line 2161
          return ((ngx_int_t )-1);
        }
      }
      {
#line 2165
      tmp___9 = ngx_list_push(mctx->variables);
#line 2165
      var = (ngx_http_ssi_var_t *)tmp___9;
      }
#line 2166
      if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2167
        return ((ngx_int_t )-1);
      }
#line 2170
      var->name = *set;
#line 2171
      var->key = (ngx_uint_t )key;
#line 2172
      var->value = ngx_http_ssi_null_string;
#line 2173
      psr->data = (void *)(& var->value);
    }
#line 2176
    flags |= 6UL;
  }
  {
#line 2179
  tmp___10 = ngx_http_subrequest(r, uri___0, & args___0, & sr, psr, flags);
  }
#line 2179
  if (tmp___10 != 0L) {
#line 2180
    return ((ngx_int_t )1);
  }
#line 2183
  if ((unsigned long )wait___0 == (unsigned long )((void *)0)) {
#line 2183
    if ((unsigned long )set == (unsigned long )((void *)0)) {
#line 2184
      return ((ngx_int_t )0);
    }
  }
#line 2187
  if ((unsigned long )ctx->wait == (unsigned long )((void *)0)) {
#line 2188
    ctx->wait = sr;
#line 2190
    return ((ngx_int_t )-2);
  } else
#line 2193
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 2193
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "can only wait for one subrequest at a time");
    }
  }
#line 2197
  return ((ngx_int_t )0);
}
}
#line 2201 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_stub_output(ngx_http_request_t *r , void *data , ngx_int_t rc ) 
{ 
  ngx_chain_t *out ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 2206
  if (rc == -1L) {
#line 2207
    return (rc);
  } else
#line 2206
  if ((r->connection)->error) {
#line 2207
    return (rc);
  } else
#line 2206
  if (r->request_output) {
#line 2207
    return (rc);
  }
#line 2213
  out = (ngx_chain_t *)data;
#line 2215
  if (! r->header_sent) {
    {
#line 2216
    r->headers_out.content_type_len = (r->parent)->headers_out.content_type_len;
#line 2218
    r->headers_out.content_type = (r->parent)->headers_out.content_type;
#line 2220
    tmp = ngx_http_send_header(r);
    }
#line 2220
    if (tmp == -1L) {
#line 2221
      return ((ngx_int_t )-1);
    }
  }
  {
#line 2225
  tmp___0 = ngx_http_output_filter(r, out);
  }
#line 2225
  return (tmp___0);
}
}
#line 2229 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_set_variable(ngx_http_request_t *r , void *data , ngx_int_t rc ) 
{ 
  ngx_str_t *value ;

  {
#line 2232
  value = (ngx_str_t *)data;
#line 2234
  if (r->upstream) {
#line 2235
    value->len = (size_t___0 )((r->upstream)->buffer.last - (r->upstream)->buffer.pos);
#line 2236
    value->data = (r->upstream)->buffer.pos;
  }
#line 2239
  return (rc);
}
}
#line 2243 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_echo(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) 
{ 
  u_char *p ;
  uintptr_t len ;
  ngx_int_t key ;
  ngx_buf_t *b ;
  ngx_str_t *var ;
  ngx_str_t *value ;
  ngx_str_t *enc ;
  ngx_str_t text ;
  ngx_chain_t *cl ;
  ngx_http_variable_value_t *vv ;
  ngx_uint_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uintptr_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 2255
  var = *(params + 0);
#line 2260
  tmp = ngx_hash_strlow(var->data, var->data, var->len);
#line 2260
  key = (ngx_int_t )tmp;
#line 2262
  value = ngx_http_ssi_get_variable(r, var, (ngx_uint_t )key);
  }
#line 2264
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 2265
    vv = ngx_http_get_variable(r, var, (ngx_uint_t )key);
    }
#line 2267
    if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 2268
      return ((ngx_int_t )1);
    }
#line 2271
    if (! vv->not_found) {
#line 2272
      text.data = vv->data;
#line 2273
      text.len = (size_t___0 )vv->len;
#line 2274
      value = & text;
    }
  }
#line 2278
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 2279
    value = *(params + 1);
#line 2281
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 2282
      value = & ngx_http_ssi_none;
    } else
#line 2284
    if (value->len == 0UL) {
#line 2285
      return ((ngx_int_t )0);
    }
  } else
#line 2289
  if (value->len == 0UL) {
#line 2290
    return ((ngx_int_t )0);
  }
#line 2294
  enc = *(params + 2);
#line 2296
  if (enc) {
#line 2297
    if (enc->len == 4UL) {
      {
#line 2297
      tmp___2 = strncmp((char const   *)enc->data, "none", (size_t )4);
      }
#line 2297
      if (tmp___2 == 0) {
#line 2299
        ctx->encoding = 0U;
      } else {
#line 2297
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2301
    if (enc->len == 3UL) {
      {
#line 2301
      tmp___1 = strncmp((char const   *)enc->data, "url", (size_t )3);
      }
#line 2301
      if (tmp___1 == 0) {
#line 2303
        ctx->encoding = 1U;
      } else {
#line 2301
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2305
    if (enc->len == 6UL) {
      {
#line 2305
      tmp___0 = strncmp((char const   *)enc->data, "entity", (size_t )6);
      }
#line 2305
      if (tmp___0 == 0) {
#line 2307
        ctx->encoding = 2U;
      } else {
#line 2305
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2310
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2310
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unknown encoding \"%V\" in the \"echo\" command",
                         enc);
      }
    }
  }
#line 2316
  p = value->data;
  {
#line 2320
  if (ctx->encoding == 1U) {
#line 2320
    goto case_1;
  }
#line 2336
  if (ctx->encoding == 2U) {
#line 2336
    goto case_2;
  }
#line 2351
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2321
  tmp___3 = ngx_escape_uri((u_char *)((void *)0), value->data, value->len, (ngx_uint_t )3);
#line 2321
  len = 2UL * tmp___3;
  }
#line 2324
  if (len) {
    {
#line 2325
    tmp___4 = ngx_pnalloc(r->pool, value->len + len);
#line 2325
    p = (u_char *)tmp___4;
    }
#line 2326
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2327
      return ((ngx_int_t )1);
    }
    {
#line 2330
    ngx_escape_uri(p, value->data, value->len, (ngx_uint_t )3);
    }
  }
#line 2333
  len += value->len;
#line 2334
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2337
  len = ngx_escape_html((u_char *)((void *)0), value->data, value->len);
  }
#line 2339
  if (len) {
    {
#line 2340
    tmp___5 = ngx_pnalloc(r->pool, value->len + len);
#line 2340
    p = (u_char *)tmp___5;
    }
#line 2341
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2342
      return ((ngx_int_t )1);
    }
    {
#line 2345
    ngx_escape_html(p, value->data, value->len);
    }
  }
#line 2348
  len += value->len;
#line 2349
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2352
  len = value->len;
#line 2353
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2356
  tmp___6 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 2356
  b = (ngx_buf_t *)tmp___6;
  }
#line 2357
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 2358
    return ((ngx_int_t )1);
  }
  {
#line 2361
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 2362
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2363
    return ((ngx_int_t )1);
  }
#line 2366
  b->memory = 1U;
#line 2367
  b->pos = p;
#line 2368
  b->last = p + len;
#line 2370
  cl->buf = b;
#line 2371
  cl->next = (ngx_chain_t *)((void *)0);
#line 2372
  *(ctx->last_out) = cl;
#line 2373
  ctx->last_out = & cl->next;
#line 2375
  return ((ngx_int_t )0);
}
}
#line 2379 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_config(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                     ngx_str_t **params ) 
{ 
  ngx_str_t *value ;
  void *tmp ;

  {
#line 2385
  value = *(params + 1);
#line 2387
  if (value) {
    {
#line 2388
    ctx->timefmt.len = value->len;
#line 2389
    tmp = ngx_pnalloc(r->pool, value->len + 1UL);
#line 2389
    ctx->timefmt.data = (u_char *)tmp;
    }
#line 2390
    if ((unsigned long )ctx->timefmt.data == (unsigned long )((void *)0)) {
#line 2391
      return ((ngx_int_t )-1);
    }
    {
#line 2394
    ngx_cpystrn(ctx->timefmt.data, value->data, value->len + 1UL);
    }
  }
#line 2397
  value = *(params + 0);
#line 2399
  if (value) {
#line 2400
    ctx->errmsg = *value;
  }
#line 2403
  return ((ngx_int_t )0);
}
}
#line 2407 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_set(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                  ngx_str_t **params ) 
{ 
  ngx_int_t key ;
  ngx_int_t rc ;
  ngx_str_t *name ;
  ngx_str_t *value ;
  ngx_str_t *vv ;
  ngx_http_ssi_var_t *var ;
  ngx_http_ssi_ctx_t *mctx ;
  ngx_uint_t tmp ;
  void *tmp___0 ;

  {
#line 2416
  mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2418
  if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
    {
#line 2419
    mctx->variables = ngx_list_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_var_t ));
    }
#line 2421
    if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
#line 2422
      return ((ngx_int_t )-1);
    }
  }
  {
#line 2426
  name = *(params + 0);
#line 2427
  value = *(params + 1);
#line 2432
  rc = ngx_http_ssi_evaluate_string(r, ctx, value, (ngx_uint_t )0);
  }
#line 2434
  if (rc != 0L) {
#line 2435
    return (rc);
  }
  {
#line 2438
  tmp = ngx_hash_strlow(name->data, name->data, name->len);
#line 2438
  key = (ngx_int_t )tmp;
#line 2440
  vv = ngx_http_ssi_get_variable(r, name, (ngx_uint_t )key);
  }
#line 2442
  if (vv) {
#line 2443
    *vv = *value;
#line 2444
    return ((ngx_int_t )0);
  }
  {
#line 2447
  tmp___0 = ngx_list_push(mctx->variables);
#line 2447
  var = (ngx_http_ssi_var_t *)tmp___0;
  }
#line 2448
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2449
    return ((ngx_int_t )-1);
  }
#line 2452
  var->name = *name;
#line 2453
  var->key = (ngx_uint_t )key;
#line 2454
  var->value = *value;
#line 2459
  return ((ngx_int_t )0);
}
}
#line 2463 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_if(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                 ngx_str_t **params ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_str_t *expr ;
  ngx_str_t left ;
  ngx_str_t right ;
  ngx_int_t rc ;
  ngx_uint_t negative ;
  ngx_uint_t noregex ;
  ngx_uint_t flags ;
  int tmp ;

  {
#line 2472
  if (ctx->command.len == 2UL) {
#line 2473
    if (ctx->conditional) {
#line 2474
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2474
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the \"if\" command inside the \"if\" command");
        }
      }
#line 2476
      return ((ngx_int_t )1);
    }
  }
#line 2480
  if (ctx->output_chosen) {
#line 2481
    ctx->output = 0U;
#line 2482
    return ((ngx_int_t )0);
  }
#line 2485
  expr = *(params + 0);
#line 2490
  left.data = expr->data;
#line 2491
  last = expr->data + expr->len;
#line 2493
  p = left.data;
  {
#line 2493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2493
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2493
      goto while_break;
    }
#line 2494
    if ((int )*p >= 65) {
#line 2494
      if ((int )*p <= 90) {
#line 2495
        *p = (u_char )((int )*p | 32);
#line 2496
        goto __Cont;
      }
    }
#line 2499
    if ((int )*p >= 97) {
#line 2499
      if ((int )*p <= 122) {
#line 2504
        goto __Cont;
      } else {
#line 2499
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2499
    if ((int )*p >= 48) {
#line 2499
      if ((int )*p <= 57) {
#line 2504
        goto __Cont;
      } else {
#line 2499
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2499
    if ((int )*p == 36) {
#line 2504
      goto __Cont;
    } else
#line 2499
    if ((int )*p == 123) {
#line 2504
      goto __Cont;
    } else
#line 2499
    if ((int )*p == 125) {
#line 2504
      goto __Cont;
    } else
#line 2499
    if ((int )*p == 95) {
#line 2504
      goto __Cont;
    } else
#line 2499
    if ((int )*p == 34) {
#line 2504
      goto __Cont;
    } else
#line 2499
    if ((int )*p == 39) {
#line 2504
      goto __Cont;
    }
#line 2507
    goto while_break;
    __Cont: /* CIL Label */ 
#line 2493
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2510
  left.len = (size_t___0 )(p - left.data);
  {
#line 2512
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2512
    if ((unsigned long )p < (unsigned long )last) {
#line 2512
      if (! ((int )*p == 32)) {
#line 2512
        goto while_break___0;
      }
    } else {
#line 2512
      goto while_break___0;
    }
#line 2513
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2516
  flags = (ngx_uint_t )0;
#line 2521
  rc = ngx_http_ssi_evaluate_string(r, ctx, & left, flags);
  }
#line 2523
  if (rc != 0L) {
#line 2524
    return (rc);
  }
#line 2530
  if ((unsigned long )p == (unsigned long )last) {
#line 2531
    if (left.len) {
#line 2532
      ctx->output = 1U;
#line 2533
      ctx->output_chosen = 1U;
    } else {
#line 2536
      ctx->output = 0U;
    }
#line 2539
    ctx->conditional = 1U;
#line 2541
    return ((ngx_int_t )0);
  }
#line 2544
  if ((unsigned long )p < (unsigned long )last) {
#line 2544
    if ((int )*p == 61) {
#line 2545
      negative = (ngx_uint_t )0;
#line 2546
      p ++;
    } else {
#line 2544
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2548
  if ((unsigned long )(p + 1) < (unsigned long )last) {
#line 2548
    if ((int )*p == 33) {
#line 2548
      if ((int )*(p + 1) == 61) {
#line 2549
        negative = (ngx_uint_t )1;
#line 2550
        p += 2;
      } else {
#line 2553
        goto invalid_expression;
      }
    } else {
#line 2553
      goto invalid_expression;
    }
  } else {
#line 2553
    goto invalid_expression;
  }
  {
#line 2556
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2556
    if ((unsigned long )p < (unsigned long )last) {
#line 2556
      if (! ((int )*p == 32)) {
#line 2556
        goto while_break___1;
      }
    } else {
#line 2556
      goto while_break___1;
    }
#line 2557
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2560
  if ((unsigned long )p < (unsigned long )(last - 1)) {
#line 2560
    if ((int )*p == 47) {
#line 2561
      if ((int )*(last - 1) != 47) {
#line 2562
        goto invalid_expression;
      }
#line 2565
      noregex = (ngx_uint_t )0;
#line 2566
      flags = (ngx_uint_t )2;
#line 2567
      last --;
#line 2568
      p ++;
    } else {
#line 2560
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 2571
    noregex = (ngx_uint_t )1;
#line 2572
    flags = (ngx_uint_t )0;
#line 2574
    if ((unsigned long )p < (unsigned long )(last - 1)) {
#line 2574
      if ((int )*(p + 0) == 92) {
#line 2574
        if ((int )*(p + 1) == 47) {
#line 2575
          p ++;
        }
      }
    }
  }
  {
#line 2579
  right.len = (size_t___0 )(last - p);
#line 2580
  right.data = p;
#line 2585
  rc = ngx_http_ssi_evaluate_string(r, ctx, & right, flags);
  }
#line 2587
  if (rc != 0L) {
#line 2588
    return (rc);
  }
#line 2594
  if (noregex) {
#line 2595
    if (left.len != right.len) {
#line 2596
      rc = (ngx_int_t )-1;
    } else {
      {
#line 2599
      tmp = strncmp((char const   *)left.data, (char const   *)right.data, right.len);
#line 2599
      rc = (ngx_int_t )tmp;
      }
    }
  } else {
    {
#line 2603
    *(right.data + right.len) = (u_char )'\000';
#line 2605
    rc = ngx_http_ssi_regex_match(r, & right, & left);
    }
#line 2607
    if (rc == 0L) {
#line 2608
      rc = (ngx_int_t )0;
    } else
#line 2609
    if (rc == -5L) {
#line 2610
      rc = (ngx_int_t )-1;
    } else {
#line 2612
      return (rc);
    }
  }
#line 2616
  if (rc == 0L) {
#line 2616
    if (! negative) {
#line 2617
      ctx->output = 1U;
#line 2618
      ctx->output_chosen = 1U;
    } else {
#line 2616
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2616
  if (rc != 0L) {
#line 2616
    if (negative) {
#line 2617
      ctx->output = 1U;
#line 2618
      ctx->output_chosen = 1U;
    } else {
#line 2621
      ctx->output = 0U;
    }
  } else {
#line 2621
    ctx->output = 0U;
  }
#line 2624
  ctx->conditional = 1U;
#line 2626
  return ((ngx_int_t )0);
  invalid_expression: 
#line 2630
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 2630
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid expression in \"%V\"",
                       expr);
    }
  }
#line 2633
  return ((ngx_int_t )1);
}
}
#line 2637 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_else(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) 
{ 


  {
#line 2644
  if (ctx->output_chosen) {
#line 2645
    ctx->output = 0U;
  } else {
#line 2647
    ctx->output = 1U;
  }
#line 2650
  ctx->conditional = 2U;
#line 2652
  return ((ngx_int_t )0);
}
}
#line 2656 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_endif(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) 
{ 


  {
#line 2663
  ctx->output = 1U;
#line 2664
  ctx->output_chosen = 0U;
#line 2665
  ctx->conditional = 0U;
#line 2667
  return ((ngx_int_t )0);
}
}
#line 2671 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_block(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) 
{ 
  ngx_http_ssi_ctx_t *mctx ;
  ngx_http_ssi_block_t *bl ;
  void *tmp ;

  {
#line 2681
  mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2683
  if ((unsigned long )mctx->blocks == (unsigned long )((void *)0)) {
    {
#line 2684
    mctx->blocks = ngx_array_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_block_t ));
    }
#line 2686
    if ((unsigned long )mctx->blocks == (unsigned long )((void *)0)) {
#line 2687
      return ((ngx_int_t )1);
    }
  }
  {
#line 2691
  tmp = ngx_array_push(mctx->blocks);
#line 2691
  bl = (ngx_http_ssi_block_t *)tmp;
  }
#line 2692
  if ((unsigned long )bl == (unsigned long )((void *)0)) {
#line 2693
    return ((ngx_int_t )1);
  }
#line 2696
  bl->name = *(*(params + 0));
#line 2697
  bl->bufs = (ngx_chain_t *)((void *)0);
#line 2698
  bl->count = (ngx_uint_t )0;
#line 2700
  ctx->output = 0U;
#line 2701
  ctx->block = 1U;
#line 2703
  return ((ngx_int_t )0);
}
}
#line 2707 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_endblock(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                       ngx_str_t **params ) 
{ 


  {
#line 2714
  ctx->output = 1U;
#line 2715
  ctx->block = 0U;
#line 2717
  return ((ngx_int_t )0);
}
}
#line 2721 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_date_gmt_local_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t gmt ) 
{ 
  time_t now ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_str_t *timefmt ;
  struct tm tm ;
  char buf[2048] ;
  void *tmp ;
  u_char *tmp___0 ;
  size_t___0 tmp___1 ;
  void *tmp___2 ;

  {
#line 2731
  v->valid = 1U;
#line 2732
  v->no_cacheable = 0U;
#line 2733
  v->not_found = 0U;
#line 2735
  now = (time_t )ngx_cached_time->sec;
#line 2737
  ctx = (ngx_http_ssi_ctx_t *)*(r->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2739
  if (ctx) {
#line 2739
    timefmt = & ctx->timefmt;
  } else {
#line 2739
    timefmt = & ngx_http_ssi_timefmt;
  }
#line 2741
  if (timefmt->len == sizeof("%s") - 1UL) {
#line 2741
    if ((int )*(timefmt->data + 0) == 37) {
#line 2741
      if ((int )*(timefmt->data + 1) == 115) {
        {
#line 2744
        tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2744
        v->data = (u_char *)tmp;
        }
#line 2745
        if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 2746
          return ((ngx_int_t )-1);
        }
        {
#line 2749
        tmp___0 = ngx_sprintf(v->data, "%T", now);
#line 2749
        v->len = (unsigned int )(tmp___0 - v->data);
        }
#line 2751
        return ((ngx_int_t )0);
      }
    }
  }
#line 2754
  if (gmt) {
    {
#line 2755
    ngx_libc_gmtime(now, & tm);
    }
  } else {
    {
#line 2757
    ngx_libc_localtime(now, & tm);
    }
  }
  {
#line 2760
  tmp___1 = strftime((char */* __restrict  */)(buf), (size_t___0 )2048, (char const   */* __restrict  */)((char *)timefmt->data),
                     (struct tm  const  */* __restrict  */)(& tm));
#line 2760
  v->len = (unsigned int )tmp___1;
  }
#line 2762
  if (v->len == 0U) {
#line 2763
    return ((ngx_int_t )-1);
  }
  {
#line 2766
  tmp___2 = ngx_pnalloc(r->pool, (size_t___0 )v->len);
#line 2766
  v->data = (u_char *)tmp___2;
  }
#line 2767
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 2768
    return ((ngx_int_t )-1);
  }
  {
#line 2771
  memcpy((void */* __restrict  */)v->data, (void const   */* __restrict  */)(buf),
         (size_t )v->len);
  }
#line 2773
  return ((ngx_int_t )0);
}
}
#line 2777 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_preconfiguration(ngx_conf_t *cf ) 
{ 
  ngx_int_t rc ;
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;
  ngx_http_ssi_command_t *cmd ;
  ngx_http_ssi_main_conf_t *smcf ;

  {
#line 2785
  v = ngx_http_ssi_vars;
  {
#line 2785
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2785
    if (! v->name.len) {
#line 2785
      goto while_break;
    }
    {
#line 2786
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 2787
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2788
      return ((ngx_int_t )-1);
    }
#line 2791
    var->get_handler = v->get_handler;
#line 2792
    var->data = v->data;
#line 2785
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2795
  smcf = (ngx_http_ssi_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_ssi_filter_module.ctx_index);
#line 2797
  cmd = ngx_http_ssi_commands;
  {
#line 2797
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2797
    if (! cmd->name.len) {
#line 2797
      goto while_break___0;
    }
    {
#line 2798
    rc = ngx_hash_add_key(& smcf->commands, & cmd->name, (void *)cmd, (ngx_uint_t )2);
    }
#line 2801
    if (rc == 0L) {
#line 2802
      goto __Cont;
    }
#line 2805
    if (rc == -3L) {
      {
#line 2806
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting SSI command \"%V\"",
                         & cmd->name);
      }
    }
#line 2810
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ 
#line 2797
    cmd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2813
  return ((ngx_int_t )0);
}
}
#line 2817 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static void *ngx_http_ssi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_ssi_main_conf_t *smcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2822
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssi_main_conf_t ));
#line 2822
  smcf = (ngx_http_ssi_main_conf_t *)tmp;
  }
#line 2823
  if ((unsigned long )smcf == (unsigned long )((void *)0)) {
#line 2824
    return ((void *)0);
  }
  {
#line 2827
  smcf->commands.pool = cf->pool;
#line 2828
  smcf->commands.temp_pool = cf->temp_pool;
#line 2830
  tmp___0 = ngx_hash_keys_array_init(& smcf->commands, (ngx_uint_t )1);
  }
#line 2830
  if (tmp___0 != 0L) {
#line 2831
    return ((void *)0);
  }
#line 2834
  return ((void *)smcf);
}
}
#line 2838 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static char *ngx_http_ssi_init_main_conf(ngx_conf_t *cf , void *conf ) 
{ 
  ngx_http_ssi_main_conf_t *smcf ;
  ngx_hash_init_t hash ;
  ngx_int_t tmp ;

  {
  {
#line 2841
  smcf = (ngx_http_ssi_main_conf_t *)conf;
#line 2845
  hash.hash = & smcf->hash;
#line 2846
  hash.key = & ngx_hash_key;
#line 2847
  hash.max_size = (ngx_uint_t )1024;
#line 2848
  hash.bucket_size = ngx_cacheline_size;
#line 2849
  hash.name = (char *)"ssi_command_hash";
#line 2850
  hash.pool = cf->pool;
#line 2851
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2853
  tmp = ngx_hash_init(& hash, (ngx_hash_key_t *)smcf->commands.keys.elts, smcf->commands.keys.nelts);
  }
#line 2853
  if (tmp != 0L) {
#line 2857
    return ((char *)((void *)-1));
  }
#line 2860
  return ((char *)((void *)0));
}
}
#line 2864 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static void *ngx_http_ssi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_ssi_loc_conf_t *slcf ;
  void *tmp ;

  {
  {
#line 2869
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssi_loc_conf_t ));
#line 2869
  slcf = (ngx_http_ssi_loc_conf_t *)tmp;
  }
#line 2870
  if ((unsigned long )slcf == (unsigned long )((void *)0)) {
#line 2871
    return ((void *)0);
  }
#line 2881
  slcf->enable = (ngx_flag_t )-1;
#line 2882
  slcf->silent_errors = (ngx_flag_t )-1;
#line 2883
  slcf->ignore_recycled_buffers = (ngx_flag_t )-1;
#line 2884
  slcf->last_modified = (ngx_flag_t )-1;
#line 2886
  slcf->min_file_chunk = (size_t___0 )-1;
#line 2887
  slcf->value_len = (size_t___0 )-1;
#line 2889
  return ((void *)slcf);
}
}
#line 2893 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static char *ngx_http_ssi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_ssi_loc_conf_t *prev ;
  ngx_http_ssi_loc_conf_t *conf ;
  char *tmp ;

  {
#line 2896
  prev = (ngx_http_ssi_loc_conf_t *)parent;
#line 2897
  conf = (ngx_http_ssi_loc_conf_t *)child;
#line 2899
  if (conf->enable == -1L) {
#line 2899
    if (prev->enable == -1L) {
#line 2899
      conf->enable = (ngx_flag_t )0;
    } else {
#line 2899
      conf->enable = prev->enable;
    }
  }
#line 2900
  if (conf->silent_errors == -1L) {
#line 2900
    if (prev->silent_errors == -1L) {
#line 2900
      conf->silent_errors = (ngx_flag_t )0;
    } else {
#line 2900
      conf->silent_errors = prev->silent_errors;
    }
  }
#line 2901
  if (conf->ignore_recycled_buffers == -1L) {
#line 2901
    if (prev->ignore_recycled_buffers == -1L) {
#line 2901
      conf->ignore_recycled_buffers = (ngx_flag_t )0;
    } else {
#line 2901
      conf->ignore_recycled_buffers = prev->ignore_recycled_buffers;
    }
  }
#line 2903
  if (conf->last_modified == -1L) {
#line 2903
    if (prev->last_modified == -1L) {
#line 2903
      conf->last_modified = (ngx_flag_t )0;
    } else {
#line 2903
      conf->last_modified = prev->last_modified;
    }
  }
#line 2905
  if (conf->min_file_chunk == 0xffffffffffffffffUL) {
#line 2905
    if (prev->min_file_chunk == 0xffffffffffffffffUL) {
#line 2905
      conf->min_file_chunk = (size_t___0 )1024;
    } else {
#line 2905
      conf->min_file_chunk = prev->min_file_chunk;
    }
  }
#line 2906
  if (conf->value_len == 0xffffffffffffffffUL) {
#line 2906
    if (prev->value_len == 0xffffffffffffffffUL) {
#line 2906
      conf->value_len = (size_t___0 )255;
    } else {
#line 2906
      conf->value_len = prev->value_len;
    }
  }
  {
#line 2908
  tmp = ngx_http_merge_types(cf, & conf->types_keys, & conf->types, & prev->types_keys,
                             & prev->types, ngx_http_html_default_types);
  }
#line 2908
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 2913
    return ((char *)((void *)-1));
  }
#line 2916
  return ((char *)((void *)0));
}
}
#line 2920 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 2923
  ngx_http_next_header_filter___3 = ngx_http_top_header_filter;
#line 2924
  ngx_http_top_header_filter = & ngx_http_ssi_header_filter;
#line 2926
  ngx_http_next_body_filter___2 = ngx_http_top_body_filter;
#line 2927
  ngx_http_top_body_filter = & ngx_http_ssi_body_filter;
#line 2929
  return ((ngx_int_t )0);
}
}
#line 121 "src/http/ngx_http.h"
ngx_int_t ngx_http_post_request(ngx_http_request_t *r , ngx_http_posted_request_t *pr ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter_add(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 15
static ngx_int_t ngx_http_postpone_filter_init(ngx_conf_t *cf ) ;
#line 18 "/tmp/nginx-1.13.2/src/http/ngx_http_postpone_filter_module.c"
static ngx_http_module_t ngx_http_postpone_filter_module_ctx  = 
#line 18
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_postpone_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 33 "/tmp/nginx-1.13.2/src/http/ngx_http_postpone_filter_module.c"
ngx_module_t ngx_http_postpone_filter_module  = 
#line 33
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_postpone_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 49 "/tmp/nginx-1.13.2/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___3)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 52 "/tmp/nginx-1.13.2/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_connection_t *c ;
  ngx_http_postponed_request_t *pr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 58
  c = r->connection;
#line 63
  if ((unsigned long )r != (unsigned long )c->data) {
#line 65
    if (in) {
      {
#line 66
      ngx_http_postpone_filter_add(r, in);
      }
#line 67
      return ((ngx_int_t )0);
    }
#line 76
    return ((ngx_int_t )0);
  }
#line 79
  if ((unsigned long )r->postponed == (unsigned long )((void *)0)) {
#line 81
    if (in) {
      {
#line 82
      tmp = (*ngx_http_next_body_filter___3)(r->main, in);
      }
#line 82
      return (tmp);
    } else
#line 81
    if (c->buffered) {
      {
#line 82
      tmp = (*ngx_http_next_body_filter___3)(r->main, in);
      }
#line 82
      return (tmp);
    }
#line 85
    return ((ngx_int_t )0);
  }
#line 88
  if (in) {
    {
#line 89
    ngx_http_postpone_filter_add(r, in);
    }
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    pr = r->postponed;
#line 95
    if (pr->request) {
      {
#line 101
      r->postponed = pr->next;
#line 103
      c->data = (void *)pr->request;
#line 105
      tmp___0 = ngx_http_post_request(pr->request, (ngx_http_posted_request_t *)((void *)0));
      }
#line 105
      return (tmp___0);
    }
#line 108
    if ((unsigned long )pr->out == (unsigned long )((void *)0)) {
#line 109
      if ((c->log)->log_level >= 2UL) {
        {
#line 109
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "http postpone filter NULL output");
        }
      }
    } else {
      {
#line 117
      tmp___1 = (*ngx_http_next_body_filter___3)(r->main, pr->out);
      }
#line 117
      if (tmp___1 == -1L) {
#line 118
        return ((ngx_int_t )-1);
      }
    }
#line 122
    r->postponed = pr->next;
#line 92
    if (! r->postponed) {
#line 92
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  return ((ngx_int_t )0);
}
}
#line 130 "/tmp/nginx-1.13.2/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter_add(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_http_postponed_request_t *pr ;
  ngx_http_postponed_request_t **ppr ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 135
  if (r->postponed) {
#line 136
    pr = r->postponed;
    {
#line 136
    while (1) {
      while_continue: /* CIL Label */ ;
#line 136
      if (! pr->next) {
#line 136
        goto while_break;
      }
#line 136
      pr = pr->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 138
    if ((unsigned long )pr->request == (unsigned long )((void *)0)) {
#line 139
      goto found;
    }
#line 142
    ppr = & pr->next;
  } else {
#line 145
    ppr = & r->postponed;
  }
  {
#line 148
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_postponed_request_t ));
#line 148
  pr = (ngx_http_postponed_request_t *)tmp;
  }
#line 149
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 150
    return ((ngx_int_t )-1);
  }
#line 153
  *ppr = pr;
#line 155
  pr->request = (ngx_http_request_t *)((void *)0);
#line 156
  pr->out = (ngx_chain_t *)((void *)0);
#line 157
  pr->next = (ngx_http_postponed_request_t *)((void *)0);
  found: 
  {
#line 161
  tmp___0 = ngx_chain_add_copy(r->pool, & pr->out, in);
  }
#line 161
  if (tmp___0 == 0L) {
#line 162
    return ((ngx_int_t )0);
  }
#line 165
  return ((ngx_int_t )-1);
}
}
#line 169 "/tmp/nginx-1.13.2/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 172
  ngx_http_next_body_filter___3 = ngx_http_top_body_filter;
#line 173
  ngx_http_top_body_filter = & ngx_http_postpone_filter;
#line 175
  return ((ngx_int_t )0);
}
}
#line 83 "src/core/ngx_palloc.h"
ngx_int_t ngx_pfree(ngx_pool_t *pool , void *p ) ;
#line 506 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_gzip_ok(ngx_http_request_t *r ) ;
#line 250 "/usr/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 363
extern int deflateEnd(z_streamp strm ) ;
#line 1726
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
#line 1769
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 87 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_memory(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 89
static ngx_int_t ngx_http_gzip_filter_buffer(ngx_http_gzip_ctx_t *ctx , ngx_chain_t *in ) ;
#line 91
static ngx_int_t ngx_http_gzip_filter_deflate_start(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 93
static ngx_int_t ngx_http_gzip_filter_gzheader(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 95
static ngx_int_t ngx_http_gzip_filter_add_data(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 97
static ngx_int_t ngx_http_gzip_filter_get_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 99
static ngx_int_t ngx_http_gzip_filter_deflate(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 101
static ngx_int_t ngx_http_gzip_filter_deflate_end(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 104
static void *ngx_http_gzip_filter_alloc(void *opaque , u_int items , u_int size ) ;
#line 106
static void ngx_http_gzip_filter_free(void *opaque , void *address ) ;
#line 107
static void ngx_http_gzip_filter_free_copy_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 110
static ngx_int_t ngx_http_gzip_add_variables(ngx_conf_t *cf ) ;
#line 111
static ngx_int_t ngx_http_gzip_ratio_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 114
static ngx_int_t ngx_http_gzip_filter_init(ngx_conf_t *cf ) ;
#line 115
static void *ngx_http_gzip_create_conf(ngx_conf_t *cf ) ;
#line 116
static char *ngx_http_gzip_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 118
static char *ngx_http_gzip_window(ngx_conf_t *cf , void *post , void *data ) ;
#line 119
static char *ngx_http_gzip_hash(ngx_conf_t *cf , void *post , void *data ) ;
#line 122 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_conf_num_bounds_t ngx_http_gzip_comp_level_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )1, (ngx_int_t )9};
#line 126 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static char *(*ngx_http_gzip_window_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_gzip_window;
#line 127 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static char *(*ngx_http_gzip_hash_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_gzip_hash;
#line 130 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_command_t ngx_http_gzip_filter_commands[10]  = 
#line 130
  {      {{sizeof("gzip") - 1UL, (u_char *)"gzip"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->enable),
      (void *)0}, 
        {{sizeof("gzip_buffers") - 1UL, (u_char *)"gzip_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->bufs), (void *)0}, 
        {{sizeof("gzip_types") - 1UL, (u_char *)"gzip_types"}, (ngx_uint_t )234883072,
      & ngx_http_types_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->types_keys), (void *)(& ngx_http_html_default_types[0])}, 
        {{sizeof("gzip_comp_level") - 1UL,
       (u_char *)"gzip_comp_level"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->level),
      (void *)(& ngx_http_gzip_comp_level_bounds)}, 
        {{sizeof("gzip_window") - 1UL, (u_char *)"gzip_window"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->wbits), (void *)(& ngx_http_gzip_window_p)}, 
        {{sizeof("gzip_hash") - 1UL,
       (u_char *)"gzip_hash"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->memlevel), (void *)(& ngx_http_gzip_hash_p)}, 
        {{sizeof("postpone_gzipping") - 1UL,
       (u_char *)"postpone_gzipping"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->postpone_gzipping),
      (void *)0}, 
        {{sizeof("gzip_no_buffer") - 1UL, (u_char *)"gzip_no_buffer"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->no_buffer), (void *)0}, 
        {{sizeof("gzip_min_length") - 1UL, (u_char *)"gzip_min_length"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->min_length), (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 200 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_http_module_t ngx_http_gzip_filter_module_ctx  = 
#line 200
     {& ngx_http_gzip_add_variables, & ngx_http_gzip_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_gzip_create_conf,
    & ngx_http_gzip_merge_conf};
#line 215 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
ngx_module_t ngx_http_gzip_filter_module  = 
#line 215
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_gzip_filter_module_ctx),
    ngx_http_gzip_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 231 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_str_t ngx_http_gzip_ratio  =    {sizeof("gzip_ratio") - 1UL, (u_char *)"gzip_ratio"};
#line 233 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___4)(ngx_http_request_t *r )  ;
#line 234 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___4)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 237 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_table_elt_t *h ;
  ngx_http_gzip_ctx_t *ctx ;
  ngx_http_gzip_conf_t *conf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;

  {
#line 244
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 246
  if (! conf->enable) {
    {
#line 257
    tmp = (*ngx_http_next_header_filter___4)(r);
    }
#line 257
    return (tmp);
  } else
#line 246
  if (r->headers_out.status != 200UL) {
#line 246
    if (r->headers_out.status != 403UL) {
#line 246
      if (r->headers_out.status != 404UL) {
        {
#line 257
        tmp = (*ngx_http_next_header_filter___4)(r);
        }
#line 257
        return (tmp);
      } else {
#line 246
        goto _L___2;
      }
    } else {
#line 246
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 246
  if (r->headers_out.content_encoding) {
#line 246
    if ((r->headers_out.content_encoding)->value.len) {
      {
#line 257
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 257
      return (tmp);
    } else {
#line 246
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 246
  if (r->headers_out.content_length_n != -1L) {
#line 246
    if (r->headers_out.content_length_n < conf->min_length) {
      {
#line 257
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 257
      return (tmp);
    } else {
#line 246
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 246
    tmp___0 = ngx_http_test_content_type(r, & conf->types);
    }
#line 246
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 257
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 257
      return (tmp);
    } else
#line 246
    if (r->header_only) {
      {
#line 257
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 257
      return (tmp);
    }
  }
#line 260
  r->gzip_vary = 1U;
#line 274
  if (! r->gzip_tested) {
    {
#line 275
    tmp___2 = ngx_http_gzip_ok(r);
    }
#line 275
    if (tmp___2 != 0L) {
      {
#line 276
      tmp___1 = (*ngx_http_next_header_filter___4)(r);
      }
#line 276
      return (tmp___1);
    }
  } else
#line 279
  if (! r->gzip_ok) {
    {
#line 280
    tmp___3 = (*ngx_http_next_header_filter___4)(r);
    }
#line 280
    return (tmp___3);
  }
  {
#line 283
  tmp___4 = ngx_pcalloc(r->pool, sizeof(ngx_http_gzip_ctx_t ));
#line 283
  ctx = (ngx_http_gzip_ctx_t *)tmp___4;
  }
#line 284
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 285
    return ((ngx_int_t )-1);
  }
  {
#line 288
  *(r->ctx + ngx_http_gzip_filter_module.ctx_index) = (void *)ctx;
#line 290
  ctx->request = r;
#line 291
  ctx->buffering = (unsigned int )(conf->postpone_gzipping != 0UL);
#line 293
  ngx_http_gzip_filter_memory(r, ctx);
#line 295
  tmp___5 = ngx_list_push(& r->headers_out.headers);
#line 295
  h = (ngx_table_elt_t *)tmp___5;
  }
#line 296
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 297
    return ((ngx_int_t )-1);
  }
#line 300
  h->hash = (ngx_uint_t )1;
#line 301
  h->key.len = sizeof("Content-Encoding") - 1UL;
#line 301
  h->key.data = (u_char *)"Content-Encoding";
#line 302
  h->value.len = sizeof("gzip") - 1UL;
#line 302
  h->value.data = (u_char *)"gzip";
#line 303
  r->headers_out.content_encoding = h;
#line 305
  r->main_filter_need_in_memory = 1U;
#line 307
  r->headers_out.content_length_n = (off_t )-1;
#line 307
  if (r->headers_out.content_length) {
#line 307
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 307
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 308
  r->allow_ranges = 0U;
#line 308
  if (r->headers_out.accept_ranges) {
#line 308
    (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 308
    r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 309
  ngx_http_weak_etag(r);
#line 311
  tmp___6 = (*ngx_http_next_header_filter___4)(r);
  }
#line 311
  return (tmp___6);
}
}
#line 315 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  int rc ;
  ngx_uint_t flush ;
  ngx_chain_t *cl ;
  ngx_http_gzip_ctx_t *ctx ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  int tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 323
  ctx = (ngx_http_gzip_ctx_t *)*(r->ctx + ngx_http_gzip_filter_module.ctx_index);
#line 325
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 326
    tmp = (*ngx_http_next_body_filter___4)(r, in);
    }
#line 326
    return (tmp);
  } else
#line 325
  if (ctx->done) {
    {
#line 326
    tmp = (*ngx_http_next_body_filter___4)(r, in);
    }
#line 326
    return (tmp);
  } else
#line 325
  if (r->header_only) {
    {
#line 326
    tmp = (*ngx_http_next_body_filter___4)(r, in);
    }
#line 326
    return (tmp);
  }
#line 332
  if (ctx->buffering) {
#line 343
    if (in) {
      {
#line 344
      tmp___0 = ngx_http_gzip_filter_buffer(ctx, in);
      }
      {
#line 346
      if (tmp___0 == 0L) {
#line 346
        goto case_0;
      }
#line 349
      if (tmp___0 == -4L) {
#line 349
        goto case_neg_4;
      }
#line 353
      goto switch_default;
      case_0: /* CIL Label */ 
#line 347
      return ((ngx_int_t )0);
      case_neg_4: /* CIL Label */ 
#line 350
      in = (ngx_chain_t *)((void *)0);
#line 351
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 354
      goto failed;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 358
      ctx->buffering = 0U;
    }
  }
#line 362
  if ((unsigned long )ctx->preallocated == (unsigned long )((void *)0)) {
    {
#line 363
    tmp___1 = ngx_http_gzip_filter_deflate_start(r, ctx);
    }
#line 363
    if (tmp___1 != 0L) {
#line 364
      goto failed;
    }
  }
#line 368
  if (in) {
    {
#line 369
    tmp___2 = ngx_chain_add_copy(r->pool, & ctx->in, in);
    }
#line 369
    if (tmp___2 != 0L) {
#line 370
      goto failed;
    }
#line 373
    (r->connection)->buffered |= 32U;
  }
#line 376
  if (ctx->nomem) {
    {
#line 380
    tmp___3 = (*ngx_http_next_body_filter___4)(r, (ngx_chain_t *)((void *)0));
    }
#line 380
    if (tmp___3 == -1L) {
#line 381
      goto failed;
    }
    {
#line 384
    cl = (ngx_chain_t *)((void *)0);
#line 386
    ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & cl, (ngx_buf_tag_t )(& ngx_http_gzip_filter_module));
#line 388
    ctx->nomem = 0U;
#line 389
    flush = (ngx_uint_t )0;
    }
  } else
#line 392
  if (ctx->busy) {
#line 392
    flush = (ngx_uint_t )1;
  } else {
#line 392
    flush = (ngx_uint_t )0;
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 399
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 403
      tmp___4 = ngx_http_gzip_filter_add_data(r, ctx);
#line 403
      rc = (int )tmp___4;
      }
#line 405
      if (rc == -5) {
#line 406
        goto while_break___0;
      }
#line 409
      if (rc == -2) {
#line 410
        goto __Cont;
      }
      {
#line 416
      tmp___5 = ngx_http_gzip_filter_get_buf(r, ctx);
#line 416
      rc = (int )tmp___5;
      }
#line 418
      if (rc == -5) {
#line 419
        goto while_break___0;
      }
#line 422
      if (rc == -1) {
#line 423
        goto failed;
      }
      {
#line 427
      tmp___6 = ngx_http_gzip_filter_deflate(r, ctx);
#line 427
      rc = (int )tmp___6;
      }
#line 429
      if (rc == 0) {
#line 430
        goto while_break___0;
      }
#line 433
      if (rc == -1) {
#line 434
        goto failed;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 440
    if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
#line 440
      if (! flush) {
        {
#line 441
        ngx_http_gzip_filter_free_copy_buf(r, ctx);
        }
#line 443
        if (ctx->busy) {
#line 443
          tmp___7 = -2;
        } else {
#line 443
          tmp___7 = 0;
        }
#line 443
        return ((ngx_int_t )tmp___7);
      }
    }
#line 446
    if (! ctx->gzheader) {
      {
#line 447
      tmp___8 = ngx_http_gzip_filter_gzheader(r, ctx);
      }
#line 447
      if (tmp___8 != 0L) {
#line 448
        goto failed;
      }
    }
    {
#line 452
    tmp___9 = (*ngx_http_next_body_filter___4)(r, ctx->out);
#line 452
    rc = (int )tmp___9;
    }
#line 454
    if (rc == -1) {
#line 455
      goto failed;
    }
    {
#line 458
    ngx_http_gzip_filter_free_copy_buf(r, ctx);
#line 460
    ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & ctx->out, (ngx_buf_tag_t )(& ngx_http_gzip_filter_module));
#line 462
    ctx->last_out = & ctx->out;
#line 464
    ctx->nomem = 0U;
#line 465
    flush = (ngx_uint_t )0;
    }
#line 467
    if (ctx->done) {
#line 468
      return ((ngx_int_t )rc);
    }
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 476
  ctx->done = 1U;
#line 478
  if (ctx->preallocated) {
    {
#line 479
    deflateEnd(& ctx->zstream);
#line 481
    ngx_pfree(r->pool, ctx->preallocated);
    }
  }
  {
#line 484
  ngx_http_gzip_filter_free_copy_buf(r, ctx);
  }
#line 486
  return ((ngx_int_t )-1);
}
}
#line 490 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_memory(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int wbits ;
  int memlevel ;
  ngx_http_gzip_conf_t *conf ;

  {
#line 496
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 498
  wbits = (int )conf->wbits;
#line 499
  memlevel = (int )conf->memlevel;
#line 501
  if (r->headers_out.content_length_n > 0L) {
    {
#line 505
    while (1) {
      while_continue: /* CIL Label */ ;
#line 505
      if (! (r->headers_out.content_length_n < (off_t )((1 << (wbits - 1)) - 262))) {
#line 505
        goto while_break;
      }
#line 506
      wbits --;
#line 507
      memlevel --;
    }
    while_break: /* CIL Label */ ;
    }
#line 510
    if (memlevel < 1) {
#line 511
      memlevel = 1;
    }
  }
#line 515
  ctx->wbits = wbits;
#line 516
  ctx->memlevel = memlevel;
#line 530
  ctx->allocated = (ngx_uint_t )((8192 + (1 << (wbits + 2))) + (1 << (memlevel + 9)));
#line 531
  return;
}
}
#line 534 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_buffer(ngx_http_gzip_ctx_t *ctx , ngx_chain_t *in ) 
{ 
  size_t___0 size ;
  size_t___0 buffered ;
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_request_t *r ;
  ngx_http_gzip_conf_t *conf ;
  void *tmp ;
  int tmp___0 ;

  {
#line 543
  r = ctx->request;
#line 545
  (r->connection)->buffered |= 32U;
#line 547
  buffered = (size_t___0 )0;
#line 548
  ll = & ctx->in;
#line 550
  cl = ctx->in;
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! cl) {
#line 550
      goto while_break;
    }
#line 551
    buffered += (size_t___0 )((cl->buf)->last - (cl->buf)->pos);
#line 552
    ll = & cl->next;
#line 550
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
  {
#line 557
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 557
    if (! in) {
#line 557
      goto while_break___0;
    }
    {
#line 558
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 559
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 560
      return ((ngx_int_t )-1);
    }
#line 563
    b = in->buf;
#line 565
    size = (size_t___0 )(b->last - b->pos);
#line 566
    buffered += size;
#line 568
    if (b->flush) {
#line 569
      ctx->buffering = 0U;
    } else
#line 568
    if (b->last_buf) {
#line 569
      ctx->buffering = 0U;
    } else
#line 568
    if (buffered > conf->postpone_gzipping) {
#line 569
      ctx->buffering = 0U;
    }
#line 572
    if (ctx->buffering) {
#line 572
      if (size) {
        {
#line 574
        buf = ngx_create_temp_buf(r->pool, size);
        }
#line 575
        if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 576
          return ((ngx_int_t )-1);
        }
        {
#line 579
        tmp = memcpy((void */* __restrict  */)buf->pos, (void const   */* __restrict  */)b->pos,
                     size);
#line 579
        buf->last = (u_char *)tmp + size;
#line 580
        b->pos = b->last;
#line 582
        buf->last_buf = b->last_buf;
#line 583
        buf->tag = (ngx_buf_tag_t )(& ngx_http_gzip_filter_module);
#line 585
        cl->buf = buf;
        }
      } else {
#line 588
        cl->buf = b;
      }
    } else {
#line 588
      cl->buf = b;
    }
#line 591
    *ll = cl;
#line 592
    ll = & cl->next;
#line 593
    in = in->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 596
  *ll = (ngx_chain_t *)((void *)0);
#line 598
  if (ctx->buffering) {
#line 598
    tmp___0 = 0;
  } else {
#line 598
    tmp___0 = -4;
  }
#line 598
  return ((ngx_int_t )tmp___0);
}
}
#line 602 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_deflate_start(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int rc ;
  ngx_http_gzip_conf_t *conf ;
  uLong tmp ;

  {
  {
#line 609
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 611
  ctx->preallocated = ngx_palloc(r->pool, ctx->allocated);
  }
#line 612
  if ((unsigned long )ctx->preallocated == (unsigned long )((void *)0)) {
#line 613
    return ((ngx_int_t )-1);
  }
  {
#line 616
  ctx->free_mem = (char *)ctx->preallocated;
#line 618
  ctx->zstream.zalloc = & ngx_http_gzip_filter_alloc;
#line 619
  ctx->zstream.zfree = & ngx_http_gzip_filter_free;
#line 620
  ctx->zstream.opaque = (voidpf )ctx;
#line 622
  rc = deflateInit2_(& ctx->zstream, (int )conf->level, 8, - ctx->wbits, ctx->memlevel,
                     0, "1.2.11", (int )sizeof(z_stream ));
  }
#line 625
  if (rc != 0) {
#line 626
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 626
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "deflateInit2() failed: %d",
                         rc);
      }
    }
#line 628
    return ((ngx_int_t )-1);
  }
  {
#line 631
  ctx->last_out = & ctx->out;
#line 632
  tmp = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 632
  ctx->crc32 = (uint32_t )tmp;
#line 633
  ctx->flush = 0U;
  }
#line 635
  return ((ngx_int_t )0);
}
}
#line 644 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static u_char gzheader[10]  = 
#line 644
  {      (u_char )31,      (u_char )139,      (u_char )8,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )3};
#line 639 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_gzheader(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  void *tmp ;

  {
  {
#line 647
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 647
  b = (ngx_buf_t *)tmp;
  }
#line 648
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 649
    return ((ngx_int_t )-1);
  }
  {
#line 652
  b->memory = 1U;
#line 653
  b->pos = gzheader;
#line 654
  b->last = b->pos + 10;
#line 656
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 657
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 658
    return ((ngx_int_t )-1);
  }
#line 661
  cl->buf = b;
#line 662
  cl->next = ctx->out;
#line 663
  ctx->out = cl;
#line 665
  ctx->gzheader = 1U;
#line 667
  return ((ngx_int_t )0);
}
}
#line 671 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_add_data(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;
  uLong tmp ;

  {
#line 676
  if (ctx->zstream.avail_in) {
#line 677
    return ((ngx_int_t )0);
  } else
#line 676
  if (ctx->flush != 0U) {
#line 677
    return ((ngx_int_t )0);
  } else
#line 676
  if (ctx->redo) {
#line 677
    return ((ngx_int_t )0);
  }
#line 683
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 684
    return ((ngx_int_t )-5);
  }
#line 687
  if (ctx->copy_buf) {
#line 694
    (ctx->copy_buf)->next = ctx->copied;
#line 695
    ctx->copied = ctx->copy_buf;
#line 696
    ctx->copy_buf = (ngx_chain_t *)((void *)0);
  }
#line 699
  cl = ctx->in;
#line 700
  ctx->in_buf = cl->buf;
#line 701
  ctx->in = cl->next;
#line 703
  if ((unsigned long )(ctx->in_buf)->tag == (unsigned long )((ngx_buf_tag_t )(& ngx_http_gzip_filter_module))) {
#line 704
    ctx->copy_buf = cl;
  } else {
#line 707
    cl->next = (r->pool)->chain;
#line 707
    (r->pool)->chain = cl;
  }
#line 710
  ctx->zstream.next_in = (ctx->in_buf)->pos;
#line 711
  ctx->zstream.avail_in = (uInt )((ctx->in_buf)->last - (ctx->in_buf)->pos);
#line 718
  if ((ctx->in_buf)->last_buf) {
#line 719
    ctx->flush = 4U;
  } else
#line 721
  if ((ctx->in_buf)->flush) {
#line 722
    ctx->flush = 2U;
  }
#line 725
  if (ctx->zstream.avail_in) {
    {
#line 727
    tmp = crc32((uLong )ctx->crc32, (Bytef const   *)ctx->zstream.next_in, ctx->zstream.avail_in);
#line 727
    ctx->crc32 = (uint32_t )tmp;
    }
  } else
#line 730
  if (ctx->flush == 0U) {
#line 731
    return ((ngx_int_t )-2);
  }
#line 734
  return ((ngx_int_t )0);
}
}
#line 738 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_get_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;
  ngx_http_gzip_conf_t *conf ;

  {
#line 744
  if (ctx->zstream.avail_out) {
#line 745
    return ((ngx_int_t )0);
  }
#line 748
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 750
  if (ctx->free) {
#line 752
    cl = ctx->free;
#line 753
    ctx->out_buf = cl->buf;
#line 754
    ctx->free = cl->next;
#line 756
    cl->next = (r->pool)->chain;
#line 756
    (r->pool)->chain = cl;
  } else
#line 758
  if (ctx->bufs < conf->bufs.num) {
    {
#line 760
    ctx->out_buf = ngx_create_temp_buf(r->pool, conf->bufs.size);
    }
#line 761
    if ((unsigned long )ctx->out_buf == (unsigned long )((void *)0)) {
#line 762
      return ((ngx_int_t )-1);
    }
#line 765
    (ctx->out_buf)->tag = (ngx_buf_tag_t )(& ngx_http_gzip_filter_module);
#line 766
    (ctx->out_buf)->recycled = 1U;
#line 767
    (ctx->bufs) ++;
  } else {
#line 770
    ctx->nomem = 1U;
#line 771
    return ((ngx_int_t )-5);
  }
#line 774
  ctx->zstream.next_out = (ctx->out_buf)->pos;
#line 775
  ctx->zstream.avail_out = (uInt )conf->bufs.size;
#line 777
  return ((ngx_int_t )0);
}
}
#line 781 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_deflate(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_gzip_conf_t *conf ;
  void *tmp ;
  off_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 795
  rc = deflate(& ctx->zstream, (int )ctx->flush);
  }
#line 797
  if (rc != 0) {
#line 797
    if (rc != 1) {
#line 797
      if (rc != -5) {
#line 798
        if (((r->connection)->log)->log_level >= 2UL) {
          {
#line 798
          ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "deflate() failed: %d, %d",
                             ctx->flush, rc);
          }
        }
#line 800
        return ((ngx_int_t )-1);
      }
    }
  }
#line 813
  if (ctx->zstream.next_in) {
#line 814
    (ctx->in_buf)->pos = ctx->zstream.next_in;
#line 816
    if (ctx->zstream.avail_in == 0U) {
#line 817
      ctx->zstream.next_in = (Bytef *)((void *)0);
    }
  }
#line 821
  (ctx->out_buf)->last = ctx->zstream.next_out;
#line 823
  if (ctx->zstream.avail_out == 0U) {
    {
#line 827
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 828
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 829
      return ((ngx_int_t )-1);
    }
#line 832
    cl->buf = ctx->out_buf;
#line 833
    cl->next = (ngx_chain_t *)((void *)0);
#line 834
    *(ctx->last_out) = cl;
#line 835
    ctx->last_out = & cl->next;
#line 837
    ctx->redo = 1U;
#line 839
    return ((ngx_int_t )-2);
  }
#line 842
  ctx->redo = 0U;
#line 844
  if (ctx->flush == 2U) {
    {
#line 846
    ctx->flush = 0U;
#line 848
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 849
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 850
      return ((ngx_int_t )-1);
    }
#line 853
    b = ctx->out_buf;
#line 855
    if (b->temporary) {
#line 855
      tmp___0 = b->last - b->pos;
    } else
#line 855
    if (b->memory) {
#line 855
      tmp___0 = b->last - b->pos;
    } else
#line 855
    if (b->mmap) {
#line 855
      tmp___0 = b->last - b->pos;
    } else {
#line 855
      tmp___0 = b->file_last - b->file_pos;
    }
#line 855
    if (tmp___0 == 0L) {
      {
#line 857
      tmp = ngx_pcalloc((ctx->request)->pool, sizeof(ngx_buf_t ));
#line 857
      b = (ngx_buf_t *)tmp;
      }
#line 858
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 859
        return ((ngx_int_t )-1);
      }
    } else {
#line 863
      ctx->zstream.avail_out = (uInt )0;
    }
#line 866
    b->flush = 1U;
#line 868
    cl->buf = b;
#line 869
    cl->next = (ngx_chain_t *)((void *)0);
#line 870
    *(ctx->last_out) = cl;
#line 871
    ctx->last_out = & cl->next;
#line 873
    (r->connection)->buffered &= 4294967263U;
#line 875
    return ((ngx_int_t )0);
  }
#line 878
  if (rc == 1) {
    {
#line 880
    tmp___1 = ngx_http_gzip_filter_deflate_end(r, ctx);
    }
#line 880
    if (tmp___1 != 0L) {
#line 881
      return ((ngx_int_t )-1);
    }
#line 884
    return ((ngx_int_t )0);
  }
#line 887
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 889
  if (conf->no_buffer) {
#line 889
    if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
      {
#line 891
      cl = ngx_alloc_chain_link(r->pool);
      }
#line 892
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 893
        return ((ngx_int_t )-1);
      }
#line 896
      cl->buf = ctx->out_buf;
#line 897
      cl->next = (ngx_chain_t *)((void *)0);
#line 898
      *(ctx->last_out) = cl;
#line 899
      ctx->last_out = & cl->next;
#line 901
      return ((ngx_int_t )0);
    }
  }
#line 904
  return ((ngx_int_t )-2);
}
}
#line 908 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_deflate_end(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  struct gztrailer *trailer ;

  {
  {
#line 917
  ctx->zin = ctx->zstream.total_in;
#line 918
  ctx->zout = (10UL + ctx->zstream.total_out) + 8UL;
#line 920
  rc = deflateEnd(& ctx->zstream);
  }
#line 922
  if (rc != 0) {
#line 923
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 923
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "deflateEnd() failed: %d",
                         rc);
      }
    }
#line 925
    return ((ngx_int_t )-1);
  }
  {
#line 928
  ngx_pfree(r->pool, ctx->preallocated);
#line 930
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 931
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 932
    return ((ngx_int_t )-1);
  }
#line 935
  cl->buf = ctx->out_buf;
#line 936
  cl->next = (ngx_chain_t *)((void *)0);
#line 937
  *(ctx->last_out) = cl;
#line 938
  ctx->last_out = & cl->next;
#line 940
  if (ctx->zstream.avail_out >= 8U) {
#line 941
    trailer = (struct gztrailer *)(ctx->out_buf)->last;
#line 942
    (ctx->out_buf)->last += 8;
#line 943
    (ctx->out_buf)->last_buf = 1U;
  } else {
    {
#line 946
    b = ngx_create_temp_buf(r->pool, (size_t___0 )8);
    }
#line 947
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 948
      return ((ngx_int_t )-1);
    }
    {
#line 951
    b->last_buf = 1U;
#line 953
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 954
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 955
      return ((ngx_int_t )-1);
    }
#line 958
    cl->buf = b;
#line 959
    cl->next = (ngx_chain_t *)((void *)0);
#line 960
    *(ctx->last_out) = cl;
#line 961
    ctx->last_out = & cl->next;
#line 962
    trailer = (struct gztrailer *)b->pos;
#line 963
    b->last += 8;
  }
#line 968
  trailer->crc32 = ctx->crc32;
#line 969
  trailer->zlen = (uint32_t )ctx->zin;
#line 985
  ctx->zstream.avail_in = (uInt )0;
#line 986
  ctx->zstream.avail_out = (uInt )0;
#line 988
  ctx->done = 1U;
#line 990
  (r->connection)->buffered &= 4294967263U;
#line 992
  return ((ngx_int_t )0);
}
}
#line 996 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static void *ngx_http_gzip_filter_alloc(void *opaque , u_int items , u_int size ) 
{ 
  ngx_http_gzip_ctx_t *ctx ;
  void *p ;
  ngx_uint_t alloc ;

  {
#line 999
  ctx = (ngx_http_gzip_ctx_t *)opaque;
#line 1004
  alloc = (ngx_uint_t )(items * size);
#line 1006
  if (alloc % 512UL != 0UL) {
#line 1006
    if (alloc < 8192UL) {
#line 1013
      alloc = (ngx_uint_t )8192;
    }
  }
#line 1016
  if (alloc <= ctx->allocated) {
#line 1017
    p = (void *)ctx->free_mem;
#line 1018
    ctx->free_mem += alloc;
#line 1019
    ctx->allocated -= alloc;
#line 1025
    return (p);
  }
#line 1028
  if ((((ctx->request)->connection)->log)->log_level >= 2UL) {
    {
#line 1028
    ngx_log_error_core((ngx_uint_t )2, ((ctx->request)->connection)->log, 0, "gzip filter failed to use preallocated memory: %ud of %ui",
                       items * size, ctx->allocated);
    }
  }
  {
#line 1032
  p = ngx_palloc((ctx->request)->pool, (size_t___0 )(items * size));
  }
#line 1034
  return (p);
}
}
#line 1038 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_free(void *opaque , void *address ) 
{ 


  {
#line 1047
  return;
}
}
#line 1050 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_free_copy_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;

  {
#line 1056
  cl = ctx->copied;
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1056
    if (! cl) {
#line 1056
      goto while_break;
    }
    {
#line 1057
    ngx_pfree(r->pool, (void *)(cl->buf)->start);
#line 1056
    cl = cl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  ctx->copied = (ngx_chain_t *)((void *)0);
#line 1061
  return;
}
}
#line 1064 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;

  {
  {
#line 1069
  var = ngx_http_add_variable(cf, & ngx_http_gzip_ratio, (ngx_uint_t )8);
  }
#line 1070
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 1071
    return ((ngx_int_t )-1);
  }
#line 1074
  var->get_handler = & ngx_http_gzip_ratio_variable;
#line 1076
  return ((ngx_int_t )0);
}
}
#line 1080 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_ratio_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_uint_t zint ;
  ngx_uint_t zfrac ;
  ngx_http_gzip_ctx_t *ctx ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1087
  ctx = (ngx_http_gzip_ctx_t *)*(r->ctx + ngx_http_gzip_filter_module.ctx_index);
#line 1089
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1090
    v->not_found = 1U;
#line 1091
    return ((ngx_int_t )0);
  } else
#line 1089
  if (ctx->zout == 0UL) {
#line 1090
    v->not_found = 1U;
#line 1091
    return ((ngx_int_t )0);
  }
  {
#line 1094
  v->valid = 1U;
#line 1095
  v->no_cacheable = 0U;
#line 1096
  v->not_found = 0U;
#line 1098
  tmp = ngx_pnalloc(r->pool, (sizeof("-2147483648") - 1UL) + 3UL);
#line 1098
  v->data = (u_char *)tmp;
  }
#line 1099
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1100
    return ((ngx_int_t )-1);
  }
#line 1103
  zint = ctx->zin / ctx->zout;
#line 1104
  zfrac = ((ctx->zin * 100UL) / ctx->zout) % 100UL;
#line 1106
  if (((ctx->zin * 1000UL) / ctx->zout) % 10UL > 4UL) {
#line 1110
    zfrac ++;
#line 1112
    if (zfrac > 99UL) {
#line 1113
      zint ++;
#line 1114
      zfrac = (ngx_uint_t )0;
    }
  }
  {
#line 1118
  tmp___0 = ngx_sprintf(v->data, "%ui.%02ui", zint, zfrac);
#line 1118
  v->len = (unsigned int )(tmp___0 - v->data);
  }
#line 1120
  return ((ngx_int_t )0);
}
}
#line 1124 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static void *ngx_http_gzip_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_gzip_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1129
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_gzip_conf_t ));
#line 1129
  conf = (ngx_http_gzip_conf_t *)tmp;
  }
#line 1130
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1131
    return ((void *)0);
  }
#line 1142
  conf->enable = (ngx_flag_t )-1;
#line 1143
  conf->no_buffer = (ngx_flag_t )-1;
#line 1145
  conf->postpone_gzipping = (size_t___0 )-1;
#line 1146
  conf->level = (ngx_int_t )-1;
#line 1147
  conf->wbits = (size_t___0 )-1;
#line 1148
  conf->memlevel = (size_t___0 )-1;
#line 1149
  conf->min_length = (ssize_t )-1;
#line 1151
  return ((void *)conf);
}
}
#line 1155 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static char *ngx_http_gzip_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_gzip_conf_t *prev ;
  ngx_http_gzip_conf_t *conf ;
  char *tmp ;

  {
#line 1158
  prev = (ngx_http_gzip_conf_t *)parent;
#line 1159
  conf = (ngx_http_gzip_conf_t *)child;
#line 1161
  if (conf->enable == -1L) {
#line 1161
    if (prev->enable == -1L) {
#line 1161
      conf->enable = (ngx_flag_t )0;
    } else {
#line 1161
      conf->enable = prev->enable;
    }
  }
#line 1162
  if (conf->no_buffer == -1L) {
#line 1162
    if (prev->no_buffer == -1L) {
#line 1162
      conf->no_buffer = (ngx_flag_t )0;
    } else {
#line 1162
      conf->no_buffer = prev->no_buffer;
    }
  }
#line 1164
  if (conf->bufs.num == 0L) {
#line 1164
    if (prev->bufs.num) {
#line 1164
      conf->bufs.num = prev->bufs.num;
#line 1164
      conf->bufs.size = prev->bufs.size;
    } else {
#line 1164
      conf->bufs.num = (ngx_int_t )(131072UL / ngx_pagesize);
#line 1164
      conf->bufs.size = ngx_pagesize;
    }
  }
#line 1167
  if (conf->postpone_gzipping == 0xffffffffffffffffUL) {
#line 1167
    if (prev->postpone_gzipping == 0xffffffffffffffffUL) {
#line 1167
      conf->postpone_gzipping = (size_t___0 )0;
    } else {
#line 1167
      conf->postpone_gzipping = prev->postpone_gzipping;
    }
  }
#line 1169
  if (conf->level == -1L) {
#line 1169
    if (prev->level == -1L) {
#line 1169
      conf->level = (ngx_int_t )1;
    } else {
#line 1169
      conf->level = prev->level;
    }
  }
#line 1170
  if (conf->wbits == 0xffffffffffffffffUL) {
#line 1170
    if (prev->wbits == 0xffffffffffffffffUL) {
#line 1170
      conf->wbits = (size_t___0 )15;
    } else {
#line 1170
      conf->wbits = prev->wbits;
    }
  }
#line 1171
  if (conf->memlevel == 0xffffffffffffffffUL) {
#line 1171
    if (prev->memlevel == 0xffffffffffffffffUL) {
#line 1171
      conf->memlevel = (size_t___0 )8;
    } else {
#line 1171
      conf->memlevel = prev->memlevel;
    }
  }
#line 1173
  if (conf->min_length == -1L) {
#line 1173
    if (prev->min_length == -1L) {
#line 1173
      conf->min_length = (ssize_t )20;
    } else {
#line 1173
      conf->min_length = prev->min_length;
    }
  }
  {
#line 1175
  tmp = ngx_http_merge_types(cf, & conf->types_keys, & conf->types, & prev->types_keys,
                             & prev->types, ngx_http_html_default_types);
  }
#line 1175
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1180
    return ((char *)((void *)-1));
  }
#line 1183
  return ((char *)((void *)0));
}
}
#line 1187 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 1190
  ngx_http_next_header_filter___4 = ngx_http_top_header_filter;
#line 1191
  ngx_http_top_header_filter = & ngx_http_gzip_header_filter;
#line 1193
  ngx_http_next_body_filter___4 = ngx_http_top_body_filter;
#line 1194
  ngx_http_top_body_filter = & ngx_http_gzip_body_filter;
#line 1196
  return ((ngx_int_t )0);
}
}
#line 1200 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static char *ngx_http_gzip_window(ngx_conf_t *cf , void *post , void *data ) 
{ 
  size_t___0 *np ;
  size_t___0 wbits ;
  size_t___0 wsize ;

  {
#line 1203
  np = (size_t___0 *)data;
#line 1207
  wbits = (size_t___0 )15;
#line 1209
  wsize = (size_t___0 )32768;
  {
#line 1209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1209
    if (! (wsize > 256UL)) {
#line 1209
      goto while_break;
    }
#line 1211
    if (wsize == *np) {
#line 1212
      *np = wbits;
#line 1214
      return ((char *)((void *)0));
    }
#line 1217
    wbits --;
#line 1209
    wsize >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1220
  return ((char *)"must be 512, 1k, 2k, 4k, 8k, 16k, or 32k");
}
}
#line 1224 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_gzip_filter_module.c"
static char *ngx_http_gzip_hash(ngx_conf_t *cf , void *post , void *data ) 
{ 
  size_t___0 *np ;
  size_t___0 memlevel ;
  size_t___0 hsize ;

  {
#line 1227
  np = (size_t___0 *)data;
#line 1231
  memlevel = (size_t___0 )9;
#line 1233
  hsize = (size_t___0 )131072;
  {
#line 1233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1233
    if (! (hsize > 256UL)) {
#line 1233
      goto while_break;
    }
#line 1235
    if (hsize == *np) {
#line 1236
      *np = memlevel;
#line 1238
      return ((char *)((void *)0));
    }
#line 1241
    memlevel --;
#line 1233
    hsize >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  return ((char *)"must be 512, 1k, 2k, 4k, 8k, 16k, 32k, 64k, or 128k");
}
}
#line 152 "src/core/ngx_file.h"
ngx_atomic_uint_t ngx_next_temp_number(ngx_uint_t collision ) ;
#line 62 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_parse(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                      ngx_uint_t ranges ) ;
#line 64
static ngx_int_t ngx_http_range_singlepart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) ;
#line 66
static ngx_int_t ngx_http_range_multipart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) ;
#line 68
static ngx_int_t ngx_http_range_not_satisfiable(ngx_http_request_t *r ) ;
#line 69
static ngx_int_t ngx_http_range_test_overlapped(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) ;
#line 71
static ngx_int_t ngx_http_range_singlepart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) ;
#line 73
static ngx_int_t ngx_http_range_multipart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                               ngx_chain_t *in ) ;
#line 76
static ngx_int_t ngx_http_range_header_filter_init(ngx_conf_t *cf ) ;
#line 77
static ngx_int_t ngx_http_range_body_filter_init(ngx_conf_t *cf ) ;
#line 80 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_http_module_t ngx_http_range_header_filter_module_ctx  = 
#line 80
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_range_header_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 95 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
ngx_module_t ngx_http_range_header_filter_module  = 
#line 95
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_range_header_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 111 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_http_module_t ngx_http_range_body_filter_module_ctx  = 
#line 111
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_range_body_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 126 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
ngx_module_t ngx_http_range_body_filter_module  = 
#line 126
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_range_body_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 142 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___5)(ngx_http_request_t *r )  ;
#line 143 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___5)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 146 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_header_filter(ngx_http_request_t *r ) 
{ 
  time_t if_range_time ;
  ngx_str_t *if_range ;
  ngx_str_t *etag ;
  ngx_uint_t ranges ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_range_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 155
  if (r->http_version < 1000UL) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  } else
#line 155
  if (r->headers_out.status != 200UL) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  } else
#line 155
  if ((unsigned long )r != (unsigned long )r->main) {
#line 155
    if (! r->subrequest_ranges) {
      {
#line 161
      tmp = (*ngx_http_next_header_filter___5)(r);
      }
#line 161
      return (tmp);
    } else {
#line 155
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 155
  if (r->headers_out.content_length_n == -1L) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  } else
#line 155
  if (! r->allow_ranges) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  }
#line 164
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 166
  if (clcf->max_ranges == 0UL) {
    {
#line 167
    tmp___0 = (*ngx_http_next_header_filter___5)(r);
    }
#line 167
    return (tmp___0);
  }
#line 170
  if ((unsigned long )r->headers_in.range == (unsigned long )((void *)0)) {
#line 176
    goto next_filter;
  } else
#line 170
  if ((r->headers_in.range)->value.len < 7UL) {
#line 176
    goto next_filter;
  } else {
    {
#line 170
    tmp___1 = ngx_strncasecmp((r->headers_in.range)->value.data, (u_char *)"bytes=",
                              (size_t___0 )6);
    }
#line 170
    if (tmp___1 != 0L) {
#line 176
      goto next_filter;
    }
  }
#line 179
  if (r->headers_in.if_range) {
#line 181
    if_range = & (r->headers_in.if_range)->value;
#line 183
    if (if_range->len >= 2UL) {
#line 183
      if ((int )*(if_range->data + (if_range->len - 1UL)) == 34) {
#line 185
        if ((unsigned long )r->headers_out.etag == (unsigned long )((void *)0)) {
#line 186
          goto next_filter;
        }
#line 189
        etag = & (r->headers_out.etag)->value;
#line 194
        if (if_range->len != etag->len) {
#line 197
          goto next_filter;
        } else {
          {
#line 194
          tmp___2 = strncmp((char const   *)if_range->data, (char const   *)etag->data,
                            etag->len);
          }
#line 194
          if (tmp___2 != 0) {
#line 197
            goto next_filter;
          }
        }
#line 200
        goto parse;
      }
    }
#line 203
    if (r->headers_out.last_modified_time == -1L) {
#line 204
      goto next_filter;
    }
    {
#line 207
    if_range_time = ngx_parse_http_time(if_range->data, if_range->len);
    }
#line 213
    if (if_range_time != r->headers_out.last_modified_time) {
#line 214
      goto next_filter;
    }
  }
  parse: 
  {
#line 220
  tmp___3 = ngx_pcalloc(r->pool, sizeof(ngx_http_range_filter_ctx_t ));
#line 220
  ctx = (ngx_http_range_filter_ctx_t *)tmp___3;
  }
#line 221
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 222
    return ((ngx_int_t )-1);
  }
#line 225
  ctx->offset = r->headers_out.content_offset;
#line 227
  if (r->single_range) {
#line 227
    ranges = (ngx_uint_t )1;
  } else {
#line 227
    ranges = clcf->max_ranges;
  }
  {
#line 229
  tmp___4 = ngx_http_range_parse(r, ctx, ranges);
  }
  {
#line 231
  if (tmp___4 == 0L) {
#line 231
    goto case_0;
  }
#line 243
  if (tmp___4 == 416L) {
#line 243
    goto case_416;
  }
#line 246
  if (tmp___4 == -1L) {
#line 246
    goto case_neg_1;
  }
#line 249
  goto switch_default;
  case_0: /* CIL Label */ 
#line 232
  *(r->ctx + ngx_http_range_body_filter_module.ctx_index) = (void *)ctx;
#line 234
  r->headers_out.status = (ngx_uint_t )206;
#line 235
  r->headers_out.status_line.len = (size_t___0 )0;
#line 237
  if (ctx->ranges.nelts == 1UL) {
    {
#line 238
    tmp___5 = ngx_http_range_singlepart_header(r, ctx);
    }
#line 238
    return (tmp___5);
  }
  {
#line 241
  tmp___6 = ngx_http_range_multipart_header(r, ctx);
  }
#line 241
  return (tmp___6);
  case_416: /* CIL Label */ 
  {
#line 244
  tmp___7 = ngx_http_range_not_satisfiable(r);
  }
#line 244
  return (tmp___7);
  case_neg_1: /* CIL Label */ 
#line 247
  return ((ngx_int_t )-1);
  switch_default: /* CIL Label */ 
#line 250
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  next_filter: 
  {
#line 255
  tmp___8 = ngx_list_push(& r->headers_out.headers);
#line 255
  r->headers_out.accept_ranges = (ngx_table_elt_t *)tmp___8;
  }
#line 256
  if ((unsigned long )r->headers_out.accept_ranges == (unsigned long )((void *)0)) {
#line 257
    return ((ngx_int_t )-1);
  }
  {
#line 260
  (r->headers_out.accept_ranges)->hash = (ngx_uint_t )1;
#line 261
  (r->headers_out.accept_ranges)->key.len = sizeof("Accept-Ranges") - 1UL;
#line 261
  (r->headers_out.accept_ranges)->key.data = (u_char *)"Accept-Ranges";
#line 262
  (r->headers_out.accept_ranges)->value.len = sizeof("bytes") - 1UL;
#line 262
  (r->headers_out.accept_ranges)->value.data = (u_char *)"bytes";
#line 264
  tmp___9 = (*ngx_http_next_header_filter___5)(r);
  }
#line 264
  return (tmp___9);
}
}
#line 268 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_parse(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                      ngx_uint_t ranges ) 
{ 
  u_char *p ;
  off_t start ;
  off_t end ;
  off_t size ;
  off_t content_length ;
  off_t cutoff ;
  off_t cutlim ;
  ngx_uint_t suffix ;
  ngx_http_range_t *range ;
  ngx_http_range_filter_ctx_t *mctx ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  ngx_uint_t tmp___4 ;
  u_char *tmp___5 ;

  {
#line 279
  if ((unsigned long )r != (unsigned long )r->main) {
#line 280
    mctx = (ngx_http_range_filter_ctx_t *)*((r->main)->ctx + ngx_http_range_body_filter_module.ctx_index);
#line 282
    if (mctx) {
#line 283
      ctx->ranges = mctx->ranges;
#line 284
      return ((ngx_int_t )0);
    }
  }
  {
#line 288
  tmp = ngx_array_init(& ctx->ranges, r->pool, (ngx_uint_t )1, sizeof(ngx_http_range_t ));
  }
#line 288
  if (tmp != 0L) {
#line 291
    return ((ngx_int_t )-1);
  }
#line 294
  p = (r->headers_in.range)->value.data + 6;
#line 295
  size = (off_t )0;
#line 296
  content_length = r->headers_out.content_length_n;
#line 298
  cutoff = (off_t )922337203685477580LL;
#line 299
  cutlim = (off_t )7LL;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    start = (off_t )0;
#line 303
    end = (off_t )0;
#line 304
    suffix = (ngx_uint_t )0;
    {
#line 306
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 306
      if (! ((int )*p == 32)) {
#line 306
        goto while_break___0;
      }
#line 306
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 308
    if ((int )*p != 45) {
#line 309
      if ((int )*p < 48) {
#line 310
        return ((ngx_int_t )416);
      } else
#line 309
      if ((int )*p > 57) {
#line 310
        return ((ngx_int_t )416);
      }
      {
#line 313
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 313
        if ((int )*p >= 48) {
#line 313
          if (! ((int )*p <= 57)) {
#line 313
            goto while_break___1;
          }
        } else {
#line 313
          goto while_break___1;
        }
#line 314
        if (start >= cutoff) {
#line 314
          if (start > cutoff) {
#line 315
            return ((ngx_int_t )416);
          } else
#line 314
          if ((off_t )((int )*p - 48) > cutlim) {
#line 315
            return ((ngx_int_t )416);
          }
        }
#line 318
        tmp___0 = p;
#line 318
        p ++;
#line 318
        start = (start * 10L + (off_t )*tmp___0) - 48L;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 321
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 321
        if (! ((int )*p == 32)) {
#line 321
          goto while_break___2;
        }
#line 321
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 323
      tmp___1 = p;
#line 323
      p ++;
#line 323
      if ((int )*tmp___1 != 45) {
#line 324
        return ((ngx_int_t )416);
      }
      {
#line 327
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 327
        if (! ((int )*p == 32)) {
#line 327
          goto while_break___3;
        }
#line 327
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 329
      if ((int )*p == 44) {
#line 330
        end = content_length;
#line 331
        goto found;
      } else
#line 329
      if ((int )*p == 0) {
#line 330
        end = content_length;
#line 331
        goto found;
      }
    } else {
#line 335
      suffix = (ngx_uint_t )1;
#line 336
      p ++;
    }
#line 339
    if ((int )*p < 48) {
#line 340
      return ((ngx_int_t )416);
    } else
#line 339
    if ((int )*p > 57) {
#line 340
      return ((ngx_int_t )416);
    }
    {
#line 343
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 343
      if ((int )*p >= 48) {
#line 343
        if (! ((int )*p <= 57)) {
#line 343
          goto while_break___4;
        }
      } else {
#line 343
        goto while_break___4;
      }
#line 344
      if (end >= cutoff) {
#line 344
        if (end > cutoff) {
#line 345
          return ((ngx_int_t )416);
        } else
#line 344
        if ((off_t )((int )*p - 48) > cutlim) {
#line 345
          return ((ngx_int_t )416);
        }
      }
#line 348
      tmp___2 = p;
#line 348
      p ++;
#line 348
      end = (end * 10L + (off_t )*tmp___2) - 48L;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 351
      if (! ((int )*p == 32)) {
#line 351
        goto while_break___5;
      }
#line 351
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 353
    if ((int )*p != 44) {
#line 353
      if ((int )*p != 0) {
#line 354
        return ((ngx_int_t )416);
      }
    }
#line 357
    if (suffix) {
#line 358
      start = content_length - end;
#line 359
      end = content_length - 1L;
    }
#line 362
    if (end >= content_length) {
#line 363
      end = content_length;
    } else {
#line 366
      end ++;
    }
    found: 
#line 371
    if (start < end) {
      {
#line 372
      tmp___3 = ngx_array_push(& ctx->ranges);
#line 372
      range = (ngx_http_range_t *)tmp___3;
      }
#line 373
      if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 374
        return ((ngx_int_t )-1);
      }
#line 377
      range->start = start;
#line 378
      range->end = end;
#line 380
      size += end - start;
#line 382
      tmp___4 = ranges;
#line 382
      ranges --;
#line 382
      if (tmp___4 == 0UL) {
#line 383
        return ((ngx_int_t )-5);
      }
    } else
#line 386
    if (start == 0L) {
#line 387
      return ((ngx_int_t )-5);
    }
#line 390
    tmp___5 = p;
#line 390
    p ++;
#line 390
    if ((int )*tmp___5 != 44) {
#line 391
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  if (ctx->ranges.nelts == 0UL) {
#line 396
    return ((ngx_int_t )416);
  }
#line 399
  if (size > content_length) {
#line 400
    return ((ngx_int_t )-5);
  }
#line 403
  return ((ngx_int_t )0);
}
}
#line 407 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_singlepart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) 
{ 
  ngx_table_elt_t *content_range ;
  ngx_http_range_t *range ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 414
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 415
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 415
    return (tmp);
  }
  {
#line 418
  tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 418
  content_range = (ngx_table_elt_t *)tmp___0;
  }
#line 419
  if ((unsigned long )content_range == (unsigned long )((void *)0)) {
#line 420
    return ((ngx_int_t )-1);
  }
  {
#line 423
  r->headers_out.content_range = content_range;
#line 425
  content_range->hash = (ngx_uint_t )1;
#line 426
  content_range->key.len = sizeof("Content-Range") - 1UL;
#line 426
  content_range->key.data = (u_char *)"Content-Range";
#line 428
  tmp___1 = ngx_pnalloc(r->pool, (sizeof("bytes -/") - 1UL) + 3UL * (sizeof("-9223372036854775808") - 1UL));
#line 428
  content_range->value.data = (u_char *)tmp___1;
  }
#line 430
  if ((unsigned long )content_range->value.data == (unsigned long )((void *)0)) {
#line 431
    content_range->hash = (ngx_uint_t )0;
#line 432
    r->headers_out.content_range = (ngx_table_elt_t *)((void *)0);
#line 433
    return ((ngx_int_t )-1);
  }
  {
#line 438
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 440
  tmp___2 = ngx_sprintf(content_range->value.data, "bytes %O-%O/%O", range->start,
                        range->end - 1L, r->headers_out.content_length_n);
#line 440
  content_range->value.len = (size_t___0 )(tmp___2 - content_range->value.data);
#line 446
  r->headers_out.content_length_n = range->end - range->start;
#line 447
  r->headers_out.content_offset = range->start;
  }
#line 449
  if (r->headers_out.content_length) {
#line 450
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 451
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 454
  tmp___3 = (*ngx_http_next_header_filter___5)(r);
  }
#line 454
  return (tmp___3);
}
}
#line 458 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_multipart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) 
{ 
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_http_range_t *range ;
  ngx_atomic_uint_t boundary ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  ngx_int_t tmp___7 ;

  {
#line 467
  len = ((((((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + sizeof("\r\nContent-Type: ")) - 1UL) + r->headers_out.content_type.len) + sizeof("\r\nContent-Range: bytes ")) - 1UL;
#line 472
  if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 472
    if (r->headers_out.charset.len) {
#line 475
      len += (sizeof("; charset=") - 1UL) + r->headers_out.charset.len;
    }
  }
  {
#line 478
  tmp = ngx_pnalloc(r->pool, len);
#line 478
  ctx->boundary_header.data = (u_char *)tmp;
  }
#line 479
  if ((unsigned long )ctx->boundary_header.data == (unsigned long )((void *)0)) {
#line 480
    return ((ngx_int_t )-1);
  }
  {
#line 483
  boundary = ngx_next_temp_number((ngx_uint_t )0);
  }
#line 493
  if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 493
    if (r->headers_out.charset.len) {
      {
#line 496
      tmp___0 = ngx_sprintf(ctx->boundary_header.data, "\r\n--%0muA\r\nContent-Type: %V; charset=%V\r\nContent-Range: bytes ",
                            boundary, & r->headers_out.content_type, & r->headers_out.charset);
#line 496
      ctx->boundary_header.len = (size_t___0 )(tmp___0 - ctx->boundary_header.data);
      }
    } else {
#line 493
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 505
  if (r->headers_out.content_type.len) {
    {
#line 506
    tmp___1 = ngx_sprintf(ctx->boundary_header.data, "\r\n--%0muA\r\nContent-Type: %V\r\nContent-Range: bytes ",
                          boundary, & r->headers_out.content_type);
#line 506
    ctx->boundary_header.len = (size_t___0 )(tmp___1 - ctx->boundary_header.data);
    }
  } else {
    {
#line 515
    tmp___2 = ngx_sprintf(ctx->boundary_header.data, "\r\n--%0muA\r\nContent-Range: bytes ",
                          boundary);
#line 515
    ctx->boundary_header.len = (size_t___0 )(tmp___2 - ctx->boundary_header.data);
    }
  }
  {
#line 522
  tmp___3 = ngx_pnalloc(r->pool, (sizeof("Content-Type: multipart/byteranges; boundary=") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 522
  r->headers_out.content_type.data = (u_char *)tmp___3;
  }
#line 527
  if ((unsigned long )r->headers_out.content_type.data == (unsigned long )((void *)0)) {
#line 528
    return ((ngx_int_t )-1);
  }
  {
#line 531
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 535
  tmp___4 = ngx_sprintf(r->headers_out.content_type.data, "multipart/byteranges; boundary=%0muA",
                        boundary);
#line 535
  r->headers_out.content_type.len = (size_t___0 )(tmp___4 - r->headers_out.content_type.data);
#line 541
  r->headers_out.content_type_len = r->headers_out.content_type.len;
#line 543
  r->headers_out.charset.len = (size_t___0 )0;
#line 547
  len = (((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + sizeof("--\r\n")) - 1UL;
#line 549
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 550
  i = (ngx_uint_t )0;
  }
  {
#line 550
  while (1) {
    while_continue: /* CIL Label */ ;
#line 550
    if (! (i < ctx->ranges.nelts)) {
#line 550
      goto while_break;
    }
    {
#line 554
    tmp___5 = ngx_pnalloc(r->pool, (3UL * (sizeof("-9223372036854775808") - 1UL) + 2UL) + 4UL);
#line 554
    (range + i)->content_range.data = (u_char *)tmp___5;
    }
#line 557
    if ((unsigned long )(range + i)->content_range.data == (unsigned long )((void *)0)) {
#line 558
      return ((ngx_int_t )-1);
    }
    {
#line 561
    tmp___6 = ngx_sprintf((range + i)->content_range.data, "%O-%O/%O\r\n\r\n", (range + i)->start,
                          (range + i)->end - 1L, r->headers_out.content_length_n);
#line 561
    (range + i)->content_range.len = (size_t___0 )(tmp___6 - (range + i)->content_range.data);
#line 567
    len += (ctx->boundary_header.len + (range + i)->content_range.len) + (size_t___0 )((range + i)->end - (range + i)->start);
#line 550
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  r->headers_out.content_length_n = (off_t )len;
#line 573
  if (r->headers_out.content_length) {
#line 574
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 575
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 578
  tmp___7 = (*ngx_http_next_header_filter___5)(r);
  }
#line 578
  return (tmp___7);
}
}
#line 582 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_not_satisfiable(ngx_http_request_t *r ) 
{ 
  ngx_table_elt_t *content_range ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;

  {
  {
#line 587
  r->headers_out.status = (ngx_uint_t )416;
#line 589
  tmp = ngx_list_push(& r->headers_out.headers);
#line 589
  content_range = (ngx_table_elt_t *)tmp;
  }
#line 590
  if ((unsigned long )content_range == (unsigned long )((void *)0)) {
#line 591
    return ((ngx_int_t )-1);
  }
  {
#line 594
  r->headers_out.content_range = content_range;
#line 596
  content_range->hash = (ngx_uint_t )1;
#line 597
  content_range->key.len = sizeof("Content-Range") - 1UL;
#line 597
  content_range->key.data = (u_char *)"Content-Range";
#line 599
  tmp___0 = ngx_pnalloc(r->pool, (sizeof("bytes */") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 599
  content_range->value.data = (u_char *)tmp___0;
  }
#line 601
  if ((unsigned long )content_range->value.data == (unsigned long )((void *)0)) {
#line 602
    content_range->hash = (ngx_uint_t )0;
#line 603
    r->headers_out.content_range = (ngx_table_elt_t *)((void *)0);
#line 604
    return ((ngx_int_t )-1);
  }
  {
#line 607
  tmp___1 = ngx_sprintf(content_range->value.data, "bytes */%O", r->headers_out.content_length_n);
#line 607
  content_range->value.len = (size_t___0 )(tmp___1 - content_range->value.data);
#line 612
  r->headers_out.content_length_n = (off_t )-1;
  }
#line 612
  if (r->headers_out.content_length) {
#line 612
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 612
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 614
  return ((ngx_int_t )416);
}
}
#line 618 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_http_range_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 623
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 624
    tmp = (*ngx_http_next_body_filter___5)(r, in);
    }
#line 624
    return (tmp);
  }
#line 627
  ctx = (ngx_http_range_filter_ctx_t *)*(r->ctx + ngx_http_range_body_filter_module.ctx_index);
#line 629
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 630
    tmp___0 = (*ngx_http_next_body_filter___5)(r, in);
    }
#line 630
    return (tmp___0);
  }
#line 633
  if (ctx->ranges.nelts == 1UL) {
    {
#line 634
    tmp___1 = ngx_http_range_singlepart_body(r, ctx, in);
    }
#line 634
    return (tmp___1);
  }
#line 641
  if ((in->buf)->flush) {
#line 641
    goto _L;
  } else
#line 641
  if ((in->buf)->last_buf) {
#line 641
    goto _L;
  } else
#line 641
  if ((in->buf)->sync) {
    _L: /* CIL Label */ 
#line 641
    if (! (in->buf)->temporary) {
#line 641
      if (! (in->buf)->memory) {
#line 641
        if (! (in->buf)->mmap) {
#line 641
          if (! (in->buf)->in_file) {
            {
#line 642
            tmp___2 = (*ngx_http_next_body_filter___5)(r, in);
            }
#line 642
            return (tmp___2);
          }
        }
      }
    }
  }
  {
#line 645
  tmp___3 = ngx_http_range_test_overlapped(r, ctx, in);
  }
#line 645
  if (tmp___3 != 0L) {
#line 646
    return ((ngx_int_t )-1);
  }
  {
#line 649
  tmp___4 = ngx_http_range_multipart_body(r, ctx, in);
  }
#line 649
  return (tmp___4);
}
}
#line 653 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_test_overlapped(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) 
{ 
  off_t start ;
  off_t last ;
  ngx_buf_t *buf ;
  ngx_uint_t i ;
  ngx_http_range_t *range ;
  off_t tmp ;

  {
#line 662
  if (ctx->offset) {
#line 663
    goto overlapped;
  }
#line 666
  buf = in->buf;
#line 668
  if (! buf->last_buf) {
#line 669
    start = ctx->offset;
#line 670
    if (buf->temporary) {
#line 670
      tmp = buf->last - buf->pos;
    } else
#line 670
    if (buf->memory) {
#line 670
      tmp = buf->last - buf->pos;
    } else
#line 670
    if (buf->mmap) {
#line 670
      tmp = buf->last - buf->pos;
    } else {
#line 670
      tmp = buf->file_last - buf->file_pos;
    }
#line 670
    last = ctx->offset + tmp;
#line 672
    range = (ngx_http_range_t *)ctx->ranges.elts;
#line 673
    i = (ngx_uint_t )0;
    {
#line 673
    while (1) {
      while_continue: /* CIL Label */ ;
#line 673
      if (! (i < ctx->ranges.nelts)) {
#line 673
        goto while_break;
      }
#line 674
      if (start > (range + i)->start) {
#line 675
        goto overlapped;
      } else
#line 674
      if (last < (range + i)->end) {
#line 675
        goto overlapped;
      }
#line 673
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 680
  if (buf->temporary) {
#line 680
    ctx->offset = buf->last - buf->pos;
  } else
#line 680
  if (buf->memory) {
#line 680
    ctx->offset = buf->last - buf->pos;
  } else
#line 680
  if (buf->mmap) {
#line 680
    ctx->offset = buf->last - buf->pos;
  } else {
#line 680
    ctx->offset = buf->file_last - buf->file_pos;
  }
#line 682
  return ((ngx_int_t )0);
  overlapped: 
#line 686
  if (((r->connection)->log)->log_level >= 2UL) {
    {
#line 686
    ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "range in overlapped buffers");
    }
  }
#line 689
  return ((ngx_int_t )-1);
}
}
#line 693 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_singlepart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) 
{ 
  off_t start ;
  off_t last ;
  ngx_buf_t *buf ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_range_t *range ;
  off_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 702
  out = (ngx_chain_t *)((void *)0);
#line 703
  ll = & out;
#line 704
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 706
  cl = in;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! cl) {
#line 706
      goto while_break;
    }
#line 708
    buf = cl->buf;
#line 710
    start = ctx->offset;
#line 711
    if (buf->temporary) {
#line 711
      tmp = buf->last - buf->pos;
    } else
#line 711
    if (buf->memory) {
#line 711
      tmp = buf->last - buf->pos;
    } else
#line 711
    if (buf->mmap) {
#line 711
      tmp = buf->last - buf->pos;
    } else {
#line 711
      tmp = buf->file_last - buf->file_pos;
    }
#line 711
    last = ctx->offset + tmp;
#line 713
    ctx->offset = last;
#line 718
    if (buf->flush) {
#line 718
      goto _L;
    } else
#line 718
    if (buf->last_buf) {
#line 718
      goto _L;
    } else
#line 718
    if (buf->sync) {
      _L: /* CIL Label */ 
#line 718
      if (! buf->temporary) {
#line 718
        if (! buf->memory) {
#line 718
          if (! buf->mmap) {
#line 718
            if (! buf->in_file) {
#line 719
              *ll = cl;
#line 720
              ll = & cl->next;
#line 721
              goto __Cont;
            }
          }
        }
      }
    }
#line 724
    if (range->end <= start) {
#line 724
      goto _L___0;
    } else
#line 724
    if (range->start >= last) {
      _L___0: /* CIL Label */ 
#line 729
      if (buf->in_file) {
#line 730
        buf->file_pos = buf->file_last;
      }
#line 733
      buf->pos = buf->last;
#line 734
      buf->sync = 1U;
#line 736
      goto __Cont;
    }
#line 739
    if (range->start > start) {
#line 741
      if (buf->in_file) {
#line 742
        buf->file_pos += range->start - start;
      }
#line 745
      if (buf->temporary) {
#line 746
        buf->pos += (size_t___0 )(range->start - start);
      } else
#line 745
      if (buf->memory) {
#line 746
        buf->pos += (size_t___0 )(range->start - start);
      } else
#line 745
      if (buf->mmap) {
#line 746
        buf->pos += (size_t___0 )(range->start - start);
      }
    }
#line 750
    if (range->end <= last) {
#line 752
      if (buf->in_file) {
#line 753
        buf->file_last -= last - range->end;
      }
#line 756
      if (buf->temporary) {
#line 757
        buf->last -= (size_t___0 )(last - range->end);
      } else
#line 756
      if (buf->memory) {
#line 757
        buf->last -= (size_t___0 )(last - range->end);
      } else
#line 756
      if (buf->mmap) {
#line 757
        buf->last -= (size_t___0 )(last - range->end);
      }
#line 760
      if ((unsigned long )r == (unsigned long )r->main) {
#line 760
        buf->last_buf = 1U;
      } else {
#line 760
        buf->last_buf = 0U;
      }
#line 761
      buf->last_in_chain = 1U;
#line 762
      *ll = cl;
#line 763
      cl->next = (ngx_chain_t *)((void *)0);
#line 765
      goto while_break;
    }
#line 768
    *ll = cl;
#line 769
    ll = & cl->next;
    __Cont: /* CIL Label */ 
#line 706
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 772
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 773
    return ((ngx_int_t )0);
  }
  {
#line 776
  tmp___0 = (*ngx_http_next_body_filter___5)(r, out);
  }
#line 776
  return (tmp___0);
}
}
#line 780 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_multipart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                               ngx_chain_t *in ) 
{ 
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_uint_t i ;
  ngx_chain_t *out ;
  ngx_chain_t *hcl ;
  ngx_chain_t *rcl ;
  ngx_chain_t *dcl ;
  ngx_chain_t **ll ;
  ngx_http_range_t *range ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 789
  ll = & out;
#line 790
  buf = in->buf;
#line 791
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 793
  i = (ngx_uint_t )0;
  {
#line 793
  while (1) {
    while_continue: /* CIL Label */ ;
#line 793
    if (! (i < ctx->ranges.nelts)) {
#line 793
      goto while_break;
    }
    {
#line 803
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 803
    b = (ngx_buf_t *)tmp;
    }
#line 804
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 805
      return ((ngx_int_t )-1);
    }
    {
#line 808
    b->memory = 1U;
#line 809
    b->pos = ctx->boundary_header.data;
#line 810
    b->last = ctx->boundary_header.data + ctx->boundary_header.len;
#line 812
    hcl = ngx_alloc_chain_link(r->pool);
    }
#line 813
    if ((unsigned long )hcl == (unsigned long )((void *)0)) {
#line 814
      return ((ngx_int_t )-1);
    }
    {
#line 817
    hcl->buf = b;
#line 822
    tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 822
    b = (ngx_buf_t *)tmp___0;
    }
#line 823
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 824
      return ((ngx_int_t )-1);
    }
    {
#line 827
    b->temporary = 1U;
#line 828
    b->pos = (range + i)->content_range.data;
#line 829
    b->last = (range + i)->content_range.data + (range + i)->content_range.len;
#line 831
    rcl = ngx_alloc_chain_link(r->pool);
    }
#line 832
    if ((unsigned long )rcl == (unsigned long )((void *)0)) {
#line 833
      return ((ngx_int_t )-1);
    }
    {
#line 836
    rcl->buf = b;
#line 841
    tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 841
    b = (ngx_buf_t *)tmp___1;
    }
#line 842
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 843
      return ((ngx_int_t )-1);
    }
#line 846
    b->in_file = buf->in_file;
#line 847
    b->temporary = buf->temporary;
#line 848
    b->memory = buf->memory;
#line 849
    b->mmap = buf->mmap;
#line 850
    b->file = buf->file;
#line 852
    if (buf->in_file) {
#line 853
      b->file_pos = buf->file_pos + (range + i)->start;
#line 854
      b->file_last = buf->file_pos + (range + i)->end;
    }
#line 857
    if (buf->temporary) {
#line 858
      b->pos = buf->pos + (size_t___0 )(range + i)->start;
#line 859
      b->last = buf->pos + (size_t___0 )(range + i)->end;
    } else
#line 857
    if (buf->memory) {
#line 858
      b->pos = buf->pos + (size_t___0 )(range + i)->start;
#line 859
      b->last = buf->pos + (size_t___0 )(range + i)->end;
    } else
#line 857
    if (buf->mmap) {
#line 858
      b->pos = buf->pos + (size_t___0 )(range + i)->start;
#line 859
      b->last = buf->pos + (size_t___0 )(range + i)->end;
    }
    {
#line 862
    dcl = ngx_alloc_chain_link(r->pool);
    }
#line 863
    if ((unsigned long )dcl == (unsigned long )((void *)0)) {
#line 864
      return ((ngx_int_t )-1);
    }
#line 867
    dcl->buf = b;
#line 869
    *ll = hcl;
#line 870
    hcl->next = rcl;
#line 871
    rcl->next = dcl;
#line 872
    ll = & dcl->next;
#line 793
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 877
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 877
  b = (ngx_buf_t *)tmp___2;
  }
#line 878
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 879
    return ((ngx_int_t )-1);
  }
  {
#line 882
  b->temporary = 1U;
#line 883
  b->last_buf = 1U;
#line 885
  tmp___3 = ngx_pnalloc(r->pool, (((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + sizeof("--\r\n")) - 1UL);
#line 885
  b->pos = (u_char *)tmp___3;
  }
#line 887
  if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
#line 888
    return ((ngx_int_t )-1);
  }
  {
#line 891
  tmp___4 = memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)ctx->boundary_header.data,
                   (sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 891
  b->last = (u_char *)tmp___4 + ((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 893
  tmp___5 = b->last;
#line 893
  (b->last) ++;
#line 893
  *tmp___5 = (u_char )'-';
#line 893
  tmp___6 = b->last;
#line 893
  (b->last) ++;
#line 893
  *tmp___6 = (u_char )'-';
#line 894
  tmp___7 = b->last;
#line 894
  (b->last) ++;
#line 894
  *tmp___7 = (u_char )'\r';
#line 894
  tmp___8 = b->last;
#line 894
  (b->last) ++;
#line 894
  *tmp___8 = (u_char )'\n';
#line 896
  hcl = ngx_alloc_chain_link(r->pool);
  }
#line 897
  if ((unsigned long )hcl == (unsigned long )((void *)0)) {
#line 898
    return ((ngx_int_t )-1);
  }
  {
#line 901
  hcl->buf = b;
#line 902
  hcl->next = (ngx_chain_t *)((void *)0);
#line 904
  *ll = hcl;
#line 906
  tmp___9 = (*ngx_http_next_body_filter___5)(r, out);
  }
#line 906
  return (tmp___9);
}
}
#line 910 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_header_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 913
  ngx_http_next_header_filter___5 = ngx_http_top_header_filter;
#line 914
  ngx_http_top_header_filter = & ngx_http_range_header_filter;
#line 916
  return ((ngx_int_t )0);
}
}
#line 920 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_body_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 923
  ngx_http_next_body_filter___5 = ngx_http_top_body_filter;
#line 924
  ngx_http_top_body_filter = & ngx_http_range_body_filter;
#line 926
  return ((ngx_int_t )0);
}
}
#line 19 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_filter_init(ngx_conf_t *cf ) ;
#line 20
static ngx_chain_t *ngx_http_chunked_create_trailers(ngx_http_request_t *r , ngx_http_chunked_filter_ctx_t *ctx ) ;
#line 24 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_http_module_t ngx_http_chunked_filter_module_ctx  = 
#line 24
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_chunked_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 39 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
ngx_module_t ngx_http_chunked_filter_module  = 
#line 39
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_chunked_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 55 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___6)(ngx_http_request_t *r )  ;
#line 56 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___6)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 59 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_chunked_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 65
  if (r->headers_out.status == 304UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if (r->headers_out.status == 204UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if (r->headers_out.status < 200UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if (r->method == 4UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  }
#line 74
  if (r->headers_out.content_length_n == -1L) {
#line 74
    goto _L___0;
  } else
#line 74
  if (r->expect_trailers) {
    _L___0: /* CIL Label */ 
#line 77
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 79
    if (r->http_version >= 1001UL) {
#line 79
      if (clcf->chunked_transfer_encoding) {
#line 82
        if (r->expect_trailers) {
#line 83
          r->headers_out.content_length_n = (off_t )-1;
#line 83
          if (r->headers_out.content_length) {
#line 83
            (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 83
            r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
          }
        }
        {
#line 86
        r->chunked = 1U;
#line 88
        tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t ));
#line 88
        ctx = (ngx_http_chunked_filter_ctx_t *)tmp___0;
        }
#line 89
        if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 90
          return ((ngx_int_t )-1);
        }
#line 93
        *(r->ctx + ngx_http_chunked_filter_module.ctx_index) = (void *)ctx;
      } else {
#line 79
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 95
    if (r->headers_out.content_length_n == -1L) {
#line 96
      r->keepalive = 0U;
    }
  }
  {
#line 100
  tmp___1 = (*ngx_http_next_header_filter___6)(r);
  }
#line 100
  return (tmp___1);
}
}
#line 104 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  u_char *chunk ;
  off_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_http_chunked_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  off_t tmp___0 ;
  void *tmp___1 ;

  {
#line 114
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 115
    tmp = (*ngx_http_next_body_filter___6)(r, in);
    }
#line 115
    return (tmp);
  } else
#line 114
  if (! r->chunked) {
    {
#line 115
    tmp = (*ngx_http_next_body_filter___6)(r, in);
    }
#line 115
    return (tmp);
  } else
#line 114
  if (r->header_only) {
    {
#line 115
    tmp = (*ngx_http_next_body_filter___6)(r, in);
    }
#line 115
    return (tmp);
  }
#line 118
  ctx = (ngx_http_chunked_filter_ctx_t *)*(r->ctx + ngx_http_chunked_filter_module.ctx_index);
#line 120
  out = (ngx_chain_t *)((void *)0);
#line 121
  ll = & out;
#line 123
  size = (off_t )0;
#line 124
  cl = in;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if ((cl->buf)->temporary) {
#line 130
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 130
    if ((cl->buf)->memory) {
#line 130
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 130
    if ((cl->buf)->mmap) {
#line 130
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 130
      tmp___0 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 130
    size += tmp___0;
#line 132
    if ((cl->buf)->flush) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->sync) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->temporary) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->memory) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->mmap) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->in_file) {
      _L: /* CIL Label */ 
      {
#line 137
      tl = ngx_alloc_chain_link(r->pool);
      }
#line 138
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 139
        return ((ngx_int_t )-1);
      }
#line 142
      tl->buf = cl->buf;
#line 143
      *ll = tl;
#line 144
      ll = & tl->next;
    }
#line 147
    if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 148
      goto while_break;
    }
#line 151
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  if (size) {
    {
#line 155
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 156
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 157
      return ((ngx_int_t )-1);
    }
#line 160
    b = tl->buf;
#line 161
    chunk = b->start;
#line 163
    if ((unsigned long )chunk == (unsigned long )((void *)0)) {
      {
#line 166
      tmp___1 = ngx_palloc(r->pool, sizeof("0000000000000000\r\n") - 1UL);
#line 166
      chunk = (u_char *)tmp___1;
      }
#line 167
      if ((unsigned long )chunk == (unsigned long )((void *)0)) {
#line 168
        return ((ngx_int_t )-1);
      }
#line 171
      b->start = chunk;
#line 172
      b->end = (chunk + sizeof("0000000000000000\r\n")) - 1;
    }
    {
#line 175
    b->tag = (ngx_buf_tag_t )(& ngx_http_chunked_filter_module);
#line 176
    b->memory = 0U;
#line 177
    b->temporary = 1U;
#line 178
    b->pos = chunk;
#line 179
    b->last = ngx_sprintf(chunk, "%xO\r\n", size);
#line 181
    tl->next = out;
#line 182
    out = tl;
    }
  }
#line 185
  if ((cl->buf)->last_buf) {
    {
#line 186
    tl = ngx_http_chunked_create_trailers(r, ctx);
    }
#line 187
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 188
      return ((ngx_int_t )-1);
    }
#line 191
    (cl->buf)->last_buf = 0U;
#line 193
    *ll = tl;
#line 195
    if (size == 0L) {
#line 196
      (tl->buf)->pos += 2;
    }
  } else
#line 199
  if (size > 0L) {
    {
#line 200
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 201
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 202
      return ((ngx_int_t )-1);
    }
#line 205
    b = tl->buf;
#line 207
    b->tag = (ngx_buf_tag_t )(& ngx_http_chunked_filter_module);
#line 208
    b->temporary = 0U;
#line 209
    b->memory = 1U;
#line 210
    b->pos = (u_char *)"\r\n";
#line 211
    b->last = b->pos + 2;
#line 213
    *ll = tl;
  } else {
#line 216
    *ll = (ngx_chain_t *)((void *)0);
  }
  {
#line 219
  rc = (*ngx_http_next_body_filter___6)(r, out);
#line 221
  ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & out, (ngx_buf_tag_t )(& ngx_http_chunked_filter_module));
  }
#line 224
  return (rc);
}
}
#line 228 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_chain_t *ngx_http_chunked_create_trailers(ngx_http_request_t *r , ngx_http_chunked_filter_ctx_t *ctx ) 
{ 
  size_t___0 len ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_chain_t *cl ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  void *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;

  {
#line 239
  len = (size_t___0 )0;
#line 241
  part = & r->headers_out.trailers.part;
#line 242
  header___0 = (ngx_table_elt_t *)part->elts;
#line 244
  i = (ngx_uint_t )0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (i >= part->nelts) {
#line 247
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 248
        goto while_break;
      }
#line 251
      part = part->next;
#line 252
      header___0 = (ngx_table_elt_t *)part->elts;
#line 253
      i = (ngx_uint_t )0;
    }
#line 256
    if ((header___0 + i)->hash == 0UL) {
#line 257
      goto __Cont;
    }
#line 260
    len += (((((header___0 + i)->key.len + sizeof(": ")) - 1UL) + (header___0 + i)->value.len) + sizeof("\r\n")) - 1UL;
    __Cont: /* CIL Label */ 
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  cl = ngx_chain_get_free_buf(r->pool, & ctx->free);
  }
#line 265
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 266
    return ((ngx_chain_t *)((void *)0));
  }
#line 269
  b = cl->buf;
#line 271
  b->tag = (ngx_buf_tag_t )(& ngx_http_chunked_filter_module);
#line 272
  b->temporary = 0U;
#line 273
  b->memory = 1U;
#line 274
  b->last_buf = 1U;
#line 276
  if (len == 0UL) {
#line 277
    b->pos = (u_char *)"\r\n0\r\n\r\n";
#line 278
    b->last = (b->pos + sizeof("\r\n0\r\n\r\n")) - 1;
#line 279
    return (cl);
  }
  {
#line 282
  len += sizeof("\r\n0\r\n\r\n") - 1UL;
#line 284
  tmp = ngx_palloc(r->pool, len);
#line 284
  b->pos = (u_char *)tmp;
  }
#line 285
  if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
#line 286
    return ((ngx_chain_t *)((void *)0));
  }
#line 289
  b->last = b->pos;
#line 291
  tmp___0 = b->last;
#line 291
  (b->last) ++;
#line 291
  *tmp___0 = (u_char )'\r';
#line 291
  tmp___1 = b->last;
#line 291
  (b->last) ++;
#line 291
  *tmp___1 = (u_char )'\n';
#line 292
  tmp___2 = b->last;
#line 292
  (b->last) ++;
#line 292
  *tmp___2 = (u_char )'0';
#line 293
  tmp___3 = b->last;
#line 293
  (b->last) ++;
#line 293
  *tmp___3 = (u_char )'\r';
#line 293
  tmp___4 = b->last;
#line 293
  (b->last) ++;
#line 293
  *tmp___4 = (u_char )'\n';
#line 295
  part = & r->headers_out.trailers.part;
#line 296
  header___0 = (ngx_table_elt_t *)part->elts;
#line 298
  i = (ngx_uint_t )0;
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (i >= part->nelts) {
#line 301
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 302
        goto while_break___0;
      }
#line 305
      part = part->next;
#line 306
      header___0 = (ngx_table_elt_t *)part->elts;
#line 307
      i = (ngx_uint_t )0;
    }
#line 310
    if ((header___0 + i)->hash == 0UL) {
#line 311
      goto __Cont___0;
    }
    {
#line 318
    tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->key.data,
                     (header___0 + i)->key.len);
#line 318
    b->last = (u_char *)tmp___5 + (header___0 + i)->key.len;
#line 319
    tmp___6 = b->last;
#line 319
    (b->last) ++;
#line 319
    *tmp___6 = (u_char )':';
#line 319
    tmp___7 = b->last;
#line 319
    (b->last) ++;
#line 319
    *tmp___7 = (u_char )' ';
#line 321
    tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                     (header___0 + i)->value.len);
#line 321
    b->last = (u_char *)tmp___8 + (header___0 + i)->value.len;
#line 322
    tmp___9 = b->last;
#line 322
    (b->last) ++;
#line 322
    *tmp___9 = (u_char )'\r';
#line 322
    tmp___10 = b->last;
#line 322
    (b->last) ++;
#line 322
    *tmp___10 = (u_char )'\n';
    }
    __Cont___0: /* CIL Label */ 
#line 298
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 325
  tmp___11 = b->last;
#line 325
  (b->last) ++;
#line 325
  *tmp___11 = (u_char )'\r';
#line 325
  tmp___12 = b->last;
#line 325
  (b->last) ++;
#line 325
  *tmp___12 = (u_char )'\n';
#line 327
  return (cl);
}
}
#line 331 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 334
  ngx_http_next_header_filter___6 = ngx_http_top_header_filter;
#line 335
  ngx_http_top_header_filter = & ngx_http_chunked_header_filter;
#line 337
  ngx_http_next_body_filter___6 = ngx_http_top_body_filter;
#line 338
  ngx_http_top_body_filter = & ngx_http_chunked_body_filter;
#line 340
  return ((ngx_int_t )0);
}
}
#line 125 "src/core/ngx_inet.h"
in_port_t ngx_inet_get_port(struct sockaddr *sa ) ;
#line 597 "src/http/ngx_http_request.h"
ngx_http_header_out_t ngx_http_headers_out[11] ;
#line 529 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_write_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 14 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static ngx_int_t ngx_http_header_filter_init(ngx_conf_t *cf ) ;
#line 15
static ngx_int_t ngx_http_header_filter(ngx_http_request_t *r ) ;
#line 18 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static ngx_http_module_t ngx_http_header_filter_module_ctx  = 
#line 18
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_header_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 33 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
ngx_module_t ngx_http_header_filter_module  = 
#line 33
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_header_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 49 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static u_char ngx_http_server_string[16]  = 
#line 49
  {      (u_char )'S',      (u_char )'e',      (u_char )'r',      (u_char )'v', 
        (u_char )'e',      (u_char )'r',      (u_char )':',      (u_char )' ', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 50 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static u_char ngx_http_server_full_string[23]  = 
#line 50
  {      (u_char )'S',      (u_char )'e',      (u_char )'r',      (u_char )'v', 
        (u_char )'e',      (u_char )'r',      (u_char )':',      (u_char )' ', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'2', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 51 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static u_char ngx_http_server_build_string[23]  = 
#line 51
  {      (u_char )'S',      (u_char )'e',      (u_char )'r',      (u_char )'v', 
        (u_char )'e',      (u_char )'r',      (u_char )':',      (u_char )' ', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'2', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 54 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static ngx_str_t ngx_http_status_lines[53]  = 
#line 54
  {      {sizeof("200 OK") - 1UL, (u_char *)"200 OK"}, 
        {sizeof("201 Created") - 1UL, (u_char *)"201 Created"}, 
        {sizeof("202 Accepted") - 1UL, (u_char *)"202 Accepted"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof("204 No Content") - 1UL, (u_char *)"204 No Content"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof("206 Partial Content") - 1UL, (u_char *)"206 Partial Content"}, 
        {sizeof("301 Moved Permanently") - 1UL, (u_char *)"301 Moved Permanently"}, 
        {sizeof("302 Moved Temporarily") - 1UL, (u_char *)"302 Moved Temporarily"}, 
        {sizeof("303 See Other") - 1UL, (u_char *)"303 See Other"}, 
        {sizeof("304 Not Modified") - 1UL, (u_char *)"304 Not Modified"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof("307 Temporary Redirect") - 1UL, (u_char *)"307 Temporary Redirect"}, 
        {sizeof("308 Permanent Redirect") - 1UL,
      (u_char *)"308 Permanent Redirect"}, 
        {sizeof("400 Bad Request") - 1UL, (u_char *)"400 Bad Request"}, 
        {sizeof("401 Unauthorized") - 1UL, (u_char *)"401 Unauthorized"}, 
        {sizeof("402 Payment Required") - 1UL, (u_char *)"402 Payment Required"}, 
        {sizeof("403 Forbidden") - 1UL, (u_char *)"403 Forbidden"}, 
        {sizeof("404 Not Found") - 1UL, (u_char *)"404 Not Found"}, 
        {sizeof("405 Not Allowed") - 1UL, (u_char *)"405 Not Allowed"}, 
        {sizeof("406 Not Acceptable") - 1UL, (u_char *)"406 Not Acceptable"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof("408 Request Time-out") - 1UL, (u_char *)"408 Request Time-out"}, 
        {sizeof("409 Conflict") - 1UL, (u_char *)"409 Conflict"}, 
        {sizeof("410 Gone") - 1UL, (u_char *)"410 Gone"}, 
        {sizeof("411 Length Required") - 1UL, (u_char *)"411 Length Required"}, 
        {sizeof("412 Precondition Failed") - 1UL, (u_char *)"412 Precondition Failed"}, 
        {sizeof("413 Request Entity Too Large") - 1UL,
      (u_char *)"413 Request Entity Too Large"}, 
        {sizeof("414 Request-URI Too Large") - 1UL, (u_char *)"414 Request-URI Too Large"}, 
        {sizeof("415 Unsupported Media Type") - 1UL,
      (u_char *)"415 Unsupported Media Type"}, 
        {sizeof("416 Requested Range Not Satisfiable") - 1UL, (u_char *)"416 Requested Range Not Satisfiable"}, 
        {(size_t___0 )0,
      (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof("421 Misdirected Request") - 1UL, (u_char *)"421 Misdirected Request"}, 
        {(size_t___0 )0,
      (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof("429 Too Many Requests") - 1UL, (u_char *)"429 Too Many Requests"}, 
        {sizeof("500 Internal Server Error") - 1UL, (u_char *)"500 Internal Server Error"}, 
        {sizeof("501 Not Implemented") - 1UL,
      (u_char *)"501 Not Implemented"}, 
        {sizeof("502 Bad Gateway") - 1UL, (u_char *)"502 Bad Gateway"}, 
        {sizeof("503 Service Temporarily Unavailable") - 1UL, (u_char *)"503 Service Temporarily Unavailable"}, 
        {sizeof("504 Gateway Time-out") - 1UL,
      (u_char *)"504 Gateway Time-out"}, 
        {sizeof("505 HTTP Version Not Supported") - 1UL, (u_char *)"505 HTTP Version Not Supported"}, 
        {(size_t___0 )0,
      (u_char *)((void *)0)}, 
        {sizeof("507 Insufficient Storage") - 1UL, (u_char *)"507 Insufficient Storage"}};
#line 135 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
ngx_http_header_out_t ngx_http_headers_out[11]  = 
#line 135
  {      {{sizeof("Server") - 1UL, (u_char *)"Server"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->server)}, 
        {{sizeof("Date") - 1UL,
       (u_char *)"Date"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->date)}, 
        {{sizeof("Content-Length") - 1UL,
       (u_char *)"Content-Length"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->content_length)}, 
        {{sizeof("Content-Encoding") - 1UL,
       (u_char *)"Content-Encoding"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->content_encoding)}, 
        {{sizeof("Location") - 1UL,
       (u_char *)"Location"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->location)}, 
        {{sizeof("Last-Modified") - 1UL,
       (u_char *)"Last-Modified"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->last_modified)}, 
        {{sizeof("Accept-Ranges") - 1UL,
       (u_char *)"Accept-Ranges"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->accept_ranges)}, 
        {{sizeof("Expires") - 1UL,
       (u_char *)"Expires"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->expires)}, 
        {{sizeof("Cache-Control") - 1UL,
       (u_char *)"Cache-Control"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->cache_control)}, 
        {{sizeof("ETag") - 1UL,
       (u_char *)"ETag"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->etag)}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 156 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static ngx_int_t ngx_http_header_filter(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_str_t host ;
  ngx_str_t *status_line ;
  ngx_buf_t *b ;
  ngx_uint_t status ;
  ngx_uint_t i ;
  ngx_uint_t port ;
  ngx_chain_t out ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t *cscf ;
  u_char addr[(sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path))] ;
  ngx_int_t tmp ;
  in_port_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  void *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  void *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  u_char *tmp___25 ;
  u_char *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  u_char *tmp___33 ;
  u_char *tmp___34 ;
  void *tmp___35 ;
  u_char *tmp___36 ;
  u_char *tmp___37 ;
  u_char *tmp___38 ;
  u_char *tmp___39 ;
  ngx_int_t tmp___40 ;

  {
#line 172
  if (r->header_sent) {
#line 173
    return ((ngx_int_t )0);
  }
#line 176
  r->header_sent = 1U;
#line 178
  if ((unsigned long )r != (unsigned long )r->main) {
#line 179
    return ((ngx_int_t )0);
  }
#line 182
  if (r->http_version < 1000UL) {
#line 183
    return ((ngx_int_t )0);
  }
#line 186
  if (r->method == 4UL) {
#line 187
    r->header_only = 1U;
  }
#line 190
  if (r->headers_out.last_modified_time != -1L) {
#line 191
    if (r->headers_out.status != 200UL) {
#line 191
      if (r->headers_out.status != 206UL) {
#line 191
        if (r->headers_out.status != 304UL) {
#line 195
          r->headers_out.last_modified_time = (time_t )-1;
#line 196
          r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
        }
      }
    }
  }
#line 200
  len = ((((sizeof("HTTP/1.x ") - 1UL) + sizeof("\r\n")) - 1UL) + sizeof("\r\n")) - 1UL;
#line 206
  if (r->headers_out.status_line.len) {
#line 207
    len += r->headers_out.status_line.len;
#line 208
    status_line = & r->headers_out.status_line;
#line 210
    status = (ngx_uint_t )0;
  } else {
#line 215
    status = r->headers_out.status;
#line 217
    if (status >= 200UL) {
#line 217
      if (status < 207UL) {
#line 222
        if (status == 204UL) {
#line 223
          r->header_only = 1U;
#line 224
          r->headers_out.content_type.len = (size_t___0 )0;
#line 224
          r->headers_out.content_type.data = (u_char *)((void *)0);
#line 225
          r->headers_out.last_modified_time = (time_t )-1;
#line 226
          r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
#line 227
          r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
#line 228
          r->headers_out.content_length_n = (off_t )-1;
        }
#line 231
        status -= 200UL;
#line 232
        status_line = & ngx_http_status_lines[status];
#line 233
        len += ngx_http_status_lines[status].len;
      } else {
#line 217
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 235
    if (status >= 301UL) {
#line 235
      if (status < 309UL) {
#line 240
        if (status == 304UL) {
#line 241
          r->header_only = 1U;
        }
#line 244
        status = (status - 301UL) + 7UL;
#line 245
        status_line = & ngx_http_status_lines[status];
#line 246
        len += ngx_http_status_lines[status].len;
      } else {
#line 235
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 248
    if (status >= 400UL) {
#line 248
      if (status < 430UL) {
#line 252
        status = (status - 400UL) + 15UL;
#line 255
        status_line = & ngx_http_status_lines[status];
#line 256
        len += ngx_http_status_lines[status].len;
      } else {
#line 248
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 258
    if (status >= 500UL) {
#line 258
      if (status < 508UL) {
#line 262
        status = (status - 500UL) + 45UL;
#line 265
        status_line = & ngx_http_status_lines[status];
#line 266
        len += ngx_http_status_lines[status].len;
      } else {
#line 269
        len += (sizeof("-9223372036854775808") - 1UL) + 1UL;
#line 270
        status_line = (ngx_str_t *)((void *)0);
      }
    } else {
#line 269
      len += (sizeof("-9223372036854775808") - 1UL) + 1UL;
#line 270
      status_line = (ngx_str_t *)((void *)0);
    }
#line 273
    if (status_line) {
#line 273
      if (status_line->len == 0UL) {
#line 274
        status = r->headers_out.status;
#line 275
        len += (sizeof("-9223372036854775808") - 1UL) + 1UL;
#line 276
        status_line = (ngx_str_t *)((void *)0);
      }
    }
  }
#line 280
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 282
  if ((unsigned long )r->headers_out.server == (unsigned long )((void *)0)) {
#line 283
    if (clcf->server_tokens == 1UL) {
#line 284
      len += sizeof(ngx_http_server_full_string) - 1UL;
    } else
#line 286
    if (clcf->server_tokens == 2UL) {
#line 287
      len += sizeof(ngx_http_server_build_string) - 1UL;
    } else {
#line 290
      len += sizeof(ngx_http_server_string) - 1UL;
    }
  }
#line 294
  if ((unsigned long )r->headers_out.date == (unsigned long )((void *)0)) {
#line 295
    len += sizeof("Date: Mon, 28 Sep 1970 06:00:00 GMT\r\n") - 1UL;
  }
#line 298
  if (r->headers_out.content_type.len) {
#line 299
    len += ((sizeof("Content-Type: ") - 1UL) + r->headers_out.content_type.len) + 2UL;
#line 302
    if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 302
      if (r->headers_out.charset.len) {
#line 305
        len += (sizeof("; charset=") - 1UL) + r->headers_out.charset.len;
      }
    }
  }
#line 309
  if ((unsigned long )r->headers_out.content_length == (unsigned long )((void *)0)) {
#line 309
    if (r->headers_out.content_length_n >= 0L) {
#line 312
      len += ((sizeof("Content-Length: ") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + 2UL;
    }
  }
#line 315
  if ((unsigned long )r->headers_out.last_modified == (unsigned long )((void *)0)) {
#line 315
    if (r->headers_out.last_modified_time != -1L) {
#line 318
      len += sizeof("Last-Modified: Mon, 28 Sep 1970 06:00:00 GMT\r\n") - 1UL;
    }
  }
#line 321
  c = r->connection;
#line 323
  if (r->headers_out.location) {
#line 323
    if ((r->headers_out.location)->value.len) {
#line 323
      if ((int )*((r->headers_out.location)->value.data + 0) == 47) {
#line 323
        if (clcf->absolute_redirect) {
#line 328
          (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 330
          if (clcf->server_name_in_redirect) {
#line 331
            cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 332
            host = cscf->server_name;
          } else
#line 334
          if (r->headers_in.server.len) {
#line 335
            host = r->headers_in.server;
          } else {
            {
#line 338
            host.len = (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path));
#line 339
            host.data = addr;
#line 341
            tmp = ngx_connection_local_sockaddr(c, & host, (ngx_uint_t )0);
            }
#line 341
            if (tmp != 0L) {
#line 342
              return ((ngx_int_t )-1);
            }
          }
          {
#line 346
          tmp___0 = ngx_inet_get_port(c->local_sockaddr);
#line 346
          port = (ngx_uint_t )tmp___0;
#line 348
          len += (((sizeof("Location: https://") - 1UL) + host.len) + (r->headers_out.location)->value.len) + 2UL;
          }
#line 352
          if (clcf->port_in_redirect) {
#line 359
            if (port == 80UL) {
#line 359
              port = (ngx_uint_t )0;
            } else {
#line 359
              port = port;
            }
          } else {
#line 362
            port = (ngx_uint_t )0;
          }
#line 365
          if (port) {
#line 366
            len += sizeof(":65535") - 1UL;
          }
        } else {
#line 370
          host.len = (size_t___0 )0;
#line 370
          host.data = (u_char *)((void *)0);
#line 371
          port = (ngx_uint_t )0;
        }
      } else {
#line 370
        host.len = (size_t___0 )0;
#line 370
        host.data = (u_char *)((void *)0);
#line 371
        port = (ngx_uint_t )0;
      }
    } else {
#line 370
      host.len = (size_t___0 )0;
#line 370
      host.data = (u_char *)((void *)0);
#line 371
      port = (ngx_uint_t )0;
    }
  } else {
#line 370
    host.len = (size_t___0 )0;
#line 370
    host.data = (u_char *)((void *)0);
#line 371
    port = (ngx_uint_t )0;
  }
#line 374
  if (r->chunked) {
#line 375
    len += sizeof("Transfer-Encoding: chunked\r\n") - 1UL;
  }
#line 378
  if (r->headers_out.status == 101UL) {
#line 379
    len += sizeof("Connection: upgrade\r\n") - 1UL;
  } else
#line 381
  if (r->keepalive) {
#line 382
    len += sizeof("Connection: keep-alive\r\n") - 1UL;
#line 392
    if (clcf->keepalive_header) {
#line 393
      len += ((sizeof("Keep-Alive: timeout=") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + 2UL;
    }
  } else {
#line 397
    len += sizeof("Connection: close\r\n") - 1UL;
  }
#line 401
  if (r->gzip_vary) {
#line 402
    if (clcf->gzip_vary) {
#line 403
      len += sizeof("Vary: Accept-Encoding\r\n") - 1UL;
    } else {
#line 406
      r->gzip_vary = 0U;
    }
  }
#line 411
  part = & r->headers_out.headers.part;
#line 412
  header___0 = (ngx_table_elt_t *)part->elts;
#line 414
  i = (ngx_uint_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (i >= part->nelts) {
#line 417
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 418
        goto while_break;
      }
#line 421
      part = part->next;
#line 422
      header___0 = (ngx_table_elt_t *)part->elts;
#line 423
      i = (ngx_uint_t )0;
    }
#line 426
    if ((header___0 + i)->hash == 0UL) {
#line 427
      goto __Cont;
    }
#line 430
    len += (((((header___0 + i)->key.len + sizeof(": ")) - 1UL) + (header___0 + i)->value.len) + sizeof("\r\n")) - 1UL;
    __Cont: /* CIL Label */ 
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 435
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 436
    return ((ngx_int_t )-1);
  }
  {
#line 440
  tmp___1 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"HTTP/1.1 ",
                   sizeof("HTTP/1.x ") - 1UL);
#line 440
  b->last = (u_char *)tmp___1 + (sizeof("HTTP/1.x ") - 1UL);
  }
#line 443
  if (status_line) {
    {
#line 444
    tmp___2 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)status_line->data,
                     status_line->len);
#line 444
    b->last = (u_char *)tmp___2 + status_line->len;
    }
  } else {
    {
#line 447
    b->last = ngx_sprintf(b->last, "%03ui ", status);
    }
  }
#line 449
  tmp___3 = b->last;
#line 449
  (b->last) ++;
#line 449
  *tmp___3 = (u_char )'\r';
#line 449
  tmp___4 = b->last;
#line 449
  (b->last) ++;
#line 449
  *tmp___4 = (u_char )'\n';
#line 451
  if ((unsigned long )r->headers_out.server == (unsigned long )((void *)0)) {
#line 452
    if (clcf->server_tokens == 1UL) {
#line 453
      p = ngx_http_server_full_string;
#line 454
      len = sizeof(ngx_http_server_full_string) - 1UL;
    } else
#line 456
    if (clcf->server_tokens == 2UL) {
#line 457
      p = ngx_http_server_build_string;
#line 458
      len = sizeof(ngx_http_server_build_string) - 1UL;
    } else {
#line 461
      p = ngx_http_server_string;
#line 462
      len = sizeof(ngx_http_server_string) - 1UL;
    }
    {
#line 465
    tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)p,
                     len);
#line 465
    b->last = (u_char *)tmp___5 + len;
    }
  }
#line 468
  if ((unsigned long )r->headers_out.date == (unsigned long )((void *)0)) {
    {
#line 469
    tmp___6 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Date: ",
                     sizeof("Date: ") - 1UL);
#line 469
    b->last = (u_char *)tmp___6 + (sizeof("Date: ") - 1UL);
#line 470
    tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ngx_cached_http_time.data,
                     (size_t )ngx_cached_http_time.len);
#line 470
    b->last = (u_char *)tmp___7 + ngx_cached_http_time.len;
#line 473
    tmp___8 = b->last;
#line 473
    (b->last) ++;
#line 473
    *tmp___8 = (u_char )'\r';
#line 473
    tmp___9 = b->last;
#line 473
    (b->last) ++;
#line 473
    *tmp___9 = (u_char )'\n';
    }
  }
#line 476
  if (r->headers_out.content_type.len) {
    {
#line 477
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Content-Type: ",
                      sizeof("Content-Type: ") - 1UL);
#line 477
    b->last = (u_char *)tmp___10 + (sizeof("Content-Type: ") - 1UL);
#line 479
    p = b->last;
#line 480
    tmp___11 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->headers_out.content_type.data,
                      r->headers_out.content_type.len);
#line 480
    b->last = (u_char *)tmp___11 + r->headers_out.content_type.len;
    }
#line 483
    if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 483
      if (r->headers_out.charset.len) {
        {
#line 486
        tmp___12 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"; charset=",
                          sizeof("; charset=") - 1UL);
#line 486
        b->last = (u_char *)tmp___12 + (sizeof("; charset=") - 1UL);
#line 488
        tmp___13 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->headers_out.charset.data,
                          r->headers_out.charset.len);
#line 488
        b->last = (u_char *)tmp___13 + r->headers_out.charset.len;
#line 493
        r->headers_out.content_type.len = (size_t___0 )(b->last - p);
#line 494
        r->headers_out.content_type.data = p;
        }
      }
    }
#line 497
    tmp___14 = b->last;
#line 497
    (b->last) ++;
#line 497
    *tmp___14 = (u_char )'\r';
#line 497
    tmp___15 = b->last;
#line 497
    (b->last) ++;
#line 497
    *tmp___15 = (u_char )'\n';
  }
#line 500
  if ((unsigned long )r->headers_out.content_length == (unsigned long )((void *)0)) {
#line 500
    if (r->headers_out.content_length_n >= 0L) {
      {
#line 503
      b->last = ngx_sprintf(b->last, "Content-Length: %O\r\n", r->headers_out.content_length_n);
      }
    }
  }
#line 507
  if ((unsigned long )r->headers_out.last_modified == (unsigned long )((void *)0)) {
#line 507
    if (r->headers_out.last_modified_time != -1L) {
      {
#line 510
      tmp___16 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Last-Modified: ",
                        sizeof("Last-Modified: ") - 1UL);
#line 510
      b->last = (u_char *)tmp___16 + (sizeof("Last-Modified: ") - 1UL);
#line 512
      b->last = ngx_http_time(b->last, r->headers_out.last_modified_time);
#line 514
      tmp___17 = b->last;
#line 514
      (b->last) ++;
#line 514
      *tmp___17 = (u_char )'\r';
#line 514
      tmp___18 = b->last;
#line 514
      (b->last) ++;
#line 514
      *tmp___18 = (u_char )'\n';
      }
    }
  }
#line 517
  if (host.data) {
    {
#line 519
    p = (b->last + sizeof("Location: ")) - 1;
#line 521
    tmp___19 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Location: http",
                      sizeof("Location: http") - 1UL);
#line 521
    b->last = (u_char *)tmp___19 + (sizeof("Location: http") - 1UL);
#line 530
    tmp___20 = b->last;
#line 530
    (b->last) ++;
#line 530
    *tmp___20 = (u_char )':';
#line 530
    tmp___21 = b->last;
#line 530
    (b->last) ++;
#line 530
    *tmp___21 = (u_char )'/';
#line 530
    tmp___22 = b->last;
#line 530
    (b->last) ++;
#line 530
    *tmp___22 = (u_char )'/';
#line 531
    tmp___23 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)host.data,
                      host.len);
#line 531
    b->last = (u_char *)tmp___23 + host.len;
    }
#line 533
    if (port) {
      {
#line 534
      b->last = ngx_sprintf(b->last, ":%ui", port);
      }
    }
    {
#line 537
    tmp___24 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(r->headers_out.location)->value.data,
                      (r->headers_out.location)->value.len);
#line 537
    b->last = (u_char *)tmp___24 + (r->headers_out.location)->value.len;
#line 542
    (r->headers_out.location)->value.len = (size_t___0 )(b->last - p);
#line 543
    (r->headers_out.location)->value.data = p;
#line 544
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 544
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 546
    tmp___25 = b->last;
#line 546
    (b->last) ++;
#line 546
    *tmp___25 = (u_char )'\r';
#line 546
    tmp___26 = b->last;
#line 546
    (b->last) ++;
#line 546
    *tmp___26 = (u_char )'\n';
    }
  }
#line 549
  if (r->chunked) {
    {
#line 550
    tmp___27 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Transfer-Encoding: chunked\r\n",
                      sizeof("Transfer-Encoding: chunked\r\n") - 1UL);
#line 550
    b->last = (u_char *)tmp___27 + (sizeof("Transfer-Encoding: chunked\r\n") - 1UL);
    }
  }
#line 554
  if (r->headers_out.status == 101UL) {
    {
#line 555
    tmp___28 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Connection: upgrade\r\n",
                      sizeof("Connection: upgrade\r\n") - 1UL);
#line 555
    b->last = (u_char *)tmp___28 + (sizeof("Connection: upgrade\r\n") - 1UL);
    }
  } else
#line 558
  if (r->keepalive) {
    {
#line 559
    tmp___29 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Connection: keep-alive\r\n",
                      sizeof("Connection: keep-alive\r\n") - 1UL);
#line 559
    b->last = (u_char *)tmp___29 + (sizeof("Connection: keep-alive\r\n") - 1UL);
    }
#line 562
    if (clcf->keepalive_header) {
      {
#line 563
      b->last = ngx_sprintf(b->last, "Keep-Alive: timeout=%T\r\n", clcf->keepalive_header);
      }
    }
  } else {
    {
#line 568
    tmp___30 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Connection: close\r\n",
                      sizeof("Connection: close\r\n") - 1UL);
#line 568
    b->last = (u_char *)tmp___30 + (sizeof("Connection: close\r\n") - 1UL);
    }
  }
#line 573
  if (r->gzip_vary) {
    {
#line 574
    tmp___31 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Vary: Accept-Encoding\r\n",
                      sizeof("Vary: Accept-Encoding\r\n") - 1UL);
#line 574
    b->last = (u_char *)tmp___31 + (sizeof("Vary: Accept-Encoding\r\n") - 1UL);
    }
  }
#line 579
  part = & r->headers_out.headers.part;
#line 580
  header___0 = (ngx_table_elt_t *)part->elts;
#line 582
  i = (ngx_uint_t )0;
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 584
    if (i >= part->nelts) {
#line 585
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 586
        goto while_break___0;
      }
#line 589
      part = part->next;
#line 590
      header___0 = (ngx_table_elt_t *)part->elts;
#line 591
      i = (ngx_uint_t )0;
    }
#line 594
    if ((header___0 + i)->hash == 0UL) {
#line 595
      goto __Cont___0;
    }
    {
#line 598
    tmp___32 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->key.data,
                      (header___0 + i)->key.len);
#line 598
    b->last = (u_char *)tmp___32 + (header___0 + i)->key.len;
#line 599
    tmp___33 = b->last;
#line 599
    (b->last) ++;
#line 599
    *tmp___33 = (u_char )':';
#line 599
    tmp___34 = b->last;
#line 599
    (b->last) ++;
#line 599
    *tmp___34 = (u_char )' ';
#line 601
    tmp___35 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                      (header___0 + i)->value.len);
#line 601
    b->last = (u_char *)tmp___35 + (header___0 + i)->value.len;
#line 602
    tmp___36 = b->last;
#line 602
    (b->last) ++;
#line 602
    *tmp___36 = (u_char )'\r';
#line 602
    tmp___37 = b->last;
#line 602
    (b->last) ++;
#line 602
    *tmp___37 = (u_char )'\n';
    }
    __Cont___0: /* CIL Label */ 
#line 582
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 609
  tmp___38 = b->last;
#line 609
  (b->last) ++;
#line 609
  *tmp___38 = (u_char )'\r';
#line 609
  tmp___39 = b->last;
#line 609
  (b->last) ++;
#line 609
  *tmp___39 = (u_char )'\n';
#line 611
  r->header_size = (size_t___0 )(b->last - b->pos);
#line 613
  if (r->header_only) {
#line 614
    b->last_buf = 1U;
  }
  {
#line 617
  out.buf = b;
#line 618
  out.next = (ngx_chain_t *)((void *)0);
#line 620
  tmp___40 = ngx_http_write_filter(r, & out);
  }
#line 620
  return (tmp___40);
}
}
#line 624 "/tmp/nginx-1.13.2/src/http/ngx_http_header_filter_module.c"
static ngx_int_t ngx_http_header_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 627
  ngx_http_top_header_filter = & ngx_http_header_filter;
#line 629
  return ((ngx_int_t )0);
}
}
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_write_filter_module.c"
static ngx_int_t ngx_http_write_filter_init(ngx_conf_t *cf ) ;
#line 16 "/tmp/nginx-1.13.2/src/http/ngx_http_write_filter_module.c"
static ngx_http_module_t ngx_http_write_filter_module_ctx  = 
#line 16
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_write_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 31 "/tmp/nginx-1.13.2/src/http/ngx_http_write_filter_module.c"
ngx_module_t ngx_http_write_filter_module  = 
#line 31
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_write_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 47 "/tmp/nginx-1.13.2/src/http/ngx_http_write_filter_module.c"
ngx_int_t ngx_http_write_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  off_t size ;
  off_t sent ;
  off_t nsent ;
  off_t limit ;
  ngx_uint_t last ;
  ngx_uint_t flush ;
  ngx_uint_t sync___0 ;
  ngx_msec_t delay ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_chain_t **ll ;
  ngx_chain_t *chain ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  off_t tmp___2 ;

  {
#line 57
  c = r->connection;
#line 59
  if (c->error) {
#line 60
    return ((ngx_int_t )-1);
  }
#line 63
  size = (off_t )0;
#line 64
  flush = (ngx_uint_t )0;
#line 65
  sync___0 = (ngx_uint_t )0;
#line 66
  last = (ngx_uint_t )0;
#line 67
  ll = & r->out;
#line 71
  cl = r->out;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! cl) {
#line 71
      goto while_break;
    }
#line 72
    ll = & cl->next;
#line 84
    if ((cl->buf)->temporary) {
#line 84
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 84
    if ((cl->buf)->memory) {
#line 84
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 84
    if ((cl->buf)->mmap) {
#line 84
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 84
      tmp = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 84
    if (tmp == 0L) {
#line 84
      if ((cl->buf)->flush) {
#line 84
        goto _L___1;
      } else
#line 84
      if ((cl->buf)->last_buf) {
#line 84
        goto _L___1;
      } else
#line 84
      if ((cl->buf)->sync) {
        _L___1: /* CIL Label */ 
#line 84
        if ((cl->buf)->temporary) {
#line 84
          goto _L___0;
        } else
#line 84
        if ((cl->buf)->memory) {
#line 84
          goto _L___0;
        } else
#line 84
        if ((cl->buf)->mmap) {
#line 84
          goto _L___0;
        } else
#line 84
        if (! (! (cl->buf)->in_file)) {
#line 84
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 85
        if ((c->log)->log_level >= 2UL) {
          {
#line 85
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "zero size buf in writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 98
        ngx_debug_point();
        }
#line 99
        return ((ngx_int_t )-1);
      }
    }
#line 103
    if ((cl->buf)->temporary) {
#line 103
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 103
    if ((cl->buf)->memory) {
#line 103
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 103
    if ((cl->buf)->mmap) {
#line 103
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 103
      tmp___0 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 103
    size += tmp___0;
#line 105
    if ((cl->buf)->flush) {
#line 106
      flush = (ngx_uint_t )1;
    } else
#line 105
    if ((cl->buf)->recycled) {
#line 106
      flush = (ngx_uint_t )1;
    }
#line 109
    if ((cl->buf)->sync) {
#line 110
      sync___0 = (ngx_uint_t )1;
    }
#line 113
    if ((cl->buf)->last_buf) {
#line 114
      last = (ngx_uint_t )1;
    }
#line 71
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  ln = in;
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! ln) {
#line 120
      goto while_break___0;
    }
    {
#line 121
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 122
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 123
      return ((ngx_int_t )-1);
    }
#line 126
    cl->buf = ln->buf;
#line 127
    *ll = cl;
#line 128
    ll = & cl->next;
#line 140
    if ((cl->buf)->temporary) {
#line 140
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 140
    if ((cl->buf)->memory) {
#line 140
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 140
    if ((cl->buf)->mmap) {
#line 140
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 140
      tmp___1 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 140
    if (tmp___1 == 0L) {
#line 140
      if ((cl->buf)->flush) {
#line 140
        goto _L___4;
      } else
#line 140
      if ((cl->buf)->last_buf) {
#line 140
        goto _L___4;
      } else
#line 140
      if ((cl->buf)->sync) {
        _L___4: /* CIL Label */ 
#line 140
        if ((cl->buf)->temporary) {
#line 140
          goto _L___3;
        } else
#line 140
        if ((cl->buf)->memory) {
#line 140
          goto _L___3;
        } else
#line 140
        if ((cl->buf)->mmap) {
#line 140
          goto _L___3;
        } else
#line 140
        if (! (! (cl->buf)->in_file)) {
#line 140
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 141
        if ((c->log)->log_level >= 2UL) {
          {
#line 141
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "zero size buf in writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 154
        ngx_debug_point();
        }
#line 155
        return ((ngx_int_t )-1);
      }
    }
#line 159
    if ((cl->buf)->temporary) {
#line 159
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 159
    if ((cl->buf)->memory) {
#line 159
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 159
    if ((cl->buf)->mmap) {
#line 159
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 159
      tmp___2 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 159
    size += tmp___2;
#line 161
    if ((cl->buf)->flush) {
#line 162
      flush = (ngx_uint_t )1;
    } else
#line 161
    if ((cl->buf)->recycled) {
#line 162
      flush = (ngx_uint_t )1;
    }
#line 165
    if ((cl->buf)->sync) {
#line 166
      sync___0 = (ngx_uint_t )1;
    }
#line 169
    if ((cl->buf)->last_buf) {
#line 170
      last = (ngx_uint_t )1;
    }
#line 120
    ln = ln->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  *ll = (ngx_chain_t *)((void *)0);
#line 179
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 187
  if (! last) {
#line 187
    if (! flush) {
#line 187
      if (in) {
#line 187
        if (size < (off_t )clcf->postpone_output) {
#line 188
          return ((ngx_int_t )0);
        }
      }
    }
  }
#line 191
  if ((c->write)->delayed) {
#line 192
    c->buffered |= 16U;
#line 193
    return ((ngx_int_t )-2);
  }
#line 196
  if (size == 0L) {
#line 196
    if (! (c->buffered & 15U)) {
#line 196
      if (last) {
#line 196
        if (! c->need_last_buf) {
#line 196
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
#line 200
        if (last) {
#line 200
          goto _L___5;
        } else
#line 200
        if (flush) {
#line 200
          goto _L___5;
        } else
#line 200
        if (sync___0) {
          _L___5: /* CIL Label */ 
#line 201
          cl = r->out;
          {
#line 201
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 201
            if (! cl) {
#line 201
              goto while_break___1;
            }
#line 202
            ln = cl;
#line 203
            cl = cl->next;
#line 204
            ln->next = (r->pool)->chain;
#line 204
            (r->pool)->chain = ln;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 207
          r->out = (ngx_chain_t *)((void *)0);
#line 208
          c->buffered &= 4294967279U;
#line 210
          return ((ngx_int_t )0);
        }
#line 213
        if ((c->log)->log_level >= 2UL) {
          {
#line 213
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "the http output chain is empty");
          }
        }
        {
#line 216
        ngx_debug_point();
        }
#line 218
        return ((ngx_int_t )-1);
      }
    }
  }
#line 221
  if (r->limit_rate) {
#line 222
    if (r->limit_rate_after == 0UL) {
#line 223
      r->limit_rate_after = clcf->limit_rate_after;
    }
#line 226
    limit = (off_t )((size_t___0 )((off_t )r->limit_rate * (off_t )((ngx_cached_time->sec - (time_t volatile   )r->start_sec) + (time_t volatile   )1)) - ((size_t___0 )c->sent - r->limit_rate_after));
#line 229
    if (limit <= 0L) {
      {
#line 230
      (c->write)->delayed = 1U;
#line 231
      delay = (size_t___0 )(- limit * 1000L) / r->limit_rate + 1UL;
#line 232
      ngx_event_add_timer(c->write, delay);
#line 234
      c->buffered |= 16U;
      }
#line 236
      return ((ngx_int_t )-2);
    }
#line 239
    if (clcf->sendfile_max_chunk) {
#line 239
      if ((off_t )clcf->sendfile_max_chunk < limit) {
#line 242
        limit = (off_t )clcf->sendfile_max_chunk;
      }
    }
  } else {
#line 246
    limit = (off_t )clcf->sendfile_max_chunk;
  }
  {
#line 249
  sent = c->sent;
#line 254
  chain = (*(c->send_chain))(c, r->out, limit);
  }
#line 259
  if ((unsigned long )chain == (unsigned long )((ngx_chain_t *)-1)) {
#line 260
    c->error = 1U;
#line 261
    return ((ngx_int_t )-1);
  }
#line 264
  if (r->limit_rate) {
#line 266
    nsent = c->sent;
#line 268
    if (r->limit_rate_after) {
#line 270
      sent = (off_t )((size_t___0 )sent - r->limit_rate_after);
#line 271
      if (sent < 0L) {
#line 272
        sent = (off_t )0;
      }
#line 275
      nsent = (off_t )((size_t___0 )nsent - r->limit_rate_after);
#line 276
      if (nsent < 0L) {
#line 277
        nsent = (off_t )0;
      }
    }
#line 281
    delay = (size_t___0 )((nsent - sent) * 1000L) / r->limit_rate;
#line 283
    if (delay > 0UL) {
      {
#line 284
      limit = (off_t )0;
#line 285
      (c->write)->delayed = 1U;
#line 286
      ngx_event_add_timer(c->write, delay);
      }
    }
  }
#line 290
  if (limit) {
#line 290
    if ((c->write)->ready) {
#line 290
      if (c->sent - sent >= limit - (off_t )(2UL * ngx_pagesize)) {
        {
#line 294
        (c->write)->delayed = 1U;
#line 295
        ngx_event_add_timer(c->write, (ngx_msec_t )1);
        }
      }
    }
  }
#line 298
  cl = r->out;
  {
#line 298
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 298
    if (cl) {
#line 298
      if (! ((unsigned long )cl != (unsigned long )chain)) {
#line 298
        goto while_break___2;
      }
    } else {
#line 298
      goto while_break___2;
    }
#line 299
    ln = cl;
#line 300
    cl = cl->next;
#line 301
    ln->next = (r->pool)->chain;
#line 301
    (r->pool)->chain = ln;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 304
  r->out = chain;
#line 306
  if (chain) {
#line 307
    c->buffered |= 16U;
#line 308
    return ((ngx_int_t )-2);
  }
#line 311
  c->buffered &= 4294967279U;
#line 313
  if (c->buffered & 15U) {
#line 313
    if ((unsigned long )r->postponed == (unsigned long )((void *)0)) {
#line 314
      return ((ngx_int_t )-2);
    }
  }
#line 317
  return ((ngx_int_t )0);
}
}
#line 321 "/tmp/nginx-1.13.2/src/http/ngx_http_write_filter_module.c"
static ngx_int_t ngx_http_write_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 324
  ngx_http_top_body_filter = & ngx_http_write_filter;
#line 326
  return ((ngx_int_t )0);
}
}
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
#line 463 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 179 "src/core/ngx_string.h"
u_char *ngx_hex_dump(u_char *dst , u_char *src , size_t___0 len ) ;
#line 129 "src/os/unix/ngx_files.h"
ssize_t ngx_write_file(ngx_file_t *file , u_char *buf , size_t___0 size , off_t offset ) ;
#line 351
size_t___0 ngx_fs_bsize(u_char *name ) ;
#line 17 "src/core/ngx_parse.h"
off_t ngx_parse_offset(ngx_str_t *line ) ;
#line 16 "src/os/unix/ngx_alloc.h"
void *ngx_alloc(size_t___0 size , ngx_log_t *log ) ;
#line 142 "src/core/ngx_file.h"
void ngx_create_hashed_filename(ngx_path_t *path , u_char *file , size_t___0 len ) ;
#line 145
ngx_int_t ngx_add_path(ngx_conf_t *cf , ngx_path_t **slot___0 ) ;
#line 147
ngx_int_t ngx_ext_rename_file(ngx_str_t *src , ngx_str_t *to , ngx_ext_rename_file_t *ext ) ;
#line 150
ngx_int_t ngx_walk_tree(ngx_tree_ctx_t *ctx , ngx_str_t *tree ) ;
#line 24 "src/core/ngx_times.h"
void ngx_time_update(void) ;
#line 52 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_quit ;
#line 187 "src/http/ngx_http_cache.h"
ngx_int_t ngx_http_file_cache_new(ngx_http_request_t *r ) ;
#line 188
ngx_int_t ngx_http_file_cache_create(ngx_http_request_t *r ) ;
#line 189
void ngx_http_file_cache_create_key(ngx_http_request_t *r ) ;
#line 190
ngx_int_t ngx_http_file_cache_open(ngx_http_request_t *r ) ;
#line 191
ngx_int_t ngx_http_file_cache_set_header(ngx_http_request_t *r , u_char *buf ) ;
#line 192
void ngx_http_file_cache_update(ngx_http_request_t *r , ngx_temp_file_t *tf ) ;
#line 193
void ngx_http_file_cache_update_header(ngx_http_request_t *r ) ;
#line 194
ngx_int_t ngx_http_cache_send(ngx_http_request_t *r ) ;
#line 195
void ngx_http_file_cache_free(ngx_http_cache_t *c , ngx_temp_file_t *tf ) ;
#line 196
time_t ngx_http_file_cache_valid(ngx_array_t *cache_valid , ngx_uint_t status ) ;
#line 204
ngx_str_t ngx_http_cache_status[7] ;
#line 120 "src/http/ngx_http.h"
void ngx_http_run_posted_requests(ngx_connection_t *c ) ;
#line 23 "src/core/ngx_md5.h"
void ngx_md5_init(ngx_md5_t *ctx ) ;
#line 24
void ngx_md5_update(ngx_md5_t *ctx , void const   *data , size_t___0 size ) ;
#line 25
void ngx_md5_final(u_char *result___0 , ngx_md5_t *ctx ) ;
#line 14 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 16
static void ngx_http_file_cache_lock_wait_handler(ngx_event_t *ev ) ;
#line 17
static void ngx_http_file_cache_lock_wait(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 19
static ngx_int_t ngx_http_file_cache_read(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 21
static ssize_t ngx_http_file_cache_aio_read(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 31
static ngx_int_t ngx_http_file_cache_exists(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) ;
#line 33
static ngx_int_t ngx_http_file_cache_name(ngx_http_request_t *r , ngx_path_t *path ) ;
#line 35
static ngx_http_file_cache_node_t *ngx_http_file_cache_lookup(ngx_http_file_cache_t *cache ,
                                                              u_char *key ) ;
#line 37
static void ngx_http_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) ;
#line 39
static void ngx_http_file_cache_vary(ngx_http_request_t *r , u_char *vary , size_t___0 len ,
                                     u_char *hash ) ;
#line 41
static void ngx_http_file_cache_vary_header(ngx_http_request_t *r , ngx_md5_t *md5 ,
                                            ngx_str_t *name ) ;
#line 43
static ngx_int_t ngx_http_file_cache_reopen(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 45
static ngx_int_t ngx_http_file_cache_update_variant(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 47
static void ngx_http_file_cache_cleanup(void *data ) ;
#line 48
static time_t ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache ) ;
#line 49
static time_t ngx_http_file_cache_expire(ngx_http_file_cache_t *cache ) ;
#line 50
static void ngx_http_file_cache_delete(ngx_http_file_cache_t *cache , ngx_queue_t *q ,
                                       u_char *name ) ;
#line 52
static void ngx_http_file_cache_loader_sleep(ngx_http_file_cache_t *cache ) ;
#line 53
static ngx_int_t ngx_http_file_cache_noop(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 55
static ngx_int_t ngx_http_file_cache_manage_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 57
static ngx_int_t ngx_http_file_cache_manage_directory(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 59
static ngx_int_t ngx_http_file_cache_add_file(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
#line 61
static ngx_int_t ngx_http_file_cache_add(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) ;
#line 63
static ngx_int_t ngx_http_file_cache_delete_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 65
static void ngx_http_file_cache_set_watermark(ngx_http_file_cache_t *cache ) ;
#line 68 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
ngx_str_t ngx_http_cache_status[7]  = {      {sizeof("MISS") - 1UL, (u_char *)"MISS"}, 
        {sizeof("BYPASS") - 1UL, (u_char *)"BYPASS"}, 
        {sizeof("EXPIRED") - 1UL, (u_char *)"EXPIRED"}, 
        {sizeof("STALE") - 1UL, (u_char *)"STALE"}, 
        {sizeof("UPDATING") - 1UL, (u_char *)"UPDATING"}, 
        {sizeof("REVALIDATED") - 1UL, (u_char *)"REVALIDATED"}, 
        {sizeof("HIT") - 1UL, (u_char *)"HIT"}};
#line 79 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static u_char ngx_http_file_cache_key[6]  = {      (u_char )'\n',      (u_char )'K',      (u_char )'E',      (u_char )'Y', 
        (u_char )':',      (u_char )' '};
#line 82 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_init(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  ngx_http_file_cache_t *ocache ;
  size_t___0 len ;
  ngx_uint_t n ;
  ngx_http_file_cache_t *cache ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 85
  ocache = (ngx_http_file_cache_t *)data;
#line 91
  cache = (ngx_http_file_cache_t *)shm_zone->data;
#line 93
  if (ocache) {
    {
#line 94
    tmp = strcmp((char const   *)(cache->path)->name.data, (char const   *)(ocache->path)->name.data);
    }
#line 94
    if (tmp != 0) {
#line 95
      if ((shm_zone->shm.log)->log_level >= 1UL) {
        {
#line 95
        ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "cache \"%V\" uses the \"%V\" cache path while previously it used the \"%V\" cache path",
                           & shm_zone->shm.name, & (cache->path)->name, & (ocache->path)->name);
        }
      }
#line 101
      return ((ngx_int_t )-1);
    }
#line 104
    n = (ngx_uint_t )0;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! (n < 3UL)) {
#line 104
        goto while_break;
      }
#line 105
      if ((cache->path)->level[n] != (ocache->path)->level[n]) {
#line 106
        if ((shm_zone->shm.log)->log_level >= 1UL) {
          {
#line 106
          ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "cache \"%V\" had previously different levels",
                             & shm_zone->shm.name);
          }
        }
#line 109
        return ((ngx_int_t )-1);
      }
#line 104
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 113
    cache->sh = ocache->sh;
#line 115
    cache->shpool = ocache->shpool;
#line 116
    cache->bsize = ocache->bsize;
#line 118
    cache->max_size = (off_t )((size_t___0 )cache->max_size / cache->bsize);
#line 120
    if (! (cache->sh)->cold) {
#line 121
      (cache->path)->loader = (void (*)(void *data ))((void *)0);
    } else
#line 120
    if ((cache->sh)->loading) {
#line 121
      (cache->path)->loader = (void (*)(void *data ))((void *)0);
    }
#line 124
    return ((ngx_int_t )0);
  }
#line 127
  cache->shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 129
  if (shm_zone->shm.exists) {
    {
#line 130
    cache->sh = (ngx_http_file_cache_sh_t *)(cache->shpool)->data;
#line 131
    cache->bsize = ngx_fs_bsize((cache->path)->name.data);
    }
#line 133
    return ((ngx_int_t )0);
  }
  {
#line 136
  tmp___0 = ngx_slab_alloc(cache->shpool, sizeof(ngx_http_file_cache_sh_t ));
#line 136
  cache->sh = (ngx_http_file_cache_sh_t *)tmp___0;
  }
#line 137
  if ((unsigned long )cache->sh == (unsigned long )((void *)0)) {
#line 138
    return ((ngx_int_t )-1);
  }
  {
#line 141
  (cache->shpool)->data = (void *)cache->sh;
#line 143
  (cache->sh)->sentinel.color = (u_char )0;
#line 143
  (cache->sh)->rbtree.root = & (cache->sh)->sentinel;
#line 143
  (cache->sh)->rbtree.sentinel = & (cache->sh)->sentinel;
#line 143
  (cache->sh)->rbtree.insert = & ngx_http_file_cache_rbtree_insert_value;
#line 146
  (cache->sh)->queue.prev = & (cache->sh)->queue;
#line 146
  (cache->sh)->queue.next = & (cache->sh)->queue;
#line 148
  (cache->sh)->cold = (ngx_atomic_t )1;
#line 149
  (cache->sh)->loading = (ngx_atomic_t )0;
#line 150
  (cache->sh)->size = (off_t )0;
#line 151
  (cache->sh)->count = (ngx_uint_t )0;
#line 152
  (cache->sh)->watermark = (ngx_uint_t )-1;
#line 154
  cache->bsize = ngx_fs_bsize((cache->path)->name.data);
#line 156
  cache->max_size = (off_t )((size_t___0 )cache->max_size / cache->bsize);
#line 158
  len = sizeof(" in cache keys zone \"\"") + shm_zone->shm.name.len;
#line 160
  tmp___1 = ngx_slab_alloc(cache->shpool, len);
#line 160
  (cache->shpool)->log_ctx = (u_char *)tmp___1;
  }
#line 161
  if ((unsigned long )(cache->shpool)->log_ctx == (unsigned long )((void *)0)) {
#line 162
    return ((ngx_int_t )-1);
  }
  {
#line 165
  ngx_sprintf((cache->shpool)->log_ctx, " in cache keys zone \"%V\"%Z", & shm_zone->shm.name);
#line 168
  (cache->shpool)->log_nomem = 0U;
  }
#line 170
  return ((ngx_int_t )0);
}
}
#line 174 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_new(ngx_http_request_t *r ) 
{ 
  ngx_http_cache_t *c ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 179
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_cache_t ));
#line 179
  c = (ngx_http_cache_t *)tmp;
  }
#line 180
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 181
    return ((ngx_int_t )-1);
  }
  {
#line 184
  tmp___0 = ngx_array_init(& c->keys, r->pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
  }
#line 184
  if (tmp___0 != 0L) {
#line 185
    return ((ngx_int_t )-1);
  }
#line 188
  r->cache = c;
#line 189
  c->file.log = (r->connection)->log;
#line 190
  c->file.fd = -1;
#line 192
  return ((ngx_int_t )0);
}
}
#line 196 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_create(ngx_http_request_t *r ) 
{ 
  ngx_http_cache_t *c ;
  ngx_pool_cleanup_t *cln ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 203
  c = r->cache;
#line 204
  cache = c->file_cache;
#line 206
  cln = ngx_pool_cleanup_add(r->pool, (size_t___0 )0);
  }
#line 207
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 208
    return ((ngx_int_t )-1);
  }
  {
#line 211
  cln->handler = & ngx_http_file_cache_cleanup;
#line 212
  cln->data = (void *)c;
#line 214
  tmp = ngx_http_file_cache_exists(cache, c);
  }
#line 214
  if (tmp == -1L) {
#line 215
    return ((ngx_int_t )-1);
  }
  {
#line 218
  tmp___0 = ngx_http_file_cache_name(r, cache->path);
  }
#line 218
  if (tmp___0 != 0L) {
#line 219
    return ((ngx_int_t )-1);
  }
#line 222
  return ((ngx_int_t )0);
}
}
#line 226 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_create_key(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  ngx_str_t *key ;
  ngx_uint_t i ;
  ngx_md5_t md5 ;
  ngx_http_cache_t *c ;

  {
  {
#line 235
  c = r->cache;
#line 237
  len = (size_t___0 )0;
#line 239
  c->crc32 = 4294967295U;
#line 240
  ngx_md5_init(& md5);
#line 242
  key = (ngx_str_t *)c->keys.elts;
#line 243
  i = (ngx_uint_t )0;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i < c->keys.nelts)) {
#line 243
      goto while_break;
    }
    {
#line 247
    len += (key + i)->len;
#line 249
    ngx_crc32_update(& c->crc32, (key + i)->data, (key + i)->len);
#line 250
    ngx_md5_update(& md5, (void const   *)(key + i)->data, (key + i)->len);
#line 243
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  c->header_start = ((sizeof(ngx_http_file_cache_header_t ) + sizeof(ngx_http_file_cache_key)) + len) + 1UL;
#line 256
  c->crc32 ^= 4294967295U;
#line 257
  ngx_md5_final((u_char *)(c->key), & md5);
#line 259
  memcpy((void */* __restrict  */)(c->main), (void const   */* __restrict  */)(c->key),
         (size_t )16);
  }
#line 260
  return;
}
}
#line 263 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_open(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_uint_t test ;
  ngx_http_cache_t *c ;
  ngx_pool_cleanup_t *cln ;
  ngx_open_file_info_t of ;
  ngx_http_file_cache_t *cache ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 274
  c = r->cache;
#line 276
  if (c->waiting) {
#line 277
    return ((ngx_int_t )-2);
  }
#line 280
  if (c->reading) {
    {
#line 281
    tmp = ngx_http_file_cache_read(r, c);
    }
#line 281
    return (tmp);
  }
#line 284
  cache = c->file_cache;
#line 286
  if ((unsigned long )c->node == (unsigned long )((void *)0)) {
    {
#line 287
    cln = ngx_pool_cleanup_add(r->pool, (size_t___0 )0);
    }
#line 288
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 289
      return ((ngx_int_t )-1);
    }
#line 292
    cln->handler = & ngx_http_file_cache_cleanup;
#line 293
    cln->data = (void *)c;
  }
  {
#line 296
  rc = ngx_http_file_cache_exists(cache, c);
  }
#line 301
  if (rc == -1L) {
#line 302
    return (rc);
  }
#line 305
  if (rc == -2L) {
#line 306
    return ((ngx_int_t )8);
  }
#line 309
  if (rc == 0L) {
#line 311
    if (c->error) {
#line 312
      return ((ngx_int_t )c->error);
    }
#line 315
    c->temp_file = 1U;
#line 316
    if (c->exists) {
#line 316
      test = (ngx_uint_t )1;
    } else {
#line 316
      test = (ngx_uint_t )0;
    }
#line 317
    rv = (ngx_int_t )-5;
  } else {
#line 321
    if ((cache->sh)->cold) {
#line 321
      test = (ngx_uint_t )1;
    } else {
#line 321
      test = (ngx_uint_t )0;
    }
#line 323
    if (c->min_uses > 1UL) {
#line 325
      if (! test) {
#line 326
        return ((ngx_int_t )8);
      }
#line 329
      rv = (ngx_int_t )8;
    } else {
#line 332
      c->temp_file = 1U;
#line 333
      rv = (ngx_int_t )-5;
    }
  }
  {
#line 337
  tmp___0 = ngx_http_file_cache_name(r, cache->path);
  }
#line 337
  if (tmp___0 != 0L) {
#line 338
    return ((ngx_int_t )-1);
  }
#line 341
  if (! test) {
#line 342
    goto done;
  }
  {
#line 345
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 347
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 349
  of.uniq = c->uniq;
#line 350
  of.valid = clcf->open_file_cache_valid;
#line 351
  of.min_uses = clcf->open_file_cache_min_uses;
#line 352
  of.events = (unsigned int )clcf->open_file_cache_events;
#line 353
  of.directio = (off_t )9223372036854775807LL;
#line 354
  of.read_ahead = clcf->read_ahead;
#line 356
  tmp___1 = ngx_open_cached_file(clcf->open_file_cache, & c->file.name, & of, r->pool);
  }
#line 356
  if (tmp___1 != 0L) {
    {
#line 361
    if (of.err == 0) {
#line 361
      goto case_0;
    }
#line 365
    if (of.err == 20) {
#line 365
      goto case_20;
    }
#line 365
    if (of.err == 2) {
#line 365
      goto case_20;
    }
#line 368
    goto switch_default;
    case_0: /* CIL Label */ 
#line 362
    return ((ngx_int_t )-1);
    case_20: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 366
    goto done;
    switch_default: /* CIL Label */ 
#line 369
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 369
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "open() \"%s\" failed",
                         c->file.name.data);
      }
    }
#line 371
    return ((ngx_int_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 378
  c->file.fd = of.fd;
#line 379
  c->file.log = (r->connection)->log;
#line 380
  c->uniq = of.uniq;
#line 381
  c->length = of.size;
#line 382
  c->fs_size = (off_t )((((size_t___0 )of.fs_size + cache->bsize) - 1UL) / cache->bsize);
#line 384
  c->buf = ngx_create_temp_buf(r->pool, c->body_start);
  }
#line 385
  if ((unsigned long )c->buf == (unsigned long )((void *)0)) {
#line 386
    return ((ngx_int_t )-1);
  }
  {
#line 389
  tmp___2 = ngx_http_file_cache_read(r, c);
  }
#line 389
  return (tmp___2);
  done: 
#line 393
  if (rv == -5L) {
    {
#line 394
    tmp___3 = ngx_http_file_cache_lock(r, c);
    }
#line 394
    return (tmp___3);
  }
#line 397
  return (rv);
}
}
#line 401 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_msec_t now ;
  ngx_msec_t timer ;
  ngx_http_file_cache_t *cache ;
  ngx_msec_t tmp ;

  {
#line 407
  if (! c->lock) {
#line 408
    return ((ngx_int_t )-5);
  }
  {
#line 411
  now = (ngx_msec_t )ngx_current_msec;
#line 413
  cache = c->file_cache;
#line 415
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 417
  timer = (c->node)->lock_time - now;
  }
#line 419
  if (! (c->node)->updating) {
#line 420
    (c->node)->updating = 1U;
#line 421
    (c->node)->lock_time = now + c->lock_age;
#line 422
    c->updating = 1U;
#line 423
    c->lock_time = (c->node)->lock_time;
  } else
#line 419
  if ((ngx_msec_int_t )timer <= 0L) {
#line 420
    (c->node)->updating = 1U;
#line 421
    (c->node)->lock_time = now + c->lock_age;
#line 422
    c->updating = 1U;
#line 423
    c->lock_time = (c->node)->lock_time;
  }
  {
#line 426
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 432
  if (c->updating) {
#line 433
    return ((ngx_int_t )-5);
  }
#line 436
  if (c->lock_timeout == 0UL) {
#line 437
    return ((ngx_int_t )8);
  }
#line 440
  c->waiting = 1U;
#line 442
  if (c->wait_time == 0UL) {
#line 443
    c->wait_time = now + c->lock_timeout;
#line 445
    c->wait_event.handler = & ngx_http_file_cache_lock_wait_handler;
#line 446
    c->wait_event.data = (void *)r;
#line 447
    c->wait_event.log = (r->connection)->log;
  }
#line 450
  timer = c->wait_time - now;
#line 452
  if (timer > 500UL) {
#line 452
    tmp = (ngx_msec_t )500;
  } else {
#line 452
    tmp = timer;
  }
  {
#line 452
  ngx_event_add_timer(& c->wait_event, tmp);
#line 454
  ((r->main)->blocked) ++;
  }
#line 456
  return ((ngx_int_t )-2);
}
}
#line 460 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_lock_wait_handler(ngx_event_t *ev ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *r ;

  {
  {
#line 466
  r = (ngx_http_request_t *)ev->data;
#line 467
  c = r->connection;
#line 469
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 474
  ngx_http_file_cache_lock_wait(r, r->cache);
#line 476
  ngx_http_run_posted_requests(c);
  }
#line 477
  return;
}
}
#line 480 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_lock_wait(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_uint_t wait___0 ;
  ngx_msec_t now ;
  ngx_msec_t timer ;
  ngx_http_file_cache_t *cache ;
  ngx_msec_t tmp ;

  {
#line 487
  now = (ngx_msec_t )ngx_current_msec;
#line 489
  timer = c->wait_time - now;
#line 491
  if ((ngx_msec_int_t )timer <= 0L) {
#line 492
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 492
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "cache lock timeout");
      }
    }
#line 494
    c->lock_timeout = (ngx_msec_t )0;
#line 495
    goto wakeup;
  }
  {
#line 498
  cache = c->file_cache;
#line 499
  wait___0 = (ngx_uint_t )0;
#line 501
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 503
  timer = (c->node)->lock_time - now;
  }
#line 505
  if ((c->node)->updating) {
#line 505
    if ((ngx_msec_int_t )timer > 0L) {
#line 506
      wait___0 = (ngx_uint_t )1;
    }
  }
  {
#line 509
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 511
  if (wait___0) {
#line 512
    if (timer > 500UL) {
#line 512
      tmp = (ngx_msec_t )500;
    } else {
#line 512
      tmp = timer;
    }
    {
#line 512
    ngx_event_add_timer(& c->wait_event, tmp);
    }
#line 513
    return;
  }
  wakeup: 
  {
#line 518
  c->waiting = 0U;
#line 519
  ((r->main)->blocked) --;
#line 520
  (*(r->write_event_handler))(r);
  }
#line 521
  return;
}
}
#line 524 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_read(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  u_char *p ;
  time_t now ;
  ssize_t n ;
  ngx_str_t *key ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_http_file_cache_t *cache ;
  ngx_http_file_cache_header_t *h ;
  int tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 536
  n = ngx_http_file_cache_aio_read(r, c);
  }
#line 538
  if (n < 0L) {
#line 539
    return (n);
  }
#line 542
  if ((size_t___0 )n < c->header_start) {
#line 543
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 543
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" is too small",
                         c->file.name.data);
      }
    }
#line 545
    return ((ngx_int_t )-5);
  }
#line 548
  h = (ngx_http_file_cache_header_t *)(c->buf)->pos;
#line 550
  if (h->version != 5UL) {
#line 551
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 551
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "cache file \"%s\" version mismatch",
                         c->file.name.data);
      }
    }
#line 553
    return ((ngx_int_t )-5);
  }
#line 556
  if (h->crc32 != c->crc32) {
#line 556
    goto _L;
  } else
#line 556
  if ((size_t___0 )h->header_start != c->header_start) {
    _L: /* CIL Label */ 
#line 557
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 557
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has md5 collision",
                         c->file.name.data);
      }
    }
#line 559
    return ((ngx_int_t )-5);
  }
#line 562
  p = ((c->buf)->pos + sizeof(ngx_http_file_cache_header_t )) + sizeof(ngx_http_file_cache_key);
#line 565
  key = (ngx_str_t *)c->keys.elts;
#line 566
  i = (ngx_uint_t )0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < c->keys.nelts)) {
#line 566
      goto while_break;
    }
    {
#line 567
    tmp = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)(key + i)->data),
                 (key + i)->len);
    }
#line 567
    if (tmp != 0) {
#line 568
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 568
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has md5 collision",
                           c->file.name.data);
        }
      }
#line 571
      return ((ngx_int_t )-5);
    }
#line 574
    p += (key + i)->len;
#line 566
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  if ((size_t___0 )h->body_start > c->body_start) {
#line 578
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 578
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has too long header",
                         c->file.name.data);
      }
    }
#line 581
    return ((ngx_int_t )-5);
  }
#line 584
  if ((int )h->vary_len > 128) {
#line 585
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 585
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has incorrect vary length",
                         c->file.name.data);
      }
    }
#line 588
    return ((ngx_int_t )-5);
  }
#line 591
  if (h->vary_len) {
    {
#line 592
    ngx_http_file_cache_vary(r, h->vary, (size_t___0 )h->vary_len, c->variant);
#line 594
    tmp___1 = memcmp((void const   *)((char const   *)(c->variant)), (void const   *)((char const   *)(h->variant)),
                     (size_t )16);
    }
#line 594
    if (tmp___1 != 0) {
      {
#line 597
      tmp___0 = ngx_http_file_cache_reopen(r, c);
      }
#line 597
      return (tmp___0);
    }
  }
#line 601
  (c->buf)->last += n;
#line 603
  c->valid_sec = h->valid_sec;
#line 604
  c->updating_sec = h->updating_sec;
#line 605
  c->error_sec = h->error_sec;
#line 606
  c->last_modified = h->last_modified;
#line 607
  c->date = h->date;
#line 608
  c->valid_msec = (ngx_uint_t )h->valid_msec;
#line 609
  c->body_start = (size_t___0 )h->body_start;
#line 610
  c->etag.len = (size_t___0 )h->etag_len;
#line 611
  c->etag.data = h->etag;
#line 613
  r->cached = 1U;
#line 615
  cache = c->file_cache;
#line 617
  if ((cache->sh)->cold) {
    {
#line 619
    ngx_shmtx_lock(& (cache->shpool)->mutex);
    }
#line 621
    if (! (c->node)->exists) {
#line 622
      (c->node)->uses = 1U;
#line 623
      (c->node)->body_start = c->body_start;
#line 624
      (c->node)->exists = 1U;
#line 625
      (c->node)->uniq = c->uniq;
#line 626
      (c->node)->fs_size = c->fs_size;
#line 628
      (cache->sh)->size += c->fs_size;
    }
    {
#line 631
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
    }
  }
#line 634
  now = (time_t )ngx_cached_time->sec;
#line 636
  if (c->valid_sec < now) {
    {
#line 637
    c->stale_updating = (unsigned int )(c->valid_sec + c->updating_sec >= now);
#line 638
    c->stale_error = (unsigned int )(c->valid_sec + c->error_sec >= now);
#line 640
    ngx_shmtx_lock(& (cache->shpool)->mutex);
    }
#line 642
    if ((c->node)->updating) {
#line 643
      rc = (ngx_int_t )5;
    } else {
#line 646
      (c->node)->updating = 1U;
#line 647
      c->updating = 1U;
#line 648
      c->lock_time = (c->node)->lock_time;
#line 649
      rc = (ngx_int_t )4;
    }
    {
#line 652
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
    }
#line 658
    return (rc);
  }
#line 661
  return ((ngx_int_t )0);
}
}
#line 665 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ssize_t ngx_http_file_cache_aio_read(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ssize_t tmp ;

  {
  {
#line 715
  tmp = ngx_read_file(& c->file, (c->buf)->pos, c->body_start, (off_t )0);
  }
#line 715
  return (tmp);
}
}
#line 818 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_exists(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) 
{ 
  ngx_int_t rc ;
  ngx_http_file_cache_node_t *fcn ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 824
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 826
  fcn = c->node;
  }
#line 828
  if ((unsigned long )fcn == (unsigned long )((void *)0)) {
    {
#line 829
    fcn = ngx_http_file_cache_lookup(cache, c->key);
    }
  }
#line 832
  if (fcn) {
#line 833
    (fcn->queue.next)->prev = fcn->queue.prev;
#line 833
    (fcn->queue.prev)->next = fcn->queue.next;
#line 835
    if ((unsigned long )c->node == (unsigned long )((void *)0)) {
#line 836
      (fcn->uses) ++;
#line 837
      (fcn->count) ++;
    }
#line 840
    if (fcn->error) {
#line 842
      if (fcn->valid_sec < (time_t )ngx_cached_time->sec) {
#line 843
        goto renew;
      }
#line 846
      rc = (ngx_int_t )0;
#line 848
      goto done;
    }
#line 851
    if (fcn->exists) {
#line 851
      goto _L;
    } else
#line 851
    if ((ngx_uint_t )fcn->uses >= c->min_uses) {
      _L: /* CIL Label */ 
#line 853
      c->exists = fcn->exists;
#line 854
      if (fcn->body_start) {
#line 855
        c->body_start = fcn->body_start;
      }
#line 858
      rc = (ngx_int_t )0;
#line 860
      goto done;
    }
#line 863
    rc = (ngx_int_t )-2;
#line 865
    goto done;
  }
  {
#line 868
  tmp = ngx_slab_calloc_locked(cache->shpool, sizeof(ngx_http_file_cache_node_t ));
#line 868
  fcn = (ngx_http_file_cache_node_t *)tmp;
  }
#line 870
  if ((unsigned long )fcn == (unsigned long )((void *)0)) {
    {
#line 871
    ngx_http_file_cache_set_watermark(cache);
#line 873
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 875
    ngx_http_file_cache_forced_expire(cache);
#line 877
    ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 879
    tmp___0 = ngx_slab_calloc_locked(cache->shpool, sizeof(ngx_http_file_cache_node_t ));
#line 879
    fcn = (ngx_http_file_cache_node_t *)tmp___0;
    }
#line 881
    if ((unsigned long )fcn == (unsigned long )((void *)0)) {
#line 882
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 882
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "could not allocate node%s",
                           (cache->shpool)->log_ctx);
        }
      }
#line 884
      rc = (ngx_int_t )-1;
#line 885
      goto failed;
    }
  }
  {
#line 889
  ((cache->sh)->count) ++;
#line 891
  memcpy((void */* __restrict  */)((u_char *)(& fcn->node.key)), (void const   */* __restrict  */)(c->key),
         sizeof(ngx_rbtree_key_t ));
#line 893
  memcpy((void */* __restrict  */)(fcn->key), (void const   */* __restrict  */)(& c->key[sizeof(ngx_rbtree_key_t )]),
         16UL - sizeof(ngx_rbtree_key_t ));
#line 896
  ngx_rbtree_insert(& (cache->sh)->rbtree, & fcn->node);
#line 898
  fcn->uses = 1U;
#line 899
  fcn->count = 1U;
  }
  renew: 
#line 903
  rc = (ngx_int_t )-5;
#line 905
  fcn->valid_msec = 0U;
#line 906
  fcn->error = 0U;
#line 907
  fcn->exists = 0U;
#line 908
  fcn->valid_sec = (time_t )0;
#line 909
  fcn->uniq = (ngx_file_uniq_t )0;
#line 910
  fcn->body_start = (size_t___0 )0;
#line 911
  fcn->fs_size = (off_t )0;
  done: 
#line 915
  fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 917
  fcn->queue.next = (cache->sh)->queue.next;
#line 917
  (fcn->queue.next)->prev = & fcn->queue;
#line 917
  fcn->queue.prev = & (cache->sh)->queue;
#line 917
  (cache->sh)->queue.next = & fcn->queue;
#line 919
  c->uniq = fcn->uniq;
#line 920
  c->error = (ngx_uint_t )fcn->error;
#line 921
  c->node = fcn;
  failed: 
  {
#line 925
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 927
  return (rc);
}
}
#line 931 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_name(ngx_http_request_t *r , ngx_path_t *path ) 
{ 
  u_char *p ;
  ngx_http_cache_t *c ;
  void *tmp ;

  {
#line 937
  c = r->cache;
#line 939
  if (c->file.name.len) {
#line 940
    return ((ngx_int_t )0);
  }
  {
#line 943
  c->file.name.len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 946
  tmp = ngx_pnalloc(r->pool, c->file.name.len + 1UL);
#line 946
  c->file.name.data = (u_char *)tmp;
  }
#line 947
  if ((unsigned long )c->file.name.data == (unsigned long )((void *)0)) {
#line 948
    return ((ngx_int_t )-1);
  }
  {
#line 951
  memcpy((void */* __restrict  */)c->file.name.data, (void const   */* __restrict  */)path->name.data,
         path->name.len);
#line 953
  p = ((c->file.name.data + path->name.len) + 1) + path->len;
#line 954
  p = ngx_hex_dump(p, c->key, (size_t___0 )16);
#line 955
  *p = (u_char )'\000';
#line 957
  ngx_create_hashed_filename(path, c->file.name.data, c->file.name.len);
  }
#line 962
  return ((ngx_int_t )0);
}
}
#line 966 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_http_file_cache_node_t *ngx_http_file_cache_lookup(ngx_http_file_cache_t *cache ,
                                                              u_char *key ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_key_t node_key ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_file_cache_node_t *fcn ;
  int tmp ;

  {
  {
#line 974
  memcpy((void */* __restrict  */)((u_char *)(& node_key)), (void const   */* __restrict  */)key,
         sizeof(ngx_rbtree_key_t ));
#line 976
  node = (cache->sh)->rbtree.root;
#line 977
  sentinel = (cache->sh)->rbtree.sentinel;
  }
  {
#line 979
  while (1) {
    while_continue: /* CIL Label */ ;
#line 979
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 979
      goto while_break;
    }
#line 981
    if (node_key < node->key) {
#line 982
      node = node->left;
#line 983
      goto while_continue;
    }
#line 986
    if (node_key > node->key) {
#line 987
      node = node->right;
#line 988
      goto while_continue;
    }
    {
#line 993
    fcn = (ngx_http_file_cache_node_t *)node;
#line 995
    tmp = memcmp((void const   *)((char const   *)(key + sizeof(ngx_rbtree_key_t ))),
                 (void const   *)((char const   *)(fcn->key)), 16UL - sizeof(ngx_rbtree_key_t ));
#line 995
    rc = (ngx_int_t )tmp;
    }
#line 998
    if (rc == 0L) {
#line 999
      return (fcn);
    }
#line 1002
    if (rc < 0L) {
#line 1002
      node = node->left;
    } else {
#line 1002
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1007
  return ((ngx_http_file_cache_node_t *)((void *)0));
}
}
#line 1011 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_http_file_cache_node_t *cn ;
  ngx_http_file_cache_node_t *cnt ;
  int tmp___0 ;

  {
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1020
    if (node->key < temp->key) {
#line 1022
      p = & temp->left;
    } else
#line 1024
    if (node->key > temp->key) {
#line 1026
      p = & temp->right;
    } else {
      {
#line 1030
      cn = (ngx_http_file_cache_node_t *)node;
#line 1031
      cnt = (ngx_http_file_cache_node_t *)temp;
#line 1033
      tmp___0 = memcmp((void const   *)((char const   *)(cn->key)), (void const   *)((char const   *)(cnt->key)),
                       16UL - sizeof(ngx_rbtree_key_t ));
      }
#line 1033
      if (tmp___0 < 0) {
#line 1033
        p = & temp->left;
      } else {
#line 1033
        p = & temp->right;
      }
    }
#line 1039
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 1040
      goto while_break;
    }
#line 1043
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 1046
  *p = node;
#line 1047
  node->parent = temp;
#line 1048
  node->left = sentinel;
#line 1049
  node->right = sentinel;
#line 1050
  node->color = (u_char )1;
#line 1051
  return;
}
}
#line 1054 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_vary(ngx_http_request_t *r , u_char *vary , size_t___0 len ,
                                     u_char *hash ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_str_t name ;
  ngx_md5_t md5 ;
  u_char buf[128] ;

  {
  {
#line 1066
  ngx_md5_init(& md5);
#line 1067
  ngx_md5_update(& md5, (void const   *)((r->cache)->main), (size_t___0 )16);
#line 1069
  ngx_strlow(buf, vary, len);
#line 1071
  p = buf;
#line 1072
  last = buf + len;
  }
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1074
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 1074
      goto while_break;
    }
    {
#line 1076
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1076
      if ((unsigned long )p < (unsigned long )last) {
#line 1076
        if (! ((int )*p == 32)) {
#line 1076
          if (! ((int )*p == 44)) {
#line 1076
            goto while_break___0;
          }
        }
      } else {
#line 1076
        goto while_break___0;
      }
#line 1076
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1078
    name.data = p;
    {
#line 1080
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1080
      if ((unsigned long )p < (unsigned long )last) {
#line 1080
        if ((int )*p != 44) {
#line 1080
          if (! ((int )*p != 32)) {
#line 1080
            goto while_break___1;
          }
        } else {
#line 1080
          goto while_break___1;
        }
      } else {
#line 1080
        goto while_break___1;
      }
#line 1080
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1082
    name.len = (size_t___0 )(p - name.data);
#line 1084
    if (name.len == 0UL) {
#line 1085
      goto while_break;
    }
    {
#line 1091
    ngx_md5_update(& md5, (void const   *)name.data, name.len);
#line 1092
    ngx_md5_update(& md5, (void const   *)((u_char *)":"), sizeof(":") - 1UL);
#line 1094
    ngx_http_file_cache_vary_header(r, & md5, & name);
#line 1096
    ngx_md5_update(& md5, (void const   *)((u_char *)"\r\n"), sizeof("\r\n") - 1UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1099
  ngx_md5_final((u_char *)hash, & md5);
  }
#line 1100
  return;
}
}
#line 1103 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_vary_header(ngx_http_request_t *r , ngx_md5_t *md5 ,
                                            ngx_str_t *name ) 
{ 
  size_t___0 len ;
  u_char *p ;
  u_char *start ;
  u_char *last ;
  ngx_uint_t i ;
  ngx_uint_t multiple ;
  ngx_uint_t normalize ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1113
  multiple = (ngx_uint_t )0;
#line 1114
  normalize = (ngx_uint_t )0;
#line 1116
  if (name->len == sizeof("Accept-Charset") - 1UL) {
    {
#line 1116
    tmp___1 = ngx_strncasecmp(name->data, (u_char *)"Accept-Charset", sizeof("Accept-Charset") - 1UL);
    }
#line 1116
    if (tmp___1 == 0L) {
#line 1120
      normalize = (ngx_uint_t )1;
    } else {
#line 1116
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1122
  if (name->len == sizeof("Accept-Encoding") - 1UL) {
    {
#line 1122
    tmp___0 = ngx_strncasecmp(name->data, (u_char *)"Accept-Encoding", sizeof("Accept-Encoding") - 1UL);
    }
#line 1122
    if (tmp___0 == 0L) {
#line 1126
      normalize = (ngx_uint_t )1;
    } else {
#line 1122
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1128
  if (name->len == sizeof("Accept-Language") - 1UL) {
    {
#line 1128
    tmp = ngx_strncasecmp(name->data, (u_char *)"Accept-Language", sizeof("Accept-Language") - 1UL);
    }
#line 1128
    if (tmp == 0L) {
#line 1132
      normalize = (ngx_uint_t )1;
    }
  }
#line 1135
  part = & r->headers_in.headers.part;
#line 1136
  header___0 = (ngx_table_elt_t *)part->elts;
#line 1138
  i = (ngx_uint_t )0;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1140
    if (i >= part->nelts) {
#line 1141
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1142
        goto while_break;
      }
#line 1145
      part = part->next;
#line 1146
      header___0 = (ngx_table_elt_t *)part->elts;
#line 1147
      i = (ngx_uint_t )0;
    }
#line 1150
    if ((header___0 + i)->hash == 0UL) {
#line 1151
      goto __Cont;
    }
#line 1154
    if ((header___0 + i)->key.len != name->len) {
#line 1155
      goto __Cont;
    }
    {
#line 1158
    tmp___2 = ngx_strncasecmp((header___0 + i)->key.data, name->data, name->len);
    }
#line 1158
    if (tmp___2 != 0L) {
#line 1159
      goto __Cont;
    }
#line 1162
    if (! normalize) {
#line 1164
      if (multiple) {
        {
#line 1165
        ngx_md5_update(md5, (void const   *)((u_char *)","), sizeof(",") - 1UL);
        }
      }
      {
#line 1168
      ngx_md5_update(md5, (void const   *)(header___0 + i)->value.data, (header___0 + i)->value.len);
#line 1170
      multiple = (ngx_uint_t )1;
      }
#line 1172
      goto __Cont;
    }
#line 1177
    p = (header___0 + i)->value.data;
#line 1178
    last = p + (header___0 + i)->value.len;
    {
#line 1180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1180
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 1180
        goto while_break___0;
      }
      {
#line 1182
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1182
        if ((unsigned long )p < (unsigned long )last) {
#line 1182
          if (! ((int )*p == 32)) {
#line 1182
            if (! ((int )*p == 44)) {
#line 1182
              goto while_break___1;
            }
          }
        } else {
#line 1182
          goto while_break___1;
        }
#line 1182
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1184
      start = p;
      {
#line 1186
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1186
        if ((unsigned long )p < (unsigned long )last) {
#line 1186
          if ((int )*p != 44) {
#line 1186
            if (! ((int )*p != 32)) {
#line 1186
              goto while_break___2;
            }
          } else {
#line 1186
            goto while_break___2;
          }
        } else {
#line 1186
          goto while_break___2;
        }
#line 1186
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1188
      len = (size_t___0 )(p - start);
#line 1190
      if (len == 0UL) {
#line 1191
        goto while_break___0;
      }
#line 1194
      if (multiple) {
        {
#line 1195
        ngx_md5_update(md5, (void const   *)((u_char *)","), sizeof(",") - 1UL);
        }
      }
      {
#line 1198
      ngx_md5_update(md5, (void const   *)start, len);
#line 1200
      multiple = (ngx_uint_t )1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1203
  return;
}
}
#line 1206 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_reopen(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;

  {
#line 1214
  if (c->secondary) {
#line 1215
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1215
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has incorrect vary hash",
                         c->file.name.data);
      }
    }
#line 1218
    return ((ngx_int_t )-5);
  }
  {
#line 1221
  cache = c->file_cache;
#line 1223
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1225
  ((c->node)->count) --;
#line 1226
  c->node = (ngx_http_file_cache_node_t *)((void *)0);
#line 1228
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1230
  c->secondary = 1U;
#line 1231
  c->file.name.len = (size_t___0 )0;
#line 1232
  c->body_start = (size_t___0 )((c->buf)->end - (c->buf)->start);
#line 1234
  memcpy((void */* __restrict  */)(c->key), (void const   */* __restrict  */)(c->variant),
         (size_t )16);
#line 1236
  tmp = ngx_http_file_cache_open(r);
  }
#line 1236
  return (tmp);
}
}
#line 1240 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_set_header(ngx_http_request_t *r , u_char *buf ) 
{ 
  ngx_http_file_cache_header_t *h ;
  u_char *p ;
  ngx_str_t *key ;
  ngx_uint_t i ;
  ngx_http_cache_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1243
  h = (ngx_http_file_cache_header_t *)buf;
#line 1253
  c = r->cache;
#line 1255
  memset((void *)h, 0, sizeof(ngx_http_file_cache_header_t ));
#line 1257
  h->version = (ngx_uint_t )5;
#line 1258
  h->valid_sec = c->valid_sec;
#line 1259
  h->updating_sec = c->updating_sec;
#line 1260
  h->error_sec = c->error_sec;
#line 1261
  h->last_modified = c->last_modified;
#line 1262
  h->date = c->date;
#line 1263
  h->crc32 = c->crc32;
#line 1264
  h->valid_msec = (u_short )c->valid_msec;
#line 1265
  h->header_start = (u_short )c->header_start;
#line 1266
  h->body_start = (u_short )c->body_start;
  }
#line 1268
  if (c->etag.len <= 128UL) {
    {
#line 1269
    h->etag_len = (u_char )c->etag.len;
#line 1270
    memcpy((void */* __restrict  */)(h->etag), (void const   */* __restrict  */)c->etag.data,
           c->etag.len);
    }
  }
#line 1273
  if (c->vary.len) {
#line 1274
    if (c->vary.len > 128UL) {
#line 1276
      c->vary.len = (size_t___0 )128;
    }
    {
#line 1279
    h->vary_len = (u_char )c->vary.len;
#line 1280
    memcpy((void */* __restrict  */)(h->vary), (void const   */* __restrict  */)c->vary.data,
           c->vary.len);
#line 1282
    ngx_http_file_cache_vary(r, c->vary.data, c->vary.len, c->variant);
#line 1283
    memcpy((void */* __restrict  */)(h->variant), (void const   */* __restrict  */)(c->variant),
           (size_t )16);
    }
  }
  {
#line 1286
  tmp = ngx_http_file_cache_update_variant(r, c);
  }
#line 1286
  if (tmp != 0L) {
#line 1287
    return ((ngx_int_t )-1);
  }
  {
#line 1290
  p = buf + sizeof(ngx_http_file_cache_header_t );
#line 1292
  tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ngx_http_file_cache_key),
                   sizeof(ngx_http_file_cache_key));
#line 1292
  p = (u_char *)tmp___0 + sizeof(ngx_http_file_cache_key);
#line 1294
  key = (ngx_str_t *)c->keys.elts;
#line 1295
  i = (ngx_uint_t )0;
  }
  {
#line 1295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1295
    if (! (i < c->keys.nelts)) {
#line 1295
      goto while_break;
    }
    {
#line 1296
    tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(key + i)->data,
                     (key + i)->len);
#line 1296
    p = (u_char *)tmp___1 + (key + i)->len;
#line 1295
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1299
  *p = (u_char )'\n';
#line 1301
  return ((ngx_int_t )0);
}
}
#line 1305 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_update_variant(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_http_file_cache_t *cache ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1310
  if (! c->secondary) {
#line 1311
    return ((ngx_int_t )0);
  }
#line 1314
  if (c->vary.len) {
    {
#line 1314
    tmp = memcmp((void const   *)((char const   *)(c->variant)), (void const   *)((char const   *)(c->key)),
                 (size_t )16);
    }
#line 1314
    if (tmp == 0) {
#line 1317
      return ((ngx_int_t )0);
    }
  }
  {
#line 1325
  cache = c->file_cache;
#line 1330
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1332
  ((c->node)->count) --;
#line 1333
  (c->node)->updating = 0U;
#line 1334
  c->node = (ngx_http_file_cache_node_t *)((void *)0);
#line 1336
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1338
  c->file.name.len = (size_t___0 )0;
#line 1340
  memcpy((void */* __restrict  */)(c->key), (void const   */* __restrict  */)(c->main),
         (size_t )16);
#line 1342
  tmp___0 = ngx_http_file_cache_exists(cache, c);
  }
#line 1342
  if (tmp___0 == -1L) {
#line 1343
    return ((ngx_int_t )-1);
  }
  {
#line 1346
  tmp___1 = ngx_http_file_cache_name(r, cache->path);
  }
#line 1346
  if (tmp___1 != 0L) {
#line 1347
    return ((ngx_int_t )-1);
  }
#line 1350
  return ((ngx_int_t )0);
}
}
#line 1354 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_update(ngx_http_request_t *r , ngx_temp_file_t *tf ) 
{ 
  off_t fs_size ;
  ngx_int_t rc ;
  ngx_file_uniq_t uniq ;
  ngx_file_info_t fi ;
  ngx_http_cache_t *c ;
  ngx_ext_rename_file_t ext ;
  ngx_http_file_cache_t *cache ;
  int *tmp ;
  __blkcnt_t tmp___0 ;
  int tmp___1 ;

  {
#line 1365
  c = r->cache;
#line 1367
  if (c->updated) {
#line 1368
    return;
  }
  {
#line 1374
  cache = c->file_cache;
#line 1376
  c->updated = 1U;
#line 1377
  c->updating = 0U;
#line 1379
  uniq = (ngx_file_uniq_t )0;
#line 1380
  fs_size = (off_t )0;
#line 1386
  ext.access = (ngx_uint_t )384;
#line 1387
  ext.path_access = (ngx_uint_t )384;
#line 1388
  ext.time = (time_t )-1;
#line 1389
  ext.create_path = 1U;
#line 1390
  ext.delete_file = 1U;
#line 1391
  ext.log = (r->connection)->log;
#line 1393
  rc = ngx_ext_rename_file(& tf->file.name, & c->file.name, & ext);
  }
#line 1395
  if (rc == 0L) {
    {
#line 1397
    tmp___1 = fstat(tf->file.fd, & fi);
    }
#line 1397
    if (tmp___1 == -1) {
#line 1398
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 1398
        tmp = __errno_location();
#line 1398
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp, "fstat() \"%s\" failed",
                           tf->file.name.data);
        }
      }
#line 1401
      rc = (ngx_int_t )-1;
    } else {
#line 1404
      uniq = fi.st_ino;
#line 1405
      if (fi.st_size < fi.st_blocks * 512L) {
#line 1405
        tmp___0 = fi.st_blocks * 512L;
      } else {
#line 1405
        tmp___0 = fi.st_size;
      }
#line 1405
      fs_size = (off_t )((((size_t___0 )tmp___0 + cache->bsize) - 1UL) / cache->bsize);
    }
  }
  {
#line 1409
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1411
  ((c->node)->count) --;
#line 1412
  (c->node)->error = 0U;
#line 1413
  (c->node)->uniq = uniq;
#line 1414
  (c->node)->body_start = c->body_start;
#line 1416
  (cache->sh)->size += fs_size - (c->node)->fs_size;
#line 1417
  (c->node)->fs_size = fs_size;
  }
#line 1419
  if (rc == 0L) {
#line 1420
    (c->node)->exists = 1U;
  }
  {
#line 1423
  (c->node)->updating = 0U;
#line 1425
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 1426
  return;
}
}
#line 1429 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_update_header(ngx_http_request_t *r ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_file_t file ;
  ngx_file_info_t fi ;
  ngx_http_cache_t *c ;
  ngx_http_file_cache_header_t h ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1442
  c = r->cache;
#line 1444
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 1446
  file.name = c->file.name;
#line 1447
  file.log = (r->connection)->log;
#line 1448
  file.fd = open((char const   *)file.name.data, 2, 0);
  }
#line 1450
  if (file.fd == -1) {
    {
#line 1451
    tmp = __errno_location();
#line 1451
    err = *tmp;
    }
#line 1455
    if (err == 2) {
#line 1459
      return;
    }
#line 1462
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1462
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, err, "open() \"%s\" failed",
                         file.name.data);
      }
    }
#line 1464
    return;
  }
  {
#line 1472
  tmp___1 = fstat(file.fd, & fi);
  }
#line 1472
  if (tmp___1 == -1) {
#line 1473
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1473
      tmp___0 = __errno_location();
#line 1473
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___0, "fstat() \"%s\" failed",
                         file.name.data);
      }
    }
#line 1475
    goto done;
  }
#line 1478
  if (c->uniq != fi.st_ino) {
#line 1484
    goto done;
  } else
#line 1478
  if (c->length != fi.st_size) {
#line 1484
    goto done;
  }
  {
#line 1487
  n = ngx_read_file(& file, (u_char *)(& h), sizeof(ngx_http_file_cache_header_t ),
                    (off_t )0);
  }
#line 1490
  if (n == -1L) {
#line 1491
    goto done;
  }
#line 1494
  if ((size_t___0 )n != sizeof(ngx_http_file_cache_header_t )) {
#line 1495
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1495
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "pread() read only %z of %z from \"%s\"",
                         n, sizeof(ngx_http_file_cache_header_t ), file.name.data);
      }
    }
#line 1498
    goto done;
  }
#line 1501
  if (h.version != 5UL) {
#line 1510
    goto done;
  } else
#line 1501
  if (h.last_modified != c->last_modified) {
#line 1510
    goto done;
  } else
#line 1501
  if (h.crc32 != c->crc32) {
#line 1510
    goto done;
  } else
#line 1501
  if ((size_t___0 )h.header_start != c->header_start) {
#line 1510
    goto done;
  } else
#line 1501
  if ((size_t___0 )h.body_start != c->body_start) {
#line 1510
    goto done;
  }
  {
#line 1518
  memset((void *)(& h), 0, sizeof(ngx_http_file_cache_header_t ));
#line 1520
  h.version = (ngx_uint_t )5;
#line 1521
  h.valid_sec = c->valid_sec;
#line 1522
  h.updating_sec = c->updating_sec;
#line 1523
  h.error_sec = c->error_sec;
#line 1524
  h.last_modified = c->last_modified;
#line 1525
  h.date = c->date;
#line 1526
  h.crc32 = c->crc32;
#line 1527
  h.valid_msec = (u_short )c->valid_msec;
#line 1528
  h.header_start = (u_short )c->header_start;
#line 1529
  h.body_start = (u_short )c->body_start;
  }
#line 1531
  if (c->etag.len <= 128UL) {
    {
#line 1532
    h.etag_len = (u_char )c->etag.len;
#line 1533
    memcpy((void */* __restrict  */)(h.etag), (void const   */* __restrict  */)c->etag.data,
           c->etag.len);
    }
  }
#line 1536
  if (c->vary.len) {
#line 1537
    if (c->vary.len > 128UL) {
#line 1539
      c->vary.len = (size_t___0 )128;
    }
    {
#line 1542
    h.vary_len = (u_char )c->vary.len;
#line 1543
    memcpy((void */* __restrict  */)(h.vary), (void const   */* __restrict  */)c->vary.data,
           c->vary.len);
#line 1545
    ngx_http_file_cache_vary(r, c->vary.data, c->vary.len, c->variant);
#line 1546
    memcpy((void */* __restrict  */)(h.variant), (void const   */* __restrict  */)(c->variant),
           (size_t )16);
    }
  }
  {
#line 1549
  ngx_write_file(& file, (u_char *)(& h), sizeof(ngx_http_file_cache_header_t ), (off_t )0);
  }
  done: 
  {
#line 1554
  tmp___3 = close(file.fd);
  }
#line 1554
  if (tmp___3 == -1) {
#line 1555
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 1555
      tmp___2 = __errno_location();
#line 1555
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp___2, "close() \"%s\" failed",
                         file.name.data);
      }
    }
  }
#line 1558
  return;
}
}
#line 1561 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_cache_send(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_http_cache_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1569
  c = r->cache;
#line 1574
  if ((unsigned long )r != (unsigned long )r->main) {
#line 1574
    if ((size_t___0 )c->length - c->body_start == 0UL) {
      {
#line 1575
      tmp = ngx_http_send_header(r);
      }
#line 1575
      return (tmp);
    }
  }
  {
#line 1580
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 1580
  b = (ngx_buf_t *)tmp___0;
  }
#line 1581
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1582
    return ((ngx_int_t )500);
  }
  {
#line 1585
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_file_t ));
#line 1585
  b->file = (ngx_file_t *)tmp___1;
  }
#line 1586
  if ((unsigned long )b->file == (unsigned long )((void *)0)) {
#line 1587
    return ((ngx_int_t )500);
  }
  {
#line 1590
  rc = ngx_http_send_header(r);
  }
#line 1592
  if (rc == -1L) {
#line 1593
    return (rc);
  } else
#line 1592
  if (rc > 0L) {
#line 1593
    return (rc);
  } else
#line 1592
  if (r->header_only) {
#line 1593
    return (rc);
  }
#line 1596
  b->file_pos = (off_t )c->body_start;
#line 1597
  b->file_last = c->length;
#line 1599
  if ((size_t___0 )c->length - c->body_start) {
#line 1599
    b->in_file = 1U;
  } else {
#line 1599
    b->in_file = 0U;
  }
#line 1600
  if ((unsigned long )r == (unsigned long )r->main) {
#line 1600
    b->last_buf = 1U;
  } else {
#line 1600
    b->last_buf = 0U;
  }
  {
#line 1601
  b->last_in_chain = 1U;
#line 1603
  (b->file)->fd = c->file.fd;
#line 1604
  (b->file)->name = c->file.name;
#line 1605
  (b->file)->log = (r->connection)->log;
#line 1607
  out.buf = b;
#line 1608
  out.next = (ngx_chain_t *)((void *)0);
#line 1610
  tmp___2 = ngx_http_output_filter(r, & out);
  }
#line 1610
  return (tmp___2);
}
}
#line 1614 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_free(ngx_http_cache_t *c , ngx_temp_file_t *tf ) 
{ 
  ngx_http_file_cache_t *cache ;
  ngx_http_file_cache_node_t *fcn ;
  int *tmp ;
  int tmp___0 ;

  {
#line 1620
  if (c->updated) {
#line 1621
    return;
  } else
#line 1620
  if ((unsigned long )c->node == (unsigned long )((void *)0)) {
#line 1621
    return;
  }
  {
#line 1624
  cache = c->file_cache;
#line 1629
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1631
  fcn = c->node;
#line 1632
  (fcn->count) --;
  }
#line 1634
  if (c->updating) {
#line 1634
    if (fcn->lock_time == c->lock_time) {
#line 1635
      fcn->updating = 0U;
    }
  }
#line 1638
  if (c->error) {
#line 1639
    fcn->error = (unsigned int )c->error;
#line 1641
    if (c->valid_sec) {
#line 1642
      fcn->valid_sec = c->valid_sec;
#line 1643
      fcn->valid_msec = (unsigned int )c->valid_msec;
    }
  } else
#line 1646
  if (! fcn->exists) {
#line 1646
    if (fcn->count == 0U) {
#line 1646
      if (c->min_uses == 1UL) {
        {
#line 1647
        (fcn->queue.next)->prev = fcn->queue.prev;
#line 1647
        (fcn->queue.prev)->next = fcn->queue.next;
#line 1648
        ngx_rbtree_delete(& (cache->sh)->rbtree, & fcn->node);
#line 1649
        ngx_slab_free_locked(cache->shpool, (void *)fcn);
#line 1650
        ((cache->sh)->count) --;
#line 1651
        c->node = (ngx_http_file_cache_node_t *)((void *)0);
        }
      }
    }
  }
  {
#line 1654
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1656
  c->updated = 1U;
#line 1657
  c->updating = 0U;
  }
#line 1659
  if (c->temp_file) {
#line 1660
    if (tf) {
#line 1660
      if (tf->file.fd != -1) {
        {
#line 1665
        tmp___0 = unlink((char const   *)tf->file.name.data);
        }
#line 1665
        if (tmp___0 == -1) {
#line 1666
          if ((c->file.log)->log_level >= 3UL) {
            {
#line 1666
            tmp = __errno_location();
#line 1666
            ngx_log_error_core((ngx_uint_t )3, c->file.log, *tmp, "unlink() \"%s\" failed",
                               tf->file.name.data);
            }
          }
        }
      }
    }
  }
#line 1673
  if (c->wait_event.timer_set) {
    {
#line 1674
    ngx_event_del_timer(& c->wait_event);
    }
  }
#line 1676
  return;
}
}
#line 1679 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_cleanup(void *data ) 
{ 
  ngx_http_cache_t *c ;

  {
#line 1682
  c = (ngx_http_cache_t *)data;
#line 1684
  if (c->updated) {
#line 1685
    return;
  }
#line 1691
  if (c->updating) {
#line 1691
    if (! c->background) {
#line 1692
      if ((c->file.log)->log_level >= 2UL) {
        {
#line 1692
        ngx_log_error_core((ngx_uint_t )2, c->file.log, 0, "stalled cache updating, error:%ui",
                           c->error);
        }
      }
    }
  }
  {
#line 1696
  ngx_http_file_cache_free(c, (ngx_temp_file_t *)((void *)0));
  }
#line 1697
  return;
}
}
#line 1700 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static time_t ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache ) 
{ 
  u_char *name ;
  u_char *p ;
  size_t___0 len ;
  time_t wait___0 ;
  ngx_uint_t tries ;
  ngx_path_t *path ;
  ngx_queue_t *q ;
  ngx_queue_t *sentinel ;
  ngx_http_file_cache_node_t *fcn ;
  u_char key[32] ;
  void *tmp ;

  {
  {
#line 1715
  path = cache->path;
#line 1716
  len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 1718
  tmp = ngx_alloc(len + 1UL, (ngx_log_t *)ngx_cycle->log);
#line 1718
  name = (u_char *)tmp;
  }
#line 1719
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1720
    return ((time_t )10);
  }
  {
#line 1723
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)path->name.data,
         path->name.len);
#line 1725
  wait___0 = (time_t )10;
#line 1726
  tries = (ngx_uint_t )20;
#line 1727
  sentinel = (ngx_queue_t *)((void *)0);
#line 1729
  ngx_shmtx_lock(& (cache->shpool)->mutex);
  }
  {
#line 1731
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1732
    if ((unsigned long )(& (cache->sh)->queue) == (unsigned long )(cache->sh)->queue.prev) {
#line 1733
      goto while_break;
    }
#line 1736
    q = (cache->sh)->queue.prev;
#line 1738
    if ((unsigned long )q == (unsigned long )sentinel) {
#line 1739
      goto while_break;
    }
#line 1742
    fcn = (ngx_http_file_cache_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_file_cache_node_t *)0)->queue));
#line 1749
    if (fcn->count == 0U) {
      {
#line 1750
      ngx_http_file_cache_delete(cache, q, name);
#line 1751
      wait___0 = (time_t )0;
      }
#line 1752
      goto while_break;
    }
    {
#line 1755
    p = ngx_hex_dump(key, (u_char *)(& fcn->node.key), sizeof(ngx_rbtree_key_t ));
#line 1757
    len = 16UL - sizeof(ngx_rbtree_key_t );
#line 1758
    ngx_hex_dump(p, fcn->key, len);
#line 1766
    (q->next)->prev = q->prev;
#line 1766
    (q->prev)->next = q->next;
#line 1767
    fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 1768
    fcn->queue.next = (cache->sh)->queue.next;
#line 1768
    (fcn->queue.next)->prev = & fcn->queue;
#line 1768
    fcn->queue.prev = & (cache->sh)->queue;
#line 1768
    (cache->sh)->queue.next = & fcn->queue;
    }
#line 1770
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 1770
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "ignore long locked inactive cache entry %*s, count:%d",
                         32UL, key, fcn->count);
      }
    }
#line 1774
    if ((unsigned long )sentinel == (unsigned long )((void *)0)) {
#line 1775
      sentinel = q;
    }
#line 1778
    tries --;
#line 1778
    if (tries) {
#line 1779
      goto __Cont;
    }
#line 1782
    wait___0 = (time_t )1;
#line 1783
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1786
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1788
  free((void *)name);
  }
#line 1790
  return (wait___0);
}
}
#line 1794 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static time_t ngx_http_file_cache_expire(ngx_http_file_cache_t *cache ) 
{ 
  u_char *name ;
  u_char *p ;
  size_t___0 len ;
  time_t now ;
  time_t wait___0 ;
  ngx_path_t *path ;
  ngx_msec_t elapsed ;
  ngx_queue_t *q ;
  ngx_http_file_cache_node_t *fcn ;
  u_char key[32] ;
  void *tmp ;

  {
  {
#line 1809
  path = cache->path;
#line 1810
  len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 1812
  tmp = ngx_alloc(len + 1UL, (ngx_log_t *)ngx_cycle->log);
#line 1812
  name = (u_char *)tmp;
  }
#line 1813
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1814
    return ((time_t )10);
  }
  {
#line 1817
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)path->name.data,
         path->name.len);
#line 1819
  now = (time_t )ngx_cached_time->sec;
#line 1821
  ngx_shmtx_lock(& (cache->shpool)->mutex);
  }
  {
#line 1823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1825
    if (ngx_quit) {
#line 1826
      wait___0 = (time_t )1;
#line 1827
      goto while_break;
    } else
#line 1825
    if (ngx_terminate) {
#line 1826
      wait___0 = (time_t )1;
#line 1827
      goto while_break;
    }
#line 1830
    if ((unsigned long )(& (cache->sh)->queue) == (unsigned long )(cache->sh)->queue.prev) {
#line 1831
      wait___0 = (time_t )10;
#line 1832
      goto while_break;
    }
#line 1835
    q = (cache->sh)->queue.prev;
#line 1837
    fcn = (ngx_http_file_cache_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_file_cache_node_t *)0)->queue));
#line 1839
    wait___0 = fcn->expire - now;
#line 1841
    if (wait___0 > 0L) {
#line 1842
      if (wait___0 > 10L) {
#line 1842
        wait___0 = (time_t )10;
      } else {
#line 1842
        wait___0 = wait___0;
      }
#line 1843
      goto while_break;
    }
#line 1851
    if (fcn->count == 0U) {
      {
#line 1852
      ngx_http_file_cache_delete(cache, q, name);
      }
#line 1853
      goto next;
    }
#line 1856
    if (fcn->deleting) {
#line 1857
      wait___0 = (time_t )1;
#line 1858
      goto while_break;
    }
    {
#line 1861
    p = ngx_hex_dump(key, (u_char *)(& fcn->node.key), sizeof(ngx_rbtree_key_t ));
#line 1863
    len = 16UL - sizeof(ngx_rbtree_key_t );
#line 1864
    ngx_hex_dump(p, fcn->key, len);
#line 1872
    (q->next)->prev = q->prev;
#line 1872
    (q->prev)->next = q->next;
#line 1873
    fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 1874
    fcn->queue.next = (cache->sh)->queue.next;
#line 1874
    (fcn->queue.next)->prev = & fcn->queue;
#line 1874
    fcn->queue.prev = & (cache->sh)->queue;
#line 1874
    (cache->sh)->queue.next = & fcn->queue;
    }
#line 1876
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 1876
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "ignore long locked inactive cache entry %*s, count:%d",
                         32UL, key, fcn->count);
      }
    }
    next: 
#line 1882
    (cache->files) ++;
#line 1882
    if (cache->files >= cache->manager_files) {
#line 1883
      wait___0 = (time_t )0;
#line 1884
      goto while_break;
    }
    {
#line 1887
    ngx_time_update();
    }
#line 1889
    if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 1889
      elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
    } else {
#line 1889
      elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
    }
#line 1891
    if (elapsed >= cache->manager_threshold) {
#line 1892
      wait___0 = (time_t )0;
#line 1893
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1897
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1899
  free((void *)name);
  }
#line 1901
  return (wait___0);
}
}
#line 1905 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_delete(ngx_http_file_cache_t *cache , ngx_queue_t *q ,
                                       u_char *name ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_path_t *path ;
  ngx_http_file_cache_node_t *fcn ;
  int *tmp ;
  int tmp___0 ;

  {
#line 1914
  fcn = (ngx_http_file_cache_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_file_cache_node_t *)0)->queue));
#line 1916
  if (fcn->exists) {
    {
#line 1917
    (cache->sh)->size -= fcn->fs_size;
#line 1919
    path = cache->path;
#line 1920
    p = ((name + path->name.len) + 1) + path->len;
#line 1921
    p = ngx_hex_dump(p, (u_char *)(& fcn->node.key), sizeof(ngx_rbtree_key_t ));
#line 1923
    len = 16UL - sizeof(ngx_rbtree_key_t );
#line 1924
    p = ngx_hex_dump(p, fcn->key, len);
#line 1925
    *p = (u_char )'\000';
#line 1927
    (fcn->count) ++;
#line 1928
    fcn->deleting = 1U;
#line 1929
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1931
    len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 1932
    ngx_create_hashed_filename(path, name, len);
#line 1937
    tmp___0 = unlink((char const   *)name);
    }
#line 1937
    if (tmp___0 == -1) {
#line 1938
      if ((ngx_cycle->log)->log_level >= 3UL) {
        {
#line 1938
        tmp = __errno_location();
#line 1938
        ngx_log_error_core((ngx_uint_t )3, (ngx_log_t *)ngx_cycle->log, *tmp, "unlink() \"%s\" failed",
                           name);
        }
      }
    }
    {
#line 1942
    ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1943
    (fcn->count) --;
#line 1944
    fcn->deleting = 0U;
    }
  }
#line 1947
  if (fcn->count == 0U) {
    {
#line 1948
    (q->next)->prev = q->prev;
#line 1948
    (q->prev)->next = q->next;
#line 1949
    ngx_rbtree_delete(& (cache->sh)->rbtree, & fcn->node);
#line 1950
    ngx_slab_free_locked(cache->shpool, (void *)fcn);
#line 1951
    ((cache->sh)->count) --;
    }
  }
#line 1953
  return;
}
}
#line 1956 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_msec_t ngx_http_file_cache_manager(void *data ) 
{ 
  ngx_http_file_cache_t *cache ;
  off_t size ;
  time_t wait___0 ;
  ngx_msec_t elapsed ;
  ngx_msec_t next ;
  ngx_uint_t count ;
  ngx_uint_t watermark ;
  time_t tmp ;

  {
  {
#line 1959
  cache = (ngx_http_file_cache_t *)data;
#line 1966
  cache->last = (ngx_msec_t )ngx_current_msec;
#line 1967
  cache->files = (ngx_uint_t )0;
#line 1969
  tmp = ngx_http_file_cache_expire(cache);
#line 1969
  next = (ngx_msec_t )tmp * 1000UL;
  }
#line 1971
  if (next == 0UL) {
#line 1972
    next = cache->manager_sleep;
#line 1973
    goto done;
  }
  {
#line 1976
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1977
    ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1979
    size = (cache->sh)->size;
#line 1980
    count = (cache->sh)->count;
#line 1981
    watermark = (cache->sh)->watermark;
#line 1983
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
    }
#line 1989
    if (size < cache->max_size) {
#line 1989
      if (count < watermark) {
#line 1990
        goto while_break;
      }
    }
    {
#line 1993
    wait___0 = ngx_http_file_cache_forced_expire(cache);
    }
#line 1995
    if (wait___0 > 0L) {
#line 1996
      next = (ngx_msec_t )wait___0 * 1000UL;
#line 1997
      goto while_break;
    }
#line 2000
    if (ngx_quit) {
#line 2001
      goto while_break;
    } else
#line 2000
    if (ngx_terminate) {
#line 2001
      goto while_break;
    }
#line 2004
    (cache->files) ++;
#line 2004
    if (cache->files >= cache->manager_files) {
#line 2005
      next = cache->manager_sleep;
#line 2006
      goto while_break;
    }
    {
#line 2009
    ngx_time_update();
    }
#line 2011
    if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 2011
      elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
    } else {
#line 2011
      elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
    }
#line 2013
    if (elapsed >= cache->manager_threshold) {
#line 2014
      next = cache->manager_sleep;
#line 2015
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 2021
  if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 2021
    elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
  } else {
#line 2021
    elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
  }
#line 2027
  return (next);
}
}
#line 2031 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_loader(void *data ) 
{ 
  ngx_http_file_cache_t *cache ;
  ngx_tree_ctx_t tree ;
  _Bool tmp ;
  ngx_int_t tmp___0 ;

  {
#line 2034
  cache = (ngx_http_file_cache_t *)data;
#line 2038
  if (! (cache->sh)->cold) {
#line 2039
    return;
  } else
#line 2038
  if ((cache->sh)->loading) {
#line 2039
    return;
  }
  {
#line 2042
  tmp = __sync_bool_compare_and_swap(& (cache->sh)->loading, 0, ngx_pid);
  }
#line 2042
  if (! tmp) {
#line 2043
    return;
  }
  {
#line 2049
  tree.init_handler = (ngx_int_t (*)(void *ctx , void *prev ))((void *)0);
#line 2050
  tree.file_handler = & ngx_http_file_cache_manage_file;
#line 2051
  tree.pre_tree_handler = & ngx_http_file_cache_manage_directory;
#line 2052
  tree.post_tree_handler = & ngx_http_file_cache_noop;
#line 2053
  tree.spec_handler = & ngx_http_file_cache_delete_file;
#line 2054
  tree.data = (void *)cache;
#line 2055
  tree.alloc = (size_t___0 )0;
#line 2056
  tree.log = (ngx_log_t *)ngx_cycle->log;
#line 2058
  cache->last = (ngx_msec_t )ngx_current_msec;
#line 2059
  cache->files = (ngx_uint_t )0;
#line 2061
  tmp___0 = ngx_walk_tree(& tree, & (cache->path)->name);
  }
#line 2061
  if (tmp___0 == -6L) {
#line 2062
    (cache->sh)->loading = (ngx_atomic_t )0;
#line 2063
    return;
  }
#line 2066
  (cache->sh)->cold = (ngx_atomic_t )0;
#line 2067
  (cache->sh)->loading = (ngx_atomic_t )0;
#line 2069
  if ((ngx_cycle->log)->log_level >= 6UL) {
    {
#line 2069
    ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "http file cache: %V %.3fM, bsize: %uz",
                       & (cache->path)->name, ((double )(cache->sh)->size * (double )cache->bsize) / (double )1048576,
                       cache->bsize);
    }
  }
#line 2074
  return;
}
}
#line 2077 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_noop(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 


  {
#line 2080
  return ((ngx_int_t )0);
}
}
#line 2084 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_manage_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 
  ngx_msec_t elapsed ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  int tmp___0 ;

  {
  {
#line 2090
  cache = (ngx_http_file_cache_t *)ctx->data;
#line 2092
  tmp = ngx_http_file_cache_add_file(ctx, path);
  }
#line 2092
  if (tmp != 0L) {
    {
#line 2093
    ngx_http_file_cache_delete_file(ctx, path);
    }
  }
#line 2096
  (cache->files) ++;
#line 2096
  if (cache->files >= cache->loader_files) {
    {
#line 2097
    ngx_http_file_cache_loader_sleep(cache);
    }
  } else {
    {
#line 2100
    ngx_time_update();
    }
#line 2102
    if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 2102
      elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
    } else {
#line 2102
      elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
    }
#line 2107
    if (elapsed >= cache->loader_threshold) {
      {
#line 2108
      ngx_http_file_cache_loader_sleep(cache);
      }
    }
  }
#line 2112
  if (ngx_quit) {
#line 2112
    tmp___0 = -6;
  } else
#line 2112
  if (ngx_terminate) {
#line 2112
    tmp___0 = -6;
  } else {
#line 2112
    tmp___0 = 0;
  }
#line 2112
  return ((ngx_int_t )tmp___0);
}
}
#line 2116 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_manage_directory(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 
  int tmp ;

  {
#line 2119
  if (path->len >= 5UL) {
    {
#line 2119
    tmp = strncmp(((char const   *)path->data + path->len) - 5, "/temp", (size_t )5);
    }
#line 2119
    if (tmp == 0) {
#line 2122
      return ((ngx_int_t )-5);
    }
  }
#line 2125
  return ((ngx_int_t )0);
}
}
#line 2129 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_loader_sleep(ngx_http_file_cache_t *cache ) 
{ 


  {
  {
#line 2132
  usleep((__useconds_t )(cache->loader_sleep * 1000UL));
#line 2134
  ngx_time_update();
#line 2136
  cache->last = (ngx_msec_t )ngx_current_msec;
#line 2137
  cache->files = (ngx_uint_t )0;
  }
#line 2138
  return;
}
}
#line 2141 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_add_file(ngx_tree_ctx_t *ctx , ngx_str_t *name ) 
{ 
  u_char *p ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_http_cache_t c ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;

  {
#line 2150
  if (name->len < 32UL) {
#line 2151
    return ((ngx_int_t )-1);
  }
#line 2159
  if (name->len >= 43UL) {
#line 2159
    if ((int )*(name->data + ((name->len - 10UL) - 1UL)) == 46) {
#line 2162
      return ((ngx_int_t )0);
    }
  }
#line 2165
  if (ctx->size < (off_t )sizeof(ngx_http_file_cache_header_t )) {
#line 2166
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 2166
      ngx_log_error_core((ngx_uint_t )3, ctx->log, 0, "cache file \"%s\" is too small",
                         name->data);
      }
    }
#line 2168
    return ((ngx_int_t )-1);
  }
  {
#line 2171
  memset((void *)(& c), 0, sizeof(ngx_http_cache_t ));
#line 2172
  cache = (ngx_http_file_cache_t *)ctx->data;
#line 2174
  c.length = ctx->size;
#line 2175
  c.fs_size = (off_t )((((size_t___0 )ctx->fs_size + cache->bsize) - 1UL) / cache->bsize);
#line 2177
  p = name->data + (name->len - 32UL);
#line 2179
  i = (ngx_uint_t )0;
  }
  {
#line 2179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2179
    if (! (i < 16UL)) {
#line 2179
      goto while_break;
    }
    {
#line 2180
    n = ngx_hextoi(p, (size_t___0 )2);
    }
#line 2182
    if (n == -1L) {
#line 2183
      return ((ngx_int_t )-1);
    }
#line 2186
    p += 2;
#line 2188
    c.key[i] = (u_char )n;
#line 2179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2191
  tmp = ngx_http_file_cache_add(cache, & c);
  }
#line 2191
  return (tmp);
}
}
#line 2195 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_add(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) 
{ 
  ngx_http_file_cache_node_t *fcn ;
  void *tmp ;

  {
  {
#line 2200
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 2202
  fcn = ngx_http_file_cache_lookup(cache, c->key);
  }
#line 2204
  if ((unsigned long )fcn == (unsigned long )((void *)0)) {
    {
#line 2206
    tmp = ngx_slab_calloc_locked(cache->shpool, sizeof(ngx_http_file_cache_node_t ));
#line 2206
    fcn = (ngx_http_file_cache_node_t *)tmp;
    }
#line 2208
    if ((unsigned long )fcn == (unsigned long )((void *)0)) {
      {
#line 2209
      ngx_http_file_cache_set_watermark(cache);
      }
#line 2211
      if (cache->fail_time != (time_t )ngx_cached_time->sec) {
#line 2212
        cache->fail_time = (time_t )ngx_cached_time->sec;
#line 2213
        if ((ngx_cycle->log)->log_level >= 2UL) {
          {
#line 2213
          ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "could not allocate node%s",
                             (cache->shpool)->log_ctx);
          }
        }
      }
      {
#line 2217
      ngx_shmtx_unlock(& (cache->shpool)->mutex);
      }
#line 2218
      return ((ngx_int_t )-1);
    }
    {
#line 2221
    ((cache->sh)->count) ++;
#line 2223
    memcpy((void */* __restrict  */)((u_char *)(& fcn->node.key)), (void const   */* __restrict  */)(c->key),
           sizeof(ngx_rbtree_key_t ));
#line 2225
    memcpy((void */* __restrict  */)(fcn->key), (void const   */* __restrict  */)(& c->key[sizeof(ngx_rbtree_key_t )]),
           16UL - sizeof(ngx_rbtree_key_t ));
#line 2228
    ngx_rbtree_insert(& (cache->sh)->rbtree, & fcn->node);
#line 2230
    fcn->uses = 1U;
#line 2231
    fcn->exists = 1U;
#line 2232
    fcn->fs_size = c->fs_size;
#line 2234
    (cache->sh)->size += c->fs_size;
    }
  } else {
#line 2237
    (fcn->queue.next)->prev = fcn->queue.prev;
#line 2237
    (fcn->queue.prev)->next = fcn->queue.next;
  }
  {
#line 2240
  fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 2242
  fcn->queue.next = (cache->sh)->queue.next;
#line 2242
  (fcn->queue.next)->prev = & fcn->queue;
#line 2242
  fcn->queue.prev = & (cache->sh)->queue;
#line 2242
  (cache->sh)->queue.next = & fcn->queue;
#line 2244
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 2246
  return ((ngx_int_t )0);
}
}
#line 2250 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_delete_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 2256
  tmp___0 = unlink((char const   *)path->data);
  }
#line 2256
  if (tmp___0 == -1) {
#line 2257
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 2257
      tmp = __errno_location();
#line 2257
      ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp, "unlink() \"%s\" failed",
                         path->data);
      }
    }
  }
#line 2261
  return ((ngx_int_t )0);
}
}
#line 2265 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_set_watermark(ngx_http_file_cache_t *cache ) 
{ 


  {
#line 2268
  (cache->sh)->watermark = (cache->sh)->count - (cache->sh)->count / 8UL;
#line 2272
  return;
}
}
#line 2275 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
time_t ngx_http_file_cache_valid(ngx_array_t *cache_valid , ngx_uint_t status ) 
{ 
  ngx_uint_t i ;
  ngx_http_cache_valid_t *valid ;

  {
#line 2281
  if ((unsigned long )cache_valid == (unsigned long )((void *)0)) {
#line 2282
    return ((time_t )0);
  }
#line 2285
  valid = (ngx_http_cache_valid_t *)cache_valid->elts;
#line 2286
  i = (ngx_uint_t )0;
  {
#line 2286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2286
    if (! (i < cache_valid->nelts)) {
#line 2286
      goto while_break;
    }
#line 2288
    if ((valid + i)->status == 0UL) {
#line 2289
      return ((valid + i)->valid);
    }
#line 2292
    if ((valid + i)->status == status) {
#line 2293
      return ((valid + i)->valid);
    }
#line 2286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2297
  return ((time_t )0);
}
}
#line 2301 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
char *ngx_http_file_cache_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *confp ;
  off_t max_size ;
  u_char *last ;
  u_char *p ;
  time_t inactive ;
  ssize_t size ;
  ngx_str_t s ;
  ngx_str_t name ;
  ngx_str_t *value ;
  ngx_int_t loader_files ;
  ngx_int_t manager_files ;
  ngx_msec_t loader_sleep ;
  ngx_msec_t manager_sleep ;
  ngx_msec_t loader_threshold ;
  ngx_msec_t manager_threshold ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t use_temp_path ;
  ngx_array_t *caches ;
  ngx_http_file_cache_t *cache ;
  ngx_http_file_cache_t **ce ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ngx_int_t tmp___13 ;
  int tmp___14 ;
  ngx_int_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  ngx_int_t tmp___18 ;
  int tmp___19 ;
  ngx_int_t tmp___20 ;
  int tmp___21 ;
  ngx_int_t tmp___22 ;
  void *tmp___23 ;

  {
  {
#line 2304
  confp = (char *)conf;
#line 2318
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_file_cache_t ));
#line 2318
  cache = (ngx_http_file_cache_t *)tmp;
  }
#line 2319
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 2320
    return ((char *)((void *)-1));
  }
  {
#line 2323
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_path_t ));
#line 2323
  cache->path = (ngx_path_t *)tmp___0;
  }
#line 2324
  if ((unsigned long )cache->path == (unsigned long )((void *)0)) {
#line 2325
    return ((char *)((void *)-1));
  }
#line 2328
  use_temp_path = (ngx_uint_t )1;
#line 2330
  inactive = (time_t )600;
#line 2332
  loader_files = (ngx_int_t )100;
#line 2333
  loader_sleep = (ngx_msec_t )50;
#line 2334
  loader_threshold = (ngx_msec_t )200;
#line 2336
  manager_files = (ngx_int_t )100;
#line 2337
  manager_sleep = (ngx_msec_t )50;
#line 2338
  manager_threshold = (ngx_msec_t )200;
#line 2340
  name.len = (size_t___0 )0;
#line 2341
  size = (ssize_t )0;
#line 2342
  max_size = (off_t )9223372036854775807LL;
#line 2344
  value = (ngx_str_t *)(cf->args)->elts;
#line 2346
  (cache->path)->name = *(value + 1);
#line 2348
  if ((int )*((cache->path)->name.data + ((cache->path)->name.len - 1UL)) == 47) {
#line 2349
    ((cache->path)->name.len) --;
  }
  {
#line 2352
  tmp___1 = ngx_conf_full_name(cf->cycle, & (cache->path)->name, (ngx_uint_t )0);
  }
#line 2352
  if (tmp___1 != 0L) {
#line 2353
    return ((char *)((void *)-1));
  }
#line 2356
  i = (ngx_uint_t )2;
  {
#line 2356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2356
    if (! (i < (cf->args)->nelts)) {
#line 2356
      goto while_break;
    }
    {
#line 2358
    tmp___4 = strncmp((char const   *)(value + i)->data, "levels=", (size_t )7);
    }
#line 2358
    if (tmp___4 == 0) {
#line 2360
      p = (value + i)->data + 7;
#line 2361
      last = (value + i)->data + (value + i)->len;
#line 2363
      n = (ngx_uint_t )0;
      {
#line 2363
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2363
        if (n < 3UL) {
#line 2363
          if (! ((unsigned long )p < (unsigned long )last)) {
#line 2363
            goto while_break___0;
          }
        } else {
#line 2363
          goto while_break___0;
        }
#line 2365
        if ((int )*p > 48) {
#line 2365
          if ((int )*p < 51) {
#line 2367
            tmp___2 = p;
#line 2367
            p ++;
#line 2367
            (cache->path)->level[n] = (size_t___0 )((int )*tmp___2 - 48);
#line 2368
            (cache->path)->len += (cache->path)->level[n] + 1UL;
#line 2370
            if ((unsigned long )p == (unsigned long )last) {
#line 2371
              goto while_break___0;
            }
#line 2374
            tmp___3 = p;
#line 2374
            p ++;
#line 2374
            if ((int )*tmp___3 == 58) {
#line 2374
              if (n < 2UL) {
#line 2374
                if ((unsigned long )p < (unsigned long )last) {
#line 2375
                  goto __Cont;
                }
              }
            }
#line 2378
            goto invalid_levels;
          }
        }
#line 2381
        goto invalid_levels;
        __Cont: /* CIL Label */ 
#line 2363
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2384
      if ((cache->path)->len < 13UL) {
#line 2385
        goto __Cont___0;
      }
      invalid_levels: 
      {
#line 2390
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid \"levels\" \"%V\"", value + i);
      }
#line 2392
      return ((char *)((void *)-1));
    }
    {
#line 2395
    tmp___7 = strncmp((char const   *)(value + i)->data, "use_temp_path=", (size_t )14);
    }
#line 2395
    if (tmp___7 == 0) {
      {
#line 2397
      tmp___6 = strcmp((char const   *)((value + i)->data + 14), "on");
      }
#line 2397
      if (tmp___6 == 0) {
#line 2398
        use_temp_path = (ngx_uint_t )1;
      } else {
        {
#line 2400
        tmp___5 = strcmp((char const   *)((value + i)->data + 14), "off");
        }
#line 2400
        if (tmp___5 == 0) {
#line 2401
          use_temp_path = (ngx_uint_t )0;
        } else {
          {
#line 2404
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid use_temp_path value \"%V\", it must be \"on\" or \"off\"",
                             value + i);
          }
#line 2408
          return ((char *)((void *)-1));
        }
      }
#line 2411
      goto __Cont___0;
    }
    {
#line 2414
    tmp___9 = strncmp((char const   *)(value + i)->data, "keys_zone=", (size_t )10);
    }
#line 2414
    if (tmp___9 == 0) {
      {
#line 2416
      name.data = (value + i)->data + 10;
#line 2418
      tmp___8 = strchr((char const   *)name.data, ':');
#line 2418
      p = (u_char *)tmp___8;
      }
#line 2420
      if (p) {
        {
#line 2421
        name.len = (size_t___0 )(p - name.data);
#line 2423
        p ++;
#line 2425
        s.len = (size_t___0 )(((value + i)->data + (value + i)->len) - p);
#line 2426
        s.data = p;
#line 2428
        size = ngx_parse_size(& s);
        }
#line 2429
        if (size > 8191L) {
#line 2430
          goto __Cont___0;
        }
      }
      {
#line 2434
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid keys zone size \"%V\"", value + i);
      }
#line 2436
      return ((char *)((void *)-1));
    }
    {
#line 2439
    tmp___10 = strncmp((char const   *)(value + i)->data, "inactive=", (size_t )9);
    }
#line 2439
    if (tmp___10 == 0) {
      {
#line 2441
      s.len = (value + i)->len - 9UL;
#line 2442
      s.data = (value + i)->data + 9;
#line 2444
      inactive = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 2445
      if (inactive == -1L) {
        {
#line 2446
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid inactive value \"%V\"",
                           value + i);
        }
#line 2448
        return ((char *)((void *)-1));
      }
#line 2451
      goto __Cont___0;
    }
    {
#line 2454
    tmp___11 = strncmp((char const   *)(value + i)->data, "max_size=", (size_t )9);
    }
#line 2454
    if (tmp___11 == 0) {
      {
#line 2456
      s.len = (value + i)->len - 9UL;
#line 2457
      s.data = (value + i)->data + 9;
#line 2459
      max_size = ngx_parse_offset(& s);
      }
#line 2460
      if (max_size < 0L) {
        {
#line 2461
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid max_size value \"%V\"",
                           value + i);
        }
#line 2463
        return ((char *)((void *)-1));
      }
#line 2466
      goto __Cont___0;
    }
    {
#line 2469
    tmp___12 = strncmp((char const   *)(value + i)->data, "loader_files=", (size_t )13);
    }
#line 2469
    if (tmp___12 == 0) {
      {
#line 2471
      loader_files = ngx_atoi((value + i)->data + 13, (value + i)->len - 13UL);
      }
#line 2472
      if (loader_files == -1L) {
        {
#line 2473
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid loader_files value \"%V\"",
                           value + i);
        }
#line 2475
        return ((char *)((void *)-1));
      }
#line 2478
      goto __Cont___0;
    }
    {
#line 2481
    tmp___14 = strncmp((char const   *)(value + i)->data, "loader_sleep=", (size_t )13);
    }
#line 2481
    if (tmp___14 == 0) {
      {
#line 2483
      s.len = (value + i)->len - 13UL;
#line 2484
      s.data = (value + i)->data + 13;
#line 2486
      tmp___13 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2486
      loader_sleep = (ngx_msec_t )tmp___13;
      }
#line 2487
      if (loader_sleep == 0xffffffffffffffffUL) {
        {
#line 2488
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid loader_sleep value \"%V\"",
                           value + i);
        }
#line 2490
        return ((char *)((void *)-1));
      }
#line 2493
      goto __Cont___0;
    }
    {
#line 2496
    tmp___16 = strncmp((char const   *)(value + i)->data, "loader_threshold=", (size_t )17);
    }
#line 2496
    if (tmp___16 == 0) {
      {
#line 2498
      s.len = (value + i)->len - 17UL;
#line 2499
      s.data = (value + i)->data + 17;
#line 2501
      tmp___15 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2501
      loader_threshold = (ngx_msec_t )tmp___15;
      }
#line 2502
      if (loader_threshold == 0xffffffffffffffffUL) {
        {
#line 2503
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid loader_threshold value \"%V\"",
                           value + i);
        }
#line 2505
        return ((char *)((void *)-1));
      }
#line 2508
      goto __Cont___0;
    }
    {
#line 2511
    tmp___17 = strncmp((char const   *)(value + i)->data, "manager_files=", (size_t )14);
    }
#line 2511
    if (tmp___17 == 0) {
      {
#line 2513
      manager_files = ngx_atoi((value + i)->data + 14, (value + i)->len - 14UL);
      }
#line 2514
      if (manager_files == -1L) {
        {
#line 2515
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid manager_files value \"%V\"",
                           value + i);
        }
#line 2517
        return ((char *)((void *)-1));
      }
#line 2520
      goto __Cont___0;
    }
    {
#line 2523
    tmp___19 = strncmp((char const   *)(value + i)->data, "manager_sleep=", (size_t )14);
    }
#line 2523
    if (tmp___19 == 0) {
      {
#line 2525
      s.len = (value + i)->len - 14UL;
#line 2526
      s.data = (value + i)->data + 14;
#line 2528
      tmp___18 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2528
      manager_sleep = (ngx_msec_t )tmp___18;
      }
#line 2529
      if (manager_sleep == 0xffffffffffffffffUL) {
        {
#line 2530
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid manager_sleep value \"%V\"",
                           value + i);
        }
#line 2532
        return ((char *)((void *)-1));
      }
#line 2535
      goto __Cont___0;
    }
    {
#line 2538
    tmp___21 = strncmp((char const   *)(value + i)->data, "manager_threshold=", (size_t )18);
    }
#line 2538
    if (tmp___21 == 0) {
      {
#line 2540
      s.len = (value + i)->len - 18UL;
#line 2541
      s.data = (value + i)->data + 18;
#line 2543
      tmp___20 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2543
      manager_threshold = (ngx_msec_t )tmp___20;
      }
#line 2544
      if (manager_threshold == 0xffffffffffffffffUL) {
        {
#line 2545
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid manager_threshold value \"%V\"",
                           value + i);
        }
#line 2547
        return ((char *)((void *)-1));
      }
#line 2550
      goto __Cont___0;
    }
    {
#line 2553
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 2555
    return ((char *)((void *)-1));
    __Cont___0: /* CIL Label */ 
#line 2356
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2558
  if (name.len == 0UL) {
    {
#line 2559
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"keys_zone\" parameter",
                       & cmd->name);
    }
#line 2562
    return ((char *)((void *)-1));
  } else
#line 2558
  if (size == 0L) {
    {
#line 2559
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"keys_zone\" parameter",
                       & cmd->name);
    }
#line 2562
    return ((char *)((void *)-1));
  }
  {
#line 2565
  (cache->path)->manager = & ngx_http_file_cache_manager;
#line 2566
  (cache->path)->loader = & ngx_http_file_cache_loader;
#line 2567
  (cache->path)->data = (void *)cache;
#line 2568
  (cache->path)->conf_file = (cf->conf_file)->file.name.data;
#line 2569
  (cache->path)->line = (cf->conf_file)->line;
#line 2570
  cache->loader_files = (ngx_uint_t )loader_files;
#line 2571
  cache->loader_sleep = loader_sleep;
#line 2572
  cache->loader_threshold = loader_threshold;
#line 2573
  cache->manager_files = (ngx_uint_t )manager_files;
#line 2574
  cache->manager_sleep = manager_sleep;
#line 2575
  cache->manager_threshold = manager_threshold;
#line 2577
  tmp___22 = ngx_add_path(cf, & cache->path);
  }
#line 2577
  if (tmp___22 != 0L) {
#line 2578
    return ((char *)((void *)-1));
  }
  {
#line 2581
  cache->shm_zone = ngx_shared_memory_add(cf, & name, (size_t___0 )size, cmd->post);
  }
#line 2582
  if ((unsigned long )cache->shm_zone == (unsigned long )((void *)0)) {
#line 2583
    return ((char *)((void *)-1));
  }
#line 2586
  if ((cache->shm_zone)->data) {
    {
#line 2587
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate zone \"%V\"", & name);
    }
#line 2589
    return ((char *)((void *)-1));
  }
  {
#line 2593
  (cache->shm_zone)->init = & ngx_http_file_cache_init;
#line 2594
  (cache->shm_zone)->data = (void *)cache;
#line 2596
  cache->use_temp_path = use_temp_path;
#line 2598
  cache->inactive = inactive;
#line 2599
  cache->max_size = max_size;
#line 2601
  caches = (ngx_array_t *)(confp + cmd->offset);
#line 2603
  tmp___23 = ngx_array_push(caches);
#line 2603
  ce = (ngx_http_file_cache_t **)tmp___23;
  }
#line 2604
  if ((unsigned long )ce == (unsigned long )((void *)0)) {
#line 2605
    return ((char *)((void *)-1));
  }
#line 2608
  *ce = cache;
#line 2610
  return ((char *)((void *)0));
}
}
#line 2625 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
static ngx_uint_t statuses[3]  = {      (ngx_uint_t )200,      (ngx_uint_t )301,      (ngx_uint_t )302};
#line 2614 "/tmp/nginx-1.13.2/src/http/ngx_http_file_cache.c"
char *ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  time_t valid ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t status ;
  ngx_array_t **a ;
  ngx_http_cache_valid_t *v ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 2618
  p = (char *)conf;
#line 2627
  a = (ngx_array_t **)(p + cmd->offset);
#line 2629
  if ((unsigned long )*a == (unsigned long )((void *)-1)) {
    {
#line 2630
    *a = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_cache_valid_t ));
    }
#line 2631
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 2632
      return ((char *)((void *)-1));
    }
  }
  {
#line 2636
  value = (ngx_str_t *)(cf->args)->elts;
#line 2637
  n = (cf->args)->nelts - 1UL;
#line 2639
  valid = ngx_parse_time(value + n, (ngx_uint_t )1);
  }
#line 2640
  if (valid == -1L) {
    {
#line 2641
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid time value \"%V\"", value + n);
    }
#line 2643
    return ((char *)((void *)-1));
  }
#line 2646
  if (n == 1UL) {
#line 2648
    i = (ngx_uint_t )0;
    {
#line 2648
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2648
      if (! (i < 3UL)) {
#line 2648
        goto while_break;
      }
      {
#line 2649
      tmp = ngx_array_push(*a);
#line 2649
      v = (ngx_http_cache_valid_t *)tmp;
      }
#line 2650
      if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2651
        return ((char *)((void *)-1));
      }
#line 2654
      v->status = statuses[i];
#line 2655
      v->valid = valid;
#line 2648
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2658
    return ((char *)((void *)0));
  }
#line 2661
  i = (ngx_uint_t )1;
  {
#line 2661
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2661
    if (! (i < n)) {
#line 2661
      goto while_break___0;
    }
    {
#line 2663
    tmp___1 = strcmp((char const   *)(value + i)->data, "any");
    }
#line 2663
    if (tmp___1 == 0) {
#line 2665
      status = (ngx_uint_t )0;
    } else {
      {
#line 2669
      tmp___0 = ngx_atoi((value + i)->data, (value + i)->len);
#line 2669
      status = (ngx_uint_t )tmp___0;
      }
#line 2670
      if (status < 100UL) {
        {
#line 2671
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid status \"%V\"", value + i);
        }
#line 2673
        return ((char *)((void *)-1));
      }
    }
    {
#line 2677
    tmp___2 = ngx_array_push(*a);
#line 2677
    v = (ngx_http_cache_valid_t *)tmp___2;
    }
#line 2678
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2679
      return ((char *)((void *)-1));
    }
#line 2682
    v->status = status;
#line 2683
    v->valid = valid;
#line 2661
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2686
  return ((char *)((void *)0));
}
}
#line 112 "src/core/ngx_inet.h"
size_t___0 ngx_sock_ntop(struct sockaddr *sa , socklen_t socklen , u_char *text ,
                         size_t___0 len , ngx_uint_t port ) ;
#line 122
ngx_int_t ngx_inet_resolve_host(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 126
void ngx_inet_set_port(struct sockaddr *sa , in_port_t port ) ;
#line 140 "src/http/ngx_http_upstream_round_robin.h"
ngx_int_t ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_resolved_t *ur ) ;
#line 144
void ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc , void *data ,
                                             ngx_uint_t state ) ;
#line 17 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream_round_robin.c"
static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp ) ;
#line 30 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_init_round_robin(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_url_t u ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t n ;
  ngx_uint_t w ;
  ngx_http_upstream_server_t *server ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t **peerp ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peers_t *backup ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 40
  us->peer.init = & ngx_http_upstream_init_round_robin_peer;
#line 42
  if (us->servers) {
#line 43
    server = (ngx_http_upstream_server_t *)(us->servers)->elts;
#line 45
    n = (ngx_uint_t )0;
#line 46
    w = (ngx_uint_t )0;
#line 48
    i = (ngx_uint_t )0;
    {
#line 48
    while (1) {
      while_continue: /* CIL Label */ ;
#line 48
      if (! (i < (us->servers)->nelts)) {
#line 48
        goto while_break;
      }
#line 49
      if ((server + i)->backup) {
#line 50
        goto __Cont;
      }
#line 53
      n += (server + i)->naddrs;
#line 54
      w += (server + i)->naddrs * (server + i)->weight;
      __Cont: /* CIL Label */ 
#line 48
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 57
    if (n == 0UL) {
#line 58
      if ((cf->log)->log_level >= 1UL) {
        {
#line 58
        ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "no servers in upstream \"%V\" in %s:%ui",
                           & us->host, us->file_name, us->line);
        }
      }
#line 61
      return ((ngx_int_t )-1);
    }
    {
#line 64
    tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 64
    peers = (ngx_http_upstream_rr_peers_t *)tmp;
    }
#line 65
    if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 66
      return ((ngx_int_t )-1);
    }
    {
#line 69
    tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peer_t ) * n);
#line 69
    peer = (ngx_http_upstream_rr_peer_t *)tmp___0;
    }
#line 70
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 71
      return ((ngx_int_t )-1);
    }
#line 74
    peers->single = (unsigned int )(n == 1UL);
#line 75
    peers->number = n;
#line 76
    peers->weighted = (unsigned int )(w != n);
#line 77
    peers->total_weight = w;
#line 78
    peers->name = & us->host;
#line 80
    n = (ngx_uint_t )0;
#line 81
    peerp = & peers->peer;
#line 83
    i = (ngx_uint_t )0;
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if (! (i < (us->servers)->nelts)) {
#line 83
        goto while_break___0;
      }
#line 84
      if ((server + i)->backup) {
#line 85
        goto __Cont___0;
      }
#line 88
      j = (ngx_uint_t )0;
      {
#line 88
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 88
        if (! (j < (server + i)->naddrs)) {
#line 88
          goto while_break___1;
        }
#line 89
        (peer + n)->sockaddr = ((server + i)->addrs + j)->sockaddr;
#line 90
        (peer + n)->socklen = ((server + i)->addrs + j)->socklen;
#line 91
        (peer + n)->name = ((server + i)->addrs + j)->name;
#line 92
        (peer + n)->weight = (ngx_int_t )(server + i)->weight;
#line 93
        (peer + n)->effective_weight = (ngx_int_t )(server + i)->weight;
#line 94
        (peer + n)->current_weight = (ngx_int_t )0;
#line 95
        (peer + n)->max_conns = (server + i)->max_conns;
#line 96
        (peer + n)->max_fails = (server + i)->max_fails;
#line 97
        (peer + n)->fail_timeout = (server + i)->fail_timeout;
#line 98
        (peer + n)->down = (ngx_uint_t )(server + i)->down;
#line 99
        (peer + n)->server = (server + i)->name;
#line 101
        *peerp = peer + n;
#line 102
        peerp = & (peer + n)->next;
#line 103
        n ++;
#line 88
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 83
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 107
    us->peer.data = (void *)peers;
#line 111
    n = (ngx_uint_t )0;
#line 112
    w = (ngx_uint_t )0;
#line 114
    i = (ngx_uint_t )0;
    {
#line 114
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 114
      if (! (i < (us->servers)->nelts)) {
#line 114
        goto while_break___2;
      }
#line 115
      if (! (server + i)->backup) {
#line 116
        goto __Cont___1;
      }
#line 119
      n += (server + i)->naddrs;
#line 120
      w += (server + i)->naddrs * (server + i)->weight;
      __Cont___1: /* CIL Label */ 
#line 114
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 123
    if (n == 0UL) {
#line 124
      return ((ngx_int_t )0);
    }
    {
#line 127
    tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 127
    backup = (ngx_http_upstream_rr_peers_t *)tmp___1;
    }
#line 128
    if ((unsigned long )backup == (unsigned long )((void *)0)) {
#line 129
      return ((ngx_int_t )-1);
    }
    {
#line 132
    tmp___2 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peer_t ) * n);
#line 132
    peer = (ngx_http_upstream_rr_peer_t *)tmp___2;
    }
#line 133
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 134
      return ((ngx_int_t )-1);
    }
#line 137
    peers->single = 0U;
#line 138
    backup->single = 0U;
#line 139
    backup->number = n;
#line 140
    backup->weighted = (unsigned int )(w != n);
#line 141
    backup->total_weight = w;
#line 142
    backup->name = & us->host;
#line 144
    n = (ngx_uint_t )0;
#line 145
    peerp = & backup->peer;
#line 147
    i = (ngx_uint_t )0;
    {
#line 147
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 147
      if (! (i < (us->servers)->nelts)) {
#line 147
        goto while_break___3;
      }
#line 148
      if (! (server + i)->backup) {
#line 149
        goto __Cont___2;
      }
#line 152
      j = (ngx_uint_t )0;
      {
#line 152
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 152
        if (! (j < (server + i)->naddrs)) {
#line 152
          goto while_break___4;
        }
#line 153
        (peer + n)->sockaddr = ((server + i)->addrs + j)->sockaddr;
#line 154
        (peer + n)->socklen = ((server + i)->addrs + j)->socklen;
#line 155
        (peer + n)->name = ((server + i)->addrs + j)->name;
#line 156
        (peer + n)->weight = (ngx_int_t )(server + i)->weight;
#line 157
        (peer + n)->effective_weight = (ngx_int_t )(server + i)->weight;
#line 158
        (peer + n)->current_weight = (ngx_int_t )0;
#line 159
        (peer + n)->max_conns = (server + i)->max_conns;
#line 160
        (peer + n)->max_fails = (server + i)->max_fails;
#line 161
        (peer + n)->fail_timeout = (server + i)->fail_timeout;
#line 162
        (peer + n)->down = (ngx_uint_t )(server + i)->down;
#line 163
        (peer + n)->server = (server + i)->name;
#line 165
        *peerp = peer + n;
#line 166
        peerp = & (peer + n)->next;
#line 167
        n ++;
#line 152
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      __Cont___2: /* CIL Label */ 
#line 147
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 171
    peers->next = backup;
#line 173
    return ((ngx_int_t )0);
  }
#line 179
  if ((int )us->port == 0) {
#line 180
    if ((cf->log)->log_level >= 1UL) {
      {
#line 180
      ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "no port in upstream \"%V\" in %s:%ui",
                         & us->host, us->file_name, us->line);
      }
    }
#line 183
    return ((ngx_int_t )-1);
  }
  {
#line 186
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 188
  u.host = us->host;
#line 189
  u.port = us->port;
#line 191
  tmp___3 = ngx_inet_resolve_host(cf->pool, & u);
  }
#line 191
  if (tmp___3 != 0L) {
#line 192
    if (u.err) {
#line 193
      if ((cf->log)->log_level >= 1UL) {
        {
#line 193
        ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "%s in upstream \"%V\" in %s:%ui",
                           u.err, & us->host, us->file_name, us->line);
        }
      }
    }
#line 198
    return ((ngx_int_t )-1);
  }
  {
#line 201
  n = u.naddrs;
#line 203
  tmp___4 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 203
  peers = (ngx_http_upstream_rr_peers_t *)tmp___4;
  }
#line 204
  if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 205
    return ((ngx_int_t )-1);
  }
  {
#line 208
  tmp___5 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peer_t ) * n);
#line 208
  peer = (ngx_http_upstream_rr_peer_t *)tmp___5;
  }
#line 209
  if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 210
    return ((ngx_int_t )-1);
  }
#line 213
  peers->single = (unsigned int )(n == 1UL);
#line 214
  peers->number = n;
#line 215
  peers->weighted = 0U;
#line 216
  peers->total_weight = n;
#line 217
  peers->name = & us->host;
#line 219
  peerp = & peers->peer;
#line 221
  i = (ngx_uint_t )0;
  {
#line 221
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 221
    if (! (i < u.naddrs)) {
#line 221
      goto while_break___5;
    }
#line 222
    (peer + i)->sockaddr = (u.addrs + i)->sockaddr;
#line 223
    (peer + i)->socklen = (u.addrs + i)->socklen;
#line 224
    (peer + i)->name = (u.addrs + i)->name;
#line 225
    (peer + i)->weight = (ngx_int_t )1;
#line 226
    (peer + i)->effective_weight = (ngx_int_t )1;
#line 227
    (peer + i)->current_weight = (ngx_int_t )0;
#line 228
    (peer + i)->max_conns = (ngx_uint_t )0;
#line 229
    (peer + i)->max_fails = (ngx_uint_t )1;
#line 230
    (peer + i)->fail_timeout = (time_t )10;
#line 231
    *peerp = peer + i;
#line 232
    peerp = & (peer + i)->next;
#line 221
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 235
  us->peer.data = (void *)peers;
#line 239
  return ((ngx_int_t )0);
}
}
#line 243 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_uint_t n ;
  ngx_http_upstream_rr_peer_data_t *rrp ;
  void *tmp ;
  void *tmp___0 ;
  ngx_uint_t tmp___1 ;

  {
#line 250
  rrp = (ngx_http_upstream_rr_peer_data_t *)(r->upstream)->peer.data;
#line 252
  if ((unsigned long )rrp == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t ));
#line 253
    rrp = (ngx_http_upstream_rr_peer_data_t *)tmp;
    }
#line 254
    if ((unsigned long )rrp == (unsigned long )((void *)0)) {
#line 255
      return ((ngx_int_t )-1);
    }
#line 258
    (r->upstream)->peer.data = (void *)rrp;
  }
#line 261
  rrp->peers = (ngx_http_upstream_rr_peers_t *)us->peer.data;
#line 262
  rrp->current = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 263
  rrp->config = (ngx_uint_t )0;
#line 265
  n = (rrp->peers)->number;
#line 267
  if ((rrp->peers)->next) {
#line 267
    if (((rrp->peers)->next)->number > n) {
#line 268
      n = ((rrp->peers)->next)->number;
    }
  }
#line 271
  if (n <= 8UL * sizeof(uintptr_t )) {
#line 272
    rrp->tried = & rrp->data;
#line 273
    rrp->data = (uintptr_t )0;
  } else {
    {
#line 276
    n = (n + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 278
    tmp___0 = ngx_pcalloc(r->pool, n * sizeof(uintptr_t ));
#line 278
    rrp->tried = (uintptr_t *)tmp___0;
    }
#line 279
    if ((unsigned long )rrp->tried == (unsigned long )((void *)0)) {
#line 280
      return ((ngx_int_t )-1);
    }
  }
#line 284
  (r->upstream)->peer.get = & ngx_http_upstream_get_round_robin_peer;
#line 285
  (r->upstream)->peer.free = & ngx_http_upstream_free_round_robin_peer;
#line 286
  if ((rrp->peers)->next) {
#line 286
    tmp___1 = ((rrp->peers)->next)->number;
  } else {
#line 286
    tmp___1 = (ngx_uint_t )0;
  }
#line 286
  (r->upstream)->peer.tries = (rrp->peers)->number + tmp___1;
#line 294
  return ((ngx_int_t )0);
}
}
#line 298 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_resolved_t *ur ) 
{ 
  u_char *p ;
  size_t___0 len ;
  socklen_t socklen ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  struct sockaddr *sockaddr ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t **peerp ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peer_data_t *rrp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_uint_t tmp___5 ;

  {
#line 311
  rrp = (ngx_http_upstream_rr_peer_data_t *)(r->upstream)->peer.data;
#line 313
  if ((unsigned long )rrp == (unsigned long )((void *)0)) {
    {
#line 314
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t ));
#line 314
    rrp = (ngx_http_upstream_rr_peer_data_t *)tmp;
    }
#line 315
    if ((unsigned long )rrp == (unsigned long )((void *)0)) {
#line 316
      return ((ngx_int_t )-1);
    }
#line 319
    (r->upstream)->peer.data = (void *)rrp;
  }
  {
#line 322
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 322
  peers = (ngx_http_upstream_rr_peers_t *)tmp___0;
  }
#line 323
  if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 324
    return ((ngx_int_t )-1);
  }
  {
#line 327
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peer_t ) * ur->naddrs);
#line 327
  peer = (ngx_http_upstream_rr_peer_t *)tmp___1;
  }
#line 329
  if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 330
    return ((ngx_int_t )-1);
  }
#line 333
  peers->single = (unsigned int )(ur->naddrs == 1UL);
#line 334
  peers->number = ur->naddrs;
#line 335
  peers->name = & ur->host;
#line 337
  if (ur->sockaddr) {
#line 338
    (peer + 0)->sockaddr = ur->sockaddr;
#line 339
    (peer + 0)->socklen = ur->socklen;
#line 340
    if (ur->name.data) {
#line 340
      (peer + 0)->name = ur->name;
    } else {
#line 340
      (peer + 0)->name = ur->host;
    }
#line 341
    (peer + 0)->weight = (ngx_int_t )1;
#line 342
    (peer + 0)->effective_weight = (ngx_int_t )1;
#line 343
    (peer + 0)->current_weight = (ngx_int_t )0;
#line 344
    (peer + 0)->max_conns = (ngx_uint_t )0;
#line 345
    (peer + 0)->max_fails = (ngx_uint_t )1;
#line 346
    (peer + 0)->fail_timeout = (time_t )10;
#line 347
    peers->peer = peer;
  } else {
#line 350
    peerp = & peers->peer;
#line 352
    i = (ngx_uint_t )0;
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! (i < ur->naddrs)) {
#line 352
        goto while_break;
      }
      {
#line 354
      socklen = (ur->addrs + i)->socklen;
#line 356
      tmp___2 = ngx_palloc(r->pool, (size_t___0 )socklen);
#line 356
      sockaddr = (struct sockaddr *)tmp___2;
      }
#line 357
      if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
#line 358
        return ((ngx_int_t )-1);
      }
      {
#line 361
      memcpy((void */* __restrict  */)sockaddr, (void const   */* __restrict  */)(ur->addrs + i)->sockaddr,
             (size_t )socklen);
#line 362
      ngx_inet_set_port(sockaddr, ur->port);
#line 364
      tmp___3 = ngx_pnalloc(r->pool, (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)));
#line 364
      p = (u_char *)tmp___3;
      }
#line 365
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 366
        return ((ngx_int_t )-1);
      }
      {
#line 369
      len = ngx_sock_ntop(sockaddr, socklen, p, (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)),
                          (ngx_uint_t )1);
#line 371
      (peer + i)->sockaddr = sockaddr;
#line 372
      (peer + i)->socklen = socklen;
#line 373
      (peer + i)->name.len = len;
#line 374
      (peer + i)->name.data = p;
#line 375
      (peer + i)->weight = (ngx_int_t )1;
#line 376
      (peer + i)->effective_weight = (ngx_int_t )1;
#line 377
      (peer + i)->current_weight = (ngx_int_t )0;
#line 378
      (peer + i)->max_conns = (ngx_uint_t )0;
#line 379
      (peer + i)->max_fails = (ngx_uint_t )1;
#line 380
      (peer + i)->fail_timeout = (time_t )10;
#line 381
      *peerp = peer + i;
#line 382
      peerp = & (peer + i)->next;
#line 352
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 386
  rrp->peers = peers;
#line 387
  rrp->current = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 388
  rrp->config = (ngx_uint_t )0;
#line 390
  if ((rrp->peers)->number <= 8UL * sizeof(uintptr_t )) {
#line 391
    rrp->tried = & rrp->data;
#line 392
    rrp->data = (uintptr_t )0;
  } else {
    {
#line 395
    n = ((rrp->peers)->number + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 398
    tmp___4 = ngx_pcalloc(r->pool, n * sizeof(uintptr_t ));
#line 398
    rrp->tried = (uintptr_t *)tmp___4;
    }
#line 399
    if ((unsigned long )rrp->tried == (unsigned long )((void *)0)) {
#line 400
      return ((ngx_int_t )-1);
    }
  }
#line 404
  (r->upstream)->peer.get = & ngx_http_upstream_get_round_robin_peer;
#line 405
  (r->upstream)->peer.free = & ngx_http_upstream_free_round_robin_peer;
#line 406
  if ((rrp->peers)->next) {
#line 406
    tmp___5 = ((rrp->peers)->next)->number;
  } else {
#line 406
    tmp___5 = (ngx_uint_t )0;
  }
#line 406
  (r->upstream)->peer.tries = (rrp->peers)->number + tmp___5;
#line 412
  return ((ngx_int_t )0);
}
}
#line 416 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_rr_peer_data_t *rrp ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peers_t *peers ;

  {
#line 419
  rrp = (ngx_http_upstream_rr_peer_data_t *)data;
#line 429
  pc->cached = 0U;
#line 430
  pc->connection = (ngx_connection_t *)((void *)0);
#line 432
  peers = rrp->peers;
#line 433
  if (peers->shpool) {
    {
#line 433
    ngx_rwlock_wlock(& peers->rwlock);
    }
  }
#line 435
  if (peers->single) {
#line 436
    peer = peers->peer;
#line 438
    if (peer->down) {
#line 439
      goto failed;
    }
#line 442
    if (peer->max_conns) {
#line 442
      if (peer->conns >= peer->max_conns) {
#line 443
        goto failed;
      }
    }
#line 446
    rrp->current = peer;
  } else {
    {
#line 452
    peer = ngx_http_upstream_get_peer(rrp);
    }
#line 454
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 455
      goto failed;
    }
  }
#line 463
  pc->sockaddr = peer->sockaddr;
#line 464
  pc->socklen = peer->socklen;
#line 465
  pc->name = & peer->name;
#line 467
  (peer->conns) ++;
#line 469
  if (peers->shpool) {
    {
#line 469
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 471
  return ((ngx_int_t )0);
  failed: 
#line 475
  if (peers->next) {
#line 479
    rrp->peers = peers->next;
#line 481
    n = ((rrp->peers)->number + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 484
    i = (ngx_uint_t )0;
    {
#line 484
    while (1) {
      while_continue: /* CIL Label */ ;
#line 484
      if (! (i < n)) {
#line 484
        goto while_break;
      }
#line 485
      *(rrp->tried + i) = (uintptr_t )0;
#line 484
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 488
    if (peers->shpool) {
      {
#line 488
      ngx_rwlock_unlock(& peers->rwlock);
      }
    }
    {
#line 490
    rc = ngx_http_upstream_get_round_robin_peer(pc, (void *)rrp);
    }
#line 492
    if (rc != -3L) {
#line 493
      return (rc);
    }
#line 496
    if (peers->shpool) {
      {
#line 496
      ngx_rwlock_wlock(& peers->rwlock);
      }
    }
  }
#line 499
  if (peers->shpool) {
    {
#line 499
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 501
  pc->name = peers->name;
#line 503
  return ((ngx_int_t )-3);
}
}
#line 507 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream_round_robin.c"
static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp ) 
{ 
  time_t now ;
  uintptr_t m ;
  ngx_int_t total ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t *best ;

  {
#line 516
  now = (time_t )ngx_cached_time->sec;
#line 518
  best = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 519
  total = (ngx_int_t )0;
#line 522
  p = (ngx_uint_t )0;
#line 525
  peer = (rrp->peers)->peer;
#line 525
  i = (ngx_uint_t )0;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! peer) {
#line 525
      goto while_break;
    }
#line 529
    n = i / (8UL * sizeof(uintptr_t ));
#line 530
    m = 1UL << i % (8UL * sizeof(uintptr_t ));
#line 532
    if (*(rrp->tried + n) & m) {
#line 533
      goto __Cont;
    }
#line 536
    if (peer->down) {
#line 537
      goto __Cont;
    }
#line 540
    if (peer->max_fails) {
#line 540
      if (peer->fails >= peer->max_fails) {
#line 540
        if (now - peer->checked <= peer->fail_timeout) {
#line 544
          goto __Cont;
        }
      }
    }
#line 547
    if (peer->max_conns) {
#line 547
      if (peer->conns >= peer->max_conns) {
#line 548
        goto __Cont;
      }
    }
#line 551
    peer->current_weight += peer->effective_weight;
#line 552
    total += peer->effective_weight;
#line 554
    if (peer->effective_weight < peer->weight) {
#line 555
      (peer->effective_weight) ++;
    }
#line 558
    if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 559
      best = peer;
#line 560
      p = i;
    } else
#line 558
    if (peer->current_weight > best->current_weight) {
#line 559
      best = peer;
#line 560
      p = i;
    }
    __Cont: /* CIL Label */ 
#line 525
    peer = peer->next;
#line 525
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 565
    return ((ngx_http_upstream_rr_peer_t *)((void *)0));
  }
#line 568
  rrp->current = best;
#line 570
  n = p / (8UL * sizeof(uintptr_t ));
#line 571
  m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 573
  *(rrp->tried + n) |= m;
#line 575
  best->current_weight -= total;
#line 577
  if (now - best->checked > best->fail_timeout) {
#line 578
    best->checked = now;
  }
#line 581
  return (best);
}
}
#line 585 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream_round_robin.c"
void ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc , void *data ,
                                             ngx_uint_t state ) 
{ 
  ngx_http_upstream_rr_peer_data_t *rrp ;
  time_t now ;
  ngx_http_upstream_rr_peer_t *peer ;

  {
#line 589
  rrp = (ngx_http_upstream_rr_peer_data_t *)data;
#line 599
  peer = rrp->current;
#line 601
  if ((rrp->peers)->shpool) {
    {
#line 601
    ngx_rwlock_rlock(& (rrp->peers)->rwlock);
    }
  }
#line 602
  if ((rrp->peers)->shpool) {
    {
#line 602
    ngx_rwlock_wlock(& peer->lock);
    }
  }
#line 604
  if ((rrp->peers)->single) {
#line 606
    (peer->conns) --;
#line 608
    if ((rrp->peers)->shpool) {
      {
#line 608
      ngx_rwlock_unlock(& peer->lock);
      }
    }
#line 609
    if ((rrp->peers)->shpool) {
      {
#line 609
      ngx_rwlock_unlock(& (rrp->peers)->rwlock);
      }
    }
#line 611
    pc->tries = (ngx_uint_t )0;
#line 612
    return;
  }
#line 615
  if (state & 4UL) {
#line 616
    now = (time_t )ngx_cached_time->sec;
#line 618
    (peer->fails) ++;
#line 619
    peer->accessed = now;
#line 620
    peer->checked = now;
#line 622
    if (peer->max_fails) {
#line 623
      peer->effective_weight = (ngx_int_t )((ngx_uint_t )peer->effective_weight - (ngx_uint_t )peer->weight / peer->max_fails);
#line 625
      if (peer->fails >= peer->max_fails) {
#line 626
        if ((pc->log)->log_level >= 5UL) {
          {
#line 626
          ngx_log_error_core((ngx_uint_t )5, pc->log, 0, "upstream server temporarily disabled");
          }
        }
      }
    }
#line 635
    if (peer->effective_weight < 0L) {
#line 636
      peer->effective_weight = (ngx_int_t )0;
    }
  } else
#line 643
  if (peer->accessed < peer->checked) {
#line 644
    peer->fails = (ngx_uint_t )0;
  }
#line 648
  (peer->conns) --;
#line 650
  if ((rrp->peers)->shpool) {
    {
#line 650
    ngx_rwlock_unlock(& peer->lock);
    }
  }
#line 651
  if ((rrp->peers)->shpool) {
    {
#line 651
    ngx_rwlock_unlock(& (rrp->peers)->rwlock);
    }
  }
#line 653
  if (pc->tries) {
#line 654
    (pc->tries) --;
  }
#line 656
  return;
}
}
#line 208 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
#line 42 "src/os/unix/ngx_socket.h"
int ngx_tcp_push(ngx_socket_t s ) ;
#line 164 "src/core/ngx_string.h"
u_char *ngx_strlcasestrn(u_char *s1 , u_char *last , u_char *s2 , size_t___0 n ) ;
#line 87 "src/core/ngx_palloc.h"
void ngx_pool_run_cleanup_file(ngx_pool_t *p , ngx_fd_t fd ) ;
#line 36 "src/core/ngx_list.h"
__inline static ngx_int_t ngx_list_init(ngx_list_t *list , ngx_pool_t *pool , ngx_uint_t n ,
                                        size_t___0 size ) 
{ 


  {
  {
#line 39
  list->part.elts = ngx_palloc(pool, n * size);
  }
#line 40
  if ((unsigned long )list->part.elts == (unsigned long )((void *)0)) {
#line 41
    return ((ngx_int_t )-1);
  }
#line 44
  list->part.nelts = (ngx_uint_t )0;
#line 45
  list->part.next = (ngx_list_part_t *)((void *)0);
#line 46
  list->last = & list->part;
#line 47
  list->size = size;
#line 48
  list->nalloc = n;
#line 49
  list->pool = pool;
#line 51
  return ((ngx_int_t )0);
}
}
#line 139 "src/core/ngx_file.h"
ngx_int_t ngx_create_temp_file(ngx_file_t *file , ngx_path_t *path , ngx_pool_t *pool ,
                               ngx_uint_t persistent , ngx_uint_t clean , ngx_uint_t access___0 ) ;
#line 119 "src/core/ngx_inet.h"
ngx_int_t ngx_parse_addr_port(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text ,
                              size_t___0 len ) ;
#line 230 "src/core/ngx_resolver.h"
ngx_resolver_ctx_t *ngx_resolve_start(ngx_resolver_t *r , ngx_resolver_ctx_t *temp ) ;
#line 232
ngx_int_t ngx_resolve_name(ngx_resolver_ctx_t *ctx ) ;
#line 233
void ngx_resolve_name_done(ngx_resolver_ctx_t *ctx ) ;
#line 236
char *ngx_resolver_strerror(ngx_int_t err ) ;
#line 217 "src/core/ngx_connection.h"
ngx_int_t ngx_tcp_nodelay(ngx_connection_t *c ) ;
#line 218
ngx_int_t ngx_connection_error(ngx_connection_t *c , ngx_err_t err , char *text ) ;
#line 58 "src/http/ngx_http_variables.h"
ngx_int_t ngx_http_variable_unknown_header(ngx_http_variable_value_t *v , ngx_str_t *var ,
                                           ngx_list_part_t *part , size_t___0 prefix ) ;
#line 215 "src/http/ngx_http_script.h"
ngx_int_t ngx_http_test_predicates(ngx_http_request_t *r , ngx_array_t *predicates ) ;
#line 197 "src/event/ngx_event.h"
ngx_event_actions_t ngx_event_actions ;
#line 199
ngx_uint_t ngx_use_epoll_rdhup ;
#line 496
ngx_uint_t ngx_event_flags ;
#line 45 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_events ;
#line 74 "src/event/ngx_event_connect.h"
ngx_int_t ngx_event_connect_peer(ngx_peer_connection_t *pc ) ;
#line 102 "src/event/ngx_event_pipe.h"
ngx_int_t ngx_event_pipe(ngx_event_pipe_t *p , ngx_int_t do_write ) ;
#line 515 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_named_location(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 518
ngx_http_cleanup_t *ngx_http_cleanup_add(ngx_http_request_t *r , size_t___0 size ) ;
#line 546
ngx_str_t ngx_http_core_get_method ;
#line 104 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers , ngx_str_t *name ,
                                          ngx_str_t *value ) ;
#line 127
void ngx_http_request_empty_handler(ngx_http_request_t *r ) ;
#line 133
ngx_int_t ngx_http_send_special(ngx_http_request_t *r , ngx_uint_t flags ) ;
#line 138
ngx_int_t ngx_http_read_unbuffered_request_body(ngx_http_request_t *r ) ;
#line 14 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 16
static ngx_int_t ngx_http_upstream_cache_get(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_file_cache_t **cache ) ;
#line 18
static ngx_int_t ngx_http_upstream_cache_send(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 20
static ngx_int_t ngx_http_upstream_cache_background_update(ngx_http_request_t *r ,
                                                           ngx_http_upstream_t *u ) ;
#line 22
static ngx_int_t ngx_http_upstream_cache_check_range(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 24
static ngx_int_t ngx_http_upstream_cache_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 26
static ngx_int_t ngx_http_upstream_cache_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 28
static ngx_int_t ngx_http_upstream_cache_etag(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 32
static void ngx_http_upstream_init_request(ngx_http_request_t *r ) ;
#line 33
static void ngx_http_upstream_resolve_handler(ngx_resolver_ctx_t *ctx ) ;
#line 34
static void ngx_http_upstream_rd_check_broken_connection(ngx_http_request_t *r ) ;
#line 35
static void ngx_http_upstream_wr_check_broken_connection(ngx_http_request_t *r ) ;
#line 36
static void ngx_http_upstream_check_broken_connection(ngx_http_request_t *r , ngx_event_t *ev ) ;
#line 38
static void ngx_http_upstream_connect(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 40
static ngx_int_t ngx_http_upstream_reinit(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 42
static void ngx_http_upstream_send_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                           ngx_uint_t do_write ) ;
#line 44
static ngx_int_t ngx_http_upstream_send_request_body(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                                     ngx_uint_t do_write ) ;
#line 46
static void ngx_http_upstream_send_request_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 48
static void ngx_http_upstream_read_request_handler(ngx_http_request_t *r ) ;
#line 49
static void ngx_http_upstream_process_header(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 51
static ngx_int_t ngx_http_upstream_test_next(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 53
static ngx_int_t ngx_http_upstream_intercept_errors(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 55
static ngx_int_t ngx_http_upstream_test_connect(ngx_connection_t *c ) ;
#line 56
static ngx_int_t ngx_http_upstream_process_headers(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 58
static void ngx_http_upstream_process_body_in_memory(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 60
static void ngx_http_upstream_send_response(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 62
static void ngx_http_upstream_upgrade(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 64
static void ngx_http_upstream_upgraded_read_downstream(ngx_http_request_t *r ) ;
#line 65
static void ngx_http_upstream_upgraded_write_downstream(ngx_http_request_t *r ) ;
#line 66
static void ngx_http_upstream_upgraded_read_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 68
static void ngx_http_upstream_upgraded_write_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 70
static void ngx_http_upstream_process_upgraded(ngx_http_request_t *r , ngx_uint_t from_upstream ,
                                               ngx_uint_t do_write ) ;
#line 72
static void ngx_http_upstream_process_non_buffered_downstream(ngx_http_request_t *r ) ;
#line 74
static void ngx_http_upstream_process_non_buffered_upstream(ngx_http_request_t *r ,
                                                            ngx_http_upstream_t *u ) ;
#line 77
static void ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r ,
                                                           ngx_uint_t do_write ) ;
#line 80
static ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data ) ;
#line 81
static ngx_int_t ngx_http_upstream_non_buffered_filter(void *data , ssize_t bytes ) ;
#line 88
static ngx_int_t ngx_http_upstream_output_filter(void *data , ngx_chain_t *chain ) ;
#line 90
static void ngx_http_upstream_process_downstream(ngx_http_request_t *r ) ;
#line 91
static void ngx_http_upstream_process_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 93
static void ngx_http_upstream_process_request(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 95
static void ngx_http_upstream_store(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 97
static void ngx_http_upstream_dummy_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 99
static void ngx_http_upstream_next(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                   ngx_uint_t ft_type ) ;
#line 101
static void ngx_http_upstream_cleanup(void *data ) ;
#line 102
static void ngx_http_upstream_finalize_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                               ngx_int_t rc ) ;
#line 105
static ngx_int_t ngx_http_upstream_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                       ngx_uint_t offset ) ;
#line 107
static ngx_int_t ngx_http_upstream_process_content_length(ngx_http_request_t *r ,
                                                          ngx_table_elt_t *h , ngx_uint_t offset ) ;
#line 109
static ngx_int_t ngx_http_upstream_process_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 111
static ngx_int_t ngx_http_upstream_process_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 113
static ngx_int_t ngx_http_upstream_process_cache_control(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 116
static ngx_int_t ngx_http_upstream_ignore_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 118
static ngx_int_t ngx_http_upstream_process_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) ;
#line 120
static ngx_int_t ngx_http_upstream_process_accel_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 122
static ngx_int_t ngx_http_upstream_process_limit_rate(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 124
static ngx_int_t ngx_http_upstream_process_buffering(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 126
static ngx_int_t ngx_http_upstream_process_charset(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) ;
#line 128
static ngx_int_t ngx_http_upstream_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 130
static ngx_int_t ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r ,
                                                             ngx_table_elt_t *h ,
                                                             ngx_uint_t offset ) ;
#line 133
static ngx_int_t ngx_http_upstream_process_vary(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                ngx_uint_t offset ) ;
#line 135
static ngx_int_t ngx_http_upstream_copy_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) ;
#line 137
static ngx_int_t ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r ,
                                                           ngx_table_elt_t *h , ngx_uint_t offset ) ;
#line 140
static ngx_int_t ngx_http_upstream_copy_content_type(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 142
static ngx_int_t ngx_http_upstream_copy_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 144
static ngx_int_t ngx_http_upstream_rewrite_location(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) ;
#line 146
static ngx_int_t ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) ;
#line 148
static ngx_int_t ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 150
static ngx_int_t ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 154
static ngx_int_t ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 158
static ngx_int_t ngx_http_upstream_add_variables(ngx_conf_t *cf ) ;
#line 159
static ngx_int_t ngx_http_upstream_addr_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 161
static ngx_int_t ngx_http_upstream_status_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 163
static ngx_int_t ngx_http_upstream_response_time_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) ;
#line 165
static ngx_int_t ngx_http_upstream_response_length_variable(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ) ;
#line 167
static ngx_int_t ngx_http_upstream_header_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 169
static ngx_int_t ngx_http_upstream_cookie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 172
static char *ngx_http_upstream(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) ;
#line 173
static char *ngx_http_upstream_server(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 176
static ngx_int_t ngx_http_upstream_set_local(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_upstream_local_t *local ) ;
#line 179
static void *ngx_http_upstream_create_main_conf(ngx_conf_t *cf ) ;
#line 180
static char *ngx_http_upstream_init_main_conf(ngx_conf_t *cf , void *conf ) ;
#line 193 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_http_upstream_header_t ngx_http_upstream_headers_in[28]  = 
#line 193
  {      {{sizeof("Status") - 1UL, (u_char *)"Status"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->status), & ngx_http_upstream_copy_header_line,
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Content-Type") - 1UL, (u_char *)"Content-Type"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->content_type), & ngx_http_upstream_copy_content_type,
      (ngx_uint_t )0, (ngx_uint_t )1}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, & ngx_http_upstream_process_content_length,
      (ngx_uint_t )0, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Date") - 1UL,
       (u_char *)"Date"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->date),
      & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->date),
      (ngx_uint_t )0}, 
        {{sizeof("Last-Modified") - 1UL, (u_char *)"Last-Modified"}, & ngx_http_upstream_process_last_modified,
      (ngx_uint_t )0, & ngx_http_upstream_copy_last_modified, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("ETag") - 1UL,
       (u_char *)"ETag"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->etag),
      & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->etag),
      (ngx_uint_t )0}, 
        {{sizeof("Server") - 1UL, (u_char *)"Server"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->server), & ngx_http_upstream_copy_header_line,
      (unsigned long )(& ((ngx_http_headers_out_t *)0)->server), (ngx_uint_t )0}, 
        {{sizeof("WWW-Authenticate") - 1UL, (u_char *)"WWW-Authenticate"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->www_authenticate),
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Location") - 1UL, (u_char *)"Location"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->location), & ngx_http_upstream_rewrite_location,
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Refresh") - 1UL, (u_char *)"Refresh"}, & ngx_http_upstream_ignore_header_line,
      (ngx_uint_t )0, & ngx_http_upstream_rewrite_refresh, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Set-Cookie") - 1UL,
       (u_char *)"Set-Cookie"}, & ngx_http_upstream_process_set_cookie, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->cookies),
      & ngx_http_upstream_rewrite_set_cookie, (ngx_uint_t )0, (ngx_uint_t )1}, 
        {{sizeof("Content-Disposition") - 1UL, (u_char *)"Content-Disposition"}, & ngx_http_upstream_ignore_header_line,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )1}, 
        {{sizeof("Cache-Control") - 1UL,
       (u_char *)"Cache-Control"}, & ngx_http_upstream_process_cache_control, (ngx_uint_t )0,
      & ngx_http_upstream_copy_multi_header_lines, (unsigned long )(& ((ngx_http_headers_out_t *)0)->cache_control),
      (ngx_uint_t )1}, 
        {{sizeof("Expires") - 1UL, (u_char *)"Expires"}, & ngx_http_upstream_process_expires,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->expires),
      (ngx_uint_t )1}, 
        {{sizeof("Accept-Ranges") - 1UL, (u_char *)"Accept-Ranges"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->accept_ranges), & ngx_http_upstream_copy_allow_ranges,
      (unsigned long )(& ((ngx_http_headers_out_t *)0)->accept_ranges), (ngx_uint_t )1}, 
        {{sizeof("Content-Range") - 1UL,
       (u_char *)"Content-Range"}, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0,
      & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->content_range),
      (ngx_uint_t )0}, 
        {{sizeof("Connection") - 1UL, (u_char *)"Connection"}, & ngx_http_upstream_process_connection,
      (ngx_uint_t )0, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Keep-Alive") - 1UL,
       (u_char *)"Keep-Alive"}, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0,
      & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Vary") - 1UL, (u_char *)"Vary"}, & ngx_http_upstream_process_vary,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Powered-By") - 1UL,
       (u_char *)"X-Powered-By"}, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0,
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, & ngx_http_upstream_process_accel_expires,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Redirect") - 1UL,
       (u_char *)"X-Accel-Redirect"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->x_accel_redirect),
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, & ngx_http_upstream_process_limit_rate,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Buffering") - 1UL,
       (u_char *)"X-Accel-Buffering"}, & ngx_http_upstream_process_buffering, (ngx_uint_t )0,
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, & ngx_http_upstream_process_charset,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Transfer-Encoding") - 1UL,
       (u_char *)"Transfer-Encoding"}, & ngx_http_upstream_process_transfer_encoding,
      (ngx_uint_t )0, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Content-Encoding") - 1UL,
       (u_char *)"Content-Encoding"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->content_encoding),
      & ngx_http_upstream_copy_content_encoding, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                              ngx_table_elt_t *h ,
                                                              ngx_uint_t offset ))((void *)0),
      (ngx_uint_t )0, (ngx_int_t (*)(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                     ngx_uint_t offset ))((void *)0), (ngx_uint_t )0,
      (ngx_uint_t )0}};
#line 327 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_command_t ngx_http_upstream_commands[3]  = {      {{sizeof("upstream") - 1UL, (u_char *)"upstream"}, (ngx_uint_t )33554690, & ngx_http_upstream,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("server") - 1UL, (u_char *)"server"}, (ngx_uint_t )268437504, & ngx_http_upstream_server,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 347 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_http_module_t ngx_http_upstream_module_ctx  = 
#line 347
     {& ngx_http_upstream_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_upstream_create_main_conf, & ngx_http_upstream_init_main_conf, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 362 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
ngx_module_t ngx_http_upstream_module  = 
#line 362
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_module_ctx),
    ngx_http_upstream_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 378 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_http_variable_t ngx_http_upstream_vars[13]  = 
#line 378
  {      {{sizeof("upstream_addr") - 1UL, (u_char *)"upstream_addr"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_upstream_addr_variable, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_status") - 1UL,
       (u_char *)"upstream_status"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ))((void *)0), & ngx_http_upstream_status_variable,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_connect_time") - 1UL, (u_char *)"upstream_connect_time"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_time_variable, (uintptr_t )2, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_header_time") - 1UL,
       (u_char *)"upstream_header_time"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_time_variable, (uintptr_t )1, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_response_time") - 1UL,
       (u_char *)"upstream_response_time"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_time_variable, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_response_length") - 1UL,
       (u_char *)"upstream_response_length"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_length_variable, (uintptr_t )0, (ngx_uint_t )2,
      (ngx_uint_t )0}, 
        {{sizeof("upstream_bytes_received") - 1UL, (u_char *)"upstream_bytes_received"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_length_variable, (uintptr_t )1, (ngx_uint_t )2,
      (ngx_uint_t )0}, 
        {{sizeof("upstream_cache_status") - 1UL, (u_char *)"upstream_cache_status"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_upstream_cache_status, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_cache_last_modified") - 1UL,
       (u_char *)"upstream_cache_last_modified"}, (void (*)(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ))((void *)0),
      & ngx_http_upstream_cache_last_modified, (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{sizeof("upstream_cache_etag") - 1UL,
       (u_char *)"upstream_cache_etag"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ))((void *)0), & ngx_http_upstream_cache_etag,
      (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{sizeof("upstream_http_") - 1UL, (u_char *)"upstream_http_"}, (void (*)(ngx_http_request_t *r ,
                                                                              ngx_http_variable_value_t *v ,
                                                                              uintptr_t data ))((void *)0),
      & ngx_http_upstream_header_variable, (uintptr_t )0, (ngx_uint_t )34, (ngx_uint_t )0}, 
        {{sizeof("upstream_cookie_") - 1UL,
       (u_char *)"upstream_cookie_"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ))((void *)0), & ngx_http_upstream_cookie_variable,
      (uintptr_t )0, (ngx_uint_t )34, (ngx_uint_t )0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                         uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 434 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_http_upstream_next_t ngx_http_upstream_next_errors[8]  = 
#line 434
  {      {(ngx_uint_t )500, (ngx_uint_t )16}, 
        {(ngx_uint_t )502, (ngx_uint_t )32}, 
        {(ngx_uint_t )503, (ngx_uint_t )64}, 
        {(ngx_uint_t )504, (ngx_uint_t )128}, 
        {(ngx_uint_t )403, (ngx_uint_t )256}, 
        {(ngx_uint_t )404, (ngx_uint_t )512}, 
        {(ngx_uint_t )429, (ngx_uint_t )1024}, 
        {(ngx_uint_t )0, (ngx_uint_t )0}};
#line 446 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
ngx_conf_bitmask_t ngx_http_upstream_cache_method_mask[4]  = {      {{sizeof("GET") - 1UL, (u_char *)"GET"}, (ngx_uint_t )2}, 
        {{sizeof("HEAD") - 1UL, (u_char *)"HEAD"}, (ngx_uint_t )4}, 
        {{sizeof("POST") - 1UL, (u_char *)"POST"}, (ngx_uint_t )8}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 454 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
ngx_conf_bitmask_t ngx_http_upstream_ignore_headers_masks[10]  = 
#line 454
  {      {{sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, (ngx_uint_t )2}, 
        {{sizeof("X-Accel-Expires") - 1UL,
       (u_char *)"X-Accel-Expires"}, (ngx_uint_t )4}, 
        {{sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, (ngx_uint_t )64}, 
        {{sizeof("X-Accel-Buffering") - 1UL,
       (u_char *)"X-Accel-Buffering"}, (ngx_uint_t )128}, 
        {{sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, (ngx_uint_t )256}, 
        {{sizeof("Expires") - 1UL,
       (u_char *)"Expires"}, (ngx_uint_t )8}, 
        {{sizeof("Cache-Control") - 1UL, (u_char *)"Cache-Control"}, (ngx_uint_t )16}, 
        {{sizeof("Set-Cookie") - 1UL,
       (u_char *)"Set-Cookie"}, (ngx_uint_t )32}, 
        {{sizeof("Vary") - 1UL, (u_char *)"Vary"}, (ngx_uint_t )512}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 468 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
ngx_int_t ngx_http_upstream_create(ngx_http_request_t *r ) 
{ 
  ngx_http_upstream_t *u ;
  void *tmp ;

  {
#line 473
  u = r->upstream;
#line 475
  if (u) {
#line 475
    if (u->cleanup) {
      {
#line 476
      ((r->main)->count) ++;
#line 477
      ngx_http_upstream_cleanup((void *)r);
      }
    }
  }
  {
#line 480
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_t ));
#line 480
  u = (ngx_http_upstream_t *)tmp;
  }
#line 481
  if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 482
    return ((ngx_int_t )-1);
  }
#line 485
  r->upstream = u;
#line 487
  u->peer.log = (r->connection)->log;
#line 488
  u->peer.log_error = 1U;
#line 491
  r->cache = (ngx_http_cache_t *)((void *)0);
#line 494
  u->headers_in.content_length_n = (off_t )-1;
#line 495
  u->headers_in.last_modified_time = (time_t )-1;
#line 497
  return ((ngx_int_t )0);
}
}
#line 501 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
void ngx_http_upstream_init(ngx_http_request_t *r ) 
{ 
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
#line 506
  c = r->connection;
#line 518
  if ((c->read)->timer_set) {
    {
#line 519
    ngx_event_del_timer(c->read);
    }
  }
#line 522
  if (ngx_event_flags & 4UL) {
#line 524
    if (! (c->write)->active) {
      {
#line 525
      tmp = (*(ngx_event_actions.add))(c->write, (ngx_int_t )4, (ngx_uint_t )2147483648U);
      }
#line 525
      if (tmp == -1L) {
        {
#line 528
        ngx_http_finalize_request(r, (ngx_int_t )500);
        }
#line 529
        return;
      }
    }
  }
  {
#line 534
  ngx_http_upstream_init_request(r);
  }
#line 535
  return;
}
}
#line 538 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_init_request(ngx_http_request_t *r ) 
{ 
  ngx_str_t *host ;
  ngx_uint_t i ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t temp ;
  ngx_http_cleanup_t *cln ;
  ngx_http_upstream_t *u ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_http_upstream_main_conf_t *umcf ;
  ngx_int_t rc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;

  {
#line 550
  if (r->aio) {
#line 551
    return;
  }
#line 554
  u = r->upstream;
#line 558
  if ((u->conf)->cache) {
    {
#line 561
    rc = ngx_http_upstream_cache(r, u);
    }
#line 563
    if (rc == -3L) {
#line 564
      r->write_event_handler = & ngx_http_upstream_init_request;
#line 565
      return;
    }
#line 568
    r->write_event_handler = & ngx_http_request_empty_handler;
#line 570
    if (rc == -1L) {
      {
#line 571
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
#line 572
      return;
    }
#line 575
    if (rc == 0L) {
      {
#line 576
      rc = ngx_http_upstream_cache_send(r, u);
      }
#line 578
      if (rc == -4L) {
#line 579
        return;
      }
#line 582
      if (rc == 40L) {
#line 583
        rc = (ngx_int_t )-5;
#line 584
        r->cached = 0U;
      }
      {
#line 587
      tmp = ngx_http_upstream_cache_background_update(r, u);
      }
#line 587
      if (tmp != 0L) {
#line 588
        rc = (ngx_int_t )-1;
      }
    }
#line 592
    if (rc != -5L) {
      {
#line 593
      ngx_http_finalize_request(r, rc);
      }
#line 594
      return;
    }
  }
#line 600
  u->store = (unsigned int )(u->conf)->store;
#line 602
  if (! u->store) {
#line 602
    if (! r->post_action) {
#line 602
      if (! (u->conf)->ignore_client_abort) {
#line 603
        r->read_event_handler = & ngx_http_upstream_rd_check_broken_connection;
#line 604
        r->write_event_handler = & ngx_http_upstream_wr_check_broken_connection;
      }
    }
  }
#line 607
  if (r->request_body) {
#line 608
    u->request_bufs = (r->request_body)->bufs;
  }
  {
#line 611
  tmp___0 = (*(u->create_request))(r);
  }
#line 611
  if (tmp___0 != 0L) {
    {
#line 612
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 613
    return;
  }
  {
#line 616
  tmp___1 = ngx_http_upstream_set_local(r, u, (u->conf)->local);
  }
#line 616
  if (tmp___1 != 0L) {
    {
#line 617
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 618
    return;
  }
#line 621
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 623
  u->output.alignment = clcf->directio_alignment;
#line 624
  u->output.pool = r->pool;
#line 625
  u->output.bufs.num = (ngx_int_t )1;
#line 626
  u->output.bufs.size = clcf->client_body_buffer_size;
#line 628
  if ((unsigned long )u->output.output_filter == (unsigned long )((void *)0)) {
#line 629
    u->output.output_filter = & ngx_chain_writer;
#line 630
    u->output.filter_ctx = (void *)(& u->writer);
  }
#line 633
  u->writer.pool = r->pool;
#line 635
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
    {
#line 637
    r->upstream_states = ngx_array_create(r->pool, (ngx_uint_t )1, sizeof(ngx_http_upstream_state_t ));
    }
#line 639
    if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
      {
#line 640
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
#line 641
      return;
    }
  } else {
    {
#line 646
    tmp___2 = ngx_array_push(r->upstream_states);
#line 646
    u->state = (ngx_http_upstream_state_t *)tmp___2;
    }
#line 647
    if ((unsigned long )u->state == (unsigned long )((void *)0)) {
      {
#line 648
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 650
      return;
    }
    {
#line 653
    memset((void *)u->state, 0, sizeof(ngx_http_upstream_state_t ));
    }
  }
  {
#line 656
  cln = ngx_http_cleanup_add(r, (size_t___0 )0);
  }
#line 657
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
    {
#line 658
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 659
    return;
  }
#line 662
  cln->handler = & ngx_http_upstream_cleanup;
#line 663
  cln->data = (void *)r;
#line 664
  u->cleanup = & cln->handler;
#line 666
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 668
    uscf = (u->conf)->upstream;
  } else {
#line 676
    host = & (u->resolved)->host;
#line 678
    umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
#line 680
    uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 682
    i = (ngx_uint_t )0;
    {
#line 682
    while (1) {
      while_continue: /* CIL Label */ ;
#line 682
      if (! (i < umcf->upstreams.nelts)) {
#line 682
        goto while_break;
      }
#line 684
      uscf = *(uscfp + i);
#line 686
      if (uscf->host.len == host->len) {
#line 686
        if ((int )uscf->port == 0) {
#line 686
          if ((u->resolved)->no_port) {
#line 686
            goto _L;
          } else {
#line 686
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 686
        if ((int )uscf->port == (int )(u->resolved)->port) {
          _L: /* CIL Label */ 
          {
#line 686
          tmp___3 = ngx_strncasecmp(uscf->host.data, host->data, host->len);
          }
#line 686
          if (tmp___3 == 0L) {
#line 691
            goto found;
          }
        }
      }
#line 682
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 695
    if ((u->resolved)->sockaddr) {
#line 697
      if ((int )(u->resolved)->port == 0) {
#line 697
        if ((int )((u->resolved)->sockaddr)->sa_family != 1) {
#line 700
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 700
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no port in upstream \"%V\"",
                               host);
            }
          }
          {
#line 702
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
          }
#line 704
          return;
        }
      }
      {
#line 707
      tmp___4 = ngx_http_upstream_create_round_robin_peer(r, u->resolved);
      }
#line 707
      if (tmp___4 != 0L) {
        {
#line 710
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 712
        return;
      }
      {
#line 715
      ngx_http_upstream_connect(r, u);
      }
#line 717
      return;
    }
#line 720
    if ((int )(u->resolved)->port == 0) {
#line 721
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 721
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no port in upstream \"%V\"",
                           host);
        }
      }
      {
#line 723
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 725
      return;
    }
    {
#line 728
    temp.name = *host;
#line 730
    ctx = ngx_resolve_start(clcf->resolver, & temp);
    }
#line 731
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
      {
#line 732
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 734
      return;
    }
#line 737
    if ((unsigned long )ctx == (unsigned long )((void *)-1)) {
#line 738
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 738
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no resolver defined to resolve %V",
                           host);
        }
      }
      {
#line 741
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
      }
#line 742
      return;
    }
    {
#line 745
    ctx->name = *host;
#line 746
    ctx->handler = & ngx_http_upstream_resolve_handler;
#line 747
    ctx->data = (void *)r;
#line 748
    ctx->timeout = clcf->resolver_timeout;
#line 750
    (u->resolved)->ctx = ctx;
#line 752
    tmp___5 = ngx_resolve_name(ctx);
    }
#line 752
    if (tmp___5 != 0L) {
      {
#line 753
      (u->resolved)->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 754
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 756
      return;
    }
#line 759
    return;
  }
  found: 
#line 764
  if ((unsigned long )uscf == (unsigned long )((void *)0)) {
#line 765
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 765
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "no upstream configuration");
      }
    }
    {
#line 767
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 769
    return;
  }
  {
#line 772
  u->upstream = uscf;
#line 778
  tmp___6 = (*(uscf->peer.init))(r, uscf);
  }
#line 778
  if (tmp___6 != 0L) {
    {
#line 779
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 781
    return;
  }
#line 784
  u->peer.start_time = (ngx_msec_t )ngx_current_msec;
#line 786
  if ((u->conf)->next_upstream_tries) {
#line 786
    if (u->peer.tries > (u->conf)->next_upstream_tries) {
#line 789
      u->peer.tries = (u->conf)->next_upstream_tries;
    }
  }
  {
#line 792
  ngx_http_upstream_connect(r, u);
  }
#line 793
  return;
}
}
#line 798 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t rc ;
  ngx_http_cache_t *c ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 805
  c = r->cache;
#line 807
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 809
    if (! (r->method & (u->conf)->cache_methods)) {
#line 810
      return ((ngx_int_t )-5);
    }
    {
#line 813
    rc = ngx_http_upstream_cache_get(r, u, & cache);
    }
#line 815
    if (rc != 0L) {
#line 816
      return (rc);
    }
#line 819
    if (r->method == 4UL) {
#line 819
      if ((u->conf)->cache_convert_head) {
#line 820
        u->method = ngx_http_core_get_method;
      }
    }
    {
#line 823
    tmp = ngx_http_file_cache_new(r);
    }
#line 823
    if (tmp != 0L) {
#line 824
      return ((ngx_int_t )-1);
    }
    {
#line 827
    tmp___0 = (*(u->create_key))(r);
    }
#line 827
    if (tmp___0 != 0L) {
#line 828
      return ((ngx_int_t )-1);
    }
    {
#line 833
    ngx_http_file_cache_create_key(r);
    }
#line 835
    if ((r->cache)->header_start + 256UL >= (u->conf)->buffer_size) {
#line 836
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 836
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%V_buffer_size %uz is not enough for cache key, it should be increased to at least %uz",
                           & (u->conf)->module, (u->conf)->buffer_size, (((r->cache)->header_start + 256UL) + 1023UL) & 0xfffffffffffffc00UL);
        }
      }
#line 842
      r->cache = (ngx_http_cache_t *)((void *)0);
#line 843
      return ((ngx_int_t )-5);
    }
    {
#line 846
    u->cacheable = 1U;
#line 848
    c = r->cache;
#line 850
    c->body_start = (u->conf)->buffer_size;
#line 851
    c->min_uses = (u->conf)->cache_min_uses;
#line 852
    c->file_cache = cache;
#line 854
    tmp___1 = ngx_http_test_predicates(r, (u->conf)->cache_bypass);
    }
    {
#line 856
    if (tmp___1 == -1L) {
#line 856
      goto case_neg_1;
    }
#line 859
    if (tmp___1 == -5L) {
#line 859
      goto case_neg_5;
    }
#line 863
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 857
    return ((ngx_int_t )-1);
    case_neg_5: /* CIL Label */ 
#line 860
    u->cache_status = 2U;
#line 861
    return ((ngx_int_t )-5);
    switch_default: /* CIL Label */ 
#line 864
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 867
    c->lock = (unsigned int )(u->conf)->cache_lock;
#line 868
    c->lock_timeout = (u->conf)->cache_lock_timeout;
#line 869
    c->lock_age = (u->conf)->cache_lock_age;
#line 871
    u->cache_status = 1U;
  }
  {
#line 874
  rc = ngx_http_file_cache_open(r);
  }
  {
#line 881
  if (rc == 4L) {
#line 881
    goto case_4;
  }
#line 894
  if (rc == 5L) {
#line 894
    goto case_5;
  }
#line 908
  if (rc == 0L) {
#line 908
    goto case_0;
  }
#line 879
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 883
  if ((u->conf)->cache_use_stale & 2048UL) {
#line 883
    goto _L;
  } else
#line 883
  if (c->stale_updating) {
    _L: /* CIL Label */ 
#line 883
    if (! r->background) {
#line 883
      if ((u->conf)->cache_background_update) {
#line 887
        (r->cache)->background = 1U;
#line 888
        u->cache_status = (unsigned int )rc;
#line 889
        rc = (ngx_int_t )0;
      }
    }
  }
#line 892
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 896
  if ((u->conf)->cache_use_stale & 2048UL) {
#line 896
    goto _L___0;
  } else
#line 896
  if (c->stale_updating) {
    _L___0: /* CIL Label */ 
#line 896
    if (! r->background) {
#line 899
      u->cache_status = (unsigned int )rc;
#line 900
      rc = (ngx_int_t )0;
    } else {
#line 903
      rc = (ngx_int_t )4;
    }
  } else {
#line 903
    rc = (ngx_int_t )4;
  }
#line 906
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 909
  u->cache_status = 7U;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 914
  if (rc == 0L) {
#line 914
    goto case_0___0;
  }
#line 918
  if (rc == 4L) {
#line 918
    goto case_4___0;
  }
#line 929
  if (rc == -5L) {
#line 929
    goto case_neg_5___0;
  }
#line 941
  if (rc == 8L) {
#line 941
    goto case_8;
  }
#line 947
  if (rc == -2L) {
#line 947
    goto case_neg_2;
  }
#line 951
  if (rc == -1L) {
#line 951
    goto case_neg_1___0;
  }
#line 955
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 916
  return ((ngx_int_t )0);
  case_4___0: /* CIL Label */ 
#line 920
  c->valid_sec = (time_t )0;
#line 921
  c->updating_sec = (time_t )0;
#line 922
  c->error_sec = (time_t )0;
#line 924
  u->buffer.start = (u_char *)((void *)0);
#line 925
  u->cache_status = 3U;
#line 927
  goto switch_break___1;
  case_neg_5___0: /* CIL Label */ 
#line 931
  if ((size_t___0 )(u->buffer.end - u->buffer.start) < (u->conf)->buffer_size) {
#line 932
    u->buffer.start = (u_char *)((void *)0);
  } else {
#line 935
    u->buffer.pos = u->buffer.start + c->header_start;
#line 936
    u->buffer.last = u->buffer.pos;
  }
#line 939
  goto switch_break___1;
  case_8: /* CIL Label */ 
#line 943
  u->cacheable = 0U;
#line 945
  goto switch_break___1;
  case_neg_2: /* CIL Label */ 
#line 949
  return ((ngx_int_t )-3);
  case_neg_1___0: /* CIL Label */ 
#line 953
  return ((ngx_int_t )-1);
  switch_default___0: /* CIL Label */ 
#line 959
  u->cache_status = 7U;
#line 961
  return (rc);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 964
  tmp___2 = ngx_http_upstream_cache_check_range(r, u);
  }
#line 964
  if (tmp___2 == -5L) {
#line 965
    u->cacheable = 0U;
  }
#line 968
  r->cached = 0U;
#line 970
  return ((ngx_int_t )-5);
}
}
#line 974 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_get(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_file_cache_t **cache ) 
{ 
  ngx_str_t *name ;
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_http_file_cache_t **caches ;
  ngx_int_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 982
  if ((u->conf)->cache_zone) {
#line 983
    *cache = (ngx_http_file_cache_t *)((u->conf)->cache_zone)->data;
#line 984
    return ((ngx_int_t )0);
  }
  {
#line 987
  tmp = ngx_http_complex_value(r, (u->conf)->cache_value, & val);
  }
#line 987
  if (tmp != 0L) {
#line 988
    return ((ngx_int_t )-1);
  }
#line 991
  if (val.len == 0UL) {
#line 994
    return ((ngx_int_t )-5);
  } else
#line 991
  if (val.len == 3UL) {
    {
#line 991
    tmp___0 = strncmp((char const   *)val.data, "off", (size_t )3);
    }
#line 991
    if (tmp___0 == 0) {
#line 994
      return ((ngx_int_t )-5);
    }
  }
#line 997
  caches = (ngx_http_file_cache_t **)(u->caches)->elts;
#line 999
  i = (ngx_uint_t )0;
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 999
    if (! (i < (u->caches)->nelts)) {
#line 999
      goto while_break;
    }
#line 1000
    name = & ((*(caches + i))->shm_zone)->shm.name;
#line 1002
    if (name->len == val.len) {
      {
#line 1002
      tmp___1 = strncmp((char const   *)name->data, (char const   *)val.data, val.len);
      }
#line 1002
      if (tmp___1 == 0) {
#line 1005
        *cache = *(caches + i);
#line 1006
        return ((ngx_int_t )0);
      }
    }
#line 999
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1010
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 1010
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "cache \"%V\" not found",
                       & val);
    }
  }
#line 1013
  return ((ngx_int_t )-1);
}
}
#line 1017 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_send(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t rc ;
  ngx_http_cache_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1023
  r->cached = 1U;
#line 1024
  c = r->cache;
#line 1026
  if (c->header_start == c->body_start) {
    {
#line 1027
    r->http_version = (ngx_uint_t )9;
#line 1028
    tmp = ngx_http_cache_send(r);
    }
#line 1028
    return (tmp);
  }
  {
#line 1033
  u->buffer = *(c->buf);
#line 1034
  u->buffer.pos += c->header_start;
#line 1036
  memset((void *)(& u->headers_in), 0, sizeof(ngx_http_upstream_headers_in_t ));
#line 1037
  u->headers_in.content_length_n = (off_t )-1;
#line 1038
  u->headers_in.last_modified_time = (time_t )-1;
#line 1040
  tmp___0 = ngx_list_init(& u->headers_in.headers, r->pool, (ngx_uint_t )8, sizeof(ngx_table_elt_t ));
  }
#line 1040
  if (tmp___0 != 0L) {
#line 1044
    return ((ngx_int_t )-1);
  }
  {
#line 1047
  rc = (*(u->process_header))(r);
  }
#line 1049
  if (rc == 0L) {
    {
#line 1051
    tmp___1 = ngx_http_upstream_process_headers(r, u);
    }
#line 1051
    if (tmp___1 != 0L) {
#line 1052
      return ((ngx_int_t )-4);
    }
    {
#line 1055
    tmp___2 = ngx_http_cache_send(r);
    }
#line 1055
    return (tmp___2);
  }
#line 1058
  if (rc == -1L) {
#line 1059
    return ((ngx_int_t )-1);
  }
#line 1066
  return (rc);
}
}
#line 1070 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_background_update(ngx_http_request_t *r ,
                                                           ngx_http_upstream_t *u ) 
{ 
  ngx_http_request_t *sr ;
  ngx_int_t tmp ;

  {
#line 1076
  if (! r->cached) {
#line 1077
    return ((ngx_int_t )0);
  } else
#line 1076
  if (! (r->cache)->background) {
#line 1077
    return ((ngx_int_t )0);
  }
  {
#line 1080
  tmp = ngx_http_subrequest(r, & r->uri, & r->args, & sr, (ngx_http_post_subrequest_t *)((void *)0),
                            (ngx_uint_t )24);
  }
#line 1080
  if (tmp != 0L) {
#line 1085
    return ((ngx_int_t )-1);
  }
#line 1088
  sr->header_only = 1U;
#line 1090
  return ((ngx_int_t )0);
}
}
#line 1094 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_check_range(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  off_t offset ;
  u_char *p ;
  u_char *start ;
  ngx_table_elt_t *h ;
  ngx_int_t tmp ;

  {
#line 1102
  h = r->headers_in.range;
#line 1104
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1108
    return ((ngx_int_t )0);
  } else
#line 1104
  if (! u->cacheable) {
#line 1108
    return ((ngx_int_t )0);
  } else
#line 1104
  if ((long long )(u->conf)->cache_max_range_offset == 9223372036854775807LL) {
#line 1108
    return ((ngx_int_t )0);
  }
#line 1111
  if ((u->conf)->cache_max_range_offset == 0L) {
#line 1112
    return ((ngx_int_t )-5);
  }
#line 1115
  if (h->value.len < 7UL) {
#line 1118
    return ((ngx_int_t )0);
  } else {
    {
#line 1115
    tmp = ngx_strncasecmp(h->value.data, (u_char *)"bytes=", (size_t___0 )6);
    }
#line 1115
    if (tmp != 0L) {
#line 1118
      return ((ngx_int_t )0);
    }
  }
#line 1121
  p = h->value.data + 6;
  {
#line 1123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1123
    if (! ((int )*p == 32)) {
#line 1123
      goto while_break;
    }
#line 1123
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1125
  if ((int )*p == 45) {
#line 1126
    return ((ngx_int_t )-5);
  }
#line 1129
  start = p;
  {
#line 1131
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1131
    if ((int )*p >= 48) {
#line 1131
      if (! ((int )*p <= 57)) {
#line 1131
        goto while_break___0;
      }
    } else {
#line 1131
      goto while_break___0;
    }
#line 1131
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1133
  offset = ngx_atoof(start, (size_t___0 )(p - start));
  }
#line 1135
  if (offset >= (u->conf)->cache_max_range_offset) {
#line 1136
    return ((ngx_int_t )-5);
  }
#line 1139
  return ((ngx_int_t )0);
}
}
#line 1145 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_resolve_handler(ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_uint_t run_posted ;
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;
  ngx_http_upstream_resolved_t *ur ;
  char *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1154
  run_posted = (ngx_uint_t )ctx->async;
#line 1156
  r = (ngx_http_request_t *)ctx->data;
#line 1157
  c = r->connection;
#line 1159
  u = r->upstream;
#line 1160
  ur = u->resolved;
#line 1162
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 1167
  if (ctx->state) {
#line 1168
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1168
      tmp = ngx_resolver_strerror(ctx->state);
#line 1168
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%V could not be resolved (%i: %s)",
                         & ctx->name, ctx->state, tmp);
      }
    }
    {
#line 1173
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
    }
#line 1174
    goto failed;
  }
  {
#line 1177
  ur->naddrs = ctx->naddrs;
#line 1178
  ur->addrs = ctx->addrs;
#line 1198
  tmp___0 = ngx_http_upstream_create_round_robin_peer(r, ur);
  }
#line 1198
  if (tmp___0 != 0L) {
    {
#line 1199
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 1201
    goto failed;
  }
  {
#line 1204
  ngx_resolve_name_done(ctx);
#line 1205
  ur->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 1207
  u->peer.start_time = (ngx_msec_t )ngx_current_msec;
  }
#line 1209
  if ((u->conf)->next_upstream_tries) {
#line 1209
    if (u->peer.tries > (u->conf)->next_upstream_tries) {
#line 1212
      u->peer.tries = (u->conf)->next_upstream_tries;
    }
  }
  {
#line 1215
  ngx_http_upstream_connect(r, u);
  }
  failed: 
#line 1219
  if (run_posted) {
    {
#line 1220
    ngx_http_run_posted_requests(c);
    }
  }
#line 1222
  return;
}
}
#line 1225 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_handler(ngx_event_t *ev ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;

  {
#line 1232
  c = (ngx_connection_t *)ev->data;
#line 1233
  r = (ngx_http_request_t *)c->data;
#line 1235
  u = r->upstream;
#line 1236
  c = r->connection;
#line 1238
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 1243
  if (ev->delayed) {
#line 1243
    if (ev->timedout) {
#line 1244
      ev->delayed = 0U;
#line 1245
      ev->timedout = 0U;
    }
  }
#line 1248
  if (ev->write) {
    {
#line 1249
    (*(u->write_event_handler))(r, u);
    }
  } else {
    {
#line 1252
    (*(u->read_event_handler))(r, u);
    }
  }
  {
#line 1255
  ngx_http_run_posted_requests(c);
  }
#line 1256
  return;
}
}
#line 1259 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_rd_check_broken_connection(ngx_http_request_t *r ) 
{ 


  {
  {
#line 1262
  ngx_http_upstream_check_broken_connection(r, (r->connection)->read);
  }
#line 1263
  return;
}
}
#line 1266 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_wr_check_broken_connection(ngx_http_request_t *r ) 
{ 


  {
  {
#line 1269
  ngx_http_upstream_check_broken_connection(r, (r->connection)->write);
  }
#line 1270
  return;
}
}
#line 1273 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_check_broken_connection(ngx_http_request_t *r , ngx_event_t *ev ) 
{ 
  int n ;
  char buf[1] ;
  ngx_err_t err ;
  ngx_int_t event ;
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  socklen_t len ;
  int *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 1288
  c = r->connection;
#line 1289
  u = r->upstream;
#line 1291
  if (c->error) {
#line 1292
    if (ngx_event_flags & 1UL) {
#line 1292
      if (ev->active) {
#line 1294
        if (ev->write) {
#line 1294
          event = (ngx_int_t )4;
        } else {
#line 1294
          event = (ngx_int_t )8193;
        }
        {
#line 1296
        tmp = (*(ngx_event_actions.del))(ev, event, (ngx_uint_t )0);
        }
#line 1296
        if (tmp != 0L) {
          {
#line 1297
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
          }
#line 1299
          return;
        }
      }
    }
#line 1303
    if (! u->cacheable) {
      {
#line 1304
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
      }
    }
#line 1308
    return;
  }
#line 1357
  if (ngx_event_flags & 64UL) {
#line 1357
    if (ngx_use_epoll_rdhup) {
#line 1360
      if (! ev->pending_eof) {
#line 1361
        return;
      }
      {
#line 1364
      ev->eof = 1U;
#line 1365
      c->error = 1U;
#line 1367
      err = 0;
#line 1368
      len = (socklen_t )sizeof(ngx_err_t );
#line 1375
      tmp___1 = getsockopt(c->fd, 1, 4, (void */* __restrict  */)((void *)(& err)),
                           (socklen_t */* __restrict  */)(& len));
      }
#line 1375
      if (tmp___1 == -1) {
        {
#line 1378
        tmp___0 = __errno_location();
#line 1378
        err = *tmp___0;
        }
      }
#line 1381
      if (err) {
#line 1382
        ev->error = 1U;
      }
#line 1385
      if (! u->cacheable) {
#line 1385
        if (u->peer.connection) {
#line 1386
          if ((ev->log)->log_level >= 7UL) {
            {
#line 1386
            ngx_log_error_core((ngx_uint_t )7, ev->log, err, "epoll_wait() reported that client prematurely closed connection, so upstream connection is closed too");
            }
          }
          {
#line 1389
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
          }
#line 1391
          return;
        }
      }
#line 1394
      if ((ev->log)->log_level >= 7UL) {
        {
#line 1394
        ngx_log_error_core((ngx_uint_t )7, ev->log, err, "epoll_wait() reported that client prematurely closed connection");
        }
      }
#line 1398
      if ((unsigned long )u->peer.connection == (unsigned long )((void *)0)) {
        {
#line 1399
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
        }
      }
#line 1403
      return;
    }
  }
  {
#line 1408
  tmp___2 = recv(c->fd, (void *)(buf), (size_t___0 )1, 2);
#line 1408
  n = (int )tmp___2;
#line 1410
  tmp___3 = __errno_location();
#line 1410
  err = *tmp___3;
  }
#line 1415
  if (ev->write) {
#line 1415
    if (n >= 0) {
#line 1416
      return;
    } else
#line 1415
    if (err == 11) {
#line 1416
      return;
    }
  }
#line 1419
  if (ngx_event_flags & 1UL) {
#line 1419
    if (ev->active) {
#line 1421
      if (ev->write) {
#line 1421
        event = (ngx_int_t )4;
      } else {
#line 1421
        event = (ngx_int_t )8193;
      }
      {
#line 1423
      tmp___4 = (*(ngx_event_actions.del))(ev, event, (ngx_uint_t )0);
      }
#line 1423
      if (tmp___4 != 0L) {
        {
#line 1424
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 1426
        return;
      }
    }
  }
#line 1430
  if (n > 0) {
#line 1431
    return;
  }
#line 1434
  if (n == -1) {
#line 1435
    if (err == 11) {
#line 1436
      return;
    }
#line 1439
    ev->error = 1U;
  } else {
#line 1442
    err = 0;
  }
#line 1445
  ev->eof = 1U;
#line 1446
  c->error = 1U;
#line 1448
  if (! u->cacheable) {
#line 1448
    if (u->peer.connection) {
#line 1449
      if ((ev->log)->log_level >= 7UL) {
        {
#line 1449
        ngx_log_error_core((ngx_uint_t )7, ev->log, err, "client prematurely closed connection, so upstream connection is closed too");
        }
      }
      {
#line 1452
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
      }
#line 1454
      return;
    }
  }
#line 1457
  if ((ev->log)->log_level >= 7UL) {
    {
#line 1457
    ngx_log_error_core((ngx_uint_t )7, ev->log, err, "client prematurely closed connection");
    }
  }
#line 1460
  if ((unsigned long )u->peer.connection == (unsigned long )((void *)0)) {
    {
#line 1461
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
    }
  }
#line 1464
  return;
}
}
#line 1467 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_connect(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1473
  ((r->connection)->log)->action = (char *)"connecting to upstream";
#line 1475
  if (u->state) {
#line 1475
    if ((u->state)->response_time) {
#line 1476
      (u->state)->response_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
    }
  }
  {
#line 1479
  tmp = ngx_array_push(r->upstream_states);
#line 1479
  u->state = (ngx_http_upstream_state_t *)tmp;
  }
#line 1480
  if ((unsigned long )u->state == (unsigned long )((void *)0)) {
    {
#line 1481
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 1483
    return;
  }
  {
#line 1486
  memset((void *)u->state, 0, sizeof(ngx_http_upstream_state_t ));
#line 1488
  (u->state)->response_time = (ngx_msec_t )ngx_current_msec;
#line 1489
  (u->state)->connect_time = (ngx_msec_t )-1;
#line 1490
  (u->state)->header_time = (ngx_msec_t )-1;
#line 1492
  rc = ngx_event_connect_peer(& u->peer);
  }
#line 1497
  if (rc == -1L) {
    {
#line 1498
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 1500
    return;
  }
#line 1503
  (u->state)->peer = u->peer.name;
#line 1505
  if (rc == -3L) {
#line 1506
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1506
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no live upstreams");
      }
    }
    {
#line 1507
    ngx_http_upstream_next(r, u, (ngx_uint_t )1073741824);
    }
#line 1508
    return;
  }
#line 1511
  if (rc == -5L) {
    {
#line 1512
    ngx_http_upstream_next(r, u, (ngx_uint_t )2);
    }
#line 1513
    return;
  }
#line 1518
  c = u->peer.connection;
#line 1520
  c->data = (void *)r;
#line 1522
  (c->write)->handler = & ngx_http_upstream_handler;
#line 1523
  (c->read)->handler = & ngx_http_upstream_handler;
#line 1525
  u->write_event_handler = & ngx_http_upstream_send_request_handler;
#line 1526
  u->read_event_handler = & ngx_http_upstream_process_header;
#line 1528
  c->sendfile &= (r->connection)->sendfile;
#line 1529
  u->output.sendfile = c->sendfile;
#line 1531
  if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
    {
#line 1535
    c->pool = ngx_create_pool((size_t___0 )128, (r->connection)->log);
    }
#line 1536
    if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
      {
#line 1537
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 1539
      return;
    }
  }
#line 1543
  c->log = (r->connection)->log;
#line 1544
  (c->pool)->log = c->log;
#line 1545
  (c->read)->log = c->log;
#line 1546
  (c->write)->log = c->log;
#line 1550
  u->writer.out = (ngx_chain_t *)((void *)0);
#line 1551
  u->writer.last = & u->writer.out;
#line 1552
  u->writer.connection = c;
#line 1553
  u->writer.limit = (off_t )0;
#line 1555
  if (u->request_sent) {
    {
#line 1556
    tmp___0 = ngx_http_upstream_reinit(r, u);
    }
#line 1556
    if (tmp___0 != 0L) {
      {
#line 1557
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 1559
      return;
    }
  }
#line 1563
  if (r->request_body) {
#line 1563
    if ((r->request_body)->buf) {
#line 1563
      if ((r->request_body)->temp_file) {
#line 1563
        if ((unsigned long )r == (unsigned long )r->main) {
          {
#line 1573
          u->output.free = ngx_alloc_chain_link(r->pool);
          }
#line 1574
          if ((unsigned long )u->output.free == (unsigned long )((void *)0)) {
            {
#line 1575
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
            }
#line 1577
            return;
          }
#line 1580
          (u->output.free)->buf = (r->request_body)->buf;
#line 1581
          (u->output.free)->next = (ngx_chain_t *)((void *)0);
#line 1582
          u->output.allocated = (ngx_int_t )1;
#line 1584
          ((r->request_body)->buf)->pos = ((r->request_body)->buf)->start;
#line 1585
          ((r->request_body)->buf)->last = ((r->request_body)->buf)->start;
#line 1586
          ((r->request_body)->buf)->tag = u->output.tag;
        }
      }
    }
  }
#line 1589
  u->request_sent = 0U;
#line 1590
  u->request_body_sent = 0U;
#line 1592
  if (rc == -2L) {
    {
#line 1593
    ngx_event_add_timer(c->write, (u->conf)->connect_timeout);
    }
#line 1594
    return;
  }
  {
#line 1606
  ngx_http_upstream_send_request(r, u, (ngx_uint_t )1);
  }
#line 1607
  return;
}
}
#line 1848 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_reinit(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  off_t file_pos ;
  ngx_chain_t *cl ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1854
  tmp = (*(u->reinit_request))(r);
  }
#line 1854
  if (tmp != 0L) {
#line 1855
    return ((ngx_int_t )-1);
  }
  {
#line 1858
  u->keepalive = 0U;
#line 1859
  u->upgrade = 0U;
#line 1861
  memset((void *)(& u->headers_in), 0, sizeof(ngx_http_upstream_headers_in_t ));
#line 1862
  u->headers_in.content_length_n = (off_t )-1;
#line 1863
  u->headers_in.last_modified_time = (time_t )-1;
#line 1865
  tmp___0 = ngx_list_init(& u->headers_in.headers, r->pool, (ngx_uint_t )8, sizeof(ngx_table_elt_t ));
  }
#line 1865
  if (tmp___0 != 0L) {
#line 1869
    return ((ngx_int_t )-1);
  }
#line 1874
  file_pos = (off_t )0;
#line 1876
  cl = u->request_bufs;
  {
#line 1876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1876
    if (! cl) {
#line 1876
      goto while_break;
    }
#line 1877
    (cl->buf)->pos = (cl->buf)->start;
#line 1881
    if ((cl->buf)->in_file) {
#line 1882
      (cl->buf)->file_pos = file_pos;
#line 1883
      file_pos = (cl->buf)->file_last;
    }
#line 1876
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1889
  if (r->request_body) {
#line 1889
    if ((r->request_body)->temp_file) {
#line 1889
      if ((unsigned long )r != (unsigned long )r->main) {
#line 1889
        if (u->output.buf) {
          {
#line 1892
          u->output.free = ngx_alloc_chain_link(r->pool);
          }
#line 1893
          if ((unsigned long )u->output.free == (unsigned long )((void *)0)) {
#line 1894
            return ((ngx_int_t )-1);
          }
#line 1897
          (u->output.free)->buf = u->output.buf;
#line 1898
          (u->output.free)->next = (ngx_chain_t *)((void *)0);
#line 1900
          (u->output.buf)->pos = (u->output.buf)->start;
#line 1901
          (u->output.buf)->last = (u->output.buf)->start;
        }
      }
    }
  }
#line 1904
  u->output.buf = (ngx_buf_t *)((void *)0);
#line 1905
  u->output.in = (ngx_chain_t *)((void *)0);
#line 1906
  u->output.busy = (ngx_chain_t *)((void *)0);
#line 1910
  u->buffer.pos = u->buffer.start;
#line 1914
  if (r->cache) {
#line 1915
    u->buffer.pos += (r->cache)->header_start;
  }
#line 1920
  u->buffer.last = u->buffer.pos;
#line 1922
  return ((ngx_int_t )0);
}
}
#line 1926 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_send_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                           ngx_uint_t do_write ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 1933
  c = u->peer.connection;
#line 1938
  if ((u->state)->connect_time == 0xffffffffffffffffUL) {
#line 1939
    (u->state)->connect_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
  }
#line 1942
  if (! u->request_sent) {
    {
#line 1942
    tmp = ngx_http_upstream_test_connect(c);
    }
#line 1942
    if (tmp != 0L) {
      {
#line 1943
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 1944
      return;
    }
  }
  {
#line 1947
  (c->log)->action = (char *)"sending request to upstream";
#line 1949
  rc = ngx_http_upstream_send_request_body(r, u, do_write);
  }
#line 1951
  if (rc == -1L) {
    {
#line 1952
    ngx_http_upstream_next(r, u, (ngx_uint_t )2);
    }
#line 1953
    return;
  }
#line 1956
  if (rc >= 300L) {
    {
#line 1957
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 1958
    return;
  }
#line 1961
  if (rc == -2L) {
#line 1962
    if (! (c->write)->ready) {
      {
#line 1963
      ngx_event_add_timer(c->write, (u->conf)->send_timeout);
      }
    } else
#line 1965
    if ((c->write)->timer_set) {
      {
#line 1966
      ngx_event_del_timer(c->write);
      }
    }
    {
#line 1969
    tmp___0 = ngx_handle_write_event(c->write, (u->conf)->send_lowat);
    }
#line 1969
    if (tmp___0 != 0L) {
      {
#line 1970
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 1972
      return;
    }
#line 1975
    return;
  }
#line 1980
  u->request_body_sent = 1U;
#line 1982
  if ((c->write)->timer_set) {
    {
#line 1983
    ngx_event_del_timer(c->write);
    }
  }
#line 1986
  if (c->tcp_nopush == 1U) {
    {
#line 1987
    tmp___2 = ngx_tcp_push(c->fd);
    }
#line 1987
    if (tmp___2 == -1) {
#line 1988
      if ((c->log)->log_level >= 3UL) {
        {
#line 1988
        tmp___1 = __errno_location();
#line 1988
        ngx_log_error_core((ngx_uint_t )3, c->log, *tmp___1, "setsockopt(!TCP_CORK) failed");
        }
      }
      {
#line 1990
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 1992
      return;
    }
#line 1995
    c->tcp_nopush = 0U;
  }
  {
#line 1998
  u->write_event_handler = & ngx_http_upstream_dummy_handler;
#line 2000
  tmp___3 = ngx_handle_write_event(c->write, (size_t___0 )0);
  }
#line 2000
  if (tmp___3 != 0L) {
    {
#line 2001
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 2003
    return;
  }
  {
#line 2006
  ngx_event_add_timer(c->read, (u->conf)->read_timeout);
  }
#line 2008
  if ((c->read)->ready) {
    {
#line 2009
    ngx_http_upstream_process_header(r, u);
    }
#line 2010
    return;
  }
#line 2012
  return;
}
}
#line 2015 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_send_request_body(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                                     ngx_uint_t do_write ) 
{ 
  ngx_int_t rc ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 2027
  if (! r->request_body_no_buffering) {
#line 2031
    if (! u->request_sent) {
#line 2032
      u->request_sent = 1U;
#line 2033
      out = u->request_bufs;
    } else {
#line 2036
      out = (ngx_chain_t *)((void *)0);
    }
    {
#line 2039
    tmp = ngx_output_chain(& u->output, out);
    }
#line 2039
    return (tmp);
  }
#line 2042
  if (! u->request_sent) {
#line 2043
    u->request_sent = 1U;
#line 2044
    out = u->request_bufs;
#line 2046
    if ((r->request_body)->bufs) {
#line 2047
      cl = out;
      {
#line 2047
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2047
        if (! cl->next) {
#line 2047
          goto while_break;
        }
#line 2047
        cl = out->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 2048
      cl->next = (r->request_body)->bufs;
#line 2049
      (r->request_body)->bufs = (ngx_chain_t *)((void *)0);
    }
#line 2052
    c = u->peer.connection;
#line 2053
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2055
    if (clcf->tcp_nodelay) {
      {
#line 2055
      tmp___0 = ngx_tcp_nodelay(c);
      }
#line 2055
      if (tmp___0 != 0L) {
#line 2056
        return ((ngx_int_t )-1);
      }
    }
#line 2059
    r->read_event_handler = & ngx_http_upstream_read_request_handler;
  } else {
#line 2062
    out = (ngx_chain_t *)((void *)0);
  }
  {
#line 2065
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2067
    if (do_write) {
      {
#line 2068
      rc = ngx_output_chain(& u->output, out);
      }
#line 2070
      if (rc == -1L) {
#line 2071
        return ((ngx_int_t )-1);
      }
      {
#line 2074
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2074
        if (! out) {
#line 2074
          goto while_break___1;
        }
#line 2075
        ln = out;
#line 2076
        out = out->next;
#line 2077
        ln->next = (r->pool)->chain;
#line 2077
        (r->pool)->chain = ln;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2080
      if (rc == 0L) {
#line 2080
        if (! r->reading_body) {
#line 2081
          goto while_break___0;
        }
      }
    }
#line 2085
    if (r->reading_body) {
      {
#line 2088
      rc = ngx_http_read_unbuffered_request_body(r);
      }
#line 2090
      if (rc >= 300L) {
#line 2091
        return (rc);
      }
#line 2094
      out = (r->request_body)->bufs;
#line 2095
      (r->request_body)->bufs = (ngx_chain_t *)((void *)0);
    }
#line 2100
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 2101
      rc = (ngx_int_t )-2;
#line 2102
      goto while_break___0;
    }
#line 2105
    do_write = (ngx_uint_t )1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2108
  if (! r->reading_body) {
#line 2109
    if (! u->store) {
#line 2109
      if (! r->post_action) {
#line 2109
        if (! (u->conf)->ignore_client_abort) {
#line 2110
          r->read_event_handler = & ngx_http_upstream_rd_check_broken_connection;
        }
      }
    }
  }
#line 2115
  return (rc);
}
}
#line 2119 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_send_request_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_connection_t *c ;

  {
#line 2125
  c = u->peer.connection;
#line 2130
  if ((c->write)->timedout) {
    {
#line 2131
    ngx_http_upstream_next(r, u, (ngx_uint_t )4);
    }
#line 2132
    return;
  }
#line 2144
  if (u->header_sent) {
    {
#line 2145
    u->write_event_handler = & ngx_http_upstream_dummy_handler;
#line 2147
    ngx_handle_write_event(c->write, (size_t___0 )0);
    }
#line 2149
    return;
  }
  {
#line 2152
  ngx_http_upstream_send_request(r, u, (ngx_uint_t )1);
  }
#line 2153
  return;
}
}
#line 2156 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_read_request_handler(ngx_http_request_t *r ) 
{ 
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;

  {
#line 2162
  c = r->connection;
#line 2163
  u = r->upstream;
#line 2168
  if ((c->read)->timedout) {
    {
#line 2169
    c->timedout = 1U;
#line 2170
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )408);
    }
#line 2171
    return;
  }
  {
#line 2174
  ngx_http_upstream_send_request(r, u, (ngx_uint_t )0);
  }
#line 2175
  return;
}
}
#line 2178 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_header(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ssize_t n ;
  ngx_int_t rc ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;

  {
#line 2185
  c = u->peer.connection;
#line 2190
  (c->log)->action = (char *)"reading response header from upstream";
#line 2192
  if ((c->read)->timedout) {
    {
#line 2193
    ngx_http_upstream_next(r, u, (ngx_uint_t )4);
    }
#line 2194
    return;
  }
#line 2197
  if (! u->request_sent) {
    {
#line 2197
    tmp = ngx_http_upstream_test_connect(c);
    }
#line 2197
    if (tmp != 0L) {
      {
#line 2198
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 2199
      return;
    }
  }
#line 2202
  if ((unsigned long )u->buffer.start == (unsigned long )((void *)0)) {
    {
#line 2203
    tmp___0 = ngx_palloc(r->pool, (u->conf)->buffer_size);
#line 2203
    u->buffer.start = (u_char *)tmp___0;
    }
#line 2204
    if ((unsigned long )u->buffer.start == (unsigned long )((void *)0)) {
      {
#line 2205
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 2207
      return;
    }
    {
#line 2210
    u->buffer.pos = u->buffer.start;
#line 2211
    u->buffer.last = u->buffer.start;
#line 2212
    u->buffer.end = u->buffer.start + (u->conf)->buffer_size;
#line 2213
    u->buffer.temporary = 1U;
#line 2215
    u->buffer.tag = u->output.tag;
#line 2217
    tmp___1 = ngx_list_init(& u->headers_in.headers, r->pool, (ngx_uint_t )8, sizeof(ngx_table_elt_t ));
    }
#line 2217
    if (tmp___1 != 0L) {
      {
#line 2221
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 2223
      return;
    }
#line 2228
    if (r->cache) {
#line 2229
      u->buffer.pos += (r->cache)->header_start;
#line 2230
      u->buffer.last = u->buffer.pos;
    }
  }
  {
#line 2235
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2237
    n = (*(c->recv))(c, u->buffer.last, (size_t___0 )(u->buffer.end - u->buffer.last));
    }
#line 2239
    if (n == -2L) {
      {
#line 2244
      tmp___2 = ngx_handle_read_event(c->read, (ngx_uint_t )0);
      }
#line 2244
      if (tmp___2 != 0L) {
        {
#line 2245
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 2247
        return;
      }
#line 2250
      return;
    }
#line 2253
    if (n == 0L) {
#line 2254
      if ((c->log)->log_level >= 4UL) {
        {
#line 2254
        ngx_log_error_core((ngx_uint_t )4, c->log, 0, "upstream prematurely closed connection");
        }
      }
    }
#line 2258
    if (n == -1L) {
      {
#line 2259
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 2260
      return;
    } else
#line 2258
    if (n == 0L) {
      {
#line 2259
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 2260
      return;
    }
    {
#line 2263
    (u->state)->bytes_received += n;
#line 2265
    u->buffer.last += n;
#line 2273
    rc = (*(u->process_header))(r);
    }
#line 2275
    if (rc == -2L) {
#line 2277
      if ((unsigned long )u->buffer.last == (unsigned long )u->buffer.end) {
#line 2278
        if ((c->log)->log_level >= 4UL) {
          {
#line 2278
          ngx_log_error_core((ngx_uint_t )4, c->log, 0, "upstream sent too big header");
          }
        }
        {
#line 2281
        ngx_http_upstream_next(r, u, (ngx_uint_t )8);
        }
#line 2283
        return;
      }
#line 2286
      goto __Cont;
    }
#line 2289
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2292
  if (rc == 40L) {
    {
#line 2293
    ngx_http_upstream_next(r, u, (ngx_uint_t )8);
    }
#line 2294
    return;
  }
#line 2297
  if (rc == -1L) {
    {
#line 2298
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 2300
    return;
  }
#line 2305
  (u->state)->header_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
#line 2307
  if (u->headers_in.status_n >= 300UL) {
    {
#line 2309
    tmp___3 = ngx_http_upstream_test_next(r, u);
    }
#line 2309
    if (tmp___3 == 0L) {
#line 2310
      return;
    }
    {
#line 2313
    tmp___4 = ngx_http_upstream_intercept_errors(r, u);
    }
#line 2313
    if (tmp___4 == 0L) {
#line 2314
      return;
    }
  }
  {
#line 2318
  tmp___5 = ngx_http_upstream_process_headers(r, u);
  }
#line 2318
  if (tmp___5 != 0L) {
#line 2319
    return;
  }
#line 2322
  if (! r->subrequest_in_memory) {
    {
#line 2323
    ngx_http_upstream_send_response(r, u);
    }
#line 2324
    return;
  }
#line 2329
  if ((unsigned long )u->input_filter == (unsigned long )((void *)0)) {
#line 2330
    u->input_filter_init = & ngx_http_upstream_non_buffered_filter_init;
#line 2331
    u->input_filter = & ngx_http_upstream_non_buffered_filter;
#line 2332
    u->input_filter_ctx = (void *)r;
  }
  {
#line 2335
  tmp___6 = (*(u->input_filter_init))(u->input_filter_ctx);
  }
#line 2335
  if (tmp___6 == -1L) {
    {
#line 2336
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 2337
    return;
  }
#line 2340
  n = u->buffer.last - u->buffer.pos;
#line 2342
  if (n) {
    {
#line 2343
    u->buffer.last = u->buffer.pos;
#line 2345
    (u->state)->response_length += n;
#line 2347
    tmp___7 = (*(u->input_filter))(u->input_filter_ctx, n);
    }
#line 2347
    if (tmp___7 == -1L) {
      {
#line 2348
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2349
      return;
    }
  }
#line 2353
  if (u->length == 0L) {
    {
#line 2354
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
    }
#line 2355
    return;
  }
  {
#line 2358
  u->read_event_handler = & ngx_http_upstream_process_body_in_memory;
#line 2360
  ngx_http_upstream_process_body_in_memory(r, u);
  }
#line 2361
  return;
}
}
#line 2364 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_test_next(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_uint_t status ;
  ngx_http_upstream_next_t *un ;
  ngx_int_t rc ;
  time_t now ;
  time_t valid ;
  time_t updating ;
  time_t error ;
  ngx_int_t rc___0 ;

  {
#line 2370
  status = u->headers_in.status_n;
#line 2372
  un = ngx_http_upstream_next_errors;
  {
#line 2372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2372
    if (! un->status) {
#line 2372
      goto while_break;
    }
#line 2374
    if (status != un->status) {
#line 2375
      goto __Cont;
    }
#line 2378
    if (u->peer.tries > 1UL) {
#line 2378
      if ((u->conf)->next_upstream & un->mask) {
        {
#line 2379
        ngx_http_upstream_next(r, u, un->mask);
        }
#line 2380
        return ((ngx_int_t )0);
      }
    }
#line 2385
    if (u->cache_status == 3U) {
#line 2385
      if ((u->conf)->cache_use_stale & un->mask) {
#line 2385
        goto _L;
      } else
#line 2385
      if ((r->cache)->stale_error) {
        _L: /* CIL Label */ 
        {
#line 2390
        rc = (*(u->reinit_request))(r);
        }
#line 2392
        if (rc == 0L) {
          {
#line 2393
          u->cache_status = 4U;
#line 2394
          rc = ngx_http_upstream_cache_send(r, u);
          }
        }
        {
#line 2397
        ngx_http_upstream_finalize_request(r, u, rc);
        }
#line 2398
        return ((ngx_int_t )0);
      }
    }
    __Cont: /* CIL Label */ 
#line 2372
    un ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2406
  if (status == 304UL) {
#line 2406
    if (u->cache_status == 3U) {
#line 2406
      if ((u->conf)->cache_revalidate) {
        {
#line 2416
        now = (time_t )ngx_cached_time->sec;
#line 2418
        valid = (r->cache)->valid_sec;
#line 2419
        updating = (r->cache)->updating_sec;
#line 2420
        error = (r->cache)->error_sec;
#line 2422
        rc___0 = (*(u->reinit_request))(r);
        }
#line 2424
        if (rc___0 != 0L) {
          {
#line 2425
          ngx_http_upstream_finalize_request(r, u, rc___0);
          }
#line 2426
          return ((ngx_int_t )0);
        }
        {
#line 2429
        u->cache_status = 6U;
#line 2430
        rc___0 = ngx_http_upstream_cache_send(r, u);
        }
#line 2432
        if (valid == 0L) {
#line 2433
          valid = (r->cache)->valid_sec;
#line 2434
          updating = (r->cache)->updating_sec;
#line 2435
          error = (r->cache)->error_sec;
        }
#line 2438
        if (valid == 0L) {
          {
#line 2439
          valid = ngx_http_file_cache_valid((u->conf)->cache_valid, u->headers_in.status_n);
          }
#line 2441
          if (valid) {
#line 2442
            valid = now + valid;
          }
        }
#line 2446
        if (valid) {
          {
#line 2447
          (r->cache)->valid_sec = valid;
#line 2448
          (r->cache)->updating_sec = updating;
#line 2449
          (r->cache)->error_sec = error;
#line 2451
          (r->cache)->date = now;
#line 2453
          ngx_http_file_cache_update_header(r);
          }
        }
        {
#line 2456
        ngx_http_upstream_finalize_request(r, u, rc___0);
        }
#line 2457
        return ((ngx_int_t )0);
      }
    }
  }
#line 2462
  return ((ngx_int_t )-5);
}
}
#line 2466 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_intercept_errors(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t status ;
  ngx_uint_t i ;
  ngx_table_elt_t *h ;
  ngx_http_err_page_t *err_page ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  time_t valid ;

  {
#line 2476
  status = (ngx_int_t )u->headers_in.status_n;
#line 2478
  if (status == 404L) {
#line 2478
    if ((u->conf)->intercept_404) {
      {
#line 2479
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )404);
      }
#line 2480
      return ((ngx_int_t )0);
    }
  }
#line 2483
  if (! (u->conf)->intercept_errors) {
#line 2484
    return ((ngx_int_t )-5);
  }
#line 2487
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2489
  if ((unsigned long )clcf->error_pages == (unsigned long )((void *)0)) {
#line 2490
    return ((ngx_int_t )-5);
  }
#line 2493
  err_page = (ngx_http_err_page_t *)(clcf->error_pages)->elts;
#line 2494
  i = (ngx_uint_t )0;
  {
#line 2494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2494
    if (! (i < (clcf->error_pages)->nelts)) {
#line 2494
      goto while_break;
    }
#line 2496
    if ((err_page + i)->status == status) {
#line 2498
      if (status == 401L) {
#line 2498
        if (u->headers_in.www_authenticate) {
          {
#line 2501
          tmp = ngx_list_push(& r->headers_out.headers);
#line 2501
          h = (ngx_table_elt_t *)tmp;
          }
#line 2503
          if ((unsigned long )h == (unsigned long )((void *)0)) {
            {
#line 2504
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
            }
#line 2506
            return ((ngx_int_t )0);
          }
#line 2509
          *h = *(u->headers_in.www_authenticate);
#line 2511
          r->headers_out.www_authenticate = h;
        }
      }
#line 2516
      if (r->cache) {
        {
#line 2519
        valid = ngx_http_file_cache_valid((u->conf)->cache_valid, (ngx_uint_t )status);
        }
#line 2521
        if (valid) {
#line 2522
          (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )valid);
#line 2523
          (r->cache)->error = (ngx_uint_t )status;
        }
        {
#line 2526
        ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
        }
      }
      {
#line 2529
      ngx_http_upstream_finalize_request(r, u, status);
      }
#line 2531
      return ((ngx_int_t )0);
    }
#line 2494
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2535
  return ((ngx_int_t )-5);
}
}
#line 2539 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_test_connect(ngx_connection_t *c ) 
{ 
  int err ;
  socklen_t len ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 2565
  err = 0;
#line 2566
  len = (socklen_t )sizeof(int );
#line 2573
  tmp___0 = getsockopt(c->fd, 1, 4, (void */* __restrict  */)((void *)(& err)), (socklen_t */* __restrict  */)(& len));
  }
#line 2573
  if (tmp___0 == -1) {
    {
#line 2576
    tmp = __errno_location();
#line 2576
    err = *tmp;
    }
  }
#line 2579
  if (err) {
    {
#line 2580
    (c->log)->action = (char *)"connecting to upstream";
#line 2581
    ngx_connection_error(c, err, (char *)"connect() failed");
    }
#line 2582
    return ((ngx_int_t )-1);
  }
#line 2586
  return ((ngx_int_t )0);
}
}
#line 2590 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_headers(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_str_t uri___0 ;
  ngx_str_t args___0 ;
  ngx_uint_t i ;
  ngx_uint_t flags ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;

  {
#line 2600
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
#line 2602
  if (u->headers_in.x_accel_redirect) {
#line 2602
    if (! ((u->conf)->ignore_headers & 2UL)) {
      {
#line 2605
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-5);
#line 2607
      part = & u->headers_in.headers.part;
#line 2608
      h = (ngx_table_elt_t *)part->elts;
#line 2610
      i = (ngx_uint_t )0;
      }
      {
#line 2610
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2612
        if (i >= part->nelts) {
#line 2613
          if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 2614
            goto while_break;
          }
#line 2617
          part = part->next;
#line 2618
          h = (ngx_table_elt_t *)part->elts;
#line 2619
          i = (ngx_uint_t )0;
        }
        {
#line 2622
        tmp = ngx_hash_find(& umcf->headers_in_hash, (h + i)->hash, (h + i)->lowcase_key,
                            (h + i)->key.len);
#line 2622
        hh = (ngx_http_upstream_header_t *)tmp;
        }
#line 2625
        if (hh) {
#line 2625
          if (hh->redirect) {
            {
#line 2626
            tmp___0 = (*(hh->copy_handler))(r, h + i, hh->conf);
            }
#line 2626
            if (tmp___0 != 0L) {
              {
#line 2627
              ngx_http_finalize_request(r, (ngx_int_t )500);
              }
#line 2629
              return ((ngx_int_t )-4);
            }
          }
        }
#line 2610
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2634
      uri___0 = (u->headers_in.x_accel_redirect)->value;
#line 2636
      if ((int )*(uri___0.data + 0) == 64) {
        {
#line 2637
        ngx_http_named_location(r, & uri___0);
        }
      } else {
        {
#line 2640
        args___0.len = (size_t___0 )0;
#line 2640
        args___0.data = (u_char *)((void *)0);
#line 2641
        flags = (ngx_uint_t )1;
#line 2643
        tmp___1 = ngx_http_parse_unsafe_uri(r, & uri___0, & args___0, & flags);
        }
#line 2643
        if (tmp___1 != 0L) {
          {
#line 2644
          ngx_http_finalize_request(r, (ngx_int_t )404);
          }
#line 2645
          return ((ngx_int_t )-4);
        }
#line 2648
        if (r->method != 4UL) {
#line 2649
          r->method = (ngx_uint_t )2;
#line 2650
          r->method_name = ngx_http_core_get_method;
        }
        {
#line 2653
        ngx_http_internal_redirect(r, & uri___0, & args___0);
        }
      }
      {
#line 2656
      ngx_http_finalize_request(r, (ngx_int_t )-4);
      }
#line 2657
      return ((ngx_int_t )-4);
    }
  }
#line 2660
  part = & u->headers_in.headers.part;
#line 2661
  h = (ngx_table_elt_t *)part->elts;
#line 2663
  i = (ngx_uint_t )0;
  {
#line 2663
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2665
    if (i >= part->nelts) {
#line 2666
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 2667
        goto while_break___0;
      }
#line 2670
      part = part->next;
#line 2671
      h = (ngx_table_elt_t *)part->elts;
#line 2672
      i = (ngx_uint_t )0;
    }
    {
#line 2675
    tmp___2 = ngx_hash_find(& (u->conf)->hide_headers_hash, (h + i)->hash, (h + i)->lowcase_key,
                            (h + i)->key.len);
    }
#line 2675
    if (tmp___2) {
#line 2678
      goto __Cont;
    }
    {
#line 2681
    tmp___3 = ngx_hash_find(& umcf->headers_in_hash, (h + i)->hash, (h + i)->lowcase_key,
                            (h + i)->key.len);
#line 2681
    hh = (ngx_http_upstream_header_t *)tmp___3;
    }
#line 2684
    if (hh) {
      {
#line 2685
      tmp___4 = (*(hh->copy_handler))(r, h + i, hh->conf);
      }
#line 2685
      if (tmp___4 != 0L) {
        {
#line 2686
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 2688
        return ((ngx_int_t )-4);
      }
#line 2691
      goto __Cont;
    }
    {
#line 2694
    tmp___5 = ngx_http_upstream_copy_header_line(r, h + i, (ngx_uint_t )0);
    }
#line 2694
    if (tmp___5 != 0L) {
      {
#line 2695
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 2697
      return ((ngx_int_t )-4);
    }
    __Cont: /* CIL Label */ 
#line 2663
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2701
  if (r->headers_out.server) {
#line 2701
    if ((unsigned long )(r->headers_out.server)->value.data == (unsigned long )((void *)0)) {
#line 2702
      (r->headers_out.server)->hash = (ngx_uint_t )0;
    }
  }
#line 2705
  if (r->headers_out.date) {
#line 2705
    if ((unsigned long )(r->headers_out.date)->value.data == (unsigned long )((void *)0)) {
#line 2706
      (r->headers_out.date)->hash = (ngx_uint_t )0;
    }
  }
#line 2709
  r->headers_out.status = u->headers_in.status_n;
#line 2710
  r->headers_out.status_line = u->headers_in.status_line;
#line 2712
  r->headers_out.content_length_n = u->headers_in.content_length_n;
#line 2714
  r->disable_not_modified = (unsigned int )(! u->cacheable);
#line 2716
  if ((u->conf)->force_ranges) {
#line 2717
    r->allow_ranges = 1U;
#line 2718
    r->single_range = 1U;
#line 2721
    if (r->cached) {
#line 2722
      r->single_range = 0U;
    }
  }
#line 2727
  u->length = (off_t )-1;
#line 2729
  return ((ngx_int_t )0);
}
}
#line 2733 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_body_in_memory(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  size_t___0 size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 2743
  c = u->peer.connection;
#line 2744
  rev = c->read;
#line 2749
  if (rev->timedout) {
    {
#line 2750
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 2751
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 2752
    return;
  }
#line 2755
  b = & u->buffer;
  {
#line 2757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2759
    size = (size_t___0 )(b->end - b->last);
#line 2761
    if (size == 0UL) {
#line 2762
      if ((c->log)->log_level >= 2UL) {
        {
#line 2762
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "upstream buffer is too small to read response");
        }
      }
      {
#line 2764
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2765
      return;
    }
    {
#line 2768
    n = (*(c->recv))(c, b->last, size);
    }
#line 2770
    if (n == -2L) {
#line 2771
      goto while_break;
    }
#line 2774
    if (n == 0L) {
      {
#line 2775
      ngx_http_upstream_finalize_request(r, u, n);
      }
#line 2776
      return;
    } else
#line 2774
    if (n == -1L) {
      {
#line 2775
      ngx_http_upstream_finalize_request(r, u, n);
      }
#line 2776
      return;
    }
    {
#line 2779
    (u->state)->bytes_received += n;
#line 2780
    (u->state)->response_length += n;
#line 2782
    tmp = (*(u->input_filter))(u->input_filter_ctx, n);
    }
#line 2782
    if (tmp == -1L) {
      {
#line 2783
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2784
      return;
    }
#line 2787
    if (! rev->ready) {
#line 2788
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2792
  if (u->length == 0L) {
    {
#line 2793
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
    }
#line 2794
    return;
  }
  {
#line 2797
  tmp___0 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 2797
  if (tmp___0 != 0L) {
    {
#line 2798
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 2799
    return;
  }
#line 2802
  if (rev->active) {
    {
#line 2803
    ngx_event_add_timer(rev, (u->conf)->read_timeout);
    }
  } else
#line 2805
  if (rev->timer_set) {
    {
#line 2806
    ngx_event_del_timer(rev);
    }
  }
#line 2808
  return;
}
}
#line 2811 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_send_response(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ssize_t n ;
  ngx_int_t rc ;
  ngx_event_pipe_t *p ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  time_t now ;
  time_t valid ;
  ngx_int_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;

  {
  {
#line 2820
  rc = ngx_http_send_header(r);
  }
#line 2822
  if (rc == -1L) {
    {
#line 2823
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 2824
    return;
  } else
#line 2822
  if (rc > 0L) {
    {
#line 2823
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 2824
    return;
  } else
#line 2822
  if (r->post_action) {
    {
#line 2823
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 2824
    return;
  }
#line 2827
  u->header_sent = 1U;
#line 2829
  if (u->upgrade) {
#line 2833
    if (r->cache) {
      {
#line 2834
      ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
      }
    }
    {
#line 2839
    ngx_http_upstream_upgrade(r, u);
    }
#line 2840
    return;
  }
#line 2843
  c = r->connection;
#line 2845
  if (r->header_only) {
#line 2847
    if (! u->buffering) {
      {
#line 2848
      ngx_http_upstream_finalize_request(r, u, rc);
      }
#line 2849
      return;
    }
#line 2852
    if (! u->cacheable) {
#line 2852
      if (! u->store) {
        {
#line 2853
        ngx_http_upstream_finalize_request(r, u, rc);
        }
#line 2854
        return;
      }
    }
#line 2857
    (u->pipe)->downstream_error = 1U;
  }
#line 2860
  if (r->request_body) {
#line 2860
    if ((r->request_body)->temp_file) {
      {
#line 2861
      ngx_pool_run_cleanup_file(r->pool, ((r->request_body)->temp_file)->file.fd);
#line 2862
      ((r->request_body)->temp_file)->file.fd = -1;
      }
    }
  }
#line 2865
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2867
  if (! u->buffering) {
#line 2871
    if (r->cache) {
      {
#line 2872
      ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
      }
    }
#line 2877
    if ((unsigned long )u->input_filter == (unsigned long )((void *)0)) {
#line 2878
      u->input_filter_init = & ngx_http_upstream_non_buffered_filter_init;
#line 2879
      u->input_filter = & ngx_http_upstream_non_buffered_filter;
#line 2880
      u->input_filter_ctx = (void *)r;
    }
    {
#line 2883
    u->read_event_handler = & ngx_http_upstream_process_non_buffered_upstream;
#line 2884
    r->write_event_handler = & ngx_http_upstream_process_non_buffered_downstream;
#line 2887
    r->limit_rate = (size_t___0 )0;
#line 2889
    tmp = (*(u->input_filter_init))(u->input_filter_ctx);
    }
#line 2889
    if (tmp == -1L) {
      {
#line 2890
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2891
      return;
    }
#line 2894
    if (clcf->tcp_nodelay) {
      {
#line 2894
      tmp___0 = ngx_tcp_nodelay(c);
      }
#line 2894
      if (tmp___0 != 0L) {
        {
#line 2895
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 2896
        return;
      }
    }
#line 2899
    n = u->buffer.last - u->buffer.pos;
#line 2901
    if (n) {
      {
#line 2902
      u->buffer.last = u->buffer.pos;
#line 2904
      (u->state)->response_length += n;
#line 2906
      tmp___1 = (*(u->input_filter))(u->input_filter_ctx, n);
      }
#line 2906
      if (tmp___1 == -1L) {
        {
#line 2907
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 2908
        return;
      }
      {
#line 2911
      ngx_http_upstream_process_non_buffered_downstream(r);
      }
    } else {
      {
#line 2914
      u->buffer.pos = u->buffer.start;
#line 2915
      u->buffer.last = u->buffer.start;
#line 2917
      tmp___2 = ngx_http_send_special(r, (ngx_uint_t )2);
      }
#line 2917
      if (tmp___2 == -1L) {
        {
#line 2918
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 2919
        return;
      }
#line 2922
      if (((u->peer.connection)->read)->ready) {
        {
#line 2923
        ngx_http_upstream_process_non_buffered_upstream(r, u);
        }
      } else
#line 2922
      if (u->length == 0L) {
        {
#line 2923
        ngx_http_upstream_process_non_buffered_upstream(r, u);
        }
      }
    }
#line 2927
    return;
  }
#line 2934
  if (r->cache) {
#line 2934
    if ((r->cache)->file.fd != -1) {
      {
#line 2935
      ngx_pool_run_cleanup_file(r->pool, (r->cache)->file.fd);
#line 2936
      (r->cache)->file.fd = -1;
      }
    }
  }
  {
#line 2939
  tmp___3 = ngx_http_test_predicates(r, (u->conf)->no_cache);
  }
  {
#line 2941
  if (tmp___3 == -1L) {
#line 2941
    goto case_neg_1;
  }
#line 2945
  if (tmp___3 == -5L) {
#line 2945
    goto case_neg_5;
  }
#line 2949
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 2942
  ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
  }
#line 2943
  return;
  case_neg_5: /* CIL Label */ 
#line 2946
  u->cacheable = 0U;
#line 2947
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2951
  if (u->cache_status == 2U) {
    {
#line 2955
    tmp___4 = ngx_http_file_cache_create(r);
    }
#line 2955
    if (tmp___4 != 0L) {
      {
#line 2956
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2957
      return;
    }
  }
#line 2961
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2964
  if (u->cacheable) {
#line 2967
    now = (time_t )ngx_cached_time->sec;
#line 2969
    valid = (r->cache)->valid_sec;
#line 2971
    if (valid == 0L) {
      {
#line 2972
      valid = ngx_http_file_cache_valid((u->conf)->cache_valid, u->headers_in.status_n);
      }
#line 2974
      if (valid) {
#line 2975
        (r->cache)->valid_sec = now + valid;
      }
    }
#line 2979
    if (valid) {
#line 2980
      (r->cache)->date = now;
#line 2981
      (r->cache)->body_start = (size_t___0 )((u_short )(u->buffer.pos - u->buffer.start));
#line 2983
      if (u->headers_in.status_n == 200UL) {
#line 2983
        goto _L;
      } else
#line 2983
      if (u->headers_in.status_n == 206UL) {
        _L: /* CIL Label */ 
#line 2986
        (r->cache)->last_modified = u->headers_in.last_modified_time;
#line 2988
        if (u->headers_in.etag) {
#line 2989
          (r->cache)->etag = (u->headers_in.etag)->value;
        } else {
#line 2992
          (r->cache)->etag.len = (size_t___0 )0;
#line 2992
          (r->cache)->etag.data = (u_char *)((void *)0);
        }
      } else {
#line 2996
        (r->cache)->last_modified = (time_t )-1;
#line 2997
        (r->cache)->etag.len = (size_t___0 )0;
#line 2997
        (r->cache)->etag.data = (u_char *)((void *)0);
      }
      {
#line 3000
      tmp___5 = ngx_http_file_cache_set_header(r, u->buffer.start);
      }
#line 3000
      if (tmp___5 != 0L) {
        {
#line 3001
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 3002
        return;
      }
    } else {
#line 3006
      u->cacheable = 0U;
    }
  }
#line 3013
  if (u->cacheable == 0U) {
#line 3013
    if (r->cache) {
      {
#line 3014
      ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
      }
    }
  }
#line 3017
  if (r->header_only) {
#line 3017
    if (! u->cacheable) {
#line 3017
      if (! u->store) {
        {
#line 3018
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
        }
#line 3019
        return;
      }
    }
  }
#line 3024
  p = u->pipe;
#line 3026
  p->output_filter = & ngx_http_upstream_output_filter;
#line 3027
  p->output_ctx = (void *)r;
#line 3028
  p->tag = u->output.tag;
#line 3029
  p->bufs = (u->conf)->bufs;
#line 3030
  p->busy_size = (ssize_t )(u->conf)->busy_buffers_size;
#line 3031
  p->upstream = u->peer.connection;
#line 3032
  p->downstream = c;
#line 3033
  p->pool = r->pool;
#line 3034
  p->log = c->log;
#line 3035
  p->limit_rate = (u->conf)->limit_rate;
#line 3036
  p->start_sec = (time_t )ngx_cached_time->sec;
#line 3038
  if (u->cacheable) {
#line 3038
    tmp___6 = 1;
  } else
#line 3038
  if (u->store) {
#line 3038
    tmp___6 = 1;
  } else {
#line 3038
    tmp___6 = 0;
  }
  {
#line 3038
  p->cacheable = (unsigned int )tmp___6;
#line 3040
  tmp___7 = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t ));
#line 3040
  p->temp_file = (ngx_temp_file_t *)tmp___7;
  }
#line 3041
  if ((unsigned long )p->temp_file == (unsigned long )((void *)0)) {
    {
#line 3042
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3043
    return;
  }
#line 3046
  (p->temp_file)->file.fd = -1;
#line 3047
  (p->temp_file)->file.log = c->log;
#line 3048
  (p->temp_file)->path = (u->conf)->temp_path;
#line 3049
  (p->temp_file)->pool = r->pool;
#line 3051
  if (p->cacheable) {
#line 3052
    (p->temp_file)->persistent = 1U;
#line 3055
    if (r->cache) {
#line 3055
      if (! ((r->cache)->file_cache)->use_temp_path) {
#line 3056
        (p->temp_file)->path = ((r->cache)->file_cache)->path;
#line 3057
        (p->temp_file)->file.name = (r->cache)->file.name;
      }
    }
  } else {
#line 3062
    (p->temp_file)->log_level = 5U;
#line 3063
    (p->temp_file)->warn = (char *)"an upstream response is buffered to a temporary file";
  }
  {
#line 3067
  p->max_temp_file_size = (off_t )(u->conf)->max_temp_file_size;
#line 3068
  p->temp_file_write_size = (ssize_t )(u->conf)->temp_file_write_size;
#line 3077
  p->preread_bufs = ngx_alloc_chain_link(r->pool);
  }
#line 3078
  if ((unsigned long )p->preread_bufs == (unsigned long )((void *)0)) {
    {
#line 3079
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3080
    return;
  }
#line 3083
  (p->preread_bufs)->buf = & u->buffer;
#line 3084
  (p->preread_bufs)->next = (ngx_chain_t *)((void *)0);
#line 3085
  u->buffer.recycled = 1U;
#line 3087
  p->preread_size = (size_t___0 )(u->buffer.last - u->buffer.pos);
#line 3089
  if (u->cacheable) {
    {
#line 3091
    tmp___8 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 3091
    p->buf_to_file = (ngx_buf_t *)tmp___8;
    }
#line 3092
    if ((unsigned long )p->buf_to_file == (unsigned long )((void *)0)) {
      {
#line 3093
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3094
      return;
    }
#line 3097
    (p->buf_to_file)->start = u->buffer.start;
#line 3098
    (p->buf_to_file)->pos = u->buffer.start;
#line 3099
    (p->buf_to_file)->last = u->buffer.pos;
#line 3100
    (p->buf_to_file)->temporary = 1U;
  }
#line 3103
  if (ngx_event_flags & 512UL) {
#line 3105
    p->single_buf = 1U;
  }
#line 3109
  p->free_bufs = 1U;
#line 3115
  u->buffer.last = u->buffer.pos;
#line 3117
  if ((u->conf)->cyclic_temp_file) {
#line 3125
    p->cyclic_temp_file = 1U;
#line 3126
    c->sendfile = 0U;
  } else {
#line 3129
    p->cyclic_temp_file = 0U;
  }
#line 3132
  p->read_timeout = (u->conf)->read_timeout;
#line 3133
  p->send_timeout = clcf->send_timeout;
#line 3134
  p->send_lowat = (ssize_t )clcf->send_lowat;
#line 3136
  p->length = (off_t )-1;
#line 3138
  if (u->input_filter_init) {
    {
#line 3138
    tmp___9 = (*(u->input_filter_init))(p->input_ctx);
    }
#line 3138
    if (tmp___9 != 0L) {
      {
#line 3141
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3142
      return;
    }
  }
  {
#line 3145
  u->read_event_handler = & ngx_http_upstream_process_upstream;
#line 3146
  r->write_event_handler = & ngx_http_upstream_process_downstream;
#line 3148
  ngx_http_upstream_process_upstream(r, u);
  }
#line 3149
  return;
}
}
#line 3152 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgrade(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 3158
  c = r->connection;
#line 3159
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3163
  r->keepalive = 0U;
#line 3164
  (c->log)->action = (char *)"proxying upgraded connection";
#line 3166
  u->read_event_handler = & ngx_http_upstream_upgraded_read_upstream;
#line 3167
  u->write_event_handler = & ngx_http_upstream_upgraded_write_upstream;
#line 3168
  r->read_event_handler = & ngx_http_upstream_upgraded_read_downstream;
#line 3169
  r->write_event_handler = & ngx_http_upstream_upgraded_write_downstream;
#line 3171
  if (clcf->tcp_nodelay) {
    {
#line 3173
    tmp = ngx_tcp_nodelay(c);
    }
#line 3173
    if (tmp != 0L) {
      {
#line 3174
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3175
      return;
    }
    {
#line 3178
    tmp___0 = ngx_tcp_nodelay(u->peer.connection);
    }
#line 3178
    if (tmp___0 != 0L) {
      {
#line 3179
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3180
      return;
    }
  }
  {
#line 3184
  tmp___1 = ngx_http_send_special(r, (ngx_uint_t )2);
  }
#line 3184
  if (tmp___1 == -1L) {
    {
#line 3185
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3186
    return;
  }
#line 3189
  if (((u->peer.connection)->read)->ready) {
#line 3189
    goto _L;
  } else
#line 3189
  if ((unsigned long )u->buffer.pos != (unsigned long )u->buffer.last) {
    _L: /* CIL Label */ 
#line 3192
    if (! (c->read)->posted) {
#line 3192
      (c->read)->posted = 1U;
#line 3192
      (c->read)->queue.prev = ngx_posted_events.prev;
#line 3192
      ((c->read)->queue.prev)->next = & (c->read)->queue;
#line 3192
      (c->read)->queue.next = & ngx_posted_events;
#line 3192
      ngx_posted_events.prev = & (c->read)->queue;
    }
    {
#line 3193
    ngx_http_upstream_process_upgraded(r, (ngx_uint_t )1, (ngx_uint_t )1);
    }
#line 3194
    return;
  }
  {
#line 3197
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )0, (ngx_uint_t )1);
  }
#line 3198
  return;
}
}
#line 3201 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_read_downstream(ngx_http_request_t *r ) 
{ 


  {
  {
#line 3204
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )0, (ngx_uint_t )0);
  }
#line 3205
  return;
}
}
#line 3208 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_write_downstream(ngx_http_request_t *r ) 
{ 


  {
  {
#line 3211
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )1, (ngx_uint_t )1);
  }
#line 3212
  return;
}
}
#line 3215 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_read_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 


  {
  {
#line 3219
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )1, (ngx_uint_t )0);
  }
#line 3220
  return;
}
}
#line 3223 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_write_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 


  {
  {
#line 3227
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )0, (ngx_uint_t )1);
  }
#line 3228
  return;
}
}
#line 3231 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_upgraded(ngx_http_request_t *r , ngx_uint_t from_upstream ,
                                               ngx_uint_t do_write ) 
{ 
  size_t___0 size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_connection_t *c ;
  ngx_connection_t *downstream ;
  ngx_connection_t *upstream ;
  ngx_connection_t *dst ;
  ngx_connection_t *src ;
  ngx_http_upstream_t *u ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 3242
  c = r->connection;
#line 3243
  u = r->upstream;
#line 3248
  downstream = c;
#line 3249
  upstream = u->peer.connection;
#line 3251
  if ((downstream->write)->timedout) {
    {
#line 3252
    c->timedout = 1U;
#line 3253
    ngx_connection_error(c, 110, (char *)"client timed out");
#line 3254
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )408);
    }
#line 3255
    return;
  }
#line 3258
  if ((upstream->read)->timedout) {
    {
#line 3259
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 3260
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 3261
    return;
  } else
#line 3258
  if ((upstream->write)->timedout) {
    {
#line 3259
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 3260
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 3261
    return;
  }
#line 3264
  if (from_upstream) {
#line 3265
    src = upstream;
#line 3266
    dst = downstream;
#line 3267
    b = & u->buffer;
  } else {
#line 3270
    src = downstream;
#line 3271
    dst = upstream;
#line 3272
    b = & u->from_client;
#line 3274
    if ((unsigned long )(r->header_in)->last > (unsigned long )(r->header_in)->pos) {
#line 3275
      b = r->header_in;
#line 3276
      b->end = b->last;
#line 3277
      do_write = (ngx_uint_t )1;
    }
#line 3280
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
      {
#line 3281
      tmp = ngx_palloc(r->pool, (u->conf)->buffer_size);
#line 3281
      b->start = (u_char *)tmp;
      }
#line 3282
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 3283
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 3284
        return;
      }
#line 3287
      b->pos = b->start;
#line 3288
      b->last = b->start;
#line 3289
      b->end = b->start + (u->conf)->buffer_size;
#line 3290
      b->temporary = 1U;
#line 3291
      b->tag = u->output.tag;
    }
  }
  {
#line 3295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3297
    if (do_write) {
#line 3299
      size = (size_t___0 )(b->last - b->pos);
#line 3301
      if (size) {
#line 3301
        if ((dst->write)->ready) {
          {
#line 3303
          n = (*(dst->send))(dst, b->pos, size);
          }
#line 3305
          if (n == -1L) {
            {
#line 3306
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
            }
#line 3307
            return;
          }
#line 3310
          if (n > 0L) {
#line 3311
            b->pos += n;
#line 3313
            if ((unsigned long )b->pos == (unsigned long )b->last) {
#line 3314
              b->pos = b->start;
#line 3315
              b->last = b->start;
            }
          }
        }
      }
    }
#line 3321
    size = (size_t___0 )(b->end - b->last);
#line 3323
    if (size) {
#line 3323
      if ((src->read)->ready) {
        {
#line 3325
        n = (*(src->recv))(src, b->last, size);
        }
#line 3327
        if (n == -2L) {
#line 3328
          goto while_break;
        } else
#line 3327
        if (n == 0L) {
#line 3328
          goto while_break;
        }
#line 3331
        if (n > 0L) {
#line 3332
          do_write = (ngx_uint_t )1;
#line 3333
          b->last += n;
#line 3335
          if (from_upstream) {
#line 3336
            (u->state)->bytes_received += n;
          }
#line 3339
          goto __Cont;
        }
#line 3342
        if (n == -1L) {
#line 3343
          (src->read)->eof = 1U;
        }
      }
    }
#line 3347
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3350
  if ((upstream->read)->eof) {
#line 3350
    if ((unsigned long )u->buffer.pos == (unsigned long )u->buffer.last) {
      {
#line 3356
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
      }
#line 3357
      return;
    } else {
#line 3350
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3350
  if ((downstream->read)->eof) {
#line 3350
    if ((unsigned long )u->from_client.pos == (unsigned long )u->from_client.last) {
      {
#line 3356
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
      }
#line 3357
      return;
    } else {
#line 3350
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3350
  if ((downstream->read)->eof) {
#line 3350
    if ((upstream->read)->eof) {
      {
#line 3356
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
      }
#line 3357
      return;
    }
  }
  {
#line 3360
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3362
  tmp___0 = ngx_handle_write_event(upstream->write, (u->conf)->send_lowat);
  }
#line 3362
  if (tmp___0 != 0L) {
    {
#line 3365
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3366
    return;
  }
#line 3369
  if ((upstream->write)->active) {
#line 3369
    if (! (upstream->write)->ready) {
      {
#line 3370
      ngx_event_add_timer(upstream->write, (u->conf)->send_timeout);
      }
    } else {
#line 3369
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3372
  if ((upstream->write)->timer_set) {
    {
#line 3373
    ngx_event_del_timer(upstream->write);
    }
  }
  {
#line 3376
  tmp___1 = ngx_handle_read_event(upstream->read, (ngx_uint_t )0);
  }
#line 3376
  if (tmp___1 != 0L) {
    {
#line 3377
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3378
    return;
  }
#line 3381
  if ((upstream->read)->active) {
#line 3381
    if (! (upstream->read)->ready) {
      {
#line 3382
      ngx_event_add_timer(upstream->read, (u->conf)->read_timeout);
      }
    } else {
#line 3381
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3384
  if ((upstream->read)->timer_set) {
    {
#line 3385
    ngx_event_del_timer(upstream->read);
    }
  }
  {
#line 3388
  tmp___2 = ngx_handle_write_event(downstream->write, clcf->send_lowat);
  }
#line 3388
  if (tmp___2 != 0L) {
    {
#line 3391
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3392
    return;
  }
  {
#line 3395
  tmp___3 = ngx_handle_read_event(downstream->read, (ngx_uint_t )0);
  }
#line 3395
  if (tmp___3 != 0L) {
    {
#line 3396
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3397
    return;
  }
#line 3400
  if ((downstream->write)->active) {
#line 3400
    if (! (downstream->write)->ready) {
      {
#line 3401
      ngx_event_add_timer(downstream->write, clcf->send_timeout);
      }
    } else {
#line 3400
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 3403
  if ((downstream->write)->timer_set) {
    {
#line 3404
    ngx_event_del_timer(downstream->write);
    }
  }
#line 3406
  return;
}
}
#line 3409 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_non_buffered_downstream(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;

  {
#line 3416
  c = r->connection;
#line 3417
  u = r->upstream;
#line 3418
  wev = c->write;
#line 3423
  (c->log)->action = (char *)"sending to client";
#line 3425
  if (wev->timedout) {
    {
#line 3426
    c->timedout = 1U;
#line 3427
    ngx_connection_error(c, 110, (char *)"client timed out");
#line 3428
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )408);
    }
#line 3429
    return;
  }
  {
#line 3432
  ngx_http_upstream_process_non_buffered_request(r, (ngx_uint_t )1);
  }
#line 3433
  return;
}
}
#line 3436 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_non_buffered_upstream(ngx_http_request_t *r ,
                                                            ngx_http_upstream_t *u ) 
{ 
  ngx_connection_t *c ;

  {
#line 3442
  c = u->peer.connection;
#line 3447
  (c->log)->action = (char *)"reading upstream";
#line 3449
  if ((c->read)->timedout) {
    {
#line 3450
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 3451
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 3452
    return;
  }
  {
#line 3455
  ngx_http_upstream_process_non_buffered_request(r, (ngx_uint_t )0);
  }
#line 3456
  return;
}
}
#line 3459 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r ,
                                                           ngx_uint_t do_write ) 
{ 
  size_t___0 size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_int_t rc ;
  ngx_connection_t *downstream ;
  ngx_connection_t *upstream ;
  ngx_http_upstream_t *u ;
  ngx_http_core_loc_conf_t *clcf ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 3471
  u = r->upstream;
#line 3472
  downstream = r->connection;
#line 3473
  upstream = u->peer.connection;
#line 3475
  b = & u->buffer;
#line 3477
  if (do_write) {
#line 3477
    tmp = 1;
  } else
#line 3477
  if (u->length == 0L) {
#line 3477
    tmp = 1;
  } else {
#line 3477
    tmp = 0;
  }
#line 3477
  do_write = (ngx_uint_t )tmp;
  {
#line 3479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3481
    if (do_write) {
#line 3483
      if (u->out_bufs) {
#line 3483
        goto _L;
      } else
#line 3483
      if (u->busy_bufs) {
        _L: /* CIL Label */ 
        {
#line 3484
        rc = ngx_http_output_filter(r, u->out_bufs);
        }
#line 3486
        if (rc == -1L) {
          {
#line 3487
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
          }
#line 3488
          return;
        }
        {
#line 3491
        ngx_chain_update_chains(r->pool, & u->free_bufs, & u->busy_bufs, & u->out_bufs,
                                u->output.tag);
        }
      }
#line 3495
      if ((unsigned long )u->busy_bufs == (unsigned long )((void *)0)) {
#line 3497
        if (u->length == 0L) {
          {
#line 3500
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
          }
#line 3501
          return;
        } else
#line 3497
        if ((upstream->read)->eof) {
#line 3497
          if (u->length == -1L) {
            {
#line 3500
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
            }
#line 3501
            return;
          }
        }
#line 3504
        if ((upstream->read)->eof) {
#line 3505
          if ((upstream->log)->log_level >= 4UL) {
            {
#line 3505
            ngx_log_error_core((ngx_uint_t )4, upstream->log, 0, "upstream prematurely closed connection");
            }
          }
          {
#line 3508
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
          }
#line 3510
          return;
        }
#line 3513
        if ((upstream->read)->error) {
          {
#line 3514
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
          }
#line 3516
          return;
        }
#line 3519
        b->pos = b->start;
#line 3520
        b->last = b->start;
      }
    }
#line 3524
    size = (size_t___0 )(b->end - b->last);
#line 3526
    if (size) {
#line 3526
      if ((upstream->read)->ready) {
        {
#line 3528
        n = (*(upstream->recv))(upstream, b->last, size);
        }
#line 3530
        if (n == -2L) {
#line 3531
          goto while_break;
        }
#line 3534
        if (n > 0L) {
          {
#line 3535
          (u->state)->bytes_received += n;
#line 3536
          (u->state)->response_length += n;
#line 3538
          tmp___0 = (*(u->input_filter))(u->input_filter_ctx, n);
          }
#line 3538
          if (tmp___0 == -1L) {
            {
#line 3539
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
            }
#line 3540
            return;
          }
        }
#line 3544
        do_write = (ngx_uint_t )1;
#line 3546
        goto __Cont;
      }
    }
#line 3549
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3552
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3554
  if ((unsigned long )downstream->data == (unsigned long )r) {
    {
#line 3555
    tmp___1 = ngx_handle_write_event(downstream->write, clcf->send_lowat);
    }
#line 3555
    if (tmp___1 != 0L) {
      {
#line 3558
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3559
      return;
    }
  }
#line 3563
  if ((downstream->write)->active) {
#line 3563
    if (! (downstream->write)->ready) {
      {
#line 3564
      ngx_event_add_timer(downstream->write, clcf->send_timeout);
      }
    } else {
#line 3563
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3566
  if ((downstream->write)->timer_set) {
    {
#line 3567
    ngx_event_del_timer(downstream->write);
    }
  }
  {
#line 3570
  tmp___2 = ngx_handle_read_event(upstream->read, (ngx_uint_t )0);
  }
#line 3570
  if (tmp___2 != 0L) {
    {
#line 3571
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3572
    return;
  }
#line 3575
  if ((upstream->read)->active) {
#line 3575
    if (! (upstream->read)->ready) {
      {
#line 3576
      ngx_event_add_timer(upstream->read, (u->conf)->read_timeout);
      }
    } else {
#line 3575
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3578
  if ((upstream->read)->timer_set) {
    {
#line 3579
    ngx_event_del_timer(upstream->read);
    }
  }
#line 3581
  return;
}
}
#line 3584 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data ) 
{ 


  {
#line 3587
  return ((ngx_int_t )0);
}
}
#line 3591 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_non_buffered_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_request_t *r ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;

  {
#line 3594
  r = (ngx_http_request_t *)data;
#line 3600
  u = r->upstream;
#line 3602
  cl = u->out_bufs;
#line 3602
  ll = & u->out_bufs;
  {
#line 3602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3602
    if (! cl) {
#line 3602
      goto while_break;
    }
#line 3603
    ll = & cl->next;
#line 3602
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3606
  cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
  }
#line 3607
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 3608
    return ((ngx_int_t )-1);
  }
#line 3611
  *ll = cl;
#line 3613
  (cl->buf)->flush = 1U;
#line 3614
  (cl->buf)->memory = 1U;
#line 3616
  b = & u->buffer;
#line 3618
  (cl->buf)->pos = b->last;
#line 3619
  b->last += bytes;
#line 3620
  (cl->buf)->last = b->last;
#line 3621
  (cl->buf)->tag = u->output.tag;
#line 3623
  if (u->length == -1L) {
#line 3624
    return ((ngx_int_t )0);
  }
#line 3627
  u->length -= bytes;
#line 3629
  return ((ngx_int_t )0);
}
}
#line 3716 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_output_filter(void *data , ngx_chain_t *chain ) 
{ 
  ngx_int_t rc ;
  ngx_event_pipe_t *p ;
  ngx_http_request_t *r ;

  {
  {
#line 3723
  r = (ngx_http_request_t *)data;
#line 3724
  p = (r->upstream)->pipe;
#line 3726
  rc = ngx_http_output_filter(r, chain);
#line 3728
  p->aio = r->aio;
  }
#line 3730
  return (rc);
}
}
#line 3734 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_downstream(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_event_pipe_t *p ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 3742
  c = r->connection;
#line 3743
  u = r->upstream;
#line 3744
  p = u->pipe;
#line 3745
  wev = c->write;
#line 3750
  (c->log)->action = (char *)"sending to client";
#line 3756
  if (wev->timedout) {
    {
#line 3758
    p->downstream_error = 1U;
#line 3759
    c->timedout = 1U;
#line 3760
    ngx_connection_error(c, 110, (char *)"client timed out");
    }
  } else {
#line 3764
    if (wev->delayed) {
      {
#line 3769
      tmp = ngx_handle_write_event(wev, (size_t___0 )p->send_lowat);
      }
#line 3769
      if (tmp != 0L) {
        {
#line 3770
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
      }
#line 3773
      return;
    }
    {
#line 3776
    tmp___0 = ngx_event_pipe(p, (ngx_int_t )1);
    }
#line 3776
    if (tmp___0 == -6L) {
      {
#line 3777
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3778
      return;
    }
  }
  {
#line 3782
  ngx_http_upstream_process_request(r, u);
  }
#line 3783
  return;
}
}
#line 3786 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_event_t *rev ;
  ngx_event_pipe_t *p ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 3794
  c = u->peer.connection;
#line 3795
  p = u->pipe;
#line 3796
  rev = c->read;
#line 3801
  (c->log)->action = (char *)"reading upstream";
#line 3803
  if (rev->timedout) {
    {
#line 3805
    p->upstream_error = 1U;
#line 3806
    ngx_connection_error(c, 110, (char *)"upstream timed out");
    }
  } else {
#line 3810
    if (rev->delayed) {
      {
#line 3815
      tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
      }
#line 3815
      if (tmp != 0L) {
        {
#line 3816
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
      }
#line 3819
      return;
    }
    {
#line 3822
    tmp___0 = ngx_event_pipe(p, (ngx_int_t )0);
    }
#line 3822
    if (tmp___0 == -6L) {
      {
#line 3823
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3824
      return;
    }
  }
  {
#line 3828
  ngx_http_upstream_process_request(r, u);
  }
#line 3829
  return;
}
}
#line 3832 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_request(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_temp_file_t *tf ;
  ngx_event_pipe_t *p ;

  {
#line 3839
  p = u->pipe;
#line 3862
  if (u->peer.connection) {
#line 3864
    if (u->store) {
#line 3866
      if (p->upstream_eof) {
#line 3866
        goto _L___0;
      } else
#line 3866
      if (p->upstream_done) {
        _L___0: /* CIL Label */ 
#line 3868
        tf = p->temp_file;
#line 3870
        if (u->headers_in.status_n == 200UL) {
#line 3870
          if (p->upstream_done) {
#line 3870
            goto _L;
          } else
#line 3870
          if (p->length == -1L) {
            _L: /* CIL Label */ 
#line 3870
            if (u->headers_in.content_length_n == -1L) {
              {
#line 3875
              ngx_http_upstream_store(r, u);
              }
            } else
#line 3870
            if (u->headers_in.content_length_n == tf->offset) {
              {
#line 3875
              ngx_http_upstream_store(r, u);
              }
            }
          }
        }
      }
    }
#line 3882
    if (u->cacheable) {
#line 3884
      if (p->upstream_done) {
        {
#line 3885
        ngx_http_file_cache_update(r, p->temp_file);
        }
      } else
#line 3887
      if (p->upstream_eof) {
#line 3889
        tf = p->temp_file;
#line 3891
        if (p->length == -1L) {
#line 3891
          if (u->headers_in.content_length_n == -1L) {
            {
#line 3896
            ngx_http_file_cache_update(r, tf);
            }
          } else
#line 3891
          if (u->headers_in.content_length_n == tf->offset - (off_t )(r->cache)->body_start) {
            {
#line 3896
            ngx_http_file_cache_update(r, tf);
            }
          } else {
            {
#line 3899
            ngx_http_file_cache_free(r->cache, tf);
            }
          }
        } else {
          {
#line 3899
          ngx_http_file_cache_free(r->cache, tf);
          }
        }
      } else
#line 3902
      if (p->upstream_error) {
        {
#line 3903
        ngx_http_file_cache_free(r->cache, p->temp_file);
        }
      }
    }
#line 3909
    if (p->upstream_done) {
#line 3909
      goto _L___1;
    } else
#line 3909
    if (p->upstream_eof) {
#line 3909
      goto _L___1;
    } else
#line 3909
    if (p->upstream_error) {
      _L___1: /* CIL Label */ 
#line 3913
      if (p->upstream_done) {
        {
#line 3916
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
        }
#line 3917
        return;
      } else
#line 3913
      if (p->upstream_eof) {
#line 3913
        if (p->length == -1L) {
          {
#line 3916
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
          }
#line 3917
          return;
        }
      }
#line 3920
      if (p->upstream_eof) {
#line 3921
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 3921
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream prematurely closed connection");
          }
        }
      }
      {
#line 3925
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
      }
#line 3926
      return;
    }
  }
#line 3930
  if (p->downstream_error) {
#line 3934
    if (! u->cacheable) {
#line 3934
      if (! u->store) {
#line 3934
        if (u->peer.connection) {
          {
#line 3935
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
          }
        }
      }
    }
  }
#line 3938
  return;
}
}
#line 3941 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_store(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  size_t___0 root ;
  time_t lm ;
  ngx_str_t path ;
  ngx_temp_file_t *tf ;
  ngx_ext_rename_file_t ext ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 3950
  tf = (u->pipe)->temp_file;
#line 3952
  if (tf->file.fd == -1) {
    {
#line 3956
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t ));
#line 3956
    tf = (ngx_temp_file_t *)tmp;
    }
#line 3957
    if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 3958
      return;
    }
    {
#line 3961
    tf->file.fd = -1;
#line 3962
    tf->file.log = (r->connection)->log;
#line 3963
    tf->path = (u->conf)->temp_path;
#line 3964
    tf->pool = r->pool;
#line 3965
    tf->persistent = 1U;
#line 3967
    tmp___0 = ngx_create_temp_file(& tf->file, tf->path, tf->pool, (ngx_uint_t )tf->persistent,
                                   (ngx_uint_t )tf->clean, tf->access);
    }
#line 3967
    if (tmp___0 != 0L) {
#line 3971
      return;
    }
#line 3974
    (u->pipe)->temp_file = tf;
  }
#line 3977
  ext.access = (u->conf)->store_access;
#line 3978
  ext.path_access = (u->conf)->store_access;
#line 3979
  ext.time = (time_t )-1;
#line 3980
  ext.create_path = 1U;
#line 3981
  ext.delete_file = 1U;
#line 3982
  ext.log = (r->connection)->log;
#line 3984
  if (u->headers_in.last_modified) {
    {
#line 3986
    lm = ngx_parse_http_time((u->headers_in.last_modified)->value.data, (u->headers_in.last_modified)->value.len);
    }
#line 3989
    if (lm != -1L) {
#line 3990
      ext.time = lm;
#line 3991
      ext.fd = tf->file.fd;
    }
  }
#line 3995
  if ((unsigned long )(u->conf)->store_lengths == (unsigned long )((void *)0)) {
    {
#line 3997
    tmp___1 = ngx_http_map_uri_to_path(r, & path, & root, (size_t___0 )0);
    }
#line 3997
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 3998
      return;
    }
  } else {
    {
#line 4002
    tmp___2 = ngx_http_script_run(r, & path, ((u->conf)->store_lengths)->elts, (size_t___0 )0,
                                  ((u->conf)->store_values)->elts);
    }
#line 4002
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 4006
      return;
    }
  }
  {
#line 4010
  (path.len) --;
#line 4016
  ngx_ext_rename_file(& tf->file.name, & path, & ext);
#line 4018
  u->store = 0U;
  }
#line 4019
  return;
}
}
#line 4022 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_dummy_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 


  {
#line 4027
  return;
}
}
#line 4030 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_next(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                   ngx_uint_t ft_type ) 
{ 
  ngx_msec_t timeout ;
  ngx_uint_t status ;
  ngx_uint_t state ;
  ngx_int_t rc ;

  {
#line 4040
  if (u->peer.sockaddr) {
#line 4042
    if (ft_type == 256UL) {
#line 4045
      state = (ngx_uint_t )2;
    } else
#line 4042
    if (ft_type == 512UL) {
#line 4045
      state = (ngx_uint_t )2;
    } else {
#line 4048
      state = (ngx_uint_t )4;
    }
    {
#line 4051
    (*(u->peer.free))(& u->peer, u->peer.data, state);
#line 4052
    u->peer.sockaddr = (struct sockaddr *)((void *)0);
    }
  }
#line 4055
  if (ft_type == 4UL) {
#line 4056
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 4056
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 110, "upstream timed out");
      }
    }
  }
#line 4060
  if (u->peer.cached) {
#line 4060
    if (ft_type == 2UL) {
#line 4062
      (u->peer.tries) ++;
    }
  }
  {
#line 4067
  if (ft_type == 4UL) {
#line 4067
    goto case_4;
  }
#line 4071
  if (ft_type == 16UL) {
#line 4071
    goto case_16;
  }
#line 4075
  if (ft_type == 256UL) {
#line 4075
    goto case_256;
  }
#line 4079
  if (ft_type == 512UL) {
#line 4079
    goto case_512;
  }
#line 4083
  if (ft_type == 1024UL) {
#line 4083
    goto case_1024;
  }
#line 4092
  goto switch_default;
  case_4: /* CIL Label */ 
#line 4068
  status = (ngx_uint_t )504;
#line 4069
  goto switch_break;
  case_16: /* CIL Label */ 
#line 4072
  status = (ngx_uint_t )500;
#line 4073
  goto switch_break;
  case_256: /* CIL Label */ 
#line 4076
  status = (ngx_uint_t )403;
#line 4077
  goto switch_break;
  case_512: /* CIL Label */ 
#line 4080
  status = (ngx_uint_t )404;
#line 4081
  goto switch_break;
  case_1024: /* CIL Label */ 
#line 4084
  status = (ngx_uint_t )429;
#line 4085
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4093
  status = (ngx_uint_t )502;
  switch_break: /* CIL Label */ ;
  }
#line 4096
  if ((r->connection)->error) {
    {
#line 4097
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
    }
#line 4099
    return;
  }
#line 4102
  (u->state)->status = status;
#line 4104
  timeout = (u->conf)->next_upstream_timeout;
#line 4106
  if (u->request_sent) {
#line 4106
    if (r->method & 20488UL) {
#line 4109
      ft_type |= 16384UL;
    }
  }
#line 4112
  if (u->peer.tries == 0UL) {
#line 4112
    goto _L___0;
  } else
#line 4112
  if (((u->conf)->next_upstream & ft_type) != ft_type) {
#line 4112
    goto _L___0;
  } else
#line 4112
  if (u->request_sent) {
#line 4112
    if (r->request_body_no_buffering) {
#line 4112
      goto _L___0;
    } else {
#line 4112
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 4112
  if (timeout) {
#line 4112
    if (ngx_current_msec - (ngx_msec_t volatile   )u->peer.start_time >= (ngx_msec_t volatile   )timeout) {
      _L___0: /* CIL Label */ 
#line 4119
      if (u->cache_status == 3U) {
#line 4119
        if ((u->conf)->cache_use_stale & ft_type) {
#line 4119
          goto _L;
        } else
#line 4119
        if ((r->cache)->stale_error) {
          _L: /* CIL Label */ 
          {
#line 4124
          rc = (*(u->reinit_request))(r);
          }
#line 4126
          if (rc == 0L) {
            {
#line 4127
            u->cache_status = 4U;
#line 4128
            rc = ngx_http_upstream_cache_send(r, u);
            }
          }
          {
#line 4131
          ngx_http_upstream_finalize_request(r, u, rc);
          }
#line 4132
          return;
        }
      }
      {
#line 4136
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )status);
      }
#line 4137
      return;
    }
  }
#line 4140
  if (u->peer.connection) {
#line 4154
    if ((u->peer.connection)->pool) {
      {
#line 4155
      ngx_destroy_pool((u->peer.connection)->pool);
      }
    }
    {
#line 4158
    ngx_close_connection(u->peer.connection);
#line 4159
    u->peer.connection = (ngx_connection_t *)((void *)0);
    }
  }
  {
#line 4162
  ngx_http_upstream_connect(r, u);
  }
#line 4163
  return;
}
}
#line 4166 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_cleanup(void *data ) 
{ 
  ngx_http_request_t *r ;

  {
  {
#line 4169
  r = (ngx_http_request_t *)data;
#line 4174
  ngx_http_upstream_finalize_request(r, r->upstream, (ngx_int_t )-4);
  }
#line 4175
  return;
}
}
#line 4178 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_finalize_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                               ngx_int_t rc ) 
{ 
  ngx_uint_t flush ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  time_t valid ;

  {
#line 4187
  if ((unsigned long )u->cleanup == (unsigned long )((void *)0)) {
    {
#line 4189
    ngx_http_finalize_request(r, (ngx_int_t )-4);
    }
#line 4190
    return;
  }
#line 4193
  *(u->cleanup) = (ngx_http_cleanup_pt )((void *)0);
#line 4194
  u->cleanup = (ngx_http_cleanup_pt *)((void *)0);
#line 4196
  if (u->resolved) {
#line 4196
    if ((u->resolved)->ctx) {
      {
#line 4197
      ngx_resolve_name_done((u->resolved)->ctx);
#line 4198
      (u->resolved)->ctx = (ngx_resolver_ctx_t *)((void *)0);
      }
    }
  }
#line 4201
  if (u->state) {
#line 4201
    if ((u->state)->response_time) {
#line 4202
      (u->state)->response_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
#line 4204
      if (u->pipe) {
#line 4204
        if ((u->pipe)->read_length) {
#line 4205
          (u->state)->bytes_received = (off_t )((size_t___0 )(u->state)->bytes_received + ((size_t___0 )(u->pipe)->read_length - (u->pipe)->preread_size));
#line 4207
          (u->state)->response_length = (u->pipe)->read_length;
        }
      }
    }
  }
  {
#line 4211
  (*(u->finalize_request))(r, rc);
  }
#line 4213
  if (u->peer.free) {
#line 4213
    if (u->peer.sockaddr) {
      {
#line 4214
      (*(u->peer.free))(& u->peer, u->peer.data, (ngx_uint_t )0);
#line 4215
      u->peer.sockaddr = (struct sockaddr *)((void *)0);
      }
    }
  }
#line 4218
  if (u->peer.connection) {
#line 4242
    if ((u->peer.connection)->pool) {
      {
#line 4243
      ngx_destroy_pool((u->peer.connection)->pool);
      }
    }
    {
#line 4246
    ngx_close_connection(u->peer.connection);
    }
  }
#line 4249
  u->peer.connection = (ngx_connection_t *)((void *)0);
#line 4251
  if (u->pipe) {
#line 4251
    if ((u->pipe)->temp_file) {
#line 4251
      tmp = 1;
    } else {
#line 4251
      tmp = 0;
    }
  } else {
#line 4251
    tmp = 0;
  }
#line 4257
  if (u->store) {
#line 4257
    if (u->pipe) {
#line 4257
      if ((u->pipe)->temp_file) {
#line 4257
        if (((u->pipe)->temp_file)->file.fd != -1) {
          {
#line 4260
          tmp___1 = unlink((char const   *)((u->pipe)->temp_file)->file.name.data);
          }
#line 4260
          if (tmp___1 == -1) {
#line 4263
            if (((r->connection)->log)->log_level >= 3UL) {
              {
#line 4263
              tmp___0 = __errno_location();
#line 4263
              ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___0, "unlink() \"%s\" failed",
                                 ((u->pipe)->temp_file)->file.name.data);
              }
            }
          }
        }
      }
    }
  }
#line 4271
  if (r->cache) {
#line 4273
    if (u->cacheable) {
#line 4275
      if (rc == 502L) {
#line 4275
        goto _L;
      } else
#line 4275
      if (rc == 504L) {
        _L: /* CIL Label */ 
        {
#line 4278
        valid = ngx_http_file_cache_valid((u->conf)->cache_valid, (ngx_uint_t )rc);
        }
#line 4280
        if (valid) {
#line 4281
          (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )valid);
#line 4282
          (r->cache)->error = (ngx_uint_t )rc;
        }
      }
    }
    {
#line 4287
    ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
    }
  }
#line 4292
  if (r->subrequest_in_memory) {
#line 4292
    if (u->headers_in.status_n >= 300UL) {
#line 4295
      u->buffer.last = u->buffer.pos;
    }
  }
#line 4298
  r->read_event_handler = & ngx_http_block_reading;
#line 4300
  if (rc == -5L) {
#line 4301
    return;
  }
#line 4304
  ((r->connection)->log)->action = (char *)"sending to client";
#line 4306
  if (! u->header_sent) {
    {
#line 4311
    ngx_http_finalize_request(r, rc);
    }
#line 4312
    return;
  } else
#line 4306
  if (rc == 408L) {
    {
#line 4311
    ngx_http_finalize_request(r, rc);
    }
#line 4312
    return;
  } else
#line 4306
  if (rc == 499L) {
    {
#line 4311
    ngx_http_finalize_request(r, rc);
    }
#line 4312
    return;
  } else
#line 4306
  if (u->pipe) {
#line 4306
    if ((u->pipe)->downstream_error) {
      {
#line 4311
      ngx_http_finalize_request(r, rc);
      }
#line 4312
      return;
    }
  }
#line 4315
  flush = (ngx_uint_t )0;
#line 4317
  if (rc >= 300L) {
#line 4318
    rc = (ngx_int_t )-1;
#line 4319
    flush = (ngx_uint_t )1;
  }
#line 4322
  if (r->header_only) {
    {
#line 4323
    ngx_http_finalize_request(r, rc);
    }
#line 4324
    return;
  }
#line 4327
  if (rc == 0L) {
    {
#line 4328
    rc = ngx_http_send_special(r, (ngx_uint_t )1);
    }
  } else
#line 4330
  if (flush) {
    {
#line 4331
    r->keepalive = 0U;
#line 4332
    rc = ngx_http_send_special(r, (ngx_uint_t )2);
    }
  }
  {
#line 4335
  ngx_http_finalize_request(r, rc);
  }
#line 4336
  return;
}
}
#line 4339 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                       ngx_uint_t offset ) 
{ 
  ngx_table_elt_t **ph ;

  {
#line 4345
  ph = (ngx_table_elt_t **)((char *)(& (r->upstream)->headers_in) + offset);
#line 4347
  if ((unsigned long )*ph == (unsigned long )((void *)0)) {
#line 4348
    *ph = h;
  }
#line 4351
  return ((ngx_int_t )0);
}
}
#line 4355 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_ignore_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 


  {
#line 4359
  return ((ngx_int_t )0);
}
}
#line 4363 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_content_length(ngx_http_request_t *r ,
                                                          ngx_table_elt_t *h , ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;

  {
  {
#line 4369
  u = r->upstream;
#line 4371
  u->headers_in.content_length = h;
#line 4372
  u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);
  }
#line 4374
  return ((ngx_int_t )0);
}
}
#line 4378 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;

  {
#line 4384
  u = r->upstream;
#line 4386
  u->headers_in.last_modified = h;
#line 4390
  if (u->cacheable) {
    {
#line 4391
    u->headers_in.last_modified_time = ngx_parse_http_time(h->value.data, h->value.len);
    }
  }
#line 4397
  return ((ngx_int_t )0);
}
}
#line 4401 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_array_t *pa ;
  ngx_table_elt_t **ph ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
#line 4409
  u = r->upstream;
#line 4410
  pa = & u->headers_in.cookies;
#line 4412
  if ((unsigned long )pa->elts == (unsigned long )((void *)0)) {
    {
#line 4413
    tmp = ngx_array_init(pa, r->pool, (ngx_uint_t )1, sizeof(ngx_table_elt_t *));
    }
#line 4413
    if (tmp != 0L) {
#line 4415
      return ((ngx_int_t )-1);
    }
  }
  {
#line 4419
  tmp___0 = ngx_array_push(pa);
#line 4419
  ph = (ngx_table_elt_t **)tmp___0;
  }
#line 4420
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 4421
    return ((ngx_int_t )-1);
  }
#line 4424
  *ph = h;
#line 4427
  if (! ((u->conf)->ignore_headers & 32UL)) {
#line 4428
    u->cacheable = 0U;
  }
#line 4432
  return ((ngx_int_t )0);
}
}
#line 4436 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_cache_control(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_array_t *pa ;
  ngx_table_elt_t **ph ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  u_char *p ;
  u_char *start ;
  u_char *last ;
  ngx_int_t n ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;

  {
#line 4444
  u = r->upstream;
#line 4445
  pa = & u->headers_in.cache_control;
#line 4447
  if ((unsigned long )pa->elts == (unsigned long )((void *)0)) {
    {
#line 4448
    tmp = ngx_array_init(pa, r->pool, (ngx_uint_t )2, sizeof(ngx_table_elt_t *));
    }
#line 4448
    if (tmp != 0L) {
#line 4450
      return ((ngx_int_t )-1);
    }
  }
  {
#line 4454
  tmp___0 = ngx_array_push(pa);
#line 4454
  ph = (ngx_table_elt_t **)tmp___0;
  }
#line 4455
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 4456
    return ((ngx_int_t )-1);
  }
#line 4459
  *ph = h;
#line 4466
  if ((u->conf)->ignore_headers & 16UL) {
#line 4467
    return ((ngx_int_t )0);
  }
#line 4470
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4471
    return ((ngx_int_t )0);
  }
#line 4474
  if ((r->cache)->valid_sec != 0L) {
#line 4474
    if ((unsigned long )u->headers_in.x_accel_expires != (unsigned long )((void *)0)) {
#line 4475
      return ((ngx_int_t )0);
    }
  }
  {
#line 4478
  start = h->value.data;
#line 4479
  last = start + h->value.len;
#line 4481
  tmp___1 = ngx_strlcasestrn(start, last, (u_char *)"no-cache", (size_t___0 )7);
  }
#line 4481
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 4485
    u->cacheable = 0U;
#line 4486
    return ((ngx_int_t )0);
  } else {
    {
#line 4481
    tmp___2 = ngx_strlcasestrn(start, last, (u_char *)"no-store", (size_t___0 )7);
    }
#line 4481
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 4485
      u->cacheable = 0U;
#line 4486
      return ((ngx_int_t )0);
    } else {
      {
#line 4481
      tmp___3 = ngx_strlcasestrn(start, last, (u_char *)"private", (size_t___0 )6);
      }
#line 4481
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 4485
        u->cacheable = 0U;
#line 4486
        return ((ngx_int_t )0);
      }
    }
  }
  {
#line 4489
  p = ngx_strlcasestrn(start, last, (u_char *)"s-maxage=", (size_t___0 )8);
#line 4490
  offset = (ngx_uint_t )9;
  }
#line 4492
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 4493
    p = ngx_strlcasestrn(start, last, (u_char *)"max-age=", (size_t___0 )7);
#line 4494
    offset = (ngx_uint_t )8;
    }
  }
#line 4497
  if (p) {
#line 4498
    n = (ngx_int_t )0;
#line 4500
    p += offset;
    {
#line 4500
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4500
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 4500
        goto while_break;
      }
#line 4501
      if ((int )*p == 44) {
#line 4502
        goto while_break;
      } else
#line 4501
      if ((int )*p == 59) {
#line 4502
        goto while_break;
      } else
#line 4501
      if ((int )*p == 32) {
#line 4502
        goto while_break;
      }
#line 4505
      if ((int )*p >= 48) {
#line 4505
        if ((int )*p <= 57) {
#line 4506
          n = (n * 10L + (ngx_int_t )*p) - 48L;
#line 4507
          goto __Cont;
        }
      }
#line 4510
      u->cacheable = 0U;
#line 4511
      return ((ngx_int_t )0);
      __Cont: /* CIL Label */ 
#line 4500
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4514
    if (n == 0L) {
#line 4515
      u->cacheable = 0U;
#line 4516
      return ((ngx_int_t )0);
    }
#line 4519
    (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )n);
  }
  {
#line 4522
  p = ngx_strlcasestrn(start, last, (u_char *)"stale-while-revalidate=", (size_t___0 )22);
  }
#line 4525
  if (p) {
#line 4526
    n = (ngx_int_t )0;
#line 4528
    p += 23;
    {
#line 4528
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4528
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 4528
        goto while_break___0;
      }
#line 4529
      if ((int )*p == 44) {
#line 4530
        goto while_break___0;
      } else
#line 4529
      if ((int )*p == 59) {
#line 4530
        goto while_break___0;
      } else
#line 4529
      if ((int )*p == 32) {
#line 4530
        goto while_break___0;
      }
#line 4533
      if ((int )*p >= 48) {
#line 4533
        if ((int )*p <= 57) {
#line 4534
          n = (n * 10L + (ngx_int_t )*p) - 48L;
#line 4535
          goto __Cont___0;
        }
      }
#line 4538
      u->cacheable = 0U;
#line 4539
      return ((ngx_int_t )0);
      __Cont___0: /* CIL Label */ 
#line 4528
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4542
    (r->cache)->updating_sec = n;
#line 4543
    (r->cache)->error_sec = n;
  }
  {
#line 4546
  p = ngx_strlcasestrn(start, last, (u_char *)"stale-if-error=", (size_t___0 )14);
  }
#line 4548
  if (p) {
#line 4549
    n = (ngx_int_t )0;
#line 4551
    p += 15;
    {
#line 4551
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4551
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 4551
        goto while_break___1;
      }
#line 4552
      if ((int )*p == 44) {
#line 4553
        goto while_break___1;
      } else
#line 4552
      if ((int )*p == 59) {
#line 4553
        goto while_break___1;
      } else
#line 4552
      if ((int )*p == 32) {
#line 4553
        goto while_break___1;
      }
#line 4556
      if ((int )*p >= 48) {
#line 4556
        if ((int )*p <= 57) {
#line 4557
          n = (n * 10L + (ngx_int_t )*p) - 48L;
#line 4558
          goto __Cont___1;
        }
      }
#line 4561
      u->cacheable = 0U;
#line 4562
      return ((ngx_int_t )0);
      __Cont___1: /* CIL Label */ 
#line 4551
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4565
    (r->cache)->error_sec = n;
  }
#line 4570
  return ((ngx_int_t )0);
}
}
#line 4574 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;
  time_t expires___0 ;

  {
#line 4580
  u = r->upstream;
#line 4581
  u->headers_in.expires = h;
#line 4587
  if ((u->conf)->ignore_headers & 8UL) {
#line 4588
    return ((ngx_int_t )0);
  }
#line 4591
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4592
    return ((ngx_int_t )0);
  }
#line 4595
  if ((r->cache)->valid_sec != 0L) {
#line 4596
    return ((ngx_int_t )0);
  }
  {
#line 4599
  expires___0 = ngx_parse_http_time(h->value.data, h->value.len);
  }
#line 4601
  if (expires___0 == -1L) {
#line 4602
    u->cacheable = 0U;
#line 4603
    return ((ngx_int_t )0);
  } else
#line 4601
  if (expires___0 < (time_t )ngx_cached_time->sec) {
#line 4602
    u->cacheable = 0U;
#line 4603
    return ((ngx_int_t )0);
  }
#line 4606
  (r->cache)->valid_sec = expires___0;
#line 4610
  return ((ngx_int_t )0);
}
}
#line 4614 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_accel_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;
  u_char *p ;
  size_t___0 len ;
  ngx_int_t n ;

  {
#line 4620
  u = r->upstream;
#line 4621
  u->headers_in.x_accel_expires = h;
#line 4629
  if ((u->conf)->ignore_headers & 4UL) {
#line 4630
    return ((ngx_int_t )0);
  }
#line 4633
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4634
    return ((ngx_int_t )0);
  }
#line 4637
  len = h->value.len;
#line 4638
  p = h->value.data;
#line 4640
  if ((int )*(p + 0) != 64) {
    {
#line 4641
    n = ngx_atoi(p, len);
    }
    {
#line 4644
    if (n == 0L) {
#line 4644
      goto case_0;
    }
#line 4648
    if (n == -1L) {
#line 4648
      goto case_neg_1;
    }
#line 4651
    goto switch_default;
    case_0: /* CIL Label */ 
#line 4645
    u->cacheable = 0U;
    case_neg_1: /* CIL Label */ 
#line 4649
    return ((ngx_int_t )0);
    switch_default: /* CIL Label */ 
#line 4652
    (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )n);
#line 4653
    return ((ngx_int_t )0);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 4657
  p ++;
#line 4658
  len --;
#line 4660
  n = ngx_atoi(p, len);
  }
#line 4662
  if (n != -1L) {
#line 4663
    (r->cache)->valid_sec = n;
  }
#line 4668
  return ((ngx_int_t )0);
}
}
#line 4672 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_limit_rate(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_int_t n ;
  ngx_http_upstream_t *u ;

  {
#line 4679
  u = r->upstream;
#line 4680
  u->headers_in.x_accel_limit_rate = h;
#line 4682
  if ((u->conf)->ignore_headers & 64UL) {
#line 4683
    return ((ngx_int_t )0);
  }
  {
#line 4686
  n = ngx_atoi(h->value.data, h->value.len);
  }
#line 4688
  if (n != -1L) {
#line 4689
    r->limit_rate = (size_t___0 )n;
  }
#line 4692
  return ((ngx_int_t )0);
}
}
#line 4696 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_buffering(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  u_char c0 ;
  u_char c1 ;
  u_char c2 ;
  ngx_http_upstream_t *u ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 4703
  u = r->upstream;
#line 4705
  if ((u->conf)->ignore_headers & 128UL) {
#line 4706
    return ((ngx_int_t )0);
  }
#line 4709
  if ((u->conf)->change_buffering) {
#line 4711
    if (h->value.len == 2UL) {
#line 4712
      if ((int )*(h->value.data + 0) >= 65) {
#line 4712
        if ((int )*(h->value.data + 0) <= 90) {
#line 4712
          tmp = (int )*(h->value.data + 0) | 32;
        } else {
#line 4712
          tmp = (int )*(h->value.data + 0);
        }
      } else {
#line 4712
        tmp = (int )*(h->value.data + 0);
      }
#line 4712
      c0 = (u_char )tmp;
#line 4713
      if ((int )*(h->value.data + 1) >= 65) {
#line 4713
        if ((int )*(h->value.data + 1) <= 90) {
#line 4713
          tmp___0 = (int )*(h->value.data + 1) | 32;
        } else {
#line 4713
          tmp___0 = (int )*(h->value.data + 1);
        }
      } else {
#line 4713
        tmp___0 = (int )*(h->value.data + 1);
      }
#line 4713
      c1 = (u_char )tmp___0;
#line 4715
      if ((int )c0 == 110) {
#line 4715
        if ((int )c1 == 111) {
#line 4716
          u->buffering = 0U;
        }
      }
    } else
#line 4719
    if (h->value.len == 3UL) {
#line 4720
      if ((int )*(h->value.data + 0) >= 65) {
#line 4720
        if ((int )*(h->value.data + 0) <= 90) {
#line 4720
          tmp___1 = (int )*(h->value.data + 0) | 32;
        } else {
#line 4720
          tmp___1 = (int )*(h->value.data + 0);
        }
      } else {
#line 4720
        tmp___1 = (int )*(h->value.data + 0);
      }
#line 4720
      c0 = (u_char )tmp___1;
#line 4721
      if ((int )*(h->value.data + 1) >= 65) {
#line 4721
        if ((int )*(h->value.data + 1) <= 90) {
#line 4721
          tmp___2 = (int )*(h->value.data + 1) | 32;
        } else {
#line 4721
          tmp___2 = (int )*(h->value.data + 1);
        }
      } else {
#line 4721
        tmp___2 = (int )*(h->value.data + 1);
      }
#line 4721
      c1 = (u_char )tmp___2;
#line 4722
      if ((int )*(h->value.data + 2) >= 65) {
#line 4722
        if ((int )*(h->value.data + 2) <= 90) {
#line 4722
          tmp___3 = (int )*(h->value.data + 2) | 32;
        } else {
#line 4722
          tmp___3 = (int )*(h->value.data + 2);
        }
      } else {
#line 4722
        tmp___3 = (int )*(h->value.data + 2);
      }
#line 4722
      c2 = (u_char )tmp___3;
#line 4724
      if ((int )c0 == 121) {
#line 4724
        if ((int )c1 == 101) {
#line 4724
          if ((int )c2 == 115) {
#line 4725
            u->buffering = 1U;
          }
        }
      }
    }
  }
#line 4730
  return ((ngx_int_t )0);
}
}
#line 4734 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_charset(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) 
{ 


  {
#line 4738
  if (((r->upstream)->conf)->ignore_headers & 256UL) {
#line 4739
    return ((ngx_int_t )0);
  }
#line 4742
  r->headers_out.override_charset = & h->value;
#line 4744
  return ((ngx_int_t )0);
}
}
#line 4748 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  u_char *tmp ;

  {
  {
#line 4752
  (r->upstream)->headers_in.connection = h;
#line 4754
  tmp = ngx_strlcasestrn(h->value.data, h->value.data + h->value.len, (u_char *)"close",
                         (size_t___0 )4);
  }
#line 4754
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 4758
    (r->upstream)->headers_in.connection_close = 1U;
  }
#line 4761
  return ((ngx_int_t )0);
}
}
#line 4765 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r ,
                                                             ngx_table_elt_t *h ,
                                                             ngx_uint_t offset ) 
{ 
  u_char *tmp ;

  {
  {
#line 4769
  (r->upstream)->headers_in.transfer_encoding = h;
#line 4771
  tmp = ngx_strlcasestrn(h->value.data, h->value.data + h->value.len, (u_char *)"chunked",
                         (size_t___0 )6);
  }
#line 4771
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 4775
    (r->upstream)->headers_in.chunked = 1U;
  }
#line 4778
  return ((ngx_int_t )0);
}
}
#line 4782 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_vary(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;

  {
#line 4788
  u = r->upstream;
#line 4789
  u->headers_in.vary = h;
#line 4793
  if ((u->conf)->ignore_headers & 512UL) {
#line 4794
    return ((ngx_int_t )0);
  }
#line 4797
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4798
    return ((ngx_int_t )0);
  }
#line 4801
  if (h->value.len > 128UL) {
#line 4804
    u->cacheable = 0U;
  } else
#line 4801
  if (h->value.len == 1UL) {
#line 4801
    if ((int )*(h->value.data + 0) == 42) {
#line 4804
      u->cacheable = 0U;
    }
  }
#line 4807
  (r->cache)->vary = h->value;
#line 4811
  return ((ngx_int_t )0);
}
}
#line 4815 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  ngx_table_elt_t **ph ;
  void *tmp ;

  {
  {
#line 4821
  tmp = ngx_list_push(& r->headers_out.headers);
#line 4821
  ho = (ngx_table_elt_t *)tmp;
  }
#line 4822
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 4823
    return ((ngx_int_t )-1);
  }
#line 4826
  *ho = *h;
#line 4828
  if (offset) {
#line 4829
    ph = (ngx_table_elt_t **)((char *)(& r->headers_out) + offset);
#line 4830
    *ph = ho;
  }
#line 4833
  return ((ngx_int_t )0);
}
}
#line 4837 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r ,
                                                           ngx_table_elt_t *h , ngx_uint_t offset ) 
{ 
  ngx_array_t *pa ;
  ngx_table_elt_t *ho ;
  ngx_table_elt_t **ph ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4844
  pa = (ngx_array_t *)((char *)(& r->headers_out) + offset);
#line 4846
  if ((unsigned long )pa->elts == (unsigned long )((void *)0)) {
    {
#line 4847
    tmp = ngx_array_init(pa, r->pool, (ngx_uint_t )2, sizeof(ngx_table_elt_t *));
    }
#line 4847
    if (tmp != 0L) {
#line 4849
      return ((ngx_int_t )-1);
    }
  }
  {
#line 4853
  tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 4853
  ho = (ngx_table_elt_t *)tmp___0;
  }
#line 4854
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 4855
    return ((ngx_int_t )-1);
  }
  {
#line 4858
  *ho = *h;
#line 4860
  tmp___1 = ngx_array_push(pa);
#line 4860
  ph = (ngx_table_elt_t **)tmp___1;
  }
#line 4861
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 4862
    return ((ngx_int_t )-1);
  }
#line 4865
  *ph = ho;
#line 4867
  return ((ngx_int_t )0);
}
}
#line 4871 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_content_type(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_int_t tmp ;

  {
#line 4877
  r->headers_out.content_type_len = h->value.len;
#line 4878
  r->headers_out.content_type = h->value;
#line 4879
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 4881
  p = h->value.data;
  {
#line 4881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4881
    if (! *p) {
#line 4881
      goto while_break;
    }
#line 4883
    if ((int )*p != 59) {
#line 4884
      goto __Cont;
    }
#line 4887
    last = p;
    {
#line 4889
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4889
      p ++;
#line 4889
      if (! ((int )*p == 32)) {
#line 4889
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4891
    if ((int )*p == 0) {
#line 4892
      return ((ngx_int_t )0);
    }
    {
#line 4895
    tmp = ngx_strncasecmp(p, (u_char *)"charset=", (size_t___0 )8);
    }
#line 4895
    if (tmp != 0L) {
#line 4896
      goto __Cont;
    }
#line 4899
    p += 8;
#line 4901
    r->headers_out.content_type_len = (size_t___0 )(last - h->value.data);
#line 4903
    if ((int )*p == 34) {
#line 4904
      p ++;
    }
#line 4907
    last = h->value.data + h->value.len;
#line 4909
    if ((int )*(last - 1) == 34) {
#line 4910
      last --;
    }
#line 4913
    r->headers_out.charset.len = (size_t___0 )(last - p);
#line 4914
    r->headers_out.charset.data = p;
#line 4916
    return ((ngx_int_t )0);
    __Cont: /* CIL Label */ 
#line 4881
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4919
  return ((ngx_int_t )0);
}
}
#line 4923 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 4929
  tmp = ngx_list_push(& r->headers_out.headers);
#line 4929
  ho = (ngx_table_elt_t *)tmp;
  }
#line 4930
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 4931
    return ((ngx_int_t )-1);
  }
#line 4934
  *ho = *h;
#line 4936
  r->headers_out.last_modified = ho;
#line 4940
  if ((r->upstream)->cacheable) {
#line 4941
    r->headers_out.last_modified_time = (r->upstream)->headers_in.last_modified_time;
  }
#line 4947
  return ((ngx_int_t )0);
}
}
#line 4951 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_rewrite_location(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) 
{ 
  ngx_int_t rc ;
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 4958
  tmp = ngx_list_push(& r->headers_out.headers);
#line 4958
  ho = (ngx_table_elt_t *)tmp;
  }
#line 4959
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 4960
    return ((ngx_int_t )-1);
  }
#line 4963
  *ho = *h;
#line 4965
  if ((r->upstream)->rewrite_redirect) {
    {
#line 4966
    rc = (*((r->upstream)->rewrite_redirect))(r, ho, (size_t___0 )0);
    }
#line 4968
    if (rc == -5L) {
#line 4969
      return ((ngx_int_t )0);
    }
#line 4972
    if (rc == 0L) {
#line 4973
      r->headers_out.location = ho;
    }
#line 4979
    return (rc);
  }
#line 4982
  if ((int )*(ho->value.data + 0) != 47) {
#line 4983
    r->headers_out.location = ho;
  }
#line 4991
  return ((ngx_int_t )0);
}
}
#line 4995 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) 
{ 
  u_char *p ;
  ngx_int_t rc ;
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 5003
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5003
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5004
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5005
    return ((ngx_int_t )-1);
  }
#line 5008
  *ho = *h;
#line 5010
  if ((r->upstream)->rewrite_redirect) {
    {
#line 5012
    p = ngx_strcasestrn(ho->value.data, (char *)"url=", (size_t___0 )3);
    }
#line 5014
    if (p) {
      {
#line 5015
      rc = (*((r->upstream)->rewrite_redirect))(r, ho, (size_t___0 )((p + 4) - ho->value.data));
      }
    } else {
#line 5018
      return ((ngx_int_t )0);
    }
#line 5021
    if (rc == -5L) {
#line 5022
      return ((ngx_int_t )0);
    }
#line 5025
    if (rc == 0L) {
#line 5026
      r->headers_out.refresh = ho;
    }
#line 5032
    return (rc);
  }
#line 5035
  r->headers_out.refresh = ho;
#line 5037
  return ((ngx_int_t )0);
}
}
#line 5041 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_int_t rc ;
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 5048
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5048
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5049
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5050
    return ((ngx_int_t )-1);
  }
#line 5053
  *ho = *h;
#line 5055
  if ((r->upstream)->rewrite_cookie) {
    {
#line 5056
    rc = (*((r->upstream)->rewrite_cookie))(r, ho);
    }
#line 5058
    if (rc == -5L) {
#line 5059
      return ((ngx_int_t )0);
    }
#line 5069
    return (rc);
  }
#line 5072
  return ((ngx_int_t )0);
}
}
#line 5076 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
#line 5082
  if (((r->upstream)->conf)->force_ranges) {
#line 5083
    return ((ngx_int_t )0);
  }
#line 5088
  if (r->cached) {
#line 5089
    r->allow_ranges = 1U;
#line 5090
    return ((ngx_int_t )0);
  }
#line 5093
  if ((r->upstream)->cacheable) {
#line 5094
    r->allow_ranges = 1U;
#line 5095
    r->single_range = 1U;
#line 5096
    return ((ngx_int_t )0);
  }
  {
#line 5101
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5101
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5102
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5103
    return ((ngx_int_t )-1);
  }
#line 5106
  *ho = *h;
#line 5108
  r->headers_out.accept_ranges = ho;
#line 5110
  return ((ngx_int_t )0);
}
}
#line 5116 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 5122
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5122
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5123
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5124
    return ((ngx_int_t )-1);
  }
#line 5127
  *ho = *h;
#line 5129
  r->headers_out.content_encoding = ho;
#line 5131
  return ((ngx_int_t )0);
}
}
#line 5137 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 5142
  v = ngx_http_upstream_vars;
  {
#line 5142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5142
    if (! v->name.len) {
#line 5142
      goto while_break;
    }
    {
#line 5143
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 5144
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 5145
      return ((ngx_int_t )-1);
    }
#line 5148
    var->get_handler = v->get_handler;
#line 5149
    var->data = v->data;
#line 5142
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5152
  return ((ngx_int_t )0);
}
}
#line 5156 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_addr_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;

  {
#line 5165
  v->valid = 1U;
#line 5166
  v->no_cacheable = 0U;
#line 5167
  v->not_found = 0U;
#line 5169
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5170
    v->not_found = 1U;
#line 5171
    return ((ngx_int_t )0);
  } else
#line 5169
  if ((r->upstream_states)->nelts == 0UL) {
#line 5170
    v->not_found = 1U;
#line 5171
    return ((ngx_int_t )0);
  }
#line 5174
  len = (size_t___0 )0;
#line 5175
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
#line 5177
  i = (ngx_uint_t )0;
  {
#line 5177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5177
    if (! (i < (r->upstream_states)->nelts)) {
#line 5177
      goto while_break;
    }
#line 5178
    if ((state + i)->peer) {
#line 5179
      len += ((state + i)->peer)->len + 2UL;
    } else {
#line 5182
      len += 3UL;
    }
#line 5177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5186
  tmp = ngx_pnalloc(r->pool, len);
#line 5186
  p = (u_char *)tmp;
  }
#line 5187
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5188
    return ((ngx_int_t )-1);
  }
#line 5191
  v->data = p;
#line 5193
  i = (ngx_uint_t )0;
  {
#line 5195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5196
    if ((state + i)->peer) {
      {
#line 5197
      tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((state + i)->peer)->data,
                       ((state + i)->peer)->len);
#line 5197
      p = (u_char *)tmp___0 + ((state + i)->peer)->len;
      }
    }
#line 5200
    i ++;
#line 5200
    if (i == (r->upstream_states)->nelts) {
#line 5201
      goto while_break___0;
    }
#line 5204
    if ((state + i)->peer) {
#line 5205
      tmp___1 = p;
#line 5205
      p ++;
#line 5205
      *tmp___1 = (u_char )',';
#line 5206
      tmp___2 = p;
#line 5206
      p ++;
#line 5206
      *tmp___2 = (u_char )' ';
    } else {
#line 5209
      tmp___3 = p;
#line 5209
      p ++;
#line 5209
      *tmp___3 = (u_char )' ';
#line 5210
      tmp___4 = p;
#line 5210
      p ++;
#line 5210
      *tmp___4 = (u_char )':';
#line 5211
      tmp___5 = p;
#line 5211
      p ++;
#line 5211
      *tmp___5 = (u_char )' ';
#line 5213
      i ++;
#line 5213
      if (i == (r->upstream_states)->nelts) {
#line 5214
        goto while_break___0;
      }
#line 5217
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5221
  v->len = (unsigned int )(p - v->data);
#line 5223
  return ((ngx_int_t )0);
}
}
#line 5227 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_status_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;

  {
#line 5236
  v->valid = 1U;
#line 5237
  v->no_cacheable = 0U;
#line 5238
  v->not_found = 0U;
#line 5240
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5241
    v->not_found = 1U;
#line 5242
    return ((ngx_int_t )0);
  } else
#line 5240
  if ((r->upstream_states)->nelts == 0UL) {
#line 5241
    v->not_found = 1U;
#line 5242
    return ((ngx_int_t )0);
  }
  {
#line 5245
  len = (r->upstream_states)->nelts * 5UL;
#line 5247
  tmp = ngx_pnalloc(r->pool, len);
#line 5247
  p = (u_char *)tmp;
  }
#line 5248
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5249
    return ((ngx_int_t )-1);
  }
#line 5252
  v->data = p;
#line 5254
  i = (ngx_uint_t )0;
#line 5255
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
  {
#line 5257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5258
    if ((state + i)->status) {
      {
#line 5259
      p = ngx_sprintf(p, "%ui", (state + i)->status);
      }
    } else {
#line 5262
      tmp___0 = p;
#line 5262
      p ++;
#line 5262
      *tmp___0 = (u_char )'-';
    }
#line 5265
    i ++;
#line 5265
    if (i == (r->upstream_states)->nelts) {
#line 5266
      goto while_break;
    }
#line 5269
    if ((state + i)->peer) {
#line 5270
      tmp___1 = p;
#line 5270
      p ++;
#line 5270
      *tmp___1 = (u_char )',';
#line 5271
      tmp___2 = p;
#line 5271
      p ++;
#line 5271
      *tmp___2 = (u_char )' ';
    } else {
#line 5274
      tmp___3 = p;
#line 5274
      p ++;
#line 5274
      *tmp___3 = (u_char )' ';
#line 5275
      tmp___4 = p;
#line 5275
      p ++;
#line 5275
      *tmp___4 = (u_char )':';
#line 5276
      tmp___5 = p;
#line 5276
      p ++;
#line 5276
      *tmp___5 = (u_char )' ';
#line 5278
      i ++;
#line 5278
      if (i == (r->upstream_states)->nelts) {
#line 5279
        goto while_break;
      }
#line 5282
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5286
  v->len = (unsigned int )(p - v->data);
#line 5288
  return ((ngx_int_t )0);
}
}
#line 5292 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_response_time_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_msec_int_t ms ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;

  {
#line 5302
  v->valid = 1U;
#line 5303
  v->no_cacheable = 0U;
#line 5304
  v->not_found = 0U;
#line 5306
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5307
    v->not_found = 1U;
#line 5308
    return ((ngx_int_t )0);
  } else
#line 5306
  if ((r->upstream_states)->nelts == 0UL) {
#line 5307
    v->not_found = 1U;
#line 5308
    return ((ngx_int_t )0);
  }
  {
#line 5311
  len = (r->upstream_states)->nelts * (((sizeof("-9223372036854775808") - 1UL) + 4UL) + 2UL);
#line 5313
  tmp = ngx_pnalloc(r->pool, len);
#line 5313
  p = (u_char *)tmp;
  }
#line 5314
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5315
    return ((ngx_int_t )-1);
  }
#line 5318
  v->data = p;
#line 5320
  i = (ngx_uint_t )0;
#line 5321
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
  {
#line 5323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5324
    if ((state + i)->status) {
#line 5326
      if (data == 1UL) {
#line 5326
        if ((state + i)->header_time != 0xffffffffffffffffUL) {
#line 5327
          ms = (ngx_msec_int_t )(state + i)->header_time;
        } else {
#line 5326
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 5329
      if (data == 2UL) {
#line 5329
        if ((state + i)->connect_time != 0xffffffffffffffffUL) {
#line 5330
          ms = (ngx_msec_int_t )(state + i)->connect_time;
        } else {
#line 5333
          ms = (ngx_msec_int_t )(state + i)->response_time;
        }
      } else {
#line 5333
        ms = (ngx_msec_int_t )(state + i)->response_time;
      }
#line 5336
      if (ms < 0L) {
#line 5336
        ms = (ngx_msec_int_t )0;
      } else {
#line 5336
        ms = ms;
      }
      {
#line 5337
      p = ngx_sprintf(p, "%T.%03M", ms / 1000L, ms % 1000L);
      }
    } else {
#line 5340
      tmp___0 = p;
#line 5340
      p ++;
#line 5340
      *tmp___0 = (u_char )'-';
    }
#line 5343
    i ++;
#line 5343
    if (i == (r->upstream_states)->nelts) {
#line 5344
      goto while_break;
    }
#line 5347
    if ((state + i)->peer) {
#line 5348
      tmp___1 = p;
#line 5348
      p ++;
#line 5348
      *tmp___1 = (u_char )',';
#line 5349
      tmp___2 = p;
#line 5349
      p ++;
#line 5349
      *tmp___2 = (u_char )' ';
    } else {
#line 5352
      tmp___3 = p;
#line 5352
      p ++;
#line 5352
      *tmp___3 = (u_char )' ';
#line 5353
      tmp___4 = p;
#line 5353
      p ++;
#line 5353
      *tmp___4 = (u_char )':';
#line 5354
      tmp___5 = p;
#line 5354
      p ++;
#line 5354
      *tmp___5 = (u_char )' ';
#line 5356
      i ++;
#line 5356
      if (i == (r->upstream_states)->nelts) {
#line 5357
        goto while_break;
      }
#line 5360
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5364
  v->len = (unsigned int )(p - v->data);
#line 5366
  return ((ngx_int_t )0);
}
}
#line 5370 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_response_length_variable(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;

  {
#line 5379
  v->valid = 1U;
#line 5380
  v->no_cacheable = 0U;
#line 5381
  v->not_found = 0U;
#line 5383
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5384
    v->not_found = 1U;
#line 5385
    return ((ngx_int_t )0);
  } else
#line 5383
  if ((r->upstream_states)->nelts == 0UL) {
#line 5384
    v->not_found = 1U;
#line 5385
    return ((ngx_int_t )0);
  }
  {
#line 5388
  len = (r->upstream_states)->nelts * ((sizeof("-9223372036854775808") - 1UL) + 2UL);
#line 5390
  tmp = ngx_pnalloc(r->pool, len);
#line 5390
  p = (u_char *)tmp;
  }
#line 5391
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5392
    return ((ngx_int_t )-1);
  }
#line 5395
  v->data = p;
#line 5397
  i = (ngx_uint_t )0;
#line 5398
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
  {
#line 5400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5402
    if (data == 1UL) {
      {
#line 5403
      p = ngx_sprintf(p, "%O", (state + i)->bytes_received);
      }
    } else {
      {
#line 5406
      p = ngx_sprintf(p, "%O", (state + i)->response_length);
      }
    }
#line 5409
    i ++;
#line 5409
    if (i == (r->upstream_states)->nelts) {
#line 5410
      goto while_break;
    }
#line 5413
    if ((state + i)->peer) {
#line 5414
      tmp___0 = p;
#line 5414
      p ++;
#line 5414
      *tmp___0 = (u_char )',';
#line 5415
      tmp___1 = p;
#line 5415
      p ++;
#line 5415
      *tmp___1 = (u_char )' ';
    } else {
#line 5418
      tmp___2 = p;
#line 5418
      p ++;
#line 5418
      *tmp___2 = (u_char )' ';
#line 5419
      tmp___3 = p;
#line 5419
      p ++;
#line 5419
      *tmp___3 = (u_char )':';
#line 5420
      tmp___4 = p;
#line 5420
      p ++;
#line 5420
      *tmp___4 = (u_char )' ';
#line 5422
      i ++;
#line 5422
      if (i == (r->upstream_states)->nelts) {
#line 5423
        goto while_break;
      }
#line 5426
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5430
  v->len = (unsigned int )(p - v->data);
#line 5432
  return ((ngx_int_t )0);
}
}
#line 5436 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_header_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
#line 5440
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5441
    v->not_found = 1U;
#line 5442
    return ((ngx_int_t )0);
  }
  {
#line 5445
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & (r->upstream)->headers_in.headers.part,
                                         sizeof("upstream_http_") - 1UL);
  }
#line 5445
  return (tmp);
}
}
#line 5451 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cookie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  ngx_str_t *name ;
  ngx_str_t cookie ;
  ngx_str_t s ;
  ngx_int_t tmp ;

  {
#line 5455
  name = (ngx_str_t *)data;
#line 5459
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5460
    v->not_found = 1U;
#line 5461
    return ((ngx_int_t )0);
  }
  {
#line 5464
  s.len = name->len - (sizeof("upstream_cookie_") - 1UL);
#line 5465
  s.data = (name->data + sizeof("upstream_cookie_")) - 1;
#line 5467
  tmp = ngx_http_parse_set_cookie_lines(& (r->upstream)->headers_in.cookies, & s,
                                        & cookie);
  }
#line 5467
  if (tmp == -5L) {
#line 5471
    v->not_found = 1U;
#line 5472
    return ((ngx_int_t )0);
  }
#line 5475
  v->len = (unsigned int )cookie.len;
#line 5476
  v->valid = 1U;
#line 5477
  v->no_cacheable = 0U;
#line 5478
  v->not_found = 0U;
#line 5479
  v->data = cookie.data;
#line 5481
  return ((ngx_int_t )0);
}
}
#line 5487 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  ngx_uint_t n ;

  {
#line 5493
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5494
    v->not_found = 1U;
#line 5495
    return ((ngx_int_t )0);
  } else
#line 5493
  if ((r->upstream)->cache_status == 0U) {
#line 5494
    v->not_found = 1U;
#line 5495
    return ((ngx_int_t )0);
  }
#line 5498
  n = (ngx_uint_t )((r->upstream)->cache_status - 1U);
#line 5500
  v->valid = 1U;
#line 5501
  v->no_cacheable = 0U;
#line 5502
  v->not_found = 0U;
#line 5503
  v->len = (unsigned int )ngx_http_cache_status[n].len;
#line 5504
  v->data = ngx_http_cache_status[n].data;
#line 5506
  return ((ngx_int_t )0);
}
}
#line 5510 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 5516
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5521
    v->not_found = 1U;
#line 5522
    return ((ngx_int_t )0);
  } else
#line 5516
  if (! ((r->upstream)->conf)->cache_revalidate) {
#line 5521
    v->not_found = 1U;
#line 5522
    return ((ngx_int_t )0);
  } else
#line 5516
  if ((r->upstream)->cache_status != 3U) {
#line 5521
    v->not_found = 1U;
#line 5522
    return ((ngx_int_t )0);
  } else
#line 5516
  if ((r->cache)->last_modified == -1L) {
#line 5521
    v->not_found = 1U;
#line 5522
    return ((ngx_int_t )0);
  }
  {
#line 5525
  tmp = ngx_pnalloc(r->pool, sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1UL);
#line 5525
  p = (u_char *)tmp;
  }
#line 5526
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5527
    return ((ngx_int_t )-1);
  }
  {
#line 5530
  tmp___0 = ngx_http_time(p, (r->cache)->last_modified);
#line 5530
  v->len = (unsigned int )(tmp___0 - p);
#line 5531
  v->valid = 1U;
#line 5532
  v->no_cacheable = 0U;
#line 5533
  v->not_found = 0U;
#line 5534
  v->data = p;
  }
#line 5536
  return ((ngx_int_t )0);
}
}
#line 5540 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_etag(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 


  {
#line 5544
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5549
    v->not_found = 1U;
#line 5550
    return ((ngx_int_t )0);
  } else
#line 5544
  if (! ((r->upstream)->conf)->cache_revalidate) {
#line 5549
    v->not_found = 1U;
#line 5550
    return ((ngx_int_t )0);
  } else
#line 5544
  if ((r->upstream)->cache_status != 3U) {
#line 5549
    v->not_found = 1U;
#line 5550
    return ((ngx_int_t )0);
  } else
#line 5544
  if ((r->cache)->etag.len == 0UL) {
#line 5549
    v->not_found = 1U;
#line 5550
    return ((ngx_int_t )0);
  }
#line 5553
  v->valid = 1U;
#line 5554
  v->no_cacheable = 0U;
#line 5555
  v->not_found = 0U;
#line 5556
  v->len = (unsigned int )(r->cache)->etag.len;
#line 5557
  v->data = (r->cache)->etag.data;
#line 5559
  return ((ngx_int_t )0);
}
}
#line 5565 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static char *ngx_http_upstream(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) 
{ 
  char *rv ;
  void *mconf ;
  ngx_str_t *value ;
  ngx_url_t u ;
  ngx_uint_t m ;
  ngx_conf_t pcf ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *http_ctx ;
  ngx_http_upstream_srv_conf_t *uscf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 5578
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 5580
  value = (ngx_str_t *)(cf->args)->elts;
#line 5581
  u.host = *(value + 1);
#line 5582
  u.no_resolve = 1U;
#line 5583
  u.no_port = 1U;
#line 5585
  uscf = ngx_http_upstream_add(cf, & u, (ngx_uint_t )319);
  }
#line 5592
  if ((unsigned long )uscf == (unsigned long )((void *)0)) {
#line 5593
    return ((char *)((void *)-1));
  }
  {
#line 5597
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 5597
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 5598
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 5599
    return ((char *)((void *)-1));
  }
  {
#line 5602
  http_ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 5603
  ctx->main_conf = http_ctx->main_conf;
#line 5607
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 5607
  ctx->srv_conf = (void **)tmp___0;
  }
#line 5608
  if ((unsigned long )ctx->srv_conf == (unsigned long )((void *)0)) {
#line 5609
    return ((char *)((void *)-1));
  }
  {
#line 5612
  *(ctx->srv_conf + ngx_http_upstream_module.ctx_index) = (void *)uscf;
#line 5614
  uscf->srv_conf = ctx->srv_conf;
#line 5619
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 5619
  ctx->loc_conf = (void **)tmp___1;
  }
#line 5620
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 5621
    return ((char *)((void *)-1));
  }
#line 5624
  m = (ngx_uint_t )0;
  {
#line 5624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5624
    if (! *((cf->cycle)->modules + m)) {
#line 5624
      goto while_break;
    }
#line 5625
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 5626
      goto __Cont;
    }
#line 5629
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 5631
    if (module->create_srv_conf) {
      {
#line 5632
      mconf = (*(module->create_srv_conf))(cf);
      }
#line 5633
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 5634
        return ((char *)((void *)-1));
      }
#line 5637
      *(ctx->srv_conf + (*((cf->cycle)->modules + m))->ctx_index) = mconf;
    }
#line 5640
    if (module->create_loc_conf) {
      {
#line 5641
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 5642
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 5643
        return ((char *)((void *)-1));
      }
#line 5646
      *(ctx->loc_conf + (*((cf->cycle)->modules + m))->ctx_index) = mconf;
    }
    __Cont: /* CIL Label */ 
#line 5624
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5650
  uscf->servers = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_server_t ));
  }
#line 5652
  if ((unsigned long )uscf->servers == (unsigned long )((void *)0)) {
#line 5653
    return ((char *)((void *)-1));
  }
  {
#line 5659
  pcf = *cf;
#line 5660
  cf->ctx = (void *)ctx;
#line 5661
  cf->cmd_type = (ngx_uint_t )268435456;
#line 5663
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 5665
  *cf = pcf;
  }
#line 5667
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 5668
    return (rv);
  }
#line 5671
  if ((uscf->servers)->nelts == 0UL) {
    {
#line 5672
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "no servers are inside upstream");
    }
#line 5674
    return ((char *)((void *)-1));
  }
#line 5677
  return (rv);
}
}
#line 5681 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static char *ngx_http_upstream_server(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;
  time_t fail_timeout ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_url_t u ;
  ngx_int_t weight ;
  ngx_int_t max_conns ;
  ngx_int_t max_fails ;
  ngx_uint_t i ;
  ngx_http_upstream_server_t *us ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ngx_int_t tmp___6 ;

  {
  {
#line 5684
  uscf = (ngx_http_upstream_srv_conf_t *)conf;
#line 5693
  tmp = ngx_array_push(uscf->servers);
#line 5693
  us = (ngx_http_upstream_server_t *)tmp;
  }
#line 5694
  if ((unsigned long )us == (unsigned long )((void *)0)) {
#line 5695
    return ((char *)((void *)-1));
  }
  {
#line 5698
  memset((void *)us, 0, sizeof(ngx_http_upstream_server_t ));
#line 5700
  value = (ngx_str_t *)(cf->args)->elts;
#line 5702
  weight = (ngx_int_t )1;
#line 5703
  max_conns = (ngx_int_t )0;
#line 5704
  max_fails = (ngx_int_t )1;
#line 5705
  fail_timeout = (time_t )10;
#line 5707
  i = (ngx_uint_t )2;
  }
  {
#line 5707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5707
    if (! (i < (cf->args)->nelts)) {
#line 5707
      goto while_break;
    }
    {
#line 5709
    tmp___0 = strncmp((char const   *)(value + i)->data, "weight=", (size_t )7);
    }
#line 5709
    if (tmp___0 == 0) {
#line 5711
      if (! (uscf->flags & 2UL)) {
#line 5712
        goto not_supported;
      }
      {
#line 5715
      weight = ngx_atoi((value + i)->data + 7, (value + i)->len - 7UL);
      }
#line 5717
      if (weight == -1L) {
#line 5718
        goto invalid;
      } else
#line 5717
      if (weight == 0L) {
#line 5718
        goto invalid;
      }
#line 5721
      goto __Cont;
    }
    {
#line 5724
    tmp___1 = strncmp((char const   *)(value + i)->data, "max_conns=", (size_t )10);
    }
#line 5724
    if (tmp___1 == 0) {
#line 5726
      if (! (uscf->flags & 256UL)) {
#line 5727
        goto not_supported;
      }
      {
#line 5730
      max_conns = ngx_atoi((value + i)->data + 10, (value + i)->len - 10UL);
      }
#line 5732
      if (max_conns == -1L) {
#line 5733
        goto invalid;
      }
#line 5736
      goto __Cont;
    }
    {
#line 5739
    tmp___2 = strncmp((char const   *)(value + i)->data, "max_fails=", (size_t )10);
    }
#line 5739
    if (tmp___2 == 0) {
#line 5741
      if (! (uscf->flags & 4UL)) {
#line 5742
        goto not_supported;
      }
      {
#line 5745
      max_fails = ngx_atoi((value + i)->data + 10, (value + i)->len - 10UL);
      }
#line 5747
      if (max_fails == -1L) {
#line 5748
        goto invalid;
      }
#line 5751
      goto __Cont;
    }
    {
#line 5754
    tmp___3 = strncmp((char const   *)(value + i)->data, "fail_timeout=", (size_t )13);
    }
#line 5754
    if (tmp___3 == 0) {
#line 5756
      if (! (uscf->flags & 8UL)) {
#line 5757
        goto not_supported;
      }
      {
#line 5760
      s.len = (value + i)->len - 13UL;
#line 5761
      s.data = (value + i)->data + 13;
#line 5763
      fail_timeout = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 5765
      if (fail_timeout == -1L) {
#line 5766
        goto invalid;
      }
#line 5769
      goto __Cont;
    }
    {
#line 5772
    tmp___4 = strcmp((char const   *)(value + i)->data, "backup");
    }
#line 5772
    if (tmp___4 == 0) {
#line 5774
      if (! (uscf->flags & 32UL)) {
#line 5775
        goto not_supported;
      }
#line 5778
      us->backup = 1U;
#line 5780
      goto __Cont;
    }
    {
#line 5783
    tmp___5 = strcmp((char const   *)(value + i)->data, "down");
    }
#line 5783
    if (tmp___5 == 0) {
#line 5785
      if (! (uscf->flags & 16UL)) {
#line 5786
        goto not_supported;
      }
#line 5789
      us->down = 1U;
#line 5791
      goto __Cont;
    }
#line 5794
    goto invalid;
    __Cont: /* CIL Label */ 
#line 5707
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5797
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 5799
  u.url = *(value + 1);
#line 5800
  u.default_port = (in_port_t )80;
#line 5802
  tmp___6 = ngx_parse_url(cf->pool, & u);
  }
#line 5802
  if (tmp___6 != 0L) {
#line 5803
    if (u.err) {
      {
#line 5804
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in upstream \"%V\"", u.err, & u.url);
      }
    }
#line 5808
    return ((char *)((void *)-1));
  }
#line 5811
  us->name = u.url;
#line 5812
  us->addrs = u.addrs;
#line 5813
  us->naddrs = u.naddrs;
#line 5814
  us->weight = (ngx_uint_t )weight;
#line 5815
  us->max_conns = (ngx_uint_t )max_conns;
#line 5816
  us->max_fails = (ngx_uint_t )max_fails;
#line 5817
  us->fail_timeout = fail_timeout;
#line 5819
  return ((char *)((void *)0));
  invalid: 
  {
#line 5823
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
  }
#line 5826
  return ((char *)((void *)-1));
  not_supported: 
  {
#line 5830
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "balancing method does not support parameter \"%V\"",
                     value + i);
  }
#line 5834
  return ((char *)((void *)-1));
}
}
#line 5838 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
ngx_http_upstream_srv_conf_t *ngx_http_upstream_add(ngx_conf_t *cf , ngx_url_t *u ,
                                                    ngx_uint_t flags ) 
{ 
  ngx_uint_t i ;
  ngx_http_upstream_server_t *us ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_http_upstream_main_conf_t *umcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 5846
  if (! (flags & 1UL)) {
    {
#line 5848
    tmp = ngx_parse_url(cf->pool, u);
    }
#line 5848
    if (tmp != 0L) {
#line 5849
      if (u->err) {
        {
#line 5850
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in upstream \"%V\"", u->err,
                           & u->url);
        }
      }
#line 5854
      return ((ngx_http_upstream_srv_conf_t *)((void *)0));
    }
  }
#line 5858
  umcf = (ngx_http_upstream_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_upstream_module.ctx_index);
#line 5860
  uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 5862
  i = (ngx_uint_t )0;
  {
#line 5862
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5862
    if (! (i < umcf->upstreams.nelts)) {
#line 5862
      goto while_break;
    }
#line 5864
    if ((*(uscfp + i))->host.len != u->host.len) {
#line 5868
      goto __Cont;
    } else {
      {
#line 5864
      tmp___0 = ngx_strncasecmp((*(uscfp + i))->host.data, u->host.data, u->host.len);
      }
#line 5864
      if (tmp___0 != 0L) {
#line 5868
        goto __Cont;
      }
    }
#line 5871
    if (flags & 1UL) {
#line 5871
      if ((*(uscfp + i))->flags & 1UL) {
        {
#line 5874
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate upstream \"%V\"", & u->host);
        }
#line 5876
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
    }
#line 5879
    if ((*(uscfp + i))->flags & 1UL) {
#line 5879
      if (! u->no_port) {
        {
#line 5880
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "upstream \"%V\" may not have port %d",
                           & u->host, (int )u->port);
        }
#line 5883
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
    }
#line 5886
    if (flags & 1UL) {
#line 5886
      if (! (*(uscfp + i))->no_port) {
#line 5887
        if ((cf->log)->log_level >= 1UL) {
          {
#line 5887
          ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "upstream \"%V\" may not have port %d in %s:%ui",
                             & u->host, (int )(*(uscfp + i))->port, (*(uscfp + i))->file_name,
                             (*(uscfp + i))->line);
          }
        }
#line 5891
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
    }
#line 5894
    if ((*(uscfp + i))->port) {
#line 5894
      if (u->port) {
#line 5894
        if ((int )(*(uscfp + i))->port != (int )u->port) {
#line 5897
          goto __Cont;
        }
      }
    }
#line 5900
    if (flags & 1UL) {
#line 5901
      (*(uscfp + i))->flags = flags;
#line 5902
      (*(uscfp + i))->port = (in_port_t )0;
    }
#line 5905
    return (*(uscfp + i));
    __Cont: /* CIL Label */ 
#line 5862
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5908
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_srv_conf_t ));
#line 5908
  uscf = (ngx_http_upstream_srv_conf_t *)tmp___1;
  }
#line 5909
  if ((unsigned long )uscf == (unsigned long )((void *)0)) {
#line 5910
    return ((ngx_http_upstream_srv_conf_t *)((void *)0));
  }
#line 5913
  uscf->flags = flags;
#line 5914
  uscf->host = u->host;
#line 5915
  uscf->file_name = (cf->conf_file)->file.name.data;
#line 5916
  uscf->line = (cf->conf_file)->line;
#line 5917
  uscf->port = u->port;
#line 5918
  uscf->no_port = (ngx_uint_t )u->no_port;
#line 5920
  if (u->naddrs == 1UL) {
#line 5920
    if (u->port) {
#line 5920
      goto _L;
    } else
#line 5920
    if (u->family == 1) {
      _L: /* CIL Label */ 
      {
#line 5921
      uscf->servers = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_upstream_server_t ));
      }
#line 5923
      if ((unsigned long )uscf->servers == (unsigned long )((void *)0)) {
#line 5924
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
      {
#line 5927
      tmp___2 = ngx_array_push(uscf->servers);
#line 5927
      us = (ngx_http_upstream_server_t *)tmp___2;
      }
#line 5928
      if ((unsigned long )us == (unsigned long )((void *)0)) {
#line 5929
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
      {
#line 5932
      memset((void *)us, 0, sizeof(ngx_http_upstream_server_t ));
#line 5934
      us->addrs = u->addrs;
#line 5935
      us->naddrs = (ngx_uint_t )1;
      }
    }
  }
  {
#line 5938
  tmp___3 = ngx_array_push(& umcf->upstreams);
#line 5938
  uscfp = (ngx_http_upstream_srv_conf_t **)tmp___3;
  }
#line 5939
  if ((unsigned long )uscfp == (unsigned long )((void *)0)) {
#line 5940
    return ((ngx_http_upstream_srv_conf_t *)((void *)0));
  }
#line 5943
  *uscfp = uscf;
#line 5945
  return (uscf);
}
}
#line 5949 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
char *ngx_http_upstream_bind_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_int_t rc ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_upstream_local_t **plocal ;
  ngx_http_upstream_local_t *local ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 5953
  p = (char *)conf;
#line 5961
  plocal = (ngx_http_upstream_local_t **)(p + cmd->offset);
#line 5963
  if ((unsigned long )*plocal != (unsigned long )((void *)-1)) {
#line 5964
    return ((char *)"is duplicate");
  }
#line 5967
  value = (ngx_str_t *)(cf->args)->elts;
#line 5969
  if ((cf->args)->nelts == 2UL) {
    {
#line 5969
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 5969
    if (tmp == 0) {
#line 5970
      *plocal = (ngx_http_upstream_local_t *)((void *)0);
#line 5971
      return ((char *)((void *)0));
    }
  }
  {
#line 5974
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 5976
  ccv.cf = cf;
#line 5977
  ccv.value = value + 1;
#line 5978
  ccv.complex_value = & cv;
#line 5980
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 5980
  if (tmp___0 != 0L) {
#line 5981
    return ((char *)((void *)-1));
  }
  {
#line 5984
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_local_t ));
#line 5984
  local = (ngx_http_upstream_local_t *)tmp___1;
  }
#line 5985
  if ((unsigned long )local == (unsigned long )((void *)0)) {
#line 5986
    return ((char *)((void *)-1));
  }
#line 5989
  *plocal = local;
#line 5991
  if (cv.lengths) {
    {
#line 5992
    tmp___2 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 5992
    local->value = (ngx_http_complex_value_t *)tmp___2;
    }
#line 5993
    if ((unsigned long )local->value == (unsigned long )((void *)0)) {
#line 5994
      return ((char *)((void *)-1));
    }
#line 5997
    *(local->value) = cv;
  } else {
    {
#line 6000
    tmp___3 = ngx_palloc(cf->pool, sizeof(ngx_addr_t ));
#line 6000
    local->addr = (ngx_addr_t *)tmp___3;
    }
#line 6001
    if ((unsigned long )local->addr == (unsigned long )((void *)0)) {
#line 6002
      return ((char *)((void *)-1));
    }
    {
#line 6005
    rc = ngx_parse_addr_port(cf->pool, local->addr, (value + 1)->data, (value + 1)->len);
    }
    {
#line 6009
    if (rc == 0L) {
#line 6009
      goto case_0;
    }
#line 6013
    if (rc == -5L) {
#line 6013
      goto case_neg_5;
    }
#line 6018
    goto switch_default;
    case_0: /* CIL Label */ 
#line 6010
    (local->addr)->name = *(value + 1);
#line 6011
    goto switch_break;
    case_neg_5: /* CIL Label */ 
    {
#line 6014
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid address \"%V\"", value + 1);
    }
    switch_default: /* CIL Label */ 
#line 6019
    return ((char *)((void *)-1));
    switch_break: /* CIL Label */ ;
    }
  }
#line 6023
  if ((cf->args)->nelts > 2UL) {
    {
#line 6024
    tmp___4 = strcmp((char const   *)(value + 2)->data, "transparent");
    }
#line 6024
    if (tmp___4 == 0) {
#line 6026
      local->transparent = (ngx_uint_t )1;
    } else {
      {
#line 6033
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 2);
      }
#line 6035
      return ((char *)((void *)-1));
    }
  }
#line 6039
  return ((char *)((void *)0));
}
}
#line 6043 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_set_local(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_upstream_local_t *local ) 
{ 
  ngx_int_t rc ;
  ngx_str_t val ;
  ngx_addr_t *addr ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
#line 6051
  if ((unsigned long )local == (unsigned long )((void *)0)) {
#line 6052
    u->peer.local = (ngx_addr_t *)((void *)0);
#line 6053
    return ((ngx_int_t )0);
  }
#line 6057
  u->peer.transparent = (unsigned int )local->transparent;
#line 6060
  if ((unsigned long )local->value == (unsigned long )((void *)0)) {
#line 6061
    u->peer.local = local->addr;
#line 6062
    return ((ngx_int_t )0);
  }
  {
#line 6065
  tmp = ngx_http_complex_value(r, local->value, & val);
  }
#line 6065
  if (tmp != 0L) {
#line 6066
    return ((ngx_int_t )-1);
  }
#line 6069
  if (val.len == 0UL) {
#line 6070
    return ((ngx_int_t )0);
  }
  {
#line 6073
  tmp___0 = ngx_palloc(r->pool, sizeof(ngx_addr_t ));
#line 6073
  addr = (ngx_addr_t *)tmp___0;
  }
#line 6074
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 6075
    return ((ngx_int_t )-1);
  }
  {
#line 6078
  rc = ngx_parse_addr_port(r->pool, addr, val.data, val.len);
  }
#line 6079
  if (rc == -1L) {
#line 6080
    return ((ngx_int_t )-1);
  }
#line 6083
  if (rc != 0L) {
#line 6084
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 6084
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid local address \"%V\"",
                         & val);
      }
    }
#line 6086
    return ((ngx_int_t )0);
  }
#line 6089
  addr->name = val;
#line 6090
  u->peer.local = addr;
#line 6092
  return ((ngx_int_t )0);
}
}
#line 6096 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
char *ngx_http_upstream_param_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_array_t **a ;
  ngx_http_upstream_param_t *param ;
  void *tmp ;
  int tmp___0 ;

  {
#line 6100
  p = (char *)conf;
#line 6106
  a = (ngx_array_t **)(p + cmd->offset);
#line 6108
  if ((unsigned long )*a == (unsigned long )((void *)0)) {
    {
#line 6109
    *a = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 6110
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 6111
      return ((char *)((void *)-1));
    }
  }
  {
#line 6115
  tmp = ngx_array_push(*a);
#line 6115
  param = (ngx_http_upstream_param_t *)tmp;
  }
#line 6116
  if ((unsigned long )param == (unsigned long )((void *)0)) {
#line 6117
    return ((char *)((void *)-1));
  }
#line 6120
  value = (ngx_str_t *)(cf->args)->elts;
#line 6122
  param->key = *(value + 1);
#line 6123
  param->value = *(value + 2);
#line 6124
  param->skip_empty = (ngx_uint_t )0;
#line 6126
  if ((cf->args)->nelts == 4UL) {
    {
#line 6127
    tmp___0 = strcmp((char const   *)(value + 3)->data, "if_not_empty");
    }
#line 6127
    if (tmp___0 != 0) {
      {
#line 6128
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 3);
      }
#line 6130
      return ((char *)((void *)-1));
    }
#line 6133
    param->skip_empty = (ngx_uint_t )1;
  }
#line 6136
  return ((char *)((void *)0));
}
}
#line 6140 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
ngx_int_t ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf , ngx_http_upstream_conf_t *conf ,
                                              ngx_http_upstream_conf_t *prev , ngx_str_t *default_hide_headers ,
                                              ngx_hash_init_t *hash ) 
{ 
  ngx_str_t *h ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_array_t hide_headers ;
  ngx_hash_key_t *hk ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 6150
  if ((unsigned long )conf->hide_headers == (unsigned long )((void *)-1)) {
#line 6150
    if ((unsigned long )conf->pass_headers == (unsigned long )((void *)-1)) {
#line 6153
      conf->hide_headers = prev->hide_headers;
#line 6154
      conf->pass_headers = prev->pass_headers;
#line 6156
      conf->hide_headers_hash = prev->hide_headers_hash;
#line 6158
      if (conf->hide_headers_hash.buckets) {
#line 6159
        return ((ngx_int_t )0);
      }
    } else {
#line 6150
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6163
    if ((unsigned long )conf->hide_headers == (unsigned long )((void *)-1)) {
#line 6164
      conf->hide_headers = prev->hide_headers;
    }
#line 6167
    if ((unsigned long )conf->pass_headers == (unsigned long )((void *)-1)) {
#line 6168
      conf->pass_headers = prev->pass_headers;
    }
  }
  {
#line 6172
  tmp = ngx_array_init(& hide_headers, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 6172
  if (tmp != 0L) {
#line 6175
    return ((ngx_int_t )-1);
  }
#line 6178
  h = default_hide_headers;
  {
#line 6178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6178
    if (! h->len) {
#line 6178
      goto while_break;
    }
    {
#line 6179
    tmp___0 = ngx_array_push(& hide_headers);
#line 6179
    hk = (ngx_hash_key_t *)tmp___0;
    }
#line 6180
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 6181
      return ((ngx_int_t )-1);
    }
    {
#line 6184
    hk->key = *h;
#line 6185
    hk->key_hash = ngx_hash_key_lc(h->data, h->len);
#line 6186
    hk->value = (void *)1;
#line 6178
    h ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6189
  if ((unsigned long )conf->hide_headers != (unsigned long )((void *)-1)) {
#line 6191
    h = (ngx_str_t *)(conf->hide_headers)->elts;
#line 6193
    i = (ngx_uint_t )0;
    {
#line 6193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6193
      if (! (i < (conf->hide_headers)->nelts)) {
#line 6193
        goto while_break___0;
      }
#line 6195
      hk = (ngx_hash_key_t *)hide_headers.elts;
#line 6197
      j = (ngx_uint_t )0;
      {
#line 6197
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 6197
        if (! (j < hide_headers.nelts)) {
#line 6197
          goto while_break___1;
        }
        {
#line 6198
        tmp___1 = ngx_strcasecmp((h + i)->data, (hk + j)->key.data);
        }
#line 6198
        if (tmp___1 == 0L) {
#line 6199
          goto exist;
        }
#line 6197
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 6203
      tmp___2 = ngx_array_push(& hide_headers);
#line 6203
      hk = (ngx_hash_key_t *)tmp___2;
      }
#line 6204
      if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 6205
        return ((ngx_int_t )-1);
      }
      {
#line 6208
      hk->key = *(h + i);
#line 6209
      hk->key_hash = ngx_hash_key_lc((h + i)->data, (h + i)->len);
#line 6210
      hk->value = (void *)1;
      }
      exist: 
#line 6214
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 6193
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 6218
  if ((unsigned long )conf->pass_headers != (unsigned long )((void *)-1)) {
#line 6220
    h = (ngx_str_t *)(conf->pass_headers)->elts;
#line 6221
    hk = (ngx_hash_key_t *)hide_headers.elts;
#line 6223
    i = (ngx_uint_t )0;
    {
#line 6223
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6223
      if (! (i < (conf->pass_headers)->nelts)) {
#line 6223
        goto while_break___2;
      }
#line 6224
      j = (ngx_uint_t )0;
      {
#line 6224
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6224
        if (! (j < hide_headers.nelts)) {
#line 6224
          goto while_break___3;
        }
#line 6226
        if ((unsigned long )(hk + j)->key.data == (unsigned long )((void *)0)) {
#line 6227
          goto __Cont___0;
        }
        {
#line 6230
        tmp___3 = ngx_strcasecmp((h + i)->data, (hk + j)->key.data);
        }
#line 6230
        if (tmp___3 == 0L) {
#line 6231
          (hk + j)->key.data = (u_char *)((void *)0);
#line 6232
          goto while_break___3;
        }
        __Cont___0: /* CIL Label */ 
#line 6224
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6223
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 6238
  hash->hash = & conf->hide_headers_hash;
#line 6239
  hash->key = & ngx_hash_key_lc;
#line 6240
  hash->pool = cf->pool;
#line 6241
  hash->temp_pool = (ngx_pool_t *)((void *)0);
#line 6243
  tmp___4 = ngx_hash_init(hash, (ngx_hash_key_t *)hide_headers.elts, hide_headers.nelts);
  }
#line 6243
  if (tmp___4 != 0L) {
#line 6244
    return ((ngx_int_t )-1);
  }
#line 6252
  if ((unsigned long )prev->hide_headers_hash.buckets == (unsigned long )((void *)0)) {
#line 6252
    if ((unsigned long )conf->hide_headers == (unsigned long )prev->hide_headers) {
#line 6252
      if ((unsigned long )conf->pass_headers == (unsigned long )prev->pass_headers) {
#line 6256
        prev->hide_headers_hash = conf->hide_headers_hash;
      }
    }
  }
#line 6259
  return ((ngx_int_t )0);
}
}
#line 6263 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static void *ngx_http_upstream_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 6268
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_main_conf_t ));
#line 6268
  umcf = (ngx_http_upstream_main_conf_t *)tmp;
  }
#line 6269
  if ((unsigned long )umcf == (unsigned long )((void *)0)) {
#line 6270
    return ((void *)0);
  }
  {
#line 6273
  tmp___0 = ngx_array_init(& umcf->upstreams, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_srv_conf_t *));
  }
#line 6273
  if (tmp___0 != 0L) {
#line 6277
    return ((void *)0);
  }
#line 6280
  return ((void *)umcf);
}
}
#line 6284 "/tmp/nginx-1.13.2/src/http/ngx_http_upstream.c"
static char *ngx_http_upstream_init_main_conf(ngx_conf_t *cf , void *conf ) 
{ 
  ngx_http_upstream_main_conf_t *umcf ;
  ngx_uint_t i ;
  ngx_array_t headers_in ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_int_t (*init)(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
  ngx_http_upstream_header_t *header___0 ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 6287
  umcf = (ngx_http_upstream_main_conf_t *)conf;
#line 6297
  uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 6299
  i = (ngx_uint_t )0;
  {
#line 6299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6299
    if (! (i < umcf->upstreams.nelts)) {
#line 6299
      goto while_break;
    }
#line 6301
    if ((*(uscfp + i))->peer.init_upstream) {
#line 6301
      init = (*(uscfp + i))->peer.init_upstream;
    } else {
#line 6301
      init = & ngx_http_upstream_init_round_robin;
    }
    {
#line 6304
    tmp = (*init)(cf, *(uscfp + i));
    }
#line 6304
    if (tmp != 0L) {
#line 6305
      return ((char *)((void *)-1));
    }
#line 6299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6312
  tmp___0 = ngx_array_init(& headers_in, cf->temp_pool, (ngx_uint_t )32, sizeof(ngx_hash_key_t ));
  }
#line 6312
  if (tmp___0 != 0L) {
#line 6315
    return ((char *)((void *)-1));
  }
#line 6318
  header___0 = ngx_http_upstream_headers_in;
  {
#line 6318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6318
    if (! header___0->name.len) {
#line 6318
      goto while_break___0;
    }
    {
#line 6319
    tmp___1 = ngx_array_push(& headers_in);
#line 6319
    hk = (ngx_hash_key_t *)tmp___1;
    }
#line 6320
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 6321
      return ((char *)((void *)-1));
    }
    {
#line 6324
    hk->key = header___0->name;
#line 6325
    hk->key_hash = ngx_hash_key_lc(header___0->name.data, header___0->name.len);
#line 6326
    hk->value = (void *)header___0;
#line 6318
    header___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6329
  hash.hash = & umcf->headers_in_hash;
#line 6330
  hash.key = & ngx_hash_key_lc;
#line 6331
  hash.max_size = (ngx_uint_t )512;
#line 6332
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 6333
  hash.name = (char *)"upstream_headers_in_hash";
#line 6334
  hash.pool = cf->pool;
#line 6335
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 6337
  tmp___2 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_in.elts, headers_in.nelts);
  }
#line 6337
  if (tmp___2 != 0L) {
#line 6338
    return ((char *)((void *)-1));
  }
#line 6341
  return ((char *)((void *)0));
}
}
#line 208 "src/core/ngx_string.h"
void ngx_unescape_uri(u_char **dst , u_char **src , size_t___0 size , ngx_uint_t type ) ;
#line 135 "src/core/ngx_file.h"
ngx_int_t ngx_get_full_name(ngx_pool_t *pool , ngx_str_t *prefix , ngx_str_t *name ) ;
#line 206 "src/http/ngx_http_script.h"
void ngx_http_script_flush_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ) ;
#line 233
size_t___0 ngx_http_script_copy_var_len_code(ngx_http_script_engine_t *e ) ;
#line 234
void ngx_http_script_copy_var_code(ngx_http_script_engine_t *e ) ;
#line 235
size_t___0 ngx_http_script_copy_capture_len_code(ngx_http_script_engine_t *e ) ;
#line 236
void ngx_http_script_copy_capture_code(ngx_http_script_engine_t *e ) ;
#line 237
size_t___0 ngx_http_script_mark_args_code(ngx_http_script_engine_t *e ) ;
#line 238
void ngx_http_script_start_args_code(ngx_http_script_engine_t *e ) ;
#line 254
void ngx_http_script_nop_code(ngx_http_script_engine_t *e ) ;
#line 497 "src/http/ngx_http_core_module.h"
void ngx_http_set_exten(ngx_http_request_t *r ) ;
#line 118 "src/http/ngx_http.h"
void ngx_http_update_location_config(ngx_http_request_t *r ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_init_arrays(ngx_http_script_compile_t *sc ) ;
#line 14
static ngx_int_t ngx_http_script_done(ngx_http_script_compile_t *sc ) ;
#line 15
static ngx_int_t ngx_http_script_add_copy_code(ngx_http_script_compile_t *sc , ngx_str_t *value ,
                                               ngx_uint_t last ) ;
#line 17
static ngx_int_t ngx_http_script_add_var_code(ngx_http_script_compile_t *sc , ngx_str_t *name ) ;
#line 19
static ngx_int_t ngx_http_script_add_args_code(ngx_http_script_compile_t *sc ) ;
#line 21
static ngx_int_t ngx_http_script_add_capture_code(ngx_http_script_compile_t *sc ,
                                                  ngx_uint_t n ) ;
#line 24
static ngx_int_t ngx_http_script_add_full_name_code(ngx_http_script_compile_t *sc ) ;
#line 26
static size_t___0 ngx_http_script_full_name_len_code(ngx_http_script_engine_t *e ) ;
#line 27
static void ngx_http_script_full_name_code(ngx_http_script_engine_t *e ) ;
#line 32 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static uintptr_t ngx_http_script_exit_code  =    (uintptr_t )((void *)0);
#line 35 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_flush_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ) 
{ 
  ngx_uint_t *index___0 ;

  {
#line 41
  index___0 = val->flushes;
#line 43
  if (index___0) {
    {
#line 44
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      if (! (*index___0 != 0xffffffffffffffffUL)) {
#line 44
        goto while_break;
      }
#line 46
      if ((r->variables + *index___0)->no_cacheable) {
#line 47
        (r->variables + *index___0)->valid = 0U;
#line 48
        (r->variables + *index___0)->not_found = 0U;
      }
#line 51
      index___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 54
  return;
}
}
#line 57 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
ngx_int_t ngx_http_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ,
                                 ngx_str_t *value ) 
{ 
  size_t___0 len ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  size_t___0 tmp ;
  void *tmp___0 ;

  {
#line 66
  if ((unsigned long )val->lengths == (unsigned long )((void *)0)) {
#line 67
    *value = val->value;
#line 68
    return ((ngx_int_t )0);
  }
  {
#line 71
  ngx_http_script_flush_complex_value(r, val);
#line 73
  memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 75
  e.ip = (u_char *)val->lengths;
#line 76
  e.request = r;
#line 77
  e.flushed = 1U;
#line 79
  len = (size_t___0 )0;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! *((uintptr_t *)e.ip)) {
#line 81
      goto while_break;
    }
    {
#line 82
    lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 83
    tmp = (*lcode)(& e);
#line 83
    len += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  value->len = len;
#line 87
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 87
  value->data = (u_char *)tmp___0;
  }
#line 88
  if ((unsigned long )value->data == (unsigned long )((void *)0)) {
#line 89
    return ((ngx_int_t )-1);
  }
#line 92
  e.ip = (u_char *)val->values;
#line 93
  e.pos = value->data;
#line 94
  e.buf = *value;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! *((uintptr_t *)e.ip)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    code = *((ngx_http_script_code_pt *)e.ip);
#line 98
    (*code)(& e);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  *value = e.buf;
#line 103
  return ((ngx_int_t )0);
}
}
#line 107 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv ) 
{ 
  ngx_str_t *v ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t nv ;
  ngx_uint_t nc ;
  ngx_array_t flushes ;
  ngx_array_t lengths ;
  ngx_array_t values ;
  ngx_array_t *pf ;
  ngx_array_t *pl ;
  ngx_array_t *pv ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 115
  v = ccv->value;
#line 117
  nv = (ngx_uint_t )0;
#line 118
  nc = (ngx_uint_t )0;
#line 120
  i = (ngx_uint_t )0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < v->len)) {
#line 120
      goto while_break;
    }
#line 121
    if ((int )*(v->data + i) == 36) {
#line 122
      if ((int )*(v->data + (i + 1UL)) >= 49) {
#line 122
        if ((int )*(v->data + (i + 1UL)) <= 57) {
#line 123
          nc ++;
        } else {
#line 126
          nv ++;
        }
      } else {
#line 126
        nv ++;
      }
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (v->len == 0UL) {
#line 131
    goto _L___0;
  } else
#line 131
  if ((int )*(v->data + 0) != 36) {
    _L___0: /* CIL Label */ 
#line 131
    if (ccv->conf_prefix) {
#line 131
      goto _L;
    } else
#line 131
    if (ccv->root_prefix) {
      _L: /* CIL Label */ 
      {
#line 134
      tmp = ngx_conf_full_name((ccv->cf)->cycle, v, (ngx_uint_t )ccv->conf_prefix);
      }
#line 134
      if (tmp != 0L) {
#line 135
        return ((ngx_int_t )-1);
      }
#line 138
      ccv->conf_prefix = 0U;
#line 139
      ccv->root_prefix = 0U;
    }
  }
#line 142
  (ccv->complex_value)->value = *v;
#line 143
  (ccv->complex_value)->flushes = (ngx_uint_t *)((void *)0);
#line 144
  (ccv->complex_value)->lengths = (void *)0;
#line 145
  (ccv->complex_value)->values = (void *)0;
#line 147
  if (nv == 0UL) {
#line 147
    if (nc == 0UL) {
#line 148
      return ((ngx_int_t )0);
    }
  }
  {
#line 151
  n = nv + 1UL;
#line 153
  tmp___0 = ngx_array_init(& flushes, (ccv->cf)->pool, n, sizeof(ngx_uint_t ));
  }
#line 153
  if (tmp___0 != 0L) {
#line 156
    return ((ngx_int_t )-1);
  }
  {
#line 159
  n = nv * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t );
#line 163
  tmp___1 = ngx_array_init(& lengths, (ccv->cf)->pool, n, (size_t___0 )1);
  }
#line 163
  if (tmp___1 != 0L) {
#line 164
    return ((ngx_int_t )-1);
  }
  {
#line 167
  n = ((((nv * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t )) + v->len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 174
  tmp___2 = ngx_array_init(& values, (ccv->cf)->pool, n, (size_t___0 )1);
  }
#line 174
  if (tmp___2 != 0L) {
#line 175
    return ((ngx_int_t )-1);
  }
  {
#line 178
  pf = & flushes;
#line 179
  pl = & lengths;
#line 180
  pv = & values;
#line 182
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 184
  sc.cf = ccv->cf;
#line 185
  sc.source = v;
#line 186
  sc.flushes = & pf;
#line 187
  sc.lengths = & pl;
#line 188
  sc.values = & pv;
#line 189
  sc.complete_lengths = 1U;
#line 190
  sc.complete_values = 1U;
#line 191
  sc.zero = ccv->zero;
#line 192
  sc.conf_prefix = ccv->conf_prefix;
#line 193
  sc.root_prefix = ccv->root_prefix;
#line 195
  tmp___3 = ngx_http_script_compile(& sc);
  }
#line 195
  if (tmp___3 != 0L) {
#line 196
    return ((ngx_int_t )-1);
  }
#line 199
  if (flushes.nelts) {
#line 200
    (ccv->complex_value)->flushes = (ngx_uint_t *)flushes.elts;
#line 201
    *((ccv->complex_value)->flushes + flushes.nelts) = (ngx_uint_t )-1;
  }
#line 204
  (ccv->complex_value)->lengths = lengths.elts;
#line 205
  (ccv->complex_value)->values = values.elts;
#line 207
  return ((ngx_int_t )0);
}
}
#line 211 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
char *ngx_http_set_complex_value_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_http_complex_value_t **cv ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 214
  p = (char *)conf;
#line 220
  cv = (ngx_http_complex_value_t **)(p + cmd->offset);
#line 222
  if ((unsigned long )*cv != (unsigned long )((void *)0)) {
#line 223
    return ((char *)"is duplicate");
  }
  {
#line 226
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 226
  *cv = (ngx_http_complex_value_t *)tmp;
  }
#line 227
  if ((unsigned long )*cv == (unsigned long )((void *)0)) {
#line 228
    return ((char *)((void *)-1));
  }
  {
#line 231
  value = (ngx_str_t *)(cf->args)->elts;
#line 233
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 235
  ccv.cf = cf;
#line 236
  ccv.value = value + 1;
#line 237
  ccv.complex_value = *cv;
#line 239
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 239
  if (tmp___0 != 0L) {
#line 240
    return ((char *)((void *)-1));
  }
#line 243
  return ((char *)((void *)0));
}
}
#line 247 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
ngx_int_t ngx_http_test_predicates(ngx_http_request_t *r , ngx_array_t *predicates ) 
{ 
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_http_complex_value_t *cv ;
  ngx_int_t tmp ;

  {
#line 254
  if ((unsigned long )predicates == (unsigned long )((void *)0)) {
#line 255
    return ((ngx_int_t )0);
  }
#line 258
  cv = (ngx_http_complex_value_t *)predicates->elts;
#line 260
  i = (ngx_uint_t )0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < predicates->nelts)) {
#line 260
      goto while_break;
    }
    {
#line 261
    tmp = ngx_http_complex_value(r, cv + i, & val);
    }
#line 261
    if (tmp != 0L) {
#line 262
      return ((ngx_int_t )-1);
    }
#line 265
    if (val.len) {
#line 265
      if (val.len != 1UL) {
#line 266
        return ((ngx_int_t )-5);
      } else
#line 265
      if ((int )*(val.data + 0) != 48) {
#line 266
        return ((ngx_int_t )-5);
      }
    }
#line 260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return ((ngx_int_t )0);
}
}
#line 274 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
char *ngx_http_set_predicate_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_array_t **a ;
  ngx_http_complex_value_t *cv ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 277
  p = (char *)conf;
#line 285
  a = (ngx_array_t **)(p + cmd->offset);
#line 287
  if ((unsigned long )*a == (unsigned long )((void *)-1)) {
    {
#line 288
    *a = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_complex_value_t ));
    }
#line 289
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 290
      return ((char *)((void *)-1));
    }
  }
#line 294
  value = (ngx_str_t *)(cf->args)->elts;
#line 296
  i = (ngx_uint_t )1;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < (cf->args)->nelts)) {
#line 296
      goto while_break;
    }
    {
#line 297
    tmp = ngx_array_push(*a);
#line 297
    cv = (ngx_http_complex_value_t *)tmp;
    }
#line 298
    if ((unsigned long )cv == (unsigned long )((void *)0)) {
#line 299
      return ((char *)((void *)-1));
    }
    {
#line 302
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 304
    ccv.cf = cf;
#line 305
    ccv.value = value + i;
#line 306
    ccv.complex_value = cv;
#line 308
    tmp___0 = ngx_http_compile_complex_value(& ccv);
    }
#line 308
    if (tmp___0 != 0L) {
#line 309
      return ((char *)((void *)-1));
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return ((char *)((void *)0));
}
}
#line 317 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
ngx_uint_t ngx_http_script_variables_count(ngx_str_t *value ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;

  {
#line 322
  n = (ngx_uint_t )0;
#line 322
  i = (ngx_uint_t )0;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (i < value->len)) {
#line 322
      goto while_break;
    }
#line 323
    if ((int )*(value->data + i) == 36) {
#line 324
      n ++;
    }
#line 322
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return (n);
}
}
#line 332 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
ngx_int_t ngx_http_script_compile(ngx_http_script_compile_t *sc ) 
{ 
  u_char ch ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_uint_t bracket ;
  ngx_int_t tmp ;
  ngx_uint_t n ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
  {
#line 339
  tmp = ngx_http_script_init_arrays(sc);
  }
#line 339
  if (tmp != 0L) {
#line 340
    return ((ngx_int_t )-1);
  }
#line 343
  i = (ngx_uint_t )0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < (sc->source)->len)) {
#line 343
      goto while_break;
    }
#line 345
    name.len = (size_t___0 )0;
#line 347
    if ((int )*((sc->source)->data + i) == 36) {
#line 349
      i ++;
#line 349
      if (i == (sc->source)->len) {
#line 350
        goto invalid_variable;
      }
#line 353
      if ((int )*((sc->source)->data + i) >= 49) {
#line 353
        if ((int )*((sc->source)->data + i) <= 57) {
#line 357
          n = (ngx_uint_t )((int )*((sc->source)->data + i) - 48);
#line 359
          if (sc->captures_mask & (1UL << n)) {
#line 360
            sc->dup_capture = 1U;
          }
          {
#line 363
          sc->captures_mask |= 1UL << n;
#line 365
          tmp___0 = ngx_http_script_add_capture_code(sc, n);
          }
#line 365
          if (tmp___0 != 0L) {
#line 366
            return ((ngx_int_t )-1);
          }
#line 369
          i ++;
#line 371
          goto __Cont;
        }
      }
#line 380
      if ((int )*((sc->source)->data + i) == 123) {
#line 381
        bracket = (ngx_uint_t )1;
#line 383
        i ++;
#line 383
        if (i == (sc->source)->len) {
#line 384
          goto invalid_variable;
        }
#line 387
        name.data = (sc->source)->data + i;
      } else {
#line 390
        bracket = (ngx_uint_t )0;
#line 391
        name.data = (sc->source)->data + i;
      }
      {
#line 394
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 394
        if (! (i < (sc->source)->len)) {
#line 394
          goto while_break___0;
        }
#line 395
        ch = *((sc->source)->data + i);
#line 397
        if ((int )ch == 125) {
#line 397
          if (bracket) {
#line 398
            i ++;
#line 399
            bracket = (ngx_uint_t )0;
#line 400
            goto while_break___0;
          }
        }
#line 403
        if ((int )ch >= 65) {
#line 403
          if ((int )ch <= 90) {
#line 408
            goto __Cont___0;
          } else {
#line 403
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 403
        if ((int )ch >= 97) {
#line 403
          if ((int )ch <= 122) {
#line 408
            goto __Cont___0;
          } else {
#line 403
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 403
        if ((int )ch >= 48) {
#line 403
          if ((int )ch <= 57) {
#line 408
            goto __Cont___0;
          } else {
#line 403
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 403
        if ((int )ch == 95) {
#line 408
          goto __Cont___0;
        }
#line 411
        goto while_break___0;
        __Cont___0: /* CIL Label */ 
#line 394
        i ++;
#line 394
        (name.len) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 414
      if (bracket) {
        {
#line 415
        ngx_conf_log_error((ngx_uint_t )1, sc->cf, 0, "the closing bracket in \"%V\" variable is missing",
                           & name);
        }
#line 418
        return ((ngx_int_t )-1);
      }
#line 421
      if (name.len == 0UL) {
#line 422
        goto invalid_variable;
      }
      {
#line 425
      (sc->variables) ++;
#line 427
      tmp___1 = ngx_http_script_add_var_code(sc, & name);
      }
#line 427
      if (tmp___1 != 0L) {
#line 428
        return ((ngx_int_t )-1);
      }
#line 431
      goto __Cont;
    }
#line 434
    if ((int )*((sc->source)->data + i) == 63) {
#line 434
      if (sc->compile_args) {
        {
#line 435
        sc->args = 1U;
#line 436
        sc->compile_args = 0U;
#line 438
        tmp___2 = ngx_http_script_add_args_code(sc);
        }
#line 438
        if (tmp___2 != 0L) {
#line 439
          return ((ngx_int_t )-1);
        }
#line 442
        i ++;
#line 444
        goto __Cont;
      }
    }
#line 447
    name.data = (sc->source)->data + i;
    {
#line 449
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 449
      if (! (i < (sc->source)->len)) {
#line 449
        goto while_break___1;
      }
#line 451
      if ((int )*((sc->source)->data + i) == 36) {
#line 452
        goto while_break___1;
      }
#line 455
      if ((int )*((sc->source)->data + i) == 63) {
#line 457
        sc->args = 1U;
#line 459
        if (sc->compile_args) {
#line 460
          goto while_break___1;
        }
      }
#line 464
      i ++;
#line 465
      (name.len) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 468
    sc->size += name.len;
#line 470
    tmp___3 = ngx_http_script_add_copy_code(sc, & name, (ngx_uint_t )(i == (sc->source)->len));
    }
#line 470
    if (tmp___3 != 0L) {
#line 473
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  tmp___4 = ngx_http_script_done(sc);
  }
#line 477
  return (tmp___4);
  invalid_variable: 
  {
#line 481
  ngx_conf_log_error((ngx_uint_t )1, sc->cf, 0, "invalid variable name");
  }
#line 483
  return ((ngx_int_t )-1);
}
}
#line 487 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
u_char *ngx_http_script_run(ngx_http_request_t *r , ngx_str_t *value , void *code_lengths ,
                            size_t___0 len , void *code_values ) 
{ 
  ngx_uint_t i ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_core_main_conf_t *cmcf ;
  size_t___0 tmp ;
  void *tmp___0 ;

  {
#line 497
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 499
  i = (ngx_uint_t )0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i < cmcf->variables.nelts)) {
#line 499
      goto while_break;
    }
#line 500
    if ((r->variables + i)->no_cacheable) {
#line 501
      (r->variables + i)->valid = 0U;
#line 502
      (r->variables + i)->not_found = 0U;
    }
#line 499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 506
  memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 508
  e.ip = (u_char *)code_lengths;
#line 509
  e.request = r;
#line 510
  e.flushed = 1U;
  }
  {
#line 512
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 512
    if (! *((uintptr_t *)e.ip)) {
#line 512
      goto while_break___0;
    }
    {
#line 513
    lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 514
    tmp = (*lcode)(& e);
#line 514
    len += tmp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 518
  value->len = len;
#line 519
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 519
  value->data = (u_char *)tmp___0;
  }
#line 520
  if ((unsigned long )value->data == (unsigned long )((void *)0)) {
#line 521
    return ((u_char *)((void *)0));
  }
#line 524
  e.ip = (u_char *)code_values;
#line 525
  e.pos = value->data;
  {
#line 527
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 527
    if (! *((uintptr_t *)e.ip)) {
#line 527
      goto while_break___1;
    }
    {
#line 528
    code = *((ngx_http_script_code_pt *)e.ip);
#line 529
    (*code)(& e);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 532
  return (e.pos);
}
}
#line 536 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_flush_no_cacheable_variables(ngx_http_request_t *r , ngx_array_t *indices ) 
{ 
  ngx_uint_t n ;
  ngx_uint_t *index___0 ;

  {
#line 542
  if (indices) {
#line 543
    index___0 = (ngx_uint_t *)indices->elts;
#line 544
    n = (ngx_uint_t )0;
    {
#line 544
    while (1) {
      while_continue: /* CIL Label */ ;
#line 544
      if (! (n < indices->nelts)) {
#line 544
        goto while_break;
      }
#line 545
      if ((r->variables + *(index___0 + n))->no_cacheable) {
#line 546
        (r->variables + *(index___0 + n))->valid = 0U;
#line 547
        (r->variables + *(index___0 + n))->not_found = 0U;
      }
#line 544
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 551
  return;
}
}
#line 554 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_init_arrays(ngx_http_script_compile_t *sc ) 
{ 
  ngx_uint_t n ;

  {
#line 559
  if (sc->flushes) {
#line 559
    if ((unsigned long )*(sc->flushes) == (unsigned long )((void *)0)) {
#line 560
      if (sc->variables) {
#line 560
        n = sc->variables;
      } else {
#line 560
        n = (ngx_uint_t )1;
      }
      {
#line 561
      *(sc->flushes) = ngx_array_create((sc->cf)->pool, n, sizeof(ngx_uint_t ));
      }
#line 562
      if ((unsigned long )*(sc->flushes) == (unsigned long )((void *)0)) {
#line 563
        return ((ngx_int_t )-1);
      }
    }
  }
#line 567
  if ((unsigned long )*(sc->lengths) == (unsigned long )((void *)0)) {
    {
#line 568
    n = sc->variables * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t );
#line 572
    *(sc->lengths) = ngx_array_create((sc->cf)->pool, n, (size_t___0 )1);
    }
#line 573
    if ((unsigned long )*(sc->lengths) == (unsigned long )((void *)0)) {
#line 574
      return ((ngx_int_t )-1);
    }
  }
#line 578
  if ((unsigned long )*(sc->values) == (unsigned long )((void *)0)) {
    {
#line 579
    n = ((((sc->variables * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t )) + (sc->source)->len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 586
    *(sc->values) = ngx_array_create((sc->cf)->pool, n, (size_t___0 )1);
    }
#line 587
    if ((unsigned long )*(sc->values) == (unsigned long )((void *)0)) {
#line 588
      return ((ngx_int_t )-1);
    }
  }
#line 592
  sc->variables = (ngx_uint_t )0;
#line 594
  return ((ngx_int_t )0);
}
}
#line 598 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_done(ngx_http_script_compile_t *sc ) 
{ 
  ngx_str_t zero___0 ;
  uintptr_t *code ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 604
  if (sc->zero) {
    {
#line 606
    zero___0.len = (size_t___0 )1;
#line 607
    zero___0.data = (u_char *)"\000";
#line 609
    tmp = ngx_http_script_add_copy_code(sc, & zero___0, (ngx_uint_t )0);
    }
#line 609
    if (tmp != 0L) {
#line 610
      return ((ngx_int_t )-1);
    }
  }
#line 614
  if (sc->conf_prefix) {
#line 614
    goto _L;
  } else
#line 614
  if (sc->root_prefix) {
    _L: /* CIL Label */ 
    {
#line 615
    tmp___0 = ngx_http_script_add_full_name_code(sc);
    }
#line 615
    if (tmp___0 != 0L) {
#line 616
      return ((ngx_int_t )-1);
    }
  }
#line 620
  if (sc->complete_lengths) {
    {
#line 621
    tmp___1 = ngx_http_script_add_code(*(sc->lengths), sizeof(uintptr_t ), (void *)0);
#line 621
    code = (uintptr_t *)tmp___1;
    }
#line 622
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 623
      return ((ngx_int_t )-1);
    }
#line 626
    *code = (uintptr_t )((void *)0);
  }
#line 629
  if (sc->complete_values) {
    {
#line 630
    tmp___2 = ngx_http_script_add_code(*(sc->values), sizeof(uintptr_t ), (void *)(& sc->main));
#line 630
    code = (uintptr_t *)tmp___2;
    }
#line 632
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 633
      return ((ngx_int_t )-1);
    }
#line 636
    *code = (uintptr_t )((void *)0);
  }
#line 639
  return ((ngx_int_t )0);
}
}
#line 643 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void *ngx_http_script_start_code(ngx_pool_t *pool , ngx_array_t **codes , size_t___0 size ) 
{ 
  void *tmp ;

  {
#line 646
  if ((unsigned long )*codes == (unsigned long )((void *)0)) {
    {
#line 647
    *codes = ngx_array_create(pool, (ngx_uint_t )256, (size_t___0 )1);
    }
#line 648
    if ((unsigned long )*codes == (unsigned long )((void *)0)) {
#line 649
      return ((void *)0);
    }
  }
  {
#line 653
  tmp = ngx_array_push_n(*codes, size);
  }
#line 653
  return (tmp);
}
}
#line 657 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void *ngx_http_script_add_code(ngx_array_t *codes , size_t___0 size , void *code ) 
{ 
  u_char *elts ;
  u_char **p ;
  void *new ;

  {
  {
#line 663
  elts = (u_char *)codes->elts;
#line 665
  new = ngx_array_push_n(codes, size);
  }
#line 666
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 667
    return ((void *)0);
  }
#line 670
  if (code) {
#line 671
    if ((unsigned long )elts != (unsigned long )codes->elts) {
#line 672
      p = (u_char **)code;
#line 673
      *p += (u_char *)codes->elts - elts;
    }
  }
#line 677
  return (new);
}
}
#line 681 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_copy_code(ngx_http_script_compile_t *sc , ngx_str_t *value ,
                                               ngx_uint_t last ) 
{ 
  u_char *p ;
  size_t___0 size ;
  size_t___0 len ;
  size_t___0 zero___0 ;
  ngx_http_script_copy_code_t *code ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 689
  if (sc->zero) {
#line 689
    if (last) {
#line 689
      tmp = 1;
    } else {
#line 689
      tmp = 0;
    }
  } else {
#line 689
    tmp = 0;
  }
  {
#line 689
  zero___0 = (size_t___0 )tmp;
#line 690
  len = value->len + zero___0;
#line 692
  tmp___0 = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_copy_code_t ),
                                     (void *)0);
#line 692
  code = (ngx_http_script_copy_code_t *)tmp___0;
  }
#line 694
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 695
    return ((ngx_int_t )-1);
  }
  {
#line 698
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 699
  code->len = len;
#line 701
  size = (((sizeof(ngx_http_script_copy_code_t ) + len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 704
  tmp___1 = ngx_http_script_add_code(*(sc->values), size, (void *)(& sc->main));
#line 704
  code = (ngx_http_script_copy_code_t *)tmp___1;
  }
#line 705
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 706
    return ((ngx_int_t )-1);
  }
  {
#line 709
  code->code = & ngx_http_script_copy_code;
#line 710
  code->len = len;
#line 712
  tmp___2 = memcpy((void */* __restrict  */)((u_char *)code + sizeof(ngx_http_script_copy_code_t )),
                   (void const   */* __restrict  */)value->data, value->len);
#line 712
  p = (u_char *)tmp___2 + value->len;
  }
#line 715
  if (zero___0) {
#line 716
    *p = (u_char )'\000';
#line 717
    sc->zero = 0U;
  }
#line 720
  return ((ngx_int_t )0);
}
}
#line 724 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
size_t___0 ngx_http_script_copy_len_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_copy_code_t *code ;

  {
#line 729
  code = (ngx_http_script_copy_code_t *)e->ip;
#line 731
  e->ip += sizeof(ngx_http_script_copy_code_t );
#line 733
  return (code->len);
}
}
#line 737 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_copy_code(ngx_http_script_engine_t *e ) 
{ 
  u_char *p ;
  ngx_http_script_copy_code_t *code ;
  void *tmp ;

  {
#line 743
  code = (ngx_http_script_copy_code_t *)e->ip;
#line 745
  p = e->pos;
#line 747
  if (! e->skip) {
    {
#line 748
    tmp = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(e->ip + sizeof(ngx_http_script_copy_code_t )),
                 code->len);
#line 748
    e->pos = (u_char *)tmp + code->len;
    }
  }
#line 752
  e->ip += sizeof(ngx_http_script_copy_code_t ) + (((code->len + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL));
#line 757
  return;
}
}
#line 760 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_var_code(ngx_http_script_compile_t *sc , ngx_str_t *name ) 
{ 
  ngx_int_t index___0 ;
  ngx_int_t *p ;
  ngx_http_script_var_code_t *code ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 766
  index___0 = ngx_http_get_variable_index(sc->cf, name);
  }
#line 768
  if (index___0 == -1L) {
#line 769
    return ((ngx_int_t )-1);
  }
#line 772
  if (sc->flushes) {
    {
#line 773
    tmp = ngx_array_push(*(sc->flushes));
#line 773
    p = (ngx_int_t *)tmp;
    }
#line 774
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 775
      return ((ngx_int_t )-1);
    }
#line 778
    *p = index___0;
  }
  {
#line 781
  tmp___0 = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_var_code_t ),
                                     (void *)0);
#line 781
  code = (ngx_http_script_var_code_t *)tmp___0;
  }
#line 783
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 784
    return ((ngx_int_t )-1);
  }
  {
#line 787
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_var_len_code);
#line 788
  code->index = (uintptr_t )index___0;
#line 790
  tmp___1 = ngx_http_script_add_code(*(sc->values), sizeof(ngx_http_script_var_code_t ),
                                     (void *)(& sc->main));
#line 790
  code = (ngx_http_script_var_code_t *)tmp___1;
  }
#line 793
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 794
    return ((ngx_int_t )-1);
  }
#line 797
  code->code = & ngx_http_script_copy_var_code;
#line 798
  code->index = (uintptr_t )index___0;
#line 800
  return ((ngx_int_t )0);
}
}
#line 804 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
size_t___0 ngx_http_script_copy_var_len_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *value ;
  ngx_http_script_var_code_t *code ;

  {
#line 810
  code = (ngx_http_script_var_code_t *)e->ip;
#line 812
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 814
  if (e->flushed) {
    {
#line 815
    value = ngx_http_get_indexed_variable(e->request, code->index);
    }
  } else {
    {
#line 818
    value = ngx_http_get_flushed_variable(e->request, code->index);
    }
  }
#line 821
  if (value) {
#line 821
    if (! value->not_found) {
#line 822
      return ((size_t___0 )value->len);
    }
  }
#line 825
  return ((size_t___0 )0);
}
}
#line 829 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_copy_var_code(ngx_http_script_engine_t *e ) 
{ 
  u_char *p ;
  ngx_http_variable_value_t *value ;
  ngx_http_script_var_code_t *code ;
  void *tmp ;

  {
#line 836
  code = (ngx_http_script_var_code_t *)e->ip;
#line 838
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 840
  if (! e->skip) {
#line 842
    if (e->flushed) {
      {
#line 843
      value = ngx_http_get_indexed_variable(e->request, code->index);
      }
    } else {
      {
#line 846
      value = ngx_http_get_flushed_variable(e->request, code->index);
      }
    }
#line 849
    if (value) {
#line 849
      if (! value->not_found) {
        {
#line 850
        p = e->pos;
#line 851
        tmp = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)value->data,
                     (size_t )value->len);
#line 851
        e->pos = (u_char *)tmp + value->len;
        }
      }
    }
  }
#line 858
  return;
}
}
#line 861 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_args_code(ngx_http_script_compile_t *sc ) 
{ 
  uintptr_t *code ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 866
  tmp = ngx_http_script_add_code(*(sc->lengths), sizeof(uintptr_t ), (void *)0);
#line 866
  code = (uintptr_t *)tmp;
  }
#line 867
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 868
    return ((ngx_int_t )-1);
  }
  {
#line 871
  *code = (uintptr_t )(& ngx_http_script_mark_args_code);
#line 873
  tmp___0 = ngx_http_script_add_code(*(sc->values), sizeof(uintptr_t ), (void *)(& sc->main));
#line 873
  code = (uintptr_t *)tmp___0;
  }
#line 874
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 875
    return ((ngx_int_t )-1);
  }
#line 878
  *code = (uintptr_t )(& ngx_http_script_start_args_code);
#line 880
  return ((ngx_int_t )0);
}
}
#line 884 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
size_t___0 ngx_http_script_mark_args_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 887
  e->is_args = 1U;
#line 888
  e->ip += sizeof(uintptr_t );
#line 890
  return ((size_t___0 )1);
}
}
#line 894 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_start_args_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 900
  e->is_args = 1U;
#line 901
  e->args = e->pos;
#line 902
  e->ip += sizeof(uintptr_t );
#line 903
  return;
}
}
#line 908 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_regex_start_code(ngx_http_script_engine_t *e ) 
{ 
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_http_request_t *r ;
  ngx_http_script_engine_t le ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_regex_code_t *code ;
  uintptr_t tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;

  {
#line 919
  code = (ngx_http_script_regex_code_t *)e->ip;
#line 921
  r = e->request;
#line 926
  if (code->uri) {
#line 927
    e->line = r->uri;
  } else {
#line 929
    (e->sp) --;
#line 930
    e->line.len = (size_t___0 )(e->sp)->len;
#line 931
    e->line.data = (e->sp)->data;
  }
  {
#line 934
  rc = ngx_http_regex_exec(r, code->regex, & e->line);
  }
#line 936
  if (rc == -5L) {
#line 937
    if (e->log) {
#line 937
      goto _L;
    } else
#line 937
    if (((r->connection)->log)->log_level & 256UL) {
      _L: /* CIL Label */ 
#line 938
      if (((r->connection)->log)->log_level >= 6UL) {
        {
#line 938
        ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "\"%V\" does not match \"%V\"",
                           & code->name, & e->line);
        }
      }
    }
#line 943
    r->ncaptures = (ngx_uint_t )0;
#line 945
    if (code->test) {
#line 946
      if (code->negative_test) {
#line 947
        (e->sp)->len = 1U;
#line 948
        (e->sp)->data = (u_char *)"1";
      } else {
#line 951
        (e->sp)->len = 0U;
#line 952
        (e->sp)->data = (u_char *)"";
      }
#line 955
      (e->sp) ++;
#line 957
      e->ip += sizeof(ngx_http_script_regex_code_t );
#line 958
      return;
    }
#line 961
    e->ip += code->next;
#line 962
    return;
  }
#line 965
  if (rc == -1L) {
#line 966
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 967
    e->status = (ngx_int_t )500;
#line 968
    return;
  }
#line 971
  if (e->log) {
#line 971
    goto _L___0;
  } else
#line 971
  if (((r->connection)->log)->log_level & 256UL) {
    _L___0: /* CIL Label */ 
#line 972
    if (((r->connection)->log)->log_level >= 6UL) {
      {
#line 972
      ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "\"%V\" matches \"%V\"",
                         & code->name, & e->line);
      }
    }
  }
#line 976
  if (code->test) {
#line 977
    if (code->negative_test) {
#line 978
      (e->sp)->len = 0U;
#line 979
      (e->sp)->data = (u_char *)"";
    } else {
#line 982
      (e->sp)->len = 1U;
#line 983
      (e->sp)->data = (u_char *)"1";
    }
#line 986
    (e->sp) ++;
#line 988
    e->ip += sizeof(ngx_http_script_regex_code_t );
#line 989
    return;
  }
#line 992
  if (code->status) {
#line 993
    e->status = (ngx_int_t )code->status;
#line 995
    if (! code->redirect) {
#line 996
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 997
      return;
    }
  }
#line 1001
  if (code->uri) {
#line 1002
    r->internal = 1U;
#line 1003
    r->valid_unparsed_uri = 0U;
#line 1005
    if (code->break_cycle) {
#line 1006
      r->valid_location = 0U;
#line 1007
      r->uri_changed = 0U;
    } else {
#line 1010
      r->uri_changed = 1U;
    }
  }
#line 1014
  if ((unsigned long )code->lengths == (unsigned long )((void *)0)) {
#line 1015
    e->buf.len = code->size;
#line 1017
    if (code->uri) {
#line 1018
      if (r->ncaptures) {
#line 1018
        if (r->quoted_uri) {
          {
#line 1019
          tmp = ngx_escape_uri((u_char *)((void *)0), r->uri.data, r->uri.len, (ngx_uint_t )1);
#line 1019
          e->buf.len += 2UL * tmp;
          }
        } else
#line 1018
        if (r->plus_in_uri) {
          {
#line 1019
          tmp = ngx_escape_uri((u_char *)((void *)0), r->uri.data, r->uri.len, (ngx_uint_t )1);
#line 1019
          e->buf.len += 2UL * tmp;
          }
        }
      }
    }
#line 1024
    n = (ngx_uint_t )2;
    {
#line 1024
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1024
      if (! (n < r->ncaptures)) {
#line 1024
        goto while_break;
      }
#line 1025
      e->buf.len += (size_t___0 )(*(r->captures + (n + 1UL)) - *(r->captures + n));
#line 1024
      n += 2UL;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1029
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 1031
    le.ip = (u_char *)(code->lengths)->elts;
#line 1032
    le.line = e->line;
#line 1033
    le.request = r;
#line 1034
    le.quote = code->redirect;
#line 1036
    len = (size_t___0 )0;
    }
    {
#line 1038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1038
      if (! *((uintptr_t *)le.ip)) {
#line 1038
        goto while_break___0;
      }
      {
#line 1039
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1040
      tmp___0 = (*lcode)(& le);
#line 1040
      len += tmp___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1043
    e->buf.len = len;
  }
#line 1046
  if (code->add_args) {
#line 1046
    if (r->args.len) {
#line 1047
      e->buf.len += r->args.len + 1UL;
    }
  }
  {
#line 1050
  tmp___1 = ngx_pnalloc(r->pool, e->buf.len);
#line 1050
  e->buf.data = (u_char *)tmp___1;
  }
#line 1051
  if ((unsigned long )e->buf.data == (unsigned long )((void *)0)) {
#line 1052
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1053
    e->status = (ngx_int_t )500;
#line 1054
    return;
  }
#line 1057
  e->quote = code->redirect;
#line 1059
  e->pos = e->buf.data;
#line 1061
  e->ip += sizeof(ngx_http_script_regex_code_t );
#line 1062
  return;
}
}
#line 1065 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_regex_end_code(ngx_http_script_engine_t *e ) 
{ 
  u_char *dst ;
  u_char *src ;
  ngx_http_request_t *r ;
  ngx_http_script_regex_end_code_t *code ;
  void *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;

  {
#line 1072
  code = (ngx_http_script_regex_end_code_t *)e->ip;
#line 1074
  r = e->request;
#line 1076
  e->quote = 0U;
#line 1081
  if (code->redirect) {
    {
#line 1083
    dst = e->buf.data;
#line 1084
    src = e->buf.data;
#line 1086
    ngx_unescape_uri(& dst, & src, (size_t___0 )(e->pos - e->buf.data), (ngx_uint_t )2);
    }
#line 1089
    if ((unsigned long )src < (unsigned long )e->pos) {
      {
#line 1090
      tmp = memmove((void *)dst, (void const   *)src, (size_t )(e->pos - src));
#line 1090
      dst = (u_char *)tmp + (e->pos - src);
      }
    }
#line 1093
    e->pos = dst;
#line 1095
    if (code->add_args) {
#line 1095
      if (r->args.len) {
#line 1096
        tmp___0 = e->pos;
#line 1096
        (e->pos) ++;
#line 1096
        if (code->args) {
#line 1096
          tmp___1 = '&';
        } else {
#line 1096
          tmp___1 = '?';
        }
        {
#line 1096
        *tmp___0 = (u_char )tmp___1;
#line 1097
        tmp___2 = memcpy((void */* __restrict  */)e->pos, (void const   */* __restrict  */)r->args.data,
                         r->args.len);
#line 1097
        e->pos = (u_char *)tmp___2 + r->args.len;
        }
      }
    }
#line 1100
    e->buf.len = (size_t___0 )(e->pos - e->buf.data);
#line 1102
    if (e->log) {
#line 1102
      goto _L;
    } else
#line 1102
    if (((r->connection)->log)->log_level & 256UL) {
      _L: /* CIL Label */ 
#line 1103
      if (((r->connection)->log)->log_level >= 6UL) {
        {
#line 1103
        ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "rewritten redirect: \"%V\"",
                           & e->buf);
        }
      }
    }
#line 1107
    if (r->headers_out.location) {
#line 1107
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 1107
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 1109
    tmp___3 = ngx_list_push(& r->headers_out.headers);
#line 1109
    r->headers_out.location = (ngx_table_elt_t *)tmp___3;
    }
#line 1110
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
#line 1111
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1112
      e->status = (ngx_int_t )500;
#line 1113
      return;
    }
#line 1116
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 1117
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 1117
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 1118
    (r->headers_out.location)->value = e->buf;
#line 1120
    e->ip += sizeof(ngx_http_script_regex_end_code_t );
#line 1121
    return;
  }
#line 1124
  if (e->args) {
#line 1125
    e->buf.len = (size_t___0 )(e->args - e->buf.data);
#line 1127
    if (code->add_args) {
#line 1127
      if (r->args.len) {
        {
#line 1128
        tmp___4 = e->pos;
#line 1128
        (e->pos) ++;
#line 1128
        *tmp___4 = (u_char )'&';
#line 1129
        tmp___5 = memcpy((void */* __restrict  */)e->pos, (void const   */* __restrict  */)r->args.data,
                         r->args.len);
#line 1129
        e->pos = (u_char *)tmp___5 + r->args.len;
        }
      }
    }
#line 1132
    r->args.len = (size_t___0 )(e->pos - e->args);
#line 1133
    r->args.data = e->args;
#line 1135
    e->args = (u_char *)((void *)0);
  } else {
#line 1138
    e->buf.len = (size_t___0 )(e->pos - e->buf.data);
#line 1140
    if (! code->add_args) {
#line 1141
      r->args.len = (size_t___0 )0;
    }
  }
#line 1145
  if (e->log) {
#line 1145
    goto _L___0;
  } else
#line 1145
  if (((r->connection)->log)->log_level & 256UL) {
    _L___0: /* CIL Label */ 
#line 1146
    if (((r->connection)->log)->log_level >= 6UL) {
      {
#line 1146
      ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "rewritten data: \"%V\", args: \"%V\"",
                         & e->buf, & r->args);
      }
    }
  }
#line 1151
  if (code->uri) {
#line 1152
    r->uri = e->buf;
#line 1154
    if (r->uri.len == 0UL) {
#line 1155
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1155
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the rewritten URI has a zero length");
        }
      }
#line 1157
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1158
      e->status = (ngx_int_t )500;
#line 1159
      return;
    }
    {
#line 1162
    ngx_http_set_exten(r);
    }
  }
#line 1165
  e->ip += sizeof(ngx_http_script_regex_end_code_t );
#line 1166
  return;
}
}
#line 1169 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_capture_code(ngx_http_script_compile_t *sc ,
                                                  ngx_uint_t n ) 
{ 
  ngx_http_script_copy_capture_code_t *code ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1174
  tmp = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_copy_capture_code_t ),
                                 (void *)0);
#line 1174
  code = (ngx_http_script_copy_capture_code_t *)tmp;
  }
#line 1177
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1178
    return ((ngx_int_t )-1);
  }
  {
#line 1181
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_capture_len_code);
#line 1183
  code->n = 2UL * n;
#line 1186
  tmp___0 = ngx_http_script_add_code(*(sc->values), sizeof(ngx_http_script_copy_capture_code_t ),
                                     (void *)(& sc->main));
#line 1186
  code = (ngx_http_script_copy_capture_code_t *)tmp___0;
  }
#line 1189
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1190
    return ((ngx_int_t )-1);
  }
#line 1193
  code->code = & ngx_http_script_copy_capture_code;
#line 1194
  code->n = 2UL * n;
#line 1196
  if (sc->ncaptures < n) {
#line 1197
    sc->ncaptures = n;
  }
#line 1200
  return ((ngx_int_t )0);
}
}
#line 1204 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
size_t___0 ngx_http_script_copy_capture_len_code(ngx_http_script_engine_t *e ) 
{ 
  int *cap ;
  u_char *p ;
  ngx_uint_t n ;
  ngx_http_request_t *r ;
  ngx_http_script_copy_capture_code_t *code ;
  uintptr_t tmp ;

  {
#line 1213
  r = e->request;
#line 1215
  code = (ngx_http_script_copy_capture_code_t *)e->ip;
#line 1217
  e->ip += sizeof(ngx_http_script_copy_capture_code_t );
#line 1219
  n = code->n;
#line 1221
  if (n < r->ncaptures) {
#line 1223
    cap = r->captures;
#line 1225
    if (e->is_args) {
#line 1225
      goto _L;
    } else
#line 1225
    if (e->quote) {
      _L: /* CIL Label */ 
#line 1225
      if ((e->request)->quoted_uri) {
        {
#line 1228
        p = r->captures_data;
#line 1230
        tmp = ngx_escape_uri((u_char *)((void *)0), p + *(cap + n), (size_t___0 )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
        }
#line 1230
        return ((uintptr_t )(*(cap + (n + 1UL)) - *(cap + n)) + 2UL * tmp);
      } else
#line 1225
      if ((e->request)->plus_in_uri) {
        {
#line 1228
        p = r->captures_data;
#line 1230
        tmp = ngx_escape_uri((u_char *)((void *)0), p + *(cap + n), (size_t___0 )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
        }
#line 1230
        return ((uintptr_t )(*(cap + (n + 1UL)) - *(cap + n)) + 2UL * tmp);
      } else {
#line 1234
        return ((size_t___0 )(*(cap + (n + 1UL)) - *(cap + n)));
      }
    } else {
#line 1234
      return ((size_t___0 )(*(cap + (n + 1UL)) - *(cap + n)));
    }
  }
#line 1238
  return ((size_t___0 )0);
}
}
#line 1242 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_copy_capture_code(ngx_http_script_engine_t *e ) 
{ 
  int *cap ;
  u_char *p ;
  u_char *pos ;
  ngx_uint_t n ;
  ngx_http_request_t *r ;
  ngx_http_script_copy_capture_code_t *code ;
  uintptr_t tmp ;
  void *tmp___0 ;

  {
#line 1251
  r = e->request;
#line 1253
  code = (ngx_http_script_copy_capture_code_t *)e->ip;
#line 1255
  e->ip += sizeof(ngx_http_script_copy_capture_code_t );
#line 1257
  n = code->n;
#line 1259
  pos = e->pos;
#line 1261
  if (n < r->ncaptures) {
#line 1263
    cap = r->captures;
#line 1264
    p = r->captures_data;
#line 1266
    if (e->is_args) {
#line 1266
      goto _L;
    } else
#line 1266
    if (e->quote) {
      _L: /* CIL Label */ 
#line 1266
      if ((e->request)->quoted_uri) {
        {
#line 1269
        tmp = ngx_escape_uri(pos, p + *(cap + n), (size_t___0 )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
#line 1269
        e->pos = (u_char *)tmp;
        }
      } else
#line 1266
      if ((e->request)->plus_in_uri) {
        {
#line 1269
        tmp = ngx_escape_uri(pos, p + *(cap + n), (size_t___0 )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
#line 1269
        e->pos = (u_char *)tmp;
        }
      } else {
        {
#line 1273
        tmp___0 = memcpy((void */* __restrict  */)pos, (void const   */* __restrict  */)(p + *(cap + n)),
                         (size_t )(*(cap + (n + 1UL)) - *(cap + n)));
#line 1273
        e->pos = (u_char *)tmp___0 + (*(cap + (n + 1UL)) - *(cap + n));
        }
      }
    } else {
      {
#line 1273
      tmp___0 = memcpy((void */* __restrict  */)pos, (void const   */* __restrict  */)(p + *(cap + n)),
                       (size_t )(*(cap + (n + 1UL)) - *(cap + n)));
#line 1273
      e->pos = (u_char *)tmp___0 + (*(cap + (n + 1UL)) - *(cap + n));
      }
    }
  }
#line 1279
  return;
}
}
#line 1284 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_full_name_code(ngx_http_script_compile_t *sc ) 
{ 
  ngx_http_script_full_name_code_t *code ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1289
  tmp = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_full_name_code_t ),
                                 (void *)0);
#line 1289
  code = (ngx_http_script_full_name_code_t *)tmp;
  }
#line 1292
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1293
    return ((ngx_int_t )-1);
  }
  {
#line 1296
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_full_name_len_code);
#line 1297
  code->conf_prefix = (uintptr_t )sc->conf_prefix;
#line 1299
  tmp___0 = ngx_http_script_add_code(*(sc->values), sizeof(ngx_http_script_full_name_code_t ),
                                     (void *)(& sc->main));
#line 1299
  code = (ngx_http_script_full_name_code_t *)tmp___0;
  }
#line 1302
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1303
    return ((ngx_int_t )-1);
  }
#line 1306
  code->code = & ngx_http_script_full_name_code;
#line 1307
  code->conf_prefix = (uintptr_t )sc->conf_prefix;
#line 1309
  return ((ngx_int_t )0);
}
}
#line 1313 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static size_t___0 ngx_http_script_full_name_len_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_full_name_code_t *code ;
  size_t___0 volatile   tmp ;

  {
#line 1318
  code = (ngx_http_script_full_name_code_t *)e->ip;
#line 1320
  e->ip += sizeof(ngx_http_script_full_name_code_t );
#line 1322
  if (code->conf_prefix) {
#line 1322
    tmp = ngx_cycle->conf_prefix.len;
  } else {
#line 1322
    tmp = ngx_cycle->prefix.len;
  }
#line 1322
  return ((size_t___0 )tmp);
}
}
#line 1327 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
static void ngx_http_script_full_name_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_full_name_code_t *code ;
  ngx_str_t value ;
  ngx_str_t *prefix ;
  ngx_int_t tmp ;

  {
#line 1334
  code = (ngx_http_script_full_name_code_t *)e->ip;
#line 1336
  value.data = e->buf.data;
#line 1337
  value.len = (size_t___0 )(e->pos - e->buf.data);
#line 1339
  if (code->conf_prefix) {
#line 1339
    prefix = (ngx_str_t *)(& ngx_cycle->conf_prefix);
  } else {
#line 1339
    prefix = (ngx_str_t *)(& ngx_cycle->prefix);
  }
  {
#line 1342
  tmp = ngx_get_full_name((e->request)->pool, prefix, & value);
  }
#line 1342
  if (tmp != 0L) {
#line 1343
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1344
    e->status = (ngx_int_t )500;
#line 1345
    return;
  }
#line 1348
  e->buf = value;
#line 1353
  e->ip += sizeof(ngx_http_script_full_name_code_t );
#line 1354
  return;
}
}
#line 1357 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_return_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_return_code_t *code ;

  {
#line 1362
  code = (ngx_http_script_return_code_t *)e->ip;
#line 1364
  if (code->status < 400UL) {
    {
#line 1368
    e->status = ngx_http_send_response(e->request, code->status, (ngx_str_t *)((void *)0),
                                       & code->text);
    }
  } else
#line 1364
  if (code->text.value.len) {
    {
#line 1368
    e->status = ngx_http_send_response(e->request, code->status, (ngx_str_t *)((void *)0),
                                       & code->text);
    }
  } else
#line 1364
  if (code->text.lengths) {
    {
#line 1368
    e->status = ngx_http_send_response(e->request, code->status, (ngx_str_t *)((void *)0),
                                       & code->text);
    }
  } else {
#line 1371
    e->status = (ngx_int_t )code->status;
  }
#line 1374
  e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1375
  return;
}
}
#line 1378 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_break_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 1381
  (e->request)->uri_changed = 0U;
#line 1383
  e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1384
  return;
}
}
#line 1387 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_if_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_if_code_t *code ;

  {
#line 1392
  code = (ngx_http_script_if_code_t *)e->ip;
#line 1397
  (e->sp) --;
#line 1399
  if ((e->sp)->len) {
#line 1399
    if ((e->sp)->len != 1U) {
#line 1399
      goto _L;
    } else
#line 1399
    if ((int )*((e->sp)->data + 0) != 48) {
      _L: /* CIL Label */ 
#line 1400
      if (code->loc_conf) {
        {
#line 1401
        (e->request)->loc_conf = code->loc_conf;
#line 1402
        ngx_http_update_location_config(e->request);
        }
      }
#line 1405
      e->ip += sizeof(ngx_http_script_if_code_t );
#line 1406
      return;
    }
  }
#line 1412
  e->ip += code->next;
#line 1413
  return;
}
}
#line 1416 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_equal_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *val ;
  ngx_http_variable_value_t *res ;
  int tmp ;

  {
#line 1424
  (e->sp) --;
#line 1425
  val = e->sp;
#line 1426
  res = e->sp - 1;
#line 1428
  e->ip += sizeof(uintptr_t );
#line 1430
  if (val->len == res->len) {
    {
#line 1430
    tmp = strncmp((char const   *)val->data, (char const   *)res->data, (size_t )res->len);
    }
#line 1430
    if (tmp == 0) {
#line 1433
      *res = ngx_http_variable_true_value;
#line 1434
      return;
    }
  }
#line 1440
  *res = ngx_http_variable_null_value;
#line 1441
  return;
}
}
#line 1444 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_not_equal_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *val ;
  ngx_http_variable_value_t *res ;
  int tmp ;

  {
#line 1452
  (e->sp) --;
#line 1453
  val = e->sp;
#line 1454
  res = e->sp - 1;
#line 1456
  e->ip += sizeof(uintptr_t );
#line 1458
  if (val->len == res->len) {
    {
#line 1458
    tmp = strncmp((char const   *)val->data, (char const   *)res->data, (size_t )res->len);
    }
#line 1458
    if (tmp == 0) {
#line 1464
      *res = ngx_http_variable_null_value;
#line 1465
      return;
    }
  }
#line 1468
  *res = ngx_http_variable_true_value;
#line 1469
  return;
}
}
#line 1472 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_file_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_str_t path ;
  ngx_http_request_t *r ;
  ngx_open_file_info_t of ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_variable_value_t *value ;
  ngx_http_script_file_code_t *code ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1482
  value = e->sp - 1;
#line 1484
  code = (ngx_http_script_file_code_t *)e->ip;
#line 1485
  e->ip += sizeof(ngx_http_script_file_code_t );
#line 1487
  path.len = (size_t___0 )(value->len - 1U);
#line 1488
  path.data = value->data;
#line 1490
  r = e->request;
#line 1495
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1497
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 1499
  of.read_ahead = clcf->read_ahead;
#line 1500
  of.directio = clcf->directio;
#line 1501
  of.valid = clcf->open_file_cache_valid;
#line 1502
  of.min_uses = clcf->open_file_cache_min_uses;
#line 1503
  of.test_only = 1U;
#line 1504
  of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 1505
  of.events = (unsigned int )clcf->open_file_cache_events;
#line 1507
  tmp = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
  }
#line 1507
  if (tmp != 0L) {
#line 1508
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1509
    e->status = (ngx_int_t )500;
#line 1510
    return;
  }
  {
#line 1513
  tmp___0 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
  }
#line 1513
  if (tmp___0 != 0L) {
#line 1516
    if (of.err == 0) {
#line 1517
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1518
      e->status = (ngx_int_t )500;
#line 1519
      return;
    }
#line 1522
    if (of.err != 2) {
#line 1522
      if (of.err != 20) {
#line 1522
        if (of.err != 36) {
#line 1526
          if (((r->connection)->log)->log_level >= 3UL) {
            {
#line 1526
            ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                               of.failed, value->data);
            }
          }
        }
      }
    }
    {
#line 1535
    if (code->op == 6UL) {
#line 1535
      goto case_6;
    }
#line 1535
    if (code->op == 4UL) {
#line 1535
      goto case_6;
    }
#line 1535
    if (code->op == 2UL) {
#line 1535
      goto case_6;
    }
#line 1535
    if (code->op == 0UL) {
#line 1535
      goto case_6;
    }
#line 1541
    if (code->op == 7UL) {
#line 1541
      goto case_7;
    }
#line 1541
    if (code->op == 5UL) {
#line 1541
      goto case_7;
    }
#line 1541
    if (code->op == 3UL) {
#line 1541
      goto case_7;
    }
#line 1541
    if (code->op == 1UL) {
#line 1541
      goto case_7;
    }
#line 1530
    goto switch_break;
    case_6: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1536
    goto false_value;
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1542
    goto true_value;
    switch_break: /* CIL Label */ ;
    }
#line 1545
    goto false_value;
  }
  {
#line 1549
  if (code->op == 0UL) {
#line 1549
    goto case_0___0;
  }
#line 1555
  if (code->op == 1UL) {
#line 1555
    goto case_1___0;
  }
#line 1561
  if (code->op == 2UL) {
#line 1561
    goto case_2___0;
  }
#line 1567
  if (code->op == 3UL) {
#line 1567
    goto case_3___0;
  }
#line 1573
  if (code->op == 4UL) {
#line 1573
    goto case_4___0;
  }
#line 1579
  if (code->op == 5UL) {
#line 1579
    goto case_5___0;
  }
#line 1585
  if (code->op == 6UL) {
#line 1585
    goto case_6___0;
  }
#line 1591
  if (code->op == 7UL) {
#line 1591
    goto case_7___0;
  }
#line 1548
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 1550
  if (of.is_file) {
#line 1551
    goto true_value;
  }
#line 1553
  goto false_value;
  case_1___0: /* CIL Label */ 
#line 1556
  if (of.is_file) {
#line 1557
    goto false_value;
  }
#line 1559
  goto true_value;
  case_2___0: /* CIL Label */ 
#line 1562
  if (of.is_dir) {
#line 1563
    goto true_value;
  }
#line 1565
  goto false_value;
  case_3___0: /* CIL Label */ 
#line 1568
  if (of.is_dir) {
#line 1569
    goto false_value;
  }
#line 1571
  goto true_value;
  case_4___0: /* CIL Label */ 
#line 1574
  if (of.is_file) {
#line 1575
    goto true_value;
  } else
#line 1574
  if (of.is_dir) {
#line 1575
    goto true_value;
  } else
#line 1574
  if (of.is_link) {
#line 1575
    goto true_value;
  }
#line 1577
  goto false_value;
  case_5___0: /* CIL Label */ 
#line 1580
  if (of.is_file) {
#line 1581
    goto false_value;
  } else
#line 1580
  if (of.is_dir) {
#line 1581
    goto false_value;
  } else
#line 1580
  if (of.is_link) {
#line 1581
    goto false_value;
  }
#line 1583
  goto true_value;
  case_6___0: /* CIL Label */ 
#line 1586
  if (of.is_exec) {
#line 1587
    goto true_value;
  }
#line 1589
  goto false_value;
  case_7___0: /* CIL Label */ 
#line 1592
  if (of.is_exec) {
#line 1593
    goto false_value;
  }
#line 1595
  goto true_value;
  switch_break___0: /* CIL Label */ ;
  }
  false_value: 
#line 1603
  *value = ngx_http_variable_null_value;
#line 1604
  return;
  true_value: 
#line 1608
  *value = ngx_http_variable_true_value;
#line 1609
  return;
}
}
#line 1613 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_complex_value_code(ngx_http_script_engine_t *e ) 
{ 
  size_t___0 len ;
  ngx_http_script_engine_t le ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_complex_value_code_t *code ;
  size_t___0 tmp ;
  void *tmp___0 ;

  {
  {
#line 1621
  code = (ngx_http_script_complex_value_code_t *)e->ip;
#line 1623
  e->ip += sizeof(ngx_http_script_complex_value_code_t );
#line 1628
  memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 1630
  le.ip = (u_char *)(code->lengths)->elts;
#line 1631
  le.line = e->line;
#line 1632
  le.request = e->request;
#line 1633
  le.quote = e->quote;
#line 1635
  len = (size_t___0 )0;
  }
  {
#line 1635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1635
    if (! *((uintptr_t *)le.ip)) {
#line 1635
      goto while_break;
    }
    {
#line 1636
    lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1635
    tmp = (*lcode)(& le);
#line 1635
    len += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1639
  e->buf.len = len;
#line 1640
  tmp___0 = ngx_pnalloc((e->request)->pool, len);
#line 1640
  e->buf.data = (u_char *)tmp___0;
  }
#line 1641
  if ((unsigned long )e->buf.data == (unsigned long )((void *)0)) {
#line 1642
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1643
    e->status = (ngx_int_t )500;
#line 1644
    return;
  }
#line 1647
  e->pos = e->buf.data;
#line 1649
  (e->sp)->len = (unsigned int )e->buf.len;
#line 1650
  (e->sp)->data = e->buf.data;
#line 1651
  (e->sp) ++;
#line 1652
  return;
}
}
#line 1655 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_value_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_value_code_t *code ;

  {
#line 1660
  code = (ngx_http_script_value_code_t *)e->ip;
#line 1662
  e->ip += sizeof(ngx_http_script_value_code_t );
#line 1664
  (e->sp)->len = (unsigned int )code->text_len;
#line 1665
  (e->sp)->data = (u_char *)code->text_data;
#line 1670
  (e->sp) ++;
#line 1671
  return;
}
}
#line 1674 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_set_var_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_script_var_code_t *code ;

  {
#line 1680
  code = (ngx_http_script_var_code_t *)e->ip;
#line 1682
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 1684
  r = e->request;
#line 1686
  (e->sp) --;
#line 1688
  (r->variables + code->index)->len = (e->sp)->len;
#line 1689
  (r->variables + code->index)->valid = 1U;
#line 1690
  (r->variables + code->index)->no_cacheable = 0U;
#line 1691
  (r->variables + code->index)->not_found = 0U;
#line 1692
  (r->variables + code->index)->data = (e->sp)->data;
#line 1707
  return;
}
}
#line 1710 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_var_handler_code_t *code ;

  {
  {
#line 1718
  code = (ngx_http_script_var_handler_code_t *)e->ip;
#line 1720
  e->ip += sizeof(ngx_http_script_var_handler_code_t );
#line 1722
  (e->sp) --;
#line 1724
  (*(code->handler))(e->request, e->sp, code->data);
  }
#line 1725
  return;
}
}
#line 1728 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_var_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *value ;
  ngx_http_script_var_code_t *code ;

  {
  {
#line 1737
  code = (ngx_http_script_var_code_t *)e->ip;
#line 1739
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 1741
  value = ngx_http_get_flushed_variable(e->request, code->index);
  }
#line 1743
  if (value) {
#line 1743
    if (! value->not_found) {
#line 1747
      *(e->sp) = *value;
#line 1748
      (e->sp) ++;
#line 1750
      return;
    }
  }
#line 1753
  *(e->sp) = ngx_http_variable_null_value;
#line 1754
  (e->sp) ++;
#line 1755
  return;
}
}
#line 1758 "/tmp/nginx-1.13.2/src/http/ngx_http_script.c"
void ngx_http_script_nop_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 1761
  e->ip += sizeof(uintptr_t );
#line 1762
  return;
}
}
#line 401 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 797
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 41 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_log_time ;
#line 42
ngx_str_t volatile   ngx_cached_http_log_iso8601 ;
#line 106 "src/http/ngx_http_variables.h"
ngx_int_t ngx_http_variables_add_core_vars(ngx_conf_t *cf ) ;
#line 107
ngx_int_t ngx_http_variables_init_vars(ngx_conf_t *cf ) ;
#line 14 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_http_variable_t *ngx_http_add_prefix_variable(ngx_conf_t *cf , ngx_str_t *name ,
                                                         ngx_uint_t flags ) ;
#line 17
static ngx_int_t ngx_http_variable_request(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 23
static ngx_int_t ngx_http_variable_request_get_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) ;
#line 25
static void ngx_http_variable_request_set_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 27
static ngx_int_t ngx_http_variable_header(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 30
static ngx_int_t ngx_http_variable_cookies(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 32
static ngx_int_t ngx_http_variable_headers(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 34
static ngx_int_t ngx_http_variable_headers_internal(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data , u_char sep ) ;
#line 37
static ngx_int_t ngx_http_variable_unknown_header_in(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 39
static ngx_int_t ngx_http_variable_unknown_header_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 41
static ngx_int_t ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 43
static ngx_int_t ngx_http_variable_request_line(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 45
static ngx_int_t ngx_http_variable_cookie(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 47
static ngx_int_t ngx_http_variable_argument(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) ;
#line 50
static ngx_int_t ngx_http_variable_tcpinfo(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 54
static ngx_int_t ngx_http_variable_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) ;
#line 56
static ngx_int_t ngx_http_variable_host(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 58
static ngx_int_t ngx_http_variable_binary_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 60
static ngx_int_t ngx_http_variable_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 62
static ngx_int_t ngx_http_variable_remote_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 64
static ngx_int_t ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 66
static ngx_int_t ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 68
static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 70
static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 72
static ngx_int_t ngx_http_variable_scheme(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 74
static ngx_int_t ngx_http_variable_https(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                         uintptr_t data ) ;
#line 76
static void ngx_http_variable_set_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) ;
#line 78
static ngx_int_t ngx_http_variable_is_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 80
static ngx_int_t ngx_http_variable_document_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 82
static ngx_int_t ngx_http_variable_realpath_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 84
static ngx_int_t ngx_http_variable_request_filename(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) ;
#line 86
static ngx_int_t ngx_http_variable_server_name(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 88
static ngx_int_t ngx_http_variable_request_method(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) ;
#line 90
static ngx_int_t ngx_http_variable_remote_user(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 92
static ngx_int_t ngx_http_variable_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 94
static ngx_int_t ngx_http_variable_body_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 96
static ngx_int_t ngx_http_variable_pipe(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 98
static ngx_int_t ngx_http_variable_request_completion(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 100
static ngx_int_t ngx_http_variable_request_body(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 102
static ngx_int_t ngx_http_variable_request_body_file(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 104
static ngx_int_t ngx_http_variable_request_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) ;
#line 106
static ngx_int_t ngx_http_variable_request_time(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 108
static ngx_int_t ngx_http_variable_request_id(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 110
static ngx_int_t ngx_http_variable_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 113
static ngx_int_t ngx_http_variable_sent_content_type(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 115
static ngx_int_t ngx_http_variable_sent_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 117
static ngx_int_t ngx_http_variable_sent_location(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 119
static ngx_int_t ngx_http_variable_sent_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 121
static ngx_int_t ngx_http_variable_sent_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 123
static ngx_int_t ngx_http_variable_sent_keep_alive(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 125
static ngx_int_t ngx_http_variable_sent_transfer_encoding(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) ;
#line 128
static ngx_int_t ngx_http_variable_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 130
static ngx_int_t ngx_http_variable_connection_requests(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 133
static ngx_int_t ngx_http_variable_nginx_version(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 135
static ngx_int_t ngx_http_variable_hostname(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) ;
#line 137
static ngx_int_t ngx_http_variable_pid(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) ;
#line 139
static ngx_int_t ngx_http_variable_msec(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 141
static ngx_int_t ngx_http_variable_time_iso8601(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 143
static ngx_int_t ngx_http_variable_time_local(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 162 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_http_variable_t ngx_http_core_variables[69]  = 
#line 162
  {      {{sizeof("http_host") - 1UL, (u_char *)"http_host"}, (void (*)(ngx_http_request_t *r ,
                                                                    ngx_http_variable_value_t *v ,
                                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.host),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_user_agent") - 1UL, (u_char *)"http_user_agent"}, (void (*)(ngx_http_request_t *r ,
                                                                                ngx_http_variable_value_t *v ,
                                                                                uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.user_agent),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_referer") - 1UL, (u_char *)"http_referer"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.referer),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_via") - 1UL, (u_char *)"http_via"}, (void (*)(ngx_http_request_t *r ,
                                                                  ngx_http_variable_value_t *v ,
                                                                  uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.via),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_x_forwarded_for") - 1UL, (u_char *)"http_x_forwarded_for"}, (void (*)(ngx_http_request_t *r ,
                                                                                          ngx_http_variable_value_t *v ,
                                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_headers, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.x_forwarded_for),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_cookie") - 1UL, (u_char *)"http_cookie"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_cookies, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.cookies),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("content_length") - 1UL, (u_char *)"content_length"}, (void (*)(ngx_http_request_t *r ,
                                                                              ngx_http_variable_value_t *v ,
                                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_content_length, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("content_type") - 1UL,
       (u_char *)"content_type"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ))((void *)0), & ngx_http_variable_header,
      (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.content_type), (ngx_uint_t )0,
      (ngx_uint_t )0}, 
        {{sizeof("host") - 1UL, (u_char *)"host"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_host, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("binary_remote_addr") - 1UL, (u_char *)"binary_remote_addr"}, (void (*)(ngx_http_request_t *r ,
                                                                                      ngx_http_variable_value_t *v ,
                                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_binary_remote_addr, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("remote_addr") - 1UL,
       (u_char *)"remote_addr"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_remote_addr,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("remote_port") - 1UL, (u_char *)"remote_port"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_remote_port, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("proxy_protocol_addr") - 1UL,
       (u_char *)"proxy_protocol_addr"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ))((void *)0), & ngx_http_variable_proxy_protocol_addr,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("proxy_protocol_port") - 1UL, (u_char *)"proxy_protocol_port"}, (void (*)(ngx_http_request_t *r ,
                                                                                        ngx_http_variable_value_t *v ,
                                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_proxy_protocol_port, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("server_addr") - 1UL,
       (u_char *)"server_addr"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_server_addr,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("server_port") - 1UL, (u_char *)"server_port"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_server_port, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("server_protocol") - 1UL,
       (u_char *)"server_protocol"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ))((void *)0), & ngx_http_variable_request,
      (unsigned long )(& ((ngx_http_request_t *)0)->http_protocol), (ngx_uint_t )0,
      (ngx_uint_t )0}, 
        {{sizeof("scheme") - 1UL, (u_char *)"scheme"}, (void (*)(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_scheme, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("https") - 1UL, (u_char *)"https"}, (void (*)(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_https, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_uri") - 1UL, (u_char *)"request_uri"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_request, (unsigned long )(& ((ngx_http_request_t *)0)->unparsed_uri),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("uri") - 1UL, (u_char *)"uri"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_request, (unsigned long )(& ((ngx_http_request_t *)0)->uri),
      (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("document_uri") - 1UL, (u_char *)"document_uri"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_request, (unsigned long )(& ((ngx_http_request_t *)0)->uri),
      (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request") - 1UL, (u_char *)"request"}, (void (*)(ngx_http_request_t *r ,
                                                                ngx_http_variable_value_t *v ,
                                                                uintptr_t data ))((void *)0),
      & ngx_http_variable_request_line, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("document_root") - 1UL,
       (u_char *)"document_root"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                             uintptr_t data ))((void *)0), & ngx_http_variable_document_root,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("realpath_root") - 1UL, (u_char *)"realpath_root"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_realpath_root, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("query_string") - 1UL,
       (u_char *)"query_string"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ))((void *)0), & ngx_http_variable_request,
      (unsigned long )(& ((ngx_http_request_t *)0)->args), (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("args") - 1UL,
       (u_char *)"args"}, & ngx_http_variable_set_args, & ngx_http_variable_request,
      (unsigned long )(& ((ngx_http_request_t *)0)->args), (ngx_uint_t )3, (ngx_uint_t )0}, 
        {{sizeof("is_args") - 1UL,
       (u_char *)"is_args"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ))((void *)0), & ngx_http_variable_is_args,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request_filename") - 1UL, (u_char *)"request_filename"}, (void (*)(ngx_http_request_t *r ,
                                                                                  ngx_http_variable_value_t *v ,
                                                                                  uintptr_t data ))((void *)0),
      & ngx_http_variable_request_filename, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("server_name") - 1UL,
       (u_char *)"server_name"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_server_name,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_method") - 1UL, (u_char *)"request_method"}, (void (*)(ngx_http_request_t *r ,
                                                                              ngx_http_variable_value_t *v ,
                                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_request_method, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("remote_user") - 1UL,
       (u_char *)"remote_user"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_remote_user,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("bytes_sent") - 1UL, (u_char *)"bytes_sent"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_bytes_sent, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("body_bytes_sent") - 1UL,
       (u_char *)"body_bytes_sent"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ))((void *)0), & ngx_http_variable_body_bytes_sent,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("pipe") - 1UL, (u_char *)"pipe"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_pipe, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_completion") - 1UL, (u_char *)"request_completion"}, (void (*)(ngx_http_request_t *r ,
                                                                                      ngx_http_variable_value_t *v ,
                                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_request_completion, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_body") - 1UL,
       (u_char *)"request_body"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ))((void *)0), & ngx_http_variable_request_body,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_body_file") - 1UL, (u_char *)"request_body_file"}, (void (*)(ngx_http_request_t *r ,
                                                                                    ngx_http_variable_value_t *v ,
                                                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_request_body_file, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_length") - 1UL,
       (u_char *)"request_length"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ))((void *)0), & ngx_http_variable_request_length,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request_time") - 1UL, (u_char *)"request_time"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_request_time, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request_id") - 1UL,
       (u_char *)"request_id"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_variable_request_id,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("status") - 1UL, (u_char *)"status"}, (void (*)(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_status, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("sent_http_content_type") - 1UL, (u_char *)"sent_http_content_type"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_content_type, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_content_length") - 1UL,
       (u_char *)"sent_http_content_length"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_content_length, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_location") - 1UL,
       (u_char *)"sent_http_location"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ))((void *)0), & ngx_http_variable_sent_location,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_last_modified") - 1UL, (u_char *)"sent_http_last_modified"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_last_modified, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_connection") - 1UL,
       (u_char *)"sent_http_connection"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_connection, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_keep_alive") - 1UL,
       (u_char *)"sent_http_keep_alive"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_keep_alive, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_transfer_encoding") - 1UL,
       (u_char *)"sent_http_transfer_encoding"}, (void (*)(ngx_http_request_t *r ,
                                                           ngx_http_variable_value_t *v ,
                                                           uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_transfer_encoding, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_cache_control") - 1UL,
       (u_char *)"sent_http_cache_control"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ))((void *)0),
      & ngx_http_variable_headers, (unsigned long )(& ((ngx_http_request_t *)0)->headers_out.cache_control),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("limit_rate") - 1UL, (u_char *)"limit_rate"}, & ngx_http_variable_request_set_size,
      & ngx_http_variable_request_get_size, (unsigned long )(& ((ngx_http_request_t *)0)->limit_rate),
      (ngx_uint_t )3, (ngx_uint_t )0}, 
        {{sizeof("connection") - 1UL, (u_char *)"connection"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_connection, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("connection_requests") - 1UL,
       (u_char *)"connection_requests"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ))((void *)0), & ngx_http_variable_connection_requests,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("nginx_version") - 1UL, (u_char *)"nginx_version"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_nginx_version, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("hostname") - 1UL,
       (u_char *)"hostname"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ))((void *)0), & ngx_http_variable_hostname,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("pid") - 1UL, (u_char *)"pid"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_pid, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("msec") - 1UL, (u_char *)"msec"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_msec, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("time_iso8601") - 1UL, (u_char *)"time_iso8601"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_time_iso8601, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("time_local") - 1UL,
       (u_char *)"time_local"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_variable_time_local,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_rtt") - 1UL, (u_char *)"tcpinfo_rtt"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_tcpinfo, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_rttvar") - 1UL,
       (u_char *)"tcpinfo_rttvar"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ))((void *)0), & ngx_http_variable_tcpinfo,
      (uintptr_t )1, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_snd_cwnd") - 1UL, (u_char *)"tcpinfo_snd_cwnd"}, (void (*)(ngx_http_request_t *r ,
                                                                                  ngx_http_variable_value_t *v ,
                                                                                  uintptr_t data ))((void *)0),
      & ngx_http_variable_tcpinfo, (uintptr_t )2, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_rcv_space") - 1UL,
       (u_char *)"tcpinfo_rcv_space"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ))((void *)0), & ngx_http_variable_tcpinfo,
      (uintptr_t )3, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("http_") - 1UL, (u_char *)"http_"}, (void (*)(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_unknown_header_in, (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("sent_http_") - 1UL,
       (u_char *)"sent_http_"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_variable_unknown_header_out,
      (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("sent_trailer_") - 1UL, (u_char *)"sent_trailer_"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_unknown_trailer_out, (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("cookie_") - 1UL,
       (u_char *)"cookie_"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ))((void *)0), & ngx_http_variable_cookie,
      (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("arg_") - 1UL, (u_char *)"arg_"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_argument, (uintptr_t )0, (ngx_uint_t )34, (ngx_uint_t )0}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                         uintptr_t data ))((void *)0), (ngx_int_t (*)(ngx_http_request_t *r ,
                                                                                      ngx_http_variable_value_t *v ,
                                                                                      uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 383 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_http_variable_value_t ngx_http_variable_null_value  =    {(unsigned int )(sizeof("") - 1UL), 1U, 0U, 0U, 0U, (u_char *)""};
#line 385 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_http_variable_value_t ngx_http_variable_true_value  =    {(unsigned int )(sizeof("1") - 1UL), 1U, 0U, 0U, 0U, (u_char *)"1"};
#line 389 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_uint_t ngx_http_variable_depth  =    (ngx_uint_t )100;
#line 392 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_http_variable_t *ngx_http_add_variable(ngx_conf_t *cf , ngx_str_t *name , ngx_uint_t flags ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_hash_key_t *key ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_http_variable_t *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 401
  if (name->len == 0UL) {
    {
#line 402
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"$\"");
    }
#line 404
    return ((ngx_http_variable_t *)((void *)0));
  }
#line 407
  if (flags & 32UL) {
    {
#line 408
    tmp = ngx_http_add_prefix_variable(cf, name, flags);
    }
#line 408
    return (tmp);
  }
#line 411
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 413
  key = (ngx_hash_key_t *)(cmcf->variables_keys)->keys.elts;
#line 414
  i = (ngx_uint_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < (cmcf->variables_keys)->keys.nelts)) {
#line 414
      goto while_break;
    }
#line 415
    if (name->len != (key + i)->key.len) {
#line 418
      goto __Cont;
    } else {
      {
#line 415
      tmp___0 = ngx_strncasecmp(name->data, (key + i)->key.data, name->len);
      }
#line 415
      if (tmp___0 != 0L) {
#line 418
        goto __Cont;
      }
    }
#line 421
    v = (ngx_http_variable_t *)(key + i)->value;
#line 423
    if (! (v->flags & 1UL)) {
      {
#line 424
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the duplicate \"%V\" variable", name);
      }
#line 426
      return ((ngx_http_variable_t *)((void *)0));
    }
#line 429
    v->flags &= flags | 0xffffffffffffffefUL;
#line 431
    return (v);
    __Cont: /* CIL Label */ 
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_variable_t ));
#line 434
  v = (ngx_http_variable_t *)tmp___1;
  }
#line 435
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 436
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 439
  v->name.len = name->len;
#line 440
  tmp___2 = ngx_pnalloc(cf->pool, name->len);
#line 440
  v->name.data = (u_char *)tmp___2;
  }
#line 441
  if ((unsigned long )v->name.data == (unsigned long )((void *)0)) {
#line 442
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 445
  ngx_strlow(v->name.data, name->data, name->len);
#line 447
  v->set_handler = (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                             uintptr_t data ))((void *)0);
#line 448
  v->get_handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                  uintptr_t data ))((void *)0);
#line 449
  v->data = (uintptr_t )0;
#line 450
  v->flags = flags;
#line 451
  v->index = (ngx_uint_t )0;
#line 453
  rc = ngx_hash_add_key(cmcf->variables_keys, & v->name, (void *)v, (ngx_uint_t )0);
  }
#line 455
  if (rc == -1L) {
#line 456
    return ((ngx_http_variable_t *)((void *)0));
  }
#line 459
  if (rc == -3L) {
    {
#line 460
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting variable name \"%V\"",
                       name);
    }
#line 462
    return ((ngx_http_variable_t *)((void *)0));
  }
#line 465
  return (v);
}
}
#line 469 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_http_variable_t *ngx_http_add_prefix_variable(ngx_conf_t *cf , ngx_str_t *name ,
                                                         ngx_uint_t flags ) 
{ 
  ngx_uint_t i ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 476
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 478
  v = (ngx_http_variable_t *)cmcf->prefix_variables.elts;
#line 479
  i = (ngx_uint_t )0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < cmcf->prefix_variables.nelts)) {
#line 479
      goto while_break;
    }
#line 480
    if (name->len != (v + i)->name.len) {
#line 483
      goto __Cont;
    } else {
      {
#line 480
      tmp = ngx_strncasecmp(name->data, (v + i)->name.data, name->len);
      }
#line 480
      if (tmp != 0L) {
#line 483
        goto __Cont;
      }
    }
#line 486
    v += i;
#line 488
    if (! (v->flags & 1UL)) {
      {
#line 489
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the duplicate \"%V\" variable", name);
      }
#line 491
      return ((ngx_http_variable_t *)((void *)0));
    }
#line 494
    v->flags &= flags | 0xffffffffffffffefUL;
#line 496
    return (v);
    __Cont: /* CIL Label */ 
#line 479
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 499
  tmp___0 = ngx_array_push(& cmcf->prefix_variables);
#line 499
  v = (ngx_http_variable_t *)tmp___0;
  }
#line 500
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 501
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 504
  v->name.len = name->len;
#line 505
  tmp___1 = ngx_pnalloc(cf->pool, name->len);
#line 505
  v->name.data = (u_char *)tmp___1;
  }
#line 506
  if ((unsigned long )v->name.data == (unsigned long )((void *)0)) {
#line 507
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 510
  ngx_strlow(v->name.data, name->data, name->len);
#line 512
  v->set_handler = (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                             uintptr_t data ))((void *)0);
#line 513
  v->get_handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                  uintptr_t data ))((void *)0);
#line 514
  v->data = (uintptr_t )0;
#line 515
  v->flags = flags;
#line 516
  v->index = (ngx_uint_t )0;
  }
#line 518
  return (v);
}
}
#line 522 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_get_variable_index(ngx_conf_t *cf , ngx_str_t *name ) 
{ 
  ngx_uint_t i ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 529
  if (name->len == 0UL) {
    {
#line 530
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"$\"");
    }
#line 532
    return ((ngx_int_t )-1);
  }
#line 535
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 537
  v = (ngx_http_variable_t *)cmcf->variables.elts;
#line 539
  if ((unsigned long )v == (unsigned long )((void *)0)) {
    {
#line 540
    tmp = ngx_array_init(& cmcf->variables, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_variable_t ));
    }
#line 540
    if (tmp != 0L) {
#line 544
      return ((ngx_int_t )-1);
    }
  } else {
#line 548
    i = (ngx_uint_t )0;
    {
#line 548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 548
      if (! (i < cmcf->variables.nelts)) {
#line 548
        goto while_break;
      }
#line 549
      if (name->len != (v + i)->name.len) {
#line 552
        goto __Cont;
      } else {
        {
#line 549
        tmp___0 = ngx_strncasecmp(name->data, (v + i)->name.data, name->len);
        }
#line 549
        if (tmp___0 != 0L) {
#line 552
          goto __Cont;
        }
      }
#line 555
      return ((ngx_int_t )i);
      __Cont: /* CIL Label */ 
#line 548
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 559
  tmp___1 = ngx_array_push(& cmcf->variables);
#line 559
  v = (ngx_http_variable_t *)tmp___1;
  }
#line 560
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 561
    return ((ngx_int_t )-1);
  }
  {
#line 564
  v->name.len = name->len;
#line 565
  tmp___2 = ngx_pnalloc(cf->pool, name->len);
#line 565
  v->name.data = (u_char *)tmp___2;
  }
#line 566
  if ((unsigned long )v->name.data == (unsigned long )((void *)0)) {
#line 567
    return ((ngx_int_t )-1);
  }
  {
#line 570
  ngx_strlow(v->name.data, name->data, name->len);
#line 572
  v->set_handler = (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                             uintptr_t data ))((void *)0);
#line 573
  v->get_handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                  uintptr_t data ))((void *)0);
#line 574
  v->data = (uintptr_t )0;
#line 575
  v->flags = (ngx_uint_t )0;
#line 576
  v->index = cmcf->variables.nelts - 1UL;
  }
#line 578
  return ((ngx_int_t )v->index);
}
}
#line 582 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_http_variable_value_t *ngx_http_get_indexed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) 
{ 
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;

  {
#line 588
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 590
  if (cmcf->variables.nelts <= index___0) {
#line 591
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 591
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "unknown variable index: %ui",
                         index___0);
      }
    }
#line 593
    return ((ngx_http_variable_value_t *)((void *)0));
  }
#line 596
  if ((r->variables + index___0)->not_found) {
#line 597
    return (r->variables + index___0);
  } else
#line 596
  if ((r->variables + index___0)->valid) {
#line 597
    return (r->variables + index___0);
  }
#line 600
  v = (ngx_http_variable_t *)cmcf->variables.elts;
#line 602
  if (ngx_http_variable_depth == 0UL) {
#line 603
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 603
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "cycle while evaluating variable \"%V\"",
                         & (v + index___0)->name);
      }
    }
#line 606
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 609
  ngx_http_variable_depth --;
#line 611
  tmp = (*((v + index___0)->get_handler))(r, r->variables + index___0, (v + index___0)->data);
  }
#line 611
  if (tmp == 0L) {
#line 614
    ngx_http_variable_depth ++;
#line 616
    if ((v + index___0)->flags & 2UL) {
#line 617
      (r->variables + index___0)->no_cacheable = 1U;
    }
#line 620
    return (r->variables + index___0);
  }
#line 623
  ngx_http_variable_depth ++;
#line 625
  (r->variables + index___0)->valid = 0U;
#line 626
  (r->variables + index___0)->not_found = 1U;
#line 628
  return ((ngx_http_variable_value_t *)((void *)0));
}
}
#line 632 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_http_variable_value_t *ngx_http_get_flushed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) 
{ 
  ngx_http_variable_value_t *v ;
  ngx_http_variable_value_t *tmp ;

  {
#line 637
  v = r->variables + index___0;
#line 639
  if (v->valid) {
#line 639
    goto _L;
  } else
#line 639
  if (v->not_found) {
    _L: /* CIL Label */ 
#line 640
    if (! v->no_cacheable) {
#line 641
      return (v);
    }
#line 644
    v->valid = 0U;
#line 645
    v->not_found = 0U;
  }
  {
#line 648
  tmp = ngx_http_get_indexed_variable(r, index___0);
  }
#line 648
  return (tmp);
}
}
#line 652 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                                 ngx_uint_t key ) 
{ 
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_variable_t *v ;
  ngx_http_variable_value_t *vv ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_http_variable_value_t *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ngx_int_t tmp___5 ;

  {
  {
#line 661
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 663
  tmp = ngx_hash_find(& cmcf->variables_hash, key, name->data, name->len);
#line 663
  v = (ngx_http_variable_t *)tmp;
  }
#line 665
  if (v) {
#line 666
    if (v->flags & 4UL) {
      {
#line 667
      tmp___0 = ngx_http_get_flushed_variable(r, v->index);
      }
#line 667
      return (tmp___0);
    }
#line 670
    if (ngx_http_variable_depth == 0UL) {
#line 671
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 671
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "cycle while evaluating variable \"%V\"",
                           name);
        }
      }
#line 673
      return ((ngx_http_variable_value_t *)((void *)0));
    }
    {
#line 676
    ngx_http_variable_depth --;
#line 678
    tmp___1 = ngx_palloc(r->pool, sizeof(ngx_http_variable_value_t ));
#line 678
    vv = (ngx_http_variable_value_t *)tmp___1;
    }
#line 680
    if (vv) {
      {
#line 680
      tmp___2 = (*(v->get_handler))(r, vv, v->data);
      }
#line 680
      if (tmp___2 == 0L) {
#line 681
        ngx_http_variable_depth ++;
#line 682
        return (vv);
      }
    }
#line 685
    ngx_http_variable_depth ++;
#line 686
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 689
  tmp___3 = ngx_palloc(r->pool, sizeof(ngx_http_variable_value_t ));
#line 689
  vv = (ngx_http_variable_value_t *)tmp___3;
  }
#line 690
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 691
    return ((ngx_http_variable_value_t *)((void *)0));
  }
#line 694
  len = (size_t___0 )0;
#line 696
  v = (ngx_http_variable_t *)cmcf->prefix_variables.elts;
#line 697
  n = cmcf->prefix_variables.nelts;
#line 699
  i = (ngx_uint_t )0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! (i < cmcf->prefix_variables.nelts)) {
#line 699
      goto while_break;
    }
#line 700
    if (name->len >= (v + i)->name.len) {
#line 700
      if (name->len > len) {
        {
#line 700
        tmp___4 = strncmp((char const   *)name->data, (char const   *)(v + i)->name.data,
                          (v + i)->name.len);
        }
#line 700
        if (tmp___4 == 0) {
#line 703
          len = (v + i)->name.len;
#line 704
          n = i;
        }
      }
    }
#line 699
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if (n != cmcf->prefix_variables.nelts) {
    {
#line 709
    tmp___5 = (*((v + n)->get_handler))(r, vv, (uintptr_t )name);
    }
#line 709
    if (tmp___5 == 0L) {
#line 710
      return (vv);
    }
#line 713
    return ((ngx_http_variable_value_t *)((void *)0));
  }
#line 716
  vv->not_found = 1U;
#line 718
  return (vv);
}
}
#line 722 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_str_t *s ;

  {
#line 728
  s = (ngx_str_t *)((char *)r + data);
#line 730
  if (s->data) {
#line 731
    v->len = (unsigned int )s->len;
#line 732
    v->valid = 1U;
#line 733
    v->no_cacheable = 0U;
#line 734
    v->not_found = 0U;
#line 735
    v->data = s->data;
  } else {
#line 738
    v->not_found = 1U;
  }
#line 741
  return ((ngx_int_t )0);
}
}
#line 762 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_get_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) 
{ 
  size_t___0 *sp ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 768
  sp = (size_t___0 *)((char *)r + data);
#line 770
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 770
  v->data = (u_char *)tmp;
  }
#line 771
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 772
    return ((ngx_int_t )-1);
  }
  {
#line 775
  tmp___0 = ngx_sprintf(v->data, "%uz", *sp);
#line 775
  v->len = (unsigned int )(tmp___0 - v->data);
#line 776
  v->valid = 1U;
#line 777
  v->no_cacheable = 0U;
#line 778
  v->not_found = 0U;
  }
#line 780
  return ((ngx_int_t )0);
}
}
#line 784 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static void ngx_http_variable_request_set_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ssize_t s ;
  ssize_t *sp ;
  ngx_str_t val ;

  {
  {
#line 791
  val.len = (size_t___0 )v->len;
#line 792
  val.data = v->data;
#line 794
  s = ngx_parse_size(& val);
  }
#line 796
  if (s == -1L) {
#line 797
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 797
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid size \"%V\"",
                         & val);
      }
    }
#line 799
    return;
  }
#line 802
  sp = (ssize_t *)((char *)r + data);
#line 804
  *sp = s;
#line 806
  return;
}
}
#line 810 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_header(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 
  ngx_table_elt_t *h ;

  {
#line 816
  h = *((ngx_table_elt_t **)((char *)r + data));
#line 818
  if (h) {
#line 819
    v->len = (unsigned int )h->value.len;
#line 820
    v->valid = 1U;
#line 821
    v->no_cacheable = 0U;
#line 822
    v->not_found = 0U;
#line 823
    v->data = h->value.data;
  } else {
#line 826
    v->not_found = 1U;
  }
#line 829
  return ((ngx_int_t )0);
}
}
#line 833 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_cookies(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 837
  tmp = ngx_http_variable_headers_internal(r, v, data, (u_char )';');
  }
#line 837
  return (tmp);
}
}
#line 841 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_headers(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 845
  tmp = ngx_http_variable_headers_internal(r, v, data, (u_char )',');
  }
#line 845
  return (tmp);
}
}
#line 849 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_headers_internal(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data , u_char sep ) 
{ 
  size_t___0 len ;
  u_char *p ;
  u_char *end ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_array_t *a ;
  ngx_table_elt_t **h ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 859
  a = (ngx_array_t *)((char *)r + data);
#line 861
  n = a->nelts;
#line 862
  h = (ngx_table_elt_t **)a->elts;
#line 864
  len = (size_t___0 )0;
#line 866
  i = (ngx_uint_t )0;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (i < n)) {
#line 866
      goto while_break;
    }
#line 868
    if ((*(h + i))->hash == 0UL) {
#line 869
      goto __Cont;
    }
#line 872
    len += (*(h + i))->value.len + 2UL;
    __Cont: /* CIL Label */ 
#line 866
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  if (len == 0UL) {
#line 876
    v->not_found = 1U;
#line 877
    return ((ngx_int_t )0);
  }
#line 880
  len -= 2UL;
#line 882
  v->valid = 1U;
#line 883
  v->no_cacheable = 0U;
#line 884
  v->not_found = 0U;
#line 886
  if (n == 1UL) {
#line 887
    v->len = (unsigned int )(*h)->value.len;
#line 888
    v->data = (*h)->value.data;
#line 890
    return ((ngx_int_t )0);
  }
  {
#line 893
  tmp = ngx_pnalloc(r->pool, len);
#line 893
  p = (u_char *)tmp;
  }
#line 894
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 895
    return ((ngx_int_t )-1);
  }
#line 898
  v->len = (unsigned int )len;
#line 899
  v->data = p;
#line 901
  end = p + len;
#line 903
  i = (ngx_uint_t )0;
  {
#line 903
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 905
    if ((*(h + i))->hash == 0UL) {
#line 906
      goto __Cont___0;
    }
    {
#line 909
    tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(*(h + i))->value.data,
                     (*(h + i))->value.len);
#line 909
    p = (u_char *)tmp___0 + (*(h + i))->value.len;
    }
#line 911
    if ((unsigned long )p == (unsigned long )end) {
#line 912
      goto while_break___0;
    }
#line 915
    tmp___1 = p;
#line 915
    p ++;
#line 915
    *tmp___1 = sep;
#line 915
    tmp___2 = p;
#line 915
    p ++;
#line 915
    *tmp___2 = (u_char )' ';
    __Cont___0: /* CIL Label */ 
#line 903
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 918
  return ((ngx_int_t )0);
}
}
#line 922 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_unknown_header_in(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 926
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & r->headers_in.headers.part,
                                         sizeof("http_") - 1UL);
  }
#line 926
  return (tmp);
}
}
#line 932 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_unknown_header_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 936
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & r->headers_out.headers.part,
                                         sizeof("sent_http_") - 1UL);
  }
#line 936
  return (tmp);
}
}
#line 942 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 946
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & r->headers_out.trailers.part,
                                         sizeof("sent_trailer_") - 1UL);
  }
#line 946
  return (tmp);
}
}
#line 952 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_variable_unknown_header(ngx_http_variable_value_t *v , ngx_str_t *var ,
                                           ngx_list_part_t *part , size_t___0 prefix ) 
{ 
  u_char ch ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_table_elt_t *header___0 ;

  {
#line 960
  header___0 = (ngx_table_elt_t *)part->elts;
#line 962
  i = (ngx_uint_t )0;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 964
    if (i >= part->nelts) {
#line 965
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 966
        goto while_break;
      }
#line 969
      part = part->next;
#line 970
      header___0 = (ngx_table_elt_t *)part->elts;
#line 971
      i = (ngx_uint_t )0;
    }
#line 974
    if ((header___0 + i)->hash == 0UL) {
#line 975
      goto __Cont;
    }
#line 978
    n = (ngx_uint_t )0;
    {
#line 978
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 978
      if (n + prefix < var->len) {
#line 978
        if (! (n < (header___0 + i)->key.len)) {
#line 978
          goto while_break___0;
        }
      } else {
#line 978
        goto while_break___0;
      }
#line 979
      ch = *((header___0 + i)->key.data + n);
#line 981
      if ((int )ch >= 65) {
#line 981
        if ((int )ch <= 90) {
#line 982
          ch = (u_char )((int )ch | 32);
        } else {
#line 981
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 984
      if ((int )ch == 45) {
#line 985
        ch = (u_char )'_';
      }
#line 988
      if ((int )*(var->data + (n + prefix)) != (int )ch) {
#line 989
        goto while_break___0;
      }
#line 978
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 993
    if (n + prefix == var->len) {
#line 993
      if (n == (header___0 + i)->key.len) {
#line 994
        v->len = (unsigned int )(header___0 + i)->value.len;
#line 995
        v->valid = 1U;
#line 996
        v->no_cacheable = 0U;
#line 997
        v->not_found = 0U;
#line 998
        v->data = (header___0 + i)->value.data;
#line 1000
        return ((ngx_int_t )0);
      }
    }
    __Cont: /* CIL Label */ 
#line 962
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  v->not_found = 1U;
#line 1006
  return ((ngx_int_t )0);
}
}
#line 1010 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_line(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  u_char *s ;

  {
#line 1016
  s = r->request_line.data;
#line 1018
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1019
    s = r->request_start;
#line 1021
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1022
      v->not_found = 1U;
#line 1023
      return ((ngx_int_t )0);
    }
#line 1026
    p = s;
    {
#line 1026
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1026
      if (! ((unsigned long )p < (unsigned long )(r->header_in)->last)) {
#line 1026
        goto while_break;
      }
#line 1027
      if ((int )*p == 13) {
#line 1028
        goto while_break;
      } else
#line 1027
      if ((int )*p == 10) {
#line 1028
        goto while_break;
      }
#line 1026
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1032
    r->request_line.len = (size_t___0 )(p - s);
#line 1033
    r->request_line.data = s;
  }
#line 1036
  v->len = (unsigned int )r->request_line.len;
#line 1037
  v->valid = 1U;
#line 1038
  v->no_cacheable = 0U;
#line 1039
  v->not_found = 0U;
#line 1040
  v->data = s;
#line 1042
  return ((ngx_int_t )0);
}
}
#line 1046 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_cookie(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 
  ngx_str_t *name ;
  ngx_str_t cookie ;
  ngx_str_t s ;
  ngx_int_t tmp ;

  {
  {
#line 1050
  name = (ngx_str_t *)data;
#line 1054
  s.len = name->len - (sizeof("cookie_") - 1UL);
#line 1055
  s.data = (name->data + sizeof("cookie_")) - 1;
#line 1057
  tmp = ngx_http_parse_multi_header_lines(& r->headers_in.cookies, & s, & cookie);
  }
#line 1057
  if (tmp == -5L) {
#line 1060
    v->not_found = 1U;
#line 1061
    return ((ngx_int_t )0);
  }
#line 1064
  v->len = (unsigned int )cookie.len;
#line 1065
  v->valid = 1U;
#line 1066
  v->no_cacheable = 0U;
#line 1067
  v->not_found = 0U;
#line 1068
  v->data = cookie.data;
#line 1070
  return ((ngx_int_t )0);
}
}
#line 1074 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_argument(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) 
{ 
  ngx_str_t *name ;
  u_char *arg ;
  size_t___0 len ;
  ngx_str_t value ;
  ngx_int_t tmp ;

  {
  {
#line 1078
  name = (ngx_str_t *)data;
#line 1084
  len = name->len - (sizeof("arg_") - 1UL);
#line 1085
  arg = (name->data + sizeof("arg_")) - 1;
#line 1087
  tmp = ngx_http_arg(r, arg, len, & value);
  }
#line 1087
  if (tmp != 0L) {
#line 1088
    v->not_found = 1U;
#line 1089
    return ((ngx_int_t )0);
  }
#line 1092
  v->data = value.data;
#line 1093
  v->len = (unsigned int )value.len;
#line 1094
  v->valid = 1U;
#line 1095
  v->no_cacheable = 0U;
#line 1096
  v->not_found = 0U;
#line 1098
  return ((ngx_int_t )0);
}
}
#line 1104 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_tcpinfo(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  struct tcp_info ti ;
  socklen_t len ;
  uint32_t value ;
  int tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;

  {
  {
#line 1112
  len = (socklen_t )sizeof(struct tcp_info );
#line 1113
  tmp = getsockopt((r->connection)->fd, 6, 11, (void */* __restrict  */)(& ti), (socklen_t */* __restrict  */)(& len));
  }
#line 1113
  if (tmp == -1) {
#line 1114
    v->not_found = 1U;
#line 1115
    return ((ngx_int_t )0);
  }
  {
#line 1118
  tmp___0 = ngx_pnalloc(r->pool, sizeof("-2147483648") - 1UL);
#line 1118
  v->data = (u_char *)tmp___0;
  }
#line 1119
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1120
    return ((ngx_int_t )-1);
  }
  {
#line 1124
  if (data == 0UL) {
#line 1124
    goto case_0;
  }
#line 1128
  if (data == 1UL) {
#line 1128
    goto case_1;
  }
#line 1132
  if (data == 2UL) {
#line 1132
    goto case_2;
  }
#line 1136
  if (data == 3UL) {
#line 1136
    goto case_3;
  }
#line 1141
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1125
  value = ti.tcpi_rtt;
#line 1126
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1129
  value = ti.tcpi_rttvar;
#line 1130
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1133
  value = ti.tcpi_snd_cwnd;
#line 1134
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1137
  value = ti.tcpi_rcv_space;
#line 1138
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1142
  value = (uint32_t )0;
#line 1143
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1146
  tmp___1 = ngx_sprintf(v->data, "%uD", value);
#line 1146
  v->len = (unsigned int )(tmp___1 - v->data);
#line 1147
  v->valid = 1U;
#line 1148
  v->no_cacheable = 0U;
#line 1149
  v->not_found = 0U;
  }
#line 1151
  return ((ngx_int_t )0);
}
}
#line 1157 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1163
  if (r->headers_in.content_length) {
#line 1164
    v->len = (unsigned int )(r->headers_in.content_length)->value.len;
#line 1165
    v->data = (r->headers_in.content_length)->value.data;
#line 1166
    v->valid = 1U;
#line 1167
    v->no_cacheable = 0U;
#line 1168
    v->not_found = 0U;
  } else
#line 1170
  if (r->reading_body) {
#line 1171
    v->not_found = 1U;
#line 1172
    v->no_cacheable = 1U;
  } else
#line 1174
  if (r->headers_in.content_length_n >= 0L) {
    {
#line 1175
    tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1175
    p = (u_char *)tmp;
    }
#line 1176
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1177
      return ((ngx_int_t )-1);
    }
    {
#line 1180
    tmp___0 = ngx_sprintf(p, "%O", r->headers_in.content_length_n);
#line 1180
    v->len = (unsigned int )(tmp___0 - p);
#line 1181
    v->data = p;
#line 1182
    v->valid = 1U;
#line 1183
    v->no_cacheable = 0U;
#line 1184
    v->not_found = 0U;
    }
  } else {
#line 1187
    v->not_found = 1U;
  }
#line 1190
  return ((ngx_int_t )0);
}
}
#line 1194 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_host(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 1200
  if (r->headers_in.server.len) {
#line 1201
    v->len = (unsigned int )r->headers_in.server.len;
#line 1202
    v->data = r->headers_in.server.data;
  } else {
#line 1205
    cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1207
    v->len = (unsigned int )cscf->server_name.len;
#line 1208
    v->data = cscf->server_name.data;
  }
#line 1211
  v->valid = 1U;
#line 1212
  v->no_cacheable = 0U;
#line 1213
  v->not_found = 0U;
#line 1215
  return ((ngx_int_t )0);
}
}
#line 1219 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_binary_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;

  {
  {
#line 1231
  if ((int )((r->connection)->sockaddr)->sa_family == 10) {
#line 1231
    goto case_10;
  }
#line 1243
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1232
  sin6 = (struct sockaddr_in6 *)(r->connection)->sockaddr;
#line 1234
  v->len = (unsigned int )sizeof(struct in6_addr );
#line 1235
  v->valid = 1U;
#line 1236
  v->no_cacheable = 0U;
#line 1237
  v->not_found = 0U;
#line 1238
  v->data = sin6->sin6_addr.__in6_u.__u6_addr8;
#line 1240
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1244
  sin = (struct sockaddr_in *)(r->connection)->sockaddr;
#line 1246
  v->len = (unsigned int )sizeof(in_addr_t );
#line 1247
  v->valid = 1U;
#line 1248
  v->no_cacheable = 0U;
#line 1249
  v->not_found = 0U;
#line 1250
  v->data = (u_char *)(& sin->sin_addr);
#line 1252
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1255
  return ((ngx_int_t )0);
}
}
#line 1259 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 


  {
#line 1263
  v->len = (unsigned int )(r->connection)->addr_text.len;
#line 1264
  v->valid = 1U;
#line 1265
  v->no_cacheable = 0U;
#line 1266
  v->not_found = 0U;
#line 1267
  v->data = (r->connection)->addr_text.data;
#line 1269
  return ((ngx_int_t )0);
}
}
#line 1273 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_remote_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_uint_t port ;
  void *tmp ;
  in_port_t tmp___0 ;
  u_char *tmp___1 ;

  {
  {
#line 1279
  v->len = 0U;
#line 1280
  v->valid = 1U;
#line 1281
  v->no_cacheable = 0U;
#line 1282
  v->not_found = 0U;
#line 1284
  tmp = ngx_pnalloc(r->pool, sizeof("65535") - 1UL);
#line 1284
  v->data = (u_char *)tmp;
  }
#line 1285
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1286
    return ((ngx_int_t )-1);
  }
  {
#line 1289
  tmp___0 = ngx_inet_get_port((r->connection)->sockaddr);
#line 1289
  port = (ngx_uint_t )tmp___0;
  }
#line 1291
  if (port > 0UL) {
#line 1291
    if (port < 65536UL) {
      {
#line 1292
      tmp___1 = ngx_sprintf(v->data, "%ui", port);
#line 1292
      v->len = (unsigned int )(tmp___1 - v->data);
      }
    }
  }
#line 1295
  return ((ngx_int_t )0);
}
}
#line 1299 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 


  {
#line 1303
  v->len = (unsigned int )(r->connection)->proxy_protocol_addr.len;
#line 1304
  v->valid = 1U;
#line 1305
  v->no_cacheable = 0U;
#line 1306
  v->not_found = 0U;
#line 1307
  v->data = (r->connection)->proxy_protocol_addr.data;
#line 1309
  return ((ngx_int_t )0);
}
}
#line 1313 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  ngx_uint_t port ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 1319
  v->len = 0U;
#line 1320
  v->valid = 1U;
#line 1321
  v->no_cacheable = 0U;
#line 1322
  v->not_found = 0U;
#line 1324
  tmp = ngx_pnalloc(r->pool, sizeof("65535") - 1UL);
#line 1324
  v->data = (u_char *)tmp;
  }
#line 1325
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1326
    return ((ngx_int_t )-1);
  }
#line 1329
  port = (ngx_uint_t )(r->connection)->proxy_protocol_port;
#line 1331
  if (port > 0UL) {
#line 1331
    if (port < 65536UL) {
      {
#line 1332
      tmp___0 = ngx_sprintf(v->data, "%ui", port);
#line 1332
      v->len = (unsigned int )(tmp___0 - v->data);
      }
    }
  }
#line 1335
  return ((ngx_int_t )0);
}
}
#line 1339 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_str_t s ;
  u_char addr[(sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path))] ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1346
  s.len = (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path));
#line 1347
  s.data = addr;
#line 1349
  tmp = ngx_connection_local_sockaddr(r->connection, & s, (ngx_uint_t )0);
  }
#line 1349
  if (tmp != 0L) {
#line 1350
    return ((ngx_int_t )-1);
  }
  {
#line 1353
  tmp___0 = ngx_pnalloc(r->pool, s.len);
#line 1353
  s.data = (u_char *)tmp___0;
  }
#line 1354
  if ((unsigned long )s.data == (unsigned long )((void *)0)) {
#line 1355
    return ((ngx_int_t )-1);
  }
  {
#line 1358
  memcpy((void */* __restrict  */)s.data, (void const   */* __restrict  */)(addr),
         s.len);
#line 1360
  v->len = (unsigned int )s.len;
#line 1361
  v->valid = 1U;
#line 1362
  v->no_cacheable = 0U;
#line 1363
  v->not_found = 0U;
#line 1364
  v->data = s.data;
  }
#line 1366
  return ((ngx_int_t )0);
}
}
#line 1370 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_uint_t port ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  in_port_t tmp___1 ;
  u_char *tmp___2 ;

  {
  {
#line 1376
  v->len = 0U;
#line 1377
  v->valid = 1U;
#line 1378
  v->no_cacheable = 0U;
#line 1379
  v->not_found = 0U;
#line 1381
  tmp = ngx_connection_local_sockaddr(r->connection, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
  }
#line 1381
  if (tmp != 0L) {
#line 1382
    return ((ngx_int_t )-1);
  }
  {
#line 1385
  tmp___0 = ngx_pnalloc(r->pool, sizeof("65535") - 1UL);
#line 1385
  v->data = (u_char *)tmp___0;
  }
#line 1386
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1387
    return ((ngx_int_t )-1);
  }
  {
#line 1390
  tmp___1 = ngx_inet_get_port((r->connection)->local_sockaddr);
#line 1390
  port = (ngx_uint_t )tmp___1;
  }
#line 1392
  if (port > 0UL) {
#line 1392
    if (port < 65536UL) {
      {
#line 1393
      tmp___2 = ngx_sprintf(v->data, "%ui", port);
#line 1393
      v->len = (unsigned int )(tmp___2 - v->data);
      }
    }
  }
#line 1396
  return ((ngx_int_t )0);
}
}
#line 1400 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_scheme(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 


  {
#line 1418
  v->len = (unsigned int )(sizeof("http") - 1UL);
#line 1419
  v->valid = 1U;
#line 1420
  v->no_cacheable = 0U;
#line 1421
  v->not_found = 0U;
#line 1422
  v->data = (u_char *)"http";
#line 1424
  return ((ngx_int_t )0);
}
}
#line 1428 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_https(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                         uintptr_t data ) 
{ 


  {
#line 1446
  *v = ngx_http_variable_null_value;
#line 1448
  return ((ngx_int_t )0);
}
}
#line 1452 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static void ngx_http_variable_set_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) 
{ 


  {
#line 1456
  r->args.len = (size_t___0 )v->len;
#line 1457
  r->args.data = v->data;
#line 1458
  r->valid_unparsed_uri = 0U;
#line 1459
  return;
}
}
#line 1462 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_is_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 


  {
#line 1466
  v->valid = 1U;
#line 1467
  v->no_cacheable = 0U;
#line 1468
  v->not_found = 0U;
#line 1470
  if (r->args.len == 0UL) {
#line 1471
    v->len = 0U;
#line 1472
    v->data = (u_char *)((void *)0);
#line 1473
    return ((ngx_int_t )0);
  }
#line 1476
  v->len = 1U;
#line 1477
  v->data = (u_char *)"?";
#line 1479
  return ((ngx_int_t )0);
}
}
#line 1483 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_document_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  ngx_str_t path ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1490
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1492
  if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
#line 1493
    v->len = (unsigned int )clcf->root.len;
#line 1494
    v->valid = 1U;
#line 1495
    v->no_cacheable = 0U;
#line 1496
    v->not_found = 0U;
#line 1497
    v->data = clcf->root.data;
  } else {
    {
#line 1500
    tmp = ngx_http_script_run(r, & path, (clcf->root_lengths)->elts, (size_t___0 )0,
                              (clcf->root_values)->elts);
    }
#line 1500
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1504
      return ((ngx_int_t )-1);
    }
    {
#line 1507
    tmp___0 = ngx_get_full_name(r->pool, (ngx_str_t *)(& ngx_cycle->prefix), & path);
    }
#line 1507
    if (tmp___0 != 0L) {
#line 1510
      return ((ngx_int_t )-1);
    }
#line 1513
    v->len = (unsigned int )path.len;
#line 1514
    v->valid = 1U;
#line 1515
    v->no_cacheable = 0U;
#line 1516
    v->not_found = 0U;
#line 1517
    v->data = path.data;
  }
#line 1520
  return ((ngx_int_t )0);
}
}
#line 1524 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_realpath_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  u_char *real ;
  size_t___0 len ;
  ngx_str_t path ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char buffer___0[4096] ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;

  {
#line 1536
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1538
  if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
#line 1539
    path = clcf->root;
  } else {
    {
#line 1542
    tmp = ngx_http_script_run(r, & path, (clcf->root_lengths)->elts, (size_t___0 )1,
                              (clcf->root_values)->elts);
    }
#line 1542
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1546
      return ((ngx_int_t )-1);
    }
    {
#line 1549
    *(path.data + (path.len - 1UL)) = (u_char )'\000';
#line 1551
    tmp___0 = ngx_get_full_name(r->pool, (ngx_str_t *)(& ngx_cycle->prefix), & path);
    }
#line 1551
    if (tmp___0 != 0L) {
#line 1554
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1559
  real = buffer___0;
#line 1564
  tmp___1 = realpath((char const   */* __restrict  */)((char *)path.data), (char */* __restrict  */)((char *)real));
#line 1564
  real = (u_char *)tmp___1;
  }
#line 1566
  if ((unsigned long )real == (unsigned long )((void *)0)) {
#line 1567
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1567
      tmp___2 = __errno_location();
#line 1567
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___2, "realpath() \"%s\" failed",
                         path.data);
      }
    }
#line 1569
    return ((ngx_int_t )-1);
  }
  {
#line 1572
  len = strlen((char const   *)real);
#line 1574
  tmp___3 = ngx_pnalloc(r->pool, len);
#line 1574
  v->data = (u_char *)tmp___3;
  }
#line 1575
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1579
    return ((ngx_int_t )-1);
  }
  {
#line 1582
  v->len = (unsigned int )len;
#line 1583
  v->valid = 1U;
#line 1584
  v->no_cacheable = 0U;
#line 1585
  v->not_found = 0U;
#line 1587
  memcpy((void */* __restrict  */)v->data, (void const   */* __restrict  */)real,
         len);
  }
#line 1593
  return ((ngx_int_t )0);
}
}
#line 1597 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_filename(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) 
{ 
  size_t___0 root ;
  ngx_str_t path ;
  u_char *tmp ;

  {
  {
#line 1604
  tmp = ngx_http_map_uri_to_path(r, & path, & root, (size_t___0 )0);
  }
#line 1604
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1605
    return ((ngx_int_t )-1);
  }
#line 1610
  v->len = (unsigned int )(path.len - 1UL);
#line 1611
  v->valid = 1U;
#line 1612
  v->no_cacheable = 0U;
#line 1613
  v->not_found = 0U;
#line 1614
  v->data = path.data;
#line 1616
  return ((ngx_int_t )0);
}
}
#line 1620 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_server_name(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 1626
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1628
  v->len = (unsigned int )cscf->server_name.len;
#line 1629
  v->valid = 1U;
#line 1630
  v->no_cacheable = 0U;
#line 1631
  v->not_found = 0U;
#line 1632
  v->data = cscf->server_name.data;
#line 1634
  return ((ngx_int_t )0);
}
}
#line 1638 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_method(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) 
{ 


  {
#line 1642
  if ((r->main)->method_name.data) {
#line 1643
    v->len = (unsigned int )(r->main)->method_name.len;
#line 1644
    v->valid = 1U;
#line 1645
    v->no_cacheable = 0U;
#line 1646
    v->not_found = 0U;
#line 1647
    v->data = (r->main)->method_name.data;
  } else {
#line 1650
    v->not_found = 1U;
  }
#line 1653
  return ((ngx_int_t )0);
}
}
#line 1657 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_remote_user(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_int_t rc ;

  {
  {
#line 1663
  rc = ngx_http_auth_basic_user(r);
  }
#line 1665
  if (rc == -5L) {
#line 1666
    v->not_found = 1U;
#line 1667
    return ((ngx_int_t )0);
  }
#line 1670
  if (rc == -1L) {
#line 1671
    return ((ngx_int_t )-1);
  }
#line 1674
  v->len = (unsigned int )r->headers_in.user.len;
#line 1675
  v->valid = 1U;
#line 1676
  v->no_cacheable = 0U;
#line 1677
  v->not_found = 0U;
#line 1678
  v->data = r->headers_in.user.data;
#line 1680
  return ((ngx_int_t )0);
}
}
#line 1684 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 1690
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1690
  p = (u_char *)tmp;
  }
#line 1691
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1692
    return ((ngx_int_t )-1);
  }
  {
#line 1695
  tmp___0 = ngx_sprintf(p, "%O", (r->connection)->sent);
#line 1695
  v->len = (unsigned int )(tmp___0 - p);
#line 1696
  v->valid = 1U;
#line 1697
  v->no_cacheable = 0U;
#line 1698
  v->not_found = 0U;
#line 1699
  v->data = p;
  }
#line 1701
  return ((ngx_int_t )0);
}
}
#line 1705 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_body_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  off_t sent ;
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1712
  sent = (off_t )((size_t___0 )(r->connection)->sent - r->header_size);
#line 1714
  if (sent < 0L) {
#line 1715
    sent = (off_t )0;
  }
  {
#line 1718
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1718
  p = (u_char *)tmp;
  }
#line 1719
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1720
    return ((ngx_int_t )-1);
  }
  {
#line 1723
  tmp___0 = ngx_sprintf(p, "%O", sent);
#line 1723
  v->len = (unsigned int )(tmp___0 - p);
#line 1724
  v->valid = 1U;
#line 1725
  v->no_cacheable = 0U;
#line 1726
  v->not_found = 0U;
#line 1727
  v->data = p;
  }
#line 1729
  return ((ngx_int_t )0);
}
}
#line 1733 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_pipe(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 
  char const   *tmp ;

  {
#line 1737
  if (r->pipeline) {
#line 1737
    tmp = "p";
  } else {
#line 1737
    tmp = ".";
  }
#line 1737
  v->data = (u_char *)tmp;
#line 1738
  v->len = 1U;
#line 1739
  v->valid = 1U;
#line 1740
  v->no_cacheable = 0U;
#line 1741
  v->not_found = 0U;
#line 1743
  return ((ngx_int_t )0);
}
}
#line 1747 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 
  ngx_uint_t status ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 1753
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1753
  v->data = (u_char *)tmp;
  }
#line 1754
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1755
    return ((ngx_int_t )-1);
  }
#line 1758
  if (r->err_status) {
#line 1759
    status = r->err_status;
  } else
#line 1761
  if (r->headers_out.status) {
#line 1762
    status = r->headers_out.status;
  } else
#line 1764
  if (r->http_version == 9UL) {
#line 1765
    status = (ngx_uint_t )9;
  } else {
#line 1768
    status = (ngx_uint_t )0;
  }
  {
#line 1771
  tmp___0 = ngx_sprintf(v->data, "%03ui", status);
#line 1771
  v->len = (unsigned int )(tmp___0 - v->data);
#line 1772
  v->valid = 1U;
#line 1773
  v->no_cacheable = 0U;
#line 1774
  v->not_found = 0U;
  }
#line 1776
  return ((ngx_int_t )0);
}
}
#line 1780 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_content_type(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 


  {
#line 1784
  if (r->headers_out.content_type.len) {
#line 1785
    v->len = (unsigned int )r->headers_out.content_type.len;
#line 1786
    v->valid = 1U;
#line 1787
    v->no_cacheable = 0U;
#line 1788
    v->not_found = 0U;
#line 1789
    v->data = r->headers_out.content_type.data;
  } else {
#line 1792
    v->not_found = 1U;
  }
#line 1795
  return ((ngx_int_t )0);
}
}
#line 1799 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1805
  if (r->headers_out.content_length) {
#line 1806
    v->len = (unsigned int )(r->headers_out.content_length)->value.len;
#line 1807
    v->valid = 1U;
#line 1808
    v->no_cacheable = 0U;
#line 1809
    v->not_found = 0U;
#line 1810
    v->data = (r->headers_out.content_length)->value.data;
#line 1812
    return ((ngx_int_t )0);
  }
#line 1815
  if (r->headers_out.content_length_n >= 0L) {
    {
#line 1816
    tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1816
    p = (u_char *)tmp;
    }
#line 1817
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1818
      return ((ngx_int_t )-1);
    }
    {
#line 1821
    tmp___0 = ngx_sprintf(p, "%O", r->headers_out.content_length_n);
#line 1821
    v->len = (unsigned int )(tmp___0 - p);
#line 1822
    v->valid = 1U;
#line 1823
    v->no_cacheable = 0U;
#line 1824
    v->not_found = 0U;
#line 1825
    v->data = p;
    }
#line 1827
    return ((ngx_int_t )0);
  }
#line 1830
  v->not_found = 1U;
#line 1832
  return ((ngx_int_t )0);
}
}
#line 1836 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_location(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  ngx_str_t name ;
  ngx_int_t tmp ;

  {
#line 1842
  if (r->headers_out.location) {
#line 1843
    v->len = (unsigned int )(r->headers_out.location)->value.len;
#line 1844
    v->valid = 1U;
#line 1845
    v->no_cacheable = 0U;
#line 1846
    v->not_found = 0U;
#line 1847
    v->data = (r->headers_out.location)->value.data;
#line 1849
    return ((ngx_int_t )0);
  }
  {
#line 1852
  name.len = sizeof("sent_http_location") - 1UL;
#line 1852
  name.data = (u_char *)"sent_http_location";
#line 1854
  tmp = ngx_http_variable_unknown_header(v, & name, & r->headers_out.headers.part,
                                         sizeof("sent_http_") - 1UL);
  }
#line 1854
  return (tmp);
}
}
#line 1860 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1866
  if (r->headers_out.last_modified) {
#line 1867
    v->len = (unsigned int )(r->headers_out.last_modified)->value.len;
#line 1868
    v->valid = 1U;
#line 1869
    v->no_cacheable = 0U;
#line 1870
    v->not_found = 0U;
#line 1871
    v->data = (r->headers_out.last_modified)->value.data;
#line 1873
    return ((ngx_int_t )0);
  }
#line 1876
  if (r->headers_out.last_modified_time >= 0L) {
    {
#line 1877
    tmp = ngx_pnalloc(r->pool, sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1UL);
#line 1877
    p = (u_char *)tmp;
    }
#line 1878
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1879
      return ((ngx_int_t )-1);
    }
    {
#line 1882
    tmp___0 = ngx_http_time(p, r->headers_out.last_modified_time);
#line 1882
    v->len = (unsigned int )(tmp___0 - p);
#line 1883
    v->valid = 1U;
#line 1884
    v->no_cacheable = 0U;
#line 1885
    v->not_found = 0U;
#line 1886
    v->data = p;
    }
#line 1888
    return ((ngx_int_t )0);
  }
#line 1891
  v->not_found = 1U;
#line 1893
  return ((ngx_int_t )0);
}
}
#line 1897 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  size_t___0 len ;
  char *p ;

  {
#line 1904
  if (r->headers_out.status == 101UL) {
#line 1905
    len = sizeof("upgrade") - 1UL;
#line 1906
    p = (char *)"upgrade";
  } else
#line 1908
  if (r->keepalive) {
#line 1909
    len = sizeof("keep-alive") - 1UL;
#line 1910
    p = (char *)"keep-alive";
  } else {
#line 1913
    len = sizeof("close") - 1UL;
#line 1914
    p = (char *)"close";
  }
#line 1917
  v->len = (unsigned int )len;
#line 1918
  v->valid = 1U;
#line 1919
  v->no_cacheable = 0U;
#line 1920
  v->not_found = 0U;
#line 1921
  v->data = (u_char *)p;
#line 1923
  return ((ngx_int_t )0);
}
}
#line 1927 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_keep_alive(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  u_char *p ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1934
  if (r->keepalive) {
#line 1935
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1937
    if (clcf->keepalive_header) {
      {
#line 1939
      tmp = ngx_pnalloc(r->pool, (sizeof("timeout=") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 1939
      p = (u_char *)tmp;
      }
#line 1940
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1941
        return ((ngx_int_t )-1);
      }
      {
#line 1944
      tmp___0 = ngx_sprintf(p, "timeout=%T", clcf->keepalive_header);
#line 1944
      v->len = (unsigned int )(tmp___0 - p);
#line 1945
      v->valid = 1U;
#line 1946
      v->no_cacheable = 0U;
#line 1947
      v->not_found = 0U;
#line 1948
      v->data = p;
      }
#line 1950
      return ((ngx_int_t )0);
    }
  }
#line 1954
  v->not_found = 1U;
#line 1956
  return ((ngx_int_t )0);
}
}
#line 1960 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_transfer_encoding(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) 
{ 


  {
#line 1964
  if (r->chunked) {
#line 1965
    v->len = (unsigned int )(sizeof("chunked") - 1UL);
#line 1966
    v->valid = 1U;
#line 1967
    v->no_cacheable = 0U;
#line 1968
    v->not_found = 0U;
#line 1969
    v->data = (u_char *)"chunked";
  } else {
#line 1972
    v->not_found = 1U;
  }
#line 1975
  return ((ngx_int_t )0);
}
}
#line 1979 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_completion(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 


  {
#line 1983
  if (r->request_complete) {
#line 1984
    v->len = 2U;
#line 1985
    v->valid = 1U;
#line 1986
    v->no_cacheable = 0U;
#line 1987
    v->not_found = 0U;
#line 1988
    v->data = (u_char *)"OK";
#line 1990
    return ((ngx_int_t )0);
  }
#line 1993
  v->len = 0U;
#line 1994
  v->valid = 1U;
#line 1995
  v->no_cacheable = 0U;
#line 1996
  v->not_found = 0U;
#line 1997
  v->data = (u_char *)"";
#line 1999
  return ((ngx_int_t )0);
}
}
#line 2003 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_body(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2012
  if ((unsigned long )r->request_body == (unsigned long )((void *)0)) {
#line 2016
    v->not_found = 1U;
#line 2018
    return ((ngx_int_t )0);
  } else
#line 2012
  if ((unsigned long )(r->request_body)->bufs == (unsigned long )((void *)0)) {
#line 2016
    v->not_found = 1U;
#line 2018
    return ((ngx_int_t )0);
  } else
#line 2012
  if ((r->request_body)->temp_file) {
#line 2016
    v->not_found = 1U;
#line 2018
    return ((ngx_int_t )0);
  }
#line 2021
  cl = (r->request_body)->bufs;
#line 2022
  buf = cl->buf;
#line 2024
  if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 2025
    v->len = (unsigned int )(buf->last - buf->pos);
#line 2026
    v->valid = 1U;
#line 2027
    v->no_cacheable = 0U;
#line 2028
    v->not_found = 0U;
#line 2029
    v->data = buf->pos;
#line 2031
    return ((ngx_int_t )0);
  }
#line 2034
  len = (size_t___0 )(buf->last - buf->pos);
#line 2035
  cl = cl->next;
  {
#line 2037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2037
    if (! cl) {
#line 2037
      goto while_break;
    }
#line 2038
    buf = cl->buf;
#line 2039
    len += (size_t___0 )(buf->last - buf->pos);
#line 2037
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2042
  tmp = ngx_pnalloc(r->pool, len);
#line 2042
  p = (u_char *)tmp;
  }
#line 2043
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2044
    return ((ngx_int_t )-1);
  }
#line 2047
  v->data = p;
#line 2048
  cl = (r->request_body)->bufs;
  {
#line 2050
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2050
    if (! cl) {
#line 2050
      goto while_break___0;
    }
    {
#line 2051
    buf = cl->buf;
#line 2052
    tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf->pos,
                     (size_t )(buf->last - buf->pos));
#line 2052
    p = (u_char *)tmp___0 + (buf->last - buf->pos);
#line 2050
    cl = cl->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2055
  v->len = (unsigned int )len;
#line 2056
  v->valid = 1U;
#line 2057
  v->no_cacheable = 0U;
#line 2058
  v->not_found = 0U;
#line 2060
  return ((ngx_int_t )0);
}
}
#line 2064 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_body_file(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 


  {
#line 2068
  if ((unsigned long )r->request_body == (unsigned long )((void *)0)) {
#line 2069
    v->not_found = 1U;
#line 2071
    return ((ngx_int_t )0);
  } else
#line 2068
  if ((unsigned long )(r->request_body)->temp_file == (unsigned long )((void *)0)) {
#line 2069
    v->not_found = 1U;
#line 2071
    return ((ngx_int_t )0);
  }
#line 2074
  v->len = (unsigned int )((r->request_body)->temp_file)->file.name.len;
#line 2075
  v->valid = 1U;
#line 2076
  v->no_cacheable = 0U;
#line 2077
  v->not_found = 0U;
#line 2078
  v->data = ((r->request_body)->temp_file)->file.name.data;
#line 2080
  return ((ngx_int_t )0);
}
}
#line 2084 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 2090
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2090
  p = (u_char *)tmp;
  }
#line 2091
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2092
    return ((ngx_int_t )-1);
  }
  {
#line 2095
  tmp___0 = ngx_sprintf(p, "%O", r->request_length);
#line 2095
  v->len = (unsigned int )(tmp___0 - p);
#line 2096
  v->valid = 1U;
#line 2097
  v->no_cacheable = 0U;
#line 2098
  v->not_found = 0U;
#line 2099
  v->data = p;
  }
#line 2101
  return ((ngx_int_t )0);
}
}
#line 2105 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_time(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  ngx_time_t *tp ;
  ngx_msec_int_t ms ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 2113
  tmp = ngx_pnalloc(r->pool, (sizeof("-9223372036854775808") - 1UL) + 4UL);
#line 2113
  p = (u_char *)tmp;
  }
#line 2114
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2115
    return ((ngx_int_t )-1);
  }
#line 2118
  tp = (ngx_time_t *)ngx_cached_time;
#line 2120
  ms = (ngx_msec_int_t )((ngx_uint_t )((tp->sec - r->start_sec) * 1000L) + (tp->msec - r->start_msec));
#line 2122
  if (ms < 0L) {
#line 2122
    ms = (ngx_msec_int_t )0;
  } else {
#line 2122
    ms = ms;
  }
  {
#line 2124
  tmp___0 = ngx_sprintf(p, "%T.%03M", ms / 1000L, ms % 1000L);
#line 2124
  v->len = (unsigned int )(tmp___0 - p);
#line 2125
  v->valid = 1U;
#line 2126
  v->no_cacheable = 0U;
#line 2127
  v->not_found = 0U;
#line 2128
  v->data = p;
  }
#line 2130
  return ((ngx_int_t )0);
}
}
#line 2134 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_id(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *id ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2144
  tmp = ngx_pnalloc(r->pool, (size_t___0 )32);
#line 2144
  id = (u_char *)tmp;
  }
#line 2145
  if ((unsigned long )id == (unsigned long )((void *)0)) {
#line 2146
    return ((ngx_int_t )-1);
  }
  {
#line 2149
  v->valid = 1U;
#line 2150
  v->no_cacheable = 0U;
#line 2151
  v->not_found = 0U;
#line 2153
  v->len = 32U;
#line 2154
  v->data = id;
#line 2167
  tmp___0 = random();
#line 2167
  tmp___1 = random();
#line 2167
  tmp___2 = random();
#line 2167
  tmp___3 = random();
#line 2167
  ngx_sprintf(id, "%08xD%08xD%08xD%08xD", (uint32_t )tmp___3, (uint32_t )tmp___2,
              (uint32_t )tmp___1, (uint32_t )tmp___0);
  }
#line 2171
  return ((ngx_int_t )0);
}
}
#line 2175 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 2181
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2181
  p = (u_char *)tmp;
  }
#line 2182
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2183
    return ((ngx_int_t )-1);
  }
  {
#line 2186
  tmp___0 = ngx_sprintf(p, "%uA", (r->connection)->number);
#line 2186
  v->len = (unsigned int )(tmp___0 - p);
#line 2187
  v->valid = 1U;
#line 2188
  v->no_cacheable = 0U;
#line 2189
  v->not_found = 0U;
#line 2190
  v->data = p;
  }
#line 2192
  return ((ngx_int_t )0);
}
}
#line 2196 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_connection_requests(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 2202
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2202
  p = (u_char *)tmp;
  }
#line 2203
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2204
    return ((ngx_int_t )-1);
  }
  {
#line 2207
  tmp___0 = ngx_sprintf(p, "%ui", (r->connection)->requests);
#line 2207
  v->len = (unsigned int )(tmp___0 - p);
#line 2208
  v->valid = 1U;
#line 2209
  v->no_cacheable = 0U;
#line 2210
  v->not_found = 0U;
#line 2211
  v->data = p;
  }
#line 2213
  return ((ngx_int_t )0);
}
}
#line 2217 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_nginx_version(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 


  {
#line 2221
  v->len = (unsigned int )(sizeof("1.13.2") - 1UL);
#line 2222
  v->valid = 1U;
#line 2223
  v->no_cacheable = 0U;
#line 2224
  v->not_found = 0U;
#line 2225
  v->data = (u_char *)"1.13.2";
#line 2227
  return ((ngx_int_t )0);
}
}
#line 2231 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_hostname(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) 
{ 


  {
#line 2235
  v->len = (unsigned int )ngx_cycle->hostname.len;
#line 2236
  v->valid = 1U;
#line 2237
  v->no_cacheable = 0U;
#line 2238
  v->not_found = 0U;
#line 2239
  v->data = (u_char *)ngx_cycle->hostname.data;
#line 2241
  return ((ngx_int_t )0);
}
}
#line 2245 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_pid(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 2251
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2251
  p = (u_char *)tmp;
  }
#line 2252
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2253
    return ((ngx_int_t )-1);
  }
  {
#line 2256
  tmp___0 = ngx_sprintf(p, "%P", ngx_pid);
#line 2256
  v->len = (unsigned int )(tmp___0 - p);
#line 2257
  v->valid = 1U;
#line 2258
  v->no_cacheable = 0U;
#line 2259
  v->not_found = 0U;
#line 2260
  v->data = p;
  }
#line 2262
  return ((ngx_int_t )0);
}
}
#line 2266 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_msec(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 
  u_char *p ;
  ngx_time_t *tp ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 2273
  tmp = ngx_pnalloc(r->pool, (sizeof("-9223372036854775808") - 1UL) + 4UL);
#line 2273
  p = (u_char *)tmp;
  }
#line 2274
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2275
    return ((ngx_int_t )-1);
  }
  {
#line 2278
  tp = (ngx_time_t *)ngx_cached_time;
#line 2280
  tmp___0 = ngx_sprintf(p, "%T.%03M", tp->sec, tp->msec);
#line 2280
  v->len = (unsigned int )(tmp___0 - p);
#line 2281
  v->valid = 1U;
#line 2282
  v->no_cacheable = 0U;
#line 2283
  v->not_found = 0U;
#line 2284
  v->data = p;
  }
#line 2286
  return ((ngx_int_t )0);
}
}
#line 2290 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_time_iso8601(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 2296
  tmp = ngx_pnalloc(r->pool, (size_t___0 )ngx_cached_http_log_iso8601.len);
#line 2296
  p = (u_char *)tmp;
  }
#line 2297
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2298
    return ((ngx_int_t )-1);
  }
  {
#line 2301
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ngx_cached_http_log_iso8601.data,
         (size_t )ngx_cached_http_log_iso8601.len);
#line 2304
  v->len = (unsigned int )ngx_cached_http_log_iso8601.len;
#line 2305
  v->valid = 1U;
#line 2306
  v->no_cacheable = 0U;
#line 2307
  v->not_found = 0U;
#line 2308
  v->data = p;
  }
#line 2310
  return ((ngx_int_t )0);
}
}
#line 2314 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_time_local(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 2320
  tmp = ngx_pnalloc(r->pool, (size_t___0 )ngx_cached_http_log_time.len);
#line 2320
  p = (u_char *)tmp;
  }
#line 2321
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2322
    return ((ngx_int_t )-1);
  }
  {
#line 2325
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ngx_cached_http_log_time.data,
         (size_t )ngx_cached_http_log_time.len);
#line 2327
  v->len = (unsigned int )ngx_cached_http_log_time.len;
#line 2328
  v->valid = 1U;
#line 2329
  v->no_cacheable = 0U;
#line 2330
  v->not_found = 0U;
#line 2331
  v->data = p;
  }
#line 2333
  return ((ngx_int_t )0);
}
}
#line 2337 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
void *ngx_http_map_find(ngx_http_request_t *r , ngx_http_map_t *map___0 , ngx_str_t *match ) 
{ 
  void *value ;
  u_char *low ;
  size_t___0 len ;
  ngx_uint_t key ;
  void *tmp ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_http_map_regex_t *reg ;

  {
#line 2345
  len = match->len;
#line 2347
  if (len) {
    {
#line 2348
    tmp = ngx_pnalloc(r->pool, len);
#line 2348
    low = (u_char *)tmp;
    }
#line 2349
    if ((unsigned long )low == (unsigned long )((void *)0)) {
#line 2350
      return ((void *)0);
    }
  } else {
#line 2354
    low = (u_char *)((void *)0);
  }
  {
#line 2357
  key = ngx_hash_strlow(low, match->data, len);
#line 2359
  value = ngx_hash_find_combined(& map___0->hash, key, low, len);
  }
#line 2360
  if (value) {
#line 2361
    return (value);
  }
#line 2366
  if (len) {
#line 2366
    if (map___0->nregex) {
#line 2371
      reg = map___0->regex;
#line 2373
      i = (ngx_uint_t )0;
      {
#line 2373
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2373
        if (! (i < map___0->nregex)) {
#line 2373
          goto while_break;
        }
        {
#line 2375
        n = ngx_http_regex_exec(r, (reg + i)->regex, match);
        }
#line 2377
        if (n == 0L) {
#line 2378
          return ((reg + i)->value);
        }
#line 2381
        if (n == -5L) {
#line 2382
          goto __Cont;
        }
#line 2387
        return ((void *)0);
        __Cont: /* CIL Label */ 
#line 2373
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2393
  return ((void *)0);
}
}
#line 2399 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_not_found(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                             uintptr_t data ) 
{ 


  {
#line 2403
  v->not_found = 1U;
#line 2404
  return ((ngx_int_t )0);
}
}
#line 2408 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_http_regex_t *ngx_http_regex_compile(ngx_conf_t *cf , ngx_regex_compile_t *rc ) 
{ 
  u_char *p ;
  size_t___0 size ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_variable_t *v ;
  ngx_http_regex_t *re ;
  ngx_http_regex_variable_t *rv ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 2420
  rc->pool = cf->pool;
#line 2422
  tmp = ngx_regex_compile(rc);
  }
#line 2422
  if (tmp != 0L) {
    {
#line 2423
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc->err);
    }
#line 2424
    return ((ngx_http_regex_t *)((void *)0));
  }
  {
#line 2427
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_regex_t ));
#line 2427
  re = (ngx_http_regex_t *)tmp___0;
  }
#line 2428
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 2429
    return ((ngx_http_regex_t *)((void *)0));
  }
#line 2432
  re->regex = rc->regex;
#line 2433
  re->ncaptures = (ngx_uint_t )rc->captures;
#line 2434
  re->name = rc->pattern;
#line 2436
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 2437
  if (cmcf->ncaptures < re->ncaptures) {
#line 2437
    cmcf->ncaptures = re->ncaptures;
  } else {
#line 2437
    cmcf->ncaptures = cmcf->ncaptures;
  }
#line 2439
  n = (ngx_uint_t )rc->named_captures;
#line 2441
  if (n == 0UL) {
#line 2442
    return (re);
  }
  {
#line 2445
  tmp___1 = ngx_palloc(rc->pool, n * sizeof(ngx_http_regex_variable_t ));
#line 2445
  rv = (ngx_http_regex_variable_t *)tmp___1;
  }
#line 2446
  if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 2447
    return ((ngx_http_regex_t *)((void *)0));
  }
#line 2450
  re->variables = rv;
#line 2451
  re->nvariables = n;
#line 2453
  size = (size_t___0 )rc->name_size;
#line 2454
  p = rc->names;
#line 2456
  i = (ngx_uint_t )0;
  {
#line 2456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2456
    if (! (i < n)) {
#line 2456
      goto while_break;
    }
    {
#line 2457
    (rv + i)->capture = (ngx_uint_t )(2 * (((int )*(p + 0) << 8) + (int )*(p + 1)));
#line 2459
    name.data = p + 2;
#line 2460
    name.len = strlen((char const   *)name.data);
#line 2462
    v = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
    }
#line 2463
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2464
      return ((ngx_http_regex_t *)((void *)0));
    }
    {
#line 2467
    (rv + i)->index = ngx_http_get_variable_index(cf, & name);
    }
#line 2468
    if ((rv + i)->index == -1L) {
#line 2469
      return ((ngx_http_regex_t *)((void *)0));
    }
#line 2472
    v->get_handler = & ngx_http_variable_not_found;
#line 2474
    p += size;
#line 2456
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2477
  return (re);
}
}
#line 2481 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_regex_exec(ngx_http_request_t *r , ngx_http_regex_t *re , ngx_str_t *s ) 
{ 
  ngx_int_t rc ;
  ngx_int_t index___0 ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t len ;
  ngx_http_variable_value_t *vv ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  int tmp___0 ;

  {
#line 2489
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 2491
  if (re->ncaptures) {
#line 2492
    len = cmcf->ncaptures;
#line 2494
    if ((unsigned long )r->captures == (unsigned long )((void *)0)) {
      {
#line 2495
      tmp = ngx_palloc(r->pool, len * sizeof(int ));
#line 2495
      r->captures = (int *)tmp;
      }
#line 2496
      if ((unsigned long )r->captures == (unsigned long )((void *)0)) {
#line 2497
        return ((ngx_int_t )-1);
      }
    }
  } else {
#line 2502
    len = (ngx_uint_t )0;
  }
  {
#line 2505
  tmp___0 = pcre_exec((pcre const   *)(re->regex)->code, (pcre_extra const   *)(re->regex)->extra,
                      (char const   *)s->data, (int )s->len, 0, 0, r->captures, (int )len);
#line 2505
  rc = (ngx_int_t )tmp___0;
  }
#line 2507
  if (rc == -1L) {
#line 2508
    return ((ngx_int_t )-5);
  }
#line 2511
  if (rc < 0L) {
#line 2512
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 2512
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "pcre_exec() failed: %i on \"%V\" using \"%V\"",
                         rc, s, & re->name);
      }
    }
#line 2515
    return ((ngx_int_t )-1);
  }
#line 2518
  i = (ngx_uint_t )0;
  {
#line 2518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2518
    if (! (i < re->nvariables)) {
#line 2518
      goto while_break;
    }
#line 2520
    n = (re->variables + i)->capture;
#line 2521
    index___0 = (re->variables + i)->index;
#line 2522
    vv = r->variables + index___0;
#line 2524
    vv->len = (unsigned int )(*(r->captures + (n + 1UL)) - *(r->captures + n));
#line 2525
    vv->valid = 1U;
#line 2526
    vv->no_cacheable = 0U;
#line 2527
    vv->not_found = 0U;
#line 2528
    vv->data = s->data + *(r->captures + n);
#line 2518
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2542
  r->ncaptures = (ngx_uint_t )(rc * 2L);
#line 2543
  r->captures_data = s->data;
#line 2545
  return ((ngx_int_t )0);
}
}
#line 2551 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_variables_add_core_vars(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *cv ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 2557
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 2559
  tmp = ngx_pcalloc(cf->temp_pool, sizeof(ngx_hash_keys_arrays_t ));
#line 2559
  cmcf->variables_keys = (ngx_hash_keys_arrays_t *)tmp;
  }
#line 2561
  if ((unsigned long )cmcf->variables_keys == (unsigned long )((void *)0)) {
#line 2562
    return ((ngx_int_t )-1);
  }
  {
#line 2565
  (cmcf->variables_keys)->pool = cf->pool;
#line 2566
  (cmcf->variables_keys)->temp_pool = cf->pool;
#line 2568
  tmp___0 = ngx_hash_keys_array_init(cmcf->variables_keys, (ngx_uint_t )1);
  }
#line 2568
  if (tmp___0 != 0L) {
#line 2571
    return ((ngx_int_t )-1);
  }
  {
#line 2574
  tmp___1 = ngx_array_init(& cmcf->prefix_variables, cf->pool, (ngx_uint_t )8, sizeof(ngx_http_variable_t ));
  }
#line 2574
  if (tmp___1 != 0L) {
#line 2578
    return ((ngx_int_t )-1);
  }
#line 2581
  cv = ngx_http_core_variables;
  {
#line 2581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2581
    if (! cv->name.len) {
#line 2581
      goto while_break;
    }
    {
#line 2582
    v = ngx_http_add_variable(cf, & cv->name, cv->flags);
    }
#line 2583
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2584
      return ((ngx_int_t )-1);
    }
#line 2587
    *v = *cv;
#line 2581
    cv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2590
  return ((ngx_int_t )0);
}
}
#line 2594 "/tmp/nginx-1.13.2/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_variables_init_vars(ngx_conf_t *cf ) 
{ 
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_hash_key_t *key ;
  ngx_hash_init_t hash ;
  ngx_http_variable_t *v ;
  ngx_http_variable_t *av ;
  ngx_http_variable_t *pv ;
  ngx_http_core_main_conf_t *cmcf ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 2606
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 2608
  v = (ngx_http_variable_t *)cmcf->variables.elts;
#line 2609
  pv = (ngx_http_variable_t *)cmcf->prefix_variables.elts;
#line 2610
  key = (ngx_hash_key_t *)(cmcf->variables_keys)->keys.elts;
#line 2612
  i = (ngx_uint_t )0;
  {
#line 2612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2612
    if (! (i < cmcf->variables.nelts)) {
#line 2612
      goto while_break;
    }
#line 2614
    n = (ngx_uint_t )0;
    {
#line 2614
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2614
      if (! (n < (cmcf->variables_keys)->keys.nelts)) {
#line 2614
        goto while_break___0;
      }
#line 2616
      av = (ngx_http_variable_t *)(key + n)->value;
#line 2618
      if ((v + i)->name.len == (key + n)->key.len) {
        {
#line 2618
        tmp = strncmp((char const   *)(v + i)->name.data, (char const   *)(key + n)->key.data,
                      (v + i)->name.len);
        }
#line 2618
        if (tmp == 0) {
#line 2622
          (v + i)->get_handler = av->get_handler;
#line 2623
          (v + i)->data = av->data;
#line 2625
          av->flags |= 4UL;
#line 2626
          (v + i)->flags = av->flags;
#line 2628
          av->index = i;
#line 2630
          if ((unsigned long )av->get_handler == (unsigned long )((void *)0)) {
#line 2633
            goto while_break___0;
          } else
#line 2630
          if (av->flags & 16UL) {
#line 2633
            goto while_break___0;
          }
#line 2636
          goto next;
        }
      }
#line 2614
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2640
    len = (size_t___0 )0;
#line 2641
    av = (ngx_http_variable_t *)((void *)0);
#line 2643
    n = (ngx_uint_t )0;
    {
#line 2643
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2643
      if (! (n < cmcf->prefix_variables.nelts)) {
#line 2643
        goto while_break___1;
      }
#line 2644
      if ((v + i)->name.len >= (pv + n)->name.len) {
#line 2644
        if ((v + i)->name.len > len) {
          {
#line 2644
          tmp___0 = strncmp((char const   *)(v + i)->name.data, (char const   *)(pv + n)->name.data,
                            (pv + n)->name.len);
          }
#line 2644
          if (tmp___0 == 0) {
#line 2648
            av = pv + n;
#line 2649
            len = (pv + n)->name.len;
          }
        }
      }
#line 2643
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2653
    if (av) {
#line 2654
      (v + i)->get_handler = av->get_handler;
#line 2655
      (v + i)->data = (uintptr_t )(& (v + i)->name);
#line 2656
      (v + i)->flags = av->flags;
#line 2658
      goto next;
    }
#line 2661
    if ((unsigned long )(v + i)->get_handler == (unsigned long )((void *)0)) {
#line 2662
      if ((cf->log)->log_level >= 1UL) {
        {
#line 2662
        ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "unknown \"%V\" variable",
                           & (v + i)->name);
        }
      }
#line 2665
      return ((ngx_int_t )-1);
    }
    next: 
#line 2669
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 2612
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2673
  n = (ngx_uint_t )0;
  {
#line 2673
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2673
    if (! (n < (cmcf->variables_keys)->keys.nelts)) {
#line 2673
      goto while_break___2;
    }
#line 2674
    av = (ngx_http_variable_t *)(key + n)->value;
#line 2676
    if (av->flags & 8UL) {
#line 2677
      (key + n)->key.data = (u_char *)((void *)0);
    }
#line 2673
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2682
  hash.hash = & cmcf->variables_hash;
#line 2683
  hash.key = & ngx_hash_key;
#line 2684
  hash.max_size = cmcf->variables_hash_max_size;
#line 2685
  hash.bucket_size = cmcf->variables_hash_bucket_size;
#line 2686
  hash.name = (char *)"variables_hash";
#line 2687
  hash.pool = cf->pool;
#line 2688
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2690
  tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)(cmcf->variables_keys)->keys.elts,
                          (cmcf->variables_keys)->keys.nelts);
  }
#line 2690
  if (tmp___1 != 0L) {
#line 2694
    return ((ngx_int_t )-1);
  }
#line 2697
  cmcf->variables_keys = (ngx_hash_keys_arrays_t *)((void *)0);
#line 2699
  return ((ngx_int_t )0);
}
}
#line 138 "src/core/ngx_file.h"
ssize_t ngx_write_chain_to_temp_file(ngx_temp_file_t *tf , ngx_chain_t *chain ) ;
#line 530 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_request_body_save_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 149 "src/http/ngx_http.h"
void ngx_http_discarded_request_body_handler(ngx_http_request_t *r ) ;
#line 173
ngx_int_t (*ngx_http_top_request_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r ) ;
#line 14
static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r ) ;
#line 15
static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r ) ;
#line 16
static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r ) ;
#line 17
static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r , ngx_buf_t *b ) ;
#line 19
static ngx_int_t ngx_http_test_expect(ngx_http_request_t *r ) ;
#line 21
static ngx_int_t ngx_http_request_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 23
static ngx_int_t ngx_http_request_body_length_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 25
static ngx_int_t ngx_http_request_body_chunked_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 29 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_read_client_request_body(ngx_http_request_t *r , void (*post_handler)(ngx_http_request_t *r ) ) 
{ 
  size_t___0 preread ;
  ssize_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 41
  ((r->main)->count) ++;
#line 43
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 44
    r->request_body_no_buffering = 0U;
#line 45
    (*post_handler)(r);
    }
#line 46
    return ((ngx_int_t )0);
  } else
#line 43
  if (r->request_body) {
    {
#line 44
    r->request_body_no_buffering = 0U;
#line 45
    (*post_handler)(r);
    }
#line 46
    return ((ngx_int_t )0);
  } else
#line 43
  if (r->discard_body) {
    {
#line 44
    r->request_body_no_buffering = 0U;
#line 45
    (*post_handler)(r);
    }
#line 46
    return ((ngx_int_t )0);
  }
  {
#line 49
  tmp = ngx_http_test_expect(r);
  }
#line 49
  if (tmp != 0L) {
#line 50
    rc = (ngx_int_t )500;
#line 51
    goto done;
  }
  {
#line 54
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t ));
#line 54
  rb = (ngx_http_request_body_t *)tmp___0;
  }
#line 55
  if ((unsigned long )rb == (unsigned long )((void *)0)) {
#line 56
    rc = (ngx_int_t )500;
#line 57
    goto done;
  }
#line 70
  rb->rest = (off_t )-1;
#line 71
  rb->post_handler = post_handler;
#line 73
  r->request_body = rb;
#line 75
  if (r->headers_in.content_length_n < 0L) {
#line 75
    if (! r->headers_in.chunked) {
      {
#line 76
      r->request_body_no_buffering = 0U;
#line 77
      (*post_handler)(r);
      }
#line 78
      return ((ngx_int_t )0);
    }
  }
#line 88
  preread = (size_t___0 )((r->header_in)->last - (r->header_in)->pos);
#line 90
  if (preread) {
    {
#line 97
    out.buf = r->header_in;
#line 98
    out.next = (ngx_chain_t *)((void *)0);
#line 100
    rc = ngx_http_request_body_filter(r, & out);
    }
#line 102
    if (rc != 0L) {
#line 103
      goto done;
    }
#line 106
    r->request_length = (off_t )((size_t___0 )r->request_length + (preread - (size_t___0 )((r->header_in)->last - (r->header_in)->pos)));
#line 108
    if (! r->headers_in.chunked) {
#line 108
      if (rb->rest > 0L) {
#line 108
        if (rb->rest <= (r->header_in)->end - (r->header_in)->last) {
          {
#line 114
          tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 114
          b = (ngx_buf_t *)tmp___1;
          }
#line 115
          if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 116
            rc = (ngx_int_t )500;
#line 117
            goto done;
          }
          {
#line 120
          b->temporary = 1U;
#line 121
          b->start = (r->header_in)->pos;
#line 122
          b->pos = (r->header_in)->pos;
#line 123
          b->last = (r->header_in)->last;
#line 124
          b->end = (r->header_in)->end;
#line 126
          rb->buf = b;
#line 128
          r->read_event_handler = & ngx_http_read_client_request_body_handler;
#line 129
          r->write_event_handler = & ngx_http_request_empty_handler;
#line 131
          rc = ngx_http_do_read_client_request_body(r);
          }
#line 132
          goto done;
        }
      }
    }
  } else {
    {
#line 138
    tmp___2 = ngx_http_request_body_filter(r, (ngx_chain_t *)((void *)0));
    }
#line 138
    if (tmp___2 != 0L) {
#line 139
      rc = (ngx_int_t )500;
#line 140
      goto done;
    }
  }
#line 144
  if (rb->rest == 0L) {
    {
#line 146
    r->request_body_no_buffering = 0U;
#line 147
    (*post_handler)(r);
    }
#line 148
    return ((ngx_int_t )0);
  }
#line 151
  if (rb->rest < 0L) {
#line 152
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 152
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "negative request body rest");
      }
    }
#line 154
    rc = (ngx_int_t )500;
#line 155
    goto done;
  }
#line 158
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 160
  size = (ssize_t )clcf->client_body_buffer_size;
#line 161
  size += size >> 2;
#line 165
  if (! r->headers_in.chunked) {
#line 165
    if (rb->rest < size) {
#line 166
      size = rb->rest;
#line 168
      if (r->request_body_in_single_buf) {
#line 169
        size = (ssize_t )((size_t___0 )size + preread);
      }
    } else {
#line 173
      size = (ssize_t )clcf->client_body_buffer_size;
    }
  } else {
#line 173
    size = (ssize_t )clcf->client_body_buffer_size;
  }
  {
#line 176
  rb->buf = ngx_create_temp_buf(r->pool, (size_t___0 )size);
  }
#line 177
  if ((unsigned long )rb->buf == (unsigned long )((void *)0)) {
#line 178
    rc = (ngx_int_t )500;
#line 179
    goto done;
  }
  {
#line 182
  r->read_event_handler = & ngx_http_read_client_request_body_handler;
#line 183
  r->write_event_handler = & ngx_http_request_empty_handler;
#line 185
  rc = ngx_http_do_read_client_request_body(r);
  }
  done: 
#line 189
  if (r->request_body_no_buffering) {
#line 189
    if (rc == 0L) {
#line 189
      goto _L;
    } else
#line 189
    if (rc == -2L) {
      _L: /* CIL Label */ 
#line 192
      if (rc == 0L) {
#line 193
        r->request_body_no_buffering = 0U;
      } else {
#line 197
        r->reading_body = 1U;
      }
      {
#line 200
      r->read_event_handler = & ngx_http_block_reading;
#line 201
      (*post_handler)(r);
      }
    }
  }
#line 204
  if (rc >= 300L) {
#line 205
    ((r->main)->count) --;
  }
#line 208
  return (rc);
}
}
#line 212 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_read_unbuffered_request_body(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;

  {
#line 229
  if (((r->connection)->read)->timedout) {
#line 230
    (r->connection)->timedout = 1U;
#line 231
    return ((ngx_int_t )408);
  }
  {
#line 234
  rc = ngx_http_do_read_client_request_body(r);
  }
#line 236
  if (rc == 0L) {
#line 237
    r->reading_body = 0U;
  }
#line 240
  return (rc);
}
}
#line 244 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;

  {
#line 249
  if (((r->connection)->read)->timedout) {
    {
#line 250
    (r->connection)->timedout = 1U;
#line 251
    ngx_http_finalize_request(r, (ngx_int_t )408);
    }
#line 252
    return;
  }
  {
#line 255
  rc = ngx_http_do_read_client_request_body(r);
  }
#line 257
  if (rc >= 300L) {
    {
#line 258
    ngx_http_finalize_request(r, rc);
    }
  }
#line 260
  return;
}
}
#line 263 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r ) 
{ 
  off_t rest ;
  size_t___0 size ;
  ssize_t n ;
  ngx_int_t rc ;
  ngx_chain_t out ;
  ngx_connection_t *c ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 275
  c = r->connection;
#line 276
  rb = r->request_body;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 283
      if ((unsigned long )(rb->buf)->last == (unsigned long )(rb->buf)->end) {
#line 285
        if ((unsigned long )(rb->buf)->pos != (unsigned long )(rb->buf)->last) {
          {
#line 289
          out.buf = rb->buf;
#line 290
          out.next = (ngx_chain_t *)((void *)0);
#line 292
          rc = ngx_http_request_body_filter(r, & out);
          }
#line 294
          if (rc != 0L) {
#line 295
            return (rc);
          }
        } else {
          {
#line 302
          rc = ngx_http_request_body_filter(r, (ngx_chain_t *)((void *)0));
          }
#line 304
          if (rc != 0L) {
#line 305
            return (rc);
          }
        }
#line 309
        if ((unsigned long )rb->busy != (unsigned long )((void *)0)) {
#line 310
          if (r->request_body_no_buffering) {
#line 311
            if ((c->read)->timer_set) {
              {
#line 312
              ngx_event_del_timer(c->read);
              }
            }
            {
#line 315
            tmp = ngx_handle_read_event(c->read, (ngx_uint_t )0);
            }
#line 315
            if (tmp != 0L) {
#line 316
              return ((ngx_int_t )500);
            }
#line 319
            return ((ngx_int_t )-2);
          }
#line 322
          return ((ngx_int_t )500);
        }
#line 325
        (rb->buf)->pos = (rb->buf)->start;
#line 326
        (rb->buf)->last = (rb->buf)->start;
      }
#line 329
      size = (size_t___0 )((rb->buf)->end - (rb->buf)->last);
#line 330
      rest = rb->rest - ((rb->buf)->last - (rb->buf)->pos);
#line 332
      if ((off_t )size > rest) {
#line 333
        size = (size_t___0 )rest;
      }
      {
#line 336
      n = (*(c->recv))(c, (rb->buf)->last, size);
      }
#line 341
      if (n == -2L) {
#line 342
        goto while_break___0;
      }
#line 345
      if (n == 0L) {
#line 346
        if ((c->log)->log_level >= 7UL) {
          {
#line 346
          ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client prematurely closed connection");
          }
        }
      }
#line 350
      if (n == 0L) {
#line 351
        c->error = 1U;
#line 352
        return ((ngx_int_t )400);
      } else
#line 350
      if (n == -1L) {
#line 351
        c->error = 1U;
#line 352
        return ((ngx_int_t )400);
      }
#line 355
      (rb->buf)->last += n;
#line 356
      r->request_length += n;
#line 358
      if (n == rest) {
        {
#line 361
        out.buf = rb->buf;
#line 362
        out.next = (ngx_chain_t *)((void *)0);
#line 364
        rc = ngx_http_request_body_filter(r, & out);
        }
#line 366
        if (rc != 0L) {
#line 367
          return (rc);
        }
      }
#line 371
      if (rb->rest == 0L) {
#line 372
        goto while_break___0;
      }
#line 375
      if ((unsigned long )(rb->buf)->last < (unsigned long )(rb->buf)->end) {
#line 376
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 383
    if (rb->rest == 0L) {
#line 384
      goto while_break;
    }
#line 387
    if (! (c->read)->ready) {
#line 389
      if (r->request_body_no_buffering) {
#line 389
        if ((unsigned long )(rb->buf)->pos != (unsigned long )(rb->buf)->last) {
          {
#line 394
          out.buf = rb->buf;
#line 395
          out.next = (ngx_chain_t *)((void *)0);
#line 397
          rc = ngx_http_request_body_filter(r, & out);
          }
#line 399
          if (rc != 0L) {
#line 400
            return (rc);
          }
        }
      }
      {
#line 404
      clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 405
      ngx_event_add_timer(c->read, clcf->client_body_timeout);
#line 407
      tmp___0 = ngx_handle_read_event(c->read, (ngx_uint_t )0);
      }
#line 407
      if (tmp___0 != 0L) {
#line 408
        return ((ngx_int_t )500);
      }
#line 411
      return ((ngx_int_t )-2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  if ((c->read)->timer_set) {
    {
#line 416
    ngx_event_del_timer(c->read);
    }
  }
#line 419
  if (! r->request_body_no_buffering) {
    {
#line 420
    r->read_event_handler = & ngx_http_block_reading;
#line 421
    (*(rb->post_handler))(r);
    }
  }
#line 424
  return ((ngx_int_t )0);
}
}
#line 428 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r ) 
{ 
  ssize_t n ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_temp_file_t *tf ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 437
  rb = r->request_body;
#line 442
  if ((unsigned long )rb->temp_file == (unsigned long )((void *)0)) {
    {
#line 443
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t ));
#line 443
    tf = (ngx_temp_file_t *)tmp;
    }
#line 444
    if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 445
      return ((ngx_int_t )-1);
    }
#line 448
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 450
    tf->file.fd = -1;
#line 451
    tf->file.log = (r->connection)->log;
#line 452
    tf->path = clcf->client_body_temp_path;
#line 453
    tf->pool = r->pool;
#line 454
    tf->warn = (char *)"a client request body is buffered to a temporary file";
#line 455
    tf->log_level = r->request_body_file_log_level;
#line 456
    tf->persistent = r->request_body_in_persistent_file;
#line 457
    tf->clean = r->request_body_in_clean_file;
#line 459
    if (r->request_body_file_group_access) {
#line 460
      tf->access = (ngx_uint_t )432;
    }
#line 463
    rb->temp_file = tf;
#line 465
    if ((unsigned long )rb->bufs == (unsigned long )((void *)0)) {
      {
#line 468
      tmp___0 = ngx_create_temp_file(& tf->file, tf->path, tf->pool, (ngx_uint_t )tf->persistent,
                                     (ngx_uint_t )tf->clean, tf->access);
      }
#line 468
      if (tmp___0 != 0L) {
#line 472
        return ((ngx_int_t )-1);
      }
#line 475
      return ((ngx_int_t )0);
    }
  }
#line 479
  if ((unsigned long )rb->bufs == (unsigned long )((void *)0)) {
#line 480
    return ((ngx_int_t )0);
  }
  {
#line 483
  n = ngx_write_chain_to_temp_file(rb->temp_file, rb->bufs);
  }
#line 487
  if (n == -1L) {
#line 488
    return ((ngx_int_t )-1);
  }
#line 491
  (rb->temp_file)->offset += n;
#line 495
  cl = rb->bufs;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! cl) {
#line 495
      goto while_break;
    }
#line 497
    (cl->buf)->pos = (cl->buf)->last;
#line 499
    ln = cl;
#line 500
    cl = cl->next;
#line 501
    ln->next = (r->pool)->chain;
#line 501
    (r->pool)->chain = ln;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  rb->bufs = (ngx_chain_t *)((void *)0);
#line 506
  return ((ngx_int_t )0);
}
}
#line 510 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_discard_request_body(ngx_http_request_t *r ) 
{ 
  ssize_t size ;
  ngx_int_t rc ;
  ngx_event_t *rev ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 517
  if ((unsigned long )r != (unsigned long )r->main) {
#line 518
    return ((ngx_int_t )0);
  } else
#line 517
  if (r->discard_body) {
#line 518
    return ((ngx_int_t )0);
  } else
#line 517
  if (r->request_body) {
#line 518
    return ((ngx_int_t )0);
  }
  {
#line 528
  tmp = ngx_http_test_expect(r);
  }
#line 528
  if (tmp != 0L) {
#line 529
    return ((ngx_int_t )500);
  }
#line 532
  rev = (r->connection)->read;
#line 536
  if (rev->timer_set) {
    {
#line 537
    ngx_event_del_timer(rev);
    }
  }
#line 540
  if (r->headers_in.content_length_n <= 0L) {
#line 540
    if (! r->headers_in.chunked) {
#line 541
      return ((ngx_int_t )0);
    }
  }
#line 544
  size = (r->header_in)->last - (r->header_in)->pos;
#line 546
  if (size) {
#line 546
    goto _L;
  } else
#line 546
  if (r->headers_in.chunked) {
    _L: /* CIL Label */ 
    {
#line 547
    rc = ngx_http_discard_request_body_filter(r, r->header_in);
    }
#line 549
    if (rc != 0L) {
#line 550
      return (rc);
    }
#line 553
    if (r->headers_in.content_length_n == 0L) {
#line 554
      return ((ngx_int_t )0);
    }
  }
  {
#line 558
  rc = ngx_http_read_discarded_request_body(r);
  }
#line 560
  if (rc == 0L) {
#line 561
    r->lingering_close = 0U;
#line 562
    return ((ngx_int_t )0);
  }
#line 565
  if (rc >= 300L) {
#line 566
    return (rc);
  }
  {
#line 571
  r->read_event_handler = & ngx_http_discarded_request_body_handler;
#line 573
  tmp___0 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 573
  if (tmp___0 != 0L) {
#line 574
    return ((ngx_int_t )500);
  }
#line 577
  (r->count) ++;
#line 578
  r->discard_body = 1U;
#line 580
  return ((ngx_int_t )0);
}
}
#line 584 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
void ngx_http_discarded_request_body_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_msec_t timer ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;

  {
#line 593
  c = r->connection;
#line 594
  rev = c->read;
#line 596
  if (rev->timedout) {
    {
#line 597
    c->timedout = 1U;
#line 598
    c->error = 1U;
#line 599
    ngx_http_finalize_request(r, (ngx_int_t )-1);
    }
#line 600
    return;
  }
#line 603
  if (r->lingering_time) {
#line 604
    timer = (ngx_msec_t )r->lingering_time - (ngx_msec_t )ngx_cached_time->sec;
#line 606
    if ((ngx_msec_int_t )timer <= 0L) {
      {
#line 607
      r->discard_body = 0U;
#line 608
      r->lingering_close = 0U;
#line 609
      ngx_http_finalize_request(r, (ngx_int_t )-1);
      }
#line 610
      return;
    }
  } else {
#line 614
    timer = (ngx_msec_t )0;
  }
  {
#line 617
  rc = ngx_http_read_discarded_request_body(r);
  }
#line 619
  if (rc == 0L) {
    {
#line 620
    r->discard_body = 0U;
#line 621
    r->lingering_close = 0U;
#line 622
    ngx_http_finalize_request(r, (ngx_int_t )-4);
    }
#line 623
    return;
  }
#line 626
  if (rc >= 300L) {
    {
#line 627
    c->error = 1U;
#line 628
    ngx_http_finalize_request(r, (ngx_int_t )-1);
    }
#line 629
    return;
  }
  {
#line 634
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 634
  if (tmp != 0L) {
    {
#line 635
    c->error = 1U;
#line 636
    ngx_http_finalize_request(r, (ngx_int_t )-1);
    }
#line 637
    return;
  }
#line 640
  if (timer) {
#line 642
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 644
    timer *= 1000UL;
#line 646
    if (timer > clcf->lingering_timeout) {
#line 647
      timer = clcf->lingering_timeout;
    }
    {
#line 650
    ngx_event_add_timer(rev, timer);
    }
  }
#line 652
  return;
}
}
#line 655 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r ) 
{ 
  size_t___0 size ;
  ssize_t n ;
  ngx_int_t rc ;
  ngx_buf_t b ;
  u_char buffer___0[4096] ;
  off_t tmp ;

  {
  {
#line 667
  memset((void *)(& b), 0, sizeof(ngx_buf_t ));
#line 669
  b.temporary = 1U;
  }
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (r->headers_in.content_length_n == 0L) {
#line 673
      r->read_event_handler = & ngx_http_block_reading;
#line 674
      return ((ngx_int_t )0);
    }
#line 677
    if (! ((r->connection)->read)->ready) {
#line 678
      return ((ngx_int_t )-2);
    }
#line 681
    if (r->headers_in.content_length_n > 4096L) {
#line 681
      tmp = (off_t )4096;
    } else {
#line 681
      tmp = r->headers_in.content_length_n;
    }
    {
#line 681
    size = (size_t___0 )tmp;
#line 684
    n = (*((r->connection)->recv))(r->connection, buffer___0, size);
    }
#line 686
    if (n == -1L) {
#line 687
      (r->connection)->error = 1U;
#line 688
      return ((ngx_int_t )0);
    }
#line 691
    if (n == -2L) {
#line 692
      return ((ngx_int_t )-2);
    }
#line 695
    if (n == 0L) {
#line 696
      return ((ngx_int_t )0);
    }
    {
#line 699
    b.pos = buffer___0;
#line 700
    b.last = buffer___0 + n;
#line 702
    rc = ngx_http_discard_request_body_filter(r, & b);
    }
#line 704
    if (rc != 0L) {
#line 705
      return (rc);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 711 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r , ngx_buf_t *b ) 
{ 
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_http_request_body_t *rb ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 718
  if (r->headers_in.chunked) {
#line 720
    rb = r->request_body;
#line 722
    if ((unsigned long )rb == (unsigned long )((void *)0)) {
      {
#line 724
      tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t ));
#line 724
      rb = (ngx_http_request_body_t *)tmp;
      }
#line 725
      if ((unsigned long )rb == (unsigned long )((void *)0)) {
#line 726
        return ((ngx_int_t )500);
      }
      {
#line 729
      tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_t ));
#line 729
      rb->chunked = (ngx_http_chunked_t *)tmp___0;
      }
#line 730
      if ((unsigned long )rb->chunked == (unsigned long )((void *)0)) {
#line 731
        return ((ngx_int_t )500);
      }
#line 734
      r->request_body = rb;
    }
    {
#line 737
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 739
      rc = ngx_http_parse_chunked(r, b, rb->chunked);
      }
#line 741
      if (rc == 0L) {
#line 745
        size = (size_t___0 )(b->last - b->pos);
#line 747
        if ((off_t )size > (rb->chunked)->size) {
#line 748
          b->pos += (size_t___0 )(rb->chunked)->size;
#line 749
          (rb->chunked)->size = (off_t )0;
        } else {
#line 752
          (rb->chunked)->size = (off_t )((size_t___0 )(rb->chunked)->size - size);
#line 753
          b->pos = b->last;
        }
#line 756
        goto __Cont;
      }
#line 759
      if (rc == -4L) {
#line 763
        r->headers_in.content_length_n = (off_t )0;
#line 764
        goto while_break;
      }
#line 767
      if (rc == -2L) {
#line 771
        r->headers_in.content_length_n = (rb->chunked)->length;
#line 772
        goto while_break;
      }
#line 777
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 777
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent invalid chunked body");
        }
      }
#line 780
      return ((ngx_int_t )400);
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 784
    size = (size_t___0 )(b->last - b->pos);
#line 786
    if ((off_t )size > r->headers_in.content_length_n) {
#line 787
      b->pos += (size_t___0 )r->headers_in.content_length_n;
#line 788
      r->headers_in.content_length_n = (off_t )0;
    } else {
#line 791
      b->pos = b->last;
#line 792
      r->headers_in.content_length_n = (off_t )((size_t___0 )r->headers_in.content_length_n - size);
    }
  }
#line 796
  return ((ngx_int_t )0);
}
}
#line 800 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_test_expect(ngx_http_request_t *r ) 
{ 
  ngx_int_t n ;
  ngx_str_t *expect ;
  ngx_int_t tmp ;

  {
#line 806
  if (r->expect_tested) {
#line 814
    return ((ngx_int_t )0);
  } else
#line 806
  if ((unsigned long )r->headers_in.expect == (unsigned long )((void *)0)) {
#line 814
    return ((ngx_int_t )0);
  } else
#line 806
  if (r->http_version < 1001UL) {
#line 814
    return ((ngx_int_t )0);
  }
#line 817
  r->expect_tested = 1U;
#line 819
  expect = & (r->headers_in.expect)->value;
#line 821
  if (expect->len != sizeof("100-continue") - 1UL) {
#line 826
    return ((ngx_int_t )0);
  } else {
    {
#line 821
    tmp = ngx_strncasecmp(expect->data, (u_char *)"100-continue", sizeof("100-continue") - 1UL);
    }
#line 821
    if (tmp != 0L) {
#line 826
      return ((ngx_int_t )0);
    }
  }
  {
#line 832
  n = (*((r->connection)->send))(r->connection, (u_char *)"HTTP/1.1 100 Continue\r\n\r\n",
                                 sizeof("HTTP/1.1 100 Continue\r\n\r\n") - 1UL);
  }
#line 836
  if ((unsigned long )n == sizeof("HTTP/1.1 100 Continue\r\n\r\n") - 1UL) {
#line 837
    return ((ngx_int_t )0);
  }
#line 842
  (r->connection)->error = 1U;
#line 844
  return ((ngx_int_t )-1);
}
}
#line 848 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_request_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 851
  if (r->headers_in.chunked) {
    {
#line 852
    tmp = ngx_http_request_body_chunked_filter(r, in);
    }
#line 852
    return (tmp);
  } else {
    {
#line 855
    tmp___0 = ngx_http_request_body_length_filter(r, in);
    }
#line 855
    return (tmp___0);
  }
}
}
#line 860 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_request_body_length_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_http_request_body_t *rb ;

  {
#line 869
  rb = r->request_body;
#line 871
  if (rb->rest == -1L) {
#line 875
    rb->rest = r->headers_in.content_length_n;
  }
#line 878
  out = (ngx_chain_t *)((void *)0);
#line 879
  ll = & out;
#line 881
  cl = in;
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 881
    if (! cl) {
#line 881
      goto while_break;
    }
#line 883
    if (rb->rest == 0L) {
#line 884
      goto while_break;
    }
    {
#line 887
    tl = ngx_chain_get_free_buf(r->pool, & rb->free);
    }
#line 888
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 889
      return ((ngx_int_t )500);
    }
    {
#line 892
    b = tl->buf;
#line 894
    memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 896
    b->temporary = 1U;
#line 897
    b->tag = (ngx_buf_tag_t )(& ngx_http_read_client_request_body);
#line 898
    b->start = (cl->buf)->pos;
#line 899
    b->pos = (cl->buf)->pos;
#line 900
    b->last = (cl->buf)->last;
#line 901
    b->end = (cl->buf)->end;
#line 902
    b->flush = r->request_body_no_buffering;
#line 904
    size = (size_t___0 )((cl->buf)->last - (cl->buf)->pos);
    }
#line 906
    if ((off_t )size < rb->rest) {
#line 907
      (cl->buf)->pos = (cl->buf)->last;
#line 908
      rb->rest = (off_t )((size_t___0 )rb->rest - size);
    } else {
#line 911
      (cl->buf)->pos += (size_t___0 )rb->rest;
#line 912
      rb->rest = (off_t )0;
#line 913
      b->last = (cl->buf)->pos;
#line 914
      b->last_buf = 1U;
    }
#line 917
    *ll = tl;
#line 918
    ll = & tl->next;
#line 881
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 921
  rc = (*ngx_http_top_request_body_filter)(r, out);
#line 923
  ngx_chain_update_chains(r->pool, & rb->free, & rb->busy, & out, (ngx_buf_tag_t )(& ngx_http_read_client_request_body));
  }
#line 926
  return (rc);
}
}
#line 930 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_request_body_chunked_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  size_t___0 size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *out ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;

  {
#line 940
  rb = r->request_body;
#line 942
  if (rb->rest == -1L) {
    {
#line 947
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_t ));
#line 947
    rb->chunked = (ngx_http_chunked_t *)tmp;
    }
#line 948
    if ((unsigned long )rb->chunked == (unsigned long )((void *)0)) {
#line 949
      return ((ngx_int_t )500);
    }
#line 952
    r->headers_in.content_length_n = (off_t )0;
#line 953
    rb->rest = (off_t )3;
  }
#line 956
  out = (ngx_chain_t *)((void *)0);
#line 957
  ll = & out;
#line 959
  cl = in;
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (! cl) {
#line 959
      goto while_break;
    }
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 972
      rc = ngx_http_parse_chunked(r, cl->buf, rb->chunked);
      }
#line 974
      if (rc == 0L) {
#line 978
        clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 980
        if (clcf->client_max_body_size) {
#line 980
          if (clcf->client_max_body_size - r->headers_in.content_length_n < (rb->chunked)->size) {
#line 984
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 984
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client intended to send too large chunked body: %O+%O bytes",
                                 r->headers_in.content_length_n, (rb->chunked)->size);
              }
            }
#line 990
            r->lingering_close = 1U;
#line 992
            return ((ngx_int_t )413);
          }
        }
        {
#line 995
        tl = ngx_chain_get_free_buf(r->pool, & rb->free);
        }
#line 996
        if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 997
          return ((ngx_int_t )500);
        }
        {
#line 1000
        b = tl->buf;
#line 1002
        memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 1004
        b->temporary = 1U;
#line 1005
        b->tag = (ngx_buf_tag_t )(& ngx_http_read_client_request_body);
#line 1006
        b->start = (cl->buf)->pos;
#line 1007
        b->pos = (cl->buf)->pos;
#line 1008
        b->last = (cl->buf)->last;
#line 1009
        b->end = (cl->buf)->end;
#line 1010
        b->flush = r->request_body_no_buffering;
#line 1012
        *ll = tl;
#line 1013
        ll = & tl->next;
#line 1015
        size = (size_t___0 )((cl->buf)->last - (cl->buf)->pos);
        }
#line 1017
        if ((off_t )size > (rb->chunked)->size) {
#line 1018
          (cl->buf)->pos += (size_t___0 )(rb->chunked)->size;
#line 1019
          r->headers_in.content_length_n += (rb->chunked)->size;
#line 1020
          (rb->chunked)->size = (off_t )0;
        } else {
#line 1023
          (rb->chunked)->size = (off_t )((size_t___0 )(rb->chunked)->size - size);
#line 1024
          r->headers_in.content_length_n = (off_t )((size_t___0 )r->headers_in.content_length_n + size);
#line 1025
          (cl->buf)->pos = (cl->buf)->last;
        }
#line 1028
        b->last = (cl->buf)->pos;
#line 1030
        goto __Cont;
      }
#line 1033
      if (rc == -4L) {
        {
#line 1037
        rb->rest = (off_t )0;
#line 1039
        tl = ngx_chain_get_free_buf(r->pool, & rb->free);
        }
#line 1040
        if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1041
          return ((ngx_int_t )500);
        }
        {
#line 1044
        b = tl->buf;
#line 1046
        memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 1048
        b->last_buf = 1U;
#line 1050
        *ll = tl;
#line 1051
        ll = & tl->next;
        }
#line 1053
        goto while_break___0;
      }
#line 1056
      if (rc == -2L) {
#line 1060
        rb->rest = (rb->chunked)->length;
#line 1062
        goto while_break___0;
      }
#line 1067
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1067
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent invalid chunked body");
        }
      }
#line 1070
      return ((ngx_int_t )400);
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 959
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1074
  rc = (*ngx_http_top_request_body_filter)(r, out);
#line 1076
  ngx_chain_update_chains(r->pool, & rb->free, & rb->busy, & out, (ngx_buf_tag_t )(& ngx_http_read_client_request_body));
  }
#line 1079
  return (rc);
}
}
#line 1083 "/tmp/nginx-1.13.2/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_request_body_save_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_request_body_t *rb ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 1090
  rb = r->request_body;
#line 1122
  tmp = ngx_chain_add_copy(r->pool, & rb->bufs, in);
  }
#line 1122
  if (tmp != 0L) {
#line 1123
    return ((ngx_int_t )500);
  }
#line 1126
  if (r->request_body_no_buffering) {
#line 1127
    return ((ngx_int_t )0);
  }
#line 1130
  if (rb->rest > 0L) {
#line 1132
    if (rb->buf) {
#line 1132
      if ((unsigned long )(rb->buf)->last == (unsigned long )(rb->buf)->end) {
        {
#line 1132
        tmp___0 = ngx_http_write_request_body(r);
        }
#line 1132
        if (tmp___0 != 0L) {
#line 1135
          return ((ngx_int_t )500);
        }
      }
    }
#line 1138
    return ((ngx_int_t )0);
  }
#line 1143
  if (rb->temp_file) {
#line 1143
    goto _L;
  } else
#line 1143
  if (r->request_body_in_file_only) {
    _L: /* CIL Label */ 
    {
#line 1145
    tmp___1 = ngx_http_write_request_body(r);
    }
#line 1145
    if (tmp___1 != 0L) {
#line 1146
      return ((ngx_int_t )500);
    }
#line 1149
    if ((rb->temp_file)->file.offset != 0L) {
      {
#line 1151
      cl = ngx_chain_get_free_buf(r->pool, & rb->free);
      }
#line 1152
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1153
        return ((ngx_int_t )500);
      }
      {
#line 1156
      b = cl->buf;
#line 1158
      memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 1160
      b->in_file = 1U;
#line 1161
      b->file_last = (rb->temp_file)->file.offset;
#line 1162
      b->file = & (rb->temp_file)->file;
#line 1164
      rb->bufs = cl;
      }
    }
  }
#line 1168
  return ((ngx_int_t )0);
}
}
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 144 "src/os/unix/ngx_files.h"
__inline static ssize_t ngx_write_fd(ngx_fd_t fd , void *buf , size_t___0 n ) 
{ 
  ssize_t tmp ;

  {
  {
#line 147
  tmp = write(fd, (void const   *)buf, n);
  }
#line 147
  return (tmp);
}
}
#line 275 "src/core/ngx_conf_file.h"
ngx_open_file_t *ngx_conf_open_file(ngx_cycle_t *cycle , ngx_str_t *name ) ;
#line 123 "src/core/ngx_open_file_cache.h"
ngx_open_file_cache_t *ngx_open_file_cache_init(ngx_pool_t *pool , ngx_uint_t max ,
                                                time_t inactive ) ;
#line 24 "src/core/ngx_syslog.h"
char *ngx_syslog_process_conf(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) ;
#line 25
u_char *ngx_syslog_add_header(ngx_syslog_peer_t *peer , u_char *buf ) ;
#line 28
ssize_t ngx_syslog_send(ngx_syslog_peer_t *peer , u_char *buf , size_t___0 len ) ;
#line 93 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_write(ngx_http_request_t *r , ngx_http_log_t *log , u_char *buf ,
                               size_t___0 len ) ;
#line 95
static ssize_t ngx_http_log_script_write(ngx_http_request_t *r , ngx_http_log_script_t *script ,
                                         u_char **name , u_char *buf , size_t___0 len ) ;
#line 99
static ssize_t ngx_http_log_gzip(ngx_fd_t fd , u_char *buf , size_t___0 len , ngx_int_t level ,
                                 ngx_log_t *log ) ;
#line 102
static void *ngx_http_log_gzip_alloc(void *opaque , u_int items , u_int size ) ;
#line 103
static void ngx_http_log_gzip_free(void *opaque , void *address ) ;
#line 106
static void ngx_http_log_flush(ngx_open_file_t *file , ngx_log_t *log ) ;
#line 107
static void ngx_http_log_flush_handler(ngx_event_t *ev ) ;
#line 109
static u_char *ngx_http_log_pipe(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 111
static u_char *ngx_http_log_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 113
static u_char *ngx_http_log_iso8601(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 115
static u_char *ngx_http_log_msec(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 117
static u_char *ngx_http_log_request_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 119
static u_char *ngx_http_log_status(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 121
static u_char *ngx_http_log_bytes_sent(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 123
static u_char *ngx_http_log_body_bytes_sent(ngx_http_request_t *r , u_char *buf ,
                                            ngx_http_log_op_t *op ) ;
#line 125
static u_char *ngx_http_log_request_length(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 128
static ngx_int_t ngx_http_log_variable_compile(ngx_conf_t *cf , ngx_http_log_op_t *op ,
                                               ngx_str_t *value , ngx_uint_t json ) ;
#line 130
static size_t___0 ngx_http_log_variable_getlen(ngx_http_request_t *r , uintptr_t data ) ;
#line 132
static u_char *ngx_http_log_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 134
static uintptr_t ngx_http_log_escape(u_char *dst , u_char *src , size_t___0 size ) ;
#line 135
static size_t___0 ngx_http_log_json_variable_getlen(ngx_http_request_t *r , uintptr_t data ) ;
#line 137
static u_char *ngx_http_log_json_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 141
static void *ngx_http_log_create_main_conf(ngx_conf_t *cf ) ;
#line 142
static void *ngx_http_log_create_loc_conf(ngx_conf_t *cf ) ;
#line 143
static char *ngx_http_log_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 145
static char *ngx_http_log_set_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 147
static char *ngx_http_log_set_format(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 149
static char *ngx_http_log_compile_format(ngx_conf_t *cf , ngx_array_t *flushes , ngx_array_t *ops ,
                                         ngx_array_t *args___0 , ngx_uint_t s ) ;
#line 151
static char *ngx_http_log_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 153
static ngx_int_t ngx_http_log_init(ngx_conf_t *cf ) ;
#line 156 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_command_t ngx_http_log_commands[4]  = {      {{sizeof("log_format") - 1UL, (u_char *)"log_format"}, (ngx_uint_t )33558528,
      & ngx_http_log_set_format, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("access_log") - 1UL, (u_char *)"access_log"}, (ngx_uint_t )3456108544U,
      & ngx_http_log_set_log, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("open_log_file_cache") - 1UL, (u_char *)"open_log_file_cache"}, (ngx_uint_t )234881054,
      & ngx_http_log_open_file_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 184 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_http_module_t ngx_http_log_module_ctx  = 
#line 184
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_log_init, & ngx_http_log_create_main_conf,
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_log_create_loc_conf,
    & ngx_http_log_merge_loc_conf};
#line 199 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
ngx_module_t ngx_http_log_module  = 
#line 199
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_log_module_ctx),
    ngx_http_log_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 215 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_str_t ngx_http_access_log  =    {sizeof("logs/access.log") - 1UL, (u_char *)"logs/access.log"};
#line 218 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_str_t ngx_http_combined_fmt  =    {sizeof("$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\"") - 1UL,
    (u_char *)"$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\""};
#line 224 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_http_log_var_t ngx_http_log_vars[10]  = 
#line 224
  {      {{sizeof("pipe") - 1UL, (u_char *)"pipe"}, (size_t___0 )1, & ngx_http_log_pipe}, 
        {{sizeof("time_local") - 1UL,
       (u_char *)"time_local"}, sizeof("28/Sep/1970:12:00:00 +0600") - 1UL, & ngx_http_log_time}, 
        {{sizeof("time_iso8601") - 1UL,
       (u_char *)"time_iso8601"}, sizeof("1970-09-28T12:00:00+06:00") - 1UL, & ngx_http_log_iso8601}, 
        {{sizeof("msec") - 1UL,
       (u_char *)"msec"}, (sizeof("-9223372036854775808") - 1UL) + 4UL, & ngx_http_log_msec}, 
        {{sizeof("request_time") - 1UL,
       (u_char *)"request_time"}, (sizeof("-9223372036854775808") - 1UL) + 4UL, & ngx_http_log_request_time}, 
        {{sizeof("status") - 1UL,
       (u_char *)"status"}, sizeof("-9223372036854775808") - 1UL, & ngx_http_log_status}, 
        {{sizeof("bytes_sent") - 1UL,
       (u_char *)"bytes_sent"}, sizeof("-9223372036854775808") - 1UL, & ngx_http_log_bytes_sent}, 
        {{sizeof("body_bytes_sent") - 1UL,
       (u_char *)"body_bytes_sent"}, sizeof("-9223372036854775808") - 1UL, & ngx_http_log_body_bytes_sent}, 
        {{sizeof("request_length") - 1UL,
       (u_char *)"request_length"}, sizeof("-9223372036854775808") - 1UL, & ngx_http_log_request_length}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (size_t___0 )0, (u_char *(*)(ngx_http_request_t *r ,
                                                            u_char *buf , ngx_http_log_op_t *op ))((void *)0)}};
#line 244 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_int_t ngx_http_log_handler(ngx_http_request_t *r ) 
{ 
  u_char *line ;
  u_char *p ;
  size_t___0 len ;
  size_t___0 size ;
  ssize_t n ;
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_uint_t l ;
  ngx_http_log_t *log ;
  ngx_http_log_op_t *op ;
  ngx_http_log_buf_t *buffer___0 ;
  ngx_http_log_loc_conf_t *lcf ;
  ngx_int_t tmp ;
  size_t___0 tmp___0 ;
  u_char *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;

  {
#line 260
  lcf = (ngx_http_log_loc_conf_t *)*(r->loc_conf + ngx_http_log_module.ctx_index);
#line 262
  if (lcf->off) {
#line 263
    return ((ngx_int_t )0);
  }
#line 266
  log = (ngx_http_log_t *)(lcf->logs)->elts;
#line 267
  l = (ngx_uint_t )0;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (l < (lcf->logs)->nelts)) {
#line 267
      goto while_break;
    }
#line 269
    if ((log + l)->filter) {
      {
#line 270
      tmp = ngx_http_complex_value(r, (log + l)->filter, & val);
      }
#line 270
      if (tmp != 0L) {
#line 271
        return ((ngx_int_t )-1);
      }
#line 274
      if (val.len == 0UL) {
#line 275
        goto __Cont;
      } else
#line 274
      if (val.len == 1UL) {
#line 274
        if ((int )*(val.data + 0) == 48) {
#line 275
          goto __Cont;
        }
      }
    }
#line 279
    if (ngx_cached_time->sec == (time_t volatile   )(log + l)->disk_full_time) {
#line 287
      goto __Cont;
    }
    {
#line 290
    ngx_http_script_flush_no_cacheable_variables(r, ((log + l)->format)->flushes);
#line 292
    len = (size_t___0 )0;
#line 293
    op = (ngx_http_log_op_t *)(((log + l)->format)->ops)->elts;
#line 294
    i = (ngx_uint_t )0;
    }
    {
#line 294
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 294
      if (! (i < (((log + l)->format)->ops)->nelts)) {
#line 294
        goto while_break___0;
      }
#line 295
      if ((op + i)->len == 0UL) {
        {
#line 296
        tmp___0 = (*((op + i)->getlen))(r, (op + i)->data);
#line 296
        len += tmp___0;
        }
      } else {
#line 299
        len += (op + i)->len;
      }
#line 294
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 303
    if ((log + l)->syslog_peer) {
#line 306
      len += ((((sizeof("<255>Jan 01 00:00:00 ") - 1UL) + (unsigned long )ngx_cycle->hostname.len) + 1UL) + ((log + l)->syslog_peer)->tag.len) + 2UL;
#line 310
      goto alloc_line;
    }
#line 313
    len ++;
#line 315
    if ((log + l)->file) {
#line 315
      buffer___0 = (ngx_http_log_buf_t *)((log + l)->file)->data;
    } else {
#line 315
      buffer___0 = (ngx_http_log_buf_t *)((void *)0);
    }
#line 317
    if (buffer___0) {
#line 319
      if (len > (size_t___0 )(buffer___0->last - buffer___0->pos)) {
        {
#line 321
        ngx_http_log_write(r, log + l, buffer___0->start, (size_t___0 )(buffer___0->pos - buffer___0->start));
#line 324
        buffer___0->pos = buffer___0->start;
        }
      }
#line 327
      if (len <= (size_t___0 )(buffer___0->last - buffer___0->pos)) {
#line 329
        p = buffer___0->pos;
#line 331
        if (buffer___0->event) {
#line 331
          if ((unsigned long )p == (unsigned long )buffer___0->start) {
            {
#line 332
            ngx_event_add_timer(buffer___0->event, buffer___0->flush);
            }
          }
        }
#line 335
        i = (ngx_uint_t )0;
        {
#line 335
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 335
          if (! (i < (((log + l)->format)->ops)->nelts)) {
#line 335
            goto while_break___1;
          }
          {
#line 336
          p = (*((op + i)->run))(r, p, op + i);
#line 335
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 339
        tmp___1 = p;
#line 339
        p ++;
#line 339
        *tmp___1 = (u_char )'\n';
#line 341
        buffer___0->pos = p;
#line 343
        goto __Cont;
      }
#line 346
      if (buffer___0->event) {
#line 346
        if ((buffer___0->event)->timer_set) {
          {
#line 347
          ngx_event_del_timer(buffer___0->event);
          }
        }
      }
    }
    alloc_line: 
    {
#line 353
    tmp___2 = ngx_pnalloc(r->pool, len);
#line 353
    line = (u_char *)tmp___2;
    }
#line 354
    if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 355
      return ((ngx_int_t )-1);
    }
#line 358
    p = line;
#line 360
    if ((log + l)->syslog_peer) {
      {
#line 361
      p = ngx_syslog_add_header((log + l)->syslog_peer, line);
      }
    }
#line 364
    i = (ngx_uint_t )0;
    {
#line 364
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 364
      if (! (i < (((log + l)->format)->ops)->nelts)) {
#line 364
        goto while_break___2;
      }
      {
#line 365
      p = (*((op + i)->run))(r, p, op + i);
#line 364
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 368
    if ((log + l)->syslog_peer) {
      {
#line 370
      size = (size_t___0 )(p - line);
#line 372
      n = ngx_syslog_send((log + l)->syslog_peer, line, size);
      }
#line 374
      if (n < 0L) {
#line 375
        if (((r->connection)->log)->log_level >= 5UL) {
          {
#line 375
          ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "send() to syslog failed");
          }
        }
      } else
#line 378
      if ((size_t___0 )n != size) {
#line 379
        if (((r->connection)->log)->log_level >= 5UL) {
          {
#line 379
          ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "send() to syslog has written only %z of %uz",
                             n, size);
          }
        }
      }
#line 384
      goto __Cont;
    }
    {
#line 387
    tmp___3 = p;
#line 387
    p ++;
#line 387
    *tmp___3 = (u_char )'\n';
#line 389
    ngx_http_log_write(r, log + l, line, (size_t___0 )(p - line));
    }
    __Cont: /* CIL Label */ 
#line 267
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return ((ngx_int_t )0);
}
}
#line 396 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_write(ngx_http_request_t *r , ngx_http_log_t *log , u_char *buf ,
                               size_t___0 len ) 
{ 
  u_char *name ;
  time_t now ;
  ssize_t n ;
  ngx_err_t err ;
  ngx_http_log_buf_t *buffer___0 ;
  int *tmp ;

  {
#line 408
  if ((unsigned long )log->script == (unsigned long )((void *)0)) {
#line 409
    name = (log->file)->name.data;
#line 412
    buffer___0 = (ngx_http_log_buf_t *)(log->file)->data;
#line 414
    if (buffer___0) {
#line 414
      if (buffer___0->gzip) {
        {
#line 415
        n = ngx_http_log_gzip((log->file)->fd, buf, len, buffer___0->gzip, (r->connection)->log);
        }
      } else {
        {
#line 418
        n = ngx_write_fd((log->file)->fd, (void *)buf, len);
        }
      }
    } else {
      {
#line 418
      n = ngx_write_fd((log->file)->fd, (void *)buf, len);
      }
    }
  } else {
    {
#line 425
    name = (u_char *)((void *)0);
#line 426
    n = ngx_http_log_script_write(r, log->script, & name, buf, len);
    }
  }
#line 429
  if (n == (ssize_t )len) {
#line 430
    return;
  }
#line 433
  now = (time_t )ngx_cached_time->sec;
#line 435
  if (n == -1L) {
    {
#line 436
    tmp = __errno_location();
#line 436
    err = *tmp;
    }
#line 438
    if (err == 28) {
#line 439
      log->disk_full_time = now;
    }
#line 442
    if (now - log->error_log_time > 59L) {
#line 443
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 443
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, err, "write() to \"%s\" failed",
                           name);
        }
      }
#line 446
      log->error_log_time = now;
    }
#line 449
    return;
  }
#line 452
  if (now - log->error_log_time > 59L) {
#line 453
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 453
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "write() to \"%s\" was incomplete: %z of %uz",
                         name, n, len);
      }
    }
#line 457
    log->error_log_time = now;
  }
#line 459
  return;
}
}
#line 462 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ssize_t ngx_http_log_script_write(ngx_http_request_t *r , ngx_http_log_script_t *script ,
                                         u_char **name , u_char *buf , size_t___0 len ) 
{ 
  size_t___0 root ;
  ssize_t n ;
  ngx_str_t log ;
  ngx_str_t path ;
  ngx_open_file_info_t of ;
  ngx_http_log_loc_conf_t *llcf ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  int *tmp___4 ;
  ngx_int_t tmp___5 ;

  {
#line 473
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 475
  if (! r->root_tested) {
    {
#line 479
    tmp = ngx_http_map_uri_to_path(r, & path, & root, (size_t___0 )0);
    }
#line 479
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 481
      return ((ssize_t )len);
    }
    {
#line 484
    *(path.data + root) = (u_char )'\000';
#line 486
    memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 488
    of.valid = clcf->open_file_cache_valid;
#line 489
    of.min_uses = clcf->open_file_cache_min_uses;
#line 490
    of.test_dir = 1U;
#line 491
    of.test_only = 1U;
#line 492
    of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 493
    of.events = (unsigned int )clcf->open_file_cache_events;
#line 495
    tmp___0 = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
    }
#line 495
    if (tmp___0 != 0L) {
#line 497
      return ((ssize_t )len);
    }
    {
#line 500
    tmp___1 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
    }
#line 500
    if (tmp___1 != 0L) {
#line 503
      if (of.err == 0) {
#line 505
        return ((ssize_t )len);
      }
#line 508
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 508
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, of.err, "testing \"%s\" existence failed",
                           path.data);
        }
      }
#line 512
      return ((ssize_t )len);
    }
#line 515
    if (! of.is_dir) {
#line 516
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 516
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 20, "testing \"%s\" existence failed",
                           path.data);
        }
      }
#line 520
      return ((ssize_t )len);
    }
  }
  {
#line 524
  tmp___2 = ngx_http_script_run(r, & log, (script->lengths)->elts, (size_t___0 )1,
                                (script->values)->elts);
  }
#line 524
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 529
    return ((ssize_t )len);
  }
  {
#line 532
  *(log.data + (log.len - 1UL)) = (u_char )'\000';
#line 533
  *name = log.data;
#line 538
  llcf = (ngx_http_log_loc_conf_t *)*(r->loc_conf + ngx_http_log_module.ctx_index);
#line 540
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 542
  of.log = 1U;
#line 543
  of.valid = llcf->open_file_cache_valid;
#line 544
  of.min_uses = llcf->open_file_cache_min_uses;
#line 545
  of.directio = (off_t )9223372036854775807LL;
#line 547
  tmp___3 = ngx_http_set_disable_symlinks(r, clcf, & log, & of);
  }
#line 547
  if (tmp___3 != 0L) {
#line 549
    return ((ssize_t )len);
  }
  {
#line 552
  tmp___5 = ngx_open_cached_file(llcf->open_file_cache, & log, & of, r->pool);
  }
#line 552
  if (tmp___5 != 0L) {
#line 555
    if (of.err == 0) {
#line 557
      return ((ssize_t )len);
    }
#line 560
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 560
      tmp___4 = __errno_location();
#line 560
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___4, "%s \"%s\" failed",
                         of.failed, log.data);
      }
    }
#line 563
    return ((ssize_t )len);
  }
  {
#line 569
  n = ngx_write_fd(of.fd, (void *)buf, len);
  }
#line 571
  return (n);
}
}
#line 577 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ssize_t ngx_http_log_gzip(ngx_fd_t fd , u_char *buf , size_t___0 len , ngx_int_t level ,
                                 ngx_log_t *log ) 
{ 
  int rc ;
  int wbits ;
  int memlevel ;
  u_char *out ;
  size_t___0 size ;
  ssize_t n ;
  z_stream zstream ;
  ngx_err_t err ;
  ngx_pool_t *pool ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 589
  wbits = 15;
#line 590
  memlevel = 8;
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! ((ssize_t )len < (ssize_t )((1 << (wbits - 1)) - 262))) {
#line 592
      goto while_break;
    }
#line 593
    wbits --;
#line 594
    memlevel --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 602
  size = (((len + ((len + 7UL) >> 3)) + ((len + 63UL) >> 6)) + 5UL) + 18UL;
#line 604
  memset((void *)(& zstream), 0, sizeof(z_stream ));
#line 606
  pool = ngx_create_pool((size_t___0 )256, log);
  }
#line 607
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 609
    return ((ssize_t )len);
  }
  {
#line 612
  pool->log = log;
#line 614
  zstream.zalloc = & ngx_http_log_gzip_alloc;
#line 615
  zstream.zfree = & ngx_http_log_gzip_free;
#line 616
  zstream.opaque = (voidpf )pool;
#line 618
  tmp = ngx_pnalloc(pool, size);
#line 618
  out = (u_char *)tmp;
  }
#line 619
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 620
    goto done;
  }
  {
#line 623
  zstream.next_in = buf;
#line 624
  zstream.avail_in = (uInt )len;
#line 625
  zstream.next_out = out;
#line 626
  zstream.avail_out = (uInt )size;
#line 628
  rc = deflateInit2_(& zstream, (int )level, 8, wbits + 16, memlevel, 0, "1.2.11",
                     (int )sizeof(z_stream ));
  }
#line 631
  if (rc != 0) {
#line 632
    if (log->log_level >= 2UL) {
      {
#line 632
      ngx_log_error_core((ngx_uint_t )2, log, 0, "deflateInit2() failed: %d", rc);
      }
    }
#line 633
    goto done;
  }
  {
#line 641
  rc = deflate(& zstream, 4);
  }
#line 643
  if (rc != 1) {
#line 644
    if (log->log_level >= 2UL) {
      {
#line 644
      ngx_log_error_core((ngx_uint_t )2, log, 0, "deflate(Z_FINISH) failed: %d", rc);
      }
    }
#line 646
    goto done;
  }
  {
#line 655
  size -= (size_t___0 )zstream.avail_out;
#line 657
  rc = deflateEnd(& zstream);
  }
#line 659
  if (rc != 0) {
#line 660
    if (log->log_level >= 2UL) {
      {
#line 660
      ngx_log_error_core((ngx_uint_t )2, log, 0, "deflateEnd() failed: %d", rc);
      }
    }
#line 661
    goto done;
  }
  {
#line 664
  n = ngx_write_fd(fd, (void *)out, size);
  }
#line 666
  if (n != (ssize_t )size) {
#line 667
    if (n == -1L) {
      {
#line 667
      tmp___0 = __errno_location();
#line 667
      err = *tmp___0;
      }
    } else {
#line 667
      err = 0;
    }
    {
#line 669
    ngx_destroy_pool(pool);
#line 671
    tmp___1 = __errno_location();
#line 671
    *tmp___1 = err;
    }
#line 672
    return ((ssize_t )-1);
  }
  done: 
  {
#line 677
  ngx_destroy_pool(pool);
  }
#line 680
  return ((ssize_t )len);
}
}
#line 684 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void *ngx_http_log_gzip_alloc(void *opaque , u_int items , u_int size ) 
{ 
  ngx_pool_t *pool ;
  void *tmp ;

  {
  {
#line 687
  pool = (ngx_pool_t *)opaque;
#line 692
  tmp = ngx_palloc(pool, (size_t___0 )(items * size));
  }
#line 692
  return (tmp);
}
}
#line 696 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_gzip_free(void *opaque , void *address ) 
{ 


  {
#line 704
  return;
}
}
#line 709 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_flush(ngx_open_file_t *file , ngx_log_t *log ) 
{ 
  size_t___0 len ;
  ssize_t n ;
  ngx_http_log_buf_t *buffer___0 ;
  int *tmp ;

  {
#line 716
  buffer___0 = (ngx_http_log_buf_t *)file->data;
#line 718
  len = (size_t___0 )(buffer___0->pos - buffer___0->start);
#line 720
  if (len == 0UL) {
#line 721
    return;
  }
#line 725
  if (buffer___0->gzip) {
    {
#line 726
    n = ngx_http_log_gzip(file->fd, buffer___0->start, len, buffer___0->gzip, log);
    }
  } else {
    {
#line 728
    n = ngx_write_fd(file->fd, (void *)buffer___0->start, len);
    }
  }
#line 734
  if (n == -1L) {
#line 735
    if (log->log_level >= 2UL) {
      {
#line 735
      tmp = __errno_location();
#line 735
      ngx_log_error_core((ngx_uint_t )2, log, *tmp, "write() to \"%s\" failed", file->name.data);
      }
    }
  } else
#line 739
  if ((size_t___0 )n != len) {
#line 740
    if (log->log_level >= 2UL) {
      {
#line 740
      ngx_log_error_core((ngx_uint_t )2, log, 0, "write() to \"%s\" was incomplete: %z of %uz",
                         file->name.data, n, len);
      }
    }
  }
#line 745
  buffer___0->pos = buffer___0->start;
#line 747
  if (buffer___0->event) {
#line 747
    if ((buffer___0->event)->timer_set) {
      {
#line 748
      ngx_event_del_timer(buffer___0->event);
      }
    }
  }
#line 750
  return;
}
}
#line 753 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_flush_handler(ngx_event_t *ev ) 
{ 


  {
  {
#line 759
  ngx_http_log_flush((ngx_open_file_t *)ev->data, ev->log);
  }
#line 760
  return;
}
}
#line 763 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_copy_short(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  size_t___0 len ;
  uintptr_t data ;
  u_char *tmp ;
  size_t___0 tmp___0 ;

  {
#line 770
  len = op->len;
#line 771
  data = op->data;
  {
#line 773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 773
    tmp___0 = len;
#line 773
    len --;
#line 773
    if (! tmp___0) {
#line 773
      goto while_break;
    }
#line 774
    tmp = buf;
#line 774
    buf ++;
#line 774
    *tmp = (u_char )(data & 255UL);
#line 775
    data >>= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  return (buf);
}
}
#line 782 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_copy_long(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  void *tmp ;

  {
  {
#line 786
  tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)((u_char *)op->data),
               op->len);
  }
#line 786
  return ((u_char *)tmp + op->len);
}
}
#line 790 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_pipe(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 


  {
#line 793
  if (r->pipeline) {
#line 794
    *buf = (u_char )'p';
  } else {
#line 796
    *buf = (u_char )'.';
  }
#line 799
  return (buf + 1);
}
}
#line 803 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  void *tmp ;

  {
  {
#line 806
  tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)ngx_cached_http_log_time.data,
               (size_t )ngx_cached_http_log_time.len);
  }
#line 806
  return ((u_char *)tmp + ngx_cached_http_log_time.len);
}
}
#line 810 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_iso8601(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  void *tmp ;

  {
  {
#line 813
  tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)ngx_cached_http_log_iso8601.data,
               (size_t )ngx_cached_http_log_iso8601.len);
  }
#line 813
  return ((u_char *)tmp + ngx_cached_http_log_iso8601.len);
}
}
#line 817 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_msec(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_time_t *tp ;
  u_char *tmp ;

  {
  {
#line 822
  tp = (ngx_time_t *)ngx_cached_time;
#line 824
  tmp = ngx_sprintf(buf, "%T.%03M", tp->sec, tp->msec);
  }
#line 824
  return (tmp);
}
}
#line 828 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_request_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_time_t *tp ;
  ngx_msec_int_t ms ;
  u_char *tmp ;

  {
#line 835
  tp = (ngx_time_t *)ngx_cached_time;
#line 837
  ms = (ngx_msec_int_t )((ngx_uint_t )((tp->sec - r->start_sec) * 1000L) + (tp->msec - r->start_msec));
#line 839
  if (ms < 0L) {
#line 839
    ms = (ngx_msec_int_t )0;
  } else {
#line 839
    ms = ms;
  }
  {
#line 841
  tmp = ngx_sprintf(buf, "%T.%03M", ms / 1000L, ms % 1000L);
  }
#line 841
  return (tmp);
}
}
#line 845 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_status(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_uint_t status ;
  u_char *tmp ;

  {
#line 850
  if (r->err_status) {
#line 851
    status = r->err_status;
  } else
#line 853
  if (r->headers_out.status) {
#line 854
    status = r->headers_out.status;
  } else
#line 856
  if (r->http_version == 9UL) {
#line 857
    status = (ngx_uint_t )9;
  } else {
#line 860
    status = (ngx_uint_t )0;
  }
  {
#line 863
  tmp = ngx_sprintf(buf, "%03ui", status);
  }
#line 863
  return (tmp);
}
}
#line 867 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_bytes_sent(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  u_char *tmp ;

  {
  {
#line 871
  tmp = ngx_sprintf(buf, "%O", (r->connection)->sent);
  }
#line 871
  return (tmp);
}
}
#line 880 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_body_bytes_sent(ngx_http_request_t *r , u_char *buf ,
                                            ngx_http_log_op_t *op ) 
{ 
  off_t length ;
  u_char *tmp ;

  {
#line 886
  length = (off_t )((size_t___0 )(r->connection)->sent - r->header_size);
#line 888
  if (length > 0L) {
    {
#line 889
    tmp = ngx_sprintf(buf, "%O", length);
    }
#line 889
    return (tmp);
  }
#line 892
  *buf = (u_char )'0';
#line 894
  return (buf + 1);
}
}
#line 898 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_request_length(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  u_char *tmp ;

  {
  {
#line 902
  tmp = ngx_sprintf(buf, "%O", r->request_length);
  }
#line 902
  return (tmp);
}
}
#line 906 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_int_t ngx_http_log_variable_compile(ngx_conf_t *cf , ngx_http_log_op_t *op ,
                                               ngx_str_t *value , ngx_uint_t json ) 
{ 
  ngx_int_t index___0 ;

  {
  {
#line 912
  index___0 = ngx_http_get_variable_index(cf, value);
  }
#line 913
  if (index___0 == -1L) {
#line 914
    return ((ngx_int_t )-1);
  }
#line 917
  op->len = (size_t___0 )0;
#line 919
  if (json) {
#line 920
    op->getlen = & ngx_http_log_json_variable_getlen;
#line 921
    op->run = & ngx_http_log_json_variable;
  } else {
#line 924
    op->getlen = & ngx_http_log_variable_getlen;
#line 925
    op->run = & ngx_http_log_variable;
  }
#line 928
  op->data = (uintptr_t )index___0;
#line 930
  return ((ngx_int_t )0);
}
}
#line 934 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static size_t___0 ngx_http_log_variable_getlen(ngx_http_request_t *r , uintptr_t data ) 
{ 
  uintptr_t len ;
  ngx_http_variable_value_t *value ;

  {
  {
#line 940
  value = ngx_http_get_indexed_variable(r, data);
  }
#line 942
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 943
    return ((size_t___0 )1);
  } else
#line 942
  if (value->not_found) {
#line 943
    return ((size_t___0 )1);
  }
  {
#line 946
  len = ngx_http_log_escape((u_char *)((void *)0), value->data, (size_t___0 )value->len);
  }
#line 948
  if (len) {
#line 948
    value->escape = 1U;
  } else {
#line 948
    value->escape = 0U;
  }
#line 950
  return ((uintptr_t )value->len + len * 3UL);
}
}
#line 954 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_http_variable_value_t *value ;
  void *tmp ;
  uintptr_t tmp___0 ;

  {
  {
#line 959
  value = ngx_http_get_indexed_variable(r, op->data);
  }
#line 961
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 962
    *buf = (u_char )'-';
#line 963
    return (buf + 1);
  } else
#line 961
  if (value->not_found) {
#line 962
    *buf = (u_char )'-';
#line 963
    return (buf + 1);
  }
#line 966
  if (value->escape == 0U) {
    {
#line 967
    tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)value->data,
                 (size_t )value->len);
    }
#line 967
    return ((u_char *)tmp + value->len);
  } else {
    {
#line 970
    tmp___0 = ngx_http_log_escape(buf, value->data, (size_t___0 )value->len);
    }
#line 970
    return ((u_char *)tmp___0);
  }
}
}
#line 979 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char hex[17]  = 
#line 979
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'A',      (u_char )'B', 
        (u_char )'C',      (u_char )'D',      (u_char )'E',      (u_char )'F', 
        (u_char )'\000'};
#line 981 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static uint32_t escape[8]  = 
#line 981
  {      4294967295U,      (uint32_t )4,      (uint32_t )268435456,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 975 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static uintptr_t ngx_http_log_escape(u_char *dst , u_char *src , size_t___0 size ) 
{ 
  ngx_uint_t n ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;

  {
#line 1000
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1004
    n = (ngx_uint_t )0;
    {
#line 1006
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1006
      if (! size) {
#line 1006
        goto while_break;
      }
#line 1007
      if (escape[(int )*src >> 5] & (1U << ((int )*src & 31))) {
#line 1008
        n ++;
      }
#line 1010
      src ++;
#line 1011
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1014
    return (n);
  }
  {
#line 1017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1017
    if (! size) {
#line 1017
      goto while_break___0;
    }
#line 1018
    if (escape[(int )*src >> 5] & (1U << ((int )*src & 31))) {
#line 1019
      tmp = dst;
#line 1019
      dst ++;
#line 1019
      *tmp = (u_char )'\\';
#line 1020
      tmp___0 = dst;
#line 1020
      dst ++;
#line 1020
      *tmp___0 = (u_char )'x';
#line 1021
      tmp___1 = dst;
#line 1021
      dst ++;
#line 1021
      *tmp___1 = hex[(int )*src >> 4];
#line 1022
      tmp___2 = dst;
#line 1022
      dst ++;
#line 1022
      *tmp___2 = hex[(int )*src & 15];
#line 1023
      src ++;
    } else {
#line 1026
      tmp___3 = dst;
#line 1026
      dst ++;
#line 1026
      tmp___4 = src;
#line 1026
      src ++;
#line 1026
      *tmp___3 = *tmp___4;
    }
#line 1028
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1031
  return ((uintptr_t )dst);
}
}
#line 1035 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static size_t___0 ngx_http_log_json_variable_getlen(ngx_http_request_t *r , uintptr_t data ) 
{ 
  uintptr_t len ;
  ngx_http_variable_value_t *value ;

  {
  {
#line 1041
  value = ngx_http_get_indexed_variable(r, data);
  }
#line 1043
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1044
    return ((size_t___0 )0);
  } else
#line 1043
  if (value->not_found) {
#line 1044
    return ((size_t___0 )0);
  }
  {
#line 1047
  len = ngx_escape_json((u_char *)((void *)0), value->data, (size_t___0 )value->len);
  }
#line 1049
  if (len) {
#line 1049
    value->escape = 1U;
  } else {
#line 1049
    value->escape = 0U;
  }
#line 1051
  return ((uintptr_t )value->len + len);
}
}
#line 1055 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_json_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_http_variable_value_t *value ;
  void *tmp ;
  uintptr_t tmp___0 ;

  {
  {
#line 1061
  value = ngx_http_get_indexed_variable(r, op->data);
  }
#line 1063
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1064
    return (buf);
  } else
#line 1063
  if (value->not_found) {
#line 1064
    return (buf);
  }
#line 1067
  if (value->escape == 0U) {
    {
#line 1068
    tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)value->data,
                 (size_t )value->len);
    }
#line 1068
    return ((u_char *)tmp + value->len);
  } else {
    {
#line 1071
    tmp___0 = ngx_escape_json(buf, value->data, (size_t___0 )value->len);
    }
#line 1071
    return ((u_char *)tmp___0);
  }
}
}
#line 1076 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void *ngx_http_log_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_log_main_conf_t *conf ;
  ngx_http_log_fmt_t *fmt ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1083
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_main_conf_t ));
#line 1083
  conf = (ngx_http_log_main_conf_t *)tmp;
  }
#line 1084
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1085
    return ((void *)0);
  }
  {
#line 1088
  tmp___0 = ngx_array_init(& conf->formats, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_log_fmt_t ));
  }
#line 1088
  if (tmp___0 != 0L) {
#line 1091
    return ((void *)0);
  }
  {
#line 1094
  tmp___1 = ngx_array_push(& conf->formats);
#line 1094
  fmt = (ngx_http_log_fmt_t *)tmp___1;
  }
#line 1095
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 1096
    return ((void *)0);
  }
  {
#line 1099
  fmt->name.len = sizeof("combined") - 1UL;
#line 1099
  fmt->name.data = (u_char *)"combined";
#line 1101
  fmt->flushes = (ngx_array_t *)((void *)0);
#line 1103
  fmt->ops = ngx_array_create(cf->pool, (ngx_uint_t )16, sizeof(ngx_http_log_op_t ));
  }
#line 1104
  if ((unsigned long )fmt->ops == (unsigned long )((void *)0)) {
#line 1105
    return ((void *)0);
  }
#line 1108
  return ((void *)conf);
}
}
#line 1112 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static void *ngx_http_log_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_log_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1117
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_loc_conf_t ));
#line 1117
  conf = (ngx_http_log_loc_conf_t *)tmp;
  }
#line 1118
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1119
    return ((void *)0);
  }
#line 1122
  conf->open_file_cache = (ngx_open_file_cache_t *)((void *)-1);
#line 1124
  return ((void *)conf);
}
}
#line 1128 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_log_loc_conf_t *prev ;
  ngx_http_log_loc_conf_t *conf ;
  ngx_http_log_t *log ;
  ngx_http_log_fmt_t *fmt ;
  ngx_http_log_main_conf_t *lmcf ;
  void *tmp ;

  {
#line 1131
  prev = (ngx_http_log_loc_conf_t *)parent;
#line 1132
  conf = (ngx_http_log_loc_conf_t *)child;
#line 1138
  if ((unsigned long )conf->open_file_cache == (unsigned long )((void *)-1)) {
#line 1140
    conf->open_file_cache = prev->open_file_cache;
#line 1141
    conf->open_file_cache_valid = prev->open_file_cache_valid;
#line 1142
    conf->open_file_cache_min_uses = prev->open_file_cache_min_uses;
#line 1144
    if ((unsigned long )conf->open_file_cache == (unsigned long )((void *)-1)) {
#line 1145
      conf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
    }
  }
#line 1149
  if (conf->logs) {
#line 1150
    return ((char *)((void *)0));
  } else
#line 1149
  if (conf->off) {
#line 1150
    return ((char *)((void *)0));
  }
#line 1153
  conf->logs = prev->logs;
#line 1154
  conf->off = prev->off;
#line 1156
  if (conf->logs) {
#line 1157
    return ((char *)((void *)0));
  } else
#line 1156
  if (conf->off) {
#line 1157
    return ((char *)((void *)0));
  }
  {
#line 1160
  conf->logs = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_http_log_t ));
  }
#line 1161
  if ((unsigned long )conf->logs == (unsigned long )((void *)0)) {
#line 1162
    return ((char *)((void *)-1));
  }
  {
#line 1165
  tmp = ngx_array_push(conf->logs);
#line 1165
  log = (ngx_http_log_t *)tmp;
  }
#line 1166
  if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 1167
    return ((char *)((void *)-1));
  }
  {
#line 1170
  memset((void *)log, 0, sizeof(ngx_http_log_t ));
#line 1172
  log->file = ngx_conf_open_file(cf->cycle, & ngx_http_access_log);
  }
#line 1173
  if ((unsigned long )log->file == (unsigned long )((void *)0)) {
#line 1174
    return ((char *)((void *)-1));
  }
#line 1177
  lmcf = (ngx_http_log_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_log_module.ctx_index);
#line 1178
  fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1181
  log->format = fmt + 0;
#line 1182
  lmcf->combined_used = (ngx_uint_t )1;
#line 1184
  return ((char *)((void *)0));
}
}
#line 1188 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_set_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_log_loc_conf_t *llcf ;
  ssize_t size ;
  ngx_int_t gzip ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_msec_t flush ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_str_t s ;
  ngx_http_log_t *log ;
  ngx_syslog_peer_t *peer ;
  ngx_http_log_buf_t *buffer___0 ;
  ngx_http_log_fmt_t *fmt ;
  ngx_http_log_main_conf_t *lmcf ;
  ngx_http_script_compile_t sc ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;
  int tmp___7 ;
  ngx_int_t tmp___8 ;
  int tmp___9 ;
  ngx_int_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  ngx_int_t tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;

  {
  {
#line 1191
  llcf = (ngx_http_log_loc_conf_t *)conf;
#line 1206
  value = (ngx_str_t *)(cf->args)->elts;
#line 1208
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 1208
  if (tmp == 0) {
#line 1209
    llcf->off = (ngx_uint_t )1;
#line 1210
    if ((cf->args)->nelts == 2UL) {
#line 1211
      return ((char *)((void *)0));
    }
    {
#line 1214
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 2);
    }
#line 1216
    return ((char *)((void *)-1));
  }
#line 1219
  if ((unsigned long )llcf->logs == (unsigned long )((void *)0)) {
    {
#line 1220
    llcf->logs = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_http_log_t ));
    }
#line 1221
    if ((unsigned long )llcf->logs == (unsigned long )((void *)0)) {
#line 1222
      return ((char *)((void *)-1));
    }
  }
  {
#line 1226
  lmcf = (ngx_http_log_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_log_module.ctx_index);
#line 1228
  tmp___0 = ngx_array_push(llcf->logs);
#line 1228
  log = (ngx_http_log_t *)tmp___0;
  }
#line 1229
  if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 1230
    return ((char *)((void *)-1));
  }
  {
#line 1233
  memset((void *)log, 0, sizeof(ngx_http_log_t ));
#line 1236
  tmp___3 = strncmp((char const   *)(value + 1)->data, "syslog:", (size_t )7);
  }
#line 1236
  if (tmp___3 == 0) {
    {
#line 1238
    tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_syslog_peer_t ));
#line 1238
    peer = (ngx_syslog_peer_t *)tmp___1;
    }
#line 1239
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 1240
      return ((char *)((void *)-1));
    }
    {
#line 1243
    tmp___2 = ngx_syslog_process_conf(cf, peer);
    }
#line 1243
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 1244
      return ((char *)((void *)-1));
    }
#line 1247
    log->syslog_peer = peer;
#line 1249
    goto process_formats;
  }
  {
#line 1252
  n = ngx_http_script_variables_count(value + 1);
  }
#line 1254
  if (n == 0UL) {
    {
#line 1255
    log->file = ngx_conf_open_file(cf->cycle, value + 1);
    }
#line 1256
    if ((unsigned long )log->file == (unsigned long )((void *)0)) {
#line 1257
      return ((char *)((void *)-1));
    }
  } else {
    {
#line 1261
    tmp___4 = ngx_conf_full_name(cf->cycle, value + 1, (ngx_uint_t )0);
    }
#line 1261
    if (tmp___4 != 0L) {
#line 1262
      return ((char *)((void *)-1));
    }
    {
#line 1265
    tmp___5 = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_script_t ));
#line 1265
    log->script = (ngx_http_log_script_t *)tmp___5;
    }
#line 1266
    if ((unsigned long )log->script == (unsigned long )((void *)0)) {
#line 1267
      return ((char *)((void *)-1));
    }
    {
#line 1270
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1272
    sc.cf = cf;
#line 1273
    sc.source = value + 1;
#line 1274
    sc.lengths = & (log->script)->lengths;
#line 1275
    sc.values = & (log->script)->values;
#line 1276
    sc.variables = n;
#line 1277
    sc.complete_lengths = 1U;
#line 1278
    sc.complete_values = 1U;
#line 1280
    tmp___6 = ngx_http_script_compile(& sc);
    }
#line 1280
    if (tmp___6 != 0L) {
#line 1281
      return ((char *)((void *)-1));
    }
  }
  process_formats: 
#line 1287
  if ((cf->args)->nelts >= 3UL) {
    {
#line 1288
    name = *(value + 2);
#line 1290
    tmp___7 = strcmp((char const   *)name.data, "combined");
    }
#line 1290
    if (tmp___7 == 0) {
#line 1291
      lmcf->combined_used = (ngx_uint_t )1;
    }
  } else {
#line 1295
    name.len = sizeof("combined") - 1UL;
#line 1295
    name.data = (u_char *)"combined";
#line 1296
    lmcf->combined_used = (ngx_uint_t )1;
  }
#line 1299
  fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1300
  i = (ngx_uint_t )0;
  {
#line 1300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1300
    if (! (i < lmcf->formats.nelts)) {
#line 1300
      goto while_break;
    }
#line 1301
    if ((fmt + i)->name.len == name.len) {
      {
#line 1301
      tmp___8 = ngx_strcasecmp((fmt + i)->name.data, name.data);
      }
#line 1301
      if (tmp___8 == 0L) {
#line 1304
        log->format = fmt + i;
#line 1305
        goto while_break;
      }
    }
#line 1300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  if ((unsigned long )log->format == (unsigned long )((void *)0)) {
    {
#line 1310
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown log format \"%V\"", & name);
    }
#line 1312
    return ((char *)((void *)-1));
  }
#line 1315
  size = (ssize_t )0;
#line 1316
  flush = (ngx_msec_t )0;
#line 1317
  gzip = (ngx_int_t )0;
#line 1319
  i = (ngx_uint_t )3;
  {
#line 1319
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1319
    if (! (i < (cf->args)->nelts)) {
#line 1319
      goto while_break___0;
    }
    {
#line 1321
    tmp___9 = strncmp((char const   *)(value + i)->data, "buffer=", (size_t )7);
    }
#line 1321
    if (tmp___9 == 0) {
      {
#line 1322
      s.len = (value + i)->len - 7UL;
#line 1323
      s.data = (value + i)->data + 7;
#line 1325
      size = ngx_parse_size(& s);
      }
#line 1327
      if (size == -1L) {
        {
#line 1328
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid buffer size \"%V\"", & s);
        }
#line 1330
        return ((char *)((void *)-1));
      } else
#line 1327
      if (size == 0L) {
        {
#line 1328
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid buffer size \"%V\"", & s);
        }
#line 1330
        return ((char *)((void *)-1));
      }
#line 1333
      goto __Cont;
    }
    {
#line 1336
    tmp___11 = strncmp((char const   *)(value + i)->data, "flush=", (size_t )6);
    }
#line 1336
    if (tmp___11 == 0) {
      {
#line 1337
      s.len = (value + i)->len - 6UL;
#line 1338
      s.data = (value + i)->data + 6;
#line 1340
      tmp___10 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 1340
      flush = (ngx_msec_t )tmp___10;
      }
#line 1342
      if (flush == 0xffffffffffffffffUL) {
        {
#line 1343
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid flush time \"%V\"", & s);
        }
#line 1345
        return ((char *)((void *)-1));
      } else
#line 1342
      if (flush == 0UL) {
        {
#line 1343
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid flush time \"%V\"", & s);
        }
#line 1345
        return ((char *)((void *)-1));
      }
#line 1348
      goto __Cont;
    }
    {
#line 1351
    tmp___12 = strncmp((char const   *)(value + i)->data, "gzip", (size_t )4);
    }
#line 1351
    if (tmp___12 == 0) {
#line 1351
      if ((value + i)->len == 4UL) {
#line 1351
        goto _L;
      } else
#line 1351
      if ((int )*((value + i)->data + 4) == 61) {
        _L: /* CIL Label */ 
#line 1355
        if (size == 0L) {
#line 1356
          size = (ssize_t )65536;
        }
#line 1359
        if ((value + i)->len == 4UL) {
#line 1360
          gzip = (ngx_int_t )1;
#line 1361
          goto __Cont;
        }
        {
#line 1364
        s.len = (value + i)->len - 5UL;
#line 1365
        s.data = (value + i)->data + 5;
#line 1367
        gzip = ngx_atoi(s.data, s.len);
        }
#line 1369
        if (gzip < 1L) {
          {
#line 1370
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid compression level \"%V\"",
                             & s);
          }
#line 1372
          return ((char *)((void *)-1));
        } else
#line 1369
        if (gzip > 9L) {
          {
#line 1370
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid compression level \"%V\"",
                             & s);
          }
#line 1372
          return ((char *)((void *)-1));
        }
#line 1375
        goto __Cont;
      }
    }
    {
#line 1384
    tmp___15 = strncmp((char const   *)(value + i)->data, "if=", (size_t )3);
    }
#line 1384
    if (tmp___15 == 0) {
      {
#line 1385
      s.len = (value + i)->len - 3UL;
#line 1386
      s.data = (value + i)->data + 3;
#line 1388
      memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 1390
      ccv.cf = cf;
#line 1391
      ccv.value = & s;
#line 1392
      tmp___13 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 1392
      ccv.complex_value = (ngx_http_complex_value_t *)tmp___13;
      }
#line 1394
      if ((unsigned long )ccv.complex_value == (unsigned long )((void *)0)) {
#line 1395
        return ((char *)((void *)-1));
      }
      {
#line 1398
      tmp___14 = ngx_http_compile_complex_value(& ccv);
      }
#line 1398
      if (tmp___14 != 0L) {
#line 1399
        return ((char *)((void *)-1));
      }
#line 1402
      log->filter = ccv.complex_value;
#line 1404
      goto __Cont;
    }
    {
#line 1407
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 1409
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 1319
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1412
  if (flush) {
#line 1412
    if (size == 0L) {
      {
#line 1413
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "no buffer is defined for access_log \"%V\"",
                         value + 1);
      }
#line 1416
      return ((char *)((void *)-1));
    }
  }
#line 1419
  if (size) {
#line 1421
    if (log->script) {
      {
#line 1422
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "buffered logs cannot have variables in name");
      }
#line 1424
      return ((char *)((void *)-1));
    }
#line 1427
    if (log->syslog_peer) {
      {
#line 1428
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "logs to syslog cannot be buffered");
      }
#line 1430
      return ((char *)((void *)-1));
    }
#line 1433
    if ((log->file)->data) {
#line 1434
      buffer___0 = (ngx_http_log_buf_t *)(log->file)->data;
#line 1436
      if (buffer___0->last - buffer___0->start != size) {
        {
#line 1440
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "access_log \"%V\" already defined with conflicting parameters",
                           value + 1);
        }
#line 1444
        return ((char *)((void *)-1));
      } else
#line 1436
      if (buffer___0->flush != flush) {
        {
#line 1440
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "access_log \"%V\" already defined with conflicting parameters",
                           value + 1);
        }
#line 1444
        return ((char *)((void *)-1));
      } else
#line 1436
      if (buffer___0->gzip != gzip) {
        {
#line 1440
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "access_log \"%V\" already defined with conflicting parameters",
                           value + 1);
        }
#line 1444
        return ((char *)((void *)-1));
      }
#line 1447
      return ((char *)((void *)0));
    }
    {
#line 1450
    tmp___16 = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_buf_t ));
#line 1450
    buffer___0 = (ngx_http_log_buf_t *)tmp___16;
    }
#line 1451
    if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 1452
      return ((char *)((void *)-1));
    }
    {
#line 1455
    tmp___17 = ngx_pnalloc(cf->pool, (size_t___0 )size);
#line 1455
    buffer___0->start = (u_char *)tmp___17;
    }
#line 1456
    if ((unsigned long )buffer___0->start == (unsigned long )((void *)0)) {
#line 1457
      return ((char *)((void *)-1));
    }
#line 1460
    buffer___0->pos = buffer___0->start;
#line 1461
    buffer___0->last = buffer___0->start + size;
#line 1463
    if (flush) {
      {
#line 1464
      tmp___18 = ngx_pcalloc(cf->pool, sizeof(ngx_event_t ));
#line 1464
      buffer___0->event = (ngx_event_t *)tmp___18;
      }
#line 1465
      if ((unsigned long )buffer___0->event == (unsigned long )((void *)0)) {
#line 1466
        return ((char *)((void *)-1));
      }
#line 1469
      (buffer___0->event)->data = (void *)log->file;
#line 1470
      (buffer___0->event)->handler = & ngx_http_log_flush_handler;
#line 1471
      (buffer___0->event)->log = & (cf->cycle)->new_log;
#line 1472
      (buffer___0->event)->cancelable = 1U;
#line 1474
      buffer___0->flush = flush;
    }
#line 1477
    buffer___0->gzip = gzip;
#line 1479
    (log->file)->flush = & ngx_http_log_flush;
#line 1480
    (log->file)->data = (void *)buffer___0;
  }
#line 1483
  return ((char *)((void *)0));
}
}
#line 1487 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_set_format(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_log_main_conf_t *lmcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_log_fmt_t *fmt ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 1490
  lmcf = (ngx_http_log_main_conf_t *)conf;
#line 1496
  value = (ngx_str_t *)(cf->args)->elts;
#line 1498
  fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1499
  i = (ngx_uint_t )0;
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! (i < lmcf->formats.nelts)) {
#line 1499
      goto while_break;
    }
#line 1500
    if ((fmt + i)->name.len == (value + 1)->len) {
      {
#line 1500
      tmp = strcmp((char const   *)(fmt + i)->name.data, (char const   *)(value + 1)->data);
      }
#line 1500
      if (tmp == 0) {
        {
#line 1503
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate \"log_format\" name \"%V\"",
                           value + 1);
        }
#line 1506
        return ((char *)((void *)-1));
      }
    }
#line 1499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1510
  tmp___0 = ngx_array_push(& lmcf->formats);
#line 1510
  fmt = (ngx_http_log_fmt_t *)tmp___0;
  }
#line 1511
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 1512
    return ((char *)((void *)-1));
  }
  {
#line 1515
  fmt->name = *(value + 1);
#line 1517
  fmt->flushes = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_int_t ));
  }
#line 1518
  if ((unsigned long )fmt->flushes == (unsigned long )((void *)0)) {
#line 1519
    return ((char *)((void *)-1));
  }
  {
#line 1522
  fmt->ops = ngx_array_create(cf->pool, (ngx_uint_t )16, sizeof(ngx_http_log_op_t ));
  }
#line 1523
  if ((unsigned long )fmt->ops == (unsigned long )((void *)0)) {
#line 1524
    return ((char *)((void *)-1));
  }
  {
#line 1527
  tmp___1 = ngx_http_log_compile_format(cf, fmt->flushes, fmt->ops, cf->args, (ngx_uint_t )2);
  }
#line 1527
  return (tmp___1);
}
}
#line 1531 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_compile_format(ngx_conf_t *cf , ngx_array_t *flushes , ngx_array_t *ops ,
                                         ngx_array_t *args___0 , ngx_uint_t s ) 
{ 
  u_char *data ;
  u_char *p ;
  u_char ch ;
  size_t___0 i ;
  size_t___0 len ;
  ngx_str_t *value ;
  ngx_str_t var ;
  ngx_int_t *flush ;
  ngx_uint_t bracket ;
  ngx_uint_t json ;
  ngx_http_log_op_t *op ;
  ngx_http_log_var_t *v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  size_t___0 tmp___6 ;
  void *tmp___7 ;

  {
#line 1543
  json = (ngx_uint_t )0;
#line 1544
  value = (ngx_str_t *)args___0->elts;
#line 1546
  if (s < args___0->nelts) {
    {
#line 1546
    tmp___1 = strncmp((char const   *)(value + s)->data, "escape=", (size_t )7);
    }
#line 1546
    if (tmp___1 == 0) {
      {
#line 1547
      data = (value + s)->data + 7;
#line 1549
      tmp___0 = strcmp((char const   *)data, "json");
      }
#line 1549
      if (tmp___0 == 0) {
#line 1550
        json = (ngx_uint_t )1;
      } else {
        {
#line 1552
        tmp = strcmp((char const   *)data, "default");
        }
#line 1552
        if (tmp != 0) {
          {
#line 1553
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown log format escaping \"%s\"",
                             data);
          }
#line 1555
          return ((char *)((void *)-1));
        }
      }
#line 1558
      s ++;
    }
  }
  {
#line 1561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1561
    if (! (s < args___0->nelts)) {
#line 1561
      goto while_break;
    }
#line 1563
    i = (size_t___0 )0;
    {
#line 1565
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1565
      if (! (i < (value + s)->len)) {
#line 1565
        goto while_break___0;
      }
      {
#line 1567
      tmp___2 = ngx_array_push(ops);
#line 1567
      op = (ngx_http_log_op_t *)tmp___2;
      }
#line 1568
      if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 1569
        return ((char *)((void *)-1));
      }
#line 1572
      data = (value + s)->data + i;
#line 1574
      if ((int )*((value + s)->data + i) == 36) {
#line 1576
        i ++;
#line 1576
        if (i == (value + s)->len) {
#line 1577
          goto invalid;
        }
#line 1580
        if ((int )*((value + s)->data + i) == 123) {
#line 1581
          bracket = (ngx_uint_t )1;
#line 1583
          i ++;
#line 1583
          if (i == (value + s)->len) {
#line 1584
            goto invalid;
          }
#line 1587
          var.data = (value + s)->data + i;
        } else {
#line 1590
          bracket = (ngx_uint_t )0;
#line 1591
          var.data = (value + s)->data + i;
        }
#line 1594
        var.len = (size_t___0 )0;
        {
#line 1594
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1594
          if (! (i < (value + s)->len)) {
#line 1594
            goto while_break___1;
          }
#line 1595
          ch = *((value + s)->data + i);
#line 1597
          if ((int )ch == 125) {
#line 1597
            if (bracket) {
#line 1598
              i ++;
#line 1599
              bracket = (ngx_uint_t )0;
#line 1600
              goto while_break___1;
            }
          }
#line 1603
          if ((int )ch >= 65) {
#line 1603
            if ((int )ch <= 90) {
#line 1608
              goto __Cont;
            } else {
#line 1603
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1603
          if ((int )ch >= 97) {
#line 1603
            if ((int )ch <= 122) {
#line 1608
              goto __Cont;
            } else {
#line 1603
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1603
          if ((int )ch >= 48) {
#line 1603
            if ((int )ch <= 57) {
#line 1608
              goto __Cont;
            } else {
#line 1603
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1603
          if ((int )ch == 95) {
#line 1608
            goto __Cont;
          }
#line 1611
          goto while_break___1;
          __Cont: /* CIL Label */ 
#line 1594
          i ++;
#line 1594
          (var.len) ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1614
        if (bracket) {
          {
#line 1615
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the closing bracket in \"%V\" variable is missing",
                             & var);
          }
#line 1618
          return ((char *)((void *)-1));
        }
#line 1621
        if (var.len == 0UL) {
#line 1622
          goto invalid;
        }
#line 1625
        v = ngx_http_log_vars;
        {
#line 1625
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1625
          if (! v->name.len) {
#line 1625
            goto while_break___2;
          }
#line 1627
          if (v->name.len == var.len) {
            {
#line 1627
            tmp___3 = strncmp((char const   *)v->name.data, (char const   *)var.data,
                              var.len);
            }
#line 1627
            if (tmp___3 == 0) {
#line 1630
              op->len = v->len;
#line 1631
              op->getlen = (size_t___0 (*)(ngx_http_request_t *r , uintptr_t data ))((void *)0);
#line 1632
              op->run = v->run;
#line 1633
              op->data = (uintptr_t )0;
#line 1635
              goto found;
            }
          }
#line 1625
          v ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1639
        tmp___4 = ngx_http_log_variable_compile(cf, op, & var, json);
        }
#line 1639
        if (tmp___4 != 0L) {
#line 1642
          return ((char *)((void *)-1));
        }
#line 1645
        if (flushes) {
          {
#line 1647
          tmp___5 = ngx_array_push(flushes);
#line 1647
          flush = (ngx_int_t *)tmp___5;
          }
#line 1648
          if ((unsigned long )flush == (unsigned long )((void *)0)) {
#line 1649
            return ((char *)((void *)-1));
          }
#line 1652
          *flush = (ngx_int_t )op->data;
        }
        found: 
#line 1657
        goto while_continue___0;
      }
#line 1660
      i ++;
      {
#line 1662
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1662
        if (i < (value + s)->len) {
#line 1662
          if (! ((int )*((value + s)->data + i) != 36)) {
#line 1662
            goto while_break___3;
          }
        } else {
#line 1662
          goto while_break___3;
        }
#line 1663
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1666
      len = (size_t___0 )(((value + s)->data + i) - data);
#line 1668
      if (len) {
#line 1670
        op->len = len;
#line 1671
        op->getlen = (size_t___0 (*)(ngx_http_request_t *r , uintptr_t data ))((void *)0);
#line 1673
        if (len <= sizeof(uintptr_t )) {
#line 1674
          op->run = & ngx_http_log_copy_short;
#line 1675
          op->data = (uintptr_t )0;
          {
#line 1677
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1677
            tmp___6 = len;
#line 1677
            len --;
#line 1677
            if (! tmp___6) {
#line 1677
              goto while_break___4;
            }
#line 1678
            op->data <<= 8;
#line 1679
            op->data |= (unsigned long )*(data + len);
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 1683
          op->run = & ngx_http_log_copy_long;
#line 1685
          tmp___7 = ngx_pnalloc(cf->pool, len);
#line 1685
          p = (u_char *)tmp___7;
          }
#line 1686
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1687
            return ((char *)((void *)-1));
          }
          {
#line 1690
          memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)data,
                 len);
#line 1691
          op->data = (uintptr_t )p;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1561
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1697
  return ((char *)((void *)0));
  invalid: 
  {
#line 1701
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%s\"", data);
  }
#line 1703
  return ((char *)((void *)-1));
}
}
#line 1707 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_log_loc_conf_t *llcf ;
  time_t inactive ;
  time_t valid ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_int_t max ;
  ngx_int_t min_uses ;
  ngx_uint_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1710
  llcf = (ngx_http_log_loc_conf_t *)conf;
#line 1717
  if ((unsigned long )llcf->open_file_cache != (unsigned long )((void *)-1)) {
#line 1718
    return ((char *)"is duplicate");
  }
#line 1721
  value = (ngx_str_t *)(cf->args)->elts;
#line 1723
  max = (ngx_int_t )0;
#line 1724
  inactive = (time_t )10;
#line 1725
  valid = (time_t )60;
#line 1726
  min_uses = (ngx_int_t )1;
#line 1728
  i = (ngx_uint_t )1;
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1728
    if (! (i < (cf->args)->nelts)) {
#line 1728
      goto while_break;
    }
    {
#line 1730
    tmp = strncmp((char const   *)(value + i)->data, "max=", (size_t )4);
    }
#line 1730
    if (tmp == 0) {
      {
#line 1732
      max = ngx_atoi((value + i)->data + 4, (value + i)->len - 4UL);
      }
#line 1733
      if (max == -1L) {
#line 1734
        goto failed;
      }
#line 1737
      goto __Cont;
    }
    {
#line 1740
    tmp___0 = strncmp((char const   *)(value + i)->data, "inactive=", (size_t )9);
    }
#line 1740
    if (tmp___0 == 0) {
      {
#line 1742
      s.len = (value + i)->len - 9UL;
#line 1743
      s.data = (value + i)->data + 9;
#line 1745
      inactive = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 1746
      if (inactive == -1L) {
#line 1747
        goto failed;
      }
#line 1750
      goto __Cont;
    }
    {
#line 1753
    tmp___1 = strncmp((char const   *)(value + i)->data, "min_uses=", (size_t )9);
    }
#line 1753
    if (tmp___1 == 0) {
      {
#line 1755
      min_uses = ngx_atoi((value + i)->data + 9, (value + i)->len - 9UL);
      }
#line 1756
      if (min_uses == -1L) {
#line 1757
        goto failed;
      }
#line 1760
      goto __Cont;
    }
    {
#line 1763
    tmp___2 = strncmp((char const   *)(value + i)->data, "valid=", (size_t )6);
    }
#line 1763
    if (tmp___2 == 0) {
      {
#line 1765
      s.len = (value + i)->len - 6UL;
#line 1766
      s.data = (value + i)->data + 6;
#line 1768
      valid = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 1769
      if (valid == -1L) {
#line 1770
        goto failed;
      }
#line 1773
      goto __Cont;
    }
    {
#line 1776
    tmp___3 = strcmp((char const   *)(value + i)->data, "off");
    }
#line 1776
    if (tmp___3 == 0) {
#line 1778
      llcf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
#line 1780
      goto __Cont;
    }
    failed: 
    {
#line 1785
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid \"open_log_file_cache\" parameter \"%V\"",
                       value + i);
    }
#line 1788
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 1728
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1791
  if ((unsigned long )llcf->open_file_cache == (unsigned long )((void *)0)) {
#line 1792
    return ((char *)((void *)0));
  }
#line 1795
  if (max == 0L) {
    {
#line 1796
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"open_log_file_cache\" must have \"max\" parameter");
    }
#line 1798
    return ((char *)((void *)-1));
  }
  {
#line 1801
  llcf->open_file_cache = ngx_open_file_cache_init(cf->pool, (ngx_uint_t )max, inactive);
  }
#line 1803
  if (llcf->open_file_cache) {
#line 1805
    llcf->open_file_cache_valid = valid;
#line 1806
    llcf->open_file_cache_min_uses = (ngx_uint_t )min_uses;
#line 1808
    return ((char *)((void *)0));
  }
#line 1811
  return ((char *)((void *)-1));
}
}
#line 1815 "/tmp/nginx-1.13.2/src/http/modules/ngx_http_log_module.c"
static ngx_int_t ngx_http_log_init(ngx_conf_t *cf ) 
{ 
  ngx_str_t *value ;
  ngx_array_t a ;
  ngx_http_handler_pt *h ;
  ngx_http_log_fmt_t *fmt ;
  ngx_http_log_main_conf_t *lmcf ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 1825
  lmcf = (ngx_http_log_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_log_module.ctx_index);
#line 1827
  if (lmcf->combined_used) {
    {
#line 1828
    tmp = ngx_array_init(& a, cf->pool, (ngx_uint_t )1, sizeof(ngx_str_t ));
    }
#line 1828
    if (tmp != 0L) {
#line 1829
      return ((ngx_int_t )-1);
    }
    {
#line 1832
    tmp___0 = ngx_array_push(& a);
#line 1832
    value = (ngx_str_t *)tmp___0;
    }
#line 1833
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1834
      return ((ngx_int_t )-1);
    }
    {
#line 1837
    *value = ngx_http_combined_fmt;
#line 1838
    fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1840
    tmp___1 = ngx_http_log_compile_format(cf, (ngx_array_t *)((void *)0), fmt->ops,
                                          & a, (ngx_uint_t )0);
    }
#line 1840
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1843
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1847
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 1849
  tmp___2 = ngx_array_push(& cmcf->phases[10].handlers);
#line 1849
  h = (ngx_http_handler_pt *)tmp___2;
  }
#line 1850
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1851
    return ((ngx_int_t )-1);
  }
#line 1854
  *h = & ngx_http_log_handler;
#line 1856
  return ((ngx_int_t )0);
}
}
#line 92 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_request_line(ngx_http_request_t *r , ngx_buf_t *b ) ;
#line 93
ngx_int_t ngx_http_parse_uri(ngx_http_request_t *r ) ;
#line 94
ngx_int_t ngx_http_parse_complex_uri(ngx_http_request_t *r , ngx_uint_t merge_slashes ) ;
#line 108
void ngx_http_split_args(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
static uint32_t usual[8]  = 
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
  {      4294958078U,      (uint32_t )2147432406,      4294967295U,      4294967295U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 103 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_request_line(ngx_http_request_t *r , ngx_buf_t *b ) 
{ 
  u_char c ;
  u_char ch ;
  u_char *p ;
  u_char *m ;
  enum __anonenum_state_67232969 state ;

  {
#line 137
  state = (enum __anonenum_state_67232969 )r->state;
#line 139
  p = b->pos;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )p < (unsigned long )b->last)) {
#line 139
      goto while_break;
    }
#line 140
    ch = *p;
    {
#line 145
    if ((unsigned int )state == 0U) {
#line 145
      goto case_0;
    }
#line 159
    if ((unsigned int )state == 1U) {
#line 159
      goto case_1;
    }
#line 280
    if ((unsigned int )state == 2U) {
#line 280
      goto case_2;
    }
#line 303
    if ((unsigned int )state == 3U) {
#line 303
      goto case_3___0;
    }
#line 320
    if ((unsigned int )state == 4U) {
#line 320
      goto case_4___0;
    }
#line 330
    if ((unsigned int )state == 5U) {
#line 330
      goto case_5___0;
    }
#line 340
    if ((unsigned int )state == 6U) {
#line 340
      goto case_6___0;
    }
#line 353
    if ((unsigned int )state == 7U) {
#line 353
      goto case_7___0;
    }
#line 366
    if ((unsigned int )state == 8U) {
#line 366
      goto case_8___0;
    }
#line 392
    if ((unsigned int )state == 9U) {
#line 392
      goto case_9___0;
    }
#line 433
    if ((unsigned int )state == 10U) {
#line 433
      goto case_10;
    }
#line 460
    if ((unsigned int )state == 11U) {
#line 460
      goto case_11;
    }
#line 482
    if ((unsigned int )state == 12U) {
#line 482
      goto case_12;
    }
#line 541
    if ((unsigned int )state == 13U) {
#line 541
      goto case_13___1;
    }
#line 602
    if ((unsigned int )state == 14U) {
#line 602
      goto case_14;
    }
#line 627
    if ((unsigned int )state == 15U) {
#line 627
      goto case_15;
    }
#line 656
    if ((unsigned int )state == 16U) {
#line 656
      goto case_16;
    }
#line 679
    if ((unsigned int )state == 17U) {
#line 679
      goto case_17;
    }
#line 689
    if ((unsigned int )state == 18U) {
#line 689
      goto case_18;
    }
#line 699
    if ((unsigned int )state == 19U) {
#line 699
      goto case_19;
    }
#line 709
    if ((unsigned int )state == 20U) {
#line 709
      goto case_20;
    }
#line 720
    if ((unsigned int )state == 21U) {
#line 720
      goto case_21;
    }
#line 735
    if ((unsigned int )state == 22U) {
#line 735
      goto case_22;
    }
#line 754
    if ((unsigned int )state == 23U) {
#line 754
      goto case_23;
    }
#line 764
    if ((unsigned int )state == 24U) {
#line 764
      goto case_24;
    }
#line 790
    if ((unsigned int )state == 25U) {
#line 790
      goto case_25;
    }
#line 805
    if ((unsigned int )state == 26U) {
#line 805
      goto case_26;
    }
#line 142
    goto switch_break;
    case_0: /* CIL Label */ 
#line 146
    r->request_start = p;
#line 148
    if ((int )ch == 13) {
#line 149
      goto switch_break;
    } else
#line 148
    if ((int )ch == 10) {
#line 149
      goto switch_break;
    }
#line 152
    if ((int )ch < 65) {
#line 152
      goto _L;
    } else
#line 152
    if ((int )ch > 90) {
      _L: /* CIL Label */ 
#line 152
      if ((int )ch != 95) {
#line 152
        if ((int )ch != 45) {
#line 153
          return ((ngx_int_t )10);
        }
      }
    }
#line 156
    state = (enum __anonenum_state_67232969 )1;
#line 157
    goto switch_break;
    case_1: /* CIL Label */ 
#line 160
    if ((int )ch == 32) {
#line 161
      r->method_end = p - 1;
#line 162
      m = r->request_start;
      {
#line 166
      if (p - m == 3L) {
#line 166
        goto case_3;
      }
#line 179
      if (p - m == 4L) {
#line 179
        goto case_4;
      }
#line 212
      if (p - m == 5L) {
#line 212
        goto case_5;
      }
#line 230
      if (p - m == 6L) {
#line 230
        goto case_6;
      }
#line 243
      if (p - m == 7L) {
#line 243
        goto case_7;
      }
#line 251
      if (p - m == 8L) {
#line 251
        goto case_8;
      }
#line 259
      if (p - m == 9L) {
#line 259
        goto case_9;
      }
#line 164
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 167
      if (*((uint32_t *)m) == (uint32_t )((((32 << 24) | (84 << 16)) | (69 << 8)) | 71)) {
#line 168
        r->method = (ngx_uint_t )2;
#line 169
        goto switch_break___0;
      }
#line 172
      if (*((uint32_t *)m) == (uint32_t )((((32 << 24) | (84 << 16)) | (85 << 8)) | 80)) {
#line 173
        r->method = (ngx_uint_t )16;
#line 174
        goto switch_break___0;
      }
#line 177
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 180
      if ((int )*(m + 1) == 79) {
#line 182
        if (*((uint32_t *)m) == (uint32_t )((((84 << 24) | (83 << 16)) | (79 << 8)) | 80)) {
#line 183
          r->method = (ngx_uint_t )8;
#line 184
          goto switch_break___0;
        }
#line 187
        if (*((uint32_t *)m) == (uint32_t )((((89 << 24) | (80 << 16)) | (79 << 8)) | 67)) {
#line 188
          r->method = (ngx_uint_t )128;
#line 189
          goto switch_break___0;
        }
#line 192
        if (*((uint32_t *)m) == (uint32_t )((((69 << 24) | (86 << 16)) | (79 << 8)) | 77)) {
#line 193
          r->method = (ngx_uint_t )256;
#line 194
          goto switch_break___0;
        }
#line 197
        if (*((uint32_t *)m) == (uint32_t )((((75 << 24) | (67 << 16)) | (79 << 8)) | 76)) {
#line 198
          r->method = (ngx_uint_t )4096;
#line 199
          goto switch_break___0;
        }
      } else
#line 204
      if (*((uint32_t *)m) == (uint32_t )((((68 << 24) | (65 << 16)) | (69 << 8)) | 72)) {
#line 205
        r->method = (ngx_uint_t )4;
#line 206
        goto switch_break___0;
      }
#line 210
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 213
      if (*((uint32_t *)m) == (uint32_t )((((79 << 24) | (67 << 16)) | (75 << 8)) | 77)) {
#line 213
        if ((int )*(m + 4) == 76) {
#line 214
          r->method = (ngx_uint_t )64;
#line 215
          goto switch_break___0;
        }
      }
#line 218
      if (*((uint32_t *)m) == (uint32_t )((((67 << 24) | (84 << 16)) | (65 << 8)) | 80)) {
#line 218
        if ((int )*(m + 4) == 72) {
#line 219
          r->method = (ngx_uint_t )16384;
#line 220
          goto switch_break___0;
        }
      }
#line 223
      if (*((uint32_t *)m) == (uint32_t )((((67 << 24) | (65 << 16)) | (82 << 8)) | 84)) {
#line 223
        if ((int )*(m + 4) == 69) {
#line 224
          r->method = (ngx_uint_t )32768;
#line 225
          goto switch_break___0;
        }
      }
#line 228
      goto switch_break___0;
      case_6: /* CIL Label */ 
#line 231
      if (*((uint32_t *)m) == (uint32_t )((((69 << 24) | (76 << 16)) | (69 << 8)) | 68)) {
#line 231
        if ((*((uint32_t *)m + 1) & 65535U) == (unsigned int )((69 << 8) | 84)) {
#line 232
          r->method = (ngx_uint_t )32;
#line 233
          goto switch_break___0;
        }
      }
#line 236
      if (*((uint32_t *)m) == (uint32_t )((((79 << 24) | (76 << 16)) | (78 << 8)) | 85)) {
#line 236
        if ((*((uint32_t *)m + 1) & 65535U) == (unsigned int )((75 << 8) | 67)) {
#line 237
          r->method = (ngx_uint_t )8192;
#line 238
          goto switch_break___0;
        }
      }
#line 241
      goto switch_break___0;
      case_7: /* CIL Label */ 
#line 244
      if (*((uint32_t *)m) == (uint32_t )((((73 << 24) | (84 << 16)) | (80 << 8)) | 79)) {
#line 244
        if (*((uint32_t *)m + 1) == (uint32_t )((((32 << 24) | (83 << 16)) | (78 << 8)) | 79)) {
#line 246
          r->method = (ngx_uint_t )512;
        }
      }
#line 249
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 252
      if (*((uint32_t *)m) == (uint32_t )((((80 << 24) | (79 << 16)) | (82 << 8)) | 80)) {
#line 252
        if (*((uint32_t *)m + 1) == (uint32_t )((((68 << 24) | (78 << 16)) | (73 << 8)) | 70)) {
#line 254
          r->method = (ngx_uint_t )1024;
        }
      }
#line 257
      goto switch_break___0;
      case_9: /* CIL Label */ 
#line 260
      if (*((uint32_t *)m) == (uint32_t )((((80 << 24) | (79 << 16)) | (82 << 8)) | 80)) {
#line 260
        if (*((uint32_t *)m + 1) == (uint32_t )((((67 << 24) | (84 << 16)) | (65 << 8)) | 80)) {
#line 260
          if ((int )*(m + 8) == 72) {
#line 263
            r->method = (ngx_uint_t )2048;
          }
        }
      }
#line 266
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 269
      state = (enum __anonenum_state_67232969 )2;
#line 270
      goto switch_break;
    }
#line 273
    if ((int )ch < 65) {
#line 273
      goto _L___0;
    } else
#line 273
    if ((int )ch > 90) {
      _L___0: /* CIL Label */ 
#line 273
      if ((int )ch != 95) {
#line 273
        if ((int )ch != 45) {
#line 274
          return ((ngx_int_t )10);
        }
      }
    }
#line 277
    goto switch_break;
    case_2: /* CIL Label */ 
#line 282
    if ((int )ch == 47) {
#line 283
      r->uri_start = p;
#line 284
      state = (enum __anonenum_state_67232969 )12;
#line 285
      goto switch_break;
    }
#line 288
    c = (u_char )((int )ch | 32);
#line 289
    if ((int )c >= 97) {
#line 289
      if ((int )c <= 122) {
#line 290
        r->schema_start = p;
#line 291
        state = (enum __anonenum_state_67232969 )3;
#line 292
        goto switch_break;
      }
    }
    {
#line 296
    if ((int )ch == 32) {
#line 296
      goto case_32;
    }
#line 298
    goto switch_default;
    case_32: /* CIL Label */ 
#line 297
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 299
    return ((ngx_int_t )11);
    switch_break___1: /* CIL Label */ ;
    }
#line 301
    goto switch_break;
    case_3___0: /* CIL Label */ 
#line 305
    c = (u_char )((int )ch | 32);
#line 306
    if ((int )c >= 97) {
#line 306
      if ((int )c <= 122) {
#line 307
        goto switch_break;
      }
    }
    {
#line 311
    if ((int )ch == 58) {
#line 311
      goto case_58;
    }
#line 315
    goto switch_default___0;
    case_58: /* CIL Label */ 
#line 312
    r->schema_end = p;
#line 313
    state = (enum __anonenum_state_67232969 )4;
#line 314
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 316
    return ((ngx_int_t )11);
    switch_break___2: /* CIL Label */ ;
    }
#line 318
    goto switch_break;
    case_4___0: /* CIL Label */ 
    {
#line 322
    if ((int )ch == 47) {
#line 322
      goto case_47;
    }
#line 325
    goto switch_default___1;
    case_47: /* CIL Label */ 
#line 323
    state = (enum __anonenum_state_67232969 )5;
#line 324
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
#line 326
    return ((ngx_int_t )11);
    switch_break___3: /* CIL Label */ ;
    }
#line 328
    goto switch_break;
    case_5___0: /* CIL Label */ 
    {
#line 332
    if ((int )ch == 47) {
#line 332
      goto case_47___0;
    }
#line 335
    goto switch_default___2;
    case_47___0: /* CIL Label */ 
#line 333
    state = (enum __anonenum_state_67232969 )6;
#line 334
    goto switch_break___4;
    switch_default___2: /* CIL Label */ 
#line 336
    return ((ngx_int_t )11);
    switch_break___4: /* CIL Label */ ;
    }
#line 338
    goto switch_break;
    case_6___0: /* CIL Label */ 
#line 342
    r->host_start = p;
#line 344
    if ((int )ch == 91) {
#line 345
      state = (enum __anonenum_state_67232969 )9;
#line 346
      goto switch_break;
    }
#line 349
    state = (enum __anonenum_state_67232969 )7;
    case_7___0: /* CIL Label */ 
#line 355
    c = (u_char )((int )ch | 32);
#line 356
    if ((int )c >= 97) {
#line 356
      if ((int )c <= 122) {
#line 357
        goto switch_break;
      }
    }
#line 360
    if ((int )ch >= 48) {
#line 360
      if ((int )ch <= 57) {
#line 361
        goto switch_break;
      } else {
#line 360
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 360
    if ((int )ch == 46) {
#line 361
      goto switch_break;
    } else
#line 360
    if ((int )ch == 45) {
#line 361
      goto switch_break;
    }
    case_8___0: /* CIL Label */ 
#line 368
    r->host_end = p;
    {
#line 371
    if ((int )ch == 58) {
#line 371
      goto case_58___0;
    }
#line 374
    if ((int )ch == 47) {
#line 374
      goto case_47___1;
    }
#line 378
    if ((int )ch == 32) {
#line 378
      goto case_32___0;
    }
#line 387
    goto switch_default___3;
    case_58___0: /* CIL Label */ 
#line 372
    state = (enum __anonenum_state_67232969 )10;
#line 373
    goto switch_break___5;
    case_47___1: /* CIL Label */ 
#line 375
    r->uri_start = p;
#line 376
    state = (enum __anonenum_state_67232969 )12;
#line 377
    goto switch_break___5;
    case_32___0: /* CIL Label */ 
#line 383
    r->uri_start = r->schema_end + 1;
#line 384
    r->uri_end = r->schema_end + 2;
#line 385
    state = (enum __anonenum_state_67232969 )11;
#line 386
    goto switch_break___5;
    switch_default___3: /* CIL Label */ 
#line 388
    return ((ngx_int_t )11);
    switch_break___5: /* CIL Label */ ;
    }
#line 390
    goto switch_break;
    case_9___0: /* CIL Label */ 
#line 394
    if ((int )ch >= 48) {
#line 394
      if ((int )ch <= 57) {
#line 395
        goto switch_break;
      }
    }
#line 398
    c = (u_char )((int )ch | 32);
#line 399
    if ((int )c >= 97) {
#line 399
      if ((int )c <= 122) {
#line 400
        goto switch_break;
      }
    }
    {
#line 404
    if ((int )ch == 58) {
#line 404
      goto case_58___1;
    }
#line 406
    if ((int )ch == 93) {
#line 406
      goto case_93;
    }
#line 412
    if ((int )ch == 126) {
#line 412
      goto case_126;
    }
#line 412
    if ((int )ch == 95) {
#line 412
      goto case_126;
    }
#line 412
    if ((int )ch == 46) {
#line 412
      goto case_126;
    }
#line 412
    if ((int )ch == 45) {
#line 412
      goto case_126;
    }
#line 425
    if ((int )ch == 61) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 59) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 44) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 43) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 42) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 41) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 40) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 39) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 38) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 36) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 33) {
#line 425
      goto case_61;
    }
#line 428
    goto switch_default___4;
    case_58___1: /* CIL Label */ 
#line 405
    goto switch_break___6;
    case_93: /* CIL Label */ 
#line 407
    state = (enum __anonenum_state_67232969 )8;
#line 408
    goto switch_break___6;
    case_126: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 414
    goto switch_break___6;
    case_61: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_33: /* CIL Label */ 
#line 427
    goto switch_break___6;
    switch_default___4: /* CIL Label */ 
#line 429
    return ((ngx_int_t )11);
    switch_break___6: /* CIL Label */ ;
    }
#line 431
    goto switch_break;
    case_10: /* CIL Label */ 
#line 434
    if ((int )ch >= 48) {
#line 434
      if ((int )ch <= 57) {
#line 435
        goto switch_break;
      }
    }
    {
#line 439
    if ((int )ch == 47) {
#line 439
      goto case_47___2;
    }
#line 444
    if ((int )ch == 32) {
#line 444
      goto case_32___1;
    }
#line 454
    goto switch_default___5;
    case_47___2: /* CIL Label */ 
#line 440
    r->port_end = p;
#line 441
    r->uri_start = p;
#line 442
    state = (enum __anonenum_state_67232969 )12;
#line 443
    goto switch_break___7;
    case_32___1: /* CIL Label */ 
#line 445
    r->port_end = p;
#line 450
    r->uri_start = r->schema_end + 1;
#line 451
    r->uri_end = r->schema_end + 2;
#line 452
    state = (enum __anonenum_state_67232969 )11;
#line 453
    goto switch_break___7;
    switch_default___5: /* CIL Label */ 
#line 455
    return ((ngx_int_t )11);
    switch_break___7: /* CIL Label */ ;
    }
#line 457
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 462
    if ((int )ch == 32) {
#line 462
      goto case_32___2;
    }
#line 464
    if ((int )ch == 13) {
#line 464
      goto case_13;
    }
#line 468
    if ((int )ch == 10) {
#line 468
      goto case_10___0;
    }
#line 471
    if ((int )ch == 72) {
#line 471
      goto case_72;
    }
#line 475
    goto switch_default___6;
    case_32___2: /* CIL Label */ 
#line 463
    goto switch_break___8;
    case_13: /* CIL Label */ 
#line 465
    r->http_minor = 9U;
#line 466
    state = (enum __anonenum_state_67232969 )26;
#line 467
    goto switch_break___8;
    case_10___0: /* CIL Label */ 
#line 469
    r->http_minor = 9U;
#line 470
    goto done;
    case_72: /* CIL Label */ 
#line 472
    r->http_protocol.data = p;
#line 473
    state = (enum __anonenum_state_67232969 )17;
#line 474
    goto switch_break___8;
    switch_default___6: /* CIL Label */ 
#line 476
    return ((ngx_int_t )11);
    switch_break___8: /* CIL Label */ ;
    }
#line 478
    goto switch_break;
    case_12: /* CIL Label */ 
#line 484
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 485
      state = (enum __anonenum_state_67232969 )13;
#line 486
      goto switch_break;
    }
    {
#line 490
    if ((int )ch == 32) {
#line 490
      goto case_32___3;
    }
#line 494
    if ((int )ch == 13) {
#line 494
      goto case_13___0;
    }
#line 499
    if ((int )ch == 10) {
#line 499
      goto case_10___1;
    }
#line 503
    if ((int )ch == 46) {
#line 503
      goto case_46___0;
    }
#line 507
    if ((int )ch == 37) {
#line 507
      goto case_37;
    }
#line 511
    if ((int )ch == 47) {
#line 511
      goto case_47___3;
    }
#line 521
    if ((int )ch == 63) {
#line 521
      goto case_63;
    }
#line 525
    if ((int )ch == 35) {
#line 525
      goto case_35;
    }
#line 529
    if ((int )ch == 43) {
#line 529
      goto case_43___0;
    }
#line 532
    if ((int )ch == 0) {
#line 532
      goto case_0___0;
    }
#line 534
    goto switch_default___7;
    case_32___3: /* CIL Label */ 
#line 491
    r->uri_end = p;
#line 492
    state = (enum __anonenum_state_67232969 )14;
#line 493
    goto switch_break___9;
    case_13___0: /* CIL Label */ 
#line 495
    r->uri_end = p;
#line 496
    r->http_minor = 9U;
#line 497
    state = (enum __anonenum_state_67232969 )26;
#line 498
    goto switch_break___9;
    case_10___1: /* CIL Label */ 
#line 500
    r->uri_end = p;
#line 501
    r->http_minor = 9U;
#line 502
    goto done;
    case_46___0: /* CIL Label */ 
#line 504
    r->complex_uri = 1U;
#line 505
    state = (enum __anonenum_state_67232969 )15;
#line 506
    goto switch_break___9;
    case_37: /* CIL Label */ 
#line 508
    r->quoted_uri = 1U;
#line 509
    state = (enum __anonenum_state_67232969 )15;
#line 510
    goto switch_break___9;
    case_47___3: /* CIL Label */ 
#line 512
    r->complex_uri = 1U;
#line 513
    state = (enum __anonenum_state_67232969 )15;
#line 514
    goto switch_break___9;
    case_63: /* CIL Label */ 
#line 522
    r->args_start = p + 1;
#line 523
    state = (enum __anonenum_state_67232969 )15;
#line 524
    goto switch_break___9;
    case_35: /* CIL Label */ 
#line 526
    r->complex_uri = 1U;
#line 527
    state = (enum __anonenum_state_67232969 )15;
#line 528
    goto switch_break___9;
    case_43___0: /* CIL Label */ 
#line 530
    r->plus_in_uri = 1U;
#line 531
    goto switch_break___9;
    case_0___0: /* CIL Label */ 
#line 533
    return ((ngx_int_t )11);
    switch_default___7: /* CIL Label */ 
#line 535
    state = (enum __anonenum_state_67232969 )13;
#line 536
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
#line 538
    goto switch_break;
    case_13___1: /* CIL Label */ 
#line 543
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 544
      goto switch_break;
    }
    {
#line 548
    if ((int )ch == 47) {
#line 548
      goto case_47___4;
    }
#line 559
    if ((int )ch == 46) {
#line 559
      goto case_46___1;
    }
#line 562
    if ((int )ch == 32) {
#line 562
      goto case_32___4;
    }
#line 566
    if ((int )ch == 13) {
#line 566
      goto case_13___2;
    }
#line 571
    if ((int )ch == 10) {
#line 571
      goto case_10___2;
    }
#line 581
    if ((int )ch == 37) {
#line 581
      goto case_37___0;
    }
#line 585
    if ((int )ch == 63) {
#line 585
      goto case_63___0;
    }
#line 589
    if ((int )ch == 35) {
#line 589
      goto case_35___0;
    }
#line 593
    if ((int )ch == 43) {
#line 593
      goto case_43___1;
    }
#line 596
    if ((int )ch == 0) {
#line 596
      goto case_0___1;
    }
#line 547
    goto switch_break___10;
    case_47___4: /* CIL Label */ 
#line 556
    r->uri_ext = (u_char *)((void *)0);
#line 557
    state = (enum __anonenum_state_67232969 )12;
#line 558
    goto switch_break___10;
    case_46___1: /* CIL Label */ 
#line 560
    r->uri_ext = p + 1;
#line 561
    goto switch_break___10;
    case_32___4: /* CIL Label */ 
#line 563
    r->uri_end = p;
#line 564
    state = (enum __anonenum_state_67232969 )14;
#line 565
    goto switch_break___10;
    case_13___2: /* CIL Label */ 
#line 567
    r->uri_end = p;
#line 568
    r->http_minor = 9U;
#line 569
    state = (enum __anonenum_state_67232969 )26;
#line 570
    goto switch_break___10;
    case_10___2: /* CIL Label */ 
#line 572
    r->uri_end = p;
#line 573
    r->http_minor = 9U;
#line 574
    goto done;
    case_37___0: /* CIL Label */ 
#line 582
    r->quoted_uri = 1U;
#line 583
    state = (enum __anonenum_state_67232969 )15;
#line 584
    goto switch_break___10;
    case_63___0: /* CIL Label */ 
#line 586
    r->args_start = p + 1;
#line 587
    state = (enum __anonenum_state_67232969 )15;
#line 588
    goto switch_break___10;
    case_35___0: /* CIL Label */ 
#line 590
    r->complex_uri = 1U;
#line 591
    state = (enum __anonenum_state_67232969 )15;
#line 592
    goto switch_break___10;
    case_43___1: /* CIL Label */ 
#line 594
    r->plus_in_uri = 1U;
#line 595
    goto switch_break___10;
    case_0___1: /* CIL Label */ 
#line 597
    return ((ngx_int_t )11);
    switch_break___10: /* CIL Label */ ;
    }
#line 599
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 604
    if ((int )ch == 32) {
#line 604
      goto case_32___5;
    }
#line 606
    if ((int )ch == 13) {
#line 606
      goto case_13___3;
    }
#line 610
    if ((int )ch == 10) {
#line 610
      goto case_10___3;
    }
#line 613
    if ((int )ch == 72) {
#line 613
      goto case_72___0;
    }
#line 617
    goto switch_default___8;
    case_32___5: /* CIL Label */ 
#line 605
    goto switch_break___11;
    case_13___3: /* CIL Label */ 
#line 607
    r->http_minor = 9U;
#line 608
    state = (enum __anonenum_state_67232969 )26;
#line 609
    goto switch_break___11;
    case_10___3: /* CIL Label */ 
#line 611
    r->http_minor = 9U;
#line 612
    goto done;
    case_72___0: /* CIL Label */ 
#line 614
    r->http_protocol.data = p;
#line 615
    state = (enum __anonenum_state_67232969 )17;
#line 616
    goto switch_break___11;
    switch_default___8: /* CIL Label */ 
#line 618
    r->space_in_uri = 1U;
#line 619
    state = (enum __anonenum_state_67232969 )13;
#line 620
    p --;
#line 621
    goto switch_break___11;
    switch_break___11: /* CIL Label */ ;
    }
#line 623
    goto switch_break;
    case_15: /* CIL Label */ 
#line 629
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 630
      goto switch_break;
    }
    {
#line 634
    if ((int )ch == 32) {
#line 634
      goto case_32___6;
    }
#line 638
    if ((int )ch == 13) {
#line 638
      goto case_13___4;
    }
#line 643
    if ((int )ch == 10) {
#line 643
      goto case_10___4;
    }
#line 647
    if ((int )ch == 35) {
#line 647
      goto case_35___1;
    }
#line 650
    if ((int )ch == 0) {
#line 650
      goto case_0___2;
    }
#line 633
    goto switch_break___12;
    case_32___6: /* CIL Label */ 
#line 635
    r->uri_end = p;
#line 636
    state = (enum __anonenum_state_67232969 )16;
#line 637
    goto switch_break___12;
    case_13___4: /* CIL Label */ 
#line 639
    r->uri_end = p;
#line 640
    r->http_minor = 9U;
#line 641
    state = (enum __anonenum_state_67232969 )26;
#line 642
    goto switch_break___12;
    case_10___4: /* CIL Label */ 
#line 644
    r->uri_end = p;
#line 645
    r->http_minor = 9U;
#line 646
    goto done;
    case_35___1: /* CIL Label */ 
#line 648
    r->complex_uri = 1U;
#line 649
    goto switch_break___12;
    case_0___2: /* CIL Label */ 
#line 651
    return ((ngx_int_t )11);
    switch_break___12: /* CIL Label */ ;
    }
#line 653
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 658
    if ((int )ch == 32) {
#line 658
      goto case_32___7;
    }
#line 660
    if ((int )ch == 13) {
#line 660
      goto case_13___5;
    }
#line 664
    if ((int )ch == 10) {
#line 664
      goto case_10___5;
    }
#line 667
    if ((int )ch == 72) {
#line 667
      goto case_72___1;
    }
#line 671
    goto switch_default___9;
    case_32___7: /* CIL Label */ 
#line 659
    goto switch_break___13;
    case_13___5: /* CIL Label */ 
#line 661
    r->http_minor = 9U;
#line 662
    state = (enum __anonenum_state_67232969 )26;
#line 663
    goto switch_break___13;
    case_10___5: /* CIL Label */ 
#line 665
    r->http_minor = 9U;
#line 666
    goto done;
    case_72___1: /* CIL Label */ 
#line 668
    r->http_protocol.data = p;
#line 669
    state = (enum __anonenum_state_67232969 )17;
#line 670
    goto switch_break___13;
    switch_default___9: /* CIL Label */ 
#line 672
    r->space_in_uri = 1U;
#line 673
    state = (enum __anonenum_state_67232969 )15;
#line 674
    p --;
#line 675
    goto switch_break___13;
    switch_break___13: /* CIL Label */ ;
    }
#line 677
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 681
    if ((int )ch == 84) {
#line 681
      goto case_84;
    }
#line 684
    goto switch_default___10;
    case_84: /* CIL Label */ 
#line 682
    state = (enum __anonenum_state_67232969 )18;
#line 683
    goto switch_break___14;
    switch_default___10: /* CIL Label */ 
#line 685
    return ((ngx_int_t )11);
    switch_break___14: /* CIL Label */ ;
    }
#line 687
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 691
    if ((int )ch == 84) {
#line 691
      goto case_84___0;
    }
#line 694
    goto switch_default___11;
    case_84___0: /* CIL Label */ 
#line 692
    state = (enum __anonenum_state_67232969 )19;
#line 693
    goto switch_break___15;
    switch_default___11: /* CIL Label */ 
#line 695
    return ((ngx_int_t )11);
    switch_break___15: /* CIL Label */ ;
    }
#line 697
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 701
    if ((int )ch == 80) {
#line 701
      goto case_80;
    }
#line 704
    goto switch_default___12;
    case_80: /* CIL Label */ 
#line 702
    state = (enum __anonenum_state_67232969 )20;
#line 703
    goto switch_break___16;
    switch_default___12: /* CIL Label */ 
#line 705
    return ((ngx_int_t )11);
    switch_break___16: /* CIL Label */ ;
    }
#line 707
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 711
    if ((int )ch == 47) {
#line 711
      goto case_47___5;
    }
#line 714
    goto switch_default___13;
    case_47___5: /* CIL Label */ 
#line 712
    state = (enum __anonenum_state_67232969 )21;
#line 713
    goto switch_break___17;
    switch_default___13: /* CIL Label */ 
#line 715
    return ((ngx_int_t )11);
    switch_break___17: /* CIL Label */ ;
    }
#line 717
    goto switch_break;
    case_21: /* CIL Label */ 
#line 721
    if ((int )ch < 49) {
#line 722
      return ((ngx_int_t )11);
    } else
#line 721
    if ((int )ch > 57) {
#line 722
      return ((ngx_int_t )11);
    }
#line 725
    r->http_major = (unsigned int )((int )ch - 48);
#line 727
    if (r->http_major > 1U) {
#line 728
      return ((ngx_int_t )12);
    }
#line 731
    state = (enum __anonenum_state_67232969 )22;
#line 732
    goto switch_break;
    case_22: /* CIL Label */ 
#line 736
    if ((int )ch == 46) {
#line 737
      state = (enum __anonenum_state_67232969 )23;
#line 738
      goto switch_break;
    }
#line 741
    if ((int )ch < 48) {
#line 742
      return ((ngx_int_t )11);
    } else
#line 741
    if ((int )ch > 57) {
#line 742
      return ((ngx_int_t )11);
    }
#line 745
    r->http_major = (r->http_major * 10U + (unsigned int )ch) - 48U;
#line 747
    if (r->http_major > 1U) {
#line 748
      return ((ngx_int_t )12);
    }
#line 751
    goto switch_break;
    case_23: /* CIL Label */ 
#line 755
    if ((int )ch < 48) {
#line 756
      return ((ngx_int_t )11);
    } else
#line 755
    if ((int )ch > 57) {
#line 756
      return ((ngx_int_t )11);
    }
#line 759
    r->http_minor = (unsigned int )((int )ch - 48);
#line 760
    state = (enum __anonenum_state_67232969 )24;
#line 761
    goto switch_break;
    case_24: /* CIL Label */ 
#line 765
    if ((int )ch == 13) {
#line 766
      state = (enum __anonenum_state_67232969 )26;
#line 767
      goto switch_break;
    }
#line 770
    if ((int )ch == 10) {
#line 771
      goto done;
    }
#line 774
    if ((int )ch == 32) {
#line 775
      state = (enum __anonenum_state_67232969 )25;
#line 776
      goto switch_break;
    }
#line 779
    if ((int )ch < 48) {
#line 780
      return ((ngx_int_t )11);
    } else
#line 779
    if ((int )ch > 57) {
#line 780
      return ((ngx_int_t )11);
    }
#line 783
    if (r->http_minor > 99U) {
#line 784
      return ((ngx_int_t )11);
    }
#line 787
    r->http_minor = (r->http_minor * 10U + (unsigned int )ch) - 48U;
#line 788
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 792
    if ((int )ch == 32) {
#line 792
      goto case_32___8;
    }
#line 794
    if ((int )ch == 13) {
#line 794
      goto case_13___6;
    }
#line 797
    if ((int )ch == 10) {
#line 797
      goto case_10___6;
    }
#line 799
    goto switch_default___14;
    case_32___8: /* CIL Label */ 
#line 793
    goto switch_break___18;
    case_13___6: /* CIL Label */ 
#line 795
    state = (enum __anonenum_state_67232969 )26;
#line 796
    goto switch_break___18;
    case_10___6: /* CIL Label */ 
#line 798
    goto done;
    switch_default___14: /* CIL Label */ 
#line 800
    return ((ngx_int_t )11);
    switch_break___18: /* CIL Label */ ;
    }
#line 802
    goto switch_break;
    case_26: /* CIL Label */ 
#line 806
    r->request_end = p - 1;
    {
#line 808
    if ((int )ch == 10) {
#line 808
      goto case_10___7;
    }
#line 810
    goto switch_default___15;
    case_10___7: /* CIL Label */ 
#line 809
    goto done;
    switch_default___15: /* CIL Label */ 
#line 811
    return ((ngx_int_t )11);
    switch_break___19: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 139
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 816
  b->pos = p;
#line 817
  r->state = (ngx_uint_t )state;
#line 819
  return ((ngx_int_t )-2);
  done: 
#line 823
  b->pos = p + 1;
#line 825
  if ((unsigned long )r->request_end == (unsigned long )((void *)0)) {
#line 826
    r->request_end = p;
  }
#line 829
  r->http_version = (ngx_uint_t )(r->http_major * 1000U + r->http_minor);
#line 830
  r->state = (ngx_uint_t )0;
#line 832
  if (r->http_version == 9UL) {
#line 832
    if (r->method != 2UL) {
#line 833
      return ((ngx_int_t )13);
    }
  }
#line 836
  return ((ngx_int_t )0);
}
}
#line 859 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
static u_char lowcase[256]  = 
#line 859
  {      (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'-',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'a',      (u_char )'b',      (u_char )'c', 
        (u_char )'d',      (u_char )'e',      (u_char )'f',      (u_char )'g', 
        (u_char )'h',      (u_char )'i',      (u_char )'j',      (u_char )'k', 
        (u_char )'l',      (u_char )'m',      (u_char )'n',      (u_char )'o', 
        (u_char )'p',      (u_char )'q',      (u_char )'r',      (u_char )'s', 
        (u_char )'t',      (u_char )'u',      (u_char )'v',      (u_char )'w', 
        (u_char )'x',      (u_char )'y',      (u_char )'z',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'a',      (u_char )'b',      (u_char )'c', 
        (u_char )'d',      (u_char )'e',      (u_char )'f',      (u_char )'g', 
        (u_char )'h',      (u_char )'i',      (u_char )'j',      (u_char )'k', 
        (u_char )'l',      (u_char )'m',      (u_char )'n',      (u_char )'o', 
        (u_char )'p',      (u_char )'q',      (u_char )'r',      (u_char )'s', 
        (u_char )'t',      (u_char )'u',      (u_char )'v',      (u_char )'w', 
        (u_char )'x',      (u_char )'y',      (u_char )'z',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000'};
#line 840 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_uint_t allow_underscores ) 
{ 
  u_char c ;
  u_char ch ;
  u_char *p ;
  ngx_uint_t hash ;
  ngx_uint_t i ;
  enum __anonenum_state_940472761 state ;
  ngx_uint_t tmp ;
  ngx_uint_t tmp___0 ;
  int tmp___1 ;

  {
#line 869
  state = (enum __anonenum_state_940472761 )r->state;
#line 870
  hash = r->header_hash;
#line 871
  i = r->lowcase_index;
#line 873
  p = b->pos;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if (! ((unsigned long )p < (unsigned long )b->last)) {
#line 873
      goto while_break;
    }
#line 874
    ch = *p;
    {
#line 879
    if ((unsigned int )state == 0U) {
#line 879
      goto case_0;
    }
#line 928
    if ((unsigned int )state == 1U) {
#line 928
      goto case_1;
    }
#line 991
    if ((unsigned int )state == 2U) {
#line 991
      goto case_2;
    }
#line 1014
    if ((unsigned int )state == 3U) {
#line 1014
      goto case_3;
    }
#line 1033
    if ((unsigned int )state == 4U) {
#line 1033
      goto case_4;
    }
#line 1051
    if ((unsigned int )state == 5U) {
#line 1051
      goto case_5;
    }
#line 1062
    if ((unsigned int )state == 6U) {
#line 1062
      goto case_6;
    }
#line 1074
    if ((unsigned int )state == 7U) {
#line 1074
      goto case_7;
    }
#line 876
    goto switch_break;
    case_0: /* CIL Label */ 
#line 880
    r->header_name_start = p;
#line 881
    r->invalid_header = 0U;
    {
#line 884
    if ((int )ch == 13) {
#line 884
      goto case_13;
    }
#line 888
    if ((int )ch == 10) {
#line 888
      goto case_10;
    }
#line 891
    goto switch_default;
    case_13: /* CIL Label */ 
#line 885
    r->header_end = p;
#line 886
    state = (enum __anonenum_state_940472761 )7;
#line 887
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 889
    r->header_end = p;
#line 890
    goto header_done;
    switch_default: /* CIL Label */ 
#line 892
    state = (enum __anonenum_state_940472761 )1;
#line 894
    c = lowcase[ch];
#line 896
    if (c) {
#line 897
      hash = (ngx_uint_t )c;
#line 898
      r->lowcase_header[0] = c;
#line 899
      i = (ngx_uint_t )1;
#line 900
      goto switch_break___0;
    }
#line 903
    if ((int )ch == 95) {
#line 904
      if (allow_underscores) {
#line 905
        hash = (ngx_uint_t )ch;
#line 906
        r->lowcase_header[0] = ch;
#line 907
        i = (ngx_uint_t )1;
      } else {
#line 910
        r->invalid_header = 1U;
      }
#line 913
      goto switch_break___0;
    }
#line 916
    if ((int )ch == 0) {
#line 917
      return ((ngx_int_t )14);
    }
#line 920
    r->invalid_header = 1U;
#line 922
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 925
    goto switch_break;
    case_1: /* CIL Label */ 
#line 929
    c = lowcase[ch];
#line 931
    if (c) {
#line 932
      hash = hash * 31UL + (ngx_uint_t )c;
#line 933
      tmp = i;
#line 933
      i ++;
#line 933
      r->lowcase_header[tmp] = c;
#line 934
      i &= 31UL;
#line 935
      goto switch_break;
    }
#line 938
    if ((int )ch == 95) {
#line 939
      if (allow_underscores) {
#line 940
        hash = hash * 31UL + (ngx_uint_t )ch;
#line 941
        tmp___0 = i;
#line 941
        i ++;
#line 941
        r->lowcase_header[tmp___0] = ch;
#line 942
        i &= 31UL;
      } else {
#line 945
        r->invalid_header = 1U;
      }
#line 948
      goto switch_break;
    }
#line 951
    if ((int )ch == 58) {
#line 952
      r->header_name_end = p;
#line 953
      state = (enum __anonenum_state_940472761 )2;
#line 954
      goto switch_break;
    }
#line 957
    if ((int )ch == 13) {
#line 958
      r->header_name_end = p;
#line 959
      r->header_start = p;
#line 960
      r->header_end = p;
#line 961
      state = (enum __anonenum_state_940472761 )6;
#line 962
      goto switch_break;
    }
#line 965
    if ((int )ch == 10) {
#line 966
      r->header_name_end = p;
#line 967
      r->header_start = p;
#line 968
      r->header_end = p;
#line 969
      goto done;
    }
#line 973
    if ((int )ch == 47) {
#line 973
      if (r->upstream) {
#line 973
        if (p - r->header_name_start == 4L) {
          {
#line 973
          tmp___1 = strncmp((char const   *)r->header_name_start, "HTTP", (size_t )4);
          }
#line 973
          if (tmp___1 == 0) {
#line 978
            state = (enum __anonenum_state_940472761 )5;
#line 979
            goto switch_break;
          }
        }
      }
    }
#line 982
    if ((int )ch == 0) {
#line 983
      return ((ngx_int_t )14);
    }
#line 986
    r->invalid_header = 1U;
#line 988
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 993
    if ((int )ch == 32) {
#line 993
      goto case_32;
    }
#line 995
    if ((int )ch == 13) {
#line 995
      goto case_13___0;
    }
#line 1000
    if ((int )ch == 10) {
#line 1000
      goto case_10___0;
    }
#line 1004
    if ((int )ch == 0) {
#line 1004
      goto case_0___0;
    }
#line 1006
    goto switch_default___0;
    case_32: /* CIL Label */ 
#line 994
    goto switch_break___1;
    case_13___0: /* CIL Label */ 
#line 996
    r->header_start = p;
#line 997
    r->header_end = p;
#line 998
    state = (enum __anonenum_state_940472761 )6;
#line 999
    goto switch_break___1;
    case_10___0: /* CIL Label */ 
#line 1001
    r->header_start = p;
#line 1002
    r->header_end = p;
#line 1003
    goto done;
    case_0___0: /* CIL Label */ 
#line 1005
    return ((ngx_int_t )14);
    switch_default___0: /* CIL Label */ 
#line 1007
    r->header_start = p;
#line 1008
    state = (enum __anonenum_state_940472761 )3;
#line 1009
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1011
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1016
    if ((int )ch == 32) {
#line 1016
      goto case_32___0;
    }
#line 1020
    if ((int )ch == 13) {
#line 1020
      goto case_13___1;
    }
#line 1024
    if ((int )ch == 10) {
#line 1024
      goto case_10___1;
    }
#line 1027
    if ((int )ch == 0) {
#line 1027
      goto case_0___1;
    }
#line 1015
    goto switch_break___2;
    case_32___0: /* CIL Label */ 
#line 1017
    r->header_end = p;
#line 1018
    state = (enum __anonenum_state_940472761 )4;
#line 1019
    goto switch_break___2;
    case_13___1: /* CIL Label */ 
#line 1021
    r->header_end = p;
#line 1022
    state = (enum __anonenum_state_940472761 )6;
#line 1023
    goto switch_break___2;
    case_10___1: /* CIL Label */ 
#line 1025
    r->header_end = p;
#line 1026
    goto done;
    case_0___1: /* CIL Label */ 
#line 1028
    return ((ngx_int_t )14);
    switch_break___2: /* CIL Label */ ;
    }
#line 1030
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1035
    if ((int )ch == 32) {
#line 1035
      goto case_32___1;
    }
#line 1037
    if ((int )ch == 13) {
#line 1037
      goto case_13___2;
    }
#line 1040
    if ((int )ch == 10) {
#line 1040
      goto case_10___2;
    }
#line 1042
    if ((int )ch == 0) {
#line 1042
      goto case_0___2;
    }
#line 1044
    goto switch_default___1;
    case_32___1: /* CIL Label */ 
#line 1036
    goto switch_break___3;
    case_13___2: /* CIL Label */ 
#line 1038
    state = (enum __anonenum_state_940472761 )6;
#line 1039
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
#line 1041
    goto done;
    case_0___2: /* CIL Label */ 
#line 1043
    return ((ngx_int_t )14);
    switch_default___1: /* CIL Label */ 
#line 1045
    state = (enum __anonenum_state_940472761 )3;
#line 1046
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1048
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1053
    if ((int )ch == 10) {
#line 1053
      goto case_10___3;
    }
#line 1056
    goto switch_default___2;
    case_10___3: /* CIL Label */ 
#line 1054
    state = (enum __anonenum_state_940472761 )0;
#line 1055
    goto switch_break___4;
    switch_default___2: /* CIL Label */ 
#line 1057
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1059
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1064
    if ((int )ch == 10) {
#line 1064
      goto case_10___4;
    }
#line 1066
    if ((int )ch == 13) {
#line 1066
      goto case_13___3;
    }
#line 1068
    goto switch_default___3;
    case_10___4: /* CIL Label */ 
#line 1065
    goto done;
    case_13___3: /* CIL Label */ 
#line 1067
    goto switch_break___5;
    switch_default___3: /* CIL Label */ 
#line 1069
    return ((ngx_int_t )14);
    switch_break___5: /* CIL Label */ ;
    }
#line 1071
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1076
    if ((int )ch == 10) {
#line 1076
      goto case_10___5;
    }
#line 1078
    goto switch_default___4;
    case_10___5: /* CIL Label */ 
#line 1077
    goto header_done;
    switch_default___4: /* CIL Label */ 
#line 1079
    return ((ngx_int_t )14);
    switch_break___6: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 873
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1084
  b->pos = p;
#line 1085
  r->state = (ngx_uint_t )state;
#line 1086
  r->header_hash = hash;
#line 1087
  r->lowcase_index = i;
#line 1089
  return ((ngx_int_t )-2);
  done: 
#line 1093
  b->pos = p + 1;
#line 1094
  r->state = (ngx_uint_t )0;
#line 1095
  r->header_hash = hash;
#line 1096
  r->lowcase_index = i;
#line 1098
  return ((ngx_int_t )0);
  header_done: 
#line 1102
  b->pos = p + 1;
#line 1103
  r->state = (ngx_uint_t )0;
#line 1105
  return ((ngx_int_t )1);
}
}
#line 1109 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_uri(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char ch ;
  enum __anonenum_state_43130286 state ;

  {
#line 1120
  state = (enum __anonenum_state_43130286 )0;
#line 1122
  p = r->uri_start;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    if (! ((unsigned long )p != (unsigned long )r->uri_end)) {
#line 1122
      goto while_break;
    }
#line 1124
    ch = *p;
    {
#line 1128
    if ((unsigned int )state == 0U) {
#line 1128
      goto case_0;
    }
#line 1138
    if ((unsigned int )state == 1U) {
#line 1138
      goto case_1;
    }
#line 1186
    if ((unsigned int )state == 2U) {
#line 1186
      goto case_2;
    }
#line 1235
    if ((unsigned int )state == 3U) {
#line 1235
      goto case_3;
    }
#line 1126
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1130
    if ((int )ch != 47) {
#line 1131
      return ((ngx_int_t )-1);
    }
#line 1134
    state = (enum __anonenum_state_43130286 )1;
#line 1135
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1140
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1141
      state = (enum __anonenum_state_43130286 )2;
#line 1142
      goto switch_break;
    }
    {
#line 1146
    if ((int )ch == 32) {
#line 1146
      goto case_32;
    }
#line 1150
    if ((int )ch == 46) {
#line 1150
      goto case_46;
    }
#line 1154
    if ((int )ch == 37) {
#line 1154
      goto case_37;
    }
#line 1158
    if ((int )ch == 47) {
#line 1158
      goto case_47;
    }
#line 1168
    if ((int )ch == 63) {
#line 1168
      goto case_63;
    }
#line 1172
    if ((int )ch == 35) {
#line 1172
      goto case_35;
    }
#line 1176
    if ((int )ch == 43) {
#line 1176
      goto case_43;
    }
#line 1179
    goto switch_default;
    case_32: /* CIL Label */ 
#line 1147
    r->space_in_uri = 1U;
#line 1148
    state = (enum __anonenum_state_43130286 )2;
#line 1149
    goto switch_break___0;
    case_46: /* CIL Label */ 
#line 1151
    r->complex_uri = 1U;
#line 1152
    state = (enum __anonenum_state_43130286 )3;
#line 1153
    goto switch_break___0;
    case_37: /* CIL Label */ 
#line 1155
    r->quoted_uri = 1U;
#line 1156
    state = (enum __anonenum_state_43130286 )3;
#line 1157
    goto switch_break___0;
    case_47: /* CIL Label */ 
#line 1159
    r->complex_uri = 1U;
#line 1160
    state = (enum __anonenum_state_43130286 )3;
#line 1161
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 1169
    r->args_start = p + 1;
#line 1170
    state = (enum __anonenum_state_43130286 )3;
#line 1171
    goto switch_break___0;
    case_35: /* CIL Label */ 
#line 1173
    r->complex_uri = 1U;
#line 1174
    state = (enum __anonenum_state_43130286 )3;
#line 1175
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 1177
    r->plus_in_uri = 1U;
#line 1178
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1180
    state = (enum __anonenum_state_43130286 )2;
#line 1181
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1183
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1188
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1189
      goto switch_break;
    }
    {
#line 1193
    if ((int )ch == 47) {
#line 1193
      goto case_47___0;
    }
#line 1204
    if ((int )ch == 46) {
#line 1204
      goto case_46___0;
    }
#line 1207
    if ((int )ch == 32) {
#line 1207
      goto case_32___0;
    }
#line 1216
    if ((int )ch == 37) {
#line 1216
      goto case_37___0;
    }
#line 1220
    if ((int )ch == 63) {
#line 1220
      goto case_63___0;
    }
#line 1224
    if ((int )ch == 35) {
#line 1224
      goto case_35___0;
    }
#line 1228
    if ((int )ch == 43) {
#line 1228
      goto case_43___0;
    }
#line 1192
    goto switch_break___1;
    case_47___0: /* CIL Label */ 
#line 1201
    r->uri_ext = (u_char *)((void *)0);
#line 1202
    state = (enum __anonenum_state_43130286 )1;
#line 1203
    goto switch_break___1;
    case_46___0: /* CIL Label */ 
#line 1205
    r->uri_ext = p + 1;
#line 1206
    goto switch_break___1;
    case_32___0: /* CIL Label */ 
#line 1208
    r->space_in_uri = 1U;
#line 1209
    goto switch_break___1;
    case_37___0: /* CIL Label */ 
#line 1217
    r->quoted_uri = 1U;
#line 1218
    state = (enum __anonenum_state_43130286 )3;
#line 1219
    goto switch_break___1;
    case_63___0: /* CIL Label */ 
#line 1221
    r->args_start = p + 1;
#line 1222
    state = (enum __anonenum_state_43130286 )3;
#line 1223
    goto switch_break___1;
    case_35___0: /* CIL Label */ 
#line 1225
    r->complex_uri = 1U;
#line 1226
    state = (enum __anonenum_state_43130286 )3;
#line 1227
    goto switch_break___1;
    case_43___0: /* CIL Label */ 
#line 1229
    r->plus_in_uri = 1U;
#line 1230
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1232
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1237
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1238
      goto switch_break;
    }
    {
#line 1242
    if ((int )ch == 32) {
#line 1242
      goto case_32___1;
    }
#line 1245
    if ((int )ch == 35) {
#line 1245
      goto case_35___1;
    }
#line 1241
    goto switch_break___2;
    case_32___1: /* CIL Label */ 
#line 1243
    r->space_in_uri = 1U;
#line 1244
    goto switch_break___2;
    case_35___1: /* CIL Label */ 
#line 1246
    r->complex_uri = 1U;
#line 1247
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1249
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1122
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  return ((ngx_int_t )0);
}
}
#line 1257 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_complex_uri(ngx_http_request_t *r , ngx_uint_t merge_slashes ) 
{ 
  u_char c ;
  u_char ch ;
  u_char decoded ;
  u_char *p ;
  u_char *u ;
  enum __anonenum_state_861259954 state ;
  enum __anonenum_state_861259954 quoted_state ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  u_char *tmp___23 ;
  u_char *tmp___24 ;
  u_char *tmp___25 ;
  u_char *tmp___26 ;
  u_char *tmp___27 ;

  {
#line 1271
  decoded = (u_char )'\000';
#line 1272
  quoted_state = (enum __anonenum_state_861259954 )0;
#line 1275
  state = (enum __anonenum_state_861259954 )0;
#line 1276
  p = r->uri_start;
#line 1277
  u = r->uri.data;
#line 1278
  r->uri_ext = (u_char *)((void *)0);
#line 1279
  r->args_start = (u_char *)((void *)0);
#line 1281
  tmp = p;
#line 1281
  p ++;
#line 1281
  ch = *tmp;
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1283
    if (! ((unsigned long )p <= (unsigned long )r->uri_end)) {
#line 1283
      goto while_break;
    }
    {
#line 1296
    if ((unsigned int )state == 0U) {
#line 1296
      goto case_0;
    }
#line 1365
    if ((unsigned int )state == 1U) {
#line 1365
      goto case_1;
    }
#line 1409
    if ((unsigned int )state == 2U) {
#line 1409
      goto case_2;
    }
#line 1451
    if ((unsigned int )state == 3U) {
#line 1451
      goto case_3;
    }
#line 1499
    if ((unsigned int )state == 4U) {
#line 1499
      goto case_4;
    }
#line 1519
    if ((unsigned int )state == 5U) {
#line 1519
      goto case_5;
    }
#line 1294
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1298
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1299
      tmp___0 = u;
#line 1299
      u ++;
#line 1299
      *tmp___0 = ch;
#line 1300
      tmp___1 = p;
#line 1300
      p ++;
#line 1300
      ch = *tmp___1;
#line 1301
      goto switch_break;
    }
    {
#line 1329
    if ((int )ch == 47) {
#line 1329
      goto case_47;
    }
#line 1341
    if ((int )ch == 37) {
#line 1341
      goto case_37;
    }
#line 1345
    if ((int )ch == 63) {
#line 1345
      goto case_63;
    }
#line 1348
    if ((int )ch == 35) {
#line 1348
      goto case_35;
    }
#line 1350
    if ((int )ch == 46) {
#line 1350
      goto case_46;
    }
#line 1354
    if ((int )ch == 43) {
#line 1354
      goto case_43;
    }
#line 1357
    goto switch_default;
    case_47: /* CIL Label */ 
#line 1337
    r->uri_ext = (u_char *)((void *)0);
#line 1338
    state = (enum __anonenum_state_861259954 )1;
#line 1339
    tmp___2 = u;
#line 1339
    u ++;
#line 1339
    *tmp___2 = ch;
#line 1340
    goto switch_break___0;
    case_37: /* CIL Label */ 
#line 1342
    quoted_state = state;
#line 1343
    state = (enum __anonenum_state_861259954 )4;
#line 1344
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 1346
    r->args_start = p;
#line 1347
    goto args;
    case_35: /* CIL Label */ 
#line 1349
    goto done;
    case_46: /* CIL Label */ 
#line 1351
    r->uri_ext = u + 1;
#line 1352
    tmp___3 = u;
#line 1352
    u ++;
#line 1352
    *tmp___3 = ch;
#line 1353
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 1355
    r->plus_in_uri = 1U;
    switch_default: /* CIL Label */ 
#line 1358
    tmp___4 = u;
#line 1358
    u ++;
#line 1358
    *tmp___4 = ch;
#line 1359
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1362
    tmp___5 = p;
#line 1362
    p ++;
#line 1362
    ch = *tmp___5;
#line 1363
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1367
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1368
      state = (enum __anonenum_state_861259954 )0;
#line 1369
      tmp___6 = u;
#line 1369
      u ++;
#line 1369
      *tmp___6 = ch;
#line 1370
      tmp___7 = p;
#line 1370
      p ++;
#line 1370
      ch = *tmp___7;
#line 1371
      goto switch_break;
    }
    {
#line 1379
    if ((int )ch == 47) {
#line 1379
      goto case_47___0;
    }
#line 1384
    if ((int )ch == 46) {
#line 1384
      goto case_46___0;
    }
#line 1388
    if ((int )ch == 37) {
#line 1388
      goto case_37___0;
    }
#line 1392
    if ((int )ch == 63) {
#line 1392
      goto case_63___0;
    }
#line 1395
    if ((int )ch == 35) {
#line 1395
      goto case_35___0;
    }
#line 1397
    if ((int )ch == 43) {
#line 1397
      goto case_43___0;
    }
#line 1400
    goto switch_default___0;
    case_47___0: /* CIL Label */ 
#line 1380
    if (! merge_slashes) {
#line 1381
      tmp___8 = u;
#line 1381
      u ++;
#line 1381
      *tmp___8 = ch;
    }
#line 1383
    goto switch_break___1;
    case_46___0: /* CIL Label */ 
#line 1385
    state = (enum __anonenum_state_861259954 )2;
#line 1386
    tmp___9 = u;
#line 1386
    u ++;
#line 1386
    *tmp___9 = ch;
#line 1387
    goto switch_break___1;
    case_37___0: /* CIL Label */ 
#line 1389
    quoted_state = state;
#line 1390
    state = (enum __anonenum_state_861259954 )4;
#line 1391
    goto switch_break___1;
    case_63___0: /* CIL Label */ 
#line 1393
    r->args_start = p;
#line 1394
    goto args;
    case_35___0: /* CIL Label */ 
#line 1396
    goto done;
    case_43___0: /* CIL Label */ 
#line 1398
    r->plus_in_uri = 1U;
    switch_default___0: /* CIL Label */ 
#line 1401
    state = (enum __anonenum_state_861259954 )0;
#line 1402
    tmp___10 = u;
#line 1402
    u ++;
#line 1402
    *tmp___10 = ch;
#line 1403
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1406
    tmp___11 = p;
#line 1406
    p ++;
#line 1406
    ch = *tmp___11;
#line 1407
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1411
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1412
      state = (enum __anonenum_state_861259954 )0;
#line 1413
      tmp___12 = u;
#line 1413
      u ++;
#line 1413
      *tmp___12 = ch;
#line 1414
      tmp___13 = p;
#line 1414
      p ++;
#line 1414
      ch = *tmp___13;
#line 1415
      goto switch_break;
    }
    {
#line 1422
    if ((int )ch == 47) {
#line 1422
      goto case_47___1;
    }
#line 1426
    if ((int )ch == 46) {
#line 1426
      goto case_46___1;
    }
#line 1430
    if ((int )ch == 37) {
#line 1430
      goto case_37___1;
    }
#line 1434
    if ((int )ch == 63) {
#line 1434
      goto case_63___1;
    }
#line 1437
    if ((int )ch == 35) {
#line 1437
      goto case_35___1;
    }
#line 1439
    if ((int )ch == 43) {
#line 1439
      goto case_43___1;
    }
#line 1442
    goto switch_default___1;
    case_47___1: /* CIL Label */ 
#line 1423
    state = (enum __anonenum_state_861259954 )1;
#line 1424
    u --;
#line 1425
    goto switch_break___2;
    case_46___1: /* CIL Label */ 
#line 1427
    state = (enum __anonenum_state_861259954 )3;
#line 1428
    tmp___14 = u;
#line 1428
    u ++;
#line 1428
    *tmp___14 = ch;
#line 1429
    goto switch_break___2;
    case_37___1: /* CIL Label */ 
#line 1431
    quoted_state = state;
#line 1432
    state = (enum __anonenum_state_861259954 )4;
#line 1433
    goto switch_break___2;
    case_63___1: /* CIL Label */ 
#line 1435
    r->args_start = p;
#line 1436
    goto args;
    case_35___1: /* CIL Label */ 
#line 1438
    goto done;
    case_43___1: /* CIL Label */ 
#line 1440
    r->plus_in_uri = 1U;
    switch_default___1: /* CIL Label */ 
#line 1443
    state = (enum __anonenum_state_861259954 )0;
#line 1444
    tmp___15 = u;
#line 1444
    u ++;
#line 1444
    *tmp___15 = ch;
#line 1445
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1448
    tmp___16 = p;
#line 1448
    p ++;
#line 1448
    ch = *tmp___16;
#line 1449
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1453
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1454
      state = (enum __anonenum_state_861259954 )0;
#line 1455
      tmp___17 = u;
#line 1455
      u ++;
#line 1455
      *tmp___17 = ch;
#line 1456
      tmp___18 = p;
#line 1456
      p ++;
#line 1456
      ch = *tmp___18;
#line 1457
      goto switch_break;
    }
    {
#line 1464
    if ((int )ch == 47) {
#line 1464
      goto case_47___2;
    }
#line 1478
    if ((int )ch == 37) {
#line 1478
      goto case_37___2;
    }
#line 1482
    if ((int )ch == 63) {
#line 1482
      goto case_63___2;
    }
#line 1485
    if ((int )ch == 35) {
#line 1485
      goto case_35___2;
    }
#line 1487
    if ((int )ch == 43) {
#line 1487
      goto case_43___2;
    }
#line 1490
    goto switch_default___2;
    case_47___2: /* CIL Label */ 
#line 1465
    state = (enum __anonenum_state_861259954 )1;
#line 1466
    u -= 5;
    {
#line 1467
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1468
      if ((unsigned long )u < (unsigned long )r->uri.data) {
#line 1469
        return ((ngx_int_t )11);
      }
#line 1471
      if ((int )*u == 47) {
#line 1472
        u ++;
#line 1473
        goto while_break___0;
      }
#line 1475
      u --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1477
    goto switch_break___3;
    case_37___2: /* CIL Label */ 
#line 1479
    quoted_state = state;
#line 1480
    state = (enum __anonenum_state_861259954 )4;
#line 1481
    goto switch_break___3;
    case_63___2: /* CIL Label */ 
#line 1483
    r->args_start = p;
#line 1484
    goto args;
    case_35___2: /* CIL Label */ 
#line 1486
    goto done;
    case_43___2: /* CIL Label */ 
#line 1488
    r->plus_in_uri = 1U;
    switch_default___2: /* CIL Label */ 
#line 1491
    state = (enum __anonenum_state_861259954 )0;
#line 1492
    tmp___19 = u;
#line 1492
    u ++;
#line 1492
    *tmp___19 = ch;
#line 1493
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1496
    tmp___20 = p;
#line 1496
    p ++;
#line 1496
    ch = *tmp___20;
#line 1497
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1500
    r->quoted_uri = 1U;
#line 1502
    if ((int )ch >= 48) {
#line 1502
      if ((int )ch <= 57) {
#line 1503
        decoded = (u_char )((int )ch - 48);
#line 1504
        state = (enum __anonenum_state_861259954 )5;
#line 1505
        tmp___21 = p;
#line 1505
        p ++;
#line 1505
        ch = *tmp___21;
#line 1506
        goto switch_break;
      }
    }
#line 1509
    c = (u_char )((int )ch | 32);
#line 1510
    if ((int )c >= 97) {
#line 1510
      if ((int )c <= 102) {
#line 1511
        decoded = (u_char )(((int )c - 97) + 10);
#line 1512
        state = (enum __anonenum_state_861259954 )5;
#line 1513
        tmp___22 = p;
#line 1513
        p ++;
#line 1513
        ch = *tmp___22;
#line 1514
        goto switch_break;
      }
    }
#line 1517
    return ((ngx_int_t )11);
    case_5: /* CIL Label */ 
#line 1520
    if ((int )ch >= 48) {
#line 1520
      if ((int )ch <= 57) {
#line 1521
        ch = (u_char )((((int )decoded << 4) + (int )ch) - 48);
#line 1523
        if ((int )ch == 37) {
#line 1523
          goto _L;
        } else
#line 1523
        if ((int )ch == 35) {
          _L: /* CIL Label */ 
#line 1524
          state = (enum __anonenum_state_861259954 )0;
#line 1525
          tmp___23 = u;
#line 1525
          u ++;
#line 1525
          *tmp___23 = ch;
#line 1526
          tmp___24 = p;
#line 1526
          p ++;
#line 1526
          ch = *tmp___24;
#line 1527
          goto switch_break;
        } else
#line 1529
        if ((int )ch == 0) {
#line 1530
          return ((ngx_int_t )11);
        }
#line 1533
        state = quoted_state;
#line 1534
        goto switch_break;
      }
    }
#line 1537
    c = (u_char )((int )ch | 32);
#line 1538
    if ((int )c >= 97) {
#line 1538
      if ((int )c <= 102) {
#line 1539
        ch = (u_char )(((((int )decoded << 4) + (int )c) - 97) + 10);
#line 1541
        if ((int )ch == 63) {
#line 1542
          state = (enum __anonenum_state_861259954 )0;
#line 1543
          tmp___25 = u;
#line 1543
          u ++;
#line 1543
          *tmp___25 = ch;
#line 1544
          tmp___26 = p;
#line 1544
          p ++;
#line 1544
          ch = *tmp___26;
#line 1545
          goto switch_break;
        } else
#line 1547
        if ((int )ch == 43) {
#line 1548
          r->plus_in_uri = 1U;
        }
#line 1551
        state = quoted_state;
#line 1552
        goto switch_break;
      }
    }
#line 1555
    return ((ngx_int_t )11);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1561
  r->uri.len = (size_t___0 )(u - r->uri.data);
#line 1563
  if (r->uri_ext) {
#line 1564
    r->exten.len = (size_t___0 )(u - r->uri_ext);
#line 1565
    r->exten.data = r->uri_ext;
  }
#line 1568
  r->uri_ext = (u_char *)((void *)0);
#line 1570
  return ((ngx_int_t )0);
  args: 
  {
#line 1574
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1574
    if (! ((unsigned long )p < (unsigned long )r->uri_end)) {
#line 1574
      goto while_break___1;
    }
#line 1575
    tmp___27 = p;
#line 1575
    p ++;
#line 1575
    if ((int )*tmp___27 != 35) {
#line 1576
      goto while_continue___1;
    }
#line 1579
    r->args.len = (size_t___0 )((p - 1) - r->args_start);
#line 1580
    r->args.data = r->args_start;
#line 1581
    r->args_start = (u_char *)((void *)0);
#line 1583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1586
  r->uri.len = (size_t___0 )(u - r->uri.data);
#line 1588
  if (r->uri_ext) {
#line 1589
    r->exten.len = (size_t___0 )(u - r->uri_ext);
#line 1590
    r->exten.data = r->uri_ext;
  }
#line 1593
  r->uri_ext = (u_char *)((void *)0);
#line 1595
  return ((ngx_int_t )0);
}
}
#line 1599 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_status_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_status_t *status ) 
{ 
  u_char ch ;
  u_char *p ;
  enum __anonenum_state_695160250 state ;

  {
#line 1621
  state = (enum __anonenum_state_695160250 )r->state;
#line 1623
  p = b->pos;
  {
#line 1623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1623
    if (! ((unsigned long )p < (unsigned long )b->last)) {
#line 1623
      goto while_break;
    }
#line 1624
    ch = *p;
    {
#line 1629
    if ((unsigned int )state == 0U) {
#line 1629
      goto case_0;
    }
#line 1639
    if ((unsigned int )state == 1U) {
#line 1639
      goto case_1;
    }
#line 1649
    if ((unsigned int )state == 2U) {
#line 1649
      goto case_2;
    }
#line 1659
    if ((unsigned int )state == 3U) {
#line 1659
      goto case_3;
    }
#line 1669
    if ((unsigned int )state == 4U) {
#line 1669
      goto case_4;
    }
#line 1680
    if ((unsigned int )state == 5U) {
#line 1680
      goto case_5;
    }
#line 1690
    if ((unsigned int )state == 6U) {
#line 1690
      goto case_6;
    }
#line 1708
    if ((unsigned int )state == 7U) {
#line 1708
      goto case_7;
    }
#line 1718
    if ((unsigned int )state == 8U) {
#line 1718
      goto case_8;
    }
#line 1736
    if ((unsigned int )state == 9U) {
#line 1736
      goto case_9;
    }
#line 1755
    if ((unsigned int )state == 10U) {
#line 1755
      goto case_10;
    }
#line 1774
    if ((unsigned int )state == 11U) {
#line 1774
      goto case_11;
    }
#line 1786
    if ((unsigned int )state == 12U) {
#line 1786
      goto case_12;
    }
#line 1626
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1631
    if ((int )ch == 72) {
#line 1631
      goto case_72;
    }
#line 1634
    goto switch_default;
    case_72: /* CIL Label */ 
#line 1632
    state = (enum __anonenum_state_695160250 )1;
#line 1633
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1635
    return ((ngx_int_t )-1);
    switch_break___0: /* CIL Label */ ;
    }
#line 1637
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1641
    if ((int )ch == 84) {
#line 1641
      goto case_84;
    }
#line 1644
    goto switch_default___0;
    case_84: /* CIL Label */ 
#line 1642
    state = (enum __anonenum_state_695160250 )2;
#line 1643
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 1645
    return ((ngx_int_t )-1);
    switch_break___1: /* CIL Label */ ;
    }
#line 1647
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1651
    if ((int )ch == 84) {
#line 1651
      goto case_84___0;
    }
#line 1654
    goto switch_default___1;
    case_84___0: /* CIL Label */ 
#line 1652
    state = (enum __anonenum_state_695160250 )3;
#line 1653
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 1655
    return ((ngx_int_t )-1);
    switch_break___2: /* CIL Label */ ;
    }
#line 1657
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1661
    if ((int )ch == 80) {
#line 1661
      goto case_80;
    }
#line 1664
    goto switch_default___2;
    case_80: /* CIL Label */ 
#line 1662
    state = (enum __anonenum_state_695160250 )4;
#line 1663
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 1665
    return ((ngx_int_t )-1);
    switch_break___3: /* CIL Label */ ;
    }
#line 1667
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1671
    if ((int )ch == 47) {
#line 1671
      goto case_47;
    }
#line 1674
    goto switch_default___3;
    case_47: /* CIL Label */ 
#line 1672
    state = (enum __anonenum_state_695160250 )5;
#line 1673
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 1675
    return ((ngx_int_t )-1);
    switch_break___4: /* CIL Label */ ;
    }
#line 1677
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1681
    if ((int )ch < 49) {
#line 1682
      return ((ngx_int_t )-1);
    } else
#line 1681
    if ((int )ch > 57) {
#line 1682
      return ((ngx_int_t )-1);
    }
#line 1685
    r->http_major = (unsigned int )((int )ch - 48);
#line 1686
    state = (enum __anonenum_state_695160250 )6;
#line 1687
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1691
    if ((int )ch == 46) {
#line 1692
      state = (enum __anonenum_state_695160250 )7;
#line 1693
      goto switch_break;
    }
#line 1696
    if ((int )ch < 48) {
#line 1697
      return ((ngx_int_t )-1);
    } else
#line 1696
    if ((int )ch > 57) {
#line 1697
      return ((ngx_int_t )-1);
    }
#line 1700
    if (r->http_major > 99U) {
#line 1701
      return ((ngx_int_t )-1);
    }
#line 1704
    r->http_major = (r->http_major * 10U + (unsigned int )ch) - 48U;
#line 1705
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1709
    if ((int )ch < 48) {
#line 1710
      return ((ngx_int_t )-1);
    } else
#line 1709
    if ((int )ch > 57) {
#line 1710
      return ((ngx_int_t )-1);
    }
#line 1713
    r->http_minor = (unsigned int )((int )ch - 48);
#line 1714
    state = (enum __anonenum_state_695160250 )8;
#line 1715
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1719
    if ((int )ch == 32) {
#line 1720
      state = (enum __anonenum_state_695160250 )9;
#line 1721
      goto switch_break;
    }
#line 1724
    if ((int )ch < 48) {
#line 1725
      return ((ngx_int_t )-1);
    } else
#line 1724
    if ((int )ch > 57) {
#line 1725
      return ((ngx_int_t )-1);
    }
#line 1728
    if (r->http_minor > 99U) {
#line 1729
      return ((ngx_int_t )-1);
    }
#line 1732
    r->http_minor = (r->http_minor * 10U + (unsigned int )ch) - 48U;
#line 1733
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1737
    if ((int )ch == 32) {
#line 1738
      goto switch_break;
    }
#line 1741
    if ((int )ch < 48) {
#line 1742
      return ((ngx_int_t )-1);
    } else
#line 1741
    if ((int )ch > 57) {
#line 1742
      return ((ngx_int_t )-1);
    }
#line 1745
    status->code = (status->code * 10UL + (ngx_uint_t )ch) - 48UL;
#line 1747
    (status->count) ++;
#line 1747
    if (status->count == 3UL) {
#line 1748
      state = (enum __anonenum_state_695160250 )10;
#line 1749
      status->start = p - 2;
    }
#line 1752
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1757
    if ((int )ch == 32) {
#line 1757
      goto case_32;
    }
#line 1760
    if ((int )ch == 46) {
#line 1760
      goto case_46;
    }
#line 1763
    if ((int )ch == 13) {
#line 1763
      goto case_13;
    }
#line 1766
    if ((int )ch == 10) {
#line 1766
      goto case_10___0;
    }
#line 1768
    goto switch_default___4;
    case_32: /* CIL Label */ 
#line 1758
    state = (enum __anonenum_state_695160250 )11;
#line 1759
    goto switch_break___5;
    case_46: /* CIL Label */ 
#line 1761
    state = (enum __anonenum_state_695160250 )11;
#line 1762
    goto switch_break___5;
    case_13: /* CIL Label */ 
#line 1764
    state = (enum __anonenum_state_695160250 )12;
#line 1765
    goto switch_break___5;
    case_10___0: /* CIL Label */ 
#line 1767
    goto done;
    switch_default___4: /* CIL Label */ 
#line 1769
    return ((ngx_int_t )-1);
    switch_break___5: /* CIL Label */ ;
    }
#line 1771
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1776
    if ((int )ch == 13) {
#line 1776
      goto case_13___0;
    }
#line 1780
    if ((int )ch == 10) {
#line 1780
      goto case_10___1;
    }
#line 1775
    goto switch_break___6;
    case_13___0: /* CIL Label */ 
#line 1777
    state = (enum __anonenum_state_695160250 )12;
#line 1779
    goto switch_break___6;
    case_10___1: /* CIL Label */ 
#line 1781
    goto done;
    switch_break___6: /* CIL Label */ ;
    }
#line 1783
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1787
    status->end = p - 1;
    {
#line 1789
    if ((int )ch == 10) {
#line 1789
      goto case_10___2;
    }
#line 1791
    goto switch_default___5;
    case_10___2: /* CIL Label */ 
#line 1790
    goto done;
    switch_default___5: /* CIL Label */ 
#line 1792
    return ((ngx_int_t )-1);
    switch_break___7: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 1623
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1797
  b->pos = p;
#line 1798
  r->state = (ngx_uint_t )state;
#line 1800
  return ((ngx_int_t )-2);
  done: 
#line 1804
  b->pos = p + 1;
#line 1806
  if ((unsigned long )status->end == (unsigned long )((void *)0)) {
#line 1807
    status->end = p;
  }
#line 1810
  status->http_version = (ngx_uint_t )(r->http_major * 1000U + r->http_minor);
#line 1811
  r->state = (ngx_uint_t )0;
#line 1813
  return ((ngx_int_t )0);
}
}
#line 1817 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                                    ngx_uint_t *flags ) 
{ 
  u_char ch ;
  u_char *p ;
  u_char *src ;
  u_char *dst ;
  size_t___0 len ;
  ngx_uint_t quoted ;
  u_char *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 1825
  len = uri___0->len;
#line 1826
  p = uri___0->data;
#line 1827
  quoted = (ngx_uint_t )0;
#line 1829
  if (len == 0UL) {
#line 1830
    goto unsafe;
  } else
#line 1829
  if ((int )*(p + 0) == 63) {
#line 1830
    goto unsafe;
  }
#line 1833
  if ((int )*(p + 0) == 46) {
#line 1833
    if (len > 1UL) {
#line 1833
      if ((int )*(p + 1) == 46) {
#line 1833
        if (len == 2UL) {
#line 1836
          goto unsafe;
        } else
#line 1833
        if ((int )*(p + 2) == 47) {
#line 1836
          goto unsafe;
        }
      }
    }
  }
  {
#line 1839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1839
    if (! len) {
#line 1839
      goto while_break;
    }
#line 1841
    tmp = p;
#line 1841
    p ++;
#line 1841
    ch = *tmp;
#line 1843
    if ((int )ch == 37) {
#line 1844
      quoted = (ngx_uint_t )1;
#line 1845
      goto __Cont;
    }
#line 1848
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1849
      goto __Cont;
    }
#line 1852
    if ((int )ch == 63) {
#line 1853
      args___0->len = len - 1UL;
#line 1854
      args___0->data = p;
#line 1855
      uri___0->len -= len;
#line 1857
      goto while_break;
    }
#line 1860
    if ((int )ch == 0) {
#line 1861
      goto unsafe;
    }
#line 1864
    if ((int )ch == 47) {
#line 1864
      if (len > 2UL) {
#line 1868
        if ((int )*(p + 0) == 46) {
#line 1868
          if ((int )*(p + 1) == 46) {
#line 1868
            if (len == 3UL) {
#line 1871
              goto unsafe;
            } else
#line 1868
            if ((int )*(p + 2) == 47) {
#line 1871
              goto unsafe;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1839
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1876
  if (quoted) {
    {
#line 1880
    src = uri___0->data;
#line 1882
    tmp___0 = ngx_pnalloc(r->pool, uri___0->len);
#line 1882
    dst = (u_char *)tmp___0;
    }
#line 1883
    if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1884
      return ((ngx_int_t )-1);
    }
    {
#line 1887
    uri___0->data = dst;
#line 1889
    ngx_unescape_uri(& dst, & src, uri___0->len, (ngx_uint_t )0);
#line 1891
    uri___0->len = (size_t___0 )(dst - uri___0->data);
#line 1896
    len = uri___0->len;
#line 1897
    p = uri___0->data;
    }
#line 1899
    if ((int )*(p + 0) == 46) {
#line 1899
      if (len > 1UL) {
#line 1899
        if ((int )*(p + 1) == 46) {
#line 1899
          if (len == 2UL) {
#line 1902
            goto unsafe;
          } else
#line 1899
          if ((int )*(p + 2) == 47) {
#line 1902
            goto unsafe;
          }
        }
      }
    }
    {
#line 1905
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1905
      if (! len) {
#line 1905
        goto while_break___0;
      }
#line 1907
      tmp___1 = p;
#line 1907
      p ++;
#line 1907
      ch = *tmp___1;
#line 1909
      if ((int )ch == 0) {
#line 1910
        goto unsafe;
      }
#line 1913
      if ((int )ch == 47) {
#line 1913
        if (len > 2UL) {
#line 1917
          if ((int )*(p + 0) == 46) {
#line 1917
            if ((int )*(p + 1) == 46) {
#line 1917
              if (len == 3UL) {
#line 1920
                goto unsafe;
              } else
#line 1917
              if ((int )*(p + 2) == 47) {
#line 1920
                goto unsafe;
              }
            }
          }
        }
      }
#line 1905
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1926
  return ((ngx_int_t )0);
  unsafe: 
#line 1930
  if (*flags & 1UL) {
#line 1931
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1931
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unsafe URI \"%V\" was detected",
                         uri___0);
      }
    }
  }
#line 1935
  return ((ngx_int_t )-1);
}
}
#line 1939 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers , ngx_str_t *name ,
                                            ngx_str_t *value ) 
{ 
  ngx_uint_t i ;
  u_char *start ;
  u_char *last ;
  u_char *end ;
  u_char ch ;
  ngx_table_elt_t **h ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 1947
  h = (ngx_table_elt_t **)headers->elts;
#line 1949
  i = (ngx_uint_t )0;
  {
#line 1949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1949
    if (! (i < headers->nelts)) {
#line 1949
      goto while_break;
    }
#line 1954
    if (name->len > (*(h + i))->value.len) {
#line 1955
      goto __Cont;
    }
#line 1958
    start = (*(h + i))->value.data;
#line 1959
    end = (*(h + i))->value.data + (*(h + i))->value.len;
    {
#line 1961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1961
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 1961
        goto while_break___0;
      }
      {
#line 1963
      tmp = ngx_strncasecmp(start, name->data, name->len);
      }
#line 1963
      if (tmp != 0L) {
#line 1964
        goto skip;
      }
#line 1967
      start += name->len;
      {
#line 1967
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1967
        if ((unsigned long )start < (unsigned long )end) {
#line 1967
          if (! ((int )*start == 32)) {
#line 1967
            goto while_break___1;
          }
        } else {
#line 1967
          goto while_break___1;
        }
#line 1967
        start ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1971
      if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1972
        if ((unsigned long )start == (unsigned long )end) {
#line 1973
          return ((ngx_int_t )i);
        } else
#line 1972
        if ((int )*start == 44) {
#line 1973
          return ((ngx_int_t )i);
        }
#line 1976
        goto skip;
      }
#line 1979
      if ((unsigned long )start == (unsigned long )end) {
#line 1981
        goto skip;
      } else {
#line 1979
        tmp___0 = start;
#line 1979
        start ++;
#line 1979
        if ((int )*tmp___0 != 61) {
#line 1981
          goto skip;
        }
      }
      {
#line 1984
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1984
        if ((unsigned long )start < (unsigned long )end) {
#line 1984
          if (! ((int )*start == 32)) {
#line 1984
            goto while_break___2;
          }
        } else {
#line 1984
          goto while_break___2;
        }
#line 1984
        start ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1986
      last = start;
      {
#line 1986
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1986
        if ((unsigned long )last < (unsigned long )end) {
#line 1986
          if (! ((int )*last != 59)) {
#line 1986
            goto while_break___3;
          }
        } else {
#line 1986
          goto while_break___3;
        }
#line 1986
        last ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1990
      value->len = (size_t___0 )(last - start);
#line 1991
      value->data = start;
#line 1993
      return ((ngx_int_t )i);
      skip: 
      {
#line 1997
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1997
        if (! ((unsigned long )start < (unsigned long )end)) {
#line 1997
          goto while_break___4;
        }
#line 1998
        tmp___1 = start;
#line 1998
        start ++;
#line 1998
        ch = *tmp___1;
#line 1999
        if ((int )ch == 59) {
#line 2000
          goto while_break___4;
        } else
#line 1999
        if ((int )ch == 44) {
#line 2000
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2004
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2004
        if ((unsigned long )start < (unsigned long )end) {
#line 2004
          if (! ((int )*start == 32)) {
#line 2004
            goto while_break___5;
          }
        } else {
#line 2004
          goto while_break___5;
        }
#line 2004
        start ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1949
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2008
  return ((ngx_int_t )-5);
}
}
#line 2012 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers , ngx_str_t *name ,
                                          ngx_str_t *value ) 
{ 
  ngx_uint_t i ;
  u_char *start ;
  u_char *last ;
  u_char *end ;
  ngx_table_elt_t **h ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;

  {
#line 2020
  h = (ngx_table_elt_t **)headers->elts;
#line 2022
  i = (ngx_uint_t )0;
  {
#line 2022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2022
    if (! (i < headers->nelts)) {
#line 2022
      goto while_break;
    }
#line 2027
    if (name->len >= (*(h + i))->value.len) {
#line 2028
      goto __Cont;
    }
    {
#line 2031
    start = (*(h + i))->value.data;
#line 2032
    end = (*(h + i))->value.data + (*(h + i))->value.len;
#line 2034
    tmp = ngx_strncasecmp(start, name->data, name->len);
    }
#line 2034
    if (tmp != 0L) {
#line 2035
      goto __Cont;
    }
#line 2038
    start += name->len;
    {
#line 2038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2038
      if ((unsigned long )start < (unsigned long )end) {
#line 2038
        if (! ((int )*start == 32)) {
#line 2038
          goto while_break___0;
        }
      } else {
#line 2038
        goto while_break___0;
      }
#line 2038
      start ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2042
    if ((unsigned long )start == (unsigned long )end) {
#line 2044
      goto __Cont;
    } else {
#line 2042
      tmp___0 = start;
#line 2042
      start ++;
#line 2042
      if ((int )*tmp___0 != 61) {
#line 2044
        goto __Cont;
      }
    }
    {
#line 2047
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2047
      if ((unsigned long )start < (unsigned long )end) {
#line 2047
        if (! ((int )*start == 32)) {
#line 2047
          goto while_break___1;
        }
      } else {
#line 2047
        goto while_break___1;
      }
#line 2047
      start ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2049
    last = start;
    {
#line 2049
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2049
      if ((unsigned long )last < (unsigned long )end) {
#line 2049
        if (! ((int )*last != 59)) {
#line 2049
          goto while_break___2;
        }
      } else {
#line 2049
        goto while_break___2;
      }
#line 2049
      last ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2053
    value->len = (size_t___0 )(last - start);
#line 2054
    value->data = start;
#line 2056
    return ((ngx_int_t )i);
    __Cont: /* CIL Label */ 
#line 2022
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2059
  return ((ngx_int_t )-5);
}
}
#line 2063 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_arg(ngx_http_request_t *r , u_char *name , size_t___0 len , ngx_str_t *value ) 
{ 
  u_char *p ;
  u_char *last ;

  {
#line 2068
  if (r->args.len == 0UL) {
#line 2069
    return ((ngx_int_t )-5);
  }
#line 2072
  p = r->args.data;
#line 2073
  last = p + r->args.len;
  {
#line 2075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2075
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2075
      goto while_break;
    }
    {
#line 2079
    p = ngx_strlcasestrn(p, last - 1, name, len - 1UL);
    }
#line 2081
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2082
      return ((ngx_int_t )-5);
    }
#line 2085
    if ((unsigned long )p == (unsigned long )r->args.data) {
#line 2085
      goto _L;
    } else
#line 2085
    if ((int )*(p - 1) == 38) {
      _L: /* CIL Label */ 
#line 2085
      if ((int )*(p + len) == 61) {
        {
#line 2087
        value->data = (p + len) + 1;
#line 2089
        p = ngx_strlchr(p, last, (u_char )'&');
        }
#line 2091
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2092
          p = r->args.data + r->args.len;
        }
#line 2095
        value->len = (size_t___0 )(p - value->data);
#line 2097
        return ((ngx_int_t )0);
      }
    }
#line 2075
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2101
  return ((ngx_int_t )-5);
}
}
#line 2105 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
void ngx_http_split_args(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ) 
{ 
  u_char *p ;
  u_char *last ;

  {
  {
#line 2110
  last = uri___0->data + uri___0->len;
#line 2112
  p = ngx_strlchr(uri___0->data, last, (u_char )'?');
  }
#line 2114
  if (p) {
#line 2115
    uri___0->len = (size_t___0 )(p - uri___0->data);
#line 2116
    p ++;
#line 2117
    args___0->len = (size_t___0 )(last - p);
#line 2118
    args___0->data = p;
  } else {
#line 2121
    args___0->len = (size_t___0 )0;
  }
#line 2123
  return;
}
}
#line 2126 "/tmp/nginx-1.13.2/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_chunked(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_chunked_t *ctx ) 
{ 
  u_char *pos ;
  u_char ch ;
  u_char c ;
  ngx_int_t rc ;
  enum __anonenum_state_962966958 state ;
  off_t tmp ;

  {
#line 2148
  state = (enum __anonenum_state_962966958 )ctx->state;
#line 2150
  if ((unsigned int )state == 4U) {
#line 2150
    if (ctx->size == 0L) {
#line 2151
      state = (enum __anonenum_state_962966958 )5;
    }
  }
#line 2154
  rc = (ngx_int_t )-2;
#line 2156
  pos = b->pos;
  {
#line 2156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2156
    if (! ((unsigned long )pos < (unsigned long )b->last)) {
#line 2156
      goto while_break;
    }
#line 2158
    ch = *pos;
    {
#line 2165
    if ((unsigned int )state == 0U) {
#line 2165
      goto case_0;
    }
#line 2182
    if ((unsigned int )state == 1U) {
#line 2182
      goto case_1;
    }
#line 2238
    if ((unsigned int )state == 2U) {
#line 2238
      goto case_2;
    }
#line 2248
    if ((unsigned int )state == 3U) {
#line 2248
      goto case_3;
    }
#line 2255
    if ((unsigned int )state == 4U) {
#line 2255
      goto case_4;
    }
#line 2259
    if ((unsigned int )state == 5U) {
#line 2259
      goto case_5;
    }
#line 2269
    if ((unsigned int )state == 6U) {
#line 2269
      goto case_6;
    }
#line 2276
    if ((unsigned int )state == 7U) {
#line 2276
      goto case_7;
    }
#line 2286
    if ((unsigned int )state == 8U) {
#line 2286
      goto case_8;
    }
#line 2293
    if ((unsigned int )state == 9U) {
#line 2293
      goto case_9___1;
    }
#line 2305
    if ((unsigned int )state == 10U) {
#line 2305
      goto case_10___5;
    }
#line 2311
    if ((unsigned int )state == 11U) {
#line 2311
      goto case_11;
    }
#line 2321
    if ((unsigned int )state == 12U) {
#line 2321
      goto case_12;
    }
#line 2163
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2166
    if ((int )ch >= 48) {
#line 2166
      if ((int )ch <= 57) {
#line 2167
        state = (enum __anonenum_state_962966958 )1;
#line 2168
        ctx->size = (off_t )((int )ch - 48);
#line 2169
        goto switch_break;
      }
    }
#line 2172
    c = (u_char )((int )ch | 32);
#line 2174
    if ((int )c >= 97) {
#line 2174
      if ((int )c <= 102) {
#line 2175
        state = (enum __anonenum_state_962966958 )1;
#line 2176
        ctx->size = (off_t )(((int )c - 97) + 10);
#line 2177
        goto switch_break;
      }
    }
#line 2180
    goto invalid;
    case_1: /* CIL Label */ 
#line 2183
    if ((long long )ctx->size > 576460752303423487LL) {
#line 2184
      goto invalid;
    }
#line 2187
    if ((int )ch >= 48) {
#line 2187
      if ((int )ch <= 57) {
#line 2188
        ctx->size = ctx->size * 16L + (off_t )((int )ch - 48);
#line 2189
        goto switch_break;
      }
    }
#line 2192
    c = (u_char )((int )ch | 32);
#line 2194
    if ((int )c >= 97) {
#line 2194
      if ((int )c <= 102) {
#line 2195
        ctx->size = ctx->size * 16L + (off_t )(((int )c - 97) + 10);
#line 2196
        goto switch_break;
      }
    }
#line 2199
    if (ctx->size == 0L) {
      {
#line 2202
      if ((int )ch == 13) {
#line 2202
        goto case_13;
      }
#line 2205
      if ((int )ch == 10) {
#line 2205
        goto case_10;
      }
#line 2210
      if ((int )ch == 9) {
#line 2210
        goto case_9;
      }
#line 2210
      if ((int )ch == 32) {
#line 2210
        goto case_9;
      }
#line 2210
      if ((int )ch == 59) {
#line 2210
        goto case_9;
      }
#line 2213
      goto switch_default;
      case_13: /* CIL Label */ 
#line 2203
      state = (enum __anonenum_state_962966958 )8;
#line 2204
      goto switch_break___0;
      case_10: /* CIL Label */ 
#line 2206
      state = (enum __anonenum_state_962966958 )9;
#line 2207
      goto switch_break___0;
      case_9: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_59: /* CIL Label */ 
#line 2211
      state = (enum __anonenum_state_962966958 )7;
#line 2212
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 2214
      goto invalid;
      switch_break___0: /* CIL Label */ ;
      }
#line 2217
      goto switch_break;
    }
    {
#line 2221
    if ((int )ch == 13) {
#line 2221
      goto case_13___0;
    }
#line 2224
    if ((int )ch == 10) {
#line 2224
      goto case_10___0;
    }
#line 2229
    if ((int )ch == 9) {
#line 2229
      goto case_9___0;
    }
#line 2229
    if ((int )ch == 32) {
#line 2229
      goto case_9___0;
    }
#line 2229
    if ((int )ch == 59) {
#line 2229
      goto case_9___0;
    }
#line 2232
    goto switch_default___0;
    case_13___0: /* CIL Label */ 
#line 2222
    state = (enum __anonenum_state_962966958 )3;
#line 2223
    goto switch_break___1;
    case_10___0: /* CIL Label */ 
#line 2225
    state = (enum __anonenum_state_962966958 )4;
#line 2226
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
    case_59___0: /* CIL Label */ 
#line 2230
    state = (enum __anonenum_state_962966958 )2;
#line 2231
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 2233
    goto invalid;
    switch_break___1: /* CIL Label */ ;
    }
#line 2236
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2240
    if ((int )ch == 13) {
#line 2240
      goto case_13___1;
    }
#line 2243
    if ((int )ch == 10) {
#line 2243
      goto case_10___1;
    }
#line 2239
    goto switch_break___2;
    case_13___1: /* CIL Label */ 
#line 2241
    state = (enum __anonenum_state_962966958 )3;
#line 2242
    goto switch_break___2;
    case_10___1: /* CIL Label */ 
#line 2244
    state = (enum __anonenum_state_962966958 )4;
    switch_break___2: /* CIL Label */ ;
    }
#line 2246
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2249
    if ((int )ch == 10) {
#line 2250
      state = (enum __anonenum_state_962966958 )4;
#line 2251
      goto switch_break;
    }
#line 2253
    goto invalid;
    case_4: /* CIL Label */ 
#line 2256
    rc = (ngx_int_t )0;
#line 2257
    goto data;
    case_5: /* CIL Label */ 
    {
#line 2261
    if ((int )ch == 13) {
#line 2261
      goto case_13___2;
    }
#line 2264
    if ((int )ch == 10) {
#line 2264
      goto case_10___2;
    }
#line 2260
    goto switch_break___3;
    case_13___2: /* CIL Label */ 
#line 2262
    state = (enum __anonenum_state_962966958 )6;
#line 2263
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
#line 2265
    state = (enum __anonenum_state_962966958 )0;
    switch_break___3: /* CIL Label */ ;
    }
#line 2267
    goto switch_break;
    case_6: /* CIL Label */ 
#line 2270
    if ((int )ch == 10) {
#line 2271
      state = (enum __anonenum_state_962966958 )0;
#line 2272
      goto switch_break;
    }
#line 2274
    goto invalid;
    case_7: /* CIL Label */ 
    {
#line 2278
    if ((int )ch == 13) {
#line 2278
      goto case_13___3;
    }
#line 2281
    if ((int )ch == 10) {
#line 2281
      goto case_10___3;
    }
#line 2277
    goto switch_break___4;
    case_13___3: /* CIL Label */ 
#line 2279
    state = (enum __anonenum_state_962966958 )8;
#line 2280
    goto switch_break___4;
    case_10___3: /* CIL Label */ 
#line 2282
    state = (enum __anonenum_state_962966958 )9;
    switch_break___4: /* CIL Label */ ;
    }
#line 2284
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2287
    if ((int )ch == 10) {
#line 2288
      state = (enum __anonenum_state_962966958 )9;
#line 2289
      goto switch_break;
    }
#line 2291
    goto invalid;
    case_9___1: /* CIL Label */ 
    {
#line 2295
    if ((int )ch == 13) {
#line 2295
      goto case_13___4;
    }
#line 2298
    if ((int )ch == 10) {
#line 2298
      goto case_10___4;
    }
#line 2300
    goto switch_default___1;
    case_13___4: /* CIL Label */ 
#line 2296
    state = (enum __anonenum_state_962966958 )10;
#line 2297
    goto switch_break___5;
    case_10___4: /* CIL Label */ 
#line 2299
    goto done;
    switch_default___1: /* CIL Label */ 
#line 2301
    state = (enum __anonenum_state_962966958 )11;
    switch_break___5: /* CIL Label */ ;
    }
#line 2303
    goto switch_break;
    case_10___5: /* CIL Label */ 
#line 2306
    if ((int )ch == 10) {
#line 2307
      goto done;
    }
#line 2309
    goto invalid;
    case_11: /* CIL Label */ 
    {
#line 2313
    if ((int )ch == 13) {
#line 2313
      goto case_13___5;
    }
#line 2316
    if ((int )ch == 10) {
#line 2316
      goto case_10___6;
    }
#line 2312
    goto switch_break___6;
    case_13___5: /* CIL Label */ 
#line 2314
    state = (enum __anonenum_state_962966958 )12;
#line 2315
    goto switch_break___6;
    case_10___6: /* CIL Label */ 
#line 2317
    state = (enum __anonenum_state_962966958 )9;
    switch_break___6: /* CIL Label */ ;
    }
#line 2319
    goto switch_break;
    case_12: /* CIL Label */ 
#line 2322
    if ((int )ch == 10) {
#line 2323
      state = (enum __anonenum_state_962966958 )9;
#line 2324
      goto switch_break;
    }
#line 2326
    goto invalid;
    switch_break: /* CIL Label */ ;
    }
#line 2156
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  data: 
#line 2333
  ctx->state = (ngx_uint_t )state;
#line 2334
  b->pos = pos;
#line 2336
  if ((long long )ctx->size > 9223372036854775802LL) {
#line 2337
    goto invalid;
  }
  {
#line 2342
  if ((unsigned int )state == 0U) {
#line 2342
    goto case_0___0;
  }
#line 2345
  if ((unsigned int )state == 1U) {
#line 2345
    goto case_1___0;
  }
#line 2351
  if ((unsigned int )state == 3U) {
#line 2351
    goto case_3___0;
  }
#line 2351
  if ((unsigned int )state == 2U) {
#line 2351
    goto case_3___0;
  }
#line 2354
  if ((unsigned int )state == 4U) {
#line 2354
    goto case_4___0;
  }
#line 2358
  if ((unsigned int )state == 6U) {
#line 2358
    goto case_6___0;
  }
#line 2358
  if ((unsigned int )state == 5U) {
#line 2358
    goto case_6___0;
  }
#line 2362
  if ((unsigned int )state == 8U) {
#line 2362
    goto case_8___0;
  }
#line 2362
  if ((unsigned int )state == 7U) {
#line 2362
    goto case_8___0;
  }
#line 2366
  if ((unsigned int )state == 10U) {
#line 2366
    goto case_10___7;
  }
#line 2366
  if ((unsigned int )state == 9U) {
#line 2366
    goto case_10___7;
  }
#line 2370
  if ((unsigned int )state == 12U) {
#line 2370
    goto case_12___0;
  }
#line 2370
  if ((unsigned int )state == 11U) {
#line 2370
    goto case_12___0;
  }
#line 2340
  goto switch_break___7;
  case_0___0: /* CIL Label */ 
#line 2343
  ctx->length = (off_t )3;
#line 2344
  goto switch_break___7;
  case_1___0: /* CIL Label */ 
#line 2346
  if (ctx->size) {
#line 2346
    tmp = ctx->size + 4L;
  } else {
#line 2346
    tmp = (off_t )1;
  }
#line 2346
  ctx->length = 1L + tmp;
#line 2349
  goto switch_break___7;
  case_3___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 2352
  ctx->length = (1L + ctx->size) + 4L;
#line 2353
  goto switch_break___7;
  case_4___0: /* CIL Label */ 
#line 2355
  ctx->length = ctx->size + 4L;
#line 2356
  goto switch_break___7;
  case_6___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 2359
  ctx->length = (off_t )4;
#line 2360
  goto switch_break___7;
  case_8___0: /* CIL Label */ 
  case_7___0: /* CIL Label */ 
#line 2363
  ctx->length = (off_t )2;
#line 2364
  goto switch_break___7;
  case_10___7: /* CIL Label */ 
  case_9___2: /* CIL Label */ 
#line 2367
  ctx->length = (off_t )1;
#line 2368
  goto switch_break___7;
  case_12___0: /* CIL Label */ 
  case_11___0: /* CIL Label */ 
#line 2371
  ctx->length = (off_t )2;
#line 2372
  goto switch_break___7;
  switch_break___7: /* CIL Label */ ;
  }
#line 2376
  return (rc);
  done: 
#line 2380
  ctx->state = (ngx_uint_t )0;
#line 2381
  b->pos = pos + 1;
#line 2383
  return ((ngx_int_t )-4);
  invalid: 
#line 2387
  return ((ngx_int_t )-1);
}
}
#line 215 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 250
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 150 "src/core/ngx_string.h"
u_char *ngx_snprintf(u_char *buf , size_t___0 max , char const   *fmt  , ...) ;
#line 162
u_char *ngx_strstrn(u_char *s1 , char *s2 , size_t___0 n ) ;
#line 176
time_t ngx_atotm(u_char *line , size_t___0 n ) ;
#line 82 "src/os/unix/ngx_os.h"
ngx_uint_t ngx_tcp_nodelay_and_tcp_nopush ;
#line 223 "src/core/ngx_connection.h"
void ngx_reusable_connection(ngx_connection_t *c , ngx_uint_t reusable ) ;
#line 19 "src/core/ngx_proxy_protocol.h"
u_char *ngx_proxy_protocol_read(ngx_connection_t *c , u_char *buf , u_char *last ) ;
#line 596 "src/http/ngx_http_request.h"
ngx_http_header_t ngx_http_headers_in[23] ;
#line 471 "src/event/ngx_event.h"
ngx_uint_t ngx_use_accept_mutex ;
#line 85 "src/http/ngx_http.h"
void ngx_http_init_connection(ngx_connection_t *c ) ;
#line 86
void ngx_http_close_connection(ngx_connection_t *c ) ;
#line 114
ngx_http_request_t *ngx_http_create_request(ngx_connection_t *c ) ;
#line 115
ngx_int_t ngx_http_process_request_uri(ngx_http_request_t *r ) ;
#line 116
ngx_int_t ngx_http_process_request_header(ngx_http_request_t *r ) ;
#line 117
void ngx_http_process_request(ngx_http_request_t *r ) ;
#line 119
void ngx_http_handler(ngx_http_request_t *r ) ;
#line 124
void ngx_http_free_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 126
void ngx_http_empty_handler(ngx_event_t *wev ) ;
#line 141
ngx_int_t ngx_http_special_response_handler(ngx_http_request_t *r , ngx_int_t error ) ;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_wait_request_handler(ngx_event_t *rev ) ;
#line 14
static void ngx_http_process_request_line(ngx_event_t *rev ) ;
#line 15
static void ngx_http_process_request_headers(ngx_event_t *rev ) ;
#line 16
static ssize_t ngx_http_read_request_header(ngx_http_request_t *r ) ;
#line 17
static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r , ngx_uint_t request_line ) ;
#line 20
static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                              ngx_uint_t offset ) ;
#line 22
static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 24
static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 26
static ngx_int_t ngx_http_process_host(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                       ngx_uint_t offset ) ;
#line 28
static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) ;
#line 30
static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) ;
#line 33
static ngx_int_t ngx_http_validate_host(ngx_str_t *host , ngx_pool_t *pool , ngx_uint_t alloc ) ;
#line 35
static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r , ngx_str_t *host ) ;
#line 37
static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c , ngx_http_virtual_names_t *virtual_names ,
                                              ngx_str_t *host , ngx_http_request_t *r ,
                                              ngx_http_core_srv_conf_t **cscfp ) ;
#line 41
static void ngx_http_request_handler(ngx_event_t *ev ) ;
#line 42
static void ngx_http_terminate_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 43
static void ngx_http_terminate_handler(ngx_http_request_t *r ) ;
#line 44
static void ngx_http_finalize_connection(ngx_http_request_t *r ) ;
#line 45
static ngx_int_t ngx_http_set_write_handler(ngx_http_request_t *r ) ;
#line 46
static void ngx_http_writer(ngx_http_request_t *r ) ;
#line 47
static void ngx_http_request_finalizer(ngx_http_request_t *r ) ;
#line 49
static void ngx_http_set_keepalive(ngx_http_request_t *r ) ;
#line 50
static void ngx_http_keepalive_handler(ngx_event_t *rev ) ;
#line 51
static void ngx_http_set_lingering_close(ngx_http_request_t *r ) ;
#line 52
static void ngx_http_lingering_close_handler(ngx_event_t *rev ) ;
#line 53
static ngx_int_t ngx_http_post_action(ngx_http_request_t *r ) ;
#line 54
static void ngx_http_close_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 55
static void ngx_http_log_request(ngx_http_request_t *r ) ;
#line 57
static u_char *ngx_http_log_error(ngx_log_t *log , u_char *buf , size_t___0 len ) ;
#line 58
static u_char *ngx_http_log_error_handler(ngx_http_request_t *r , ngx_http_request_t *sr ,
                                          u_char *buf , size_t___0 len ) ;
#line 67 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static char *ngx_http_client_errors[4]  = {      (char *)"client sent invalid method",      (char *)"client sent invalid request",      (char *)"client sent invalid version",      (char *)"client sent invalid method in HTTP/0.9 request"};
#line 83 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
ngx_http_header_t ngx_http_headers_in[23]  = 
#line 83
  {      {{sizeof("Host") - 1UL, (u_char *)"Host"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->host),
      & ngx_http_process_host}, 
        {{sizeof("Connection") - 1UL, (u_char *)"Connection"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->connection),
      & ngx_http_process_connection}, 
        {{sizeof("If-Modified-Since") - 1UL, (u_char *)"If-Modified-Since"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_modified_since),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("If-Unmodified-Since") - 1UL, (u_char *)"If-Unmodified-Since"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_unmodified_since),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("If-Match") - 1UL, (u_char *)"If-Match"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_match),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("If-None-Match") - 1UL, (u_char *)"If-None-Match"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_none_match),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("User-Agent") - 1UL, (u_char *)"User-Agent"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->user_agent),
      & ngx_http_process_user_agent}, 
        {{sizeof("Referer") - 1UL, (u_char *)"Referer"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->referer),
      & ngx_http_process_header_line}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->content_length),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Content-Range") - 1UL, (u_char *)"Content-Range"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->content_range),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Content-Type") - 1UL, (u_char *)"Content-Type"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->content_type),
      & ngx_http_process_header_line}, 
        {{sizeof("Range") - 1UL, (u_char *)"Range"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->range),
      & ngx_http_process_header_line}, 
        {{sizeof("If-Range") - 1UL, (u_char *)"If-Range"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_range),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Transfer-Encoding") - 1UL, (u_char *)"Transfer-Encoding"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->transfer_encoding),
      & ngx_http_process_header_line}, 
        {{sizeof("Expect") - 1UL, (u_char *)"Expect"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->expect),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Upgrade") - 1UL, (u_char *)"Upgrade"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->upgrade),
      & ngx_http_process_header_line}, 
        {{sizeof("Accept-Encoding") - 1UL, (u_char *)"Accept-Encoding"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->accept_encoding),
      & ngx_http_process_header_line}, 
        {{sizeof("Via") - 1UL, (u_char *)"Via"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->via),
      & ngx_http_process_header_line}, 
        {{sizeof("Authorization") - 1UL, (u_char *)"Authorization"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->authorization),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Keep-Alive") - 1UL, (u_char *)"Keep-Alive"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->keep_alive),
      & ngx_http_process_header_line}, 
        {{sizeof("X-Forwarded-For") - 1UL, (u_char *)"X-Forwarded-For"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->x_forwarded_for),
      & ngx_http_process_multi_header_lines}, 
        {{sizeof("Cookie") - 1UL, (u_char *)"Cookie"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->cookies),
      & ngx_http_process_multi_header_lines}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                                              ngx_table_elt_t *h ,
                                                                              ngx_uint_t offset ))((void *)0)}};
#line 201 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_init_connection(ngx_connection_t *c ) 
{ 
  ngx_uint_t i ;
  ngx_event_t *rev ;
  struct sockaddr_in *sin ;
  ngx_http_port_t *port ;
  ngx_http_in_addr_t *addr ;
  ngx_http_log_ctx_t *ctx ;
  ngx_http_connection_t *hc ;
  struct sockaddr_in6 *sin6 ;
  ngx_http_in6_addr_t *addr6 ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;

  {
  {
#line 216
  tmp = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t ));
#line 216
  hc = (ngx_http_connection_t *)tmp;
  }
#line 217
  if ((unsigned long )hc == (unsigned long )((void *)0)) {
    {
#line 218
    ngx_http_close_connection(c);
    }
#line 219
    return;
  }
#line 222
  c->data = (void *)hc;
#line 226
  port = (ngx_http_port_t *)(c->listening)->servers;
#line 228
  if (port->naddrs > 1UL) {
    {
#line 236
    tmp___0 = ngx_connection_local_sockaddr(c, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
    }
#line 236
    if (tmp___0 != 0L) {
      {
#line 237
      ngx_http_close_connection(c);
      }
#line 238
      return;
    }
    {
#line 244
    if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 244
      goto case_10;
    }
#line 262
    goto switch_default;
    case_10: /* CIL Label */ 
#line 245
    sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 247
    addr6 = (ngx_http_in6_addr_t *)port->addrs;
#line 251
    i = (ngx_uint_t )0;
    {
#line 251
    while (1) {
      while_continue: /* CIL Label */ ;
#line 251
      if (! (i < port->naddrs - 1UL)) {
#line 251
        goto while_break;
      }
      {
#line 252
      tmp___1 = memcmp((void const   *)((char const   *)(& (addr6 + i)->addr6)), (void const   *)((char const   *)(& sin6->sin6_addr)),
                       (size_t )16);
      }
#line 252
      if (tmp___1 == 0) {
#line 253
        goto while_break;
      }
#line 251
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 257
    hc->addr_conf = & (addr6 + i)->conf;
#line 259
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 263
    sin = (struct sockaddr_in *)c->local_sockaddr;
#line 265
    addr = (ngx_http_in_addr_t *)port->addrs;
#line 269
    i = (ngx_uint_t )0;
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! (i < port->naddrs - 1UL)) {
#line 269
        goto while_break___0;
      }
#line 270
      if ((addr + i)->addr == sin->sin_addr.s_addr) {
#line 271
        goto while_break___0;
      }
#line 269
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    hc->addr_conf = & (addr + i)->conf;
#line 277
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 285
    if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 285
      goto case_10___0;
    }
#line 291
    goto switch_default___0;
    case_10___0: /* CIL Label */ 
#line 286
    addr6 = (ngx_http_in6_addr_t *)port->addrs;
#line 287
    hc->addr_conf = & (addr6 + 0)->conf;
#line 288
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 292
    addr = (ngx_http_in_addr_t *)port->addrs;
#line 293
    hc->addr_conf = & (addr + 0)->conf;
#line 294
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 299
  hc->conf_ctx = ((hc->addr_conf)->default_server)->ctx;
#line 301
  tmp___2 = ngx_palloc(c->pool, sizeof(ngx_http_log_ctx_t ));
#line 301
  ctx = (ngx_http_log_ctx_t *)tmp___2;
  }
#line 302
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 303
    ngx_http_close_connection(c);
    }
#line 304
    return;
  }
#line 307
  ctx->connection = c;
#line 308
  ctx->request = (ngx_http_request_t *)((void *)0);
#line 309
  ctx->current_request = (ngx_http_request_t *)((void *)0);
#line 311
  (c->log)->connection = c->number;
#line 312
  (c->log)->handler = & ngx_http_log_error;
#line 313
  (c->log)->data = (void *)ctx;
#line 314
  (c->log)->action = (char *)"waiting for request";
#line 316
  c->log_error = 2U;
#line 318
  rev = c->read;
#line 319
  rev->handler = & ngx_http_wait_request_handler;
#line 320
  (c->write)->handler = & ngx_http_empty_handler;
#line 353
  if ((hc->addr_conf)->proxy_protocol) {
#line 354
    hc->proxy_protocol = 1U;
#line 355
    (c->log)->action = (char *)"reading PROXY protocol";
  }
#line 358
  if (rev->ready) {
#line 361
    if (ngx_use_accept_mutex) {
#line 362
      if (! rev->posted) {
#line 362
        rev->posted = 1U;
#line 362
        rev->queue.prev = ngx_posted_events.prev;
#line 362
        (rev->queue.prev)->next = & rev->queue;
#line 362
        rev->queue.next = & ngx_posted_events;
#line 362
        ngx_posted_events.prev = & rev->queue;
      }
#line 363
      return;
    }
    {
#line 366
    (*(rev->handler))(rev);
    }
#line 367
    return;
  }
  {
#line 370
  ngx_event_add_timer(rev, (c->listening)->post_accept_timeout);
#line 371
  ngx_reusable_connection(c, (ngx_uint_t )1);
#line 373
  tmp___3 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 373
  if (tmp___3 != 0L) {
    {
#line 374
    ngx_http_close_connection(c);
    }
#line 375
    return;
  }
#line 377
  return;
}
}
#line 380 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_wait_request_handler(ngx_event_t *rev ) 
{ 
  u_char *p ;
  size_t___0 size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_connection_t *c ;
  ngx_http_connection_t *hc ;
  ngx_http_core_srv_conf_t *cscf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_http_request_t *tmp___2 ;

  {
#line 391
  c = (ngx_connection_t *)rev->data;
#line 395
  if (rev->timedout) {
#line 396
    if ((c->log)->log_level >= 7UL) {
      {
#line 396
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 397
    ngx_http_close_connection(c);
    }
#line 398
    return;
  }
#line 401
  if (c->close) {
    {
#line 402
    ngx_http_close_connection(c);
    }
#line 403
    return;
  }
#line 406
  hc = (ngx_http_connection_t *)c->data;
#line 407
  cscf = (ngx_http_core_srv_conf_t *)*((hc->conf_ctx)->srv_conf + ngx_http_core_module.ctx_index);
#line 409
  size = cscf->client_header_buffer_size;
#line 411
  b = c->buffer;
#line 413
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 414
    b = ngx_create_temp_buf(c->pool, size);
    }
#line 415
    if ((unsigned long )b == (unsigned long )((void *)0)) {
      {
#line 416
      ngx_http_close_connection(c);
      }
#line 417
      return;
    }
#line 420
    c->buffer = b;
  } else
#line 422
  if ((unsigned long )b->start == (unsigned long )((void *)0)) {
    {
#line 424
    tmp = ngx_palloc(c->pool, size);
#line 424
    b->start = (u_char *)tmp;
    }
#line 425
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
      {
#line 426
      ngx_http_close_connection(c);
      }
#line 427
      return;
    }
#line 430
    b->pos = b->start;
#line 431
    b->last = b->start;
#line 432
    b->end = b->last + size;
  }
  {
#line 435
  n = (*(c->recv))(c, b->last, size);
  }
#line 437
  if (n == -2L) {
#line 439
    if (! rev->timer_set) {
      {
#line 440
      ngx_event_add_timer(rev, (c->listening)->post_accept_timeout);
#line 441
      ngx_reusable_connection(c, (ngx_uint_t )1);
      }
    }
    {
#line 444
    tmp___0 = ngx_handle_read_event(rev, (ngx_uint_t )0);
    }
#line 444
    if (tmp___0 != 0L) {
      {
#line 445
      ngx_http_close_connection(c);
      }
#line 446
      return;
    }
    {
#line 453
    tmp___1 = ngx_pfree(c->pool, (void *)b->start);
    }
#line 453
    if (tmp___1 == 0L) {
#line 454
      b->start = (u_char *)((void *)0);
    }
#line 457
    return;
  }
#line 460
  if (n == -1L) {
    {
#line 461
    ngx_http_close_connection(c);
    }
#line 462
    return;
  }
#line 465
  if (n == 0L) {
#line 466
    if ((c->log)->log_level >= 7UL) {
      {
#line 466
      ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client closed connection");
      }
    }
    {
#line 468
    ngx_http_close_connection(c);
    }
#line 469
    return;
  }
#line 472
  b->last += n;
#line 474
  if (hc->proxy_protocol) {
    {
#line 475
    hc->proxy_protocol = 0U;
#line 477
    p = ngx_proxy_protocol_read(c, b->pos, b->last);
    }
#line 479
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 480
      ngx_http_close_connection(c);
      }
#line 481
      return;
    }
#line 484
    b->pos = p;
#line 486
    if ((unsigned long )b->pos == (unsigned long )b->last) {
#line 487
      (c->log)->action = (char *)"waiting for request";
#line 488
      b->pos = b->start;
#line 489
      b->last = b->start;
#line 490
      if (! rev->posted) {
#line 490
        rev->posted = 1U;
#line 490
        rev->queue.prev = ngx_posted_events.prev;
#line 490
        (rev->queue.prev)->next = & rev->queue;
#line 490
        rev->queue.next = & ngx_posted_events;
#line 490
        ngx_posted_events.prev = & rev->queue;
      }
#line 491
      return;
    }
  }
  {
#line 495
  (c->log)->action = (char *)"reading client request line";
#line 497
  ngx_reusable_connection(c, (ngx_uint_t )0);
#line 499
  tmp___2 = ngx_http_create_request(c);
#line 499
  c->data = (void *)tmp___2;
  }
#line 500
  if ((unsigned long )c->data == (unsigned long )((void *)0)) {
    {
#line 501
    ngx_http_close_connection(c);
    }
#line 502
    return;
  }
  {
#line 505
  rev->handler = & ngx_http_process_request_line;
#line 506
  ngx_http_process_request_line(rev);
  }
#line 507
  return;
}
}
#line 510 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
ngx_http_request_t *ngx_http_create_request(ngx_connection_t *c ) 
{ 
  ngx_pool_t *pool ;
  ngx_time_t *tp ;
  ngx_http_request_t *r ;
  ngx_http_log_ctx_t *ctx ;
  ngx_http_connection_t *hc ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 522
  (c->requests) ++;
#line 524
  hc = (ngx_http_connection_t *)c->data;
#line 526
  cscf = (ngx_http_core_srv_conf_t *)*((hc->conf_ctx)->srv_conf + ngx_http_core_module.ctx_index);
#line 528
  pool = ngx_create_pool(cscf->request_pool_size, c->log);
  }
#line 529
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 530
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 533
  tmp = ngx_pcalloc(pool, sizeof(ngx_http_request_t ));
#line 533
  r = (ngx_http_request_t *)tmp;
  }
#line 534
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 535
    ngx_destroy_pool(pool);
    }
#line 536
    return ((ngx_http_request_t *)((void *)0));
  }
#line 539
  r->pool = pool;
#line 541
  r->http_connection = hc;
#line 542
  r->signature = (uint32_t )1347703880;
#line 543
  r->connection = c;
#line 545
  r->main_conf = (hc->conf_ctx)->main_conf;
#line 546
  r->srv_conf = (hc->conf_ctx)->srv_conf;
#line 547
  r->loc_conf = (hc->conf_ctx)->loc_conf;
#line 549
  r->read_event_handler = & ngx_http_block_reading;
#line 551
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 553
  ((r->connection)->log)->file = (clcf->error_log)->file;
#line 553
  ((r->connection)->log)->next = (clcf->error_log)->next;
#line 553
  ((r->connection)->log)->writer = (clcf->error_log)->writer;
#line 553
  ((r->connection)->log)->wdata = (clcf->error_log)->wdata;
#line 553
  if (! (((r->connection)->log)->log_level & 2147483648UL)) {
#line 553
    ((r->connection)->log)->log_level = (clcf->error_log)->log_level;
  }
#line 555
  if (hc->busy) {
#line 555
    r->header_in = (hc->busy)->buf;
  } else {
#line 555
    r->header_in = c->buffer;
  }
  {
#line 557
  tmp___0 = ngx_list_init(& r->headers_out.headers, r->pool, (ngx_uint_t )20, sizeof(ngx_table_elt_t ));
  }
#line 557
  if (tmp___0 != 0L) {
    {
#line 561
    ngx_destroy_pool(r->pool);
    }
#line 562
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 565
  tmp___1 = ngx_list_init(& r->headers_out.trailers, r->pool, (ngx_uint_t )4, sizeof(ngx_table_elt_t ));
  }
#line 565
  if (tmp___1 != 0L) {
    {
#line 569
    ngx_destroy_pool(r->pool);
    }
#line 570
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 573
  tmp___2 = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);
#line 573
  r->ctx = (void **)tmp___2;
  }
#line 574
  if ((unsigned long )r->ctx == (unsigned long )((void *)0)) {
    {
#line 575
    ngx_destroy_pool(r->pool);
    }
#line 576
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 579
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 581
  tmp___3 = ngx_pcalloc(r->pool, cmcf->variables.nelts * sizeof(ngx_http_variable_value_t ));
#line 581
  r->variables = (ngx_http_variable_value_t *)tmp___3;
  }
#line 583
  if ((unsigned long )r->variables == (unsigned long )((void *)0)) {
    {
#line 584
    ngx_destroy_pool(r->pool);
    }
#line 585
    return ((ngx_http_request_t *)((void *)0));
  }
#line 594
  r->main = r;
#line 595
  r->count = 1U;
#line 597
  tp = (ngx_time_t *)ngx_cached_time;
#line 598
  r->start_sec = tp->sec;
#line 599
  r->start_msec = tp->msec;
#line 601
  r->method = (ngx_uint_t )1;
#line 602
  r->http_version = (ngx_uint_t )1000;
#line 604
  r->headers_in.content_length_n = (off_t )-1;
#line 605
  r->headers_in.keep_alive_n = (time_t )-1;
#line 606
  r->headers_out.content_length_n = (off_t )-1;
#line 607
  r->headers_out.last_modified_time = (time_t )-1;
#line 609
  r->uri_changes = 11U;
#line 610
  r->subrequests = 51U;
#line 612
  r->http_state = 1U;
#line 614
  ctx = (ngx_http_log_ctx_t *)(c->log)->data;
#line 615
  ctx->request = r;
#line 616
  ctx->current_request = r;
#line 617
  r->log_handler = & ngx_http_log_error_handler;
#line 625
  return (r);
}
}
#line 939 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_process_request_line(ngx_event_t *rev ) 
{ 
  ssize_t n ;
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_str_t host ;
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 948
  c = (ngx_connection_t *)rev->data;
#line 949
  r = (ngx_http_request_t *)c->data;
#line 954
  if (rev->timedout) {
#line 955
    if ((c->log)->log_level >= 7UL) {
      {
#line 955
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 956
    c->timedout = 1U;
#line 957
    ngx_http_close_request(r, (ngx_int_t )408);
    }
#line 958
    return;
  }
#line 961
  rc = (ngx_int_t )-2;
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 965
    if (rc == -2L) {
      {
#line 966
      n = ngx_http_read_request_header(r);
      }
#line 968
      if (n == -2L) {
#line 969
        return;
      } else
#line 968
      if (n == -1L) {
#line 969
        return;
      }
    }
    {
#line 973
    rc = ngx_http_parse_request_line(r, r->header_in);
    }
#line 975
    if (rc == 0L) {
#line 979
      r->request_line.len = (size_t___0 )(r->request_end - r->request_start);
#line 980
      r->request_line.data = r->request_start;
#line 981
      r->request_length = (r->header_in)->pos - r->request_start;
#line 986
      r->method_name.len = (size_t___0 )((r->method_end - r->request_start) + 1L);
#line 987
      r->method_name.data = r->request_line.data;
#line 989
      if (r->http_protocol.data) {
#line 990
        r->http_protocol.len = (size_t___0 )(r->request_end - r->http_protocol.data);
      }
      {
#line 993
      tmp = ngx_http_process_request_uri(r);
      }
#line 993
      if (tmp != 0L) {
#line 994
        return;
      }
#line 997
      if (r->host_start) {
#line 997
        if (r->host_end) {
          {
#line 999
          host.len = (size_t___0 )(r->host_end - r->host_start);
#line 1000
          host.data = r->host_start;
#line 1002
          rc = ngx_http_validate_host(& host, r->pool, (ngx_uint_t )0);
          }
#line 1004
          if (rc == -5L) {
#line 1005
            if ((c->log)->log_level >= 7UL) {
              {
#line 1005
              ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent invalid host in request line");
              }
            }
            {
#line 1007
            ngx_http_finalize_request(r, (ngx_int_t )400);
            }
#line 1008
            return;
          }
#line 1011
          if (rc == -1L) {
            {
#line 1012
            ngx_http_close_request(r, (ngx_int_t )500);
            }
#line 1013
            return;
          }
          {
#line 1016
          tmp___0 = ngx_http_set_virtual_server(r, & host);
          }
#line 1016
          if (tmp___0 == -1L) {
#line 1017
            return;
          }
#line 1020
          r->headers_in.server = host;
        }
      }
#line 1023
      if (r->http_version < 1000UL) {
#line 1025
        if (r->headers_in.server.len == 0UL) {
          {
#line 1025
          tmp___1 = ngx_http_set_virtual_server(r, & r->headers_in.server);
          }
#line 1025
          if (tmp___1 == -1L) {
#line 1029
            return;
          }
        }
        {
#line 1032
        ngx_http_process_request(r);
        }
#line 1033
        return;
      }
      {
#line 1037
      tmp___2 = ngx_list_init(& r->headers_in.headers, r->pool, (ngx_uint_t )20, sizeof(ngx_table_elt_t ));
      }
#line 1037
      if (tmp___2 != 0L) {
        {
#line 1041
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1042
        return;
      }
      {
#line 1045
      (c->log)->action = (char *)"reading client request headers";
#line 1047
      rev->handler = & ngx_http_process_request_headers;
#line 1048
      ngx_http_process_request_headers(rev);
      }
#line 1050
      return;
    }
#line 1053
    if (rc != -2L) {
#line 1057
      if ((c->log)->log_level >= 7UL) {
        {
#line 1057
        ngx_log_error_core((ngx_uint_t )7, c->log, 0, (char const   *)ngx_http_client_errors[rc - 10L]);
        }
      }
#line 1060
      if (rc == 12L) {
        {
#line 1061
        ngx_http_finalize_request(r, (ngx_int_t )505);
        }
      } else {
        {
#line 1064
        ngx_http_finalize_request(r, (ngx_int_t )400);
        }
      }
#line 1067
      return;
    }
#line 1072
    if ((unsigned long )(r->header_in)->pos == (unsigned long )(r->header_in)->end) {
      {
#line 1074
      rv = ngx_http_alloc_large_header_buffer(r, (ngx_uint_t )1);
      }
#line 1076
      if (rv == -1L) {
        {
#line 1077
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1078
        return;
      }
#line 1081
      if (rv == -5L) {
#line 1082
        r->request_line.len = (size_t___0 )((r->header_in)->end - r->request_start);
#line 1083
        r->request_line.data = r->request_start;
#line 1085
        if ((c->log)->log_level >= 7UL) {
          {
#line 1085
          ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent too long URI");
          }
        }
        {
#line 1087
        ngx_http_finalize_request(r, (ngx_int_t )414);
        }
#line 1088
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1095 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
ngx_int_t ngx_http_process_request_uri(ngx_http_request_t *r ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1100
  if (r->args_start) {
#line 1101
    r->uri.len = (size_t___0 )((r->args_start - 1) - r->uri_start);
  } else {
#line 1103
    r->uri.len = (size_t___0 )(r->uri_end - r->uri_start);
  }
#line 1106
  if (r->complex_uri) {
#line 1106
    goto _L;
  } else
#line 1106
  if (r->quoted_uri) {
    _L: /* CIL Label */ 
    {
#line 1108
    tmp = ngx_pnalloc(r->pool, r->uri.len + 1UL);
#line 1108
    r->uri.data = (u_char *)tmp;
    }
#line 1109
    if ((unsigned long )r->uri.data == (unsigned long )((void *)0)) {
      {
#line 1110
      ngx_http_close_request(r, (ngx_int_t )500);
      }
#line 1111
      return ((ngx_int_t )-1);
    }
    {
#line 1114
    cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1116
    tmp___0 = ngx_http_parse_complex_uri(r, (ngx_uint_t )cscf->merge_slashes);
    }
#line 1116
    if (tmp___0 != 0L) {
#line 1117
      r->uri.len = (size_t___0 )0;
#line 1119
      if (((r->connection)->log)->log_level >= 7UL) {
        {
#line 1119
        ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid request");
        }
      }
      {
#line 1121
      ngx_http_finalize_request(r, (ngx_int_t )400);
      }
#line 1122
      return ((ngx_int_t )-1);
    }
  } else {
#line 1126
    r->uri.data = r->uri_start;
  }
#line 1129
  r->unparsed_uri.len = (size_t___0 )(r->uri_end - r->uri_start);
#line 1130
  r->unparsed_uri.data = r->uri_start;
#line 1132
  if (r->space_in_uri) {
#line 1132
    r->valid_unparsed_uri = 0U;
  } else {
#line 1132
    r->valid_unparsed_uri = 1U;
  }
#line 1134
  if (r->uri_ext) {
#line 1135
    if (r->args_start) {
#line 1136
      r->exten.len = (size_t___0 )((r->args_start - 1) - r->uri_ext);
    } else {
#line 1138
      r->exten.len = (size_t___0 )(r->uri_end - r->uri_ext);
    }
#line 1141
    r->exten.data = r->uri_ext;
  }
#line 1144
  if (r->args_start) {
#line 1144
    if ((unsigned long )r->uri_end > (unsigned long )r->args_start) {
#line 1145
      r->args.len = (size_t___0 )(r->uri_end - r->args_start);
#line 1146
      r->args.data = r->args_start;
    }
  }
#line 1208
  return ((ngx_int_t )0);
}
}
#line 1212 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_process_request_headers(ngx_event_t *rev ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ssize_t n ;
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_table_elt_t *h ;
  ngx_connection_t *c ;
  ngx_http_header_t *hh ;
  ngx_http_request_t *r ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1226
  c = (ngx_connection_t *)rev->data;
#line 1227
  r = (ngx_http_request_t *)c->data;
#line 1232
  if (rev->timedout) {
#line 1233
    if ((c->log)->log_level >= 7UL) {
      {
#line 1233
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 1234
    c->timedout = 1U;
#line 1235
    ngx_http_close_request(r, (ngx_int_t )408);
    }
#line 1236
    return;
  }
#line 1239
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 1241
  rc = (ngx_int_t )-2;
  {
#line 1243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1245
    if (rc == -2L) {
#line 1247
      if ((unsigned long )(r->header_in)->pos == (unsigned long )(r->header_in)->end) {
        {
#line 1249
        rv = ngx_http_alloc_large_header_buffer(r, (ngx_uint_t )0);
        }
#line 1251
        if (rv == -1L) {
          {
#line 1252
          ngx_http_close_request(r, (ngx_int_t )500);
          }
#line 1253
          return;
        }
#line 1256
        if (rv == -5L) {
#line 1257
          p = r->header_name_start;
#line 1259
          r->lingering_close = 1U;
#line 1261
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1262
            if ((c->log)->log_level >= 7UL) {
              {
#line 1262
              ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent too large request");
              }
            }
            {
#line 1264
            ngx_http_finalize_request(r, (ngx_int_t )494);
            }
#line 1266
            return;
          }
#line 1269
          len = (size_t___0 )((r->header_in)->end - p);
#line 1271
          if (len > 1748UL) {
#line 1272
            len = (size_t___0 )1748;
          }
#line 1275
          if ((c->log)->log_level >= 7UL) {
            {
#line 1275
            ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent too long header line: \"%*s...\"",
                               len, r->header_name_start);
            }
          }
          {
#line 1279
          ngx_http_finalize_request(r, (ngx_int_t )494);
          }
#line 1281
          return;
        }
      }
      {
#line 1285
      n = ngx_http_read_request_header(r);
      }
#line 1287
      if (n == -2L) {
#line 1288
        return;
      } else
#line 1287
      if (n == -1L) {
#line 1288
        return;
      }
    }
    {
#line 1293
    cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1295
    rc = ngx_http_parse_header_line(r, r->header_in, (ngx_uint_t )cscf->underscores_in_headers);
    }
#line 1298
    if (rc == 0L) {
#line 1300
      r->request_length += (r->header_in)->pos - r->header_name_start;
#line 1302
      if (r->invalid_header) {
#line 1302
        if (cscf->ignore_invalid_headers) {
#line 1306
          if ((c->log)->log_level >= 7UL) {
            {
#line 1306
            ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent invalid header line: \"%*s\"",
                               r->header_end - r->header_name_start, r->header_name_start);
            }
          }
#line 1310
          goto __Cont;
        }
      }
      {
#line 1315
      tmp = ngx_list_push(& r->headers_in.headers);
#line 1315
      h = (ngx_table_elt_t *)tmp;
      }
#line 1316
      if ((unsigned long )h == (unsigned long )((void *)0)) {
        {
#line 1317
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1318
        return;
      }
      {
#line 1321
      h->hash = r->header_hash;
#line 1323
      h->key.len = (size_t___0 )(r->header_name_end - r->header_name_start);
#line 1324
      h->key.data = r->header_name_start;
#line 1325
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1327
      h->value.len = (size_t___0 )(r->header_end - r->header_start);
#line 1328
      h->value.data = r->header_start;
#line 1329
      *(h->value.data + h->value.len) = (u_char )'\000';
#line 1331
      tmp___0 = ngx_pnalloc(r->pool, h->key.len);
#line 1331
      h->lowcase_key = (u_char *)tmp___0;
      }
#line 1332
      if ((unsigned long )h->lowcase_key == (unsigned long )((void *)0)) {
        {
#line 1333
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1334
        return;
      }
#line 1337
      if (h->key.len == r->lowcase_index) {
        {
#line 1338
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1341
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1344
      tmp___1 = ngx_hash_find(& cmcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1344
      hh = (ngx_http_header_t *)tmp___1;
      }
#line 1347
      if (hh) {
        {
#line 1347
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1347
        if (tmp___2 != 0L) {
#line 1348
          return;
        }
      }
#line 1355
      goto __Cont;
    }
#line 1358
    if (rc == 1L) {
      {
#line 1365
      r->request_length += (r->header_in)->pos - r->header_name_start;
#line 1367
      r->http_state = 2U;
#line 1369
      rc = ngx_http_process_request_header(r);
      }
#line 1371
      if (rc != 0L) {
#line 1372
        return;
      }
      {
#line 1375
      ngx_http_process_request(r);
      }
#line 1377
      return;
    }
#line 1380
    if (rc == -2L) {
#line 1384
      goto __Cont;
    }
#line 1389
    if ((c->log)->log_level >= 7UL) {
      {
#line 1389
      ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent invalid header line");
      }
    }
    {
#line 1392
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1393
    return;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1398 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ssize_t ngx_http_read_request_header(ngx_http_request_t *r ) 
{ 
  ssize_t n ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_int_t tmp ;

  {
#line 1406
  c = r->connection;
#line 1407
  rev = c->read;
#line 1409
  n = (r->header_in)->last - (r->header_in)->pos;
#line 1411
  if (n > 0L) {
#line 1412
    return (n);
  }
#line 1415
  if (rev->ready) {
    {
#line 1416
    n = (*(c->recv))(c, (r->header_in)->last, (size_t___0 )((r->header_in)->end - (r->header_in)->last));
    }
  } else {
#line 1419
    n = (ssize_t )-2;
  }
#line 1422
  if (n == -2L) {
#line 1423
    if (! rev->timer_set) {
      {
#line 1424
      cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1425
      ngx_event_add_timer(rev, cscf->client_header_timeout);
      }
    }
    {
#line 1428
    tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
    }
#line 1428
    if (tmp != 0L) {
      {
#line 1429
      ngx_http_close_request(r, (ngx_int_t )500);
      }
#line 1430
      return ((ssize_t )-1);
    }
#line 1433
    return ((ssize_t )-2);
  }
#line 1436
  if (n == 0L) {
#line 1437
    if ((c->log)->log_level >= 7UL) {
      {
#line 1437
      ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client prematurely closed connection");
      }
    }
  }
#line 1441
  if (n == 0L) {
    {
#line 1442
    c->error = 1U;
#line 1443
    (c->log)->action = (char *)"reading client request headers";
#line 1445
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1446
    return ((ssize_t )-1);
  } else
#line 1441
  if (n == -1L) {
    {
#line 1442
    c->error = 1U;
#line 1443
    (c->log)->action = (char *)"reading client request headers";
#line 1445
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1446
    return ((ssize_t )-1);
  }
#line 1449
  (r->header_in)->last += n;
#line 1451
  return (n);
}
}
#line 1455 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r , ngx_uint_t request_line ) 
{ 
  u_char *old ;
  u_char *new ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_connection_t *hc ;
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 1468
  if (request_line) {
#line 1468
    if (r->state == 0UL) {
#line 1472
      (r->header_in)->pos = (r->header_in)->start;
#line 1473
      (r->header_in)->last = (r->header_in)->start;
#line 1475
      return ((ngx_int_t )0);
    }
  }
#line 1478
  if (request_line) {
#line 1478
    old = r->request_start;
  } else {
#line 1478
    old = r->header_name_start;
  }
#line 1480
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1482
  if (r->state != 0UL) {
#line 1482
    if ((size_t___0 )((r->header_in)->pos - old) >= cscf->large_client_header_buffers.size) {
#line 1486
      return ((ngx_int_t )-5);
    }
  }
#line 1489
  hc = r->http_connection;
#line 1491
  if (hc->free) {
#line 1492
    cl = hc->free;
#line 1493
    hc->free = cl->next;
#line 1495
    b = cl->buf;
  } else
#line 1501
  if (hc->nbusy < cscf->large_client_header_buffers.num) {
    {
#line 1503
    b = ngx_create_temp_buf((r->connection)->pool, cscf->large_client_header_buffers.size);
    }
#line 1505
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1506
      return ((ngx_int_t )-1);
    }
    {
#line 1509
    cl = ngx_alloc_chain_link((r->connection)->pool);
    }
#line 1510
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1511
      return ((ngx_int_t )-1);
    }
#line 1514
    cl->buf = b;
  } else {
#line 1521
    return ((ngx_int_t )-5);
  }
#line 1524
  cl->next = hc->busy;
#line 1525
  hc->busy = cl;
#line 1526
  (hc->nbusy) ++;
#line 1528
  if (r->state == 0UL) {
#line 1535
    r->header_in = b;
#line 1537
    return ((ngx_int_t )0);
  }
  {
#line 1543
  new = b->start;
#line 1545
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)old, (size_t )((r->header_in)->pos - old));
#line 1547
  b->pos = new + ((r->header_in)->pos - old);
#line 1548
  b->last = new + ((r->header_in)->pos - old);
  }
#line 1550
  if (request_line) {
#line 1551
    r->request_start = new;
#line 1553
    if (r->request_end) {
#line 1554
      r->request_end = new + (r->request_end - old);
    }
#line 1557
    r->method_end = new + (r->method_end - old);
#line 1559
    r->uri_start = new + (r->uri_start - old);
#line 1560
    r->uri_end = new + (r->uri_end - old);
#line 1562
    if (r->schema_start) {
#line 1563
      r->schema_start = new + (r->schema_start - old);
#line 1564
      r->schema_end = new + (r->schema_end - old);
    }
#line 1567
    if (r->host_start) {
#line 1568
      r->host_start = new + (r->host_start - old);
#line 1569
      if (r->host_end) {
#line 1570
        r->host_end = new + (r->host_end - old);
      }
    }
#line 1574
    if (r->port_start) {
#line 1575
      r->port_start = new + (r->port_start - old);
#line 1576
      r->port_end = new + (r->port_end - old);
    }
#line 1579
    if (r->uri_ext) {
#line 1580
      r->uri_ext = new + (r->uri_ext - old);
    }
#line 1583
    if (r->args_start) {
#line 1584
      r->args_start = new + (r->args_start - old);
    }
#line 1587
    if (r->http_protocol.data) {
#line 1588
      r->http_protocol.data = new + (r->http_protocol.data - old);
    }
  } else {
#line 1592
    r->header_name_start = new;
#line 1593
    r->header_name_end = new + (r->header_name_end - old);
#line 1594
    r->header_start = new + (r->header_start - old);
#line 1595
    r->header_end = new + (r->header_end - old);
  }
#line 1598
  r->header_in = b;
#line 1600
  return ((ngx_int_t )0);
}
}
#line 1604 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                              ngx_uint_t offset ) 
{ 
  ngx_table_elt_t **ph ;

  {
#line 1610
  ph = (ngx_table_elt_t **)((char *)(& r->headers_in) + offset);
#line 1612
  if ((unsigned long )*ph == (unsigned long )((void *)0)) {
#line 1613
    *ph = h;
  }
#line 1616
  return ((ngx_int_t )0);
}
}
#line 1620 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  ngx_table_elt_t **ph ;

  {
#line 1626
  ph = (ngx_table_elt_t **)((char *)(& r->headers_in) + offset);
#line 1628
  if ((unsigned long )*ph == (unsigned long )((void *)0)) {
#line 1629
    *ph = h;
#line 1630
    return ((ngx_int_t )0);
  }
#line 1633
  if (((r->connection)->log)->log_level >= 7UL) {
    {
#line 1633
    ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent duplicate header line: \"%V: %V\", previous value: \"%V: %V\"",
                       & h->key, & h->value, & (*ph)->key, & (*ph)->value);
    }
  }
  {
#line 1638
  ngx_http_finalize_request(r, (ngx_int_t )400);
  }
#line 1640
  return ((ngx_int_t )-1);
}
}
#line 1644 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_host(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                       ngx_uint_t offset ) 
{ 
  ngx_int_t rc ;
  ngx_str_t host ;
  ngx_int_t tmp ;

  {
#line 1651
  if ((unsigned long )r->headers_in.host == (unsigned long )((void *)0)) {
#line 1652
    r->headers_in.host = h;
  }
  {
#line 1655
  host = h->value;
#line 1657
  rc = ngx_http_validate_host(& host, r->pool, (ngx_uint_t )0);
  }
#line 1659
  if (rc == -5L) {
#line 1660
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 1660
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid host header");
      }
    }
    {
#line 1662
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1663
    return ((ngx_int_t )-1);
  }
#line 1666
  if (rc == -1L) {
    {
#line 1667
    ngx_http_close_request(r, (ngx_int_t )500);
    }
#line 1668
    return ((ngx_int_t )-1);
  }
#line 1671
  if (r->headers_in.server.len) {
#line 1672
    return ((ngx_int_t )0);
  }
  {
#line 1675
  tmp = ngx_http_set_virtual_server(r, & host);
  }
#line 1675
  if (tmp == -1L) {
#line 1676
    return ((ngx_int_t )-1);
  }
#line 1679
  r->headers_in.server = host;
#line 1681
  return ((ngx_int_t )0);
}
}
#line 1685 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) 
{ 
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 1689
  tmp___0 = ngx_strcasestrn(h->value.data, (char *)"close", (size_t___0 )4);
  }
#line 1689
  if (tmp___0) {
#line 1690
    r->headers_in.connection_type = 1U;
  } else {
    {
#line 1692
    tmp = ngx_strcasestrn(h->value.data, (char *)"keep-alive", (size_t___0 )9);
    }
#line 1692
    if (tmp) {
#line 1693
      r->headers_in.connection_type = 2U;
    }
  }
#line 1696
  return ((ngx_int_t )0);
}
}
#line 1700 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) 
{ 
  u_char *user_agent ;
  u_char *msie ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;

  {
#line 1706
  if (r->headers_in.user_agent) {
#line 1707
    return ((ngx_int_t )0);
  }
  {
#line 1710
  r->headers_in.user_agent = h;
#line 1714
  user_agent = h->value.data;
#line 1716
  msie = ngx_strstrn(user_agent, (char *)"MSIE ", (size_t___0 )4);
  }
#line 1718
  if (msie) {
#line 1718
    if ((unsigned long )(msie + 7) < (unsigned long )(user_agent + h->value.len)) {
#line 1720
      r->headers_in.msie = 1U;
#line 1722
      if ((int )*(msie + 6) == 46) {
        {
#line 1726
        if ((int )*(msie + 5) == 53) {
#line 1726
          goto case_53;
        }
#line 1726
        if ((int )*(msie + 5) == 52) {
#line 1726
          goto case_53;
        }
#line 1729
        if ((int )*(msie + 5) == 54) {
#line 1729
          goto case_54;
        }
#line 1724
        goto switch_break;
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
#line 1727
        r->headers_in.msie6 = 1U;
#line 1728
        goto switch_break;
        case_54: /* CIL Label */ 
        {
#line 1730
        tmp = ngx_strstrn(msie + 8, (char *)"SV1", (size_t___0 )2);
        }
#line 1730
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1731
          r->headers_in.msie6 = 1U;
        }
#line 1733
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 1745
  tmp___0 = ngx_strstrn(user_agent, (char *)"Opera", (size_t___0 )4);
  }
#line 1745
  if (tmp___0) {
#line 1746
    r->headers_in.opera = 1U;
#line 1747
    r->headers_in.msie = 0U;
#line 1748
    r->headers_in.msie6 = 0U;
  }
#line 1751
  if (! r->headers_in.msie) {
#line 1751
    if (! r->headers_in.opera) {
      {
#line 1753
      tmp___5 = ngx_strstrn(user_agent, (char *)"Gecko/", (size_t___0 )5);
      }
#line 1753
      if (tmp___5) {
#line 1754
        r->headers_in.gecko = 1U;
      } else {
        {
#line 1756
        tmp___4 = ngx_strstrn(user_agent, (char *)"Chrome/", (size_t___0 )6);
        }
#line 1756
        if (tmp___4) {
#line 1757
          r->headers_in.chrome = 1U;
        } else {
          {
#line 1759
          tmp___2 = ngx_strstrn(user_agent, (char *)"Safari/", (size_t___0 )6);
          }
#line 1759
          if (tmp___2) {
            {
#line 1759
            tmp___3 = ngx_strstrn(user_agent, (char *)"Mac OS X", (size_t___0 )7);
            }
#line 1759
            if (tmp___3) {
#line 1762
              r->headers_in.safari = 1U;
            } else {
#line 1759
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 1764
            tmp___1 = ngx_strstrn(user_agent, (char *)"Konqueror", (size_t___0 )8);
            }
#line 1764
            if (tmp___1) {
#line 1765
              r->headers_in.konqueror = 1U;
            }
          }
        }
      }
    }
  }
#line 1769
  return ((ngx_int_t )0);
}
}
#line 1773 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  ngx_array_t *headers ;
  ngx_table_elt_t **ph ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
#line 1780
  headers = (ngx_array_t *)((char *)(& r->headers_in) + offset);
#line 1782
  if ((unsigned long )headers->elts == (unsigned long )((void *)0)) {
    {
#line 1783
    tmp = ngx_array_init(headers, r->pool, (ngx_uint_t )1, sizeof(ngx_table_elt_t *));
    }
#line 1783
    if (tmp != 0L) {
      {
#line 1786
      ngx_http_close_request(r, (ngx_int_t )500);
      }
#line 1787
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1791
  tmp___0 = ngx_array_push(headers);
#line 1791
  ph = (ngx_table_elt_t **)tmp___0;
  }
#line 1792
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
    {
#line 1793
    ngx_http_close_request(r, (ngx_int_t )500);
    }
#line 1794
    return ((ngx_int_t )-1);
  }
#line 1797
  *ph = h;
#line 1798
  return ((ngx_int_t )0);
}
}
#line 1802 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
ngx_int_t ngx_http_process_request_header(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1805
  if (r->headers_in.server.len == 0UL) {
    {
#line 1805
    tmp = ngx_http_set_virtual_server(r, & r->headers_in.server);
    }
#line 1805
    if (tmp == -1L) {
#line 1809
      return ((ngx_int_t )-1);
    }
  }
#line 1812
  if ((unsigned long )r->headers_in.host == (unsigned long )((void *)0)) {
#line 1812
    if (r->http_version > 1000UL) {
#line 1813
      if (((r->connection)->log)->log_level >= 7UL) {
        {
#line 1813
        ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent HTTP/1.1 request without \"Host\" header");
        }
      }
      {
#line 1815
      ngx_http_finalize_request(r, (ngx_int_t )400);
      }
#line 1816
      return ((ngx_int_t )-1);
    }
  }
#line 1819
  if (r->headers_in.content_length) {
    {
#line 1820
    r->headers_in.content_length_n = ngx_atoof((r->headers_in.content_length)->value.data,
                                               (r->headers_in.content_length)->value.len);
    }
#line 1824
    if (r->headers_in.content_length_n == -1L) {
#line 1825
      if (((r->connection)->log)->log_level >= 7UL) {
        {
#line 1825
        ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid \"Content-Length\" header");
        }
      }
      {
#line 1827
      ngx_http_finalize_request(r, (ngx_int_t )400);
      }
#line 1828
      return ((ngx_int_t )-1);
    }
  }
#line 1832
  if (r->method == 32768UL) {
#line 1833
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 1833
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent TRACE method");
      }
    }
    {
#line 1835
    ngx_http_finalize_request(r, (ngx_int_t )405);
    }
#line 1836
    return ((ngx_int_t )-1);
  }
#line 1839
  if (r->headers_in.transfer_encoding) {
#line 1840
    if ((r->headers_in.transfer_encoding)->value.len == 7UL) {
      {
#line 1840
      tmp___1 = ngx_strncasecmp((r->headers_in.transfer_encoding)->value.data, (u_char *)"chunked",
                                (size_t___0 )7);
      }
#line 1840
      if (tmp___1 == 0L) {
#line 1844
        r->headers_in.content_length = (ngx_table_elt_t *)((void *)0);
#line 1845
        r->headers_in.content_length_n = (off_t )-1;
#line 1846
        r->headers_in.chunked = 1U;
      } else {
#line 1840
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1848
    if ((r->headers_in.transfer_encoding)->value.len != 8UL) {
#line 1848
      goto _L;
    } else {
      {
#line 1848
      tmp___0 = ngx_strncasecmp((r->headers_in.transfer_encoding)->value.data, (u_char *)"identity",
                                (size_t___0 )8);
      }
#line 1848
      if (tmp___0 != 0L) {
        _L: /* CIL Label */ 
#line 1852
        if (((r->connection)->log)->log_level >= 7UL) {
          {
#line 1852
          ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent unknown \"Transfer-Encoding\": \"%V\"",
                             & (r->headers_in.transfer_encoding)->value);
          }
        }
        {
#line 1855
        ngx_http_finalize_request(r, (ngx_int_t )501);
        }
#line 1856
        return ((ngx_int_t )-1);
      }
    }
  }
#line 1860
  if (r->headers_in.connection_type == 2U) {
#line 1861
    if (r->headers_in.keep_alive) {
      {
#line 1862
      r->headers_in.keep_alive_n = ngx_atotm((r->headers_in.keep_alive)->value.data,
                                             (r->headers_in.keep_alive)->value.len);
      }
    }
  }
#line 1868
  return ((ngx_int_t )0);
}
}
#line 1872 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_process_request(ngx_http_request_t *r ) 
{ 
  ngx_connection_t *c ;

  {
#line 1877
  c = r->connection;
#line 1933
  if ((c->read)->timer_set) {
    {
#line 1934
    ngx_event_del_timer(c->read);
    }
  }
  {
#line 1944
  (c->read)->handler = & ngx_http_request_handler;
#line 1945
  (c->write)->handler = & ngx_http_request_handler;
#line 1946
  r->read_event_handler = & ngx_http_block_reading;
#line 1948
  ngx_http_handler(r);
#line 1950
  ngx_http_run_posted_requests(c);
  }
#line 1951
  return;
}
}
#line 1954 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_validate_host(ngx_str_t *host , ngx_pool_t *pool , ngx_uint_t alloc ) 
{ 
  u_char *h ;
  u_char ch ;
  size_t___0 i ;
  size_t___0 dot_pos ;
  size_t___0 host_len ;
  enum __anonenum_state_207726914 state ;
  void *tmp ;

  {
#line 1966
  dot_pos = host->len;
#line 1967
  host_len = host->len;
#line 1969
  h = host->data;
#line 1971
  state = (enum __anonenum_state_207726914 )0;
#line 1973
  i = (size_t___0 )0;
  {
#line 1973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1973
    if (! (i < host->len)) {
#line 1973
      goto while_break;
    }
#line 1974
    ch = *(h + i);
    {
#line 1978
    if ((int )ch == 46) {
#line 1978
      goto case_46;
    }
#line 1985
    if ((int )ch == 58) {
#line 1985
      goto case_58;
    }
#line 1992
    if ((int )ch == 91) {
#line 1992
      goto case_91;
    }
#line 1998
    if ((int )ch == 93) {
#line 1998
      goto case_93;
    }
#line 2005
    if ((int )ch == 0) {
#line 2005
      goto case_0;
    }
#line 2008
    goto switch_default;
    case_46: /* CIL Label */ 
#line 1979
    if (dot_pos == i - 1UL) {
#line 1980
      return ((ngx_int_t )-5);
    }
#line 1982
    dot_pos = i;
#line 1983
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1986
    if ((unsigned int )state == 0U) {
#line 1987
      host_len = i;
#line 1988
      state = (enum __anonenum_state_207726914 )2;
    }
#line 1990
    goto switch_break;
    case_91: /* CIL Label */ 
#line 1993
    if (i == 0UL) {
#line 1994
      state = (enum __anonenum_state_207726914 )1;
    }
#line 1996
    goto switch_break;
    case_93: /* CIL Label */ 
#line 1999
    if ((unsigned int )state == 1U) {
#line 2000
      host_len = i + 1UL;
#line 2001
      state = (enum __anonenum_state_207726914 )2;
    }
#line 2003
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2006
    return ((ngx_int_t )-5);
    switch_default: /* CIL Label */ 
#line 2010
    if ((int )ch == 47) {
#line 2011
      return ((ngx_int_t )-5);
    }
#line 2014
    if ((int )ch >= 65) {
#line 2014
      if ((int )ch <= 90) {
#line 2015
        alloc = (ngx_uint_t )1;
      }
    }
#line 2018
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2022
  if (dot_pos == host_len - 1UL) {
#line 2023
    host_len --;
  }
#line 2026
  if (host_len == 0UL) {
#line 2027
    return ((ngx_int_t )-5);
  }
#line 2030
  if (alloc) {
    {
#line 2031
    tmp = ngx_pnalloc(pool, host_len);
#line 2031
    host->data = (u_char *)tmp;
    }
#line 2032
    if ((unsigned long )host->data == (unsigned long )((void *)0)) {
#line 2033
      return ((ngx_int_t )-1);
    }
    {
#line 2036
    ngx_strlow(host->data, h, host_len);
    }
  }
#line 2039
  host->len = host_len;
#line 2041
  return ((ngx_int_t )0);
}
}
#line 2045 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r , ngx_str_t *host ) 
{ 
  ngx_int_t rc ;
  ngx_http_connection_t *hc ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t *cscf ;

  {
  {
#line 2054
  cscf = (ngx_http_core_srv_conf_t *)((void *)0);
#line 2057
  hc = r->http_connection;
#line 2081
  rc = ngx_http_find_virtual_server(r->connection, (hc->addr_conf)->virtual_names,
                                    host, r, & cscf);
  }
#line 2085
  if (rc == -1L) {
    {
#line 2086
    ngx_http_close_request(r, (ngx_int_t )500);
    }
#line 2087
    return ((ngx_int_t )-1);
  }
#line 2113
  if (rc == -5L) {
#line 2114
    return ((ngx_int_t )0);
  }
#line 2117
  r->srv_conf = (cscf->ctx)->srv_conf;
#line 2118
  r->loc_conf = (cscf->ctx)->loc_conf;
#line 2120
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2122
  ((r->connection)->log)->file = (clcf->error_log)->file;
#line 2122
  ((r->connection)->log)->next = (clcf->error_log)->next;
#line 2122
  ((r->connection)->log)->writer = (clcf->error_log)->writer;
#line 2122
  ((r->connection)->log)->wdata = (clcf->error_log)->wdata;
#line 2122
  if (! (((r->connection)->log)->log_level & 2147483648UL)) {
#line 2122
    ((r->connection)->log)->log_level = (clcf->error_log)->log_level;
  }
#line 2124
  return ((ngx_int_t )0);
}
}
#line 2128 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c , ngx_http_virtual_names_t *virtual_names ,
                                              ngx_str_t *host , ngx_http_request_t *r ,
                                              ngx_http_core_srv_conf_t **cscfp ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  ngx_uint_t tmp ;
  void *tmp___0 ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_http_server_name_t *sn ;

  {
#line 2135
  if ((unsigned long )virtual_names == (unsigned long )((void *)0)) {
#line 2136
    return ((ngx_int_t )-5);
  }
  {
#line 2139
  tmp = ngx_hash_key(host->data, host->len);
#line 2139
  tmp___0 = ngx_hash_find_combined(& virtual_names->names, tmp, host->data, host->len);
#line 2139
  cscf = (ngx_http_core_srv_conf_t *)tmp___0;
  }
#line 2143
  if (cscf) {
#line 2144
    *cscfp = cscf;
#line 2145
    return ((ngx_int_t )0);
  }
#line 2150
  if (host->len) {
#line 2150
    if (virtual_names->nregex) {
#line 2155
      sn = virtual_names->regex;
#line 2191
      i = (ngx_uint_t )0;
      {
#line 2191
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2191
        if (! (i < virtual_names->nregex)) {
#line 2191
          goto while_break;
        }
        {
#line 2193
        n = ngx_http_regex_exec(r, (sn + i)->regex, host);
        }
#line 2195
        if (n == -5L) {
#line 2196
          goto __Cont;
        }
#line 2199
        if (n == 0L) {
#line 2200
          *cscfp = (sn + i)->server;
#line 2201
          return ((ngx_int_t )0);
        }
#line 2204
        return ((ngx_int_t )-1);
        __Cont: /* CIL Label */ 
#line 2191
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2210
  return ((ngx_int_t )-5);
}
}
#line 2214 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_request_handler(ngx_event_t *ev ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *r ;

  {
#line 2220
  c = (ngx_connection_t *)ev->data;
#line 2221
  r = (ngx_http_request_t *)c->data;
#line 2223
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 2228
  if (ev->delayed) {
#line 2228
    if (ev->timedout) {
#line 2229
      ev->delayed = 0U;
#line 2230
      ev->timedout = 0U;
    }
  }
#line 2233
  if (ev->write) {
    {
#line 2234
    (*(r->write_event_handler))(r);
    }
  } else {
    {
#line 2237
    (*(r->read_event_handler))(r);
    }
  }
  {
#line 2240
  ngx_http_run_posted_requests(c);
  }
#line 2241
  return;
}
}
#line 2244 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_run_posted_requests(ngx_connection_t *c ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_posted_request_t *pr ;

  {
  {
#line 2250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2252
    if (c->destroyed) {
#line 2253
      return;
    }
#line 2256
    r = (ngx_http_request_t *)c->data;
#line 2257
    pr = (r->main)->posted_requests;
#line 2259
    if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2260
      return;
    }
    {
#line 2263
    (r->main)->posted_requests = pr->next;
#line 2265
    r = pr->request;
#line 2267
    ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 2272
    (*(r->write_event_handler))(r);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2277 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
ngx_int_t ngx_http_post_request(ngx_http_request_t *r , ngx_http_posted_request_t *pr ) 
{ 
  ngx_http_posted_request_t **p ;
  void *tmp ;

  {
#line 2282
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
    {
#line 2283
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t ));
#line 2283
    pr = (ngx_http_posted_request_t *)tmp;
    }
#line 2284
    if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2285
      return ((ngx_int_t )-1);
    }
  }
#line 2289
  pr->request = r;
#line 2290
  pr->next = (ngx_http_posted_request_t *)((void *)0);
#line 2292
  p = & (r->main)->posted_requests;
  {
#line 2292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2292
    if (! *p) {
#line 2292
      goto while_break;
    }
#line 2292
    p = & (*p)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2294
  *p = pr;
#line 2296
  return ((ngx_int_t )0);
}
}
#line 2300 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *pr ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 2307
  c = r->connection;
#line 2313
  if (rc == -4L) {
    {
#line 2314
    ngx_http_finalize_connection(r);
    }
#line 2315
    return;
  }
#line 2318
  if (rc == 0L) {
#line 2318
    if (r->filter_finalize) {
#line 2319
      c->error = 1U;
    }
  }
#line 2322
  if (rc == -5L) {
    {
#line 2323
    r->content_handler = (ngx_int_t (*)(ngx_http_request_t *r ))((void *)0);
#line 2324
    r->write_event_handler = & ngx_http_core_run_phases;
#line 2325
    ngx_http_core_run_phases(r);
    }
#line 2326
    return;
  }
#line 2329
  if ((unsigned long )r != (unsigned long )r->main) {
#line 2329
    if (r->post_subrequest) {
      {
#line 2330
      rc = (*((r->post_subrequest)->handler))(r, (r->post_subrequest)->data, rc);
      }
    }
  }
#line 2333
  if (rc == -1L) {
#line 2333
    goto _L;
  } else
#line 2333
  if (rc == 408L) {
#line 2333
    goto _L;
  } else
#line 2333
  if (rc == 499L) {
#line 2333
    goto _L;
  } else
#line 2333
  if (c->error) {
    _L: /* CIL Label */ 
    {
#line 2338
    tmp = ngx_http_post_action(r);
    }
#line 2338
    if (tmp == 0L) {
#line 2339
      return;
    }
    {
#line 2342
    ngx_http_terminate_request(r, rc);
    }
#line 2343
    return;
  }
#line 2346
  if (rc >= 300L) {
#line 2346
    goto _L___0;
  } else
#line 2346
  if (rc == 201L) {
#line 2346
    goto _L___0;
  } else
#line 2346
  if (rc == 204L) {
    _L___0: /* CIL Label */ 
#line 2350
    if (rc == 444L) {
      {
#line 2351
      ngx_http_terminate_request(r, rc);
      }
#line 2352
      return;
    }
#line 2355
    if ((unsigned long )r == (unsigned long )r->main) {
#line 2356
      if ((c->read)->timer_set) {
        {
#line 2357
        ngx_event_del_timer(c->read);
        }
      }
#line 2360
      if ((c->write)->timer_set) {
        {
#line 2361
        ngx_event_del_timer(c->write);
        }
      }
    }
    {
#line 2365
    (c->read)->handler = & ngx_http_request_handler;
#line 2366
    (c->write)->handler = & ngx_http_request_handler;
#line 2368
    tmp___0 = ngx_http_special_response_handler(r, rc);
#line 2368
    ngx_http_finalize_request(r, tmp___0);
    }
#line 2369
    return;
  }
#line 2372
  if ((unsigned long )r != (unsigned long )r->main) {
#line 2373
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2375
    if (r->background) {
#line 2376
      if (! r->logged) {
#line 2377
        if (clcf->log_subrequest) {
          {
#line 2378
          ngx_http_log_request(r);
          }
        }
#line 2381
        r->logged = 1U;
      } else
#line 2384
      if ((c->log)->log_level >= 2UL) {
        {
#line 2384
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "subrequest: \"%V?%V\" logged again",
                           & r->uri, & r->args);
        }
      }
      {
#line 2389
      r->done = 1U;
#line 2390
      ngx_http_finalize_connection(r);
      }
#line 2391
      return;
    }
#line 2394
    if (r->buffered) {
#line 2394
      goto _L___1;
    } else
#line 2394
    if (r->postponed) {
      _L___1: /* CIL Label */ 
      {
#line 2396
      tmp___1 = ngx_http_set_write_handler(r);
      }
#line 2396
      if (tmp___1 != 0L) {
        {
#line 2397
        ngx_http_terminate_request(r, (ngx_int_t )0);
        }
      }
#line 2400
      return;
    }
#line 2403
    pr = r->parent;
#line 2405
    if ((unsigned long )r == (unsigned long )c->data) {
#line 2407
      ((r->main)->count) --;
#line 2409
      if (! r->logged) {
#line 2410
        if (clcf->log_subrequest) {
          {
#line 2411
          ngx_http_log_request(r);
          }
        }
#line 2414
        r->logged = 1U;
      } else
#line 2417
      if ((c->log)->log_level >= 2UL) {
        {
#line 2417
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "subrequest: \"%V?%V\" logged again",
                           & r->uri, & r->args);
        }
      }
#line 2422
      r->done = 1U;
#line 2424
      if (pr->postponed) {
#line 2424
        if ((unsigned long )(pr->postponed)->request == (unsigned long )r) {
#line 2425
          pr->postponed = (pr->postponed)->next;
        }
      }
#line 2428
      c->data = (void *)pr;
    } else {
#line 2436
      r->write_event_handler = & ngx_http_request_finalizer;
#line 2438
      if (r->waited) {
#line 2439
        r->done = 1U;
      }
    }
    {
#line 2443
    tmp___2 = ngx_http_post_request(pr, (ngx_http_posted_request_t *)((void *)0));
    }
#line 2443
    if (tmp___2 != 0L) {
      {
#line 2444
      ((r->main)->count) ++;
#line 2445
      ngx_http_terminate_request(r, (ngx_int_t )0);
      }
#line 2446
      return;
    }
#line 2453
    return;
  }
#line 2456
  if (r->buffered) {
#line 2456
    goto _L___2;
  } else
#line 2456
  if (c->buffered) {
#line 2456
    goto _L___2;
  } else
#line 2456
  if (r->postponed) {
    _L___2: /* CIL Label */ 
    {
#line 2458
    tmp___3 = ngx_http_set_write_handler(r);
    }
#line 2458
    if (tmp___3 != 0L) {
      {
#line 2459
      ngx_http_terminate_request(r, (ngx_int_t )0);
      }
    }
#line 2462
    return;
  }
#line 2465
  if ((unsigned long )r != (unsigned long )c->data) {
#line 2466
    if ((c->log)->log_level >= 2UL) {
      {
#line 2466
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "http finalize non-active request: \"%V?%V\"",
                         & r->uri, & r->args);
      }
    }
#line 2469
    return;
  }
#line 2472
  r->done = 1U;
#line 2474
  r->read_event_handler = & ngx_http_block_reading;
#line 2475
  r->write_event_handler = & ngx_http_request_empty_handler;
#line 2477
  if (! r->post_action) {
#line 2478
    r->request_complete = 1U;
  }
  {
#line 2481
  tmp___4 = ngx_http_post_action(r);
  }
#line 2481
  if (tmp___4 == 0L) {
#line 2482
    return;
  }
#line 2485
  if ((c->read)->timer_set) {
    {
#line 2486
    ngx_event_del_timer(c->read);
    }
  }
#line 2489
  if ((c->write)->timer_set) {
    {
#line 2490
    (c->write)->delayed = 0U;
#line 2491
    ngx_event_del_timer(c->write);
    }
  }
#line 2494
  if ((c->read)->eof) {
    {
#line 2495
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 2496
    return;
  }
  {
#line 2499
  ngx_http_finalize_connection(r);
  }
#line 2500
  return;
}
}
#line 2503 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_terminate_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_http_cleanup_t *cln ;
  ngx_http_request_t *mr ;
  ngx_http_ephemeral_t *e ;

  {
#line 2510
  mr = r->main;
#line 2515
  if (rc > 0L) {
#line 2515
    if (mr->headers_out.status == 0UL) {
#line 2516
      mr->headers_out.status = (ngx_uint_t )rc;
    } else
#line 2515
    if ((mr->connection)->sent == 0L) {
#line 2516
      mr->headers_out.status = (ngx_uint_t )rc;
    }
  }
#line 2519
  cln = mr->cleanup;
#line 2520
  mr->cleanup = (ngx_http_cleanup_t *)((void *)0);
  {
#line 2522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2522
    if (! cln) {
#line 2522
      goto while_break;
    }
#line 2523
    if (cln->handler) {
      {
#line 2524
      (*(cln->handler))(cln->data);
      }
    }
#line 2527
    cln = cln->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2534
  if (mr->write_event_handler) {
#line 2536
    if (mr->blocked) {
#line 2537
      (r->connection)->error = 1U;
#line 2538
      r->write_event_handler = & ngx_http_request_finalizer;
#line 2539
      return;
    }
    {
#line 2542
    e = (ngx_http_ephemeral_t *)((void *)(& mr->uri_start));
#line 2543
    mr->posted_requests = (ngx_http_posted_request_t *)((void *)0);
#line 2544
    mr->write_event_handler = & ngx_http_terminate_handler;
#line 2545
    ngx_http_post_request(mr, & e->terminal_posted_request);
    }
#line 2546
    return;
  }
  {
#line 2549
  ngx_http_close_request(mr, rc);
  }
#line 2550
  return;
}
}
#line 2553 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_terminate_handler(ngx_http_request_t *r ) 
{ 


  {
  {
#line 2559
  r->count = 1U;
#line 2561
  ngx_http_close_request(r, (ngx_int_t )0);
  }
#line 2562
  return;
}
}
#line 2565 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_finalize_connection(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 2577
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2579
  if ((r->main)->count != 1U) {
#line 2581
    if (r->discard_body) {
      {
#line 2582
      r->read_event_handler = & ngx_http_discarded_request_body_handler;
#line 2583
      ngx_event_add_timer((r->connection)->read, clcf->lingering_timeout);
      }
#line 2585
      if (r->lingering_time == 0L) {
#line 2586
        r->lingering_time = (time_t )(ngx_cached_time->sec + (time_t volatile   )((time_t )(clcf->lingering_time / 1000UL)));
      }
    }
    {
#line 2591
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 2592
    return;
  }
#line 2595
  r = r->main;
#line 2597
  if (r->reading_body) {
#line 2598
    r->keepalive = 0U;
#line 2599
    r->lingering_close = 1U;
  }
#line 2602
  if (! ngx_terminate) {
#line 2602
    if (! ngx_exiting) {
#line 2602
      if (r->keepalive) {
#line 2602
        if (clcf->keepalive_timeout > 0UL) {
          {
#line 2607
          ngx_http_set_keepalive(r);
          }
#line 2608
          return;
        }
      }
    }
  }
#line 2611
  if (clcf->lingering_close == 2UL) {
    {
#line 2617
    ngx_http_set_lingering_close(r);
    }
#line 2618
    return;
  } else
#line 2611
  if (clcf->lingering_close == 1UL) {
#line 2611
    if (r->lingering_close) {
      {
#line 2617
      ngx_http_set_lingering_close(r);
      }
#line 2618
      return;
    } else
#line 2611
    if ((unsigned long )(r->header_in)->pos < (unsigned long )(r->header_in)->last) {
      {
#line 2617
      ngx_http_set_lingering_close(r);
      }
#line 2618
      return;
    } else
#line 2611
    if (((r->connection)->read)->ready) {
      {
#line 2617
      ngx_http_set_lingering_close(r);
      }
#line 2618
      return;
    }
  }
  {
#line 2621
  ngx_http_close_request(r, (ngx_int_t )0);
  }
#line 2622
  return;
}
}
#line 2625 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_set_write_handler(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;

  {
#line 2631
  r->http_state = 6U;
#line 2633
  if (r->discard_body) {
#line 2633
    r->read_event_handler = & ngx_http_discarded_request_body_handler;
  } else {
#line 2633
    r->read_event_handler = & ngx_http_test_reading;
  }
#line 2636
  r->write_event_handler = & ngx_http_writer;
#line 2638
  wev = (r->connection)->write;
#line 2640
  if (wev->ready) {
#line 2640
    if (wev->delayed) {
#line 2641
      return ((ngx_int_t )0);
    }
  }
#line 2644
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2645
  if (! wev->delayed) {
    {
#line 2646
    ngx_event_add_timer(wev, clcf->send_timeout);
    }
  }
  {
#line 2649
  tmp = ngx_handle_write_event(wev, clcf->send_lowat);
  }
#line 2649
  if (tmp != 0L) {
    {
#line 2650
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 2651
    return ((ngx_int_t )-1);
  }
#line 2654
  return ((ngx_int_t )0);
}
}
#line 2658 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_writer(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 2666
  c = r->connection;
#line 2667
  wev = c->write;
#line 2672
  clcf = (ngx_http_core_loc_conf_t *)*((r->main)->loc_conf + ngx_http_core_module.ctx_index);
#line 2674
  if (wev->timedout) {
#line 2675
    if ((c->log)->log_level >= 7UL) {
      {
#line 2675
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 2677
    c->timedout = 1U;
#line 2679
    ngx_http_finalize_request(r, (ngx_int_t )408);
    }
#line 2680
    return;
  }
#line 2683
  if (wev->delayed) {
#line 2683
    goto _L;
  } else
#line 2683
  if (r->aio) {
    _L: /* CIL Label */ 
#line 2687
    if (! wev->delayed) {
      {
#line 2688
      ngx_event_add_timer(wev, clcf->send_timeout);
      }
    }
    {
#line 2691
    tmp = ngx_handle_write_event(wev, clcf->send_lowat);
    }
#line 2691
    if (tmp != 0L) {
      {
#line 2692
      ngx_http_close_request(r, (ngx_int_t )0);
      }
    }
#line 2695
    return;
  }
  {
#line 2698
  rc = ngx_http_output_filter(r, (ngx_chain_t *)((void *)0));
  }
#line 2704
  if (rc == -1L) {
    {
#line 2705
    ngx_http_finalize_request(r, rc);
    }
#line 2706
    return;
  }
#line 2709
  if (r->buffered) {
#line 2709
    goto _L___0;
  } else
#line 2709
  if (r->postponed) {
#line 2709
    goto _L___0;
  } else
#line 2709
  if ((unsigned long )r == (unsigned long )r->main) {
#line 2709
    if (c->buffered) {
      _L___0: /* CIL Label */ 
#line 2711
      if (! wev->delayed) {
        {
#line 2712
        ngx_event_add_timer(wev, clcf->send_timeout);
        }
      }
      {
#line 2715
      tmp___0 = ngx_handle_write_event(wev, clcf->send_lowat);
      }
#line 2715
      if (tmp___0 != 0L) {
        {
#line 2716
        ngx_http_close_request(r, (ngx_int_t )0);
        }
      }
#line 2719
      return;
    }
  }
  {
#line 2725
  r->write_event_handler = & ngx_http_request_empty_handler;
#line 2727
  ngx_http_finalize_request(r, rc);
  }
#line 2728
  return;
}
}
#line 2731 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_request_finalizer(ngx_http_request_t *r ) 
{ 


  {
  {
#line 2737
  ngx_http_finalize_request(r, (ngx_int_t )0);
  }
#line 2738
  return;
}
}
#line 2741 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_block_reading(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;

  {
#line 2749
  if (ngx_event_flags & 1UL) {
#line 2749
    if (((r->connection)->read)->active) {
      {
#line 2752
      tmp = (*(ngx_event_actions.del))((r->connection)->read, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 2752
      if (tmp != 0L) {
        {
#line 2753
        ngx_http_close_request(r, (ngx_int_t )0);
        }
      }
    }
  }
#line 2756
  return;
}
}
#line 2759 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_test_reading(ngx_http_request_t *r ) 
{ 
  int n ;
  char buf[1] ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  socklen_t len ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 2768
  c = r->connection;
#line 2769
  rev = c->read;
#line 2805
  if (ngx_event_flags & 64UL) {
#line 2805
    if (ngx_use_epoll_rdhup) {
#line 2808
      if (! rev->pending_eof) {
#line 2809
        return;
      }
      {
#line 2812
      rev->eof = 1U;
#line 2813
      c->error = 1U;
#line 2815
      err = 0;
#line 2816
      len = (socklen_t )sizeof(ngx_err_t );
#line 2823
      tmp___0 = getsockopt(c->fd, 1, 4, (void */* __restrict  */)((void *)(& err)),
                           (socklen_t */* __restrict  */)(& len));
      }
#line 2823
      if (tmp___0 == -1) {
        {
#line 2826
        tmp = __errno_location();
#line 2826
        err = *tmp;
        }
      }
#line 2829
      goto closed;
    }
  }
  {
#line 2834
  tmp___1 = recv(c->fd, (void *)(buf), (size_t___0 )1, 2);
#line 2834
  n = (int )tmp___1;
  }
#line 2836
  if (n == 0) {
#line 2837
    rev->eof = 1U;
#line 2838
    c->error = 1U;
#line 2839
    err = 0;
#line 2841
    goto closed;
  } else
#line 2843
  if (n == -1) {
    {
#line 2844
    tmp___2 = __errno_location();
#line 2844
    err = *tmp___2;
    }
#line 2846
    if (err != 11) {
#line 2847
      rev->eof = 1U;
#line 2848
      c->error = 1U;
#line 2850
      goto closed;
    }
  }
#line 2856
  if (ngx_event_flags & 1UL) {
#line 2856
    if (rev->active) {
      {
#line 2858
      tmp___3 = (*(ngx_event_actions.del))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 2858
      if (tmp___3 != 0L) {
        {
#line 2859
        ngx_http_close_request(r, (ngx_int_t )0);
        }
      }
    }
  }
#line 2863
  return;
  closed: 
#line 2867
  if (err) {
#line 2868
    rev->error = 1U;
  }
#line 2871
  if ((c->log)->log_level >= 7UL) {
    {
#line 2871
    ngx_log_error_core((ngx_uint_t )7, c->log, err, "client prematurely closed connection");
    }
  }
  {
#line 2874
  ngx_http_finalize_request(r, (ngx_int_t )499);
  }
#line 2875
  return;
}
}
#line 2878 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_set_keepalive(ngx_http_request_t *r ) 
{ 
  int tcp_nodelay ;
  ngx_buf_t *b ;
  ngx_buf_t *f ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_connection_t *hc ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 2889
  c = r->connection;
#line 2890
  rev = c->read;
#line 2892
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2896
  if (r->discard_body) {
    {
#line 2897
    r->write_event_handler = & ngx_http_request_empty_handler;
#line 2898
    r->lingering_time = (time_t )(ngx_cached_time->sec + (time_t volatile   )((time_t )(clcf->lingering_time / 1000UL)));
#line 2899
    ngx_event_add_timer(rev, clcf->lingering_timeout);
    }
#line 2900
    return;
  }
#line 2903
  (c->log)->action = (char *)"closing request";
#line 2905
  hc = r->http_connection;
#line 2906
  b = r->header_in;
#line 2908
  if ((unsigned long )b->pos < (unsigned long )b->last) {
#line 2912
    if ((unsigned long )b != (unsigned long )c->buffer) {
#line 2922
      cl = hc->busy;
      {
#line 2922
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2922
        if (! cl) {
#line 2922
          goto while_break;
        }
#line 2923
        ln = cl;
#line 2924
        cl = cl->next;
#line 2926
        if ((unsigned long )ln->buf == (unsigned long )b) {
#line 2927
          ln->next = (c->pool)->chain;
#line 2927
          (c->pool)->chain = ln;
#line 2928
          goto __Cont;
        }
#line 2931
        f = ln->buf;
#line 2932
        f->pos = f->start;
#line 2933
        f->last = f->start;
#line 2935
        ln->next = hc->free;
#line 2936
        hc->free = ln;
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2939
      cl = ngx_alloc_chain_link(c->pool);
      }
#line 2940
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
        {
#line 2941
        ngx_http_close_request(r, (ngx_int_t )0);
        }
#line 2942
        return;
      }
#line 2945
      cl->buf = b;
#line 2946
      cl->next = (ngx_chain_t *)((void *)0);
#line 2948
      hc->busy = cl;
#line 2949
      hc->nbusy = (ngx_int_t )1;
    }
  }
  {
#line 2954
  r->keepalive = 0U;
#line 2956
  ngx_http_free_request(r, (ngx_int_t )0);
#line 2958
  c->data = (void *)hc;
#line 2960
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 2960
  if (tmp != 0L) {
    {
#line 2961
    ngx_http_close_connection(c);
    }
#line 2962
    return;
  }
#line 2965
  wev = c->write;
#line 2966
  wev->handler = & ngx_http_empty_handler;
#line 2968
  if ((unsigned long )b->pos < (unsigned long )b->last) {
    {
#line 2972
    (c->log)->action = (char *)"reading client pipelined request line";
#line 2974
    r = ngx_http_create_request(c);
    }
#line 2975
    if ((unsigned long )r == (unsigned long )((void *)0)) {
      {
#line 2976
      ngx_http_close_connection(c);
      }
#line 2977
      return;
    }
#line 2980
    r->pipeline = 1U;
#line 2982
    c->data = (void *)r;
#line 2984
    c->sent = (off_t )0;
#line 2985
    c->destroyed = 0U;
#line 2987
    if (rev->timer_set) {
      {
#line 2988
      ngx_event_del_timer(rev);
      }
    }
#line 2991
    rev->handler = & ngx_http_process_request_line;
#line 2992
    if (! rev->posted) {
#line 2992
      rev->posted = 1U;
#line 2992
      rev->queue.prev = ngx_posted_events.prev;
#line 2992
      (rev->queue.prev)->next = & rev->queue;
#line 2992
      rev->queue.next = & ngx_posted_events;
#line 2992
      ngx_posted_events.prev = & rev->queue;
    }
#line 2993
    return;
  }
  {
#line 3003
  b = c->buffer;
#line 3005
  tmp___0 = ngx_pfree(c->pool, (void *)b->start);
  }
#line 3005
  if (tmp___0 == 0L) {
#line 3012
    b->pos = (u_char *)((void *)0);
  } else {
#line 3015
    b->pos = b->start;
#line 3016
    b->last = b->start;
  }
#line 3022
  if (hc->free) {
#line 3023
    cl = hc->free;
    {
#line 3023
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3023
      if (! cl) {
#line 3023
        goto while_break___0;
      }
      {
#line 3024
      ln = cl;
#line 3025
      cl = cl->next;
#line 3026
      ngx_pfree(c->pool, (void *)(ln->buf)->start);
#line 3027
      ln->next = (c->pool)->chain;
#line 3027
      (c->pool)->chain = ln;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3030
    hc->free = (ngx_chain_t *)((void *)0);
  }
#line 3036
  if (hc->busy) {
#line 3037
    cl = hc->busy;
    {
#line 3037
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3037
      if (! cl) {
#line 3037
        goto while_break___1;
      }
      {
#line 3038
      ln = cl;
#line 3039
      cl = cl->next;
#line 3040
      ngx_pfree(c->pool, (void *)(ln->buf)->start);
#line 3041
      ln->next = (c->pool)->chain;
#line 3041
      (c->pool)->chain = ln;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3044
    hc->busy = (ngx_chain_t *)((void *)0);
#line 3045
    hc->nbusy = (ngx_int_t )0;
  }
#line 3054
  rev->handler = & ngx_http_keepalive_handler;
#line 3056
  if (wev->active) {
#line 3056
    if (ngx_event_flags & 1UL) {
      {
#line 3057
      tmp___1 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
      }
#line 3057
      if (tmp___1 != 0L) {
        {
#line 3058
        ngx_http_close_connection(c);
        }
#line 3059
        return;
      }
    }
  }
#line 3063
  (c->log)->action = (char *)"keepalive";
#line 3065
  if (c->tcp_nopush == 1U) {
    {
#line 3066
    tmp___3 = ngx_tcp_push(c->fd);
    }
#line 3066
    if (tmp___3 == -1) {
      {
#line 3067
      tmp___2 = __errno_location();
#line 3067
      ngx_connection_error(c, *tmp___2, (char *)"setsockopt(!TCP_CORK) failed");
#line 3068
      ngx_http_close_connection(c);
      }
#line 3069
      return;
    }
#line 3072
    c->tcp_nopush = 0U;
#line 3073
    if (ngx_tcp_nodelay_and_tcp_nopush) {
#line 3073
      tcp_nodelay = 1;
    } else {
#line 3073
      tcp_nodelay = 0;
    }
  } else {
#line 3076
    tcp_nodelay = 1;
  }
#line 3079
  if (tcp_nodelay) {
#line 3079
    if (clcf->tcp_nodelay) {
      {
#line 3079
      tmp___4 = ngx_tcp_nodelay(c);
      }
#line 3079
      if (tmp___4 != 0L) {
        {
#line 3080
        ngx_http_close_connection(c);
        }
#line 3081
        return;
      }
    }
  }
  {
#line 3089
  c->idle = 1U;
#line 3090
  ngx_reusable_connection(c, (ngx_uint_t )1);
#line 3092
  ngx_event_add_timer(rev, clcf->keepalive_timeout);
  }
#line 3094
  if (rev->ready) {
#line 3095
    if (! rev->posted) {
#line 3095
      rev->posted = 1U;
#line 3095
      rev->queue.prev = ngx_posted_events.prev;
#line 3095
      (rev->queue.prev)->next = & rev->queue;
#line 3095
      rev->queue.next = & ngx_posted_events;
#line 3095
      ngx_posted_events.prev = & rev->queue;
    }
  }
#line 3097
  return;
}
}
#line 3100 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_keepalive_handler(ngx_event_t *rev ) 
{ 
  size_t___0 size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_connection_t *c ;
  void *tmp ;
  int *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  int *tmp___3 ;
  ngx_http_request_t *tmp___4 ;

  {
#line 3108
  c = (ngx_connection_t *)rev->data;
#line 3112
  if (rev->timedout) {
    {
#line 3113
    ngx_http_close_connection(c);
    }
#line 3114
    return;
  } else
#line 3112
  if (c->close) {
    {
#line 3113
    ngx_http_close_connection(c);
    }
#line 3114
    return;
  }
#line 3137
  b = c->buffer;
#line 3138
  size = (size_t___0 )(b->end - b->start);
#line 3140
  if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
    {
#line 3148
    tmp = ngx_palloc(c->pool, size);
#line 3148
    b->pos = (u_char *)tmp;
    }
#line 3149
    if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
      {
#line 3150
      ngx_http_close_connection(c);
      }
#line 3151
      return;
    }
#line 3154
    b->start = b->pos;
#line 3155
    b->last = b->pos;
#line 3156
    b->end = b->pos + size;
  }
  {
#line 3164
  c->log_error = 3U;
#line 3165
  tmp___0 = __errno_location();
#line 3165
  *tmp___0 = 0;
#line 3167
  n = (*(c->recv))(c, b->last, size);
#line 3168
  c->log_error = 2U;
  }
#line 3170
  if (n == -2L) {
    {
#line 3171
    tmp___1 = ngx_handle_read_event(rev, (ngx_uint_t )0);
    }
#line 3171
    if (tmp___1 != 0L) {
      {
#line 3172
      ngx_http_close_connection(c);
      }
#line 3173
      return;
    }
    {
#line 3181
    tmp___2 = ngx_pfree(c->pool, (void *)b->start);
    }
#line 3181
    if (tmp___2 == 0L) {
#line 3187
      b->pos = (u_char *)((void *)0);
    }
#line 3190
    return;
  }
#line 3193
  if (n == -1L) {
    {
#line 3194
    ngx_http_close_connection(c);
    }
#line 3195
    return;
  }
#line 3198
  (c->log)->handler = (u_char *(*)(ngx_log_t *log , u_char *buf , size_t___0 len ))((void *)0);
#line 3200
  if (n == 0L) {
#line 3201
    if ((c->log)->log_level >= 7UL) {
      {
#line 3201
      tmp___3 = __errno_location();
#line 3201
      ngx_log_error_core((ngx_uint_t )7, c->log, *tmp___3, "client %V closed keepalive connection",
                         & c->addr_text);
      }
    }
    {
#line 3203
    ngx_http_close_connection(c);
    }
#line 3204
    return;
  }
  {
#line 3207
  b->last += n;
#line 3209
  (c->log)->handler = & ngx_http_log_error;
#line 3210
  (c->log)->action = (char *)"reading client request line";
#line 3212
  c->idle = 0U;
#line 3213
  ngx_reusable_connection(c, (ngx_uint_t )0);
#line 3215
  tmp___4 = ngx_http_create_request(c);
#line 3215
  c->data = (void *)tmp___4;
  }
#line 3216
  if ((unsigned long )c->data == (unsigned long )((void *)0)) {
    {
#line 3217
    ngx_http_close_connection(c);
    }
#line 3218
    return;
  }
  {
#line 3221
  c->sent = (off_t )0;
#line 3222
  c->destroyed = 0U;
#line 3224
  ngx_event_del_timer(rev);
#line 3226
  rev->handler = & ngx_http_process_request_line;
#line 3227
  ngx_http_process_request_line(rev);
  }
#line 3228
  return;
}
}
#line 3231 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_set_lingering_close(ngx_http_request_t *r ) 
{ 
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3238
  c = r->connection;
#line 3240
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3242
  rev = c->read;
#line 3243
  rev->handler = & ngx_http_lingering_close_handler;
#line 3245
  r->lingering_time = (time_t )(ngx_cached_time->sec + (time_t volatile   )((time_t )(clcf->lingering_time / 1000UL)));
#line 3246
  ngx_event_add_timer(rev, clcf->lingering_timeout);
#line 3248
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 3248
  if (tmp != 0L) {
    {
#line 3249
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3250
    return;
  }
#line 3253
  wev = c->write;
#line 3254
  wev->handler = & ngx_http_empty_handler;
#line 3256
  if (wev->active) {
#line 3256
    if (ngx_event_flags & 1UL) {
      {
#line 3257
      tmp___0 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
      }
#line 3257
      if (tmp___0 != 0L) {
        {
#line 3258
        ngx_http_close_request(r, (ngx_int_t )0);
        }
#line 3259
        return;
      }
    }
  }
  {
#line 3263
  tmp___2 = shutdown(c->fd, 1);
  }
#line 3263
  if (tmp___2 == -1) {
    {
#line 3264
    tmp___1 = __errno_location();
#line 3264
    ngx_connection_error(c, *tmp___1, (char *)"shutdown() failed");
#line 3266
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3267
    return;
  }
#line 3270
  if (rev->ready) {
    {
#line 3271
    ngx_http_lingering_close_handler(rev);
    }
  }
#line 3273
  return;
}
}
#line 3276 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_lingering_close_handler(ngx_event_t *rev ) 
{ 
  ssize_t n ;
  ngx_msec_t timer ;
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char buffer___0[4096] ;
  ngx_int_t tmp ;

  {
#line 3286
  c = (ngx_connection_t *)rev->data;
#line 3287
  r = (ngx_http_request_t *)c->data;
#line 3292
  if (rev->timedout) {
    {
#line 3293
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3294
    return;
  }
#line 3297
  timer = (ngx_msec_t )r->lingering_time - (ngx_msec_t )ngx_cached_time->sec;
#line 3298
  if ((ngx_msec_int_t )timer <= 0L) {
    {
#line 3299
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3300
    return;
  }
  {
#line 3303
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3304
    n = (*(c->recv))(c, buffer___0, (size_t___0 )4096);
    }
#line 3308
    if (n == -1L) {
      {
#line 3309
      ngx_http_close_request(r, (ngx_int_t )0);
      }
#line 3310
      return;
    } else
#line 3308
    if (n == 0L) {
      {
#line 3309
      ngx_http_close_request(r, (ngx_int_t )0);
      }
#line 3310
      return;
    }
#line 3303
    if (! rev->ready) {
#line 3303
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3315
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 3315
  if (tmp != 0L) {
    {
#line 3316
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3317
    return;
  }
#line 3320
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3322
  timer *= 1000UL;
#line 3324
  if (timer > clcf->lingering_timeout) {
#line 3325
    timer = clcf->lingering_timeout;
  }
  {
#line 3328
  ngx_event_add_timer(rev, timer);
  }
#line 3329
  return;
}
}
#line 3332 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_empty_handler(ngx_event_t *wev ) 
{ 


  {
#line 3337
  return;
}
}
#line 3341 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_request_empty_handler(ngx_http_request_t *r ) 
{ 


  {
#line 3347
  return;
}
}
#line 3351 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
ngx_int_t ngx_http_send_special(ngx_http_request_t *r , ngx_uint_t flags ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t out ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3357
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 3357
  b = (ngx_buf_t *)tmp;
  }
#line 3358
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 3359
    return ((ngx_int_t )-1);
  }
#line 3362
  if (flags & 1UL) {
#line 3364
    if ((unsigned long )r == (unsigned long )r->main) {
#line 3364
      if (! r->post_action) {
#line 3365
        b->last_buf = 1U;
      } else {
#line 3368
        b->sync = 1U;
#line 3369
        b->last_in_chain = 1U;
      }
    } else {
#line 3368
      b->sync = 1U;
#line 3369
      b->last_in_chain = 1U;
    }
  }
#line 3373
  if (flags & 2UL) {
#line 3374
    b->flush = 1U;
  }
  {
#line 3377
  out.buf = b;
#line 3378
  out.next = (ngx_chain_t *)((void *)0);
#line 3380
  tmp___0 = ngx_http_output_filter(r, & out);
  }
#line 3380
  return (tmp___0);
}
}
#line 3384 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_post_action(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 3389
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3391
  if ((unsigned long )clcf->post_action.data == (unsigned long )((void *)0)) {
#line 3392
    return ((ngx_int_t )-5);
  }
#line 3395
  if (r->post_action) {
#line 3395
    if (r->uri_changes == 0U) {
#line 3396
      return ((ngx_int_t )-5);
    }
  }
#line 3402
  ((r->main)->count) --;
#line 3404
  r->http_version = (ngx_uint_t )9;
#line 3405
  r->header_only = 1U;
#line 3406
  r->post_action = 1U;
#line 3408
  r->read_event_handler = & ngx_http_block_reading;
#line 3410
  if ((int )*(clcf->post_action.data + 0) == 47) {
    {
#line 3411
    ngx_http_internal_redirect(r, & clcf->post_action, (ngx_str_t *)((void *)0));
    }
  } else {
    {
#line 3414
    ngx_http_named_location(r, & clcf->post_action);
    }
  }
#line 3417
  return ((ngx_int_t )0);
}
}
#line 3421 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_close_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_connection_t *c ;

  {
#line 3426
  r = r->main;
#line 3427
  c = r->connection;
#line 3432
  if (r->count == 0U) {
#line 3433
    if ((c->log)->log_level >= 2UL) {
      {
#line 3433
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "http request count is zero");
      }
    }
  }
#line 3436
  (r->count) --;
#line 3438
  if (r->count) {
#line 3439
    return;
  } else
#line 3438
  if (r->blocked) {
#line 3439
    return;
  }
  {
#line 3449
  ngx_http_free_request(r, rc);
#line 3450
  ngx_http_close_connection(c);
  }
#line 3451
  return;
}
}
#line 3454 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_free_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_log_t *log ;
  ngx_pool_t *pool ;
  struct linger linger ;
  ngx_http_cleanup_t *cln ;
  ngx_http_log_ctx_t *ctx ;
  ngx_http_core_loc_conf_t *clcf ;
  int *tmp ;
  int tmp___0 ;

  {
#line 3464
  log = (r->connection)->log;
#line 3468
  if ((unsigned long )r->pool == (unsigned long )((void *)0)) {
#line 3469
    if (log->log_level >= 2UL) {
      {
#line 3469
      ngx_log_error_core((ngx_uint_t )2, log, 0, "http request already closed");
      }
    }
#line 3470
    return;
  }
#line 3473
  cln = r->cleanup;
#line 3474
  r->cleanup = (ngx_http_cleanup_t *)((void *)0);
  {
#line 3476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3476
    if (! cln) {
#line 3476
      goto while_break;
    }
#line 3477
    if (cln->handler) {
      {
#line 3478
      (*(cln->handler))(cln->data);
      }
    }
#line 3481
    cln = cln->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3496
  if (rc > 0L) {
#line 3496
    if (r->headers_out.status == 0UL) {
#line 3497
      r->headers_out.status = (ngx_uint_t )rc;
    } else
#line 3496
    if ((r->connection)->sent == 0L) {
#line 3497
      r->headers_out.status = (ngx_uint_t )rc;
    }
  }
  {
#line 3500
  log->action = (char *)"logging request";
#line 3502
  ngx_http_log_request(r);
#line 3504
  log->action = (char *)"closing request";
  }
#line 3506
  if ((r->connection)->timedout) {
#line 3507
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3509
    if (clcf->reset_timedout_connection) {
      {
#line 3510
      linger.l_onoff = 1;
#line 3511
      linger.l_linger = 0;
#line 3513
      tmp___0 = setsockopt((r->connection)->fd, 1, 13, (void const   *)(& linger),
                           (socklen_t )sizeof(struct linger ));
      }
#line 3513
      if (tmp___0 == -1) {
#line 3516
        if (log->log_level >= 2UL) {
          {
#line 3516
          tmp = __errno_location();
#line 3516
          ngx_log_error_core((ngx_uint_t )2, log, *tmp, "setsockopt(SO_LINGER) failed");
          }
        }
      }
    }
  }
  {
#line 3523
  ctx = (ngx_http_log_ctx_t *)log->data;
#line 3524
  ctx->request = (ngx_http_request_t *)((void *)0);
#line 3526
  r->request_line.len = (size_t___0 )0;
#line 3528
  (r->connection)->destroyed = 1U;
#line 3535
  pool = r->pool;
#line 3536
  r->pool = (ngx_pool_t *)((void *)0);
#line 3538
  ngx_destroy_pool(pool);
  }
#line 3539
  return;
}
}
#line 3542 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static void ngx_http_log_request(ngx_http_request_t *r ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_handler_pt *log_handler ;
  ngx_http_core_main_conf_t *cmcf ;

  {
#line 3549
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 3551
  log_handler = (ngx_http_handler_pt *)cmcf->phases[10].handlers.elts;
#line 3552
  n = cmcf->phases[10].handlers.nelts;
#line 3554
  i = (ngx_uint_t )0;
  {
#line 3554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3554
    if (! (i < n)) {
#line 3554
      goto while_break;
    }
    {
#line 3555
    (*(*(log_handler + i)))(r);
#line 3554
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3557
  return;
}
}
#line 3560 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
void ngx_http_close_connection(ngx_connection_t *c ) 
{ 
  ngx_pool_t *pool ;

  {
  {
#line 3583
  c->destroyed = 1U;
#line 3585
  pool = c->pool;
#line 3587
  ngx_close_connection(c);
#line 3589
  ngx_destroy_pool(pool);
  }
#line 3590
  return;
}
}
#line 3593 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static u_char *ngx_http_log_error(ngx_log_t *log , u_char *buf , size_t___0 len ) 
{ 
  u_char *p ;
  ngx_http_request_t *r ;
  ngx_http_log_ctx_t *ctx ;
  u_char *tmp ;

  {
#line 3600
  if (log->action) {
    {
#line 3601
    p = ngx_snprintf(buf, len, " while %s", log->action);
#line 3602
    len -= (size_t___0 )(p - buf);
#line 3603
    buf = p;
    }
  }
  {
#line 3606
  ctx = (ngx_http_log_ctx_t *)log->data;
#line 3608
  p = ngx_snprintf(buf, len, ", client: %V", & (ctx->connection)->addr_text);
#line 3609
  len -= (size_t___0 )(p - buf);
#line 3611
  r = ctx->request;
  }
#line 3613
  if (r) {
    {
#line 3614
    tmp = (*(r->log_handler))(r, ctx->current_request, p, len);
    }
#line 3614
    return (tmp);
  } else {
    {
#line 3617
    p = ngx_snprintf(p, len, ", server: %V", & ((ctx->connection)->listening)->addr_text);
    }
  }
#line 3621
  return (p);
}
}
#line 3625 "/tmp/nginx-1.13.2/src/http/ngx_http_request.c"
static u_char *ngx_http_log_error_handler(ngx_http_request_t *r , ngx_http_request_t *sr ,
                                          u_char *buf , size_t___0 len ) 
{ 
  char *uri_separator ;
  u_char *p ;
  ngx_http_upstream_t *u ;
  ngx_http_core_srv_conf_t *cscf ;

  {
  {
#line 3634
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 3636
  p = ngx_snprintf(buf, len, ", server: %V", & cscf->server_name);
#line 3637
  len -= (size_t___0 )(p - buf);
#line 3638
  buf = p;
  }
#line 3640
  if ((unsigned long )r->request_line.data == (unsigned long )((void *)0)) {
#line 3640
    if (r->request_start) {
#line 3641
      p = r->request_start;
      {
#line 3641
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3641
        if (! ((unsigned long )p < (unsigned long )(r->header_in)->last)) {
#line 3641
          goto while_break;
        }
#line 3642
        if ((int )*p == 13) {
#line 3643
          goto while_break;
        } else
#line 3642
        if ((int )*p == 10) {
#line 3643
          goto while_break;
        }
#line 3641
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 3647
      r->request_line.len = (size_t___0 )(p - r->request_start);
#line 3648
      r->request_line.data = r->request_start;
    }
  }
#line 3651
  if (r->request_line.len) {
    {
#line 3652
    p = ngx_snprintf(buf, len, ", request: \"%V\"", & r->request_line);
#line 3653
    len -= (size_t___0 )(p - buf);
#line 3654
    buf = p;
    }
  }
#line 3657
  if ((unsigned long )r != (unsigned long )sr) {
    {
#line 3658
    p = ngx_snprintf(buf, len, ", subrequest: \"%V\"", & sr->uri);
#line 3659
    len -= (size_t___0 )(p - buf);
#line 3660
    buf = p;
    }
  }
#line 3663
  u = sr->upstream;
#line 3665
  if (u) {
#line 3665
    if (u->peer.name) {
#line 3667
      uri_separator = (char *)"";
#line 3670
      if (u->peer.sockaddr) {
#line 3670
        if ((int )(u->peer.sockaddr)->sa_family == 1) {
#line 3671
          uri_separator = (char *)":";
        }
      }
      {
#line 3675
      p = ngx_snprintf(buf, len, ", upstream: \"%V%V%s%V\"", & u->schema, u->peer.name,
                       uri_separator, & u->uri);
#line 3678
      len -= (size_t___0 )(p - buf);
#line 3679
      buf = p;
      }
    }
  }
#line 3682
  if (r->headers_in.host) {
    {
#line 3683
    p = ngx_snprintf(buf, len, ", host: \"%V\"", & (r->headers_in.host)->value);
#line 3685
    len -= (size_t___0 )(p - buf);
#line 3686
    buf = p;
    }
  }
#line 3689
  if (r->headers_in.referer) {
    {
#line 3690
    p = ngx_snprintf(buf, len, ", referrer: \"%V\"", & (r->headers_in.referer)->value);
#line 3692
    buf = p;
    }
  }
#line 3695
  return (buf);
}
}
#line 145 "src/http/ngx_http.h"
void ngx_http_clean_header(ngx_http_request_t *r ) ;
#line 14 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_error_page(ngx_http_request_t *r , ngx_http_err_page_t *err_page ) ;
#line 16
static ngx_int_t ngx_http_send_special_response(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                                ngx_uint_t err ) ;
#line 18
static ngx_int_t ngx_http_send_refresh(ngx_http_request_t *r ) ;
#line 21 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static u_char ngx_http_error_full_tail[54]  = 
#line 21
  {      (u_char )'<',      (u_char )'h',      (u_char )'r',      (u_char )'>', 
        (u_char )'<',      (u_char )'c',      (u_char )'e',      (u_char )'n', 
        (u_char )'t',      (u_char )'e',      (u_char )'r',      (u_char )'>', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'2', 
        (u_char )'<',      (u_char )'/',      (u_char )'c',      (u_char )'e', 
        (u_char )'n',      (u_char )'t',      (u_char )'e',      (u_char )'r', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'/',      (u_char )'b',      (u_char )'o',      (u_char )'d', 
        (u_char )'y',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'/',      (u_char )'h',      (u_char )'t', 
        (u_char )'m',      (u_char )'l',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'\000'};
#line 28 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static u_char ngx_http_error_build_tail[54]  = 
#line 28
  {      (u_char )'<',      (u_char )'h',      (u_char )'r',      (u_char )'>', 
        (u_char )'<',      (u_char )'c',      (u_char )'e',      (u_char )'n', 
        (u_char )'t',      (u_char )'e',      (u_char )'r',      (u_char )'>', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'2', 
        (u_char )'<',      (u_char )'/',      (u_char )'c',      (u_char )'e', 
        (u_char )'n',      (u_char )'t',      (u_char )'e',      (u_char )'r', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'/',      (u_char )'b',      (u_char )'o',      (u_char )'d', 
        (u_char )'y',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'/',      (u_char )'h',      (u_char )'t', 
        (u_char )'m',      (u_char )'l',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'\000'};
#line 35 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static u_char ngx_http_error_tail[47]  = 
#line 35
  {      (u_char )'<',      (u_char )'h',      (u_char )'r',      (u_char )'>', 
        (u_char )'<',      (u_char )'c',      (u_char )'e',      (u_char )'n', 
        (u_char )'t',      (u_char )'e',      (u_char )'r',      (u_char )'>', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'<',      (u_char )'/',      (u_char )'c', 
        (u_char )'e',      (u_char )'n',      (u_char )'t',      (u_char )'e', 
        (u_char )'r',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'/',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'/',      (u_char )'h', 
        (u_char )'t',      (u_char )'m',      (u_char )'l',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 42 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static u_char ngx_http_msie_padding[403]  = 
#line 42
  {      (u_char )'<',      (u_char )'!',      (u_char )'-',      (u_char )'-', 
        (u_char )' ',      (u_char )'a',      (u_char )' ',      (u_char )'p', 
        (u_char )'a',      (u_char )'d',      (u_char )'d',      (u_char )'i', 
        (u_char )'n',      (u_char )'g',      (u_char )' ',      (u_char )'t', 
        (u_char )'o',      (u_char )' ',      (u_char )'d',      (u_char )'i', 
        (u_char )'s',      (u_char )'a',      (u_char )'b',      (u_char )'l', 
        (u_char )'e',      (u_char )' ',      (u_char )'M',      (u_char )'S', 
        (u_char )'I',      (u_char )'E',      (u_char )' ',      (u_char )'a', 
        (u_char )'n',      (u_char )'d',      (u_char )' ',      (u_char )'C', 
        (u_char )'h',      (u_char )'r',      (u_char )'o',      (u_char )'m', 
        (u_char )'e',      (u_char )' ',      (u_char )'f',      (u_char )'r', 
        (u_char )'i',      (u_char )'e',      (u_char )'n',      (u_char )'d', 
        (u_char )'l',      (u_char )'y',      (u_char )' ',      (u_char )'e', 
        (u_char )'r',      (u_char )'r',      (u_char )'o',      (u_char )'r', 
        (u_char )' ',      (u_char )'p',      (u_char )'a',      (u_char )'g', 
        (u_char )'e',      (u_char )' ',      (u_char )'-',      (u_char )'-', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'!',      (u_char )'-',      (u_char )'-',      (u_char )' ', 
        (u_char )'a',      (u_char )' ',      (u_char )'p',      (u_char )'a', 
        (u_char )'d',      (u_char )'d',      (u_char )'i',      (u_char )'n', 
        (u_char )'g',      (u_char )' ',      (u_char )'t',      (u_char )'o', 
        (u_char )' ',      (u_char )'d',      (u_char )'i',      (u_char )'s', 
        (u_char )'a',      (u_char )'b',      (u_char )'l',      (u_char )'e', 
        (u_char )' ',      (u_char )'M',      (u_char )'S',      (u_char )'I', 
        (u_char )'E',      (u_char )' ',      (u_char )'a',      (u_char )'n', 
        (u_char )'d',      (u_char )' ',      (u_char )'C',      (u_char )'h', 
        (u_char )'r',      (u_char )'o',      (u_char )'m',      (u_char )'e', 
        (u_char )' ',      (u_char )'f',      (u_char )'r',      (u_char )'i', 
        (u_char )'e',      (u_char )'n',      (u_char )'d',      (u_char )'l', 
        (u_char )'y',      (u_char )' ',      (u_char )'e',      (u_char )'r', 
        (u_char )'r',      (u_char )'o',      (u_char )'r',      (u_char )' ', 
        (u_char )'p',      (u_char )'a',      (u_char )'g',      (u_char )'e', 
        (u_char )' ',      (u_char )'-',      (u_char )'-',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'<',      (u_char )'!', 
        (u_char )'-',      (u_char )'-',      (u_char )' ',      (u_char )'a', 
        (u_char )' ',      (u_char )'p',      (u_char )'a',      (u_char )'d', 
        (u_char )'d',      (u_char )'i',      (u_char )'n',      (u_char )'g', 
        (u_char )' ',      (u_char )'t',      (u_char )'o',      (u_char )' ', 
        (u_char )'d',      (u_char )'i',      (u_char )'s',      (u_char )'a', 
        (u_char )'b',      (u_char )'l',      (u_char )'e',      (u_char )' ', 
        (u_char )'M',      (u_char )'S',      (u_char )'I',      (u_char )'E', 
        (u_char )' ',      (u_char )'a',      (u_char )'n',      (u_char )'d', 
        (u_char )' ',      (u_char )'C',      (u_char )'h',      (u_char )'r', 
        (u_char )'o',      (u_char )'m',      (u_char )'e',      (u_char )' ', 
        (u_char )'f',      (u_char )'r',      (u_char )'i',      (u_char )'e', 
        (u_char )'n',      (u_char )'d',      (u_char )'l',      (u_char )'y', 
        (u_char )' ',      (u_char )'e',      (u_char )'r',      (u_char )'r', 
        (u_char )'o',      (u_char )'r',      (u_char )' ',      (u_char )'p', 
        (u_char )'a',      (u_char )'g',      (u_char )'e',      (u_char )' ', 
        (u_char )'-',      (u_char )'-',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'!',      (u_char )'-', 
        (u_char )'-',      (u_char )' ',      (u_char )'a',      (u_char )' ', 
        (u_char )'p',      (u_char )'a',      (u_char )'d',      (u_char )'d', 
        (u_char )'i',      (u_char )'n',      (u_char )'g',      (u_char )' ', 
        (u_char )'t',      (u_char )'o',      (u_char )' ',      (u_char )'d', 
        (u_char )'i',      (u_char )'s',      (u_char )'a',      (u_char )'b', 
        (u_char )'l',      (u_char )'e',      (u_char )' ',      (u_char )'M', 
        (u_char )'S',      (u_char )'I',      (u_char )'E',      (u_char )' ', 
        (u_char )'a',      (u_char )'n',      (u_char )'d',      (u_char )' ', 
        (u_char )'C',      (u_char )'h',      (u_char )'r',      (u_char )'o', 
        (u_char )'m',      (u_char )'e',      (u_char )' ',      (u_char )'f', 
        (u_char )'r',      (u_char )'i',      (u_char )'e',      (u_char )'n', 
        (u_char )'d',      (u_char )'l',      (u_char )'y',      (u_char )' ', 
        (u_char )'e',      (u_char )'r',      (u_char )'r',      (u_char )'o', 
        (u_char )'r',      (u_char )' ',      (u_char )'p',      (u_char )'a', 
        (u_char )'g',      (u_char )'e',      (u_char )' ',      (u_char )'-', 
        (u_char )'-',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'!',      (u_char )'-',      (u_char )'-', 
        (u_char )' ',      (u_char )'a',      (u_char )' ',      (u_char )'p', 
        (u_char )'a',      (u_char )'d',      (u_char )'d',      (u_char )'i', 
        (u_char )'n',      (u_char )'g',      (u_char )' ',      (u_char )'t', 
        (u_char )'o',      (u_char )' ',      (u_char )'d',      (u_char )'i', 
        (u_char )'s',      (u_char )'a',      (u_char )'b',      (u_char )'l', 
        (u_char )'e',      (u_char )' ',      (u_char )'M',      (u_char )'S', 
        (u_char )'I',      (u_char )'E',      (u_char )' ',      (u_char )'a', 
        (u_char )'n',      (u_char )'d',      (u_char )' ',      (u_char )'C', 
        (u_char )'h',      (u_char )'r',      (u_char )'o',      (u_char )'m', 
        (u_char )'e',      (u_char )' ',      (u_char )'f',      (u_char )'r', 
        (u_char )'i',      (u_char )'e',      (u_char )'n',      (u_char )'d', 
        (u_char )'l',      (u_char )'y',      (u_char )' ',      (u_char )'e', 
        (u_char )'r',      (u_char )'r',      (u_char )'o',      (u_char )'r', 
        (u_char )' ',      (u_char )'p',      (u_char )'a',      (u_char )'g', 
        (u_char )'e',      (u_char )' ',      (u_char )'-',      (u_char )'-', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'!',      (u_char )'-',      (u_char )'-',      (u_char )' ', 
        (u_char )'a',      (u_char )' ',      (u_char )'p',      (u_char )'a', 
        (u_char )'d',      (u_char )'d',      (u_char )'i',      (u_char )'n', 
        (u_char )'g',      (u_char )' ',      (u_char )'t',      (u_char )'o', 
        (u_char )' ',      (u_char )'d',      (u_char )'i',      (u_char )'s', 
        (u_char )'a',      (u_char )'b',      (u_char )'l',      (u_char )'e', 
        (u_char )' ',      (u_char )'M',      (u_char )'S',      (u_char )'I', 
        (u_char )'E',      (u_char )' ',      (u_char )'a',      (u_char )'n', 
        (u_char )'d',      (u_char )' ',      (u_char )'C',      (u_char )'h', 
        (u_char )'r',      (u_char )'o',      (u_char )'m',      (u_char )'e', 
        (u_char )' ',      (u_char )'f',      (u_char )'r',      (u_char )'i', 
        (u_char )'e',      (u_char )'n',      (u_char )'d',      (u_char )'l', 
        (u_char )'y',      (u_char )' ',      (u_char )'e',      (u_char )'r', 
        (u_char )'r',      (u_char )'o',      (u_char )'r',      (u_char )' ', 
        (u_char )'p',      (u_char )'a',      (u_char )'g',      (u_char )'e', 
        (u_char )' ',      (u_char )'-',      (u_char )'-',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 52 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static u_char ngx_http_msie_refresh_head[56]  = 
#line 52
  {      (u_char )'<',      (u_char )'h',      (u_char )'t',      (u_char )'m', 
        (u_char )'l',      (u_char )'>',      (u_char )'<',      (u_char )'h', 
        (u_char )'e',      (u_char )'a',      (u_char )'d',      (u_char )'>', 
        (u_char )'<',      (u_char )'m',      (u_char )'e',      (u_char )'t', 
        (u_char )'a',      (u_char )' ',      (u_char )'h',      (u_char )'t', 
        (u_char )'t',      (u_char )'p',      (u_char )'-',      (u_char )'e', 
        (u_char )'q',      (u_char )'u',      (u_char )'i',      (u_char )'v', 
        (u_char )'=',      (u_char )'\"',      (u_char )'R',      (u_char )'e', 
        (u_char )'f',      (u_char )'r',      (u_char )'e',      (u_char )'s', 
        (u_char )'h',      (u_char )'\"',      (u_char )' ',      (u_char )'c', 
        (u_char )'o',      (u_char )'n',      (u_char )'t',      (u_char )'e', 
        (u_char )'n',      (u_char )'t',      (u_char )'=',      (u_char )'\"', 
        (u_char )'0',      (u_char )';',      (u_char )' ',      (u_char )'U', 
        (u_char )'R',      (u_char )'L',      (u_char )'=',      (u_char )'\000'};
#line 56 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static u_char ngx_http_msie_refresh_tail[32]  = 
#line 56
  {      (u_char )'\"',      (u_char )'>',      (u_char )'<',      (u_char )'/', 
        (u_char )'h',      (u_char )'e',      (u_char )'a',      (u_char )'d', 
        (u_char )'>',      (u_char )'<',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )'>',      (u_char )'<', 
        (u_char )'/',      (u_char )'b',      (u_char )'o',      (u_char )'d', 
        (u_char )'y',      (u_char )'>',      (u_char )'<',      (u_char )'/', 
        (u_char )'h',      (u_char )'t',      (u_char )'m',      (u_char )'l', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 60 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_301_page[133]  = 
#line 60
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'1', 
        (char )' ',      (char )'M',      (char )'o',      (char )'v', 
        (char )'e',      (char )'d',      (char )' ',      (char )'P', 
        (char )'e',      (char )'r',      (char )'m',      (char )'a', 
        (char )'n',      (char )'e',      (char )'n',      (char )'t', 
        (char )'l',      (char )'y',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'3', 
        (char )'0',      (char )'1',      (char )' ',      (char )'M', 
        (char )'o',      (char )'v',      (char )'e',      (char )'d', 
        (char )' ',      (char )'P',      (char )'e',      (char )'r', 
        (char )'m',      (char )'a',      (char )'n',      (char )'e', 
        (char )'n',      (char )'t',      (char )'l',      (char )'y', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 68 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_302_page[109]  = 
#line 68
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'2', 
        (char )' ',      (char )'F',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'3', 
        (char )'0',      (char )'2',      (char )' ',      (char )'F', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 76 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_303_page[117]  = 
#line 76
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'3', 
        (char )' ',      (char )'S',      (char )'e',      (char )'e', 
        (char )' ',      (char )'O',      (char )'t',      (char )'h', 
        (char )'e',      (char )'r',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'3', 
        (char )'0',      (char )'3',      (char )' ',      (char )'S', 
        (char )'e',      (char )'e',      (char )' ',      (char )'O', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 84 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_307_page[135]  = 
#line 84
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'7', 
        (char )' ',      (char )'T',      (char )'e',      (char )'m', 
        (char )'p',      (char )'o',      (char )'r',      (char )'a', 
        (char )'r',      (char )'y',      (char )' ',      (char )'R', 
        (char )'e',      (char )'d',      (char )'i',      (char )'r', 
        (char )'e',      (char )'c',      (char )'t',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'3',      (char )'0',      (char )'7',      (char )' ', 
        (char )'T',      (char )'e',      (char )'m',      (char )'p', 
        (char )'o',      (char )'r',      (char )'a',      (char )'r', 
        (char )'y',      (char )' ',      (char )'R',      (char )'e', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 92 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_308_page[135]  = 
#line 92
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'8', 
        (char )' ',      (char )'P',      (char )'e',      (char )'r', 
        (char )'m',      (char )'a',      (char )'n',      (char )'e', 
        (char )'n',      (char )'t',      (char )' ',      (char )'R', 
        (char )'e',      (char )'d',      (char )'i',      (char )'r', 
        (char )'e',      (char )'c',      (char )'t',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'3',      (char )'0',      (char )'8',      (char )' ', 
        (char )'P',      (char )'e',      (char )'r',      (char )'m', 
        (char )'a',      (char )'n',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'R',      (char )'e', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 100 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_400_page[121]  = 
#line 100
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 108 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_401_page[143]  = 
#line 108
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'1', 
        (char )' ',      (char )'A',      (char )'u',      (char )'t', 
        (char )'h',      (char )'o',      (char )'r',      (char )'i', 
        (char )'z',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'i', 
        (char )'r',      (char )'e',      (char )'d',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'0',      (char )'1',      (char )' ', 
        (char )'A',      (char )'u',      (char )'t',      (char )'h', 
        (char )'o',      (char )'r',      (char )'i',      (char )'z', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'i',      (char )'r', 
        (char )'e',      (char )'d',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 116 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_402_page[131]  = 
#line 116
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'2', 
        (char )' ',      (char )'P',      (char )'a',      (char )'y', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'i',      (char )'r',      (char )'e', 
        (char )'d',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'2',      (char )' ',      (char )'P',      (char )'a', 
        (char )'y',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'i',      (char )'r', 
        (char )'e',      (char )'d',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 124 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_403_page[117]  = 
#line 124
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'3', 
        (char )' ',      (char )'F',      (char )'o',      (char )'r', 
        (char )'b',      (char )'i',      (char )'d',      (char )'d', 
        (char )'e',      (char )'n',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'3',      (char )' ',      (char )'F', 
        (char )'o',      (char )'r',      (char )'b',      (char )'i', 
        (char )'d',      (char )'d',      (char )'e',      (char )'n', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 132 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_404_page[117]  = 
#line 132
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'4', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'F',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'4',      (char )' ',      (char )'N', 
        (char )'o',      (char )'t',      (char )' ',      (char )'F', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 140 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_405_page[121]  = 
#line 140
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'5', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'A',      (char )'l',      (char )'l', 
        (char )'o',      (char )'w',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'0',      (char )'5', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'A',      (char )'l',      (char )'l', 
        (char )'o',      (char )'w',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 148 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_406_page[127]  = 
#line 148
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'6', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'A',      (char )'c',      (char )'c', 
        (char )'e',      (char )'p',      (char )'t',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'0',      (char )'6',      (char )' ', 
        (char )'N',      (char )'o',      (char )'t',      (char )' ', 
        (char )'A',      (char )'c',      (char )'c',      (char )'e', 
        (char )'p',      (char )'t',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 156 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_408_page[131]  = 
#line 156
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'8', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'T',      (char )'i',      (char )'m', 
        (char )'e',      (char )'-',      (char )'o',      (char )'u', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'8',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'T',      (char )'i', 
        (char )'m',      (char )'e',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 164 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_409_page[115]  = 
#line 164
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'9', 
        (char )' ',      (char )'C',      (char )'o',      (char )'n', 
        (char )'f',      (char )'l',      (char )'i',      (char )'c', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'9',      (char )' ',      (char )'C',      (char )'o', 
        (char )'n',      (char )'f',      (char )'l',      (char )'i', 
        (char )'c',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 172 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_410_page[107]  = 
#line 172
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'0', 
        (char )' ',      (char )'G',      (char )'o',      (char )'n', 
        (char )'e',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'1', 
        (char )'0',      (char )' ',      (char )'G',      (char )'o', 
        (char )'n',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 180 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_411_page[129]  = 
#line 180
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'1', 
        (char )' ',      (char )'L',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'1',      (char )'1', 
        (char )' ',      (char )'L',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 188 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_412_page[137]  = 
#line 188
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'2', 
        (char )' ',      (char )'P',      (char )'r',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )'i',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'F',      (char )'a', 
        (char )'i',      (char )'l',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'1',      (char )'2', 
        (char )' ',      (char )'P',      (char )'r',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )'i',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'F',      (char )'a', 
        (char )'i',      (char )'l',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 196 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_413_page[147]  = 
#line 196
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'3', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'E',      (char )'n',      (char )'t', 
        (char )'i',      (char )'t',      (char )'y',      (char )' ', 
        (char )'T',      (char )'o',      (char )'o',      (char )' ', 
        (char )'L',      (char )'a',      (char )'r',      (char )'g', 
        (char )'e',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'1', 
        (char )'3',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'E',      (char )'n', 
        (char )'t',      (char )'i',      (char )'t',      (char )'y', 
        (char )' ',      (char )'T',      (char )'o',      (char )'o', 
        (char )' ',      (char )'L',      (char )'a',      (char )'r', 
        (char )'g',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 204 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_414_page[141]  = 
#line 204
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'4', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'-',      (char )'U',      (char )'R',      (char )'I', 
        (char )' ',      (char )'T',      (char )'o',      (char )'o', 
        (char )' ',      (char )'L',      (char )'a',      (char )'r', 
        (char )'g',      (char )'e',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'1',      (char )'4',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )'-',      (char )'U', 
        (char )'R',      (char )'I',      (char )' ',      (char )'T', 
        (char )'o',      (char )'o',      (char )' ',      (char )'L', 
        (char )'a',      (char )'r',      (char )'g',      (char )'e', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 212 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_415_page[143]  = 
#line 212
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'5', 
        (char )' ',      (char )'U',      (char )'n',      (char )'s', 
        (char )'u',      (char )'p',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'M',      (char )'e',      (char )'d', 
        (char )'i',      (char )'a',      (char )' ',      (char )'T', 
        (char )'y',      (char )'p',      (char )'e',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'1',      (char )'5',      (char )' ', 
        (char )'U',      (char )'n',      (char )'s',      (char )'u', 
        (char )'p',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'M',      (char )'e',      (char )'d',      (char )'i', 
        (char )'a',      (char )' ',      (char )'T',      (char )'y', 
        (char )'p',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 220 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_416_page[161]  = 
#line 220
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'6', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'e',      (char )'d',      (char )' ',      (char )'R', 
        (char )'a',      (char )'n',      (char )'g',      (char )'e', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'S',      (char )'a',      (char )'t', 
        (char )'i',      (char )'s',      (char )'f',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'1',      (char )'6', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'e',      (char )'d',      (char )' ',      (char )'R', 
        (char )'a',      (char )'n',      (char )'g',      (char )'e', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'S',      (char )'a',      (char )'t', 
        (char )'i',      (char )'s',      (char )'f',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 228 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_421_page[137]  = 
#line 228
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'2',      (char )'1', 
        (char )' ',      (char )'M',      (char )'i',      (char )'s', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'2',      (char )'1', 
        (char )' ',      (char )'M',      (char )'i',      (char )'s', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 236 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_429_page[133]  = 
#line 236
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'2',      (char )'9', 
        (char )' ',      (char )'T',      (char )'o',      (char )'o', 
        (char )' ',      (char )'M',      (char )'a',      (char )'n', 
        (char )'y',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )'s',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'2',      (char )'9',      (char )' ',      (char )'T', 
        (char )'o',      (char )'o',      (char )' ',      (char )'M', 
        (char )'a',      (char )'n',      (char )'y',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'s',      (char )'t',      (char )'s', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 244 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_494_page[197]  = 
#line 244
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'H',      (char )'e',      (char )'a', 
        (char )'d',      (char )'e',      (char )'r',      (char )' ', 
        (char )'O',      (char )'r',      (char )' ',      (char )'C', 
        (char )'o',      (char )'o',      (char )'k',      (char )'i', 
        (char )'e',      (char )' ',      (char )'T',      (char )'o', 
        (char )'o',      (char )' ',      (char )'L',      (char )'a', 
        (char )'r',      (char )'g',      (char )'e',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'0',      (char )'0',      (char )' ', 
        (char )'B',      (char )'a',      (char )'d',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'s',      (char )'t',      (char )'<', 
        (char )'/',      (char )'h',      (char )'1',      (char )'>', 
        (char )'<',      (char )'/',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )' ',      (char )'H', 
        (char )'e',      (char )'a',      (char )'d',      (char )'e', 
        (char )'r',      (char )' ',      (char )'O',      (char )'r', 
        (char )' ',      (char )'C',      (char )'o',      (char )'o', 
        (char )'k',      (char )'i',      (char )'e',      (char )' ', 
        (char )'T',      (char )'o',      (char )'o',      (char )' ', 
        (char )'L',      (char )'a',      (char )'r',      (char )'g', 
        (char )'e',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 254 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_495_page[179]  = 
#line 254
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'S',      (char )'S',      (char )'L', 
        (char )' ',      (char )'c',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'f',      (char )'i', 
        (char )'c',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'e',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'0',      (char )' ',      (char )'B', 
        (char )'a',      (char )'d',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'S',      (char )'S', 
        (char )'L',      (char )' ',      (char )'c',      (char )'e', 
        (char )'r',      (char )'t',      (char )'i',      (char )'f', 
        (char )'i',      (char )'c',      (char )'a',      (char )'t', 
        (char )'e',      (char )' ',      (char )'e',      (char )'r', 
        (char )'r',      (char )'o',      (char )'r',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 264 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_496_page[201]  = 
#line 264
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'N',      (char )'o',      (char )' ', 
        (char )'r',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )' ',      (char )'S',      (char )'S',      (char )'L', 
        (char )' ',      (char )'c',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'f',      (char )'i', 
        (char )'c',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'w',      (char )'a',      (char )'s', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'0',      (char )' ',      (char )'B',      (char )'a', 
        (char )'d',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )'<',      (char )'/',      (char )'h', 
        (char )'1',      (char )'>',      (char )'<',      (char )'/', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'N',      (char )'o',      (char )' ', 
        (char )'r',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )' ',      (char )'S',      (char )'S',      (char )'L', 
        (char )' ',      (char )'c',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'f',      (char )'i', 
        (char )'c',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'w',      (char )'a',      (char )'s', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'t',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 274 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_497_page[219]  = 
#line 274
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'p',      (char )'l',      (char )'a', 
        (char )'i',      (char )'n',      (char )' ',      (char )'H', 
        (char )'T',      (char )'T',      (char )'P',      (char )' ', 
        (char )'r',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'s',      (char )'t',      (char )' ', 
        (char )'w',      (char )'a',      (char )'s',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )'S',      (char )' ',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'0',      (char )' ',      (char )'B', 
        (char )'a',      (char )'d',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'p',      (char )'l', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )' ',      (char )'r',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'w',      (char )'a',      (char )'s', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'S',      (char )' ',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 284 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_500_page[141]  = 
#line 284
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'0', 
        (char )' ',      (char )'I',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'n',      (char )'a', 
        (char )'l',      (char )' ',      (char )'S',      (char )'e', 
        (char )'r',      (char )'v',      (char )'e',      (char )'r', 
        (char )' ',      (char )'E',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'5', 
        (char )'0',      (char )'0',      (char )' ',      (char )'I', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'n',      (char )'a',      (char )'l',      (char )' ', 
        (char )'S',      (char )'e',      (char )'r',      (char )'v', 
        (char )'e',      (char )'r',      (char )' ',      (char )'E', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 292 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_501_page[129]  = 
#line 292
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'1', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'I',      (char )'m',      (char )'p', 
        (char )'l',      (char )'e',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'5',      (char )'0',      (char )'1', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'I',      (char )'m',      (char )'p', 
        (char )'l',      (char )'e',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 300 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_502_page[121]  = 
#line 300
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'2', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'G',      (char )'a',      (char )'t', 
        (char )'e',      (char )'w',      (char )'a',      (char )'y', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'5',      (char )'0',      (char )'2', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'G',      (char )'a',      (char )'t', 
        (char )'e',      (char )'w',      (char )'a',      (char )'y', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 308 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_503_page[161]  = 
#line 308
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'3', 
        (char )' ',      (char )'S',      (char )'e',      (char )'r', 
        (char )'v',      (char )'i',      (char )'c',      (char )'e', 
        (char )' ',      (char )'T',      (char )'e',      (char )'m', 
        (char )'p',      (char )'o',      (char )'r',      (char )'a', 
        (char )'r',      (char )'i',      (char )'l',      (char )'y', 
        (char )' ',      (char )'U',      (char )'n',      (char )'a', 
        (char )'v',      (char )'a',      (char )'i',      (char )'l', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'5',      (char )'0',      (char )'3', 
        (char )' ',      (char )'S',      (char )'e',      (char )'r', 
        (char )'v',      (char )'i',      (char )'c',      (char )'e', 
        (char )' ',      (char )'T',      (char )'e',      (char )'m', 
        (char )'p',      (char )'o',      (char )'r',      (char )'a', 
        (char )'r',      (char )'i',      (char )'l',      (char )'y', 
        (char )' ',      (char )'U',      (char )'n',      (char )'a', 
        (char )'v',      (char )'a',      (char )'i',      (char )'l', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 316 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_504_page[131]  = 
#line 316
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'4', 
        (char )' ',      (char )'G',      (char )'a',      (char )'t', 
        (char )'e',      (char )'w',      (char )'a',      (char )'y', 
        (char )' ',      (char )'T',      (char )'i',      (char )'m', 
        (char )'e',      (char )'-',      (char )'o',      (char )'u', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'5',      (char )'0', 
        (char )'4',      (char )' ',      (char )'G',      (char )'a', 
        (char )'t',      (char )'e',      (char )'w',      (char )'a', 
        (char )'y',      (char )' ',      (char )'T',      (char )'i', 
        (char )'m',      (char )'e',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 324 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_505_page[151]  = 
#line 324
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'5', 
        (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )' ',      (char )'V',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'N',      (char )'o', 
        (char )'t',      (char )' ',      (char )'S',      (char )'u', 
        (char )'p',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'e',      (char )'d',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'5',      (char )'0',      (char )'5',      (char )' ', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )' ',      (char )'V',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'S',      (char )'u',      (char )'p', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'e',      (char )'d',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 332 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static char ngx_http_error_507_page[139]  = 
#line 332
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'7', 
        (char )' ',      (char )'I',      (char )'n',      (char )'s', 
        (char )'u',      (char )'f',      (char )'f',      (char )'i', 
        (char )'c',      (char )'i',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'S',      (char )'t', 
        (char )'o',      (char )'r',      (char )'a',      (char )'g', 
        (char )'e',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'5',      (char )'0', 
        (char )'7',      (char )' ',      (char )'I',      (char )'n', 
        (char )'s',      (char )'u',      (char )'f',      (char )'f', 
        (char )'i',      (char )'c',      (char )'i',      (char )'e', 
        (char )'n',      (char )'t',      (char )' ',      (char )'S', 
        (char )'t',      (char )'o',      (char )'r',      (char )'a', 
        (char )'g',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 340 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static ngx_str_t ngx_http_error_pages[53]  = 
#line 340
  {      {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_301_page) - 1UL, (u_char *)(ngx_http_error_301_page)}, 
        {sizeof(ngx_http_error_302_page) - 1UL,
      (u_char *)(ngx_http_error_302_page)}, 
        {sizeof(ngx_http_error_303_page) - 1UL, (u_char *)(ngx_http_error_303_page)}, 
        {(size_t___0 )0,
      (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_307_page) - 1UL, (u_char *)(ngx_http_error_307_page)}, 
        {sizeof(ngx_http_error_308_page) - 1UL,
      (u_char *)(ngx_http_error_308_page)}, 
        {sizeof(ngx_http_error_400_page) - 1UL, (u_char *)(ngx_http_error_400_page)}, 
        {sizeof(ngx_http_error_401_page) - 1UL,
      (u_char *)(ngx_http_error_401_page)}, 
        {sizeof(ngx_http_error_402_page) - 1UL, (u_char *)(ngx_http_error_402_page)}, 
        {sizeof(ngx_http_error_403_page) - 1UL,
      (u_char *)(ngx_http_error_403_page)}, 
        {sizeof(ngx_http_error_404_page) - 1UL, (u_char *)(ngx_http_error_404_page)}, 
        {sizeof(ngx_http_error_405_page) - 1UL,
      (u_char *)(ngx_http_error_405_page)}, 
        {sizeof(ngx_http_error_406_page) - 1UL, (u_char *)(ngx_http_error_406_page)}, 
        {(size_t___0 )0,
      (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_408_page) - 1UL, (u_char *)(ngx_http_error_408_page)}, 
        {sizeof(ngx_http_error_409_page) - 1UL,
      (u_char *)(ngx_http_error_409_page)}, 
        {sizeof(ngx_http_error_410_page) - 1UL, (u_char *)(ngx_http_error_410_page)}, 
        {sizeof(ngx_http_error_411_page) - 1UL,
      (u_char *)(ngx_http_error_411_page)}, 
        {sizeof(ngx_http_error_412_page) - 1UL, (u_char *)(ngx_http_error_412_page)}, 
        {sizeof(ngx_http_error_413_page) - 1UL,
      (u_char *)(ngx_http_error_413_page)}, 
        {sizeof(ngx_http_error_414_page) - 1UL, (u_char *)(ngx_http_error_414_page)}, 
        {sizeof(ngx_http_error_415_page) - 1UL,
      (u_char *)(ngx_http_error_415_page)}, 
        {sizeof(ngx_http_error_416_page) - 1UL, (u_char *)(ngx_http_error_416_page)}, 
        {(size_t___0 )0,
      (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_421_page) - 1UL, (u_char *)(ngx_http_error_421_page)}, 
        {(size_t___0 )0,
      (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_429_page) - 1UL, (u_char *)(ngx_http_error_429_page)}, 
        {sizeof(ngx_http_error_494_page) - 1UL,
      (u_char *)(ngx_http_error_494_page)}, 
        {sizeof(ngx_http_error_495_page) - 1UL, (u_char *)(ngx_http_error_495_page)}, 
        {sizeof(ngx_http_error_496_page) - 1UL,
      (u_char *)(ngx_http_error_496_page)}, 
        {sizeof(ngx_http_error_497_page) - 1UL, (u_char *)(ngx_http_error_497_page)}, 
        {sizeof(ngx_http_error_404_page) - 1UL,
      (u_char *)(ngx_http_error_404_page)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_500_page) - 1UL, (u_char *)(ngx_http_error_500_page)}, 
        {sizeof(ngx_http_error_501_page) - 1UL,
      (u_char *)(ngx_http_error_501_page)}, 
        {sizeof(ngx_http_error_502_page) - 1UL, (u_char *)(ngx_http_error_502_page)}, 
        {sizeof(ngx_http_error_503_page) - 1UL,
      (u_char *)(ngx_http_error_503_page)}, 
        {sizeof(ngx_http_error_504_page) - 1UL, (u_char *)(ngx_http_error_504_page)}, 
        {sizeof(ngx_http_error_505_page) - 1UL,
      (u_char *)(ngx_http_error_505_page)}, 
        {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_507_page) - 1UL, (u_char *)(ngx_http_error_507_page)}};
#line 415 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
ngx_int_t ngx_http_special_response_handler(ngx_http_request_t *r , ngx_int_t error ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t err ;
  ngx_http_err_page_t *err_page ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 426
  r->err_status = (ngx_uint_t )error;
#line 428
  if (r->keepalive) {
    {
#line 437
    if (error == 501L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 500L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 496L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 495L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 497L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 414L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 413L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 400L) {
#line 437
      goto case_501;
    }
#line 429
    goto switch_break;
    case_501: /* CIL Label */ 
    case_500: /* CIL Label */ 
    case_496: /* CIL Label */ 
    case_495: /* CIL Label */ 
    case_497: /* CIL Label */ 
    case_414: /* CIL Label */ 
    case_413: /* CIL Label */ 
    case_400: /* CIL Label */ 
#line 438
    r->keepalive = 0U;
    switch_break: /* CIL Label */ ;
    }
  }
#line 442
  if (r->lingering_close) {
    {
#line 447
    if (error == 496L) {
#line 447
      goto case_496___0;
    }
#line 447
    if (error == 495L) {
#line 447
      goto case_496___0;
    }
#line 447
    if (error == 497L) {
#line 447
      goto case_496___0;
    }
#line 447
    if (error == 400L) {
#line 447
      goto case_496___0;
    }
#line 443
    goto switch_break___0;
    case_496___0: /* CIL Label */ 
    case_495___0: /* CIL Label */ 
    case_497___0: /* CIL Label */ 
    case_400___0: /* CIL Label */ 
#line 448
    r->lingering_close = 0U;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 452
  r->headers_out.content_type.len = (size_t___0 )0;
#line 454
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 456
  if (! r->error_page) {
#line 456
    if (clcf->error_pages) {
#line 456
      if (r->uri_changes != 0U) {
#line 458
        if (clcf->recursive_error_pages == 0L) {
#line 459
          r->error_page = 1U;
        }
#line 462
        err_page = (ngx_http_err_page_t *)(clcf->error_pages)->elts;
#line 464
        i = (ngx_uint_t )0;
        {
#line 464
        while (1) {
          while_continue: /* CIL Label */ ;
#line 464
          if (! (i < (clcf->error_pages)->nelts)) {
#line 464
            goto while_break;
          }
#line 465
          if ((err_page + i)->status == error) {
            {
#line 466
            tmp = ngx_http_send_error_page(r, err_page + i);
            }
#line 466
            return (tmp);
          }
#line 464
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 471
  r->expect_tested = 1U;
#line 473
  tmp___0 = ngx_http_discard_request_body(r);
  }
#line 473
  if (tmp___0 != 0L) {
#line 474
    r->keepalive = 0U;
  }
#line 477
  if (clcf->msie_refresh) {
#line 477
    if (r->headers_in.msie) {
#line 477
      if (error == 301L) {
        {
#line 482
        tmp___1 = ngx_http_send_refresh(r);
        }
#line 482
        return (tmp___1);
      } else
#line 477
      if (error == 302L) {
        {
#line 482
        tmp___1 = ngx_http_send_refresh(r);
        }
#line 482
        return (tmp___1);
      }
    }
  }
#line 485
  if (error == 201L) {
#line 487
    err = (ngx_uint_t )0;
  } else
#line 489
  if (error == 204L) {
#line 491
    err = (ngx_uint_t )0;
  } else
#line 493
  if (error >= 301L) {
#line 493
    if (error < 309L) {
#line 497
      err = (ngx_uint_t )((error - 301L) + 1L);
    } else {
#line 493
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 499
  if (error >= 400L) {
#line 499
    if (error < 430L) {
#line 503
      err = (ngx_uint_t )((error - 400L) + 9L);
    } else {
#line 499
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 505
  if (error >= 494L) {
#line 505
    if (error < 508L) {
#line 509
      err = (ngx_uint_t )((error - 494L) + 39L);
      {
#line 514
      if (error == 494L) {
#line 514
        goto case_494;
      }
#line 514
      if (error == 496L) {
#line 514
        goto case_494;
      }
#line 514
      if (error == 495L) {
#line 514
        goto case_494;
      }
#line 514
      if (error == 497L) {
#line 514
        goto case_494;
      }
#line 510
      goto switch_break___1;
      case_494: /* CIL Label */ 
      case_496___1: /* CIL Label */ 
      case_495___1: /* CIL Label */ 
      case_497___1: /* CIL Label */ 
#line 515
      r->err_status = (ngx_uint_t )400;
      switch_break___1: /* CIL Label */ ;
      }
    } else {
#line 520
      err = (ngx_uint_t )0;
    }
  } else {
#line 520
    err = (ngx_uint_t )0;
  }
  {
#line 523
  tmp___2 = ngx_http_send_special_response(r, clcf, err);
  }
#line 523
  return (tmp___2);
}
}
#line 527 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
ngx_int_t ngx_http_filter_finalize_request(ngx_http_request_t *r , ngx_module_t *m ,
                                           ngx_int_t error ) 
{ 
  void *ctx ;
  ngx_int_t rc ;

  {
  {
#line 534
  ngx_http_clean_header(r);
#line 536
  ctx = (void *)0;
  }
#line 538
  if (m) {
#line 539
    ctx = *(r->ctx + m->ctx_index);
  }
  {
#line 543
  memset((void *)r->ctx, 0, sizeof(void *) * ngx_http_max_module);
  }
#line 545
  if (m) {
#line 546
    *(r->ctx + m->ctx_index) = ctx;
  }
  {
#line 549
  r->filter_finalize = 1U;
#line 551
  rc = ngx_http_special_response_handler(r, error);
  }
  {
#line 558
  if (rc == -4L) {
#line 558
    goto case_neg_4;
  }
#line 558
  if (rc == 0L) {
#line 558
    goto case_neg_4;
  }
#line 561
  goto switch_default;
  case_neg_4: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 559
  return ((ngx_int_t )-1);
  switch_default: /* CIL Label */ 
#line 562
  return (rc);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 567 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
void ngx_http_clean_header(ngx_http_request_t *r ) 
{ 


  {
  {
#line 570
  memset((void *)(& r->headers_out.status), 0, sizeof(ngx_http_headers_out_t ) - (unsigned long )(& ((ngx_http_headers_out_t *)0)->status));
#line 574
  r->headers_out.headers.part.nelts = (ngx_uint_t )0;
#line 575
  r->headers_out.headers.part.next = (ngx_list_part_t *)((void *)0);
#line 576
  r->headers_out.headers.last = & r->headers_out.headers.part;
#line 578
  r->headers_out.content_length_n = (off_t )-1;
#line 579
  r->headers_out.last_modified_time = (time_t )-1;
  }
#line 580
  return;
}
}
#line 583 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_error_page(ngx_http_request_t *r , ngx_http_err_page_t *err_page ) 
{ 
  ngx_int_t overwrite ;
  ngx_str_t uri___0 ;
  ngx_str_t args___0 ;
  ngx_table_elt_t *location ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 591
  overwrite = err_page->overwrite;
#line 593
  if (overwrite) {
#line 593
    if (overwrite != 200L) {
#line 594
      r->expect_tested = 1U;
    }
  }
#line 597
  if (overwrite >= 0L) {
#line 598
    r->err_status = (ngx_uint_t )overwrite;
  }
  {
#line 601
  tmp = ngx_http_complex_value(r, & err_page->value, & uri___0);
  }
#line 601
  if (tmp != 0L) {
#line 602
    return ((ngx_int_t )-1);
  }
#line 605
  if (uri___0.len) {
#line 605
    if ((int )*(uri___0.data + 0) == 47) {
#line 607
      if (err_page->value.lengths) {
        {
#line 608
        ngx_http_split_args(r, & uri___0, & args___0);
        }
      } else {
#line 611
        args___0 = err_page->args;
      }
#line 614
      if (r->method != 4UL) {
#line 615
        r->method = (ngx_uint_t )2;
#line 616
        r->method_name = ngx_http_core_get_method;
      }
      {
#line 619
      tmp___0 = ngx_http_internal_redirect(r, & uri___0, & args___0);
      }
#line 619
      return (tmp___0);
    }
  }
#line 622
  if (uri___0.len) {
#line 622
    if ((int )*(uri___0.data + 0) == 64) {
      {
#line 623
      tmp___1 = ngx_http_named_location(r, & uri___0);
      }
#line 623
      return (tmp___1);
    }
  }
  {
#line 626
  tmp___2 = ngx_list_push(& r->headers_out.headers);
#line 626
  location = (ngx_table_elt_t *)tmp___2;
  }
#line 628
  if ((unsigned long )location == (unsigned long )((void *)0)) {
#line 629
    return ((ngx_int_t )-1);
  }
#line 632
  if (overwrite != 301L) {
#line 632
    if (overwrite != 302L) {
#line 632
      if (overwrite != 303L) {
#line 632
        if (overwrite != 307L) {
#line 632
          if (overwrite != 308L) {
#line 638
            r->err_status = (ngx_uint_t )302;
          }
        }
      }
    }
  }
#line 641
  location->hash = (ngx_uint_t )1;
#line 642
  location->key.len = sizeof("Location") - 1UL;
#line 642
  location->key.data = (u_char *)"Location";
#line 643
  location->value = uri___0;
#line 645
  if (r->headers_out.location) {
#line 645
    (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 645
    r->headers_out.location = (ngx_table_elt_t *)((void *)0);
  }
#line 647
  r->headers_out.location = location;
#line 649
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 651
  if (clcf->msie_refresh) {
#line 651
    if (r->headers_in.msie) {
      {
#line 652
      tmp___3 = ngx_http_send_refresh(r);
      }
#line 652
      return (tmp___3);
    }
  }
  {
#line 655
  tmp___4 = ngx_http_send_special_response(r, clcf, (r->err_status - 301UL) + 1UL);
  }
#line 655
  return (tmp___4);
}
}
#line 661 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_special_response(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                                ngx_uint_t err ) 
{ 
  u_char *tail___1 ;
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_uint_t msie_padding ;
  ngx_chain_t out[3] ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 672
  if (clcf->server_tokens == 1UL) {
#line 673
    len = sizeof(ngx_http_error_full_tail) - 1UL;
#line 674
    tail___1 = ngx_http_error_full_tail;
  } else
#line 676
  if (clcf->server_tokens == 2UL) {
#line 677
    len = sizeof(ngx_http_error_build_tail) - 1UL;
#line 678
    tail___1 = ngx_http_error_build_tail;
  } else {
#line 681
    len = sizeof(ngx_http_error_tail) - 1UL;
#line 682
    tail___1 = ngx_http_error_tail;
  }
#line 685
  msie_padding = (ngx_uint_t )0;
#line 687
  if (ngx_http_error_pages[err].len) {
#line 688
    r->headers_out.content_length_n = (off_t )(ngx_http_error_pages[err].len + len);
#line 689
    if (clcf->msie_padding) {
#line 689
      if (r->headers_in.msie) {
#line 689
        goto _L;
      } else
#line 689
      if (r->headers_in.chrome) {
        _L: /* CIL Label */ 
#line 689
        if (r->http_version >= 1000UL) {
#line 689
          if (err >= 9UL) {
#line 694
            r->headers_out.content_length_n = (off_t )((unsigned long )r->headers_out.content_length_n + (sizeof(ngx_http_msie_padding) - 1UL));
#line 696
            msie_padding = (ngx_uint_t )1;
          }
        }
      }
    }
#line 699
    r->headers_out.content_type_len = sizeof("text/html") - 1UL;
#line 700
    r->headers_out.content_type.len = sizeof("text/html") - 1UL;
#line 700
    r->headers_out.content_type.data = (u_char *)"text/html";
#line 701
    r->headers_out.content_type_lowcase = (u_char *)((void *)0);
  } else {
#line 704
    r->headers_out.content_length_n = (off_t )0;
  }
#line 707
  if (r->headers_out.content_length) {
#line 708
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 709
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 712
  r->allow_ranges = 0U;
#line 712
  if (r->headers_out.accept_ranges) {
#line 712
    (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 712
    r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
#line 713
  r->headers_out.last_modified_time = (time_t )-1;
#line 713
  if (r->headers_out.last_modified) {
#line 713
    (r->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 713
    r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
  }
#line 714
  if (r->headers_out.etag) {
#line 714
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 714
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 716
  rc = ngx_http_send_header(r);
  }
#line 718
  if (rc == -1L) {
#line 719
    return (rc);
  } else
#line 718
  if (r->header_only) {
#line 719
    return (rc);
  }
#line 722
  if (ngx_http_error_pages[err].len == 0UL) {
    {
#line 723
    tmp = ngx_http_send_special(r, (ngx_uint_t )1);
    }
#line 723
    return (tmp);
  }
  {
#line 726
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 726
  b = (ngx_buf_t *)tmp___0;
  }
#line 727
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 728
    return ((ngx_int_t )-1);
  }
  {
#line 731
  b->memory = 1U;
#line 732
  b->pos = ngx_http_error_pages[err].data;
#line 733
  b->last = ngx_http_error_pages[err].data + ngx_http_error_pages[err].len;
#line 735
  out[0].buf = b;
#line 736
  out[0].next = & out[1];
#line 738
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 738
  b = (ngx_buf_t *)tmp___1;
  }
#line 739
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 740
    return ((ngx_int_t )-1);
  }
#line 743
  b->memory = 1U;
#line 745
  b->pos = tail___1;
#line 746
  b->last = tail___1 + len;
#line 748
  out[1].buf = b;
#line 749
  out[1].next = (ngx_chain_t *)((void *)0);
#line 751
  if (msie_padding) {
    {
#line 752
    tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 752
    b = (ngx_buf_t *)tmp___2;
    }
#line 753
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 754
      return ((ngx_int_t )-1);
    }
#line 757
    b->memory = 1U;
#line 758
    b->pos = ngx_http_msie_padding;
#line 759
    b->last = (ngx_http_msie_padding + sizeof(ngx_http_msie_padding)) - 1;
#line 761
    out[1].next = & out[2];
#line 762
    out[2].buf = b;
#line 763
    out[2].next = (ngx_chain_t *)((void *)0);
  }
#line 766
  if ((unsigned long )r == (unsigned long )r->main) {
#line 767
    b->last_buf = 1U;
  }
  {
#line 770
  b->last_in_chain = 1U;
#line 772
  tmp___3 = ngx_http_output_filter(r, & out[0]);
  }
#line 772
  return (tmp___3);
}
}
#line 776 "/tmp/nginx-1.13.2/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_refresh(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *location ;
  size_t___0 len ;
  size_t___0 size ;
  uintptr_t escape___0 ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  uintptr_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uintptr_t tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;

  {
  {
#line 786
  len = (r->headers_out.location)->value.len;
#line 787
  location = (r->headers_out.location)->value.data;
#line 789
  tmp = ngx_escape_uri((u_char *)((void *)0), location, len, (ngx_uint_t )4);
#line 789
  escape___0 = 2UL * tmp;
#line 791
  size = ((((sizeof(ngx_http_msie_refresh_head) - 1UL) + escape___0) + len) + sizeof(ngx_http_msie_refresh_tail)) - 1UL;
#line 795
  r->err_status = (ngx_uint_t )200;
#line 797
  r->headers_out.content_type_len = sizeof("text/html") - 1UL;
#line 798
  r->headers_out.content_type.len = sizeof("text/html") - 1UL;
#line 798
  r->headers_out.content_type.data = (u_char *)"text/html";
#line 799
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 801
  (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 802
  r->headers_out.location = (ngx_table_elt_t *)((void *)0);
#line 804
  r->headers_out.content_length_n = (off_t )size;
  }
#line 806
  if (r->headers_out.content_length) {
#line 807
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 808
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 811
  r->allow_ranges = 0U;
#line 811
  if (r->headers_out.accept_ranges) {
#line 811
    (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 811
    r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
#line 812
  r->headers_out.last_modified_time = (time_t )-1;
#line 812
  if (r->headers_out.last_modified) {
#line 812
    (r->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 812
    r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
  }
#line 813
  if (r->headers_out.etag) {
#line 813
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 813
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 815
  rc = ngx_http_send_header(r);
  }
#line 817
  if (rc == -1L) {
#line 818
    return (rc);
  } else
#line 817
  if (r->header_only) {
#line 818
    return (rc);
  }
  {
#line 821
  b = ngx_create_temp_buf(r->pool, size);
  }
#line 822
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 823
    return ((ngx_int_t )-1);
  }
  {
#line 826
  tmp___0 = memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)(ngx_http_msie_refresh_head),
                   sizeof(ngx_http_msie_refresh_head) - 1UL);
#line 826
  p = (u_char *)tmp___0 + (sizeof(ngx_http_msie_refresh_head) - 1UL);
  }
#line 829
  if (escape___0 == 0UL) {
    {
#line 830
    tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)location,
                     len);
#line 830
    p = (u_char *)tmp___1 + len;
    }
  } else {
    {
#line 833
    tmp___2 = ngx_escape_uri(p, location, len, (ngx_uint_t )4);
#line 833
    p = (u_char *)tmp___2;
    }
  }
  {
#line 836
  tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ngx_http_msie_refresh_tail),
                   sizeof(ngx_http_msie_refresh_tail) - 1UL);
#line 836
  b->last = (u_char *)tmp___3 + (sizeof(ngx_http_msie_refresh_tail) - 1UL);
  }
#line 839
  if ((unsigned long )r == (unsigned long )r->main) {
#line 839
    b->last_buf = 1U;
  } else {
#line 839
    b->last_buf = 0U;
  }
  {
#line 840
  b->last_in_chain = 1U;
#line 842
  out.buf = b;
#line 843
  out.next = (ngx_chain_t *)((void *)0);
#line 845
  tmp___4 = ngx_http_output_filter(r, & out);
  }
#line 845
  return (tmp___4);
}
}
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 170 "src/core/ngx_string.h"
ngx_int_t ngx_filename_cmp(u_char *s1 , u_char *s2 , size_t___0 n ) ;
#line 238 "src/core/ngx_log.h"
char *ngx_log_set_log(ngx_conf_t *cf , ngx_log_t **head___0 ) ;
#line 116 "src/core/ngx_inet.h"
ngx_int_t ngx_cidr_match(struct sockaddr *sa , ngx_array_t *cidrs ) ;
#line 228 "src/core/ngx_resolver.h"
ngx_resolver_t *ngx_resolver_create(ngx_conf_t *cf , ngx_str_t *names , ngx_uint_t n ) ;
#line 289 "src/core/ngx_conf_file.h"
char *ngx_conf_set_sec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 425 "src/event/ngx_event.h"
ngx_os_io_t ngx_io ;
#line 477 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_core_generic_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 479
ngx_int_t ngx_http_core_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 481
ngx_int_t ngx_http_core_find_config_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 483
ngx_int_t ngx_http_core_post_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 485
ngx_int_t ngx_http_core_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 487
ngx_int_t ngx_http_core_post_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 489
ngx_int_t ngx_http_core_try_files_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 491
ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 81 "src/http/ngx_http.h"
ngx_int_t ngx_http_add_listen(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf , ngx_http_listen_opt_t *lsopt ) ;
#line 24 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_find_location(ngx_http_request_t *r ) ;
#line 25
static ngx_int_t ngx_http_core_find_static_location(ngx_http_request_t *r , ngx_http_location_tree_node_t *node ) ;
#line 28
static ngx_int_t ngx_http_core_preconfiguration(ngx_conf_t *cf ) ;
#line 29
static ngx_int_t ngx_http_core_postconfiguration(ngx_conf_t *cf ) ;
#line 30
static void *ngx_http_core_create_main_conf(ngx_conf_t *cf ) ;
#line 31
static char *ngx_http_core_init_main_conf(ngx_conf_t *cf , void *conf ) ;
#line 32
static void *ngx_http_core_create_srv_conf(ngx_conf_t *cf ) ;
#line 33
static char *ngx_http_core_merge_srv_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 35
static void *ngx_http_core_create_loc_conf(ngx_conf_t *cf ) ;
#line 36
static char *ngx_http_core_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 39
static char *ngx_http_core_server(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) ;
#line 41
static char *ngx_http_core_location(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) ;
#line 43
static ngx_int_t ngx_http_core_regex_location(ngx_conf_t *cf , ngx_http_core_loc_conf_t *clcf ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) ;
#line 46
static char *ngx_http_core_types(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 48
static char *ngx_http_core_type(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 51
static char *ngx_http_core_listen(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 53
static char *ngx_http_core_server_name(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 55
static char *ngx_http_core_root(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 56
static char *ngx_http_core_limit_except(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 58
static char *ngx_http_core_set_aio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 60
static char *ngx_http_core_directio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 62
static char *ngx_http_core_error_page(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64
static char *ngx_http_core_try_files(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 66
static char *ngx_http_core_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 68
static char *ngx_http_core_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 70
static char *ngx_http_core_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 72
static char *ngx_http_core_internal(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 74
static char *ngx_http_core_resolver(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 77
static ngx_int_t ngx_http_gzip_accept_encoding(ngx_str_t *ae ) ;
#line 78
static ngx_uint_t ngx_http_gzip_quantity(u_char *p , u_char *last ) ;
#line 79
static char *ngx_http_gzip_disable(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 82
static ngx_int_t ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r , ngx_addr_t *addr ,
                                                      u_char *xff , size_t___0 xfflen ,
                                                      ngx_array_t *proxies , int recursive ) ;
#line 86
static char *ngx_http_disable_symlinks(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 90
static char *ngx_http_core_lowat_check(ngx_conf_t *cf , void *post , void *data ) ;
#line 91
static char *ngx_http_core_pool_size(ngx_conf_t *cf , void *post , void *data ) ;
#line 93 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_post_t ngx_http_core_lowat_post  =    {& ngx_http_core_lowat_check};
#line 96 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *(*ngx_http_core_pool_size_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_core_pool_size;
#line 100 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_request_body_in_file[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )1}, 
        {{sizeof("clean") - 1UL, (u_char *)"clean"}, (ngx_uint_t )2}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 108 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_satisfy[3]  = {      {{sizeof("all") - 1UL, (u_char *)"all"}, (ngx_uint_t )0}, 
        {{sizeof("any") - 1UL, (u_char *)"any"}, (ngx_uint_t )1}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 115 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_lingering_close[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )1}, 
        {{sizeof("always") - 1UL, (u_char *)"always"}, (ngx_uint_t )2}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 123 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_server_tokens[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )1}, 
        {{sizeof("build") - 1UL, (u_char *)"build"}, (ngx_uint_t )2}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 131 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_if_modified_since[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("exact") - 1UL, (u_char *)"exact"}, (ngx_uint_t )1}, 
        {{sizeof("before") - 1UL, (u_char *)"before"}, (ngx_uint_t )2}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 139 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_bitmask_t ngx_http_core_keepalive_disable[4]  = {      {{sizeof("none") - 1UL, (u_char *)"none"}, (ngx_uint_t )2}, 
        {{sizeof("msie6") - 1UL, (u_char *)"msie6"}, (ngx_uint_t )4}, 
        {{sizeof("safari") - 1UL, (u_char *)"safari"}, (ngx_uint_t )8}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 147 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_path_init_t ngx_http_client_temp_path  =    {{sizeof("client_body_temp") - 1UL, (u_char *)"client_body_temp"}, {(size_t___0 )0,
                                                                       (size_t___0 )0,
                                                                       (size_t___0 )0}};
#line 154 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_gzip_http_version[3]  = {      {{sizeof("1.0") - 1UL, (u_char *)"1.0"}, (ngx_uint_t )1000}, 
        {{sizeof("1.1") - 1UL, (u_char *)"1.1"}, (ngx_uint_t )1001}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 161 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_conf_bitmask_t ngx_http_gzip_proxied_mask[10]  = 
#line 161
  {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2}, 
        {{sizeof("expired") - 1UL, (u_char *)"expired"}, (ngx_uint_t )4}, 
        {{sizeof("no-cache") - 1UL, (u_char *)"no-cache"}, (ngx_uint_t )8}, 
        {{sizeof("no-store") - 1UL, (u_char *)"no-store"}, (ngx_uint_t )16}, 
        {{sizeof("private") - 1UL, (u_char *)"private"}, (ngx_uint_t )32}, 
        {{sizeof("no_last_modified") - 1UL, (u_char *)"no_last_modified"}, (ngx_uint_t )64}, 
        {{sizeof("no_etag") - 1UL,
       (u_char *)"no_etag"}, (ngx_uint_t )128}, 
        {{sizeof("auth") - 1UL, (u_char *)"auth"}, (ngx_uint_t )256}, 
        {{sizeof("any") - 1UL, (u_char *)"any"}, (ngx_uint_t )512}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 175 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_gzip_no_cache  =    {sizeof("no-cache") - 1UL, (u_char *)"no-cache"};
#line 176 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_gzip_no_store  =    {sizeof("no-store") - 1UL, (u_char *)"no-store"};
#line 177 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_gzip_private  =    {sizeof("private") - 1UL, (u_char *)"private"};
#line 182 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_command_t ngx_http_core_commands[82]  = 
#line 182
  {      {{sizeof("variables_hash_max_size") - 1UL, (u_char *)"variables_hash_max_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->variables_hash_max_size),
      (void *)0}, 
        {{sizeof("variables_hash_bucket_size") - 1UL, (u_char *)"variables_hash_bucket_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->variables_hash_bucket_size),
      (void *)0}, 
        {{sizeof("server_names_hash_max_size") - 1UL, (u_char *)"server_names_hash_max_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->server_names_hash_max_size),
      (void *)0}, 
        {{sizeof("server_names_hash_bucket_size") - 1UL, (u_char *)"server_names_hash_bucket_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->server_names_hash_bucket_size),
      (void *)0}, 
        {{sizeof("server") - 1UL, (u_char *)"server"}, (ngx_uint_t )33554689, & ngx_http_core_server,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("connection_pool_size") - 1UL, (u_char *)"connection_pool_size"}, (ngx_uint_t )100663298,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->connection_pool_size), (void *)(& ngx_http_core_pool_size_p)}, 
        {{sizeof("request_pool_size") - 1UL,
       (u_char *)"request_pool_size"}, (ngx_uint_t )100663298, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->request_pool_size),
      (void *)(& ngx_http_core_pool_size_p)}, 
        {{sizeof("client_header_timeout") - 1UL, (u_char *)"client_header_timeout"},
      (ngx_uint_t )100663298, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->client_header_timeout),
      (void *)0}, 
        {{sizeof("client_header_buffer_size") - 1UL, (u_char *)"client_header_buffer_size"},
      (ngx_uint_t )100663298, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->client_header_buffer_size),
      (void *)0}, 
        {{sizeof("large_client_header_buffers") - 1UL, (u_char *)"large_client_header_buffers"},
      (ngx_uint_t )100663300, & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->large_client_header_buffers),
      (void *)0}, 
        {{sizeof("ignore_invalid_headers") - 1UL, (u_char *)"ignore_invalid_headers"},
      (ngx_uint_t )100663808, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->ignore_invalid_headers),
      (void *)0}, 
        {{sizeof("merge_slashes") - 1UL, (u_char *)"merge_slashes"}, (ngx_uint_t )100663808,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->merge_slashes), (void *)0}, 
        {{sizeof("underscores_in_headers") - 1UL,
       (u_char *)"underscores_in_headers"}, (ngx_uint_t )100663808, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->underscores_in_headers),
      (void *)0}, 
        {{sizeof("location") - 1UL, (u_char *)"location"}, (ngx_uint_t )201326854, & ngx_http_core_location,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("listen") - 1UL,
       (u_char *)"listen"}, (ngx_uint_t )67110912, & ngx_http_core_listen, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("server_name") - 1UL, (u_char *)"server_name"}, (ngx_uint_t )67110912,
      & ngx_http_core_server_name, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("types_hash_max_size") - 1UL, (u_char *)"types_hash_max_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->types_hash_max_size), (void *)0}, 
        {{sizeof("types_hash_bucket_size") - 1UL,
       (u_char *)"types_hash_bucket_size"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->types_hash_bucket_size),
      (void *)0}, 
        {{sizeof("types") - 1UL, (u_char *)"types"}, (ngx_uint_t )234881281, & ngx_http_core_types,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("default_type") - 1UL,
       (u_char *)"default_type"}, (ngx_uint_t )234881026, & ngx_conf_set_str_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->default_type),
      (void *)0}, 
        {{sizeof("root") - 1UL, (u_char *)"root"}, (ngx_uint_t )1308622850, & ngx_http_core_root,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("alias") - 1UL,
       (u_char *)"alias"}, (ngx_uint_t )134217730, & ngx_http_core_root, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_except") - 1UL, (u_char *)"limit_except"}, (ngx_uint_t )134220032,
      & ngx_http_core_limit_except, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("client_max_body_size") - 1UL, (u_char *)"client_max_body_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_max_body_size), (void *)0}, 
        {{sizeof("client_body_buffer_size") - 1UL,
       (u_char *)"client_body_buffer_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_buffer_size),
      (void *)0}, 
        {{sizeof("client_body_timeout") - 1UL, (u_char *)"client_body_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_timeout), (void *)0}, 
        {{sizeof("client_body_temp_path") - 1UL,
       (u_char *)"client_body_temp_path"}, (ngx_uint_t )234881054, & ngx_conf_set_path_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_temp_path),
      (void *)0}, 
        {{sizeof("client_body_in_file_only") - 1UL, (u_char *)"client_body_in_file_only"},
      (ngx_uint_t )234881026, & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_in_file_only),
      (void *)(& ngx_http_core_request_body_in_file)}, 
        {{sizeof("client_body_in_single_buffer") - 1UL, (u_char *)"client_body_in_single_buffer"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_in_single_buffer),
      (void *)0}, 
        {{sizeof("sendfile") - 1UL, (u_char *)"sendfile"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->sendfile),
      (void *)0}, 
        {{sizeof("sendfile_max_chunk") - 1UL, (u_char *)"sendfile_max_chunk"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->sendfile_max_chunk), (void *)0}, 
        {{sizeof("aio") - 1UL,
       (u_char *)"aio"}, (ngx_uint_t )234881026, & ngx_http_core_set_aio, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("aio_write") - 1UL, (u_char *)"aio_write"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->aio_write), (void *)0}, 
        {{sizeof("read_ahead") - 1UL, (u_char *)"read_ahead"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->read_ahead), (void *)0}, 
        {{sizeof("directio") - 1UL,
       (u_char *)"directio"}, (ngx_uint_t )234881026, & ngx_http_core_directio, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("directio_alignment") - 1UL, (u_char *)"directio_alignment"}, (ngx_uint_t )234881026,
      & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->directio_alignment), (void *)0}, 
        {{sizeof("tcp_nopush") - 1UL,
       (u_char *)"tcp_nopush"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->tcp_nopush),
      (void *)0}, 
        {{sizeof("tcp_nodelay") - 1UL, (u_char *)"tcp_nodelay"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->tcp_nodelay), (void *)0}, 
        {{sizeof("send_timeout") - 1UL,
       (u_char *)"send_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->send_timeout),
      (void *)0}, 
        {{sizeof("send_lowat") - 1UL, (u_char *)"send_lowat"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->send_lowat), (void *)(& ngx_http_core_lowat_post)}, 
        {{sizeof("postpone_output") - 1UL,
       (u_char *)"postpone_output"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->postpone_output),
      (void *)0}, 
        {{sizeof("limit_rate") - 1UL, (u_char *)"limit_rate"}, (ngx_uint_t )1308622850,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->limit_rate), (void *)0}, 
        {{sizeof("limit_rate_after") - 1UL,
       (u_char *)"limit_rate_after"}, (ngx_uint_t )1308622850, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->limit_rate_after),
      (void *)0}, 
        {{sizeof("keepalive_timeout") - 1UL, (u_char *)"keepalive_timeout"}, (ngx_uint_t )234881030,
      & ngx_http_core_keepalive, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("keepalive_requests") - 1UL, (u_char *)"keepalive_requests"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->keepalive_requests), (void *)0}, 
        {{sizeof("keepalive_disable") - 1UL,
       (u_char *)"keepalive_disable"}, (ngx_uint_t )234881030, & ngx_conf_set_bitmask_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->keepalive_disable),
      (void *)(& ngx_http_core_keepalive_disable)}, 
        {{sizeof("satisfy") - 1UL, (u_char *)"satisfy"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->satisfy),
      (void *)(& ngx_http_core_satisfy)}, 
        {{sizeof("internal") - 1UL, (u_char *)"internal"}, (ngx_uint_t )134217729, & ngx_http_core_internal,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("lingering_close") - 1UL,
       (u_char *)"lingering_close"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->lingering_close),
      (void *)(& ngx_http_core_lingering_close)}, 
        {{sizeof("lingering_time") - 1UL, (u_char *)"lingering_time"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->lingering_time), (void *)0}, 
        {{sizeof("lingering_timeout") - 1UL,
       (u_char *)"lingering_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->lingering_timeout),
      (void *)0}, 
        {{sizeof("reset_timedout_connection") - 1UL, (u_char *)"reset_timedout_connection"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->reset_timedout_connection),
      (void *)0}, 
        {{sizeof("absolute_redirect") - 1UL, (u_char *)"absolute_redirect"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->absolute_redirect), (void *)0}, 
        {{sizeof("server_name_in_redirect") - 1UL,
       (u_char *)"server_name_in_redirect"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->server_name_in_redirect),
      (void *)0}, 
        {{sizeof("port_in_redirect") - 1UL, (u_char *)"port_in_redirect"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->port_in_redirect), (void *)0}, 
        {{sizeof("msie_padding") - 1UL,
       (u_char *)"msie_padding"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->msie_padding),
      (void *)0}, 
        {{sizeof("msie_refresh") - 1UL, (u_char *)"msie_refresh"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->msie_refresh), (void *)0}, 
        {{sizeof("log_not_found") - 1UL,
       (u_char *)"log_not_found"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->log_not_found),
      (void *)0}, 
        {{sizeof("log_subrequest") - 1UL, (u_char *)"log_subrequest"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->log_subrequest), (void *)0}, 
        {{sizeof("recursive_error_pages") - 1UL,
       (u_char *)"recursive_error_pages"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->recursive_error_pages),
      (void *)0}, 
        {{sizeof("server_tokens") - 1UL, (u_char *)"server_tokens"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->server_tokens), (void *)(& ngx_http_core_server_tokens)}, 
        {{sizeof("if_modified_since") - 1UL,
       (u_char *)"if_modified_since"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->if_modified_since),
      (void *)(& ngx_http_core_if_modified_since)}, 
        {{sizeof("max_ranges") - 1UL, (u_char *)"max_ranges"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->max_ranges), (void *)0}, 
        {{sizeof("chunked_transfer_encoding") - 1UL,
       (u_char *)"chunked_transfer_encoding"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->chunked_transfer_encoding),
      (void *)0}, 
        {{sizeof("etag") - 1UL, (u_char *)"etag"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->etag),
      (void *)0}, 
        {{sizeof("error_page") - 1UL, (u_char *)"error_page"}, (ngx_uint_t )1308626944,
      & ngx_http_core_error_page, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("try_files") - 1UL, (u_char *)"try_files"}, (ngx_uint_t )201330688,
      & ngx_http_core_try_files, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("post_action") - 1UL, (u_char *)"post_action"}, (ngx_uint_t )1308622850,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->post_action), (void *)0}, 
        {{sizeof("error_log") - 1UL,
       (u_char *)"error_log"}, (ngx_uint_t )234883072, & ngx_http_core_error_log,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("open_file_cache") - 1UL,
       (u_char *)"open_file_cache"}, (ngx_uint_t )234881030, & ngx_http_core_open_file_cache,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache),
      (void *)0}, 
        {{sizeof("open_file_cache_valid") - 1UL, (u_char *)"open_file_cache_valid"},
      (ngx_uint_t )234881026, & ngx_conf_set_sec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_valid),
      (void *)0}, 
        {{sizeof("open_file_cache_min_uses") - 1UL, (u_char *)"open_file_cache_min_uses"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_min_uses),
      (void *)0}, 
        {{sizeof("open_file_cache_errors") - 1UL, (u_char *)"open_file_cache_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_errors),
      (void *)0}, 
        {{sizeof("open_file_cache_events") - 1UL, (u_char *)"open_file_cache_events"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_events),
      (void *)0}, 
        {{sizeof("resolver") - 1UL, (u_char *)"resolver"}, (ngx_uint_t )234883072, & ngx_http_core_resolver,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("resolver_timeout") - 1UL,
       (u_char *)"resolver_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->resolver_timeout),
      (void *)0}, 
        {{sizeof("gzip_vary") - 1UL, (u_char *)"gzip_vary"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->gzip_vary), (void *)0}, 
        {{sizeof("gzip_http_version") - 1UL, (u_char *)"gzip_http_version"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->gzip_http_version), (void *)(& ngx_http_gzip_http_version)}, 
        {{sizeof("gzip_proxied") - 1UL,
       (u_char *)"gzip_proxied"}, (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->gzip_proxied),
      (void *)(& ngx_http_gzip_proxied_mask)}, 
        {{sizeof("gzip_disable") - 1UL, (u_char *)"gzip_disable"}, (ngx_uint_t )234883072,
      & ngx_http_gzip_disable, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("disable_symlinks") - 1UL, (u_char *)"disable_symlinks"}, (ngx_uint_t )234881030,
      & ngx_http_disable_symlinks, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 770 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_http_module_t ngx_http_core_module_ctx  = 
#line 770
     {& ngx_http_core_preconfiguration, & ngx_http_core_postconfiguration, & ngx_http_core_create_main_conf,
    & ngx_http_core_init_main_conf, & ngx_http_core_create_srv_conf, & ngx_http_core_merge_srv_conf,
    & ngx_http_core_create_loc_conf, & ngx_http_core_merge_loc_conf};
#line 785 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_module_t ngx_http_core_module  = 
#line 785
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_core_module_ctx),
    ngx_http_core_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 801 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_str_t ngx_http_core_get_method  =    {(size_t___0 )3, (u_char *)"GET"};
#line 804 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
void ngx_http_handler(ngx_http_request_t *r ) 
{ 
  ngx_http_core_main_conf_t *cmcf ;
  int tmp ;

  {
#line 809
  ((r->connection)->log)->action = (char *)((void *)0);
#line 811
  if (! r->internal) {
    {
#line 813
    if (r->headers_in.connection_type == 0U) {
#line 813
      goto case_0;
    }
#line 817
    if (r->headers_in.connection_type == 1U) {
#line 817
      goto case_1;
    }
#line 821
    if (r->headers_in.connection_type == 2U) {
#line 821
      goto case_2;
    }
#line 812
    goto switch_break;
    case_0: /* CIL Label */ 
#line 814
    r->keepalive = (unsigned int )(r->http_version > 1000UL);
#line 815
    goto switch_break;
    case_1: /* CIL Label */ 
#line 818
    r->keepalive = 0U;
#line 819
    goto switch_break;
    case_2: /* CIL Label */ 
#line 822
    r->keepalive = 1U;
#line 823
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 826
    if (r->headers_in.content_length_n > 0L) {
#line 826
      tmp = 1;
    } else
#line 826
    if (r->headers_in.chunked) {
#line 826
      tmp = 1;
    } else {
#line 826
      tmp = 0;
    }
#line 826
    r->lingering_close = (unsigned int )tmp;
#line 828
    r->phase_handler = (ngx_int_t )0;
  } else {
#line 831
    cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 832
    r->phase_handler = (ngx_int_t )cmcf->phase_engine.server_rewrite_index;
  }
  {
#line 835
  r->valid_location = 1U;
#line 837
  r->gzip_tested = 0U;
#line 838
  r->gzip_ok = 0U;
#line 839
  r->gzip_vary = 0U;
#line 842
  r->write_event_handler = & ngx_http_core_run_phases;
#line 843
  ngx_http_core_run_phases(r);
  }
#line 844
  return;
}
}
#line 847 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
void ngx_http_core_run_phases(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_phase_handler_t *ph ;
  ngx_http_core_main_conf_t *cmcf ;

  {
#line 854
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 856
  ph = cmcf->phase_engine.handlers;
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (! (ph + r->phase_handler)->checker) {
#line 858
      goto while_break;
    }
    {
#line 860
    rc = (*((ph + r->phase_handler)->checker))(r, ph + r->phase_handler);
    }
#line 862
    if (rc == 0L) {
#line 863
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 866
  return;
}
}
#line 869 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_generic_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t rc ;

  {
  {
#line 882
  rc = (*(ph->handler))(r);
  }
#line 884
  if (rc == 0L) {
#line 885
    r->phase_handler = (ngx_int_t )ph->next;
#line 886
    return ((ngx_int_t )-2);
  }
#line 889
  if (rc == -5L) {
#line 890
    (r->phase_handler) ++;
#line 891
    return ((ngx_int_t )-2);
  }
#line 894
  if (rc == -2L) {
#line 895
    return ((ngx_int_t )0);
  } else
#line 894
  if (rc == -4L) {
#line 895
    return ((ngx_int_t )0);
  }
  {
#line 900
  ngx_http_finalize_request(r, rc);
  }
#line 902
  return ((ngx_int_t )0);
}
}
#line 906 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t rc ;

  {
  {
#line 914
  rc = (*(ph->handler))(r);
  }
#line 916
  if (rc == -5L) {
#line 917
    (r->phase_handler) ++;
#line 918
    return ((ngx_int_t )-2);
  }
#line 921
  if (rc == -4L) {
#line 922
    return ((ngx_int_t )0);
  }
  {
#line 927
  ngx_http_finalize_request(r, rc);
  }
#line 929
  return ((ngx_int_t )0);
}
}
#line 933 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_find_config_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;

  {
  {
#line 942
  r->content_handler = (ngx_int_t (*)(ngx_http_request_t *r ))((void *)0);
#line 943
  r->uri_changed = 0U;
#line 945
  rc = ngx_http_core_find_location(r);
  }
#line 947
  if (rc == -1L) {
    {
#line 948
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 949
    return ((ngx_int_t )0);
  }
#line 952
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 954
  if (! r->internal) {
#line 954
    if (clcf->internal) {
      {
#line 955
      ngx_http_finalize_request(r, (ngx_int_t )404);
      }
#line 956
      return ((ngx_int_t )0);
    }
  }
  {
#line 964
  ngx_http_update_location_config(r);
  }
#line 970
  if (r->headers_in.content_length_n != -1L) {
#line 970
    if (! r->discard_body) {
#line 970
      if (clcf->client_max_body_size) {
#line 970
        if (clcf->client_max_body_size < r->headers_in.content_length_n) {
#line 975
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 975
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client intended to send too large body: %O bytes",
                               r->headers_in.content_length_n);
            }
          }
          {
#line 979
          r->expect_tested = 1U;
#line 980
          ngx_http_discard_request_body(r);
#line 981
          ngx_http_finalize_request(r, (ngx_int_t )413);
          }
#line 982
          return ((ngx_int_t )0);
        }
      }
    }
  }
#line 985
  if (rc == -4L) {
#line 986
    if (r->headers_out.location) {
#line 986
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 986
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 988
    tmp = ngx_list_push(& r->headers_out.headers);
#line 988
    r->headers_out.location = (ngx_table_elt_t *)tmp;
    }
#line 989
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
      {
#line 990
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
#line 991
      return ((ngx_int_t )0);
    }
#line 994
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 995
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 995
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 997
    if (r->args.len == 0UL) {
#line 998
      (r->headers_out.location)->value = clcf->name;
    } else {
      {
#line 1001
      len = (clcf->name.len + 1UL) + r->args.len;
#line 1002
      tmp___0 = ngx_pnalloc(r->pool, len);
#line 1002
      p = (u_char *)tmp___0;
      }
#line 1004
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1005
        if (r->headers_out.location) {
#line 1005
          (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 1005
          r->headers_out.location = (ngx_table_elt_t *)((void *)0);
        }
        {
#line 1006
        ngx_http_finalize_request(r, (ngx_int_t )500);
        }
#line 1007
        return ((ngx_int_t )0);
      }
      {
#line 1010
      (r->headers_out.location)->value.len = len;
#line 1011
      (r->headers_out.location)->value.data = p;
#line 1013
      tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)clcf->name.data,
                       clcf->name.len);
#line 1013
      p = (u_char *)tmp___1 + clcf->name.len;
#line 1014
      tmp___2 = p;
#line 1014
      p ++;
#line 1014
      *tmp___2 = (u_char )'?';
#line 1015
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)r->args.data,
             r->args.len);
      }
    }
    {
#line 1018
    ngx_http_finalize_request(r, (ngx_int_t )301);
    }
#line 1019
    return ((ngx_int_t )0);
  }
#line 1022
  (r->phase_handler) ++;
#line 1023
  return ((ngx_int_t )-2);
}
}
#line 1027 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_post_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 1036
  if (! r->uri_changed) {
#line 1037
    (r->phase_handler) ++;
#line 1038
    return ((ngx_int_t )-2);
  }
#line 1051
  (r->uri_changes) --;
#line 1053
  if (r->uri_changes == 0U) {
#line 1054
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1054
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "rewrite or internal redirection cycle while processing \"%V\"",
                         & r->uri);
      }
    }
    {
#line 1058
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 1059
    return ((ngx_int_t )0);
  }
#line 1062
  r->phase_handler = (ngx_int_t )ph->next;
#line 1064
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1065
  r->loc_conf = (cscf->ctx)->loc_conf;
#line 1067
  return ((ngx_int_t )-2);
}
}
#line 1071 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 1077
  if ((unsigned long )r != (unsigned long )r->main) {
#line 1078
    r->phase_handler = (ngx_int_t )ph->next;
#line 1079
    return ((ngx_int_t )-2);
  }
  {
#line 1085
  rc = (*(ph->handler))(r);
  }
#line 1087
  if (rc == -5L) {
#line 1088
    (r->phase_handler) ++;
#line 1089
    return ((ngx_int_t )-2);
  }
#line 1092
  if (rc == -2L) {
#line 1093
    return ((ngx_int_t )0);
  } else
#line 1092
  if (rc == -4L) {
#line 1093
    return ((ngx_int_t )0);
  }
#line 1096
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1098
  if (clcf->satisfy == 0UL) {
#line 1100
    if (rc == 0L) {
#line 1101
      (r->phase_handler) ++;
#line 1102
      return ((ngx_int_t )-2);
    }
  } else {
#line 1106
    if (rc == 0L) {
#line 1107
      r->access_code = (ngx_uint_t )0;
#line 1109
      if (r->headers_out.www_authenticate) {
#line 1110
        (r->headers_out.www_authenticate)->hash = (ngx_uint_t )0;
      }
#line 1113
      r->phase_handler = (ngx_int_t )ph->next;
#line 1114
      return ((ngx_int_t )-2);
    }
#line 1117
    if (rc == 403L) {
#line 1117
      goto _L;
    } else
#line 1117
    if (rc == 401L) {
      _L: /* CIL Label */ 
#line 1118
      if (r->access_code != 401UL) {
#line 1119
        r->access_code = (ngx_uint_t )rc;
      }
#line 1122
      (r->phase_handler) ++;
#line 1123
      return ((ngx_int_t )-2);
    }
  }
  {
#line 1129
  ngx_http_finalize_request(r, rc);
  }
#line 1130
  return ((ngx_int_t )0);
}
}
#line 1134 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_post_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t access_code ;

  {
#line 1143
  access_code = (ngx_int_t )r->access_code;
#line 1145
  if (access_code) {
#line 1146
    if (access_code == 403L) {
#line 1147
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1147
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "access forbidden by rule");
        }
      }
    }
    {
#line 1151
    r->access_code = (ngx_uint_t )0;
#line 1152
    ngx_http_finalize_request(r, access_code);
    }
#line 1153
    return ((ngx_int_t )0);
  }
#line 1156
  (r->phase_handler) ++;
#line 1157
  return ((ngx_int_t )-2);
}
}
#line 1161 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_try_files_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  size_t___0 len ;
  size_t___0 root ;
  size_t___0 alias ;
  size_t___0 reserve ;
  size_t___0 allocated ;
  u_char *p ;
  u_char *name ;
  ngx_str_t path ;
  ngx_str_t args___0 ;
  ngx_uint_t test_dir ;
  ngx_http_try_file_t *tf ;
  ngx_open_file_info_t of ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_core_loc_conf_t *clcf ;
  size_t___0 (*lcode)(ngx_http_script_engine_t *e ) ;
  size_t___0 tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 1179
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1181
  if ((unsigned long )clcf->try_files == (unsigned long )((void *)0)) {
#line 1182
    (r->phase_handler) ++;
#line 1183
    return ((ngx_int_t )-2);
  }
#line 1186
  allocated = (size_t___0 )0;
#line 1187
  root = (size_t___0 )0;
#line 1188
  name = (u_char *)((void *)0);
#line 1190
  path.data = (u_char *)((void *)0);
#line 1192
  tf = clcf->try_files;
#line 1194
  alias = clcf->alias;
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1198
    if (tf->lengths) {
      {
#line 1199
      memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 1201
      e.ip = (u_char *)(tf->lengths)->elts;
#line 1202
      e.request = r;
#line 1205
      len = (size_t___0 )1;
      }
      {
#line 1207
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1207
        if (! *((uintptr_t *)e.ip)) {
#line 1207
          goto while_break___0;
        }
        {
#line 1208
        lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 1209
        tmp = (*lcode)(& e);
#line 1209
        len += tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 1213
      len = tf->name.len;
    }
#line 1216
    if (! alias) {
#line 1217
      if (len > r->uri.len) {
#line 1217
        reserve = len - r->uri.len;
      } else {
#line 1217
        reserve = (size_t___0 )0;
      }
    } else
#line 1219
    if ((unsigned long long )alias == 9223372036854775807ULL) {
#line 1220
      reserve = len;
    } else
#line 1223
    if (len > r->uri.len - alias) {
#line 1223
      reserve = len - (r->uri.len - alias);
    } else {
#line 1223
      reserve = (size_t___0 )0;
    }
#line 1226
    if (reserve > allocated) {
#line 1226
      goto _L;
    } else
#line 1226
    if (! allocated) {
      _L: /* CIL Label */ 
      {
#line 1229
      allocated = reserve + 16UL;
#line 1231
      tmp___0 = ngx_http_map_uri_to_path(r, & path, & root, allocated);
      }
#line 1231
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 1232
        ngx_http_finalize_request(r, (ngx_int_t )500);
        }
#line 1233
        return ((ngx_int_t )0);
      }
#line 1236
      name = path.data + root;
    }
#line 1239
    if ((unsigned long )tf->values == (unsigned long )((void *)0)) {
      {
#line 1243
      memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)tf->name.data,
             tf->name.len);
#line 1245
      path.len = (size_t___0 )(((name + tf->name.len) - 1) - path.data);
      }
    } else {
#line 1248
      e.ip = (u_char *)(tf->values)->elts;
#line 1249
      e.pos = name;
#line 1250
      e.flushed = 1U;
      {
#line 1252
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1252
        if (! *((uintptr_t *)e.ip)) {
#line 1252
          goto while_break___1;
        }
        {
#line 1253
        code = *((ngx_http_script_code_pt *)e.ip);
#line 1254
        (*code)(& e);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1257
      path.len = (size_t___0 )(e.pos - path.data);
#line 1259
      *(e.pos) = (u_char )'\000';
#line 1261
      if (alias) {
#line 1261
        if ((unsigned long long )alias != 9223372036854775807ULL) {
          {
#line 1261
          tmp___1 = strncmp((char const   *)name, (char const   *)r->uri.data, alias);
          }
#line 1261
          if (tmp___1 == 0) {
            {
#line 1264
            memmove((void *)name, (void const   *)(name + alias), len - alias);
#line 1265
            path.len -= alias;
            }
          }
        }
      }
    }
#line 1269
    test_dir = (ngx_uint_t )tf->test_dir;
#line 1271
    tf ++;
#line 1277
    if ((unsigned long )tf->lengths == (unsigned long )((void *)0)) {
#line 1277
      if (tf->name.len == 0UL) {
#line 1279
        if (tf->code) {
          {
#line 1280
          ngx_http_finalize_request(r, (ngx_int_t )tf->code);
          }
#line 1281
          return ((ngx_int_t )0);
        }
#line 1284
        path.len -= root;
#line 1285
        path.data += root;
#line 1287
        if ((int )*(path.data + 0) == 64) {
          {
#line 1288
          ngx_http_named_location(r, & path);
          }
        } else {
          {
#line 1291
          ngx_http_split_args(r, & path, & args___0);
#line 1293
          ngx_http_internal_redirect(r, & path, & args___0);
          }
        }
        {
#line 1296
        ngx_http_finalize_request(r, (ngx_int_t )-4);
        }
#line 1297
        return ((ngx_int_t )0);
      }
    }
    {
#line 1300
    memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 1302
    of.read_ahead = clcf->read_ahead;
#line 1303
    of.directio = clcf->directio;
#line 1304
    of.valid = clcf->open_file_cache_valid;
#line 1305
    of.min_uses = clcf->open_file_cache_min_uses;
#line 1306
    of.test_only = 1U;
#line 1307
    of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 1308
    of.events = (unsigned int )clcf->open_file_cache_events;
#line 1310
    tmp___2 = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
    }
#line 1310
    if (tmp___2 != 0L) {
      {
#line 1311
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
#line 1312
      return ((ngx_int_t )0);
    }
    {
#line 1315
    tmp___3 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
    }
#line 1315
    if (tmp___3 != 0L) {
#line 1318
      if (of.err == 0) {
        {
#line 1319
        ngx_http_finalize_request(r, (ngx_int_t )500);
        }
#line 1320
        return ((ngx_int_t )0);
      }
#line 1323
      if (of.err != 2) {
#line 1323
        if (of.err != 20) {
#line 1323
          if (of.err != 36) {
#line 1327
            if (((r->connection)->log)->log_level >= 3UL) {
              {
#line 1327
              ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                                 of.failed, path.data);
              }
            }
          }
        }
      }
#line 1331
      goto __Cont;
    }
#line 1334
    if ((ngx_uint_t )of.is_dir != test_dir) {
#line 1335
      goto __Cont;
    }
#line 1338
    path.len -= root;
#line 1339
    path.data += root;
#line 1341
    if (! alias) {
#line 1342
      r->uri = path;
    } else
#line 1344
    if ((unsigned long long )alias == 9223372036854775807ULL) {
#line 1345
      if (! test_dir) {
#line 1346
        r->uri = path;
#line 1347
        r->add_uri_to_alias = 1U;
      }
    } else {
      {
#line 1351
      name = r->uri.data;
#line 1353
      r->uri.len = alias + path.len;
#line 1354
      tmp___4 = ngx_pnalloc(r->pool, r->uri.len);
#line 1354
      r->uri.data = (u_char *)tmp___4;
      }
#line 1355
      if ((unsigned long )r->uri.data == (unsigned long )((void *)0)) {
        {
#line 1356
        r->uri.len = (size_t___0 )0;
#line 1357
        ngx_http_finalize_request(r, (ngx_int_t )500);
        }
#line 1358
        return ((ngx_int_t )0);
      }
      {
#line 1361
      tmp___5 = memcpy((void */* __restrict  */)r->uri.data, (void const   */* __restrict  */)name,
                       alias);
#line 1361
      p = (u_char *)tmp___5 + alias;
#line 1362
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)path.data,
             path.len);
      }
    }
    {
#line 1365
    ngx_http_set_exten(r);
#line 1370
    (r->phase_handler) ++;
    }
#line 1371
    return ((ngx_int_t )-2);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1378 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  size_t___0 root ;
  ngx_int_t rc ;
  ngx_str_t path ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;

  {
#line 1386
  if (r->content_handler) {
    {
#line 1387
    r->write_event_handler = & ngx_http_request_empty_handler;
#line 1388
    tmp = (*(r->content_handler))(r);
#line 1388
    ngx_http_finalize_request(r, tmp);
    }
#line 1389
    return ((ngx_int_t )0);
  }
  {
#line 1395
  rc = (*(ph->handler))(r);
  }
#line 1397
  if (rc != -5L) {
    {
#line 1398
    ngx_http_finalize_request(r, rc);
    }
#line 1399
    return ((ngx_int_t )0);
  }
#line 1404
  ph ++;
#line 1406
  if (ph->checker) {
#line 1407
    (r->phase_handler) ++;
#line 1408
    return ((ngx_int_t )-2);
  }
#line 1413
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) == 47) {
    {
#line 1415
    tmp___0 = ngx_http_map_uri_to_path(r, & path, & root, (size_t___0 )0);
    }
#line 1415
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1416
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1416
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "directory index of \"%s\" is forbidden",
                           path.data);
        }
      }
    }
    {
#line 1420
    ngx_http_finalize_request(r, (ngx_int_t )403);
    }
#line 1421
    return ((ngx_int_t )0);
  }
#line 1424
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 1424
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no handler found");
    }
  }
  {
#line 1426
  ngx_http_finalize_request(r, (ngx_int_t )404);
  }
#line 1427
  return ((ngx_int_t )0);
}
}
#line 1431 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
void ngx_http_update_location_config(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 1436
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1438
  if (r->method & (unsigned long )clcf->limit_except) {
#line 1439
    r->loc_conf = clcf->limit_except_loc_conf;
#line 1440
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
  }
#line 1443
  if ((unsigned long )r == (unsigned long )r->main) {
#line 1444
    ((r->connection)->log)->file = (clcf->error_log)->file;
#line 1444
    ((r->connection)->log)->next = (clcf->error_log)->next;
#line 1444
    ((r->connection)->log)->writer = (clcf->error_log)->writer;
#line 1444
    ((r->connection)->log)->wdata = (clcf->error_log)->wdata;
#line 1444
    if (! (((r->connection)->log)->log_level & 2147483648UL)) {
#line 1444
      ((r->connection)->log)->log_level = (clcf->error_log)->log_level;
    }
  }
#line 1447
  if (ngx_io.flags & 1UL) {
#line 1447
    if (clcf->sendfile) {
#line 1448
      (r->connection)->sendfile = 1U;
    } else {
#line 1451
      (r->connection)->sendfile = 0U;
    }
  } else {
#line 1451
    (r->connection)->sendfile = 0U;
  }
#line 1454
  if (clcf->client_body_in_file_only) {
#line 1455
    r->request_body_in_file_only = 1U;
#line 1456
    r->request_body_in_persistent_file = 1U;
#line 1457
    r->request_body_in_clean_file = (unsigned int )(clcf->client_body_in_file_only == 2UL);
#line 1459
    r->request_body_file_log_level = 6U;
  } else {
#line 1462
    r->request_body_file_log_level = 5U;
  }
#line 1465
  r->request_body_in_single_buf = (unsigned int )clcf->client_body_in_single_buffer;
#line 1467
  if (r->keepalive) {
#line 1468
    if (clcf->keepalive_timeout == 0UL) {
#line 1469
      r->keepalive = 0U;
    } else
#line 1471
    if ((r->connection)->requests >= clcf->keepalive_requests) {
#line 1472
      r->keepalive = 0U;
    } else
#line 1474
    if (r->headers_in.msie6) {
#line 1474
      if (r->method == 8UL) {
#line 1474
        if (clcf->keepalive_disable & 4UL) {
#line 1483
          r->keepalive = 0U;
        } else {
#line 1474
          goto _L___0;
        }
      } else {
#line 1474
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1485
    if (r->headers_in.safari) {
#line 1485
      if (clcf->keepalive_disable & 8UL) {
#line 1494
        r->keepalive = 0U;
      }
    }
  }
#line 1498
  if (! clcf->tcp_nopush) {
#line 1500
    (r->connection)->tcp_nopush = 2U;
  }
#line 1503
  if (r->limit_rate == 0UL) {
#line 1504
    r->limit_rate = clcf->limit_rate;
  }
#line 1507
  if (clcf->handler) {
#line 1508
    r->content_handler = clcf->handler;
  }
#line 1510
  return;
}
}
#line 1521 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_find_location(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *pclcf ;
  ngx_int_t n ;
  ngx_uint_t noregex ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_loc_conf_t **clcfp ;
  ngx_int_t tmp ;

  {
  {
#line 1531
  noregex = (ngx_uint_t )0;
#line 1534
  pclcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1536
  rc = ngx_http_core_find_static_location(r, pclcf->static_locations);
  }
#line 1538
  if (rc == -2L) {
    {
#line 1541
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1543
    noregex = (ngx_uint_t )clcf->noregex;
#line 1548
    rc = ngx_http_core_find_location(r);
    }
  }
#line 1551
  if (rc == 0L) {
#line 1552
    return (rc);
  } else
#line 1551
  if (rc == -4L) {
#line 1552
    return (rc);
  }
#line 1559
  if (noregex == 0UL) {
#line 1559
    if (pclcf->regex_locations) {
#line 1561
      clcfp = pclcf->regex_locations;
      {
#line 1561
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1561
        if (! *clcfp) {
#line 1561
          goto while_break;
        }
        {
#line 1566
        n = ngx_http_regex_exec(r, (*clcfp)->regex, & r->uri);
        }
#line 1568
        if (n == 0L) {
          {
#line 1569
          r->loc_conf = (*clcfp)->loc_conf;
#line 1573
          rc = ngx_http_core_find_location(r);
          }
#line 1575
          if (rc == -1L) {
#line 1575
            tmp = rc;
          } else {
#line 1575
            tmp = (ngx_int_t )0;
          }
#line 1575
          return (tmp);
        }
#line 1578
        if (n == -5L) {
#line 1579
          goto __Cont;
        }
#line 1582
        return ((ngx_int_t )-1);
        __Cont: /* CIL Label */ 
#line 1561
        clcfp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1587
  return (rc);
}
}
#line 1598 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_find_static_location(ngx_http_request_t *r , ngx_http_location_tree_node_t *node ) 
{ 
  u_char *uri___0 ;
  size_t___0 len ;
  size_t___0 n ;
  ngx_int_t rc ;
  ngx_int_t rv ;

  {
#line 1606
  len = r->uri.len;
#line 1607
  uri___0 = r->uri.data;
#line 1609
  rv = (ngx_int_t )-5;
  {
#line 1611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1613
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1614
      return (rv);
    }
#line 1621
    if (len <= (size_t___0 )node->len) {
#line 1621
      n = len;
    } else {
#line 1621
      n = (size_t___0 )node->len;
    }
    {
#line 1623
    rc = ngx_filename_cmp(uri___0, node->name, n);
    }
#line 1625
    if (rc != 0L) {
#line 1626
      if (rc < 0L) {
#line 1626
        node = node->left;
      } else {
#line 1626
        node = node->right;
      }
#line 1628
      goto __Cont;
    }
#line 1631
    if (len > (size_t___0 )node->len) {
#line 1633
      if (node->inclusive) {
#line 1635
        r->loc_conf = (node->inclusive)->loc_conf;
#line 1636
        rv = (ngx_int_t )-2;
#line 1638
        node = node->tree;
#line 1639
        uri___0 += n;
#line 1640
        len -= n;
#line 1642
        goto __Cont;
      }
#line 1647
      node = node->right;
#line 1649
      goto __Cont;
    }
#line 1652
    if (len == (size_t___0 )node->len) {
#line 1654
      if (node->exact) {
#line 1655
        r->loc_conf = (node->exact)->loc_conf;
#line 1656
        return ((ngx_int_t )0);
      } else {
#line 1659
        r->loc_conf = (node->inclusive)->loc_conf;
#line 1660
        return ((ngx_int_t )-2);
      }
    }
#line 1666
    if (len + 1UL == (size_t___0 )node->len) {
#line 1666
      if (node->auto_redirect) {
#line 1668
        if (node->exact) {
#line 1668
          r->loc_conf = (node->exact)->loc_conf;
        } else {
#line 1668
          r->loc_conf = (node->inclusive)->loc_conf;
        }
#line 1670
        rv = (ngx_int_t )-4;
      }
    }
#line 1673
    node = node->left;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1678 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
void *ngx_http_test_content_type(ngx_http_request_t *r , ngx_hash_t *types_hash ) 
{ 
  u_char c ;
  u_char *lowcase___0 ;
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_uint_t hash ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1685
  if (types_hash->size == 0UL) {
#line 1686
    return ((void *)4);
  }
#line 1689
  if (r->headers_out.content_type.len == 0UL) {
#line 1690
    return ((void *)0);
  }
#line 1693
  len = r->headers_out.content_type_len;
#line 1695
  if ((unsigned long )r->headers_out.content_type_lowcase == (unsigned long )((void *)0)) {
    {
#line 1697
    tmp = ngx_pnalloc(r->pool, len);
#line 1697
    lowcase___0 = (u_char *)tmp;
    }
#line 1698
    if ((unsigned long )lowcase___0 == (unsigned long )((void *)0)) {
#line 1699
      return ((void *)0);
    }
#line 1702
    r->headers_out.content_type_lowcase = lowcase___0;
#line 1704
    hash = (ngx_uint_t )0;
#line 1706
    i = (ngx_uint_t )0;
    {
#line 1706
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1706
      if (! (i < len)) {
#line 1706
        goto while_break;
      }
#line 1707
      if ((int )*(r->headers_out.content_type.data + i) >= 65) {
#line 1707
        if ((int )*(r->headers_out.content_type.data + i) <= 90) {
#line 1707
          tmp___0 = (int )*(r->headers_out.content_type.data + i) | 32;
        } else {
#line 1707
          tmp___0 = (int )*(r->headers_out.content_type.data + i);
        }
      } else {
#line 1707
        tmp___0 = (int )*(r->headers_out.content_type.data + i);
      }
#line 1707
      c = (u_char )tmp___0;
#line 1708
      hash = hash * 31UL + (ngx_uint_t )c;
#line 1709
      *(lowcase___0 + i) = c;
#line 1706
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1712
    r->headers_out.content_type_hash = hash;
  }
  {
#line 1715
  tmp___1 = ngx_hash_find(types_hash, r->headers_out.content_type_hash, r->headers_out.content_type_lowcase,
                          len);
  }
#line 1715
  return (tmp___1);
}
}
#line 1720 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r ) 
{ 
  u_char c ;
  u_char *exten ;
  ngx_str_t *type ;
  ngx_uint_t i ;
  ngx_uint_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1728
  if (r->headers_out.content_type.len) {
#line 1729
    return ((ngx_int_t )0);
  }
#line 1732
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1734
  if (r->exten.len) {
#line 1736
    hash = (ngx_uint_t )0;
#line 1738
    i = (ngx_uint_t )0;
    {
#line 1738
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1738
      if (! (i < r->exten.len)) {
#line 1738
        goto while_break;
      }
#line 1739
      c = *(r->exten.data + i);
#line 1741
      if ((int )c >= 65) {
#line 1741
        if ((int )c <= 90) {
          {
#line 1743
          tmp = ngx_pnalloc(r->pool, r->exten.len);
#line 1743
          exten = (u_char *)tmp;
          }
#line 1744
          if ((unsigned long )exten == (unsigned long )((void *)0)) {
#line 1745
            return ((ngx_int_t )-1);
          }
          {
#line 1748
          hash = ngx_hash_strlow(exten, r->exten.data, r->exten.len);
#line 1750
          r->exten.data = exten;
          }
#line 1752
          goto while_break;
        }
      }
#line 1755
      hash = hash * 31UL + (ngx_uint_t )c;
#line 1738
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1758
    tmp___0 = ngx_hash_find(& clcf->types_hash, hash, r->exten.data, r->exten.len);
#line 1758
    type = (ngx_str_t *)tmp___0;
    }
#line 1761
    if (type) {
#line 1762
      r->headers_out.content_type_len = type->len;
#line 1763
      r->headers_out.content_type = *type;
#line 1765
      return ((ngx_int_t )0);
    }
  }
#line 1769
  r->headers_out.content_type_len = clcf->default_type.len;
#line 1770
  r->headers_out.content_type = clcf->default_type;
#line 1772
  return ((ngx_int_t )0);
}
}
#line 1776 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
void ngx_http_set_exten(ngx_http_request_t *r ) 
{ 
  ngx_int_t i ;

  {
#line 1781
  r->exten.len = (size_t___0 )0;
#line 1781
  r->exten.data = (u_char *)((void *)0);
#line 1783
  i = (ngx_int_t )(r->uri.len - 1UL);
  {
#line 1783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1783
    if (! (i > 1L)) {
#line 1783
      goto while_break;
    }
#line 1784
    if ((int )*(r->uri.data + i) == 46) {
#line 1784
      if ((int )*(r->uri.data + (i - 1L)) != 47) {
#line 1786
        r->exten.len = (r->uri.len - (size_t___0 )i) - 1UL;
#line 1787
        r->exten.data = r->uri.data + (i + 1L);
#line 1789
        return;
      } else {
#line 1784
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1791
    if ((int )*(r->uri.data + i) == 47) {
#line 1792
      return;
    }
#line 1783
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1796
  return;
}
}
#line 1800 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_set_etag(ngx_http_request_t *r ) 
{ 
  ngx_table_elt_t *etag ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 1806
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1808
  if (! clcf->etag) {
#line 1809
    return ((ngx_int_t )0);
  }
  {
#line 1812
  tmp = ngx_list_push(& r->headers_out.headers);
#line 1812
  etag = (ngx_table_elt_t *)tmp;
  }
#line 1813
  if ((unsigned long )etag == (unsigned long )((void *)0)) {
#line 1814
    return ((ngx_int_t )-1);
  }
  {
#line 1817
  etag->hash = (ngx_uint_t )1;
#line 1818
  etag->key.len = sizeof("ETag") - 1UL;
#line 1818
  etag->key.data = (u_char *)"ETag";
#line 1820
  tmp___0 = ngx_pnalloc(r->pool, ((sizeof("-9223372036854775808") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + 3UL);
#line 1820
  etag->value.data = (u_char *)tmp___0;
  }
#line 1821
  if ((unsigned long )etag->value.data == (unsigned long )((void *)0)) {
#line 1822
    etag->hash = (ngx_uint_t )0;
#line 1823
    return ((ngx_int_t )-1);
  }
  {
#line 1826
  tmp___1 = ngx_sprintf(etag->value.data, "\"%xT-%xO\"", r->headers_out.last_modified_time,
                        r->headers_out.content_length_n);
#line 1826
  etag->value.len = (size_t___0 )(tmp___1 - etag->value.data);
#line 1831
  r->headers_out.etag = etag;
  }
#line 1833
  return ((ngx_int_t )0);
}
}
#line 1837 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
void ngx_http_weak_etag(ngx_http_request_t *r ) 
{ 
  size_t___0 len ;
  u_char *p ;
  ngx_table_elt_t *etag ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1844
  etag = r->headers_out.etag;
#line 1846
  if ((unsigned long )etag == (unsigned long )((void *)0)) {
#line 1847
    return;
  }
#line 1850
  if (etag->value.len > 2UL) {
#line 1850
    if ((int )*(etag->value.data + 0) == 87) {
#line 1850
      if ((int )*(etag->value.data + 1) == 47) {
#line 1854
        return;
      }
    }
  }
#line 1857
  if (etag->value.len < 1UL) {
#line 1858
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 1859
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
#line 1860
    return;
  } else
#line 1857
  if ((int )*(etag->value.data + 0) != 34) {
#line 1858
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 1859
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
#line 1860
    return;
  }
  {
#line 1863
  tmp = ngx_pnalloc(r->pool, etag->value.len + 2UL);
#line 1863
  p = (u_char *)tmp;
  }
#line 1864
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1865
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 1866
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
#line 1867
    return;
  }
  {
#line 1870
  tmp___0 = ngx_sprintf(p, "W/%V", & etag->value);
#line 1870
  len = (size_t___0 )(tmp___0 - p);
#line 1872
  etag->value.data = p;
#line 1873
  etag->value.len = len;
  }
#line 1874
  return;
}
}
#line 1877 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_send_response(ngx_http_request_t *r , ngx_uint_t status , ngx_str_t *ct ,
                                 ngx_http_complex_value_t *cv ) 
{ 
  ngx_int_t rc ;
  ngx_str_t val ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  ngx_int_t tmp___5 ;

  {
  {
#line 1886
  tmp = ngx_http_discard_request_body(r);
  }
#line 1886
  if (tmp != 0L) {
#line 1887
    return ((ngx_int_t )500);
  }
  {
#line 1890
  r->headers_out.status = status;
#line 1892
  tmp___0 = ngx_http_complex_value(r, cv, & val);
  }
#line 1892
  if (tmp___0 != 0L) {
#line 1893
    return ((ngx_int_t )500);
  }
#line 1896
  if (status == 301UL) {
#line 1896
    goto _L;
  } else
#line 1896
  if (status == 302UL) {
#line 1896
    goto _L;
  } else
#line 1896
  if (status == 303UL) {
#line 1896
    goto _L;
  } else
#line 1896
  if (status == 307UL) {
#line 1896
    goto _L;
  } else
#line 1896
  if (status == 308UL) {
    _L: /* CIL Label */ 
#line 1902
    if (r->headers_out.location) {
#line 1902
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 1902
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 1904
    tmp___1 = ngx_list_push(& r->headers_out.headers);
#line 1904
    r->headers_out.location = (ngx_table_elt_t *)tmp___1;
    }
#line 1905
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
#line 1906
      return ((ngx_int_t )500);
    }
#line 1909
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 1910
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 1910
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 1911
    (r->headers_out.location)->value = val;
#line 1913
    return ((ngx_int_t )status);
  }
#line 1916
  r->headers_out.content_length_n = (off_t )val.len;
#line 1918
  if (ct) {
#line 1919
    r->headers_out.content_type_len = ct->len;
#line 1920
    r->headers_out.content_type = *ct;
  } else {
    {
#line 1923
    tmp___2 = ngx_http_set_content_type(r);
    }
#line 1923
    if (tmp___2 != 0L) {
#line 1924
      return ((ngx_int_t )500);
    }
  }
#line 1928
  if (r->method == 4UL) {
    {
#line 1929
    tmp___3 = ngx_http_send_header(r);
    }
#line 1929
    return (tmp___3);
  } else
#line 1928
  if ((unsigned long )r != (unsigned long )r->main) {
#line 1928
    if (val.len == 0UL) {
      {
#line 1929
      tmp___3 = ngx_http_send_header(r);
      }
#line 1929
      return (tmp___3);
    }
  }
  {
#line 1932
  tmp___4 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 1932
  b = (ngx_buf_t *)tmp___4;
  }
#line 1933
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1934
    return ((ngx_int_t )500);
  }
#line 1937
  b->pos = val.data;
#line 1938
  b->last = val.data + val.len;
#line 1939
  if (val.len) {
#line 1939
    b->memory = 1U;
  } else {
#line 1939
    b->memory = 0U;
  }
#line 1940
  if ((unsigned long )r == (unsigned long )r->main) {
#line 1940
    b->last_buf = 1U;
  } else {
#line 1940
    b->last_buf = 0U;
  }
  {
#line 1941
  b->last_in_chain = 1U;
#line 1943
  out.buf = b;
#line 1944
  out.next = (ngx_chain_t *)((void *)0);
#line 1946
  rc = ngx_http_send_header(r);
  }
#line 1948
  if (rc == -1L) {
#line 1949
    return (rc);
  } else
#line 1948
  if (rc > 0L) {
#line 1949
    return (rc);
  } else
#line 1948
  if (r->header_only) {
#line 1949
    return (rc);
  }
  {
#line 1952
  tmp___5 = ngx_http_output_filter(r, & out);
  }
#line 1952
  return (tmp___5);
}
}
#line 1956 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_send_header(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;

  {
#line 1959
  if (r->post_action) {
#line 1960
    return ((ngx_int_t )0);
  }
#line 1963
  if (r->header_sent) {
#line 1964
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 1964
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "header already sent");
      }
    }
#line 1966
    return ((ngx_int_t )-1);
  }
#line 1969
  if (r->err_status) {
#line 1970
    r->headers_out.status = r->err_status;
#line 1971
    r->headers_out.status_line.len = (size_t___0 )0;
  }
  {
#line 1974
  tmp = (*ngx_http_top_header_filter)(r);
  }
#line 1974
  return (tmp);
}
}
#line 1978 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_output_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;

  {
  {
#line 1984
  c = r->connection;
#line 1989
  rc = (*ngx_http_top_body_filter)(r, in);
  }
#line 1991
  if (rc == -1L) {
#line 1993
    c->error = 1U;
  }
#line 1996
  return (rc);
}
}
#line 2000 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
u_char *ngx_http_map_uri_to_path(ngx_http_request_t *r , ngx_str_t *path , size_t___0 *root_length ,
                                 size_t___0 reserved ) 
{ 
  u_char *last ;
  size_t___0 alias ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;
  size_t___0 tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 2008
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2010
  alias = clcf->alias;
#line 2012
  if (alias) {
#line 2012
    if (! r->valid_location) {
#line 2013
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 2013
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "\"alias\" cannot be used in location \"%V\" where URI was rewritten",
                           & clcf->name);
        }
      }
#line 2016
      return ((u_char *)((void *)0));
    }
  }
#line 2019
  if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
    {
#line 2021
    *root_length = clcf->root.len;
#line 2023
    path->len = (((clcf->root.len + reserved) + r->uri.len) - alias) + 1UL;
#line 2025
    tmp = ngx_pnalloc(r->pool, path->len);
#line 2025
    path->data = (u_char *)tmp;
    }
#line 2026
    if ((unsigned long )path->data == (unsigned long )((void *)0)) {
#line 2027
      return ((u_char *)((void *)0));
    }
    {
#line 2030
    tmp___0 = memcpy((void */* __restrict  */)path->data, (void const   */* __restrict  */)clcf->root.data,
                     clcf->root.len);
#line 2030
    last = (u_char *)tmp___0 + clcf->root.len;
    }
  } else {
#line 2034
    if ((unsigned long long )alias == 9223372036854775807ULL) {
#line 2035
      if (r->add_uri_to_alias) {
#line 2035
        tmp___1 = r->uri.len + 1UL;
      } else {
#line 2035
        tmp___1 = (size_t___0 )1;
      }
#line 2035
      reserved += tmp___1;
    } else {
#line 2038
      reserved += (r->uri.len - alias) + 1UL;
    }
    {
#line 2041
    tmp___2 = ngx_http_script_run(r, path, (clcf->root_lengths)->elts, reserved, (clcf->root_values)->elts);
    }
#line 2041
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 2045
      return ((u_char *)((void *)0));
    }
    {
#line 2048
    tmp___3 = ngx_get_full_name(r->pool, (ngx_str_t *)(& ngx_cycle->prefix), path);
    }
#line 2048
    if (tmp___3 != 0L) {
#line 2051
      return ((u_char *)((void *)0));
    }
#line 2054
    *root_length = path->len - reserved;
#line 2055
    last = path->data + *root_length;
#line 2057
    if ((unsigned long long )alias == 9223372036854775807ULL) {
#line 2058
      if (! r->add_uri_to_alias) {
#line 2059
        *last = (u_char )'\000';
#line 2060
        return (last);
      }
#line 2063
      alias = (size_t___0 )0;
    }
  }
  {
#line 2067
  last = ngx_cpystrn(last, r->uri.data + alias, (r->uri.len - alias) + 1UL);
  }
#line 2069
  return (last);
}
}
#line 2073 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_auth_basic_user(ngx_http_request_t *r ) 
{ 
  ngx_str_t auth ;
  ngx_str_t encoded ;
  ngx_uint_t len ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 2079
  if (r->headers_in.user.len == 0UL) {
#line 2079
    if ((unsigned long )r->headers_in.user.data != (unsigned long )((void *)0)) {
#line 2080
      return ((ngx_int_t )-5);
    }
  }
#line 2083
  if ((unsigned long )r->headers_in.authorization == (unsigned long )((void *)0)) {
#line 2084
    r->headers_in.user.data = (u_char *)"";
#line 2085
    return ((ngx_int_t )-5);
  }
#line 2088
  encoded = (r->headers_in.authorization)->value;
#line 2090
  if (encoded.len < sizeof("Basic ") - 1UL) {
#line 2095
    r->headers_in.user.data = (u_char *)"";
#line 2096
    return ((ngx_int_t )-5);
  } else {
    {
#line 2090
    tmp = ngx_strncasecmp(encoded.data, (u_char *)"Basic ", sizeof("Basic ") - 1UL);
    }
#line 2090
    if (tmp != 0L) {
#line 2095
      r->headers_in.user.data = (u_char *)"";
#line 2096
      return ((ngx_int_t )-5);
    }
  }
#line 2099
  encoded.len -= sizeof("Basic ") - 1UL;
#line 2100
  encoded.data += sizeof("Basic ") - 1UL;
  {
#line 2102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2102
    if (encoded.len) {
#line 2102
      if (! ((int )*(encoded.data + 0) == 32)) {
#line 2102
        goto while_break;
      }
    } else {
#line 2102
      goto while_break;
    }
#line 2103
    (encoded.len) --;
#line 2104
    (encoded.data) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2107
  if (encoded.len == 0UL) {
#line 2108
    r->headers_in.user.data = (u_char *)"";
#line 2109
    return ((ngx_int_t )-5);
  }
  {
#line 2112
  auth.len = ((encoded.len + 3UL) / 4UL) * 3UL;
#line 2113
  tmp___0 = ngx_pnalloc(r->pool, auth.len + 1UL);
#line 2113
  auth.data = (u_char *)tmp___0;
  }
#line 2114
  if ((unsigned long )auth.data == (unsigned long )((void *)0)) {
#line 2115
    return ((ngx_int_t )-1);
  }
  {
#line 2118
  tmp___1 = ngx_decode_base64(& auth, & encoded);
  }
#line 2118
  if (tmp___1 != 0L) {
#line 2119
    r->headers_in.user.data = (u_char *)"";
#line 2120
    return ((ngx_int_t )-5);
  }
#line 2123
  *(auth.data + auth.len) = (u_char )'\000';
#line 2125
  len = (ngx_uint_t )0;
  {
#line 2125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2125
    if (! (len < auth.len)) {
#line 2125
      goto while_break___0;
    }
#line 2126
    if ((int )*(auth.data + len) == 58) {
#line 2127
      goto while_break___0;
    }
#line 2125
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2131
  if (len == 0UL) {
#line 2132
    r->headers_in.user.data = (u_char *)"";
#line 2133
    return ((ngx_int_t )-5);
  } else
#line 2131
  if (len == auth.len) {
#line 2132
    r->headers_in.user.data = (u_char *)"";
#line 2133
    return ((ngx_int_t )-5);
  }
#line 2136
  r->headers_in.user.len = len;
#line 2137
  r->headers_in.user.data = auth.data;
#line 2138
  r->headers_in.passwd.len = (auth.len - len) - 1UL;
#line 2139
  r->headers_in.passwd.data = auth.data + (len + 1UL);
#line 2141
  return ((ngx_int_t )0);
}
}
#line 2147 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_gzip_ok(ngx_http_request_t *r ) 
{ 
  time_t date ;
  time_t expires___0 ;
  ngx_uint_t p ;
  ngx_array_t *cc ;
  ngx_table_elt_t *e ;
  ngx_table_elt_t *d ;
  ngx_table_elt_t *ae ;
  ngx_http_core_loc_conf_t *clcf ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 2156
  r->gzip_tested = 1U;
#line 2158
  if ((unsigned long )r != (unsigned long )r->main) {
#line 2159
    return ((ngx_int_t )-5);
  }
#line 2162
  ae = r->headers_in.accept_encoding;
#line 2163
  if ((unsigned long )ae == (unsigned long )((void *)0)) {
#line 2164
    return ((ngx_int_t )-5);
  }
#line 2167
  if (ae->value.len < sizeof("gzip") - 1UL) {
#line 2168
    return ((ngx_int_t )-5);
  }
  {
#line 2180
  tmp = memcmp((void const   *)((char const   *)ae->value.data), (void const   *)"gzip,",
               (size_t )5);
  }
#line 2180
  if (tmp != 0) {
    {
#line 2180
    tmp___0 = ngx_http_gzip_accept_encoding(& ae->value);
    }
#line 2180
    if (tmp___0 != 0L) {
#line 2183
      return ((ngx_int_t )-5);
    }
  }
#line 2186
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2188
  if (r->headers_in.msie6) {
#line 2188
    if (clcf->gzip_disable_msie6) {
#line 2189
      return ((ngx_int_t )-5);
    }
  }
#line 2192
  if (r->http_version < clcf->gzip_http_version) {
#line 2193
    return ((ngx_int_t )-5);
  }
#line 2196
  if ((unsigned long )r->headers_in.via == (unsigned long )((void *)0)) {
#line 2197
    goto ok;
  }
#line 2200
  p = clcf->gzip_proxied;
#line 2202
  if (p & 2UL) {
#line 2203
    return ((ngx_int_t )-5);
  }
#line 2206
  if (p & 512UL) {
#line 2207
    goto ok;
  }
#line 2210
  if (r->headers_in.authorization) {
#line 2210
    if (p & 256UL) {
#line 2211
      goto ok;
    }
  }
#line 2214
  e = r->headers_out.expires;
#line 2216
  if (e) {
#line 2218
    if (! (p & 4UL)) {
#line 2219
      return ((ngx_int_t )-5);
    }
    {
#line 2222
    expires___0 = ngx_parse_http_time(e->value.data, e->value.len);
    }
#line 2223
    if (expires___0 == -1L) {
#line 2224
      return ((ngx_int_t )-5);
    }
#line 2227
    d = r->headers_out.date;
#line 2229
    if (d) {
      {
#line 2230
      date = ngx_parse_http_time(d->value.data, d->value.len);
      }
#line 2231
      if (date == -1L) {
#line 2232
        return ((ngx_int_t )-5);
      }
    } else {
#line 2236
      date = (time_t )ngx_cached_time->sec;
    }
#line 2239
    if (expires___0 < date) {
#line 2240
      goto ok;
    }
#line 2243
    return ((ngx_int_t )-5);
  }
#line 2246
  cc = & r->headers_out.cache_control;
#line 2248
  if (cc->elts) {
#line 2250
    if (p & 8UL) {
      {
#line 2250
      tmp___1 = ngx_http_parse_multi_header_lines(cc, & ngx_http_gzip_no_cache, (ngx_str_t *)((void *)0));
      }
#line 2250
      if (tmp___1 >= 0L) {
#line 2255
        goto ok;
      }
    }
#line 2258
    if (p & 16UL) {
      {
#line 2258
      tmp___2 = ngx_http_parse_multi_header_lines(cc, & ngx_http_gzip_no_store, (ngx_str_t *)((void *)0));
      }
#line 2258
      if (tmp___2 >= 0L) {
#line 2263
        goto ok;
      }
    }
#line 2266
    if (p & 32UL) {
      {
#line 2266
      tmp___3 = ngx_http_parse_multi_header_lines(cc, & ngx_http_gzip_private, (ngx_str_t *)((void *)0));
      }
#line 2266
      if (tmp___3 >= 0L) {
#line 2271
        goto ok;
      }
    }
#line 2274
    return ((ngx_int_t )-5);
  }
#line 2277
  if (p & 64UL) {
#line 2277
    if (r->headers_out.last_modified) {
#line 2278
      return ((ngx_int_t )-5);
    }
  }
#line 2281
  if (p & 128UL) {
#line 2281
    if (r->headers_out.etag) {
#line 2282
      return ((ngx_int_t )-5);
    }
  }
  ok: 
#line 2289
  if (clcf->gzip_disable) {
#line 2289
    if (r->headers_in.user_agent) {
      {
#line 2291
      tmp___4 = ngx_regex_exec_array(clcf->gzip_disable, & (r->headers_in.user_agent)->value,
                                     (r->connection)->log);
      }
#line 2291
      if (tmp___4 != -5L) {
#line 2296
        return ((ngx_int_t )-5);
      }
    }
  }
#line 2302
  r->gzip_ok = 1U;
#line 2304
  return ((ngx_int_t )0);
}
}
#line 2315 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_gzip_accept_encoding(ngx_str_t *ae ) 
{ 
  u_char *p ;
  u_char *start ;
  u_char *last ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  ngx_uint_t tmp___2 ;

  {
#line 2320
  start = ae->data;
#line 2321
  last = start + ae->len;
  {
#line 2323
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2324
    p = ngx_strcasestrn(start, (char *)"gzip", (size_t___0 )3);
    }
#line 2325
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2326
      return ((ngx_int_t )-5);
    }
#line 2329
    if ((unsigned long )p == (unsigned long )start) {
#line 2330
      goto while_break;
    } else
#line 2329
    if ((int )*(p - 1) == 44) {
#line 2330
      goto while_break;
    } else
#line 2329
    if ((int )*(p - 1) == 32) {
#line 2330
      goto while_break;
    }
#line 2333
    start = p + 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 2336
  p += 4;
  {
#line 2338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2338
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2338
      goto while_break___0;
    }
#line 2339
    tmp = p;
#line 2339
    p ++;
    {
#line 2340
    if ((int )*tmp == 44) {
#line 2340
      goto case_44;
    }
#line 2342
    if ((int )*tmp == 59) {
#line 2342
      goto case_59;
    }
#line 2344
    if ((int )*tmp == 32) {
#line 2344
      goto case_32;
    }
#line 2346
    goto switch_default;
    case_44: /* CIL Label */ 
#line 2341
    return ((ngx_int_t )0);
    case_59: /* CIL Label */ 
#line 2343
    goto quantity;
    case_32: /* CIL Label */ 
#line 2345
    goto while_continue___0;
    switch_default: /* CIL Label */ 
#line 2347
    return ((ngx_int_t )-5);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2351
  return ((ngx_int_t )0);
  quantity: 
  {
#line 2355
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2355
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2355
      goto while_break___1;
    }
#line 2356
    tmp___0 = p;
#line 2356
    p ++;
    {
#line 2358
    if ((int )*tmp___0 == 81) {
#line 2358
      goto case_81;
    }
#line 2358
    if ((int )*tmp___0 == 113) {
#line 2358
      goto case_81;
    }
#line 2360
    if ((int )*tmp___0 == 32) {
#line 2360
      goto case_32___0;
    }
#line 2362
    goto switch_default___0;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 2359
    goto equal;
    case_32___0: /* CIL Label */ 
#line 2361
    goto while_continue___1;
    switch_default___0: /* CIL Label */ 
#line 2363
    return ((ngx_int_t )-5);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2367
  return ((ngx_int_t )0);
  equal: 
#line 2371
  if ((unsigned long )(p + 2) > (unsigned long )last) {
#line 2372
    return ((ngx_int_t )-5);
  } else {
#line 2371
    tmp___1 = p;
#line 2371
    p ++;
#line 2371
    if ((int )*tmp___1 != 61) {
#line 2372
      return ((ngx_int_t )-5);
    }
  }
  {
#line 2375
  tmp___2 = ngx_http_gzip_quantity(p, last);
  }
#line 2375
  if (tmp___2 == 0UL) {
#line 2376
    return ((ngx_int_t )-5);
  }
#line 2379
  return ((ngx_int_t )0);
}
}
#line 2383 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_uint_t ngx_http_gzip_quantity(u_char *p , u_char *last ) 
{ 
  u_char c ;
  ngx_uint_t n ;
  ngx_uint_t q ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 2389
  tmp = p;
#line 2389
  p ++;
#line 2389
  c = *tmp;
#line 2391
  if ((int )c != 48) {
#line 2391
    if ((int )c != 49) {
#line 2392
      return ((ngx_uint_t )0);
    }
  }
#line 2395
  q = (ngx_uint_t )(((int )c - 48) * 100);
#line 2397
  if ((unsigned long )p == (unsigned long )last) {
#line 2398
    return (q);
  }
#line 2401
  tmp___0 = p;
#line 2401
  p ++;
#line 2401
  c = *tmp___0;
#line 2403
  if ((int )c == 44) {
#line 2404
    return (q);
  } else
#line 2403
  if ((int )c == 32) {
#line 2404
    return (q);
  }
#line 2407
  if ((int )c != 46) {
#line 2408
    return ((ngx_uint_t )0);
  }
#line 2411
  n = (ngx_uint_t )0;
  {
#line 2413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2413
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2413
      goto while_break;
    }
#line 2414
    tmp___1 = p;
#line 2414
    p ++;
#line 2414
    c = *tmp___1;
#line 2416
    if ((int )c == 44) {
#line 2417
      goto while_break;
    } else
#line 2416
    if ((int )c == 32) {
#line 2417
      goto while_break;
    }
#line 2420
    if ((int )c >= 48) {
#line 2420
      if ((int )c <= 57) {
#line 2421
        q += (ngx_uint_t )((int )c - 48);
#line 2422
        n ++;
#line 2423
        goto while_continue;
      }
    }
#line 2426
    return ((ngx_uint_t )0);
  }
  while_break: /* CIL Label */ ;
  }
#line 2429
  if (q > 100UL) {
#line 2430
    return ((ngx_uint_t )0);
  } else
#line 2429
  if (n > 3UL) {
#line 2430
    return ((ngx_uint_t )0);
  }
#line 2433
  return (q);
}
}
#line 2439 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_subrequest(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                              ngx_http_request_t **psr , ngx_http_post_subrequest_t *ps ,
                              ngx_uint_t flags ) 
{ 
  ngx_time_t *tp ;
  ngx_connection_t *c ;
  ngx_http_request_t *sr ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_postponed_request_t *pr ;
  ngx_http_postponed_request_t *p ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 2450
  if (r->subrequests == 0U) {
#line 2451
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2451
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "subrequests cycle while processing \"%V\"",
                         uri___0);
      }
    }
#line 2453
    return ((ngx_int_t )-1);
  }
#line 2459
  if ((r->main)->count >= 64535U) {
#line 2460
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 2460
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "request reference counter overflow while processing \"%V\"",
                         uri___0);
      }
    }
#line 2463
    return ((ngx_int_t )-1);
  }
  {
#line 2466
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_request_t ));
#line 2466
  sr = (ngx_http_request_t *)tmp;
  }
#line 2467
  if ((unsigned long )sr == (unsigned long )((void *)0)) {
#line 2468
    return ((ngx_int_t )-1);
  }
  {
#line 2471
  sr->signature = (uint32_t )1347703880;
#line 2473
  c = r->connection;
#line 2474
  sr->connection = c;
#line 2476
  tmp___0 = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);
#line 2476
  sr->ctx = (void **)tmp___0;
  }
#line 2477
  if ((unsigned long )sr->ctx == (unsigned long )((void *)0)) {
#line 2478
    return ((ngx_int_t )-1);
  }
  {
#line 2481
  tmp___1 = ngx_list_init(& sr->headers_out.headers, r->pool, (ngx_uint_t )20, sizeof(ngx_table_elt_t ));
  }
#line 2481
  if (tmp___1 != 0L) {
#line 2485
    return ((ngx_int_t )-1);
  }
  {
#line 2488
  tmp___2 = ngx_list_init(& sr->headers_out.trailers, r->pool, (ngx_uint_t )4, sizeof(ngx_table_elt_t ));
  }
#line 2488
  if (tmp___2 != 0L) {
#line 2492
    return ((ngx_int_t )-1);
  }
#line 2495
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 2496
  sr->main_conf = (cscf->ctx)->main_conf;
#line 2497
  sr->srv_conf = (cscf->ctx)->srv_conf;
#line 2498
  sr->loc_conf = (cscf->ctx)->loc_conf;
#line 2500
  sr->pool = r->pool;
#line 2502
  sr->headers_in = r->headers_in;
#line 2504
  sr->headers_out.content_length_n = (off_t )-1;
#line 2504
  if (sr->headers_out.content_length) {
#line 2504
    (sr->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 2504
    sr->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 2505
  sr->allow_ranges = 0U;
#line 2505
  if (sr->headers_out.accept_ranges) {
#line 2505
    (sr->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 2505
    sr->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
#line 2506
  sr->headers_out.last_modified_time = (time_t )-1;
#line 2506
  if (sr->headers_out.last_modified) {
#line 2506
    (sr->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 2506
    sr->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
  }
#line 2508
  sr->request_body = r->request_body;
#line 2514
  sr->method = (ngx_uint_t )2;
#line 2515
  sr->http_version = r->http_version;
#line 2517
  sr->request_line = r->request_line;
#line 2518
  sr->uri = *uri___0;
#line 2520
  if (args___0) {
#line 2521
    sr->args = *args___0;
  }
  {
#line 2527
  sr->subrequest_in_memory = (unsigned int )((flags & 2UL) != 0UL);
#line 2528
  sr->waited = (unsigned int )((flags & 4UL) != 0UL);
#line 2529
  sr->background = (unsigned int )((flags & 16UL) != 0UL);
#line 2531
  sr->unparsed_uri = r->unparsed_uri;
#line 2532
  sr->method_name = ngx_http_core_get_method;
#line 2533
  sr->http_protocol = r->http_protocol;
#line 2535
  ngx_http_set_exten(sr);
#line 2537
  sr->main = r->main;
#line 2538
  sr->parent = r;
#line 2539
  sr->post_subrequest = ps;
#line 2540
  sr->read_event_handler = & ngx_http_request_empty_handler;
#line 2541
  sr->write_event_handler = & ngx_http_handler;
#line 2543
  sr->variables = r->variables;
#line 2545
  sr->log_handler = r->log_handler;
  }
#line 2547
  if (! sr->background) {
#line 2548
    if ((unsigned long )c->data == (unsigned long )r) {
#line 2548
      if ((unsigned long )r->postponed == (unsigned long )((void *)0)) {
#line 2549
        c->data = (void *)sr;
      }
    }
    {
#line 2552
    tmp___3 = ngx_palloc(r->pool, sizeof(ngx_http_postponed_request_t ));
#line 2552
    pr = (ngx_http_postponed_request_t *)tmp___3;
    }
#line 2553
    if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2554
      return ((ngx_int_t )-1);
    }
#line 2557
    pr->request = sr;
#line 2558
    pr->out = (ngx_chain_t *)((void *)0);
#line 2559
    pr->next = (ngx_http_postponed_request_t *)((void *)0);
#line 2561
    if (r->postponed) {
#line 2562
      p = r->postponed;
      {
#line 2562
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2562
        if (! p->next) {
#line 2562
          goto while_break;
        }
#line 2562
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 2563
      p->next = pr;
    } else {
#line 2566
      r->postponed = pr;
    }
  }
#line 2570
  sr->internal = 1U;
#line 2572
  sr->discard_body = r->discard_body;
#line 2573
  sr->expect_tested = 1U;
#line 2574
  sr->main_filter_need_in_memory = r->main_filter_need_in_memory;
#line 2576
  sr->uri_changes = 11U;
#line 2577
  sr->subrequests = r->subrequests - 1U;
#line 2579
  tp = (ngx_time_t *)ngx_cached_time;
#line 2580
  sr->start_sec = tp->sec;
#line 2581
  sr->start_msec = tp->msec;
#line 2583
  ((r->main)->count) ++;
#line 2585
  *psr = sr;
#line 2587
  if (flags & 8UL) {
    {
#line 2588
    sr->method = r->method;
#line 2589
    sr->method_name = r->method_name;
#line 2590
    sr->loc_conf = r->loc_conf;
#line 2591
    sr->valid_location = r->valid_location;
#line 2592
    sr->content_handler = r->content_handler;
#line 2593
    sr->phase_handler = r->phase_handler;
#line 2594
    sr->write_event_handler = & ngx_http_core_run_phases;
#line 2596
    ngx_http_update_location_config(sr);
    }
  }
  {
#line 2599
  tmp___4 = ngx_http_post_request(sr, (ngx_http_posted_request_t *)((void *)0));
  }
#line 2599
  return (tmp___4);
}
}
#line 2603 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_internal_redirect(ngx_http_request_t *r , ngx_str_t *uri___0 ,
                                     ngx_str_t *args___0 ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 2609
  (r->uri_changes) --;
#line 2611
  if (r->uri_changes == 0U) {
#line 2612
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2612
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "rewrite or internal redirection cycle while internally redirecting to \"%V\"",
                         uri___0);
      }
    }
    {
#line 2616
    ((r->main)->count) ++;
#line 2617
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 2618
    return ((ngx_int_t )-4);
  }
#line 2621
  r->uri = *uri___0;
#line 2623
  if (args___0) {
#line 2624
    r->args = *args___0;
  } else {
#line 2627
    r->args.len = (size_t___0 )0;
#line 2627
    r->args.data = (u_char *)((void *)0);
  }
  {
#line 2633
  ngx_http_set_exten(r);
#line 2636
  memset((void *)r->ctx, 0, sizeof(void *) * ngx_http_max_module);
#line 2638
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 2639
  r->loc_conf = (cscf->ctx)->loc_conf;
#line 2641
  ngx_http_update_location_config(r);
#line 2644
  r->cache = (ngx_http_cache_t *)((void *)0);
#line 2647
  r->internal = 1U;
#line 2648
  r->valid_unparsed_uri = 0U;
#line 2649
  r->add_uri_to_alias = 0U;
#line 2650
  ((r->main)->count) ++;
#line 2652
  ngx_http_handler(r);
  }
#line 2654
  return ((ngx_int_t )-4);
}
}
#line 2658 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_named_location(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_loc_conf_t **clcfp ;
  ngx_http_core_main_conf_t *cmcf ;
  int tmp ;

  {
#line 2665
  ((r->main)->count) ++;
#line 2666
  (r->uri_changes) --;
#line 2668
  if (r->uri_changes == 0U) {
#line 2669
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2669
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "rewrite or internal redirection cycle while redirect to named location \"%V\"",
                         name);
      }
    }
    {
#line 2673
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 2674
    return ((ngx_int_t )-4);
  }
#line 2677
  if (r->uri.len == 0UL) {
#line 2678
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2678
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "empty URI in redirect to named location \"%V\"",
                         name);
      }
    }
    {
#line 2681
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 2682
    return ((ngx_int_t )-4);
  }
#line 2685
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 2687
  if (cscf->named_locations) {
#line 2689
    clcfp = cscf->named_locations;
    {
#line 2689
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2689
      if (! *clcfp) {
#line 2689
        goto while_break;
      }
#line 2694
      if (name->len != (*clcfp)->name.len) {
#line 2697
        goto __Cont;
      } else {
        {
#line 2694
        tmp = strncmp((char const   *)name->data, (char const   *)(*clcfp)->name.data,
                      name->len);
        }
#line 2694
        if (tmp != 0) {
#line 2697
          goto __Cont;
        }
      }
      {
#line 2704
      r->internal = 1U;
#line 2705
      r->content_handler = (ngx_int_t (*)(ngx_http_request_t *r ))((void *)0);
#line 2706
      r->uri_changed = 0U;
#line 2707
      r->loc_conf = (*clcfp)->loc_conf;
#line 2710
      memset((void *)r->ctx, 0, sizeof(void *) * ngx_http_max_module);
#line 2712
      ngx_http_update_location_config(r);
#line 2714
      cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 2716
      r->phase_handler = (ngx_int_t )cmcf->phase_engine.location_rewrite_index;
#line 2718
      r->write_event_handler = & ngx_http_core_run_phases;
#line 2719
      ngx_http_core_run_phases(r);
      }
#line 2721
      return ((ngx_int_t )-4);
      __Cont: /* CIL Label */ 
#line 2689
      clcfp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2725
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 2725
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "could not find named location \"%V\"",
                       name);
    }
  }
  {
#line 2728
  ngx_http_finalize_request(r, (ngx_int_t )500);
  }
#line 2730
  return ((ngx_int_t )-4);
}
}
#line 2734 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_http_cleanup_t *ngx_http_cleanup_add(ngx_http_request_t *r , size_t___0 size ) 
{ 
  ngx_http_cleanup_t *cln ;
  void *tmp ;

  {
  {
#line 2739
  r = r->main;
#line 2741
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_cleanup_t ));
#line 2741
  cln = (ngx_http_cleanup_t *)tmp;
  }
#line 2742
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 2743
    return ((ngx_http_cleanup_t *)((void *)0));
  }
#line 2746
  if (size) {
    {
#line 2747
    cln->data = ngx_palloc(r->pool, size);
    }
#line 2748
    if ((unsigned long )cln->data == (unsigned long )((void *)0)) {
#line 2749
      return ((ngx_http_cleanup_t *)((void *)0));
    }
  } else {
#line 2753
    cln->data = (void *)0;
  }
#line 2756
  cln->handler = (void (*)(void *data ))((void *)0);
#line 2757
  cln->next = r->cleanup;
#line 2759
  r->cleanup = cln;
#line 2764
  return (cln);
}
}
#line 2768 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                        ngx_str_t *path , ngx_open_file_info_t *of ) 
{ 
  u_char *p ;
  ngx_str_t from ;
  ngx_int_t tmp ;
  int tmp___0 ;

  {
#line 2776
  of->disable_symlinks = (unsigned int )clcf->disable_symlinks;
#line 2778
  if ((unsigned long )clcf->disable_symlinks_from == (unsigned long )((void *)0)) {
#line 2779
    return ((ngx_int_t )0);
  }
  {
#line 2782
  tmp = ngx_http_complex_value(r, clcf->disable_symlinks_from, & from);
  }
#line 2782
  if (tmp != 0L) {
#line 2785
    return ((ngx_int_t )-1);
  }
#line 2788
  if (from.len == 0UL) {
#line 2792
    return ((ngx_int_t )0);
  } else
#line 2788
  if (from.len > path->len) {
#line 2792
    return ((ngx_int_t )0);
  } else {
    {
#line 2788
    tmp___0 = memcmp((void const   *)((char const   *)path->data), (void const   *)((char const   *)from.data),
                     from.len);
    }
#line 2788
    if (tmp___0 != 0) {
#line 2792
      return ((ngx_int_t )0);
    }
  }
#line 2795
  if (from.len == path->len) {
#line 2796
    of->disable_symlinks = 0U;
#line 2797
    return ((ngx_int_t )0);
  }
#line 2800
  p = path->data + from.len;
#line 2802
  if ((int )*p == 47) {
#line 2803
    of->disable_symlinks_from = from.len;
#line 2804
    return ((ngx_int_t )0);
  }
#line 2807
  p --;
#line 2809
  if ((int )*p == 47) {
#line 2810
    of->disable_symlinks_from = from.len - 1UL;
  }
#line 2814
  return ((ngx_int_t )0);
}
}
#line 2818 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r , ngx_addr_t *addr , ngx_array_t *headers ,
                                      ngx_str_t *value , ngx_array_t *proxies , int recursive ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_uint_t found ;
  ngx_table_elt_t **h ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;

  {
#line 2827
  if ((unsigned long )headers == (unsigned long )((void *)0)) {
    {
#line 2828
    tmp = ngx_http_get_forwarded_addr_internal(r, addr, value->data, value->len, proxies,
                                               recursive);
    }
#line 2828
    return (tmp);
  }
#line 2833
  i = headers->nelts;
#line 2834
  h = (ngx_table_elt_t **)headers->elts;
#line 2836
  rc = (ngx_int_t )-5;
#line 2838
  found = (ngx_uint_t )0;
  {
#line 2840
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2840
    tmp___0 = i;
#line 2840
    i --;
#line 2840
    if (! (tmp___0 > 0UL)) {
#line 2840
      goto while_break;
    }
    {
#line 2841
    rc = ngx_http_get_forwarded_addr_internal(r, addr, (*(h + i))->value.data, (*(h + i))->value.len,
                                              proxies, recursive);
    }
#line 2845
    if (! recursive) {
#line 2846
      goto while_break;
    }
#line 2849
    if (rc == -5L) {
#line 2849
      if (found) {
#line 2850
        rc = (ngx_int_t )-4;
#line 2851
        goto while_break;
      }
    }
#line 2854
    if (rc != 0L) {
#line 2855
      goto while_break;
    }
#line 2858
    found = (ngx_uint_t )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2861
  return (rc);
}
}
#line 2865 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r , ngx_addr_t *addr ,
                                                      u_char *xff , size_t___0 xfflen ,
                                                      ngx_array_t *proxies , int recursive ) 
{ 
  u_char *p ;
  ngx_int_t rc ;
  ngx_addr_t paddr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2873
  tmp = ngx_cidr_match(addr->sockaddr, proxies);
  }
#line 2873
  if (tmp != 0L) {
#line 2874
    return ((ngx_int_t )-5);
  }
#line 2877
  p = (xff + xfflen) - 1;
  {
#line 2877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2877
    if (! ((unsigned long )p > (unsigned long )xff)) {
#line 2877
      goto while_break;
    }
#line 2878
    if ((int )*p != 32) {
#line 2878
      if ((int )*p != 44) {
#line 2879
        goto while_break;
      }
    }
#line 2877
    p --;
#line 2877
    xfflen --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2883
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2883
    if (! ((unsigned long )p > (unsigned long )xff)) {
#line 2883
      goto while_break___0;
    }
#line 2884
    if ((int )*p == 32) {
#line 2885
      p ++;
#line 2886
      goto while_break___0;
    } else
#line 2884
    if ((int )*p == 44) {
#line 2885
      p ++;
#line 2886
      goto while_break___0;
    }
#line 2883
    p --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2890
  tmp___0 = ngx_parse_addr_port(r->pool, & paddr, p, xfflen - (size_t___0 )(p - xff));
  }
#line 2890
  if (tmp___0 != 0L) {
#line 2891
    return ((ngx_int_t )-5);
  }
#line 2894
  *addr = paddr;
#line 2896
  if (recursive) {
#line 2896
    if ((unsigned long )p > (unsigned long )xff) {
      {
#line 2897
      rc = ngx_http_get_forwarded_addr_internal(r, addr, xff, (size_t___0 )((p - 1) - xff),
                                                proxies, 1);
      }
#line 2900
      if (rc == -5L) {
#line 2901
        return ((ngx_int_t )-4);
      }
#line 2905
      return (rc);
    }
  }
#line 2908
  return ((ngx_int_t )0);
}
}
#line 2912 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_server(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) 
{ 
  char *rv ;
  void *mconf ;
  ngx_uint_t i ;
  ngx_conf_t pcf ;
  ngx_http_module_t *module ;
  struct sockaddr_in *sin ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *http_ctx ;
  ngx_http_listen_opt_t lsopt ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_srv_conf_t **cscfp ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned short __v ;
  unsigned short __x ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  ngx_int_t tmp___6 ;

  {
  {
#line 2926
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 2926
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 2927
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2928
    return ((char *)((void *)-1));
  }
  {
#line 2931
  http_ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 2932
  ctx->main_conf = http_ctx->main_conf;
#line 2936
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 2936
  ctx->srv_conf = (void **)tmp___0;
  }
#line 2937
  if ((unsigned long )ctx->srv_conf == (unsigned long )((void *)0)) {
#line 2938
    return ((char *)((void *)-1));
  }
  {
#line 2943
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 2943
  ctx->loc_conf = (void **)tmp___1;
  }
#line 2944
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 2945
    return ((char *)((void *)-1));
  }
#line 2948
  i = (ngx_uint_t )0;
  {
#line 2948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2948
    if (! *((cf->cycle)->modules + i)) {
#line 2948
      goto while_break;
    }
#line 2949
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 2950
      goto __Cont;
    }
#line 2953
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 2955
    if (module->create_srv_conf) {
      {
#line 2956
      mconf = (*(module->create_srv_conf))(cf);
      }
#line 2957
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 2958
        return ((char *)((void *)-1));
      }
#line 2961
      *(ctx->srv_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
#line 2964
    if (module->create_loc_conf) {
      {
#line 2965
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 2966
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 2967
        return ((char *)((void *)-1));
      }
#line 2970
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
    __Cont: /* CIL Label */ 
#line 2948
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2977
  cscf = (ngx_http_core_srv_conf_t *)*(ctx->srv_conf + ngx_http_core_module.ctx_index);
#line 2978
  cscf->ctx = ctx;
#line 2981
  cmcf = (ngx_http_core_main_conf_t *)*(ctx->main_conf + ngx_http_core_module.ctx_index);
#line 2983
  tmp___2 = ngx_array_push(& cmcf->servers);
#line 2983
  cscfp = (ngx_http_core_srv_conf_t **)tmp___2;
  }
#line 2984
  if ((unsigned long )cscfp == (unsigned long )((void *)0)) {
#line 2985
    return ((char *)((void *)-1));
  }
  {
#line 2988
  *cscfp = cscf;
#line 2993
  pcf = *cf;
#line 2994
  cf->ctx = (void *)ctx;
#line 2995
  cf->cmd_type = (ngx_uint_t )67108864;
#line 2997
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 2999
  *cf = pcf;
  }
#line 3001
  if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 3001
    if (! cscf->listen) {
      {
#line 3002
      memset((void *)(& lsopt), 0, sizeof(ngx_http_listen_opt_t ));
#line 3004
      sin = & lsopt.sockaddr.sockaddr_in;
#line 3006
      sin->sin_family = (sa_family_t )2;
#line 3010
      tmp___5 = getuid();
      }
#line 3010
      if (tmp___5 == 0U) {
#line 3010
        tmp___4 = 80;
      } else {
#line 3010
        tmp___4 = 8000;
      }
      {
#line 3010
      __x = (unsigned short )tmp___4;
#line 3010
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 3010
      sin->sin_port = __v;
#line 3012
      sin->sin_addr.s_addr = (in_addr_t )0;
#line 3014
      lsopt.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 3016
      lsopt.backlog = 511;
#line 3017
      lsopt.rcvbuf = -1;
#line 3018
      lsopt.sndbuf = -1;
#line 3023
      lsopt.fastopen = -1;
#line 3025
      lsopt.wildcard = 1U;
#line 3027
      ngx_sock_ntop(& lsopt.sockaddr.sockaddr, lsopt.socklen, lsopt.addr, (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)),
                    (ngx_uint_t )1);
#line 3030
      tmp___6 = ngx_http_add_listen(cf, cscf, & lsopt);
      }
#line 3030
      if (tmp___6 != 0L) {
#line 3031
        return ((char *)((void *)-1));
      }
    }
  }
#line 3035
  return (rv);
}
}
#line 3039 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_location(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) 
{ 
  char *rv ;
  u_char *mod ;
  size_t___0 len ;
  ngx_str_t *value ;
  ngx_str_t *name ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *pctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_loc_conf_t *pclcf ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;

  {
  {
#line 3052
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 3052
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 3053
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 3054
    return ((char *)((void *)-1));
  }
  {
#line 3057
  pctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 3058
  ctx->main_conf = pctx->main_conf;
#line 3059
  ctx->srv_conf = pctx->srv_conf;
#line 3061
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 3061
  ctx->loc_conf = (void **)tmp___0;
  }
#line 3062
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 3063
    return ((char *)((void *)-1));
  }
#line 3066
  i = (ngx_uint_t )0;
  {
#line 3066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3066
    if (! *((cf->cycle)->modules + i)) {
#line 3066
      goto while_break;
    }
#line 3067
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 3068
      goto __Cont;
    }
#line 3071
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 3073
    if (module->create_loc_conf) {
      {
#line 3074
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = (*(module->create_loc_conf))(cf);
      }
#line 3076
      if ((unsigned long )*(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) == (unsigned long )((void *)0)) {
#line 3077
        return ((char *)((void *)-1));
      }
    }
    __Cont: /* CIL Label */ 
#line 3066
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3082
  clcf = (ngx_http_core_loc_conf_t *)*(ctx->loc_conf + ngx_http_core_module.ctx_index);
#line 3083
  clcf->loc_conf = ctx->loc_conf;
#line 3085
  value = (ngx_str_t *)(cf->args)->elts;
#line 3087
  if ((cf->args)->nelts == 3UL) {
#line 3089
    len = (value + 1)->len;
#line 3090
    mod = (value + 1)->data;
#line 3091
    name = value + 2;
#line 3093
    if (len == 1UL) {
#line 3093
      if ((int )*(mod + 0) == 61) {
#line 3095
        clcf->name = *name;
#line 3096
        clcf->exact_match = 1U;
      } else {
#line 3093
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 3098
    if (len == 2UL) {
#line 3098
      if ((int )*(mod + 0) == 94) {
#line 3098
        if ((int )*(mod + 1) == 126) {
#line 3100
          clcf->name = *name;
#line 3101
          clcf->noregex = 1U;
        } else {
#line 3098
          goto _L___1;
        }
      } else {
#line 3098
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3103
    if (len == 1UL) {
#line 3103
      if ((int )*(mod + 0) == 126) {
        {
#line 3105
        tmp___1 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )0);
        }
#line 3105
        if (tmp___1 != 0L) {
#line 3106
          return ((char *)((void *)-1));
        }
      } else {
#line 3103
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3109
    if (len == 2UL) {
#line 3109
      if ((int )*(mod + 0) == 126) {
#line 3109
        if ((int )*(mod + 1) == 42) {
          {
#line 3111
          tmp___2 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )1);
          }
#line 3111
          if (tmp___2 != 0L) {
#line 3112
            return ((char *)((void *)-1));
          }
        } else {
          {
#line 3116
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid location modifier \"%V\"",
                             value + 1);
          }
#line 3118
          return ((char *)((void *)-1));
        }
      } else {
        {
#line 3116
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid location modifier \"%V\"",
                           value + 1);
        }
#line 3118
        return ((char *)((void *)-1));
      }
    } else {
      {
#line 3116
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid location modifier \"%V\"",
                         value + 1);
      }
#line 3118
      return ((char *)((void *)-1));
    }
  } else {
#line 3123
    name = value + 1;
#line 3125
    if ((int )*(name->data + 0) == 61) {
#line 3127
      clcf->name.len = name->len - 1UL;
#line 3128
      clcf->name.data = name->data + 1;
#line 3129
      clcf->exact_match = 1U;
    } else
#line 3131
    if ((int )*(name->data + 0) == 94) {
#line 3131
      if ((int )*(name->data + 1) == 126) {
#line 3133
        clcf->name.len = name->len - 2UL;
#line 3134
        clcf->name.data = name->data + 2;
#line 3135
        clcf->noregex = 1U;
      } else {
#line 3131
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 3137
    if ((int )*(name->data + 0) == 126) {
#line 3139
      (name->len) --;
#line 3140
      (name->data) ++;
#line 3142
      if ((int )*(name->data + 0) == 42) {
        {
#line 3144
        (name->len) --;
#line 3145
        (name->data) ++;
#line 3147
        tmp___3 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )1);
        }
#line 3147
        if (tmp___3 != 0L) {
#line 3148
          return ((char *)((void *)-1));
        }
      } else {
        {
#line 3152
        tmp___4 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )0);
        }
#line 3152
        if (tmp___4 != 0L) {
#line 3153
          return ((char *)((void *)-1));
        }
      }
    } else {
#line 3159
      clcf->name = *name;
#line 3161
      if ((int )*(name->data + 0) == 64) {
#line 3162
        clcf->named = 1U;
      }
    }
  }
#line 3167
  pclcf = (ngx_http_core_loc_conf_t *)*(pctx->loc_conf + ngx_http_core_module.ctx_index);
#line 3169
  if (cf->cmd_type == 134217728UL) {
#line 3177
    if (pclcf->exact_match) {
      {
#line 3178
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "location \"%V\" cannot be inside the exact location \"%V\"",
                         & clcf->name, & pclcf->name);
      }
#line 3182
      return ((char *)((void *)-1));
    }
#line 3185
    if (pclcf->named) {
      {
#line 3186
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "location \"%V\" cannot be inside the named location \"%V\"",
                         & clcf->name, & pclcf->name);
      }
#line 3190
      return ((char *)((void *)-1));
    }
#line 3193
    if (clcf->named) {
      {
#line 3194
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "named location \"%V\" can be on the server level only",
                         & clcf->name);
      }
#line 3198
      return ((char *)((void *)-1));
    }
#line 3201
    len = pclcf->name.len;
#line 3204
    if ((unsigned long )clcf->regex == (unsigned long )((void *)0)) {
      {
#line 3204
      tmp___5 = ngx_filename_cmp(clcf->name.data, pclcf->name.data, len);
      }
#line 3204
      if (tmp___5 != 0L) {
        {
#line 3210
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "location \"%V\" is outside location \"%V\"",
                           & clcf->name, & pclcf->name);
        }
#line 3213
        return ((char *)((void *)-1));
      }
    }
  }
  {
#line 3217
  tmp___6 = ngx_http_add_location(cf, & pclcf->locations, clcf);
  }
#line 3217
  if (tmp___6 != 0L) {
#line 3218
    return ((char *)((void *)-1));
  }
  {
#line 3221
  save = *cf;
#line 3222
  cf->ctx = (void *)ctx;
#line 3223
  cf->cmd_type = (ngx_uint_t )134217728;
#line 3225
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 3227
  *cf = save;
  }
#line 3229
  return (rv);
}
}
#line 3233 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_regex_location(ngx_conf_t *cf , ngx_http_core_loc_conf_t *clcf ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) 
{ 
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;

  {
  {
#line 3241
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 3243
  rc.pattern = *regex;
#line 3244
  rc.err.len = (size_t___0 )1024;
#line 3245
  rc.err.data = errstr;
  }
#line 3250
  if (caseless) {
#line 3250
    rc.options = (ngx_int_t )1;
  } else {
#line 3250
    rc.options = (ngx_int_t )0;
  }
  {
#line 3253
  clcf->regex = ngx_http_regex_compile(cf, & rc);
  }
#line 3254
  if ((unsigned long )clcf->regex == (unsigned long )((void *)0)) {
#line 3255
    return ((ngx_int_t )-1);
  }
#line 3258
  clcf->name = *regex;
#line 3260
  return ((ngx_int_t )0);
}
}
#line 3273 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_types(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  char *rv ;
  ngx_conf_t save ;

  {
#line 3276
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 3281
  if ((unsigned long )clcf->types == (unsigned long )((void *)0)) {
    {
#line 3282
    clcf->types = ngx_array_create(cf->pool, (ngx_uint_t )64, sizeof(ngx_hash_key_t ));
    }
#line 3283
    if ((unsigned long )clcf->types == (unsigned long )((void *)0)) {
#line 3284
      return ((char *)((void *)-1));
    }
  }
  {
#line 3288
  save = *cf;
#line 3289
  cf->handler = & ngx_http_core_type;
#line 3290
  cf->handler_conf = (char *)conf;
#line 3292
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 3294
  *cf = save;
  }
#line 3296
  return (rv);
}
}
#line 3300 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_type(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_str_t *content_type ;
  ngx_str_t *old ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_hash_key_t *type ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3303
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 3309
  value = (ngx_str_t *)(cf->args)->elts;
#line 3311
  tmp___0 = strcmp((char const   *)(value + 0)->data, "include");
  }
#line 3311
  if (tmp___0 == 0) {
#line 3312
    if ((cf->args)->nelts != 2UL) {
      {
#line 3313
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of arguments in \"include\" directive");
      }
#line 3316
      return ((char *)((void *)-1));
    }
    {
#line 3319
    tmp = ngx_conf_include(cf, dummy, conf);
    }
#line 3319
    return (tmp);
  }
  {
#line 3322
  tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_str_t ));
#line 3322
  content_type = (ngx_str_t *)tmp___1;
  }
#line 3323
  if ((unsigned long )content_type == (unsigned long )((void *)0)) {
#line 3324
    return ((char *)((void *)-1));
  }
#line 3327
  *content_type = *(value + 0);
#line 3329
  i = (ngx_uint_t )1;
  {
#line 3329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3329
    if (! (i < (cf->args)->nelts)) {
#line 3329
      goto while_break;
    }
    {
#line 3331
    hash = ngx_hash_strlow((value + i)->data, (value + i)->data, (value + i)->len);
#line 3333
    type = (ngx_hash_key_t *)(clcf->types)->elts;
#line 3334
    n = (ngx_uint_t )0;
    }
    {
#line 3334
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3334
      if (! (n < (clcf->types)->nelts)) {
#line 3334
        goto while_break___0;
      }
      {
#line 3335
      tmp___2 = strcmp((char const   *)(value + i)->data, (char const   *)(type + n)->key.data);
      }
#line 3335
      if (tmp___2 == 0) {
        {
#line 3336
        old = (ngx_str_t *)(type + n)->value;
#line 3337
        (type + n)->value = (void *)content_type;
#line 3339
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate extension \"%V\", content type: \"%V\", previous content type: \"%V\"",
                           value + i, content_type, old);
        }
#line 3344
        goto next;
      }
#line 3334
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3349
    tmp___3 = ngx_array_push(clcf->types);
#line 3349
    type = (ngx_hash_key_t *)tmp___3;
    }
#line 3350
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 3351
      return ((char *)((void *)-1));
    }
#line 3354
    type->key = *(value + i);
#line 3355
    type->key_hash = hash;
#line 3356
    type->value = (void *)content_type;
    next: 
#line 3359
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 3329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3362
  return ((char *)((void *)0));
}
}
#line 3366 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_preconfiguration(ngx_conf_t *cf ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 3369
  tmp = ngx_http_variables_add_core_vars(cf);
  }
#line 3369
  return (tmp);
}
}
#line 3373 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_postconfiguration(ngx_conf_t *cf ) 
{ 


  {
#line 3376
  ngx_http_top_request_body_filter = & ngx_http_request_body_save_filter;
#line 3378
  return ((ngx_int_t )0);
}
}
#line 3382 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static void *ngx_http_core_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3387
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_main_conf_t ));
#line 3387
  cmcf = (ngx_http_core_main_conf_t *)tmp;
  }
#line 3388
  if ((unsigned long )cmcf == (unsigned long )((void *)0)) {
#line 3389
    return ((void *)0);
  }
  {
#line 3392
  tmp___0 = ngx_array_init(& cmcf->servers, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_core_srv_conf_t *));
  }
#line 3392
  if (tmp___0 != 0L) {
#line 3396
    return ((void *)0);
  }
#line 3399
  cmcf->server_names_hash_max_size = (ngx_uint_t )-1;
#line 3400
  cmcf->server_names_hash_bucket_size = (ngx_uint_t )-1;
#line 3402
  cmcf->variables_hash_max_size = (ngx_uint_t )-1;
#line 3403
  cmcf->variables_hash_bucket_size = (ngx_uint_t )-1;
#line 3405
  return ((void *)cmcf);
}
}
#line 3409 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_init_main_conf(ngx_conf_t *cf , void *conf ) 
{ 
  ngx_http_core_main_conf_t *cmcf ;

  {
#line 3412
  cmcf = (ngx_http_core_main_conf_t *)conf;
#line 3414
  if (cmcf->server_names_hash_max_size == 0xffffffffffffffffUL) {
#line 3414
    cmcf->server_names_hash_max_size = (ngx_uint_t )512;
  }
#line 3415
  if (cmcf->server_names_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3415
    cmcf->server_names_hash_bucket_size = ngx_cacheline_size;
  }
#line 3418
  cmcf->server_names_hash_bucket_size = (cmcf->server_names_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3422
  if (cmcf->variables_hash_max_size == 0xffffffffffffffffUL) {
#line 3422
    cmcf->variables_hash_max_size = (ngx_uint_t )1024;
  }
#line 3423
  if (cmcf->variables_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3423
    cmcf->variables_hash_bucket_size = (ngx_uint_t )64;
  }
#line 3425
  cmcf->variables_hash_bucket_size = (cmcf->variables_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3428
  if (cmcf->ncaptures) {
#line 3429
    cmcf->ncaptures = (cmcf->ncaptures + 1UL) * 3UL;
  }
#line 3432
  return ((char *)((void *)0));
}
}
#line 3436 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static void *ngx_http_core_create_srv_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3441
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_srv_conf_t ));
#line 3441
  cscf = (ngx_http_core_srv_conf_t *)tmp;
  }
#line 3442
  if ((unsigned long )cscf == (unsigned long )((void *)0)) {
#line 3443
    return ((void *)0);
  }
  {
#line 3452
  tmp___0 = ngx_array_init(& cscf->server_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_server_name_t ));
  }
#line 3452
  if (tmp___0 != 0L) {
#line 3456
    return ((void *)0);
  }
#line 3459
  cscf->connection_pool_size = (size_t___0 )-1;
#line 3460
  cscf->request_pool_size = (size_t___0 )-1;
#line 3461
  cscf->client_header_timeout = (ngx_msec_t )-1;
#line 3462
  cscf->client_header_buffer_size = (size_t___0 )-1;
#line 3463
  cscf->ignore_invalid_headers = (ngx_flag_t )-1;
#line 3464
  cscf->merge_slashes = (ngx_flag_t )-1;
#line 3465
  cscf->underscores_in_headers = (ngx_flag_t )-1;
#line 3467
  return ((void *)cscf);
}
}
#line 3471 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_merge_srv_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_core_srv_conf_t *prev ;
  ngx_http_core_srv_conf_t *conf ;
  ngx_str_t name ;
  ngx_http_server_name_t *sn ;
  void *tmp ;

  {
#line 3474
  prev = (ngx_http_core_srv_conf_t *)parent;
#line 3475
  conf = (ngx_http_core_srv_conf_t *)child;
#line 3482
  if (conf->connection_pool_size == 0xffffffffffffffffUL) {
#line 3482
    if (prev->connection_pool_size == 0xffffffffffffffffUL) {
#line 3482
      conf->connection_pool_size = 64UL * sizeof(void *);
    } else {
#line 3482
      conf->connection_pool_size = prev->connection_pool_size;
    }
  }
#line 3484
  if (conf->request_pool_size == 0xffffffffffffffffUL) {
#line 3484
    if (prev->request_pool_size == 0xffffffffffffffffUL) {
#line 3484
      conf->request_pool_size = (size_t___0 )4096;
    } else {
#line 3484
      conf->request_pool_size = prev->request_pool_size;
    }
  }
#line 3486
  if (conf->client_header_timeout == 0xffffffffffffffffUL) {
#line 3486
    if (prev->client_header_timeout == 0xffffffffffffffffUL) {
#line 3486
      conf->client_header_timeout = (ngx_msec_t )60000;
    } else {
#line 3486
      conf->client_header_timeout = prev->client_header_timeout;
    }
  }
#line 3488
  if (conf->client_header_buffer_size == 0xffffffffffffffffUL) {
#line 3488
    if (prev->client_header_buffer_size == 0xffffffffffffffffUL) {
#line 3488
      conf->client_header_buffer_size = (size_t___0 )1024;
    } else {
#line 3488
      conf->client_header_buffer_size = prev->client_header_buffer_size;
    }
  }
#line 3490
  if (conf->large_client_header_buffers.num == 0L) {
#line 3490
    if (prev->large_client_header_buffers.num) {
#line 3490
      conf->large_client_header_buffers.num = prev->large_client_header_buffers.num;
#line 3490
      conf->large_client_header_buffers.size = prev->large_client_header_buffers.size;
    } else {
#line 3490
      conf->large_client_header_buffers.num = (ngx_int_t )4;
#line 3490
      conf->large_client_header_buffers.size = (size_t___0 )8192;
    }
  }
#line 3494
  if (conf->large_client_header_buffers.size < conf->connection_pool_size) {
    {
#line 3495
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"large_client_header_buffers\" size must be equal to or greater than \"connection_pool_size\"");
    }
#line 3498
    return ((char *)((void *)-1));
  }
#line 3501
  if (conf->ignore_invalid_headers == -1L) {
#line 3501
    if (prev->ignore_invalid_headers == -1L) {
#line 3501
      conf->ignore_invalid_headers = (ngx_flag_t )1;
    } else {
#line 3501
      conf->ignore_invalid_headers = prev->ignore_invalid_headers;
    }
  }
#line 3504
  if (conf->merge_slashes == -1L) {
#line 3504
    if (prev->merge_slashes == -1L) {
#line 3504
      conf->merge_slashes = (ngx_flag_t )1;
    } else {
#line 3504
      conf->merge_slashes = prev->merge_slashes;
    }
  }
#line 3506
  if (conf->underscores_in_headers == -1L) {
#line 3506
    if (prev->underscores_in_headers == -1L) {
#line 3506
      conf->underscores_in_headers = (ngx_flag_t )0;
    } else {
#line 3506
      conf->underscores_in_headers = prev->underscores_in_headers;
    }
  }
#line 3509
  if (conf->server_names.nelts == 0UL) {
    {
#line 3511
    tmp = ngx_array_push(& conf->server_names);
#line 3511
    sn = (ngx_http_server_name_t *)tmp;
#line 3513
    sn->regex = (ngx_http_regex_t *)((void *)0);
#line 3515
    sn->server = conf;
#line 3516
    sn->name.len = sizeof("") - 1UL;
#line 3516
    sn->name.data = (u_char *)"";
    }
  }
#line 3519
  sn = (ngx_http_server_name_t *)conf->server_names.elts;
#line 3520
  name = (sn + 0)->name;
#line 3523
  if (sn->regex) {
#line 3524
    (name.len) ++;
#line 3525
    (name.data) --;
  } else
#line 3529
  if ((int )*(name.data + 0) == 46) {
#line 3530
    (name.len) --;
#line 3531
    (name.data) ++;
  }
  {
#line 3534
  conf->server_name.len = name.len;
#line 3535
  conf->server_name.data = ngx_pstrdup(cf->pool, & name);
  }
#line 3536
  if ((unsigned long )conf->server_name.data == (unsigned long )((void *)0)) {
#line 3537
    return ((char *)((void *)-1));
  }
#line 3540
  return ((char *)((void *)0));
}
}
#line 3544 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static void *ngx_http_core_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;

  {
  {
#line 3549
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_loc_conf_t ));
#line 3549
  clcf = (ngx_http_core_loc_conf_t *)tmp;
  }
#line 3550
  if ((unsigned long )clcf == (unsigned long )((void *)0)) {
#line 3551
    return ((void *)0);
  }
#line 3574
  clcf->client_max_body_size = (off_t )-1;
#line 3575
  clcf->client_body_buffer_size = (size_t___0 )-1;
#line 3576
  clcf->client_body_timeout = (ngx_msec_t )-1;
#line 3577
  clcf->satisfy = (ngx_uint_t )-1;
#line 3578
  clcf->if_modified_since = (ngx_uint_t )-1;
#line 3579
  clcf->max_ranges = (ngx_uint_t )-1;
#line 3580
  clcf->client_body_in_file_only = (ngx_uint_t )-1;
#line 3581
  clcf->client_body_in_single_buffer = (ngx_flag_t )-1;
#line 3582
  clcf->internal = (ngx_flag_t )-1;
#line 3583
  clcf->sendfile = (ngx_flag_t )-1;
#line 3584
  clcf->sendfile_max_chunk = (size_t___0 )-1;
#line 3585
  clcf->aio = (ngx_flag_t )-1;
#line 3586
  clcf->aio_write = (ngx_flag_t )-1;
#line 3591
  clcf->read_ahead = (size_t___0 )-1;
#line 3592
  clcf->directio = (off_t )-1;
#line 3593
  clcf->directio_alignment = (off_t )-1;
#line 3594
  clcf->tcp_nopush = (ngx_flag_t )-1;
#line 3595
  clcf->tcp_nodelay = (ngx_flag_t )-1;
#line 3596
  clcf->send_timeout = (ngx_msec_t )-1;
#line 3597
  clcf->send_lowat = (size_t___0 )-1;
#line 3598
  clcf->postpone_output = (size_t___0 )-1;
#line 3599
  clcf->limit_rate = (size_t___0 )-1;
#line 3600
  clcf->limit_rate_after = (size_t___0 )-1;
#line 3601
  clcf->keepalive_timeout = (ngx_msec_t )-1;
#line 3602
  clcf->keepalive_header = (time_t )-1;
#line 3603
  clcf->keepalive_requests = (ngx_uint_t )-1;
#line 3604
  clcf->lingering_close = (ngx_uint_t )-1;
#line 3605
  clcf->lingering_time = (ngx_msec_t )-1;
#line 3606
  clcf->lingering_timeout = (ngx_msec_t )-1;
#line 3607
  clcf->resolver_timeout = (ngx_msec_t )-1;
#line 3608
  clcf->reset_timedout_connection = (ngx_flag_t )-1;
#line 3609
  clcf->absolute_redirect = (ngx_flag_t )-1;
#line 3610
  clcf->server_name_in_redirect = (ngx_flag_t )-1;
#line 3611
  clcf->port_in_redirect = (ngx_flag_t )-1;
#line 3612
  clcf->msie_padding = (ngx_flag_t )-1;
#line 3613
  clcf->msie_refresh = (ngx_flag_t )-1;
#line 3614
  clcf->log_not_found = (ngx_flag_t )-1;
#line 3615
  clcf->log_subrequest = (ngx_flag_t )-1;
#line 3616
  clcf->recursive_error_pages = (ngx_flag_t )-1;
#line 3617
  clcf->chunked_transfer_encoding = (ngx_flag_t )-1;
#line 3618
  clcf->etag = (ngx_flag_t )-1;
#line 3619
  clcf->server_tokens = (ngx_uint_t )-1;
#line 3620
  clcf->types_hash_max_size = (ngx_uint_t )-1;
#line 3621
  clcf->types_hash_bucket_size = (ngx_uint_t )-1;
#line 3623
  clcf->open_file_cache = (ngx_open_file_cache_t *)((void *)-1);
#line 3624
  clcf->open_file_cache_valid = (time_t )-1;
#line 3625
  clcf->open_file_cache_min_uses = (ngx_uint_t )-1;
#line 3626
  clcf->open_file_cache_errors = (ngx_flag_t )-1;
#line 3627
  clcf->open_file_cache_events = (ngx_flag_t )-1;
#line 3630
  clcf->gzip_vary = (ngx_flag_t )-1;
#line 3631
  clcf->gzip_http_version = (ngx_uint_t )-1;
#line 3633
  clcf->gzip_disable = (ngx_array_t *)((void *)-1);
#line 3635
  clcf->gzip_disable_msie6 = 3U;
#line 3642
  clcf->disable_symlinks = (ngx_uint_t )-1;
#line 3643
  clcf->disable_symlinks_from = (ngx_http_complex_value_t *)((void *)-1);
#line 3646
  return ((void *)clcf);
}
}
#line 3650 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_core_text_html_type  =    {sizeof("text/html") - 1UL, (u_char *)"text/html"};
#line 3651 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_core_image_gif_type  =    {sizeof("image/gif") - 1UL, (u_char *)"image/gif"};
#line 3652 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_core_image_jpeg_type  =    {sizeof("image/jpeg") - 1UL, (u_char *)"image/jpeg"};
#line 3654 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_hash_key_t ngx_http_core_default_types[4]  = {      {{sizeof("html") - 1UL, (u_char *)"html"}, (ngx_uint_t )0, (void *)(& ngx_http_core_text_html_type)}, 
        {{sizeof("gif") - 1UL,
       (u_char *)"gif"}, (ngx_uint_t )0, (void *)(& ngx_http_core_image_gif_type)}, 
        {{sizeof("jpg") - 1UL,
       (u_char *)"jpg"}, (ngx_uint_t )0, (void *)(& ngx_http_core_image_jpeg_type)}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (void *)0}};
#line 3662 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_core_loc_conf_t *prev ;
  ngx_http_core_loc_conf_t *conf ;
  ngx_uint_t i ;
  ngx_hash_key_t *type ;
  ngx_hash_init_t types_hash ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *tmp___3 ;

  {
#line 3665
  prev = (ngx_http_core_loc_conf_t *)parent;
#line 3666
  conf = (ngx_http_core_loc_conf_t *)child;
#line 3672
  if ((unsigned long )conf->root.data == (unsigned long )((void *)0)) {
#line 3674
    conf->alias = prev->alias;
#line 3675
    conf->root = prev->root;
#line 3676
    conf->root_lengths = prev->root_lengths;
#line 3677
    conf->root_values = prev->root_values;
#line 3679
    if ((unsigned long )prev->root.data == (unsigned long )((void *)0)) {
      {
#line 3680
      conf->root.len = sizeof("html") - 1UL;
#line 3680
      conf->root.data = (u_char *)"html";
#line 3682
      tmp = ngx_conf_full_name(cf->cycle, & conf->root, (ngx_uint_t )0);
      }
#line 3682
      if (tmp != 0L) {
#line 3683
        return ((char *)((void *)-1));
      }
    }
  }
#line 3688
  if ((unsigned long )conf->post_action.data == (unsigned long )((void *)0)) {
#line 3689
    conf->post_action = prev->post_action;
  }
#line 3692
  if (conf->types_hash_max_size == 0xffffffffffffffffUL) {
#line 3692
    if (prev->types_hash_max_size == 0xffffffffffffffffUL) {
#line 3692
      conf->types_hash_max_size = (ngx_uint_t )1024;
    } else {
#line 3692
      conf->types_hash_max_size = prev->types_hash_max_size;
    }
  }
#line 3695
  if (conf->types_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3695
    if (prev->types_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3695
      conf->types_hash_bucket_size = (ngx_uint_t )64;
    } else {
#line 3695
      conf->types_hash_bucket_size = prev->types_hash_bucket_size;
    }
  }
#line 3698
  conf->types_hash_bucket_size = (conf->types_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3706
  if (prev->types) {
#line 3706
    if ((unsigned long )prev->types_hash.buckets == (unsigned long )((void *)0)) {
      {
#line 3708
      types_hash.hash = & prev->types_hash;
#line 3709
      types_hash.key = & ngx_hash_key_lc;
#line 3710
      types_hash.max_size = conf->types_hash_max_size;
#line 3711
      types_hash.bucket_size = conf->types_hash_bucket_size;
#line 3712
      types_hash.name = (char *)"types_hash";
#line 3713
      types_hash.pool = cf->pool;
#line 3714
      types_hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3716
      tmp___0 = ngx_hash_init(& types_hash, (ngx_hash_key_t *)(prev->types)->elts,
                              (prev->types)->nelts);
      }
#line 3716
      if (tmp___0 != 0L) {
#line 3719
        return ((char *)((void *)-1));
      }
    }
  }
#line 3723
  if ((unsigned long )conf->types == (unsigned long )((void *)0)) {
#line 3724
    conf->types = prev->types;
#line 3725
    conf->types_hash = prev->types_hash;
  }
#line 3728
  if ((unsigned long )conf->types == (unsigned long )((void *)0)) {
    {
#line 3729
    conf->types = ngx_array_create(cf->pool, (ngx_uint_t )3, sizeof(ngx_hash_key_t ));
    }
#line 3730
    if ((unsigned long )conf->types == (unsigned long )((void *)0)) {
#line 3731
      return ((char *)((void *)-1));
    }
#line 3734
    i = (ngx_uint_t )0;
    {
#line 3734
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3734
      if (! ngx_http_core_default_types[i].key.len) {
#line 3734
        goto while_break;
      }
      {
#line 3735
      tmp___1 = ngx_array_push(conf->types);
#line 3735
      type = (ngx_hash_key_t *)tmp___1;
      }
#line 3736
      if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 3737
        return ((char *)((void *)-1));
      }
      {
#line 3740
      type->key = ngx_http_core_default_types[i].key;
#line 3741
      type->key_hash = ngx_hash_key_lc(ngx_http_core_default_types[i].key.data, ngx_http_core_default_types[i].key.len);
#line 3744
      type->value = ngx_http_core_default_types[i].value;
#line 3734
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3748
  if ((unsigned long )conf->types_hash.buckets == (unsigned long )((void *)0)) {
    {
#line 3750
    types_hash.hash = & conf->types_hash;
#line 3751
    types_hash.key = & ngx_hash_key_lc;
#line 3752
    types_hash.max_size = conf->types_hash_max_size;
#line 3753
    types_hash.bucket_size = conf->types_hash_bucket_size;
#line 3754
    types_hash.name = (char *)"types_hash";
#line 3755
    types_hash.pool = cf->pool;
#line 3756
    types_hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3758
    tmp___2 = ngx_hash_init(& types_hash, (ngx_hash_key_t *)(conf->types)->elts, (conf->types)->nelts);
    }
#line 3758
    if (tmp___2 != 0L) {
#line 3761
      return ((char *)((void *)-1));
    }
  }
#line 3765
  if ((unsigned long )conf->error_log == (unsigned long )((void *)0)) {
#line 3766
    if (prev->error_log) {
#line 3767
      conf->error_log = prev->error_log;
    } else {
#line 3769
      conf->error_log = & (cf->cycle)->new_log;
    }
  }
#line 3773
  if ((unsigned long )conf->error_pages == (unsigned long )((void *)0)) {
#line 3773
    if (prev->error_pages) {
#line 3774
      conf->error_pages = prev->error_pages;
    }
  }
#line 3777
  if ((unsigned long )conf->default_type.data == (unsigned long )((void *)0)) {
#line 3777
    if (prev->default_type.data) {
#line 3777
      conf->default_type.len = prev->default_type.len;
#line 3777
      conf->default_type.data = prev->default_type.data;
    } else {
#line 3777
      conf->default_type.len = sizeof("text/plain") - 1UL;
#line 3777
      conf->default_type.data = (u_char *)"text/plain";
    }
  }
#line 3780
  if (conf->client_max_body_size == -1L) {
#line 3780
    if (prev->client_max_body_size == -1L) {
#line 3780
      conf->client_max_body_size = (off_t )1048576;
    } else {
#line 3780
      conf->client_max_body_size = prev->client_max_body_size;
    }
  }
#line 3782
  if (conf->client_body_buffer_size == 0xffffffffffffffffUL) {
#line 3782
    if (prev->client_body_buffer_size == 0xffffffffffffffffUL) {
#line 3782
      conf->client_body_buffer_size = 2UL * ngx_pagesize;
    } else {
#line 3782
      conf->client_body_buffer_size = prev->client_body_buffer_size;
    }
  }
#line 3785
  if (conf->client_body_timeout == 0xffffffffffffffffUL) {
#line 3785
    if (prev->client_body_timeout == 0xffffffffffffffffUL) {
#line 3785
      conf->client_body_timeout = (ngx_msec_t )60000;
    } else {
#line 3785
      conf->client_body_timeout = prev->client_body_timeout;
    }
  }
#line 3788
  if (conf->keepalive_disable == 0UL) {
#line 3788
    if (prev->keepalive_disable == 0UL) {
#line 3788
      conf->keepalive_disable = (ngx_uint_t )5;
    } else {
#line 3788
      conf->keepalive_disable = prev->keepalive_disable;
    }
  }
#line 3792
  if (conf->satisfy == 0xffffffffffffffffUL) {
#line 3792
    if (prev->satisfy == 0xffffffffffffffffUL) {
#line 3792
      conf->satisfy = (ngx_uint_t )0;
    } else {
#line 3792
      conf->satisfy = prev->satisfy;
    }
  }
#line 3794
  if (conf->if_modified_since == 0xffffffffffffffffUL) {
#line 3794
    if (prev->if_modified_since == 0xffffffffffffffffUL) {
#line 3794
      conf->if_modified_since = (ngx_uint_t )1;
    } else {
#line 3794
      conf->if_modified_since = prev->if_modified_since;
    }
  }
#line 3796
  if (conf->max_ranges == 0xffffffffffffffffUL) {
#line 3796
    if (prev->max_ranges == 0xffffffffffffffffUL) {
#line 3796
      conf->max_ranges = (ngx_uint_t )((uint32_t )2147483647);
    } else {
#line 3796
      conf->max_ranges = prev->max_ranges;
    }
  }
#line 3798
  if (conf->client_body_in_file_only == 0xffffffffffffffffUL) {
#line 3798
    if (prev->client_body_in_file_only == 0xffffffffffffffffUL) {
#line 3798
      conf->client_body_in_file_only = (ngx_uint_t )0;
    } else {
#line 3798
      conf->client_body_in_file_only = prev->client_body_in_file_only;
    }
  }
#line 3801
  if (conf->client_body_in_single_buffer == -1L) {
#line 3801
    if (prev->client_body_in_single_buffer == -1L) {
#line 3801
      conf->client_body_in_single_buffer = (ngx_flag_t )0;
    } else {
#line 3801
      conf->client_body_in_single_buffer = prev->client_body_in_single_buffer;
    }
  }
#line 3803
  if (conf->internal == -1L) {
#line 3803
    if (prev->internal == -1L) {
#line 3803
      conf->internal = (ngx_flag_t )0;
    } else {
#line 3803
      conf->internal = prev->internal;
    }
  }
#line 3804
  if (conf->sendfile == -1L) {
#line 3804
    if (prev->sendfile == -1L) {
#line 3804
      conf->sendfile = (ngx_flag_t )0;
    } else {
#line 3804
      conf->sendfile = prev->sendfile;
    }
  }
#line 3805
  if (conf->sendfile_max_chunk == 0xffffffffffffffffUL) {
#line 3805
    if (prev->sendfile_max_chunk == 0xffffffffffffffffUL) {
#line 3805
      conf->sendfile_max_chunk = (size_t___0 )0;
    } else {
#line 3805
      conf->sendfile_max_chunk = prev->sendfile_max_chunk;
    }
  }
#line 3807
  if (conf->aio == -1L) {
#line 3807
    if (prev->aio == -1L) {
#line 3807
      conf->aio = (ngx_flag_t )0;
    } else {
#line 3807
      conf->aio = prev->aio;
    }
  }
#line 3808
  if (conf->aio_write == -1L) {
#line 3808
    if (prev->aio_write == -1L) {
#line 3808
      conf->aio_write = (ngx_flag_t )0;
    } else {
#line 3808
      conf->aio_write = prev->aio_write;
    }
  }
#line 3814
  if (conf->read_ahead == 0xffffffffffffffffUL) {
#line 3814
    if (prev->read_ahead == 0xffffffffffffffffUL) {
#line 3814
      conf->read_ahead = (size_t___0 )0;
    } else {
#line 3814
      conf->read_ahead = prev->read_ahead;
    }
  }
#line 3815
  if (conf->directio == -1L) {
#line 3815
    if (prev->directio == -1L) {
#line 3815
      conf->directio = (off_t )9223372036854775807LL;
    } else {
#line 3815
      conf->directio = prev->directio;
    }
  }
#line 3817
  if (conf->directio_alignment == -1L) {
#line 3817
    if (prev->directio_alignment == -1L) {
#line 3817
      conf->directio_alignment = (off_t )512;
    } else {
#line 3817
      conf->directio_alignment = prev->directio_alignment;
    }
  }
#line 3819
  if (conf->tcp_nopush == -1L) {
#line 3819
    if (prev->tcp_nopush == -1L) {
#line 3819
      conf->tcp_nopush = (ngx_flag_t )0;
    } else {
#line 3819
      conf->tcp_nopush = prev->tcp_nopush;
    }
  }
#line 3820
  if (conf->tcp_nodelay == -1L) {
#line 3820
    if (prev->tcp_nodelay == -1L) {
#line 3820
      conf->tcp_nodelay = (ngx_flag_t )1;
    } else {
#line 3820
      conf->tcp_nodelay = prev->tcp_nodelay;
    }
  }
#line 3822
  if (conf->send_timeout == 0xffffffffffffffffUL) {
#line 3822
    if (prev->send_timeout == 0xffffffffffffffffUL) {
#line 3822
      conf->send_timeout = (ngx_msec_t )60000;
    } else {
#line 3822
      conf->send_timeout = prev->send_timeout;
    }
  }
#line 3823
  if (conf->send_lowat == 0xffffffffffffffffUL) {
#line 3823
    if (prev->send_lowat == 0xffffffffffffffffUL) {
#line 3823
      conf->send_lowat = (size_t___0 )0;
    } else {
#line 3823
      conf->send_lowat = prev->send_lowat;
    }
  }
#line 3824
  if (conf->postpone_output == 0xffffffffffffffffUL) {
#line 3824
    if (prev->postpone_output == 0xffffffffffffffffUL) {
#line 3824
      conf->postpone_output = (size_t___0 )1460;
    } else {
#line 3824
      conf->postpone_output = prev->postpone_output;
    }
  }
#line 3826
  if (conf->limit_rate == 0xffffffffffffffffUL) {
#line 3826
    if (prev->limit_rate == 0xffffffffffffffffUL) {
#line 3826
      conf->limit_rate = (size_t___0 )0;
    } else {
#line 3826
      conf->limit_rate = prev->limit_rate;
    }
  }
#line 3827
  if (conf->limit_rate_after == 0xffffffffffffffffUL) {
#line 3827
    if (prev->limit_rate_after == 0xffffffffffffffffUL) {
#line 3827
      conf->limit_rate_after = (size_t___0 )0;
    } else {
#line 3827
      conf->limit_rate_after = prev->limit_rate_after;
    }
  }
#line 3829
  if (conf->keepalive_timeout == 0xffffffffffffffffUL) {
#line 3829
    if (prev->keepalive_timeout == 0xffffffffffffffffUL) {
#line 3829
      conf->keepalive_timeout = (ngx_msec_t )75000;
    } else {
#line 3829
      conf->keepalive_timeout = prev->keepalive_timeout;
    }
  }
#line 3831
  if (conf->keepalive_header == -1L) {
#line 3831
    if (prev->keepalive_header == -1L) {
#line 3831
      conf->keepalive_header = (time_t )0;
    } else {
#line 3831
      conf->keepalive_header = prev->keepalive_header;
    }
  }
#line 3833
  if (conf->keepalive_requests == 0xffffffffffffffffUL) {
#line 3833
    if (prev->keepalive_requests == 0xffffffffffffffffUL) {
#line 3833
      conf->keepalive_requests = (ngx_uint_t )100;
    } else {
#line 3833
      conf->keepalive_requests = prev->keepalive_requests;
    }
  }
#line 3835
  if (conf->lingering_close == 0xffffffffffffffffUL) {
#line 3835
    if (prev->lingering_close == 0xffffffffffffffffUL) {
#line 3835
      conf->lingering_close = (ngx_uint_t )1;
    } else {
#line 3835
      conf->lingering_close = prev->lingering_close;
    }
  }
#line 3837
  if (conf->lingering_time == 0xffffffffffffffffUL) {
#line 3837
    if (prev->lingering_time == 0xffffffffffffffffUL) {
#line 3837
      conf->lingering_time = (ngx_msec_t )30000;
    } else {
#line 3837
      conf->lingering_time = prev->lingering_time;
    }
  }
#line 3839
  if (conf->lingering_timeout == 0xffffffffffffffffUL) {
#line 3839
    if (prev->lingering_timeout == 0xffffffffffffffffUL) {
#line 3839
      conf->lingering_timeout = (ngx_msec_t )5000;
    } else {
#line 3839
      conf->lingering_timeout = prev->lingering_timeout;
    }
  }
#line 3841
  if (conf->resolver_timeout == 0xffffffffffffffffUL) {
#line 3841
    if (prev->resolver_timeout == 0xffffffffffffffffUL) {
#line 3841
      conf->resolver_timeout = (ngx_msec_t )30000;
    } else {
#line 3841
      conf->resolver_timeout = prev->resolver_timeout;
    }
  }
#line 3844
  if ((unsigned long )conf->resolver == (unsigned long )((void *)0)) {
#line 3846
    if ((unsigned long )prev->resolver == (unsigned long )((void *)0)) {
      {
#line 3853
      prev->resolver = ngx_resolver_create(cf, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
      }
#line 3854
      if ((unsigned long )prev->resolver == (unsigned long )((void *)0)) {
#line 3855
        return ((char *)((void *)-1));
      }
    }
#line 3859
    conf->resolver = prev->resolver;
  }
  {
#line 3862
  tmp___3 = ngx_conf_merge_path_value(cf, & conf->client_body_temp_path, prev->client_body_temp_path,
                                      & ngx_http_client_temp_path);
  }
#line 3862
  if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
#line 3867
    return ((char *)((void *)-1));
  }
#line 3870
  if (conf->reset_timedout_connection == -1L) {
#line 3870
    if (prev->reset_timedout_connection == -1L) {
#line 3870
      conf->reset_timedout_connection = (ngx_flag_t )0;
    } else {
#line 3870
      conf->reset_timedout_connection = prev->reset_timedout_connection;
    }
  }
#line 3872
  if (conf->absolute_redirect == -1L) {
#line 3872
    if (prev->absolute_redirect == -1L) {
#line 3872
      conf->absolute_redirect = (ngx_flag_t )1;
    } else {
#line 3872
      conf->absolute_redirect = prev->absolute_redirect;
    }
  }
#line 3874
  if (conf->server_name_in_redirect == -1L) {
#line 3874
    if (prev->server_name_in_redirect == -1L) {
#line 3874
      conf->server_name_in_redirect = (ngx_flag_t )0;
    } else {
#line 3874
      conf->server_name_in_redirect = prev->server_name_in_redirect;
    }
  }
#line 3876
  if (conf->port_in_redirect == -1L) {
#line 3876
    if (prev->port_in_redirect == -1L) {
#line 3876
      conf->port_in_redirect = (ngx_flag_t )1;
    } else {
#line 3876
      conf->port_in_redirect = prev->port_in_redirect;
    }
  }
#line 3877
  if (conf->msie_padding == -1L) {
#line 3877
    if (prev->msie_padding == -1L) {
#line 3877
      conf->msie_padding = (ngx_flag_t )1;
    } else {
#line 3877
      conf->msie_padding = prev->msie_padding;
    }
  }
#line 3878
  if (conf->msie_refresh == -1L) {
#line 3878
    if (prev->msie_refresh == -1L) {
#line 3878
      conf->msie_refresh = (ngx_flag_t )0;
    } else {
#line 3878
      conf->msie_refresh = prev->msie_refresh;
    }
  }
#line 3879
  if (conf->log_not_found == -1L) {
#line 3879
    if (prev->log_not_found == -1L) {
#line 3879
      conf->log_not_found = (ngx_flag_t )1;
    } else {
#line 3879
      conf->log_not_found = prev->log_not_found;
    }
  }
#line 3880
  if (conf->log_subrequest == -1L) {
#line 3880
    if (prev->log_subrequest == -1L) {
#line 3880
      conf->log_subrequest = (ngx_flag_t )0;
    } else {
#line 3880
      conf->log_subrequest = prev->log_subrequest;
    }
  }
#line 3881
  if (conf->recursive_error_pages == -1L) {
#line 3881
    if (prev->recursive_error_pages == -1L) {
#line 3881
      conf->recursive_error_pages = (ngx_flag_t )0;
    } else {
#line 3881
      conf->recursive_error_pages = prev->recursive_error_pages;
    }
  }
#line 3883
  if (conf->chunked_transfer_encoding == -1L) {
#line 3883
    if (prev->chunked_transfer_encoding == -1L) {
#line 3883
      conf->chunked_transfer_encoding = (ngx_flag_t )1;
    } else {
#line 3883
      conf->chunked_transfer_encoding = prev->chunked_transfer_encoding;
    }
  }
#line 3885
  if (conf->etag == -1L) {
#line 3885
    if (prev->etag == -1L) {
#line 3885
      conf->etag = (ngx_flag_t )1;
    } else {
#line 3885
      conf->etag = prev->etag;
    }
  }
#line 3887
  if (conf->server_tokens == 0xffffffffffffffffUL) {
#line 3887
    if (prev->server_tokens == 0xffffffffffffffffUL) {
#line 3887
      conf->server_tokens = (ngx_uint_t )1;
    } else {
#line 3887
      conf->server_tokens = prev->server_tokens;
    }
  }
#line 3890
  if ((unsigned long )conf->open_file_cache == (unsigned long )((void *)-1)) {
#line 3890
    if ((unsigned long )prev->open_file_cache == (unsigned long )((void *)-1)) {
#line 3890
      conf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
    } else {
#line 3890
      conf->open_file_cache = prev->open_file_cache;
    }
  }
#line 3893
  if (conf->open_file_cache_valid == -1L) {
#line 3893
    if (prev->open_file_cache_valid == -1L) {
#line 3893
      conf->open_file_cache_valid = (time_t )60;
    } else {
#line 3893
      conf->open_file_cache_valid = prev->open_file_cache_valid;
    }
  }
#line 3896
  if (conf->open_file_cache_min_uses == 0xffffffffffffffffUL) {
#line 3896
    if (prev->open_file_cache_min_uses == 0xffffffffffffffffUL) {
#line 3896
      conf->open_file_cache_min_uses = (ngx_uint_t )1;
    } else {
#line 3896
      conf->open_file_cache_min_uses = prev->open_file_cache_min_uses;
    }
  }
#line 3899
  if (conf->open_file_cache_errors == -1L) {
#line 3899
    if (prev->open_file_cache_errors == -1L) {
#line 3899
      conf->open_file_cache_errors = (ngx_flag_t )0;
    } else {
#line 3899
      conf->open_file_cache_errors = prev->open_file_cache_errors;
    }
  }
#line 3902
  if (conf->open_file_cache_events == -1L) {
#line 3902
    if (prev->open_file_cache_events == -1L) {
#line 3902
      conf->open_file_cache_events = (ngx_flag_t )0;
    } else {
#line 3902
      conf->open_file_cache_events = prev->open_file_cache_events;
    }
  }
#line 3906
  if (conf->gzip_vary == -1L) {
#line 3906
    if (prev->gzip_vary == -1L) {
#line 3906
      conf->gzip_vary = (ngx_flag_t )0;
    } else {
#line 3906
      conf->gzip_vary = prev->gzip_vary;
    }
  }
#line 3907
  if (conf->gzip_http_version == 0xffffffffffffffffUL) {
#line 3907
    if (prev->gzip_http_version == 0xffffffffffffffffUL) {
#line 3907
      conf->gzip_http_version = (ngx_uint_t )1001;
    } else {
#line 3907
      conf->gzip_http_version = prev->gzip_http_version;
    }
  }
#line 3909
  if (conf->gzip_proxied == 0UL) {
#line 3909
    if (prev->gzip_proxied == 0UL) {
#line 3909
      conf->gzip_proxied = (ngx_uint_t )3;
    } else {
#line 3909
      conf->gzip_proxied = prev->gzip_proxied;
    }
  }
#line 3913
  if ((unsigned long )conf->gzip_disable == (unsigned long )((void *)-1)) {
#line 3913
    if ((unsigned long )prev->gzip_disable == (unsigned long )((void *)-1)) {
#line 3913
      conf->gzip_disable = (ngx_array_t *)((void *)0);
    } else {
#line 3913
      conf->gzip_disable = prev->gzip_disable;
    }
  }
#line 3916
  if (conf->gzip_disable_msie6 == 3U) {
#line 3917
    if (prev->gzip_disable_msie6 == 3U) {
#line 3917
      conf->gzip_disable_msie6 = 0U;
    } else {
#line 3917
      conf->gzip_disable_msie6 = prev->gzip_disable_msie6;
    }
  }
#line 3933
  if (conf->disable_symlinks == 0xffffffffffffffffUL) {
#line 3933
    if (prev->disable_symlinks == 0xffffffffffffffffUL) {
#line 3933
      conf->disable_symlinks = (ngx_uint_t )0;
    } else {
#line 3933
      conf->disable_symlinks = prev->disable_symlinks;
    }
  }
#line 3935
  if ((unsigned long )conf->disable_symlinks_from == (unsigned long )((void *)-1)) {
#line 3935
    if ((unsigned long )prev->disable_symlinks_from == (unsigned long )((void *)-1)) {
#line 3935
      conf->disable_symlinks_from = (ngx_http_complex_value_t *)((void *)0);
    } else {
#line 3935
      conf->disable_symlinks_from = prev->disable_symlinks_from;
    }
  }
#line 3939
  return ((char *)((void *)0));
}
}
#line 3943 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_listen(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  ngx_str_t *value ;
  ngx_str_t size ;
  ngx_url_t u ;
  ngx_uint_t n ;
  ngx_http_listen_opt_t lsopt ;
  ngx_int_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ngx_int_t tmp___3 ;
  int tmp___4 ;
  ngx_int_t tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct sockaddr *sa ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  u_char *p ;
  u_char *end ;
  ngx_str_t s ;
  ngx_int_t tmp___20 ;
  ngx_int_t tmp___21 ;
  ngx_int_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  ngx_int_t tmp___27 ;

  {
  {
#line 3946
  cscf = (ngx_http_core_srv_conf_t *)conf;
#line 3953
  cscf->listen = 1U;
#line 3955
  value = (ngx_str_t *)(cf->args)->elts;
#line 3957
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 3959
  u.url = *(value + 1);
#line 3960
  u.listen = 1U;
#line 3961
  u.default_port = (in_port_t )80;
#line 3963
  tmp = ngx_parse_url(cf->pool, & u);
  }
#line 3963
  if (tmp != 0L) {
#line 3964
    if (u.err) {
      {
#line 3965
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in \"%V\" of the \"listen\" directive",
                         u.err, & u.url);
      }
    }
#line 3970
    return ((char *)((void *)-1));
  }
  {
#line 3973
  memset((void *)(& lsopt), 0, sizeof(ngx_http_listen_opt_t ));
#line 3975
  memcpy((void */* __restrict  */)(& lsopt.sockaddr.sockaddr), (void const   */* __restrict  */)(& u.sockaddr),
         (size_t )u.socklen);
#line 3977
  lsopt.socklen = u.socklen;
#line 3978
  lsopt.backlog = 511;
#line 3979
  lsopt.rcvbuf = -1;
#line 3980
  lsopt.sndbuf = -1;
#line 3985
  lsopt.fastopen = -1;
#line 3987
  lsopt.wildcard = u.wildcard;
#line 3989
  lsopt.ipv6only = 1U;
#line 3992
  ngx_sock_ntop(& lsopt.sockaddr.sockaddr, lsopt.socklen, lsopt.addr, (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)),
                (ngx_uint_t )1);
#line 3995
  n = (ngx_uint_t )2;
  }
  {
#line 3995
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3995
    if (! (n < (cf->args)->nelts)) {
#line 3995
      goto while_break;
    }
    {
#line 3997
    tmp___0 = strcmp((char const   *)(value + n)->data, "default_server");
    }
#line 3997
    if (tmp___0 == 0) {
#line 4000
      lsopt.default_server = 1U;
#line 4001
      goto __Cont;
    } else {
      {
#line 3997
      tmp___1 = strcmp((char const   *)(value + n)->data, "default");
      }
#line 3997
      if (tmp___1 == 0) {
#line 4000
        lsopt.default_server = 1U;
#line 4001
        goto __Cont;
      }
    }
    {
#line 4004
    tmp___2 = strcmp((char const   *)(value + n)->data, "bind");
    }
#line 4004
    if (tmp___2 == 0) {
#line 4005
      lsopt.set = 1U;
#line 4006
      lsopt.bind = 1U;
#line 4007
      goto __Cont;
    }
    {
#line 4027
    tmp___4 = strncmp((char const   *)(value + n)->data, "fastopen=", (size_t )9);
    }
#line 4027
    if (tmp___4 == 0) {
      {
#line 4028
      tmp___3 = ngx_atoi((value + n)->data + 9, (value + n)->len - 9UL);
#line 4028
      lsopt.fastopen = (int )tmp___3;
#line 4029
      lsopt.set = 1U;
#line 4030
      lsopt.bind = 1U;
      }
#line 4032
      if (lsopt.fastopen == -1) {
        {
#line 4033
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid fastopen \"%V\"", value + n);
        }
#line 4035
        return ((char *)((void *)-1));
      }
#line 4038
      goto __Cont;
    }
    {
#line 4042
    tmp___6 = strncmp((char const   *)(value + n)->data, "backlog=", (size_t )8);
    }
#line 4042
    if (tmp___6 == 0) {
      {
#line 4043
      tmp___5 = ngx_atoi((value + n)->data + 8, (value + n)->len - 8UL);
#line 4043
      lsopt.backlog = (int )tmp___5;
#line 4044
      lsopt.set = 1U;
#line 4045
      lsopt.bind = 1U;
      }
#line 4047
      if (lsopt.backlog == -1) {
        {
#line 4048
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid backlog \"%V\"", value + n);
        }
#line 4050
        return ((char *)((void *)-1));
      } else
#line 4047
      if (lsopt.backlog == 0) {
        {
#line 4048
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid backlog \"%V\"", value + n);
        }
#line 4050
        return ((char *)((void *)-1));
      }
#line 4053
      goto __Cont;
    }
    {
#line 4056
    tmp___8 = strncmp((char const   *)(value + n)->data, "rcvbuf=", (size_t )7);
    }
#line 4056
    if (tmp___8 == 0) {
      {
#line 4057
      size.len = (value + n)->len - 7UL;
#line 4058
      size.data = (value + n)->data + 7;
#line 4060
      tmp___7 = ngx_parse_size(& size);
#line 4060
      lsopt.rcvbuf = (int )tmp___7;
#line 4061
      lsopt.set = 1U;
#line 4062
      lsopt.bind = 1U;
      }
#line 4064
      if (lsopt.rcvbuf == -1) {
        {
#line 4065
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid rcvbuf \"%V\"", value + n);
        }
#line 4067
        return ((char *)((void *)-1));
      }
#line 4070
      goto __Cont;
    }
    {
#line 4073
    tmp___10 = strncmp((char const   *)(value + n)->data, "sndbuf=", (size_t )7);
    }
#line 4073
    if (tmp___10 == 0) {
      {
#line 4074
      size.len = (value + n)->len - 7UL;
#line 4075
      size.data = (value + n)->data + 7;
#line 4077
      tmp___9 = ngx_parse_size(& size);
#line 4077
      lsopt.sndbuf = (int )tmp___9;
#line 4078
      lsopt.set = 1U;
#line 4079
      lsopt.bind = 1U;
      }
#line 4081
      if (lsopt.sndbuf == -1) {
        {
#line 4082
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid sndbuf \"%V\"", value + n);
        }
#line 4084
        return ((char *)((void *)-1));
      }
#line 4087
      goto __Cont;
    }
    {
#line 4090
    tmp___11 = strncmp((char const   *)(value + n)->data, "accept_filter=", (size_t )14);
    }
#line 4090
    if (tmp___11 == 0) {
      {
#line 4096
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "accept filters \"%V\" are not supported on this platform, ignored",
                         value + n);
      }
#line 4101
      goto __Cont;
    }
    {
#line 4104
    tmp___12 = strcmp((char const   *)(value + n)->data, "deferred");
    }
#line 4104
    if (tmp___12 == 0) {
#line 4106
      lsopt.deferred_accept = 1U;
#line 4107
      lsopt.set = 1U;
#line 4108
      lsopt.bind = 1U;
#line 4114
      goto __Cont;
    }
    {
#line 4117
    tmp___15 = strncmp((char const   *)(value + n)->data, "ipv6only=o", (size_t )10);
    }
#line 4117
    if (tmp___15 == 0) {
#line 4121
      sa = & lsopt.sockaddr.sockaddr;
#line 4123
      if ((int )sa->sa_family == 10) {
        {
#line 4125
        tmp___14 = strcmp((char const   *)((value + n)->data + 10), "n");
        }
#line 4125
        if (tmp___14 == 0) {
#line 4126
          lsopt.ipv6only = 1U;
        } else {
          {
#line 4128
          tmp___13 = strcmp((char const   *)((value + n)->data + 10), "ff");
          }
#line 4128
          if (tmp___13 == 0) {
#line 4129
            lsopt.ipv6only = 0U;
          } else {
            {
#line 4132
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid ipv6only flags \"%s\"",
                               (value + n)->data + 9);
            }
#line 4135
            return ((char *)((void *)-1));
          }
        }
#line 4138
        lsopt.set = 1U;
#line 4139
        lsopt.bind = 1U;
      } else {
        {
#line 4142
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "ipv6only is not supported on addr \"%s\", ignored",
                           lsopt.addr);
        }
      }
#line 4147
      goto __Cont;
    }
    {
#line 4156
    tmp___16 = strcmp((char const   *)(value + n)->data, "reuseport");
    }
#line 4156
    if (tmp___16 == 0) {
#line 4158
      lsopt.reuseport = 1U;
#line 4159
      lsopt.set = 1U;
#line 4160
      lsopt.bind = 1U;
#line 4166
      goto __Cont;
    }
    {
#line 4169
    tmp___17 = strcmp((char const   *)(value + n)->data, "ssl");
    }
#line 4169
    if (tmp___17 == 0) {
      {
#line 4174
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"ssl\" parameter requires ngx_http_ssl_module");
      }
#line 4177
      return ((char *)((void *)-1));
    }
    {
#line 4181
    tmp___18 = strcmp((char const   *)(value + n)->data, "http2");
    }
#line 4181
    if (tmp___18 == 0) {
      {
#line 4186
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"http2\" parameter requires ngx_http_v2_module");
      }
#line 4189
      return ((char *)((void *)-1));
    }
    {
#line 4193
    tmp___19 = strcmp((char const   *)(value + n)->data, "spdy");
    }
#line 4193
    if (tmp___19 == 0) {
      {
#line 4194
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "invalid parameter \"spdy\": ngx_http_spdy_module was superseded by ngx_http_v2_module");
      }
#line 4198
      goto __Cont;
    }
    {
#line 4201
    tmp___25 = strncmp((char const   *)(value + n)->data, "so_keepalive=", (size_t )13);
    }
#line 4201
    if (tmp___25 == 0) {
      {
#line 4203
      tmp___24 = strcmp((char const   *)((value + n)->data + 13), "on");
      }
#line 4203
      if (tmp___24 == 0) {
#line 4204
        lsopt.so_keepalive = 1U;
      } else {
        {
#line 4206
        tmp___23 = strcmp((char const   *)((value + n)->data + 13), "off");
        }
#line 4206
        if (tmp___23 == 0) {
#line 4207
          lsopt.so_keepalive = 2U;
        } else {
          {
#line 4215
          end = (value + n)->data + (value + n)->len;
#line 4216
          s.data = (value + n)->data + 13;
#line 4218
          p = ngx_strlchr(s.data, end, (u_char )':');
          }
#line 4219
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 4220
            p = end;
          }
#line 4223
          if ((unsigned long )p > (unsigned long )s.data) {
            {
#line 4224
            s.len = (size_t___0 )(p - s.data);
#line 4226
            tmp___20 = ngx_parse_time(& s, (ngx_uint_t )1);
#line 4226
            lsopt.tcp_keepidle = (int )tmp___20;
            }
#line 4227
            if ((time_t )lsopt.tcp_keepidle == -1L) {
#line 4228
              goto invalid_so_keepalive;
            }
          }
#line 4232
          if ((unsigned long )p < (unsigned long )end) {
#line 4232
            s.data = p + 1;
          } else {
#line 4232
            s.data = end;
          }
          {
#line 4234
          p = ngx_strlchr(s.data, end, (u_char )':');
          }
#line 4235
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 4236
            p = end;
          }
#line 4239
          if ((unsigned long )p > (unsigned long )s.data) {
            {
#line 4240
            s.len = (size_t___0 )(p - s.data);
#line 4242
            tmp___21 = ngx_parse_time(& s, (ngx_uint_t )1);
#line 4242
            lsopt.tcp_keepintvl = (int )tmp___21;
            }
#line 4243
            if ((time_t )lsopt.tcp_keepintvl == -1L) {
#line 4244
              goto invalid_so_keepalive;
            }
          }
#line 4248
          if ((unsigned long )p < (unsigned long )end) {
#line 4248
            s.data = p + 1;
          } else {
#line 4248
            s.data = end;
          }
#line 4250
          if ((unsigned long )s.data < (unsigned long )end) {
            {
#line 4251
            s.len = (size_t___0 )(end - s.data);
#line 4253
            tmp___22 = ngx_atoi(s.data, s.len);
#line 4253
            lsopt.tcp_keepcnt = (int )tmp___22;
            }
#line 4254
            if (lsopt.tcp_keepcnt == -1) {
#line 4255
              goto invalid_so_keepalive;
            }
          }
#line 4259
          if (lsopt.tcp_keepidle == 0) {
#line 4259
            if (lsopt.tcp_keepintvl == 0) {
#line 4259
              if (lsopt.tcp_keepcnt == 0) {
#line 4262
                goto invalid_so_keepalive;
              }
            }
          }
#line 4265
          lsopt.so_keepalive = 1U;
        }
      }
#line 4277
      lsopt.set = 1U;
#line 4278
      lsopt.bind = 1U;
#line 4280
      goto __Cont;
      invalid_so_keepalive: 
      {
#line 4285
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid so_keepalive value: \"%s\"",
                         (value + n)->data + 13);
      }
#line 4288
      return ((char *)((void *)-1));
    }
    {
#line 4292
    tmp___26 = strcmp((char const   *)(value + n)->data, "proxy_protocol");
    }
#line 4292
    if (tmp___26 == 0) {
#line 4293
      lsopt.proxy_protocol = 1U;
#line 4294
      goto __Cont;
    }
    {
#line 4297
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + n);
    }
#line 4299
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 3995
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4302
  tmp___27 = ngx_http_add_listen(cf, cscf, & lsopt);
  }
#line 4302
  if (tmp___27 == 0L) {
#line 4303
    return ((char *)((void *)0));
  }
#line 4306
  return ((char *)((void *)-1));
}
}
#line 4310 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_server_name(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  u_char ch ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_server_name_t *sn ;
  char *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  u_char *p ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;

  {
#line 4313
  cscf = (ngx_http_core_srv_conf_t *)conf;
#line 4320
  value = (ngx_str_t *)(cf->args)->elts;
#line 4322
  i = (ngx_uint_t )1;
  {
#line 4322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4322
    if (! (i < (cf->args)->nelts)) {
#line 4322
      goto while_break;
    }
#line 4324
    ch = *((value + i)->data + 0);
#line 4326
    if ((int )ch == 42) {
#line 4326
      if ((value + i)->len < 3UL) {
        {
#line 4329
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "server name \"%V\" is invalid",
                           value + i);
        }
#line 4331
        return ((char *)((void *)-1));
      } else
#line 4326
      if ((int )*((value + i)->data + 1) != 46) {
        {
#line 4329
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "server name \"%V\" is invalid",
                           value + i);
        }
#line 4331
        return ((char *)((void *)-1));
      } else {
#line 4326
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4326
    if ((int )ch == 46) {
#line 4326
      if ((value + i)->len < 2UL) {
        {
#line 4329
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "server name \"%V\" is invalid",
                           value + i);
        }
#line 4331
        return ((char *)((void *)-1));
      }
    }
    {
#line 4334
    tmp = strchr((char const   *)(value + i)->data, '/');
    }
#line 4334
    if (tmp) {
      {
#line 4335
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "server name \"%V\" has suspicious symbols",
                         value + i);
      }
    }
    {
#line 4340
    tmp___0 = ngx_array_push(& cscf->server_names);
#line 4340
    sn = (ngx_http_server_name_t *)tmp___0;
    }
#line 4341
    if ((unsigned long )sn == (unsigned long )((void *)0)) {
#line 4342
      return ((char *)((void *)-1));
    }
    {
#line 4346
    sn->regex = (ngx_http_regex_t *)((void *)0);
#line 4348
    sn->server = cscf;
#line 4350
    tmp___1 = ngx_strcasecmp((value + i)->data, (u_char *)"$hostname");
    }
#line 4350
    if (tmp___1 == 0L) {
#line 4351
      sn->name = (cf->cycle)->hostname;
    } else {
#line 4354
      sn->name = *(value + i);
    }
#line 4357
    if ((int )*((value + i)->data + 0) != 126) {
      {
#line 4358
      ngx_strlow(sn->name.data, sn->name.data, sn->name.len);
      }
#line 4359
      goto __Cont;
    }
#line 4368
    if ((value + i)->len == 1UL) {
      {
#line 4369
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "empty regex in server name \"%V\"",
                         value + i);
      }
#line 4371
      return ((char *)((void *)-1));
    }
    {
#line 4374
    ((value + i)->len) --;
#line 4375
    ((value + i)->data) ++;
#line 4377
    memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 4379
    rc.pattern = *(value + i);
#line 4380
    rc.err.len = (size_t___0 )1024;
#line 4381
    rc.err.data = errstr;
#line 4383
    p = (value + i)->data;
    }
    {
#line 4383
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4383
      if (! ((unsigned long )p < (unsigned long )((value + i)->data + (value + i)->len))) {
#line 4383
        goto while_break___0;
      }
#line 4384
      if ((int )*p >= 65) {
#line 4384
        if ((int )*p <= 90) {
#line 4385
          rc.options = (ngx_int_t )1;
#line 4386
          goto while_break___0;
        }
      }
#line 4383
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4390
    sn->regex = ngx_http_regex_compile(cf, & rc);
    }
#line 4391
    if ((unsigned long )sn->regex == (unsigned long )((void *)0)) {
#line 4392
      return ((char *)((void *)-1));
    }
#line 4395
    sn->name = *(value + i);
#line 4396
    cscf->captures = (unsigned int )(rc.captures > 0);
    __Cont: /* CIL Label */ 
#line 4322
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4407
  return ((char *)((void *)0));
}
}
#line 4411 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_root(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_int_t alias ;
  ngx_uint_t n ;
  ngx_http_script_compile_t sc ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;

  {
#line 4414
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4421
  if (cmd->name.len == sizeof("alias") - 1UL) {
#line 4421
    alias = (ngx_int_t )1;
  } else {
#line 4421
    alias = (ngx_int_t )0;
  }
#line 4423
  if (clcf->root.data) {
#line 4425
    if ((ngx_int_t )(clcf->alias != 0UL) == alias) {
#line 4426
      return ((char *)"is duplicate");
    }
#line 4429
    if (clcf->alias) {
#line 4429
      tmp = "alias";
    } else {
#line 4429
      tmp = "root";
    }
    {
#line 4429
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" directive is duplicate, \"%s\" directive was specified earlier",
                       & cmd->name, tmp);
    }
#line 4434
    return ((char *)((void *)-1));
  }
#line 4437
  if (clcf->named) {
#line 4437
    if (alias) {
      {
#line 4438
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"alias\" directive cannot be used inside the named location");
      }
#line 4442
      return ((char *)((void *)-1));
    }
  }
  {
#line 4445
  value = (ngx_str_t *)(cf->args)->elts;
#line 4447
  tmp___0 = strstr((char const   *)(value + 1)->data, "$document_root");
  }
#line 4447
  if (tmp___0) {
    {
#line 4450
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $document_root variable cannot be used in the \"%V\" directive",
                       & cmd->name);
    }
#line 4455
    return ((char *)((void *)-1));
  } else {
    {
#line 4447
    tmp___1 = strstr((char const   *)(value + 1)->data, "${document_root}");
    }
#line 4447
    if (tmp___1) {
      {
#line 4450
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $document_root variable cannot be used in the \"%V\" directive",
                         & cmd->name);
      }
#line 4455
      return ((char *)((void *)-1));
    }
  }
  {
#line 4458
  tmp___2 = strstr((char const   *)(value + 1)->data, "$realpath_root");
  }
#line 4458
  if (tmp___2) {
    {
#line 4461
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $realpath_root variable cannot be used in the \"%V\" directive",
                       & cmd->name);
    }
#line 4466
    return ((char *)((void *)-1));
  } else {
    {
#line 4458
    tmp___3 = strstr((char const   *)(value + 1)->data, "${realpath_root}");
    }
#line 4458
    if (tmp___3) {
      {
#line 4461
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $realpath_root variable cannot be used in the \"%V\" directive",
                         & cmd->name);
      }
#line 4466
      return ((char *)((void *)-1));
    }
  }
#line 4469
  if (alias) {
#line 4469
    clcf->alias = clcf->name.len;
  } else {
#line 4469
    clcf->alias = (size_t___0 )0;
  }
#line 4470
  clcf->root = *(value + 1);
#line 4472
  if (! alias) {
#line 4472
    if (clcf->root.len > 0UL) {
#line 4472
      if ((int )*(clcf->root.data + (clcf->root.len - 1UL)) == 47) {
#line 4475
        (clcf->root.len) --;
      }
    }
  }
#line 4478
  if ((int )*(clcf->root.data + 0) != 36) {
    {
#line 4479
    tmp___4 = ngx_conf_full_name(cf->cycle, & clcf->root, (ngx_uint_t )0);
    }
#line 4479
    if (tmp___4 != 0L) {
#line 4480
      return ((char *)((void *)-1));
    }
  }
  {
#line 4484
  n = ngx_http_script_variables_count(& clcf->root);
#line 4486
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 4487
  sc.variables = n;
  }
#line 4490
  if (alias) {
#line 4490
    if (clcf->regex) {
#line 4491
      clcf->alias = (size_t___0 )9223372036854775807LL;
#line 4492
      n = (ngx_uint_t )1;
    }
  }
#line 4496
  if (n) {
    {
#line 4497
    sc.cf = cf;
#line 4498
    sc.source = & clcf->root;
#line 4499
    sc.lengths = & clcf->root_lengths;
#line 4500
    sc.values = & clcf->root_values;
#line 4501
    sc.complete_lengths = 1U;
#line 4502
    sc.complete_values = 1U;
#line 4504
    tmp___5 = ngx_http_script_compile(& sc);
    }
#line 4504
    if (tmp___5 != 0L) {
#line 4505
      return ((char *)((void *)-1));
    }
  }
#line 4509
  return ((char *)((void *)0));
}
}
#line 4513 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static ngx_http_method_name_t ngx_methods_names[15]  = 
#line 4513
  {      {(u_char *)"GET", (uint32_t )(~ 2)}, 
        {(u_char *)"HEAD", (uint32_t )(~ 4)}, 
        {(u_char *)"POST", (uint32_t )(~ 8)}, 
        {(u_char *)"PUT", (uint32_t )(~ 16)}, 
        {(u_char *)"DELETE", (uint32_t )(~ 32)}, 
        {(u_char *)"MKCOL", (uint32_t )(~ 64)}, 
        {(u_char *)"COPY", (uint32_t )(~ 128)}, 
        {(u_char *)"MOVE", (uint32_t )(~ 256)}, 
        {(u_char *)"OPTIONS", (uint32_t )(~ 512)}, 
        {(u_char *)"PROPFIND", (uint32_t )(~ 1024)}, 
        {(u_char *)"PROPPATCH", (uint32_t )(~ 2048)}, 
        {(u_char *)"LOCK", (uint32_t )(~ 4096)}, 
        {(u_char *)"UNLOCK", (uint32_t )(~ 8192)}, 
        {(u_char *)"PATCH", (uint32_t )(~ 16384)}, 
        {(u_char *)((void *)0), (uint32_t )0}};
#line 4532 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_limit_except(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *pclcf ;
  char *rv ;
  void *mconf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *pctx ;
  ngx_http_method_name_t *name ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 4535
  pclcf = (ngx_http_core_loc_conf_t *)conf;
#line 4547
  if (pclcf->limit_except) {
#line 4548
    return ((char *)"is duplicate");
  }
#line 4551
  pclcf->limit_except = 4294967295U;
#line 4553
  value = (ngx_str_t *)(cf->args)->elts;
#line 4555
  i = (ngx_uint_t )1;
  {
#line 4555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4555
    if (! (i < (cf->args)->nelts)) {
#line 4555
      goto while_break;
    }
#line 4556
    name = ngx_methods_names;
    {
#line 4556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4556
      if (! name->name) {
#line 4556
        goto while_break___0;
      }
      {
#line 4558
      tmp = ngx_strcasecmp((value + i)->data, name->name);
      }
#line 4558
      if (tmp == 0L) {
#line 4559
        pclcf->limit_except &= name->method;
#line 4560
        goto next;
      }
#line 4556
      name ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4564
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid method \"%V\"", value + i);
    }
#line 4566
    return ((char *)((void *)-1));
    next: 
#line 4569
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 4555
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4572
  if (! (pclcf->limit_except & 2U)) {
#line 4573
    pclcf->limit_except &= 4294967291U;
  }
  {
#line 4576
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 4576
  ctx = (ngx_http_conf_ctx_t *)tmp___0;
  }
#line 4577
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 4578
    return ((char *)((void *)-1));
  }
  {
#line 4581
  pctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 4582
  ctx->main_conf = pctx->main_conf;
#line 4583
  ctx->srv_conf = pctx->srv_conf;
#line 4585
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 4585
  ctx->loc_conf = (void **)tmp___1;
  }
#line 4586
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 4587
    return ((char *)((void *)-1));
  }
#line 4590
  i = (ngx_uint_t )0;
  {
#line 4590
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4590
    if (! *((cf->cycle)->modules + i)) {
#line 4590
      goto while_break___1;
    }
#line 4591
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 4592
      goto __Cont___0;
    }
#line 4595
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 4597
    if (module->create_loc_conf) {
      {
#line 4599
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 4600
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 4601
        return ((char *)((void *)-1));
      }
#line 4604
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
    __Cont___0: /* CIL Label */ 
#line 4590
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4609
  clcf = (ngx_http_core_loc_conf_t *)*(ctx->loc_conf + ngx_http_core_module.ctx_index);
#line 4610
  pclcf->limit_except_loc_conf = ctx->loc_conf;
#line 4611
  clcf->loc_conf = ctx->loc_conf;
#line 4612
  clcf->name = pclcf->name;
#line 4613
  clcf->noname = 1U;
#line 4614
  clcf->lmt_excpt = 1U;
#line 4616
  tmp___2 = ngx_http_add_location(cf, & pclcf->locations, clcf);
  }
#line 4616
  if (tmp___2 != 0L) {
#line 4617
    return ((char *)((void *)-1));
  }
  {
#line 4620
  save = *cf;
#line 4621
  cf->ctx = (void *)ctx;
#line 4622
  cf->cmd_type = (ngx_uint_t )2147483648U;
#line 4624
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 4626
  *cf = save;
  }
#line 4628
  return (rv);
}
}
#line 4632 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_set_aio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4635
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4639
  if (clcf->aio != -1L) {
#line 4640
    return ((char *)"is duplicate");
  }
  {
#line 4648
  value = (ngx_str_t *)(cf->args)->elts;
#line 4650
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4650
  if (tmp == 0) {
#line 4651
    clcf->aio = (ngx_flag_t )0;
#line 4652
    return ((char *)((void *)0));
  }
  {
#line 4655
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 4655
  if (tmp___0 == 0) {
    {
#line 4660
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"aio on\" is unsupported on this platform");
    }
#line 4663
    return ((char *)((void *)-1));
  }
  {
#line 4680
  tmp___1 = strncmp((char const   *)(value + 1)->data, "threads", (size_t )7);
  }
#line 4680
  if (tmp___1 == 0) {
#line 4680
    if ((value + 1)->len == 7UL) {
      {
#line 4731
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"aio threads\" is unsupported on this platform");
      }
#line 4734
      return ((char *)((void *)-1));
    } else
#line 4680
    if ((int )*((value + 1)->data + 7) == 61) {
      {
#line 4731
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"aio threads\" is unsupported on this platform");
      }
#line 4734
      return ((char *)((void *)-1));
    }
  }
#line 4738
  return ((char *)"invalid value");
}
}
#line 4742 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_directio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  int tmp ;

  {
#line 4745
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4749
  if (clcf->directio != -1L) {
#line 4750
    return ((char *)"is duplicate");
  }
  {
#line 4753
  value = (ngx_str_t *)(cf->args)->elts;
#line 4755
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4755
  if (tmp == 0) {
#line 4756
    clcf->directio = (off_t )9223372036854775807LL;
#line 4757
    return ((char *)((void *)0));
  }
  {
#line 4760
  clcf->directio = ngx_parse_offset(value + 1);
  }
#line 4761
  if (clcf->directio == -1L) {
#line 4762
    return ((char *)"invalid value");
  }
#line 4765
  return ((char *)((void *)0));
}
}
#line 4769 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_error_page(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  u_char *p ;
  ngx_int_t overwrite ;
  ngx_str_t *value ;
  ngx_str_t uri___0 ;
  ngx_str_t args___0 ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_err_page_t *err ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
#line 4772
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4782
  if ((unsigned long )clcf->error_pages == (unsigned long )((void *)0)) {
    {
#line 4783
    clcf->error_pages = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_err_page_t ));
    }
#line 4785
    if ((unsigned long )clcf->error_pages == (unsigned long )((void *)0)) {
#line 4786
      return ((char *)((void *)-1));
    }
  }
#line 4790
  value = (ngx_str_t *)(cf->args)->elts;
#line 4792
  i = (cf->args)->nelts - 2UL;
#line 4794
  if ((int )*((value + i)->data + 0) == 61) {
#line 4795
    if (i == 1UL) {
      {
#line 4796
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
      }
#line 4798
      return ((char *)((void *)-1));
    }
#line 4801
    if ((value + i)->len > 1UL) {
      {
#line 4802
      overwrite = ngx_atoi((value + i)->data + 1, (value + i)->len - 1UL);
      }
#line 4804
      if (overwrite == -1L) {
        {
#line 4805
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
        }
#line 4807
        return ((char *)((void *)-1));
      }
    } else {
#line 4811
      overwrite = (ngx_int_t )0;
    }
#line 4814
    n = (ngx_uint_t )2;
  } else {
#line 4817
    overwrite = (ngx_int_t )-1;
#line 4818
    n = (ngx_uint_t )1;
  }
  {
#line 4821
  uri___0 = *(value + ((cf->args)->nelts - 1UL));
#line 4823
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4825
  ccv.cf = cf;
#line 4826
  ccv.value = & uri___0;
#line 4827
  ccv.complex_value = & cv;
#line 4829
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 4829
  if (tmp != 0L) {
#line 4830
    return ((char *)((void *)-1));
  }
#line 4833
  args___0.len = (size_t___0 )0;
#line 4833
  args___0.data = (u_char *)((void *)0);
#line 4835
  if ((unsigned long )cv.lengths == (unsigned long )((void *)0)) {
#line 4835
    if (uri___0.len) {
#line 4835
      if ((int )*(uri___0.data + 0) == 47) {
        {
#line 4836
        tmp___0 = strchr((char const   *)uri___0.data, '?');
#line 4836
        p = (u_char *)tmp___0;
        }
#line 4838
        if (p) {
#line 4839
          cv.value.len = (size_t___0 )(p - uri___0.data);
#line 4840
          cv.value.data = uri___0.data;
#line 4841
          p ++;
#line 4842
          args___0.len = (size_t___0 )((uri___0.data + uri___0.len) - p);
#line 4843
          args___0.data = p;
        }
      }
    }
  }
#line 4847
  i = (ngx_uint_t )1;
  {
#line 4847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4847
    if (! (i < (cf->args)->nelts - n)) {
#line 4847
      goto while_break;
    }
    {
#line 4848
    tmp___1 = ngx_array_push(clcf->error_pages);
#line 4848
    err = (ngx_http_err_page_t *)tmp___1;
    }
#line 4849
    if ((unsigned long )err == (unsigned long )((void *)0)) {
#line 4850
      return ((char *)((void *)-1));
    }
    {
#line 4853
    err->status = ngx_atoi((value + i)->data, (value + i)->len);
    }
#line 4855
    if (err->status == -1L) {
      {
#line 4856
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
      }
#line 4858
      return ((char *)((void *)-1));
    } else
#line 4855
    if (err->status == 499L) {
      {
#line 4856
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
      }
#line 4858
      return ((char *)((void *)-1));
    }
#line 4861
    if (err->status < 300L) {
      {
#line 4862
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value \"%V\" must be between 300 and 599",
                         value + i);
      }
#line 4865
      return ((char *)((void *)-1));
    } else
#line 4861
    if (err->status > 599L) {
      {
#line 4862
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value \"%V\" must be between 300 and 599",
                         value + i);
      }
#line 4865
      return ((char *)((void *)-1));
    }
#line 4868
    err->overwrite = overwrite;
#line 4870
    if (overwrite == -1L) {
      {
#line 4874
      if (err->status == 496L) {
#line 4874
        goto case_496;
      }
#line 4874
      if (err->status == 495L) {
#line 4874
        goto case_496;
      }
#line 4874
      if (err->status == 497L) {
#line 4874
        goto case_496;
      }
#line 4871
      goto switch_break;
      case_496: /* CIL Label */ 
      case_495: /* CIL Label */ 
      case_497: /* CIL Label */ 
#line 4875
      err->overwrite = (ngx_int_t )400;
      switch_break: /* CIL Label */ ;
      }
    }
#line 4879
    err->value = cv;
#line 4880
    err->args = args___0;
#line 4847
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4883
  return ((char *)((void *)0));
}
}
#line 4887 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_try_files(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_int_t code ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_try_file_t *tf ;
  ngx_http_script_compile_t sc ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 4890
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4899
  if (clcf->try_files) {
#line 4900
    return ((char *)"is duplicate");
  }
  {
#line 4903
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 4905
  cmcf->try_files = (ngx_uint_t )1;
#line 4907
  tmp = ngx_pcalloc(cf->pool, (cf->args)->nelts * sizeof(ngx_http_try_file_t ));
#line 4907
  tf = (ngx_http_try_file_t *)tmp;
  }
#line 4908
  if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 4909
    return ((char *)((void *)-1));
  }
#line 4912
  clcf->try_files = tf;
#line 4914
  value = (ngx_str_t *)(cf->args)->elts;
#line 4916
  i = (ngx_uint_t )0;
  {
#line 4916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4916
    if (! (i < (cf->args)->nelts - 1UL)) {
#line 4916
      goto while_break;
    }
#line 4918
    (tf + i)->name = *(value + (i + 1UL));
#line 4920
    if ((tf + i)->name.len > 0UL) {
#line 4920
      if ((int )*((tf + i)->name.data + ((tf + i)->name.len - 1UL)) == 47) {
#line 4920
        if (i + 2UL < (cf->args)->nelts) {
#line 4924
          (tf + i)->test_dir = 1U;
#line 4925
          ((tf + i)->name.len) --;
#line 4926
          *((tf + i)->name.data + (tf + i)->name.len) = (u_char )'\000';
        }
      }
    }
    {
#line 4929
    n = ngx_http_script_variables_count(& (tf + i)->name);
    }
#line 4931
    if (n) {
      {
#line 4932
      memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 4934
      sc.cf = cf;
#line 4935
      sc.source = & (tf + i)->name;
#line 4936
      sc.lengths = & (tf + i)->lengths;
#line 4937
      sc.values = & (tf + i)->values;
#line 4938
      sc.variables = n;
#line 4939
      sc.complete_lengths = 1U;
#line 4940
      sc.complete_values = 1U;
#line 4942
      tmp___0 = ngx_http_script_compile(& sc);
      }
#line 4942
      if (tmp___0 != 0L) {
#line 4943
        return ((char *)((void *)-1));
      }
    } else {
#line 4948
      ((tf + i)->name.len) ++;
    }
#line 4916
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4952
  if ((int )*((tf + (i - 1UL))->name.data + 0) == 61) {
    {
#line 4954
    code = ngx_atoi((tf + (i - 1UL))->name.data + 1, (tf + (i - 1UL))->name.len - 2UL);
    }
#line 4956
    if (code == -1L) {
      {
#line 4957
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid code \"%*s\"", (tf + (i - 1UL))->name.len - 1UL,
                         (tf + (i - 1UL))->name.data);
      }
#line 4960
      return ((char *)((void *)-1));
    } else
#line 4956
    if (code > 999L) {
      {
#line 4957
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid code \"%*s\"", (tf + (i - 1UL))->name.len - 1UL,
                         (tf + (i - 1UL))->name.data);
      }
#line 4960
      return ((char *)((void *)-1));
    }
#line 4963
    (tf + i)->code = (unsigned int )code;
  }
#line 4966
  return ((char *)((void *)0));
}
}
#line 4970 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  time_t inactive ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_int_t max ;
  ngx_uint_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4973
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4980
  if ((unsigned long )clcf->open_file_cache != (unsigned long )((void *)-1)) {
#line 4981
    return ((char *)"is duplicate");
  }
#line 4984
  value = (ngx_str_t *)(cf->args)->elts;
#line 4986
  max = (ngx_int_t )0;
#line 4987
  inactive = (time_t )60;
#line 4989
  i = (ngx_uint_t )1;
  {
#line 4989
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4989
    if (! (i < (cf->args)->nelts)) {
#line 4989
      goto while_break;
    }
    {
#line 4991
    tmp = strncmp((char const   *)(value + i)->data, "max=", (size_t )4);
    }
#line 4991
    if (tmp == 0) {
      {
#line 4993
      max = ngx_atoi((value + i)->data + 4, (value + i)->len - 4UL);
      }
#line 4994
      if (max <= 0L) {
#line 4995
        goto failed;
      }
#line 4998
      goto __Cont;
    }
    {
#line 5001
    tmp___0 = strncmp((char const   *)(value + i)->data, "inactive=", (size_t )9);
    }
#line 5001
    if (tmp___0 == 0) {
      {
#line 5003
      s.len = (value + i)->len - 9UL;
#line 5004
      s.data = (value + i)->data + 9;
#line 5006
      inactive = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 5007
      if (inactive == -1L) {
#line 5008
        goto failed;
      }
#line 5011
      goto __Cont;
    }
    {
#line 5014
    tmp___1 = strcmp((char const   *)(value + i)->data, "off");
    }
#line 5014
    if (tmp___1 == 0) {
#line 5016
      clcf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
#line 5018
      goto __Cont;
    }
    failed: 
    {
#line 5023
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid \"open_file_cache\" parameter \"%V\"",
                       value + i);
    }
#line 5026
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 4989
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5029
  if ((unsigned long )clcf->open_file_cache == (unsigned long )((void *)0)) {
#line 5030
    return ((char *)((void *)0));
  }
#line 5033
  if (max == 0L) {
    {
#line 5034
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"open_file_cache\" must have the \"max\" parameter");
    }
#line 5036
    return ((char *)((void *)-1));
  }
  {
#line 5039
  clcf->open_file_cache = ngx_open_file_cache_init(cf->pool, (ngx_uint_t )max, inactive);
  }
#line 5040
  if (clcf->open_file_cache) {
#line 5041
    return ((char *)((void *)0));
  }
#line 5044
  return ((char *)((void *)-1));
}
}
#line 5048 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;

  {
  {
#line 5051
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 5053
  tmp = ngx_log_set_log(cf, & clcf->error_log);
  }
#line 5053
  return (tmp);
}
}
#line 5057 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_int_t tmp ;

  {
#line 5060
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 5064
  if (clcf->keepalive_timeout != 0xffffffffffffffffUL) {
#line 5065
    return ((char *)"is duplicate");
  }
  {
#line 5068
  value = (ngx_str_t *)(cf->args)->elts;
#line 5070
  tmp = ngx_parse_time(value + 1, (ngx_uint_t )0);
#line 5070
  clcf->keepalive_timeout = (ngx_msec_t )tmp;
  }
#line 5072
  if (clcf->keepalive_timeout == 0xffffffffffffffffUL) {
#line 5073
    return ((char *)"invalid value");
  }
#line 5076
  if ((cf->args)->nelts == 2UL) {
#line 5077
    return ((char *)((void *)0));
  }
  {
#line 5080
  clcf->keepalive_header = ngx_parse_time(value + 2, (ngx_uint_t )1);
  }
#line 5082
  if (clcf->keepalive_header == -1L) {
#line 5083
    return ((char *)"invalid value");
  }
#line 5086
  return ((char *)((void *)0));
}
}
#line 5090 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_internal(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 5093
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 5095
  if (clcf->internal != -1L) {
#line 5096
    return ((char *)"is duplicate");
  }
#line 5099
  clcf->internal = (ngx_flag_t )1;
#line 5101
  return ((char *)((void *)0));
}
}
#line 5105 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_resolver(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;

  {
#line 5108
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 5112
  if (clcf->resolver) {
#line 5113
    return ((char *)"is duplicate");
  }
  {
#line 5116
  value = (ngx_str_t *)(cf->args)->elts;
#line 5118
  clcf->resolver = ngx_resolver_create(cf, value + 1, (cf->args)->nelts - 1UL);
  }
#line 5119
  if ((unsigned long )clcf->resolver == (unsigned long )((void *)0)) {
#line 5120
    return ((char *)((void *)-1));
  }
#line 5123
  return ((char *)((void *)0));
}
}
#line 5129 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_gzip_disable(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_regex_elt_t *re ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 5132
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 5142
  if ((unsigned long )clcf->gzip_disable == (unsigned long )((void *)-1)) {
    {
#line 5143
    clcf->gzip_disable = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_regex_elt_t ));
    }
#line 5145
    if ((unsigned long )clcf->gzip_disable == (unsigned long )((void *)0)) {
#line 5146
      return ((char *)((void *)-1));
    }
  }
  {
#line 5150
  value = (ngx_str_t *)(cf->args)->elts;
#line 5152
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 5154
  rc.pool = cf->pool;
#line 5155
  rc.err.len = (size_t___0 )1024;
#line 5156
  rc.err.data = errstr;
#line 5158
  i = (ngx_uint_t )1;
  }
  {
#line 5158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5158
    if (! (i < (cf->args)->nelts)) {
#line 5158
      goto while_break;
    }
    {
#line 5160
    tmp = strcmp((char const   *)(value + i)->data, "msie6");
    }
#line 5160
    if (tmp == 0) {
#line 5161
      clcf->gzip_disable_msie6 = 1U;
#line 5162
      goto __Cont;
    }
    {
#line 5174
    tmp___0 = ngx_array_push(clcf->gzip_disable);
#line 5174
    re = (ngx_regex_elt_t *)tmp___0;
    }
#line 5175
    if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 5176
      return ((char *)((void *)-1));
    }
    {
#line 5179
    rc.pattern = *(value + i);
#line 5180
    rc.options = (ngx_int_t )1;
#line 5182
    tmp___1 = ngx_regex_compile(& rc);
    }
#line 5182
    if (tmp___1 != 0L) {
      {
#line 5183
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc.err);
      }
#line 5184
      return ((char *)((void *)-1));
    }
#line 5187
    re->regex = rc.regex;
#line 5188
    re->name = (value + i)->data;
    __Cont: /* CIL Label */ 
#line 5158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5191
  return ((char *)((void *)0));
}
}
#line 5231 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_disable_symlinks(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  int tmp___4 ;

  {
#line 5234
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 5240
  if (clcf->disable_symlinks != 0xffffffffffffffffUL) {
#line 5241
    return ((char *)"is duplicate");
  }
#line 5244
  value = (ngx_str_t *)(cf->args)->elts;
#line 5246
  i = (ngx_uint_t )1;
  {
#line 5246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5246
    if (! (i < (cf->args)->nelts)) {
#line 5246
      goto while_break;
    }
    {
#line 5248
    tmp = strcmp((char const   *)(value + i)->data, "off");
    }
#line 5248
    if (tmp == 0) {
#line 5249
      clcf->disable_symlinks = (ngx_uint_t )0;
#line 5250
      goto __Cont;
    }
    {
#line 5253
    tmp___0 = strcmp((char const   *)(value + i)->data, "if_not_owner");
    }
#line 5253
    if (tmp___0 == 0) {
#line 5254
      clcf->disable_symlinks = (ngx_uint_t )2;
#line 5255
      goto __Cont;
    }
    {
#line 5258
    tmp___1 = strcmp((char const   *)(value + i)->data, "on");
    }
#line 5258
    if (tmp___1 == 0) {
#line 5259
      clcf->disable_symlinks = (ngx_uint_t )1;
#line 5260
      goto __Cont;
    }
    {
#line 5263
    tmp___4 = strncmp((char const   *)(value + i)->data, "from=", (size_t )5);
    }
#line 5263
    if (tmp___4 == 0) {
      {
#line 5264
      (value + i)->len -= 5UL;
#line 5265
      (value + i)->data += 5;
#line 5267
      memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 5269
      ccv.cf = cf;
#line 5270
      ccv.value = value + i;
#line 5271
      tmp___2 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 5271
      ccv.complex_value = (ngx_http_complex_value_t *)tmp___2;
      }
#line 5273
      if ((unsigned long )ccv.complex_value == (unsigned long )((void *)0)) {
#line 5274
        return ((char *)((void *)-1));
      }
      {
#line 5277
      tmp___3 = ngx_http_compile_complex_value(& ccv);
      }
#line 5277
      if (tmp___3 != 0L) {
#line 5278
        return ((char *)((void *)-1));
      }
#line 5281
      clcf->disable_symlinks_from = ccv.complex_value;
#line 5283
      goto __Cont;
    }
    {
#line 5286
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 5288
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 5246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5291
  if (clcf->disable_symlinks == 0xffffffffffffffffUL) {
    {
#line 5292
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"off\", \"on\" or \"if_not_owner\" parameter",
                       & cmd->name);
    }
#line 5296
    return ((char *)((void *)-1));
  }
#line 5299
  if ((cf->args)->nelts == 2UL) {
#line 5300
    clcf->disable_symlinks_from = (ngx_http_complex_value_t *)((void *)0);
#line 5301
    return ((char *)((void *)0));
  }
#line 5304
  if ((unsigned long )clcf->disable_symlinks_from == (unsigned long )((void *)-1)) {
    {
#line 5305
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate parameters \"%V %V\"", value + 1,
                       value + 2);
    }
#line 5308
    return ((char *)((void *)-1));
  }
#line 5311
  if (clcf->disable_symlinks == 0UL) {
    {
#line 5312
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"from=\" cannot be used with \"off\" parameter");
    }
#line 5314
    return ((char *)((void *)-1));
  }
#line 5317
  return ((char *)((void *)0));
}
}
#line 5323 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_lowat_check(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ssize_t *np ;

  {
  {
#line 5339
  np = (ssize_t *)data;
#line 5341
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"send_lowat\" is not supported, ignored");
#line 5344
  *np = (ssize_t )0;
  }
#line 5348
  return ((char *)((void *)0));
}
}
#line 5352 "/tmp/nginx-1.13.2/src/http/ngx_http_core_module.c"
static char *ngx_http_core_pool_size(ngx_conf_t *cf , void *post , void *data ) 
{ 
  size_t___0 *sp ;

  {
#line 5355
  sp = (size_t___0 *)data;
#line 5357
  if (*sp < (((sizeof(ngx_pool_t ) + 2UL * sizeof(ngx_pool_large_t )) + 15UL) & 0xfffffffffffffff0UL)) {
    {
#line 5358
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the pool size must be no less than %uz",
                       ((sizeof(ngx_pool_t ) + 2UL * sizeof(ngx_pool_large_t )) + 15UL) & 0xfffffffffffffff0UL);
    }
#line 5361
    return ((char *)((void *)-1));
  }
#line 5364
  if (*sp % 16UL) {
    {
#line 5365
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the pool size must be a multiple of %uz",
                       16);
    }
#line 5368
    return ((char *)((void *)-1));
  }
#line 5371
  return ((char *)((void *)0));
}
}
#line 225 "src/core/ngx_string.h"
void ngx_sort(void *base , size_t___0 n , size_t___0 size , ngx_int_t (*cmp)(void const   * ,
                                                                             void const   * ) ) ;
#line 107 "src/core/ngx_queue.h"
ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue ) ;
#line 108
void ngx_queue_sort(ngx_queue_t *queue , ngx_int_t (*cmp)(ngx_queue_t const   * ,
                                                          ngx_queue_t const   * ) ) ;
#line 123 "src/core/ngx_inet.h"
ngx_int_t ngx_cmp_sockaddr(struct sockaddr *sa1 , socklen_t slen1 , struct sockaddr *sa2 ,
                           socklen_t slen2 , ngx_uint_t cmp_port ) ;
#line 270 "src/core/ngx_module.h"
ngx_int_t ngx_count_modules(ngx_cycle_t *cycle , ngx_uint_t type ) ;
#line 206 "src/core/ngx_connection.h"
ngx_listening_t *ngx_create_listening(ngx_conf_t *cf , struct sockaddr *sockaddr ,
                                      socklen_t socklen ) ;
#line 208
ngx_int_t ngx_clone_listening(ngx_conf_t *cf , ngx_listening_t *ls ) ;
#line 511 "src/event/ngx_event.h"
u_char *ngx_accept_log_error(ngx_log_t *log , u_char *buf , size_t___0 len ) ;
#line 544 "src/http/ngx_http_core_module.h"
ngx_uint_t ngx_http_max_module  ;
#line 158 "src/http/ngx_http.h"
ngx_int_t ngx_http_set_default_types(ngx_conf_t *cf , ngx_array_t **types , ngx_str_t *default_type ) ;
#line 171 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_header_filter)(ngx_http_request_t *r )  ;
#line 172 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 173 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_request_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 13 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static char *ngx_http_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 14
static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) ;
#line 16
static ngx_int_t ngx_http_init_headers_in_hash(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) ;
#line 18
static ngx_int_t ngx_http_init_phase_handlers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) ;
#line 21
static ngx_int_t ngx_http_add_addresses(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                        ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) ;
#line 24
static ngx_int_t ngx_http_add_address(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                      ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) ;
#line 27
static ngx_int_t ngx_http_add_server(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                     ngx_http_conf_addr_t *addr ) ;
#line 30
static char *ngx_http_merge_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                    ngx_http_module_t *module , ngx_uint_t ctx_index ) ;
#line 33
static char *ngx_http_merge_locations(ngx_conf_t *cf , ngx_queue_t *locations , void **loc_conf ,
                                      ngx_http_module_t *module , ngx_uint_t ctx_index ) ;
#line 36
static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                         ngx_http_core_loc_conf_t *pclcf ) ;
#line 38
static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf , ngx_http_core_loc_conf_t *pclcf ) ;
#line 40
static ngx_int_t ngx_http_cmp_locations(ngx_queue_t const   *one , ngx_queue_t const   *two ) ;
#line 42
static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf , ngx_queue_t *locations ) ;
#line 44
static void ngx_http_create_locations_list(ngx_queue_t *locations , ngx_queue_t *q ) ;
#line 46
static ngx_http_location_tree_node_t *ngx_http_create_locations_tree(ngx_conf_t *cf ,
                                                                     ngx_queue_t *locations ,
                                                                     size_t___0 prefix ) ;
#line 50
static ngx_int_t ngx_http_optimize_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                           ngx_array_t *ports ) ;
#line 52
static ngx_int_t ngx_http_server_names(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                       ngx_http_conf_addr_t *addr ) ;
#line 54
static ngx_int_t ngx_http_cmp_conf_addrs(void const   *one , void const   *two ) ;
#line 55
static int ngx_http_cmp_dns_wildcards(void const   *one , void const   *two ) ;
#line 58
static ngx_int_t ngx_http_init_listening(ngx_conf_t *cf , ngx_http_conf_port_t *port ) ;
#line 60
static ngx_listening_t *ngx_http_add_listening(ngx_conf_t *cf , ngx_http_conf_addr_t *addr ) ;
#line 62
static ngx_int_t ngx_http_add_addrs(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) ;
#line 65
static ngx_int_t ngx_http_add_addrs6(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) ;
#line 77 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
ngx_str_t ngx_http_html_default_types[2]  = {      {sizeof("text/html") - 1UL, (u_char *)"text/html"}, 
        {(size_t___0 )0, (u_char *)((void *)0)}};
#line 83 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_command_t ngx_http_commands[2]  = {      {{sizeof("http") - 1UL, (u_char *)"http"}, (ngx_uint_t )16777473, & ngx_http_block,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 96 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_core_module_t ngx_http_module_ctx  =    {{sizeof("http") - 1UL, (u_char *)"http"}, (void *(*)(ngx_cycle_t *cycle ))((void *)0),
    (char *(*)(ngx_cycle_t *cycle , void *conf ))((void *)0)};
#line 103 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
ngx_module_t ngx_http_module  = 
#line 103
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_module_ctx),
    ngx_http_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 119 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static char *ngx_http_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  ngx_uint_t mi ;
  ngx_uint_t m ;
  ngx_uint_t s ;
  ngx_conf_t pcf ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t **cscfp ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;
  ngx_int_t tmp___11 ;
  ngx_int_t tmp___12 ;

  {
#line 131
  if (*((ngx_http_conf_ctx_t **)conf)) {
#line 132
    return ((char *)"is duplicate");
  }
  {
#line 137
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 137
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 138
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 139
    return ((char *)((void *)-1));
  }
  {
#line 142
  *((ngx_http_conf_ctx_t **)conf) = ctx;
#line 147
  tmp___0 = ngx_count_modules(cf->cycle, (ngx_uint_t )1347703880);
#line 147
  ngx_http_max_module = (ngx_uint_t )tmp___0;
#line 152
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 152
  ctx->main_conf = (void **)tmp___1;
  }
#line 154
  if ((unsigned long )ctx->main_conf == (unsigned long )((void *)0)) {
#line 155
    return ((char *)((void *)-1));
  }
  {
#line 164
  tmp___2 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 164
  ctx->srv_conf = (void **)tmp___2;
  }
#line 165
  if ((unsigned long )ctx->srv_conf == (unsigned long )((void *)0)) {
#line 166
    return ((char *)((void *)-1));
  }
  {
#line 175
  tmp___3 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 175
  ctx->loc_conf = (void **)tmp___3;
  }
#line 176
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 177
    return ((char *)((void *)-1));
  }
#line 186
  m = (ngx_uint_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *((cf->cycle)->modules + m)) {
#line 186
      goto while_break;
    }
#line 187
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 188
      goto __Cont;
    }
#line 191
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 192
    mi = (*((cf->cycle)->modules + m))->ctx_index;
#line 194
    if (module->create_main_conf) {
      {
#line 195
      *(ctx->main_conf + mi) = (*(module->create_main_conf))(cf);
      }
#line 196
      if ((unsigned long )*(ctx->main_conf + mi) == (unsigned long )((void *)0)) {
#line 197
        return ((char *)((void *)-1));
      }
    }
#line 201
    if (module->create_srv_conf) {
      {
#line 202
      *(ctx->srv_conf + mi) = (*(module->create_srv_conf))(cf);
      }
#line 203
      if ((unsigned long )*(ctx->srv_conf + mi) == (unsigned long )((void *)0)) {
#line 204
        return ((char *)((void *)-1));
      }
    }
#line 208
    if (module->create_loc_conf) {
      {
#line 209
      *(ctx->loc_conf + mi) = (*(module->create_loc_conf))(cf);
      }
#line 210
      if ((unsigned long )*(ctx->loc_conf + mi) == (unsigned long )((void *)0)) {
#line 211
        return ((char *)((void *)-1));
      }
    }
    __Cont: /* CIL Label */ 
#line 186
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  pcf = *cf;
#line 217
  cf->ctx = (void *)ctx;
#line 219
  m = (ngx_uint_t )0;
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if (! *((cf->cycle)->modules + m)) {
#line 219
      goto while_break___0;
    }
#line 220
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 221
      goto __Cont___0;
    }
#line 224
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 226
    if (module->preconfiguration) {
      {
#line 227
      tmp___4 = (*(module->preconfiguration))(cf);
      }
#line 227
      if (tmp___4 != 0L) {
#line 228
        return ((char *)((void *)-1));
      }
    }
    __Cont___0: /* CIL Label */ 
#line 219
    m ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 235
  cf->module_type = (ngx_uint_t )1347703880;
#line 236
  cf->cmd_type = (ngx_uint_t )33554432;
#line 237
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
  }
#line 239
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 240
    goto failed;
  }
#line 248
  cmcf = (ngx_http_core_main_conf_t *)*(ctx->main_conf + ngx_http_core_module.ctx_index);
#line 249
  cscfp = (ngx_http_core_srv_conf_t **)cmcf->servers.elts;
#line 251
  m = (ngx_uint_t )0;
  {
#line 251
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 251
    if (! *((cf->cycle)->modules + m)) {
#line 251
      goto while_break___1;
    }
#line 252
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 253
      goto __Cont___1;
    }
#line 256
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 257
    mi = (*((cf->cycle)->modules + m))->ctx_index;
#line 261
    if (module->init_main_conf) {
      {
#line 262
      rv = (*(module->init_main_conf))(cf, *(ctx->main_conf + mi));
      }
#line 263
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 264
        goto failed;
      }
    }
    {
#line 268
    rv = ngx_http_merge_servers(cf, cmcf, module, mi);
    }
#line 269
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 270
      goto failed;
    }
    __Cont___1: /* CIL Label */ 
#line 251
    m ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 277
  s = (ngx_uint_t )0;
  {
#line 277
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 277
    if (! (s < cmcf->servers.nelts)) {
#line 277
      goto while_break___2;
    }
    {
#line 279
    clcf = (ngx_http_core_loc_conf_t *)*(((*(cscfp + s))->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 281
    tmp___5 = ngx_http_init_locations(cf, *(cscfp + s), clcf);
    }
#line 281
    if (tmp___5 != 0L) {
#line 282
      return ((char *)((void *)-1));
    }
    {
#line 285
    tmp___6 = ngx_http_init_static_location_trees(cf, clcf);
    }
#line 285
    if (tmp___6 != 0L) {
#line 286
      return ((char *)((void *)-1));
    }
#line 277
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 291
  tmp___7 = ngx_http_init_phases(cf, cmcf);
  }
#line 291
  if (tmp___7 != 0L) {
#line 292
    return ((char *)((void *)-1));
  }
  {
#line 295
  tmp___8 = ngx_http_init_headers_in_hash(cf, cmcf);
  }
#line 295
  if (tmp___8 != 0L) {
#line 296
    return ((char *)((void *)-1));
  }
#line 300
  m = (ngx_uint_t )0;
  {
#line 300
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 300
    if (! *((cf->cycle)->modules + m)) {
#line 300
      goto while_break___3;
    }
#line 301
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 302
      goto __Cont___2;
    }
#line 305
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 307
    if (module->postconfiguration) {
      {
#line 308
      tmp___9 = (*(module->postconfiguration))(cf);
      }
#line 308
      if (tmp___9 != 0L) {
#line 309
        return ((char *)((void *)-1));
      }
    }
    __Cont___2: /* CIL Label */ 
#line 300
    m ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 314
  tmp___10 = ngx_http_variables_init_vars(cf);
  }
#line 314
  if (tmp___10 != 0L) {
#line 315
    return ((char *)((void *)-1));
  }
  {
#line 323
  *cf = pcf;
#line 326
  tmp___11 = ngx_http_init_phase_handlers(cf, cmcf);
  }
#line 326
  if (tmp___11 != 0L) {
#line 327
    return ((char *)((void *)-1));
  }
  {
#line 333
  tmp___12 = ngx_http_optimize_servers(cf, cmcf, cmcf->ports);
  }
#line 333
  if (tmp___12 != 0L) {
#line 334
    return ((char *)((void *)-1));
  }
#line 337
  return ((char *)((void *)0));
  failed: 
#line 341
  *cf = pcf;
#line 343
  return (rv);
}
}
#line 347 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;

  {
  {
#line 350
  tmp = ngx_array_init(& cmcf->phases[0].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 350
  if (tmp != 0L) {
#line 354
    return ((ngx_int_t )-1);
  }
  {
#line 357
  tmp___0 = ngx_array_init(& cmcf->phases[1].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 357
  if (tmp___0 != 0L) {
#line 361
    return ((ngx_int_t )-1);
  }
  {
#line 364
  tmp___1 = ngx_array_init(& cmcf->phases[3].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 364
  if (tmp___1 != 0L) {
#line 368
    return ((ngx_int_t )-1);
  }
  {
#line 371
  tmp___2 = ngx_array_init(& cmcf->phases[5].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 371
  if (tmp___2 != 0L) {
#line 375
    return ((ngx_int_t )-1);
  }
  {
#line 378
  tmp___3 = ngx_array_init(& cmcf->phases[6].handlers, cf->pool, (ngx_uint_t )2, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 378
  if (tmp___3 != 0L) {
#line 382
    return ((ngx_int_t )-1);
  }
  {
#line 385
  tmp___4 = ngx_array_init(& cmcf->phases[9].handlers, cf->pool, (ngx_uint_t )4, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 385
  if (tmp___4 != 0L) {
#line 389
    return ((ngx_int_t )-1);
  }
  {
#line 392
  tmp___5 = ngx_array_init(& cmcf->phases[10].handlers, cf->pool, (ngx_uint_t )1,
                           sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 392
  if (tmp___5 != 0L) {
#line 396
    return ((ngx_int_t )-1);
  }
#line 399
  return ((ngx_int_t )0);
}
}
#line 403 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_headers_in_hash(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) 
{ 
  ngx_array_t headers_in ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_header_t *header___0 ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 411
  tmp = ngx_array_init(& headers_in, cf->temp_pool, (ngx_uint_t )32, sizeof(ngx_hash_key_t ));
  }
#line 411
  if (tmp != 0L) {
#line 414
    return ((ngx_int_t )-1);
  }
#line 417
  header___0 = ngx_http_headers_in;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! header___0->name.len) {
#line 417
      goto while_break;
    }
    {
#line 418
    tmp___0 = ngx_array_push(& headers_in);
#line 418
    hk = (ngx_hash_key_t *)tmp___0;
    }
#line 419
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 420
      return ((ngx_int_t )-1);
    }
    {
#line 423
    hk->key = header___0->name;
#line 424
    hk->key_hash = ngx_hash_key_lc(header___0->name.data, header___0->name.len);
#line 425
    hk->value = (void *)header___0;
#line 417
    header___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  hash.hash = & cmcf->headers_in_hash;
#line 429
  hash.key = & ngx_hash_key_lc;
#line 430
  hash.max_size = (ngx_uint_t )512;
#line 431
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 432
  hash.name = (char *)"headers_in_hash";
#line 433
  hash.pool = cf->pool;
#line 434
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 436
  tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_in.elts, headers_in.nelts);
  }
#line 436
  if (tmp___1 != 0L) {
#line 437
    return ((ngx_int_t )-1);
  }
#line 440
  return ((ngx_int_t )0);
}
}
#line 444 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_phase_handlers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) 
{ 
  ngx_int_t j ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t find_config_index ;
  ngx_uint_t use_rewrite ;
  ngx_uint_t use_access ;
  ngx_http_handler_pt *h ;
  ngx_http_phase_handler_t *ph ;
  ngx_int_t (*checker)(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
  void *tmp ;

  {
#line 454
  cmcf->phase_engine.server_rewrite_index = (ngx_uint_t )-1;
#line 455
  cmcf->phase_engine.location_rewrite_index = (ngx_uint_t )-1;
#line 456
  find_config_index = (ngx_uint_t )0;
#line 457
  if (cmcf->phases[3].handlers.nelts) {
#line 457
    use_rewrite = (ngx_uint_t )1;
  } else {
#line 457
    use_rewrite = (ngx_uint_t )0;
  }
#line 458
  if (cmcf->phases[6].handlers.nelts) {
#line 458
    use_access = (ngx_uint_t )1;
  } else {
#line 458
    use_access = (ngx_uint_t )0;
  }
#line 460
  n = ((1UL + use_rewrite) + use_access) + cmcf->try_files;
#line 465
  i = (ngx_uint_t )0;
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (i < 10UL)) {
#line 465
      goto while_break;
    }
#line 466
    n += cmcf->phases[i].handlers.nelts;
#line 465
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  tmp = ngx_pcalloc(cf->pool, n * sizeof(ngx_http_phase_handler_t ) + sizeof(void *));
#line 469
  ph = (ngx_http_phase_handler_t *)tmp;
  }
#line 471
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 472
    return ((ngx_int_t )-1);
  }
#line 475
  cmcf->phase_engine.handlers = ph;
#line 476
  n = (ngx_uint_t )0;
#line 478
  i = (ngx_uint_t )0;
  {
#line 478
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 478
    if (! (i < 10UL)) {
#line 478
      goto while_break___0;
    }
#line 479
    h = (ngx_http_handler_pt *)cmcf->phases[i].handlers.elts;
    {
#line 483
    if (i == 1UL) {
#line 483
      goto case_1;
    }
#line 491
    if (i == 2UL) {
#line 491
      goto case_2;
    }
#line 500
    if (i == 3UL) {
#line 500
      goto case_3;
    }
#line 508
    if (i == 4UL) {
#line 508
      goto case_4;
    }
#line 518
    if (i == 6UL) {
#line 518
      goto case_6;
    }
#line 523
    if (i == 7UL) {
#line 523
      goto case_7;
    }
#line 532
    if (i == 8UL) {
#line 532
      goto case_8;
    }
#line 541
    if (i == 9UL) {
#line 541
      goto case_9;
    }
#line 545
    goto switch_default;
    case_1: /* CIL Label */ 
#line 484
    if (cmcf->phase_engine.server_rewrite_index == 0xffffffffffffffffUL) {
#line 485
      cmcf->phase_engine.server_rewrite_index = n;
    }
#line 487
    checker = & ngx_http_core_rewrite_phase;
#line 489
    goto switch_break;
    case_2: /* CIL Label */ 
#line 492
    find_config_index = n;
#line 494
    ph->checker = & ngx_http_core_find_config_phase;
#line 495
    n ++;
#line 496
    ph ++;
#line 498
    goto __Cont;
    case_3: /* CIL Label */ 
#line 501
    if (cmcf->phase_engine.location_rewrite_index == 0xffffffffffffffffUL) {
#line 502
      cmcf->phase_engine.location_rewrite_index = n;
    }
#line 504
    checker = & ngx_http_core_rewrite_phase;
#line 506
    goto switch_break;
    case_4: /* CIL Label */ 
#line 509
    if (use_rewrite) {
#line 510
      ph->checker = & ngx_http_core_post_rewrite_phase;
#line 511
      ph->next = find_config_index;
#line 512
      n ++;
#line 513
      ph ++;
    }
#line 516
    goto __Cont;
    case_6: /* CIL Label */ 
#line 519
    checker = & ngx_http_core_access_phase;
#line 520
    n ++;
#line 521
    goto switch_break;
    case_7: /* CIL Label */ 
#line 524
    if (use_access) {
#line 525
      ph->checker = & ngx_http_core_post_access_phase;
#line 526
      ph->next = n;
#line 527
      ph ++;
    }
#line 530
    goto __Cont;
    case_8: /* CIL Label */ 
#line 533
    if (cmcf->try_files) {
#line 534
      ph->checker = & ngx_http_core_try_files_phase;
#line 535
      n ++;
#line 536
      ph ++;
    }
#line 539
    goto __Cont;
    case_9: /* CIL Label */ 
#line 542
    checker = & ngx_http_core_content_phase;
#line 543
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 546
    checker = & ngx_http_core_generic_phase;
    switch_break: /* CIL Label */ ;
    }
#line 549
    n += cmcf->phases[i].handlers.nelts;
#line 551
    j = (ngx_int_t )(cmcf->phases[i].handlers.nelts - 1UL);
    {
#line 551
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 551
      if (! (j >= 0L)) {
#line 551
        goto while_break___1;
      }
#line 552
      ph->checker = checker;
#line 553
      ph->handler = *(h + j);
#line 554
      ph->next = n;
#line 555
      ph ++;
#line 551
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 478
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 559
  return ((ngx_int_t )0);
}
}
#line 563 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static char *ngx_http_merge_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                    ngx_http_module_t *module , ngx_uint_t ctx_index ) 
{ 
  char *rv ;
  ngx_uint_t s ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t saved ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t **cscfp ;

  {
#line 573
  cscfp = (ngx_http_core_srv_conf_t **)cmcf->servers.elts;
#line 574
  ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 575
  saved = *ctx;
#line 576
  rv = (char *)((void *)0);
#line 578
  s = (ngx_uint_t )0;
  {
#line 578
  while (1) {
    while_continue: /* CIL Label */ ;
#line 578
    if (! (s < cmcf->servers.nelts)) {
#line 578
      goto while_break;
    }
#line 582
    ctx->srv_conf = ((*(cscfp + s))->ctx)->srv_conf;
#line 584
    if (module->merge_srv_conf) {
      {
#line 585
      rv = (*(module->merge_srv_conf))(cf, *(saved.srv_conf + ctx_index), *(((*(cscfp + s))->ctx)->srv_conf + ctx_index));
      }
#line 587
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 588
        goto failed;
      }
    }
#line 592
    if (module->merge_loc_conf) {
      {
#line 596
      ctx->loc_conf = ((*(cscfp + s))->ctx)->loc_conf;
#line 598
      rv = (*(module->merge_loc_conf))(cf, *(saved.loc_conf + ctx_index), *(((*(cscfp + s))->ctx)->loc_conf + ctx_index));
      }
#line 600
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 601
        goto failed;
      }
      {
#line 606
      clcf = (ngx_http_core_loc_conf_t *)*(((*(cscfp + s))->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 608
      rv = ngx_http_merge_locations(cf, clcf->locations, ((*(cscfp + s))->ctx)->loc_conf,
                                    module, ctx_index);
      }
#line 611
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 612
        goto failed;
      }
    }
#line 578
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 619
  *ctx = saved;
#line 621
  return (rv);
}
}
#line 625 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static char *ngx_http_merge_locations(ngx_conf_t *cf , ngx_queue_t *locations , void **loc_conf ,
                                      ngx_http_module_t *module , ngx_uint_t ctx_index ) 
{ 
  char *rv ;
  ngx_queue_t *q ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t saved ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_location_queue_t *lq ;

  {
#line 635
  if ((unsigned long )locations == (unsigned long )((void *)0)) {
#line 636
    return ((char *)((void *)0));
  }
#line 639
  ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 640
  saved = *ctx;
#line 642
  q = locations->next;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! ((unsigned long )q != (unsigned long )locations)) {
#line 642
      goto while_break;
    }
#line 646
    lq = (ngx_http_location_queue_t *)q;
#line 648
    if (lq->exact) {
#line 648
      clcf = lq->exact;
    } else {
#line 648
      clcf = lq->inclusive;
    }
    {
#line 649
    ctx->loc_conf = clcf->loc_conf;
#line 651
    rv = (*(module->merge_loc_conf))(cf, *(loc_conf + ctx_index), *(clcf->loc_conf + ctx_index));
    }
#line 653
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 654
      return (rv);
    }
    {
#line 657
    rv = ngx_http_merge_locations(cf, clcf->locations, clcf->loc_conf, module, ctx_index);
    }
#line 659
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 660
      return (rv);
    }
#line 642
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 664
  *ctx = saved;
#line 666
  return ((char *)((void *)0));
}
}
#line 670 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                         ngx_http_core_loc_conf_t *pclcf ) 
{ 
  ngx_uint_t n ;
  ngx_queue_t *q ;
  ngx_queue_t *locations ;
  ngx_queue_t *named ;
  ngx_queue_t tail___1 ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_location_queue_t *lq ;
  ngx_http_core_loc_conf_t **clcfp ;
  ngx_uint_t r ;
  ngx_queue_t *regex ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_http_core_loc_conf_t **tmp___1 ;
  void *tmp___2 ;
  ngx_http_core_loc_conf_t **tmp___3 ;

  {
#line 684
  locations = pclcf->locations;
#line 686
  if ((unsigned long )locations == (unsigned long )((void *)0)) {
#line 687
    return ((ngx_int_t )0);
  }
  {
#line 690
  ngx_queue_sort(locations, & ngx_http_cmp_locations);
#line 692
  named = (ngx_queue_t *)((void *)0);
#line 693
  n = (ngx_uint_t )0;
#line 695
  regex = (ngx_queue_t *)((void *)0);
#line 696
  r = (ngx_uint_t )0;
#line 699
  q = locations->next;
  }
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! ((unsigned long )q != (unsigned long )locations)) {
#line 699
      goto while_break;
    }
#line 703
    lq = (ngx_http_location_queue_t *)q;
#line 705
    if (lq->exact) {
#line 705
      clcf = lq->exact;
    } else {
#line 705
      clcf = lq->inclusive;
    }
    {
#line 707
    tmp = ngx_http_init_locations(cf, (ngx_http_core_srv_conf_t *)((void *)0), clcf);
    }
#line 707
    if (tmp != 0L) {
#line 708
      return ((ngx_int_t )-1);
    }
#line 713
    if (clcf->regex) {
#line 714
      r ++;
#line 716
      if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 717
        regex = q;
      }
#line 720
      goto __Cont;
    }
#line 725
    if (clcf->named) {
#line 726
      n ++;
#line 728
      if ((unsigned long )named == (unsigned long )((void *)0)) {
#line 729
        named = q;
      }
#line 732
      goto __Cont;
    }
#line 735
    if (clcf->noname) {
#line 736
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 699
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 740
  if ((unsigned long )q != (unsigned long )locations) {
#line 741
    tail___1.prev = locations->prev;
#line 741
    (tail___1.prev)->next = & tail___1;
#line 741
    tail___1.next = q;
#line 741
    locations->prev = q->prev;
#line 741
    (locations->prev)->next = locations;
#line 741
    q->prev = & tail___1;
  }
#line 744
  if (named) {
    {
#line 745
    tmp___0 = ngx_palloc(cf->pool, (n + 1UL) * sizeof(ngx_http_core_loc_conf_t *));
#line 745
    clcfp = (ngx_http_core_loc_conf_t **)tmp___0;
    }
#line 747
    if ((unsigned long )clcfp == (unsigned long )((void *)0)) {
#line 748
      return ((ngx_int_t )-1);
    }
#line 751
    cscf->named_locations = clcfp;
#line 753
    q = named;
    {
#line 753
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 753
      if (! ((unsigned long )q != (unsigned long )locations)) {
#line 753
        goto while_break___0;
      }
#line 757
      lq = (ngx_http_location_queue_t *)q;
#line 759
      tmp___1 = clcfp;
#line 759
      clcfp ++;
#line 759
      *tmp___1 = lq->exact;
#line 753
      q = q->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 762
    *clcfp = (ngx_http_core_loc_conf_t *)((void *)0);
#line 764
    tail___1.prev = locations->prev;
#line 764
    (tail___1.prev)->next = & tail___1;
#line 764
    tail___1.next = named;
#line 764
    locations->prev = named->prev;
#line 764
    (locations->prev)->next = locations;
#line 764
    named->prev = & tail___1;
  }
#line 769
  if (regex) {
    {
#line 771
    tmp___2 = ngx_palloc(cf->pool, (r + 1UL) * sizeof(ngx_http_core_loc_conf_t *));
#line 771
    clcfp = (ngx_http_core_loc_conf_t **)tmp___2;
    }
#line 773
    if ((unsigned long )clcfp == (unsigned long )((void *)0)) {
#line 774
      return ((ngx_int_t )-1);
    }
#line 777
    pclcf->regex_locations = clcfp;
#line 779
    q = regex;
    {
#line 779
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 779
      if (! ((unsigned long )q != (unsigned long )locations)) {
#line 779
        goto while_break___1;
      }
#line 783
      lq = (ngx_http_location_queue_t *)q;
#line 785
      tmp___3 = clcfp;
#line 785
      clcfp ++;
#line 785
      *tmp___3 = lq->exact;
#line 779
      q = q->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 788
    *clcfp = (ngx_http_core_loc_conf_t *)((void *)0);
#line 790
    tail___1.prev = locations->prev;
#line 790
    (tail___1.prev)->next = & tail___1;
#line 790
    tail___1.next = regex;
#line 790
    locations->prev = regex->prev;
#line 790
    (locations->prev)->next = locations;
#line 790
    regex->prev = & tail___1;
  }
#line 795
  return ((ngx_int_t )0);
}
}
#line 799 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf , ngx_http_core_loc_conf_t *pclcf ) 
{ 
  ngx_queue_t *q ;
  ngx_queue_t *locations ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_location_queue_t *lq ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 807
  locations = pclcf->locations;
#line 809
  if ((unsigned long )locations == (unsigned long )((void *)0)) {
#line 810
    return ((ngx_int_t )0);
  }
#line 813
  if ((unsigned long )locations == (unsigned long )locations->prev) {
#line 814
    return ((ngx_int_t )0);
  }
#line 817
  q = locations->next;
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 817
    if (! ((unsigned long )q != (unsigned long )locations)) {
#line 817
      goto while_break;
    }
#line 821
    lq = (ngx_http_location_queue_t *)q;
#line 823
    if (lq->exact) {
#line 823
      clcf = lq->exact;
    } else {
#line 823
      clcf = lq->inclusive;
    }
    {
#line 825
    tmp = ngx_http_init_static_location_trees(cf, clcf);
    }
#line 825
    if (tmp != 0L) {
#line 826
      return ((ngx_int_t )-1);
    }
#line 817
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 830
  tmp___0 = ngx_http_join_exact_locations(cf, locations);
  }
#line 830
  if (tmp___0 != 0L) {
#line 831
    return ((ngx_int_t )-1);
  }
  {
#line 834
  ngx_http_create_locations_list(locations, locations->next);
#line 836
  pclcf->static_locations = ngx_http_create_locations_tree(cf, locations, (size_t___0 )0);
  }
#line 837
  if ((unsigned long )pclcf->static_locations == (unsigned long )((void *)0)) {
#line 838
    return ((ngx_int_t )-1);
  }
#line 841
  return ((ngx_int_t )0);
}
}
#line 845 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
ngx_int_t ngx_http_add_location(ngx_conf_t *cf , ngx_queue_t **locations , ngx_http_core_loc_conf_t *clcf ) 
{ 
  ngx_http_location_queue_t *lq ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 851
  if ((unsigned long )*locations == (unsigned long )((void *)0)) {
    {
#line 852
    tmp = ngx_palloc(cf->temp_pool, sizeof(ngx_http_location_queue_t ));
#line 852
    *locations = (ngx_queue_t *)tmp;
    }
#line 854
    if ((unsigned long )*locations == (unsigned long )((void *)0)) {
#line 855
      return ((ngx_int_t )-1);
    }
#line 858
    (*locations)->prev = *locations;
#line 858
    (*locations)->next = *locations;
  }
  {
#line 861
  tmp___0 = ngx_palloc(cf->temp_pool, sizeof(ngx_http_location_queue_t ));
#line 861
  lq = (ngx_http_location_queue_t *)tmp___0;
  }
#line 862
  if ((unsigned long )lq == (unsigned long )((void *)0)) {
#line 863
    return ((ngx_int_t )-1);
  }
#line 866
  if (clcf->exact_match) {
#line 872
    lq->exact = clcf;
#line 873
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else
#line 866
  if (clcf->regex) {
#line 872
    lq->exact = clcf;
#line 873
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else
#line 866
  if (clcf->named) {
#line 872
    lq->exact = clcf;
#line 873
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else
#line 866
  if (clcf->noname) {
#line 872
    lq->exact = clcf;
#line 873
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else {
#line 876
    lq->exact = (ngx_http_core_loc_conf_t *)((void *)0);
#line 877
    lq->inclusive = clcf;
  }
#line 880
  lq->name = & clcf->name;
#line 881
  lq->file_name = (cf->conf_file)->file.name.data;
#line 882
  lq->line = (cf->conf_file)->line;
#line 884
  lq->list.prev = & lq->list;
#line 884
  lq->list.next = & lq->list;
#line 886
  lq->queue.prev = (*locations)->prev;
#line 886
  (lq->queue.prev)->next = & lq->queue;
#line 886
  lq->queue.next = *locations;
#line 886
  (*locations)->prev = & lq->queue;
#line 888
  return ((ngx_int_t )0);
}
}
#line 892 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_cmp_locations(ngx_queue_t const   *one , ngx_queue_t const   *two ) 
{ 
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *first ;
  ngx_http_core_loc_conf_t *second ;
  ngx_http_location_queue_t *lq1 ;
  ngx_http_location_queue_t *lq2 ;
  int tmp ;
  size_t___0 tmp___0 ;

  {
#line 899
  lq1 = (ngx_http_location_queue_t *)one;
#line 900
  lq2 = (ngx_http_location_queue_t *)two;
#line 902
  if (lq1->exact) {
#line 902
    first = lq1->exact;
  } else {
#line 902
    first = lq1->inclusive;
  }
#line 903
  if (lq2->exact) {
#line 903
    second = lq2->exact;
  } else {
#line 903
    second = lq2->inclusive;
  }
#line 905
  if (first->noname) {
#line 905
    if (! second->noname) {
#line 907
      return ((ngx_int_t )1);
    }
  }
#line 910
  if (! first->noname) {
#line 910
    if (second->noname) {
#line 912
      return ((ngx_int_t )-1);
    }
  }
#line 915
  if (first->noname) {
#line 917
    return ((ngx_int_t )0);
  } else
#line 915
  if (second->noname) {
#line 917
    return ((ngx_int_t )0);
  }
#line 920
  if (first->named) {
#line 920
    if (! second->named) {
#line 922
      return ((ngx_int_t )1);
    }
  }
#line 925
  if (! first->named) {
#line 925
    if (second->named) {
#line 927
      return ((ngx_int_t )-1);
    }
  }
#line 930
  if (first->named) {
#line 930
    if (second->named) {
      {
#line 931
      tmp = strcmp((char const   *)first->name.data, (char const   *)second->name.data);
      }
#line 931
      return ((ngx_int_t )tmp);
    }
  }
#line 936
  if (first->regex) {
#line 936
    if (! second->regex) {
#line 938
      return ((ngx_int_t )1);
    }
  }
#line 941
  if (! first->regex) {
#line 941
    if (second->regex) {
#line 943
      return ((ngx_int_t )-1);
    }
  }
#line 946
  if (first->regex) {
#line 948
    return ((ngx_int_t )0);
  } else
#line 946
  if (second->regex) {
#line 948
    return ((ngx_int_t )0);
  }
#line 953
  if (first->name.len > second->name.len) {
#line 953
    tmp___0 = second->name.len;
  } else {
#line 953
    tmp___0 = first->name.len;
  }
  {
#line 953
  rc = ngx_filename_cmp(first->name.data, second->name.data, tmp___0 + 1UL);
  }
#line 956
  if (rc == 0L) {
#line 956
    if (! first->exact_match) {
#line 956
      if (second->exact_match) {
#line 958
        return ((ngx_int_t )1);
      }
    }
  }
#line 961
  return (rc);
}
}
#line 965 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf , ngx_queue_t *locations ) 
{ 
  ngx_queue_t *q ;
  ngx_queue_t *x ;
  ngx_http_location_queue_t *lq ;
  ngx_http_location_queue_t *lx ;
  ngx_int_t tmp ;

  {
#line 971
  q = locations->next;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! ((unsigned long )q != (unsigned long )locations->prev)) {
#line 973
      goto while_break;
    }
#line 975
    x = q->next;
#line 977
    lq = (ngx_http_location_queue_t *)q;
#line 978
    lx = (ngx_http_location_queue_t *)x;
#line 980
    if ((lq->name)->len == (lx->name)->len) {
      {
#line 980
      tmp = ngx_filename_cmp((lq->name)->data, (lx->name)->data, (lx->name)->len);
      }
#line 980
      if (tmp == 0L) {
#line 984
        if (lq->exact) {
#line 984
          if (lx->exact) {
#line 984
            goto _L;
          } else {
#line 984
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 984
        if (lq->inclusive) {
#line 984
          if (lx->inclusive) {
            _L: /* CIL Label */ 
#line 985
            if ((cf->log)->log_level >= 1UL) {
              {
#line 985
              ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "duplicate location \"%V\" in %s:%ui",
                                 lx->name, lx->file_name, lx->line);
              }
            }
#line 989
            return ((ngx_int_t )-1);
          }
        }
#line 992
        lq->inclusive = lx->inclusive;
#line 994
        (x->next)->prev = x->prev;
#line 994
        (x->prev)->next = x->next;
#line 996
        goto while_continue;
      }
    }
#line 999
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  return ((ngx_int_t )0);
}
}
#line 1006 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static void ngx_http_create_locations_list(ngx_queue_t *locations , ngx_queue_t *q ) 
{ 
  u_char *name ;
  size_t___0 len ;
  ngx_queue_t *x ;
  ngx_queue_t tail___1 ;
  ngx_http_location_queue_t *lq ;
  ngx_http_location_queue_t *lx ;
  ngx_int_t tmp ;

  {
#line 1014
  if ((unsigned long )q == (unsigned long )locations->prev) {
#line 1015
    return;
  }
#line 1018
  lq = (ngx_http_location_queue_t *)q;
#line 1020
  if ((unsigned long )lq->inclusive == (unsigned long )((void *)0)) {
    {
#line 1021
    ngx_http_create_locations_list(locations, q->next);
    }
#line 1022
    return;
  }
#line 1025
  len = (lq->name)->len;
#line 1026
  name = (lq->name)->data;
#line 1028
  x = q->next;
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! ((unsigned long )x != (unsigned long )locations)) {
#line 1028
      goto while_break;
    }
#line 1032
    lx = (ngx_http_location_queue_t *)x;
#line 1034
    if (len > (lx->name)->len) {
#line 1037
      goto while_break;
    } else {
      {
#line 1034
      tmp = ngx_filename_cmp(name, (lx->name)->data, len);
      }
#line 1034
      if (tmp != 0L) {
#line 1037
        goto while_break;
      }
    }
#line 1028
    x = x->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  q = q->next;
#line 1043
  if ((unsigned long )q == (unsigned long )x) {
    {
#line 1044
    ngx_http_create_locations_list(locations, x);
    }
#line 1045
    return;
  }
#line 1048
  tail___1.prev = locations->prev;
#line 1048
  (tail___1.prev)->next = & tail___1;
#line 1048
  tail___1.next = q;
#line 1048
  locations->prev = q->prev;
#line 1048
  (locations->prev)->next = locations;
#line 1048
  q->prev = & tail___1;
#line 1049
  (lq->list.prev)->next = tail___1.next;
#line 1049
  (tail___1.next)->prev = lq->list.prev;
#line 1049
  lq->list.prev = tail___1.prev;
#line 1049
  (lq->list.prev)->next = & lq->list;
#line 1051
  if ((unsigned long )x == (unsigned long )locations) {
    {
#line 1052
    ngx_http_create_locations_list(& lq->list, lq->list.next);
    }
#line 1053
    return;
  }
  {
#line 1056
  tail___1.prev = lq->list.prev;
#line 1056
  (tail___1.prev)->next = & tail___1;
#line 1056
  tail___1.next = x;
#line 1056
  lq->list.prev = x->prev;
#line 1056
  (lq->list.prev)->next = & lq->list;
#line 1056
  x->prev = & tail___1;
#line 1057
  (locations->prev)->next = tail___1.next;
#line 1057
  (tail___1.next)->prev = locations->prev;
#line 1057
  locations->prev = tail___1.prev;
#line 1057
  (locations->prev)->next = locations;
#line 1059
  ngx_http_create_locations_list(& lq->list, lq->list.next);
#line 1061
  ngx_http_create_locations_list(locations, x);
  }
#line 1062
  return;
}
}
#line 1070 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_http_location_tree_node_t *ngx_http_create_locations_tree(ngx_conf_t *cf ,
                                                                     ngx_queue_t *locations ,
                                                                     size_t___0 prefix ) 
{ 
  size_t___0 len ;
  ngx_queue_t *q ;
  ngx_queue_t tail___1 ;
  ngx_http_location_queue_t *lq ;
  ngx_http_location_tree_node_t *node ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1079
  q = ngx_queue_middle(locations);
#line 1081
  lq = (ngx_http_location_queue_t *)q;
#line 1082
  len = (lq->name)->len - prefix;
#line 1084
  tmp = ngx_palloc(cf->pool, (unsigned long )(& ((ngx_http_location_tree_node_t *)0)->name) + len);
#line 1084
  node = (ngx_http_location_tree_node_t *)tmp;
  }
#line 1086
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1087
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
#line 1090
  node->left = (ngx_http_location_tree_node_t *)((void *)0);
#line 1091
  node->right = (ngx_http_location_tree_node_t *)((void *)0);
#line 1092
  node->tree = (ngx_http_location_tree_node_t *)((void *)0);
#line 1093
  node->exact = lq->exact;
#line 1094
  node->inclusive = lq->inclusive;
#line 1096
  if (lq->exact) {
#line 1096
    if ((lq->exact)->auto_redirect) {
#line 1096
      tmp___0 = 1;
    } else {
#line 1096
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1096
  if (lq->inclusive) {
#line 1096
    if ((lq->inclusive)->auto_redirect) {
#line 1096
      tmp___0 = 1;
    } else {
#line 1096
      tmp___0 = 0;
    }
  } else {
#line 1096
    tmp___0 = 0;
  }
  {
#line 1096
  node->auto_redirect = (u_char )tmp___0;
#line 1099
  node->len = (u_char )len;
#line 1100
  memcpy((void */* __restrict  */)(node->name), (void const   */* __restrict  */)((lq->name)->data + prefix),
         len);
#line 1102
  tail___1.prev = locations->prev;
#line 1102
  (tail___1.prev)->next = & tail___1;
#line 1102
  tail___1.next = q;
#line 1102
  locations->prev = q->prev;
#line 1102
  (locations->prev)->next = locations;
#line 1102
  q->prev = & tail___1;
  }
#line 1104
  if ((unsigned long )locations == (unsigned long )locations->prev) {
#line 1109
    goto inclusive;
  }
  {
#line 1112
  node->left = ngx_http_create_locations_tree(cf, locations, prefix);
  }
#line 1113
  if ((unsigned long )node->left == (unsigned long )((void *)0)) {
#line 1114
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
#line 1117
  (q->next)->prev = q->prev;
#line 1117
  (q->prev)->next = q->next;
#line 1119
  if ((unsigned long )(& tail___1) == (unsigned long )tail___1.prev) {
#line 1120
    goto inclusive;
  }
  {
#line 1123
  node->right = ngx_http_create_locations_tree(cf, & tail___1, prefix);
  }
#line 1124
  if ((unsigned long )node->right == (unsigned long )((void *)0)) {
#line 1125
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
  inclusive: 
#line 1130
  if ((unsigned long )(& lq->list) == (unsigned long )lq->list.prev) {
#line 1131
    return (node);
  }
  {
#line 1134
  node->tree = ngx_http_create_locations_tree(cf, & lq->list, prefix + len);
  }
#line 1135
  if ((unsigned long )node->tree == (unsigned long )((void *)0)) {
#line 1136
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
#line 1139
  return (node);
}
}
#line 1143 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
ngx_int_t ngx_http_add_listen(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf , ngx_http_listen_opt_t *lsopt ) 
{ 
  in_port_t p ;
  ngx_uint_t i ;
  struct sockaddr *sa ;
  ngx_http_conf_port_t *port ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1153
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 1155
  if ((unsigned long )cmcf->ports == (unsigned long )((void *)0)) {
    {
#line 1156
    cmcf->ports = ngx_array_create(cf->temp_pool, (ngx_uint_t )2, sizeof(ngx_http_conf_port_t ));
    }
#line 1158
    if ((unsigned long )cmcf->ports == (unsigned long )((void *)0)) {
#line 1159
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1163
  sa = & lsopt->sockaddr.sockaddr;
#line 1164
  p = ngx_inet_get_port(sa);
#line 1166
  port = (ngx_http_conf_port_t *)(cmcf->ports)->elts;
#line 1167
  i = (ngx_uint_t )0;
  }
  {
#line 1167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1167
    if (! (i < (cmcf->ports)->nelts)) {
#line 1167
      goto while_break;
    }
#line 1169
    if ((int )p != (int )(port + i)->port) {
#line 1170
      goto __Cont;
    } else
#line 1169
    if ((ngx_int_t )sa->sa_family != (port + i)->family) {
#line 1170
      goto __Cont;
    }
    {
#line 1175
    tmp = ngx_http_add_addresses(cf, cscf, port + i, lsopt);
    }
#line 1175
    return (tmp);
    __Cont: /* CIL Label */ 
#line 1167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1180
  tmp___0 = ngx_array_push(cmcf->ports);
#line 1180
  port = (ngx_http_conf_port_t *)tmp___0;
  }
#line 1181
  if ((unsigned long )port == (unsigned long )((void *)0)) {
#line 1182
    return ((ngx_int_t )-1);
  }
  {
#line 1185
  port->family = (ngx_int_t )sa->sa_family;
#line 1186
  port->port = p;
#line 1187
  port->addrs.elts = (void *)0;
#line 1189
  tmp___1 = ngx_http_add_address(cf, cscf, port, lsopt);
  }
#line 1189
  return (tmp___1);
}
}
#line 1193 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_addresses(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                        ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t default_server ;
  ngx_uint_t proxy_protocol ;
  ngx_http_conf_addr_t *addr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1211
  addr = (ngx_http_conf_addr_t *)port->addrs.elts;
#line 1213
  i = (ngx_uint_t )0;
  {
#line 1213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1213
    if (! (i < port->addrs.nelts)) {
#line 1213
      goto while_break;
    }
    {
#line 1215
    tmp = ngx_cmp_sockaddr(& lsopt->sockaddr.sockaddr, lsopt->socklen, & (addr + i)->opt.sockaddr.sockaddr,
                           (addr + i)->opt.socklen, (ngx_uint_t )0);
    }
#line 1215
    if (tmp != 0L) {
#line 1220
      goto __Cont;
    }
    {
#line 1225
    tmp___0 = ngx_http_add_server(cf, cscf, addr + i);
    }
#line 1225
    if (tmp___0 != 0L) {
#line 1226
      return ((ngx_int_t )-1);
    }
#line 1230
    default_server = (ngx_uint_t )(addr + i)->opt.default_server;
#line 1232
    if (lsopt->proxy_protocol) {
#line 1232
      tmp___1 = 1;
    } else
#line 1232
    if ((addr + i)->opt.proxy_protocol) {
#line 1232
      tmp___1 = 1;
    } else {
#line 1232
      tmp___1 = 0;
    }
#line 1232
    proxy_protocol = (ngx_uint_t )tmp___1;
#line 1241
    if (lsopt->set) {
#line 1243
      if ((addr + i)->opt.set) {
        {
#line 1244
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate listen options for %s",
                           (addr + i)->opt.addr);
        }
#line 1246
        return ((ngx_int_t )-1);
      }
#line 1249
      (addr + i)->opt = *lsopt;
    }
#line 1254
    if (lsopt->default_server) {
#line 1256
      if (default_server) {
        {
#line 1257
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "a duplicate default server for %s",
                           (addr + i)->opt.addr);
        }
#line 1259
        return ((ngx_int_t )-1);
      }
#line 1262
      default_server = (ngx_uint_t )1;
#line 1263
      (addr + i)->default_server = cscf;
    }
#line 1266
    (addr + i)->opt.default_server = (unsigned int )default_server;
#line 1267
    (addr + i)->opt.proxy_protocol = (unsigned int )proxy_protocol;
#line 1275
    return ((ngx_int_t )0);
    __Cont: /* CIL Label */ 
#line 1213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1280
  tmp___2 = ngx_http_add_address(cf, cscf, port, lsopt);
  }
#line 1280
  return (tmp___2);
}
}
#line 1289 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_address(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                      ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) 
{ 
  ngx_http_conf_addr_t *addr ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1295
  if ((unsigned long )port->addrs.elts == (unsigned long )((void *)0)) {
    {
#line 1296
    tmp = ngx_array_init(& port->addrs, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_conf_addr_t ));
    }
#line 1296
    if (tmp != 0L) {
#line 1300
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1317
  tmp___0 = ngx_array_push(& port->addrs);
#line 1317
  addr = (ngx_http_conf_addr_t *)tmp___0;
  }
#line 1318
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 1319
    return ((ngx_int_t )-1);
  }
  {
#line 1322
  addr->opt = *lsopt;
#line 1323
  addr->hash.buckets = (ngx_hash_elt_t **)((void *)0);
#line 1324
  addr->hash.size = (ngx_uint_t )0;
#line 1325
  addr->wc_head = (ngx_hash_wildcard_t *)((void *)0);
#line 1326
  addr->wc_tail = (ngx_hash_wildcard_t *)((void *)0);
#line 1328
  addr->nregex = (ngx_uint_t )0;
#line 1329
  addr->regex = (ngx_http_server_name_t *)((void *)0);
#line 1331
  addr->default_server = cscf;
#line 1332
  addr->servers.elts = (void *)0;
#line 1334
  tmp___1 = ngx_http_add_server(cf, cscf, addr);
  }
#line 1334
  return (tmp___1);
}
}
#line 1340 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_server(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                     ngx_http_conf_addr_t *addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_core_srv_conf_t **server ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
#line 1347
  if ((unsigned long )addr->servers.elts == (unsigned long )((void *)0)) {
    {
#line 1348
    tmp = ngx_array_init(& addr->servers, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_core_srv_conf_t *));
    }
#line 1348
    if (tmp != 0L) {
#line 1352
      return ((ngx_int_t )-1);
    }
  } else {
#line 1356
    server = (ngx_http_core_srv_conf_t **)addr->servers.elts;
#line 1357
    i = (ngx_uint_t )0;
    {
#line 1357
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1357
      if (! (i < addr->servers.nelts)) {
#line 1357
        goto while_break;
      }
#line 1358
      if ((unsigned long )*(server + i) == (unsigned long )cscf) {
        {
#line 1359
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "a duplicate listen %s", addr->opt.addr);
        }
#line 1361
        return ((ngx_int_t )-1);
      }
#line 1357
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1366
  tmp___0 = ngx_array_push(& addr->servers);
#line 1366
  server = (ngx_http_core_srv_conf_t **)tmp___0;
  }
#line 1367
  if ((unsigned long )server == (unsigned long )((void *)0)) {
#line 1368
    return ((ngx_int_t )-1);
  }
#line 1371
  *server = cscf;
#line 1373
  return ((ngx_int_t )0);
}
}
#line 1377 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_optimize_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                           ngx_array_t *ports ) 
{ 
  ngx_uint_t p ;
  ngx_uint_t a ;
  ngx_http_conf_port_t *port ;
  ngx_http_conf_addr_t *addr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1385
  if ((unsigned long )ports == (unsigned long )((void *)0)) {
#line 1386
    return ((ngx_int_t )0);
  }
#line 1389
  port = (ngx_http_conf_port_t *)ports->elts;
#line 1390
  p = (ngx_uint_t )0;
  {
#line 1390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1390
    if (! (p < ports->nelts)) {
#line 1390
      goto while_break;
    }
    {
#line 1392
    ngx_sort((port + p)->addrs.elts, (port + p)->addrs.nelts, sizeof(ngx_http_conf_addr_t ),
             & ngx_http_cmp_conf_addrs);
#line 1400
    addr = (ngx_http_conf_addr_t *)(port + p)->addrs.elts;
#line 1401
    a = (ngx_uint_t )0;
    }
    {
#line 1401
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1401
      if (! (a < (port + p)->addrs.nelts)) {
#line 1401
        goto while_break___0;
      }
#line 1403
      if ((addr + a)->servers.nelts > 1UL) {
#line 1403
        goto _L;
      } else
#line 1403
      if (((addr + a)->default_server)->captures) {
        _L: /* CIL Label */ 
        {
#line 1409
        tmp = ngx_http_server_names(cf, cmcf, addr + a);
        }
#line 1409
        if (tmp != 0L) {
#line 1410
          return ((ngx_int_t )-1);
        }
      }
#line 1401
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1415
    tmp___0 = ngx_http_init_listening(cf, port + p);
    }
#line 1415
    if (tmp___0 != 0L) {
#line 1416
      return ((ngx_int_t )-1);
    }
#line 1390
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1420
  return ((ngx_int_t )0);
}
}
#line 1424 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_server_names(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                       ngx_http_conf_addr_t *addr ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_uint_t s ;
  ngx_hash_init_t hash ;
  ngx_hash_keys_arrays_t ha ;
  ngx_http_server_name_t *name ;
  ngx_http_core_srv_conf_t **cscfp ;
  ngx_uint_t regex ;
  ngx_uint_t i ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  ngx_uint_t tmp___4 ;

  {
  {
#line 1437
  regex = (ngx_uint_t )0;
#line 1440
  memset((void *)(& ha), 0, sizeof(ngx_hash_keys_arrays_t ));
#line 1442
  ha.temp_pool = ngx_create_pool((size_t___0 )16384, cf->log);
  }
#line 1443
  if ((unsigned long )ha.temp_pool == (unsigned long )((void *)0)) {
#line 1444
    return ((ngx_int_t )-1);
  }
  {
#line 1447
  ha.pool = cf->pool;
#line 1449
  tmp = ngx_hash_keys_array_init(& ha, (ngx_uint_t )2);
  }
#line 1449
  if (tmp != 0L) {
#line 1450
    goto failed;
  }
#line 1453
  cscfp = (ngx_http_core_srv_conf_t **)addr->servers.elts;
#line 1455
  s = (ngx_uint_t )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (s < addr->servers.nelts)) {
#line 1455
      goto while_break;
    }
#line 1457
    name = (ngx_http_server_name_t *)(*(cscfp + s))->server_names.elts;
#line 1459
    n = (ngx_uint_t )0;
    {
#line 1459
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1459
      if (! (n < (*(cscfp + s))->server_names.nelts)) {
#line 1459
        goto while_break___0;
      }
#line 1462
      if ((name + n)->regex) {
#line 1463
        regex ++;
#line 1464
        goto __Cont;
      }
      {
#line 1468
      rc = ngx_hash_add_key(& ha, & (name + n)->name, (void *)(name + n)->server,
                            (ngx_uint_t )1);
      }
#line 1471
      if (rc == -1L) {
#line 1472
        return ((ngx_int_t )-1);
      }
#line 1475
      if (rc == -5L) {
#line 1476
        if ((cf->log)->log_level >= 1UL) {
          {
#line 1476
          ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "invalid server name or wildcard \"%V\" on %s",
                             & (name + n)->name, addr->opt.addr);
          }
        }
#line 1479
        return ((ngx_int_t )-1);
      }
#line 1482
      if (rc == -3L) {
#line 1483
        if ((cf->log)->log_level >= 5UL) {
          {
#line 1483
          ngx_log_error_core((ngx_uint_t )5, cf->log, 0, "conflicting server name \"%V\" on %s, ignored",
                             & (name + n)->name, addr->opt.addr);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1459
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1455
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1490
  hash.key = & ngx_hash_key_lc;
#line 1491
  hash.max_size = cmcf->server_names_hash_max_size;
#line 1492
  hash.bucket_size = cmcf->server_names_hash_bucket_size;
#line 1493
  hash.name = (char *)"server_names_hash";
#line 1494
  hash.pool = cf->pool;
#line 1496
  if (ha.keys.nelts) {
    {
#line 1497
    hash.hash = & addr->hash;
#line 1498
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 1500
    tmp___0 = ngx_hash_init(& hash, (ngx_hash_key_t *)ha.keys.elts, ha.keys.nelts);
    }
#line 1500
    if (tmp___0 != 0L) {
#line 1501
      goto failed;
    }
  }
#line 1505
  if (ha.dns_wc_head.nelts) {
    {
#line 1507
    qsort(ha.dns_wc_head.elts, ha.dns_wc_head.nelts, sizeof(ngx_hash_key_t ), & ngx_http_cmp_dns_wildcards);
#line 1510
    hash.hash = (ngx_hash_t *)((void *)0);
#line 1511
    hash.temp_pool = ha.temp_pool;
#line 1513
    tmp___1 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ha.dns_wc_head.elts,
                                     ha.dns_wc_head.nelts);
    }
#line 1513
    if (tmp___1 != 0L) {
#line 1517
      goto failed;
    }
#line 1520
    addr->wc_head = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 1523
  if (ha.dns_wc_tail.nelts) {
    {
#line 1525
    qsort(ha.dns_wc_tail.elts, ha.dns_wc_tail.nelts, sizeof(ngx_hash_key_t ), & ngx_http_cmp_dns_wildcards);
#line 1528
    hash.hash = (ngx_hash_t *)((void *)0);
#line 1529
    hash.temp_pool = ha.temp_pool;
#line 1531
    tmp___2 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ha.dns_wc_tail.elts,
                                     ha.dns_wc_tail.nelts);
    }
#line 1531
    if (tmp___2 != 0L) {
#line 1535
      goto failed;
    }
#line 1538
    addr->wc_tail = (ngx_hash_wildcard_t *)hash.hash;
  }
  {
#line 1541
  ngx_destroy_pool(ha.temp_pool);
  }
#line 1545
  if (regex == 0UL) {
#line 1546
    return ((ngx_int_t )0);
  }
  {
#line 1549
  addr->nregex = regex;
#line 1550
  tmp___3 = ngx_palloc(cf->pool, regex * sizeof(ngx_http_server_name_t ));
#line 1550
  addr->regex = (ngx_http_server_name_t *)tmp___3;
  }
#line 1551
  if ((unsigned long )addr->regex == (unsigned long )((void *)0)) {
#line 1552
    return ((ngx_int_t )-1);
  }
#line 1555
  i = (ngx_uint_t )0;
#line 1557
  s = (ngx_uint_t )0;
  {
#line 1557
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1557
    if (! (s < addr->servers.nelts)) {
#line 1557
      goto while_break___1;
    }
#line 1559
    name = (ngx_http_server_name_t *)(*(cscfp + s))->server_names.elts;
#line 1561
    n = (ngx_uint_t )0;
    {
#line 1561
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1561
      if (! (n < (*(cscfp + s))->server_names.nelts)) {
#line 1561
        goto while_break___2;
      }
#line 1562
      if ((name + n)->regex) {
#line 1563
        tmp___4 = i;
#line 1563
        i ++;
#line 1563
        *(addr->regex + tmp___4) = *(name + n);
      }
#line 1561
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1557
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1570
  return ((ngx_int_t )0);
  failed: 
  {
#line 1574
  ngx_destroy_pool(ha.temp_pool);
  }
#line 1576
  return ((ngx_int_t )-1);
}
}
#line 1580 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_cmp_conf_addrs(void const   *one , void const   *two ) 
{ 
  ngx_http_conf_addr_t *first ;
  ngx_http_conf_addr_t *second ;

  {
#line 1585
  first = (ngx_http_conf_addr_t *)one;
#line 1586
  second = (ngx_http_conf_addr_t *)two;
#line 1588
  if (first->opt.wildcard) {
#line 1590
    return ((ngx_int_t )1);
  }
#line 1593
  if (second->opt.wildcard) {
#line 1595
    return ((ngx_int_t )-1);
  }
#line 1598
  if (first->opt.bind) {
#line 1598
    if (! second->opt.bind) {
#line 1600
      return ((ngx_int_t )-1);
    }
  }
#line 1603
  if (! first->opt.bind) {
#line 1603
    if (second->opt.bind) {
#line 1605
      return ((ngx_int_t )1);
    }
  }
#line 1610
  return ((ngx_int_t )0);
}
}
#line 1614 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static int ngx_http_cmp_dns_wildcards(void const   *one , void const   *two ) 
{ 
  ngx_hash_key_t *first ;
  ngx_hash_key_t *second ;
  ngx_int_t tmp ;

  {
  {
#line 1619
  first = (ngx_hash_key_t *)one;
#line 1620
  second = (ngx_hash_key_t *)two;
#line 1622
  tmp = ngx_dns_strcmp(first->key.data, second->key.data);
  }
#line 1622
  return ((int )tmp);
}
}
#line 1626 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_listening(ngx_conf_t *cf , ngx_http_conf_port_t *port ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t last ;
  ngx_uint_t bind_wildcard ;
  ngx_listening_t *ls ;
  ngx_http_port_t *hport ;
  ngx_http_conf_addr_t *addr ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1634
  addr = (ngx_http_conf_addr_t *)port->addrs.elts;
#line 1635
  last = port->addrs.nelts;
#line 1644
  if ((addr + (last - 1UL))->opt.wildcard) {
#line 1645
    (addr + (last - 1UL))->opt.bind = 1U;
#line 1646
    bind_wildcard = (ngx_uint_t )1;
  } else {
#line 1649
    bind_wildcard = (ngx_uint_t )0;
  }
#line 1652
  i = (ngx_uint_t )0;
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! (i < last)) {
#line 1654
      goto while_break;
    }
#line 1656
    if (bind_wildcard) {
#line 1656
      if (! (addr + i)->opt.bind) {
#line 1657
        i ++;
#line 1658
        goto while_continue;
      }
    }
    {
#line 1661
    ls = ngx_http_add_listening(cf, addr + i);
    }
#line 1662
    if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 1663
      return ((ngx_int_t )-1);
    }
    {
#line 1666
    tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_port_t ));
#line 1666
    hport = (ngx_http_port_t *)tmp;
    }
#line 1667
    if ((unsigned long )hport == (unsigned long )((void *)0)) {
#line 1668
      return ((ngx_int_t )-1);
    }
#line 1671
    ls->servers = (void *)hport;
#line 1673
    hport->naddrs = i + 1UL;
    {
#line 1678
    if ((int )(ls->sockaddr)->sa_family == 10) {
#line 1678
      goto case_10;
    }
#line 1684
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 1679
    tmp___0 = ngx_http_add_addrs6(cf, hport, addr);
    }
#line 1679
    if (tmp___0 != 0L) {
#line 1680
      return ((ngx_int_t )-1);
    }
#line 1682
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1685
    tmp___1 = ngx_http_add_addrs(cf, hport, addr);
    }
#line 1685
    if (tmp___1 != 0L) {
#line 1686
      return ((ngx_int_t )-1);
    }
#line 1688
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1691
    tmp___2 = ngx_clone_listening(cf, ls);
    }
#line 1691
    if (tmp___2 != 0L) {
#line 1692
      return ((ngx_int_t )-1);
    }
#line 1695
    addr ++;
#line 1696
    last --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1699
  return ((ngx_int_t )0);
}
}
#line 1703 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_listening_t *ngx_http_add_listening(ngx_conf_t *cf , ngx_http_conf_addr_t *addr ) 
{ 
  ngx_listening_t *ls ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t *cscf ;

  {
  {
#line 1710
  ls = ngx_create_listening(cf, & addr->opt.sockaddr.sockaddr, addr->opt.socklen);
  }
#line 1712
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 1713
    return ((ngx_listening_t *)((void *)0));
  }
#line 1716
  ls->addr_ntop = 1U;
#line 1718
  ls->handler = & ngx_http_init_connection;
#line 1720
  cscf = addr->default_server;
#line 1721
  ls->pool_size = cscf->connection_pool_size;
#line 1722
  ls->post_accept_timeout = cscf->client_header_timeout;
#line 1724
  clcf = (ngx_http_core_loc_conf_t *)*((cscf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1726
  ls->logp = clcf->error_log;
#line 1727
  ls->log.data = (void *)(& ls->addr_text);
#line 1728
  ls->log.handler = & ngx_accept_log_error;
#line 1743
  ls->backlog = addr->opt.backlog;
#line 1744
  ls->rcvbuf = addr->opt.rcvbuf;
#line 1745
  ls->sndbuf = addr->opt.sndbuf;
#line 1747
  ls->keepalive = addr->opt.so_keepalive;
#line 1749
  ls->keepidle = addr->opt.tcp_keepidle;
#line 1750
  ls->keepintvl = addr->opt.tcp_keepintvl;
#line 1751
  ls->keepcnt = addr->opt.tcp_keepcnt;
#line 1759
  ls->deferred_accept = addr->opt.deferred_accept;
#line 1763
  ls->ipv6only = addr->opt.ipv6only;
#line 1771
  ls->fastopen = addr->opt.fastopen;
#line 1775
  ls->reuseport = addr->opt.reuseport;
#line 1778
  return (ls);
}
}
#line 1782 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_addrs(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_in_addr_t *addrs ;
  struct sockaddr_in *sin ;
  ngx_http_virtual_names_t *vn ;
  void *tmp ;

  {
  {
#line 1791
  hport->addrs = ngx_pcalloc(cf->pool, hport->naddrs * sizeof(ngx_http_in_addr_t ));
  }
#line 1793
  if ((unsigned long )hport->addrs == (unsigned long )((void *)0)) {
#line 1794
    return ((ngx_int_t )-1);
  }
#line 1797
  addrs = (ngx_http_in_addr_t *)hport->addrs;
#line 1799
  i = (ngx_uint_t )0;
  {
#line 1799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1799
    if (! (i < hport->naddrs)) {
#line 1799
      goto while_break;
    }
#line 1801
    sin = & (addr + i)->opt.sockaddr.sockaddr_in;
#line 1802
    (addrs + i)->addr = sin->sin_addr.s_addr;
#line 1803
    (addrs + i)->conf.default_server = (addr + i)->default_server;
#line 1810
    (addrs + i)->conf.proxy_protocol = (addr + i)->opt.proxy_protocol;
#line 1812
    if ((unsigned long )(addr + i)->hash.buckets == (unsigned long )((void *)0)) {
#line 1812
      if ((unsigned long )(addr + i)->wc_head == (unsigned long )((void *)0)) {
#line 1812
        goto _L___0;
      } else
#line 1812
      if ((unsigned long )((addr + i)->wc_head)->hash.buckets == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1812
        if ((unsigned long )(addr + i)->wc_tail == (unsigned long )((void *)0)) {
#line 1812
          goto _L;
        } else
#line 1812
        if ((unsigned long )((addr + i)->wc_tail)->hash.buckets == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 1812
          if ((addr + i)->nregex == 0UL) {
#line 1822
            goto __Cont;
          }
        }
      }
    }
    {
#line 1825
    tmp = ngx_palloc(cf->pool, sizeof(ngx_http_virtual_names_t ));
#line 1825
    vn = (ngx_http_virtual_names_t *)tmp;
    }
#line 1826
    if ((unsigned long )vn == (unsigned long )((void *)0)) {
#line 1827
      return ((ngx_int_t )-1);
    }
#line 1830
    (addrs + i)->conf.virtual_names = vn;
#line 1832
    vn->names.hash = (addr + i)->hash;
#line 1833
    vn->names.wc_head = (addr + i)->wc_head;
#line 1834
    vn->names.wc_tail = (addr + i)->wc_tail;
#line 1836
    vn->nregex = (addr + i)->nregex;
#line 1837
    vn->regex = (addr + i)->regex;
    __Cont: /* CIL Label */ 
#line 1799
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1841
  return ((ngx_int_t )0);
}
}
#line 1847 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_addrs6(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_in6_addr_t *addrs6 ;
  struct sockaddr_in6 *sin6 ;
  ngx_http_virtual_names_t *vn ;
  void *tmp ;

  {
  {
#line 1856
  hport->addrs = ngx_pcalloc(cf->pool, hport->naddrs * sizeof(ngx_http_in6_addr_t ));
  }
#line 1858
  if ((unsigned long )hport->addrs == (unsigned long )((void *)0)) {
#line 1859
    return ((ngx_int_t )-1);
  }
#line 1862
  addrs6 = (ngx_http_in6_addr_t *)hport->addrs;
#line 1864
  i = (ngx_uint_t )0;
  {
#line 1864
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1864
    if (! (i < hport->naddrs)) {
#line 1864
      goto while_break;
    }
#line 1866
    sin6 = & (addr + i)->opt.sockaddr.sockaddr_in6;
#line 1867
    (addrs6 + i)->addr6 = sin6->sin6_addr;
#line 1868
    (addrs6 + i)->conf.default_server = (addr + i)->default_server;
#line 1875
    (addrs6 + i)->conf.proxy_protocol = (addr + i)->opt.proxy_protocol;
#line 1877
    if ((unsigned long )(addr + i)->hash.buckets == (unsigned long )((void *)0)) {
#line 1877
      if ((unsigned long )(addr + i)->wc_head == (unsigned long )((void *)0)) {
#line 1877
        goto _L___0;
      } else
#line 1877
      if ((unsigned long )((addr + i)->wc_head)->hash.buckets == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1877
        if ((unsigned long )(addr + i)->wc_tail == (unsigned long )((void *)0)) {
#line 1877
          goto _L;
        } else
#line 1877
        if ((unsigned long )((addr + i)->wc_tail)->hash.buckets == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 1877
          if ((addr + i)->nregex == 0UL) {
#line 1887
            goto __Cont;
          }
        }
      }
    }
    {
#line 1890
    tmp = ngx_palloc(cf->pool, sizeof(ngx_http_virtual_names_t ));
#line 1890
    vn = (ngx_http_virtual_names_t *)tmp;
    }
#line 1891
    if ((unsigned long )vn == (unsigned long )((void *)0)) {
#line 1892
      return ((ngx_int_t )-1);
    }
#line 1895
    (addrs6 + i)->conf.virtual_names = vn;
#line 1897
    vn->names.hash = (addr + i)->hash;
#line 1898
    vn->names.wc_head = (addr + i)->wc_head;
#line 1899
    vn->names.wc_tail = (addr + i)->wc_tail;
#line 1901
    vn->nregex = (addr + i)->nregex;
#line 1902
    vn->regex = (addr + i)->regex;
    __Cont: /* CIL Label */ 
#line 1864
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1906
  return ((ngx_int_t )0);
}
}
#line 1912 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
char *ngx_http_types_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_array_t **types ;
  ngx_str_t *value ;
  ngx_str_t *default_type ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_hash_key_t *type ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1915
  p = (char *)conf;
#line 1922
  types = (ngx_array_t **)(p + cmd->offset);
#line 1924
  if ((unsigned long )*types == (unsigned long )((void *)-1)) {
#line 1925
    return ((char *)((void *)0));
  }
#line 1928
  default_type = (ngx_str_t *)cmd->post;
#line 1930
  if ((unsigned long )*types == (unsigned long )((void *)0)) {
    {
#line 1931
    *types = ngx_array_create(cf->temp_pool, (ngx_uint_t )1, sizeof(ngx_hash_key_t ));
    }
#line 1932
    if ((unsigned long )*types == (unsigned long )((void *)0)) {
#line 1933
      return ((char *)((void *)-1));
    }
#line 1936
    if (default_type) {
      {
#line 1937
      tmp = ngx_array_push(*types);
#line 1937
      type = (ngx_hash_key_t *)tmp;
      }
#line 1938
      if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 1939
        return ((char *)((void *)-1));
      }
      {
#line 1942
      type->key = *default_type;
#line 1943
      type->key_hash = ngx_hash_key(default_type->data, default_type->len);
#line 1945
      type->value = (void *)4;
      }
    }
  }
#line 1949
  value = (ngx_str_t *)(cf->args)->elts;
#line 1951
  i = (ngx_uint_t )1;
  {
#line 1951
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1951
    if (! (i < (cf->args)->nelts)) {
#line 1951
      goto while_break;
    }
#line 1953
    if ((value + i)->len == 1UL) {
#line 1953
      if ((int )*((value + i)->data + 0) == 42) {
#line 1954
        *types = (ngx_array_t *)((void *)-1);
#line 1955
        return ((char *)((void *)0));
      }
    }
    {
#line 1958
    hash = ngx_hash_strlow((value + i)->data, (value + i)->data, (value + i)->len);
#line 1959
    *((value + i)->data + (value + i)->len) = (u_char )'\000';
#line 1961
    type = (ngx_hash_key_t *)(*types)->elts;
#line 1962
    n = (ngx_uint_t )0;
    }
    {
#line 1962
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1962
      if (! (n < (*types)->nelts)) {
#line 1962
        goto while_break___0;
      }
      {
#line 1964
      tmp___0 = strcmp((char const   *)(value + i)->data, (char const   *)(type + n)->key.data);
      }
#line 1964
      if (tmp___0 == 0) {
        {
#line 1965
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate MIME type \"%V\"", value + i);
        }
#line 1967
        goto next;
      }
#line 1962
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1971
    tmp___1 = ngx_array_push(*types);
#line 1971
    type = (ngx_hash_key_t *)tmp___1;
    }
#line 1972
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 1973
      return ((char *)((void *)-1));
    }
#line 1976
    type->key = *(value + i);
#line 1977
    type->key_hash = hash;
#line 1978
    type->value = (void *)4;
    next: 
#line 1982
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1951
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1985
  return ((char *)((void *)0));
}
}
#line 1989 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
char *ngx_http_merge_types(ngx_conf_t *cf , ngx_array_t **keys , ngx_hash_t *types_hash ,
                           ngx_array_t **prev_keys , ngx_hash_t *prev_types_hash ,
                           ngx_str_t *default_types ) 
{ 
  ngx_hash_init_t hash ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1996
  if (*keys) {
#line 1998
    if ((unsigned long )*keys == (unsigned long )((void *)-1)) {
#line 1999
      return ((char *)((void *)0));
    }
    {
#line 2002
    hash.hash = types_hash;
#line 2003
    hash.key = (ngx_uint_t (*)(u_char *data , size_t___0 len ))((void *)0);
#line 2004
    hash.max_size = (ngx_uint_t )2048;
#line 2005
    hash.bucket_size = (ngx_uint_t )64;
#line 2006
    hash.name = (char *)"test_types_hash";
#line 2007
    hash.pool = cf->pool;
#line 2008
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2010
    tmp = ngx_hash_init(& hash, (ngx_hash_key_t *)(*keys)->elts, (*keys)->nelts);
    }
#line 2010
    if (tmp != 0L) {
#line 2011
      return ((char *)((void *)-1));
    }
#line 2014
    return ((char *)((void *)0));
  }
#line 2017
  if ((unsigned long )prev_types_hash->buckets == (unsigned long )((void *)0)) {
#line 2019
    if ((unsigned long )*prev_keys == (unsigned long )((void *)0)) {
      {
#line 2021
      tmp___0 = ngx_http_set_default_types(cf, prev_keys, default_types);
      }
#line 2021
      if (tmp___0 != 0L) {
#line 2024
        return ((char *)((void *)-1));
      }
    } else
#line 2027
    if ((unsigned long )*prev_keys == (unsigned long )((void *)-1)) {
#line 2028
      *keys = *prev_keys;
#line 2029
      return ((char *)((void *)0));
    }
    {
#line 2032
    hash.hash = prev_types_hash;
#line 2033
    hash.key = (ngx_uint_t (*)(u_char *data , size_t___0 len ))((void *)0);
#line 2034
    hash.max_size = (ngx_uint_t )2048;
#line 2035
    hash.bucket_size = (ngx_uint_t )64;
#line 2036
    hash.name = (char *)"test_types_hash";
#line 2037
    hash.pool = cf->pool;
#line 2038
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2040
    tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)(*prev_keys)->elts, (*prev_keys)->nelts);
    }
#line 2040
    if (tmp___1 != 0L) {
#line 2043
      return ((char *)((void *)-1));
    }
  }
#line 2047
  *types_hash = *prev_types_hash;
#line 2049
  return ((char *)((void *)0));
}
}
#line 2054 "/tmp/nginx-1.13.2/src/http/ngx_http.c"
ngx_int_t ngx_http_set_default_types(ngx_conf_t *cf , ngx_array_t **types , ngx_str_t *default_type ) 
{ 
  ngx_hash_key_t *type ;
  void *tmp ;

  {
  {
#line 2060
  *types = ngx_array_create(cf->temp_pool, (ngx_uint_t )1, sizeof(ngx_hash_key_t ));
  }
#line 2061
  if ((unsigned long )*types == (unsigned long )((void *)0)) {
#line 2062
    return ((ngx_int_t )-1);
  }
  {
#line 2065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2065
    if (! default_type->len) {
#line 2065
      goto while_break;
    }
    {
#line 2067
    tmp = ngx_array_push(*types);
#line 2067
    type = (ngx_hash_key_t *)tmp;
    }
#line 2068
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 2069
      return ((ngx_int_t )-1);
    }
    {
#line 2072
    type->key = *default_type;
#line 2073
    type->key_hash = ngx_hash_key(default_type->data, default_type->len);
#line 2075
    type->value = (void *)4;
#line 2077
    default_type ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2080
  return ((ngx_int_t )0);
}
}
#line 489 "/usr/include/pcre.h"
extern void *(*pcre_malloc)(size_t___0  ) ;
#line 490
extern void (*pcre_free)(void * ) ;
#line 540
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
#line 552
extern int pcre_config(int  , void * ) ;
#line 594
extern int pcre_fullinfo(pcre const   * , pcre_extra const   * , int  , void * ) ;
#line 633
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
#line 636
extern void pcre_free_study(pcre_extra * ) ;
#line 49 "src/core/ngx_regex.h"
void ngx_regex_init(void) ;
#line 17 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static void *ngx_regex_malloc(size_t___0 size ) ;
#line 18
static void ngx_regex_free(void *p ) ;
#line 20
static void ngx_pcre_free_studies(void *data ) ;
#line 23
static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle ) ;
#line 25
static void *ngx_regex_create_conf(ngx_cycle_t *cycle ) ;
#line 26
static char *ngx_regex_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 28
static char *ngx_regex_pcre_jit(ngx_conf_t *cf , void *post , void *data ) ;
#line 29 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static ngx_conf_post_t ngx_regex_pcre_jit_post  =    {& ngx_regex_pcre_jit};
#line 32 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static ngx_command_t ngx_regex_commands[2]  = {      {{sizeof("pcre_jit") - 1UL, (u_char *)"pcre_jit"}, (ngx_uint_t )16843264, & ngx_conf_set_flag_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_regex_conf_t *)0)->pcre_jit), (void *)(& ngx_regex_pcre_jit_post)}, 
        {{(size_t___0 )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 45 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static ngx_core_module_t ngx_regex_module_ctx  =    {{sizeof("regex") - 1UL, (u_char *)"regex"}, & ngx_regex_create_conf, & ngx_regex_init_conf};
#line 52 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
ngx_module_t ngx_regex_module  = 
#line 52
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_regex_module_ctx),
    ngx_regex_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    & ngx_regex_module_init, (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0};
#line 68 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static ngx_pool_t *ngx_pcre_pool  ;
#line 69 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static ngx_list_t *ngx_pcre_studies  ;
#line 72 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
void ngx_regex_init(void) 
{ 


  {
#line 75
  pcre_malloc = & ngx_regex_malloc;
#line 76
  pcre_free = & ngx_regex_free;
#line 77
  return;
}
}
#line 80 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
__inline static void ngx_regex_malloc_init(ngx_pool_t *pool ) 
{ 


  {
#line 83
  ngx_pcre_pool = pool;
#line 84
  return;
}
}
#line 87 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
__inline static void ngx_regex_malloc_done(void) 
{ 


  {
#line 90
  ngx_pcre_pool = (ngx_pool_t *)((void *)0);
#line 91
  return;
}
}
#line 94 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
ngx_int_t ngx_regex_compile(ngx_regex_compile_t *rc ) 
{ 
  int n ;
  int erroff ;
  char *p ;
  pcre *re ;
  char const   *errstr ;
  ngx_regex_elt_t *elt ;
  u_char *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;

  {
  {
#line 103
  ngx_regex_malloc_init(rc->pool);
#line 105
  re = pcre_compile((char const   *)rc->pattern.data, (int )rc->options, & errstr,
                    & erroff, (unsigned char const   *)((void *)0));
#line 109
  ngx_regex_malloc_done();
  }
#line 111
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 112
    if ((size_t___0 )erroff == rc->pattern.len) {
      {
#line 113
      tmp = ngx_snprintf(rc->err.data, rc->err.len, "pcre_compile() failed: %s in \"%V\"",
                         errstr, & rc->pattern);
#line 113
      rc->err.len = (size_t___0 )(tmp - rc->err.data);
      }
    } else {
      {
#line 119
      tmp___0 = ngx_snprintf(rc->err.data, rc->err.len, "pcre_compile() failed: %s in \"%V\" at \"%s\"",
                             errstr, & rc->pattern, rc->pattern.data + erroff);
#line 119
      rc->err.len = (size_t___0 )(tmp___0 - rc->err.data);
      }
    }
#line 125
    return ((ngx_int_t )-1);
  }
  {
#line 128
  tmp___1 = ngx_pcalloc(rc->pool, sizeof(ngx_regex_t ));
#line 128
  rc->regex = (ngx_regex_t *)tmp___1;
  }
#line 129
  if ((unsigned long )rc->regex == (unsigned long )((void *)0)) {
#line 130
    goto nomem;
  }
#line 133
  (rc->regex)->code = re;
#line 137
  if ((unsigned long )ngx_pcre_studies != (unsigned long )((void *)0)) {
    {
#line 138
    tmp___2 = ngx_list_push(ngx_pcre_studies);
#line 138
    elt = (ngx_regex_elt_t *)tmp___2;
    }
#line 139
    if ((unsigned long )elt == (unsigned long )((void *)0)) {
#line 140
      goto nomem;
    }
#line 143
    elt->regex = rc->regex;
#line 144
    elt->name = rc->pattern.data;
  }
  {
#line 147
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 2, (void *)(& rc->captures));
  }
#line 148
  if (n < 0) {
#line 149
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_CAPTURECOUNT) failed: %d";
#line 150
    goto failed;
  }
#line 153
  if (rc->captures == 0) {
#line 154
    return ((ngx_int_t )0);
  }
  {
#line 157
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 8, (void *)(& rc->named_captures));
  }
#line 158
  if (n < 0) {
#line 159
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_NAMECOUNT) failed: %d";
#line 160
    goto failed;
  }
#line 163
  if (rc->named_captures == 0) {
#line 164
    return ((ngx_int_t )0);
  }
  {
#line 167
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 7, (void *)(& rc->name_size));
  }
#line 168
  if (n < 0) {
#line 169
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_NAMEENTRYSIZE) failed: %d";
#line 170
    goto failed;
  }
  {
#line 173
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 9, (void *)(& rc->names));
  }
#line 174
  if (n < 0) {
#line 175
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_NAMETABLE) failed: %d";
#line 176
    goto failed;
  }
#line 179
  return ((ngx_int_t )0);
  failed: 
  {
#line 183
  tmp___3 = ngx_snprintf(rc->err.data, rc->err.len, (char const   *)p, & rc->pattern,
                         n);
#line 183
  rc->err.len = (size_t___0 )(tmp___3 - rc->err.data);
  }
#line 185
  return ((ngx_int_t )-1);
  nomem: 
  {
#line 189
  tmp___4 = ngx_snprintf(rc->err.data, rc->err.len, "regex \"%V\" compilation failed: no memory",
                         & rc->pattern);
#line 189
  rc->err.len = (size_t___0 )(tmp___4 - rc->err.data);
  }
#line 193
  return ((ngx_int_t )-1);
}
}
#line 197 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
ngx_int_t ngx_regex_exec_array(ngx_array_t *a , ngx_str_t *s , ngx_log_t *log ) 
{ 
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_regex_elt_t *re ;
  int tmp ;

  {
#line 204
  re = (ngx_regex_elt_t *)a->elts;
#line 206
  i = (ngx_uint_t )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < a->nelts)) {
#line 206
      goto while_break;
    }
    {
#line 208
    tmp = pcre_exec((pcre const   *)((re + i)->regex)->code, (pcre_extra const   *)((re + i)->regex)->extra,
                    (char const   *)s->data, (int )s->len, 0, 0, (int *)((void *)0),
                    0);
#line 208
    n = (ngx_int_t )tmp;
    }
#line 210
    if (n == -1L) {
#line 211
      goto __Cont;
    }
#line 214
    if (n < 0L) {
#line 215
      if (log->log_level >= 2UL) {
        {
#line 215
        ngx_log_error_core((ngx_uint_t )2, log, 0, "pcre_exec() failed: %i on \"%V\" using \"%s\"",
                           n, s, (re + i)->name);
        }
      }
#line 218
      return ((ngx_int_t )-1);
    }
#line 223
    return ((ngx_int_t )0);
    __Cont: /* CIL Label */ 
#line 206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return ((ngx_int_t )-5);
}
}
#line 230 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static void *ngx_regex_malloc(size_t___0 size ) 
{ 
  ngx_pool_t *pool ;
  void *tmp ;

  {
#line 234
  pool = ngx_pcre_pool;
#line 236
  if (pool) {
    {
#line 237
    tmp = ngx_palloc(pool, size);
    }
#line 237
    return (tmp);
  }
#line 240
  return ((void *)0);
}
}
#line 244 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static void ngx_regex_free(void *p ) 
{ 


  {
#line 247
  return;
}
}
#line 253 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static void ngx_pcre_free_studies(void *data ) 
{ 
  ngx_list_t *studies ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_regex_elt_t *elts ;

  {
#line 256
  studies = (ngx_list_t *)data;
#line 262
  part = & studies->part;
#line 263
  elts = (ngx_regex_elt_t *)part->elts;
#line 265
  i = (ngx_uint_t )0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (i >= part->nelts) {
#line 268
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 269
        goto while_break;
      }
#line 272
      part = part->next;
#line 273
      elts = (ngx_regex_elt_t *)part->elts;
#line 274
      i = (ngx_uint_t )0;
    }
#line 277
    if ((unsigned long )((elts + i)->regex)->extra != (unsigned long )((void *)0)) {
      {
#line 278
      pcre_free_study(((elts + i)->regex)->extra);
      }
    }
#line 265
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 286 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle ) 
{ 
  int opt ;
  char const   *errstr ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_regex_elt_t *elts ;
  ngx_regex_conf_t *rcf ;
  ngx_pool_cleanup_t *cln ;
  int jit ;
  int n ;

  {
#line 295
  opt = 0;
#line 302
  rcf = (ngx_regex_conf_t *)*(cycle->conf_ctx + ngx_regex_module.index);
#line 304
  if (rcf->pcre_jit) {
    {
#line 305
    opt = 1;
#line 313
    cln = ngx_pool_cleanup_add(cycle->pool, (size_t___0 )0);
    }
#line 314
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 315
      return ((ngx_int_t )-1);
    }
#line 318
    cln->handler = & ngx_pcre_free_studies;
#line 319
    cln->data = (void *)ngx_pcre_studies;
  }
  {
#line 324
  ngx_regex_malloc_init(cycle->pool);
#line 326
  part = & ngx_pcre_studies->part;
#line 327
  elts = (ngx_regex_elt_t *)part->elts;
#line 329
  i = (ngx_uint_t )0;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (i >= part->nelts) {
#line 332
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 333
        goto while_break;
      }
#line 336
      part = part->next;
#line 337
      elts = (ngx_regex_elt_t *)part->elts;
#line 338
      i = (ngx_uint_t )0;
    }
    {
#line 341
    ((elts + i)->regex)->extra = pcre_study((pcre const   *)((elts + i)->regex)->code,
                                            opt, & errstr);
    }
#line 343
    if ((unsigned long )errstr != (unsigned long )((void *)0)) {
#line 344
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 344
        ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "pcre_study() failed: %s in \"%s\"",
                           errstr, (elts + i)->name);
        }
      }
    }
#line 350
    if (opt & 1) {
      {
#line 353
      jit = 0;
#line 354
      n = pcre_fullinfo((pcre const   *)((elts + i)->regex)->code, (pcre_extra const   *)((elts + i)->regex)->extra,
                        16, (void *)(& jit));
      }
#line 357
      if (n != 0) {
#line 357
        goto _L;
      } else
#line 357
      if (jit != 1) {
        _L: /* CIL Label */ 
#line 358
        if ((cycle->log)->log_level >= 7UL) {
          {
#line 358
          ngx_log_error_core((ngx_uint_t )7, cycle->log, 0, "JIT compiler does not support pattern: \"%s\"",
                             (elts + i)->name);
          }
        }
      }
    }
#line 329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  ngx_regex_malloc_done();
#line 368
  ngx_pcre_studies = (ngx_list_t *)((void *)0);
  }
#line 370
  return ((ngx_int_t )0);
}
}
#line 374 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static void *ngx_regex_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_regex_conf_t *rcf ;
  void *tmp ;

  {
  {
#line 379
  tmp = ngx_pcalloc(cycle->pool, sizeof(ngx_regex_conf_t ));
#line 379
  rcf = (ngx_regex_conf_t *)tmp;
  }
#line 380
  if ((unsigned long )rcf == (unsigned long )((void *)0)) {
#line 381
    return ((void *)0);
  }
  {
#line 384
  rcf->pcre_jit = (ngx_flag_t )-1;
#line 386
  ngx_pcre_studies = ngx_list_create(cycle->pool, (ngx_uint_t )8, sizeof(ngx_regex_elt_t ));
  }
#line 387
  if ((unsigned long )ngx_pcre_studies == (unsigned long )((void *)0)) {
#line 388
    return ((void *)0);
  }
#line 391
  return ((void *)rcf);
}
}
#line 395 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static char *ngx_regex_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_regex_conf_t *rcf ;

  {
#line 398
  rcf = (ngx_regex_conf_t *)conf;
#line 400
  if (rcf->pcre_jit == -1L) {
#line 400
    rcf->pcre_jit = (ngx_flag_t )0;
  }
#line 402
  return ((char *)((void *)0));
}
}
#line 406 "/tmp/nginx-1.13.2/src/core/ngx_regex.c"
static char *ngx_regex_pcre_jit(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_flag_t *fp ;
  int jit ;
  int r ;

  {
#line 409
  fp = (ngx_flag_t *)data;
#line 411
  if (*fp == 0L) {
#line 412
    return ((char *)((void *)0));
  }
  {
#line 419
  jit = 0;
#line 420
  r = pcre_config(9, (void *)(& jit));
  }
#line 422
  if (r != 0) {
    {
#line 423
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "PCRE library does not support JIT");
#line 425
    *fp = (ngx_flag_t )0;
    }
  } else
#line 422
  if (jit != 1) {
    {
#line 423
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "PCRE library does not support JIT");
#line 425
    *fp = (ngx_flag_t )0;
    }
  }
#line 434
  return ((char *)((void *)0));
}
}
#line 37 "/usr/include/x86_64-linux-gnu/sys/sendfile.h"
extern  __attribute__((__nothrow__)) ssize_t sendfile(int __out_fd , int __in_fd ,
                                                      __off64_t *__offset , size_t___0 __count )  __asm__("sendfile64")  ;
#line 41 "src/os/unix/ngx_socket.h"
int ngx_tcp_nopush(ngx_socket_t s ) ;
#line 166 "src/core/ngx_buf.h"
off_t ngx_chain_coalesce_file(ngx_chain_t **in , off_t limit ) ;
#line 168
ngx_chain_t *ngx_chain_update_sent(ngx_chain_t *in , off_t sent ) ;
#line 71 "src/os/unix/ngx_os.h"
ngx_chain_t *ngx_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in , size_t___0 limit ,
                                       ngx_log_t *log ) ;
#line 75
ssize_t ngx_writev(ngx_connection_t *c , ngx_iovec_t *vec ) ;
#line 12 "src/os/unix/ngx_linux.h"
ngx_chain_t *ngx_linux_sendfile_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_sendfile_chain.c"
static ssize_t ngx_linux_sendfile(ngx_connection_t *c , ngx_buf_t *file , size_t___0 size ) ;
#line 46 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_sendfile_chain.c"
ngx_chain_t *ngx_linux_sendfile_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) 
{ 
  int tcp_nodelay ;
  off_t send___0 ;
  off_t prev_send ;
  size_t___0 file_size ;
  size_t___0 sent ;
  ssize_t n ;
  ngx_err_t err ;
  ngx_buf_t *file ;
  ngx_event_t *wev ;
  ngx_chain_t *cl ;
  ngx_iovec_t header___0 ;
  struct iovec headers[64] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  off_t tmp___3 ;

  {
#line 60
  wev = c->write;
#line 62
  if (! wev->ready) {
#line 63
    return (in);
  }
#line 69
  if (limit == 0L) {
#line 70
    limit = (off_t )(2147483647UL - ngx_pagesize);
  } else
#line 69
  if (limit > (off_t )(2147483647UL - ngx_pagesize)) {
#line 70
    limit = (off_t )(2147483647UL - ngx_pagesize);
  }
#line 74
  send___0 = (off_t )0;
#line 76
  header___0.iovs = headers;
#line 77
  header___0.nalloc = (ngx_uint_t )64;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    prev_send = send___0;
#line 84
    cl = ngx_output_chain_to_iovec(& header___0, in, (size_t___0 )(limit - send___0),
                                   c->log);
    }
#line 86
    if ((unsigned long )cl == (unsigned long )((ngx_chain_t *)-1)) {
#line 87
      return ((ngx_chain_t *)-1);
    }
#line 90
    send___0 = (off_t )((size_t___0 )send___0 + header___0.size);
#line 94
    if (c->tcp_nopush == 0U) {
#line 94
      if (header___0.count != 0UL) {
#line 94
        if (cl) {
#line 94
          if ((cl->buf)->in_file) {
#line 101
            if (c->tcp_nodelay == 1U) {
              {
#line 103
              tcp_nodelay = 0;
#line 105
              tmp___0 = setsockopt(c->fd, 6, 1, (void const   *)(& tcp_nodelay), (socklen_t )sizeof(int ));
              }
#line 105
              if (tmp___0 == -1) {
                {
#line 108
                tmp = __errno_location();
#line 108
                err = *tmp;
                }
#line 116
                if (err != 4) {
                  {
#line 117
                  wev->error = 1U;
#line 118
                  ngx_connection_error(c, err, (char *)"setsockopt(TCP_NODELAY) failed");
                  }
#line 120
                  return ((ngx_chain_t *)-1);
                }
              } else {
#line 124
                c->tcp_nodelay = 0U;
              }
            }
#line 131
            if (c->tcp_nodelay == 0U) {
              {
#line 133
              tmp___2 = ngx_tcp_nopush(c->fd);
              }
#line 133
              if (tmp___2 == -1) {
                {
#line 134
                tmp___1 = __errno_location();
#line 134
                err = *tmp___1;
                }
#line 141
                if (err != 4) {
                  {
#line 142
                  wev->error = 1U;
#line 143
                  ngx_connection_error(c, err, (char *)"setsockopt(TCP_CORK) failed");
                  }
#line 145
                  return ((ngx_chain_t *)-1);
                }
              } else {
#line 149
                c->tcp_nopush = 1U;
              }
            }
          }
        }
      }
    }
#line 159
    if (header___0.count == 0UL) {
#line 159
      if (cl) {
#line 159
        if ((cl->buf)->in_file) {
#line 159
          if (send___0 < limit) {
            {
#line 160
            file = cl->buf;
#line 164
            tmp___3 = ngx_chain_coalesce_file(& cl, limit - send___0);
#line 164
            file_size = (size_t___0 )tmp___3;
#line 166
            send___0 = (off_t )((size_t___0 )send___0 + file_size);
            }
#line 168
            if (file_size == 0UL) {
              {
#line 169
              ngx_debug_point();
              }
#line 170
              return ((ngx_chain_t *)-1);
            }
            {
#line 174
            n = ngx_linux_sendfile(c, file, file_size);
            }
#line 176
            if (n == -1L) {
#line 177
              return ((ngx_chain_t *)-1);
            }
#line 180
            if (n == -4L) {
#line 182
              return (in);
            }
#line 185
            if (n == -2L) {
#line 185
              sent = (size_t___0 )0;
            } else {
#line 185
              sent = (size_t___0 )n;
            }
          } else {
#line 159
            goto _L___1;
          }
        } else {
#line 159
          goto _L___1;
        }
      } else {
#line 159
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 188
      n = ngx_writev(c, & header___0);
      }
#line 190
      if (n == -1L) {
#line 191
        return ((ngx_chain_t *)-1);
      }
#line 194
      if (n == -2L) {
#line 194
        sent = (size_t___0 )0;
      } else {
#line 194
        sent = (size_t___0 )n;
      }
    }
    {
#line 197
    c->sent = (off_t )((size_t___0 )c->sent + sent);
#line 199
    in = ngx_chain_update_sent(in, (off_t )sent);
    }
#line 201
    if (n == -2L) {
#line 202
      wev->ready = 0U;
#line 203
      return (in);
    }
#line 206
    if ((size_t___0 )(send___0 - prev_send) != sent) {
#line 218
      send___0 = (off_t )((size_t___0 )prev_send + sent);
#line 219
      goto __Cont;
    }
#line 222
    if (send___0 >= limit) {
#line 223
      return (in);
    } else
#line 222
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 223
      return (in);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 229 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_sendfile_chain.c"
static ssize_t ngx_linux_sendfile(ngx_connection_t *c , ngx_buf_t *file , size_t___0 size ) 
{ 
  off_t offset ;
  ssize_t n ;
  ngx_err_t err ;
  int *tmp ;

  {
#line 249
  offset = file->file_pos;
  eintr: 
  {
#line 259
  n = sendfile(c->fd, (file->file)->fd, & offset, size);
  }
#line 261
  if (n == -1L) {
    {
#line 262
    tmp = __errno_location();
#line 262
    err = *tmp;
    }
    {
#line 265
    if (err == 11) {
#line 265
      goto case_11;
    }
#line 270
    if (err == 4) {
#line 270
      goto case_4;
    }
#line 275
    goto switch_default;
    case_11: /* CIL Label */ ;
#line 268
    return ((ssize_t )-2);
    case_4: /* CIL Label */ ;
#line 273
    goto eintr;
    switch_default: /* CIL Label */ 
    {
#line 276
    (c->write)->error = 1U;
#line 277
    ngx_connection_error(c, err, (char *)"sendfile() failed");
    }
#line 278
    return ((ssize_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 282
  if (n == 0L) {
#line 288
    if ((c->log)->log_level >= 2UL) {
      {
#line 288
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "sendfile() reported that \"%s\" was truncated at %O",
                         (file->file)->name.data, file->file_pos);
      }
    }
#line 292
    return ((ssize_t )-1);
  }
#line 298
  return (n);
}
}
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 108 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
#line 96 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
extern  __attribute__((__nothrow__)) int epoll_create(int __size ) ;
#line 109
extern  __attribute__((__nothrow__)) int epoll_ctl(int __epfd , int __op , int __fd ,
                                                   struct epoll_event *__event ) ;
#line 123
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
#line 34 "/usr/include/x86_64-linux-gnu/sys/eventfd.h"
extern  __attribute__((__nothrow__)) int eventfd(unsigned int __count , int __flags ) ;
#line 78 "src/os/unix/ngx_os.h"
ngx_os_io_t ngx_os_io ;
#line 199 "src/event/ngx_event.h"
ngx_uint_t ngx_use_epoll_rdhup  ;
#line 495
sig_atomic_t ngx_event_timer_alarm ;
#line 44 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_accept_events ;
#line 104 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_init(ngx_cycle_t *cycle , ngx_msec_t timer ) ;
#line 106
static ngx_int_t ngx_epoll_notify_init(ngx_log_t *log ) ;
#line 107
static void ngx_epoll_notify_handler(ngx_event_t *ev ) ;
#line 110
static void ngx_epoll_test_rdhup(ngx_cycle_t *cycle ) ;
#line 112
static void ngx_epoll_done(ngx_cycle_t *cycle ) ;
#line 113
static ngx_int_t ngx_epoll_add_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
#line 115
static ngx_int_t ngx_epoll_del_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
#line 117
static ngx_int_t ngx_epoll_add_connection(ngx_connection_t *c ) ;
#line 118
static ngx_int_t ngx_epoll_del_connection(ngx_connection_t *c , ngx_uint_t flags ) ;
#line 121
static ngx_int_t ngx_epoll_notify(void (*handler)(ngx_event_t *ev ) ) ;
#line 123
static ngx_int_t ngx_epoll_process_events(ngx_cycle_t *cycle , ngx_msec_t timer ,
                                          ngx_uint_t flags ) ;
#line 130
static void *ngx_epoll_create_conf(ngx_cycle_t *cycle ) ;
#line 131
static char *ngx_epoll_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 133 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static int ep  =    -1;
#line 134 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static struct epoll_event *event_list  ;
#line 135 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_uint_t nevents  ;
#line 138 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static int notify_fd  =    -1;
#line 139 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_event_t notify_event  ;
#line 140 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_connection_t notify_conn  ;
#line 157 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_str_t epoll_name  =    {sizeof("epoll") - 1UL, (u_char *)"epoll"};
#line 159 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_command_t ngx_epoll_commands[3]  = {      {{sizeof("epoll_events") - 1UL, (u_char *)"epoll_events"}, (ngx_uint_t )33554434,
      & ngx_conf_set_num_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_epoll_conf_t *)0)->events),
      (void *)0}, 
        {{sizeof("worker_aio_requests") - 1UL, (u_char *)"worker_aio_requests"}, (ngx_uint_t )33554434,
      & ngx_conf_set_num_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_epoll_conf_t *)0)->aio_requests),
      (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 179 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_event_module_t ngx_epoll_module_ctx  =    {& epoll_name, & ngx_epoll_create_conf, & ngx_epoll_init_conf, {& ngx_epoll_add_event,
                                                                   & ngx_epoll_del_event,
                                                                   & ngx_epoll_add_event,
                                                                   & ngx_epoll_del_event,
                                                                   & ngx_epoll_add_connection,
                                                                   & ngx_epoll_del_connection,
                                                                   & ngx_epoll_notify,
                                                                   & ngx_epoll_process_events,
                                                                   & ngx_epoll_init,
                                                                   & ngx_epoll_done}};
#line 202 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
ngx_module_t ngx_epoll_module  = 
#line 202
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_epoll_module_ctx),
    ngx_epoll_commands, (ngx_uint_t )1414420037, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 322 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_init(ngx_cycle_t *cycle , ngx_msec_t timer ) 
{ 
  ngx_epoll_conf_t *epcf ;
  int *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;

  {
#line 327
  epcf = (ngx_epoll_conf_t *)*(*(*(cycle->conf_ctx + ngx_events_module.index)) + ngx_epoll_module.ctx_index);
#line 329
  if (ep == -1) {
    {
#line 330
    ep = epoll_create((int )(cycle->connection_n / 2UL));
    }
#line 332
    if (ep == -1) {
#line 333
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 333
        tmp = __errno_location();
#line 333
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp, "epoll_create() failed");
        }
      }
#line 335
      return ((ngx_int_t )-1);
    }
    {
#line 339
    tmp___0 = ngx_epoll_notify_init(cycle->log);
    }
#line 339
    if (tmp___0 != 0L) {
#line 340
      ngx_epoll_module_ctx.actions.notify = (ngx_int_t (*)(void (*handler)(ngx_event_t *ev ) ))((void *)0);
    }
    {
#line 349
    ngx_epoll_test_rdhup(cycle);
    }
  }
#line 353
  if (nevents < epcf->events) {
#line 354
    if (event_list) {
      {
#line 355
      free((void *)event_list);
      }
    }
    {
#line 358
    tmp___1 = ngx_alloc(sizeof(struct epoll_event ) * epcf->events, cycle->log);
#line 358
    event_list = (struct epoll_event *)tmp___1;
    }
#line 360
    if ((unsigned long )event_list == (unsigned long )((void *)0)) {
#line 361
      return ((ngx_int_t )-1);
    }
  }
#line 365
  nevents = epcf->events;
#line 367
  ngx_io = ngx_os_io;
#line 369
  ngx_event_actions = ngx_epoll_module_ctx.actions;
#line 372
  ngx_event_flags = (ngx_uint_t )100;
#line 379
  return ((ngx_int_t )0);
}
}
#line 385 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_notify_init(ngx_log_t *log ) 
{ 
  struct epoll_event ee ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 391
  notify_fd = eventfd(0U, 0);
  }
#line 396
  if (notify_fd == -1) {
#line 397
    if (log->log_level >= 1UL) {
      {
#line 397
      tmp = __errno_location();
#line 397
      ngx_log_error_core((ngx_uint_t )1, log, *tmp, "eventfd() failed");
      }
    }
#line 398
    return ((ngx_int_t )-1);
  }
  {
#line 404
  notify_event.handler = & ngx_epoll_notify_handler;
#line 405
  notify_event.log = log;
#line 406
  notify_event.active = 1U;
#line 408
  notify_conn.fd = notify_fd;
#line 409
  notify_conn.read = & notify_event;
#line 410
  notify_conn.log = log;
#line 412
  ee.events = 2147483649U;
#line 413
  ee.data.ptr = (void *)(& notify_conn);
#line 415
  tmp___3 = epoll_ctl(ep, 1, notify_fd, & ee);
  }
#line 415
  if (tmp___3 == -1) {
#line 416
    if (log->log_level >= 1UL) {
      {
#line 416
      tmp___0 = __errno_location();
#line 416
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___0, "epoll_ctl(EPOLL_CTL_ADD, eventfd) failed");
      }
    }
    {
#line 419
    tmp___2 = close(notify_fd);
    }
#line 419
    if (tmp___2 == -1) {
#line 420
      if (log->log_level >= 2UL) {
        {
#line 420
        tmp___1 = __errno_location();
#line 420
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___1, "eventfd close() failed");
        }
      }
    }
#line 424
    return ((ngx_int_t )-1);
  }
#line 427
  return ((ngx_int_t )0);
}
}
#line 431 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static void ngx_epoll_notify_handler(ngx_event_t *ev ) 
{ 
  ssize_t n ;
  uint64_t count ;
  ngx_err_t err ;
  void (*handler)(ngx_event_t *ev ) ;
  int *tmp ;

  {
#line 439
  (ev->index) ++;
#line 439
  if (ev->index == 4294967295UL) {
    {
#line 440
    ev->index = (ngx_uint_t )0;
#line 442
    n = read(notify_fd, (void *)(& count), sizeof(uint64_t ));
#line 444
    tmp = __errno_location();
#line 444
    err = *tmp;
    }
#line 449
    if ((size_t___0 )n != sizeof(uint64_t )) {
#line 450
      if ((ev->log)->log_level >= 2UL) {
        {
#line 450
        ngx_log_error_core((ngx_uint_t )2, ev->log, err, "read() eventfd %d failed",
                           notify_fd);
        }
      }
    }
  }
  {
#line 455
  handler = (void (*)(ngx_event_t *ev ))ev->data;
#line 456
  (*handler)(ev);
  }
#line 457
  return;
}
}
#line 464 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static void ngx_epoll_test_rdhup(ngx_cycle_t *cycle ) 
{ 
  int s[2] ;
  int events ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 470
  tmp___0 = socketpair(1, 1, 0, (int *)(s));
  }
#line 470
  if (tmp___0 == -1) {
#line 471
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 471
      tmp = __errno_location();
#line 471
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "socketpair() failed");
      }
    }
#line 473
    return;
  }
  {
#line 476
  ee.events = 2147491841U;
#line 478
  tmp___2 = epoll_ctl(ep, 1, s[0], & ee);
  }
#line 478
  if (tmp___2 == -1) {
#line 479
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 479
      tmp___1 = __errno_location();
#line 479
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "epoll_ctl() failed");
      }
    }
#line 481
    goto failed;
  }
  {
#line 484
  tmp___4 = close(s[1]);
  }
#line 484
  if (tmp___4 == -1) {
#line 485
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 485
      tmp___3 = __errno_location();
#line 485
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "close() failed");
      }
    }
#line 487
    s[1] = -1;
#line 488
    goto failed;
  }
  {
#line 491
  s[1] = -1;
#line 493
  events = epoll_wait(ep, & ee, 1, 5000);
  }
#line 495
  if (events == -1) {
#line 496
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 496
      tmp___5 = __errno_location();
#line 496
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "epoll_wait() failed");
      }
    }
#line 498
    goto failed;
  }
#line 501
  if (events) {
#line 502
    ngx_use_epoll_rdhup = (ngx_uint_t )(ee.events & 8192U);
  } else
#line 505
  if ((cycle->log)->log_level >= 2UL) {
    {
#line 505
    ngx_log_error_core((ngx_uint_t )2, cycle->log, 110, "epoll_wait() timed out");
    }
  }
  failed: 
#line 515
  if (s[1] != -1) {
    {
#line 515
    tmp___7 = close(s[1]);
    }
#line 515
    if (tmp___7 == -1) {
#line 516
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 516
        tmp___6 = __errno_location();
#line 516
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___6, "close() failed");
        }
      }
    }
  }
  {
#line 520
  tmp___9 = close(s[0]);
  }
#line 520
  if (tmp___9 == -1) {
#line 521
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 521
      tmp___8 = __errno_location();
#line 521
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___8, "close() failed");
      }
    }
  }
#line 524
  return;
}
}
#line 529 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static void ngx_epoll_done(ngx_cycle_t *cycle ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 532
  tmp___0 = close(ep);
  }
#line 532
  if (tmp___0 == -1) {
#line 533
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 533
      tmp = __errno_location();
#line 533
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "epoll close() failed");
      }
    }
  }
  {
#line 537
  ep = -1;
#line 541
  tmp___2 = close(notify_fd);
  }
#line 541
  if (tmp___2 == -1) {
#line 542
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 542
      tmp___1 = __errno_location();
#line 542
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "eventfd close() failed");
      }
    }
  }
  {
#line 546
  notify_fd = -1;
#line 571
  free((void *)event_list);
#line 573
  event_list = (struct epoll_event *)((void *)0);
#line 574
  nevents = (ngx_uint_t )0;
  }
#line 575
  return;
}
}
#line 578 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_add_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) 
{ 
  int op ;
  uint32_t events ;
  uint32_t prev ;
  ngx_event_t *e ;
  ngx_connection_t *c ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;

  {
#line 587
  c = (ngx_connection_t *)ev->data;
#line 589
  events = (uint32_t )event;
#line 591
  if (event == 8193L) {
#line 592
    e = c->write;
#line 593
    prev = (uint32_t )4;
  } else {
#line 599
    e = c->read;
#line 600
    prev = (uint32_t )8193;
  }
#line 606
  if (e->active) {
#line 607
    op = 3;
#line 608
    events |= prev;
  } else {
#line 611
    op = 1;
  }
#line 615
  if (flags & 268435456UL) {
#line 616
    events &= 4294959103U;
  }
  {
#line 620
  ee.events = events | (uint32_t )flags;
#line 621
  ee.data.ptr = (void *)((uintptr_t )c | (unsigned long )ev->instance);
#line 627
  tmp___0 = epoll_ctl(ep, op, c->fd, & ee);
  }
#line 627
  if (tmp___0 == -1) {
#line 628
    if ((ev->log)->log_level >= 2UL) {
      {
#line 628
      tmp = __errno_location();
#line 628
      ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp, "epoll_ctl(%d, %d) failed",
                         op, c->fd);
      }
    }
#line 630
    return ((ngx_int_t )-1);
  }
#line 633
  ev->active = 1U;
#line 638
  return ((ngx_int_t )0);
}
}
#line 642 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_del_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) 
{ 
  int op ;
  uint32_t prev ;
  ngx_event_t *e ;
  ngx_connection_t *c ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;

  {
#line 657
  if (flags & 1UL) {
#line 658
    ev->active = 0U;
#line 659
    return ((ngx_int_t )0);
  }
#line 662
  c = (ngx_connection_t *)ev->data;
#line 664
  if (event == 8193L) {
#line 665
    e = c->write;
#line 666
    prev = (uint32_t )4;
  } else {
#line 669
    e = c->read;
#line 670
    prev = (uint32_t )8193;
  }
#line 673
  if (e->active) {
#line 674
    op = 3;
#line 675
    ee.events = prev | (uint32_t )flags;
#line 676
    ee.data.ptr = (void *)((uintptr_t )c | (unsigned long )ev->instance);
  } else {
#line 679
    op = 2;
#line 680
    ee.events = (uint32_t )0;
#line 681
    ee.data.ptr = (void *)0;
  }
  {
#line 688
  tmp___0 = epoll_ctl(ep, op, c->fd, & ee);
  }
#line 688
  if (tmp___0 == -1) {
#line 689
    if ((ev->log)->log_level >= 2UL) {
      {
#line 689
      tmp = __errno_location();
#line 689
      ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp, "epoll_ctl(%d, %d) failed",
                         op, c->fd);
      }
    }
#line 691
    return ((ngx_int_t )-1);
  }
#line 694
  ev->active = 0U;
#line 696
  return ((ngx_int_t )0);
}
}
#line 700 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_add_connection(ngx_connection_t *c ) 
{ 
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 705
  ee.events = 2147491845U;
#line 706
  ee.data.ptr = (void *)((uintptr_t )c | (unsigned long )(c->read)->instance);
#line 711
  tmp___0 = epoll_ctl(ep, 1, c->fd, & ee);
  }
#line 711
  if (tmp___0 == -1) {
#line 712
    if ((c->log)->log_level >= 2UL) {
      {
#line 712
      tmp = __errno_location();
#line 712
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "epoll_ctl(EPOLL_CTL_ADD, %d) failed",
                         c->fd);
      }
    }
#line 714
    return ((ngx_int_t )-1);
  }
#line 717
  (c->read)->active = 1U;
#line 718
  (c->write)->active = 1U;
#line 720
  return ((ngx_int_t )0);
}
}
#line 724 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_del_connection(ngx_connection_t *c , ngx_uint_t flags ) 
{ 
  int op ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;

  {
#line 736
  if (flags & 1UL) {
#line 737
    (c->read)->active = 0U;
#line 738
    (c->write)->active = 0U;
#line 739
    return ((ngx_int_t )0);
  }
  {
#line 745
  op = 2;
#line 746
  ee.events = (uint32_t )0;
#line 747
  ee.data.ptr = (void *)0;
#line 749
  tmp___0 = epoll_ctl(ep, op, c->fd, & ee);
  }
#line 749
  if (tmp___0 == -1) {
#line 750
    if ((c->log)->log_level >= 2UL) {
      {
#line 750
      tmp = __errno_location();
#line 750
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "epoll_ctl(%d, %d) failed",
                         op, c->fd);
      }
    }
#line 752
    return ((ngx_int_t )-1);
  }
#line 755
  (c->read)->active = 0U;
#line 756
  (c->write)->active = 0U;
#line 758
  return ((ngx_int_t )0);
}
}
#line 767 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static uint64_t inc  =    (uint64_t )1;
#line 764 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_notify(void (*handler)(ngx_event_t *ev ) ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 769
  notify_event.data = (void *)handler;
#line 771
  tmp___0 = write(notify_fd, (void const   *)(& inc), sizeof(uint64_t ));
  }
#line 771
  if ((size_t___0 )tmp___0 != sizeof(uint64_t )) {
#line 772
    if ((notify_event.log)->log_level >= 2UL) {
      {
#line 772
      tmp = __errno_location();
#line 772
      ngx_log_error_core((ngx_uint_t )2, notify_event.log, *tmp, "write() to eventfd %d failed",
                         notify_fd);
      }
    }
#line 774
    return ((ngx_int_t )-1);
  }
#line 777
  return ((ngx_int_t )0);
}
}
#line 783 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_process_events(ngx_cycle_t *cycle , ngx_msec_t timer ,
                                          ngx_uint_t flags ) 
{ 
  int events ;
  uint32_t revents ;
  ngx_int_t instance ;
  ngx_int_t i ;
  ngx_uint_t level ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_queue_t *queue ;
  ngx_connection_t *c ;
  int *tmp ;

  {
  {
#line 800
  events = epoll_wait(ep, event_list, (int )nevents, (int )timer);
  }
#line 802
  if (events == -1) {
    {
#line 802
    tmp = __errno_location();
#line 802
    err = *tmp;
    }
  } else {
#line 802
    err = 0;
  }
#line 804
  if (flags & 1UL) {
    {
#line 805
    ngx_time_update();
    }
  } else
#line 804
  if (ngx_event_timer_alarm) {
    {
#line 805
    ngx_time_update();
    }
  }
#line 808
  if (err) {
#line 809
    if (err == 4) {
#line 811
      if (ngx_event_timer_alarm) {
#line 812
        ngx_event_timer_alarm = 0;
#line 813
        return ((ngx_int_t )0);
      }
#line 816
      level = (ngx_uint_t )7;
    } else {
#line 819
      level = (ngx_uint_t )2;
    }
#line 822
    if ((cycle->log)->log_level >= level) {
      {
#line 822
      ngx_log_error_core(level, cycle->log, err, "epoll_wait() failed");
      }
    }
#line 823
    return ((ngx_int_t )-1);
  }
#line 826
  if (events == 0) {
#line 827
    if (timer != 0xffffffffffffffffUL) {
#line 828
      return ((ngx_int_t )0);
    }
#line 831
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 831
      ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "epoll_wait() returned no events without timeout");
      }
    }
#line 833
    return ((ngx_int_t )-1);
  }
#line 836
  i = (ngx_int_t )0;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < (ngx_int_t )events)) {
#line 836
      goto while_break;
    }
#line 837
    c = (ngx_connection_t *)(event_list + i)->data.ptr;
#line 839
    instance = (ngx_int_t )((uintptr_t )c & 1UL);
#line 840
    c = (ngx_connection_t *)((uintptr_t )c & 0xfffffffffffffffeUL);
#line 842
    rev = c->read;
#line 844
    if (c->fd == -1) {
#line 853
      goto __Cont;
    } else
#line 844
    if ((ngx_int_t )rev->instance != instance) {
#line 853
      goto __Cont;
    }
#line 856
    revents = (event_list + i)->events;
#line 862
    if (revents & 24U) {
#line 872
      revents |= 5U;
    }
#line 883
    if (revents & 1U) {
#line 883
      if (rev->active) {
#line 886
        if (revents & 8192U) {
#line 887
          rev->pending_eof = 1U;
        }
#line 890
        rev->available = 1U;
#line 893
        rev->ready = 1U;
#line 895
        if (flags & 2UL) {
#line 896
          if (rev->accept) {
#line 896
            queue = & ngx_posted_accept_events;
          } else {
#line 896
            queue = & ngx_posted_events;
          }
#line 899
          if (! rev->posted) {
#line 899
            rev->posted = 1U;
#line 899
            rev->queue.prev = queue->prev;
#line 899
            (rev->queue.prev)->next = & rev->queue;
#line 899
            rev->queue.next = queue;
#line 899
            queue->prev = & rev->queue;
          }
        } else {
          {
#line 902
          (*(rev->handler))(rev);
          }
        }
      }
    }
#line 906
    wev = c->write;
#line 908
    if (revents & 4U) {
#line 908
      if (wev->active) {
#line 910
        if (c->fd == -1) {
#line 919
          goto __Cont;
        } else
#line 910
        if ((ngx_int_t )wev->instance != instance) {
#line 919
          goto __Cont;
        }
#line 922
        wev->ready = 1U;
#line 927
        if (flags & 2UL) {
#line 928
          if (! wev->posted) {
#line 928
            wev->posted = 1U;
#line 928
            wev->queue.prev = ngx_posted_events.prev;
#line 928
            (wev->queue.prev)->next = & wev->queue;
#line 928
            wev->queue.next = & ngx_posted_events;
#line 928
            ngx_posted_events.prev = & wev->queue;
          }
        } else {
          {
#line 931
          (*(wev->handler))(wev);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 836
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return ((ngx_int_t )0);
}
}
#line 1026 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static void *ngx_epoll_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_epoll_conf_t *epcf ;
  void *tmp ;

  {
  {
#line 1031
  tmp = ngx_palloc(cycle->pool, sizeof(ngx_epoll_conf_t ));
#line 1031
  epcf = (ngx_epoll_conf_t *)tmp;
  }
#line 1032
  if ((unsigned long )epcf == (unsigned long )((void *)0)) {
#line 1033
    return ((void *)0);
  }
#line 1036
  epcf->events = (ngx_uint_t )-1;
#line 1037
  epcf->aio_requests = (ngx_uint_t )-1;
#line 1039
  return ((void *)epcf);
}
}
#line 1043 "/tmp/nginx-1.13.2/src/event/modules/ngx_epoll_module.c"
static char *ngx_epoll_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_epoll_conf_t *epcf ;

  {
#line 1046
  epcf = (ngx_epoll_conf_t *)conf;
#line 1048
  if (epcf->events == 0xffffffffffffffffUL) {
#line 1048
    epcf->events = (ngx_uint_t )512;
  }
#line 1049
  if (epcf->aio_requests == 0xffffffffffffffffUL) {
#line 1049
    epcf->aio_requests = (ngx_uint_t )32;
  }
#line 1051
  return ((char *)((void *)0));
}
}
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
#line 40 "src/os/unix/ngx_os.h"
ngx_int_t ngx_os_specific_init(ngx_log_t *log ) ;
#line 41
void ngx_os_specific_status(ngx_log_t *log ) ;
#line 46
ssize_t ngx_unix_recv(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
#line 47
ssize_t ngx_readv_chain(ngx_connection_t *c , ngx_chain_t *chain , off_t limit ) ;
#line 48
ssize_t ngx_udp_unix_recv(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
#line 49
ssize_t ngx_unix_send(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
#line 52
ssize_t ngx_udp_unix_send(ngx_connection_t *c , u_char *buf , size_t___0 size ) ;
#line 53
ngx_chain_t *ngx_udp_unix_sendmsg_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
#line 12 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_init.c"
u_char ngx_linux_kern_ostype[50]  ;
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_init.c"
u_char ngx_linux_kern_osrelease[50]  ;
#line 16 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_init.c"
static ngx_os_io_t ngx_linux_io  = 
#line 16
     {& ngx_unix_recv, & ngx_readv_chain, & ngx_udp_unix_recv, & ngx_unix_send, & ngx_udp_unix_send,
    & ngx_udp_unix_sendmsg_chain, & ngx_linux_sendfile_chain, (ngx_uint_t )1};
#line 33 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_init.c"
ngx_int_t ngx_os_specific_init(ngx_log_t *log ) 
{ 
  struct utsname u ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 38
  tmp___0 = uname(& u);
  }
#line 38
  if (tmp___0 == -1) {
#line 39
    if (log->log_level >= 2UL) {
      {
#line 39
      tmp = __errno_location();
#line 39
      ngx_log_error_core((ngx_uint_t )2, log, *tmp, "uname() failed");
      }
    }
#line 40
    return ((ngx_int_t )-1);
  }
  {
#line 43
  ngx_cpystrn(ngx_linux_kern_ostype, (u_char *)(u.sysname), sizeof(ngx_linux_kern_ostype));
#line 46
  ngx_cpystrn(ngx_linux_kern_osrelease, (u_char *)(u.release), sizeof(ngx_linux_kern_osrelease));
#line 49
  ngx_os_io = ngx_linux_io;
  }
#line 51
  return ((ngx_int_t )0);
}
}
#line 55 "/tmp/nginx-1.13.2/src/os/unix/ngx_linux_init.c"
void ngx_os_specific_status(ngx_log_t *log ) 
{ 


  {
#line 58
  if (log->log_level >= 6UL) {
    {
#line 58
    ngx_log_error_core((ngx_uint_t )6, log, 0, "OS: %s %s", ngx_linux_kern_ostype,
                       ngx_linux_kern_osrelease);
    }
  }
#line 60
  return;
}
}
#line 128 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval  const  * __restrict  __new ,
                                                   struct itimerval * __restrict  __old ) ;
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 703
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 720
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 146 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 404 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 196
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 229
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 237
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 197 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 73 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits )  __asm__("setrlimit64")  ;
#line 97
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/prctl.h"
extern  __attribute__((__nothrow__)) int prctl(int __option  , ...) ;
#line 26 "src/os/unix/ngx_setaffinity.h"
void ngx_setaffinity(ngx_cpuset_t *cpu_affinity , ngx_log_t *log ) ;
#line 38 "src/os/unix/ngx_setproctitle.h"
void ngx_setproctitle(char *title___0 ) ;
#line 63 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle , void (*proc)(ngx_cycle_t *cycle ,
                                                              void *data ) , void *data ,
                            char *name , ngx_int_t respawn ) ;
#line 77
int ngx_argc ;
#line 78
char **ngx_argv ;
#line 81 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_pid  ;
#line 82
ngx_socket_t ngx_channel ;
#line 83
ngx_int_t ngx_process_slot ;
#line 84
ngx_int_t ngx_last_process ;
#line 85
ngx_process_t ngx_processes[1024] ;
#line 237 "src/core/ngx_log.h"
ngx_log_t *ngx_log_get_file_log(ngx_log_t *head___0 ) ;
#line 123 "src/core/ngx_cycle.h"
ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle ) ;
#line 125
void ngx_delete_pidfile(ngx_cycle_t *cycle ) ;
#line 127
void ngx_reopen_files(ngx_cycle_t *cycle , ngx_uid_t user ) ;
#line 128
char **ngx_set_environment(ngx_cycle_t *cycle , ngx_uint_t *last ) ;
#line 129
ngx_pid_t ngx_exec_new_binary(ngx_cycle_t *cycle , char * const  *argv ) ;
#line 130
ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n ) ;
#line 133
void ngx_set_shutdown_timer(ngx_cycle_t *cycle ) ;
#line 37 "src/os/unix/ngx_process_cycle.h"
void ngx_master_process_cycle(ngx_cycle_t *cycle ) ;
#line 38
void ngx_single_process_cycle(ngx_cycle_t *cycle ) ;
#line 41 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_process  ;
#line 42 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_worker  ;
#line 44 "src/os/unix/ngx_process_cycle.h"
ngx_pid_t ngx_new_binary  ;
#line 45 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_inherited  ;
#line 46 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_daemonized  ;
#line 47 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_exiting  ;
#line 49 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_reap  ;
#line 50 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_sigio  ;
#line 51 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_sigalrm  ;
#line 52 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_quit  ;
#line 53 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_debug_quit  ;
#line 54 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_terminate  ;
#line 55 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_noaccept  ;
#line 56 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_reconfigure  ;
#line 57 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_reopen  ;
#line 58 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_change_binary  ;
#line 212 "src/core/ngx_connection.h"
void ngx_close_listening_sockets(ngx_cycle_t *cycle ) ;
#line 214
void ngx_close_idle_connections(ngx_cycle_t *cycle ) ;
#line 514 "src/event/ngx_event.h"
void ngx_process_events_and_timers(ngx_cycle_t *cycle ) ;
#line 25 "src/event/ngx_event_timer.h"
ngx_int_t ngx_event_no_timers_left(void) ;
#line 25 "src/os/unix/ngx_channel.h"
ngx_int_t ngx_write_channel(ngx_socket_t s , ngx_channel_t *ch , size_t___0 size ,
                            ngx_log_t *log ) ;
#line 27
ngx_int_t ngx_read_channel(ngx_socket_t s , ngx_channel_t *ch , size_t___0 size ,
                           ngx_log_t *log ) ;
#line 29
ngx_int_t ngx_add_channel_event(ngx_cycle_t *cycle , ngx_fd_t fd , ngx_int_t event ,
                                void (*handler)(ngx_event_t *ev ) ) ;
#line 31
void ngx_close_channel(ngx_fd_t *fd , ngx_log_t *log ) ;
#line 14 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_start_worker_processes(ngx_cycle_t *cycle , ngx_int_t n , ngx_int_t type ) ;
#line 16
static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle , ngx_uint_t respawn ) ;
#line 18
static void ngx_pass_open_channel(ngx_cycle_t *cycle , ngx_channel_t *ch ) ;
#line 19
static void ngx_signal_worker_processes(ngx_cycle_t *cycle , int signo ) ;
#line 20
static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle ) ;
#line 21
static void ngx_master_process_exit(ngx_cycle_t *cycle ) ;
#line 22
static void ngx_worker_process_cycle(ngx_cycle_t *cycle , void *data ) ;
#line 23
static void ngx_worker_process_init(ngx_cycle_t *cycle , ngx_int_t worker ) ;
#line 24
static void ngx_worker_process_exit(ngx_cycle_t *cycle ) ;
#line 25
static void ngx_channel_handler(ngx_event_t *ev ) ;
#line 26
static void ngx_cache_manager_process_cycle(ngx_cycle_t *cycle , void *data ) ;
#line 27
static void ngx_cache_manager_process_handler(ngx_event_t *ev ) ;
#line 28
static void ngx_cache_loader_process_handler(ngx_event_t *ev ) ;
#line 51 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
ngx_uint_t ngx_noaccepting  ;
#line 52 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
ngx_uint_t ngx_restart  ;
#line 55 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static u_char master_process[15]  = 
#line 55
  {      (u_char )'m',      (u_char )'a',      (u_char )'s',      (u_char )'t', 
        (u_char )'e',      (u_char )'r',      (u_char )' ',      (u_char )'p', 
        (u_char )'r',      (u_char )'o',      (u_char )'c',      (u_char )'e', 
        (u_char )'s',      (u_char )'s',      (u_char )'\000'};
#line 58 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static ngx_cache_manager_ctx_t ngx_cache_manager_ctx  =    {& ngx_cache_manager_process_handler, (char *)"cache manager process", (ngx_msec_t )0};
#line 62 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static ngx_cache_manager_ctx_t ngx_cache_loader_ctx  =    {& ngx_cache_loader_process_handler, (char *)"cache loader process", (ngx_msec_t )60000};
#line 67 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static ngx_cycle_t ngx_exit_cycle  ;
#line 68 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static ngx_log_t ngx_exit_log  ;
#line 69 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static ngx_open_file_t ngx_exit_log_file  ;
#line 72 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
void ngx_master_process_cycle(ngx_cycle_t *cycle ) 
{ 
  char *title___0 ;
  u_char *p ;
  size_t___0 size ;
  ngx_int_t i ;
  ngx_uint_t n ;
  ngx_uint_t sigio ;
  sigset_t set ;
  struct itimerval itv ;
  ngx_uint_t live ;
  ngx_msec_t delay ;
  ngx_listening_t *ls ;
  ngx_core_conf_t *ccf ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 87
  sigemptyset(& set);
#line 88
  sigaddset(& set, 17);
#line 89
  sigaddset(& set, 14);
#line 90
  sigaddset(& set, 29);
#line 91
  sigaddset(& set, 2);
#line 92
  sigaddset(& set, 1);
#line 93
  sigaddset(& set, 10);
#line 94
  sigaddset(& set, 28);
#line 95
  sigaddset(& set, 15);
#line 96
  sigaddset(& set, 3);
#line 97
  sigaddset(& set, 12);
#line 99
  tmp___0 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 99
  if (tmp___0 == -1) {
#line 100
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 100
      tmp = __errno_location();
#line 100
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "sigprocmask() failed");
      }
    }
  }
  {
#line 104
  sigemptyset(& set);
#line 107
  size = sizeof(master_process);
#line 109
  i = (ngx_int_t )0;
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 109
    if (! (i < (ngx_int_t )ngx_argc)) {
#line 109
      goto while_break;
    }
    {
#line 110
    tmp___1 = strlen((char const   *)*(ngx_argv + i));
#line 110
    size += tmp___1 + 1UL;
#line 109
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  tmp___2 = ngx_pnalloc(cycle->pool, size);
#line 113
  title___0 = (char *)tmp___2;
  }
#line 114
  if ((unsigned long )title___0 == (unsigned long )((void *)0)) {
    {
#line 116
    exit(2);
    }
  }
  {
#line 119
  tmp___3 = memcpy((void */* __restrict  */)title___0, (void const   */* __restrict  */)(master_process),
                   sizeof(master_process) - 1UL);
#line 119
  p = (u_char *)tmp___3 + (sizeof(master_process) - 1UL);
#line 120
  i = (ngx_int_t )0;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! (i < (ngx_int_t )ngx_argc)) {
#line 120
      goto while_break___0;
    }
    {
#line 121
    tmp___4 = p;
#line 121
    p ++;
#line 121
    *tmp___4 = (u_char )' ';
#line 122
    p = ngx_cpystrn(p, (u_char *)*(ngx_argv + i), size);
#line 120
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 125
  ngx_setproctitle(title___0);
#line 128
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 130
  ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-3);
#line 132
  ngx_start_cache_manager_processes(cycle, (ngx_uint_t )0);
#line 134
  ngx_new_binary = 0;
#line 135
  delay = (ngx_msec_t )0;
#line 136
  sigio = (ngx_uint_t )0;
#line 137
  live = (ngx_uint_t )1;
  }
  {
#line 139
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 140
    if (delay) {
#line 141
      if (ngx_sigalrm) {
#line 142
        sigio = (ngx_uint_t )0;
#line 143
        delay *= 2UL;
#line 144
        ngx_sigalrm = 0;
      }
      {
#line 150
      itv.it_interval.tv_sec = (__time_t )0;
#line 151
      itv.it_interval.tv_usec = (__suseconds_t )0;
#line 152
      itv.it_value.tv_sec = (__time_t )(delay / 1000UL);
#line 153
      itv.it_value.tv_usec = (__suseconds_t )((delay % 1000UL) * 1000UL);
#line 155
      tmp___6 = setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& itv),
                          (struct itimerval */* __restrict  */)((void *)0));
      }
#line 155
      if (tmp___6 == -1) {
#line 156
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 156
          tmp___5 = __errno_location();
#line 156
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "setitimer() failed");
          }
        }
      }
    }
    {
#line 163
    sigsuspend((sigset_t const   *)(& set));
#line 165
    ngx_time_update();
    }
#line 170
    if (ngx_reap) {
      {
#line 171
      ngx_reap = 0;
#line 174
      live = ngx_reap_children(cycle);
      }
    }
#line 177
    if (! live) {
#line 177
      if (ngx_terminate) {
        {
#line 178
        ngx_master_process_exit(cycle);
        }
      } else
#line 177
      if (ngx_quit) {
        {
#line 178
        ngx_master_process_exit(cycle);
        }
      }
    }
#line 181
    if (ngx_terminate) {
#line 182
      if (delay == 0UL) {
#line 183
        delay = (ngx_msec_t )50;
      }
#line 186
      if (sigio) {
#line 187
        sigio --;
#line 188
        goto __Cont;
      }
#line 191
      sigio = (ngx_uint_t )(ccf->worker_processes + 2L);
#line 193
      if (delay > 1000UL) {
        {
#line 194
        ngx_signal_worker_processes(cycle, 9);
        }
      } else {
        {
#line 196
        ngx_signal_worker_processes(cycle, 15);
        }
      }
#line 200
      goto __Cont;
    }
#line 203
    if (ngx_quit) {
      {
#line 204
      ngx_signal_worker_processes(cycle, 3);
#line 207
      ls = (ngx_listening_t *)cycle->listening.elts;
#line 208
      n = (ngx_uint_t )0;
      }
      {
#line 208
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 208
        if (! (n < cycle->listening.nelts)) {
#line 208
          goto while_break___2;
        }
        {
#line 209
        tmp___8 = close((ls + n)->fd);
        }
#line 209
        if (tmp___8 == -1) {
#line 210
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 210
            tmp___7 = __errno_location();
#line 210
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___7, "close() socket %V failed",
                               & (ls + n)->addr_text);
            }
          }
        }
#line 208
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 215
      cycle->listening.nelts = (ngx_uint_t )0;
#line 217
      goto __Cont;
    }
#line 220
    if (ngx_reconfigure) {
#line 221
      ngx_reconfigure = 0;
#line 223
      if (ngx_new_binary) {
        {
#line 224
        ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-3);
#line 226
        ngx_start_cache_manager_processes(cycle, (ngx_uint_t )0);
#line 227
        ngx_noaccepting = (ngx_uint_t )0;
        }
#line 229
        goto __Cont;
      }
#line 232
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 232
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reconfiguring");
        }
      }
      {
#line 234
      cycle = ngx_init_cycle(cycle);
      }
#line 235
      if ((unsigned long )cycle == (unsigned long )((void *)0)) {
#line 236
        cycle = (ngx_cycle_t *)ngx_cycle;
#line 237
        goto __Cont;
      }
      {
#line 240
      ngx_cycle = (ngx_cycle_t volatile   *)cycle;
#line 241
      ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 243
      ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-4);
#line 245
      ngx_start_cache_manager_processes(cycle, (ngx_uint_t )1);
#line 248
      usleep((__useconds_t )100000);
#line 250
      live = (ngx_uint_t )1;
#line 251
      ngx_signal_worker_processes(cycle, 3);
      }
    }
#line 255
    if (ngx_restart) {
      {
#line 256
      ngx_restart = (ngx_uint_t )0;
#line 257
      ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-3);
#line 259
      ngx_start_cache_manager_processes(cycle, (ngx_uint_t )0);
#line 260
      live = (ngx_uint_t )1;
      }
    }
#line 263
    if (ngx_reopen) {
#line 264
      ngx_reopen = 0;
#line 265
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 265
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 266
      ngx_reopen_files(cycle, ccf->user);
#line 267
      ngx_signal_worker_processes(cycle, 10);
      }
    }
#line 271
    if (ngx_change_binary) {
#line 272
      ngx_change_binary = 0;
#line 273
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 273
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "changing binary");
        }
      }
      {
#line 274
      ngx_new_binary = ngx_exec_new_binary(cycle, (char * const  *)ngx_argv);
      }
    }
#line 277
    if (ngx_noaccept) {
      {
#line 278
      ngx_noaccept = 0;
#line 279
      ngx_noaccepting = (ngx_uint_t )1;
#line 280
      ngx_signal_worker_processes(cycle, 3);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 287 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
void ngx_single_process_cycle(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  char **tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 292
  tmp = ngx_set_environment(cycle, (ngx_uint_t *)((void *)0));
  }
#line 292
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 294
    exit(2);
    }
  }
#line 297
  i = (ngx_uint_t )0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! *(cycle->modules + i)) {
#line 297
      goto while_break;
    }
#line 298
    if ((*(cycle->modules + i))->init_process) {
      {
#line 299
      tmp___0 = (*((*(cycle->modules + i))->init_process))(cycle);
      }
#line 299
      if (tmp___0 == -1L) {
        {
#line 301
        exit(2);
        }
      }
    }
#line 297
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 309
    ngx_process_events_and_timers(cycle);
    }
#line 311
    if (ngx_terminate) {
#line 311
      goto _L;
    } else
#line 311
    if (ngx_quit) {
      _L: /* CIL Label */ 
#line 313
      i = (ngx_uint_t )0;
      {
#line 313
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 313
        if (! *(cycle->modules + i)) {
#line 313
          goto while_break___1;
        }
#line 314
        if ((*(cycle->modules + i))->exit_process) {
          {
#line 315
          (*((*(cycle->modules + i))->exit_process))(cycle);
          }
        }
#line 313
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 319
      ngx_master_process_exit(cycle);
      }
    }
#line 322
    if (ngx_reconfigure) {
#line 323
      ngx_reconfigure = 0;
#line 324
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 324
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reconfiguring");
        }
      }
      {
#line 326
      cycle = ngx_init_cycle(cycle);
      }
#line 327
      if ((unsigned long )cycle == (unsigned long )((void *)0)) {
#line 328
        cycle = (ngx_cycle_t *)ngx_cycle;
#line 329
        goto __Cont;
      }
#line 332
      ngx_cycle = (ngx_cycle_t volatile   *)cycle;
    }
#line 335
    if (ngx_reopen) {
#line 336
      ngx_reopen = 0;
#line 337
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 337
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 338
      ngx_reopen_files(cycle, (ngx_uid_t )-1);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 344 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_start_worker_processes(ngx_cycle_t *cycle , ngx_int_t n , ngx_int_t type ) 
{ 
  ngx_int_t i ;
  ngx_channel_t ch ;

  {
#line 350
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 350
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "start worker processes");
    }
  }
  {
#line 352
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
#line 354
  ch.command = (ngx_uint_t )1;
#line 356
  i = (ngx_int_t )0;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    if (! (i < n)) {
#line 356
      goto while_break;
    }
    {
#line 358
    ngx_spawn_process(cycle, & ngx_worker_process_cycle, (void *)i, (char *)"worker process",
                      type);
#line 361
    ch.pid = ngx_processes[ngx_process_slot].pid;
#line 362
    ch.slot = ngx_process_slot;
#line 363
    ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 365
    ngx_pass_open_channel(cycle, & ch);
#line 356
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return;
}
}
#line 370 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle , ngx_uint_t respawn ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t manager ;
  ngx_uint_t loader ;
  ngx_path_t **path ;
  ngx_channel_t ch ;
  int tmp ;
  int tmp___0 ;

  {
#line 377
  manager = (ngx_uint_t )0;
#line 378
  loader = (ngx_uint_t )0;
#line 380
  path = (ngx_path_t **)ngx_cycle->paths.elts;
#line 381
  i = (ngx_uint_t )0;
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! (i < (ngx_uint_t )ngx_cycle->paths.nelts)) {
#line 381
      goto while_break;
    }
#line 383
    if ((*(path + i))->manager) {
#line 384
      manager = (ngx_uint_t )1;
    }
#line 387
    if ((*(path + i))->loader) {
#line 388
      loader = (ngx_uint_t )1;
    }
#line 381
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  if (manager == 0UL) {
#line 393
    return;
  }
#line 396
  if (respawn) {
#line 396
    tmp = -4;
  } else {
#line 396
    tmp = -3;
  }
  {
#line 396
  ngx_spawn_process(cycle, & ngx_cache_manager_process_cycle, (void *)(& ngx_cache_manager_ctx),
                    (char *)"cache manager process", (ngx_int_t )tmp);
#line 400
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
#line 402
  ch.command = (ngx_uint_t )1;
#line 403
  ch.pid = ngx_processes[ngx_process_slot].pid;
#line 404
  ch.slot = ngx_process_slot;
#line 405
  ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 407
  ngx_pass_open_channel(cycle, & ch);
  }
#line 409
  if (loader == 0UL) {
#line 410
    return;
  }
#line 413
  if (respawn) {
#line 413
    tmp___0 = -2;
  } else {
#line 413
    tmp___0 = -1;
  }
  {
#line 413
  ngx_spawn_process(cycle, & ngx_cache_manager_process_cycle, (void *)(& ngx_cache_loader_ctx),
                    (char *)"cache loader process", (ngx_int_t )tmp___0);
#line 417
  ch.command = (ngx_uint_t )1;
#line 418
  ch.pid = ngx_processes[ngx_process_slot].pid;
#line 419
  ch.slot = ngx_process_slot;
#line 420
  ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 422
  ngx_pass_open_channel(cycle, & ch);
  }
#line 423
  return;
}
}
#line 426 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_pass_open_channel(ngx_cycle_t *cycle , ngx_channel_t *ch ) 
{ 
  ngx_int_t i ;

  {
#line 431
  i = (ngx_int_t )0;
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < ngx_last_process)) {
#line 431
      goto while_break;
    }
#line 433
    if (i == ngx_process_slot) {
#line 437
      goto __Cont;
    } else
#line 433
    if (ngx_processes[i].pid == -1) {
#line 437
      goto __Cont;
    } else
#line 433
    if (ngx_processes[i].channel[0] == -1) {
#line 437
      goto __Cont;
    }
    {
#line 448
    ngx_write_channel(ngx_processes[i].channel[0], ch, sizeof(ngx_channel_t ), cycle->log);
    }
    __Cont: /* CIL Label */ 
#line 431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return;
}
}
#line 454 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_signal_worker_processes(ngx_cycle_t *cycle , int signo ) 
{ 
  ngx_int_t i ;
  ngx_err_t err ;
  ngx_channel_t ch ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 461
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
  }
  {
#line 471
  if (signo == 3) {
#line 471
    goto case_3;
  }
#line 475
  if (signo == 15) {
#line 475
    goto case_15;
  }
#line 479
  if (signo == 10) {
#line 479
    goto case_10;
  }
#line 483
  goto switch_default;
  case_3: /* CIL Label */ 
#line 472
  ch.command = (ngx_uint_t )3;
#line 473
  goto switch_break;
  case_15: /* CIL Label */ 
#line 476
  ch.command = (ngx_uint_t )4;
#line 477
  goto switch_break;
  case_10: /* CIL Label */ 
#line 480
  ch.command = (ngx_uint_t )5;
#line 481
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 484
  ch.command = (ngx_uint_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 489
  ch.fd = -1;
#line 492
  i = (ngx_int_t )0;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (i < ngx_last_process)) {
#line 492
      goto while_break;
    }
#line 504
    if (ngx_processes[i].detached) {
#line 505
      goto __Cont;
    } else
#line 504
    if (ngx_processes[i].pid == -1) {
#line 505
      goto __Cont;
    }
#line 508
    if (ngx_processes[i].just_spawn) {
#line 509
      ngx_processes[i].just_spawn = 0U;
#line 510
      goto __Cont;
    }
#line 513
    if (ngx_processes[i].exiting) {
#line 513
      if (signo == 3) {
#line 516
        goto __Cont;
      }
    }
#line 519
    if (ch.command) {
      {
#line 520
      tmp = ngx_write_channel(ngx_processes[i].channel[0], & ch, sizeof(ngx_channel_t ),
                              cycle->log);
      }
#line 520
      if (tmp == 0L) {
#line 524
        if (signo != 10) {
#line 525
          ngx_processes[i].exiting = 1U;
        }
#line 528
        goto __Cont;
      }
    }
    {
#line 535
    tmp___1 = kill(ngx_processes[i].pid, signo);
    }
#line 535
    if (tmp___1 == -1) {
      {
#line 536
      tmp___0 = __errno_location();
#line 536
      err = *tmp___0;
      }
#line 537
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 537
        ngx_log_error_core((ngx_uint_t )2, cycle->log, err, "kill(%P, %d) failed",
                           ngx_processes[i].pid, signo);
        }
      }
#line 540
      if (err == 3) {
#line 541
        ngx_processes[i].exited = 1U;
#line 542
        ngx_processes[i].exiting = 0U;
#line 543
        ngx_reap = 1;
      }
#line 546
      goto __Cont;
    }
#line 549
    if (signo != 10) {
#line 550
      ngx_processes[i].exiting = 1U;
    }
    __Cont: /* CIL Label */ 
#line 492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  return;
}
}
#line 556 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle ) 
{ 
  ngx_int_t i ;
  ngx_int_t n ;
  ngx_uint_t live ;
  ngx_channel_t ch ;
  ngx_core_conf_t *ccf ;
  ngx_pid_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 564
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
#line 566
  ch.command = (ngx_uint_t )2;
#line 567
  ch.fd = -1;
#line 569
  live = (ngx_uint_t )0;
#line 570
  i = (ngx_int_t )0;
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (i < ngx_last_process)) {
#line 570
      goto while_break;
    }
#line 582
    if (ngx_processes[i].pid == -1) {
#line 583
      goto __Cont;
    }
#line 586
    if (ngx_processes[i].exited) {
#line 588
      if (! ngx_processes[i].detached) {
        {
#line 589
        ngx_close_channel(ngx_processes[i].channel, cycle->log);
#line 591
        ngx_processes[i].channel[0] = -1;
#line 592
        ngx_processes[i].channel[1] = -1;
#line 594
        ch.pid = ngx_processes[i].pid;
#line 595
        ch.slot = i;
#line 597
        n = (ngx_int_t )0;
        }
        {
#line 597
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 597
          if (! (n < ngx_last_process)) {
#line 597
            goto while_break___0;
          }
#line 598
          if (ngx_processes[n].exited) {
#line 602
            goto __Cont___0;
          } else
#line 598
          if (ngx_processes[n].pid == -1) {
#line 602
            goto __Cont___0;
          } else
#line 598
          if (ngx_processes[n].channel[0] == -1) {
#line 602
            goto __Cont___0;
          }
          {
#line 611
          ngx_write_channel(ngx_processes[n].channel[0], & ch, sizeof(ngx_channel_t ),
                            cycle->log);
          }
          __Cont___0: /* CIL Label */ 
#line 597
          n ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 616
      if (ngx_processes[i].respawn) {
#line 616
        if (! ngx_processes[i].exiting) {
#line 616
          if (! ngx_terminate) {
#line 616
            if (! ngx_quit) {
              {
#line 621
              tmp = ngx_spawn_process(cycle, ngx_processes[i].proc, ngx_processes[i].data,
                                      ngx_processes[i].name, i);
              }
#line 621
              if (tmp == -1) {
#line 626
                if ((cycle->log)->log_level >= 2UL) {
                  {
#line 626
                  ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "could not respawn %s",
                                     ngx_processes[i].name);
                  }
                }
#line 629
                goto __Cont;
              }
              {
#line 633
              ch.command = (ngx_uint_t )1;
#line 634
              ch.pid = ngx_processes[ngx_process_slot].pid;
#line 635
              ch.slot = ngx_process_slot;
#line 636
              ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 638
              ngx_pass_open_channel(cycle, & ch);
#line 640
              live = (ngx_uint_t )1;
              }
#line 642
              goto __Cont;
            }
          }
        }
      }
#line 645
      if (ngx_processes[i].pid == ngx_new_binary) {
        {
#line 647
        ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 650
        tmp___1 = rename((char const   *)((char *)ccf->oldpid.data), (char const   *)((char *)ccf->pid.data));
        }
#line 650
        if (tmp___1 == -1) {
#line 654
          if ((cycle->log)->log_level >= 2UL) {
            {
#line 654
            tmp___0 = __errno_location();
#line 654
            ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "rename() %s back to %s failed after the new binary process \"%s\" exited",
                               ccf->oldpid.data, ccf->pid.data, *(ngx_argv + 0));
            }
          }
        }
#line 660
        ngx_new_binary = 0;
#line 661
        if (ngx_noaccepting) {
#line 662
          ngx_restart = (ngx_uint_t )1;
#line 663
          ngx_noaccepting = (ngx_uint_t )0;
        }
      }
#line 667
      if (i == ngx_last_process - 1L) {
#line 668
        ngx_last_process --;
      } else {
#line 671
        ngx_processes[i].pid = -1;
      }
    } else
#line 674
    if (ngx_processes[i].exiting) {
#line 675
      live = (ngx_uint_t )1;
    } else
#line 674
    if (! ngx_processes[i].detached) {
#line 675
      live = (ngx_uint_t )1;
    }
    __Cont: /* CIL Label */ 
#line 570
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  return (live);
}
}
#line 683 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_master_process_exit(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_log_t *tmp ;

  {
  {
#line 688
  ngx_delete_pidfile(cycle);
  }
#line 690
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 690
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exit");
    }
  }
#line 692
  i = (ngx_uint_t )0;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! *(cycle->modules + i)) {
#line 692
      goto while_break;
    }
#line 693
    if ((*(cycle->modules + i))->exit_master) {
      {
#line 694
      (*((*(cycle->modules + i))->exit_master))(cycle);
      }
    }
#line 692
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 698
  ngx_close_listening_sockets(cycle);
#line 708
  tmp = ngx_log_get_file_log((ngx_log_t *)ngx_cycle->log);
#line 708
  ngx_exit_log = *tmp;
#line 710
  ngx_exit_log_file.fd = (ngx_exit_log.file)->fd;
#line 711
  ngx_exit_log.file = & ngx_exit_log_file;
#line 712
  ngx_exit_log.next = (ngx_log_t *)((void *)0);
#line 713
  ngx_exit_log.writer = (void (*)(ngx_log_t *log , ngx_uint_t level , u_char *buf ,
                                  size_t___0 len ))((void *)0);
#line 715
  ngx_exit_cycle.log = & ngx_exit_log;
#line 716
  ngx_exit_cycle.files = (ngx_connection_t **)ngx_cycle->files;
#line 717
  ngx_exit_cycle.files_n = (ngx_uint_t )ngx_cycle->files_n;
#line 718
  ngx_cycle = (ngx_cycle_t volatile   *)(& ngx_exit_cycle);
#line 720
  ngx_destroy_pool(cycle->pool);
#line 722
  exit(0);
  }
}
}
#line 726 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_worker_process_cycle(ngx_cycle_t *cycle , void *data ) 
{ 
  ngx_int_t worker ;
  ngx_int_t tmp ;

  {
  {
#line 729
  worker = (intptr_t )data;
#line 731
  ngx_process = (ngx_uint_t )3;
#line 732
  ngx_worker = (ngx_uint_t )worker;
#line 734
  ngx_worker_process_init(cycle, worker);
#line 736
  ngx_setproctitle((char *)"worker process");
  }
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (ngx_exiting) {
      {
#line 741
      tmp = ngx_event_no_timers_left();
      }
#line 741
      if (tmp == 0L) {
#line 742
        if ((cycle->log)->log_level >= 6UL) {
          {
#line 742
          ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exiting");
          }
        }
        {
#line 743
        ngx_worker_process_exit(cycle);
        }
      }
    }
    {
#line 749
    ngx_process_events_and_timers(cycle);
    }
#line 751
    if (ngx_terminate) {
#line 752
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 752
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exiting");
        }
      }
      {
#line 753
      ngx_worker_process_exit(cycle);
      }
    }
#line 756
    if (ngx_quit) {
#line 757
      ngx_quit = 0;
#line 758
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 758
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "gracefully shutting down");
        }
      }
      {
#line 760
      ngx_setproctitle((char *)"worker process is shutting down");
      }
#line 762
      if (! ngx_exiting) {
        {
#line 763
        ngx_exiting = (ngx_uint_t )1;
#line 764
        ngx_set_shutdown_timer(cycle);
#line 765
        ngx_close_listening_sockets(cycle);
#line 766
        ngx_close_idle_connections(cycle);
        }
      }
    }
#line 770
    if (ngx_reopen) {
#line 771
      ngx_reopen = 0;
#line 772
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 772
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 773
      ngx_reopen_files(cycle, (ngx_uid_t )-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 779 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_worker_process_init(ngx_cycle_t *cycle , ngx_int_t worker ) 
{ 
  sigset_t set ;
  ngx_int_t n ;
  ngx_time_t *tp ;
  ngx_uint_t i ;
  ngx_cpuset_t *cpu_affinity ;
  struct rlimit rlmt___0 ;
  ngx_core_conf_t *ccf ;
  ngx_listening_t *ls ;
  char **tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  __uid_t tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  ngx_int_t tmp___19 ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  ngx_int_t tmp___24 ;

  {
  {
#line 791
  tmp = ngx_set_environment(cycle, (ngx_uint_t *)((void *)0));
  }
#line 791
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 793
    exit(2);
    }
  }
#line 796
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 798
  if (worker >= 0L) {
#line 798
    if (ccf->priority != 0) {
      {
#line 799
      tmp___1 = setpriority((__priority_which_t )0, (id_t )0, ccf->priority);
      }
#line 799
      if (tmp___1 == -1) {
#line 800
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 800
          tmp___0 = __errno_location();
#line 800
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "setpriority(%d) failed",
                             ccf->priority);
          }
        }
      }
    }
  }
#line 805
  if (ccf->rlimit_nofile != -1L) {
    {
#line 806
    rlmt___0.rlim_cur = (rlim_t )ccf->rlimit_nofile;
#line 807
    rlmt___0.rlim_max = (rlim_t )ccf->rlimit_nofile;
#line 809
    tmp___3 = setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)(& rlmt___0));
    }
#line 809
    if (tmp___3 == -1) {
#line 810
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 810
        tmp___2 = __errno_location();
#line 810
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___2, "setrlimit(RLIMIT_NOFILE, %i) failed",
                           ccf->rlimit_nofile);
        }
      }
    }
  }
#line 816
  if (ccf->rlimit_core != -1L) {
    {
#line 817
    rlmt___0.rlim_cur = (rlim_t )ccf->rlimit_core;
#line 818
    rlmt___0.rlim_max = (rlim_t )ccf->rlimit_core;
#line 820
    tmp___5 = setrlimit((__rlimit_resource_t )4, (struct rlimit  const  *)(& rlmt___0));
    }
#line 820
    if (tmp___5 == -1) {
#line 821
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 821
        tmp___4 = __errno_location();
#line 821
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___4, "setrlimit(RLIMIT_CORE, %O) failed",
                           ccf->rlimit_core);
        }
      }
    }
  }
  {
#line 827
  tmp___12 = geteuid();
  }
#line 827
  if (tmp___12 == 0U) {
    {
#line 828
    tmp___7 = setgid(ccf->group);
    }
#line 828
    if (tmp___7 == -1) {
#line 829
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 829
        tmp___6 = __errno_location();
#line 829
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___6, "setgid(%d) failed",
                           ccf->group);
        }
      }
      {
#line 832
      exit(2);
      }
    }
    {
#line 835
    tmp___9 = initgroups((char const   *)ccf->username, ccf->group);
    }
#line 835
    if (tmp___9 == -1) {
#line 836
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 836
        tmp___8 = __errno_location();
#line 836
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___8, "initgroups(%s, %d) failed",
                           ccf->username, ccf->group);
        }
      }
    }
    {
#line 841
    tmp___11 = setuid(ccf->user);
    }
#line 841
    if (tmp___11 == -1) {
#line 842
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 842
        tmp___10 = __errno_location();
#line 842
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___10, "setuid(%d) failed",
                           ccf->user);
        }
      }
      {
#line 845
      exit(2);
      }
    }
  }
#line 849
  if (worker >= 0L) {
    {
#line 850
    cpu_affinity = ngx_get_cpu_affinity((ngx_uint_t )worker);
    }
#line 852
    if (cpu_affinity) {
      {
#line 853
      ngx_setaffinity(cpu_affinity, cycle->log);
      }
    }
  }
  {
#line 861
  tmp___14 = prctl(4, 1, 0, 0, 0);
  }
#line 861
  if (tmp___14 == -1) {
#line 862
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 862
      tmp___13 = __errno_location();
#line 862
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___13, "prctl(PR_SET_DUMPABLE) failed");
      }
    }
  }
#line 868
  if (ccf->working_directory.len) {
    {
#line 869
    tmp___16 = chdir((char const   *)((char *)ccf->working_directory.data));
    }
#line 869
    if (tmp___16 == -1) {
#line 870
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 870
        tmp___15 = __errno_location();
#line 870
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___15, "chdir(\"%s\") failed",
                           ccf->working_directory.data);
        }
      }
      {
#line 873
      exit(2);
      }
    }
  }
  {
#line 877
  sigemptyset(& set);
#line 879
  tmp___18 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 879
  if (tmp___18 == -1) {
#line 880
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 880
      tmp___17 = __errno_location();
#line 880
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___17, "sigprocmask() failed");
      }
    }
  }
  {
#line 884
  tp = (ngx_time_t *)ngx_cached_time;
#line 885
  srandom((unsigned int )((unsigned long )((long )((unsigned int )ngx_pid << 16) ^ tp->sec) ^ tp->msec));
#line 891
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 892
  i = (ngx_uint_t )0;
  }
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    if (! (i < cycle->listening.nelts)) {
#line 892
      goto while_break;
    }
#line 893
    (ls + i)->previous = (ngx_listening_t *)((void *)0);
#line 892
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 896
  i = (ngx_uint_t )0;
  {
#line 896
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 896
    if (! *(cycle->modules + i)) {
#line 896
      goto while_break___0;
    }
#line 897
    if ((*(cycle->modules + i))->init_process) {
      {
#line 898
      tmp___19 = (*((*(cycle->modules + i))->init_process))(cycle);
      }
#line 898
      if (tmp___19 == -1L) {
        {
#line 900
        exit(2);
        }
      }
    }
#line 896
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 905
  n = (ngx_int_t )0;
  {
#line 905
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 905
    if (! (n < ngx_last_process)) {
#line 905
      goto while_break___1;
    }
#line 907
    if (ngx_processes[n].pid == -1) {
#line 908
      goto __Cont;
    }
#line 911
    if (n == ngx_process_slot) {
#line 912
      goto __Cont;
    }
#line 915
    if (ngx_processes[n].channel[1] == -1) {
#line 916
      goto __Cont;
    }
    {
#line 919
    tmp___21 = close(ngx_processes[n].channel[1]);
    }
#line 919
    if (tmp___21 == -1) {
#line 920
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 920
        tmp___20 = __errno_location();
#line 920
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___20, "close() channel failed");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 905
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 925
  tmp___23 = close(ngx_processes[ngx_process_slot].channel[0]);
  }
#line 925
  if (tmp___23 == -1) {
#line 926
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 926
      tmp___22 = __errno_location();
#line 926
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___22, "close() channel failed");
      }
    }
  }
  {
#line 934
  tmp___24 = ngx_add_channel_event(cycle, ngx_channel, (ngx_int_t )8193, & ngx_channel_handler);
  }
#line 934
  if (tmp___24 == -1L) {
    {
#line 939
    exit(2);
    }
  }
#line 941
  return;
}
}
#line 944 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_worker_process_exit(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_connection_t *c ;
  ngx_log_t *tmp ;

  {
#line 950
  i = (ngx_uint_t )0;
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    if (! *(cycle->modules + i)) {
#line 950
      goto while_break;
    }
#line 951
    if ((*(cycle->modules + i))->exit_process) {
      {
#line 952
      (*((*(cycle->modules + i))->exit_process))(cycle);
      }
    }
#line 950
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 956
  if (ngx_exiting) {
#line 957
    c = cycle->connections;
#line 958
    i = (ngx_uint_t )0;
    {
#line 958
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 958
      if (! (i < cycle->connection_n)) {
#line 958
        goto while_break___0;
      }
#line 959
      if ((c + i)->fd != -1) {
#line 959
        if ((c + i)->read) {
#line 959
          if (! ((c + i)->read)->accept) {
#line 959
            if (! ((c + i)->read)->channel) {
#line 959
              if (! ((c + i)->read)->resolver) {
#line 965
                if ((cycle->log)->log_level >= 2UL) {
                  {
#line 965
                  ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "*%uA open socket #%d left in connection %ui",
                                     (c + i)->number, (c + i)->fd, i);
                  }
                }
#line 968
                ngx_debug_quit = 1;
              }
            }
          }
        }
      }
#line 958
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 972
    if (ngx_debug_quit) {
#line 973
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 973
        ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "aborting");
        }
      }
      {
#line 974
      ngx_debug_point();
      }
    }
  }
  {
#line 985
  tmp = ngx_log_get_file_log((ngx_log_t *)ngx_cycle->log);
#line 985
  ngx_exit_log = *tmp;
#line 987
  ngx_exit_log_file.fd = (ngx_exit_log.file)->fd;
#line 988
  ngx_exit_log.file = & ngx_exit_log_file;
#line 989
  ngx_exit_log.next = (ngx_log_t *)((void *)0);
#line 990
  ngx_exit_log.writer = (void (*)(ngx_log_t *log , ngx_uint_t level , u_char *buf ,
                                  size_t___0 len ))((void *)0);
#line 992
  ngx_exit_cycle.log = & ngx_exit_log;
#line 993
  ngx_exit_cycle.files = (ngx_connection_t **)ngx_cycle->files;
#line 994
  ngx_exit_cycle.files_n = (ngx_uint_t )ngx_cycle->files_n;
#line 995
  ngx_cycle = (ngx_cycle_t volatile   *)(& ngx_exit_cycle);
#line 997
  ngx_destroy_pool(cycle->pool);
  }
#line 999
  if ((ngx_cycle->log)->log_level >= 6UL) {
    {
#line 999
    ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "exit");
    }
  }
  {
#line 1001
  exit(0);
  }
}
}
#line 1005 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_channel_handler(ngx_event_t *ev ) 
{ 
  ngx_int_t n ;
  ngx_channel_t ch ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 1012
  if (ev->timedout) {
#line 1013
    ev->timedout = 0U;
#line 1014
    return;
  }
#line 1017
  c = (ngx_connection_t *)ev->data;
  {
#line 1021
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1023
    n = ngx_read_channel(c->fd, & ch, sizeof(ngx_channel_t ), ev->log);
    }
#line 1027
    if (n == -1L) {
#line 1029
      if (ngx_event_flags & 64UL) {
        {
#line 1030
        (*(ngx_event_actions.del_conn))(c, (ngx_uint_t )0);
        }
      }
      {
#line 1033
      ngx_close_connection(c);
      }
#line 1034
      return;
    }
#line 1037
    if (ngx_event_flags & 4096UL) {
      {
#line 1038
      tmp = (*(ngx_event_actions.add))(ev, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 1038
      if (tmp == -1L) {
#line 1039
        return;
      }
    }
#line 1043
    if (n == -2L) {
#line 1044
      return;
    }
    {
#line 1052
    if (ch.command == 3UL) {
#line 1052
      goto case_3;
    }
#line 1056
    if (ch.command == 4UL) {
#line 1056
      goto case_4;
    }
#line 1060
    if (ch.command == 5UL) {
#line 1060
      goto case_5;
    }
#line 1064
    if (ch.command == 1UL) {
#line 1064
      goto case_1;
    }
#line 1074
    if (ch.command == 2UL) {
#line 1074
      goto case_2;
    }
#line 1050
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1053
    ngx_quit = 1;
#line 1054
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1057
    ngx_terminate = 1;
#line 1058
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1061
    ngx_reopen = 1;
#line 1062
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1070
    ngx_processes[ch.slot].pid = ch.pid;
#line 1071
    ngx_processes[ch.slot].channel[0] = ch.fd;
#line 1072
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1081
    tmp___1 = close(ngx_processes[ch.slot].channel[0]);
    }
#line 1081
    if (tmp___1 == -1) {
#line 1082
      if ((ev->log)->log_level >= 2UL) {
        {
#line 1082
        tmp___0 = __errno_location();
#line 1082
        ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___0, "close() channel failed");
        }
      }
    }
#line 1086
    ngx_processes[ch.slot].channel[0] = -1;
#line 1087
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1093 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_cache_manager_process_cycle(ngx_cycle_t *cycle , void *data ) 
{ 
  ngx_cache_manager_ctx_t *ctx ;
  void *ident[4] ;
  ngx_event_t ev ;

  {
  {
#line 1096
  ctx = (ngx_cache_manager_ctx_t *)data;
#line 1105
  ngx_process = (ngx_uint_t )4;
#line 1107
  ngx_close_listening_sockets(cycle);
#line 1110
  cycle->connection_n = (ngx_uint_t )512;
#line 1112
  ngx_worker_process_init(cycle, (ngx_int_t )-1);
#line 1114
  memset((void *)(& ev), 0, sizeof(ngx_event_t ));
#line 1115
  ev.handler = ctx->handler;
#line 1116
  ev.data = (void *)(ident);
#line 1117
  ev.log = cycle->log;
#line 1118
  ident[3] = (void *)-1;
#line 1120
  ngx_use_accept_mutex = (ngx_uint_t )0;
#line 1122
  ngx_setproctitle(ctx->name);
#line 1124
  ngx_event_add_timer(& ev, ctx->delay);
  }
  {
#line 1126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    if (ngx_terminate) {
#line 1128
      goto _L;
    } else
#line 1128
    if (ngx_quit) {
      _L: /* CIL Label */ 
#line 1129
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 1129
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exiting");
        }
      }
      {
#line 1130
      exit(0);
      }
    }
#line 1133
    if (ngx_reopen) {
#line 1134
      ngx_reopen = 0;
#line 1135
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 1135
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 1136
      ngx_reopen_files(cycle, (ngx_uid_t )-1);
      }
    }
    {
#line 1139
    ngx_process_events_and_timers(cycle);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1144 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_cache_manager_process_handler(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_msec_t next ;
  ngx_msec_t n ;
  ngx_path_t **path ;

  {
#line 1151
  next = (ngx_msec_t )3600000;
#line 1153
  path = (ngx_path_t **)ngx_cycle->paths.elts;
#line 1154
  i = (ngx_uint_t )0;
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1154
    if (! (i < (ngx_uint_t )ngx_cycle->paths.nelts)) {
#line 1154
      goto while_break;
    }
#line 1156
    if ((*(path + i))->manager) {
      {
#line 1157
      n = (*((*(path + i))->manager))((*(path + i))->data);
      }
#line 1159
      if (n <= next) {
#line 1159
        next = n;
      } else {
#line 1159
        next = next;
      }
      {
#line 1161
      ngx_time_update();
      }
    }
#line 1154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1165
  if (next == 0UL) {
#line 1166
    next = (ngx_msec_t )1;
  }
  {
#line 1169
  ngx_event_add_timer(ev, next);
  }
#line 1170
  return;
}
}
#line 1173 "/tmp/nginx-1.13.2/src/os/unix/ngx_process_cycle.c"
static void ngx_cache_loader_process_handler(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_path_t **path ;
  ngx_cycle_t *cycle ;

  {
#line 1180
  cycle = (ngx_cycle_t *)ngx_cycle;
#line 1182
  path = (ngx_path_t **)cycle->paths.elts;
#line 1183
  i = (ngx_uint_t )0;
  {
#line 1183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1183
    if (! (i < cycle->paths.nelts)) {
#line 1183
      goto while_break;
    }
#line 1185
    if (ngx_terminate) {
#line 1186
      goto while_break;
    } else
#line 1185
    if (ngx_quit) {
#line 1186
      goto while_break;
    }
#line 1189
    if ((*(path + i))->loader) {
      {
#line 1190
      (*((*(path + i))->loader))((*(path + i))->data);
#line 1191
      ngx_time_update();
      }
    }
#line 1183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1195
  exit(0);
  }
}
}
#line 82 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
#line 27 "src/os/unix/ngx_dlopen.h"
char *ngx_dlerror(void) ;
#line 14 "/tmp/nginx-1.13.2/src/os/unix/ngx_dlopen.c"
char *ngx_dlerror(void) 
{ 
  char *err ;
  char *tmp ;

  {
  {
#line 19
  tmp = dlerror();
#line 19
  err = tmp;
  }
#line 21
  if ((unsigned long )err == (unsigned long )((void *)0)) {
#line 22
    return ((char *)"");
  }
#line 25
  return (err);
}
}
#line 60 "/usr/include/crypt.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2,3))) crypt_r)(char const   *__key ,
                                                                                          char const   *__salt ,
                                                                                          struct crypt_data * __restrict  __data ) ;
#line 20 "src/os/unix/ngx_user.h"
ngx_int_t ngx_libc_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 26 "/tmp/nginx-1.13.2/src/os/unix/ngx_user.c"
ngx_int_t ngx_libc_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  char *value ;
  size_t___0 len ;
  struct crypt_data cd ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 33
  cd.initialized = 0;
#line 36
  cd.current_salt[0] = (char )(~ ((int )*(salt + 0)));
#line 39
  value = crypt_r((char const   *)((char *)key), (char const   *)((char *)salt), (struct crypt_data */* __restrict  */)(& cd));
  }
#line 41
  if (value) {
    {
#line 42
    tmp = strlen((char const   *)value);
#line 42
    len = tmp + 1UL;
#line 44
    tmp___0 = ngx_pnalloc(pool, len);
#line 44
    *encrypted = (u_char *)tmp___0;
    }
#line 45
    if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 46
      return ((ngx_int_t )-1);
    }
    {
#line 49
    memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)value,
           len);
    }
#line 50
    return ((ngx_int_t )0);
  }
#line 53
  if ((pool->log)->log_level >= 3UL) {
    {
#line 53
    tmp___1 = __errno_location();
#line 53
    ngx_log_error_core((ngx_uint_t )3, pool->log, *tmp___1, "crypt_r() failed");
    }
  }
#line 55
  return ((ngx_int_t )-1);
}
}
#line 622 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
#line 979
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits )  __asm__("getrlimit64")  ;
#line 37 "src/os/unix/ngx_setproctitle.h"
ngx_int_t ngx_init_setproctitle(ngx_log_t *log ) ;
#line 41 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize_shift ;
#line 38 "src/os/unix/ngx_os.h"
ngx_int_t ngx_os_init(ngx_log_t *log ) ;
#line 39
void ngx_os_status(ngx_log_t *log ) ;
#line 50
ngx_chain_t *ngx_writev_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
#line 79 "src/os/unix/ngx_os.h"
ngx_int_t ngx_ncpu  ;
#line 80 "src/os/unix/ngx_os.h"
ngx_int_t ngx_max_sockets  ;
#line 81 "src/os/unix/ngx_os.h"
ngx_uint_t ngx_inherited_nonblocking  ;
#line 82 "src/os/unix/ngx_os.h"
ngx_uint_t ngx_tcp_nodelay_and_tcp_nopush  ;
#line 103 "src/core/ngx_core.h"
void ngx_cpuinfo(void) ;
#line 19 "/tmp/nginx-1.13.2/src/os/unix/ngx_posix_init.c"
struct rlimit rlmt  ;
#line 22 "/tmp/nginx-1.13.2/src/os/unix/ngx_posix_init.c"
ngx_os_io_t ngx_os_io  = 
#line 22
     {& ngx_unix_recv, & ngx_readv_chain, & ngx_udp_unix_recv, & ngx_unix_send, & ngx_udp_unix_send,
    & ngx_udp_unix_sendmsg_chain, & ngx_writev_chain, (ngx_uint_t )0};
#line 34 "/tmp/nginx-1.13.2/src/os/unix/ngx_posix_init.c"
ngx_int_t ngx_os_init(ngx_log_t *log ) 
{ 
  ngx_time_t *tp ;
  ngx_uint_t n ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 41
  tmp = ngx_os_specific_init(log);
  }
#line 41
  if (tmp != 0L) {
#line 42
    return ((ngx_int_t )-1);
  }
  {
#line 46
  tmp___0 = ngx_init_setproctitle(log);
  }
#line 46
  if (tmp___0 != 0L) {
#line 47
    return ((ngx_int_t )-1);
  }
  {
#line 50
  tmp___1 = getpagesize();
#line 50
  ngx_pagesize = (ngx_uint_t )tmp___1;
#line 51
  ngx_cacheline_size = (ngx_uint_t )64;
#line 53
  n = ngx_pagesize;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    n >>= 1;
#line 53
    if (! n) {
#line 53
      goto while_break;
    }
#line 53
    ngx_pagesize_shift ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  if (ngx_ncpu == 0L) {
    {
#line 57
    ngx_ncpu = sysconf(84);
    }
  }
#line 61
  if (ngx_ncpu < 1L) {
#line 62
    ngx_ncpu = (ngx_int_t )1;
  }
  {
#line 65
  ngx_cpuinfo();
#line 67
  tmp___3 = getrlimit((__rlimit_resource_t )7, & rlmt);
  }
#line 67
  if (tmp___3 == -1) {
#line 68
    if (log->log_level >= 2UL) {
      {
#line 68
      tmp___2 = __errno_location();
#line 68
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___2, "getrlimit(RLIMIT_NOFILE) failed");
      }
    }
#line 70
    return ((ngx_int_t )-1);
  }
  {
#line 73
  ngx_max_sockets = (ngx_int_t )rlmt.rlim_cur;
#line 76
  ngx_inherited_nonblocking = (ngx_uint_t )1;
#line 81
  tp = (ngx_time_t *)ngx_cached_time;
#line 82
  srandom((unsigned int )((unsigned long )((long )((unsigned int )ngx_pid << 16) ^ tp->sec) ^ tp->msec));
  }
#line 84
  return ((ngx_int_t )0);
}
}
#line 88 "/tmp/nginx-1.13.2/src/os/unix/ngx_posix_init.c"
void ngx_os_status(ngx_log_t *log ) 
{ 


  {
#line 91
  if (log->log_level >= 6UL) {
    {
#line 91
    ngx_log_error_core((ngx_uint_t )6, log, 0, "nginx/1.13.2");
    }
  }
#line 94
  if (log->log_level >= 6UL) {
    {
#line 94
    ngx_log_error_core((ngx_uint_t )6, log, 0, "built by clang 11.0.0 (https://github.com/llvm/llvm-project.git 48a8c7dcbfb90e917920e90fa2b3ec402e72f4cd)");
    }
  }
  {
#line 98
  ngx_os_specific_status(log);
  }
#line 101
  if (log->log_level >= 6UL) {
    {
#line 101
    ngx_log_error_core((ngx_uint_t )6, log, 0, "getrlimit(RLIMIT_NOFILE): %r:%r",
                       rlmt.rlim_cur, rlmt.rlim_max);
    }
  }
#line 104
  return;
}
}
#line 548 "/usr/include/unistd.h"
extern char **environ ;
#line 79 "src/os/unix/ngx_process.h"
char **ngx_os_argv ;
#line 32 "/tmp/nginx-1.13.2/src/os/unix/ngx_setproctitle.c"
static char *ngx_os_argv_last  ;
#line 34 "/tmp/nginx-1.13.2/src/os/unix/ngx_setproctitle.c"
ngx_int_t ngx_init_setproctitle(ngx_log_t *log ) 
{ 
  u_char *p ;
  size_t___0 size ;
  ngx_uint_t i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 41
  size = (size_t___0 )0;
#line 43
  i = (ngx_uint_t )0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! *(environ + i)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp = strlen((char const   *)*(environ + i));
#line 44
    size += tmp + 1UL;
#line 43
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp___0 = ngx_alloc(size, log);
#line 47
  p = (u_char *)tmp___0;
  }
#line 48
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 49
    return ((ngx_int_t )-1);
  }
#line 52
  ngx_os_argv_last = *(ngx_os_argv + 0);
#line 54
  i = (ngx_uint_t )0;
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! *(ngx_os_argv + i)) {
#line 54
      goto while_break___0;
    }
#line 55
    if ((unsigned long )ngx_os_argv_last == (unsigned long )*(ngx_os_argv + i)) {
      {
#line 56
      tmp___1 = strlen((char const   *)*(ngx_os_argv + i));
#line 56
      ngx_os_argv_last = (*(ngx_os_argv + i) + tmp___1) + 1;
      }
    }
#line 54
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 60
  i = (ngx_uint_t )0;
  {
#line 60
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! *(environ + i)) {
#line 60
      goto while_break___1;
    }
#line 61
    if ((unsigned long )ngx_os_argv_last == (unsigned long )*(environ + i)) {
      {
#line 63
      tmp___2 = strlen((char const   *)*(environ + i));
#line 63
      size = tmp___2 + 1UL;
#line 64
      ngx_os_argv_last = *(environ + i) + size;
#line 66
      ngx_cpystrn(p, (u_char *)*(environ + i), size);
#line 67
      *(environ + i) = (char *)p;
#line 68
      p += size;
      }
    }
#line 60
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 72
  ngx_os_argv_last --;
#line 74
  return ((ngx_int_t )0);
}
}
#line 78 "/tmp/nginx-1.13.2/src/os/unix/ngx_setproctitle.c"
void ngx_setproctitle(char *title___0 ) 
{ 
  u_char *p ;

  {
  {
#line 90
  *(ngx_os_argv + 1) = (char *)((void *)0);
#line 92
  p = ngx_cpystrn((u_char *)*(ngx_os_argv + 0), (u_char *)"nginx: ", (size_t___0 )(ngx_os_argv_last - *(ngx_os_argv + 0)));
#line 95
  p = ngx_cpystrn(p, (u_char *)title___0, (size_t___0 )(ngx_os_argv_last - (char *)p));
  }
#line 127
  if (ngx_os_argv_last - (char *)p) {
    {
#line 128
    memset((void *)p, '\000', (size_t )(ngx_os_argv_last - (char *)p));
    }
  }
#line 133
  return;
}
}
#line 121 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setaffinity(__pid_t __pid , size_t___0 __cpusetsize ,
                                                           cpu_set_t const   *__cpuset ) ;
#line 35 "/tmp/nginx-1.13.2/src/os/unix/ngx_setaffinity.c"
void ngx_setaffinity(ngx_cpuset_t *cpu_affinity , ngx_log_t *log ) 
{ 
  ngx_uint_t i ;
  size_t___0 __cpu ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 40
  i = (ngx_uint_t )0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < 1024UL)) {
#line 40
      goto while_break;
    }
#line 41
    __cpu = i;
#line 41
    if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 41
      tmp = (*((__cpu_mask const   *)(cpu_affinity->__bits) + __cpu / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu % (8UL * sizeof(__cpu_mask )))) != 0UL;
    } else {
#line 41
      tmp = 0;
    }
#line 41
    if (tmp) {
#line 42
      if (log->log_level >= 6UL) {
        {
#line 42
        ngx_log_error_core((ngx_uint_t )6, log, 0, "sched_setaffinity(): using cpu #%ui",
                           i);
        }
      }
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp___1 = sched_setaffinity(0, sizeof(cpu_set_t ), (cpu_set_t const   *)cpu_affinity);
  }
#line 47
  if (tmp___1 == -1) {
#line 48
    if (log->log_level >= 2UL) {
      {
#line 48
      tmp___0 = __errno_location();
#line 48
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___0, "sched_setaffinity() failed");
      }
    }
  }
#line 51
  return;
}
}
#line 537 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 670
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 759
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 42 "src/os/unix/ngx_os.h"
ngx_int_t ngx_daemon(ngx_log_t *log ) ;
#line 12 "/tmp/nginx-1.13.2/src/os/unix/ngx_daemon.c"
ngx_int_t ngx_daemon(ngx_log_t *log ) 
{ 
  int fd ;
  __pid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 17
  tmp = fork();
  }
  {
#line 18
  if (tmp == -1) {
#line 18
    goto case_neg_1;
  }
#line 22
  if (tmp == 0) {
#line 22
    goto case_0;
  }
#line 25
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 19
  if (log->log_level >= 1UL) {
    {
#line 19
    tmp___0 = __errno_location();
#line 19
    ngx_log_error_core((ngx_uint_t )1, log, *tmp___0, "fork() failed");
    }
  }
#line 20
  return ((ngx_int_t )-1);
  case_0: /* CIL Label */ 
#line 23
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 26
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 29
  ngx_pid = getpid();
#line 31
  tmp___2 = setsid();
  }
#line 31
  if (tmp___2 == -1) {
#line 32
    if (log->log_level >= 1UL) {
      {
#line 32
      tmp___1 = __errno_location();
#line 32
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___1, "setsid() failed");
      }
    }
#line 33
    return ((ngx_int_t )-1);
  }
  {
#line 36
  umask((__mode_t )0);
#line 38
  fd = open("/dev/null", 2);
  }
#line 39
  if (fd == -1) {
#line 40
    if (log->log_level >= 1UL) {
      {
#line 40
      tmp___3 = __errno_location();
#line 40
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___3, "open(\"/dev/null\") failed");
      }
    }
#line 42
    return ((ngx_int_t )-1);
  }
  {
#line 45
  tmp___5 = dup2(fd, 0);
  }
#line 45
  if (tmp___5 == -1) {
#line 46
    if (log->log_level >= 1UL) {
      {
#line 46
      tmp___4 = __errno_location();
#line 46
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___4, "dup2(STDIN) failed");
      }
    }
#line 47
    return ((ngx_int_t )-1);
  }
  {
#line 50
  tmp___7 = dup2(fd, 1);
  }
#line 50
  if (tmp___7 == -1) {
#line 51
    if (log->log_level >= 1UL) {
      {
#line 51
      tmp___6 = __errno_location();
#line 51
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___6, "dup2(STDOUT) failed");
      }
    }
#line 52
    return ((ngx_int_t )-1);
  }
#line 62
  if (fd > 2) {
    {
#line 63
    tmp___9 = close(fd);
    }
#line 63
    if (tmp___9 == -1) {
#line 64
      if (log->log_level >= 1UL) {
        {
#line 64
        tmp___8 = __errno_location();
#line 64
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___8, "close() failed");
        }
      }
#line 65
      return ((ngx_int_t )-1);
    }
  }
#line 69
  return ((ngx_int_t )0);
}
}
#line 554 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execve)(char const   *__path ,
                                                                                     char * const  *__argv ,
                                                                                     char * const  *__envp ) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 123 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 240
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 25 "src/os/unix/ngx_socket.h"
int ngx_nonblocking(ngx_socket_t s ) ;
#line 65 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_execute(ngx_cycle_t *cycle , ngx_exec_ctx_t *ctx ) ;
#line 66
ngx_int_t ngx_init_signals(ngx_log_t *log ) ;
#line 77 "src/os/unix/ngx_process.h"
int ngx_argc  ;
#line 78 "src/os/unix/ngx_process.h"
char **ngx_argv  ;
#line 79 "src/os/unix/ngx_process.h"
char **ngx_os_argv  ;
#line 82 "src/os/unix/ngx_process.h"
ngx_socket_t ngx_channel  ;
#line 83 "src/os/unix/ngx_process.h"
ngx_int_t ngx_process_slot  ;
#line 84 "src/os/unix/ngx_process.h"
ngx_int_t ngx_last_process  ;
#line 85 "src/os/unix/ngx_process.h"
ngx_process_t ngx_processes[1024]  ;
#line 25 "src/core/ngx_times.h"
void ngx_time_sigsafe_update(void) ;
#line 46 "src/core/ngx_shmtx.h"
ngx_uint_t ngx_shmtx_force_unlock(ngx_shmtx_t *mtx , ngx_pid_t pid ) ;
#line 43 "src/os/unix/ngx_os.h"
ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle , char *name , ngx_pid_t pid ) ;
#line 469 "src/event/ngx_event.h"
ngx_atomic_t *ngx_accept_mutex_ptr ;
#line 470
ngx_shmtx_t ngx_accept_mutex ;
#line 23 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
static void ngx_execute_proc(ngx_cycle_t *cycle , void *data ) ;
#line 24
static void ngx_signal_handler(int signo , siginfo_t *siginfo , void *ucontext ) ;
#line 25
static void ngx_process_get_status(void) ;
#line 26
static void ngx_unlock_mutexes(ngx_pid_t pid ) ;
#line 39 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
ngx_signal_t signals[13]  = 
#line 39
  {      {1, (char *)"SIGHUP", (char *)"reload", & ngx_signal_handler}, 
        {10, (char *)"SIGUSR1", (char *)"reopen", & ngx_signal_handler}, 
        {28, (char *)"SIGWINCH", (char *)"", & ngx_signal_handler}, 
        {15, (char *)"SIGTERM", (char *)"stop", & ngx_signal_handler}, 
        {3, (char *)"SIGQUIT", (char *)"quit", & ngx_signal_handler}, 
        {12, (char *)"SIGUSR2", (char *)"", & ngx_signal_handler}, 
        {14, (char *)"SIGALRM", (char *)"", & ngx_signal_handler}, 
        {2, (char *)"SIGINT", (char *)"", & ngx_signal_handler}, 
        {29, (char *)"SIGIO", (char *)"", & ngx_signal_handler}, 
        {17, (char *)"SIGCHLD", (char *)"", & ngx_signal_handler}, 
        {31, (char *)"SIGSYS, SIG_IGN", (char *)"", (void (*)(int signo , siginfo_t *siginfo ,
                                                           void *ucontext ))((void *)0)}, 
        {13,
      (char *)"SIGPIPE, SIG_IGN", (char *)"", (void (*)(int signo , siginfo_t *siginfo ,
                                                        void *ucontext ))((void *)0)}, 
        {0,
      (char *)((void *)0), (char *)"", (void (*)(int signo , siginfo_t *siginfo ,
                                                 void *ucontext ))((void *)0)}};
#line 86 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle , void (*proc)(ngx_cycle_t *cycle ,
                                                              void *data ) , void *data ,
                            char *name , ngx_int_t respawn ) 
{ 
  u_long on ;
  ngx_pid_t pid ;
  ngx_int_t s ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 94
  if (respawn >= 0L) {
#line 95
    s = respawn;
  } else {
#line 98
    s = (ngx_int_t )0;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! (s < ngx_last_process)) {
#line 98
        goto while_break;
      }
#line 99
      if (ngx_processes[s].pid == -1) {
#line 100
        goto while_break;
      }
#line 98
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 104
    if (s == 1024L) {
#line 105
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 105
        ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "no more than %d processes can be spawned",
                           1024);
        }
      }
#line 108
      return (-1);
    }
  }
#line 113
  if (respawn != -5L) {
    {
#line 117
    tmp___0 = socketpair(1, 1, 0, (int *)(ngx_processes[s].channel));
    }
#line 117
    if (tmp___0 == -1) {
#line 119
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 119
        tmp = __errno_location();
#line 119
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "socketpair() failed while spawning \"%s\"",
                           name);
        }
      }
#line 121
      return (-1);
    }
    {
#line 129
    tmp___2 = ngx_nonblocking(ngx_processes[s].channel[0]);
    }
#line 129
    if (tmp___2 == -1) {
#line 130
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 130
        tmp___1 = __errno_location();
#line 130
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "ioctl(FIONBIO) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 133
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 134
      return (-1);
    }
    {
#line 137
    tmp___4 = ngx_nonblocking(ngx_processes[s].channel[1]);
    }
#line 137
    if (tmp___4 == -1) {
#line 138
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 138
        tmp___3 = __errno_location();
#line 138
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "ioctl(FIONBIO) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 141
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 142
      return (-1);
    }
    {
#line 145
    on = (u_long )1;
#line 146
    tmp___6 = ioctl(ngx_processes[s].channel[0], 21586UL, & on);
    }
#line 146
    if (tmp___6 == -1) {
#line 147
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 147
        tmp___5 = __errno_location();
#line 147
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "ioctl(FIOASYNC) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 149
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 150
      return (-1);
    }
    {
#line 153
    tmp___8 = fcntl(ngx_processes[s].channel[0], 8, ngx_pid);
    }
#line 153
    if (tmp___8 == -1) {
#line 154
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 154
        tmp___7 = __errno_location();
#line 154
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___7, "fcntl(F_SETOWN) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 156
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 157
      return (-1);
    }
    {
#line 160
    tmp___10 = fcntl(ngx_processes[s].channel[0], 2, 1);
    }
#line 160
    if (tmp___10 == -1) {
#line 161
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 161
        tmp___9 = __errno_location();
#line 161
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___9, "fcntl(FD_CLOEXEC) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 164
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 165
      return (-1);
    }
    {
#line 168
    tmp___12 = fcntl(ngx_processes[s].channel[1], 2, 1);
    }
#line 168
    if (tmp___12 == -1) {
#line 169
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 169
        tmp___11 = __errno_location();
#line 169
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___11, "fcntl(FD_CLOEXEC) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 172
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 173
      return (-1);
    }
#line 176
    ngx_channel = ngx_processes[s].channel[1];
  } else {
#line 179
    ngx_processes[s].channel[0] = -1;
#line 180
    ngx_processes[s].channel[1] = -1;
  }
  {
#line 183
  ngx_process_slot = s;
#line 186
  pid = fork();
  }
  {
#line 190
  if (pid == -1) {
#line 190
    goto case_neg_1;
  }
#line 196
  if (pid == 0) {
#line 196
    goto case_0;
  }
#line 201
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 191
  if ((cycle->log)->log_level >= 2UL) {
    {
#line 191
    tmp___13 = __errno_location();
#line 191
    ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___13, "fork() failed while spawning \"%s\"",
                       name);
    }
  }
  {
#line 193
  ngx_close_channel(ngx_processes[s].channel, cycle->log);
  }
#line 194
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 197
  ngx_pid = getpid();
#line 198
  (*proc)(cycle, data);
  }
#line 199
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 202
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 205
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 205
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "start %s %P", name, pid);
    }
  }
#line 207
  ngx_processes[s].pid = pid;
#line 208
  ngx_processes[s].exited = 0U;
#line 210
  if (respawn >= 0L) {
#line 211
    return (pid);
  }
#line 214
  ngx_processes[s].proc = proc;
#line 215
  ngx_processes[s].data = data;
#line 216
  ngx_processes[s].name = name;
#line 217
  ngx_processes[s].exiting = 0U;
  {
#line 221
  if (respawn == -1L) {
#line 221
    goto case_neg_1___0;
  }
#line 227
  if (respawn == -2L) {
#line 227
    goto case_neg_2;
  }
#line 233
  if (respawn == -3L) {
#line 233
    goto case_neg_3;
  }
#line 239
  if (respawn == -4L) {
#line 239
    goto case_neg_4;
  }
#line 245
  if (respawn == -5L) {
#line 245
    goto case_neg_5;
  }
#line 219
  goto switch_break___0;
  case_neg_1___0: /* CIL Label */ 
#line 222
  ngx_processes[s].respawn = 0U;
#line 223
  ngx_processes[s].just_spawn = 0U;
#line 224
  ngx_processes[s].detached = 0U;
#line 225
  goto switch_break___0;
  case_neg_2: /* CIL Label */ 
#line 228
  ngx_processes[s].respawn = 0U;
#line 229
  ngx_processes[s].just_spawn = 1U;
#line 230
  ngx_processes[s].detached = 0U;
#line 231
  goto switch_break___0;
  case_neg_3: /* CIL Label */ 
#line 234
  ngx_processes[s].respawn = 1U;
#line 235
  ngx_processes[s].just_spawn = 0U;
#line 236
  ngx_processes[s].detached = 0U;
#line 237
  goto switch_break___0;
  case_neg_4: /* CIL Label */ 
#line 240
  ngx_processes[s].respawn = 1U;
#line 241
  ngx_processes[s].just_spawn = 1U;
#line 242
  ngx_processes[s].detached = 0U;
#line 243
  goto switch_break___0;
  case_neg_5: /* CIL Label */ 
#line 246
  ngx_processes[s].respawn = 0U;
#line 247
  ngx_processes[s].just_spawn = 0U;
#line 248
  ngx_processes[s].detached = 1U;
#line 249
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 252
  if (s == ngx_last_process) {
#line 253
    ngx_last_process ++;
  }
#line 256
  return (pid);
}
}
#line 260 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
ngx_pid_t ngx_execute(ngx_cycle_t *cycle , ngx_exec_ctx_t *ctx ) 
{ 
  ngx_pid_t tmp ;

  {
  {
#line 263
  tmp = ngx_spawn_process(cycle, & ngx_execute_proc, (void *)ctx, ctx->name, (ngx_int_t )-5);
  }
#line 263
  return (tmp);
}
}
#line 268 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
static void ngx_execute_proc(ngx_cycle_t *cycle , void *data ) 
{ 
  ngx_exec_ctx_t *ctx ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 271
  ctx = (ngx_exec_ctx_t *)data;
#line 273
  tmp___0 = execve((char const   *)ctx->path, ctx->argv, ctx->envp);
  }
#line 273
  if (tmp___0 == -1) {
#line 274
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 274
      tmp = __errno_location();
#line 274
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "execve() failed while executing %s \"%s\"",
                         ctx->name, ctx->path);
      }
    }
  }
  {
#line 279
  exit(1);
  }
}
}
#line 283 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
ngx_int_t ngx_init_signals(ngx_log_t *log ) 
{ 
  ngx_signal_t *sig ;
  struct sigaction sa ;
  int *tmp ;
  int tmp___0 ;

  {
#line 289
  sig = signals;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (sig->signo != 0)) {
#line 289
      goto while_break;
    }
    {
#line 290
    memset((void *)(& sa), 0, sizeof(struct sigaction ));
    }
#line 292
    if (sig->handler) {
#line 293
      sa.__sigaction_handler.sa_sigaction = sig->handler;
#line 294
      sa.sa_flags = 4;
    } else {
#line 297
      sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
    }
    {
#line 300
    sigemptyset(& sa.sa_mask);
#line 301
    tmp___0 = sigaction(sig->signo, (struct sigaction  const  */* __restrict  */)(& sa),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 301
    if (tmp___0 == -1) {
#line 306
      if (log->log_level >= 1UL) {
        {
#line 306
        tmp = __errno_location();
#line 306
        ngx_log_error_core((ngx_uint_t )1, log, *tmp, "sigaction(%s) failed", sig->signame);
        }
      }
#line 308
      return ((ngx_int_t )-1);
    }
#line 289
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return ((ngx_int_t )0);
}
}
#line 317 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
static void ngx_signal_handler(int signo , siginfo_t *siginfo , void *ucontext ) 
{ 
  char *action ;
  ngx_int_t ignore ;
  ngx_err_t err ;
  ngx_signal_t *sig ;
  int *tmp ;
  __pid_t tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 325
  ignore = (ngx_int_t )0;
#line 327
  tmp = __errno_location();
#line 327
  err = *tmp;
#line 329
  sig = signals;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 329
    if (! (sig->signo != 0)) {
#line 329
      goto while_break;
    }
#line 330
    if (sig->signo == signo) {
#line 331
      goto while_break;
    }
#line 329
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 335
  ngx_time_sigsafe_update();
#line 337
  action = (char *)"";
  }
  {
#line 342
  if (ngx_process == 0UL) {
#line 342
    goto case_0;
  }
#line 342
  if (ngx_process == 1UL) {
#line 342
    goto case_0;
  }
#line 408
  if (ngx_process == 4UL) {
#line 408
    goto case_4;
  }
#line 408
  if (ngx_process == 3UL) {
#line 408
    goto case_4;
  }
#line 339
  goto switch_break;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 345
  if (signo == 3) {
#line 345
    goto case_3;
  }
#line 351
  if (signo == 2) {
#line 351
    goto case_2;
  }
#line 351
  if (signo == 15) {
#line 351
    goto case_2;
  }
#line 356
  if (signo == 28) {
#line 356
    goto case_28;
  }
#line 363
  if (signo == 1) {
#line 363
    goto case_1___0;
  }
#line 368
  if (signo == 10) {
#line 368
    goto case_10;
  }
#line 373
  if (signo == 12) {
#line 373
    goto case_12;
  }
#line 392
  if (signo == 14) {
#line 392
    goto case_14;
  }
#line 396
  if (signo == 29) {
#line 396
    goto case_29;
  }
#line 400
  if (signo == 17) {
#line 400
    goto case_17;
  }
#line 343
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 346
  ngx_quit = 1;
#line 347
  action = (char *)", shutting down";
#line 348
  goto switch_break___0;
  case_2: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 352
  ngx_terminate = 1;
#line 353
  action = (char *)", exiting";
#line 354
  goto switch_break___0;
  case_28: /* CIL Label */ 
#line 357
  if (ngx_daemonized) {
#line 358
    ngx_noaccept = 1;
#line 359
    action = (char *)", stop accepting connections";
  }
#line 361
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 364
  ngx_reconfigure = 1;
#line 365
  action = (char *)", reconfiguring";
#line 366
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 369
  ngx_reopen = 1;
#line 370
  action = (char *)", reopening logs";
#line 371
  goto switch_break___0;
  case_12: /* CIL Label */ 
  {
#line 374
  tmp___0 = getppid();
  }
#line 374
  if (tmp___0 > 1) {
#line 383
    action = (char *)", ignoring";
#line 384
    ignore = (ngx_int_t )1;
#line 385
    goto switch_break___0;
  } else
#line 374
  if (ngx_new_binary > 0) {
#line 383
    action = (char *)", ignoring";
#line 384
    ignore = (ngx_int_t )1;
#line 385
    goto switch_break___0;
  }
#line 388
  ngx_change_binary = 1;
#line 389
  action = (char *)", changing binary";
#line 390
  goto switch_break___0;
  case_14: /* CIL Label */ 
#line 393
  ngx_sigalrm = 1;
#line 394
  goto switch_break___0;
  case_29: /* CIL Label */ 
#line 397
  ngx_sigio = 1;
#line 398
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 401
  ngx_reap = 1;
#line 402
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 405
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 411
  if (signo == 28) {
#line 411
    goto case_28___0;
  }
#line 417
  if (signo == 3) {
#line 417
    goto case_3___1;
  }
#line 423
  if (signo == 2) {
#line 423
    goto case_2___0;
  }
#line 423
  if (signo == 15) {
#line 423
    goto case_2___0;
  }
#line 428
  if (signo == 10) {
#line 428
    goto case_10___0;
  }
#line 435
  if (signo == 29) {
#line 435
    goto case_29___0;
  }
#line 435
  if (signo == 12) {
#line 435
    goto case_29___0;
  }
#line 435
  if (signo == 1) {
#line 435
    goto case_29___0;
  }
#line 409
  goto switch_break___1;
  case_28___0: /* CIL Label */ 
#line 412
  if (! ngx_daemonized) {
#line 413
    goto switch_break___1;
  }
#line 415
  ngx_debug_quit = 1;
  case_3___1: /* CIL Label */ 
#line 418
  ngx_quit = 1;
#line 419
  action = (char *)", shutting down";
#line 420
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  case_15___0: /* CIL Label */ 
#line 424
  ngx_terminate = 1;
#line 425
  action = (char *)", exiting";
#line 426
  goto switch_break___1;
  case_10___0: /* CIL Label */ 
#line 429
  ngx_reopen = 1;
#line 430
  action = (char *)", reopening logs";
#line 431
  goto switch_break___1;
  case_29___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
  case_1___1: /* CIL Label */ 
#line 436
  action = (char *)", ignoring";
#line 437
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 440
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 443
  if (siginfo) {
#line 443
    if (siginfo->_sifields._kill.si_pid) {
#line 444
      if ((ngx_cycle->log)->log_level >= 6UL) {
        {
#line 444
        ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "signal %d (%s) received from %P%s",
                           signo, sig->signame, siginfo->_sifields._kill.si_pid, action);
        }
      }
    } else {
#line 443
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 449
  if ((ngx_cycle->log)->log_level >= 6UL) {
    {
#line 449
    ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "signal %d (%s) received%s",
                       signo, sig->signame, action);
    }
  }
#line 454
  if (ignore) {
#line 455
    if ((ngx_cycle->log)->log_level >= 3UL) {
      {
#line 455
      ngx_log_error_core((ngx_uint_t )3, (ngx_log_t *)ngx_cycle->log, 0, "the changing binary signal is ignored: you should shutdown or terminate before either old or new binary\'s process");
      }
    }
  }
#line 461
  if (signo == 17) {
    {
#line 462
    ngx_process_get_status();
    }
  }
  {
#line 465
  tmp___1 = __errno_location();
#line 465
  *tmp___1 = err;
  }
#line 466
  return;
}
}
#line 469 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
static void ngx_process_get_status(void) 
{ 
  int status ;
  char *process ;
  ngx_pid_t pid ;
  ngx_err_t err ;
  ngx_int_t i ;
  ngx_uint_t one ;
  int *tmp ;
  char const   *tmp___0 ;

  {
#line 479
  one = (ngx_uint_t )0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 482
    pid = waitpid(-1, & status, 1);
    }
#line 484
    if (pid == 0) {
#line 485
      return;
    }
#line 488
    if (pid == -1) {
      {
#line 489
      tmp = __errno_location();
#line 489
      err = *tmp;
      }
#line 491
      if (err == 4) {
#line 492
        goto __Cont;
      }
#line 495
      if (err == 10) {
#line 495
        if (one) {
#line 496
          return;
        }
      }
#line 508
      if (err == 10) {
#line 509
        if ((ngx_cycle->log)->log_level >= 7UL) {
          {
#line 509
          ngx_log_error_core((ngx_uint_t )7, (ngx_log_t *)ngx_cycle->log, err, "waitpid() failed");
          }
        }
#line 511
        return;
      }
#line 514
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 514
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, err, "waitpid() failed");
        }
      }
#line 516
      return;
    }
#line 520
    one = (ngx_uint_t )1;
#line 521
    process = (char *)"unknown process";
#line 523
    i = (ngx_int_t )0;
    {
#line 523
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 523
      if (! (i < ngx_last_process)) {
#line 523
        goto while_break___0;
      }
#line 524
      if (ngx_processes[i].pid == pid) {
#line 525
        ngx_processes[i].status = status;
#line 526
        ngx_processes[i].exited = 1U;
#line 527
        process = ngx_processes[i].name;
#line 528
        goto while_break___0;
      }
#line 523
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 532
    if (status & 127) {
#line 534
      if ((ngx_cycle->log)->log_level >= 2UL) {
#line 534
        if (status & 128) {
#line 534
          tmp___0 = " (core dumped)";
        } else {
#line 534
          tmp___0 = "";
        }
        {
#line 534
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "%s %P exited on signal %d%s",
                           process, pid, status & 127, tmp___0);
        }
      }
    } else
#line 545
    if ((ngx_cycle->log)->log_level >= 6UL) {
      {
#line 545
      ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "%s %P exited with code %d",
                         process, pid, (status & 65280) >> 8);
      }
    }
#line 550
    if ((status & 65280) >> 8 == 2) {
#line 550
      if (ngx_processes[i].respawn) {
#line 551
        if ((ngx_cycle->log)->log_level >= 2UL) {
          {
#line 551
          ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "%s %P exited with fatal code %d and cannot be respawned",
                             process, pid, (status & 65280) >> 8);
          }
        }
#line 555
        ngx_processes[i].respawn = 0U;
      }
    }
    {
#line 558
    ngx_unlock_mutexes(pid);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 563 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
static void ngx_unlock_mutexes(ngx_pid_t pid ) 
{ 
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_list_part_t *part ;
  ngx_slab_pool_t *sp ;
  ngx_uint_t tmp ;

  {
#line 576
  if (ngx_accept_mutex_ptr) {
    {
#line 577
    ngx_shmtx_force_unlock(& ngx_accept_mutex, pid);
    }
  }
#line 585
  part = (ngx_list_part_t *)(& ngx_cycle->shared_memory.part);
#line 586
  shm_zone = (ngx_shm_zone_t *)part->elts;
#line 588
  i = (ngx_uint_t )0;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (i >= part->nelts) {
#line 591
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 592
        goto while_break;
      }
#line 594
      part = part->next;
#line 595
      shm_zone = (ngx_shm_zone_t *)part->elts;
#line 596
      i = (ngx_uint_t )0;
    }
    {
#line 599
    sp = (ngx_slab_pool_t *)(shm_zone + i)->shm.addr;
#line 601
    tmp = ngx_shmtx_force_unlock(& sp->mutex, pid);
    }
#line 601
    if (tmp) {
#line 602
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 602
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "shared memory zone \"%V\" was locked by %P",
                           & (shm_zone + i)->shm.name, pid);
        }
      }
    }
#line 588
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  return;
}
}
#line 610 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
void ngx_debug_point(void) 
{ 
  ngx_core_conf_t *ccf ;

  {
#line 615
  ccf = (ngx_core_conf_t *)*(ngx_cycle->conf_ctx + ngx_core_module.index);
  {
#line 620
  if (ccf->debug_points == 1L) {
#line 620
    goto case_1;
  }
#line 624
  if (ccf->debug_points == 2L) {
#line 624
    goto case_2;
  }
#line 618
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 621
  raise(19);
  }
#line 622
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 625
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 627
  return;
}
}
#line 630 "/tmp/nginx-1.13.2/src/os/unix/ngx_process.c"
ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle , char *name , ngx_pid_t pid ) 
{ 
  ngx_signal_t *sig ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 635
  sig = signals;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! (sig->signo != 0)) {
#line 635
      goto while_break;
    }
    {
#line 636
    tmp___1 = strcmp((char const   *)name, (char const   *)sig->name);
    }
#line 636
    if (tmp___1 == 0) {
      {
#line 637
      tmp = kill(pid, sig->signo);
      }
#line 637
      if (tmp != -1) {
#line 638
        return ((ngx_int_t )0);
      }
#line 641
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 641
        tmp___0 = __errno_location();
#line 641
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "kill(%P, %d) failed",
                           pid, sig->signo);
        }
      }
    }
#line 635
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 646
  return ((ngx_int_t )1);
}
}
#line 61 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t___0 __len ,
                                                int __prot , int __flags , int __fd ,
                                                __off64_t __offset )  __asm__("mmap64")  ;
#line 76
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t___0 __len ) ;
#line 25 "src/os/unix/ngx_shmem.h"
ngx_int_t ngx_shm_alloc(ngx_shm_t *shm ) ;
#line 26
void ngx_shm_free(ngx_shm_t *shm ) ;
#line 14 "/tmp/nginx-1.13.2/src/os/unix/ngx_shmem.c"
ngx_int_t ngx_shm_alloc(ngx_shm_t *shm ) 
{ 
  void *tmp ;
  int *tmp___0 ;

  {
  {
#line 17
  tmp = mmap((void *)0, shm->size, 3, 33, -1, (__off64_t )0);
#line 17
  shm->addr = (u_char *)tmp;
  }
#line 21
  if ((unsigned long )shm->addr == (unsigned long )((void *)-1)) {
#line 22
    if ((shm->log)->log_level >= 2UL) {
      {
#line 22
      tmp___0 = __errno_location();
#line 22
      ngx_log_error_core((ngx_uint_t )2, shm->log, *tmp___0, "mmap(MAP_ANON|MAP_SHARED, %uz) failed",
                         shm->size);
      }
    }
#line 24
    return ((ngx_int_t )-1);
  }
#line 27
  return ((ngx_int_t )0);
}
}
#line 31 "/tmp/nginx-1.13.2/src/os/unix/ngx_shmem.c"
void ngx_shm_free(ngx_shm_t *shm ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 34
  tmp___0 = munmap((void *)shm->addr, shm->size);
  }
#line 34
  if (tmp___0 == -1) {
#line 35
    if ((shm->log)->log_level >= 2UL) {
      {
#line 35
      tmp = __errno_location();
#line 35
      ngx_log_error_core((ngx_uint_t )2, shm->log, *tmp, "munmap(%p, %uz) failed",
                         shm->addr, shm->size);
      }
    }
  }
#line 38
  return;
}
}
#line 173 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 191
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 220 "src/core/ngx_connection.h"
ngx_connection_t *ngx_get_connection(ngx_socket_t s , ngx_log_t *log ) ;
#line 221
void ngx_free_connection(ngx_connection_t *c ) ;
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_channel.c"
ngx_int_t ngx_write_channel(ngx_socket_t s , ngx_channel_t *ch , size_t___0 size ,
                            ngx_log_t *log ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  struct iovec iov[1] ;
  struct msghdr msg ;
  union __anonunion_cmsg_918060065 cmsg ;
  int *tmp ;

  {
#line 29
  if (ch->fd == -1) {
#line 30
    msg.msg_control = (void *)0;
#line 31
    msg.msg_controllen = (size_t___0 )0;
  } else {
    {
#line 34
    msg.msg_control = (void *)((caddr_t )(& cmsg));
#line 35
    msg.msg_controllen = sizeof(cmsg);
#line 37
    memset((void *)(& cmsg), 0, sizeof(cmsg));
#line 39
    cmsg.cm.cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + sizeof(int );
#line 40
    cmsg.cm.cmsg_level = 1;
#line 41
    cmsg.cm.cmsg_type = 1;
#line 53
    memcpy((void */* __restrict  */)(cmsg.cm.__cmsg_data), (void const   */* __restrict  */)(& ch->fd),
           sizeof(int ));
    }
  }
  {
#line 56
  msg.msg_flags = 0;
#line 71
  iov[0].iov_base = (void *)((char *)ch);
#line 72
  iov[0].iov_len = size;
#line 74
  msg.msg_name = (void *)0;
#line 75
  msg.msg_namelen = (socklen_t )0;
#line 76
  msg.msg_iov = iov;
#line 77
  msg.msg_iovlen = (size_t___0 )1;
#line 79
  n = sendmsg(s, (struct msghdr  const  *)(& msg), 0);
  }
#line 81
  if (n == -1L) {
    {
#line 82
    tmp = __errno_location();
#line 82
    err = *tmp;
    }
#line 83
    if (err == 11) {
#line 84
      return ((ngx_int_t )-2);
    }
#line 87
    if (log->log_level >= 2UL) {
      {
#line 87
      ngx_log_error_core((ngx_uint_t )2, log, err, "sendmsg() failed");
      }
    }
#line 88
    return ((ngx_int_t )-1);
  }
#line 91
  return ((ngx_int_t )0);
}
}
#line 95 "/tmp/nginx-1.13.2/src/os/unix/ngx_channel.c"
ngx_int_t ngx_read_channel(ngx_socket_t s , ngx_channel_t *ch , size_t___0 size ,
                           ngx_log_t *log ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  struct iovec iov[1] ;
  struct msghdr msg ;
  union __anonunion_cmsg_918060066 cmsg ;
  int *tmp ;

  {
  {
#line 112
  iov[0].iov_base = (void *)((char *)ch);
#line 113
  iov[0].iov_len = size;
#line 115
  msg.msg_name = (void *)0;
#line 116
  msg.msg_namelen = (socklen_t )0;
#line 117
  msg.msg_iov = iov;
#line 118
  msg.msg_iovlen = (size_t___0 )1;
#line 121
  msg.msg_control = (void *)((caddr_t )(& cmsg));
#line 122
  msg.msg_controllen = sizeof(cmsg);
#line 128
  n = recvmsg(s, & msg, 0);
  }
#line 130
  if (n == -1L) {
    {
#line 131
    tmp = __errno_location();
#line 131
    err = *tmp;
    }
#line 132
    if (err == 11) {
#line 133
      return ((ngx_int_t )-2);
    }
#line 136
    if (log->log_level >= 2UL) {
      {
#line 136
      ngx_log_error_core((ngx_uint_t )2, log, err, "recvmsg() failed");
      }
    }
#line 137
    return ((ngx_int_t )-1);
  }
#line 140
  if (n == 0L) {
#line 142
    return ((ngx_int_t )-1);
  }
#line 145
  if ((size_t___0 )n < sizeof(ngx_channel_t )) {
#line 146
    if (log->log_level >= 2UL) {
      {
#line 146
      ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() returned not enough data: %z",
                         n);
      }
    }
#line 148
    return ((ngx_int_t )-1);
  }
#line 153
  if (ch->command == 1UL) {
#line 155
    if (cmsg.cm.cmsg_len < (size_t___0 )((socklen_t )((((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + sizeof(int )))) {
#line 156
      if (log->log_level >= 2UL) {
        {
#line 156
        ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() returned too small ancillary data");
        }
      }
#line 158
      return ((ngx_int_t )-1);
    }
#line 161
    if (cmsg.cm.cmsg_level != 1) {
#line 161
      goto _L;
    } else
#line 161
    if (cmsg.cm.cmsg_type != 1) {
      _L: /* CIL Label */ 
#line 163
      if (log->log_level >= 2UL) {
        {
#line 163
        ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() returned invalid ancillary data level %d or type %d",
                           cmsg.cm.cmsg_level, cmsg.cm.cmsg_type);
        }
      }
#line 167
      return ((ngx_int_t )-1);
    }
    {
#line 172
    memcpy((void */* __restrict  */)(& ch->fd), (void const   */* __restrict  */)(cmsg.cm.__cmsg_data),
           sizeof(int ));
    }
  }
#line 175
  if (msg.msg_flags & 40) {
#line 176
    if (log->log_level >= 2UL) {
      {
#line 176
      ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() truncated data");
      }
    }
  }
#line 194
  return (n);
}
}
#line 198 "/tmp/nginx-1.13.2/src/os/unix/ngx_channel.c"
ngx_int_t ngx_add_channel_event(ngx_cycle_t *cycle , ngx_fd_t fd , ngx_int_t event ,
                                void (*handler)(ngx_event_t *ev ) ) 
{ 
  ngx_event_t *ev ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 205
  c = ngx_get_connection(fd, cycle->log);
  }
#line 207
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 208
    return ((ngx_int_t )-1);
  }
#line 211
  c->pool = cycle->pool;
#line 213
  rev = c->read;
#line 214
  wev = c->write;
#line 216
  rev->log = cycle->log;
#line 217
  wev->log = cycle->log;
#line 219
  rev->channel = 1U;
#line 220
  wev->channel = 1U;
#line 222
  if (event == 8193L) {
#line 222
    ev = rev;
  } else {
#line 222
    ev = wev;
  }
#line 224
  ev->handler = handler;
#line 226
  if (ngx_event_actions.add_conn) {
#line 226
    if ((ngx_event_flags & 64UL) == 0UL) {
      {
#line 227
      tmp = (*(ngx_event_actions.add_conn))(c);
      }
#line 227
      if (tmp == -1L) {
        {
#line 228
        ngx_free_connection(c);
        }
#line 229
        return ((ngx_int_t )-1);
      }
    } else {
#line 226
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 233
    tmp___0 = (*(ngx_event_actions.add))(ev, event, (ngx_uint_t )0);
    }
#line 233
    if (tmp___0 == -1L) {
      {
#line 234
      ngx_free_connection(c);
      }
#line 235
      return ((ngx_int_t )-1);
    }
  }
#line 239
  return ((ngx_int_t )0);
}
}
#line 243 "/tmp/nginx-1.13.2/src/os/unix/ngx_channel.c"
void ngx_close_channel(ngx_fd_t *fd , ngx_log_t *log ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 246
  tmp___0 = close(*(fd + 0));
  }
#line 246
  if (tmp___0 == -1) {
#line 247
    if (log->log_level >= 2UL) {
      {
#line 247
      tmp = __errno_location();
#line 247
      ngx_log_error_core((ngx_uint_t )2, log, *tmp, "close() channel failed");
      }
    }
  }
  {
#line 250
  tmp___2 = close(*(fd + 1));
  }
#line 250
  if (tmp___2 == -1) {
#line 251
    if (log->log_level >= 2UL) {
      {
#line 251
      tmp___1 = __errno_location();
#line 251
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___1, "close() channel failed");
      }
    }
  }
#line 253
  return;
}
}
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_udp_sendmsg_chain.c"
static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in ,
                                                  ngx_log_t *log ) ;
#line 15
static ssize_t ngx_sendmsg(ngx_connection_t *c , ngx_iovec_t *vec ) ;
#line 18 "/tmp/nginx-1.13.2/src/os/unix/ngx_udp_sendmsg_chain.c"
ngx_chain_t *ngx_udp_unix_sendmsg_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) 
{ 
  ssize_t n ;
  off_t send___0 ;
  ngx_chain_t *cl ;
  ngx_event_t *wev ;
  ngx_iovec_t vec ;
  struct iovec iovs[64] ;

  {
#line 28
  wev = c->write;
#line 30
  if (! wev->ready) {
#line 31
    return (in);
  }
#line 47
  if (limit == 0L) {
#line 48
    limit = (off_t )(9223372036854775807ULL - (unsigned long long )ngx_pagesize);
  } else
#line 47
  if (limit > (off_t )(9223372036854775807ULL - (unsigned long long )ngx_pagesize)) {
#line 48
    limit = (off_t )(9223372036854775807ULL - (unsigned long long )ngx_pagesize);
  }
#line 51
  send___0 = (off_t )0;
#line 53
  vec.iovs = iovs;
#line 54
  vec.nalloc = (ngx_uint_t )64;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    cl = ngx_udp_output_chain_to_iovec(& vec, in, c->log);
    }
#line 62
    if ((unsigned long )cl == (unsigned long )((ngx_chain_t *)-1)) {
#line 63
      return ((ngx_chain_t *)-1);
    }
#line 66
    if (cl) {
#line 66
      if ((cl->buf)->in_file) {
#line 67
        if ((c->log)->log_level >= 2UL) {
          {
#line 67
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "file buf in sendmsg t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 80
        ngx_debug_point();
        }
#line 82
        return ((ngx_chain_t *)-1);
      }
    }
#line 85
    if ((unsigned long )cl == (unsigned long )in) {
#line 86
      return (in);
    }
    {
#line 89
    send___0 = (off_t )((size_t___0 )send___0 + vec.size);
#line 91
    n = ngx_sendmsg(c, & vec);
    }
#line 93
    if (n == -1L) {
#line 94
      return ((ngx_chain_t *)-1);
    }
#line 97
    if (n == -2L) {
#line 98
      wev->ready = 0U;
#line 99
      return (in);
    }
    {
#line 102
    c->sent += n;
#line 104
    in = ngx_chain_update_sent(in, n);
    }
#line 106
    if (send___0 >= limit) {
#line 107
      return (in);
    } else
#line 106
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 107
      return (in);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 113 "/tmp/nginx-1.13.2/src/os/unix/ngx_udp_sendmsg_chain.c"
static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in ,
                                                  ngx_log_t *log ) 
{ 
  size_t___0 total ;
  size_t___0 size ;
  u_char *prev ;
  ngx_uint_t n ;
  ngx_uint_t flush ;
  ngx_chain_t *cl ;
  struct iovec *iov ;
  ngx_uint_t tmp ;

  {
#line 122
  cl = in;
#line 123
  iov = (struct iovec *)((void *)0);
#line 124
  prev = (u_char *)((void *)0);
#line 125
  total = (size_t___0 )0;
#line 126
  n = (ngx_uint_t )0;
#line 127
  flush = (ngx_uint_t )0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (in) {
#line 129
      if (! (! flush)) {
#line 129
        goto while_break;
      }
    } else {
#line 129
      goto while_break;
    }
#line 131
    if ((in->buf)->flush) {
#line 132
      flush = (ngx_uint_t )1;
    } else
#line 131
    if ((in->buf)->last_buf) {
#line 132
      flush = (ngx_uint_t )1;
    }
#line 135
    if ((in->buf)->flush) {
#line 135
      goto _L;
    } else
#line 135
    if ((in->buf)->last_buf) {
#line 135
      goto _L;
    } else
#line 135
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 135
      if (! (in->buf)->temporary) {
#line 135
        if (! (in->buf)->memory) {
#line 135
          if (! (in->buf)->mmap) {
#line 135
            if (! (in->buf)->in_file) {
#line 136
              goto __Cont;
            }
          }
        }
      }
    }
#line 139
    if ((in->buf)->in_file) {
#line 140
      goto while_break;
    }
#line 143
    if (! (in->buf)->temporary) {
#line 143
      if (! (in->buf)->memory) {
#line 143
        if (! (in->buf)->mmap) {
#line 144
          if (log->log_level >= 2UL) {
            {
#line 144
            ngx_log_error_core((ngx_uint_t )2, log, 0, "bad buf in output chain t:%d r:%d f:%d %p %p-%p %p %O-%O",
                               (in->buf)->temporary, (in->buf)->recycled, (in->buf)->in_file,
                               (in->buf)->start, (in->buf)->pos, (in->buf)->last,
                               (in->buf)->file, (in->buf)->file_pos, (in->buf)->file_last);
            }
          }
          {
#line 157
          ngx_debug_point();
          }
#line 159
          return ((ngx_chain_t *)-1);
        }
      }
    }
#line 162
    size = (size_t___0 )((in->buf)->last - (in->buf)->pos);
#line 164
    if ((unsigned long )prev == (unsigned long )(in->buf)->pos) {
#line 165
      iov->iov_len += size;
    } else {
#line 168
      if (n == vec->nalloc) {
#line 169
        if (log->log_level >= 2UL) {
          {
#line 169
          ngx_log_error_core((ngx_uint_t )2, log, 0, "too many parts in a datagram");
          }
        }
#line 171
        return ((ngx_chain_t *)-1);
      }
#line 174
      tmp = n;
#line 174
      n ++;
#line 174
      iov = vec->iovs + tmp;
#line 176
      iov->iov_base = (void *)(in->buf)->pos;
#line 177
      iov->iov_len = size;
    }
#line 180
    prev = (in->buf)->pos + size;
#line 181
    total += size;
    __Cont: /* CIL Label */ 
#line 129
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (! flush) {
#line 186
    vec->size = (size_t___0 )0;
#line 187
    vec->count = (ngx_uint_t )0;
#line 189
    return (cl);
  }
#line 192
  vec->count = n;
#line 193
  vec->size = total;
#line 195
  return (in);
}
}
#line 199 "/tmp/nginx-1.13.2/src/os/unix/ngx_udp_sendmsg_chain.c"
static ssize_t ngx_sendmsg(ngx_connection_t *c , ngx_iovec_t *vec ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  struct msghdr msg ;
  u_char msg_control[(((sizeof(struct in_pktinfo ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
  u_char msg_control6[(((sizeof(struct in6_pktinfo ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
  struct cmsghdr *cmsg ;
  struct in_pktinfo *pkt ;
  struct sockaddr_in *sin ;
  struct cmsghdr *cmsg___0 ;
  struct in6_pktinfo *pkt6 ;
  struct sockaddr_in6 *sin6 ;
  int *tmp ;

  {
  {
#line 220
  memset((void *)(& msg), 0, sizeof(struct msghdr ));
  }
#line 222
  if (c->socklen) {
#line 223
    msg.msg_name = (void *)c->sockaddr;
#line 224
    msg.msg_namelen = c->socklen;
  }
#line 227
  msg.msg_iov = vec->iovs;
#line 228
  msg.msg_iovlen = vec->count;
#line 232
  if (c->listening) {
#line 232
    if ((c->listening)->wildcard) {
#line 232
      if (c->local_sockaddr) {
#line 257
        if ((int )(c->local_sockaddr)->sa_family == 2) {
#line 262
          msg.msg_control = (void *)(& msg_control);
#line 263
          msg.msg_controllen = sizeof(msg_control);
#line 265
          if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 265
            cmsg = (struct cmsghdr *)msg.msg_control;
          } else {
#line 265
            cmsg = (struct cmsghdr *)0;
          }
          {
#line 266
          cmsg->cmsg_level = 0;
#line 267
          cmsg->cmsg_type = 8;
#line 268
          cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + sizeof(struct in_pktinfo );
#line 270
          sin = (struct sockaddr_in *)c->local_sockaddr;
#line 272
          pkt = (struct in_pktinfo *)(cmsg->__cmsg_data);
#line 273
          memset((void *)pkt, 0, sizeof(struct in_pktinfo ));
#line 274
          pkt->ipi_spec_dst = sin->sin_addr;
          }
        }
#line 281
        if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 286
          msg.msg_control = (void *)(& msg_control6);
#line 287
          msg.msg_controllen = sizeof(msg_control6);
#line 289
          if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 289
            cmsg___0 = (struct cmsghdr *)msg.msg_control;
          } else {
#line 289
            cmsg___0 = (struct cmsghdr *)0;
          }
          {
#line 290
          cmsg___0->cmsg_level = 41;
#line 291
          cmsg___0->cmsg_type = 50;
#line 292
          cmsg___0->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + sizeof(struct in6_pktinfo );
#line 294
          sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 296
          pkt6 = (struct in6_pktinfo *)(cmsg___0->__cmsg_data);
#line 297
          memset((void *)pkt6, 0, sizeof(struct in6_pktinfo ));
#line 298
          pkt6->ipi6_addr = sin6->sin6_addr;
          }
        }
      }
    }
  }
  eintr: 
  {
#line 308
  n = sendmsg(c->fd, (struct msghdr  const  *)(& msg), 0);
  }
#line 313
  if (n == -1L) {
    {
#line 314
    tmp = __errno_location();
#line 314
    err = *tmp;
    }
    {
#line 317
    if (err == 11) {
#line 317
      goto case_11;
    }
#line 322
    if (err == 4) {
#line 322
      goto case_4;
    }
#line 327
    goto switch_default;
    case_11: /* CIL Label */ ;
#line 320
    return ((ssize_t )-2);
    case_4: /* CIL Label */ ;
#line 325
    goto eintr;
    switch_default: /* CIL Label */ 
    {
#line 328
    (c->write)->error = 1U;
#line 329
    ngx_connection_error(c, err, (char *)"sendmsg() failed");
    }
#line 330
    return ((ssize_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 334
  return (n);
}
}
#line 152 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t___0 __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_udp_send.c"
ssize_t ngx_udp_unix_send(ngx_connection_t *c , u_char *buf , size_t___0 size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *wev ;
  int *tmp ;

  {
#line 20
  wev = c->write;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 23
    n = sendto(c->fd, (void const   *)buf, size, 0, (struct sockaddr  const  */* __restrict  */)c->sockaddr,
               c->socklen);
    }
#line 29
    if (n >= 0L) {
#line 30
      if ((size_t___0 )n != size) {
        {
#line 31
        wev->error = 1U;
#line 32
        ngx_connection_error(c, 0, (char *)"sendto() incomplete");
        }
#line 33
        return ((ssize_t )-1);
      }
#line 36
      c->sent += n;
#line 38
      return (n);
    }
    {
#line 41
    tmp = __errno_location();
#line 41
    err = *tmp;
    }
#line 43
    if (err == 11) {
#line 44
      wev->ready = 0U;
#line 47
      return ((ssize_t )-2);
    }
#line 50
    if (err != 4) {
      {
#line 51
      wev->error = 1U;
#line 52
      ngx_connection_error(c, err, (char *)"sendto() failed");
      }
#line 53
      return ((ssize_t )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 52 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_writev_chain.c"
ngx_chain_t *ngx_writev_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) 
{ 
  ssize_t n ;
  ssize_t sent ;
  off_t send___0 ;
  off_t prev_send ;
  ngx_chain_t *cl ;
  ngx_event_t *wev ;
  ngx_iovec_t vec ;
  struct iovec iovs[64] ;

  {
#line 23
  wev = c->write;
#line 25
  if (! wev->ready) {
#line 26
    return (in);
  }
#line 42
  if (limit == 0L) {
#line 43
    limit = (off_t )(9223372036854775807ULL - (unsigned long long )ngx_pagesize);
  } else
#line 42
  if (limit > (off_t )(9223372036854775807ULL - (unsigned long long )ngx_pagesize)) {
#line 43
    limit = (off_t )(9223372036854775807ULL - (unsigned long long )ngx_pagesize);
  }
#line 46
  send___0 = (off_t )0;
#line 48
  vec.iovs = iovs;
#line 49
  vec.nalloc = (ngx_uint_t )64;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    prev_send = send___0;
#line 56
    cl = ngx_output_chain_to_iovec(& vec, in, (size_t___0 )(limit - send___0), c->log);
    }
#line 58
    if ((unsigned long )cl == (unsigned long )((ngx_chain_t *)-1)) {
#line 59
      return ((ngx_chain_t *)-1);
    }
#line 62
    if (cl) {
#line 62
      if ((cl->buf)->in_file) {
#line 63
        if ((c->log)->log_level >= 2UL) {
          {
#line 63
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "file buf in writev t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 76
        ngx_debug_point();
        }
#line 78
        return ((ngx_chain_t *)-1);
      }
    }
    {
#line 81
    send___0 = (off_t )((size_t___0 )send___0 + vec.size);
#line 83
    n = ngx_writev(c, & vec);
    }
#line 85
    if (n == -1L) {
#line 86
      return ((ngx_chain_t *)-1);
    }
#line 89
    if (n == -2L) {
#line 89
      sent = (ssize_t )0;
    } else {
#line 89
      sent = n;
    }
    {
#line 91
    c->sent += sent;
#line 93
    in = ngx_chain_update_sent(in, sent);
    }
#line 95
    if (send___0 - prev_send != sent) {
#line 96
      wev->ready = 0U;
#line 97
      return (in);
    }
#line 100
    if (send___0 >= limit) {
#line 101
      return (in);
    } else
#line 100
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 101
      return (in);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 107 "/tmp/nginx-1.13.2/src/os/unix/ngx_writev_chain.c"
ngx_chain_t *ngx_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in , size_t___0 limit ,
                                       ngx_log_t *log ) 
{ 
  size_t___0 total ;
  size_t___0 size ;
  u_char *prev ;
  ngx_uint_t n ;
  struct iovec *iov ;
  ngx_uint_t tmp ;

  {
#line 116
  iov = (struct iovec *)((void *)0);
#line 117
  prev = (u_char *)((void *)0);
#line 118
  total = (size_t___0 )0;
#line 119
  n = (ngx_uint_t )0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (in) {
#line 121
      if (! (total < limit)) {
#line 121
        goto while_break;
      }
    } else {
#line 121
      goto while_break;
    }
#line 123
    if ((in->buf)->flush) {
#line 123
      goto _L;
    } else
#line 123
    if ((in->buf)->last_buf) {
#line 123
      goto _L;
    } else
#line 123
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 123
      if (! (in->buf)->temporary) {
#line 123
        if (! (in->buf)->memory) {
#line 123
          if (! (in->buf)->mmap) {
#line 123
            if (! (in->buf)->in_file) {
#line 124
              goto __Cont;
            }
          }
        }
      }
    }
#line 127
    if ((in->buf)->in_file) {
#line 128
      goto while_break;
    }
#line 131
    if (! (in->buf)->temporary) {
#line 131
      if (! (in->buf)->memory) {
#line 131
        if (! (in->buf)->mmap) {
#line 132
          if (log->log_level >= 2UL) {
            {
#line 132
            ngx_log_error_core((ngx_uint_t )2, log, 0, "bad buf in output chain t:%d r:%d f:%d %p %p-%p %p %O-%O",
                               (in->buf)->temporary, (in->buf)->recycled, (in->buf)->in_file,
                               (in->buf)->start, (in->buf)->pos, (in->buf)->last,
                               (in->buf)->file, (in->buf)->file_pos, (in->buf)->file_last);
            }
          }
          {
#line 145
          ngx_debug_point();
          }
#line 147
          return ((ngx_chain_t *)-1);
        }
      }
    }
#line 150
    size = (size_t___0 )((in->buf)->last - (in->buf)->pos);
#line 152
    if (size > limit - total) {
#line 153
      size = limit - total;
    }
#line 156
    if ((unsigned long )prev == (unsigned long )(in->buf)->pos) {
#line 157
      iov->iov_len += size;
    } else {
#line 160
      if (n == vec->nalloc) {
#line 161
        goto while_break;
      }
#line 164
      tmp = n;
#line 164
      n ++;
#line 164
      iov = vec->iovs + tmp;
#line 166
      iov->iov_base = (void *)(in->buf)->pos;
#line 167
      iov->iov_len = size;
    }
#line 170
    prev = (in->buf)->pos + size;
#line 171
    total += size;
    __Cont: /* CIL Label */ 
#line 121
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  vec->count = n;
#line 175
  vec->size = total;
#line 177
  return (in);
}
}
#line 181 "/tmp/nginx-1.13.2/src/os/unix/ngx_writev_chain.c"
ssize_t ngx_writev(ngx_connection_t *c , ngx_iovec_t *vec ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  int *tmp ;

  {
  eintr: 
  {
#line 189
  n = writev(c->fd, (struct iovec  const  *)vec->iovs, (int )vec->count);
  }
#line 194
  if (n == -1L) {
    {
#line 195
    tmp = __errno_location();
#line 195
    err = *tmp;
    }
    {
#line 198
    if (err == 11) {
#line 198
      goto case_11;
    }
#line 203
    if (err == 4) {
#line 203
      goto case_4;
    }
#line 208
    goto switch_default;
    case_11: /* CIL Label */ ;
#line 201
    return ((ssize_t )-2);
    case_4: /* CIL Label */ ;
#line 206
    goto eintr;
    switch_default: /* CIL Label */ 
    {
#line 209
    (c->write)->error = 1U;
#line 210
    ngx_connection_error(c, err, (char *)"writev() failed");
    }
#line 211
    return ((ssize_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 215
  return (n);
}
}
#line 138 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t___0 __n , int __flags ) ;
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_send.c"
ssize_t ngx_unix_send(ngx_connection_t *c , u_char *buf , size_t___0 size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *wev ;
  int *tmp ;

  {
#line 20
  wev = c->write;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 34
    n = send(c->fd, (void const   *)buf, size, 0);
    }
#line 39
    if (n > 0L) {
#line 40
      if (n < (ssize_t )size) {
#line 41
        wev->ready = 0U;
      }
#line 44
      c->sent += n;
#line 46
      return (n);
    }
    {
#line 49
    tmp = __errno_location();
#line 49
    err = *tmp;
    }
#line 51
    if (n == 0L) {
#line 52
      if ((c->log)->log_level >= 2UL) {
        {
#line 52
        ngx_log_error_core((ngx_uint_t )2, c->log, err, "send() returned zero");
        }
      }
#line 53
      wev->ready = 0U;
#line 54
      return (n);
    }
#line 57
    if (err == 11) {
#line 57
      goto _L;
    } else
#line 57
    if (err == 4) {
      _L: /* CIL Label */ 
#line 58
      wev->ready = 0U;
#line 63
      if (err == 11) {
#line 64
        return ((ssize_t )-2);
      }
    } else {
      {
#line 68
      wev->error = 1U;
#line 69
      ngx_connection_error(c, err, (char *)"send() failed");
      }
#line 70
      return ((ssize_t )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_udp_recv.c"
ssize_t ngx_udp_unix_recv(ngx_connection_t *c , u_char *buf , size_t___0 size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  int *tmp ;

  {
#line 20
  rev = c->read;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 23
    n = recv(c->fd, (void *)buf, size, 0);
    }
#line 28
    if (n >= 0L) {
#line 48
      return (n);
    }
    {
#line 51
    tmp = __errno_location();
#line 51
    err = *tmp;
    }
#line 53
    if (err == 11) {
#line 56
      n = (ssize_t )-2;
    } else
#line 53
    if (err == 4) {
#line 56
      n = (ssize_t )-2;
    } else {
      {
#line 59
      n = ngx_connection_error(c, err, (char *)"recv() failed");
      }
#line 60
      goto while_break;
    }
#line 22
    if (! (err == 4)) {
#line 22
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  rev->ready = 0U;
#line 67
  if (n == -1L) {
#line 68
    rev->error = 1U;
  }
#line 71
  return (n);
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_readv_chain.c"
ssize_t ngx_readv_chain(ngx_connection_t *c , ngx_chain_t *chain , off_t limit ) 
{ 
  u_char *prev ;
  ssize_t n ;
  ssize_t size ;
  ngx_err_t err ;
  ngx_array_t vec ;
  ngx_event_t *rev ;
  struct iovec *iov ;
  struct iovec iovs[64] ;
  void *tmp ;
  int *tmp___0 ;

  {
#line 23
  rev = c->read;
#line 58
  if (ngx_event_flags & 64UL) {
#line 63
    if (! rev->available) {
#line 63
      if (! rev->pending_eof) {
#line 64
        return ((ssize_t )-2);
      }
    }
  }
#line 70
  prev = (u_char *)((void *)0);
#line 71
  iov = (struct iovec *)((void *)0);
#line 72
  size = (ssize_t )0;
#line 74
  vec.elts = (void *)(iovs);
#line 75
  vec.nelts = (ngx_uint_t )0;
#line 76
  vec.size = sizeof(struct iovec );
#line 77
  vec.nalloc = (ngx_uint_t )64;
#line 78
  vec.pool = c->pool;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! chain) {
#line 82
      goto while_break;
    }
#line 83
    n = (chain->buf)->end - (chain->buf)->last;
#line 85
    if (limit) {
#line 86
      if (size >= limit) {
#line 87
        goto while_break;
      }
#line 90
      if (size + n > limit) {
#line 91
        n = limit - size;
      }
    }
#line 95
    if ((unsigned long )prev == (unsigned long )(chain->buf)->last) {
#line 96
      iov->iov_len += (size_t___0 )n;
    } else {
#line 99
      if (vec.nelts >= 1024UL) {
#line 100
        goto while_break;
      }
      {
#line 103
      tmp = ngx_array_push(& vec);
#line 103
      iov = (struct iovec *)tmp;
      }
#line 104
      if ((unsigned long )iov == (unsigned long )((void *)0)) {
#line 105
        return ((ssize_t )-1);
      }
#line 108
      iov->iov_base = (void *)(chain->buf)->last;
#line 109
      iov->iov_len = (size_t___0 )n;
    }
#line 112
    size += n;
#line 113
    prev = (chain->buf)->end;
#line 114
    chain = chain->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 121
    n = readv(c->fd, (struct iovec  const  *)((struct iovec *)vec.elts), (int )vec.nelts);
    }
#line 123
    if (n == 0L) {
#line 124
      rev->ready = 0U;
#line 125
      rev->eof = 1U;
#line 140
      return ((ssize_t )0);
    }
#line 143
    if (n > 0L) {
#line 170
      if (ngx_event_flags & 64UL) {
#line 170
        if (ngx_use_epoll_rdhup) {
#line 173
          if (n < size) {
#line 174
            if (! rev->pending_eof) {
#line 175
              rev->ready = 0U;
            }
#line 178
            rev->available = 0U;
          }
#line 181
          return (n);
        }
      }
#line 186
      if (n < size) {
#line 186
        if (! (ngx_event_flags & 32UL)) {
#line 187
          rev->ready = 0U;
        }
      }
#line 190
      return (n);
    }
    {
#line 193
    tmp___0 = __errno_location();
#line 193
    err = *tmp___0;
    }
#line 195
    if (err == 11) {
#line 198
      n = (ssize_t )-2;
    } else
#line 195
    if (err == 4) {
#line 198
      n = (ssize_t )-2;
    } else {
      {
#line 201
      n = ngx_connection_error(c, err, (char *)"readv() failed");
      }
#line 202
      goto while_break___0;
    }
#line 120
    if (! (err == 4)) {
#line 120
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 207
  rev->ready = 0U;
#line 209
  if (n == -1L) {
#line 210
    (c->read)->error = 1U;
  }
#line 213
  return (n);
}
}
#line 13 "/tmp/nginx-1.13.2/src/os/unix/ngx_recv.c"
ssize_t ngx_unix_recv(ngx_connection_t *c , u_char *buf , size_t___0 size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  int *tmp ;

  {
#line 20
  rev = c->read;
#line 55
  if (ngx_event_flags & 64UL) {
#line 60
    if (! rev->available) {
#line 60
      if (! rev->pending_eof) {
#line 61
        rev->ready = 0U;
#line 62
        return ((ssize_t )-2);
      }
    }
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    n = recv(c->fd, (void *)buf, size, 0);
    }
#line 74
    if (n == 0L) {
#line 75
      rev->ready = 0U;
#line 76
      rev->eof = 1U;
#line 91
      return ((ssize_t )0);
    }
#line 94
    if (n > 0L) {
#line 121
      if (ngx_event_flags & 64UL) {
#line 121
        if (ngx_use_epoll_rdhup) {
#line 124
          if ((size_t___0 )n < size) {
#line 125
            if (! rev->pending_eof) {
#line 126
              rev->ready = 0U;
            }
#line 129
            rev->available = 0U;
          }
#line 132
          return (n);
        }
      }
#line 137
      if ((size_t___0 )n < size) {
#line 137
        if (! (ngx_event_flags & 32UL)) {
#line 140
          rev->ready = 0U;
        }
      }
#line 143
      return (n);
    }
    {
#line 146
    tmp = __errno_location();
#line 146
    err = *tmp;
    }
#line 148
    if (err == 11) {
#line 151
      n = (ssize_t )-2;
    } else
#line 148
    if (err == 4) {
#line 151
      n = (ssize_t )-2;
    } else {
      {
#line 154
      n = ngx_connection_error(c, err, (char *)"recv() failed");
      }
#line 155
      goto while_break;
    }
#line 68
    if (! (err == 4)) {
#line 68
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  rev->ready = 0U;
#line 162
  if (n == -1L) {
#line 163
    rev->error = 1U;
  }
#line 166
  return (n);
}
}
#line 26 "src/os/unix/ngx_socket.h"
int ngx_blocking(ngx_socket_t s ) ;
#line 26 "/tmp/nginx-1.13.2/src/os/unix/ngx_socket.c"
int ngx_nonblocking(ngx_socket_t s ) 
{ 
  int nb ;
  int tmp ;

  {
  {
#line 31
  nb = 1;
#line 33
  tmp = ioctl(s, 21537UL, & nb);
  }
#line 33
  return (tmp);
}
}
#line 37 "/tmp/nginx-1.13.2/src/os/unix/ngx_socket.c"
int ngx_blocking(ngx_socket_t s ) 
{ 
  int nb ;
  int tmp ;

  {
  {
#line 42
  nb = 0;
#line 44
  tmp = ioctl(s, 21537UL, & nb);
  }
#line 44
  return (tmp);
}
}
#line 78 "/tmp/nginx-1.13.2/src/os/unix/ngx_socket.c"
int ngx_tcp_nopush(ngx_socket_t s ) 
{ 
  int cork ;
  int tmp ;

  {
  {
#line 83
  cork = 1;
#line 85
  tmp = setsockopt(s, 6, 3, (void const   *)(& cork), (socklen_t )sizeof(int ));
  }
#line 85
  return (tmp);
}
}
#line 90 "/tmp/nginx-1.13.2/src/os/unix/ngx_socket.c"
int ngx_tcp_push(ngx_socket_t s ) 
{ 
  int cork ;
  int tmp ;

  {
  {
#line 95
  cork = 0;
#line 97
  tmp = setsockopt(s, 6, 3, (void const   *)(& cork), (socklen_t )sizeof(int ));
  }
#line 97
  return (tmp);
}
}
#line 135 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utimes)(char const   *__file ,
                                                                                   struct timeval  const  *__tvp ) ;
#line 391 "/usr/include/unistd.h"
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pread64")  ;
#line 394
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pwrite64")  ;
#line 1020
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 153 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int glob(char const   * __restrict  __pattern ,
                                              int __flags , int (*__errfunc)(char const   * ,
                                                                             int  ) ,
                                              glob_t * __restrict  __pglob )  __asm__("glob64")  ;
#line 158
extern  __attribute__((__nothrow__)) void globfree(glob_t *__pglob )  __asm__("globfree64")  ;
#line 35 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) statfs)(char const   *__file ,
                                                                                     struct statfs *__buf )  __asm__("statfs64")  ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t pwritev(int __fd , struct iovec  const  *__iovec , int __count , __off64_t __offset )  __asm__("pwritev64")  ;
#line 253 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off64_t __offset ,
                                                       __off64_t __len , int __advise )  __asm__("posix_fadvise64")  ;
#line 117 "src/os/unix/ngx_files.h"
ngx_fd_t ngx_open_tempfile(u_char *name , ngx_uint_t persistent , ngx_uint_t access___0 ) ;
#line 132
ssize_t ngx_write_chain_to_file(ngx_file_t *file , ngx_chain_t *cl , off_t offset ,
                                ngx_pool_t *pool ) ;
#line 169
ngx_int_t ngx_set_file_time(u_char *name , ngx_fd_t fd , time_t s ) ;
#line 289
ngx_int_t ngx_open_glob(ngx_glob_t *gl ) ;
#line 291
ngx_int_t ngx_read_glob(ngx_glob_t *gl , ngx_str_t *name ) ;
#line 292
void ngx_close_glob(ngx_glob_t *gl ) ;
#line 295
ngx_err_t ngx_trylock_fd(ngx_fd_t fd ) ;
#line 296
ngx_err_t ngx_lock_fd(ngx_fd_t fd ) ;
#line 297
ngx_err_t ngx_unlock_fd(ngx_fd_t fd ) ;
#line 315
ngx_int_t ngx_read_ahead(ngx_fd_t fd , size_t___0 n ) ;
#line 328
ngx_int_t ngx_directio_on(ngx_fd_t fd ) ;
#line 331
ngx_int_t ngx_directio_off(ngx_fd_t fd ) ;
#line 18 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
static ngx_chain_t *ngx_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *cl ) ;
#line 19
static ssize_t ngx_writev_file(ngx_file_t *file , ngx_iovec_t *vec , off_t offset ) ;
#line 30 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ssize_t ngx_read_file(ngx_file_t *file , u_char *buf , size_t___0 size , off_t offset ) 
{ 
  ssize_t n ;
  int *tmp ;

  {
  {
#line 40
  n = pread(file->fd, (void *)buf, size, offset);
  }
#line 42
  if (n == -1L) {
#line 43
    if ((file->log)->log_level >= 3UL) {
      {
#line 43
      tmp = __errno_location();
#line 43
      ngx_log_error_core((ngx_uint_t )3, file->log, *tmp, "pread() \"%s\" failed",
                         file->name.data);
      }
    }
#line 45
    return ((ssize_t )-1);
  }
#line 72
  file->offset += n;
#line 74
  return (n);
}
}
#line 192 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ssize_t ngx_write_file(ngx_file_t *file , u_char *buf , size_t___0 size , off_t offset ) 
{ 
  ssize_t n ;
  ssize_t written ;
  ngx_err_t err ;
  int *tmp ;

  {
#line 201
  written = (ssize_t )0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    n = pwrite(file->fd, (void const   *)(buf + written), size, offset);
    }
#line 208
    if (n == -1L) {
      {
#line 209
      tmp = __errno_location();
#line 209
      err = *tmp;
      }
#line 211
      if (err == 4) {
#line 214
        goto __Cont;
      }
#line 217
      if ((file->log)->log_level >= 3UL) {
        {
#line 217
        ngx_log_error_core((ngx_uint_t )3, file->log, err, "pwrite() \"%s\" failed",
                           file->name.data);
        }
      }
#line 219
      return ((ssize_t )-1);
    }
#line 222
    file->offset += n;
#line 223
    written += n;
#line 225
    if ((size_t___0 )n == size) {
#line 226
      return (written);
    }
#line 229
    offset += n;
#line 230
    size -= (size_t___0 )n;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 276 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_fd_t ngx_open_tempfile(u_char *name , ngx_uint_t persistent , ngx_uint_t access___0 ) 
{ 
  ngx_fd_t fd ;
  ngx_uint_t tmp ;

  {
#line 281
  if (access___0) {
#line 281
    tmp = access___0;
  } else {
#line 281
    tmp = (ngx_uint_t )384;
  }
  {
#line 281
  fd = open((char const   *)name, 194, tmp);
  }
#line 284
  if (fd != -1) {
#line 284
    if (! persistent) {
      {
#line 285
      unlink((char const   *)name);
      }
    }
  }
#line 288
  return (fd);
}
}
#line 292 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ssize_t ngx_write_chain_to_file(ngx_file_t *file , ngx_chain_t *cl , off_t offset ,
                                ngx_pool_t *pool ) 
{ 
  ssize_t total ;
  ssize_t n ;
  ngx_iovec_t vec ;
  struct iovec iovs[64] ;
  ssize_t tmp ;

  {
#line 302
  if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
    {
#line 303
    tmp = ngx_write_file(file, (cl->buf)->pos, (size_t___0 )((cl->buf)->last - (cl->buf)->pos),
                         offset);
    }
#line 303
    return (tmp);
  }
#line 308
  total = (ssize_t )0;
#line 310
  vec.iovs = iovs;
#line 311
  vec.nalloc = (ngx_uint_t )64;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 315
    cl = ngx_chain_to_iovec(& vec, cl);
    }
#line 319
    if (vec.count == 1UL) {
      {
#line 320
      n = ngx_write_file(file, (u_char *)iovs[0].iov_base, iovs[0].iov_len, offset);
      }
#line 323
      if (n == -1L) {
#line 324
        return (n);
      }
#line 327
      return (total + n);
    }
    {
#line 330
    n = ngx_writev_file(file, & vec, offset);
    }
#line 332
    if (n == -1L) {
#line 333
      return (n);
    }
#line 336
    offset += n;
#line 337
    total += n;
#line 313
    if (! cl) {
#line 313
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return (total);
}
}
#line 345 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
static ngx_chain_t *ngx_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *cl ) 
{ 
  size_t___0 total ;
  size_t___0 size ;
  u_char *prev ;
  ngx_uint_t n ;
  struct iovec *iov ;
  ngx_uint_t tmp ;

  {
#line 353
  iov = (struct iovec *)((void *)0);
#line 354
  prev = (u_char *)((void *)0);
#line 355
  total = (size_t___0 )0;
#line 356
  n = (ngx_uint_t )0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! cl) {
#line 358
      goto while_break;
    }
#line 360
    if ((cl->buf)->flush) {
#line 360
      goto _L;
    } else
#line 360
    if ((cl->buf)->last_buf) {
#line 360
      goto _L;
    } else
#line 360
    if ((cl->buf)->sync) {
      _L: /* CIL Label */ 
#line 360
      if (! (cl->buf)->temporary) {
#line 360
        if (! (cl->buf)->memory) {
#line 360
          if (! (cl->buf)->mmap) {
#line 360
            if (! (cl->buf)->in_file) {
#line 361
              goto __Cont;
            }
          }
        }
      }
    }
#line 364
    size = (size_t___0 )((cl->buf)->last - (cl->buf)->pos);
#line 366
    if ((unsigned long )prev == (unsigned long )(cl->buf)->pos) {
#line 367
      iov->iov_len += size;
    } else {
#line 370
      if (n == vec->nalloc) {
#line 371
        goto while_break;
      }
#line 374
      tmp = n;
#line 374
      n ++;
#line 374
      iov = vec->iovs + tmp;
#line 376
      iov->iov_base = (void *)(cl->buf)->pos;
#line 377
      iov->iov_len = size;
    }
#line 380
    prev = (cl->buf)->pos + size;
#line 381
    total += size;
    __Cont: /* CIL Label */ 
#line 358
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  vec->count = n;
#line 385
  vec->size = total;
#line 387
  return (cl);
}
}
#line 391 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
static ssize_t ngx_writev_file(ngx_file_t *file , ngx_iovec_t *vec , off_t offset ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  int *tmp ;

  {
  eintr: 
  {
#line 404
  n = pwritev(file->fd, (struct iovec  const  *)vec->iovs, (int )vec->count, offset);
  }
#line 406
  if (n == -1L) {
    {
#line 407
    tmp = __errno_location();
#line 407
    err = *tmp;
    }
#line 409
    if (err == 4) {
#line 412
      goto eintr;
    }
#line 415
    if ((file->log)->log_level >= 3UL) {
      {
#line 415
      ngx_log_error_core((ngx_uint_t )3, file->log, err, "pwritev() \"%s\" failed",
                         file->name.data);
      }
    }
#line 417
    return ((ssize_t )-1);
  }
#line 420
  if ((size_t___0 )n != vec->size) {
#line 421
    if ((file->log)->log_level >= 3UL) {
      {
#line 421
      ngx_log_error_core((ngx_uint_t )3, file->log, 0, "pwritev() \"%s\" has written only %z of %uz",
                         file->name.data, n, vec->size);
      }
    }
#line 424
    return ((ssize_t )-1);
  }
#line 468
  file->offset += n;
#line 470
  return (n);
}
}
#line 600 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_set_file_time(u_char *name , ngx_fd_t fd , time_t s ) 
{ 
  struct timeval tv[2] ;
  int tmp ;

  {
  {
#line 605
  tv[0].tv_sec = (__time_t )ngx_cached_time->sec;
#line 606
  tv[0].tv_usec = (__suseconds_t )0;
#line 607
  tv[1].tv_sec = s;
#line 608
  tv[1].tv_usec = (__suseconds_t )0;
#line 610
  tmp = utimes((char const   *)((char *)name), (struct timeval  const  *)(tv));
  }
#line 610
  if (tmp != -1) {
#line 611
    return ((ngx_int_t )0);
  }
#line 614
  return ((ngx_int_t )-1);
}
}
#line 618 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 621
  fm->fd = open((char const   *)fm->name, 578, 420);
  }
#line 623
  if (fm->fd == -1) {
#line 624
    if ((fm->log)->log_level >= 3UL) {
      {
#line 624
      tmp = __errno_location();
#line 624
      ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp, "open() \"%s\" failed", fm->name);
      }
    }
#line 626
    return ((ngx_int_t )-1);
  }
  {
#line 629
  tmp___1 = ftruncate(fm->fd, (__off64_t )fm->size);
  }
#line 629
  if (tmp___1 == -1) {
#line 630
    if ((fm->log)->log_level >= 3UL) {
      {
#line 630
      tmp___0 = __errno_location();
#line 630
      ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp___0, "ftruncate() \"%s\" failed",
                         fm->name);
      }
    }
#line 632
    goto failed;
  }
  {
#line 635
  fm->addr = mmap((void *)0, fm->size, 3, 1, fm->fd, (__off64_t )0);
  }
#line 637
  if ((unsigned long )fm->addr != (unsigned long )((void *)-1)) {
#line 638
    return ((ngx_int_t )0);
  }
#line 641
  if ((fm->log)->log_level >= 3UL) {
    {
#line 641
    tmp___2 = __errno_location();
#line 641
    ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp___2, "mmap(%uz) \"%s\" failed",
                       fm->size, fm->name);
    }
  }
  failed: 
  {
#line 646
  tmp___4 = close(fm->fd);
  }
#line 646
  if (tmp___4 == -1) {
#line 647
    if ((fm->log)->log_level >= 2UL) {
      {
#line 647
      tmp___3 = __errno_location();
#line 647
      ngx_log_error_core((ngx_uint_t )2, fm->log, *tmp___3, "close() \"%s\" failed",
                         fm->name);
      }
    }
  }
#line 651
  return ((ngx_int_t )-1);
}
}
#line 655 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
void ngx_close_file_mapping(ngx_file_mapping_t *fm ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 658
  tmp___0 = munmap(fm->addr, fm->size);
  }
#line 658
  if (tmp___0 == -1) {
#line 659
    if ((fm->log)->log_level >= 3UL) {
      {
#line 659
      tmp = __errno_location();
#line 659
      ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp, "munmap(%uz) \"%s\" failed",
                         fm->size, fm->name);
      }
    }
  }
  {
#line 663
  tmp___2 = close(fm->fd);
  }
#line 663
  if (tmp___2 == -1) {
#line 664
    if ((fm->log)->log_level >= 2UL) {
      {
#line 664
      tmp___1 = __errno_location();
#line 664
      ngx_log_error_core((ngx_uint_t )2, fm->log, *tmp___1, "close() \"%s\" failed",
                         fm->name);
      }
    }
  }
#line 667
  return;
}
}
#line 670 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_open_dir(ngx_str_t *name , ngx_dir_t *dir ) 
{ 


  {
  {
#line 673
  dir->dir = opendir((char const   *)name->data);
  }
#line 675
  if ((unsigned long )dir->dir == (unsigned long )((void *)0)) {
#line 676
    return ((ngx_int_t )-1);
  }
#line 679
  dir->valid_info = 0U;
#line 681
  return ((ngx_int_t )0);
}
}
#line 685 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_read_dir(ngx_dir_t *dir ) 
{ 


  {
  {
#line 688
  dir->de = readdir(dir->dir);
  }
#line 690
  if (dir->de) {
#line 692
    dir->type = (unsigned int )(dir->de)->d_type;
#line 696
    return ((ngx_int_t )0);
  }
#line 699
  return ((ngx_int_t )-1);
}
}
#line 703 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_open_glob(ngx_glob_t *gl ) 
{ 
  int n ;

  {
  {
#line 708
  n = glob((char const   */* __restrict  */)((char *)gl->pattern), 0, (int (*)(char const   * ,
                                                                               int  ))((void *)0),
           (glob_t */* __restrict  */)(& gl->pglob));
  }
#line 710
  if (n == 0) {
#line 711
    return ((ngx_int_t )0);
  }
#line 716
  if (n == 3) {
#line 716
    if (gl->test) {
#line 717
      return ((ngx_int_t )0);
    }
  }
#line 722
  return ((ngx_int_t )-1);
}
}
#line 726 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_read_glob(ngx_glob_t *gl , ngx_str_t *name ) 
{ 
  size_t___0 count ;
  size_t tmp ;

  {
#line 732
  count = gl->pglob.gl_pathc;
#line 737
  if (gl->n < count) {
    {
#line 739
    tmp = strlen((char const   *)*(gl->pglob.gl_pathv + gl->n));
#line 739
    name->len = tmp;
#line 740
    name->data = (u_char *)*(gl->pglob.gl_pathv + gl->n);
#line 741
    (gl->n) ++;
    }
#line 743
    return ((ngx_int_t )0);
  }
#line 746
  return ((ngx_int_t )-4);
}
}
#line 750 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
void ngx_close_glob(ngx_glob_t *gl ) 
{ 


  {
  {
#line 753
  globfree(& gl->pglob);
  }
#line 754
  return;
}
}
#line 757 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_err_t ngx_trylock_fd(ngx_fd_t fd ) 
{ 
  struct flock fl ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 762
  memset((void *)(& fl), 0, sizeof(struct flock ));
#line 763
  fl.l_type = (short)1;
#line 764
  fl.l_whence = (short)0;
#line 766
  tmp___0 = fcntl(fd, 6, & fl);
  }
#line 766
  if (tmp___0 == -1) {
    {
#line 767
    tmp = __errno_location();
    }
#line 767
    return (*tmp);
  }
#line 770
  return (0);
}
}
#line 774 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_err_t ngx_lock_fd(ngx_fd_t fd ) 
{ 
  struct flock fl ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 779
  memset((void *)(& fl), 0, sizeof(struct flock ));
#line 780
  fl.l_type = (short)1;
#line 781
  fl.l_whence = (short)0;
#line 783
  tmp___0 = fcntl(fd, 7, & fl);
  }
#line 783
  if (tmp___0 == -1) {
    {
#line 784
    tmp = __errno_location();
    }
#line 784
    return (*tmp);
  }
#line 787
  return (0);
}
}
#line 791 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_err_t ngx_unlock_fd(ngx_fd_t fd ) 
{ 
  struct flock fl ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 796
  memset((void *)(& fl), 0, sizeof(struct flock ));
#line 797
  fl.l_type = (short)2;
#line 798
  fl.l_whence = (short)0;
#line 800
  tmp___0 = fcntl(fd, 6, & fl);
  }
#line 800
  if (tmp___0 == -1) {
    {
#line 801
    tmp = __errno_location();
    }
#line 801
    return (*tmp);
  }
#line 804
  return (0);
}
}
#line 810 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_read_ahead(ngx_fd_t fd , size_t___0 n ) 
{ 
  int err ;
  int *tmp ;

  {
  {
#line 815
  err = posix_fadvise(fd, (__off64_t )0, (__off64_t )0, 2);
  }
#line 817
  if (err == 0) {
#line 818
    return ((ngx_int_t )0);
  }
  {
#line 821
  tmp = __errno_location();
#line 821
  *tmp = err;
  }
#line 822
  return ((ngx_int_t )-1);
}
}
#line 830 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_directio_on(ngx_fd_t fd ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 835
  flags = fcntl(fd, 3);
  }
#line 837
  if (flags == -1) {
#line 838
    return ((ngx_int_t )-1);
  }
  {
#line 841
  tmp = fcntl(fd, 4, flags | 16384);
  }
#line 841
  return ((ngx_int_t )tmp);
}
}
#line 845 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
ngx_int_t ngx_directio_off(ngx_fd_t fd ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 850
  flags = fcntl(fd, 3);
  }
#line 852
  if (flags == -1) {
#line 853
    return ((ngx_int_t )-1);
  }
  {
#line 856
  tmp = fcntl(fd, 4, flags & -16385);
  }
#line 856
  return ((ngx_int_t )tmp);
}
}
#line 864 "/tmp/nginx-1.13.2/src/os/unix/ngx_files.c"
size_t___0 ngx_fs_bsize(u_char *name ) 
{ 
  struct statfs fs ;
  int tmp ;

  {
  {
#line 869
  tmp = statfs((char const   *)((char *)name), & fs);
  }
#line 869
  if (tmp == -1) {
#line 870
    return ((size_t___0 )512);
  }
#line 873
  if (fs.f_bsize % 512L != 0L) {
#line 874
    return ((size_t___0 )512);
  }
#line 877
  return ((size_t___0 )fs.f_bsize);
}
}
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(unsigned long __size )  __attribute__((__malloc__)) ;
#line 577
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) posix_memalign)(void **__memptr ,
                                                                                           size_t __alignment ,
                                                                                           size_t __size ) ;
#line 17 "src/os/unix/ngx_alloc.h"
void *ngx_calloc(size_t___0 size , ngx_log_t *log ) ;
#line 31
void *ngx_memalign(size_t___0 alignment , size_t___0 size , ngx_log_t *log ) ;
#line 40 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize  ;
#line 41 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize_shift  ;
#line 42 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_cacheline_size  ;
#line 17 "/tmp/nginx-1.13.2/src/os/unix/ngx_alloc.c"
void *ngx_alloc(size_t___0 size , ngx_log_t *log ) 
{ 
  void *p ;
  int *tmp ;

  {
  {
#line 22
  p = malloc(size);
  }
#line 23
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 24
    if (log->log_level >= 1UL) {
      {
#line 24
      tmp = __errno_location();
#line 24
      ngx_log_error_core((ngx_uint_t )1, log, *tmp, "malloc(%uz) failed", size);
      }
    }
  }
#line 30
  return (p);
}
}
#line 34 "/tmp/nginx-1.13.2/src/os/unix/ngx_alloc.c"
void *ngx_calloc(size_t___0 size , ngx_log_t *log ) 
{ 
  void *p ;

  {
  {
#line 39
  p = ngx_alloc(size, log);
  }
#line 41
  if (p) {
    {
#line 42
    memset(p, 0, size);
    }
  }
#line 45
  return (p);
}
}
#line 51 "/tmp/nginx-1.13.2/src/os/unix/ngx_alloc.c"
void *ngx_memalign(size_t___0 alignment , size_t___0 size , ngx_log_t *log ) 
{ 
  void *p ;
  int err ;

  {
  {
#line 57
  err = posix_memalign(& p, alignment, size);
  }
#line 59
  if (err) {
#line 60
    if (log->log_level >= 1UL) {
      {
#line 60
      ngx_log_error_core((ngx_uint_t )1, log, err, "posix_memalign(%uz, %uz) failed",
                         alignment, size);
      }
    }
#line 62
    p = (void *)0;
  }
#line 68
  return (p);
}
}
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 75 "src/os/unix/ngx_errno.h"
u_char *ngx_strerror(ngx_err_t err , u_char *errstr , size_t___0 size ) ;
#line 76
ngx_int_t ngx_strerror_init(void) ;
#line 233 "src/core/ngx_log.h"
void ngx_log_stderr(ngx_err_t err , char const   *fmt  , ...) ;
#line 28 "/tmp/nginx-1.13.2/src/os/unix/ngx_errno.c"
static ngx_str_t *ngx_sys_errlist  ;
#line 29 "/tmp/nginx-1.13.2/src/os/unix/ngx_errno.c"
static ngx_str_t ngx_unknown_error  =    {sizeof("Unknown error") - 1UL, (u_char *)"Unknown error"};
#line 32 "/tmp/nginx-1.13.2/src/os/unix/ngx_errno.c"
u_char *ngx_strerror(ngx_err_t err , u_char *errstr , size_t___0 size ) 
{ 
  ngx_str_t *msg ;
  void *tmp ;

  {
#line 37
  if ((ngx_uint_t )err < 135UL) {
#line 37
    msg = ngx_sys_errlist + err;
  } else {
#line 37
    msg = & ngx_unknown_error;
  }
#line 39
  if (size > msg->len) {
#line 39
    size = msg->len;
  } else {
#line 39
    size = size;
  }
  {
#line 41
  tmp = memcpy((void */* __restrict  */)errstr, (void const   */* __restrict  */)msg->data,
               size);
  }
#line 41
  return ((u_char *)tmp + size);
}
}
#line 45 "/tmp/nginx-1.13.2/src/os/unix/ngx_errno.c"
ngx_int_t ngx_strerror_init(void) 
{ 
  char *msg ;
  u_char *p ;
  size_t___0 len ;
  ngx_err_t err ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 58
  len = 135UL * sizeof(ngx_str_t );
#line 60
  tmp = malloc(len);
#line 60
  ngx_sys_errlist = (ngx_str_t *)tmp;
  }
#line 61
  if ((unsigned long )ngx_sys_errlist == (unsigned long )((void *)0)) {
#line 62
    goto failed;
  }
#line 65
  err = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (err < 135)) {
#line 65
      goto while_break;
    }
    {
#line 66
    msg = strerror(err);
#line 67
    len = strlen((char const   *)msg);
#line 69
    tmp___0 = malloc(len);
#line 69
    p = (u_char *)tmp___0;
    }
#line 70
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 71
      goto failed;
    }
    {
#line 74
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)msg, len);
#line 75
    (ngx_sys_errlist + err)->len = len;
#line 76
    (ngx_sys_errlist + err)->data = p;
#line 65
    err ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return ((ngx_int_t )0);
  failed: 
  {
#line 83
  tmp___1 = __errno_location();
#line 83
  err = *tmp___1;
#line 84
  tmp___2 = strerror(err);
#line 84
  ngx_log_stderr(0, "malloc(%uz) failed (%d: %s)", len, err, tmp___2);
  }
#line 86
  return ((ngx_int_t )-1);
}
}
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 123
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
#line 56 "src/os/unix/ngx_time.h"
void ngx_timezone_update(void) ;
#line 57
void ngx_localtime(time_t s , ngx_tm_t *tm ) ;
#line 24 "/tmp/nginx-1.13.2/src/os/unix/ngx_time.c"
void ngx_timezone_update(void) 
{ 
  time_t s ;
  struct tm *t ;
  char buf[4] ;

  {
  {
#line 46
  s = time((time_t *)0);
#line 48
  t = localtime((time_t const   *)(& s));
#line 50
  strftime((char */* __restrict  */)(buf), (size_t___0 )4, (char const   */* __restrict  */)"%H",
           (struct tm  const  */* __restrict  */)t);
  }
#line 53
  return;
}
}
#line 56 "/tmp/nginx-1.13.2/src/os/unix/ngx_time.c"
void ngx_localtime(time_t s , ngx_tm_t *tm ) 
{ 


  {
  {
#line 60
  localtime_r((time_t const   */* __restrict  */)(& s), (struct tm */* __restrict  */)tm);
#line 70
  (tm->tm_mon) ++;
#line 71
  tm->tm_year += 1900;
  }
#line 72
  return;
}
}
#line 75 "/tmp/nginx-1.13.2/src/os/unix/ngx_time.c"
void ngx_libc_localtime(time_t s , struct tm *tm ) 
{ 


  {
  {
#line 79
  localtime_r((time_t const   */* __restrict  */)(& s), (struct tm */* __restrict  */)tm);
  }
#line 88
  return;
}
}
#line 91 "/tmp/nginx-1.13.2/src/os/unix/ngx_time.c"
void ngx_libc_gmtime(time_t s , struct tm *tm ) 
{ 


  {
  {
#line 95
  gmtime_r((time_t const   */* __restrict  */)(& s), (struct tm */* __restrict  */)tm);
  }
#line 104
  return;
}
}
#line 14 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_read_upstream(ngx_event_pipe_t *p ) ;
#line 15
static ngx_int_t ngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p ) ;
#line 17
static ngx_int_t ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t *p ) ;
#line 18
__inline static void ngx_event_pipe_remove_shadow_links(ngx_buf_t *buf ) ;
#line 19
static ngx_int_t ngx_event_pipe_drain_chains(ngx_event_pipe_t *p ) ;
#line 22 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
ngx_int_t ngx_event_pipe(ngx_event_pipe_t *p , ngx_int_t do_write ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t flags ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (do_write) {
      {
#line 31
      (p->log)->action = (char *)"sending to client";
#line 33
      rc = ngx_event_pipe_write_to_downstream(p);
      }
#line 35
      if (rc == -6L) {
#line 36
        return ((ngx_int_t )-6);
      }
#line 39
      if (rc == -3L) {
#line 40
        return ((ngx_int_t )0);
      }
    }
    {
#line 44
    p->read = 0U;
#line 45
    p->upstream_blocked = 0U;
#line 47
    (p->log)->action = (char *)"reading upstream";
#line 49
    tmp = ngx_event_pipe_read_upstream(p);
    }
#line 49
    if (tmp == -6L) {
#line 50
      return ((ngx_int_t )-6);
    }
#line 53
    if (! p->read) {
#line 53
      if (! p->upstream_blocked) {
#line 54
        goto while_break;
      }
    }
#line 57
    do_write = (ngx_int_t )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if ((p->upstream)->fd != -1) {
#line 61
    rev = (p->upstream)->read;
#line 63
    if (rev->eof) {
#line 63
      flags = (ngx_uint_t )1;
    } else
#line 63
    if (rev->error) {
#line 63
      flags = (ngx_uint_t )1;
    } else {
#line 63
      flags = (ngx_uint_t )0;
    }
    {
#line 65
    tmp___0 = ngx_handle_read_event(rev, flags);
    }
#line 65
    if (tmp___0 != 0L) {
#line 66
      return ((ngx_int_t )-6);
    }
#line 69
    if (! rev->delayed) {
#line 70
      if (rev->active) {
#line 70
        if (! rev->ready) {
          {
#line 71
          ngx_event_add_timer(rev, p->read_timeout);
          }
        } else {
#line 70
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 73
      if (rev->timer_set) {
        {
#line 74
        ngx_event_del_timer(rev);
        }
      }
    }
  }
#line 79
  if ((p->downstream)->fd != -1) {
#line 79
    if ((unsigned long )(p->downstream)->data == (unsigned long )p->output_ctx) {
      {
#line 82
      wev = (p->downstream)->write;
#line 83
      tmp___1 = ngx_handle_write_event(wev, (size_t___0 )p->send_lowat);
      }
#line 83
      if (tmp___1 != 0L) {
#line 84
        return ((ngx_int_t )-6);
      }
#line 87
      if (! wev->delayed) {
#line 88
        if (wev->active) {
#line 88
          if (! wev->ready) {
            {
#line 89
            ngx_event_add_timer(wev, p->send_timeout);
            }
          } else {
#line 88
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 91
        if (wev->timer_set) {
          {
#line 92
          ngx_event_del_timer(wev);
          }
        }
      }
    }
  }
#line 97
  return ((ngx_int_t )0);
}
}
#line 101 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_read_upstream(ngx_event_pipe_t *p ) 
{ 
  off_t limit ;
  ssize_t n ;
  ssize_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_msec_t delay ;
  ngx_chain_t *chain ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  int tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 111
  if (p->upstream_eof) {
#line 112
    return ((ngx_int_t )0);
  } else
#line 111
  if (p->upstream_error) {
#line 112
    return ((ngx_int_t )0);
  } else
#line 111
  if (p->upstream_done) {
#line 112
    return ((ngx_int_t )0);
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (p->upstream_eof) {
#line 142
      goto while_break;
    } else
#line 141
    if (p->upstream_error) {
#line 142
      goto while_break;
    } else
#line 141
    if (p->upstream_done) {
#line 142
      goto while_break;
    }
#line 145
    if ((unsigned long )p->preread_bufs == (unsigned long )((void *)0)) {
#line 145
      if (! ((p->upstream)->read)->ready) {
#line 146
        goto while_break;
      }
    }
#line 149
    if (p->preread_bufs) {
#line 153
      chain = p->preread_bufs;
#line 154
      p->preread_bufs = (ngx_chain_t *)((void *)0);
#line 155
      n = (ssize_t )p->preread_size;
#line 160
      if (n) {
#line 161
        p->read = 1U;
      }
    } else {
#line 197
      if (p->limit_rate) {
#line 198
        if (((p->upstream)->read)->delayed) {
#line 199
          goto while_break;
        }
#line 202
        limit = (off_t )p->limit_rate * (off_t )((ngx_cached_time->sec - (time_t volatile   )p->start_sec) + (time_t volatile   )1) - p->read_length;
#line 205
        if (limit <= 0L) {
          {
#line 206
          ((p->upstream)->read)->delayed = 1U;
#line 207
          delay = (size_t___0 )(- limit * 1000L) / p->limit_rate + 1UL;
#line 208
          ngx_event_add_timer((p->upstream)->read, delay);
          }
#line 209
          goto while_break;
        }
      } else {
#line 213
        limit = (off_t )0;
      }
#line 216
      if (p->free_raw_bufs) {
#line 220
        chain = p->free_raw_bufs;
#line 221
        if (p->single_buf) {
#line 222
          p->free_raw_bufs = (p->free_raw_bufs)->next;
#line 223
          chain->next = (ngx_chain_t *)((void *)0);
        } else {
#line 225
          p->free_raw_bufs = (ngx_chain_t *)((void *)0);
        }
      } else
#line 228
      if (p->allocated < p->bufs.num) {
        {
#line 232
        b = ngx_create_temp_buf(p->pool, p->bufs.size);
        }
#line 233
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 234
          return ((ngx_int_t )-6);
        }
        {
#line 237
        (p->allocated) ++;
#line 239
        chain = ngx_alloc_chain_link(p->pool);
        }
#line 240
        if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 241
          return ((ngx_int_t )-6);
        }
#line 244
        chain->buf = b;
#line 245
        chain->next = (ngx_chain_t *)((void *)0);
      } else
#line 247
      if (! p->cacheable) {
#line 247
        if ((unsigned long )(p->downstream)->data == (unsigned long )p->output_ctx) {
#line 247
          if (((p->downstream)->write)->ready) {
#line 247
            if (! ((p->downstream)->write)->delayed) {
#line 257
              p->upstream_blocked = 1U;
#line 262
              goto while_break;
            } else {
#line 247
              goto _L___2;
            }
          } else {
#line 247
            goto _L___2;
          }
        } else {
#line 247
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 264
      if (p->cacheable) {
#line 264
        goto _L;
      } else
#line 264
      if ((p->temp_file)->offset < p->max_temp_file_size) {
        _L: /* CIL Label */ 
        {
#line 273
        rc = ngx_event_pipe_write_chain_to_temp_file(p);
        }
#line 278
        if (rc == -3L) {
#line 279
          goto while_break;
        }
#line 282
        if (rc != 0L) {
#line 283
          return (rc);
        }
#line 286
        chain = p->free_raw_bufs;
#line 287
        if (p->single_buf) {
#line 288
          p->free_raw_bufs = (p->free_raw_bufs)->next;
#line 289
          chain->next = (ngx_chain_t *)((void *)0);
        } else {
#line 291
          p->free_raw_bufs = (ngx_chain_t *)((void *)0);
        }
      } else {
#line 301
        goto while_break;
      }
      {
#line 304
      n = (*((p->upstream)->recv_chain))(p->upstream, chain, limit);
      }
#line 309
      if (p->free_raw_bufs) {
#line 310
        chain->next = p->free_raw_bufs;
      }
#line 312
      p->free_raw_bufs = chain;
#line 314
      if (n == -1L) {
#line 315
        p->upstream_error = 1U;
#line 316
        goto while_break;
      }
#line 319
      if (n == -2L) {
#line 320
        if (p->single_buf) {
          {
#line 321
          ngx_event_pipe_remove_shadow_links(chain->buf);
          }
        }
#line 324
        goto while_break;
      }
#line 327
      p->read = 1U;
#line 329
      if (n == 0L) {
#line 330
        p->upstream_eof = 1U;
#line 331
        goto while_break;
      }
    }
#line 335
    if (p->limit_rate) {
#line 335
      delay = ((ngx_msec_t )n * 1000UL) / p->limit_rate;
    } else {
#line 335
      delay = (ngx_msec_t )0;
    }
#line 337
    p->read_length += n;
#line 338
    cl = chain;
#line 339
    p->free_raw_bufs = (ngx_chain_t *)((void *)0);
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (cl) {
#line 341
        if (! (n > 0L)) {
#line 341
          goto while_break___0;
        }
      } else {
#line 341
        goto while_break___0;
      }
      {
#line 343
      ngx_event_pipe_remove_shadow_links(cl->buf);
#line 345
      size = (cl->buf)->end - (cl->buf)->last;
      }
#line 347
      if (n >= size) {
        {
#line 348
        (cl->buf)->last = (cl->buf)->end;
#line 350
        tmp = p->num;
#line 350
        (p->num) ++;
#line 350
        (cl->buf)->num = tmp;
#line 352
        tmp___0 = (*(p->input_filter))(p, cl->buf);
        }
#line 352
        if (tmp___0 == -1L) {
#line 353
          return ((ngx_int_t )-6);
        }
#line 356
        n -= size;
#line 357
        ln = cl;
#line 358
        cl = cl->next;
#line 359
        ln->next = (p->pool)->chain;
#line 359
        (p->pool)->chain = ln;
      } else {
#line 362
        (cl->buf)->last += n;
#line 363
        n = (ssize_t )0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 367
    if (cl) {
#line 368
      ln = cl;
      {
#line 368
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 368
        if (! ln->next) {
#line 368
          goto while_break___1;
        }
#line 368
        ln = ln->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 370
      ln->next = p->free_raw_bufs;
#line 371
      p->free_raw_bufs = cl;
    }
#line 374
    if (delay > 0UL) {
      {
#line 375
      ((p->upstream)->read)->delayed = 1U;
#line 376
      ngx_event_add_timer((p->upstream)->read, delay);
      }
#line 377
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 440
  if (p->free_raw_bufs) {
#line 440
    if (p->length != -1L) {
#line 441
      cl = p->free_raw_bufs;
#line 443
      if ((cl->buf)->last - (cl->buf)->pos >= p->length) {
        {
#line 445
        p->free_raw_bufs = cl->next;
#line 447
        tmp___1 = p->num;
#line 447
        (p->num) ++;
#line 447
        (cl->buf)->num = tmp___1;
#line 449
        tmp___2 = (*(p->input_filter))(p, cl->buf);
        }
#line 449
        if (tmp___2 == -1L) {
#line 450
          return ((ngx_int_t )-6);
        }
#line 453
        cl->next = (p->pool)->chain;
#line 453
        (p->pool)->chain = cl;
      }
    }
  }
#line 457
  if (p->length == 0L) {
#line 458
    p->upstream_done = 1U;
#line 459
    p->read = 1U;
  }
#line 462
  if (p->upstream_eof) {
#line 462
    goto _L___3;
  } else
#line 462
  if (p->upstream_error) {
    _L___3: /* CIL Label */ 
#line 462
    if (p->free_raw_bufs) {
      {
#line 464
      tmp___3 = p->num;
#line 464
      (p->num) ++;
#line 464
      ((p->free_raw_bufs)->buf)->num = tmp___3;
#line 466
      tmp___4 = (*(p->input_filter))(p, (p->free_raw_bufs)->buf);
      }
#line 466
      if (tmp___4 == -1L) {
#line 467
        return ((ngx_int_t )-6);
      }
#line 470
      p->free_raw_bufs = (p->free_raw_bufs)->next;
#line 472
      if (p->free_bufs) {
#line 472
        if ((unsigned long )p->buf_to_file == (unsigned long )((void *)0)) {
#line 473
          cl = p->free_raw_bufs;
          {
#line 473
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 473
            if (! cl) {
#line 473
              goto while_break___2;
            }
#line 474
            if ((unsigned long )(cl->buf)->shadow == (unsigned long )((void *)0)) {
              {
#line 475
              ngx_pfree(p->pool, (void *)(cl->buf)->start);
              }
            }
#line 473
            cl = cl->next;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 481
  if (p->cacheable) {
#line 481
    if (p->in) {
#line 481
      goto _L___4;
    } else
#line 481
    if (p->buf_to_file) {
      _L___4: /* CIL Label */ 
      {
#line 486
      rc = ngx_event_pipe_write_chain_to_temp_file(p);
      }
#line 488
      if (rc != 0L) {
#line 489
        return (rc);
      }
    }
  }
#line 493
  return ((ngx_int_t )0);
}
}
#line 497 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p ) 
{ 
  u_char *prev ;
  size_t___0 bsize ;
  ngx_int_t rc ;
  ngx_uint_t flush ;
  ngx_uint_t flushed ;
  ngx_uint_t prev_last_shadow ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_chain_t *cl ;
  ngx_connection_t *downstream ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_uint_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 507
  downstream = p->downstream;
#line 524
  flushed = (ngx_uint_t )0;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (p->downstream_error) {
      {
#line 528
      tmp = ngx_event_pipe_drain_chains(p);
      }
#line 528
      return (tmp);
    }
#line 531
    if (p->upstream_eof) {
#line 531
      goto _L;
    } else
#line 531
    if (p->upstream_error) {
#line 531
      goto _L;
    } else
#line 531
    if (p->upstream_done) {
      _L: /* CIL Label */ 
#line 535
      cl = p->busy;
      {
#line 535
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 535
        if (! cl) {
#line 535
          goto while_break___0;
        }
#line 536
        (cl->buf)->recycled = 0U;
#line 535
        cl = cl->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 539
      if (p->out) {
#line 543
        cl = p->out;
        {
#line 543
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 543
          if (! cl) {
#line 543
            goto while_break___1;
          }
#line 544
          (cl->buf)->recycled = 0U;
#line 543
          cl = cl->next;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 547
        rc = (*(p->output_filter))(p->output_ctx, p->out);
        }
#line 549
        if (rc == -1L) {
          {
#line 550
          p->downstream_error = 1U;
#line 551
          tmp___0 = ngx_event_pipe_drain_chains(p);
          }
#line 551
          return (tmp___0);
        }
#line 554
        p->out = (ngx_chain_t *)((void *)0);
      }
#line 557
      if (p->writing) {
#line 558
        goto while_break;
      }
#line 561
      if (p->in) {
#line 565
        cl = p->in;
        {
#line 565
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 565
          if (! cl) {
#line 565
            goto while_break___2;
          }
#line 566
          (cl->buf)->recycled = 0U;
#line 565
          cl = cl->next;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 569
        rc = (*(p->output_filter))(p->output_ctx, p->in);
        }
#line 571
        if (rc == -1L) {
          {
#line 572
          p->downstream_error = 1U;
#line 573
          tmp___1 = ngx_event_pipe_drain_chains(p);
          }
#line 573
          return (tmp___1);
        }
#line 576
        p->in = (ngx_chain_t *)((void *)0);
      }
#line 584
      p->downstream_done = 1U;
#line 585
      goto while_break;
    }
#line 588
    if ((unsigned long )downstream->data != (unsigned long )p->output_ctx) {
#line 592
      goto while_break;
    } else
#line 588
    if (! (downstream->write)->ready) {
#line 592
      goto while_break;
    } else
#line 588
    if ((downstream->write)->delayed) {
#line 592
      goto while_break;
    }
#line 597
    prev = (u_char *)((void *)0);
#line 598
    bsize = (size_t___0 )0;
#line 600
    cl = p->busy;
    {
#line 600
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 600
      if (! cl) {
#line 600
        goto while_break___3;
      }
#line 602
      if ((cl->buf)->recycled) {
#line 603
        if ((unsigned long )prev == (unsigned long )(cl->buf)->start) {
#line 604
          goto __Cont;
        }
#line 607
        bsize += (size_t___0 )((cl->buf)->end - (cl->buf)->start);
#line 608
        prev = (cl->buf)->start;
      }
      __Cont: /* CIL Label */ 
#line 600
      cl = cl->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 615
    out = (ngx_chain_t *)((void *)0);
#line 617
    if (bsize >= (size_t___0 )p->busy_size) {
#line 618
      flush = (ngx_uint_t )1;
#line 619
      goto flush;
    }
#line 622
    flush = (ngx_uint_t )0;
#line 623
    ll = (ngx_chain_t **)((void *)0);
#line 624
    prev_last_shadow = (ngx_uint_t )1;
    {
#line 626
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 627
      if (p->out) {
#line 628
        cl = p->out;
#line 630
        if ((cl->buf)->recycled) {
#line 631
          if ((p->log)->log_level >= 2UL) {
            {
#line 631
            ngx_log_error_core((ngx_uint_t )2, p->log, 0, "recycled buffer in pipe out chain");
            }
          }
        }
#line 635
        p->out = (p->out)->next;
      } else
#line 637
      if (! p->cacheable) {
#line 637
        if (! p->writing) {
#line 637
          if (p->in) {
#line 638
            cl = p->in;
#line 646
            if ((cl->buf)->recycled) {
#line 646
              if (prev_last_shadow) {
#line 647
                if (((cl->buf)->end + bsize) - (cl->buf)->start > p->busy_size) {
#line 648
                  flush = (ngx_uint_t )1;
#line 649
                  goto while_break___4;
                }
#line 652
                bsize += (size_t___0 )((cl->buf)->end - (cl->buf)->start);
              }
            }
#line 655
            prev_last_shadow = (ngx_uint_t )(cl->buf)->last_shadow;
#line 657
            p->in = (p->in)->next;
          } else {
#line 660
            goto while_break___4;
          }
        } else {
#line 660
          goto while_break___4;
        }
      } else {
#line 660
        goto while_break___4;
      }
#line 663
      cl->next = (ngx_chain_t *)((void *)0);
#line 665
      if (out) {
#line 666
        *ll = cl;
      } else {
#line 668
        out = cl;
      }
#line 670
      ll = & cl->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    flush: ;
#line 678
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 680
      if (! flush) {
#line 681
        goto while_break;
      }
#line 685
      tmp___2 = flushed;
#line 685
      flushed ++;
#line 685
      if (tmp___2 > 10UL) {
#line 686
        return ((ngx_int_t )-3);
      }
    }
    {
#line 690
    rc = (*(p->output_filter))(p->output_ctx, out);
#line 692
    ngx_chain_update_chains(p->pool, & p->free, & p->busy, & out, p->tag);
    }
#line 694
    if (rc == -1L) {
      {
#line 695
      p->downstream_error = 1U;
#line 696
      tmp___3 = ngx_event_pipe_drain_chains(p);
      }
#line 696
      return (tmp___3);
    }
#line 699
    cl = p->free;
    {
#line 699
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 699
      if (! cl) {
#line 699
        goto while_break___5;
      }
#line 701
      if ((cl->buf)->temp_file) {
#line 702
        if (p->cacheable) {
#line 703
          goto __Cont___0;
        } else
#line 702
        if (! p->cyclic_temp_file) {
#line 703
          goto __Cont___0;
        }
#line 708
        if ((cl->buf)->file_last == (p->temp_file)->offset) {
#line 709
          (p->temp_file)->offset = (off_t )0;
        }
      }
#line 717
      if ((cl->buf)->last_shadow) {
        {
#line 718
        tmp___4 = ngx_event_pipe_add_free_buf(p, (cl->buf)->shadow);
        }
#line 718
        if (tmp___4 != 0L) {
#line 719
          return ((ngx_int_t )-6);
        }
#line 722
        (cl->buf)->last_shadow = 0U;
      }
#line 725
      (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
      __Cont___0: /* CIL Label */ 
#line 699
      cl = cl->next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return ((ngx_int_t )0);
}
}
#line 733 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t *p ) 
{ 
  ssize_t size ;
  ssize_t bsize ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_uint_t prev_last_shadow ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t *next ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_chain_t **last_out ;
  ngx_chain_t **last_free ;

  {
#line 763
  if (p->buf_to_file) {
    {
#line 764
    out = ngx_alloc_chain_link(p->pool);
    }
#line 765
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 766
      return ((ngx_int_t )-6);
    }
#line 769
    out->buf = p->buf_to_file;
#line 770
    out->next = p->in;
  } else {
#line 773
    out = p->in;
  }
#line 776
  if (! p->cacheable) {
#line 778
    size = (ssize_t )0;
#line 779
    cl = out;
#line 780
    ll = (ngx_chain_t **)((void *)0);
#line 781
    prev_last_shadow = (ngx_uint_t )1;
    {
#line 786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 787
      bsize = (cl->buf)->last - (cl->buf)->pos;
#line 794
      if (prev_last_shadow) {
#line 794
        if (size + bsize > p->temp_file_write_size) {
#line 799
          goto while_break;
        } else
#line 794
        if (((p->temp_file)->offset + size) + bsize > p->max_temp_file_size) {
#line 799
          goto while_break;
        }
      }
#line 802
      prev_last_shadow = (ngx_uint_t )(cl->buf)->last_shadow;
#line 804
      size += bsize;
#line 805
      ll = & cl->next;
#line 806
      cl = cl->next;
#line 786
      if (! cl) {
#line 786
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 812
    if ((unsigned long )ll == (unsigned long )((void *)0)) {
#line 813
      return ((ngx_int_t )-3);
    }
#line 816
    if (cl) {
#line 817
      p->in = cl;
#line 818
      *ll = (ngx_chain_t *)((void *)0);
    } else {
#line 821
      p->in = (ngx_chain_t *)((void *)0);
#line 822
      p->last_in = & p->in;
    }
  } else {
#line 826
    p->in = (ngx_chain_t *)((void *)0);
#line 827
    p->last_in = & p->in;
  }
  {
#line 839
  n = ngx_write_chain_to_temp_file(p->temp_file, out);
  }
#line 841
  if (n == -1L) {
#line 842
    return ((ngx_int_t )-6);
  }
#line 857
  if (p->buf_to_file) {
#line 858
    (p->temp_file)->offset = (p->buf_to_file)->last - (p->buf_to_file)->pos;
#line 859
    n -= (p->buf_to_file)->last - (p->buf_to_file)->pos;
#line 860
    p->buf_to_file = (ngx_buf_t *)((void *)0);
#line 861
    out = out->next;
  }
#line 864
  if (n > 0L) {
#line 867
    if (p->out) {
#line 868
      cl = p->out;
      {
#line 868
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 868
        if (! cl->next) {
#line 868
          goto while_break___0;
        }
#line 868
        cl = cl->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 870
      b = cl->buf;
#line 872
      if (b->file_last == (p->temp_file)->offset) {
#line 873
        (p->temp_file)->offset += n;
#line 874
        b->file_last = (p->temp_file)->offset;
#line 875
        goto free;
      }
#line 878
      last_out = & cl->next;
    } else {
#line 881
      last_out = & p->out;
    }
    {
#line 884
    cl = ngx_chain_get_free_buf(p->pool, & p->free);
    }
#line 885
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 886
      return ((ngx_int_t )-6);
    }
    {
#line 889
    b = cl->buf;
#line 891
    memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 893
    b->tag = p->tag;
#line 895
    b->file = & (p->temp_file)->file;
#line 896
    b->file_pos = (p->temp_file)->offset;
#line 897
    (p->temp_file)->offset += n;
#line 898
    b->file_last = (p->temp_file)->offset;
#line 900
    b->in_file = 1U;
#line 901
    b->temp_file = 1U;
#line 903
    *last_out = cl;
    }
  }
  free: 
#line 908
  last_free = & p->free_raw_bufs;
  {
#line 908
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 908
    if (! ((unsigned long )*last_free != (unsigned long )((void *)0))) {
#line 908
      goto while_break___1;
    }
#line 908
    last_free = & (*last_free)->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 915
  cl = out;
  {
#line 915
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 915
    if (! cl) {
#line 915
      goto while_break___2;
    }
#line 916
    next = cl->next;
#line 918
    cl->next = p->free;
#line 919
    p->free = cl;
#line 921
    b = cl->buf;
#line 923
    if (b->last_shadow) {
      {
#line 925
      tl = ngx_alloc_chain_link(p->pool);
      }
#line 926
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 927
        return ((ngx_int_t )-6);
      }
      {
#line 930
      tl->buf = b->shadow;
#line 931
      tl->next = (ngx_chain_t *)((void *)0);
#line 933
      *last_free = tl;
#line 934
      last_free = & tl->next;
#line 936
      (b->shadow)->pos = (b->shadow)->start;
#line 937
      (b->shadow)->last = (b->shadow)->start;
#line 939
      ngx_event_pipe_remove_shadow_links(b->shadow);
      }
    }
#line 915
    cl = next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 943
  return ((ngx_int_t )0);
}
}
#line 949 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
ngx_int_t ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;

  {
#line 955
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 956
    return ((ngx_int_t )0);
  }
  {
#line 959
  cl = ngx_chain_get_free_buf(p->pool, & p->free);
  }
#line 960
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 961
    return ((ngx_int_t )-1);
  }
  {
#line 964
  b = cl->buf;
#line 966
  memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)buf, sizeof(ngx_buf_t ));
#line 967
  b->shadow = buf;
#line 968
  b->tag = p->tag;
#line 969
  b->last_shadow = 1U;
#line 970
  b->recycled = 1U;
#line 971
  buf->shadow = b;
  }
#line 975
  if (p->in) {
#line 976
    *(p->last_in) = cl;
  } else {
#line 978
    p->in = cl;
  }
#line 980
  p->last_in = & cl->next;
#line 982
  if (p->length == -1L) {
#line 983
    return ((ngx_int_t )0);
  }
#line 986
  p->length -= b->last - b->pos;
#line 988
  return ((ngx_int_t )0);
}
}
#line 992 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
__inline static void ngx_event_pipe_remove_shadow_links(ngx_buf_t *buf ) 
{ 
  ngx_buf_t *b ;
  ngx_buf_t *next ;

  {
#line 997
  b = buf->shadow;
#line 999
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1000
    return;
  }
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    if (! (! b->last_shadow)) {
#line 1003
      goto while_break;
    }
#line 1004
    next = b->shadow;
#line 1006
    b->temporary = 0U;
#line 1007
    b->recycled = 0U;
#line 1009
    b->shadow = (ngx_buf_t *)((void *)0);
#line 1010
    b = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  b->temporary = 0U;
#line 1014
  b->recycled = 0U;
#line 1015
  b->last_shadow = 0U;
#line 1017
  b->shadow = (ngx_buf_t *)((void *)0);
#line 1019
  buf->shadow = (ngx_buf_t *)((void *)0);
#line 1020
  return;
}
}
#line 1023 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
ngx_int_t ngx_event_pipe_add_free_buf(ngx_event_pipe_t *p , ngx_buf_t *b ) 
{ 
  ngx_chain_t *cl ;

  {
  {
#line 1028
  cl = ngx_alloc_chain_link(p->pool);
  }
#line 1029
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1030
    return ((ngx_int_t )-1);
  }
#line 1033
  if (p->buf_to_file) {
#line 1033
    if ((unsigned long )b->start == (unsigned long )(p->buf_to_file)->start) {
#line 1034
      b->pos = (p->buf_to_file)->last;
#line 1035
      b->last = (p->buf_to_file)->last;
    } else {
#line 1038
      b->pos = b->start;
#line 1039
      b->last = b->start;
    }
  } else {
#line 1038
    b->pos = b->start;
#line 1039
    b->last = b->start;
  }
#line 1042
  b->shadow = (ngx_buf_t *)((void *)0);
#line 1044
  cl->buf = b;
#line 1046
  if ((unsigned long )p->free_raw_bufs == (unsigned long )((void *)0)) {
#line 1047
    p->free_raw_bufs = cl;
#line 1048
    cl->next = (ngx_chain_t *)((void *)0);
#line 1050
    return ((ngx_int_t )0);
  }
#line 1053
  if ((unsigned long )((p->free_raw_bufs)->buf)->pos == (unsigned long )((p->free_raw_bufs)->buf)->last) {
#line 1057
    cl->next = p->free_raw_bufs;
#line 1058
    p->free_raw_bufs = cl;
#line 1060
    return ((ngx_int_t )0);
  }
#line 1065
  cl->next = (p->free_raw_bufs)->next;
#line 1066
  (p->free_raw_bufs)->next = cl;
#line 1068
  return ((ngx_int_t )0);
}
}
#line 1072 "/tmp/nginx-1.13.2/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_drain_chains(ngx_event_pipe_t *p ) 
{ 
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_int_t tmp ;

  {
  {
#line 1077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (p->busy) {
#line 1079
      cl = p->busy;
#line 1080
      p->busy = (ngx_chain_t *)((void *)0);
    } else
#line 1082
    if (p->out) {
#line 1083
      cl = p->out;
#line 1084
      p->out = (ngx_chain_t *)((void *)0);
    } else
#line 1086
    if (p->in) {
#line 1087
      cl = p->in;
#line 1088
      p->in = (ngx_chain_t *)((void *)0);
    } else {
#line 1091
      return ((ngx_int_t )0);
    }
    {
#line 1094
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1094
      if (! cl) {
#line 1094
        goto while_break___0;
      }
#line 1095
      if ((cl->buf)->last_shadow) {
        {
#line 1096
        tmp = ngx_event_pipe_add_free_buf(p, (cl->buf)->shadow);
        }
#line 1096
        if (tmp != 0L) {
#line 1097
          return ((ngx_int_t )-6);
        }
#line 1100
        (cl->buf)->last_shadow = 0U;
      }
#line 1103
      (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
#line 1104
      tl = cl->next;
#line 1105
      cl->next = p->free;
#line 1106
      p->free = cl;
#line 1107
      cl = tl;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
#line 102 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 112
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
#line 126
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 467 "src/event/ngx_event.h"
ngx_atomic_t *ngx_connection_counter ;
#line 75 "src/event/ngx_event_connect.h"
ngx_int_t ngx_event_get_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 15 "/tmp/nginx-1.13.2/src/event/ngx_event_connect.c"
static ngx_int_t ngx_event_connect_set_transparent(ngx_peer_connection_t *pc , ngx_socket_t s ) ;
#line 100 "/tmp/nginx-1.13.2/src/event/ngx_event_connect.c"
static int bind_address_no_port  =    1;
#line 20 "/tmp/nginx-1.13.2/src/event/ngx_event_connect.c"
ngx_int_t ngx_event_connect_peer(ngx_peer_connection_t *pc ) 
{ 
  int rc ;
  int type ;
  in_port_t port ;
  ngx_int_t event ;
  ngx_err_t err ;
  ngx_uint_t level ;
  ngx_socket_t s ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int reuse_addr ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  ngx_atomic_t tmp___14 ;
  ngx_int_t tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  ngx_int_t tmp___19 ;
  ngx_int_t tmp___20 ;

  {
  {
#line 34
  tmp = (*(pc->get))(pc, pc->data);
#line 34
  rc = (int )tmp;
  }
#line 35
  if (rc != 0) {
#line 36
    return ((ngx_int_t )rc);
  }
#line 39
  if (pc->type) {
#line 39
    type = pc->type;
  } else {
#line 39
    type = 1;
  }
  {
#line 41
  s = socket((int )(pc->sockaddr)->sa_family, type, 0);
  }
#line 46
  if (s == -1) {
#line 47
    if ((pc->log)->log_level >= 2UL) {
      {
#line 47
      tmp___0 = __errno_location();
#line 47
      ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___0, "socket() failed");
      }
    }
#line 49
    return ((ngx_int_t )-1);
  }
  {
#line 53
  c = ngx_get_connection(s, pc->log);
  }
#line 55
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 56
    tmp___2 = close(s);
    }
#line 56
    if (tmp___2 == -1) {
#line 57
      if ((pc->log)->log_level >= 2UL) {
        {
#line 57
        tmp___1 = __errno_location();
#line 57
        ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___1, "close() socketfailed");
        }
      }
    }
#line 61
    return ((ngx_int_t )-1);
  }
#line 64
  c->type = type;
#line 66
  if (pc->rcvbuf) {
    {
#line 67
    tmp___4 = setsockopt(s, 1, 8, (void const   *)(& pc->rcvbuf), (socklen_t )sizeof(int ));
    }
#line 67
    if (tmp___4 == -1) {
#line 70
      if ((pc->log)->log_level >= 2UL) {
        {
#line 70
        tmp___3 = __errno_location();
#line 70
        ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___3, "setsockopt(SO_RCVBUF) failed");
        }
      }
#line 72
      goto failed;
    }
  }
  {
#line 76
  tmp___6 = ngx_nonblocking(s);
  }
#line 76
  if (tmp___6 == -1) {
#line 77
    if ((pc->log)->log_level >= 2UL) {
      {
#line 77
      tmp___5 = __errno_location();
#line 77
      ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___5, "ioctl(FIONBIO) failed");
      }
    }
#line 80
    goto failed;
  }
#line 83
  if (pc->local) {
#line 86
    if (pc->transparent) {
      {
#line 87
      tmp___7 = ngx_event_connect_set_transparent(pc, s);
      }
#line 87
      if (tmp___7 != 0L) {
#line 88
        goto failed;
      }
    }
    {
#line 94
    port = ngx_inet_get_port((pc->local)->sockaddr);
    }
#line 99
    if ((int )(pc->sockaddr)->sa_family != 1) {
#line 99
      if ((int )port == 0) {
#line 102
        if (bind_address_no_port) {
          {
#line 103
          tmp___9 = setsockopt(s, 0, 24, (void const   *)(& bind_address_no_port),
                               (socklen_t )sizeof(int ));
          }
#line 103
          if (tmp___9 == -1) {
            {
#line 107
            tmp___8 = __errno_location();
#line 107
            err = *tmp___8;
            }
#line 109
            if (err != 95) {
#line 109
              if (err != 92) {
#line 110
                if ((pc->log)->log_level >= 2UL) {
                  {
#line 110
                  ngx_log_error_core((ngx_uint_t )2, pc->log, err, "setsockopt(IP_BIND_ADDRESS_NO_PORT) failed, ignored");
                  }
                }
              } else {
#line 115
                bind_address_no_port = 0;
              }
            } else {
#line 115
              bind_address_no_port = 0;
            }
          }
        }
      }
    }
#line 125
    if (pc->type == 2) {
#line 125
      if ((int )port != 0) {
        {
#line 126
        reuse_addr = 1;
#line 128
        tmp___11 = setsockopt(s, 1, 2, (void const   *)(& reuse_addr), (socklen_t )sizeof(int ));
        }
#line 128
        if (tmp___11 == -1) {
#line 132
          if ((pc->log)->log_level >= 2UL) {
            {
#line 132
            tmp___10 = __errno_location();
#line 132
            ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___10, "setsockopt(SO_REUSEADDR) failed");
            }
          }
#line 134
          goto failed;
        }
      }
    }
    {
#line 140
    tmp___13 = bind(s, (struct sockaddr  const  */* __restrict  */)(pc->local)->sockaddr,
                    (pc->local)->socklen);
    }
#line 140
    if (tmp___13 == -1) {
#line 141
      if ((pc->log)->log_level >= 3UL) {
        {
#line 141
        tmp___12 = __errno_location();
#line 141
        ngx_log_error_core((ngx_uint_t )3, pc->log, *tmp___12, "bind(%V) failed",
                           & (pc->local)->name);
        }
      }
#line 144
      goto failed;
    }
  }
#line 148
  if (type == 1) {
#line 149
    c->recv = ngx_io.recv;
#line 150
    c->send = ngx_io.send;
#line 151
    c->recv_chain = ngx_io.recv_chain;
#line 152
    c->send_chain = ngx_io.send_chain;
#line 154
    c->sendfile = 1U;
#line 156
    if ((int )(pc->sockaddr)->sa_family == 1) {
#line 157
      c->tcp_nopush = 2U;
#line 158
      c->tcp_nodelay = 2U;
    }
  } else {
#line 167
    c->recv = ngx_io.udp_recv;
#line 168
    c->send = ngx_io.send;
#line 169
    c->send_chain = ngx_io.udp_send_chain;
  }
  {
#line 172
  c->log_error = pc->log_error;
#line 174
  rev = c->read;
#line 175
  wev = c->write;
#line 177
  rev->log = pc->log;
#line 178
  wev->log = pc->log;
#line 180
  pc->connection = c;
#line 182
  tmp___14 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, 1);
#line 182
  c->number = (ngx_atomic_uint_t )tmp___14;
  }
#line 184
  if (ngx_event_actions.add_conn) {
    {
#line 185
    tmp___15 = (*(ngx_event_actions.add_conn))(c);
    }
#line 185
    if (tmp___15 == -1L) {
#line 186
      goto failed;
    }
  }
  {
#line 193
  rc = connect(s, (struct sockaddr  const  */* __restrict  */)pc->sockaddr, pc->socklen);
  }
#line 195
  if (rc == -1) {
    {
#line 196
    tmp___16 = __errno_location();
#line 196
    err = *tmp___16;
    }
#line 199
    if (err != 115) {
#line 206
      if (err == 111) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 11) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 104) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 100) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 101) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 112) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 113) {
#line 220
        level = (ngx_uint_t )4;
      } else {
#line 223
        level = (ngx_uint_t )3;
      }
#line 226
      if ((c->log)->log_level >= level) {
        {
#line 226
        ngx_log_error_core(level, c->log, err, "connect() to %V failed", pc->name);
        }
      }
      {
#line 229
      ngx_close_connection(c);
#line 230
      pc->connection = (ngx_connection_t *)((void *)0);
      }
#line 232
      return ((ngx_int_t )-5);
    }
  }
#line 236
  if (ngx_event_actions.add_conn) {
#line 237
    if (rc == -1) {
#line 241
      return ((ngx_int_t )-2);
    }
#line 246
    wev->ready = 1U;
#line 248
    return ((ngx_int_t )0);
  }
#line 251
  if (ngx_event_flags & 512UL) {
    {
#line 256
    tmp___18 = ngx_blocking(s);
    }
#line 256
    if (tmp___18 == -1) {
#line 257
      if ((pc->log)->log_level >= 2UL) {
        {
#line 257
        tmp___17 = __errno_location();
#line 257
        ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___17, "ioctl(!FIONBIO) failed");
        }
      }
#line 259
      goto failed;
    }
#line 269
    rev->ready = 1U;
#line 270
    wev->ready = 1U;
#line 272
    return ((ngx_int_t )0);
  }
#line 275
  if (ngx_event_flags & 4UL) {
#line 279
    event = (ngx_int_t )2147483648U;
  } else {
#line 285
    event = (ngx_int_t )0;
  }
  {
#line 288
  tmp___19 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )event);
  }
#line 288
  if (tmp___19 != 0L) {
#line 289
    goto failed;
  }
#line 292
  if (rc == -1) {
    {
#line 296
    tmp___20 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )event);
    }
#line 296
    if (tmp___20 != 0L) {
#line 297
      goto failed;
    }
#line 300
    return ((ngx_int_t )-2);
  }
#line 305
  wev->ready = 1U;
#line 307
  return ((ngx_int_t )0);
  failed: 
  {
#line 311
  ngx_close_connection(c);
#line 312
  pc->connection = (ngx_connection_t *)((void *)0);
  }
#line 314
  return ((ngx_int_t )-1);
}
}
#line 320 "/tmp/nginx-1.13.2/src/event/ngx_event_connect.c"
static ngx_int_t ngx_event_connect_set_transparent(ngx_peer_connection_t *pc , ngx_socket_t s ) 
{ 
  int value ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 325
  value = 1;
  {
#line 341
  if ((int )((pc->local)->sockaddr)->sa_family == 2) {
#line 341
    goto case_2;
  }
#line 369
  if ((int )((pc->local)->sockaddr)->sa_family == 10) {
#line 369
    goto case_10;
  }
#line 339
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 345
  tmp___0 = setsockopt(s, 0, 19, (void const   *)(& value), (socklen_t )sizeof(int ));
  }
#line 345
  if (tmp___0 == -1) {
#line 348
    if ((pc->log)->log_level >= 2UL) {
      {
#line 348
      tmp = __errno_location();
#line 348
      ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp, "setsockopt(IP_TRANSPARENT) failed");
      }
    }
#line 350
    return ((ngx_int_t )-1);
  }
#line 365
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 373
  tmp___2 = setsockopt(s, 41, 75, (void const   *)(& value), (socklen_t )sizeof(int ));
  }
#line 373
  if (tmp___2 == -1) {
#line 376
    if ((pc->log)->log_level >= 2UL) {
      {
#line 376
      tmp___1 = __errno_location();
#line 376
      ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___1, "setsockopt(IPV6_TRANSPARENT) failed");
      }
    }
#line 378
    return ((ngx_int_t )-1);
  }
#line 392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 400
  return ((ngx_int_t )0);
}
}
#line 406 "/tmp/nginx-1.13.2/src/event/ngx_event_connect.c"
ngx_int_t ngx_event_get_peer(ngx_peer_connection_t *pc , void *data ) 
{ 


  {
#line 409
  return ((ngx_int_t )0);
}
}
#line 232 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 240
extern int accept4(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ,
                   int __flags ) ;
#line 43 "src/core/ngx_shmtx.h"
ngx_uint_t ngx_shmtx_trylock(ngx_shmtx_t *mtx ) ;
#line 472 "src/event/ngx_event.h"
ngx_uint_t ngx_accept_events ;
#line 473
ngx_uint_t ngx_accept_mutex_held ;
#line 475
ngx_int_t ngx_accept_disabled ;
#line 506
void ngx_event_accept(ngx_event_t *ev ) ;
#line 508
void ngx_event_recvmsg(ngx_event_t *ev ) ;
#line 510
ngx_int_t ngx_trylock_accept_mutex(ngx_cycle_t *cycle ) ;
#line 13 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
static ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle ) ;
#line 14
static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle , ngx_uint_t all ) ;
#line 15
static void ngx_close_accepted_connection(ngx_connection_t *c ) ;
#line 36 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
static ngx_uint_t use_accept4  =    (ngx_uint_t )1;
#line 22 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
void ngx_event_accept(ngx_event_t *ev ) 
{ 
  socklen_t socklen ;
  ngx_err_t err ;
  ngx_log_t *log ;
  ngx_uint_t level ;
  ngx_socket_t s ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_sockaddr_t sa ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_connection_t *lc ;
  ngx_event_conf_t *ecf ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  ngx_int_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  ngx_atomic_t tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;

  {
#line 39
  if (ev->timedout) {
    {
#line 40
    tmp = ngx_enable_accept_events((ngx_cycle_t *)ngx_cycle);
    }
#line 40
    if (tmp != 0L) {
#line 41
      return;
    }
#line 44
    ev->timedout = 0U;
  }
#line 47
  ecf = (ngx_event_conf_t *)*(*(*(ngx_cycle->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
#line 49
  if (! (ngx_event_flags & 8UL)) {
#line 50
    ev->available = (unsigned int )ecf->multi_accept;
  }
#line 53
  lc = (ngx_connection_t *)ev->data;
#line 54
  ls = lc->listening;
#line 55
  ev->ready = 0U;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    socklen = (socklen_t )sizeof(ngx_sockaddr_t );
#line 64
    if (use_accept4) {
      {
#line 65
      s = accept4(lc->fd, (struct sockaddr */* __restrict  */)(& sa.sockaddr), (socklen_t */* __restrict  */)(& socklen),
                  2048);
      }
    } else {
      {
#line 67
      s = accept(lc->fd, (struct sockaddr */* __restrict  */)(& sa.sockaddr), (socklen_t */* __restrict  */)(& socklen));
      }
    }
#line 73
    if (s == -1) {
      {
#line 74
      tmp___0 = __errno_location();
#line 74
      err = *tmp___0;
      }
#line 76
      if (err == 11) {
#line 79
        return;
      }
#line 82
      level = (ngx_uint_t )2;
#line 84
      if (err == 103) {
#line 85
        level = (ngx_uint_t )4;
      } else
#line 87
      if (err == 24) {
#line 88
        level = (ngx_uint_t )3;
      } else
#line 87
      if (err == 23) {
#line 88
        level = (ngx_uint_t )3;
      }
#line 92
      if ((ev->log)->log_level >= level) {
#line 92
        if (use_accept4) {
#line 92
          tmp___1 = "accept4() failed";
        } else {
#line 92
          tmp___1 = "accept() failed";
        }
        {
#line 92
        ngx_log_error_core(level, ev->log, err, tmp___1);
        }
      }
#line 95
      if (use_accept4) {
#line 95
        if (err == 38) {
#line 96
          use_accept4 = (ngx_uint_t )0;
#line 97
          ngx_inherited_nonblocking = (ngx_uint_t )0;
#line 98
          goto __Cont;
        }
      }
#line 104
      if (err == 103) {
#line 105
        if (ngx_event_flags & 8UL) {
#line 106
          (ev->available) --;
        }
#line 109
        if (ev->available) {
#line 110
          goto __Cont;
        }
      }
#line 114
      if (err == 24) {
#line 114
        goto _L;
      } else
#line 114
      if (err == 23) {
        _L: /* CIL Label */ 
        {
#line 115
        tmp___2 = ngx_disable_accept_events((ngx_cycle_t *)ngx_cycle, (ngx_uint_t )1);
        }
#line 115
        if (tmp___2 != 0L) {
#line 118
          return;
        }
#line 121
        if (ngx_use_accept_mutex) {
#line 122
          if (ngx_accept_mutex_held) {
            {
#line 123
            ngx_shmtx_unlock(& ngx_accept_mutex);
#line 124
            ngx_accept_mutex_held = (ngx_uint_t )0;
            }
          }
#line 127
          ngx_accept_disabled = (ngx_int_t )1;
        } else {
          {
#line 130
          ngx_event_add_timer(ev, ecf->accept_mutex_delay);
          }
        }
      }
#line 134
      return;
    }
    {
#line 141
    ngx_accept_disabled = (ngx_int_t )(ngx_cycle->connection_n / (ngx_uint_t volatile   )8 - ngx_cycle->free_connection_n);
#line 144
    c = ngx_get_connection(s, ev->log);
    }
#line 146
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 147
      tmp___4 = close(s);
      }
#line 147
      if (tmp___4 == -1) {
#line 148
        if ((ev->log)->log_level >= 2UL) {
          {
#line 148
          tmp___3 = __errno_location();
#line 148
          ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___3, "close() socket failed");
          }
        }
      }
#line 152
      return;
    }
    {
#line 155
    c->type = 1;
#line 161
    c->pool = ngx_create_pool(ls->pool_size, ev->log);
    }
#line 162
    if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
      {
#line 163
      ngx_close_accepted_connection(c);
      }
#line 164
      return;
    }
    {
#line 167
    tmp___5 = ngx_palloc(c->pool, (size_t___0 )socklen);
#line 167
    c->sockaddr = (struct sockaddr *)tmp___5;
    }
#line 168
    if ((unsigned long )c->sockaddr == (unsigned long )((void *)0)) {
      {
#line 169
      ngx_close_accepted_connection(c);
      }
#line 170
      return;
    }
    {
#line 173
    memcpy((void */* __restrict  */)c->sockaddr, (void const   */* __restrict  */)(& sa),
           (size_t )socklen);
#line 175
    tmp___6 = ngx_palloc(c->pool, sizeof(ngx_log_t ));
#line 175
    log = (ngx_log_t *)tmp___6;
    }
#line 176
    if ((unsigned long )log == (unsigned long )((void *)0)) {
      {
#line 177
      ngx_close_accepted_connection(c);
      }
#line 178
      return;
    }
#line 183
    if (ngx_inherited_nonblocking) {
#line 184
      if (ngx_event_flags & 512UL) {
        {
#line 185
        tmp___8 = ngx_blocking(s);
        }
#line 185
        if (tmp___8 == -1) {
#line 186
          if ((ev->log)->log_level >= 2UL) {
            {
#line 186
            tmp___7 = __errno_location();
#line 186
            ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___7, "ioctl(!FIONBIO) failed");
            }
          }
          {
#line 188
          ngx_close_accepted_connection(c);
          }
#line 189
          return;
        }
      }
    } else
#line 194
    if (! (ngx_event_flags & 512UL)) {
      {
#line 195
      tmp___10 = ngx_nonblocking(s);
      }
#line 195
      if (tmp___10 == -1) {
#line 196
        if ((ev->log)->log_level >= 2UL) {
          {
#line 196
          tmp___9 = __errno_location();
#line 196
          ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___9, "ioctl(FIONBIO) failed");
          }
        }
        {
#line 198
        ngx_close_accepted_connection(c);
        }
#line 199
        return;
      }
    }
#line 204
    *log = ls->log;
#line 206
    c->recv = ngx_io.recv;
#line 207
    c->send = ngx_io.send;
#line 208
    c->recv_chain = ngx_io.recv_chain;
#line 209
    c->send_chain = ngx_io.send_chain;
#line 211
    c->log = log;
#line 212
    (c->pool)->log = log;
#line 214
    c->socklen = socklen;
#line 215
    c->listening = ls;
#line 216
    c->local_sockaddr = ls->sockaddr;
#line 217
    c->local_socklen = ls->socklen;
#line 220
    if ((int )(c->sockaddr)->sa_family == 1) {
#line 221
      c->tcp_nopush = 2U;
#line 222
      c->tcp_nodelay = 2U;
    }
#line 230
    rev = c->read;
#line 231
    wev = c->write;
#line 233
    wev->ready = 1U;
#line 235
    if (ngx_event_flags & 512UL) {
#line 236
      rev->ready = 1U;
    }
#line 239
    if (ev->deferred_accept) {
#line 240
      rev->ready = 1U;
#line 242
      rev->available = 1U;
    }
    {
#line 246
    rev->log = log;
#line 247
    wev->log = log;
#line 258
    tmp___11 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, 1);
#line 258
    c->number = (ngx_atomic_uint_t )tmp___11;
    }
#line 264
    if (ls->addr_ntop) {
      {
#line 265
      tmp___12 = ngx_pnalloc(c->pool, ls->addr_text_max_len);
#line 265
      c->addr_text.data = (u_char *)tmp___12;
      }
#line 266
      if ((unsigned long )c->addr_text.data == (unsigned long )((void *)0)) {
        {
#line 267
        ngx_close_accepted_connection(c);
        }
#line 268
        return;
      }
      {
#line 271
      c->addr_text.len = ngx_sock_ntop(c->sockaddr, c->socklen, c->addr_text.data,
                                       ls->addr_text_max_len, (ngx_uint_t )0);
      }
#line 274
      if (c->addr_text.len == 0UL) {
        {
#line 275
        ngx_close_accepted_connection(c);
        }
#line 276
        return;
      }
    }
#line 299
    if (ngx_event_actions.add_conn) {
#line 299
      if ((ngx_event_flags & 64UL) == 0UL) {
        {
#line 300
        tmp___13 = (*(ngx_event_actions.add_conn))(c);
        }
#line 300
        if (tmp___13 == -1L) {
          {
#line 301
          ngx_close_accepted_connection(c);
          }
#line 302
          return;
        }
      }
    }
    {
#line 306
    log->data = (void *)0;
#line 307
    log->handler = (u_char *(*)(ngx_log_t *log , u_char *buf , size_t___0 len ))((void *)0);
#line 309
    (*(ls->handler))(c);
    }
#line 311
    if (ngx_event_flags & 8UL) {
#line 312
      (ev->available) --;
    }
    __Cont: /* CIL Label */ 
#line 60
    if (! ev->available) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 334 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
static u_char buffer[65535]  ;
#line 321 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
void ngx_event_recvmsg(ngx_event_t *ev ) 
{ 
  ssize_t n ;
  ngx_log_t *log ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  struct iovec iov[1] ;
  struct msghdr msg ;
  ngx_sockaddr_t sa ;
  ngx_listening_t *ls ;
  ngx_event_conf_t *ecf ;
  ngx_connection_t *c ;
  ngx_connection_t *lc ;
  u_char msg_control[(((sizeof(struct in_pktinfo ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
  u_char msg_control6[(((sizeof(struct in6_pktinfo ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t___0 )) - 1UL) & ~ (sizeof(size_t___0 ) - 1UL))] ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct cmsghdr *cmsg ;
  struct sockaddr *sockaddr ;
  void *tmp___3 ;
  struct in_pktinfo *pkt ;
  struct sockaddr_in *sin ;
  struct in6_pktinfo *pkt6 ;
  struct sockaddr_in6 *sin6 ;
  void *tmp___4 ;
  ngx_atomic_t tmp___5 ;
  void *tmp___6 ;

  {
#line 350
  if (ev->timedout) {
    {
#line 351
    tmp = ngx_enable_accept_events((ngx_cycle_t *)ngx_cycle);
    }
#line 351
    if (tmp != 0L) {
#line 352
      return;
    }
#line 355
    ev->timedout = 0U;
  }
#line 358
  ecf = (ngx_event_conf_t *)*(*(*(ngx_cycle->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
#line 360
  if (! (ngx_event_flags & 8UL)) {
#line 361
    ev->available = (unsigned int )ecf->multi_accept;
  }
#line 364
  lc = (ngx_connection_t *)ev->data;
#line 365
  ls = lc->listening;
#line 366
  ev->ready = 0U;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 372
    memset((void *)(& msg), 0, sizeof(struct msghdr ));
#line 374
    iov[0].iov_base = (void *)(buffer);
#line 375
    iov[0].iov_len = sizeof(buffer);
#line 377
    msg.msg_name = (void *)(& sa);
#line 378
    msg.msg_namelen = (socklen_t )sizeof(ngx_sockaddr_t );
#line 379
    msg.msg_iov = iov;
#line 380
    msg.msg_iovlen = (size_t___0 )1;
    }
#line 384
    if (ls->wildcard) {
#line 387
      if ((int )(ls->sockaddr)->sa_family == 2) {
#line 388
        msg.msg_control = (void *)(& msg_control);
#line 389
        msg.msg_controllen = sizeof(msg_control);
      }
#line 394
      if ((int )(ls->sockaddr)->sa_family == 10) {
#line 395
        msg.msg_control = (void *)(& msg_control6);
#line 396
        msg.msg_controllen = sizeof(msg_control6);
      }
    }
    {
#line 403
    n = recvmsg(lc->fd, & msg, 0);
    }
#line 405
    if (n == -1L) {
      {
#line 406
      tmp___0 = __errno_location();
#line 406
      err = *tmp___0;
      }
#line 408
      if (err == 11) {
#line 411
        return;
      }
#line 414
      if ((ev->log)->log_level >= 2UL) {
        {
#line 414
        ngx_log_error_core((ngx_uint_t )2, ev->log, err, "recvmsg() failed");
        }
      }
#line 416
      return;
    }
#line 424
    if (msg.msg_flags & 40) {
#line 425
      if ((ev->log)->log_level >= 2UL) {
        {
#line 425
        ngx_log_error_core((ngx_uint_t )2, ev->log, 0, "recvmsg() truncated data");
        }
      }
#line 427
      goto __Cont;
    }
    {
#line 431
    ngx_accept_disabled = (ngx_int_t )(ngx_cycle->connection_n / (ngx_uint_t volatile   )8 - ngx_cycle->free_connection_n);
#line 434
    c = ngx_get_connection(lc->fd, ev->log);
    }
#line 435
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 436
      return;
    }
    {
#line 439
    c->shared = 1U;
#line 440
    c->type = 2;
#line 441
    c->socklen = msg.msg_namelen;
#line 447
    c->pool = ngx_create_pool(ls->pool_size, ev->log);
    }
#line 448
    if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
      {
#line 449
      ngx_close_accepted_connection(c);
      }
#line 450
      return;
    }
    {
#line 453
    tmp___1 = ngx_palloc(c->pool, (size_t___0 )c->socklen);
#line 453
    c->sockaddr = (struct sockaddr *)tmp___1;
    }
#line 454
    if ((unsigned long )c->sockaddr == (unsigned long )((void *)0)) {
      {
#line 455
      ngx_close_accepted_connection(c);
      }
#line 456
      return;
    }
    {
#line 459
    memcpy((void */* __restrict  */)c->sockaddr, (void const   */* __restrict  */)msg.msg_name,
           (size_t )c->socklen);
#line 461
    tmp___2 = ngx_palloc(c->pool, sizeof(ngx_log_t ));
#line 461
    log = (ngx_log_t *)tmp___2;
    }
#line 462
    if ((unsigned long )log == (unsigned long )((void *)0)) {
      {
#line 463
      ngx_close_accepted_connection(c);
      }
#line 464
      return;
    }
#line 467
    *log = ls->log;
#line 469
    c->send = ngx_io.udp_send;
#line 470
    c->send_chain = ngx_io.udp_send_chain;
#line 472
    c->log = log;
#line 473
    (c->pool)->log = log;
#line 475
    c->listening = ls;
#line 476
    c->local_sockaddr = ls->sockaddr;
#line 477
    c->local_socklen = ls->socklen;
#line 481
    if (ls->wildcard) {
      {
#line 485
      tmp___3 = ngx_palloc(c->pool, (size_t___0 )c->local_socklen);
#line 485
      sockaddr = (struct sockaddr *)tmp___3;
      }
#line 486
      if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
        {
#line 487
        ngx_close_accepted_connection(c);
        }
#line 488
        return;
      }
      {
#line 491
      memcpy((void */* __restrict  */)sockaddr, (void const   */* __restrict  */)c->local_sockaddr,
             (size_t )c->local_socklen);
#line 492
      c->local_sockaddr = sockaddr;
      }
#line 494
      if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 494
        cmsg = (struct cmsghdr *)msg.msg_control;
      } else {
#line 494
        cmsg = (struct cmsghdr *)0;
      }
      {
#line 494
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 494
        if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 494
          goto while_break___0;
        }
#line 517
        if (cmsg->cmsg_level == 0) {
#line 517
          if (cmsg->cmsg_type == 8) {
#line 517
            if ((int )sockaddr->sa_family == 2) {
#line 524
              pkt = (struct in_pktinfo *)(cmsg->__cmsg_data);
#line 525
              sin = (struct sockaddr_in *)sockaddr;
#line 526
              sin->sin_addr = pkt->ipi_addr;
#line 528
              goto while_break___0;
            }
          }
        }
#line 535
        if (cmsg->cmsg_level == 41) {
#line 535
          if (cmsg->cmsg_type == 50) {
#line 535
            if ((int )sockaddr->sa_family == 10) {
#line 542
              pkt6 = (struct in6_pktinfo *)(cmsg->__cmsg_data);
#line 543
              sin6 = (struct sockaddr_in6 *)sockaddr;
#line 544
              sin6->sin6_addr = pkt6->ipi6_addr;
#line 546
              goto while_break___0;
            }
          }
        }
        {
#line 494
        cmsg = __cmsg_nxthdr(& msg, cmsg);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 556
    c->buffer = ngx_create_temp_buf(c->pool, (size_t___0 )n);
    }
#line 557
    if ((unsigned long )c->buffer == (unsigned long )((void *)0)) {
      {
#line 558
      ngx_close_accepted_connection(c);
      }
#line 559
      return;
    }
    {
#line 562
    tmp___4 = memcpy((void */* __restrict  */)(c->buffer)->last, (void const   */* __restrict  */)(buffer),
                     (size_t )n);
#line 562
    (c->buffer)->last = (u_char *)tmp___4 + n;
#line 564
    rev = c->read;
#line 565
    wev = c->write;
#line 567
    wev->ready = 1U;
#line 569
    rev->log = log;
#line 570
    wev->log = log;
#line 581
    tmp___5 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, 1);
#line 581
    c->number = (ngx_atomic_uint_t )tmp___5;
    }
#line 587
    if (ls->addr_ntop) {
      {
#line 588
      tmp___6 = ngx_pnalloc(c->pool, ls->addr_text_max_len);
#line 588
      c->addr_text.data = (u_char *)tmp___6;
      }
#line 589
      if ((unsigned long )c->addr_text.data == (unsigned long )((void *)0)) {
        {
#line 590
        ngx_close_accepted_connection(c);
        }
#line 591
        return;
      }
      {
#line 594
      c->addr_text.len = ngx_sock_ntop(c->sockaddr, c->socklen, c->addr_text.data,
                                       ls->addr_text_max_len, (ngx_uint_t )0);
      }
#line 597
      if (c->addr_text.len == 0UL) {
        {
#line 598
        ngx_close_accepted_connection(c);
        }
#line 599
        return;
      }
    }
    {
#line 623
    log->data = (void *)0;
#line 624
    log->handler = (u_char *(*)(ngx_log_t *log , u_char *buf , size_t___0 len ))((void *)0);
#line 626
    (*(ls->handler))(c);
    }
#line 628
    if (ngx_event_flags & 8UL) {
#line 629
      ev->available = (unsigned int )((ssize_t )ev->available - n);
    }
    __Cont: /* CIL Label */ 
#line 371
    if (! ev->available) {
#line 371
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 633
  return;
}
}
#line 638 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
ngx_int_t ngx_trylock_accept_mutex(ngx_cycle_t *cycle ) 
{ 
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 641
  tmp___0 = ngx_shmtx_trylock(& ngx_accept_mutex);
  }
#line 641
  if (tmp___0) {
#line 646
    if (ngx_accept_mutex_held) {
#line 646
      if (ngx_accept_events == 0UL) {
#line 647
        return ((ngx_int_t )0);
      }
    }
    {
#line 650
    tmp = ngx_enable_accept_events(cycle);
    }
#line 650
    if (tmp == -1L) {
      {
#line 651
      ngx_shmtx_unlock(& ngx_accept_mutex);
      }
#line 652
      return ((ngx_int_t )-1);
    }
#line 655
    ngx_accept_events = (ngx_uint_t )0;
#line 656
    ngx_accept_mutex_held = (ngx_uint_t )1;
#line 658
    return ((ngx_int_t )0);
  }
#line 664
  if (ngx_accept_mutex_held) {
    {
#line 665
    tmp___1 = ngx_disable_accept_events(cycle, (ngx_uint_t )0);
    }
#line 665
    if (tmp___1 == -1L) {
#line 666
      return ((ngx_int_t )-1);
    }
#line 669
    ngx_accept_mutex_held = (ngx_uint_t )0;
  }
#line 672
  return ((ngx_int_t )0);
}
}
#line 676 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
static ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
#line 683
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 684
  i = (ngx_uint_t )0;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (i < cycle->listening.nelts)) {
#line 684
      goto while_break;
    }
#line 686
    c = (ls + i)->connection;
#line 688
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 689
      goto __Cont;
    } else
#line 688
    if ((c->read)->active) {
#line 689
      goto __Cont;
    }
    {
#line 692
    tmp = (*(ngx_event_actions.add))(c->read, (ngx_int_t )8193, (ngx_uint_t )0);
    }
#line 692
    if (tmp == -1L) {
#line 693
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ 
#line 684
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return ((ngx_int_t )0);
}
}
#line 701 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle , ngx_uint_t all ) 
{ 
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
#line 708
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 709
  i = (ngx_uint_t )0;
  {
#line 709
  while (1) {
    while_continue: /* CIL Label */ ;
#line 709
    if (! (i < cycle->listening.nelts)) {
#line 709
      goto while_break;
    }
#line 711
    c = (ls + i)->connection;
#line 713
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 714
      goto __Cont;
    } else
#line 713
    if (! (c->read)->active) {
#line 714
      goto __Cont;
    }
#line 724
    if ((ls + i)->reuseport) {
#line 724
      if (! all) {
#line 725
        goto __Cont;
      }
    }
    {
#line 730
    tmp = (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )2);
    }
#line 730
    if (tmp == -1L) {
#line 733
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ 
#line 709
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return ((ngx_int_t )0);
}
}
#line 741 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
static void ngx_close_accepted_connection(ngx_connection_t *c ) 
{ 
  ngx_socket_t fd ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 746
  ngx_free_connection(c);
#line 748
  fd = c->fd;
#line 749
  c->fd = -1;
  }
#line 751
  if (! c->shared) {
    {
#line 751
    tmp___0 = close(fd);
    }
#line 751
    if (tmp___0 == -1) {
#line 752
      if ((c->log)->log_level >= 2UL) {
        {
#line 752
        tmp = __errno_location();
#line 752
        ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "close() socket failed");
        }
      }
    }
  }
#line 756
  if (c->pool) {
    {
#line 757
    ngx_destroy_pool(c->pool);
    }
  }
#line 763
  return;
}
}
#line 766 "/tmp/nginx-1.13.2/src/event/ngx_event_accept.c"
u_char *ngx_accept_log_error(ngx_log_t *log , u_char *buf , size_t___0 len ) 
{ 
  u_char *tmp ;

  {
  {
#line 769
  tmp = ngx_snprintf(buf, len, " while accepting new connection on %V", log->data);
  }
#line 769
  return (tmp);
}
}
#line 41 "src/event/ngx_event_posted.h"
void ngx_event_process_posted(ngx_cycle_t *cycle , ngx_queue_t *posted ) ;
#line 44 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_accept_events  ;
#line 45 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_events  ;
#line 17 "/tmp/nginx-1.13.2/src/event/ngx_event_posted.c"
void ngx_event_process_posted(ngx_cycle_t *cycle , ngx_queue_t *posted ) 
{ 
  ngx_queue_t *q ;
  ngx_event_t *ev ;

  {
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (! ((unsigned long )posted == (unsigned long )posted->prev))) {
#line 23
      goto while_break;
    }
    {
#line 25
    q = posted->next;
#line 26
    ev = (ngx_event_t *)((u_char *)q - (unsigned long )(& ((ngx_event_t *)0)->queue));
#line 31
    ev->posted = 0U;
#line 31
    (ev->queue.next)->prev = ev->queue.prev;
#line 31
    (ev->queue.prev)->next = ev->queue.next;
#line 33
    (*(ev->handler))(ev);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return;
}
}
#line 55 "src/core/ngx_rbtree.h"
void ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                   ngx_rbtree_node_t *sentinel ) ;
#line 57
ngx_rbtree_node_t *ngx_rbtree_next(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) ;
#line 73 "src/core/ngx_rbtree.h"
__inline static ngx_rbtree_node_t *ngx_rbtree_min(ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) 
{ 


  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )node->left != (unsigned long )sentinel)) {
#line 76
      goto while_break;
    }
#line 77
    node = node->left;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (node);
}
}
#line 22 "src/event/ngx_event_timer.h"
ngx_int_t ngx_event_timer_init(ngx_log_t *log ) ;
#line 23
ngx_msec_t ngx_event_find_timer(void) ;
#line 24
void ngx_event_expire_timers(void) ;
#line 28 "src/event/ngx_event_timer.h"
ngx_rbtree_t ngx_event_timer_rbtree  ;
#line 14 "/tmp/nginx-1.13.2/src/event/ngx_event_timer.c"
static ngx_rbtree_node_t ngx_event_timer_sentinel  ;
#line 22 "/tmp/nginx-1.13.2/src/event/ngx_event_timer.c"
ngx_int_t ngx_event_timer_init(ngx_log_t *log ) 
{ 


  {
#line 25
  ngx_event_timer_sentinel.color = (u_char )0;
#line 25
  ngx_event_timer_rbtree.root = & ngx_event_timer_sentinel;
#line 25
  ngx_event_timer_rbtree.sentinel = & ngx_event_timer_sentinel;
#line 25
  ngx_event_timer_rbtree.insert = & ngx_rbtree_insert_timer_value;
#line 28
  return ((ngx_int_t )0);
}
}
#line 32 "/tmp/nginx-1.13.2/src/event/ngx_event_timer.c"
ngx_msec_t ngx_event_find_timer(void) 
{ 
  ngx_msec_int_t timer ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;
  ngx_msec_int_t tmp ;

  {
#line 38
  if ((unsigned long )ngx_event_timer_rbtree.root == (unsigned long )(& ngx_event_timer_sentinel)) {
#line 39
    return ((ngx_msec_t )-1);
  }
  {
#line 42
  root = ngx_event_timer_rbtree.root;
#line 43
  sentinel = ngx_event_timer_rbtree.sentinel;
#line 45
  node = ngx_rbtree_min(root, sentinel);
#line 47
  timer = (ngx_msec_int_t )(node->key - (ngx_rbtree_key_t )ngx_current_msec);
  }
#line 49
  if (timer > 0L) {
#line 49
    tmp = timer;
  } else {
#line 49
    tmp = (ngx_msec_int_t )0;
  }
#line 49
  return ((ngx_msec_t )tmp);
}
}
#line 53 "/tmp/nginx-1.13.2/src/event/ngx_event_timer.c"
void ngx_event_expire_timers(void) 
{ 
  ngx_event_t *ev ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 59
  sentinel = ngx_event_timer_rbtree.sentinel;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    root = ngx_event_timer_rbtree.root;
#line 64
    if ((unsigned long )root == (unsigned long )sentinel) {
#line 65
      return;
    }
    {
#line 68
    node = ngx_rbtree_min(root, sentinel);
    }
#line 72
    if ((ngx_msec_int_t )(node->key - (ngx_rbtree_key_t )ngx_current_msec) > 0L) {
#line 73
      return;
    }
    {
#line 76
    ev = (ngx_event_t *)((char *)node - (unsigned long )(& ((ngx_event_t *)0)->timer));
#line 82
    ngx_rbtree_delete(& ngx_event_timer_rbtree, & ev->timer);
#line 90
    ev->timer_set = 0U;
#line 92
    ev->timedout = 1U;
#line 94
    (*(ev->handler))(ev);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 99 "/tmp/nginx-1.13.2/src/event/ngx_event_timer.c"
ngx_int_t ngx_event_no_timers_left(void) 
{ 
  ngx_event_t *ev ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 105
  sentinel = ngx_event_timer_rbtree.sentinel;
#line 106
  root = ngx_event_timer_rbtree.root;
#line 108
  if ((unsigned long )root == (unsigned long )sentinel) {
#line 109
    return ((ngx_int_t )0);
  }
  {
#line 112
  node = ngx_rbtree_min(root, sentinel);
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! node) {
#line 112
      goto while_break;
    }
#line 116
    ev = (ngx_event_t *)((char *)node - (unsigned long )(& ((ngx_event_t *)0)->timer));
#line 118
    if (! ev->cancelable) {
#line 119
      return ((ngx_int_t )-2);
    }
    {
#line 112
    node = ngx_rbtree_next(& ngx_event_timer_rbtree, node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return ((ngx_int_t )0);
}
}
#line 160 "src/core/ngx_file.h"
ngx_atomic_t *ngx_temp_number ;
#line 161
ngx_atomic_int_t ngx_random_number ;
#line 40 "src/core/ngx_shmtx.h"
ngx_int_t ngx_shmtx_create(ngx_shmtx_t *mtx , ngx_shmtx_sh_t *addr , u_char *name ) ;
#line 139 "src/core/ngx_cycle.h"
ngx_uint_t ngx_test_config ;
#line 197 "src/event/ngx_event.h"
ngx_event_actions_t ngx_event_actions  ;
#line 469 "src/event/ngx_event.h"
ngx_atomic_t *ngx_accept_mutex_ptr  ;
#line 470 "src/event/ngx_event.h"
ngx_shmtx_t ngx_accept_mutex  ;
#line 471 "src/event/ngx_event.h"
ngx_uint_t ngx_use_accept_mutex  ;
#line 472 "src/event/ngx_event.h"
ngx_uint_t ngx_accept_events  ;
#line 473 "src/event/ngx_event.h"
ngx_uint_t ngx_accept_mutex_held  ;
#line 474 "src/event/ngx_event.h"
ngx_msec_t ngx_accept_mutex_delay  ;
#line 475 "src/event/ngx_event.h"
ngx_int_t ngx_accept_disabled  ;
#line 495 "src/event/ngx_event.h"
sig_atomic_t ngx_event_timer_alarm  ;
#line 496 "src/event/ngx_event.h"
ngx_uint_t ngx_event_flags  ;
#line 526
ngx_int_t ngx_send_lowat(ngx_connection_t *c , size_t___0 lowat ) ;
#line 23 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static char *ngx_event_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 24
static ngx_int_t ngx_event_module_init(ngx_cycle_t *cycle ) ;
#line 25
static ngx_int_t ngx_event_process_init(ngx_cycle_t *cycle ) ;
#line 26
static char *ngx_events_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 28
static char *ngx_event_connections(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 30
static char *ngx_event_use(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 31
static char *ngx_event_debug_connection(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 34
static void *ngx_event_core_create_conf(ngx_cycle_t *cycle ) ;
#line 35
static char *ngx_event_core_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 38 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_uint_t ngx_timer_resolution  ;
#line 41 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_uint_t ngx_event_max_module  ;
#line 47 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static unsigned long volatile   connection_counter  =    (ngx_atomic_t )1;
#line 48 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
ngx_atomic_t *ngx_connection_counter  =    & connection_counter;
#line 81 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_command_t ngx_events_commands[2]  = {      {{sizeof("events") - 1UL, (u_char *)"events"}, (ngx_uint_t )16777473, & ngx_events_block,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 94 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_core_module_t ngx_events_module_ctx  =    {{sizeof("events") - 1UL, (u_char *)"events"}, (void *(*)(ngx_cycle_t *cycle ))((void *)0),
    & ngx_event_init_conf};
#line 101 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
ngx_module_t ngx_events_module  = 
#line 101
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_events_module_ctx),
    ngx_events_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 117 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_str_t event_core_name  =    {sizeof("event_core") - 1UL, (u_char *)"event_core"};
#line 120 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_command_t ngx_event_core_commands[7]  = {      {{sizeof("worker_connections") - 1UL, (u_char *)"worker_connections"}, (ngx_uint_t )33554434,
      & ngx_event_connections, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("use") - 1UL, (u_char *)"use"}, (ngx_uint_t )33554434, & ngx_event_use,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("multi_accept") - 1UL, (u_char *)"multi_accept"}, (ngx_uint_t )33554944,
      & ngx_conf_set_flag_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_event_conf_t *)0)->multi_accept),
      (void *)0}, 
        {{sizeof("accept_mutex") - 1UL, (u_char *)"accept_mutex"}, (ngx_uint_t )33554944,
      & ngx_conf_set_flag_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_event_conf_t *)0)->accept_mutex),
      (void *)0}, 
        {{sizeof("accept_mutex_delay") - 1UL, (u_char *)"accept_mutex_delay"}, (ngx_uint_t )33554434,
      & ngx_conf_set_msec_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_event_conf_t *)0)->accept_mutex_delay),
      (void *)0}, 
        {{sizeof("debug_connection") - 1UL, (u_char *)"debug_connection"}, (ngx_uint_t )33554434,
      & ngx_event_debug_connection, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 168 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_event_module_t ngx_event_core_module_ctx  =    {& event_core_name, & ngx_event_core_create_conf, & ngx_event_core_init_conf, {(ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_connection_t *c ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_connection_t *c ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(void (*handler)(ngx_event_t *ev ) ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_cycle_t *cycle ,
                                                                                                 ngx_msec_t timer ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_cycle_t *cycle ,
                                                                                                 ngx_msec_t timer ))((void *)0),
                                                                                  (void (*)(ngx_cycle_t *cycle ))((void *)0)}};
#line 177 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
ngx_module_t ngx_event_core_module  = 
#line 177
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_event_core_module_ctx),
    ngx_event_core_commands, (ngx_uint_t )1414420037, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    & ngx_event_module_init, & ngx_event_process_init, (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0};
#line 193 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
void ngx_process_events_and_timers(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t flags ;
  ngx_msec_t timer ;
  ngx_msec_t delta ;
  ngx_int_t tmp ;

  {
#line 199
  if (ngx_timer_resolution) {
#line 200
    timer = (ngx_msec_t )-1;
#line 201
    flags = (ngx_uint_t )0;
  } else {
    {
#line 204
    timer = ngx_event_find_timer();
#line 205
    flags = (ngx_uint_t )1;
    }
  }
#line 218
  if (ngx_use_accept_mutex) {
#line 219
    if (ngx_accept_disabled > 0L) {
#line 220
      ngx_accept_disabled --;
    } else {
      {
#line 223
      tmp = ngx_trylock_accept_mutex(cycle);
      }
#line 223
      if (tmp == -1L) {
#line 224
        return;
      }
#line 227
      if (ngx_accept_mutex_held) {
#line 228
        flags |= 2UL;
      } else
#line 231
      if (timer == 0xffffffffffffffffUL) {
#line 234
        timer = ngx_accept_mutex_delay;
      } else
#line 231
      if (timer > ngx_accept_mutex_delay) {
#line 234
        timer = ngx_accept_mutex_delay;
      }
    }
  }
  {
#line 240
  delta = (ngx_msec_t )ngx_current_msec;
#line 242
  (*(ngx_event_actions.process_events))(cycle, timer, flags);
#line 244
  delta = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )delta);
#line 249
  ngx_event_process_posted(cycle, & ngx_posted_accept_events);
  }
#line 251
  if (ngx_accept_mutex_held) {
    {
#line 252
    ngx_shmtx_unlock(& ngx_accept_mutex);
    }
  }
#line 255
  if (delta) {
    {
#line 256
    ngx_event_expire_timers();
    }
  }
  {
#line 259
  ngx_event_process_posted(cycle, & ngx_posted_events);
  }
#line 260
  return;
}
}
#line 263 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
ngx_int_t ngx_handle_read_event(ngx_event_t *rev , ngx_uint_t flags ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 266
  if (ngx_event_flags & 4UL) {
#line 270
    if (! rev->active) {
#line 270
      if (! rev->ready) {
        {
#line 271
        tmp = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )2147483648U);
        }
#line 271
        if (tmp == -1L) {
#line 274
          return ((ngx_int_t )-1);
        }
      }
    }
#line 278
    return ((ngx_int_t )0);
  } else
#line 280
  if (ngx_event_flags & 1UL) {
#line 284
    if (! rev->active) {
#line 284
      if (! rev->ready) {
        {
#line 285
        tmp___0 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
        }
#line 285
        if (tmp___0 == -1L) {
#line 288
          return ((ngx_int_t )-1);
        }
#line 291
        return ((ngx_int_t )0);
      }
    }
#line 294
    if (rev->active) {
#line 294
      if (rev->ready) {
#line 294
        goto _L;
      } else
#line 294
      if (flags & 1UL) {
        _L: /* CIL Label */ 
        {
#line 295
        tmp___1 = (*(ngx_event_actions.del))(rev, (ngx_int_t )8193, flags);
        }
#line 295
        if (tmp___1 == -1L) {
#line 298
          return ((ngx_int_t )-1);
        }
#line 301
        return ((ngx_int_t )0);
      }
    }
  } else
#line 304
  if (ngx_event_flags & 4096UL) {
#line 308
    if (! rev->active) {
#line 308
      if (! rev->ready) {
        {
#line 309
        tmp___2 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
        }
#line 309
        if (tmp___2 == -1L) {
#line 310
          return ((ngx_int_t )-1);
        }
#line 313
        return ((ngx_int_t )0);
      }
    }
#line 316
    if (rev->oneshot) {
#line 316
      if (! rev->ready) {
        {
#line 317
        tmp___3 = (*(ngx_event_actions.del))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
        }
#line 317
        if (tmp___3 == -1L) {
#line 318
          return ((ngx_int_t )-1);
        }
#line 321
        return ((ngx_int_t )0);
      }
    }
  }
#line 327
  return ((ngx_int_t )0);
}
}
#line 331 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
ngx_int_t ngx_handle_write_event(ngx_event_t *wev , size_t___0 lowat ) 
{ 
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;

  {
#line 336
  if (lowat) {
    {
#line 337
    c = (ngx_connection_t *)wev->data;
#line 339
    tmp = ngx_send_lowat(c, lowat);
    }
#line 339
    if (tmp == -1L) {
#line 340
      return ((ngx_int_t )-1);
    }
  }
#line 344
  if (ngx_event_flags & 4UL) {
#line 348
    if (! wev->active) {
#line 348
      if (! wev->ready) {
#line 349
        if (lowat) {
#line 349
          tmp___0 = 0;
        } else {
#line 349
          tmp___0 = 0;
        }
        {
#line 349
        tmp___1 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )(2147483648U | (unsigned int )tmp___0));
        }
#line 349
        if (tmp___1 == -1L) {
#line 353
          return ((ngx_int_t )-1);
        }
      }
    }
#line 357
    return ((ngx_int_t )0);
  } else
#line 359
  if (ngx_event_flags & 1UL) {
#line 363
    if (! wev->active) {
#line 363
      if (! wev->ready) {
        {
#line 364
        tmp___2 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 364
        if (tmp___2 == -1L) {
#line 367
          return ((ngx_int_t )-1);
        }
#line 370
        return ((ngx_int_t )0);
      }
    }
#line 373
    if (wev->active) {
#line 373
      if (wev->ready) {
        {
#line 374
        tmp___3 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 374
        if (tmp___3 == -1L) {
#line 377
          return ((ngx_int_t )-1);
        }
#line 380
        return ((ngx_int_t )0);
      }
    }
  } else
#line 383
  if (ngx_event_flags & 4096UL) {
#line 387
    if (! wev->active) {
#line 387
      if (! wev->ready) {
        {
#line 388
        tmp___4 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 388
        if (tmp___4 == -1L) {
#line 389
          return ((ngx_int_t )-1);
        }
#line 392
        return ((ngx_int_t )0);
      }
    }
#line 395
    if (wev->oneshot) {
#line 395
      if (wev->ready) {
        {
#line 396
        tmp___5 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 396
        if (tmp___5 == -1L) {
#line 397
          return ((ngx_int_t )-1);
        }
#line 400
        return ((ngx_int_t )0);
      }
    }
  }
#line 406
  return ((ngx_int_t )0);
}
}
#line 410 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static char *ngx_event_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 


  {
#line 413
  if ((unsigned long )*(cycle->conf_ctx + ngx_events_module.index) == (unsigned long )((void *)0)) {
#line 414
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 414
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "no \"events\" section in configuration");
      }
    }
#line 416
    return ((char *)((void *)-1));
  }
#line 419
  return ((char *)((void *)0));
}
}
#line 423 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_int_t ngx_event_module_init(ngx_cycle_t *cycle ) 
{ 
  void ***cf ;
  u_char *shared ;
  size_t___0 size ;
  size_t___0 cl ;
  ngx_shm_t shm ;
  ngx_time_t *tp ;
  ngx_core_conf_t *ccf ;
  ngx_event_conf_t *ecf ;
  ngx_int_t limit ;
  struct rlimit rlmt___0 ;
  int *tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 434
  cf = *(cycle->conf_ctx + ngx_events_module.index);
#line 435
  ecf = (ngx_event_conf_t *)*(*cf + ngx_event_core_module.ctx_index);
#line 437
  if (! ngx_test_config) {
#line 437
    if (ngx_process <= 1UL) {
#line 438
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 438
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "using the \"%s\" event method",
                           ecf->name);
        }
      }
    }
  }
  {
#line 442
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 444
  ngx_timer_resolution = ccf->timer_resolution;
#line 451
  tmp___0 = getrlimit((__rlimit_resource_t )7, & rlmt___0);
  }
#line 451
  if (tmp___0 == -1) {
#line 452
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 452
      tmp = __errno_location();
#line 452
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "getrlimit(RLIMIT_NOFILE) failed, ignored");
      }
    }
  } else
#line 456
  if (ecf->connections > rlmt___0.rlim_cur) {
#line 456
    if (ccf->rlimit_nofile == -1L) {
#line 456
      goto _L;
    } else
#line 456
    if (ecf->connections > (ngx_uint_t )ccf->rlimit_nofile) {
      _L: /* CIL Label */ 
#line 460
      if (ccf->rlimit_nofile == -1L) {
#line 460
        limit = (ngx_int_t )rlmt___0.rlim_cur;
      } else {
#line 460
        limit = ccf->rlimit_nofile;
      }
#line 463
      if ((cycle->log)->log_level >= 5UL) {
        {
#line 463
        ngx_log_error_core((ngx_uint_t )5, cycle->log, 0, "%ui worker_connections exceed open file resource limit: %i",
                           ecf->connections, limit);
        }
      }
    }
  }
#line 473
  if (ccf->master == 0L) {
#line 474
    return ((ngx_int_t )0);
  }
#line 477
  if (ngx_accept_mutex_ptr) {
#line 478
    return ((ngx_int_t )0);
  }
  {
#line 484
  cl = (size_t___0 )128;
#line 486
  size = (cl + cl) + cl;
#line 502
  shm.size = size;
#line 503
  shm.name.len = sizeof("nginx_shared_zone") - 1UL;
#line 503
  shm.name.data = (u_char *)"nginx_shared_zone";
#line 504
  shm.log = cycle->log;
#line 506
  tmp___1 = ngx_shm_alloc(& shm);
  }
#line 506
  if (tmp___1 != 0L) {
#line 507
    return ((ngx_int_t )-1);
  }
  {
#line 510
  shared = shm.addr;
#line 512
  ngx_accept_mutex_ptr = (ngx_atomic_t *)shared;
#line 513
  ngx_accept_mutex.spin = (ngx_uint_t )-1;
#line 515
  tmp___2 = ngx_shmtx_create(& ngx_accept_mutex, (ngx_shmtx_sh_t *)shared, cycle->lock_file.data);
  }
#line 515
  if (tmp___2 != 0L) {
#line 519
    return ((ngx_int_t )-1);
  }
  {
#line 522
  ngx_connection_counter = (ngx_atomic_t *)(shared + cl);
#line 524
  __sync_bool_compare_and_swap(ngx_connection_counter, 0, 1);
#line 530
  ngx_temp_number = (ngx_atomic_t *)(shared + 2UL * cl);
#line 532
  tp = (ngx_time_t *)ngx_cached_time;
#line 534
  ngx_random_number = (ngx_atomic_int_t )((tp->msec << 16) + (ngx_uint_t )ngx_pid);
  }
#line 548
  return ((ngx_int_t )0);
}
}
#line 554 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static void ngx_timer_signal_handler(int signo ) 
{ 


  {
#line 557
  ngx_event_timer_alarm = 1;
#line 562
  return;
}
}
#line 567 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static ngx_int_t ngx_event_process_init(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t m ;
  ngx_uint_t i ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_connection_t *next ;
  ngx_connection_t *old ;
  ngx_core_conf_t *ccf ;
  ngx_event_conf_t *ecf ;
  ngx_event_module_t *module ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  struct sigaction sa ;
  struct itimerval itv ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  struct rlimit rlmt___0 ;
  int *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  ngx_int_t tmp___11 ;
  ngx_int_t tmp___12 ;
  ngx_int_t tmp___13 ;
  ngx_int_t tmp___14 ;

  {
#line 578
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 579
  ecf = (ngx_event_conf_t *)*(*(*(cycle->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
#line 581
  if (ccf->master) {
#line 581
    if (ccf->worker_processes > 1L) {
#line 581
      if (ecf->accept_mutex) {
#line 582
        ngx_use_accept_mutex = (ngx_uint_t )1;
#line 583
        ngx_accept_mutex_held = (ngx_uint_t )0;
#line 584
        ngx_accept_mutex_delay = ecf->accept_mutex_delay;
      } else {
#line 587
        ngx_use_accept_mutex = (ngx_uint_t )0;
      }
    } else {
#line 587
      ngx_use_accept_mutex = (ngx_uint_t )0;
    }
  } else {
#line 587
    ngx_use_accept_mutex = (ngx_uint_t )0;
  }
  {
#line 601
  ngx_posted_accept_events.prev = & ngx_posted_accept_events;
#line 601
  ngx_posted_accept_events.next = & ngx_posted_accept_events;
#line 602
  ngx_posted_events.prev = & ngx_posted_events;
#line 602
  ngx_posted_events.next = & ngx_posted_events;
#line 604
  tmp = ngx_event_timer_init(cycle->log);
  }
#line 604
  if (tmp == -1L) {
#line 605
    return ((ngx_int_t )-1);
  }
#line 608
  m = (ngx_uint_t )0;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! *(cycle->modules + m)) {
#line 608
      goto while_break;
    }
#line 609
    if ((*(cycle->modules + m))->type != 1414420037UL) {
#line 610
      goto __Cont;
    }
#line 613
    if ((*(cycle->modules + m))->ctx_index != ecf->use) {
#line 614
      goto __Cont;
    }
    {
#line 617
    module = (ngx_event_module_t *)(*(cycle->modules + m))->ctx;
#line 619
    tmp___0 = (*(module->actions.init))(cycle, ngx_timer_resolution);
    }
#line 619
    if (tmp___0 != 0L) {
      {
#line 621
      exit(2);
      }
    }
#line 624
    goto while_break;
    __Cont: /* CIL Label */ 
#line 608
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  if (ngx_timer_resolution) {
#line 629
    if (! (ngx_event_flags & 2048UL)) {
      {
#line 633
      memset((void *)(& sa), 0, sizeof(struct sigaction ));
#line 634
      sa.__sigaction_handler.sa_handler = & ngx_timer_signal_handler;
#line 635
      sigemptyset(& sa.sa_mask);
#line 637
      tmp___2 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa),
                          (struct sigaction */* __restrict  */)((void *)0));
      }
#line 637
      if (tmp___2 == -1) {
#line 638
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 638
          tmp___1 = __errno_location();
#line 638
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "sigaction(SIGALRM) failed");
          }
        }
#line 640
        return ((ngx_int_t )-1);
      }
      {
#line 643
      itv.it_interval.tv_sec = (__time_t )(ngx_timer_resolution / 1000UL);
#line 644
      itv.it_interval.tv_usec = (__suseconds_t )((ngx_timer_resolution % 1000UL) * 1000UL);
#line 645
      itv.it_value.tv_sec = (__time_t )(ngx_timer_resolution / 1000UL);
#line 646
      itv.it_value.tv_usec = (__suseconds_t )((ngx_timer_resolution % 1000UL) * 1000UL);
#line 648
      tmp___4 = setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& itv),
                          (struct itimerval */* __restrict  */)((void *)0));
      }
#line 648
      if (tmp___4 == -1) {
#line 649
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 649
          tmp___3 = __errno_location();
#line 649
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "setitimer() failed");
          }
        }
      }
    }
  }
#line 654
  if (ngx_event_flags & 1024UL) {
    {
#line 657
    tmp___6 = getrlimit((__rlimit_resource_t )7, & rlmt___0);
    }
#line 657
    if (tmp___6 == -1) {
#line 658
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 658
        tmp___5 = __errno_location();
#line 658
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "getrlimit(RLIMIT_NOFILE) failed");
        }
      }
#line 660
      return ((ngx_int_t )-1);
    }
    {
#line 663
    cycle->files_n = rlmt___0.rlim_cur;
#line 665
    tmp___7 = ngx_calloc(sizeof(ngx_connection_t *) * cycle->files_n, cycle->log);
#line 665
    cycle->files = (ngx_connection_t **)tmp___7;
    }
#line 667
    if ((unsigned long )cycle->files == (unsigned long )((void *)0)) {
#line 668
      return ((ngx_int_t )-1);
    }
  }
  {
#line 683
  tmp___8 = ngx_alloc(sizeof(ngx_connection_t ) * cycle->connection_n, cycle->log);
#line 683
  cycle->connections = (ngx_connection_t *)tmp___8;
  }
#line 685
  if ((unsigned long )cycle->connections == (unsigned long )((void *)0)) {
#line 686
    return ((ngx_int_t )-1);
  }
  {
#line 689
  c = cycle->connections;
#line 691
  tmp___9 = ngx_alloc(sizeof(ngx_event_t ) * cycle->connection_n, cycle->log);
#line 691
  cycle->read_events = (ngx_event_t *)tmp___9;
  }
#line 693
  if ((unsigned long )cycle->read_events == (unsigned long )((void *)0)) {
#line 694
    return ((ngx_int_t )-1);
  }
#line 697
  rev = cycle->read_events;
#line 698
  i = (ngx_uint_t )0;
  {
#line 698
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 698
    if (! (i < cycle->connection_n)) {
#line 698
      goto while_break___0;
    }
#line 699
    (rev + i)->closed = 1U;
#line 700
    (rev + i)->instance = 1U;
#line 698
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 703
  tmp___10 = ngx_alloc(sizeof(ngx_event_t ) * cycle->connection_n, cycle->log);
#line 703
  cycle->write_events = (ngx_event_t *)tmp___10;
  }
#line 705
  if ((unsigned long )cycle->write_events == (unsigned long )((void *)0)) {
#line 706
    return ((ngx_int_t )-1);
  }
#line 709
  wev = cycle->write_events;
#line 710
  i = (ngx_uint_t )0;
  {
#line 710
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 710
    if (! (i < cycle->connection_n)) {
#line 710
      goto while_break___1;
    }
#line 711
    (wev + i)->closed = 1U;
#line 710
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 714
  i = cycle->connection_n;
#line 715
  next = (ngx_connection_t *)((void *)0);
  {
#line 717
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 718
    i --;
#line 720
    (c + i)->data = (void *)next;
#line 721
    (c + i)->read = cycle->read_events + i;
#line 722
    (c + i)->write = cycle->write_events + i;
#line 723
    (c + i)->fd = -1;
#line 725
    next = c + i;
#line 717
    if (! i) {
#line 717
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 728
  cycle->free_connections = next;
#line 729
  cycle->free_connection_n = cycle->connection_n;
#line 733
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 734
  i = (ngx_uint_t )0;
  {
#line 734
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 734
    if (! (i < cycle->listening.nelts)) {
#line 734
      goto while_break___3;
    }
#line 737
    if ((ls + i)->reuseport) {
#line 737
      if ((ls + i)->worker != ngx_worker) {
#line 738
        goto __Cont___0;
      }
    }
    {
#line 742
    c = ngx_get_connection((ls + i)->fd, cycle->log);
    }
#line 744
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 745
      return ((ngx_int_t )-1);
    }
#line 748
    c->type = (ls + i)->type;
#line 749
    c->log = & (ls + i)->log;
#line 751
    c->listening = ls + i;
#line 752
    (ls + i)->connection = c;
#line 754
    rev = c->read;
#line 756
    rev->log = c->log;
#line 757
    rev->accept = 1U;
#line 760
    rev->deferred_accept = (ls + i)->deferred_accept;
#line 763
    if (! (ngx_event_flags & 512UL)) {
#line 764
      if ((ls + i)->previous) {
        {
#line 771
        old = ((ls + i)->previous)->connection;
#line 773
        tmp___11 = (*(ngx_event_actions.del))(old->read, (ngx_int_t )8193, (ngx_uint_t )1);
        }
#line 773
        if (tmp___11 == -1L) {
#line 776
          return ((ngx_int_t )-1);
        }
#line 779
        old->fd = -1;
      }
    }
#line 821
    if (c->type == 1) {
#line 821
      rev->handler = & ngx_event_accept;
    } else {
#line 821
      rev->handler = & ngx_event_recvmsg;
    }
#line 826
    if ((ls + i)->reuseport) {
      {
#line 827
      tmp___12 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 827
      if (tmp___12 == -1L) {
#line 828
        return ((ngx_int_t )-1);
      }
#line 831
      goto __Cont___0;
    }
#line 836
    if (ngx_use_accept_mutex) {
#line 837
      goto __Cont___0;
    }
#line 842
    if (ngx_event_flags & 64UL) {
#line 842
      if (ccf->worker_processes > 1L) {
        {
#line 845
        tmp___13 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )268435456);
        }
#line 845
        if (tmp___13 == -1L) {
#line 848
          return ((ngx_int_t )-1);
        }
#line 851
        goto __Cont___0;
      }
    }
    {
#line 856
    tmp___14 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
    }
#line 856
    if (tmp___14 == -1L) {
#line 857
      return ((ngx_int_t )-1);
    }
    __Cont___0: /* CIL Label */ 
#line 734
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 864
  return ((ngx_int_t )0);
}
}
#line 868 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
ngx_int_t ngx_send_lowat(ngx_connection_t *c , size_t___0 lowat ) 
{ 
  int sndlowat ;
  int *tmp ;
  int tmp___0 ;

  {
#line 882
  if (lowat == 0UL) {
#line 883
    return ((ngx_int_t )0);
  } else
#line 882
  if (c->sndlowat) {
#line 883
    return ((ngx_int_t )0);
  }
  {
#line 886
  sndlowat = (int )lowat;
#line 888
  tmp___0 = setsockopt(c->fd, 1, 19, (void const   *)(& sndlowat), (socklen_t )sizeof(int ));
  }
#line 888
  if (tmp___0 == -1) {
    {
#line 892
    tmp = __errno_location();
#line 892
    ngx_connection_error(c, *tmp, (char *)"setsockopt(SO_SNDLOWAT) failed");
    }
#line 894
    return ((ngx_int_t )-1);
  }
#line 897
  c->sndlowat = 1U;
#line 899
  return ((ngx_int_t )0);
}
}
#line 903 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static char *ngx_events_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  void ***ctx ;
  ngx_uint_t i ;
  ngx_conf_t pcf ;
  ngx_event_module_t *m ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 912
  if (*((void **)conf)) {
#line 913
    return ((char *)"is duplicate");
  }
  {
#line 918
  tmp = ngx_count_modules(cf->cycle, (ngx_uint_t )1414420037);
#line 918
  ngx_event_max_module = (ngx_uint_t )tmp;
#line 920
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *));
#line 920
  ctx = (void ***)tmp___0;
  }
#line 921
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 922
    return ((char *)((void *)-1));
  }
  {
#line 925
  tmp___1 = ngx_pcalloc(cf->pool, ngx_event_max_module * sizeof(void *));
#line 925
  *ctx = (void **)tmp___1;
  }
#line 926
  if ((unsigned long )*ctx == (unsigned long )((void *)0)) {
#line 927
    return ((char *)((void *)-1));
  }
#line 930
  *((void **)conf) = (void *)ctx;
#line 932
  i = (ngx_uint_t )0;
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if (! *((cf->cycle)->modules + i)) {
#line 932
      goto while_break;
    }
#line 933
    if ((*((cf->cycle)->modules + i))->type != 1414420037UL) {
#line 934
      goto __Cont;
    }
#line 937
    m = (ngx_event_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 939
    if (m->create_conf) {
      {
#line 940
      *(*ctx + (*((cf->cycle)->modules + i))->ctx_index) = (*(m->create_conf))(cf->cycle);
      }
#line 942
      if ((unsigned long )*(*ctx + (*((cf->cycle)->modules + i))->ctx_index) == (unsigned long )((void *)0)) {
#line 943
        return ((char *)((void *)-1));
      }
    }
    __Cont: /* CIL Label */ 
#line 932
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  pcf = *cf;
#line 949
  cf->ctx = (void *)ctx;
#line 950
  cf->module_type = (ngx_uint_t )1414420037;
#line 951
  cf->cmd_type = (ngx_uint_t )33554432;
#line 953
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 955
  *cf = pcf;
  }
#line 957
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 958
    return (rv);
  }
#line 961
  i = (ngx_uint_t )0;
  {
#line 961
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 961
    if (! *((cf->cycle)->modules + i)) {
#line 961
      goto while_break___0;
    }
#line 962
    if ((*((cf->cycle)->modules + i))->type != 1414420037UL) {
#line 963
      goto __Cont___0;
    }
#line 966
    m = (ngx_event_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 968
    if (m->init_conf) {
      {
#line 969
      rv = (*(m->init_conf))(cf->cycle, *(*ctx + (*((cf->cycle)->modules + i))->ctx_index));
      }
#line 971
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 972
        return (rv);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 961
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 977
  return ((char *)((void *)0));
}
}
#line 981 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static char *ngx_event_connections(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_event_conf_t *ecf ;
  ngx_str_t *value ;
  ngx_int_t tmp ;

  {
#line 984
  ecf = (ngx_event_conf_t *)conf;
#line 988
  if (ecf->connections != 0xffffffffffffffffUL) {
#line 989
    return ((char *)"is duplicate");
  }
  {
#line 992
  value = (ngx_str_t *)(cf->args)->elts;
#line 993
  tmp = ngx_atoi((value + 1)->data, (value + 1)->len);
#line 993
  ecf->connections = (ngx_uint_t )tmp;
  }
#line 994
  if (ecf->connections == 0xffffffffffffffffUL) {
    {
#line 995
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number \"%V\"", value + 1);
    }
#line 998
    return ((char *)((void *)-1));
  }
#line 1001
  (cf->cycle)->connection_n = ecf->connections;
#line 1003
  return ((char *)((void *)0));
}
}
#line 1007 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static char *ngx_event_use(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_event_conf_t *ecf ;
  ngx_int_t m ;
  ngx_str_t *value ;
  ngx_event_conf_t *old_ecf ;
  ngx_event_module_t *module ;
  int tmp ;

  {
#line 1010
  ecf = (ngx_event_conf_t *)conf;
#line 1017
  if (ecf->use != 0xffffffffffffffffUL) {
#line 1018
    return ((char *)"is duplicate");
  }
#line 1021
  value = (ngx_str_t *)(cf->args)->elts;
#line 1023
  if (((cf->cycle)->old_cycle)->conf_ctx) {
#line 1024
    old_ecf = (ngx_event_conf_t *)*(*(*(((cf->cycle)->old_cycle)->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
  } else {
#line 1027
    old_ecf = (ngx_event_conf_t *)((void *)0);
  }
#line 1031
  m = (ngx_int_t )0;
  {
#line 1031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1031
    if (! *((cf->cycle)->modules + m)) {
#line 1031
      goto while_break;
    }
#line 1032
    if ((*((cf->cycle)->modules + m))->type != 1414420037UL) {
#line 1033
      goto __Cont;
    }
#line 1036
    module = (ngx_event_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 1037
    if ((module->name)->len == (value + 1)->len) {
      {
#line 1038
      tmp = strcmp((char const   *)(module->name)->data, (char const   *)(value + 1)->data);
      }
#line 1038
      if (tmp == 0) {
#line 1039
        ecf->use = (*((cf->cycle)->modules + m))->ctx_index;
#line 1040
        ecf->name = (module->name)->data;
#line 1042
        if (ngx_process == 0UL) {
#line 1042
          if (old_ecf) {
#line 1042
            if (old_ecf->use != ecf->use) {
              {
#line 1046
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "when the server runs without a master process the \"%V\" event type must be the same as in previous configuration - \"%s\" and it cannot be changed on the fly, to change it you need to stop server and start it again",
                                 value + 1, old_ecf->name);
              }
#line 1055
              return ((char *)((void *)-1));
            }
          }
        }
#line 1058
        return ((char *)((void *)0));
      }
    }
    __Cont: /* CIL Label */ 
#line 1031
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1063
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid event type \"%V\"", value + 1);
  }
#line 1066
  return ((char *)((void *)-1));
}
}
#line 1070 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static char *ngx_event_debug_connection(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 


  {
  {
#line 1164
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"debug_connection\" is ignored, you need to rebuild nginx using --with-debug option to enable it");
  }
#line 1170
  return ((char *)((void *)0));
}
}
#line 1174 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static void *ngx_event_core_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_event_conf_t *ecf ;
  void *tmp ;

  {
  {
#line 1179
  tmp = ngx_palloc(cycle->pool, sizeof(ngx_event_conf_t ));
#line 1179
  ecf = (ngx_event_conf_t *)tmp;
  }
#line 1180
  if ((unsigned long )ecf == (unsigned long )((void *)0)) {
#line 1181
    return ((void *)0);
  }
#line 1184
  ecf->connections = (ngx_uint_t )-1;
#line 1185
  ecf->use = (ngx_uint_t )-1;
#line 1186
  ecf->multi_accept = (ngx_flag_t )-1;
#line 1187
  ecf->accept_mutex = (ngx_flag_t )-1;
#line 1188
  ecf->accept_mutex_delay = (ngx_msec_t )-1;
#line 1189
  ecf->name = (u_char *)((void *)-1);
#line 1201
  return ((void *)ecf);
}
}
#line 1205 "/tmp/nginx-1.13.2/src/event/ngx_event.c"
static char *ngx_event_core_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_event_conf_t *ecf ;
  int fd ;
  ngx_int_t i ;
  ngx_module_t *module ;
  ngx_event_module_t *event_module ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 1208
  ecf = (ngx_event_conf_t *)conf;
#line 1217
  module = (ngx_module_t *)((void *)0);
#line 1221
  fd = epoll_create(100);
  }
#line 1223
  if (fd != -1) {
    {
#line 1224
    close(fd);
#line 1225
    module = & ngx_epoll_module;
    }
  } else {
    {
#line 1227
    tmp = __errno_location();
    }
#line 1227
    if (*tmp != 38) {
#line 1228
      module = & ngx_epoll_module;
    }
  }
#line 1253
  if ((unsigned long )module == (unsigned long )((void *)0)) {
#line 1254
    i = (ngx_int_t )0;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1254
      if (! *(cycle->modules + i)) {
#line 1254
        goto while_break;
      }
#line 1256
      if ((*(cycle->modules + i))->type != 1414420037UL) {
#line 1257
        goto __Cont;
      }
      {
#line 1260
      event_module = (ngx_event_module_t *)(*(cycle->modules + i))->ctx;
#line 1262
      tmp___0 = strcmp((char const   *)(event_module->name)->data, (char const   *)event_core_name.data);
      }
#line 1262
      if (tmp___0 == 0) {
#line 1264
        goto __Cont;
      }
#line 1267
      module = *(cycle->modules + i);
#line 1268
      goto while_break;
      __Cont: /* CIL Label */ 
#line 1254
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1272
  if ((unsigned long )module == (unsigned long )((void *)0)) {
#line 1273
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 1273
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "no events module found");
      }
    }
#line 1274
    return ((char *)((void *)-1));
  }
#line 1277
  if (ecf->connections == 0xffffffffffffffffUL) {
#line 1277
    ecf->connections = (ngx_uint_t )512;
  }
#line 1278
  cycle->connection_n = ecf->connections;
#line 1280
  if (ecf->use == 0xffffffffffffffffUL) {
#line 1280
    ecf->use = module->ctx_index;
  }
#line 1282
  event_module = (ngx_event_module_t *)module->ctx;
#line 1283
  if ((unsigned long )ecf->name == (unsigned long )((void *)-1)) {
#line 1283
    ecf->name = (event_module->name)->data;
  }
#line 1285
  if (ecf->multi_accept == -1L) {
#line 1285
    ecf->multi_accept = (ngx_flag_t )0;
  }
#line 1286
  if (ecf->accept_mutex == -1L) {
#line 1286
    ecf->accept_mutex = (ngx_flag_t )0;
  }
#line 1287
  if (ecf->accept_mutex_delay == 0xffffffffffffffffUL) {
#line 1287
    ecf->accept_mutex_delay = (ngx_msec_t )500;
  }
#line 1289
  return ((char *)((void *)0));
}
}
#line 43 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_syslog_time ;
#line 26 "src/core/ngx_syslog.h"
void ngx_syslog_writer(ngx_log_t *log , ngx_uint_t level , u_char *buf , size_t___0 len ) ;
#line 18 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static char *ngx_syslog_parse_args(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) ;
#line 19
static ngx_int_t ngx_syslog_init_peer(ngx_syslog_peer_t *peer ) ;
#line 20
static void ngx_syslog_cleanup(void *data ) ;
#line 23 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static char *facilities[25]  = 
#line 23
  {      (char *)"kern",      (char *)"user",      (char *)"mail",      (char *)"daemon", 
        (char *)"auth",      (char *)"intern",      (char *)"lpr",      (char *)"news", 
        (char *)"uucp",      (char *)"clock",      (char *)"authpriv",      (char *)"ftp", 
        (char *)"ntp",      (char *)"audit",      (char *)"alert",      (char *)"cron", 
        (char *)"local0",      (char *)"local1",      (char *)"local2",      (char *)"local3", 
        (char *)"local4",      (char *)"local5",      (char *)"local6",      (char *)"local7", 
        (char *)((void *)0)};
#line 31 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static char *severities[9]  = 
#line 31
  {      (char *)"emerg",      (char *)"alert",      (char *)"crit",      (char *)"error", 
        (char *)"warn",      (char *)"notice",      (char *)"info",      (char *)"debug", 
        (char *)((void *)0)};
#line 35 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static ngx_log_t ngx_syslog_dummy_log  ;
#line 36 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static ngx_event_t ngx_syslog_dummy_event  ;
#line 39 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
char *ngx_syslog_process_conf(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) 
{ 
  char *tmp ;

  {
  {
#line 42
  peer->pool = cf->pool;
#line 43
  peer->facility = (ngx_uint_t )-1;
#line 44
  peer->severity = (ngx_uint_t )-1;
#line 46
  tmp = ngx_syslog_parse_args(cf, peer);
  }
#line 46
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 47
    return ((char *)((void *)-1));
  }
#line 50
  if ((unsigned long )peer->server.sockaddr == (unsigned long )((void *)0)) {
    {
#line 51
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "no syslog server specified");
    }
#line 53
    return ((char *)((void *)-1));
  }
#line 56
  if (peer->facility == 0xffffffffffffffffUL) {
#line 57
    peer->facility = (ngx_uint_t )23;
  }
#line 60
  if (peer->severity == 0xffffffffffffffffUL) {
#line 61
    peer->severity = (ngx_uint_t )6;
  }
#line 64
  if ((unsigned long )peer->tag.data == (unsigned long )((void *)0)) {
#line 65
    peer->tag.len = sizeof("nginx") - 1UL;
#line 65
    peer->tag.data = (u_char *)"nginx";
  }
#line 68
  peer->conn.fd = -1;
#line 70
  return ((char *)((void *)0));
}
}
#line 74 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static char *ngx_syslog_parse_args(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) 
{ 
  u_char *p ;
  u_char *comma ;
  u_char c ;
  size_t___0 len ;
  ngx_str_t *value ;
  ngx_url_t u ;
  ngx_uint_t i ;
  char *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 83
  value = (ngx_str_t *)(cf->args)->elts;
#line 85
  p = ((value + 1)->data + sizeof("syslog:")) - 1;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 88
    tmp = strchr((char const   *)p, ',');
#line 88
    comma = (u_char *)tmp;
    }
#line 90
    if ((unsigned long )comma != (unsigned long )((void *)0)) {
#line 91
      len = (size_t___0 )(comma - p);
#line 92
      *comma = (u_char )'\000';
    } else {
#line 95
      len = (size_t___0 )(((value + 1)->data + (value + 1)->len) - p);
    }
    {
#line 98
    tmp___8 = strncmp((char const   *)p, "server=", (size_t )7);
    }
#line 98
    if (tmp___8 == 0) {
#line 100
      if ((unsigned long )peer->server.sockaddr != (unsigned long )((void *)0)) {
        {
#line 101
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"server\"");
        }
#line 103
        return ((char *)((void *)-1));
      }
      {
#line 106
      memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 108
      u.url.data = p + 7;
#line 109
      u.url.len = len - 7UL;
#line 110
      u.default_port = (in_port_t )514;
#line 112
      tmp___0 = ngx_parse_url(cf->pool, & u);
      }
#line 112
      if (tmp___0 != 0L) {
#line 113
        if (u.err) {
          {
#line 114
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in syslog server \"%V\"",
                             u.err, & u.url);
          }
        }
#line 119
        return ((char *)((void *)-1));
      }
#line 122
      peer->server = *(u.addrs + 0);
    } else {
      {
#line 124
      tmp___7 = strncmp((char const   *)p, "facility=", (size_t )9);
      }
#line 124
      if (tmp___7 == 0) {
#line 126
        if (peer->facility != 0xffffffffffffffffUL) {
          {
#line 127
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"facility\"");
          }
#line 129
          return ((char *)((void *)-1));
        }
#line 132
        i = (ngx_uint_t )0;
        {
#line 132
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 132
          if (! ((unsigned long )facilities[i] != (unsigned long )((void *)0))) {
#line 132
            goto while_break___0;
          }
          {
#line 134
          tmp___1 = strcmp((char const   *)p + 9, (char const   *)facilities[i]);
          }
#line 134
          if (tmp___1 == 0) {
#line 135
            peer->facility = i;
#line 136
            goto next;
          }
#line 132
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 140
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog facility \"%s\"",
                           p + 9);
        }
#line 142
        return ((char *)((void *)-1));
      } else {
        {
#line 144
        tmp___6 = strncmp((char const   *)p, "severity=", (size_t )9);
        }
#line 144
        if (tmp___6 == 0) {
#line 146
          if (peer->severity != 0xffffffffffffffffUL) {
            {
#line 147
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"severity\"");
            }
#line 149
            return ((char *)((void *)-1));
          }
#line 152
          i = (ngx_uint_t )0;
          {
#line 152
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 152
            if (! ((unsigned long )severities[i] != (unsigned long )((void *)0))) {
#line 152
              goto while_break___1;
            }
            {
#line 154
            tmp___2 = strcmp((char const   *)p + 9, (char const   *)severities[i]);
            }
#line 154
            if (tmp___2 == 0) {
#line 155
              peer->severity = i;
#line 156
              goto next;
            }
#line 152
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 160
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog severity \"%s\"",
                             p + 9);
          }
#line 162
          return ((char *)((void *)-1));
        } else {
          {
#line 164
          tmp___5 = strncmp((char const   *)p, "tag=", (size_t )4);
          }
#line 164
          if (tmp___5 == 0) {
#line 166
            if ((unsigned long )peer->tag.data != (unsigned long )((void *)0)) {
              {
#line 167
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"tag\"");
              }
#line 169
              return ((char *)((void *)-1));
            }
#line 176
            if (len - 4UL > 32UL) {
              {
#line 177
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog tag length exceeds 32");
              }
#line 179
              return ((char *)((void *)-1));
            }
#line 182
            i = (ngx_uint_t )4;
            {
#line 182
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 182
              if (! (i < len)) {
#line 182
                goto while_break___2;
              }
#line 183
              if ((int )*(p + i) >= 65) {
#line 183
                if ((int )*(p + i) <= 90) {
#line 183
                  tmp___3 = (int )*(p + i) | 32;
                } else {
#line 183
                  tmp___3 = (int )*(p + i);
                }
              } else {
#line 183
                tmp___3 = (int )*(p + i);
              }
#line 183
              c = (u_char )tmp___3;
#line 185
              if ((int )c < 48) {
                {
#line 186
                ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog \"tag\" only allows alphanumeric characters and underscore");
                }
#line 190
                return ((char *)((void *)-1));
              } else
#line 185
              if ((int )c > 57) {
#line 185
                if ((int )c < 97) {
#line 185
                  if ((int )c != 95) {
                    {
#line 186
                    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog \"tag\" only allows alphanumeric characters and underscore");
                    }
#line 190
                    return ((char *)((void *)-1));
                  } else {
#line 185
                    goto _L___0;
                  }
                } else {
#line 185
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 185
              if ((int )c > 122) {
                {
#line 186
                ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog \"tag\" only allows alphanumeric characters and underscore");
                }
#line 190
                return ((char *)((void *)-1));
              }
#line 182
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 194
            peer->tag.data = p + 4;
#line 195
            peer->tag.len = len - 4UL;
          } else
#line 197
          if (len == 10UL) {
            {
#line 197
            tmp___4 = strncmp((char const   *)p, "nohostname", (size_t )10);
            }
#line 197
            if (tmp___4 == 0) {
#line 198
              peer->nohostname = 1U;
            } else {
              {
#line 201
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog parameter \"%s\"",
                                 p);
              }
#line 203
              return ((char *)((void *)-1));
            }
          } else {
            {
#line 201
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog parameter \"%s\"",
                               p);
            }
#line 203
            return ((char *)((void *)-1));
          }
        }
      }
    }
    next: 
#line 208
    if ((unsigned long )comma == (unsigned long )((void *)0)) {
#line 209
      goto while_break;
    }
#line 212
    p = comma + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return ((char *)((void *)0));
}
}
#line 219 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
u_char *ngx_syslog_add_header(ngx_syslog_peer_t *peer , u_char *buf ) 
{ 
  ngx_uint_t pri ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
#line 224
  pri = peer->facility * 8UL + peer->severity;
#line 226
  if (peer->nohostname) {
    {
#line 227
    tmp = ngx_sprintf(buf, "<%ui>%V %V: ", pri, & ngx_cached_syslog_time, & peer->tag);
    }
#line 227
    return (tmp);
  }
  {
#line 231
  tmp___0 = ngx_sprintf(buf, "<%ui>%V %V %V: ", pri, & ngx_cached_syslog_time, & ngx_cycle->hostname,
                        & peer->tag);
  }
#line 231
  return (tmp___0);
}
}
#line 236 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
void ngx_syslog_writer(ngx_log_t *log , ngx_uint_t level , u_char *buf , size_t___0 len ) 
{ 
  u_char *p ;
  u_char msg[(((((2048UL + sizeof("<255>Jan 01 00:00:00 ")) - 1UL) + 255UL) + 1UL) + 32UL) + 2UL] ;
  ngx_uint_t head_len ;
  ngx_syslog_peer_t *peer ;

  {
#line 244
  peer = (ngx_syslog_peer_t *)log->wdata;
#line 246
  if (peer->busy) {
#line 247
    return;
  }
  {
#line 250
  peer->busy = 1U;
#line 251
  peer->severity = level - 1UL;
#line 253
  p = ngx_syslog_add_header(peer, msg);
#line 254
  head_len = (ngx_uint_t )(p - msg);
#line 256
  len --;
  }
#line 258
  if (len > ((((((2048UL + sizeof("<255>Jan 01 00:00:00 ")) - 1UL) + 255UL) + 1UL) + 32UL) + 2UL) - head_len) {
#line 259
    len = ((((((2048UL + sizeof("<255>Jan 01 00:00:00 ")) - 1UL) + 255UL) + 1UL) + 32UL) + 2UL) - head_len;
  }
  {
#line 262
  p = ngx_snprintf(p, len, "%s", buf);
#line 264
  ngx_syslog_send(peer, msg, (size_t___0 )(p - msg));
#line 266
  peer->busy = 0U;
  }
#line 267
  return;
}
}
#line 270 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
ssize_t ngx_syslog_send(ngx_syslog_peer_t *peer , u_char *buf , size_t___0 len ) 
{ 
  ssize_t n ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 275
  if (peer->conn.fd == -1) {
    {
#line 276
    tmp = ngx_syslog_init_peer(peer);
    }
#line 276
    if (tmp != 0L) {
#line 277
      return ((ssize_t )-1);
    }
  }
#line 282
  peer->conn.log = (ngx_log_t *)ngx_cycle->log;
#line 284
  if (ngx_io.send) {
    {
#line 285
    n = (*(ngx_io.send))(& peer->conn, buf, len);
    }
  } else {
    {
#line 289
    n = (*(ngx_os_io.send))(& peer->conn, buf, len);
    }
  }
#line 294
  if (n == -1L) {
#line 294
    if ((int )(peer->server.sockaddr)->sa_family == 1) {
      {
#line 296
      tmp___1 = close(peer->conn.fd);
      }
#line 296
      if (tmp___1 == -1) {
#line 297
        if ((ngx_cycle->log)->log_level >= 2UL) {
          {
#line 297
          tmp___0 = __errno_location();
#line 297
          ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___0,
                             "close() socket failed");
          }
        }
      }
#line 301
      peer->conn.fd = -1;
    }
  }
#line 306
  return (n);
}
}
#line 310 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static ngx_int_t ngx_syslog_init_peer(ngx_syslog_peer_t *peer ) 
{ 
  ngx_socket_t fd ;
  ngx_pool_cleanup_t *cln ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 316
  peer->conn.read = & ngx_syslog_dummy_event;
#line 317
  peer->conn.write = & ngx_syslog_dummy_event;
#line 319
  ngx_syslog_dummy_event.log = & ngx_syslog_dummy_log;
#line 321
  fd = socket((int )(peer->server.sockaddr)->sa_family, 2, 0);
  }
#line 322
  if (fd == -1) {
#line 323
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 323
      tmp = __errno_location();
#line 323
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "socket() failed");
      }
    }
#line 325
    return ((ngx_int_t )-1);
  }
  {
#line 328
  tmp___1 = ngx_nonblocking(fd);
  }
#line 328
  if (tmp___1 == -1) {
#line 329
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 329
      tmp___0 = __errno_location();
#line 329
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___0, "ioctl(FIONBIO) failed");
      }
    }
#line 331
    goto failed;
  }
  {
#line 334
  tmp___3 = connect(fd, (struct sockaddr  const  */* __restrict  */)peer->server.sockaddr,
                    peer->server.socklen);
  }
#line 334
  if (tmp___3 == -1) {
#line 335
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 335
      tmp___2 = __errno_location();
#line 335
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___2, "connect() failed");
      }
    }
#line 337
    goto failed;
  }
  {
#line 340
  cln = ngx_pool_cleanup_add(peer->pool, (size_t___0 )0);
  }
#line 341
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 342
    goto failed;
  }
#line 345
  cln->data = (void *)peer;
#line 346
  cln->handler = & ngx_syslog_cleanup;
#line 348
  peer->conn.fd = fd;
#line 351
  (peer->conn.write)->ready = 1U;
#line 353
  return ((ngx_int_t )0);
  failed: 
  {
#line 357
  tmp___5 = close(fd);
  }
#line 357
  if (tmp___5 == -1) {
#line 358
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 358
      tmp___4 = __errno_location();
#line 358
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___4, "close() socket failed");
      }
    }
  }
#line 362
  return ((ngx_int_t )-1);
}
}
#line 366 "/tmp/nginx-1.13.2/src/core/ngx_syslog.c"
static void ngx_syslog_cleanup(void *data ) 
{ 
  ngx_syslog_peer_t *peer ;
  int *tmp ;
  int tmp___0 ;

  {
#line 369
  peer = (ngx_syslog_peer_t *)data;
#line 372
  peer->busy = 1U;
#line 374
  if (peer->conn.fd == -1) {
#line 375
    return;
  }
  {
#line 378
  tmp___0 = close(peer->conn.fd);
  }
#line 378
  if (tmp___0 == -1) {
#line 379
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 379
      tmp = __errno_location();
#line 379
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "close() socket failed");
      }
    }
  }
#line 382
  return;
}
}
#line 151 "src/core/ngx_string.h"
u_char *ngx_slprintf(u_char *buf , u_char *last , char const   *fmt  , ...) ;
#line 21 "src/core/ngx_proxy_protocol.h"
u_char *ngx_proxy_protocol_write(ngx_connection_t *c , u_char *buf , u_char *last ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_proxy_protocol.c"
u_char *ngx_proxy_protocol_read(ngx_connection_t *c , u_char *buf , u_char *last ) 
{ 
  size_t___0 len ;
  u_char ch ;
  u_char *p ;
  u_char *addr ;
  u_char *port ;
  ngx_int_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;

  {
#line 19
  p = buf;
#line 20
  len = (size_t___0 )(last - buf);
#line 22
  if (len < 8UL) {
#line 23
    goto invalid;
  } else {
    {
#line 22
    tmp = strncmp((char const   *)p, "PROXY ", (size_t )6);
    }
#line 22
    if (tmp != 0) {
#line 23
      goto invalid;
    }
  }
#line 26
  p += 6;
#line 27
  len -= 6UL;
#line 29
  if (len >= 7UL) {
    {
#line 29
    tmp___0 = strncmp((char const   *)p, "UNKNOWN", (size_t )7);
    }
#line 29
    if (tmp___0 == 0) {
#line 32
      p += 7;
#line 33
      goto skip;
    }
  }
#line 36
  if (len < 5UL) {
#line 39
    goto invalid;
  } else {
    {
#line 36
    tmp___1 = strncmp((char const   *)p, "TCP", (size_t )3);
    }
#line 36
    if (tmp___1 != 0) {
#line 39
      goto invalid;
    } else
#line 36
    if ((int )*(p + 3) != 52) {
#line 36
      if ((int )*(p + 3) != 54) {
#line 39
        goto invalid;
      } else {
#line 36
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 36
    if ((int )*(p + 4) != 32) {
#line 39
      goto invalid;
    }
  }
#line 42
  p += 5;
#line 43
  addr = p;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if ((unsigned long )p == (unsigned long )last) {
#line 47
      goto invalid;
    }
#line 50
    tmp___2 = p;
#line 50
    p ++;
#line 50
    ch = *tmp___2;
#line 52
    if ((int )ch == 32) {
#line 53
      goto while_break;
    }
#line 56
    if ((int )ch != 58) {
#line 56
      if ((int )ch != 46) {
#line 56
        if ((int )ch < 97) {
#line 56
          goto _L___1;
        } else
#line 56
        if ((int )ch > 102) {
          _L___1: /* CIL Label */ 
#line 56
          if ((int )ch < 65) {
#line 56
            goto _L___0;
          } else
#line 56
          if ((int )ch > 70) {
            _L___0: /* CIL Label */ 
#line 56
            if ((int )ch < 48) {
#line 61
              goto invalid;
            } else
#line 56
            if ((int )ch > 57) {
#line 61
              goto invalid;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  len = (size_t___0 )((p - addr) - 1L);
#line 66
  tmp___3 = ngx_pnalloc(c->pool, len);
#line 66
  c->proxy_protocol_addr.data = (u_char *)tmp___3;
  }
#line 68
  if ((unsigned long )c->proxy_protocol_addr.data == (unsigned long )((void *)0)) {
#line 69
    return ((u_char *)((void *)0));
  }
  {
#line 72
  memcpy((void */* __restrict  */)c->proxy_protocol_addr.data, (void const   */* __restrict  */)addr,
         len);
#line 73
  c->proxy_protocol_addr.len = len;
  }
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if ((unsigned long )p == (unsigned long )last) {
#line 77
      goto invalid;
    }
#line 80
    tmp___4 = p;
#line 80
    p ++;
#line 80
    if ((int )*tmp___4 == 32) {
#line 81
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  port = p;
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 88
    if ((unsigned long )p == (unsigned long )last) {
#line 89
      goto invalid;
    }
#line 92
    tmp___5 = p;
#line 92
    p ++;
#line 92
    if ((int )*tmp___5 == 32) {
#line 93
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  len = (size_t___0 )((p - port) - 1L);
#line 99
  n = ngx_atoi(port, len);
  }
#line 101
  if (n < 0L) {
#line 102
    goto invalid;
  } else
#line 101
  if (n > 65535L) {
#line 102
    goto invalid;
  }
#line 105
  c->proxy_protocol_port = (in_port_t )n;
  skip: 
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )p < (unsigned long )(last - 1))) {
#line 112
      goto while_break___2;
    }
#line 113
    if ((int )*(p + 0) == 13) {
#line 113
      if ((int )*(p + 1) == 10) {
#line 114
        return (p + 2);
      }
    }
#line 112
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  invalid: 
#line 120
  if ((c->log)->log_level >= 4UL) {
    {
#line 120
    ngx_log_error_core((ngx_uint_t )4, c->log, 0, "broken header: \"%*s\"", (size_t___0 )(last - buf),
                       buf);
    }
  }
#line 123
  return ((u_char *)((void *)0));
}
}
#line 127 "/tmp/nginx-1.13.2/src/core/ngx_proxy_protocol.c"
u_char *ngx_proxy_protocol_write(ngx_connection_t *c , u_char *buf , u_char *last ) 
{ 
  ngx_uint_t port ;
  ngx_uint_t lport ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t___0 tmp___3 ;
  u_char *tmp___4 ;
  size_t___0 tmp___5 ;
  in_port_t tmp___6 ;
  in_port_t tmp___7 ;
  u_char *tmp___8 ;

  {
#line 132
  if (last - buf < 107L) {
#line 133
    return ((u_char *)((void *)0));
  }
  {
#line 136
  tmp = ngx_connection_local_sockaddr(c, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
  }
#line 136
  if (tmp != 0L) {
#line 137
    return ((u_char *)((void *)0));
  }
  {
#line 142
  if ((int )(c->sockaddr)->sa_family == 2) {
#line 142
    goto case_2;
  }
#line 147
  if ((int )(c->sockaddr)->sa_family == 10) {
#line 147
    goto case_10;
  }
#line 152
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 143
  tmp___0 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"PROXY TCP4 ",
                   sizeof("PROXY TCP4 ") - 1UL);
#line 143
  buf = (u_char *)tmp___0 + (sizeof("PROXY TCP4 ") - 1UL);
  }
#line 144
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 148
  tmp___1 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"PROXY TCP6 ",
                   sizeof("PROXY TCP6 ") - 1UL);
#line 148
  buf = (u_char *)tmp___1 + (sizeof("PROXY TCP6 ") - 1UL);
  }
#line 149
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 153
  tmp___2 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"PROXY UNKNOWN\r\n",
                   sizeof("PROXY UNKNOWN\r\n") - 1UL);
  }
#line 153
  return ((u_char *)tmp___2 + (sizeof("PROXY UNKNOWN\r\n") - 1UL));
  switch_break: /* CIL Label */ ;
  }
  {
#line 157
  tmp___3 = ngx_sock_ntop(c->sockaddr, c->socklen, buf, (size_t___0 )(last - buf),
                          (ngx_uint_t )0);
#line 157
  buf += tmp___3;
#line 159
  tmp___4 = buf;
#line 159
  buf ++;
#line 159
  *tmp___4 = (u_char )' ';
#line 161
  tmp___5 = ngx_sock_ntop(c->local_sockaddr, c->local_socklen, buf, (size_t___0 )(last - buf),
                          (ngx_uint_t )0);
#line 161
  buf += tmp___5;
#line 164
  tmp___6 = ngx_inet_get_port(c->sockaddr);
#line 164
  port = (ngx_uint_t )tmp___6;
#line 165
  tmp___7 = ngx_inet_get_port(c->local_sockaddr);
#line 165
  lport = (ngx_uint_t )tmp___7;
#line 167
  tmp___8 = ngx_slprintf(buf, last, " %ui %ui\r\n", port, lport);
  }
#line 167
  return (tmp___8);
}
}
#line 23 "src/core/ngx_sha1.h"
void ngx_sha1_init(ngx_sha1_t *ctx ) ;
#line 24
void ngx_sha1_update(ngx_sha1_t *ctx , void const   *data , size_t___0 size ) ;
#line 25
void ngx_sha1_final(u_char *result___0 , ngx_sha1_t *ctx ) ;
#line 16 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_apr1(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 18
static ngx_int_t ngx_crypt_plain(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 20
static ngx_int_t ngx_crypt_ssha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 22
static ngx_int_t ngx_crypt_sha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 26
static u_char *ngx_crypt_to64(u_char *p , uint32_t v , size_t___0 n ) ;
#line 29 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
ngx_int_t ngx_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;

  {
  {
#line 32
  tmp___6 = strncmp((char const   *)salt, "$apr1$", sizeof("$apr1$") - 1UL);
  }
#line 32
  if (tmp___6 == 0) {
    {
#line 33
    tmp = ngx_crypt_apr1(pool, key, salt, encrypted);
    }
#line 33
    return (tmp);
  } else {
    {
#line 35
    tmp___5 = strncmp((char const   *)salt, "{PLAIN}", sizeof("{PLAIN}") - 1UL);
    }
#line 35
    if (tmp___5 == 0) {
      {
#line 36
      tmp___0 = ngx_crypt_plain(pool, key, salt, encrypted);
      }
#line 36
      return (tmp___0);
    } else {
      {
#line 38
      tmp___4 = strncmp((char const   *)salt, "{SSHA}", sizeof("{SSHA}") - 1UL);
      }
#line 38
      if (tmp___4 == 0) {
        {
#line 39
        tmp___1 = ngx_crypt_ssha(pool, key, salt, encrypted);
        }
#line 39
        return (tmp___1);
      } else {
        {
#line 41
        tmp___3 = strncmp((char const   *)salt, "{SHA}", sizeof("{SHA}") - 1UL);
        }
#line 41
        if (tmp___3 == 0) {
          {
#line 42
          tmp___2 = ngx_crypt_sha(pool, key, salt, encrypted);
          }
#line 42
          return (tmp___2);
        }
      }
    }
  }
  {
#line 47
  tmp___7 = ngx_libc_crypt(pool, key, salt, encrypted);
  }
#line 47
  return (tmp___7);
}
}
#line 51 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_apr1(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  ngx_int_t n ;
  ngx_uint_t i ;
  u_char *p ;
  u_char *last ;
  u_char final[16] ;
  size_t___0 saltlen ;
  size_t___0 keylen ;
  ngx_md5_t md5 ;
  ngx_md5_t ctx1 ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;

  {
  {
#line 62
  keylen = strlen((char const   *)key);
#line 66
  salt += sizeof("$apr1$") - 1UL;
#line 67
  last = salt + 8;
#line 68
  p = salt;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (*p) {
#line 68
      if ((int )*p != 36) {
#line 68
        if (! ((unsigned long )p < (unsigned long )last)) {
#line 68
          goto while_break;
        }
      } else {
#line 68
        goto while_break;
      }
    } else {
#line 68
      goto while_break;
    }
#line 68
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  saltlen = (size_t___0 )(p - salt);
#line 73
  ngx_md5_init(& md5);
#line 74
  ngx_md5_update(& md5, (void const   *)key, keylen);
#line 75
  ngx_md5_update(& md5, (void const   *)((u_char *)"$apr1$"), sizeof("$apr1$") - 1UL);
#line 76
  ngx_md5_update(& md5, (void const   *)salt, saltlen);
#line 78
  ngx_md5_init(& ctx1);
#line 79
  ngx_md5_update(& ctx1, (void const   *)key, keylen);
#line 80
  ngx_md5_update(& ctx1, (void const   *)salt, saltlen);
#line 81
  ngx_md5_update(& ctx1, (void const   *)key, keylen);
#line 82
  ngx_md5_final((u_char *)(final), & ctx1);
#line 84
  n = (ngx_int_t )keylen;
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (n > 0L)) {
#line 84
      goto while_break___0;
    }
#line 85
    if (n > 16L) {
#line 85
      tmp = (ngx_int_t )16;
    } else {
#line 85
      tmp = n;
    }
    {
#line 85
    ngx_md5_update(& md5, (void const   *)(final), (size_t___0 )tmp);
#line 84
    n -= 16L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 88
  memset((void *)(final), 0, sizeof(final));
#line 90
  i = keylen;
  }
  {
#line 90
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 90
    if (! i) {
#line 90
      goto while_break___1;
    }
#line 91
    if (i & 1UL) {
      {
#line 92
      ngx_md5_update(& md5, (void const   *)(final), (size_t___0 )1);
      }
    } else {
      {
#line 95
      ngx_md5_update(& md5, (void const   *)key, (size_t___0 )1);
      }
    }
#line 90
    i >>= 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 99
  ngx_md5_final((u_char *)(final), & md5);
#line 101
  i = (ngx_uint_t )0;
  }
  {
#line 101
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 101
    if (! (i < 1000UL)) {
#line 101
      goto while_break___2;
    }
    {
#line 102
    ngx_md5_init(& ctx1);
    }
#line 104
    if (i & 1UL) {
      {
#line 105
      ngx_md5_update(& ctx1, (void const   *)key, keylen);
      }
    } else {
      {
#line 108
      ngx_md5_update(& ctx1, (void const   *)(final), (size_t___0 )16);
      }
    }
#line 111
    if (i % 3UL) {
      {
#line 112
      ngx_md5_update(& ctx1, (void const   *)salt, saltlen);
      }
    }
#line 115
    if (i % 7UL) {
      {
#line 116
      ngx_md5_update(& ctx1, (void const   *)key, keylen);
      }
    }
#line 119
    if (i & 1UL) {
      {
#line 120
      ngx_md5_update(& ctx1, (void const   *)(final), (size_t___0 )16);
      }
    } else {
      {
#line 123
      ngx_md5_update(& ctx1, (void const   *)key, keylen);
      }
    }
    {
#line 126
    ngx_md5_final((u_char *)(final), & ctx1);
#line 101
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = ngx_pnalloc(pool, ((((sizeof("$apr1$") - 1UL) + saltlen) + 1UL) + 22UL) + 1UL);
#line 131
  *encrypted = (u_char *)tmp___0;
  }
#line 132
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 133
    return ((ngx_int_t )-1);
  }
  {
#line 136
  tmp___1 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"$apr1$",
                   sizeof("$apr1$") - 1UL);
#line 136
  p = (u_char *)tmp___1 + (sizeof("$apr1$") - 1UL);
#line 137
  tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)salt,
                   saltlen);
#line 137
  p = (u_char *)tmp___2 + saltlen;
#line 138
  tmp___3 = p;
#line 138
  p ++;
#line 138
  *tmp___3 = (u_char )'$';
#line 140
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[0] << 16) | ((int )final[6] << 8)) | (int )final[12]),
                     (size_t___0 )4);
#line 141
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[1] << 16) | ((int )final[7] << 8)) | (int )final[13]),
                     (size_t___0 )4);
#line 142
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[2] << 16) | ((int )final[8] << 8)) | (int )final[14]),
                     (size_t___0 )4);
#line 143
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[3] << 16) | ((int )final[9] << 8)) | (int )final[15]),
                     (size_t___0 )4);
#line 144
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[4] << 16) | ((int )final[10] << 8)) | (int )final[5]),
                     (size_t___0 )4);
#line 145
  p = ngx_crypt_to64(p, (uint32_t )final[11], (size_t___0 )2);
#line 146
  *p = (u_char )'\000';
  }
#line 148
  return ((ngx_int_t )0);
}
}
#line 155 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
static u_char itoa64[65]  = 
#line 155
  {      (u_char )'.',      (u_char )'/',      (u_char )'0',      (u_char )'1', 
        (u_char )'2',      (u_char )'3',      (u_char )'4',      (u_char )'5', 
        (u_char )'6',      (u_char )'7',      (u_char )'8',      (u_char )'9', 
        (u_char )'A',      (u_char )'B',      (u_char )'C',      (u_char )'D', 
        (u_char )'E',      (u_char )'F',      (u_char )'G',      (u_char )'H', 
        (u_char )'I',      (u_char )'J',      (u_char )'K',      (u_char )'L', 
        (u_char )'M',      (u_char )'N',      (u_char )'O',      (u_char )'P', 
        (u_char )'Q',      (u_char )'R',      (u_char )'S',      (u_char )'T', 
        (u_char )'U',      (u_char )'V',      (u_char )'W',      (u_char )'X', 
        (u_char )'Y',      (u_char )'Z',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'g',      (u_char )'h',      (u_char )'i',      (u_char )'j', 
        (u_char )'k',      (u_char )'l',      (u_char )'m',      (u_char )'n', 
        (u_char )'o',      (u_char )'p',      (u_char )'q',      (u_char )'r', 
        (u_char )'s',      (u_char )'t',      (u_char )'u',      (u_char )'v', 
        (u_char )'w',      (u_char )'x',      (u_char )'y',      (u_char )'z', 
        (u_char )'\000'};
#line 152 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
static u_char *ngx_crypt_to64(u_char *p , uint32_t v , size_t___0 n ) 
{ 
  u_char *tmp ;
  size_t___0 tmp___0 ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    tmp___0 = n;
#line 158
    n --;
#line 158
    if (! tmp___0) {
#line 158
      goto while_break;
    }
#line 159
    tmp = p;
#line 159
    p ++;
#line 159
    *tmp = itoa64[v & 63U];
#line 160
    v >>= 6;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return (p);
}
}
#line 167 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_plain(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  size_t___0 len ;
  u_char *p ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 173
  len = strlen((char const   *)key);
#line 175
  tmp = ngx_pnalloc(pool, ((sizeof("{PLAIN}") - 1UL) + len) + 1UL);
#line 175
  *encrypted = (u_char *)tmp;
  }
#line 176
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 177
    return ((ngx_int_t )-1);
  }
  {
#line 180
  tmp___0 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"{PLAIN}",
                   sizeof("{PLAIN}") - 1UL);
#line 180
  p = (u_char *)tmp___0 + (sizeof("{PLAIN}") - 1UL);
#line 181
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)key, len + 1UL);
  }
#line 183
  return ((ngx_int_t )0);
}
}
#line 187 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_ssha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_str_t encoded ;
  ngx_str_t decoded ;
  ngx_sha1_t sha1 ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 199
  encoded.data = (salt + sizeof("{SSHA}")) - 1;
#line 200
  encoded.len = strlen((char const   *)encoded.data);
  }
#line 202
  if (((encoded.len + 3UL) / 4UL) * 3UL < 20UL) {
#line 202
    len = (size_t___0 )20;
  } else {
#line 202
    len = ((encoded.len + 3UL) / 4UL) * 3UL;
  }
  {
#line 204
  tmp = ngx_pnalloc(pool, len);
#line 204
  decoded.data = (u_char *)tmp;
  }
#line 205
  if ((unsigned long )decoded.data == (unsigned long )((void *)0)) {
#line 206
    return ((ngx_int_t )-1);
  }
  {
#line 209
  rc = ngx_decode_base64(& decoded, & encoded);
  }
#line 211
  if (rc != 0L) {
#line 212
    decoded.len = (size_t___0 )20;
  } else
#line 211
  if (decoded.len < 20UL) {
#line 212
    decoded.len = (size_t___0 )20;
  }
  {
#line 217
  ngx_sha1_init(& sha1);
#line 218
  tmp___0 = strlen((char const   *)key);
#line 218
  ngx_sha1_update(& sha1, (void const   *)key, tmp___0);
#line 219
  ngx_sha1_update(& sha1, (void const   *)(decoded.data + 20), decoded.len - 20UL);
#line 220
  ngx_sha1_final((u_char *)decoded.data, & sha1);
#line 224
  len = ((sizeof("{SSHA}") - 1UL) + ((decoded.len + 2UL) / 3UL) * 4UL) + 1UL;
#line 226
  tmp___1 = ngx_pnalloc(pool, len);
#line 226
  *encrypted = (u_char *)tmp___1;
  }
#line 227
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 228
    return ((ngx_int_t )-1);
  }
  {
#line 231
  tmp___2 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"{SSHA}",
                   sizeof("{SSHA}") - 1UL);
#line 231
  encoded.data = (u_char *)tmp___2 + (sizeof("{SSHA}") - 1UL);
#line 232
  ngx_encode_base64(& encoded, & decoded);
#line 233
  *(encoded.data + encoded.len) = (u_char )'\000';
  }
#line 235
  return ((ngx_int_t )0);
}
}
#line 239 "/tmp/nginx-1.13.2/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_sha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  size_t___0 len ;
  ngx_str_t encoded ;
  ngx_str_t decoded ;
  ngx_sha1_t sha1 ;
  u_char digest[20] ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 249
  decoded.len = sizeof(digest);
#line 250
  decoded.data = digest;
#line 252
  ngx_sha1_init(& sha1);
#line 253
  tmp = strlen((char const   *)key);
#line 253
  ngx_sha1_update(& sha1, (void const   *)key, tmp);
#line 254
  ngx_sha1_final((u_char *)(digest), & sha1);
#line 256
  len = ((sizeof("{SHA}") - 1UL) + ((decoded.len + 2UL) / 3UL) * 4UL) + 1UL;
#line 258
  tmp___0 = ngx_pnalloc(pool, len);
#line 258
  *encrypted = (u_char *)tmp___0;
  }
#line 259
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 260
    return ((ngx_int_t )-1);
  }
  {
#line 263
  tmp___1 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"{SHA}",
                   sizeof("{SHA}") - 1UL);
#line 263
  encoded.data = (u_char *)tmp___1 + (sizeof("{SHA}") - 1UL);
#line 264
  ngx_encode_base64(& encoded, & decoded);
#line 265
  *(encoded.data + encoded.len) = (u_char )'\000';
  }
#line 267
  return ((ngx_int_t )0);
}
}
#line 185 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...)  __asm__("openat64")  ;
#line 88 "src/core/ngx_palloc.h"
void ngx_pool_cleanup_file(void *data ) ;
#line 24 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_cleanup(void *data ) ;
#line 26
static ngx_fd_t ngx_openat_file_owner(ngx_fd_t at_fd , u_char const   *name , ngx_int_t mode ,
                                      ngx_int_t create , ngx_int_t access___0 , ngx_log_t *log ) ;
#line 29
static ngx_int_t ngx_file_o_path_info(ngx_fd_t fd , ngx_file_info_t *fi , ngx_log_t *log ) ;
#line 33
static ngx_fd_t ngx_open_file_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                      ngx_int_t mode , ngx_int_t create , ngx_int_t access___0 ,
                                      ngx_log_t *log ) ;
#line 36
static ngx_int_t ngx_file_info_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                       ngx_file_info_t *fi , ngx_log_t *log ) ;
#line 38
static ngx_int_t ngx_open_and_stat_file(ngx_str_t *name , ngx_open_file_info_t *of ,
                                        ngx_log_t *log ) ;
#line 40
static void ngx_open_file_add_event(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                    ngx_open_file_info_t *of , ngx_log_t *log ) ;
#line 42
static void ngx_open_file_cleanup(void *data ) ;
#line 43
static void ngx_close_cached_file(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                  ngx_uint_t min_uses , ngx_log_t *log ) ;
#line 45
static void ngx_open_file_del_event(ngx_cached_open_file_t *file ) ;
#line 46
static void ngx_expire_old_cached_files(ngx_open_file_cache_t *cache , ngx_uint_t n ,
                                        ngx_log_t *log ) ;
#line 48
static void ngx_open_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) ;
#line 50
static ngx_cached_open_file_t *ngx_open_file_lookup(ngx_open_file_cache_t *cache ,
                                                    ngx_str_t *name , uint32_t hash ) ;
#line 53
static void ngx_open_file_cache_remove(ngx_event_t *ev ) ;
#line 56 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
ngx_open_file_cache_t *ngx_open_file_cache_init(ngx_pool_t *pool , ngx_uint_t max ,
                                                time_t inactive ) 
{ 
  ngx_pool_cleanup_t *cln ;
  ngx_open_file_cache_t *cache ;
  void *tmp ;

  {
  {
#line 62
  tmp = ngx_palloc(pool, sizeof(ngx_open_file_cache_t ));
#line 62
  cache = (ngx_open_file_cache_t *)tmp;
  }
#line 63
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 64
    return ((ngx_open_file_cache_t *)((void *)0));
  }
  {
#line 67
  cache->sentinel.color = (u_char )0;
#line 67
  cache->rbtree.root = & cache->sentinel;
#line 67
  cache->rbtree.sentinel = & cache->sentinel;
#line 67
  cache->rbtree.insert = & ngx_open_file_cache_rbtree_insert_value;
#line 70
  cache->expire_queue.prev = & cache->expire_queue;
#line 70
  cache->expire_queue.next = & cache->expire_queue;
#line 72
  cache->current = (ngx_uint_t )0;
#line 73
  cache->max = max;
#line 74
  cache->inactive = inactive;
#line 76
  cln = ngx_pool_cleanup_add(pool, (size_t___0 )0);
  }
#line 77
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 78
    return ((ngx_open_file_cache_t *)((void *)0));
  }
#line 81
  cln->handler = & ngx_open_file_cache_cleanup;
#line 82
  cln->data = (void *)cache;
#line 84
  return (cache);
}
}
#line 88 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_cleanup(void *data ) 
{ 
  ngx_open_file_cache_t *cache ;
  ngx_queue_t *q ;
  ngx_cached_open_file_t *file ;

  {
#line 91
  cache = (ngx_open_file_cache_t *)data;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if ((unsigned long )(& cache->expire_queue) == (unsigned long )cache->expire_queue.prev) {
#line 102
      goto while_break;
    }
    {
#line 105
    q = cache->expire_queue.prev;
#line 107
    file = (ngx_cached_open_file_t *)((u_char *)q - (unsigned long )(& ((ngx_cached_open_file_t *)0)->queue));
#line 109
    (q->next)->prev = q->prev;
#line 109
    (q->prev)->next = q->next;
#line 111
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 113
    (cache->current) --;
    }
#line 118
    if (! file->err) {
#line 118
      if (! file->is_dir) {
        {
#line 119
        file->close = 1U;
#line 120
        file->count = 0U;
#line 121
        ngx_close_cached_file(cache, file, (ngx_uint_t )0, (ngx_log_t *)ngx_cycle->log);
        }
      } else {
        {
#line 124
        free((void *)file->name);
#line 125
        free((void *)file);
        }
      }
    } else {
      {
#line 124
      free((void *)file->name);
#line 125
      free((void *)file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  if (cache->current) {
#line 130
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 130
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "%ui items still left in open file cache",
                         cache->current);
      }
    }
  }
#line 135
  if ((unsigned long )cache->rbtree.root != (unsigned long )cache->rbtree.sentinel) {
#line 136
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 136
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "rbtree still is not empty in open file cache");
      }
    }
  }
#line 140
  return;
}
}
#line 143 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
ngx_int_t ngx_open_cached_file(ngx_open_file_cache_t *cache , ngx_str_t *name , ngx_open_file_info_t *of ,
                               ngx_pool_t *pool ) 
{ 
  time_t now ;
  uint32_t hash ;
  ngx_int_t rc ;
  ngx_file_info_t fi ;
  ngx_pool_cleanup_t *cln ;
  ngx_cached_open_file_t *file ;
  ngx_pool_cleanup_file_t *clnf ;
  ngx_open_file_cache_cleanup_t *ofcln ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 156
  of->fd = -1;
#line 157
  of->err = 0;
#line 159
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 161
    if (of->test_only) {
      {
#line 163
      tmp = ngx_file_info_wrapper(name, of, & fi, pool->log);
      }
#line 163
      if (tmp == -1L) {
#line 166
        return ((ngx_int_t )-1);
      }
#line 169
      of->uniq = fi.st_ino;
#line 170
      of->mtime = fi.st_mtim.tv_sec;
#line 171
      of->size = fi.st_size;
#line 172
      if (fi.st_size < fi.st_blocks * 512L) {
#line 172
        of->fs_size = fi.st_blocks * 512L;
      } else {
#line 172
        of->fs_size = fi.st_size;
      }
#line 173
      of->is_dir = (unsigned int )((fi.st_mode & 61440U) == 16384U);
#line 174
      of->is_file = (unsigned int )((fi.st_mode & 61440U) == 32768U);
#line 175
      of->is_link = (unsigned int )((fi.st_mode & 61440U) == 40960U);
#line 176
      of->is_exec = (unsigned int )((fi.st_mode & 64U) == 64U);
#line 178
      return ((ngx_int_t )0);
    }
    {
#line 181
    cln = ngx_pool_cleanup_add(pool, sizeof(ngx_pool_cleanup_file_t ));
    }
#line 182
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 183
      return ((ngx_int_t )-1);
    }
    {
#line 186
    rc = ngx_open_and_stat_file(name, of, pool->log);
    }
#line 188
    if (rc == 0L) {
#line 188
      if (! of->is_dir) {
#line 189
        cln->handler = & ngx_pool_cleanup_file;
#line 190
        clnf = (ngx_pool_cleanup_file_t *)cln->data;
#line 192
        clnf->fd = of->fd;
#line 193
        clnf->name = name->data;
#line 194
        clnf->log = pool->log;
      }
    }
#line 197
    return (rc);
  }
  {
#line 200
  cln = ngx_pool_cleanup_add(pool, sizeof(ngx_open_file_cache_cleanup_t ));
  }
#line 201
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 202
    return ((ngx_int_t )-1);
  }
  {
#line 205
  now = (time_t )ngx_cached_time->sec;
#line 207
  hash = ngx_crc32_long(name->data, name->len);
#line 209
  file = ngx_open_file_lookup(cache, name, hash);
  }
#line 211
  if (file) {
#line 213
    (file->uses) ++;
#line 215
    (file->queue.next)->prev = file->queue.prev;
#line 215
    (file->queue.prev)->next = file->queue.next;
#line 217
    if (file->fd == -1) {
#line 217
      if (file->err == 0) {
#line 217
        if (! file->is_dir) {
          {
#line 221
          rc = ngx_open_and_stat_file(name, of, pool->log);
          }
#line 223
          if (rc != 0L) {
#line 223
            if (of->err == 0) {
#line 224
              goto failed;
            } else
#line 223
            if (! of->errors) {
#line 224
              goto failed;
            }
          }
#line 227
          goto add_event;
        }
      }
    }
#line 230
    if (file->use_event) {
#line 230
      goto _L;
    } else
#line 230
    if ((unsigned long )file->event == (unsigned long )((void *)0)) {
#line 230
      if (of->uniq == 0UL) {
#line 230
        goto _L___0;
      } else
#line 230
      if (of->uniq == file->uniq) {
        _L___0: /* CIL Label */ 
#line 230
        if (now - file->created < of->valid) {
#line 230
          if (of->disable_symlinks == file->disable_symlinks) {
#line 230
            if (of->disable_symlinks_from == file->disable_symlinks_from) {
              _L: /* CIL Label */ 
#line 240
              if (file->err == 0) {
#line 242
                of->fd = file->fd;
#line 243
                of->uniq = file->uniq;
#line 244
                of->mtime = file->mtime;
#line 245
                of->size = file->size;
#line 247
                of->is_dir = file->is_dir;
#line 248
                of->is_file = file->is_file;
#line 249
                of->is_link = file->is_link;
#line 250
                of->is_exec = file->is_exec;
#line 251
                of->is_directio = file->is_directio;
#line 253
                if (! file->is_dir) {
                  {
#line 254
                  (file->count) ++;
#line 255
                  ngx_open_file_add_event(cache, file, of, pool->log);
                  }
                }
              } else {
#line 259
                of->err = file->err;
#line 261
                if (file->disable_symlinks) {
#line 261
                  of->failed = (char *)"openat()";
                } else {
#line 261
                  of->failed = (char *)"open()";
                }
              }
#line 268
              goto found;
            }
          }
        }
      }
    }
#line 275
    if (file->is_dir) {
#line 283
      of->test_dir = 1U;
    }
    {
#line 286
    of->fd = file->fd;
#line 287
    of->uniq = file->uniq;
#line 289
    rc = ngx_open_and_stat_file(name, of, pool->log);
    }
#line 291
    if (rc != 0L) {
#line 291
      if (of->err == 0) {
#line 292
        goto failed;
      } else
#line 291
      if (! of->errors) {
#line 292
        goto failed;
      }
    }
#line 295
    if (of->is_dir) {
#line 297
      if (file->is_dir) {
#line 298
        goto update;
      } else
#line 297
      if (file->err) {
#line 298
        goto update;
      }
    } else
#line 303
    if (of->err == 0) {
#line 305
      if (file->is_dir) {
#line 306
        goto add_event;
      } else
#line 305
      if (file->err) {
#line 306
        goto add_event;
      }
#line 309
      if (of->uniq == file->uniq) {
#line 311
        if (file->event) {
#line 312
          file->use_event = 1U;
        }
#line 315
        of->is_directio = file->is_directio;
#line 317
        goto update;
      }
    } else
#line 324
    if (file->err) {
#line 325
      goto update;
    } else
#line 324
    if (file->is_dir) {
#line 325
      goto update;
    }
#line 331
    if (file->count == 0U) {
      {
#line 333
      ngx_open_file_del_event(file);
#line 335
      tmp___1 = close(file->fd);
      }
#line 335
      if (tmp___1 == -1) {
#line 336
        if ((pool->log)->log_level >= 2UL) {
          {
#line 336
          tmp___0 = __errno_location();
#line 336
          ngx_log_error_core((ngx_uint_t )2, pool->log, *tmp___0, "close() \"%V\" failed",
                             name);
          }
        }
      }
#line 340
      goto add_event;
    }
    {
#line 343
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 345
    (cache->current) --;
#line 347
    file->close = 1U;
    }
#line 349
    goto create;
  }
  {
#line 354
  rc = ngx_open_and_stat_file(name, of, pool->log);
  }
#line 356
  if (rc != 0L) {
#line 356
    if (of->err == 0) {
#line 357
      goto failed;
    } else
#line 356
    if (! of->errors) {
#line 357
      goto failed;
    }
  }
  create: 
#line 362
  if (cache->current >= cache->max) {
    {
#line 363
    ngx_expire_old_cached_files(cache, (ngx_uint_t )0, pool->log);
    }
  }
  {
#line 366
  tmp___2 = ngx_alloc(sizeof(ngx_cached_open_file_t ), pool->log);
#line 366
  file = (ngx_cached_open_file_t *)tmp___2;
  }
#line 368
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 369
    goto failed;
  }
  {
#line 372
  tmp___3 = ngx_alloc(name->len + 1UL, pool->log);
#line 372
  file->name = (u_char *)tmp___3;
  }
#line 374
  if ((unsigned long )file->name == (unsigned long )((void *)0)) {
    {
#line 375
    free((void *)file);
#line 376
    file = (ngx_cached_open_file_t *)((void *)0);
    }
#line 377
    goto failed;
  }
  {
#line 380
  ngx_cpystrn(file->name, name->data, name->len + 1UL);
#line 382
  file->node.key = (ngx_rbtree_key_t )hash;
#line 384
  ngx_rbtree_insert(& cache->rbtree, & file->node);
#line 386
  (cache->current) ++;
#line 388
  file->uses = (uint32_t )1;
#line 389
  file->count = 0U;
#line 390
  file->use_event = 0U;
#line 391
  file->event = (ngx_event_t *)((void *)0);
  }
  add_event: 
  {
#line 395
  ngx_open_file_add_event(cache, file, of, pool->log);
  }
  update: 
#line 399
  file->fd = of->fd;
#line 400
  file->err = of->err;
#line 402
  file->disable_symlinks = of->disable_symlinks;
#line 403
  file->disable_symlinks_from = of->disable_symlinks_from;
#line 406
  if (of->err == 0) {
#line 407
    file->uniq = of->uniq;
#line 408
    file->mtime = of->mtime;
#line 409
    file->size = of->size;
#line 411
    file->close = 0U;
#line 413
    file->is_dir = of->is_dir;
#line 414
    file->is_file = of->is_file;
#line 415
    file->is_link = of->is_link;
#line 416
    file->is_exec = of->is_exec;
#line 417
    file->is_directio = of->is_directio;
#line 419
    if (! of->is_dir) {
#line 420
      (file->count) ++;
    }
  }
#line 424
  file->created = now;
  found: 
#line 428
  file->accessed = now;
#line 430
  file->queue.next = cache->expire_queue.next;
#line 430
  (file->queue.next)->prev = & file->queue;
#line 430
  file->queue.prev = & cache->expire_queue;
#line 430
  cache->expire_queue.next = & file->queue;
#line 436
  if (of->err == 0) {
#line 438
    if (! of->is_dir) {
#line 439
      cln->handler = & ngx_open_file_cleanup;
#line 440
      ofcln = (ngx_open_file_cache_cleanup_t *)cln->data;
#line 442
      ofcln->cache = cache;
#line 443
      ofcln->file = file;
#line 444
      ofcln->min_uses = of->min_uses;
#line 445
      ofcln->log = pool->log;
    }
#line 448
    return ((ngx_int_t )0);
  }
#line 451
  return ((ngx_int_t )-1);
  failed: 
#line 455
  if (file) {
    {
#line 456
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 458
    (cache->current) --;
    }
#line 460
    if (file->count == 0U) {
#line 462
      if (file->fd != -1) {
        {
#line 463
        tmp___5 = close(file->fd);
        }
#line 463
        if (tmp___5 == -1) {
#line 464
          if ((pool->log)->log_level >= 2UL) {
            {
#line 464
            tmp___4 = __errno_location();
#line 464
            ngx_log_error_core((ngx_uint_t )2, pool->log, *tmp___4, "close() \"%s\" failed",
                               file->name);
            }
          }
        }
      }
      {
#line 470
      free((void *)file->name);
#line 471
      free((void *)file);
      }
    } else {
#line 474
      file->close = 1U;
    }
  }
#line 478
  if (of->fd != -1) {
    {
#line 479
    tmp___7 = close(of->fd);
    }
#line 479
    if (tmp___7 == -1) {
#line 480
      if ((pool->log)->log_level >= 2UL) {
        {
#line 480
        tmp___6 = __errno_location();
#line 480
        ngx_log_error_core((ngx_uint_t )2, pool->log, *tmp___6, "close() \"%V\" failed",
                           name);
        }
      }
    }
  }
#line 485
  return ((ngx_int_t )-1);
}
}
#line 491 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static ngx_fd_t ngx_openat_file_owner(ngx_fd_t at_fd , u_char const   *name , ngx_int_t mode ,
                                      ngx_int_t create , ngx_int_t access___0 , ngx_log_t *log ) 
{ 
  ngx_fd_t fd ;
  ngx_err_t err ;
  ngx_file_info_t fi ;
  ngx_file_info_t atfi ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  ngx_int_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 511
  fd = openat(at_fd, (char const   *)name, (int )(mode | create), access___0);
  }
#line 513
  if (fd == -1) {
#line 514
    return (-1);
  }
  {
#line 517
  tmp___0 = fstatat(at_fd, (char const   */* __restrict  */)((char const   *)name),
                    (struct stat */* __restrict  */)(& atfi), 256);
  }
#line 517
  if (tmp___0 == -1) {
    {
#line 520
    tmp = __errno_location();
#line 520
    err = *tmp;
    }
#line 521
    goto failed;
  }
  {
#line 525
  tmp___2 = ngx_file_o_path_info(fd, & fi, log);
  }
#line 525
  if (tmp___2 == -1L) {
    {
#line 526
    tmp___1 = __errno_location();
#line 526
    err = *tmp___1;
    }
#line 527
    goto failed;
  }
#line 536
  if (fi.st_uid != atfi.st_uid) {
#line 537
    err = 40;
#line 538
    goto failed;
  }
#line 541
  return (fd);
  failed: 
  {
#line 545
  tmp___4 = close(fd);
  }
#line 545
  if (tmp___4 == -1) {
#line 546
    if (log->log_level >= 2UL) {
      {
#line 546
      tmp___3 = __errno_location();
#line 546
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___3, "close() \"%s\" failed", name);
      }
    }
  }
  {
#line 550
  tmp___5 = __errno_location();
#line 550
  *tmp___5 = err;
  }
#line 552
  return (-1);
}
}
#line 561 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static ngx_uint_t use_fstat  =    (ngx_uint_t )1;
#line 558 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static ngx_int_t ngx_file_o_path_info(ngx_fd_t fd , ngx_file_info_t *fi , ngx_log_t *log ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 585
  if (use_fstat) {
    {
#line 586
    tmp = fstat(fd, fi);
    }
#line 586
    if (tmp != -1) {
#line 587
      return ((ngx_int_t )0);
    }
    {
#line 590
    tmp___0 = __errno_location();
    }
#line 590
    if (*tmp___0 != 9) {
#line 591
      return ((ngx_int_t )-1);
    }
#line 594
    if (log->log_level >= 6UL) {
      {
#line 594
      ngx_log_error_core((ngx_uint_t )6, log, 0, "fstat(O_PATH) failed with EBADF, switching to fstatat(AT_EMPTY_PATH)");
      }
    }
#line 598
    use_fstat = (ngx_uint_t )0;
  }
  {
#line 601
  tmp___1 = fstatat(fd, (char const   */* __restrict  */)"", (struct stat */* __restrict  */)fi,
                    4096);
  }
#line 601
  if (tmp___1 != -1) {
#line 602
    return ((ngx_int_t )0);
  }
#line 605
  return ((ngx_int_t )-1);
}
}
#line 613 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static ngx_fd_t ngx_open_file_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                      ngx_int_t mode , ngx_int_t create , ngx_int_t access___0 ,
                                      ngx_log_t *log ) 
{ 
  ngx_fd_t fd ;
  u_char *p ;
  u_char *cp ;
  u_char *end ;
  ngx_fd_t at_fd ;
  ngx_str_t at_name ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 637
  if (of->disable_symlinks == 0U) {
    {
#line 638
    fd = open((char const   *)name->data, (int )(mode | create), access___0);
    }
#line 640
    if (fd == -1) {
      {
#line 641
      tmp = __errno_location();
#line 641
      of->err = *tmp;
#line 642
      of->failed = (char *)"open()";
      }
#line 643
      return (-1);
    }
#line 646
    return (fd);
  }
#line 649
  p = name->data;
#line 650
  end = p + name->len;
#line 652
  at_name = *name;
#line 654
  if (of->disable_symlinks_from) {
    {
#line 656
    cp = p + of->disable_symlinks_from;
#line 658
    *cp = (u_char )'\000';
#line 660
    at_fd = open((char const   *)p, 2164736, 0);
#line 663
    *cp = (u_char )'/';
    }
#line 665
    if (at_fd == -1) {
      {
#line 666
      tmp___0 = __errno_location();
#line 666
      of->err = *tmp___0;
#line 667
      of->failed = (char *)"open()";
      }
#line 668
      return (-1);
    }
#line 671
    at_name.len = of->disable_symlinks_from;
#line 672
    p = cp + 1;
  } else
#line 674
  if ((int )*p == 47) {
    {
#line 676
    at_fd = open("/", 2164736, 0);
    }
#line 680
    if (at_fd == -1) {
      {
#line 681
      tmp___1 = __errno_location();
#line 681
      of->err = *tmp___1;
#line 682
      of->failed = (char *)"openat()";
      }
#line 683
      return (-1);
    }
#line 686
    at_name.len = (size_t___0 )1;
#line 687
    p ++;
  } else {
#line 690
    at_fd = -100;
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 694
    cp = ngx_strlchr(p, end, (u_char )'/');
    }
#line 695
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 696
      goto while_break;
    }
#line 699
    if ((unsigned long )cp == (unsigned long )p) {
#line 700
      p ++;
#line 701
      goto __Cont;
    }
#line 704
    *cp = (u_char )'\000';
#line 706
    if (of->disable_symlinks == 2U) {
      {
#line 707
      fd = ngx_openat_file_owner(at_fd, (u_char const   *)p, (ngx_int_t )2164736,
                                 (ngx_int_t )0, (ngx_int_t )0, log);
      }
    } else {
      {
#line 712
      fd = openat(at_fd, (char const   *)p, 2295808, 0);
      }
    }
#line 717
    *cp = (u_char )'/';
#line 719
    if (fd == -1) {
      {
#line 720
      tmp___2 = __errno_location();
#line 720
      of->err = *tmp___2;
#line 721
      of->failed = (char *)"openat()";
      }
#line 722
      goto failed;
    }
#line 725
    if (at_fd != -100) {
      {
#line 725
      tmp___4 = close(at_fd);
      }
#line 725
      if (tmp___4 == -1) {
#line 726
        if (log->log_level >= 2UL) {
          {
#line 726
          tmp___3 = __errno_location();
#line 726
          ngx_log_error_core((ngx_uint_t )2, log, *tmp___3, "close() \"%V\" failed",
                             & at_name);
          }
        }
      }
    }
#line 730
    p = cp + 1;
#line 731
    at_fd = fd;
#line 732
    at_name.len = (size_t___0 )(cp - at_name.data);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  if ((unsigned long )p == (unsigned long )end) {
    {
#line 748
    fd = openat(at_fd, ".", (int )(mode | create), access___0);
    }
#line 749
    goto done;
  }
#line 752
  if (of->disable_symlinks == 2U) {
#line 752
    if (! (create & 576L)) {
      {
#line 755
      fd = ngx_openat_file_owner(at_fd, (u_char const   *)p, mode, create, access___0,
                                 log);
      }
    } else {
      {
#line 758
      fd = openat(at_fd, (char const   *)p, (int )((mode | 131072L) | create), access___0);
      }
    }
  } else {
    {
#line 758
    fd = openat(at_fd, (char const   *)p, (int )((mode | 131072L) | create), access___0);
    }
  }
  done: 
#line 763
  if (fd == -1) {
    {
#line 764
    tmp___5 = __errno_location();
#line 764
    of->err = *tmp___5;
#line 765
    of->failed = (char *)"openat()";
    }
  }
  failed: 
#line 770
  if (at_fd != -100) {
    {
#line 770
    tmp___7 = close(at_fd);
    }
#line 770
    if (tmp___7 == -1) {
#line 771
      if (log->log_level >= 2UL) {
        {
#line 771
        tmp___6 = __errno_location();
#line 771
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___6, "close() \"%V\" failed",
                           & at_name);
        }
      }
    }
  }
#line 775
  return (fd);
}
}
#line 780 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static ngx_int_t ngx_file_info_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                       ngx_file_info_t *fi , ngx_log_t *log ) 
{ 
  ngx_int_t rc ;
  ngx_fd_t fd ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 802
  if (of->disable_symlinks == 0U) {
    {
#line 804
    tmp = stat((char const   */* __restrict  */)((char const   *)name->data), (struct stat */* __restrict  */)fi);
#line 804
    rc = (ngx_int_t )tmp;
    }
#line 806
    if (rc == -1L) {
      {
#line 807
      tmp___0 = __errno_location();
#line 807
      of->err = *tmp___0;
#line 808
      of->failed = (char *)"stat()";
      }
#line 809
      return ((ngx_int_t )-1);
    }
#line 812
    return (rc);
  }
  {
#line 815
  fd = ngx_open_file_wrapper(name, of, (ngx_int_t )2048, (ngx_int_t )0, (ngx_int_t )0,
                             log);
  }
#line 818
  if (fd == -1) {
#line 819
    return ((ngx_int_t )-1);
  }
  {
#line 822
  tmp___1 = fstat(fd, fi);
#line 822
  rc = (ngx_int_t )tmp___1;
  }
#line 824
  if (rc == -1L) {
    {
#line 825
    tmp___2 = __errno_location();
#line 825
    of->err = *tmp___2;
#line 826
    of->failed = (char *)"fstat()";
    }
  }
  {
#line 829
  tmp___4 = close(fd);
  }
#line 829
  if (tmp___4 == -1) {
#line 830
    if (log->log_level >= 2UL) {
      {
#line 830
      tmp___3 = __errno_location();
#line 830
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___3, "close() \"%V\" failed", name);
      }
    }
  }
#line 834
  return (rc);
}
}
#line 839 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static ngx_int_t ngx_open_and_stat_file(ngx_str_t *name , ngx_open_file_info_t *of ,
                                        ngx_log_t *log ) 
{ 
  ngx_fd_t fd ;
  ngx_file_info_t fi ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  ngx_int_t tmp___8 ;
  int *tmp___9 ;
  ngx_int_t tmp___10 ;

  {
#line 846
  if (of->fd != -1) {
    {
#line 848
    tmp = ngx_file_info_wrapper(name, of, & fi, log);
    }
#line 848
    if (tmp == -1L) {
#line 849
      of->fd = -1;
#line 850
      return ((ngx_int_t )-1);
    }
#line 853
    if (of->uniq == fi.st_ino) {
#line 854
      goto done;
    }
  } else
#line 857
  if (of->test_dir) {
    {
#line 859
    tmp___0 = ngx_file_info_wrapper(name, of, & fi, log);
    }
#line 859
    if (tmp___0 == -1L) {
#line 860
      of->fd = -1;
#line 861
      return ((ngx_int_t )-1);
    }
#line 864
    if ((fi.st_mode & 61440U) == 16384U) {
#line 865
      goto done;
    }
  }
#line 869
  if (! of->log) {
    {
#line 876
    fd = ngx_open_file_wrapper(name, of, (ngx_int_t )2048, (ngx_int_t )0, (ngx_int_t )0,
                               log);
    }
  } else {
    {
#line 880
    fd = ngx_open_file_wrapper(name, of, (ngx_int_t )1025, (ngx_int_t )64, (ngx_int_t )420,
                               log);
    }
  }
#line 885
  if (fd == -1) {
#line 886
    of->fd = -1;
#line 887
    return ((ngx_int_t )-1);
  }
  {
#line 890
  tmp___4 = fstat(fd, & fi);
  }
#line 890
  if (tmp___4 == -1) {
#line 891
    if (log->log_level >= 3UL) {
      {
#line 891
      tmp___1 = __errno_location();
#line 891
      ngx_log_error_core((ngx_uint_t )3, log, *tmp___1, "fstat() \"%V\" failed", name);
      }
    }
    {
#line 894
    tmp___3 = close(fd);
    }
#line 894
    if (tmp___3 == -1) {
#line 895
      if (log->log_level >= 2UL) {
        {
#line 895
        tmp___2 = __errno_location();
#line 895
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___2, "close() \"%V\" failed",
                           name);
        }
      }
    }
#line 899
    of->fd = -1;
#line 901
    return ((ngx_int_t )-1);
  }
#line 904
  if ((fi.st_mode & 61440U) == 16384U) {
    {
#line 905
    tmp___6 = close(fd);
    }
#line 905
    if (tmp___6 == -1) {
#line 906
      if (log->log_level >= 2UL) {
        {
#line 906
        tmp___5 = __errno_location();
#line 906
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___5, "close() \"%V\" failed",
                           name);
        }
      }
    }
#line 910
    of->fd = -1;
  } else {
#line 913
    of->fd = fd;
#line 915
    if (of->read_ahead) {
#line 915
      if (fi.st_size > 131072L) {
        {
#line 916
        tmp___8 = ngx_read_ahead(fd, of->read_ahead);
        }
#line 916
        if (tmp___8 == -1L) {
#line 917
          if (log->log_level >= 2UL) {
            {
#line 917
            tmp___7 = __errno_location();
#line 917
            ngx_log_error_core((ngx_uint_t )2, log, *tmp___7, "posix_fadvise(POSIX_FADV_SEQUENTIAL) \"%V\" failed",
                               name);
            }
          }
        }
      }
    }
#line 922
    if (of->directio <= fi.st_size) {
      {
#line 923
      tmp___10 = ngx_directio_on(fd);
      }
#line 923
      if (tmp___10 == -1L) {
#line 924
        if (log->log_level >= 2UL) {
          {
#line 924
          tmp___9 = __errno_location();
#line 924
          ngx_log_error_core((ngx_uint_t )2, log, *tmp___9, "fcntl(O_DIRECT) \"%V\" failed",
                             name);
          }
        }
      } else {
#line 928
        of->is_directio = 1U;
      }
    }
  }
  done: 
#line 935
  of->uniq = fi.st_ino;
#line 936
  of->mtime = fi.st_mtim.tv_sec;
#line 937
  of->size = fi.st_size;
#line 938
  if (fi.st_size < fi.st_blocks * 512L) {
#line 938
    of->fs_size = fi.st_blocks * 512L;
  } else {
#line 938
    of->fs_size = fi.st_size;
  }
#line 939
  of->is_dir = (unsigned int )((fi.st_mode & 61440U) == 16384U);
#line 940
  of->is_file = (unsigned int )((fi.st_mode & 61440U) == 32768U);
#line 941
  of->is_link = (unsigned int )((fi.st_mode & 61440U) == 40960U);
#line 942
  of->is_exec = (unsigned int )((fi.st_mode & 64U) == 64U);
#line 944
  return ((ngx_int_t )0);
}
}
#line 953 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_open_file_add_event(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                    ngx_open_file_info_t *of , ngx_log_t *log ) 
{ 
  ngx_open_file_cache_event_t *fev ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 959
  if (! (ngx_event_flags & 8192UL)) {
#line 965
    return;
  } else
#line 959
  if (! of->events) {
#line 965
    return;
  } else
#line 959
  if (file->event) {
#line 965
    return;
  } else
#line 959
  if (of->fd == -1) {
#line 965
    return;
  } else
#line 959
  if ((ngx_uint_t )file->uses < of->min_uses) {
#line 965
    return;
  }
  {
#line 968
  file->use_event = 0U;
#line 970
  tmp = ngx_calloc(sizeof(ngx_event_t ), log);
#line 970
  file->event = (ngx_event_t *)tmp;
  }
#line 971
  if ((unsigned long )file->event == (unsigned long )((void *)0)) {
#line 972
    return;
  }
  {
#line 975
  tmp___0 = ngx_alloc(sizeof(ngx_open_file_cache_event_t ), log);
#line 975
  fev = (ngx_open_file_cache_event_t *)tmp___0;
  }
#line 976
  if ((unsigned long )fev == (unsigned long )((void *)0)) {
    {
#line 977
    free((void *)file->event);
#line 978
    file->event = (ngx_event_t *)((void *)0);
    }
#line 979
    return;
  }
  {
#line 982
  fev->fd = of->fd;
#line 983
  fev->file = file;
#line 984
  fev->cache = cache;
#line 986
  (file->event)->handler = & ngx_open_file_cache_remove;
#line 987
  (file->event)->data = (void *)fev;
#line 995
  (file->event)->log = (ngx_log_t *)ngx_cycle->log;
#line 997
  tmp___1 = (*(ngx_event_actions.add))(file->event, (ngx_int_t )0, (ngx_uint_t )1879048192);
  }
#line 997
  if (tmp___1 != 0L) {
    {
#line 1000
    free((file->event)->data);
#line 1001
    free((void *)file->event);
#line 1002
    file->event = (ngx_event_t *)((void *)0);
    }
#line 1003
    return;
  }
#line 1013
  return;
}
}
#line 1017 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cleanup(void *data ) 
{ 
  ngx_open_file_cache_cleanup_t *c ;

  {
  {
#line 1020
  c = (ngx_open_file_cache_cleanup_t *)data;
#line 1022
  ((c->file)->count) --;
#line 1024
  ngx_close_cached_file(c->cache, c->file, c->min_uses, c->log);
#line 1027
  ngx_expire_old_cached_files(c->cache, (ngx_uint_t )1, c->log);
  }
#line 1028
  return;
}
}
#line 1031 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_close_cached_file(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                  ngx_uint_t min_uses , ngx_log_t *log ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 1039
  if (! file->close) {
#line 1041
    file->accessed = (time_t )ngx_cached_time->sec;
#line 1043
    (file->queue.next)->prev = file->queue.prev;
#line 1043
    (file->queue.prev)->next = file->queue.next;
#line 1045
    file->queue.next = cache->expire_queue.next;
#line 1045
    (file->queue.next)->prev = & file->queue;
#line 1045
    file->queue.prev = & cache->expire_queue;
#line 1045
    cache->expire_queue.next = & file->queue;
#line 1047
    if ((ngx_uint_t )file->uses >= min_uses) {
#line 1048
      return;
    } else
#line 1047
    if (file->count) {
#line 1048
      return;
    }
  }
  {
#line 1052
  ngx_open_file_del_event(file);
  }
#line 1054
  if (file->count) {
#line 1055
    return;
  }
#line 1058
  if (file->fd != -1) {
    {
#line 1060
    tmp___0 = close(file->fd);
    }
#line 1060
    if (tmp___0 == -1) {
#line 1061
      if (log->log_level >= 2UL) {
        {
#line 1061
        tmp = __errno_location();
#line 1061
        ngx_log_error_core((ngx_uint_t )2, log, *tmp, "close() \"%s\" failed", file->name);
        }
      }
    }
#line 1065
    file->fd = -1;
  }
#line 1068
  if (! file->close) {
#line 1069
    return;
  }
  {
#line 1072
  free((void *)file->name);
#line 1073
  free((void *)file);
  }
#line 1074
  return;
}
}
#line 1077 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_open_file_del_event(ngx_cached_open_file_t *file ) 
{ 
  int tmp ;

  {
#line 1080
  if ((unsigned long )file->event == (unsigned long )((void *)0)) {
#line 1081
    return;
  }
#line 1084
  if (file->count) {
#line 1084
    tmp = 4;
  } else {
#line 1084
    tmp = 1;
  }
  {
#line 1084
  (*(ngx_event_actions.del))(file->event, (ngx_int_t )0, (ngx_uint_t )tmp);
#line 1087
  free((file->event)->data);
#line 1088
  free((void *)file->event);
#line 1089
  file->event = (ngx_event_t *)((void *)0);
#line 1090
  file->use_event = 0U;
  }
#line 1091
  return;
}
}
#line 1094 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_expire_old_cached_files(ngx_open_file_cache_t *cache , ngx_uint_t n ,
                                        ngx_log_t *log ) 
{ 
  time_t now ;
  ngx_queue_t *q ;
  ngx_cached_open_file_t *file ;
  ngx_uint_t tmp ;

  {
#line 1102
  now = (time_t )ngx_cached_time->sec;
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1110
    if (! (n < 3UL)) {
#line 1110
      goto while_break;
    }
#line 1112
    if ((unsigned long )(& cache->expire_queue) == (unsigned long )cache->expire_queue.prev) {
#line 1113
      return;
    }
#line 1116
    q = cache->expire_queue.prev;
#line 1118
    file = (ngx_cached_open_file_t *)((u_char *)q - (unsigned long )(& ((ngx_cached_open_file_t *)0)->queue));
#line 1120
    tmp = n;
#line 1120
    n ++;
#line 1120
    if (tmp != 0UL) {
#line 1120
      if (now - file->accessed <= cache->inactive) {
#line 1121
        return;
      }
    }
    {
#line 1124
    (q->next)->prev = q->prev;
#line 1124
    (q->prev)->next = q->next;
#line 1126
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 1128
    (cache->current) --;
    }
#line 1133
    if (! file->err) {
#line 1133
      if (! file->is_dir) {
        {
#line 1134
        file->close = 1U;
#line 1135
        ngx_close_cached_file(cache, file, (ngx_uint_t )0, log);
        }
      } else {
        {
#line 1138
        free((void *)file->name);
#line 1139
        free((void *)file);
        }
      }
    } else {
      {
#line 1138
      free((void *)file->name);
#line 1139
      free((void *)file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  return;
}
}
#line 1145 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_cached_open_file_t *file ;
  ngx_cached_open_file_t *file_temp ;
  int tmp___0 ;

  {
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1154
    if (node->key < temp->key) {
#line 1156
      p = & temp->left;
    } else
#line 1158
    if (node->key > temp->key) {
#line 1160
      p = & temp->right;
    } else {
      {
#line 1164
      file = (ngx_cached_open_file_t *)node;
#line 1165
      file_temp = (ngx_cached_open_file_t *)temp;
#line 1167
      tmp___0 = strcmp((char const   *)file->name, (char const   *)file_temp->name);
      }
#line 1167
      if (tmp___0 < 0) {
#line 1167
        p = & temp->left;
      } else {
#line 1167
        p = & temp->right;
      }
    }
#line 1171
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 1172
      goto while_break;
    }
#line 1175
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  *p = node;
#line 1179
  node->parent = temp;
#line 1180
  node->left = sentinel;
#line 1181
  node->right = sentinel;
#line 1182
  node->color = (u_char )1;
#line 1183
  return;
}
}
#line 1186 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static ngx_cached_open_file_t *ngx_open_file_lookup(ngx_open_file_cache_t *cache ,
                                                    ngx_str_t *name , uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_cached_open_file_t *file ;
  int tmp ;

  {
#line 1194
  node = cache->rbtree.root;
#line 1195
  sentinel = cache->rbtree.sentinel;
  {
#line 1197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1197
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 1197
      goto while_break;
    }
#line 1199
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 1200
      node = node->left;
#line 1201
      goto while_continue;
    }
#line 1204
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 1205
      node = node->right;
#line 1206
      goto while_continue;
    }
    {
#line 1211
    file = (ngx_cached_open_file_t *)node;
#line 1213
    tmp = strcmp((char const   *)name->data, (char const   *)file->name);
#line 1213
    rc = (ngx_int_t )tmp;
    }
#line 1215
    if (rc == 0L) {
#line 1216
      return (file);
    }
#line 1219
    if (rc < 0L) {
#line 1219
      node = node->left;
    } else {
#line 1219
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  return ((ngx_cached_open_file_t *)((void *)0));
}
}
#line 1226 "/tmp/nginx-1.13.2/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_remove(ngx_event_t *ev ) 
{ 
  ngx_cached_open_file_t *file ;
  ngx_open_file_cache_event_t *fev ;

  {
  {
#line 1232
  fev = (ngx_open_file_cache_event_t *)ev->data;
#line 1233
  file = fev->file;
#line 1235
  (file->queue.next)->prev = file->queue.prev;
#line 1235
  (file->queue.prev)->next = file->queue.next;
#line 1237
  ngx_rbtree_delete(& (fev->cache)->rbtree, & file->node);
#line 1239
  ((fev->cache)->current) --;
#line 1242
  file->event = (ngx_event_t *)((void *)0);
#line 1243
  file->use_event = 0U;
#line 1245
  file->close = 1U;
#line 1247
  ngx_close_cached_file(fev->cache, file, (ngx_uint_t )0, ev->log);
#line 1251
  free(ev->data);
#line 1252
  free((void *)ev);
  }
#line 1253
  return;
}
}
#line 53 "src/core/ngx_rbtree.h"
void ngx_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) ;
#line 234 "src/core/ngx_resolver.h"
ngx_int_t ngx_resolve_addr(ngx_resolver_ctx_t *ctx ) ;
#line 235
void ngx_resolve_addr_done(ngx_resolver_ctx_t *ctx ) ;
#line 59 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_udp_connect(ngx_resolver_connection_t *rec ) ;
#line 60
static ngx_int_t ngx_tcp_connect(ngx_resolver_connection_t *rec ) ;
#line 63
static void ngx_resolver_cleanup(void *data ) ;
#line 64
static void ngx_resolver_cleanup_tree(ngx_resolver_t *r , ngx_rbtree_t *tree ) ;
#line 65
static ngx_int_t ngx_resolve_name_locked(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ,
                                         ngx_str_t *name ) ;
#line 67
static void ngx_resolver_expire(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) ;
#line 69
static ngx_int_t ngx_resolver_send_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ) ;
#line 71
static ngx_int_t ngx_resolver_send_udp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) ;
#line 73
static ngx_int_t ngx_resolver_send_tcp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) ;
#line 75
static ngx_int_t ngx_resolver_create_name_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_str_t *name ) ;
#line 77
static ngx_int_t ngx_resolver_create_srv_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                               ngx_str_t *name ) ;
#line 79
static ngx_int_t ngx_resolver_create_addr_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_resolver_addr_t *addr ) ;
#line 81
static void ngx_resolver_resend_handler(ngx_event_t *ev ) ;
#line 82
static time_t ngx_resolver_resend(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) ;
#line 84
static ngx_uint_t ngx_resolver_resend_empty(ngx_resolver_t *r ) ;
#line 85
static void ngx_resolver_udp_read(ngx_event_t *rev ) ;
#line 86
static void ngx_resolver_tcp_write(ngx_event_t *wev ) ;
#line 87
static void ngx_resolver_tcp_read(ngx_event_t *rev ) ;
#line 88
static void ngx_resolver_process_response(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                          ngx_uint_t tcp ) ;
#line 90
static void ngx_resolver_process_a(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                   ngx_uint_t ident , ngx_uint_t code , ngx_uint_t qtype ,
                                   ngx_uint_t nan , ngx_uint_t trunc , ngx_uint_t ans ) ;
#line 93
static void ngx_resolver_process_srv(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ,
                                     ngx_uint_t trunc , ngx_uint_t ans ) ;
#line 96
static void ngx_resolver_process_ptr(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ) ;
#line 98
static ngx_resolver_node_t *ngx_resolver_lookup_name(ngx_resolver_t *r , ngx_str_t *name ,
                                                     uint32_t hash ) ;
#line 100
static ngx_resolver_node_t *ngx_resolver_lookup_srv(ngx_resolver_t *r , ngx_str_t *name ,
                                                    uint32_t hash ) ;
#line 102
static ngx_resolver_node_t *ngx_resolver_lookup_addr(ngx_resolver_t *r , in_addr_t addr ) ;
#line 104
static void ngx_resolver_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                             ngx_rbtree_node_t *sentinel ) ;
#line 106
static ngx_int_t ngx_resolver_copy(ngx_resolver_t *r , ngx_str_t *name , u_char *buf ,
                                   u_char *src , u_char *last ) ;
#line 108
static void ngx_resolver_timeout_handler(ngx_event_t *ev ) ;
#line 109
static void ngx_resolver_free_node(ngx_resolver_t *r , ngx_resolver_node_t *rn ) ;
#line 110
static void *ngx_resolver_alloc(ngx_resolver_t *r , size_t___0 size ) ;
#line 111
static void *ngx_resolver_calloc(ngx_resolver_t *r , size_t___0 size ) ;
#line 112
static void ngx_resolver_free(ngx_resolver_t *r , void *p ) ;
#line 113
static void ngx_resolver_free_locked(ngx_resolver_t *r , void *p ) ;
#line 114
static void *ngx_resolver_dup(ngx_resolver_t *r , void *src , size_t___0 size ) ;
#line 115
static ngx_resolver_addr_t *ngx_resolver_export(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_uint_t rotate ) ;
#line 117
static void ngx_resolver_report_srv(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ) ;
#line 118
static u_char *ngx_resolver_log_error(ngx_log_t *log , u_char *buf , size_t___0 len ) ;
#line 119
static void ngx_resolver_resolve_srv_names(ngx_resolver_ctx_t *ctx , ngx_resolver_node_t *rn ) ;
#line 121
static void ngx_resolver_srv_names_handler(ngx_resolver_ctx_t *cctx ) ;
#line 122
static ngx_int_t ngx_resolver_cmp_srvs(void const   *one , void const   *two ) ;
#line 125
static void ngx_resolver_rbtree_insert_addr6_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                   ngx_rbtree_node_t *sentinel ) ;
#line 127
static ngx_resolver_node_t *ngx_resolver_lookup_addr6(ngx_resolver_t *r , struct in6_addr *addr ,
                                                      uint32_t hash ) ;
#line 132 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
ngx_resolver_t *ngx_resolver_create(ngx_conf_t *cf , ngx_str_t *names , ngx_uint_t n ) 
{ 
  ngx_str_t s ;
  ngx_url_t u ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_resolver_t *r ;
  ngx_pool_cleanup_t *cln ;
  ngx_resolver_connection_t *rec ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ngx_int_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 142
  cln = ngx_pool_cleanup_add(cf->pool, (size_t___0 )0);
  }
#line 143
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 144
    return ((ngx_resolver_t *)((void *)0));
  }
  {
#line 147
  cln->handler = & ngx_resolver_cleanup;
#line 149
  tmp = ngx_calloc(sizeof(ngx_resolver_t ), cf->log);
#line 149
  r = (ngx_resolver_t *)tmp;
  }
#line 150
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 151
    return ((ngx_resolver_t *)((void *)0));
  }
  {
#line 154
  cln->data = (void *)r;
#line 156
  tmp___0 = ngx_calloc(sizeof(ngx_event_t ), cf->log);
#line 156
  r->event = (ngx_event_t *)tmp___0;
  }
#line 157
  if ((unsigned long )r->event == (unsigned long )((void *)0)) {
#line 158
    return ((ngx_resolver_t *)((void *)0));
  }
#line 161
  r->name_sentinel.color = (u_char )0;
#line 161
  r->name_rbtree.root = & r->name_sentinel;
#line 161
  r->name_rbtree.sentinel = & r->name_sentinel;
#line 161
  r->name_rbtree.insert = & ngx_resolver_rbtree_insert_value;
#line 164
  r->srv_sentinel.color = (u_char )0;
#line 164
  r->srv_rbtree.root = & r->srv_sentinel;
#line 164
  r->srv_rbtree.sentinel = & r->srv_sentinel;
#line 164
  r->srv_rbtree.insert = & ngx_resolver_rbtree_insert_value;
#line 167
  r->addr_sentinel.color = (u_char )0;
#line 167
  r->addr_rbtree.root = & r->addr_sentinel;
#line 167
  r->addr_rbtree.sentinel = & r->addr_sentinel;
#line 167
  r->addr_rbtree.insert = & ngx_rbtree_insert_value;
#line 170
  r->name_resend_queue.prev = & r->name_resend_queue;
#line 170
  r->name_resend_queue.next = & r->name_resend_queue;
#line 171
  r->srv_resend_queue.prev = & r->srv_resend_queue;
#line 171
  r->srv_resend_queue.next = & r->srv_resend_queue;
#line 172
  r->addr_resend_queue.prev = & r->addr_resend_queue;
#line 172
  r->addr_resend_queue.next = & r->addr_resend_queue;
#line 174
  r->name_expire_queue.prev = & r->name_expire_queue;
#line 174
  r->name_expire_queue.next = & r->name_expire_queue;
#line 175
  r->srv_expire_queue.prev = & r->srv_expire_queue;
#line 175
  r->srv_expire_queue.next = & r->srv_expire_queue;
#line 176
  r->addr_expire_queue.prev = & r->addr_expire_queue;
#line 176
  r->addr_expire_queue.next = & r->addr_expire_queue;
#line 179
  r->ipv6 = (ngx_uint_t )1;
#line 181
  r->addr6_sentinel.color = (u_char )0;
#line 181
  r->addr6_rbtree.root = & r->addr6_sentinel;
#line 181
  r->addr6_rbtree.sentinel = & r->addr6_sentinel;
#line 181
  r->addr6_rbtree.insert = & ngx_resolver_rbtree_insert_addr6_value;
#line 184
  r->addr6_resend_queue.prev = & r->addr6_resend_queue;
#line 184
  r->addr6_resend_queue.next = & r->addr6_resend_queue;
#line 186
  r->addr6_expire_queue.prev = & r->addr6_expire_queue;
#line 186
  r->addr6_expire_queue.next = & r->addr6_expire_queue;
#line 189
  (r->event)->handler = & ngx_resolver_resend_handler;
#line 190
  (r->event)->data = (void *)r;
#line 191
  (r->event)->log = & (cf->cycle)->new_log;
#line 192
  r->ident = (ngx_int_t )-1;
#line 194
  r->resend_timeout = (time_t )5;
#line 195
  r->tcp_timeout = (time_t )5;
#line 196
  r->expire = (time_t )30;
#line 197
  r->valid = (time_t )0;
#line 199
  r->log = & (cf->cycle)->new_log;
#line 200
  r->log_level = (ngx_uint_t )4;
#line 202
  if (n) {
    {
#line 203
    tmp___1 = ngx_array_init(& r->connections, cf->pool, n, sizeof(ngx_resolver_connection_t ));
    }
#line 203
    if (tmp___1 != 0L) {
#line 207
      return ((ngx_resolver_t *)((void *)0));
    }
  }
#line 211
  i = (ngx_uint_t )0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < n)) {
#line 211
      goto while_break;
    }
    {
#line 212
    tmp___2 = strncmp((char const   *)(names + i)->data, "valid=", (size_t )6);
    }
#line 212
    if (tmp___2 == 0) {
      {
#line 213
      s.len = (names + i)->len - 6UL;
#line 214
      s.data = (names + i)->data + 6;
#line 216
      r->valid = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 218
      if (r->valid == -1L) {
        {
#line 219
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter: %V", names + i);
        }
#line 221
        return ((ngx_resolver_t *)((void *)0));
      }
#line 224
      goto __Cont;
    }
    {
#line 228
    tmp___5 = strncmp((char const   *)(names + i)->data, "ipv6=", (size_t )5);
    }
#line 228
    if (tmp___5 == 0) {
      {
#line 230
      tmp___4 = strcmp((char const   *)((names + i)->data + 5), "on");
      }
#line 230
      if (tmp___4 == 0) {
#line 231
        r->ipv6 = (ngx_uint_t )1;
      } else {
        {
#line 233
        tmp___3 = strcmp((char const   *)((names + i)->data + 5), "off");
        }
#line 233
        if (tmp___3 == 0) {
#line 234
          r->ipv6 = (ngx_uint_t )0;
        } else {
          {
#line 237
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter: %V", names + i);
          }
#line 239
          return ((ngx_resolver_t *)((void *)0));
        }
      }
#line 242
      goto __Cont;
    }
    {
#line 246
    memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 248
    u.url = *(names + i);
#line 249
    u.default_port = (in_port_t )53;
#line 251
    tmp___6 = ngx_parse_url(cf->pool, & u);
    }
#line 251
    if (tmp___6 != 0L) {
#line 252
      if (u.err) {
        {
#line 253
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in resolver \"%V\"", u.err,
                           & u.url);
        }
      }
#line 258
      return ((ngx_resolver_t *)((void *)0));
    }
    {
#line 261
    tmp___7 = ngx_array_push_n(& r->connections, u.naddrs);
#line 261
    rec = (ngx_resolver_connection_t *)tmp___7;
    }
#line 262
    if ((unsigned long )rec == (unsigned long )((void *)0)) {
#line 263
      return ((ngx_resolver_t *)((void *)0));
    }
    {
#line 266
    memset((void *)rec, 0, u.naddrs * sizeof(ngx_resolver_connection_t ));
#line 268
    j = (ngx_uint_t )0;
    }
    {
#line 268
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 268
      if (! (j < u.naddrs)) {
#line 268
        goto while_break___0;
      }
#line 269
      (rec + j)->sockaddr = (u.addrs + j)->sockaddr;
#line 270
      (rec + j)->socklen = (u.addrs + j)->socklen;
#line 271
      (rec + j)->server = (u.addrs + j)->name;
#line 272
      (rec + j)->resolver = r;
#line 268
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return (r);
}
}
#line 280 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_cleanup(void *data ) 
{ 
  ngx_resolver_t *r ;
  ngx_uint_t i ;
  ngx_resolver_connection_t *rec ;

  {
#line 283
  r = (ngx_resolver_t *)data;
#line 288
  if (r) {
    {
#line 292
    ngx_resolver_cleanup_tree(r, & r->name_rbtree);
#line 294
    ngx_resolver_cleanup_tree(r, & r->srv_rbtree);
#line 296
    ngx_resolver_cleanup_tree(r, & r->addr_rbtree);
#line 299
    ngx_resolver_cleanup_tree(r, & r->addr6_rbtree);
    }
#line 302
    if (r->event) {
#line 303
      if ((r->event)->timer_set) {
        {
#line 304
        ngx_event_del_timer(r->event);
        }
      }
      {
#line 307
      free((void *)r->event);
      }
    }
#line 311
    rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 313
    i = (ngx_uint_t )0;
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      if (! (i < r->connections.nelts)) {
#line 313
        goto while_break;
      }
#line 314
      if ((rec + i)->udp) {
        {
#line 315
        ngx_close_connection((rec + i)->udp);
        }
      }
#line 318
      if ((rec + i)->tcp) {
        {
#line 319
        ngx_close_connection((rec + i)->tcp);
        }
      }
#line 322
      if ((rec + i)->read_buf) {
        {
#line 323
        ngx_resolver_free(r, (void *)((rec + i)->read_buf)->start);
#line 324
        ngx_resolver_free(r, (void *)(rec + i)->read_buf);
        }
      }
#line 327
      if ((rec + i)->write_buf) {
        {
#line 328
        ngx_resolver_free(r, (void *)((rec + i)->write_buf)->start);
#line 329
        ngx_resolver_free(r, (void *)(rec + i)->write_buf);
        }
      }
#line 313
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 333
    free((void *)r);
    }
  }
#line 335
  return;
}
}
#line 338 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_cleanup_tree(ngx_resolver_t *r , ngx_rbtree_t *tree ) 
{ 
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_node_t *rn ;
  ngx_rbtree_node_t *tmp ;

  {
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )tree->root != (unsigned long )tree->sentinel)) {
#line 344
      goto while_break;
    }
    {
#line 346
    tmp = ngx_rbtree_min(tree->root, tree->sentinel);
#line 346
    rn = (ngx_resolver_node_t *)((u_char *)tmp - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 348
    (rn->queue.next)->prev = rn->queue.prev;
#line 348
    (rn->queue.prev)->next = rn->queue.next;
#line 350
    ctx = rn->waiting;
    }
    {
#line 350
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 350
      if (! ctx) {
#line 350
        goto while_break___0;
      }
#line 351
      next = ctx->next;
#line 353
      if (ctx->event) {
#line 354
        if ((ctx->event)->timer_set) {
          {
#line 355
          ngx_event_del_timer(ctx->event);
          }
        }
        {
#line 358
        ngx_resolver_free(r, (void *)ctx->event);
        }
      }
      {
#line 361
      ngx_resolver_free(r, (void *)ctx);
#line 350
      ctx = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 364
    ngx_rbtree_delete(tree, & rn->node);
#line 366
    ngx_resolver_free_node(r, rn);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 371 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
ngx_resolver_ctx_t *ngx_resolve_start(ngx_resolver_t *r , ngx_resolver_ctx_t *temp ) 
{ 
  in_addr_t addr ;
  ngx_resolver_ctx_t *ctx ;
  void *tmp ;

  {
#line 377
  if (temp) {
    {
#line 378
    addr = ngx_inet_addr(temp->name.data, temp->name.len);
    }
#line 380
    if (addr != 4294967295U) {
      {
#line 381
      temp->resolver = r;
#line 382
      temp->state = (ngx_int_t )0;
#line 383
      temp->naddrs = (ngx_uint_t )1;
#line 384
      temp->addrs = & temp->addr;
#line 385
      temp->addr.sockaddr = (struct sockaddr *)(& temp->sin);
#line 386
      temp->addr.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 387
      memset((void *)(& temp->sin), 0, sizeof(struct sockaddr_in ));
#line 388
      temp->sin.sin_family = (sa_family_t )2;
#line 389
      temp->sin.sin_addr.s_addr = addr;
#line 390
      temp->quick = 1U;
      }
#line 392
      return (temp);
    }
  }
#line 396
  if (r->connections.nelts == 0UL) {
#line 397
    return ((ngx_resolver_ctx_t *)((void *)-1));
  }
  {
#line 400
  tmp = ngx_resolver_calloc(r, sizeof(ngx_resolver_ctx_t ));
#line 400
  ctx = (ngx_resolver_ctx_t *)tmp;
  }
#line 402
  if (ctx) {
#line 403
    ctx->resolver = r;
  }
#line 406
  return (ctx);
}
}
#line 410 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
ngx_int_t ngx_resolve_name(ngx_resolver_ctx_t *ctx ) 
{ 
  size_t___0 slen ;
  ngx_int_t rc ;
  ngx_str_t name ;
  ngx_resolver_t *r ;
  u_char *tmp ;
  void *tmp___0 ;

  {
#line 418
  r = ctx->resolver;
#line 420
  if (ctx->name.len > 0UL) {
#line 420
    if ((int )*(ctx->name.data + (ctx->name.len - 1UL)) == 46) {
#line 421
      (ctx->name.len) --;
    }
  }
#line 427
  if (ctx->quick) {
    {
#line 428
    (*(ctx->handler))(ctx);
    }
#line 429
    return ((ngx_int_t )0);
  }
#line 432
  if (ctx->service.len) {
    {
#line 433
    slen = ctx->service.len;
#line 435
    tmp = ngx_strlchr(ctx->service.data, ctx->service.data + ctx->service.len, (u_char )'.');
    }
#line 435
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 439
      slen += sizeof("_._tcp") - 1UL;
    }
    {
#line 442
    name.len = (slen + 1UL) + ctx->name.len;
#line 444
    tmp___0 = ngx_resolver_alloc(r, name.len);
#line 444
    name.data = (u_char *)tmp___0;
    }
#line 445
    if ((unsigned long )name.data == (unsigned long )((void *)0)) {
#line 446
      goto failed;
    }
#line 449
    if (slen == ctx->service.len) {
      {
#line 450
      ngx_sprintf(name.data, "%V.%V", & ctx->service, & ctx->name);
      }
    } else {
      {
#line 453
      ngx_sprintf(name.data, "_%V._tcp.%V", & ctx->service, & ctx->name);
      }
    }
    {
#line 458
    rc = ngx_resolve_name_locked(r, ctx, & name);
#line 460
    ngx_resolver_free(r, (void *)name.data);
    }
  } else {
    {
#line 465
    rc = ngx_resolve_name_locked(r, ctx, & ctx->name);
    }
  }
#line 468
  if (rc == 0L) {
#line 469
    return ((ngx_int_t )0);
  }
#line 474
  if (rc == -2L) {
#line 475
    return ((ngx_int_t )0);
  }
#line 480
  if (ctx->event) {
    {
#line 481
    ngx_resolver_free(r, (void *)ctx->event);
    }
  }
  failed: 
  {
#line 486
  ngx_resolver_free(r, (void *)ctx);
  }
#line 488
  return ((ngx_int_t )-1);
}
}
#line 492 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
void ngx_resolve_name_done(ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_uint_t i ;
  ngx_resolver_t *r ;
  ngx_resolver_ctx_t *w ;
  ngx_resolver_ctx_t **p ;
  ngx_resolver_node_t *rn ;
  ngx_uint_t tmp ;

  {
#line 500
  r = ctx->resolver;
#line 505
  if (ctx->quick) {
#line 506
    return;
  }
#line 509
  if (ctx->event) {
#line 509
    if ((ctx->event)->timer_set) {
      {
#line 510
      ngx_event_del_timer(ctx->event);
      }
    }
  }
#line 515
  if (ctx->nsrvs) {
#line 516
    i = (ngx_uint_t )0;
    {
#line 516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 516
      if (! (i < ctx->nsrvs)) {
#line 516
        goto while_break;
      }
#line 517
      if ((ctx->srvs + i)->ctx) {
        {
#line 518
        ngx_resolve_name_done((ctx->srvs + i)->ctx);
        }
      }
#line 521
      if ((ctx->srvs + i)->addrs) {
        {
#line 522
        ngx_resolver_free(r, (void *)((ctx->srvs + i)->addrs)->sockaddr);
#line 523
        ngx_resolver_free(r, (void *)(ctx->srvs + i)->addrs);
        }
      }
      {
#line 526
      ngx_resolver_free(r, (void *)(ctx->srvs + i)->name.data);
#line 516
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 529
    ngx_resolver_free(r, (void *)ctx->srvs);
    }
  }
#line 532
  if (ctx->state == -2L) {
#line 532
    goto _L;
  } else
#line 532
  if (ctx->state == 110L) {
    _L: /* CIL Label */ 
#line 534
    rn = ctx->node;
#line 536
    if (rn) {
#line 537
      p = & rn->waiting;
#line 538
      w = rn->waiting;
      {
#line 540
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 540
        if (! w) {
#line 540
          goto while_break___0;
        }
#line 541
        if ((unsigned long )w == (unsigned long )ctx) {
#line 542
          *p = w->next;
#line 544
          goto done;
        }
#line 547
        p = & w->next;
#line 548
        w = w->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 551
      if ((r->log)->log_level >= 2UL) {
        {
#line 551
        ngx_log_error_core((ngx_uint_t )2, r->log, 0, "could not cancel %V resolving",
                           & ctx->name);
        }
      }
    }
  }
  done: 
#line 558
  if (ctx->service.len) {
    {
#line 559
    ngx_resolver_expire(r, & r->srv_rbtree, & r->srv_expire_queue);
    }
  } else {
    {
#line 562
    ngx_resolver_expire(r, & r->name_rbtree, & r->name_expire_queue);
    }
  }
#line 569
  if (ctx->event) {
    {
#line 570
    ngx_resolver_free_locked(r, (void *)ctx->event);
    }
  }
  {
#line 573
  ngx_resolver_free_locked(r, (void *)ctx);
  }
#line 577
  if ((r->event)->timer_set) {
    {
#line 577
    tmp = ngx_resolver_resend_empty(r);
    }
#line 577
    if (tmp) {
      {
#line 578
      ngx_event_del_timer(r->event);
      }
    }
  }
#line 580
  return;
}
}
#line 583 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolve_name_locked(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ,
                                         ngx_str_t *name ) 
{ 
  uint32_t hash ;
  ngx_int_t rc ;
  ngx_str_t cname ;
  ngx_uint_t i ;
  ngx_uint_t naddrs ;
  ngx_queue_t *resend_queue ;
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_ctx_t *last ;
  ngx_resolver_addr_t *addrs ;
  ngx_resolver_node_t *rn ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_uint_t tmp___1 ;
  time_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  ngx_uint_t tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;
  ngx_uint_t tmp___9 ;

  {
  {
#line 597
  ngx_strlow(name->data, name->data, name->len);
#line 599
  hash = ngx_crc32_short(name->data, name->len);
  }
#line 601
  if (ctx->service.len) {
    {
#line 602
    rn = ngx_resolver_lookup_srv(r, name, hash);
#line 604
    tree = & r->srv_rbtree;
#line 605
    resend_queue = & r->srv_resend_queue;
#line 606
    expire_queue = & r->srv_expire_queue;
    }
  } else {
    {
#line 609
    rn = ngx_resolver_lookup_name(r, name, hash);
#line 611
    tree = & r->name_rbtree;
#line 612
    resend_queue = & r->name_resend_queue;
#line 613
    expire_queue = & r->name_expire_queue;
    }
  }
#line 616
  if (rn) {
#line 619
    last = ctx;
    {
#line 619
    while (1) {
      while_continue: /* CIL Label */ ;
#line 619
      if (! last->next) {
#line 619
        goto while_break;
      }
#line 619
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 621
    if (rn->valid >= (time_t )ngx_cached_time->sec) {
#line 625
      (rn->queue.next)->prev = rn->queue.prev;
#line 625
      (rn->queue.prev)->next = rn->queue.next;
#line 627
      rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 629
      rn->queue.next = expire_queue->next;
#line 629
      (rn->queue.next)->prev = & rn->queue;
#line 629
      rn->queue.prev = expire_queue;
#line 629
      expire_queue->next = & rn->queue;
#line 631
      if ((int )rn->naddrs == 65535) {
#line 631
        naddrs = (ngx_uint_t )0;
      } else {
#line 631
        naddrs = (ngx_uint_t )rn->naddrs;
      }
#line 633
      if ((int )rn->naddrs6 == 65535) {
#line 633
        tmp = 0;
      } else {
#line 633
        tmp = (int )rn->naddrs6;
      }
#line 633
      naddrs += (ngx_uint_t )tmp;
#line 636
      if (naddrs) {
#line 638
        if (naddrs == 1UL) {
#line 638
          if ((int )rn->naddrs == 1) {
#line 639
            addrs = (ngx_resolver_addr_t *)((void *)0);
          } else {
#line 638
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 642
          addrs = ngx_resolver_export(r, rn, (ngx_uint_t )1);
          }
#line 643
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
#line 644
            return ((ngx_int_t )-1);
          }
        }
#line 648
        last->next = rn->waiting;
#line 649
        rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
        {
#line 653
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 654
          ctx->state = (ngx_int_t )0;
#line 655
          ctx->valid = rn->valid;
#line 656
          ctx->naddrs = naddrs;
#line 658
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
            {
#line 659
            ctx->addrs = & ctx->addr;
#line 660
            ctx->addr.sockaddr = (struct sockaddr *)(& ctx->sin);
#line 661
            ctx->addr.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 662
            memset((void *)(& ctx->sin), 0, sizeof(struct sockaddr_in ));
#line 663
            ctx->sin.sin_family = (sa_family_t )2;
#line 664
            ctx->sin.sin_addr.s_addr = rn->u.addr;
            }
          } else {
#line 667
            ctx->addrs = addrs;
          }
          {
#line 670
          next = ctx->next;
#line 672
          (*(ctx->handler))(ctx);
#line 674
          ctx = next;
          }
#line 653
          if (! ctx) {
#line 653
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 677
        if ((unsigned long )addrs != (unsigned long )((void *)0)) {
          {
#line 678
          ngx_resolver_free(r, (void *)addrs->sockaddr);
#line 679
          ngx_resolver_free(r, (void *)addrs);
          }
        }
#line 682
        return ((ngx_int_t )0);
      }
#line 685
      if (rn->nsrvs) {
#line 686
        last->next = rn->waiting;
#line 687
        rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
        {
#line 691
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 692
          next = ctx->next;
#line 694
          ngx_resolver_resolve_srv_names(ctx, rn);
#line 696
          ctx = next;
          }
#line 691
          if (! ctx) {
#line 691
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 699
        return ((ngx_int_t )0);
      }
#line 704
      tmp___1 = ctx->recursion;
#line 704
      (ctx->recursion) ++;
#line 704
      if (tmp___1 < 50UL) {
        {
#line 706
        cname.len = (size_t___0 )rn->cnlen;
#line 707
        cname.data = rn->u.cname;
#line 709
        tmp___0 = ngx_resolve_name_locked(r, ctx, & cname);
        }
#line 709
        return (tmp___0);
      }
#line 712
      last->next = rn->waiting;
#line 713
      rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
      {
#line 717
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 718
        ctx->state = (ngx_int_t )3;
#line 719
        if (r->valid) {
#line 719
          tmp___2 = r->valid;
        } else {
#line 719
          tmp___2 = (time_t )10;
        }
        {
#line 719
        ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___2);
#line 720
        next = ctx->next;
#line 722
        (*(ctx->handler))(ctx);
#line 724
        ctx = next;
        }
#line 717
        if (! ctx) {
#line 717
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 727
      return ((ngx_int_t )0);
    }
#line 730
    if (rn->waiting) {
#line 732
      if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 732
        if (ctx->timeout) {
          {
#line 733
          tmp___3 = ngx_resolver_calloc(r, sizeof(ngx_event_t ));
#line 733
          ctx->event = (ngx_event_t *)tmp___3;
          }
#line 734
          if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 735
            return ((ngx_int_t )-1);
          }
          {
#line 738
          (ctx->event)->handler = & ngx_resolver_timeout_handler;
#line 739
          (ctx->event)->data = (void *)ctx;
#line 740
          (ctx->event)->log = r->log;
#line 741
          ctx->ident = (ngx_int_t )-1;
#line 743
          ngx_event_add_timer(ctx->event, ctx->timeout);
          }
        }
      }
#line 746
      last->next = rn->waiting;
#line 747
      rn->waiting = ctx;
#line 748
      ctx->state = (ngx_int_t )-2;
#line 749
      ctx->async = 1U;
      {
#line 751
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 752
        ctx->node = rn;
#line 753
        ctx = ctx->next;
#line 751
        if (! ctx) {
#line 751
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 756
      return ((ngx_int_t )-2);
    }
#line 759
    (rn->queue.next)->prev = rn->queue.prev;
#line 759
    (rn->queue.prev)->next = rn->queue.next;
#line 763
    if (rn->query) {
      {
#line 764
      ngx_resolver_free_locked(r, (void *)rn->query);
#line 765
      rn->query = (u_char *)((void *)0);
#line 767
      rn->query6 = (u_char *)((void *)0);
      }
    }
#line 771
    if (rn->cnlen) {
      {
#line 772
      ngx_resolver_free_locked(r, (void *)rn->u.cname);
      }
    }
#line 775
    if ((int )rn->naddrs > 1) {
#line 775
      if ((int )rn->naddrs != 65535) {
        {
#line 776
        ngx_resolver_free_locked(r, (void *)rn->u.addrs);
        }
      }
    }
#line 780
    if ((int )rn->naddrs6 > 1) {
#line 780
      if ((int )rn->naddrs6 != 65535) {
        {
#line 781
        ngx_resolver_free_locked(r, (void *)rn->u6.addrs6);
        }
      }
    }
#line 785
    if (rn->nsrvs) {
#line 786
      i = (ngx_uint_t )0;
      {
#line 786
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 786
        if (! (i < (ngx_uint_t )rn->nsrvs)) {
#line 786
          goto while_break___4;
        }
#line 787
        if ((rn->u.srvs + i)->name.data) {
          {
#line 788
          ngx_resolver_free_locked(r, (void *)(rn->u.srvs + i)->name.data);
          }
        }
#line 786
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 792
      ngx_resolver_free_locked(r, (void *)rn->u.srvs);
      }
    }
  } else {
    {
#line 799
    tmp___4 = ngx_resolver_alloc(r, sizeof(ngx_resolver_node_t ));
#line 799
    rn = (ngx_resolver_node_t *)tmp___4;
    }
#line 800
    if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 801
      return ((ngx_int_t )-1);
    }
    {
#line 804
    tmp___5 = ngx_resolver_dup(r, (void *)name->data, name->len);
#line 804
    rn->name = (u_char *)tmp___5;
    }
#line 805
    if ((unsigned long )rn->name == (unsigned long )((void *)0)) {
      {
#line 806
      ngx_resolver_free(r, (void *)rn);
      }
#line 807
      return ((ngx_int_t )-1);
    }
    {
#line 810
    rn->node.key = (ngx_rbtree_key_t )hash;
#line 811
    rn->nlen = (u_short )name->len;
#line 812
    rn->query = (u_char *)((void *)0);
#line 814
    rn->query6 = (u_char *)((void *)0);
#line 817
    ngx_rbtree_insert(tree, & rn->node);
    }
  }
#line 820
  if (ctx->service.len) {
    {
#line 821
    rc = ngx_resolver_create_srv_query(r, rn, name);
    }
  } else {
    {
#line 824
    rc = ngx_resolver_create_name_query(r, rn, name);
    }
  }
#line 827
  if (rc == -1L) {
#line 828
    goto failed;
  }
#line 831
  if (rc == -5L) {
    {
#line 832
    ngx_rbtree_delete(tree, & rn->node);
#line 834
    ngx_resolver_free(r, (void *)rn->query);
#line 835
    ngx_resolver_free(r, (void *)rn->name);
#line 836
    ngx_resolver_free(r, (void *)rn);
    }
    {
#line 838
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 839
      ctx->state = (ngx_int_t )3;
#line 840
      next = ctx->next;
#line 842
      (*(ctx->handler))(ctx);
#line 844
      ctx = next;
      }
#line 838
      if (! ctx) {
#line 838
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 847
    return ((ngx_int_t )0);
  }
#line 850
  tmp___6 = r->last_connection;
#line 850
  (r->last_connection) ++;
#line 850
  rn->last_connection = tmp___6;
#line 851
  if (r->last_connection == r->connections.nelts) {
#line 852
    r->last_connection = (ngx_uint_t )0;
  }
#line 855
  rn->naddrs = (u_short )-1;
#line 856
  rn->tcp = 0U;
#line 858
  if (r->ipv6) {
#line 858
    rn->naddrs6 = (u_short )-1;
  } else {
#line 858
    rn->naddrs6 = (u_short )0;
  }
  {
#line 859
  rn->tcp6 = 0U;
#line 861
  rn->nsrvs = (u_short )0;
#line 863
  tmp___7 = ngx_resolver_send_query(r, rn);
  }
#line 863
  if (tmp___7 != 0L) {
#line 864
    goto failed;
  }
#line 867
  if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 867
    if (ctx->timeout) {
      {
#line 868
      tmp___8 = ngx_resolver_calloc(r, sizeof(ngx_event_t ));
#line 868
      ctx->event = (ngx_event_t *)tmp___8;
      }
#line 869
      if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 870
        goto failed;
      }
      {
#line 873
      (ctx->event)->handler = & ngx_resolver_timeout_handler;
#line 874
      (ctx->event)->data = (void *)ctx;
#line 875
      (ctx->event)->log = r->log;
#line 876
      ctx->ident = (ngx_int_t )-1;
#line 878
      ngx_event_add_timer(ctx->event, ctx->timeout);
      }
    }
  }
  {
#line 881
  tmp___9 = ngx_resolver_resend_empty(r);
  }
#line 881
  if (tmp___9) {
    {
#line 882
    ngx_event_add_timer(r->event, (ngx_msec_t )(r->resend_timeout * 1000L));
    }
  }
#line 885
  rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 887
  rn->queue.next = resend_queue->next;
#line 887
  (rn->queue.next)->prev = & rn->queue;
#line 887
  rn->queue.prev = resend_queue;
#line 887
  resend_queue->next = & rn->queue;
#line 889
  rn->code = (u_char )0;
#line 890
  rn->cnlen = (u_short )0;
#line 891
  rn->valid = (time_t )0;
#line 892
  rn->ttl = 4294967295U;
#line 893
  rn->waiting = ctx;
#line 895
  ctx->state = (ngx_int_t )-2;
#line 896
  ctx->async = 1U;
  {
#line 898
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 899
    ctx->node = rn;
#line 900
    ctx = ctx->next;
#line 898
    if (! ctx) {
#line 898
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 903
  return ((ngx_int_t )-2);
  failed: 
  {
#line 907
  ngx_rbtree_delete(tree, & rn->node);
  }
#line 909
  if (rn->query) {
    {
#line 910
    ngx_resolver_free(r, (void *)rn->query);
    }
  }
  {
#line 913
  ngx_resolver_free(r, (void *)rn->name);
#line 915
  ngx_resolver_free(r, (void *)rn);
  }
#line 917
  return ((ngx_int_t )-1);
}
}
#line 921 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
ngx_int_t ngx_resolve_addr(ngx_resolver_ctx_t *ctx ) 
{ 
  u_char *name ;
  in_addr_t addr ;
  ngx_queue_t *resend_queue ;
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_t *r ;
  struct sockaddr_in *sin ;
  ngx_resolver_node_t *rn ;
  uint32_t hash ;
  struct sockaddr_in6 *sin6 ;
  unsigned int __v ;
  unsigned int __x ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  ngx_uint_t tmp___6 ;

  {
#line 937
  addr = (in_addr_t )0;
#line 939
  hash = (uint32_t )0;
#line 940
  sin6 = (struct sockaddr_in6 *)((void *)0);
#line 944
  r = ctx->resolver;
  {
#line 949
  if ((int )(ctx->addr.sockaddr)->sa_family == 10) {
#line 949
    goto case_10;
  }
#line 964
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 950
  sin6 = (struct sockaddr_in6 *)ctx->addr.sockaddr;
#line 951
  hash = ngx_crc32_short(sin6->sin6_addr.__in6_u.__u6_addr8, (size_t___0 )16);
#line 955
  rn = ngx_resolver_lookup_addr6(r, & sin6->sin6_addr, hash);
#line 957
  tree = & r->addr6_rbtree;
#line 958
  resend_queue = & r->addr6_resend_queue;
#line 959
  expire_queue = & r->addr6_expire_queue;
  }
#line 961
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 965
  sin = (struct sockaddr_in *)ctx->addr.sockaddr;
#line 966
  __x = sin->sin_addr.s_addr;
#line 966
  __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 966
  addr = __v;
#line 970
  rn = ngx_resolver_lookup_addr(r, addr);
#line 972
  tree = & r->addr_rbtree;
#line 973
  resend_queue = & r->addr_resend_queue;
#line 974
  expire_queue = & r->addr_expire_queue;
  }
  switch_break: /* CIL Label */ ;
  }
#line 977
  if (rn) {
#line 979
    if (rn->valid >= (time_t )ngx_cached_time->sec) {
      {
#line 983
      (rn->queue.next)->prev = rn->queue.prev;
#line 983
      (rn->queue.prev)->next = rn->queue.next;
#line 985
      rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 987
      rn->queue.next = expire_queue->next;
#line 987
      (rn->queue.next)->prev = & rn->queue;
#line 987
      rn->queue.prev = expire_queue;
#line 987
      expire_queue->next = & rn->queue;
#line 989
      tmp = ngx_resolver_dup(r, (void *)rn->name, (size_t___0 )rn->nlen);
#line 989
      name = (u_char *)tmp;
      }
#line 990
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 991
        goto failed;
      }
      {
#line 994
      ctx->name.len = (size_t___0 )rn->nlen;
#line 995
      ctx->name.data = name;
#line 999
      ctx->state = (ngx_int_t )0;
#line 1000
      ctx->valid = rn->valid;
#line 1002
      (*(ctx->handler))(ctx);
#line 1004
      ngx_resolver_free(r, (void *)name);
      }
#line 1006
      return ((ngx_int_t )0);
    }
#line 1009
    if (rn->waiting) {
#line 1011
      if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 1011
        if (ctx->timeout) {
          {
#line 1012
          tmp___0 = ngx_resolver_calloc(r, sizeof(ngx_event_t ));
#line 1012
          ctx->event = (ngx_event_t *)tmp___0;
          }
#line 1013
          if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 1014
            return ((ngx_int_t )-1);
          }
          {
#line 1017
          (ctx->event)->handler = & ngx_resolver_timeout_handler;
#line 1018
          (ctx->event)->data = (void *)ctx;
#line 1019
          (ctx->event)->log = r->log;
#line 1020
          ctx->ident = (ngx_int_t )-1;
#line 1022
          ngx_event_add_timer(ctx->event, ctx->timeout);
          }
        }
      }
#line 1025
      ctx->next = rn->waiting;
#line 1026
      rn->waiting = ctx;
#line 1027
      ctx->state = (ngx_int_t )-2;
#line 1028
      ctx->async = 1U;
#line 1029
      ctx->node = rn;
#line 1033
      return ((ngx_int_t )0);
    }
    {
#line 1036
    (rn->queue.next)->prev = rn->queue.prev;
#line 1036
    (rn->queue.prev)->next = rn->queue.next;
#line 1038
    ngx_resolver_free(r, (void *)rn->query);
#line 1039
    rn->query = (u_char *)((void *)0);
#line 1041
    rn->query6 = (u_char *)((void *)0);
    }
  } else {
    {
#line 1045
    tmp___1 = ngx_resolver_alloc(r, sizeof(ngx_resolver_node_t ));
#line 1045
    rn = (ngx_resolver_node_t *)tmp___1;
    }
#line 1046
    if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 1047
      goto failed;
    }
    {
#line 1053
    if ((int )(ctx->addr.sockaddr)->sa_family == 10) {
#line 1053
      goto case_10___0;
    }
#line 1059
    goto switch_default___0;
    case_10___0: /* CIL Label */ 
#line 1054
    rn->addr6 = sin6->sin6_addr;
#line 1055
    rn->node.key = (ngx_rbtree_key_t )hash;
#line 1056
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1060
    rn->node.key = (ngx_rbtree_key_t )addr;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1063
    rn->query = (u_char *)((void *)0);
#line 1065
    rn->query6 = (u_char *)((void *)0);
#line 1068
    ngx_rbtree_insert(tree, & rn->node);
    }
  }
  {
#line 1071
  tmp___2 = ngx_resolver_create_addr_query(r, rn, & ctx->addr);
  }
#line 1071
  if (tmp___2 != 0L) {
#line 1072
    goto failed;
  }
#line 1075
  tmp___3 = r->last_connection;
#line 1075
  (r->last_connection) ++;
#line 1075
  rn->last_connection = tmp___3;
#line 1076
  if (r->last_connection == r->connections.nelts) {
#line 1077
    r->last_connection = (ngx_uint_t )0;
  }
  {
#line 1080
  rn->naddrs = (u_short )-1;
#line 1081
  rn->tcp = 0U;
#line 1083
  rn->naddrs6 = (u_short )-1;
#line 1084
  rn->tcp6 = 0U;
#line 1086
  rn->nsrvs = (u_short )0;
#line 1088
  tmp___4 = ngx_resolver_send_query(r, rn);
  }
#line 1088
  if (tmp___4 != 0L) {
#line 1089
    goto failed;
  }
#line 1092
  if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 1092
    if (ctx->timeout) {
      {
#line 1093
      tmp___5 = ngx_resolver_calloc(r, sizeof(ngx_event_t ));
#line 1093
      ctx->event = (ngx_event_t *)tmp___5;
      }
#line 1094
      if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 1095
        goto failed;
      }
      {
#line 1098
      (ctx->event)->handler = & ngx_resolver_timeout_handler;
#line 1099
      (ctx->event)->data = (void *)ctx;
#line 1100
      (ctx->event)->log = r->log;
#line 1101
      ctx->ident = (ngx_int_t )-1;
#line 1103
      ngx_event_add_timer(ctx->event, ctx->timeout);
      }
    }
  }
  {
#line 1106
  tmp___6 = ngx_resolver_resend_empty(r);
  }
#line 1106
  if (tmp___6) {
    {
#line 1107
    ngx_event_add_timer(r->event, (ngx_msec_t )(r->resend_timeout * 1000L));
    }
  }
#line 1110
  rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 1112
  rn->queue.next = resend_queue->next;
#line 1112
  (rn->queue.next)->prev = & rn->queue;
#line 1112
  rn->queue.prev = resend_queue;
#line 1112
  resend_queue->next = & rn->queue;
#line 1114
  rn->code = (u_char )0;
#line 1115
  rn->cnlen = (u_short )0;
#line 1116
  rn->name = (u_char *)((void *)0);
#line 1117
  rn->nlen = (u_short )0;
#line 1118
  rn->valid = (time_t )0;
#line 1119
  rn->ttl = 4294967295U;
#line 1120
  rn->waiting = ctx;
#line 1124
  ctx->state = (ngx_int_t )-2;
#line 1125
  ctx->async = 1U;
#line 1126
  ctx->node = rn;
#line 1128
  return ((ngx_int_t )0);
  failed: 
#line 1132
  if (rn) {
    {
#line 1133
    ngx_rbtree_delete(tree, & rn->node);
    }
#line 1135
    if (rn->query) {
      {
#line 1136
      ngx_resolver_free(r, (void *)rn->query);
      }
    }
    {
#line 1139
    ngx_resolver_free(r, (void *)rn);
    }
  }
#line 1144
  if (ctx->event) {
    {
#line 1145
    ngx_resolver_free(r, (void *)ctx->event);
    }
  }
  {
#line 1148
  ngx_resolver_free(r, (void *)ctx);
  }
#line 1150
  return ((ngx_int_t )-1);
}
}
#line 1154 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
void ngx_resolve_addr_done(ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_t *r ;
  ngx_resolver_ctx_t *w ;
  ngx_resolver_ctx_t **p ;
  ngx_resolver_node_t *rn ;
  u_char text[(sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path))] ;
  ngx_str_t addrtext ;
  ngx_uint_t tmp ;

  {
#line 1163
  r = ctx->resolver;
  {
#line 1168
  if ((int )(ctx->addr.sockaddr)->sa_family == 10) {
#line 1168
    goto case_10;
  }
#line 1174
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1169
  tree = & r->addr6_rbtree;
#line 1170
  expire_queue = & r->addr6_expire_queue;
#line 1171
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1175
  tree = & r->addr_rbtree;
#line 1176
  expire_queue = & r->addr_expire_queue;
  switch_break: /* CIL Label */ ;
  }
#line 1182
  if (ctx->event) {
#line 1182
    if ((ctx->event)->timer_set) {
      {
#line 1183
      ngx_event_del_timer(ctx->event);
      }
    }
  }
#line 1188
  if (ctx->state == -2L) {
#line 1188
    goto _L;
  } else
#line 1188
  if (ctx->state == 110L) {
    _L: /* CIL Label */ 
#line 1190
    rn = ctx->node;
#line 1192
    if (rn) {
#line 1193
      p = & rn->waiting;
#line 1194
      w = rn->waiting;
      {
#line 1196
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1196
        if (! w) {
#line 1196
          goto while_break;
        }
#line 1197
        if ((unsigned long )w == (unsigned long )ctx) {
#line 1198
          *p = w->next;
#line 1200
          goto done;
        }
#line 1203
        p = & w->next;
#line 1204
        w = w->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1212
    addrtext.data = text;
#line 1213
    addrtext.len = ngx_sock_ntop(ctx->addr.sockaddr, ctx->addr.socklen, text, (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)),
                                 (ngx_uint_t )0);
    }
#line 1216
    if ((r->log)->log_level >= 2UL) {
      {
#line 1216
      ngx_log_error_core((ngx_uint_t )2, r->log, 0, "could not cancel %V resolving",
                         & addrtext);
      }
    }
  }
  done: 
  {
#line 1223
  ngx_resolver_expire(r, tree, expire_queue);
  }
#line 1229
  if (ctx->event) {
    {
#line 1230
    ngx_resolver_free_locked(r, (void *)ctx->event);
    }
  }
  {
#line 1233
  ngx_resolver_free_locked(r, (void *)ctx);
  }
#line 1237
  if ((r->event)->timer_set) {
    {
#line 1237
    tmp = ngx_resolver_resend_empty(r);
    }
#line 1237
    if (tmp) {
      {
#line 1238
      ngx_event_del_timer(r->event);
      }
    }
  }
#line 1240
  return;
}
}
#line 1243 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_expire(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) 
{ 
  time_t now ;
  ngx_uint_t i ;
  ngx_queue_t *q ;
  ngx_resolver_node_t *rn ;

  {
#line 1253
  now = (time_t )ngx_cached_time->sec;
#line 1255
  i = (ngx_uint_t )0;
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! (i < 2UL)) {
#line 1255
      goto while_break;
    }
#line 1256
    if ((unsigned long )queue == (unsigned long )queue->prev) {
#line 1257
      return;
    }
#line 1260
    q = queue->prev;
#line 1262
    rn = (ngx_resolver_node_t *)((u_char *)q - (unsigned long )(& ((ngx_resolver_node_t *)0)->queue));
#line 1264
    if (now <= rn->expire) {
#line 1265
      return;
    }
    {
#line 1271
    (q->next)->prev = q->prev;
#line 1271
    (q->prev)->next = q->next;
#line 1273
    ngx_rbtree_delete(tree, & rn->node);
#line 1275
    ngx_resolver_free_node(r, rn);
#line 1255
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  return;
}
}
#line 1280 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_send_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ) 
{ 
  ngx_int_t rc ;
  ngx_resolver_connection_t *rec ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1286
  rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 1287
  rec += rn->last_connection;
#line 1289
  if ((unsigned long )rec->log.handler == (unsigned long )((void *)0)) {
#line 1290
    rec->log = *(r->log);
#line 1291
    rec->log.handler = & ngx_resolver_log_error;
#line 1292
    rec->log.data = (void *)rec;
#line 1293
    rec->log.action = (char *)"resolving";
  }
#line 1296
  if ((int )rn->naddrs == 65535) {
#line 1297
    if (rn->tcp) {
      {
#line 1297
      tmp = ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen);
#line 1297
      rc = tmp;
      }
    } else {
      {
#line 1297
      tmp___0 = ngx_resolver_send_udp_query(r, rec, rn->query, rn->qlen);
#line 1297
      rc = tmp___0;
      }
    }
#line 1300
    if (rc != 0L) {
#line 1301
      return (rc);
    }
  }
#line 1307
  if (rn->query6) {
#line 1307
    if ((int )rn->naddrs6 == 65535) {
#line 1308
      if (rn->tcp6) {
        {
#line 1308
        tmp___1 = ngx_resolver_send_tcp_query(r, rec, rn->query6, rn->qlen);
#line 1308
        rc = tmp___1;
        }
      } else {
        {
#line 1308
        tmp___2 = ngx_resolver_send_udp_query(r, rec, rn->query6, rn->qlen);
#line 1308
        rc = tmp___2;
        }
      }
#line 1312
      if (rc != 0L) {
#line 1313
        return (rc);
      }
    }
  }
#line 1319
  return ((ngx_int_t )0);
}
}
#line 1323 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_send_udp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) 
{ 
  ssize_t n ;
  ngx_int_t tmp ;

  {
#line 1329
  if ((unsigned long )rec->udp == (unsigned long )((void *)0)) {
    {
#line 1330
    tmp = ngx_udp_connect(rec);
    }
#line 1330
    if (tmp != 0L) {
#line 1331
      return ((ngx_int_t )-1);
    }
#line 1334
    (rec->udp)->data = (void *)rec;
#line 1335
    ((rec->udp)->read)->handler = & ngx_resolver_udp_read;
#line 1336
    ((rec->udp)->read)->resolver = 1U;
  }
  {
#line 1339
  n = (*(ngx_io.send))(rec->udp, query, (size_t___0 )qlen);
  }
#line 1341
  if (n == -1L) {
#line 1342
    return ((ngx_int_t )-1);
  }
#line 1345
  if ((size_t___0 )n != (size_t___0 )qlen) {
#line 1346
    if (rec->log.log_level >= 3UL) {
      {
#line 1346
      ngx_log_error_core((ngx_uint_t )3, & rec->log, 0, "send() incomplete");
      }
    }
#line 1347
    return ((ngx_int_t )-1);
  }
#line 1350
  return ((ngx_int_t )0);
}
}
#line 1354 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_send_tcp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) 
{ 
  ngx_buf_t *b ;
  ngx_int_t rc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;

  {
#line 1361
  rc = (ngx_int_t )0;
#line 1363
  if ((unsigned long )rec->tcp == (unsigned long )((void *)0)) {
#line 1364
    b = rec->read_buf;
#line 1366
    if ((unsigned long )b == (unsigned long )((void *)0)) {
      {
#line 1367
      tmp = ngx_resolver_calloc(r, sizeof(ngx_buf_t ));
#line 1367
      b = (ngx_buf_t *)tmp;
      }
#line 1368
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1369
        return ((ngx_int_t )-1);
      }
      {
#line 1372
      tmp___0 = ngx_resolver_alloc(r, (size_t___0 )65537);
#line 1372
      b->start = (u_char *)tmp___0;
      }
#line 1373
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 1374
        ngx_resolver_free(r, (void *)b);
        }
#line 1375
        return ((ngx_int_t )-1);
      }
#line 1378
      b->end = b->start + 65537;
#line 1380
      rec->read_buf = b;
    }
#line 1383
    b->pos = b->start;
#line 1384
    b->last = b->start;
#line 1386
    b = rec->write_buf;
#line 1388
    if ((unsigned long )b == (unsigned long )((void *)0)) {
      {
#line 1389
      tmp___1 = ngx_resolver_calloc(r, sizeof(ngx_buf_t ));
#line 1389
      b = (ngx_buf_t *)tmp___1;
      }
#line 1390
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1391
        return ((ngx_int_t )-1);
      }
      {
#line 1394
      tmp___2 = ngx_resolver_alloc(r, (size_t___0 )8192);
#line 1394
      b->start = (u_char *)tmp___2;
      }
#line 1395
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 1396
        ngx_resolver_free(r, (void *)b);
        }
#line 1397
        return ((ngx_int_t )-1);
      }
#line 1400
      b->end = b->start + 8192;
#line 1402
      rec->write_buf = b;
    }
    {
#line 1405
    b->pos = b->start;
#line 1406
    b->last = b->start;
#line 1408
    rc = ngx_tcp_connect(rec);
    }
#line 1409
    if (rc == -1L) {
#line 1410
      return ((ngx_int_t )-1);
    }
    {
#line 1413
    (rec->tcp)->data = (void *)rec;
#line 1414
    ((rec->tcp)->write)->handler = & ngx_resolver_tcp_write;
#line 1415
    ((rec->tcp)->read)->handler = & ngx_resolver_tcp_read;
#line 1416
    ((rec->tcp)->read)->resolver = 1U;
#line 1418
    ngx_event_add_timer((rec->tcp)->write, (ngx_msec_t )(r->tcp_timeout * 1000L));
    }
  }
#line 1421
  b = rec->write_buf;
#line 1423
  if (b->end - b->last < (long )(2 + (int )qlen)) {
#line 1424
    if (rec->log.log_level >= 3UL) {
      {
#line 1424
      ngx_log_error_core((ngx_uint_t )3, & rec->log, 0, "buffer overflow");
      }
    }
#line 1425
    return ((ngx_int_t )-1);
  }
  {
#line 1428
  tmp___3 = b->last;
#line 1428
  (b->last) ++;
#line 1428
  *tmp___3 = (u_char )((int )qlen >> 8);
#line 1429
  tmp___4 = b->last;
#line 1429
  (b->last) ++;
#line 1429
  *tmp___4 = (u_char )qlen;
#line 1430
  tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)query,
                   (size_t )qlen);
#line 1430
  b->last = (u_char *)tmp___5 + (int )qlen;
  }
#line 1432
  if (rc == 0L) {
    {
#line 1433
    ngx_resolver_tcp_write((rec->tcp)->write);
    }
  }
#line 1436
  return ((ngx_int_t )0);
}
}
#line 1440 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_resend_handler(ngx_event_t *ev ) 
{ 
  time_t timer ;
  time_t atimer ;
  time_t stimer ;
  time_t ntimer ;
  time_t a6timer ;
  ngx_resolver_t *r ;

  {
  {
#line 1449
  r = (ngx_resolver_t *)ev->data;
#line 1456
  ntimer = ngx_resolver_resend(r, & r->name_rbtree, & r->name_resend_queue);
#line 1458
  stimer = ngx_resolver_resend(r, & r->srv_rbtree, & r->srv_resend_queue);
#line 1464
  atimer = ngx_resolver_resend(r, & r->addr_rbtree, & r->addr_resend_queue);
#line 1472
  a6timer = ngx_resolver_resend(r, & r->addr6_rbtree, & r->addr6_resend_queue);
#line 1478
  timer = ntimer;
  }
#line 1480
  if (timer == 0L) {
#line 1481
    timer = atimer;
  } else
#line 1483
  if (atimer) {
#line 1484
    if (timer > atimer) {
#line 1484
      timer = atimer;
    } else {
#line 1484
      timer = timer;
    }
  }
#line 1487
  if (timer == 0L) {
#line 1488
    timer = stimer;
  } else
#line 1490
  if (stimer) {
#line 1491
    if (timer > stimer) {
#line 1491
      timer = stimer;
    } else {
#line 1491
      timer = timer;
    }
  }
#line 1496
  if (timer == 0L) {
#line 1497
    timer = a6timer;
  } else
#line 1499
  if (a6timer) {
#line 1500
    if (timer > a6timer) {
#line 1500
      timer = a6timer;
    } else {
#line 1500
      timer = timer;
    }
  }
#line 1505
  if (timer) {
    {
#line 1506
    ngx_event_add_timer(r->event, (ngx_msec_t )(timer * 1000L));
    }
  }
#line 1508
  return;
}
}
#line 1511 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static time_t ngx_resolver_resend(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) 
{ 
  time_t now ;
  ngx_queue_t *q ;
  ngx_resolver_node_t *rn ;

  {
#line 1518
  now = (time_t )ngx_cached_time->sec;
  {
#line 1520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1521
    if ((unsigned long )queue == (unsigned long )queue->prev) {
#line 1522
      return ((time_t )0);
    }
#line 1525
    q = queue->prev;
#line 1527
    rn = (ngx_resolver_node_t *)((u_char *)q - (unsigned long )(& ((ngx_resolver_node_t *)0)->queue));
#line 1529
    if (now < rn->expire) {
#line 1530
      return (rn->expire - now);
    }
#line 1537
    (q->next)->prev = q->prev;
#line 1537
    (q->prev)->next = q->next;
#line 1539
    if (rn->waiting) {
#line 1541
      (rn->last_connection) ++;
#line 1541
      if (rn->last_connection == r->connections.nelts) {
#line 1542
        rn->last_connection = (ngx_uint_t )0;
      }
      {
#line 1545
      ngx_resolver_send_query(r, rn);
#line 1547
      rn->expire = now + r->resend_timeout;
#line 1549
      q->next = queue->next;
#line 1549
      (q->next)->prev = q;
#line 1549
      q->prev = queue;
#line 1549
      queue->next = q;
      }
#line 1551
      goto __Cont;
    }
    {
#line 1554
    ngx_rbtree_delete(tree, & rn->node);
#line 1556
    ngx_resolver_free_node(r, rn);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1561 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_uint_t ngx_resolver_resend_empty(ngx_resolver_t *r ) 
{ 
  int tmp ;

  {
#line 1564
  if ((unsigned long )(& r->name_resend_queue) == (unsigned long )r->name_resend_queue.prev) {
#line 1564
    if ((unsigned long )(& r->srv_resend_queue) == (unsigned long )r->srv_resend_queue.prev) {
#line 1564
      if ((unsigned long )(& r->addr6_resend_queue) == (unsigned long )r->addr6_resend_queue.prev) {
#line 1564
        if ((unsigned long )(& r->addr_resend_queue) == (unsigned long )r->addr_resend_queue.prev) {
#line 1564
          tmp = 1;
        } else {
#line 1564
          tmp = 0;
        }
      } else {
#line 1564
        tmp = 0;
      }
    } else {
#line 1564
      tmp = 0;
    }
  } else {
#line 1564
    tmp = 0;
  }
#line 1564
  return ((ngx_uint_t )tmp);
}
}
#line 1573 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_udp_read(ngx_event_t *rev ) 
{ 
  ssize_t n ;
  ngx_connection_t *c ;
  ngx_resolver_connection_t *rec ;
  u_char buf[4096] ;

  {
#line 1581
  c = (ngx_connection_t *)rev->data;
#line 1582
  rec = (ngx_resolver_connection_t *)c->data;
  {
#line 1584
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1585
    n = (*(ngx_io.udp_recv))(c, buf, (size_t___0 )4096);
    }
#line 1587
    if (n < 0L) {
#line 1588
      return;
    }
    {
#line 1591
    ngx_resolver_process_response(rec->resolver, buf, (size_t___0 )n, (ngx_uint_t )0);
    }
#line 1584
    if (! rev->ready) {
#line 1584
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1594
  return;
}
}
#line 1597 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_tcp_write(ngx_event_t *wev ) 
{ 
  off_t sent ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_resolver_t *r ;
  ngx_connection_t *c ;
  ngx_resolver_connection_t *rec ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1607
  c = (ngx_connection_t *)wev->data;
#line 1608
  rec = (ngx_resolver_connection_t *)c->data;
#line 1609
  b = rec->write_buf;
#line 1610
  r = rec->resolver;
#line 1612
  if (wev->timedout) {
#line 1613
    goto failed;
  }
#line 1616
  sent = c->sent;
  {
#line 1618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1618
    if (wev->ready) {
#line 1618
      if (! ((unsigned long )b->pos < (unsigned long )b->last)) {
#line 1618
        goto while_break;
      }
    } else {
#line 1618
      goto while_break;
    }
    {
#line 1619
    n = (*(ngx_io.send))(c, b->pos, (size_t___0 )(b->last - b->pos));
    }
#line 1621
    if (n == -2L) {
#line 1622
      goto while_break;
    }
#line 1625
    if (n == -1L) {
#line 1626
      goto failed;
    }
#line 1629
    b->pos += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 1632
  if ((unsigned long )b->pos != (unsigned long )b->start) {
    {
#line 1633
    tmp = memmove((void *)b->start, (void const   *)b->pos, (size_t )(b->last - b->pos));
#line 1633
    b->last = (u_char *)tmp + (b->last - b->pos);
#line 1634
    b->pos = b->start;
    }
  }
#line 1637
  if (c->sent != sent) {
    {
#line 1638
    ngx_event_add_timer(wev, (ngx_msec_t )(r->tcp_timeout * 1000L));
    }
  }
  {
#line 1641
  tmp___0 = ngx_handle_write_event(wev, (size_t___0 )0);
  }
#line 1641
  if (tmp___0 != 0L) {
#line 1642
    goto failed;
  }
#line 1645
  return;
  failed: 
  {
#line 1649
  ngx_close_connection(c);
#line 1650
  rec->tcp = (ngx_connection_t *)((void *)0);
  }
#line 1651
  return;
}
}
#line 1654 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_tcp_read(ngx_event_t *rev ) 
{ 
  u_char *p ;
  size_t___0 size ;
  ssize_t n ;
  u_short qlen ;
  ngx_buf_t *b ;
  ngx_resolver_t *r ;
  ngx_connection_t *c ;
  ngx_resolver_connection_t *rec ;
  u_char *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1666
  c = (ngx_connection_t *)rev->data;
#line 1667
  rec = (ngx_resolver_connection_t *)c->data;
#line 1668
  b = rec->read_buf;
#line 1669
  r = rec->resolver;
  {
#line 1671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1671
    if (! rev->ready) {
#line 1671
      goto while_break;
    }
    {
#line 1672
    n = (*(ngx_io.recv))(c, b->last, (size_t___0 )(b->end - b->last));
    }
#line 1674
    if (n == -2L) {
#line 1675
      goto while_break;
    }
#line 1678
    if (n == -1L) {
#line 1679
      goto failed;
    } else
#line 1678
    if (n == 0L) {
#line 1679
      goto failed;
    }
#line 1682
    b->last += n;
    {
#line 1684
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1685
      p = b->pos;
#line 1686
      size = (size_t___0 )(b->last - p);
#line 1688
      if (size < 2UL) {
#line 1689
        goto while_break___0;
      }
#line 1692
      tmp = p;
#line 1692
      p ++;
#line 1692
      qlen = (u_short )((int )((u_short )*tmp) << 8);
#line 1693
      tmp___0 = p;
#line 1693
      p ++;
#line 1693
      qlen = (u_short )((int )qlen + (int )*tmp___0);
#line 1695
      if (size < (size_t___0 )(2 + (int )qlen)) {
#line 1696
        goto while_break___0;
      }
      {
#line 1699
      ngx_resolver_process_response(r, p, (size_t___0 )qlen, (ngx_uint_t )1);
#line 1701
      b->pos += 2 + (int )qlen;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1704
    if ((unsigned long )b->pos != (unsigned long )b->start) {
      {
#line 1705
      tmp___1 = memmove((void *)b->start, (void const   *)b->pos, (size_t )(b->last - b->pos));
#line 1705
      b->last = (u_char *)tmp___1 + (b->last - b->pos);
#line 1706
      b->pos = b->start;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1710
  tmp___2 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 1710
  if (tmp___2 != 0L) {
#line 1711
    goto failed;
  }
#line 1714
  return;
  failed: 
  {
#line 1718
  ngx_close_connection(c);
#line 1719
  rec->tcp = (ngx_connection_t *)((void *)0);
  }
#line 1720
  return;
}
}
#line 1723 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_process_response(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                          ngx_uint_t tcp ) 
{ 
  char *err ;
  ngx_uint_t i ;
  ngx_uint_t times ;
  ngx_uint_t ident ;
  ngx_uint_t qident ;
  ngx_uint_t flags ;
  ngx_uint_t code ;
  ngx_uint_t nqs ;
  ngx_uint_t nan ;
  ngx_uint_t trunc ;
  ngx_uint_t qtype ;
  ngx_uint_t qclass ;
  ngx_uint_t qident6 ;
  ngx_queue_t *q ;
  ngx_resolver_qs_t *qs ;
  ngx_resolver_hdr_t *response ;
  ngx_resolver_node_t *rn ;
  char const   *tmp ;
  ngx_uint_t tmp___0 ;
  ngx_uint_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1738
  if (n < sizeof(ngx_resolver_hdr_t )) {
#line 1739
    goto short_response;
  }
#line 1742
  response = (ngx_resolver_hdr_t *)buf;
#line 1744
  ident = (ngx_uint_t )(((int )response->ident_hi << 8) + (int )response->ident_lo);
#line 1745
  flags = (ngx_uint_t )(((int )response->flags_hi << 8) + (int )response->flags_lo);
#line 1746
  nqs = (ngx_uint_t )(((int )response->nqs_hi << 8) + (int )response->nqs_lo);
#line 1747
  nan = (ngx_uint_t )(((int )response->nan_hi << 8) + (int )response->nan_lo);
#line 1748
  trunc = flags & 512UL;
#line 1757
  if ((flags & 63600UL) != 32768UL) {
#line 1757
    goto _L;
  } else
#line 1757
  if (trunc) {
#line 1757
    if (tcp) {
      _L: /* CIL Label */ 
#line 1758
      if ((r->log)->log_level >= r->log_level) {
#line 1758
        if (tcp) {
#line 1758
          tmp = "TCP";
        } else {
#line 1758
          tmp = "UDP";
        }
        {
#line 1758
        ngx_log_error_core(r->log_level, r->log, 0, "invalid %s DNS response %ui fl:%04Xi",
                           tmp, ident, flags);
        }
      }
#line 1761
      return;
    }
  }
#line 1764
  code = flags & 15UL;
#line 1766
  if (code == 1UL) {
#line 1768
    times = (ngx_uint_t )0;
#line 1770
    q = r->name_resend_queue.next;
    {
#line 1770
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1770
      if ((unsigned long )q != (unsigned long )(& r->name_resend_queue)) {
#line 1770
        tmp___0 = times;
#line 1770
        times ++;
#line 1770
        if (! (tmp___0 < 100UL)) {
#line 1770
          goto while_break;
        }
      } else {
#line 1770
        goto while_break;
      }
#line 1774
      rn = (ngx_resolver_node_t *)((u_char *)q - (unsigned long )(& ((ngx_resolver_node_t *)0)->queue));
#line 1775
      qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
#line 1777
      if (qident == ident) {
#line 1778
        goto dns_error_name;
      }
#line 1782
      if (rn->query6) {
#line 1783
        qident6 = (ngx_uint_t )(((int )*(rn->query6 + 0) << 8) + (int )*(rn->query6 + 1));
#line 1785
        if (qident6 == ident) {
#line 1786
          goto dns_error_name;
        }
      }
#line 1770
      q = q->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1792
    goto dns_error;
  }
#line 1795
  if (code > 5UL) {
#line 1796
    goto dns_error;
  }
#line 1799
  if (nqs != 1UL) {
#line 1800
    err = (char *)"invalid number of questions in DNS response";
#line 1801
    goto done;
  }
#line 1804
  i = sizeof(ngx_resolver_hdr_t );
  {
#line 1806
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1806
    if (! (i < n)) {
#line 1806
      goto while_break___0;
    }
#line 1807
    if ((int )*(buf + i) == 0) {
#line 1808
      goto found;
    }
#line 1811
    i += (ngx_uint_t )(1 + (int )*(buf + i));
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1814
  goto short_response;
  found: 
#line 1818
  tmp___1 = i;
#line 1818
  i ++;
#line 1818
  if (tmp___1 == sizeof(ngx_resolver_hdr_t )) {
#line 1819
    err = (char *)"zero-length domain name in DNS response";
#line 1820
    goto done;
  }
#line 1823
  if ((i + sizeof(ngx_resolver_qs_t )) + nan * (2UL + sizeof(ngx_resolver_an_t )) > n) {
#line 1826
    goto short_response;
  }
#line 1829
  qs = (ngx_resolver_qs_t *)(buf + i);
#line 1831
  qtype = (ngx_uint_t )(((int )qs->type_hi << 8) + (int )qs->type_lo);
#line 1832
  qclass = (ngx_uint_t )(((int )qs->class_hi << 8) + (int )qs->class_lo);
#line 1837
  if (qclass != 1UL) {
#line 1838
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1838
      ngx_log_error_core(r->log_level, r->log, 0, "unknown query class %ui in DNS response",
                         qclass);
      }
    }
#line 1840
    return;
  }
  {
#line 1847
  if (qtype == 28UL) {
#line 1847
    goto case_28;
  }
#line 1847
  if (qtype == 1UL) {
#line 1847
    goto case_28;
  }
#line 1855
  if (qtype == 33UL) {
#line 1855
    goto case_33;
  }
#line 1862
  if (qtype == 12UL) {
#line 1862
    goto case_12;
  }
#line 1868
  goto switch_default;
  case_28: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1850
  ngx_resolver_process_a(r, buf, n, ident, code, qtype, nan, trunc, i + sizeof(ngx_resolver_qs_t ));
  }
#line 1853
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 1857
  ngx_resolver_process_srv(r, buf, n, ident, code, nan, trunc, i + sizeof(ngx_resolver_qs_t ));
  }
#line 1860
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1864
  ngx_resolver_process_ptr(r, buf, n, ident, code, nan);
  }
#line 1866
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1869
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1869
    ngx_log_error_core(r->log_level, r->log, 0, "unknown query type %ui in DNS response",
                       qtype);
    }
  }
#line 1871
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1874
  return;
  short_response: 
#line 1878
  err = (char *)"short DNS response";
  done: 
#line 1882
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1882
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 1884
  return;
  dns_error_name: 
#line 1888
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1888
    tmp___2 = ngx_resolver_strerror((ngx_int_t )code);
#line 1888
    ngx_log_error_core(r->log_level, r->log, 0, "DNS error (%ui: %s), query id:%ui, name:\"%*s\"",
                       code, tmp___2, ident, (size_t___0 )rn->nlen, rn->name);
    }
  }
#line 1892
  return;
  dns_error: 
#line 1896
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1896
    tmp___3 = ngx_resolver_strerror((ngx_int_t )code);
#line 1896
    ngx_log_error_core(r->log_level, r->log, 0, "DNS error (%ui: %s), query id:%ui",
                       code, tmp___3, ident);
    }
  }
#line 1899
  return;
}
}
#line 1903 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_process_a(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                   ngx_uint_t ident , ngx_uint_t code , ngx_uint_t qtype ,
                                   ngx_uint_t nan , ngx_uint_t trunc , ngx_uint_t ans ) 
{ 
  char *err ;
  u_char *cname ;
  size_t___0 len ;
  int32_t ttl ;
  uint32_t hash ;
  in_addr_t *addr ;
  ngx_str_t name ;
  ngx_uint_t type ;
  ngx_uint_t class ;
  ngx_uint_t qident ;
  ngx_uint_t naddrs ;
  ngx_uint_t a ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t start ;
  struct in6_addr *addr6 ;
  ngx_resolver_an_t *an ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_addr_t *addrs ;
  ngx_resolver_connection_t *rec ;
  ngx_int_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int __v ;
  unsigned int __x ;
  time_t tmp___3 ;
  ngx_int_t tmp___4 ;
  time_t tmp___5 ;
  ngx_uint_t tmp___6 ;

  {
  {
#line 1925
  tmp = ngx_resolver_copy(r, & name, buf, buf + sizeof(ngx_resolver_hdr_t ), buf + n);
  }
#line 1925
  if (tmp != 0L) {
#line 1929
    return;
  }
  {
#line 1934
  hash = ngx_crc32_short(name.data, name.len);
#line 1938
  rn = ngx_resolver_lookup_name(r, & name, hash);
  }
#line 1940
  if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 1941
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1941
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 1943
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1944
    goto failed;
  }
  {
#line 1950
  if (qtype == 28UL) {
#line 1950
    goto case_28;
  }
#line 1969
  goto switch_default;
  case_28: /* CIL Label */ 
#line 1952
  if ((unsigned long )rn->query6 == (unsigned long )((void *)0)) {
#line 1952
    goto _L;
  } else
#line 1952
  if ((int )rn->naddrs6 != 65535) {
    _L: /* CIL Label */ 
#line 1953
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1953
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 1955
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1956
    goto failed;
  }
#line 1959
  if (trunc) {
#line 1959
    if (rn->tcp6) {
      {
#line 1960
      ngx_resolver_free(r, (void *)name.data);
      }
#line 1961
      goto failed;
    }
  }
#line 1964
  qident = (ngx_uint_t )(((int )*(rn->query6 + 0) << 8) + (int )*(rn->query6 + 1));
#line 1966
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1971
  if ((unsigned long )rn->query == (unsigned long )((void *)0)) {
#line 1971
    goto _L___0;
  } else
#line 1971
  if ((int )rn->naddrs != 65535) {
    _L___0: /* CIL Label */ 
#line 1972
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1972
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 1974
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1975
    goto failed;
  }
#line 1978
  if (trunc) {
#line 1978
    if (rn->tcp) {
      {
#line 1979
      ngx_resolver_free(r, (void *)name.data);
      }
#line 1980
      goto failed;
    }
  }
#line 1983
  qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
  switch_break: /* CIL Label */ ;
  }
#line 1986
  if (ident != qident) {
#line 1987
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1987
      ngx_log_error_core(r->log_level, r->log, 0, "wrong ident %ui response for %V, expect %ui",
                         ident, & name, qident);
      }
    }
    {
#line 1990
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1991
    goto failed;
  }
  {
#line 1994
  ngx_resolver_free(r, (void *)name.data);
  }
#line 1996
  if (trunc) {
#line 1998
    (rn->queue.next)->prev = rn->queue.prev;
#line 1998
    (rn->queue.prev)->next = rn->queue.next;
#line 2000
    if ((unsigned long )rn->waiting == (unsigned long )((void *)0)) {
      {
#line 2001
      ngx_rbtree_delete(& r->name_rbtree, & rn->node);
#line 2002
      ngx_resolver_free_node(r, rn);
      }
#line 2003
      goto failed;
    }
#line 2006
    rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 2007
    rec += rn->last_connection;
    {
#line 2012
    if (qtype == 28UL) {
#line 2012
      goto case_28___0;
    }
#line 2021
    goto switch_default___0;
    case_28___0: /* CIL Label */ 
    {
#line 2014
    rn->tcp6 = 1U;
#line 2016
    ngx_resolver_send_tcp_query(r, rec, rn->query6, rn->qlen);
    }
#line 2018
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2023
    rn->tcp = 1U;
#line 2025
    ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 2028
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 2030
    rn->queue.next = r->name_resend_queue.next;
#line 2030
    (rn->queue.next)->prev = & rn->queue;
#line 2030
    rn->queue.prev = & r->name_resend_queue;
#line 2030
    r->name_resend_queue.next = & rn->queue;
#line 2032
    goto failed;
  }
#line 2035
  if (code == 0UL) {
#line 2035
    if (rn->code) {
#line 2036
      code = (ngx_uint_t )rn->code;
    }
  }
#line 2039
  if (code == 0UL) {
#line 2039
    if (nan == 0UL) {
      {
#line 2044
      if (qtype == 28UL) {
#line 2044
        goto case_28___1;
      }
#line 2058
      goto switch_default___1;
      case_28___1: /* CIL Label */ 
#line 2046
      rn->naddrs6 = (u_short )0;
#line 2048
      if ((int )rn->naddrs == 65535) {
#line 2049
        goto failed;
      }
#line 2052
      if (rn->naddrs) {
#line 2053
        goto export;
      }
#line 2056
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 2060
      rn->naddrs = (u_short )0;
#line 2062
      if ((int )rn->naddrs6 == 65535) {
#line 2063
        goto failed;
      }
#line 2066
      if (rn->naddrs6) {
#line 2067
        goto export;
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 2072
      code = (ngx_uint_t )3;
    }
  }
#line 2075
  if (code) {
    {
#line 2080
    if (qtype == 28UL) {
#line 2080
      goto case_28___2;
    }
#line 2091
    goto switch_default___2;
    case_28___2: /* CIL Label */ 
#line 2082
    rn->naddrs6 = (u_short )0;
#line 2084
    if ((int )rn->naddrs == 65535) {
#line 2085
      rn->code = (u_char )code;
#line 2086
      goto failed;
    }
#line 2089
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2093
    rn->naddrs = (u_short )0;
#line 2095
    if ((int )rn->naddrs6 == 65535) {
#line 2096
      rn->code = (u_char )code;
#line 2097
      goto failed;
    }
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 2102
    next = rn->waiting;
#line 2103
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
#line 2105
    (rn->queue.next)->prev = rn->queue.prev;
#line 2105
    (rn->queue.prev)->next = rn->queue.next;
#line 2107
    ngx_rbtree_delete(& r->name_rbtree, & rn->node);
    }
    {
#line 2111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2111
      if (! next) {
#line 2111
        goto while_break;
      }
#line 2112
      ctx = next;
#line 2113
      ctx->state = (ngx_int_t )code;
#line 2114
      if (r->valid) {
#line 2114
        tmp___0 = r->valid;
      } else {
#line 2114
        tmp___0 = (time_t )10;
      }
      {
#line 2114
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___0);
#line 2115
      next = ctx->next;
#line 2117
      (*(ctx->handler))(ctx);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2120
    ngx_resolver_free_node(r, rn);
    }
#line 2122
    return;
  }
#line 2125
  i = ans;
#line 2126
  naddrs = (ngx_uint_t )0;
#line 2127
  cname = (u_char *)((void *)0);
#line 2129
  a = (ngx_uint_t )0;
  {
#line 2129
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2129
    if (! (a < nan)) {
#line 2129
      goto while_break___0;
    }
#line 2131
    start = i;
    {
#line 2133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2133
      if (! (i < n)) {
#line 2133
        goto while_break___1;
      }
#line 2135
      if ((int )*(buf + i) & 192) {
#line 2136
        i += 2UL;
#line 2137
        goto found;
      }
#line 2140
      if ((int )*(buf + i) == 0) {
#line 2141
        i ++;
#line 2142
        goto test_length;
      }
#line 2145
      i += (ngx_uint_t )(1 + (int )*(buf + i));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2148
    goto short_response;
    test_length: 
#line 2152
    if (i - start < 2UL) {
#line 2153
      err = (char *)"invalid name in DNS response";
#line 2154
      goto invalid;
    }
    found: 
#line 2159
    if (i + sizeof(ngx_resolver_an_t ) >= n) {
#line 2160
      goto short_response;
    }
#line 2163
    an = (ngx_resolver_an_t *)(buf + i);
#line 2165
    type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2166
    class = (ngx_uint_t )(((int )an->class_hi << 8) + (int )an->class_lo);
#line 2167
    len = (size_t___0 )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2168
    ttl = ((((int )an->ttl[0] << 24) + ((int )an->ttl[1] << 16)) + ((int )an->ttl[2] << 8)) + (int )an->ttl[3];
#line 2171
    if (class != 1UL) {
#line 2172
      if ((r->log)->log_level >= r->log_level) {
        {
#line 2172
        ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR class %ui", class);
        }
      }
#line 2174
      goto failed;
    }
#line 2177
    if (ttl < 0) {
#line 2178
      ttl = 0;
    }
#line 2181
    if (rn->ttl > (uint32_t )ttl) {
#line 2181
      rn->ttl = (uint32_t )ttl;
    } else {
#line 2181
      rn->ttl = rn->ttl;
    }
#line 2183
    i += sizeof(ngx_resolver_an_t );
    {
#line 2187
    if (type == 1UL) {
#line 2187
      goto case_1;
    }
#line 2208
    if (type == 28UL) {
#line 2208
      goto case_28___3;
    }
#line 2229
    if (type == 5UL) {
#line 2229
      goto case_5;
    }
#line 2235
    if (type == 39UL) {
#line 2235
      goto case_39;
    }
#line 2239
    goto switch_default___3;
    case_1: /* CIL Label */ 
#line 2189
    if (qtype != 1UL) {
#line 2190
      err = (char *)"unexpected A record in DNS response";
#line 2191
      goto invalid;
    }
#line 2194
    if (len != 4UL) {
#line 2195
      err = (char *)"invalid A record in DNS response";
#line 2196
      goto invalid;
    }
#line 2199
    if (i + 4UL > n) {
#line 2200
      goto short_response;
    }
#line 2203
    naddrs ++;
#line 2205
    goto switch_break___3;
    case_28___3: /* CIL Label */ 
#line 2210
    if (qtype != 28UL) {
#line 2211
      err = (char *)"unexpected AAAA record in DNS response";
#line 2212
      goto invalid;
    }
#line 2215
    if (len != 16UL) {
#line 2216
      err = (char *)"invalid AAAA record in DNS response";
#line 2217
      goto invalid;
    }
#line 2220
    if (i + 16UL > n) {
#line 2221
      goto short_response;
    }
#line 2224
    naddrs ++;
#line 2226
    goto switch_break___3;
    case_5: /* CIL Label */ 
#line 2231
    cname = buf + i;
#line 2233
    goto switch_break___3;
    case_39: /* CIL Label */ 
#line 2237
    goto switch_break___3;
    switch_default___3: /* CIL Label */ 
#line 2241
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2241
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR type %ui", type);
      }
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 2245
    i += len;
#line 2129
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2252
  if (naddrs) {
    {
#line 2257
    if (qtype == 28UL) {
#line 2257
      goto case_28___4;
    }
#line 2280
    goto switch_default___4;
    case_28___4: /* CIL Label */ 
#line 2259
    if (naddrs == 1UL) {
#line 2260
      addr6 = & rn->u6.addr6;
#line 2261
      rn->naddrs6 = (u_short )1;
    } else {
      {
#line 2264
      tmp___1 = ngx_resolver_alloc(r, naddrs * sizeof(struct in6_addr ));
#line 2264
      addr6 = (struct in6_addr *)tmp___1;
      }
#line 2265
      if ((unsigned long )addr6 == (unsigned long )((void *)0)) {
#line 2266
        goto failed;
      }
#line 2269
      rn->u6.addrs6 = addr6;
#line 2270
      rn->naddrs6 = (u_short )naddrs;
    }
#line 2274
    addr = (in_addr_t *)((void *)0);
#line 2277
    goto switch_break___4;
    switch_default___4: /* CIL Label */ 
#line 2282
    if (naddrs == 1UL) {
#line 2283
      addr = & rn->u.addr;
#line 2284
      rn->naddrs = (u_short )1;
    } else {
      {
#line 2287
      tmp___2 = ngx_resolver_alloc(r, naddrs * sizeof(in_addr_t ));
#line 2287
      addr = (in_addr_t *)tmp___2;
      }
#line 2288
      if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 2289
        goto failed;
      }
#line 2292
      rn->u.addrs = addr;
#line 2293
      rn->naddrs = (u_short )naddrs;
    }
#line 2297
    addr6 = (struct in6_addr *)((void *)0);
    switch_break___4: /* CIL Label */ ;
    }
#line 2301
    j = (ngx_uint_t )0;
#line 2302
    i = ans;
#line 2304
    a = (ngx_uint_t )0;
    {
#line 2304
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2304
      if (! (a < nan)) {
#line 2304
        goto while_break___2;
      }
      {
#line 2306
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2308
        if ((int )*(buf + i) & 192) {
#line 2309
          i += 2UL;
#line 2310
          goto while_break___3;
        }
#line 2313
        if ((int )*(buf + i) == 0) {
#line 2314
          i ++;
#line 2315
          goto while_break___3;
        }
#line 2318
        i += (ngx_uint_t )(1 + (int )*(buf + i));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2321
      an = (ngx_resolver_an_t *)(buf + i);
#line 2323
      type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2324
      len = (size_t___0 )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2326
      i += sizeof(ngx_resolver_an_t );
#line 2328
      if (type == 1UL) {
#line 2330
        __x = (unsigned int )(((((int )*(buf + i) << 24) + ((int )*(buf + (i + 1UL)) << 16)) + ((int )*(buf + (i + 2UL)) << 8)) + (int )*(buf + (i + 3UL)));
#line 2330
        __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 2330
        *(addr + j) = __v;
#line 2333
        j ++;
#line 2333
        if (j == naddrs) {
#line 2336
          if ((int )rn->naddrs6 == 65535) {
#line 2337
            goto failed;
          }
#line 2341
          goto while_break___2;
        }
      } else
#line 2346
      if (type == 28UL) {
        {
#line 2348
        memcpy((void */* __restrict  */)((addr6 + j)->__in6_u.__u6_addr8), (void const   */* __restrict  */)(buf + i),
               (size_t )16);
#line 2350
        j ++;
        }
#line 2350
        if (j == naddrs) {
#line 2352
          if ((int )rn->naddrs == 65535) {
#line 2353
            goto failed;
          }
#line 2356
          goto while_break___2;
        }
      }
#line 2361
      i += len;
#line 2304
      a ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2368
  if (qtype == 28UL) {
#line 2368
    goto case_28___5;
  }
#line 2377
  goto switch_default___5;
  case_28___5: /* CIL Label */ 
#line 2370
  if ((int )rn->naddrs6 == 65535) {
#line 2371
    rn->naddrs6 = (u_short )0;
  }
#line 2374
  goto switch_break___5;
  switch_default___5: /* CIL Label */ 
#line 2379
  if ((int )rn->naddrs == 65535) {
#line 2380
    rn->naddrs = (u_short )0;
  }
  switch_break___5: /* CIL Label */ ;
  }
#line 2384
  if ((int )rn->naddrs != 65535) {
#line 2384
    if ((int )rn->naddrs6 != 65535) {
#line 2384
      if ((int )rn->naddrs + (int )rn->naddrs6 > 0) {
        export: 
#line 2399
        naddrs = (ngx_uint_t )rn->naddrs;
#line 2401
        naddrs += (ngx_uint_t )rn->naddrs6;
#line 2404
        if (naddrs == 1UL) {
#line 2404
          if ((int )rn->naddrs == 1) {
#line 2405
            addrs = (ngx_resolver_addr_t *)((void *)0);
          } else {
#line 2404
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 2408
          addrs = ngx_resolver_export(r, rn, (ngx_uint_t )0);
          }
#line 2409
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
#line 2410
            goto failed;
          }
        }
#line 2414
        (rn->queue.next)->prev = rn->queue.prev;
#line 2414
        (rn->queue.prev)->next = rn->queue.next;
#line 2416
        if (r->valid) {
#line 2416
          tmp___3 = r->valid;
        } else {
#line 2416
          tmp___3 = (time_t )rn->ttl;
        }
#line 2416
        rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___3);
#line 2417
        rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2419
        rn->queue.next = r->name_expire_queue.next;
#line 2419
        (rn->queue.next)->prev = & rn->queue;
#line 2419
        rn->queue.prev = & r->name_expire_queue;
#line 2419
        r->name_expire_queue.next = & rn->queue;
#line 2421
        next = rn->waiting;
#line 2422
        rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
        {
#line 2426
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2426
          if (! next) {
#line 2426
            goto while_break___4;
          }
#line 2427
          ctx = next;
#line 2428
          ctx->state = (ngx_int_t )0;
#line 2429
          ctx->valid = rn->valid;
#line 2430
          ctx->naddrs = naddrs;
#line 2432
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
            {
#line 2433
            ctx->addrs = & ctx->addr;
#line 2434
            ctx->addr.sockaddr = (struct sockaddr *)(& ctx->sin);
#line 2435
            ctx->addr.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 2436
            memset((void *)(& ctx->sin), 0, sizeof(struct sockaddr_in ));
#line 2437
            ctx->sin.sin_family = (sa_family_t )2;
#line 2438
            ctx->sin.sin_addr.s_addr = rn->u.addr;
            }
          } else {
#line 2441
            ctx->addrs = addrs;
          }
          {
#line 2444
          next = ctx->next;
#line 2446
          (*(ctx->handler))(ctx);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2449
        if ((unsigned long )addrs != (unsigned long )((void *)0)) {
          {
#line 2450
          ngx_resolver_free(r, (void *)addrs->sockaddr);
#line 2451
          ngx_resolver_free(r, (void *)addrs);
          }
        }
        {
#line 2454
        ngx_resolver_free(r, (void *)rn->query);
#line 2455
        rn->query = (u_char *)((void *)0);
#line 2457
        rn->query6 = (u_char *)((void *)0);
        }
#line 2460
        return;
      }
    }
  }
#line 2463
  if (cname) {
#line 2467
    if ((int )rn->naddrs == 65535) {
#line 2473
      goto failed;
    } else
#line 2467
    if ((int )rn->naddrs6 == 65535) {
#line 2473
      goto failed;
    }
    {
#line 2476
    tmp___4 = ngx_resolver_copy(r, & name, buf, cname, buf + n);
    }
#line 2476
    if (tmp___4 != 0L) {
#line 2477
      goto failed;
    }
#line 2483
    (rn->queue.next)->prev = rn->queue.prev;
#line 2483
    (rn->queue.prev)->next = rn->queue.next;
#line 2485
    rn->cnlen = (u_short )name.len;
#line 2486
    rn->u.cname = name.data;
#line 2488
    if (r->valid) {
#line 2488
      tmp___5 = r->valid;
    } else {
#line 2488
      tmp___5 = (time_t )rn->ttl;
    }
    {
#line 2488
    rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___5);
#line 2489
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2491
    rn->queue.next = r->name_expire_queue.next;
#line 2491
    (rn->queue.next)->prev = & rn->queue;
#line 2491
    rn->queue.prev = & r->name_expire_queue;
#line 2491
    r->name_expire_queue.next = & rn->queue;
#line 2493
    ngx_resolver_free(r, (void *)rn->query);
#line 2494
    rn->query = (u_char *)((void *)0);
#line 2496
    rn->query6 = (u_char *)((void *)0);
#line 2499
    ctx = rn->waiting;
#line 2500
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
    }
#line 2502
    if (ctx) {
#line 2504
      tmp___6 = ctx->recursion;
#line 2504
      (ctx->recursion) ++;
#line 2504
      if (tmp___6 >= 50UL) {
        {
#line 2508
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 2509
          ctx->state = (ngx_int_t )3;
#line 2510
          next = ctx->next;
#line 2512
          (*(ctx->handler))(ctx);
#line 2514
          ctx = next;
          }
#line 2508
          if (! ctx) {
#line 2508
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2517
        return;
      }
#line 2520
      next = ctx;
      {
#line 2520
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2520
        if (! next) {
#line 2520
          goto while_break___6;
        }
#line 2521
        next->node = (ngx_resolver_node_t *)((void *)0);
#line 2520
        next = next->next;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2524
      ngx_resolve_name_locked(r, ctx, & name);
      }
    }
#line 2529
    return;
  }
#line 2532
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2532
    ngx_log_error_core(r->log_level, r->log, 0, "no A or CNAME types in DNS response");
    }
  }
#line 2534
  return;
  short_response: 
#line 2538
  err = (char *)"short DNS response";
  invalid: 
#line 2544
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2544
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 2546
  return;
  failed: 
#line 2554
  return;
}
}
#line 2558 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_process_srv(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ,
                                     ngx_uint_t trunc , ngx_uint_t ans ) 
{ 
  char *err ;
  u_char *cname ;
  size_t___0 len ;
  int32_t ttl ;
  uint32_t hash ;
  ngx_str_t name ;
  ngx_uint_t type ;
  ngx_uint_t qident ;
  ngx_uint_t class ;
  ngx_uint_t start ;
  ngx_uint_t nsrvs ;
  ngx_uint_t a ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_resolver_an_t *an ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_srv_t *srvs ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_connection_t *rec ;
  ngx_int_t tmp ;
  time_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  time_t tmp___4 ;
  ngx_int_t tmp___5 ;
  time_t tmp___6 ;
  ngx_uint_t tmp___7 ;

  {
  {
#line 2576
  tmp = ngx_resolver_copy(r, & name, buf, buf + sizeof(ngx_resolver_hdr_t ), buf + n);
  }
#line 2576
  if (tmp != 0L) {
#line 2580
    return;
  }
  {
#line 2585
  hash = ngx_crc32_short(name.data, name.len);
#line 2587
  rn = ngx_resolver_lookup_srv(r, & name, hash);
  }
#line 2589
  if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 2589
    goto _L;
  } else
#line 2589
  if ((unsigned long )rn->query == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 2590
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2590
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 2592
    ngx_resolver_free(r, (void *)name.data);
    }
#line 2593
    goto failed;
  }
#line 2596
  if (trunc) {
#line 2596
    if (rn->tcp) {
      {
#line 2597
      ngx_resolver_free(r, (void *)name.data);
      }
#line 2598
      goto failed;
    }
  }
#line 2601
  qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
#line 2603
  if (ident != qident) {
#line 2604
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2604
      ngx_log_error_core(r->log_level, r->log, 0, "wrong ident %ui response for %V, expect %ui",
                         ident, & name, qident);
      }
    }
    {
#line 2607
    ngx_resolver_free(r, (void *)name.data);
    }
#line 2608
    goto failed;
  }
  {
#line 2611
  ngx_resolver_free(r, (void *)name.data);
  }
#line 2613
  if (trunc) {
#line 2615
    (rn->queue.next)->prev = rn->queue.prev;
#line 2615
    (rn->queue.prev)->next = rn->queue.next;
#line 2617
    if ((unsigned long )rn->waiting == (unsigned long )((void *)0)) {
      {
#line 2618
      ngx_rbtree_delete(& r->srv_rbtree, & rn->node);
#line 2619
      ngx_resolver_free_node(r, rn);
      }
#line 2620
      return;
    }
    {
#line 2623
    rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 2624
    rec += rn->last_connection;
#line 2626
    rn->tcp = 1U;
#line 2628
    ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen);
#line 2630
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 2632
    rn->queue.next = r->srv_resend_queue.next;
#line 2632
    (rn->queue.next)->prev = & rn->queue;
#line 2632
    rn->queue.prev = & r->srv_resend_queue;
#line 2632
    r->srv_resend_queue.next = & rn->queue;
    }
#line 2634
    return;
  }
#line 2637
  if (code == 0UL) {
#line 2637
    if (rn->code) {
#line 2638
      code = (ngx_uint_t )rn->code;
    }
  }
#line 2641
  if (code == 0UL) {
#line 2641
    if (nan == 0UL) {
#line 2642
      code = (ngx_uint_t )3;
    }
  }
#line 2645
  if (code) {
    {
#line 2646
    next = rn->waiting;
#line 2647
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
#line 2649
    (rn->queue.next)->prev = rn->queue.prev;
#line 2649
    (rn->queue.prev)->next = rn->queue.next;
#line 2651
    ngx_rbtree_delete(& r->srv_rbtree, & rn->node);
    }
    {
#line 2653
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2653
      if (! next) {
#line 2653
        goto while_break;
      }
#line 2654
      ctx = next;
#line 2655
      ctx->state = (ngx_int_t )code;
#line 2656
      if (r->valid) {
#line 2656
        tmp___0 = r->valid;
      } else {
#line 2656
        tmp___0 = (time_t )10;
      }
      {
#line 2656
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___0);
#line 2657
      next = ctx->next;
#line 2659
      (*(ctx->handler))(ctx);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2662
    ngx_resolver_free_node(r, rn);
    }
#line 2664
    return;
  }
#line 2667
  i = ans;
#line 2668
  nsrvs = (ngx_uint_t )0;
#line 2669
  cname = (u_char *)((void *)0);
#line 2671
  a = (ngx_uint_t )0;
  {
#line 2671
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2671
    if (! (a < nan)) {
#line 2671
      goto while_break___0;
    }
#line 2673
    start = i;
    {
#line 2675
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2675
      if (! (i < n)) {
#line 2675
        goto while_break___1;
      }
#line 2677
      if ((int )*(buf + i) & 192) {
#line 2678
        i += 2UL;
#line 2679
        goto found;
      }
#line 2682
      if ((int )*(buf + i) == 0) {
#line 2683
        i ++;
#line 2684
        goto test_length;
      }
#line 2687
      i += (ngx_uint_t )(1 + (int )*(buf + i));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2690
    goto short_response;
    test_length: 
#line 2694
    if (i - start < 2UL) {
#line 2695
      err = (char *)"invalid name DNS response";
#line 2696
      goto invalid;
    }
    found: 
#line 2701
    if (i + sizeof(ngx_resolver_an_t ) >= n) {
#line 2702
      goto short_response;
    }
#line 2705
    an = (ngx_resolver_an_t *)(buf + i);
#line 2707
    type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2708
    class = (ngx_uint_t )(((int )an->class_hi << 8) + (int )an->class_lo);
#line 2709
    len = (size_t___0 )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2710
    ttl = ((((int )an->ttl[0] << 24) + ((int )an->ttl[1] << 16)) + ((int )an->ttl[2] << 8)) + (int )an->ttl[3];
#line 2713
    if (class != 1UL) {
#line 2714
      if ((r->log)->log_level >= r->log_level) {
        {
#line 2714
        ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR class %ui", class);
        }
      }
#line 2716
      goto failed;
    }
#line 2719
    if (ttl < 0) {
#line 2720
      ttl = 0;
    }
#line 2723
    if (rn->ttl > (uint32_t )ttl) {
#line 2723
      rn->ttl = (uint32_t )ttl;
    } else {
#line 2723
      rn->ttl = rn->ttl;
    }
#line 2725
    i += sizeof(ngx_resolver_an_t );
    {
#line 2729
    if (type == 33UL) {
#line 2729
      goto case_33;
    }
#line 2745
    if (type == 5UL) {
#line 2745
      goto case_5;
    }
#line 2751
    if (type == 39UL) {
#line 2751
      goto case_39;
    }
#line 2755
    goto switch_default;
    case_33: /* CIL Label */ 
#line 2731
    if (i + 6UL > n) {
#line 2732
      goto short_response;
    }
    {
#line 2735
    tmp___1 = ngx_resolver_copy(r, (ngx_str_t *)((void *)0), buf, buf + (i + 6UL),
                                buf + n);
    }
#line 2735
    if (tmp___1 != 0L) {
#line 2738
      goto failed;
    }
#line 2741
    nsrvs ++;
#line 2743
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2747
    cname = buf + i;
#line 2749
    goto switch_break;
    case_39: /* CIL Label */ 
#line 2753
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2757
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2757
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR type %ui", type);
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 2761
    i += len;
#line 2671
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2768
  if (nsrvs) {
    {
#line 2770
    tmp___2 = ngx_resolver_calloc(r, nsrvs * sizeof(ngx_resolver_srv_t ));
#line 2770
    srvs = (ngx_resolver_srv_t *)tmp___2;
    }
#line 2771
    if ((unsigned long )srvs == (unsigned long )((void *)0)) {
#line 2772
      goto failed;
    }
#line 2775
    rn->u.srvs = srvs;
#line 2776
    rn->nsrvs = (u_short )nsrvs;
#line 2778
    j = (ngx_uint_t )0;
#line 2779
    i = ans;
#line 2781
    a = (ngx_uint_t )0;
    {
#line 2781
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2781
      if (! (a < nan)) {
#line 2781
        goto while_break___2;
      }
      {
#line 2783
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2785
        if ((int )*(buf + i) & 192) {
#line 2786
          i += 2UL;
#line 2787
          goto while_break___3;
        }
#line 2790
        if ((int )*(buf + i) == 0) {
#line 2791
          i ++;
#line 2792
          goto while_break___3;
        }
#line 2795
        i += (ngx_uint_t )(1 + (int )*(buf + i));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2798
      an = (ngx_resolver_an_t *)(buf + i);
#line 2800
      type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2801
      len = (size_t___0 )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2803
      i += sizeof(ngx_resolver_an_t );
#line 2805
      if (type == 33UL) {
#line 2807
        (srvs + j)->priority = (u_short )(((int )*(buf + i) << 8) + (int )*(buf + (i + 1UL)));
#line 2808
        (srvs + j)->weight = (u_short )(((int )*(buf + (i + 2UL)) << 8) + (int )*(buf + (i + 3UL)));
#line 2810
        if ((int )(srvs + j)->weight == 0) {
#line 2811
          (srvs + j)->weight = (u_short )1;
        }
        {
#line 2814
        (srvs + j)->port = (u_short )(((int )*(buf + (i + 4UL)) << 8) + (int )*(buf + (i + 5UL)));
#line 2816
        tmp___3 = ngx_resolver_copy(r, & (srvs + j)->name, buf, buf + (i + 6UL), buf + n);
        }
#line 2816
        if (tmp___3 != 0L) {
#line 2820
          goto failed;
        }
#line 2823
        j ++;
      }
#line 2826
      i += len;
#line 2781
      a ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2829
    ngx_sort((void *)srvs, nsrvs, sizeof(ngx_resolver_srv_t ), & ngx_resolver_cmp_srvs);
#line 2832
    ngx_resolver_free(r, (void *)rn->query);
#line 2833
    rn->query = (u_char *)((void *)0);
#line 2835
    (rn->queue.next)->prev = rn->queue.prev;
#line 2835
    (rn->queue.prev)->next = rn->queue.next;
    }
#line 2837
    if (r->valid) {
#line 2837
      tmp___4 = r->valid;
    } else {
#line 2837
      tmp___4 = (time_t )rn->ttl;
    }
#line 2837
    rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___4);
#line 2838
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2840
    rn->queue.next = r->srv_expire_queue.next;
#line 2840
    (rn->queue.next)->prev = & rn->queue;
#line 2840
    rn->queue.prev = & r->srv_expire_queue;
#line 2840
    r->srv_expire_queue.next = & rn->queue;
#line 2842
    next = rn->waiting;
#line 2843
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
    {
#line 2845
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2845
      if (! next) {
#line 2845
        goto while_break___4;
      }
      {
#line 2846
      ctx = next;
#line 2847
      next = ctx->next;
#line 2849
      ngx_resolver_resolve_srv_names(ctx, rn);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2852
    return;
  }
#line 2855
  rn->nsrvs = (u_short )0;
#line 2857
  if (cname) {
    {
#line 2861
    tmp___5 = ngx_resolver_copy(r, & name, buf, cname, buf + n);
    }
#line 2861
    if (tmp___5 != 0L) {
#line 2862
      goto failed;
    }
#line 2868
    (rn->queue.next)->prev = rn->queue.prev;
#line 2868
    (rn->queue.prev)->next = rn->queue.next;
#line 2870
    rn->cnlen = (u_short )name.len;
#line 2871
    rn->u.cname = name.data;
#line 2873
    if (r->valid) {
#line 2873
      tmp___6 = r->valid;
    } else {
#line 2873
      tmp___6 = (time_t )rn->ttl;
    }
    {
#line 2873
    rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___6);
#line 2874
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2876
    rn->queue.next = r->srv_expire_queue.next;
#line 2876
    (rn->queue.next)->prev = & rn->queue;
#line 2876
    rn->queue.prev = & r->srv_expire_queue;
#line 2876
    r->srv_expire_queue.next = & rn->queue;
#line 2878
    ngx_resolver_free(r, (void *)rn->query);
#line 2879
    rn->query = (u_char *)((void *)0);
#line 2881
    rn->query6 = (u_char *)((void *)0);
#line 2884
    ctx = rn->waiting;
#line 2885
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
    }
#line 2887
    if (ctx) {
#line 2889
      tmp___7 = ctx->recursion;
#line 2889
      (ctx->recursion) ++;
#line 2889
      if (tmp___7 >= 50UL) {
        {
#line 2893
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 2894
          ctx->state = (ngx_int_t )3;
#line 2895
          next = ctx->next;
#line 2897
          (*(ctx->handler))(ctx);
#line 2899
          ctx = next;
          }
#line 2893
          if (! ctx) {
#line 2893
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2902
        return;
      }
#line 2905
      next = ctx;
      {
#line 2905
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2905
        if (! next) {
#line 2905
          goto while_break___6;
        }
#line 2906
        next->node = (ngx_resolver_node_t *)((void *)0);
#line 2905
        next = next->next;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2909
      ngx_resolve_name_locked(r, ctx, & name);
      }
    }
#line 2914
    return;
  }
#line 2917
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2917
    ngx_log_error_core(r->log_level, r->log, 0, "no SRV type in DNS response");
    }
  }
#line 2919
  return;
  short_response: 
#line 2923
  err = (char *)"short DNS response";
  invalid: 
#line 2929
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2929
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 2931
  return;
  failed: 
#line 2937
  return;
}
}
#line 2941 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_resolve_srv_names(ngx_resolver_ctx_t *ctx , ngx_resolver_node_t *rn ) 
{ 
  ngx_uint_t i ;
  ngx_resolver_t *r ;
  ngx_resolver_ctx_t *cctx ;
  ngx_resolver_srv_name_t *srvs ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  time_t tmp___2 ;

  {
  {
#line 2949
  r = ctx->resolver;
#line 2951
  ctx->node = (ngx_resolver_node_t *)((void *)0);
#line 2952
  ctx->state = (ngx_int_t )0;
#line 2953
  ctx->valid = rn->valid;
#line 2954
  ctx->count = (ngx_uint_t )rn->nsrvs;
#line 2956
  tmp = ngx_resolver_calloc(r, (unsigned long )rn->nsrvs * sizeof(ngx_resolver_srv_name_t ));
#line 2956
  srvs = (ngx_resolver_srv_name_t *)tmp;
  }
#line 2957
  if ((unsigned long )srvs == (unsigned long )((void *)0)) {
#line 2958
    goto failed;
  }
#line 2961
  ctx->srvs = srvs;
#line 2962
  ctx->nsrvs = (ngx_uint_t )rn->nsrvs;
#line 2964
  if (ctx->event) {
#line 2964
    if ((ctx->event)->timer_set) {
      {
#line 2965
      ngx_event_del_timer(ctx->event);
      }
    }
  }
#line 2968
  i = (ngx_uint_t )0;
  {
#line 2968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2968
    if (! (i < (ngx_uint_t )rn->nsrvs)) {
#line 2968
      goto while_break;
    }
    {
#line 2969
    tmp___0 = ngx_resolver_alloc(r, (rn->u.srvs + i)->name.len);
#line 2969
    (srvs + i)->name.data = (u_char *)tmp___0;
    }
#line 2970
    if ((unsigned long )(srvs + i)->name.data == (unsigned long )((void *)0)) {
#line 2971
      goto failed;
    }
    {
#line 2974
    (srvs + i)->name.len = (rn->u.srvs + i)->name.len;
#line 2975
    memcpy((void */* __restrict  */)(srvs + i)->name.data, (void const   */* __restrict  */)(rn->u.srvs + i)->name.data,
           (srvs + i)->name.len);
#line 2978
    cctx = ngx_resolve_start(r, (ngx_resolver_ctx_t *)((void *)0));
    }
#line 2979
    if ((unsigned long )cctx == (unsigned long )((void *)0)) {
#line 2980
      goto failed;
    }
    {
#line 2983
    cctx->name = (srvs + i)->name;
#line 2984
    cctx->handler = & ngx_resolver_srv_names_handler;
#line 2985
    cctx->data = (void *)ctx;
#line 2986
    cctx->srvs = srvs + i;
#line 2987
    cctx->timeout = ctx->timeout;
#line 2989
    (srvs + i)->priority = (rn->u.srvs + i)->priority;
#line 2990
    (srvs + i)->weight = (rn->u.srvs + i)->weight;
#line 2991
    (srvs + i)->port = (rn->u.srvs + i)->port;
#line 2992
    (srvs + i)->ctx = cctx;
#line 2994
    tmp___1 = ngx_resolve_name(cctx);
    }
#line 2994
    if (tmp___1 == -1L) {
#line 2995
      (srvs + i)->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 2996
      goto failed;
    }
#line 2968
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3000
  return;
  failed: 
#line 3004
  ctx->state = (ngx_int_t )-1;
#line 3005
  if (r->valid) {
#line 3005
    tmp___2 = r->valid;
  } else {
#line 3005
    tmp___2 = (time_t )10;
  }
  {
#line 3005
  ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___2);
#line 3007
  (*(ctx->handler))(ctx);
  }
#line 3008
  return;
}
}
#line 3011 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_srv_names_handler(ngx_resolver_ctx_t *cctx ) 
{ 
  ngx_uint_t i ;
  ngx_addr_t *addrs ;
  ngx_resolver_t *r ;
  ngx_sockaddr_t *sockaddr ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_srv_name_t *srv ;
  void *tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  time_t tmp___2 ;

  {
#line 3021
  r = cctx->resolver;
#line 3022
  ctx = (ngx_resolver_ctx_t *)cctx->data;
#line 3023
  srv = cctx->srvs;
#line 3025
  (ctx->count) --;
#line 3026
  ctx->async |= cctx->async;
#line 3028
  srv->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 3029
  srv->state = cctx->state;
#line 3031
  if (cctx->naddrs) {
#line 3033
    if (ctx->valid > cctx->valid) {
#line 3033
      ctx->valid = cctx->valid;
    } else {
#line 3033
      ctx->valid = ctx->valid;
    }
    {
#line 3035
    tmp = ngx_resolver_calloc(r, cctx->naddrs * sizeof(ngx_addr_t ));
#line 3035
    addrs = (ngx_addr_t *)tmp;
    }
#line 3036
    if ((unsigned long )addrs == (unsigned long )((void *)0)) {
      {
#line 3037
      ngx_resolve_name_done(cctx);
#line 3039
      ctx->state = (ngx_int_t )-1;
      }
#line 3040
      if (r->valid) {
#line 3040
        tmp___0 = r->valid;
      } else {
#line 3040
        tmp___0 = (time_t )10;
      }
      {
#line 3040
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___0);
#line 3042
      (*(ctx->handler))(ctx);
      }
#line 3043
      return;
    }
    {
#line 3046
    tmp___1 = ngx_resolver_alloc(r, cctx->naddrs * sizeof(ngx_sockaddr_t ));
#line 3046
    sockaddr = (ngx_sockaddr_t *)tmp___1;
    }
#line 3047
    if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
      {
#line 3048
      ngx_resolver_free(r, (void *)addrs);
#line 3049
      ngx_resolve_name_done(cctx);
#line 3051
      ctx->state = (ngx_int_t )-1;
      }
#line 3052
      if (r->valid) {
#line 3052
        tmp___2 = r->valid;
      } else {
#line 3052
        tmp___2 = (time_t )10;
      }
      {
#line 3052
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___2);
#line 3054
      (*(ctx->handler))(ctx);
      }
#line 3055
      return;
    }
#line 3058
    i = (ngx_uint_t )0;
    {
#line 3058
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3058
      if (! (i < cctx->naddrs)) {
#line 3058
        goto while_break;
      }
      {
#line 3059
      (addrs + i)->sockaddr = & (sockaddr + i)->sockaddr;
#line 3060
      (addrs + i)->socklen = (cctx->addrs + i)->socklen;
#line 3062
      memcpy((void */* __restrict  */)(sockaddr + i), (void const   */* __restrict  */)(cctx->addrs + i)->sockaddr,
             (size_t )(addrs + i)->socklen);
#line 3065
      ngx_inet_set_port((addrs + i)->sockaddr, srv->port);
#line 3058
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3068
    srv->addrs = addrs;
#line 3069
    srv->naddrs = cctx->naddrs;
  }
  {
#line 3072
  ngx_resolve_name_done(cctx);
  }
#line 3074
  if (ctx->count == 0UL) {
    {
#line 3075
    ngx_resolver_report_srv(r, ctx);
    }
  }
#line 3077
  return;
}
}
#line 3080 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_process_ptr(ngx_resolver_t *r , u_char *buf , size_t___0 n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ) 
{ 
  char *err ;
  size_t___0 len ;
  in_addr_t addr ;
  int32_t ttl ;
  ngx_int_t octet ;
  ngx_str_t name ;
  ngx_uint_t mask ;
  ngx_uint_t type ;
  ngx_uint_t class ;
  ngx_uint_t qident ;
  ngx_uint_t a ;
  ngx_uint_t i ;
  ngx_uint_t start ;
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_an_t *an ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_node_t *rn ;
  uint32_t hash ;
  ngx_int_t digit ;
  struct in6_addr addr6 ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_uint_t tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_uint_t tmp___4 ;
  ngx_uint_t tmp___5 ;
  ngx_int_t tmp___6 ;
  time_t tmp___7 ;
  ngx_int_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;

  {
  {
#line 3102
  tmp = ngx_resolver_copy(r, & name, buf, buf + sizeof(ngx_resolver_hdr_t ), buf + n);
  }
#line 3102
  if (tmp != 0L) {
#line 3106
    return;
  }
#line 3113
  addr = (in_addr_t )0;
#line 3114
  i = sizeof(ngx_resolver_hdr_t );
#line 3116
  mask = (ngx_uint_t )0;
  {
#line 3116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3116
    if (! (mask < 32UL)) {
#line 3116
      goto while_break;
    }
    {
#line 3117
    tmp___0 = i;
#line 3117
    i ++;
#line 3117
    len = (size_t___0 )*(buf + tmp___0);
#line 3119
    octet = ngx_atoi(buf + i, len);
    }
#line 3120
    if (octet == -1L) {
#line 3121
      goto invalid_in_addr_arpa;
    } else
#line 3120
    if (octet > 255L) {
#line 3121
      goto invalid_in_addr_arpa;
    }
#line 3124
    addr = (in_addr_t )((ngx_int_t )addr + (octet << mask));
#line 3125
    i += len;
#line 3116
    mask += 8UL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3128
  tmp___1 = ngx_strcasecmp(buf + i, (u_char *)"\ain-addr\004arpa");
  }
#line 3128
  if (tmp___1 == 0L) {
    {
#line 3129
    i += sizeof("\ain-addr\004arpa");
#line 3133
    rn = ngx_resolver_lookup_addr(r, addr);
#line 3135
    tree = & r->addr_rbtree;
#line 3136
    expire_queue = & r->addr_expire_queue;
    }
#line 3138
    goto valid;
  }
  invalid_in_addr_arpa: 
#line 3145
  i = sizeof(ngx_resolver_hdr_t );
#line 3147
  octet = (ngx_int_t )15;
  {
#line 3147
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3147
    if (! (octet >= 0L)) {
#line 3147
      goto while_break___0;
    }
#line 3148
    tmp___2 = i;
#line 3148
    i ++;
#line 3148
    if ((int )*(buf + tmp___2) != 1) {
#line 3149
      goto invalid_ip6_arpa;
    }
    {
#line 3152
    tmp___3 = i;
#line 3152
    i ++;
#line 3152
    digit = ngx_hextoi(buf + tmp___3, (size_t___0 )1);
    }
#line 3153
    if (digit == -1L) {
#line 3154
      goto invalid_ip6_arpa;
    }
#line 3157
    addr6.__in6_u.__u6_addr8[octet] = (u_char )digit;
#line 3159
    tmp___4 = i;
#line 3159
    i ++;
#line 3159
    if ((int )*(buf + tmp___4) != 1) {
#line 3160
      goto invalid_ip6_arpa;
    }
    {
#line 3163
    tmp___5 = i;
#line 3163
    i ++;
#line 3163
    digit = ngx_hextoi(buf + tmp___5, (size_t___0 )1);
    }
#line 3164
    if (digit == -1L) {
#line 3165
      goto invalid_ip6_arpa;
    }
#line 3168
    addr6.__in6_u.__u6_addr8[octet] = (uint8_t )((int )addr6.__in6_u.__u6_addr8[octet] + (int )((u_char )(digit * 16L)));
#line 3147
    octet --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3171
  tmp___6 = ngx_strcasecmp(buf + i, (u_char *)"\003ip6\004arpa");
  }
#line 3171
  if (tmp___6 == 0L) {
    {
#line 3172
    i += sizeof("\003ip6\004arpa");
#line 3176
    hash = ngx_crc32_short(addr6.__in6_u.__u6_addr8, (size_t___0 )16);
#line 3177
    rn = ngx_resolver_lookup_addr6(r, & addr6, hash);
#line 3179
    tree = & r->addr6_rbtree;
#line 3180
    expire_queue = & r->addr6_expire_queue;
    }
#line 3182
    goto valid;
  }
  invalid_ip6_arpa: 
#line 3188
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3188
    ngx_log_error_core(r->log_level, r->log, 0, "invalid in-addr.arpa or ip6.arpa name in DNS response");
    }
  }
  {
#line 3190
  ngx_resolver_free(r, (void *)name.data);
  }
#line 3191
  return;
  valid: 
#line 3195
  if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 3195
    goto _L;
  } else
#line 3195
  if ((unsigned long )rn->query == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 3196
    if ((r->log)->log_level >= r->log_level) {
      {
#line 3196
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 3198
    ngx_resolver_free(r, (void *)name.data);
    }
#line 3199
    goto failed;
  }
#line 3202
  qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
#line 3204
  if (ident != qident) {
#line 3205
    if ((r->log)->log_level >= r->log_level) {
      {
#line 3205
      ngx_log_error_core(r->log_level, r->log, 0, "wrong ident %ui response for %V, expect %ui",
                         ident, & name, qident);
      }
    }
    {
#line 3208
    ngx_resolver_free(r, (void *)name.data);
    }
#line 3209
    goto failed;
  }
  {
#line 3212
  ngx_resolver_free(r, (void *)name.data);
  }
#line 3214
  if (code == 0UL) {
#line 3214
    if (nan == 0UL) {
#line 3215
      code = (ngx_uint_t )3;
    }
  }
#line 3218
  if (code) {
    {
#line 3219
    next = rn->waiting;
#line 3220
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
#line 3222
    (rn->queue.next)->prev = rn->queue.prev;
#line 3222
    (rn->queue.prev)->next = rn->queue.next;
#line 3224
    ngx_rbtree_delete(tree, & rn->node);
    }
    {
#line 3228
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3228
      if (! next) {
#line 3228
        goto while_break___1;
      }
#line 3229
      ctx = next;
#line 3230
      ctx->state = (ngx_int_t )code;
#line 3231
      if (r->valid) {
#line 3231
        tmp___7 = r->valid;
      } else {
#line 3231
        tmp___7 = (time_t )10;
      }
      {
#line 3231
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___7);
#line 3232
      next = ctx->next;
#line 3234
      (*(ctx->handler))(ctx);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3237
    ngx_resolver_free_node(r, rn);
    }
#line 3239
    return;
  }
#line 3242
  i += sizeof(ngx_resolver_qs_t );
#line 3244
  a = (ngx_uint_t )0;
  {
#line 3244
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3244
    if (! (a < nan)) {
#line 3244
      goto while_break___2;
    }
#line 3246
    start = i;
    {
#line 3248
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3248
      if (! (i < n)) {
#line 3248
        goto while_break___3;
      }
#line 3250
      if ((int )*(buf + i) & 192) {
#line 3251
        i += 2UL;
#line 3252
        goto found;
      }
#line 3255
      if ((int )*(buf + i) == 0) {
#line 3256
        i ++;
#line 3257
        goto test_length;
      }
#line 3260
      i += (ngx_uint_t )(1 + (int )*(buf + i));
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3263
    goto short_response;
    test_length: 
#line 3267
    if (i - start < 2UL) {
#line 3268
      err = (char *)"invalid name in DNS response";
#line 3269
      goto invalid;
    }
    found: 
#line 3274
    if (i + sizeof(ngx_resolver_an_t ) >= n) {
#line 3275
      goto short_response;
    }
#line 3278
    an = (ngx_resolver_an_t *)(buf + i);
#line 3280
    type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 3281
    class = (ngx_uint_t )(((int )an->class_hi << 8) + (int )an->class_lo);
#line 3282
    len = (size_t___0 )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 3283
    ttl = ((((int )an->ttl[0] << 24) + ((int )an->ttl[1] << 16)) + ((int )an->ttl[2] << 8)) + (int )an->ttl[3];
#line 3286
    if (class != 1UL) {
#line 3287
      if ((r->log)->log_level >= r->log_level) {
        {
#line 3287
        ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR class %ui", class);
        }
      }
#line 3289
      goto failed;
    }
#line 3292
    if (ttl < 0) {
#line 3293
      ttl = 0;
    }
#line 3300
    i += sizeof(ngx_resolver_an_t );
    {
#line 3304
    if (type == 12UL) {
#line 3304
      goto case_12;
    }
#line 3308
    if (type == 5UL) {
#line 3308
      goto case_5;
    }
#line 3312
    goto switch_default;
    case_12: /* CIL Label */ 
#line 3306
    goto ptr;
    case_5: /* CIL Label */ 
#line 3310
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3314
    if ((r->log)->log_level >= r->log_level) {
      {
#line 3314
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR type %ui", type);
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 3318
    i += len;
#line 3244
    a ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3323
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3323
    ngx_log_error_core(r->log_level, r->log, 0, "no PTR type in DNS response");
    }
  }
#line 3325
  return;
  ptr: 
  {
#line 3329
  tmp___8 = ngx_resolver_copy(r, & name, buf, buf + i, buf + n);
  }
#line 3329
  if (tmp___8 != 0L) {
#line 3330
    goto failed;
  }
#line 3335
  if (name.len != (size_t___0 )rn->nlen) {
#line 3335
    goto _L___0;
  } else {
    {
#line 3335
    tmp___10 = strncmp((char const   *)name.data, (char const   *)rn->name, name.len);
    }
#line 3335
    if (tmp___10 != 0) {
      _L___0: /* CIL Label */ 
#line 3338
      if (rn->nlen) {
        {
#line 3339
        ngx_resolver_free(r, (void *)rn->name);
        }
      }
      {
#line 3342
      rn->nlen = (u_short )name.len;
#line 3343
      rn->name = name.data;
#line 3345
      tmp___9 = ngx_resolver_dup(r, (void *)rn->name, name.len);
#line 3345
      name.data = (u_char *)tmp___9;
      }
#line 3346
      if ((unsigned long )name.data == (unsigned long )((void *)0)) {
#line 3347
        goto failed;
      }
    }
  }
#line 3351
  (rn->queue.next)->prev = rn->queue.prev;
#line 3351
  (rn->queue.prev)->next = rn->queue.next;
#line 3353
  if (r->valid) {
#line 3353
    tmp___11 = r->valid;
  } else {
#line 3353
    tmp___11 = (time_t )ttl;
  }
#line 3353
  rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___11);
#line 3354
  rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 3356
  rn->queue.next = expire_queue->next;
#line 3356
  (rn->queue.next)->prev = & rn->queue;
#line 3356
  rn->queue.prev = expire_queue;
#line 3356
  expire_queue->next = & rn->queue;
#line 3358
  next = rn->waiting;
#line 3359
  rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
  {
#line 3363
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3363
    if (! next) {
#line 3363
      goto while_break___4;
    }
    {
#line 3364
    ctx = next;
#line 3365
    ctx->state = (ngx_int_t )0;
#line 3366
    ctx->valid = rn->valid;
#line 3367
    ctx->name = name;
#line 3368
    next = ctx->next;
#line 3370
    (*(ctx->handler))(ctx);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 3373
  ngx_resolver_free(r, (void *)name.data);
  }
#line 3375
  return;
  short_response: 
#line 3379
  err = (char *)"short DNS response";
  invalid: 
#line 3385
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3385
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 3387
  return;
  failed: 
#line 3393
  return;
}
}
#line 3397 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_name(ngx_resolver_t *r , ngx_str_t *name ,
                                                     uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_resolver_node_t *rn ;

  {
#line 3404
  node = r->name_rbtree.root;
#line 3405
  sentinel = r->name_rbtree.sentinel;
  {
#line 3407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3407
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3407
      goto while_break;
    }
#line 3409
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 3410
      node = node->left;
#line 3411
      goto while_continue;
    }
#line 3414
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 3415
      node = node->right;
#line 3416
      goto while_continue;
    }
    {
#line 3421
    rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3423
    rc = ngx_memn2cmp(name->data, rn->name, name->len, (size_t___0 )rn->nlen);
    }
#line 3425
    if (rc == 0L) {
#line 3426
      return (rn);
    }
#line 3429
    if (rc < 0L) {
#line 3429
      node = node->left;
    } else {
#line 3429
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3434
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3438 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_srv(ngx_resolver_t *r , ngx_str_t *name ,
                                                    uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_resolver_node_t *rn ;

  {
#line 3445
  node = r->srv_rbtree.root;
#line 3446
  sentinel = r->srv_rbtree.sentinel;
  {
#line 3448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3448
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3448
      goto while_break;
    }
#line 3450
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 3451
      node = node->left;
#line 3452
      goto while_continue;
    }
#line 3455
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 3456
      node = node->right;
#line 3457
      goto while_continue;
    }
    {
#line 3462
    rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3464
    rc = ngx_memn2cmp(name->data, rn->name, name->len, (size_t___0 )rn->nlen);
    }
#line 3466
    if (rc == 0L) {
#line 3467
      return (rn);
    }
#line 3470
    if (rc < 0L) {
#line 3470
      node = node->left;
    } else {
#line 3470
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3475
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3479 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_addr(ngx_resolver_t *r , in_addr_t addr ) 
{ 
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 3484
  node = r->addr_rbtree.root;
#line 3485
  sentinel = r->addr_rbtree.sentinel;
  {
#line 3487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3487
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3487
      goto while_break;
    }
#line 3489
    if ((ngx_rbtree_key_t )addr < node->key) {
#line 3490
      node = node->left;
#line 3491
      goto while_continue;
    }
#line 3494
    if ((ngx_rbtree_key_t )addr > node->key) {
#line 3495
      node = node->right;
#line 3496
      goto while_continue;
    }
#line 3501
    return ((ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node)));
  }
  while_break: /* CIL Label */ ;
  }
#line 3506
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3512 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_addr6(ngx_resolver_t *r , struct in6_addr *addr ,
                                                      uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_resolver_node_t *rn ;
  int tmp ;

  {
#line 3520
  node = r->addr6_rbtree.root;
#line 3521
  sentinel = r->addr6_rbtree.sentinel;
  {
#line 3523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3523
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3523
      goto while_break;
    }
#line 3525
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 3526
      node = node->left;
#line 3527
      goto while_continue;
    }
#line 3530
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 3531
      node = node->right;
#line 3532
      goto while_continue;
    }
    {
#line 3537
    rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3539
    tmp = memcmp((void const   *)((char const   *)addr), (void const   *)((char const   *)(& rn->addr6)),
                 (size_t )16);
#line 3539
    rc = (ngx_int_t )tmp;
    }
#line 3541
    if (rc == 0L) {
#line 3542
      return (rn);
    }
#line 3545
    if (rc < 0L) {
#line 3545
      node = node->left;
    } else {
#line 3545
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3550
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3556 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                             ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_node_t *rn_temp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3565
    if (node->key < temp->key) {
#line 3567
      p = & temp->left;
    } else
#line 3569
    if (node->key > temp->key) {
#line 3571
      p = & temp->right;
    } else {
      {
#line 3575
      rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3576
      rn_temp = (ngx_resolver_node_t *)((u_char *)temp - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3578
      tmp___0 = ngx_memn2cmp(rn->name, rn_temp->name, (size_t___0 )rn->nlen, (size_t___0 )rn_temp->nlen);
      }
#line 3578
      if (tmp___0 < 0L) {
#line 3578
        p = & temp->left;
      } else {
#line 3578
        p = & temp->right;
      }
    }
#line 3582
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 3583
      goto while_break;
    }
#line 3586
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 3589
  *p = node;
#line 3590
  node->parent = temp;
#line 3591
  node->left = sentinel;
#line 3592
  node->right = sentinel;
#line 3593
  node->color = (u_char )1;
#line 3594
  return;
}
}
#line 3599 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_rbtree_insert_addr6_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                   ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_node_t *rn_temp ;
  int tmp___0 ;

  {
  {
#line 3606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3608
    if (node->key < temp->key) {
#line 3610
      p = & temp->left;
    } else
#line 3612
    if (node->key > temp->key) {
#line 3614
      p = & temp->right;
    } else {
      {
#line 3618
      rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3619
      rn_temp = (ngx_resolver_node_t *)((u_char *)temp - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3621
      tmp___0 = memcmp((void const   *)((char const   *)(& rn->addr6)), (void const   *)((char const   *)(& rn_temp->addr6)),
                       (size_t )16);
      }
#line 3621
      if (tmp___0 < 0) {
#line 3621
        p = & temp->left;
      } else {
#line 3621
        p = & temp->right;
      }
    }
#line 3625
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 3626
      goto while_break;
    }
#line 3629
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 3632
  *p = node;
#line 3633
  node->parent = temp;
#line 3634
  node->left = sentinel;
#line 3635
  node->right = sentinel;
#line 3636
  node->color = (u_char )1;
#line 3637
  return;
}
}
#line 3642 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_create_name_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_str_t *name ) 
{ 
  u_char *p ;
  u_char *s ;
  size_t___0 len ;
  size_t___0 nlen ;
  ngx_uint_t ident ;
  ngx_resolver_qs_t *qs ;
  ngx_resolver_hdr_t *query ;
  size_t___0 tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  u_char *tmp___2 ;
  long tmp___3 ;

  {
#line 3652
  if (name->len) {
#line 3652
    nlen = (1UL + name->len) + 1UL;
  } else {
#line 3652
    nlen = (size_t___0 )1;
  }
#line 3654
  len = (sizeof(ngx_resolver_hdr_t ) + nlen) + sizeof(ngx_resolver_qs_t );
#line 3657
  if (r->ipv6) {
#line 3657
    tmp = len * 2UL;
  } else {
#line 3657
    tmp = len;
  }
  {
#line 3657
  tmp___0 = ngx_resolver_alloc(r, tmp);
#line 3657
  p = (u_char *)tmp___0;
  }
#line 3661
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3662
    return ((ngx_int_t )-1);
  }
#line 3665
  rn->qlen = (u_short )len;
#line 3666
  rn->query = p;
#line 3669
  if (r->ipv6) {
#line 3670
    rn->query6 = p + len;
  }
  {
#line 3674
  query = (ngx_resolver_hdr_t *)p;
#line 3676
  tmp___1 = random();
#line 3676
  ident = (ngx_uint_t )tmp___1;
#line 3681
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3682
  query->ident_lo = (u_char )(ident & 255UL);
#line 3685
  query->flags_hi = (u_char )1;
#line 3685
  query->flags_lo = (u_char )0;
#line 3688
  query->nqs_hi = (u_char )0;
#line 3688
  query->nqs_lo = (u_char )1;
#line 3689
  query->nan_hi = (u_char )0;
#line 3689
  query->nan_lo = (u_char )0;
#line 3690
  query->nns_hi = (u_char )0;
#line 3690
  query->nns_lo = (u_char )0;
#line 3691
  query->nar_hi = (u_char )0;
#line 3691
  query->nar_lo = (u_char )0;
#line 3693
  p += sizeof(ngx_resolver_hdr_t ) + nlen;
#line 3695
  qs = (ngx_resolver_qs_t *)p;
#line 3698
  qs->type_hi = (u_char )0;
#line 3698
  qs->type_lo = (u_char )1;
#line 3701
  qs->class_hi = (u_char )0;
#line 3701
  qs->class_lo = (u_char )1;
#line 3705
  len = (size_t___0 )0;
#line 3706
  p --;
#line 3707
  tmp___2 = p;
#line 3707
  p --;
#line 3707
  *tmp___2 = (u_char )'\000';
  }
#line 3709
  if (name->len == 0UL) {
#line 3710
    return ((ngx_int_t )-5);
  }
#line 3713
  s = (name->data + name->len) - 1;
  {
#line 3713
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3713
    if (! ((unsigned long )s >= (unsigned long )name->data)) {
#line 3713
      goto while_break;
    }
#line 3714
    if ((int )*s != 46) {
#line 3715
      *p = *s;
#line 3716
      len ++;
    } else {
#line 3719
      if (len == 0UL) {
#line 3720
        return ((ngx_int_t )-5);
      } else
#line 3719
      if (len > 255UL) {
#line 3720
        return ((ngx_int_t )-5);
      }
#line 3723
      *p = (u_char )len;
#line 3724
      len = (size_t___0 )0;
    }
#line 3727
    p --;
#line 3713
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3730
  if (len == 0UL) {
#line 3731
    return ((ngx_int_t )-5);
  } else
#line 3730
  if (len > 255UL) {
#line 3731
    return ((ngx_int_t )-5);
  }
#line 3734
  *p = (u_char )len;
#line 3737
  if (! r->ipv6) {
#line 3738
    return ((ngx_int_t )0);
  }
  {
#line 3741
  p = rn->query6;
#line 3743
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)rn->query, (size_t )rn->qlen);
#line 3745
  query = (ngx_resolver_hdr_t *)p;
#line 3747
  tmp___3 = random();
#line 3747
  ident = (ngx_uint_t )tmp___3;
#line 3752
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3753
  query->ident_lo = (u_char )(ident & 255UL);
#line 3755
  p += sizeof(ngx_resolver_hdr_t ) + nlen;
#line 3757
  qs = (ngx_resolver_qs_t *)p;
#line 3759
  qs->type_lo = (u_char )28;
  }
#line 3762
  return ((ngx_int_t )0);
}
}
#line 3766 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_create_srv_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                               ngx_str_t *name ) 
{ 
  u_char *p ;
  u_char *s ;
  size_t___0 len ;
  size_t___0 nlen ;
  ngx_uint_t ident ;
  ngx_resolver_qs_t *qs ;
  ngx_resolver_hdr_t *query ;
  void *tmp ;
  long tmp___0 ;
  u_char *tmp___1 ;

  {
#line 3776
  if (name->len) {
#line 3776
    nlen = (1UL + name->len) + 1UL;
  } else {
#line 3776
    nlen = (size_t___0 )1;
  }
  {
#line 3778
  len = (sizeof(ngx_resolver_hdr_t ) + nlen) + sizeof(ngx_resolver_qs_t );
#line 3780
  tmp = ngx_resolver_alloc(r, len);
#line 3780
  p = (u_char *)tmp;
  }
#line 3781
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3782
    return ((ngx_int_t )-1);
  }
  {
#line 3785
  rn->qlen = (u_short )len;
#line 3786
  rn->query = p;
#line 3788
  query = (ngx_resolver_hdr_t *)p;
#line 3790
  tmp___0 = random();
#line 3790
  ident = (ngx_uint_t )tmp___0;
#line 3795
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3796
  query->ident_lo = (u_char )(ident & 255UL);
#line 3799
  query->flags_hi = (u_char )1;
#line 3799
  query->flags_lo = (u_char )0;
#line 3802
  query->nqs_hi = (u_char )0;
#line 3802
  query->nqs_lo = (u_char )1;
#line 3803
  query->nan_hi = (u_char )0;
#line 3803
  query->nan_lo = (u_char )0;
#line 3804
  query->nns_hi = (u_char )0;
#line 3804
  query->nns_lo = (u_char )0;
#line 3805
  query->nar_hi = (u_char )0;
#line 3805
  query->nar_lo = (u_char )0;
#line 3807
  p += sizeof(ngx_resolver_hdr_t ) + nlen;
#line 3809
  qs = (ngx_resolver_qs_t *)p;
#line 3812
  qs->type_hi = (u_char )0;
#line 3812
  qs->type_lo = (u_char )33;
#line 3815
  qs->class_hi = (u_char )0;
#line 3815
  qs->class_lo = (u_char )1;
#line 3819
  len = (size_t___0 )0;
#line 3820
  p --;
#line 3821
  tmp___1 = p;
#line 3821
  p --;
#line 3821
  *tmp___1 = (u_char )'\000';
  }
#line 3823
  if (name->len == 0UL) {
#line 3824
    return ((ngx_int_t )-5);
  }
#line 3827
  s = (name->data + name->len) - 1;
  {
#line 3827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3827
    if (! ((unsigned long )s >= (unsigned long )name->data)) {
#line 3827
      goto while_break;
    }
#line 3828
    if ((int )*s != 46) {
#line 3829
      *p = *s;
#line 3830
      len ++;
    } else {
#line 3833
      if (len == 0UL) {
#line 3834
        return ((ngx_int_t )-5);
      } else
#line 3833
      if (len > 255UL) {
#line 3834
        return ((ngx_int_t )-5);
      }
#line 3837
      *p = (u_char )len;
#line 3838
      len = (size_t___0 )0;
    }
#line 3841
    p --;
#line 3827
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3844
  if (len == 0UL) {
#line 3845
    return ((ngx_int_t )-5);
  } else
#line 3844
  if (len > 255UL) {
#line 3845
    return ((ngx_int_t )-5);
  }
#line 3848
  *p = (u_char )len;
#line 3850
  return ((ngx_int_t )0);
}
}
#line 3854 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_create_addr_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_resolver_addr_t *addr ) 
{ 
  u_char *p ;
  u_char *d ;
  size_t___0 len ;
  in_addr_t inaddr ;
  ngx_int_t n ;
  ngx_uint_t ident ;
  ngx_resolver_hdr_t *query ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  unsigned int __v ;
  unsigned int __x ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3872
  if ((int )(addr->sockaddr)->sa_family == 10) {
#line 3872
    goto case_10;
  }
#line 3880
  goto switch_default;
  case_10: /* CIL Label */ 
#line 3873
  len = (((sizeof(ngx_resolver_hdr_t ) + 64UL) + sizeof(".ip6.arpa.")) - 1UL) + sizeof(ngx_resolver_qs_t );
#line 3877
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3881
  len = ((sizeof(ngx_resolver_hdr_t ) + sizeof(".255.255.255.255.in-addr.arpa.")) - 1UL) + sizeof(ngx_resolver_qs_t );
  switch_break: /* CIL Label */ ;
  }
  {
#line 3886
  tmp = ngx_resolver_alloc(r, len);
#line 3886
  p = (u_char *)tmp;
  }
#line 3887
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3888
    return ((ngx_int_t )-1);
  }
  {
#line 3891
  rn->query = p;
#line 3892
  query = (ngx_resolver_hdr_t *)p;
#line 3894
  tmp___0 = random();
#line 3894
  ident = (ngx_uint_t )tmp___0;
#line 3896
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3897
  query->ident_lo = (u_char )(ident & 255UL);
#line 3900
  query->flags_hi = (u_char )1;
#line 3900
  query->flags_lo = (u_char )0;
#line 3903
  query->nqs_hi = (u_char )0;
#line 3903
  query->nqs_lo = (u_char )1;
#line 3904
  query->nan_hi = (u_char )0;
#line 3904
  query->nan_lo = (u_char )0;
#line 3905
  query->nns_hi = (u_char )0;
#line 3905
  query->nns_lo = (u_char )0;
#line 3906
  query->nar_hi = (u_char )0;
#line 3906
  query->nar_lo = (u_char )0;
#line 3908
  p += sizeof(ngx_resolver_hdr_t );
  }
  {
#line 3913
  if ((int )(addr->sockaddr)->sa_family == 10) {
#line 3913
    goto case_10___0;
  }
#line 3927
  goto switch_default___0;
  case_10___0: /* CIL Label */ 
#line 3914
  sin6 = (struct sockaddr_in6 *)addr->sockaddr;
#line 3916
  n = (ngx_int_t )15;
  {
#line 3916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3916
    if (! (n >= 0L)) {
#line 3916
      goto while_break;
    }
    {
#line 3917
    p = ngx_sprintf(p, "\001%xd\001%xd", (int )sin6->sin6_addr.__in6_u.__u6_addr8[n] & 15,
                    ((int )sin6->sin6_addr.__in6_u.__u6_addr8[n] >> 4) & 15);
#line 3916
    n --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3922
  tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"\003ip6\004arpa\000",
                   (size_t )10);
#line 3922
  p = (u_char *)tmp___1 + 10;
  }
#line 3924
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 3929
  sin = (struct sockaddr_in *)addr->sockaddr;
#line 3930
  __x = sin->sin_addr.s_addr;
#line 3930
  __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 3930
  inaddr = __v;
#line 3932
  n = (ngx_int_t )0;
  {
#line 3932
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3932
    if (! (n < 32L)) {
#line 3932
      goto while_break___0;
    }
    {
#line 3933
    d = ngx_sprintf(p + 1, "%ud", (inaddr >> n) & 255U);
#line 3934
    *p = (u_char )(d - (p + 1));
#line 3935
    p = d;
#line 3932
    n += 8L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3938
  tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"\ain-addr\004arpa\000",
                   (size_t )14);
#line 3938
  p = (u_char *)tmp___2 + 14;
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 3942
  tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"\000\f\000\001",
                   (size_t )4);
#line 3942
  p = (u_char *)tmp___3 + 4;
#line 3944
  rn->qlen = (u_short )(p - rn->query);
  }
#line 3946
  return ((ngx_int_t )0);
}
}
#line 3950 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_copy(ngx_resolver_t *r , ngx_str_t *name , u_char *buf ,
                                   u_char *src , u_char *last ) 
{ 
  char *err ;
  u_char *p ;
  u_char *dst ;
  ssize_t len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  u_char *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;

  {
#line 3959
  p = src;
#line 3960
  len = (ssize_t )-1;
#line 3967
  i = (ngx_uint_t )0;
  {
#line 3967
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3967
    if (! (i < 128UL)) {
#line 3967
      goto while_break;
    }
#line 3968
    tmp = p;
#line 3968
    p ++;
#line 3968
    n = (ngx_uint_t )*tmp;
#line 3970
    if (n == 0UL) {
#line 3971
      goto done;
    }
#line 3974
    if (n & 192UL) {
#line 3975
      n = ((n & 63UL) << 8) + (unsigned long )*p;
#line 3976
      p = buf + n;
    } else {
#line 3979
      len = (ssize_t )((ngx_uint_t )len + (1UL + n));
#line 3980
      p += n;
    }
#line 3983
    if ((unsigned long )p >= (unsigned long )last) {
#line 3984
      err = (char *)"name is out of response";
#line 3985
      goto invalid;
    }
#line 3967
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3989
  err = (char *)"compression pointers loop";
  invalid: 
#line 3993
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3993
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 3995
  return ((ngx_int_t )-1);
  done: 
#line 3999
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 4000
    return ((ngx_int_t )0);
  }
#line 4003
  if (len == -1L) {
#line 4004
    name->len = (size_t___0 )0;
#line 4004
    name->data = (u_char *)((void *)0);
#line 4005
    return ((ngx_int_t )0);
  }
  {
#line 4008
  tmp___0 = ngx_resolver_alloc(r, (size_t___0 )len);
#line 4008
  dst = (u_char *)tmp___0;
  }
#line 4009
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 4010
    return ((ngx_int_t )-1);
  }
#line 4013
  name->data = dst;
#line 4015
  tmp___1 = src;
#line 4015
  src ++;
#line 4015
  n = (ngx_uint_t )*tmp___1;
  {
#line 4017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4018
    if (n & 192UL) {
#line 4019
      n = ((n & 63UL) << 8) + (unsigned long )*src;
#line 4020
      src = buf + n;
#line 4022
      tmp___2 = src;
#line 4022
      src ++;
#line 4022
      n = (ngx_uint_t )*tmp___2;
    } else {
      {
#line 4025
      ngx_strlow(dst, src, n);
#line 4026
      dst += n;
#line 4027
      src += n;
#line 4029
      tmp___3 = src;
#line 4029
      src ++;
#line 4029
      n = (ngx_uint_t )*tmp___3;
      }
#line 4031
      if (n != 0UL) {
#line 4032
        tmp___4 = dst;
#line 4032
        dst ++;
#line 4032
        *tmp___4 = (u_char )'.';
      }
    }
#line 4036
    if (n == 0UL) {
#line 4037
      name->len = (size_t___0 )(dst - name->data);
#line 4038
      return ((ngx_int_t )0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 4044 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_timeout_handler(ngx_event_t *ev ) 
{ 
  ngx_resolver_ctx_t *ctx ;

  {
  {
#line 4049
  ctx = (ngx_resolver_ctx_t *)ev->data;
#line 4051
  ctx->state = (ngx_int_t )110;
#line 4053
  (*(ctx->handler))(ctx);
  }
#line 4054
  return;
}
}
#line 4057 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_free_node(ngx_resolver_t *r , ngx_resolver_node_t *rn ) 
{ 
  ngx_uint_t i ;

  {
#line 4064
  if (rn->query) {
    {
#line 4065
    ngx_resolver_free_locked(r, (void *)rn->query);
    }
  }
#line 4068
  if (rn->name) {
    {
#line 4069
    ngx_resolver_free_locked(r, (void *)rn->name);
    }
  }
#line 4072
  if (rn->cnlen) {
    {
#line 4073
    ngx_resolver_free_locked(r, (void *)rn->u.cname);
    }
  }
#line 4076
  if ((int )rn->naddrs > 1) {
#line 4076
    if ((int )rn->naddrs != 65535) {
      {
#line 4077
      ngx_resolver_free_locked(r, (void *)rn->u.addrs);
      }
    }
  }
#line 4081
  if ((int )rn->naddrs6 > 1) {
#line 4081
    if ((int )rn->naddrs6 != 65535) {
      {
#line 4082
      ngx_resolver_free_locked(r, (void *)rn->u6.addrs6);
      }
    }
  }
#line 4086
  if (rn->nsrvs) {
#line 4087
    i = (ngx_uint_t )0;
    {
#line 4087
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4087
      if (! (i < (ngx_uint_t )rn->nsrvs)) {
#line 4087
        goto while_break;
      }
#line 4088
      if ((rn->u.srvs + i)->name.data) {
        {
#line 4089
        ngx_resolver_free_locked(r, (void *)(rn->u.srvs + i)->name.data);
        }
      }
#line 4087
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4093
    ngx_resolver_free_locked(r, (void *)rn->u.srvs);
    }
  }
  {
#line 4096
  ngx_resolver_free_locked(r, (void *)rn);
  }
#line 4099
  return;
}
}
#line 4102 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void *ngx_resolver_alloc(ngx_resolver_t *r , size_t___0 size ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 4109
  tmp = ngx_alloc(size, r->log);
#line 4109
  p = (u_char *)tmp;
  }
#line 4113
  return ((void *)p);
}
}
#line 4117 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void *ngx_resolver_calloc(ngx_resolver_t *r , size_t___0 size ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 4122
  tmp = ngx_resolver_alloc(r, size);
#line 4122
  p = (u_char *)tmp;
  }
#line 4124
  if (p) {
    {
#line 4125
    memset((void *)p, 0, size);
    }
  }
#line 4128
  return ((void *)p);
}
}
#line 4132 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_free(ngx_resolver_t *r , void *p ) 
{ 


  {
  {
#line 4137
  free(p);
  }
#line 4140
  return;
}
}
#line 4143 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_free_locked(ngx_resolver_t *r , void *p ) 
{ 


  {
  {
#line 4146
  free(p);
  }
#line 4147
  return;
}
}
#line 4150 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void *ngx_resolver_dup(ngx_resolver_t *r , void *src , size_t___0 size ) 
{ 
  void *dst ;

  {
  {
#line 4155
  dst = ngx_resolver_alloc(r, size);
  }
#line 4157
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 4158
    return (dst);
  }
  {
#line 4161
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, size);
  }
#line 4163
  return (dst);
}
}
#line 4167 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_resolver_addr_t *ngx_resolver_export(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_uint_t rotate ) 
{ 
  ngx_uint_t d ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t n ;
  in_addr_t *addr ;
  ngx_sockaddr_t *sockaddr ;
  struct sockaddr_in *sin ;
  ngx_resolver_addr_t *dst ;
  struct in6_addr *addr6 ;
  struct sockaddr_in6 *sin6 ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_uint_t tmp___4 ;
  long tmp___5 ;
  ngx_uint_t tmp___6 ;
  ngx_uint_t tmp___7 ;

  {
  {
#line 4181
  n = (ngx_uint_t )rn->naddrs;
#line 4183
  n += (ngx_uint_t )rn->naddrs6;
#line 4186
  tmp = ngx_resolver_calloc(r, n * sizeof(ngx_resolver_addr_t ));
#line 4186
  dst = (ngx_resolver_addr_t *)tmp;
  }
#line 4187
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 4188
    return ((ngx_resolver_addr_t *)((void *)0));
  }
  {
#line 4191
  tmp___0 = ngx_resolver_calloc(r, n * sizeof(ngx_sockaddr_t ));
#line 4191
  sockaddr = (ngx_sockaddr_t *)tmp___0;
  }
#line 4192
  if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
    {
#line 4193
    ngx_resolver_free(r, (void *)dst);
    }
#line 4194
    return ((ngx_resolver_addr_t *)((void *)0));
  }
#line 4197
  i = (ngx_uint_t )0;
#line 4198
  if (rotate) {
    {
#line 4198
    tmp___1 = random();
#line 4198
    d = (unsigned long )tmp___1 % n;
    }
  } else {
#line 4198
    d = (ngx_uint_t )0;
  }
#line 4200
  if (rn->naddrs) {
#line 4201
    if (rotate) {
      {
#line 4201
      tmp___2 = random();
#line 4201
      j = (ngx_uint_t )(tmp___2 % (long )rn->naddrs);
      }
    } else {
#line 4201
      j = (ngx_uint_t )0;
    }
#line 4203
    if ((int )rn->naddrs == 1) {
#line 4203
      addr = & rn->u.addr;
    } else {
#line 4203
      addr = rn->u.addrs;
    }
    {
#line 4205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4206
      sin = & (sockaddr + d)->sockaddr_in;
#line 4207
      sin->sin_family = (sa_family_t )2;
#line 4208
      tmp___3 = j;
#line 4208
      j ++;
#line 4208
      sin->sin_addr.s_addr = *(addr + tmp___3);
#line 4209
      (dst + d)->sockaddr = (struct sockaddr *)sin;
#line 4210
      tmp___4 = d;
#line 4210
      d ++;
#line 4210
      (dst + tmp___4)->socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 4212
      if (d == n) {
#line 4213
        d = (ngx_uint_t )0;
      }
#line 4216
      if (j == (ngx_uint_t )rn->naddrs) {
#line 4217
        j = (ngx_uint_t )0;
      }
#line 4205
      i ++;
#line 4205
      if (! (i < (ngx_uint_t )rn->naddrs)) {
#line 4205
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4223
  if (rn->naddrs6) {
#line 4224
    if (rotate) {
      {
#line 4224
      tmp___5 = random();
#line 4224
      j = (ngx_uint_t )(tmp___5 % (long )rn->naddrs6);
      }
    } else {
#line 4224
      j = (ngx_uint_t )0;
    }
#line 4226
    if ((int )rn->naddrs6 == 1) {
#line 4226
      addr6 = & rn->u6.addr6;
    } else {
#line 4226
      addr6 = rn->u6.addrs6;
    }
    {
#line 4228
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4229
      sin6 = & (sockaddr + d)->sockaddr_in6;
#line 4230
      sin6->sin6_family = (sa_family_t )10;
#line 4231
      tmp___6 = j;
#line 4231
      j ++;
#line 4231
      memcpy((void */* __restrict  */)(sin6->sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)((addr6 + tmp___6)->__in6_u.__u6_addr8),
             (size_t )16);
#line 4232
      (dst + d)->sockaddr = (struct sockaddr *)sin6;
#line 4233
      tmp___7 = d;
#line 4233
      d ++;
#line 4233
      (dst + tmp___7)->socklen = (socklen_t )sizeof(struct sockaddr_in6 );
      }
#line 4235
      if (d == n) {
#line 4236
        d = (ngx_uint_t )0;
      }
#line 4239
      if (j == (ngx_uint_t )rn->naddrs6) {
#line 4240
        j = (ngx_uint_t )0;
      }
#line 4228
      i ++;
#line 4228
      if (! (i < n)) {
#line 4228
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4246
  return (dst);
}
}
#line 4250 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static void ngx_resolver_report_srv(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_uint_t naddrs ;
  ngx_uint_t nsrvs ;
  ngx_uint_t nw ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t k ;
  ngx_uint_t l ;
  ngx_uint_t m ;
  ngx_uint_t n ;
  ngx_uint_t w ;
  ngx_resolver_addr_t *addrs ;
  ngx_resolver_srv_name_t *srvs ;
  time_t tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;
  long tmp___2 ;

  {
#line 4257
  naddrs = (ngx_uint_t )0;
#line 4259
  i = (ngx_uint_t )0;
  {
#line 4259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4259
    if (! (i < ctx->nsrvs)) {
#line 4259
      goto while_break;
    }
#line 4260
    naddrs += (ctx->srvs + i)->naddrs;
#line 4259
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4263
  if (naddrs == 0UL) {
#line 4264
    ctx->state = (ngx_int_t )3;
#line 4265
    if (r->valid) {
#line 4265
      tmp = r->valid;
    } else {
#line 4265
      tmp = (time_t )10;
    }
    {
#line 4265
    ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp);
#line 4267
    (*(ctx->handler))(ctx);
    }
#line 4268
    return;
  }
  {
#line 4271
  tmp___0 = ngx_resolver_calloc(r, naddrs * sizeof(ngx_resolver_addr_t ));
#line 4271
  addrs = (ngx_resolver_addr_t *)tmp___0;
  }
#line 4272
  if ((unsigned long )addrs == (unsigned long )((void *)0)) {
#line 4273
    ctx->state = (ngx_int_t )-1;
#line 4274
    if (r->valid) {
#line 4274
      tmp___1 = r->valid;
    } else {
#line 4274
      tmp___1 = (time_t )10;
    }
    {
#line 4274
    ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___1);
#line 4276
    (*(ctx->handler))(ctx);
    }
#line 4277
    return;
  }
#line 4280
  srvs = ctx->srvs;
#line 4281
  nsrvs = ctx->nsrvs;
#line 4283
  i = (ngx_uint_t )0;
#line 4284
  n = (ngx_uint_t )0;
  {
#line 4286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4287
    nw = (ngx_uint_t )0;
#line 4289
    j = i;
    {
#line 4289
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4289
      if (! (j < nsrvs)) {
#line 4289
        goto while_break___1;
      }
#line 4290
      if ((int )(srvs + j)->priority != (int )(srvs + i)->priority) {
#line 4291
        goto while_break___1;
      }
#line 4294
      nw += (srvs + j)->naddrs * (ngx_uint_t )(srvs + j)->weight;
#line 4289
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4297
    if (nw == 0UL) {
#line 4298
      goto next_srv;
    }
    {
#line 4301
    tmp___2 = random();
#line 4301
    w = (unsigned long )tmp___2 % nw;
#line 4303
    k = i;
    }
    {
#line 4303
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4303
      if (! (k < j)) {
#line 4303
        goto while_break___2;
      }
#line 4304
      if (w < (srvs + k)->naddrs * (ngx_uint_t )(srvs + k)->weight) {
#line 4305
        goto while_break___2;
      }
#line 4308
      w -= (srvs + k)->naddrs * (ngx_uint_t )(srvs + k)->weight;
#line 4303
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4311
    l = i;
    {
#line 4311
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4311
      if (! (l < j)) {
#line 4311
        goto while_break___3;
      }
#line 4313
      m = (ngx_uint_t )0;
      {
#line 4313
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 4313
        if (! (m < (srvs + k)->naddrs)) {
#line 4313
          goto while_break___4;
        }
#line 4314
        (addrs + n)->socklen = ((srvs + k)->addrs + m)->socklen;
#line 4315
        (addrs + n)->sockaddr = ((srvs + k)->addrs + m)->sockaddr;
#line 4316
        (addrs + n)->name = (srvs + k)->name;
#line 4317
        (addrs + n)->priority = (srvs + k)->priority;
#line 4318
        (addrs + n)->weight = (srvs + k)->weight;
#line 4319
        n ++;
#line 4313
        m ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 4322
      k ++;
#line 4322
      if (k == j) {
#line 4323
        k = i;
      }
#line 4311
      l ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    next_srv: 
#line 4329
    i = j;
#line 4286
    if (! (i < ctx->nsrvs)) {
#line 4286
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4333
  ctx->state = (ngx_int_t )0;
#line 4334
  ctx->addrs = addrs;
#line 4335
  ctx->naddrs = naddrs;
#line 4337
  (*(ctx->handler))(ctx);
#line 4339
  ngx_resolver_free(r, (void *)addrs);
  }
#line 4340
  return;
}
}
#line 4346 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static char *errors[5]  = {      (char *)"Format error",      (char *)"Server failure",      (char *)"Host not found",      (char *)"Unimplemented", 
        (char *)"Operation refused"};
#line 4343 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
char *ngx_resolver_strerror(ngx_int_t err ) 
{ 


  {
#line 4354
  if (err > 0L) {
#line 4354
    if (err < 6L) {
#line 4355
      return (errors[err - 1L]);
    }
  }
#line 4358
  if (err == 110L) {
#line 4359
    return ((char *)"Operation timed out");
  }
#line 4362
  return ((char *)"Unknown error");
}
}
#line 4366 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static u_char *ngx_resolver_log_error(ngx_log_t *log , u_char *buf , size_t___0 len ) 
{ 
  u_char *p ;
  ngx_resolver_connection_t *rec ;

  {
#line 4372
  p = buf;
#line 4374
  if (log->action) {
    {
#line 4375
    p = ngx_snprintf(buf, len, " while %s", log->action);
#line 4376
    len -= (size_t___0 )(p - buf);
    }
  }
#line 4379
  rec = (ngx_resolver_connection_t *)log->data;
#line 4381
  if (rec) {
    {
#line 4382
    p = ngx_snprintf(p, len, ", resolver: %V", & rec->server);
    }
  }
#line 4385
  return (p);
}
}
#line 4389 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_udp_connect(ngx_resolver_connection_t *rec ) 
{ 
  int rc ;
  ngx_int_t event ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_socket_t s ;
  ngx_connection_t *c ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  ngx_atomic_t tmp___4 ;
  int *tmp___5 ;
  ngx_int_t tmp___6 ;

  {
  {
#line 4398
  s = socket((int )(rec->sockaddr)->sa_family, 2, 0);
  }
#line 4402
  if (s == -1) {
#line 4403
    if (rec->log.log_level >= 2UL) {
      {
#line 4403
      tmp = __errno_location();
#line 4403
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp, "socket() failed");
      }
    }
#line 4405
    return ((ngx_int_t )-1);
  }
  {
#line 4408
  c = ngx_get_connection(s, & rec->log);
  }
#line 4410
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 4411
    tmp___1 = close(s);
    }
#line 4411
    if (tmp___1 == -1) {
#line 4412
      if (rec->log.log_level >= 2UL) {
        {
#line 4412
        tmp___0 = __errno_location();
#line 4412
        ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___0, "close() socketfailed");
        }
      }
    }
#line 4416
    return ((ngx_int_t )-1);
  }
  {
#line 4419
  tmp___3 = ngx_nonblocking(s);
  }
#line 4419
  if (tmp___3 == -1) {
#line 4420
    if (rec->log.log_level >= 2UL) {
      {
#line 4420
      tmp___2 = __errno_location();
#line 4420
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___2, "ioctl(FIONBIO) failed");
      }
    }
#line 4423
    goto failed;
  }
  {
#line 4426
  rev = c->read;
#line 4427
  wev = c->write;
#line 4429
  rev->log = & rec->log;
#line 4430
  wev->log = & rec->log;
#line 4432
  rec->udp = c;
#line 4434
  tmp___4 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, 1);
#line 4434
  c->number = (ngx_atomic_uint_t )tmp___4;
#line 4439
  rc = connect(s, (struct sockaddr  const  */* __restrict  */)rec->sockaddr, rec->socklen);
  }
#line 4443
  if (rc == -1) {
#line 4444
    if (rec->log.log_level >= 3UL) {
      {
#line 4444
      tmp___5 = __errno_location();
#line 4444
      ngx_log_error_core((ngx_uint_t )3, & rec->log, *tmp___5, "connect() failed");
      }
    }
#line 4447
    goto failed;
  }
#line 4451
  wev->ready = 1U;
#line 4453
  if (ngx_event_flags & 4UL) {
#line 4453
    event = (ngx_int_t )2147483648U;
  } else {
#line 4453
    event = (ngx_int_t )0;
  }
  {
#line 4458
  tmp___6 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )event);
  }
#line 4458
  if (tmp___6 != 0L) {
#line 4459
    goto failed;
  }
#line 4462
  return ((ngx_int_t )0);
  failed: 
  {
#line 4466
  ngx_close_connection(c);
#line 4467
  rec->udp = (ngx_connection_t *)((void *)0);
  }
#line 4469
  return ((ngx_int_t )-1);
}
}
#line 4473 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_tcp_connect(ngx_resolver_connection_t *rec ) 
{ 
  int rc ;
  ngx_int_t event ;
  ngx_err_t err ;
  ngx_uint_t level ;
  ngx_socket_t s ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  ngx_atomic_t tmp___4 ;
  ngx_int_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;

  {
  {
#line 4484
  s = socket((int )(rec->sockaddr)->sa_family, 1, 0);
  }
#line 4488
  if (s == -1) {
#line 4489
    if (rec->log.log_level >= 2UL) {
      {
#line 4489
      tmp = __errno_location();
#line 4489
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp, "socket() failed");
      }
    }
#line 4491
    return ((ngx_int_t )-1);
  }
  {
#line 4494
  c = ngx_get_connection(s, & rec->log);
  }
#line 4496
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 4497
    tmp___1 = close(s);
    }
#line 4497
    if (tmp___1 == -1) {
#line 4498
      if (rec->log.log_level >= 2UL) {
        {
#line 4498
        tmp___0 = __errno_location();
#line 4498
        ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___0, "close() socketfailed");
        }
      }
    }
#line 4502
    return ((ngx_int_t )-1);
  }
  {
#line 4505
  tmp___3 = ngx_nonblocking(s);
  }
#line 4505
  if (tmp___3 == -1) {
#line 4506
    if (rec->log.log_level >= 2UL) {
      {
#line 4506
      tmp___2 = __errno_location();
#line 4506
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___2, "ioctl(FIONBIO) failed");
      }
    }
#line 4509
    goto failed;
  }
  {
#line 4512
  rev = c->read;
#line 4513
  wev = c->write;
#line 4515
  rev->log = & rec->log;
#line 4516
  wev->log = & rec->log;
#line 4518
  rec->tcp = c;
#line 4520
  tmp___4 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, 1);
#line 4520
  c->number = (ngx_atomic_uint_t )tmp___4;
  }
#line 4522
  if (ngx_event_actions.add_conn) {
    {
#line 4523
    tmp___5 = (*(ngx_event_actions.add_conn))(c);
    }
#line 4523
    if (tmp___5 == -1L) {
#line 4524
      goto failed;
    }
  }
  {
#line 4531
  rc = connect(s, (struct sockaddr  const  */* __restrict  */)rec->sockaddr, rec->socklen);
  }
#line 4533
  if (rc == -1) {
    {
#line 4534
    tmp___6 = __errno_location();
#line 4534
    err = *tmp___6;
    }
#line 4537
    if (err != 115) {
#line 4544
      if (err == 111) {
#line 4558
        level = (ngx_uint_t )4;
      } else
#line 4544
      if (err == 11) {
#line 4558
        level = (ngx_uint_t )4;
      } else
#line 4544
      if (err == 104) {
#line 4558
        level = (ngx_uint_t )4;
      } else
#line 4544
      if (err == 100) {
#line 4558
        level = (ngx_uint_t )4;
      } else
#line 4544
      if (err == 101) {
#line 4558
        level = (ngx_uint_t )4;
      } else
#line 4544
      if (err == 112) {
#line 4558
        level = (ngx_uint_t )4;
      } else
#line 4544
      if (err == 113) {
#line 4558
        level = (ngx_uint_t )4;
      } else {
#line 4561
        level = (ngx_uint_t )3;
      }
#line 4564
      if ((c->log)->log_level >= level) {
        {
#line 4564
        ngx_log_error_core(level, c->log, err, "connect() to %V failed", & rec->server);
        }
      }
      {
#line 4567
      ngx_close_connection(c);
#line 4568
      rec->tcp = (ngx_connection_t *)((void *)0);
      }
#line 4570
      return ((ngx_int_t )-1);
    }
  }
#line 4574
  if (ngx_event_actions.add_conn) {
#line 4575
    if (rc == -1) {
#line 4579
      return ((ngx_int_t )-2);
    }
#line 4584
    wev->ready = 1U;
#line 4586
    return ((ngx_int_t )0);
  }
#line 4589
  if (ngx_event_flags & 512UL) {
    {
#line 4594
    tmp___8 = ngx_blocking(s);
    }
#line 4594
    if (tmp___8 == -1) {
#line 4595
      if (rec->log.log_level >= 2UL) {
        {
#line 4595
        tmp___7 = __errno_location();
#line 4595
        ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___7, "ioctl(!FIONBIO) failed");
        }
      }
#line 4597
      goto failed;
    }
#line 4607
    rev->ready = 1U;
#line 4608
    wev->ready = 1U;
#line 4610
    return ((ngx_int_t )0);
  }
#line 4613
  if (ngx_event_flags & 4UL) {
#line 4617
    event = (ngx_int_t )2147483648U;
  } else {
#line 4623
    event = (ngx_int_t )0;
  }
  {
#line 4626
  tmp___9 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )event);
  }
#line 4626
  if (tmp___9 != 0L) {
#line 4627
    goto failed;
  }
#line 4630
  if (rc == -1) {
    {
#line 4634
    tmp___10 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )event);
    }
#line 4634
    if (tmp___10 != 0L) {
#line 4635
      goto failed;
    }
#line 4638
    return ((ngx_int_t )-2);
  }
#line 4643
  wev->ready = 1U;
#line 4645
  return ((ngx_int_t )0);
  failed: 
  {
#line 4649
  ngx_close_connection(c);
#line 4650
  rec->tcp = (ngx_connection_t *)((void *)0);
  }
#line 4652
  return ((ngx_int_t )-1);
}
}
#line 4656 "/tmp/nginx-1.13.2/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_cmp_srvs(void const   *one , void const   *two ) 
{ 
  ngx_int_t p1 ;
  ngx_int_t p2 ;
  ngx_resolver_srv_t *first ;
  ngx_resolver_srv_t *second ;

  {
#line 4662
  first = (ngx_resolver_srv_t *)one;
#line 4663
  second = (ngx_resolver_srv_t *)two;
#line 4665
  p1 = (ngx_int_t )first->priority;
#line 4666
  p2 = (ngx_int_t )second->priority;
#line 4668
  return (p1 - p2);
}
}
#line 267 "src/core/ngx_module.h"
ngx_int_t ngx_preinit_modules(void) ;
#line 268
ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle ) ;
#line 269
ngx_int_t ngx_init_modules(ngx_cycle_t *cycle ) ;
#line 273
ngx_int_t ngx_add_module(ngx_conf_t *cf , ngx_str_t *file , ngx_module_t *module ,
                         char **order ) ;
#line 278 "src/core/ngx_module.h"
ngx_uint_t ngx_max_module  ;
#line 16 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
static ngx_uint_t ngx_module_index(ngx_cycle_t *cycle ) ;
#line 17
static ngx_uint_t ngx_module_ctx_index(ngx_cycle_t *cycle , ngx_uint_t type , ngx_uint_t index___0 ) ;
#line 22 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
static ngx_uint_t ngx_modules_n  ;
#line 25 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
ngx_int_t ngx_preinit_modules(void) 
{ 
  ngx_uint_t i ;

  {
#line 30
  i = (ngx_uint_t )0;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! ngx_modules[i]) {
#line 30
      goto while_break;
    }
#line 31
    (ngx_modules[i])->index = i;
#line 32
    (ngx_modules[i])->name = ngx_module_names[i];
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  ngx_modules_n = i;
#line 36
  ngx_max_module = ngx_modules_n + 128UL;
#line 38
  return ((ngx_int_t )0);
}
}
#line 42 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = ngx_pcalloc(cycle->pool, (ngx_max_module + 1UL) * sizeof(ngx_module_t *));
#line 50
  cycle->modules = (ngx_module_t **)tmp;
  }
#line 52
  if ((unsigned long )cycle->modules == (unsigned long )((void *)0)) {
#line 53
    return ((ngx_int_t )-1);
  }
  {
#line 56
  memcpy((void */* __restrict  */)cycle->modules, (void const   */* __restrict  */)(ngx_modules),
         ngx_modules_n * sizeof(ngx_module_t *));
#line 59
  cycle->modules_n = ngx_modules_n;
  }
#line 61
  return ((ngx_int_t )0);
}
}
#line 65 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
ngx_int_t ngx_init_modules(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_int_t tmp ;

  {
#line 70
  i = (ngx_uint_t )0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! *(cycle->modules + i)) {
#line 70
      goto while_break;
    }
#line 71
    if ((*(cycle->modules + i))->init_module) {
      {
#line 72
      tmp = (*((*(cycle->modules + i))->init_module))(cycle);
      }
#line 72
      if (tmp != 0L) {
#line 73
        return ((ngx_int_t )-1);
      }
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return ((ngx_int_t )0);
}
}
#line 82 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
ngx_int_t ngx_count_modules(ngx_cycle_t *cycle , ngx_uint_t type ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t next ;
  ngx_uint_t max ;
  ngx_module_t *module ;

  {
#line 88
  next = (ngx_uint_t )0;
#line 89
  max = (ngx_uint_t )0;
#line 93
  i = (ngx_uint_t )0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! *(cycle->modules + i)) {
#line 93
      goto while_break;
    }
#line 94
    module = *(cycle->modules + i);
#line 96
    if (module->type != type) {
#line 97
      goto __Cont;
    }
#line 100
    if (module->ctx_index != 0xffffffffffffffffUL) {
#line 104
      if (module->ctx_index > max) {
#line 105
        max = module->ctx_index;
      }
#line 108
      if (module->ctx_index == next) {
#line 109
        next ++;
      }
#line 112
      goto __Cont;
    }
    {
#line 117
    module->ctx_index = ngx_module_ctx_index(cycle, type, next);
    }
#line 119
    if (module->ctx_index > max) {
#line 120
      max = module->ctx_index;
    }
#line 123
    next = module->ctx_index + 1UL;
    __Cont: /* CIL Label */ 
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (cycle->old_cycle) {
#line 133
    if ((cycle->old_cycle)->modules) {
#line 135
      i = (ngx_uint_t )0;
      {
#line 135
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 135
        if (! *((cycle->old_cycle)->modules + i)) {
#line 135
          goto while_break___0;
        }
#line 136
        module = *((cycle->old_cycle)->modules + i);
#line 138
        if (module->type != type) {
#line 139
          goto __Cont___0;
        }
#line 142
        if (module->ctx_index > max) {
#line 143
          max = module->ctx_index;
        }
        __Cont___0: /* CIL Label */ 
#line 135
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 150
  cycle->modules_used = (ngx_uint_t )1;
#line 152
  return ((ngx_int_t )(max + 1UL));
}
}
#line 156 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
ngx_int_t ngx_add_module(ngx_conf_t *cf , ngx_str_t *file , ngx_module_t *module ,
                         char **order ) 
{ 
  void *rv ;
  ngx_uint_t i ;
  ngx_uint_t m ;
  ngx_uint_t before ;
  ngx_core_module_t *core_module ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 164
  if ((cf->cycle)->modules_n >= ngx_max_module) {
    {
#line 165
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too many modules loaded");
    }
#line 167
    return ((ngx_int_t )-1);
  }
#line 170
  if (module->version != 1013002UL) {
    {
#line 171
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "module \"%V\" version %ui instead of %ui",
                       file, module->version, (ngx_uint_t )1013002);
    }
#line 174
    return ((ngx_int_t )-1);
  }
  {
#line 177
  tmp = strcmp(module->signature, "8,4,8,0000111111010111001110101111000110");
  }
#line 177
  if (tmp != 0) {
    {
#line 178
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "module \"%V\" is not binary compatible",
                       file);
    }
#line 181
    return ((ngx_int_t )-1);
  }
#line 184
  m = (ngx_uint_t )0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! *((cf->cycle)->modules + m)) {
#line 184
      goto while_break;
    }
    {
#line 185
    tmp___0 = strcmp((char const   *)(*((cf->cycle)->modules + m))->name, (char const   *)module->name);
    }
#line 185
    if (tmp___0 == 0) {
      {
#line 186
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "module \"%s\" is already loaded",
                         module->name);
      }
#line 189
      return ((ngx_int_t )-1);
    }
#line 184
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  if (module->index == 0xffffffffffffffffUL) {
    {
#line 198
    module->index = ngx_module_index(cf->cycle);
    }
#line 200
    if (module->index >= ngx_max_module) {
      {
#line 201
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too many modules loaded");
      }
#line 203
      return ((ngx_int_t )-1);
    }
  }
#line 211
  before = (cf->cycle)->modules_n;
#line 213
  if (order) {
#line 214
    i = (ngx_uint_t )0;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! *(order + i)) {
#line 214
        goto while_break___0;
      }
      {
#line 215
      tmp___1 = strcmp((char const   *)*(order + i), (char const   *)module->name);
      }
#line 215
      if (tmp___1 == 0) {
#line 216
        i ++;
#line 217
        goto while_break___0;
      }
#line 214
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 221
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 221
      if (! *(order + i)) {
#line 221
        goto while_break___1;
      }
#line 229
      m = (ngx_uint_t )0;
      {
#line 229
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 229
        if (! (m < before)) {
#line 229
          goto while_break___2;
        }
        {
#line 230
        tmp___2 = strcmp((char const   *)(*((cf->cycle)->modules + m))->name, (char const   *)*(order + i));
        }
#line 230
        if (tmp___2 == 0) {
#line 236
          before = m;
#line 237
          goto while_break___2;
        }
#line 229
        m ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 221
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 245
  if (before != (cf->cycle)->modules_n) {
    {
#line 246
    memmove((void *)((cf->cycle)->modules + (before + 1UL)), (void const   *)((cf->cycle)->modules + before),
            ((cf->cycle)->modules_n - before) * sizeof(ngx_module_t *));
    }
  }
#line 251
  *((cf->cycle)->modules + before) = module;
#line 252
  ((cf->cycle)->modules_n) ++;
#line 254
  if (module->type == 1163022147UL) {
#line 263
    core_module = (ngx_core_module_t *)module->ctx;
#line 265
    if (core_module->create_conf) {
      {
#line 266
      rv = (*(core_module->create_conf))(cf->cycle);
      }
#line 267
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 268
        return ((ngx_int_t )-1);
      }
#line 271
      *((cf->cycle)->conf_ctx + module->index) = (void ***)rv;
    }
  }
#line 275
  return ((ngx_int_t )0);
}
}
#line 279 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
static ngx_uint_t ngx_module_index(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t index___0 ;
  ngx_module_t *module ;

  {
#line 285
  index___0 = (ngx_uint_t )0;
  again: 
#line 291
  i = (ngx_uint_t )0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! *(cycle->modules + i)) {
#line 291
      goto while_break;
    }
#line 292
    module = *(cycle->modules + i);
#line 294
    if (module->index == index___0) {
#line 295
      index___0 ++;
#line 296
      goto again;
    }
#line 291
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  if (cycle->old_cycle) {
#line 302
    if ((cycle->old_cycle)->modules) {
#line 304
      i = (ngx_uint_t )0;
      {
#line 304
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 304
        if (! *((cycle->old_cycle)->modules + i)) {
#line 304
          goto while_break___0;
        }
#line 305
        module = *((cycle->old_cycle)->modules + i);
#line 307
        if (module->index == index___0) {
#line 308
          index___0 ++;
#line 309
          goto again;
        }
#line 304
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 314
  return (index___0);
}
}
#line 318 "/tmp/nginx-1.13.2/src/core/ngx_module.c"
static ngx_uint_t ngx_module_ctx_index(ngx_cycle_t *cycle , ngx_uint_t type , ngx_uint_t index___0 ) 
{ 
  ngx_uint_t i ;
  ngx_module_t *module ;

  {
  again: 
#line 328
  i = (ngx_uint_t )0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! *(cycle->modules + i)) {
#line 328
      goto while_break;
    }
#line 329
    module = *(cycle->modules + i);
#line 331
    if (module->type != type) {
#line 332
      goto __Cont;
    }
#line 335
    if (module->ctx_index == index___0) {
#line 336
      index___0 ++;
#line 337
      goto again;
    }
    __Cont: /* CIL Label */ 
#line 328
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if (cycle->old_cycle) {
#line 343
    if ((cycle->old_cycle)->modules) {
#line 345
      i = (ngx_uint_t )0;
      {
#line 345
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 345
        if (! *((cycle->old_cycle)->modules + i)) {
#line 345
          goto while_break___0;
        }
#line 346
        module = *((cycle->old_cycle)->modules + i);
#line 348
        if (module->type != type) {
#line 349
          goto __Cont___0;
        }
#line 352
        if (module->ctx_index == index___0) {
#line 353
          index___0 ++;
#line 354
          goto again;
        }
        __Cont___0: /* CIL Label */ 
#line 345
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 359
  return (index___0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 302 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 153 "src/core/ngx_string.h"
u_char *ngx_vslprintf(u_char *buf , u_char *last , char const   *fmt , va_list___0 args___0 ) ;
#line 234 "src/core/ngx_log.h"
u_char *ngx_log_errno(u_char *buf , u_char *last , ngx_err_t err ) ;
#line 140 "src/core/ngx_cycle.h"
ngx_uint_t ngx_dump_config ;
#line 172 "src/core/ngx_conf_file.h"
char *ngx_conf_deprecated(ngx_conf_t *cf , void *post , void *data ) ;
#line 268
char *ngx_conf_param(ngx_conf_t *cf ) ;
#line 13 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_add_dump(ngx_conf_t *cf , ngx_str_t *filename ) ;
#line 14
static ngx_int_t ngx_conf_handler(ngx_conf_t *cf , ngx_int_t last ) ;
#line 15
static ngx_int_t ngx_conf_read_token(ngx_conf_t *cf ) ;
#line 16
static void ngx_conf_flush_files(ngx_cycle_t *cycle ) ;
#line 19 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
static ngx_command_t ngx_conf_commands[2]  = {      {{sizeof("include") - 1UL, (u_char *)"include"}, (ngx_uint_t )520093698, & ngx_conf_include,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 32 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
ngx_module_t ngx_conf_module  = 
#line 32
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)0, ngx_conf_commands,
    (ngx_uint_t )1179537219, (ngx_int_t (*)(ngx_log_t *log ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), & ngx_conf_flush_files, (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 50 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
static ngx_uint_t argument_number[8]  = 
#line 50
  {      (ngx_uint_t )1,      (ngx_uint_t )2,      (ngx_uint_t )4,      (ngx_uint_t )8, 
        (ngx_uint_t )16,      (ngx_uint_t )32,      (ngx_uint_t )64,      (ngx_uint_t )128};
#line 62 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_param(ngx_conf_t *cf ) 
{ 
  char *rv ;
  ngx_str_t *param ;
  ngx_buf_t b ;
  ngx_conf_file_t conf_file ;

  {
#line 70
  param = & (cf->cycle)->conf_param;
#line 72
  if (param->len == 0UL) {
#line 73
    return ((char *)((void *)0));
  }
  {
#line 76
  memset((void *)(& conf_file), 0, sizeof(ngx_conf_file_t ));
#line 78
  memset((void *)(& b), 0, sizeof(ngx_buf_t ));
#line 80
  b.start = param->data;
#line 81
  b.pos = param->data;
#line 82
  b.last = param->data + param->len;
#line 83
  b.end = b.last;
#line 84
  b.temporary = 1U;
#line 86
  conf_file.file.fd = -1;
#line 87
  conf_file.file.name.data = (u_char *)((void *)0);
#line 88
  conf_file.line = (ngx_uint_t )0;
#line 90
  cf->conf_file = & conf_file;
#line 91
  (cf->conf_file)->buffer = & b;
#line 93
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 95
  cf->conf_file = (ngx_conf_file_t *)((void *)0);
  }
#line 97
  return (rv);
}
}
#line 101 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_add_dump(ngx_conf_t *cf , ngx_str_t *filename ) 
{ 
  off_t size ;
  u_char *p ;
  uint32_t hash ;
  ngx_buf_t *buf ;
  ngx_str_node_t *sn ;
  ngx_conf_dump_t *cd ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 111
  hash = ngx_crc32_long(filename->data, filename->len);
#line 113
  sn = ngx_str_rbtree_lookup(& (cf->cycle)->config_dump_rbtree, filename, hash);
  }
#line 115
  if (sn) {
#line 116
    (cf->conf_file)->dump = (ngx_buf_t *)((void *)0);
#line 117
    return ((ngx_int_t )0);
  }
  {
#line 120
  p = ngx_pstrdup((cf->cycle)->pool, filename);
  }
#line 121
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 122
    return ((ngx_int_t )-1);
  }
  {
#line 125
  tmp = ngx_array_push(& (cf->cycle)->config_dump);
#line 125
  cd = (ngx_conf_dump_t *)tmp;
  }
#line 126
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 127
    return ((ngx_int_t )-1);
  }
  {
#line 130
  size = (cf->conf_file)->file.info.st_size;
#line 132
  buf = ngx_create_temp_buf((cf->cycle)->pool, (size_t___0 )size);
  }
#line 133
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 134
    return ((ngx_int_t )-1);
  }
  {
#line 137
  cd->name.data = p;
#line 138
  cd->name.len = filename->len;
#line 139
  cd->buffer = buf;
#line 141
  (cf->conf_file)->dump = buf;
#line 143
  tmp___0 = ngx_palloc(cf->temp_pool, sizeof(ngx_str_node_t ));
#line 143
  sn = (ngx_str_node_t *)tmp___0;
  }
#line 144
  if ((unsigned long )sn == (unsigned long )((void *)0)) {
#line 145
    return ((ngx_int_t )-1);
  }
  {
#line 148
  sn->node.key = (ngx_rbtree_key_t )hash;
#line 149
  sn->str = cd->name;
#line 151
  ngx_rbtree_insert(& (cf->cycle)->config_dump_rbtree, & sn->node);
  }
#line 153
  return ((ngx_int_t )0);
}
}
#line 157 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_parse(ngx_conf_t *cf , ngx_str_t *filename ) 
{ 
  char *rv ;
  ngx_fd_t fd ;
  ngx_int_t rc ;
  ngx_buf_t buf ;
  ngx_conf_file_t *prev ;
  ngx_conf_file_t conf_file ;
  enum __anonenum_type_207765989 type ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 172
  fd = -1;
#line 173
  prev = (ngx_conf_file_t *)((void *)0);
#line 176
  if (filename) {
    {
#line 180
    fd = open((char const   *)filename->data, 0, 0);
    }
#line 181
    if (fd == -1) {
      {
#line 182
      tmp = __errno_location();
#line 182
      ngx_conf_log_error((ngx_uint_t )1, cf, *tmp, "open() \"%s\" failed", filename->data);
      }
#line 185
      return ((char *)((void *)-1));
    }
    {
#line 188
    prev = cf->conf_file;
#line 190
    cf->conf_file = & conf_file;
#line 192
    tmp___1 = fstat(fd, & (cf->conf_file)->file.info);
    }
#line 192
    if (tmp___1 == -1) {
#line 193
      if ((cf->log)->log_level >= 1UL) {
        {
#line 193
        tmp___0 = __errno_location();
#line 193
        ngx_log_error_core((ngx_uint_t )1, cf->log, *tmp___0, "fstat() \"%s\" failed",
                           filename->data);
        }
      }
    }
    {
#line 197
    (cf->conf_file)->buffer = & buf;
#line 199
    tmp___2 = ngx_alloc((size_t___0 )4096, cf->log);
#line 199
    buf.start = (u_char *)tmp___2;
    }
#line 200
    if ((unsigned long )buf.start == (unsigned long )((void *)0)) {
#line 201
      goto failed;
    }
#line 204
    buf.pos = buf.start;
#line 205
    buf.last = buf.start;
#line 206
    buf.end = buf.last + 4096;
#line 207
    buf.temporary = 1U;
#line 209
    (cf->conf_file)->file.fd = fd;
#line 210
    (cf->conf_file)->file.name.len = filename->len;
#line 211
    (cf->conf_file)->file.name.data = filename->data;
#line 212
    (cf->conf_file)->file.offset = (off_t )0;
#line 213
    (cf->conf_file)->file.log = cf->log;
#line 214
    (cf->conf_file)->line = (ngx_uint_t )1;
#line 216
    type = (enum __anonenum_type_207765989 )0;
#line 218
    if (ngx_dump_config) {
      {
#line 224
      tmp___3 = ngx_conf_add_dump(cf, filename);
      }
#line 224
      if (tmp___3 != 0L) {
#line 225
        goto failed;
      }
    } else {
#line 229
      (cf->conf_file)->dump = (ngx_buf_t *)((void *)0);
    }
  } else
#line 232
  if ((cf->conf_file)->file.fd != -1) {
#line 234
    type = (enum __anonenum_type_207765989 )1;
  } else {
#line 237
    type = (enum __anonenum_type_207765989 )2;
  }
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 242
    rc = ngx_conf_read_token(cf);
    }
#line 254
    if (rc == -1L) {
#line 255
      goto done;
    }
#line 258
    if (rc == 2L) {
#line 260
      if ((unsigned int )type != 1U) {
        {
#line 261
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"}\"");
        }
#line 262
        goto failed;
      }
#line 265
      goto done;
    }
#line 268
    if (rc == 3L) {
#line 270
      if ((unsigned int )type == 1U) {
        {
#line 271
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected end of file, expecting \"}\"");
        }
#line 273
        goto failed;
      }
#line 276
      goto done;
    }
#line 279
    if (rc == 1L) {
#line 281
      if ((unsigned int )type == 2U) {
        {
#line 282
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "block directives are not supported in -g option");
        }
#line 285
        goto failed;
      }
    }
#line 291
    if (cf->handler) {
#line 298
      if (rc == 1L) {
        {
#line 299
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"{\"");
        }
#line 300
        goto failed;
      }
      {
#line 303
      rv = (*(cf->handler))(cf, (ngx_command_t *)((void *)0), (void *)cf->handler_conf);
      }
#line 304
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 305
        goto __Cont;
      }
#line 308
      if ((unsigned long )rv == (unsigned long )((void *)-1)) {
#line 309
        goto failed;
      }
      {
#line 312
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, (char const   *)rv);
      }
#line 314
      goto failed;
    }
    {
#line 318
    rc = ngx_conf_handler(cf, rc);
    }
#line 320
    if (rc == -1L) {
#line 321
      goto failed;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 327
  rc = (ngx_int_t )-1;
  done: 
#line 331
  if (filename) {
#line 332
    if (((cf->conf_file)->buffer)->start) {
      {
#line 333
      free((void *)((cf->conf_file)->buffer)->start);
      }
    }
    {
#line 336
    tmp___5 = close(fd);
    }
#line 336
    if (tmp___5 == -1) {
#line 337
      if ((cf->log)->log_level >= 2UL) {
        {
#line 337
        tmp___4 = __errno_location();
#line 337
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___4, "close() %s failed",
                           filename->data);
        }
      }
#line 340
      rc = (ngx_int_t )-1;
    }
#line 343
    cf->conf_file = prev;
  }
#line 346
  if (rc == -1L) {
#line 347
    return ((char *)((void *)-1));
  }
#line 350
  return ((char *)((void *)0));
}
}
#line 354 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_handler(ngx_conf_t *cf , ngx_int_t last ) 
{ 
  char *rv ;
  void *conf ;
  void **confp ;
  ngx_uint_t i ;
  ngx_uint_t found ;
  ngx_str_t *name ;
  ngx_command_t *cmd ;
  int tmp ;

  {
#line 363
  name = (ngx_str_t *)(cf->args)->elts;
#line 365
  found = (ngx_uint_t )0;
#line 367
  i = (ngx_uint_t )0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! *((cf->cycle)->modules + i)) {
#line 367
      goto while_break;
    }
#line 369
    cmd = (*((cf->cycle)->modules + i))->commands;
#line 370
    if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 371
      goto __Cont;
    }
    {
#line 374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 374
      if (! cmd->name.len) {
#line 374
        goto while_break___0;
      }
#line 376
      if (name->len != cmd->name.len) {
#line 377
        goto __Cont___0;
      }
      {
#line 380
      tmp = strcmp((char const   *)name->data, (char const   *)cmd->name.data);
      }
#line 380
      if (tmp != 0) {
#line 381
        goto __Cont___0;
      }
#line 384
      found = (ngx_uint_t )1;
#line 386
      if ((*((cf->cycle)->modules + i))->type != 1179537219UL) {
#line 386
        if ((*((cf->cycle)->modules + i))->type != cf->module_type) {
#line 389
          goto __Cont___0;
        }
      }
#line 394
      if (! (cmd->type & cf->cmd_type)) {
#line 395
        goto __Cont___0;
      }
#line 398
      if (! (cmd->type & 256UL)) {
#line 398
        if (last != 0L) {
          {
#line 399
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "directive \"%s\" is not terminated by \";\"",
                             name->data);
          }
#line 402
          return ((ngx_int_t )-1);
        }
      }
#line 405
      if (cmd->type & 256UL) {
#line 405
        if (last != 1L) {
          {
#line 406
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "directive \"%s\" has no opening \"{\"",
                             name->data);
          }
#line 409
          return ((ngx_int_t )-1);
        }
      }
#line 414
      if (! (cmd->type & 1024UL)) {
#line 416
        if (cmd->type & 512UL) {
#line 418
          if ((cf->args)->nelts != 2UL) {
#line 419
            goto invalid;
          }
        } else
#line 422
        if (cmd->type & 2048UL) {
#line 424
          if ((cf->args)->nelts < 2UL) {
#line 425
            goto invalid;
          }
        } else
#line 428
        if (cmd->type & 4096UL) {
#line 430
          if ((cf->args)->nelts < 3UL) {
#line 431
            goto invalid;
          }
        } else
#line 434
        if ((cf->args)->nelts > 8UL) {
#line 436
          goto invalid;
        } else
#line 438
        if (! (cmd->type & argument_number[(cf->args)->nelts - 1UL])) {
#line 440
          goto invalid;
        }
      }
#line 446
      conf = (void *)0;
#line 448
      if (cmd->type & 65536UL) {
#line 449
        conf = *((void **)cf->ctx + (*((cf->cycle)->modules + i))->index);
      } else
#line 451
      if (cmd->type & 16777216UL) {
#line 452
        conf = (void *)((void **)cf->ctx + (*((cf->cycle)->modules + i))->index);
      } else
#line 454
      if (cf->ctx) {
#line 455
        confp = (void **)*((void **)((char *)cf->ctx + cmd->conf));
#line 457
        if (confp) {
#line 458
          conf = *(confp + (*((cf->cycle)->modules + i))->ctx_index);
        }
      }
      {
#line 462
      rv = (*(cmd->set))(cf, cmd, conf);
      }
#line 464
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 465
        return ((ngx_int_t )0);
      }
#line 468
      if ((unsigned long )rv == (unsigned long )((void *)-1)) {
#line 469
        return ((ngx_int_t )-1);
      }
      {
#line 472
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%s\" directive %s", name->data,
                         rv);
      }
#line 475
      return ((ngx_int_t )-1);
      __Cont___0: /* CIL Label */ 
#line 374
      cmd ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 367
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  if (found) {
    {
#line 480
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%s\" directive is not allowed here",
                       name->data);
    }
#line 483
    return ((ngx_int_t )-1);
  }
  {
#line 486
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown directive \"%s\"", name->data);
  }
#line 489
  return ((ngx_int_t )-1);
  invalid: 
  {
#line 493
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of arguments in \"%s\" directive",
                     name->data);
  }
#line 497
  return ((ngx_int_t )-1);
}
}
#line 501 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_read_token(ngx_conf_t *cf ) 
{ 
  u_char *start ;
  u_char ch ;
  u_char *src ;
  u_char *dst ;
  off_t file_size ;
  size_t___0 len ;
  ssize_t n ;
  ssize_t size ;
  ngx_uint_t found ;
  ngx_uint_t need_space ;
  ngx_uint_t last_space ;
  ngx_uint_t sharp_comment ;
  ngx_uint_t variable ;
  ngx_uint_t quoted ;
  ngx_uint_t s_quoted ;
  ngx_uint_t d_quoted ;
  ngx_uint_t start_line ;
  ngx_str_t *word ;
  ngx_buf_t *b ;
  ngx_buf_t *dump ;
  void *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;

  {
#line 513
  found = (ngx_uint_t )0;
#line 514
  need_space = (ngx_uint_t )0;
#line 515
  last_space = (ngx_uint_t )1;
#line 516
  sharp_comment = (ngx_uint_t )0;
#line 517
  variable = (ngx_uint_t )0;
#line 518
  quoted = (ngx_uint_t )0;
#line 519
  s_quoted = (ngx_uint_t )0;
#line 520
  d_quoted = (ngx_uint_t )0;
#line 522
  (cf->args)->nelts = (ngx_uint_t )0;
#line 523
  b = (cf->conf_file)->buffer;
#line 524
  dump = (cf->conf_file)->dump;
#line 525
  start = b->pos;
#line 526
  start_line = (cf->conf_file)->line;
#line 528
  file_size = (cf->conf_file)->file.info.st_size;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if ((unsigned long )b->pos >= (unsigned long )b->last) {
#line 534
      if ((cf->conf_file)->file.offset >= file_size) {
#line 536
        if ((cf->args)->nelts > 0UL) {
#line 536
          goto _L;
        } else
#line 536
        if (! last_space) {
          _L: /* CIL Label */ 
#line 538
          if ((cf->conf_file)->file.fd == -1) {
            {
#line 539
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected end of parameter, expecting \";\"");
            }
#line 542
            return ((ngx_int_t )-1);
          }
          {
#line 545
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected end of file, expecting \";\" or \"}\"");
          }
#line 548
          return ((ngx_int_t )-1);
        }
#line 551
        return ((ngx_int_t )3);
      }
#line 554
      len = (size_t___0 )(b->pos - start);
#line 556
      if (len == 4096UL) {
#line 557
        (cf->conf_file)->line = start_line;
#line 559
        if (d_quoted) {
#line 560
          ch = (u_char )'\"';
        } else
#line 562
        if (s_quoted) {
#line 563
          ch = (u_char )'\'';
        } else {
          {
#line 566
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too long parameter \"%*s...\" started",
                             10, start);
          }
#line 569
          return ((ngx_int_t )-1);
        }
        {
#line 572
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too long parameter, probably missing terminating \"%c\" character",
                           (int )ch);
        }
#line 575
        return ((ngx_int_t )-1);
      }
#line 578
      if (len) {
        {
#line 579
        memmove((void *)b->start, (void const   *)start, len);
        }
      }
#line 582
      size = file_size - (cf->conf_file)->file.offset;
#line 584
      if (size > b->end - (b->start + len)) {
#line 585
        size = b->end - (b->start + len);
      }
      {
#line 588
      n = ngx_read_file(& (cf->conf_file)->file, b->start + len, (size_t___0 )size,
                        (cf->conf_file)->file.offset);
      }
#line 591
      if (n == -1L) {
#line 592
        return ((ngx_int_t )-1);
      }
#line 595
      if (n != size) {
        {
#line 596
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "pread() returned only %z bytes instead of %z",
                           n, size);
        }
#line 600
        return ((ngx_int_t )-1);
      }
#line 603
      b->pos = b->start + len;
#line 604
      b->last = b->pos + n;
#line 605
      start = b->start;
#line 607
      if (dump) {
        {
#line 608
        tmp = memcpy((void */* __restrict  */)dump->last, (void const   */* __restrict  */)b->pos,
                     (size_t )size);
#line 608
        dump->last = (u_char *)tmp + size;
        }
      }
    }
#line 612
    tmp___0 = b->pos;
#line 612
    (b->pos) ++;
#line 612
    ch = *tmp___0;
#line 614
    if ((int )ch == 10) {
#line 615
      ((cf->conf_file)->line) ++;
#line 617
      if (sharp_comment) {
#line 618
        sharp_comment = (ngx_uint_t )0;
      }
    }
#line 622
    if (sharp_comment) {
#line 623
      goto __Cont;
    }
#line 626
    if (quoted) {
#line 627
      quoted = (ngx_uint_t )0;
#line 628
      goto __Cont;
    }
#line 631
    if (need_space) {
#line 632
      if ((int )ch == 32) {
#line 633
        last_space = (ngx_uint_t )1;
#line 634
        need_space = (ngx_uint_t )0;
#line 635
        goto __Cont;
      } else
#line 632
      if ((int )ch == 9) {
#line 633
        last_space = (ngx_uint_t )1;
#line 634
        need_space = (ngx_uint_t )0;
#line 635
        goto __Cont;
      } else
#line 632
      if ((int )ch == 13) {
#line 633
        last_space = (ngx_uint_t )1;
#line 634
        need_space = (ngx_uint_t )0;
#line 635
        goto __Cont;
      } else
#line 632
      if ((int )ch == 10) {
#line 633
        last_space = (ngx_uint_t )1;
#line 634
        need_space = (ngx_uint_t )0;
#line 635
        goto __Cont;
      }
#line 638
      if ((int )ch == 59) {
#line 639
        return ((ngx_int_t )0);
      }
#line 642
      if ((int )ch == 123) {
#line 643
        return ((ngx_int_t )1);
      }
#line 646
      if ((int )ch == 41) {
#line 647
        last_space = (ngx_uint_t )1;
#line 648
        need_space = (ngx_uint_t )0;
      } else {
        {
#line 651
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"%c\"", (int )ch);
        }
#line 653
        return ((ngx_int_t )-1);
      }
    }
#line 657
    if (last_space) {
#line 658
      if ((int )ch == 32) {
#line 659
        goto __Cont;
      } else
#line 658
      if ((int )ch == 9) {
#line 659
        goto __Cont;
      } else
#line 658
      if ((int )ch == 13) {
#line 659
        goto __Cont;
      } else
#line 658
      if ((int )ch == 10) {
#line 659
        goto __Cont;
      }
#line 662
      start = b->pos - 1;
#line 663
      start_line = (cf->conf_file)->line;
      {
#line 668
      if ((int )ch == 123) {
#line 668
        goto case_123;
      }
#line 668
      if ((int )ch == 59) {
#line 668
        goto case_123;
      }
#line 681
      if ((int )ch == 125) {
#line 681
        goto case_125;
      }
#line 690
      if ((int )ch == 35) {
#line 690
        goto case_35;
      }
#line 694
      if ((int )ch == 92) {
#line 694
        goto case_92;
      }
#line 699
      if ((int )ch == 34) {
#line 699
        goto case_34;
      }
#line 705
      if ((int )ch == 39) {
#line 705
        goto case_39;
      }
#line 711
      goto switch_default;
      case_123: /* CIL Label */ 
      case_59: /* CIL Label */ 
#line 669
      if ((cf->args)->nelts == 0UL) {
        {
#line 670
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"%c\"", (int )ch);
        }
#line 672
        return ((ngx_int_t )-1);
      }
#line 675
      if ((int )ch == 123) {
#line 676
        return ((ngx_int_t )1);
      }
#line 679
      return ((ngx_int_t )0);
      case_125: /* CIL Label */ 
#line 682
      if ((cf->args)->nelts != 0UL) {
        {
#line 683
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"}\"");
        }
#line 685
        return ((ngx_int_t )-1);
      }
#line 688
      return ((ngx_int_t )2);
      case_35: /* CIL Label */ 
#line 691
      sharp_comment = (ngx_uint_t )1;
#line 692
      goto __Cont;
      case_92: /* CIL Label */ 
#line 695
      quoted = (ngx_uint_t )1;
#line 696
      last_space = (ngx_uint_t )0;
#line 697
      goto __Cont;
      case_34: /* CIL Label */ 
#line 700
      start ++;
#line 701
      d_quoted = (ngx_uint_t )1;
#line 702
      last_space = (ngx_uint_t )0;
#line 703
      goto __Cont;
      case_39: /* CIL Label */ 
#line 706
      start ++;
#line 707
      s_quoted = (ngx_uint_t )1;
#line 708
      last_space = (ngx_uint_t )0;
#line 709
      goto __Cont;
      switch_default: /* CIL Label */ 
#line 712
      last_space = (ngx_uint_t )0;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 716
      if ((int )ch == 123) {
#line 716
        if (variable) {
#line 717
          goto __Cont;
        }
      }
#line 720
      variable = (ngx_uint_t )0;
#line 722
      if ((int )ch == 92) {
#line 723
        quoted = (ngx_uint_t )1;
#line 724
        goto __Cont;
      }
#line 727
      if ((int )ch == 36) {
#line 728
        variable = (ngx_uint_t )1;
#line 729
        goto __Cont;
      }
#line 732
      if (d_quoted) {
#line 733
        if ((int )ch == 34) {
#line 734
          d_quoted = (ngx_uint_t )0;
#line 735
          need_space = (ngx_uint_t )1;
#line 736
          found = (ngx_uint_t )1;
        }
      } else
#line 739
      if (s_quoted) {
#line 740
        if ((int )ch == 39) {
#line 741
          s_quoted = (ngx_uint_t )0;
#line 742
          need_space = (ngx_uint_t )1;
#line 743
          found = (ngx_uint_t )1;
        }
      } else
#line 746
      if ((int )ch == 32) {
#line 749
        last_space = (ngx_uint_t )1;
#line 750
        found = (ngx_uint_t )1;
      } else
#line 746
      if ((int )ch == 9) {
#line 749
        last_space = (ngx_uint_t )1;
#line 750
        found = (ngx_uint_t )1;
      } else
#line 746
      if ((int )ch == 13) {
#line 749
        last_space = (ngx_uint_t )1;
#line 750
        found = (ngx_uint_t )1;
      } else
#line 746
      if ((int )ch == 10) {
#line 749
        last_space = (ngx_uint_t )1;
#line 750
        found = (ngx_uint_t )1;
      } else
#line 746
      if ((int )ch == 59) {
#line 749
        last_space = (ngx_uint_t )1;
#line 750
        found = (ngx_uint_t )1;
      } else
#line 746
      if ((int )ch == 123) {
#line 749
        last_space = (ngx_uint_t )1;
#line 750
        found = (ngx_uint_t )1;
      }
#line 753
      if (found) {
        {
#line 754
        tmp___1 = ngx_array_push(cf->args);
#line 754
        word = (ngx_str_t *)tmp___1;
        }
#line 755
        if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 756
          return ((ngx_int_t )-1);
        }
        {
#line 759
        tmp___2 = ngx_pnalloc(cf->pool, (size_t___0 )(((b->pos - 1) - start) + 1L));
#line 759
        word->data = (u_char *)tmp___2;
        }
#line 760
        if ((unsigned long )word->data == (unsigned long )((void *)0)) {
#line 761
          return ((ngx_int_t )-1);
        }
#line 764
        dst = word->data;
#line 764
        src = start;
#line 764
        len = (size_t___0 )0;
        {
#line 764
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 764
          if (! ((unsigned long )src < (unsigned long )(b->pos - 1))) {
#line 764
            goto while_break___0;
          }
#line 768
          if ((int )*src == 92) {
            {
#line 772
            if ((int )*(src + 1) == 92) {
#line 772
              goto case_92___0;
            }
#line 772
            if ((int )*(src + 1) == 39) {
#line 772
              goto case_92___0;
            }
#line 772
            if ((int )*(src + 1) == 34) {
#line 772
              goto case_92___0;
            }
#line 776
            if ((int )*(src + 1) == 116) {
#line 776
              goto case_116;
            }
#line 781
            if ((int )*(src + 1) == 114) {
#line 781
              goto case_114;
            }
#line 786
            if ((int )*(src + 1) == 110) {
#line 786
              goto case_110;
            }
#line 769
            goto switch_break___0;
            case_92___0: /* CIL Label */ 
            case_39___0: /* CIL Label */ 
            case_34___0: /* CIL Label */ 
#line 773
            src ++;
#line 774
            goto switch_break___0;
            case_116: /* CIL Label */ 
#line 777
            tmp___3 = dst;
#line 777
            dst ++;
#line 777
            *tmp___3 = (u_char )'\t';
#line 778
            src += 2;
#line 779
            goto __Cont___0;
            case_114: /* CIL Label */ 
#line 782
            tmp___4 = dst;
#line 782
            dst ++;
#line 782
            *tmp___4 = (u_char )'\r';
#line 783
            src += 2;
#line 784
            goto __Cont___0;
            case_110: /* CIL Label */ 
#line 787
            tmp___5 = dst;
#line 787
            dst ++;
#line 787
            *tmp___5 = (u_char )'\n';
#line 788
            src += 2;
#line 789
            goto __Cont___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
#line 793
          tmp___6 = dst;
#line 793
          dst ++;
#line 793
          tmp___7 = src;
#line 793
          src ++;
#line 793
          *tmp___6 = *tmp___7;
          __Cont___0: /* CIL Label */ 
#line 764
          len ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 795
        *dst = (u_char )'\000';
#line 796
        word->len = len;
#line 798
        if ((int )ch == 59) {
#line 799
          return ((ngx_int_t )0);
        }
#line 802
        if ((int )ch == 123) {
#line 803
          return ((ngx_int_t )1);
        }
#line 806
        found = (ngx_uint_t )0;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 813 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_include(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  ngx_int_t n ;
  ngx_str_t *value ;
  ngx_str_t file ;
  ngx_str_t name ;
  ngx_glob_t gl ;
  ngx_int_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  ngx_int_t tmp___3 ;
  size_t___0 tmp___4 ;

  {
  {
#line 821
  value = (ngx_str_t *)(cf->args)->elts;
#line 822
  file = *(value + 1);
#line 826
  tmp = ngx_conf_full_name(cf->cycle, & file, (ngx_uint_t )1);
  }
#line 826
  if (tmp != 0L) {
#line 827
    return ((char *)((void *)-1));
  }
  {
#line 830
  tmp___1 = strpbrk((char const   *)((char *)file.data), "*?[");
  }
#line 830
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 834
    tmp___0 = ngx_conf_parse(cf, & file);
    }
#line 834
    return (tmp___0);
  }
  {
#line 837
  memset((void *)(& gl), 0, sizeof(ngx_glob_t ));
#line 839
  gl.pattern = file.data;
#line 840
  gl.log = cf->log;
#line 841
  gl.test = (ngx_uint_t )1;
#line 843
  tmp___3 = ngx_open_glob(& gl);
  }
#line 843
  if (tmp___3 != 0L) {
    {
#line 844
    tmp___2 = __errno_location();
#line 844
    ngx_conf_log_error((ngx_uint_t )1, cf, *tmp___2, "glob() \"%s\" failed", file.data);
    }
#line 846
    return ((char *)((void *)-1));
  }
#line 849
  rv = (char *)((void *)0);
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 852
    n = ngx_read_glob(& gl, & name);
    }
#line 854
    if (n != 0L) {
#line 855
      goto while_break;
    }
    {
#line 858
    tmp___4 = name.len;
#line 858
    (name.len) ++;
#line 858
    file.len = tmp___4;
#line 859
    file.data = ngx_pstrdup(cf->pool, & name);
    }
#line 860
    if ((unsigned long )file.data == (unsigned long )((void *)0)) {
#line 861
      return ((char *)((void *)-1));
    }
    {
#line 866
    rv = ngx_conf_parse(cf, & file);
    }
#line 868
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 869
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  ngx_close_glob(& gl);
  }
#line 875
  return (rv);
}
}
#line 879 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
ngx_int_t ngx_conf_full_name(ngx_cycle_t *cycle , ngx_str_t *name , ngx_uint_t conf_prefix ) 
{ 
  ngx_str_t *prefix ;
  ngx_int_t tmp ;

  {
#line 884
  if (conf_prefix) {
#line 884
    prefix = & cycle->conf_prefix;
  } else {
#line 884
    prefix = & cycle->prefix;
  }
  {
#line 886
  tmp = ngx_get_full_name(cycle->pool, prefix, name);
  }
#line 886
  return (tmp);
}
}
#line 890 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
ngx_open_file_t *ngx_conf_open_file(ngx_cycle_t *cycle , ngx_str_t *name ) 
{ 
  ngx_str_t full ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_open_file_t *file ;
  ngx_int_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 899
  full.len = (size_t___0 )0;
#line 899
  full.data = (u_char *)((void *)0);
#line 902
  if (name->len) {
    {
#line 903
    full = *name;
#line 905
    tmp = ngx_conf_full_name(cycle, & full, (ngx_uint_t )0);
    }
#line 905
    if (tmp != 0L) {
#line 906
      return ((ngx_open_file_t *)((void *)0));
    }
#line 909
    part = & cycle->open_files.part;
#line 910
    file = (ngx_open_file_t *)part->elts;
#line 912
    i = (ngx_uint_t )0;
    {
#line 912
    while (1) {
      while_continue: /* CIL Label */ ;
#line 914
      if (i >= part->nelts) {
#line 915
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 916
          goto while_break;
        }
#line 918
        part = part->next;
#line 919
        file = (ngx_open_file_t *)part->elts;
#line 920
        i = (ngx_uint_t )0;
      }
#line 923
      if (full.len != (file + i)->name.len) {
#line 924
        goto __Cont;
      }
      {
#line 927
      tmp___0 = strcmp((char const   *)full.data, (char const   *)(file + i)->name.data);
      }
#line 927
      if (tmp___0 == 0) {
#line 928
        return (file + i);
      }
      __Cont: /* CIL Label */ 
#line 912
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 933
  tmp___1 = ngx_list_push(& cycle->open_files);
#line 933
  file = (ngx_open_file_t *)tmp___1;
  }
#line 934
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 935
    return ((ngx_open_file_t *)((void *)0));
  }
#line 938
  if (name->len) {
#line 939
    file->fd = -1;
#line 940
    file->name = full;
  } else {
#line 943
    file->fd = 2;
#line 944
    file->name = *name;
  }
#line 947
  file->flush = (void (*)(ngx_open_file_t *file , ngx_log_t *log ))((void *)0);
#line 948
  file->data = (void *)0;
#line 950
  return (file);
}
}
#line 954 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
static void ngx_conf_flush_files(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_open_file_t *file ;

  {
#line 963
  part = & cycle->open_files.part;
#line 964
  file = (ngx_open_file_t *)part->elts;
#line 966
  i = (ngx_uint_t )0;
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
#line 968
    if (i >= part->nelts) {
#line 969
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 970
        goto while_break;
      }
#line 972
      part = part->next;
#line 973
      file = (ngx_open_file_t *)part->elts;
#line 974
      i = (ngx_uint_t )0;
    }
#line 977
    if ((file + i)->flush) {
      {
#line 978
      (*((file + i)->flush))(file + i, cycle->log);
      }
    }
#line 966
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  return;
}
}
#line 984 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
void ngx_conf_log_error(ngx_uint_t level , ngx_conf_t *cf , ngx_err_t err , char const   *fmt 
                        , ...) 
{ 
  u_char errstr[1024] ;
  u_char *p ;
  u_char *last ;
  va_list___0 args___0 ;

  {
  {
#line 991
  last = errstr + 1024;
#line 993
  __builtin_va_start(args___0, fmt);
#line 994
  p = ngx_vslprintf(errstr, last, fmt, args___0);
#line 995
  __builtin_va_end(args___0);
  }
#line 997
  if (err) {
    {
#line 998
    p = ngx_log_errno(p, last, err);
    }
  }
#line 1001
  if ((unsigned long )cf->conf_file == (unsigned long )((void *)0)) {
#line 1002
    if ((cf->log)->log_level >= level) {
      {
#line 1002
      ngx_log_error_core(level, cf->log, 0, "%*s", p - errstr, errstr);
      }
    }
#line 1003
    return;
  }
#line 1006
  if ((cf->conf_file)->file.fd == -1) {
#line 1007
    if ((cf->log)->log_level >= level) {
      {
#line 1007
      ngx_log_error_core(level, cf->log, 0, "%*s in command line", p - errstr, errstr);
      }
    }
#line 1009
    return;
  }
#line 1012
  if ((cf->log)->log_level >= level) {
    {
#line 1012
    ngx_log_error_core(level, cf->log, 0, "%*s in %s:%ui", p - errstr, errstr, (cf->conf_file)->file.name.data,
                       (cf->conf_file)->line);
    }
  }
#line 1015
  return;
}
}
#line 1018 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_flag_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_flag_t *fp ;
  ngx_conf_post_t *post ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;

  {
#line 1021
  p = (char *)conf;
#line 1027
  fp = (ngx_flag_t *)(p + cmd->offset);
#line 1029
  if (*fp != -1L) {
#line 1030
    return ((char *)"is duplicate");
  }
  {
#line 1033
  value = (ngx_str_t *)(cf->args)->elts;
#line 1035
  tmp___0 = ngx_strcasecmp((value + 1)->data, (u_char *)"on");
  }
#line 1035
  if (tmp___0 == 0L) {
#line 1036
    *fp = (ngx_flag_t )1;
  } else {
    {
#line 1038
    tmp = ngx_strcasecmp((value + 1)->data, (u_char *)"off");
    }
#line 1038
    if (tmp == 0L) {
#line 1039
      *fp = (ngx_flag_t )0;
    } else {
      {
#line 1042
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%s\" in \"%s\" directive, it must be \"on\" or \"off\"",
                         (value + 1)->data, cmd->name.data);
      }
#line 1046
      return ((char *)((void *)-1));
    }
  }
#line 1049
  if (cmd->post) {
    {
#line 1050
    post = (ngx_conf_post_t *)cmd->post;
#line 1051
    tmp___1 = (*(post->post_handler))(cf, (void *)post, (void *)fp);
    }
#line 1051
    return (tmp___1);
  }
#line 1054
  return ((char *)((void *)0));
}
}
#line 1058 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_str_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *field ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;

  {
#line 1061
  p = (char *)conf;
#line 1066
  field = (ngx_str_t *)(p + cmd->offset);
#line 1068
  if (field->data) {
#line 1069
    return ((char *)"is duplicate");
  }
#line 1072
  value = (ngx_str_t *)(cf->args)->elts;
#line 1074
  *field = *(value + 1);
#line 1076
  if (cmd->post) {
    {
#line 1077
    post = (ngx_conf_post_t *)cmd->post;
#line 1078
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)field);
    }
#line 1078
    return (tmp);
  }
#line 1081
  return ((char *)((void *)0));
}
}
#line 1085 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_str_array_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_str_t *s ;
  ngx_array_t **a ;
  ngx_conf_post_t *post ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1088
  p = (char *)conf;
#line 1094
  a = (ngx_array_t **)(p + cmd->offset);
#line 1096
  if ((unsigned long )*a == (unsigned long )((void *)-1)) {
    {
#line 1097
    *a = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
    }
#line 1098
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 1099
      return ((char *)((void *)-1));
    }
  }
  {
#line 1103
  tmp = ngx_array_push(*a);
#line 1103
  s = (ngx_str_t *)tmp;
  }
#line 1104
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1105
    return ((char *)((void *)-1));
  }
#line 1108
  value = (ngx_str_t *)(cf->args)->elts;
#line 1110
  *s = *(value + 1);
#line 1112
  if (cmd->post) {
    {
#line 1113
    post = (ngx_conf_post_t *)cmd->post;
#line 1114
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)s);
    }
#line 1114
    return (tmp___0);
  }
#line 1117
  return ((char *)((void *)0));
}
}
#line 1121 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_keyval_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_array_t **a ;
  ngx_keyval_t *kv ;
  ngx_conf_post_t *post ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1124
  p = (char *)conf;
#line 1131
  a = (ngx_array_t **)(p + cmd->offset);
#line 1133
  if ((unsigned long )*a == (unsigned long )((void *)0)) {
    {
#line 1134
    *a = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_keyval_t ));
    }
#line 1135
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 1136
      return ((char *)((void *)-1));
    }
  }
  {
#line 1140
  tmp = ngx_array_push(*a);
#line 1140
  kv = (ngx_keyval_t *)tmp;
  }
#line 1141
  if ((unsigned long )kv == (unsigned long )((void *)0)) {
#line 1142
    return ((char *)((void *)-1));
  }
#line 1145
  value = (ngx_str_t *)(cf->args)->elts;
#line 1147
  kv->key = *(value + 1);
#line 1148
  kv->value = *(value + 2);
#line 1150
  if (cmd->post) {
    {
#line 1151
    post = (ngx_conf_post_t *)cmd->post;
#line 1152
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)kv);
    }
#line 1152
    return (tmp___0);
  }
#line 1155
  return ((char *)((void *)0));
}
}
#line 1159 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_num_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_int_t *np ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;

  {
#line 1162
  p = (char *)conf;
#line 1169
  np = (ngx_int_t *)(p + cmd->offset);
#line 1171
  if (*np != -1L) {
#line 1172
    return ((char *)"is duplicate");
  }
  {
#line 1175
  value = (ngx_str_t *)(cf->args)->elts;
#line 1176
  *np = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 1177
  if (*np == -1L) {
#line 1178
    return ((char *)"invalid number");
  }
#line 1181
  if (cmd->post) {
    {
#line 1182
    post = (ngx_conf_post_t *)cmd->post;
#line 1183
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)np);
    }
#line 1183
    return (tmp);
  }
#line 1186
  return ((char *)((void *)0));
}
}
#line 1190 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_size_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  size_t___0 *sp ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  ssize_t tmp ;
  char *tmp___0 ;

  {
#line 1193
  p = (char *)conf;
#line 1200
  sp = (size_t___0 *)(p + cmd->offset);
#line 1201
  if (*sp != 0xffffffffffffffffUL) {
#line 1202
    return ((char *)"is duplicate");
  }
  {
#line 1205
  value = (ngx_str_t *)(cf->args)->elts;
#line 1207
  tmp = ngx_parse_size(value + 1);
#line 1207
  *sp = (size_t___0 )tmp;
  }
#line 1208
  if (*sp == 0xffffffffffffffffUL) {
#line 1209
    return ((char *)"invalid value");
  }
#line 1212
  if (cmd->post) {
    {
#line 1213
    post = (ngx_conf_post_t *)cmd->post;
#line 1214
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)sp);
    }
#line 1214
    return (tmp___0);
  }
#line 1217
  return ((char *)((void *)0));
}
}
#line 1221 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_off_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  off_t *op ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;

  {
#line 1224
  p = (char *)conf;
#line 1231
  op = (off_t *)(p + cmd->offset);
#line 1232
  if (*op != -1L) {
#line 1233
    return ((char *)"is duplicate");
  }
  {
#line 1236
  value = (ngx_str_t *)(cf->args)->elts;
#line 1238
  *op = ngx_parse_offset(value + 1);
  }
#line 1239
  if (*op == -1L) {
#line 1240
    return ((char *)"invalid value");
  }
#line 1243
  if (cmd->post) {
    {
#line 1244
    post = (ngx_conf_post_t *)cmd->post;
#line 1245
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)op);
    }
#line 1245
    return (tmp);
  }
#line 1248
  return ((char *)((void *)0));
}
}
#line 1252 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_msec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_msec_t *msp ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  ngx_int_t tmp ;
  char *tmp___0 ;

  {
#line 1255
  p = (char *)conf;
#line 1262
  msp = (ngx_msec_t *)(p + cmd->offset);
#line 1263
  if (*msp != 0xffffffffffffffffUL) {
#line 1264
    return ((char *)"is duplicate");
  }
  {
#line 1267
  value = (ngx_str_t *)(cf->args)->elts;
#line 1269
  tmp = ngx_parse_time(value + 1, (ngx_uint_t )0);
#line 1269
  *msp = (ngx_msec_t )tmp;
  }
#line 1270
  if (*msp == 0xffffffffffffffffUL) {
#line 1271
    return ((char *)"invalid value");
  }
#line 1274
  if (cmd->post) {
    {
#line 1275
    post = (ngx_conf_post_t *)cmd->post;
#line 1276
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)msp);
    }
#line 1276
    return (tmp___0);
  }
#line 1279
  return ((char *)((void *)0));
}
}
#line 1283 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_sec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  time_t *sp ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;

  {
#line 1286
  p = (char *)conf;
#line 1293
  sp = (time_t *)(p + cmd->offset);
#line 1294
  if (*sp != -1L) {
#line 1295
    return ((char *)"is duplicate");
  }
  {
#line 1298
  value = (ngx_str_t *)(cf->args)->elts;
#line 1300
  *sp = ngx_parse_time(value + 1, (ngx_uint_t )1);
  }
#line 1301
  if (*sp == -1L) {
#line 1302
    return ((char *)"invalid value");
  }
#line 1305
  if (cmd->post) {
    {
#line 1306
    post = (ngx_conf_post_t *)cmd->post;
#line 1307
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)sp);
    }
#line 1307
    return (tmp);
  }
#line 1310
  return ((char *)((void *)0));
}
}
#line 1314 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_bufs_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_bufs_t *bufs ;
  ssize_t tmp ;

  {
#line 1317
  p = (char *)conf;
#line 1323
  bufs = (ngx_bufs_t *)(p + cmd->offset);
#line 1324
  if (bufs->num) {
#line 1325
    return ((char *)"is duplicate");
  }
  {
#line 1328
  value = (ngx_str_t *)(cf->args)->elts;
#line 1330
  bufs->num = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 1331
  if (bufs->num == -1L) {
#line 1332
    return ((char *)"invalid value");
  } else
#line 1331
  if (bufs->num == 0L) {
#line 1332
    return ((char *)"invalid value");
  }
  {
#line 1335
  tmp = ngx_parse_size(value + 2);
#line 1335
  bufs->size = (size_t___0 )tmp;
  }
#line 1336
  if (bufs->size == 0xffffffffffffffffUL) {
#line 1337
    return ((char *)"invalid value");
  } else
#line 1336
  if (bufs->size == 0UL) {
#line 1337
    return ((char *)"invalid value");
  }
#line 1340
  return ((char *)((void *)0));
}
}
#line 1344 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_enum_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_uint_t *np ;
  ngx_uint_t i ;
  ngx_str_t *value ;
  ngx_conf_enum_t *e ;
  ngx_int_t tmp ;

  {
#line 1347
  p = (char *)conf;
#line 1353
  np = (ngx_uint_t *)(p + cmd->offset);
#line 1355
  if (*np != 0xffffffffffffffffUL) {
#line 1356
    return ((char *)"is duplicate");
  }
#line 1359
  value = (ngx_str_t *)(cf->args)->elts;
#line 1360
  e = (ngx_conf_enum_t *)cmd->post;
#line 1362
  i = (ngx_uint_t )0;
  {
#line 1362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1362
    if (! ((e + i)->name.len != 0UL)) {
#line 1362
      goto while_break;
    }
#line 1363
    if ((e + i)->name.len != (value + 1)->len) {
#line 1366
      goto __Cont;
    } else {
      {
#line 1363
      tmp = ngx_strcasecmp((e + i)->name.data, (value + 1)->data);
      }
#line 1363
      if (tmp != 0L) {
#line 1366
        goto __Cont;
      }
    }
#line 1369
    *np = (e + i)->value;
#line 1371
    return ((char *)((void *)0));
    __Cont: /* CIL Label */ 
#line 1362
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1374
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%s\"", (value + 1)->data);
  }
#line 1377
  return ((char *)((void *)-1));
}
}
#line 1381 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_set_bitmask_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_uint_t *np ;
  ngx_uint_t i ;
  ngx_uint_t m ;
  ngx_str_t *value ;
  ngx_conf_bitmask_t *mask ;
  ngx_int_t tmp ;

  {
#line 1384
  p = (char *)conf;
#line 1391
  np = (ngx_uint_t *)(p + cmd->offset);
#line 1392
  value = (ngx_str_t *)(cf->args)->elts;
#line 1393
  mask = (ngx_conf_bitmask_t *)cmd->post;
#line 1395
  i = (ngx_uint_t )1;
  {
#line 1395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1395
    if (! (i < (cf->args)->nelts)) {
#line 1395
      goto while_break;
    }
#line 1396
    m = (ngx_uint_t )0;
    {
#line 1396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1396
      if (! ((mask + m)->name.len != 0UL)) {
#line 1396
        goto while_break___0;
      }
#line 1398
      if ((mask + m)->name.len != (value + i)->len) {
#line 1401
        goto __Cont;
      } else {
        {
#line 1398
        tmp = ngx_strcasecmp((mask + m)->name.data, (value + i)->data);
        }
#line 1398
        if (tmp != 0L) {
#line 1401
          goto __Cont;
        }
      }
#line 1404
      if (*np & (mask + m)->mask) {
        {
#line 1405
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate value \"%s\"", (value + i)->data);
        }
      } else {
#line 1409
        *np |= (mask + m)->mask;
      }
#line 1412
      goto while_break___0;
      __Cont: /* CIL Label */ 
#line 1396
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1415
    if ((mask + m)->name.len == 0UL) {
      {
#line 1416
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%s\"", (value + i)->data);
      }
#line 1419
      return ((char *)((void *)-1));
    }
#line 1395
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1423
  return ((char *)((void *)0));
}
}
#line 1438 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_deprecated(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_conf_deprecated_t *d ;

  {
  {
#line 1441
  d = (ngx_conf_deprecated_t *)post;
#line 1443
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "the \"%s\" directive is deprecated, use the \"%s\" directive instead",
                     d->old_name, d->new_name);
  }
#line 1448
  return ((char *)((void *)0));
}
}
#line 1452 "/tmp/nginx-1.13.2/src/core/ngx_conf_file.c"
char *ngx_conf_check_num_bounds(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_conf_num_bounds_t *bounds ;
  ngx_int_t *np ;

  {
#line 1455
  bounds = (ngx_conf_num_bounds_t *)post;
#line 1456
  np = (ngx_int_t *)data;
#line 1458
  if (bounds->high == -1L) {
#line 1459
    if (*np >= bounds->low) {
#line 1460
      return ((char *)((void *)0));
    }
    {
#line 1463
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value must be equal to or greater than %i",
                       bounds->low);
    }
#line 1467
    return ((char *)((void *)-1));
  }
#line 1470
  if (*np >= bounds->low) {
#line 1470
    if (*np <= bounds->high) {
#line 1471
      return ((char *)((void *)0));
    }
  }
  {
#line 1474
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value must be between %i and %i", bounds->low,
                     bounds->high);
  }
#line 1478
  return ((char *)((void *)-1));
}
}
#line 15 "/tmp/nginx-1.13.2/src/core/ngx_cpuinfo.c"
__inline static void ngx_cpuid(uint32_t i , uint32_t *buf ) ;
#line 49 "/tmp/nginx-1.13.2/src/core/ngx_cpuinfo.c"
__inline static void ngx_cpuid(uint32_t i , uint32_t *buf ) 
{ 
  uint32_t eax ;
  uint32_t ebx ;
  uint32_t ecx ;
  uint32_t edx ;

  {
#line 54
  __asm__  ("cpuid": "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx): "a" (i));
#line 60
  *(buf + 0) = eax;
#line 61
  *(buf + 1) = ebx;
#line 62
  *(buf + 2) = edx;
#line 63
  *(buf + 3) = ecx;
#line 64
  return;
}
}
#line 72 "/tmp/nginx-1.13.2/src/core/ngx_cpuinfo.c"
void ngx_cpuinfo(void) 
{ 
  u_char *vendor ;
  uint32_t vbuf[5] ;
  uint32_t cpu[4] ;
  uint32_t model ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 78
  vbuf[0] = (uint32_t )0;
#line 79
  vbuf[1] = (uint32_t )0;
#line 80
  vbuf[2] = (uint32_t )0;
#line 81
  vbuf[3] = (uint32_t )0;
#line 82
  vbuf[4] = (uint32_t )0;
#line 84
  ngx_cpuid((uint32_t )0, vbuf);
#line 86
  vendor = (u_char *)(& vbuf[1]);
  }
#line 88
  if (vbuf[0] == 0U) {
#line 89
    return;
  }
  {
#line 92
  ngx_cpuid((uint32_t )1, cpu);
#line 94
  tmp___0 = strcmp((char const   *)vendor, "GenuineIntel");
  }
#line 94
  if (tmp___0 == 0) {
    {
#line 99
    if ((cpu[0] & 3840U) >> 8 == 5U) {
#line 99
      goto case_5;
    }
#line 104
    if ((cpu[0] & 3840U) >> 8 == 6U) {
#line 104
      goto case_6;
    }
#line 120
    if ((cpu[0] & 3840U) >> 8 == 15U) {
#line 120
      goto case_15;
    }
#line 96
    goto switch_break;
    case_5: /* CIL Label */ 
#line 100
    ngx_cacheline_size = (ngx_uint_t )32;
#line 101
    goto switch_break;
    case_6: /* CIL Label */ 
#line 105
    ngx_cacheline_size = (ngx_uint_t )32;
#line 107
    model = ((cpu[0] & 983040U) >> 8) | (cpu[0] & 240U);
#line 109
    if (model >= 208U) {
#line 111
      ngx_cacheline_size = (ngx_uint_t )64;
    }
#line 114
    goto switch_break;
    case_15: /* CIL Label */ 
#line 121
    ngx_cacheline_size = (ngx_uint_t )128;
#line 122
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 125
    tmp = strcmp((char const   *)vendor, "AuthenticAMD");
    }
#line 125
    if (tmp == 0) {
#line 126
      ngx_cacheline_size = (ngx_uint_t )64;
    }
  }
#line 128
  return;
}
}
#line 68 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 19 "src/core/ngx_rwlock.h"
void ngx_rwlock_downgrade(ngx_atomic_t *lock ) ;
#line 19 "/tmp/nginx-1.13.2/src/core/ngx_rwlock.c"
void ngx_rwlock_wlock(ngx_atomic_t *lock ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (*lock == (ngx_atomic_t )0) {
      {
#line 26
      tmp = __sync_bool_compare_and_swap(lock, 0, (ngx_atomic_uint_t )-1);
      }
#line 26
      if (tmp) {
#line 27
        return;
      }
    }
#line 30
    if (ngx_ncpu > 1L) {
#line 32
      n = (ngx_uint_t )1;
      {
#line 32
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 32
        if (! (n < 2048UL)) {
#line 32
          goto while_break___0;
        }
#line 34
        i = (ngx_uint_t )0;
        {
#line 34
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 34
          if (! (i < n)) {
#line 34
            goto while_break___1;
          }
#line 35
          __asm__  ("pause":);
#line 34
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 38
        if (*lock == (ngx_atomic_t )0) {
          {
#line 38
          tmp___0 = __sync_bool_compare_and_swap(lock, 0, (ngx_atomic_uint_t )-1);
          }
#line 38
          if (tmp___0) {
#line 41
            return;
          }
        }
#line 32
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 46
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 51 "/tmp/nginx-1.13.2/src/core/ngx_rwlock.c"
void ngx_rwlock_rlock(ngx_atomic_t *lock ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_atomic_uint_t readers ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    readers = (ngx_atomic_uint_t )*lock;
#line 60
    if (readers != 0xffffffffffffffffUL) {
      {
#line 60
      tmp = __sync_bool_compare_and_swap(lock, readers, readers + 1UL);
      }
#line 60
      if (tmp) {
#line 63
        return;
      }
    }
#line 66
    if (ngx_ncpu > 1L) {
#line 68
      n = (ngx_uint_t )1;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! (n < 2048UL)) {
#line 68
          goto while_break___0;
        }
#line 70
        i = (ngx_uint_t )0;
        {
#line 70
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 70
          if (! (i < n)) {
#line 70
            goto while_break___1;
          }
#line 71
          __asm__  ("pause":);
#line 70
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 74
        readers = (ngx_atomic_uint_t )*lock;
#line 76
        if (readers != 0xffffffffffffffffUL) {
          {
#line 76
          tmp___0 = __sync_bool_compare_and_swap(lock, readers, readers + 1UL);
          }
#line 76
          if (tmp___0) {
#line 79
            return;
          }
        }
#line 68
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 84
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 89 "/tmp/nginx-1.13.2/src/core/ngx_rwlock.c"
void ngx_rwlock_unlock(ngx_atomic_t *lock ) 
{ 
  ngx_atomic_uint_t readers ;
  _Bool tmp ;

  {
#line 94
  readers = (ngx_atomic_uint_t )*lock;
#line 96
  if (readers == 0xffffffffffffffffUL) {
    {
#line 97
    __sync_bool_compare_and_swap(lock, (ngx_atomic_uint_t )-1, 0);
    }
#line 98
    return;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp = __sync_bool_compare_and_swap(lock, readers, readers - 1UL);
    }
#line 103
    if (tmp) {
#line 104
      return;
    }
#line 107
    readers = (ngx_atomic_uint_t )*lock;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 112 "/tmp/nginx-1.13.2/src/core/ngx_rwlock.c"
void ngx_rwlock_downgrade(ngx_atomic_t *lock ) 
{ 


  {
#line 115
  if (*lock == (ngx_atomic_t )0xffffffffffffffffUL) {
#line 116
    *lock = (ngx_atomic_t )1;
  }
#line 118
  return;
}
}
#line 307 "src/os/unix/ngx_atomic.h"
void ngx_spinlock(ngx_atomic_t *lock , ngx_atomic_int_t value , ngx_uint_t spin ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_spinlock.c"
void ngx_spinlock(ngx_atomic_t *lock , ngx_atomic_int_t value , ngx_uint_t spin ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (*lock == (ngx_atomic_t )0) {
      {
#line 22
      tmp = __sync_bool_compare_and_swap(lock, 0, value);
      }
#line 22
      if (tmp) {
#line 23
        return;
      }
    }
#line 26
    if (ngx_ncpu > 1L) {
#line 28
      n = (ngx_uint_t )1;
      {
#line 28
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 28
        if (! (n < spin)) {
#line 28
          goto while_break___0;
        }
#line 30
        i = (ngx_uint_t )0;
        {
#line 30
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 30
          if (! (i < n)) {
#line 30
            goto while_break___1;
          }
#line 31
          __asm__  ("pause":);
#line 30
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 34
        if (*lock == (ngx_atomic_t )0) {
          {
#line 34
          tmp___0 = __sync_bool_compare_and_swap(lock, 0, value);
          }
#line 34
          if (tmp___0) {
#line 35
            return;
          }
        }
#line 28
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 40
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 476 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 880
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 235 "src/core/ngx_log.h"
ngx_int_t ngx_log_open_default(ngx_cycle_t *cycle ) ;
#line 236
ngx_int_t ngx_log_redirect_stderr(ngx_cycle_t *cycle ) ;
#line 265
ngx_uint_t ngx_use_stderr ;
#line 146 "src/core/ngx_file.h"
ngx_int_t ngx_create_paths(ngx_cycle_t *cycle , ngx_uid_t user ) ;
#line 62 "src/core/ngx_slab.h"
void ngx_slab_init(ngx_slab_pool_t *pool ) ;
#line 124 "src/core/ngx_cycle.h"
ngx_int_t ngx_create_pidfile(ngx_str_t *name , ngx_log_t *log ) ;
#line 126
ngx_int_t ngx_signal_process(ngx_cycle_t *cycle , char *sig ) ;
#line 136 "src/core/ngx_cycle.h"
ngx_cycle_t volatile   *ngx_cycle  ;
#line 137 "src/core/ngx_cycle.h"
ngx_array_t ngx_old_cycles  ;
#line 139 "src/core/ngx_cycle.h"
ngx_uint_t ngx_test_config  ;
#line 140 "src/core/ngx_cycle.h"
ngx_uint_t ngx_dump_config  ;
#line 141 "src/core/ngx_cycle.h"
ngx_uint_t ngx_quiet_mode  ;
#line 210 "src/core/ngx_connection.h"
ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle ) ;
#line 211
void ngx_configure_listening_sockets(ngx_cycle_t *cycle ) ;
#line 13 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static void ngx_destroy_cycle_pools(ngx_conf_t *conf ) ;
#line 14
static ngx_int_t ngx_init_zone_pool(ngx_cycle_t *cycle , ngx_shm_zone_t *zn ) ;
#line 16
static ngx_int_t ngx_test_lockfile(u_char *file , ngx_log_t *log ) ;
#line 17
static void ngx_clean_old_cycles(ngx_event_t *ev ) ;
#line 18
static void ngx_shutdown_timer_handler(ngx_event_t *ev ) ;
#line 24 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static ngx_pool_t *ngx_temp_pool  ;
#line 25 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static ngx_event_t ngx_cleaner_event  ;
#line 26 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static ngx_event_t ngx_shutdown_event  ;
#line 34 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static ngx_connection_t dumb  ;
#line 38 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle ) 
{ 
  void *rv ;
  char **senv ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_log_t *log ;
  ngx_time_t *tp ;
  ngx_conf_t conf ;
  ngx_pool_t *pool ;
  ngx_cycle_t *cycle ;
  ngx_cycle_t **old ;
  ngx_shm_zone_t *shm_zone ;
  ngx_shm_zone_t *oshm_zone ;
  ngx_list_part_t *part ;
  ngx_list_part_t *opart ;
  ngx_open_file_t *file ;
  ngx_listening_t *ls ;
  ngx_listening_t *nls ;
  ngx_core_conf_t *ccf ;
  ngx_core_conf_t *old_ccf ;
  ngx_core_module_t *module ;
  char hostname[256] ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  ngx_int_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  ngx_int_t tmp___14 ;
  ngx_int_t tmp___15 ;
  int tmp___16 ;
  ngx_int_t tmp___17 ;
  ngx_int_t tmp___18 ;
  ngx_int_t tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  ngx_int_t tmp___24 ;
  ngx_int_t tmp___25 ;
  ngx_int_t tmp___26 ;
  ngx_int_t tmp___27 ;
  ngx_int_t tmp___28 ;
  ngx_int_t tmp___29 ;
  ngx_int_t tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  int tmp___33 ;
  u_char *name ;
  int *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  ngx_int_t tmp___38 ;
  void *tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  int tmp___43 ;

  {
  {
#line 57
  ngx_timezone_update();
#line 61
  tp = (ngx_time_t *)ngx_cached_time;
#line 62
  tp->sec = (time_t )0;
#line 64
  ngx_time_update();
#line 67
  log = old_cycle->log;
#line 69
  pool = ngx_create_pool((size_t___0 )16384, log);
  }
#line 70
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 71
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 73
  pool->log = log;
#line 75
  tmp = ngx_pcalloc(pool, sizeof(ngx_cycle_t ));
#line 75
  cycle = (ngx_cycle_t *)tmp;
  }
#line 76
  if ((unsigned long )cycle == (unsigned long )((void *)0)) {
    {
#line 77
    ngx_destroy_pool(pool);
    }
#line 78
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 81
  cycle->pool = pool;
#line 82
  cycle->log = log;
#line 83
  cycle->old_cycle = old_cycle;
#line 85
  cycle->conf_prefix.len = old_cycle->conf_prefix.len;
#line 86
  cycle->conf_prefix.data = ngx_pstrdup(pool, & old_cycle->conf_prefix);
  }
#line 87
  if ((unsigned long )cycle->conf_prefix.data == (unsigned long )((void *)0)) {
    {
#line 88
    ngx_destroy_pool(pool);
    }
#line 89
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 92
  cycle->prefix.len = old_cycle->prefix.len;
#line 93
  cycle->prefix.data = ngx_pstrdup(pool, & old_cycle->prefix);
  }
#line 94
  if ((unsigned long )cycle->prefix.data == (unsigned long )((void *)0)) {
    {
#line 95
    ngx_destroy_pool(pool);
    }
#line 96
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 99
  cycle->conf_file.len = old_cycle->conf_file.len;
#line 100
  tmp___0 = ngx_pnalloc(pool, old_cycle->conf_file.len + 1UL);
#line 100
  cycle->conf_file.data = (u_char *)tmp___0;
  }
#line 101
  if ((unsigned long )cycle->conf_file.data == (unsigned long )((void *)0)) {
    {
#line 102
    ngx_destroy_pool(pool);
    }
#line 103
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 105
  ngx_cpystrn(cycle->conf_file.data, old_cycle->conf_file.data, old_cycle->conf_file.len + 1UL);
#line 108
  cycle->conf_param.len = old_cycle->conf_param.len;
#line 109
  cycle->conf_param.data = ngx_pstrdup(pool, & old_cycle->conf_param);
  }
#line 110
  if ((unsigned long )cycle->conf_param.data == (unsigned long )((void *)0)) {
    {
#line 111
    ngx_destroy_pool(pool);
    }
#line 112
    return ((ngx_cycle_t *)((void *)0));
  }
#line 116
  if (old_cycle->paths.nelts) {
#line 116
    n = old_cycle->paths.nelts;
  } else {
#line 116
    n = (ngx_uint_t )10;
  }
  {
#line 118
  tmp___1 = ngx_array_init(& cycle->paths, pool, n, sizeof(ngx_path_t *));
  }
#line 118
  if (tmp___1 != 0L) {
    {
#line 121
    ngx_destroy_pool(pool);
    }
#line 122
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 125
  memset(cycle->paths.elts, 0, n * sizeof(ngx_path_t *));
#line 128
  tmp___2 = ngx_array_init(& cycle->config_dump, pool, (ngx_uint_t )1, sizeof(ngx_conf_dump_t ));
  }
#line 128
  if (tmp___2 != 0L) {
    {
#line 131
    ngx_destroy_pool(pool);
    }
#line 132
    return ((ngx_cycle_t *)((void *)0));
  }
#line 135
  cycle->config_dump_sentinel.color = (u_char )0;
#line 135
  cycle->config_dump_rbtree.root = & cycle->config_dump_sentinel;
#line 135
  cycle->config_dump_rbtree.sentinel = & cycle->config_dump_sentinel;
#line 135
  cycle->config_dump_rbtree.insert = & ngx_str_rbtree_insert_value;
#line 138
  if (old_cycle->open_files.part.nelts) {
#line 139
    n = old_cycle->open_files.part.nelts;
#line 140
    part = old_cycle->open_files.part.next;
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! part) {
#line 140
        goto while_break;
      }
#line 141
      n += part->nelts;
#line 140
      part = part->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 145
    n = (ngx_uint_t )20;
  }
  {
#line 148
  tmp___3 = ngx_list_init(& cycle->open_files, pool, n, sizeof(ngx_open_file_t ));
  }
#line 148
  if (tmp___3 != 0L) {
    {
#line 151
    ngx_destroy_pool(pool);
    }
#line 152
    return ((ngx_cycle_t *)((void *)0));
  }
#line 156
  if (old_cycle->shared_memory.part.nelts) {
#line 157
    n = old_cycle->shared_memory.part.nelts;
#line 158
    part = old_cycle->shared_memory.part.next;
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (! part) {
#line 158
        goto while_break___0;
      }
#line 160
      n += part->nelts;
#line 158
      part = part->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 164
    n = (ngx_uint_t )1;
  }
  {
#line 167
  tmp___4 = ngx_list_init(& cycle->shared_memory, pool, n, sizeof(ngx_shm_zone_t ));
  }
#line 167
  if (tmp___4 != 0L) {
    {
#line 170
    ngx_destroy_pool(pool);
    }
#line 171
    return ((ngx_cycle_t *)((void *)0));
  }
#line 174
  if (old_cycle->listening.nelts) {
#line 174
    n = old_cycle->listening.nelts;
  } else {
#line 174
    n = (ngx_uint_t )10;
  }
  {
#line 176
  tmp___5 = ngx_array_init(& cycle->listening, pool, n, sizeof(ngx_listening_t ));
  }
#line 176
  if (tmp___5 != 0L) {
    {
#line 179
    ngx_destroy_pool(pool);
    }
#line 180
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 183
  memset(cycle->listening.elts, 0, n * sizeof(ngx_listening_t ));
#line 186
  cycle->reusable_connections_queue.prev = & cycle->reusable_connections_queue;
#line 186
  cycle->reusable_connections_queue.next = & cycle->reusable_connections_queue;
#line 189
  tmp___6 = ngx_pcalloc(pool, ngx_max_module * sizeof(void *));
#line 189
  cycle->conf_ctx = (void ****)tmp___6;
  }
#line 190
  if ((unsigned long )cycle->conf_ctx == (unsigned long )((void *)0)) {
    {
#line 191
    ngx_destroy_pool(pool);
    }
#line 192
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 196
  tmp___8 = gethostname(hostname, (size_t )256);
  }
#line 196
  if (tmp___8 == -1) {
#line 197
    if (log->log_level >= 1UL) {
      {
#line 197
      tmp___7 = __errno_location();
#line 197
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___7, "gethostname() failed");
      }
    }
    {
#line 198
    ngx_destroy_pool(pool);
    }
#line 199
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 204
  hostname[255] = (char )'\000';
#line 205
  cycle->hostname.len = strlen((char const   *)(hostname));
#line 207
  tmp___9 = ngx_pnalloc(pool, cycle->hostname.len);
#line 207
  cycle->hostname.data = (u_char *)tmp___9;
  }
#line 208
  if ((unsigned long )cycle->hostname.data == (unsigned long )((void *)0)) {
    {
#line 209
    ngx_destroy_pool(pool);
    }
#line 210
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 213
  ngx_strlow(cycle->hostname.data, (u_char *)(hostname), cycle->hostname.len);
#line 216
  tmp___10 = ngx_cycle_modules(cycle);
  }
#line 216
  if (tmp___10 != 0L) {
    {
#line 217
    ngx_destroy_pool(pool);
    }
#line 218
    return ((ngx_cycle_t *)((void *)0));
  }
#line 222
  i = (ngx_uint_t )0;
  {
#line 222
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 222
    if (! *(cycle->modules + i)) {
#line 222
      goto while_break___1;
    }
#line 223
    if ((*(cycle->modules + i))->type != 1163022147UL) {
#line 224
      goto __Cont;
    }
#line 227
    module = (ngx_core_module_t *)(*(cycle->modules + i))->ctx;
#line 229
    if (module->create_conf) {
      {
#line 230
      rv = (*(module->create_conf))(cycle);
      }
#line 231
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
        {
#line 232
        ngx_destroy_pool(pool);
        }
#line 233
        return ((ngx_cycle_t *)((void *)0));
      }
#line 235
      *(cycle->conf_ctx + (*(cycle->modules + i))->index) = (void ***)rv;
    }
    __Cont: /* CIL Label */ 
#line 222
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 240
  senv = environ;
#line 243
  memset((void *)(& conf), 0, sizeof(ngx_conf_t ));
#line 245
  conf.args = ngx_array_create(pool, (ngx_uint_t )10, sizeof(ngx_str_t ));
  }
#line 246
  if ((unsigned long )conf.args == (unsigned long )((void *)0)) {
    {
#line 247
    ngx_destroy_pool(pool);
    }
#line 248
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 251
  conf.temp_pool = ngx_create_pool((size_t___0 )16384, log);
  }
#line 252
  if ((unsigned long )conf.temp_pool == (unsigned long )((void *)0)) {
    {
#line 253
    ngx_destroy_pool(pool);
    }
#line 254
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 258
  conf.ctx = (void *)cycle->conf_ctx;
#line 259
  conf.cycle = cycle;
#line 260
  conf.pool = pool;
#line 261
  conf.log = log;
#line 262
  conf.module_type = (ngx_uint_t )1163022147;
#line 263
  conf.cmd_type = (ngx_uint_t )16777216;
#line 269
  tmp___11 = ngx_conf_param(& conf);
  }
#line 269
  if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
    {
#line 270
    environ = senv;
#line 271
    ngx_destroy_cycle_pools(& conf);
    }
#line 272
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 275
  tmp___12 = ngx_conf_parse(& conf, & cycle->conf_file);
  }
#line 275
  if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
    {
#line 276
    environ = senv;
#line 277
    ngx_destroy_cycle_pools(& conf);
    }
#line 278
    return ((ngx_cycle_t *)((void *)0));
  }
#line 281
  if (ngx_test_config) {
#line 281
    if (! ngx_quiet_mode) {
      {
#line 282
      ngx_log_stderr(0, "the configuration file %s syntax is ok", cycle->conf_file.data);
      }
    }
  }
#line 286
  i = (ngx_uint_t )0;
  {
#line 286
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 286
    if (! *(cycle->modules + i)) {
#line 286
      goto while_break___2;
    }
#line 287
    if ((*(cycle->modules + i))->type != 1163022147UL) {
#line 288
      goto __Cont___0;
    }
#line 291
    module = (ngx_core_module_t *)(*(cycle->modules + i))->ctx;
#line 293
    if (module->init_conf) {
      {
#line 294
      tmp___13 = (*(module->init_conf))(cycle, (void *)*(cycle->conf_ctx + (*(cycle->modules + i))->index));
      }
#line 294
      if ((unsigned long )tmp___13 == (unsigned long )((void *)-1)) {
        {
#line 298
        environ = senv;
#line 299
        ngx_destroy_cycle_pools(& conf);
        }
#line 300
        return ((ngx_cycle_t *)((void *)0));
      }
    }
    __Cont___0: /* CIL Label */ 
#line 286
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 305
  if (ngx_process == 2UL) {
#line 306
    return (cycle);
  }
#line 309
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 311
  if (ngx_test_config) {
    {
#line 313
    tmp___14 = ngx_create_pidfile(& ccf->pid, log);
    }
#line 313
    if (tmp___14 != 0L) {
#line 314
      goto failed;
    }
  } else
#line 317
  if (! ((unsigned long )old_cycle->conf_ctx == (unsigned long )((void *)0))) {
#line 324
    old_ccf = (ngx_core_conf_t *)*(old_cycle->conf_ctx + ngx_core_module.index);
#line 326
    if (ccf->pid.len != old_ccf->pid.len) {
#line 326
      goto _L;
    } else {
      {
#line 326
      tmp___16 = strcmp((char const   *)ccf->pid.data, (char const   *)old_ccf->pid.data);
      }
#line 326
      if (tmp___16 != 0) {
        _L: /* CIL Label */ 
        {
#line 331
        tmp___15 = ngx_create_pidfile(& ccf->pid, log);
        }
#line 331
        if (tmp___15 != 0L) {
#line 332
          goto failed;
        }
        {
#line 335
        ngx_delete_pidfile(old_cycle);
        }
      }
    }
  }
  {
#line 340
  tmp___17 = ngx_test_lockfile(cycle->lock_file.data, log);
  }
#line 340
  if (tmp___17 != 0L) {
#line 341
    goto failed;
  }
  {
#line 345
  tmp___18 = ngx_create_paths(cycle, ccf->user);
  }
#line 345
  if (tmp___18 != 0L) {
#line 346
    goto failed;
  }
  {
#line 350
  tmp___19 = ngx_log_open_default(cycle);
  }
#line 350
  if (tmp___19 != 0L) {
#line 351
    goto failed;
  }
#line 356
  part = & cycle->open_files.part;
#line 357
  file = (ngx_open_file_t *)part->elts;
#line 359
  i = (ngx_uint_t )0;
  {
#line 359
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 361
    if (i >= part->nelts) {
#line 362
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 363
        goto while_break___3;
      }
#line 365
      part = part->next;
#line 366
      file = (ngx_open_file_t *)part->elts;
#line 367
      i = (ngx_uint_t )0;
    }
#line 370
    if ((file + i)->name.len == 0UL) {
#line 371
      goto __Cont___1;
    }
    {
#line 374
    (file + i)->fd = open((char const   *)(file + i)->name.data, 1089, 420);
    }
#line 383
    if ((file + i)->fd == -1) {
#line 384
      if (log->log_level >= 1UL) {
        {
#line 384
        tmp___20 = __errno_location();
#line 384
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___20, "open() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
#line 387
      goto failed;
    }
    {
#line 391
    tmp___22 = fcntl((file + i)->fd, 2, 1);
    }
#line 391
    if (tmp___22 == -1) {
#line 392
      if (log->log_level >= 1UL) {
        {
#line 392
        tmp___21 = __errno_location();
#line 392
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___21, "fcntl(FD_CLOEXEC) \"%s\" failed",
                           (file + i)->name.data);
        }
      }
#line 395
      goto failed;
    }
    __Cont___1: /* CIL Label */ 
#line 359
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 400
  cycle->log = & cycle->new_log;
#line 401
  pool->log = & cycle->new_log;
#line 406
  part = & cycle->shared_memory.part;
#line 407
  shm_zone = (ngx_shm_zone_t *)part->elts;
#line 409
  i = (ngx_uint_t )0;
  {
#line 409
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 411
    if (i >= part->nelts) {
#line 412
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 413
        goto while_break___4;
      }
#line 415
      part = part->next;
#line 416
      shm_zone = (ngx_shm_zone_t *)part->elts;
#line 417
      i = (ngx_uint_t )0;
    }
#line 420
    if ((shm_zone + i)->shm.size == 0UL) {
#line 421
      if (log->log_level >= 1UL) {
        {
#line 421
        ngx_log_error_core((ngx_uint_t )1, log, 0, "zero size shared memory zone \"%V\"",
                           & (shm_zone + i)->shm.name);
        }
      }
#line 424
      goto failed;
    }
#line 427
    (shm_zone + i)->shm.log = cycle->log;
#line 429
    opart = & old_cycle->shared_memory.part;
#line 430
    oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 432
    n = (ngx_uint_t )0;
    {
#line 432
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 434
      if (n >= opart->nelts) {
#line 435
        if ((unsigned long )opart->next == (unsigned long )((void *)0)) {
#line 436
          goto while_break___5;
        }
#line 438
        opart = opart->next;
#line 439
        oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 440
        n = (ngx_uint_t )0;
      }
#line 443
      if ((shm_zone + i)->shm.name.len != (oshm_zone + n)->shm.name.len) {
#line 444
        goto __Cont___2;
      }
      {
#line 447
      tmp___23 = strncmp((char const   *)(shm_zone + i)->shm.name.data, (char const   *)(oshm_zone + n)->shm.name.data,
                         (shm_zone + i)->shm.name.len);
      }
#line 447
      if (tmp___23 != 0) {
#line 452
        goto __Cont___2;
      }
#line 455
      if ((unsigned long )(shm_zone + i)->tag == (unsigned long )(oshm_zone + n)->tag) {
#line 455
        if ((shm_zone + i)->shm.size == (oshm_zone + n)->shm.size) {
#line 455
          if (! (shm_zone + i)->noreuse) {
            {
#line 459
            (shm_zone + i)->shm.addr = (oshm_zone + n)->shm.addr;
#line 464
            tmp___24 = (*((shm_zone + i)->init))(shm_zone + i, (oshm_zone + n)->data);
            }
#line 464
            if (tmp___24 != 0L) {
#line 467
              goto failed;
            }
#line 470
            goto shm_zone_found;
          }
        }
      }
      {
#line 473
      ngx_shm_free(& (oshm_zone + n)->shm);
      }
#line 475
      goto while_break___5;
      __Cont___2: /* CIL Label */ 
#line 432
      n ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 478
    tmp___25 = ngx_shm_alloc(& (shm_zone + i)->shm);
    }
#line 478
    if (tmp___25 != 0L) {
#line 479
      goto failed;
    }
    {
#line 482
    tmp___26 = ngx_init_zone_pool(cycle, shm_zone + i);
    }
#line 482
    if (tmp___26 != 0L) {
#line 483
      goto failed;
    }
    {
#line 486
    tmp___27 = (*((shm_zone + i)->init))(shm_zone + i, (void *)0);
    }
#line 486
    if (tmp___27 != 0L) {
#line 487
      goto failed;
    }
    shm_zone_found: 
#line 492
    goto __Cont___3;
    __Cont___3: /* CIL Label */ 
#line 409
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 498
  if (old_cycle->listening.nelts) {
#line 499
    ls = (ngx_listening_t *)old_cycle->listening.elts;
#line 500
    i = (ngx_uint_t )0;
    {
#line 500
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 500
      if (! (i < old_cycle->listening.nelts)) {
#line 500
        goto while_break___6;
      }
#line 501
      (ls + i)->remain = 0U;
#line 500
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 504
    nls = (ngx_listening_t *)cycle->listening.elts;
#line 505
    n = (ngx_uint_t )0;
    {
#line 505
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 505
      if (! (n < cycle->listening.nelts)) {
#line 505
        goto while_break___7;
      }
#line 507
      i = (ngx_uint_t )0;
      {
#line 507
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 507
        if (! (i < old_cycle->listening.nelts)) {
#line 507
          goto while_break___8;
        }
#line 508
        if ((ls + i)->ignore) {
#line 509
          goto __Cont___4;
        }
#line 512
        if ((ls + i)->remain) {
#line 513
          goto __Cont___4;
        }
#line 516
        if ((ls + i)->type != (nls + n)->type) {
#line 517
          goto __Cont___4;
        }
        {
#line 520
        tmp___28 = ngx_cmp_sockaddr((nls + n)->sockaddr, (nls + n)->socklen, (ls + i)->sockaddr,
                                    (ls + i)->socklen, (ngx_uint_t )1);
        }
#line 520
        if (tmp___28 == 0L) {
#line 524
          (nls + n)->fd = (ls + i)->fd;
#line 525
          (nls + n)->previous = ls + i;
#line 526
          (ls + i)->remain = 1U;
#line 528
          if ((ls + i)->backlog != (nls + n)->backlog) {
#line 529
            (nls + n)->listen = 1U;
          }
#line 559
          if ((ls + i)->deferred_accept) {
#line 559
            if (! (nls + n)->deferred_accept) {
#line 560
              (nls + n)->delete_deferred = 1U;
            } else {
#line 559
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 562
          if ((ls + i)->deferred_accept != (nls + n)->deferred_accept) {
#line 564
            (nls + n)->add_deferred = 1U;
          }
#line 569
          if ((nls + n)->reuseport) {
#line 569
            if (! (ls + i)->reuseport) {
#line 570
              (nls + n)->add_reuseport = 1U;
            }
          }
#line 574
          goto while_break___8;
        }
        __Cont___4: /* CIL Label */ 
#line 507
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 578
      if ((nls + n)->fd == -1) {
#line 579
        (nls + n)->open = 1U;
#line 586
        if ((nls + n)->deferred_accept) {
#line 587
          (nls + n)->add_deferred = 1U;
        }
      }
#line 505
      n ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
#line 594
    ls = (ngx_listening_t *)cycle->listening.elts;
#line 595
    i = (ngx_uint_t )0;
    {
#line 595
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 595
      if (! (i < cycle->listening.nelts)) {
#line 595
        goto while_break___9;
      }
#line 596
      (ls + i)->open = 1U;
#line 603
      if ((ls + i)->deferred_accept) {
#line 604
        (ls + i)->add_deferred = 1U;
      }
#line 595
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 610
  tmp___29 = ngx_open_listening_sockets(cycle);
  }
#line 610
  if (tmp___29 != 0L) {
#line 611
    goto failed;
  }
#line 614
  if (! ngx_test_config) {
    {
#line 615
    ngx_configure_listening_sockets(cycle);
    }
  }
#line 621
  if (! ngx_use_stderr) {
    {
#line 622
    ngx_log_redirect_stderr(cycle);
    }
  }
  {
#line 625
  pool->log = cycle->log;
#line 627
  tmp___30 = ngx_init_modules(cycle);
  }
#line 627
  if (tmp___30 != 0L) {
    {
#line 629
    exit(1);
    }
  }
#line 637
  opart = & old_cycle->shared_memory.part;
#line 638
  oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 640
  i = (ngx_uint_t )0;
  {
#line 640
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 642
    if (i >= opart->nelts) {
#line 643
      if ((unsigned long )opart->next == (unsigned long )((void *)0)) {
#line 644
        goto old_shm_zone_done;
      }
#line 646
      opart = opart->next;
#line 647
      oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 648
      i = (ngx_uint_t )0;
    }
#line 651
    part = & cycle->shared_memory.part;
#line 652
    shm_zone = (ngx_shm_zone_t *)part->elts;
#line 654
    n = (ngx_uint_t )0;
    {
#line 654
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 656
      if (n >= part->nelts) {
#line 657
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 658
          goto while_break___11;
        }
#line 660
        part = part->next;
#line 661
        shm_zone = (ngx_shm_zone_t *)part->elts;
#line 662
        n = (ngx_uint_t )0;
      }
#line 665
      if ((oshm_zone + i)->shm.name.len == (shm_zone + n)->shm.name.len) {
        {
#line 665
        tmp___31 = strncmp((char const   *)(oshm_zone + i)->shm.name.data, (char const   *)(shm_zone + n)->shm.name.data,
                           (oshm_zone + i)->shm.name.len);
        }
#line 665
        if (tmp___31 == 0) {
#line 671
          goto live_shm_zone;
        }
      }
#line 654
      n ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 675
    ngx_shm_free(& (oshm_zone + i)->shm);
    }
    live_shm_zone: 
#line 679
    goto __Cont___5;
    __Cont___5: /* CIL Label */ 
#line 640
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  old_shm_zone_done: 
#line 687
  ls = (ngx_listening_t *)old_cycle->listening.elts;
#line 688
  i = (ngx_uint_t )0;
  {
#line 688
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 688
    if (! (i < old_cycle->listening.nelts)) {
#line 688
      goto while_break___12;
    }
#line 690
    if ((ls + i)->remain) {
#line 691
      goto __Cont___6;
    } else
#line 690
    if ((ls + i)->fd == -1) {
#line 691
      goto __Cont___6;
    }
    {
#line 694
    tmp___33 = close((ls + i)->fd);
    }
#line 694
    if (tmp___33 == -1) {
#line 695
      if (log->log_level >= 1UL) {
        {
#line 695
        tmp___32 = __errno_location();
#line 695
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___32, "close() socket listening socket on %V failed",
                           & (ls + i)->addr_text);
        }
      }
    }
#line 702
    if ((int )((ls + i)->sockaddr)->sa_family == 1) {
#line 705
      name = ((ls + i)->addr_text.data + sizeof("unix:")) - 1;
#line 707
      if ((cycle->log)->log_level >= 5UL) {
        {
#line 707
        ngx_log_error_core((ngx_uint_t )5, cycle->log, 0, "deleting socket %s", name);
        }
      }
      {
#line 710
      tmp___35 = unlink((char const   *)name);
      }
#line 710
      if (tmp___35 == -1) {
#line 711
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 711
          tmp___34 = __errno_location();
#line 711
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___34, "unlink() %s failed",
                             name);
          }
        }
      }
    }
    __Cont___6: /* CIL Label */ 
#line 688
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 722
  part = & old_cycle->open_files.part;
#line 723
  file = (ngx_open_file_t *)part->elts;
#line 725
  i = (ngx_uint_t )0;
  {
#line 725
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 727
    if (i >= part->nelts) {
#line 728
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 729
        goto while_break___13;
      }
#line 731
      part = part->next;
#line 732
      file = (ngx_open_file_t *)part->elts;
#line 733
      i = (ngx_uint_t )0;
    }
#line 736
    if ((file + i)->fd == -1) {
#line 737
      goto __Cont___7;
    } else
#line 736
    if ((file + i)->fd == 2) {
#line 737
      goto __Cont___7;
    }
    {
#line 740
    tmp___37 = close((file + i)->fd);
    }
#line 740
    if (tmp___37 == -1) {
#line 741
      if (log->log_level >= 1UL) {
        {
#line 741
        tmp___36 = __errno_location();
#line 741
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___36, "close() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
    }
    __Cont___7: /* CIL Label */ 
#line 725
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 747
  ngx_destroy_pool(conf.temp_pool);
  }
#line 749
  if (ngx_process == 1UL) {
    {
#line 751
    ngx_destroy_pool(old_cycle->pool);
#line 752
    cycle->old_cycle = (ngx_cycle_t *)((void *)0);
    }
#line 754
    return (cycle);
  } else
#line 749
  if ((unsigned long )old_cycle->conf_ctx == (unsigned long )((void *)0)) {
    {
#line 751
    ngx_destroy_pool(old_cycle->pool);
#line 752
    cycle->old_cycle = (ngx_cycle_t *)((void *)0);
    }
#line 754
    return (cycle);
  }
#line 758
  if ((unsigned long )ngx_temp_pool == (unsigned long )((void *)0)) {
    {
#line 759
    ngx_temp_pool = ngx_create_pool((size_t___0 )128, cycle->log);
    }
#line 760
    if ((unsigned long )ngx_temp_pool == (unsigned long )((void *)0)) {
#line 761
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 761
        ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "could not create ngx_temp_pool");
        }
      }
      {
#line 763
      exit(1);
      }
    }
    {
#line 766
    n = (ngx_uint_t )10;
#line 768
    tmp___38 = ngx_array_init(& ngx_old_cycles, ngx_temp_pool, n, sizeof(ngx_cycle_t *));
    }
#line 768
    if (tmp___38 != 0L) {
      {
#line 772
      exit(1);
      }
    }
    {
#line 775
    memset(ngx_old_cycles.elts, 0, n * sizeof(ngx_cycle_t *));
#line 777
    ngx_cleaner_event.handler = & ngx_clean_old_cycles;
#line 778
    ngx_cleaner_event.log = cycle->log;
#line 779
    ngx_cleaner_event.data = (void *)(& dumb);
#line 780
    dumb.fd = -1;
    }
  }
  {
#line 783
  ngx_temp_pool->log = cycle->log;
#line 785
  tmp___39 = ngx_array_push(& ngx_old_cycles);
#line 785
  old = (ngx_cycle_t **)tmp___39;
  }
#line 786
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    {
#line 787
    exit(1);
    }
  }
#line 789
  *old = old_cycle;
#line 791
  if (! ngx_cleaner_event.timer_set) {
    {
#line 792
    ngx_event_add_timer(& ngx_cleaner_event, (ngx_msec_t )30000);
#line 793
    ngx_cleaner_event.timer_set = 1U;
    }
  }
#line 796
  return (cycle);
  failed: 
#line 801
  if (! ((unsigned long )old_cycle->conf_ctx == (unsigned long )((void *)0))) {
#line 802
    old_ccf = (ngx_core_conf_t *)*(old_cycle->conf_ctx + ngx_core_module.index);
#line 804
    if (old_ccf->environment) {
#line 805
      environ = old_ccf->environment;
    }
  }
#line 811
  part = & cycle->open_files.part;
#line 812
  file = (ngx_open_file_t *)part->elts;
#line 814
  i = (ngx_uint_t )0;
  {
#line 814
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 816
    if (i >= part->nelts) {
#line 817
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 818
        goto while_break___14;
      }
#line 820
      part = part->next;
#line 821
      file = (ngx_open_file_t *)part->elts;
#line 822
      i = (ngx_uint_t )0;
    }
#line 825
    if ((file + i)->fd == -1) {
#line 826
      goto __Cont___8;
    } else
#line 825
    if ((file + i)->fd == 2) {
#line 826
      goto __Cont___8;
    }
    {
#line 829
    tmp___41 = close((file + i)->fd);
    }
#line 829
    if (tmp___41 == -1) {
#line 830
      if (log->log_level >= 1UL) {
        {
#line 830
        tmp___40 = __errno_location();
#line 830
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___40, "close() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
    }
    __Cont___8: /* CIL Label */ 
#line 814
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 836
  if (ngx_test_config) {
    {
#line 837
    ngx_destroy_cycle_pools(& conf);
    }
#line 838
    return ((ngx_cycle_t *)((void *)0));
  }
#line 841
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 842
  i = (ngx_uint_t )0;
  {
#line 842
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 842
    if (! (i < cycle->listening.nelts)) {
#line 842
      goto while_break___15;
    }
#line 843
    if ((ls + i)->fd == -1) {
#line 844
      goto __Cont___9;
    } else
#line 843
    if (! (ls + i)->open) {
#line 844
      goto __Cont___9;
    }
    {
#line 847
    tmp___43 = close((ls + i)->fd);
    }
#line 847
    if (tmp___43 == -1) {
#line 848
      if (log->log_level >= 1UL) {
        {
#line 848
        tmp___42 = __errno_location();
#line 848
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___42, "close() socket %V failed",
                           & (ls + i)->addr_text);
        }
      }
    }
    __Cont___9: /* CIL Label */ 
#line 842
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 854
  ngx_destroy_cycle_pools(& conf);
  }
#line 856
  return ((ngx_cycle_t *)((void *)0));
}
}
#line 860 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static void ngx_destroy_cycle_pools(ngx_conf_t *conf ) 
{ 


  {
  {
#line 863
  ngx_destroy_pool(conf->temp_pool);
#line 864
  ngx_destroy_pool(conf->pool);
  }
#line 865
  return;
}
}
#line 868 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static ngx_int_t ngx_init_zone_pool(ngx_cycle_t *cycle , ngx_shm_zone_t *zn ) 
{ 
  u_char *file ;
  ngx_slab_pool_t *sp ;
  ngx_int_t tmp ;

  {
#line 874
  sp = (ngx_slab_pool_t *)zn->shm.addr;
#line 876
  if (zn->shm.exists) {
#line 878
    if ((unsigned long )sp == (unsigned long )sp->addr) {
#line 879
      return ((ngx_int_t )0);
    }
#line 898
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 898
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "shared zone \"%V\" has no equal addresses: %p vs %p",
                         & zn->shm.name, sp->addr, sp);
      }
    }
#line 901
    return ((ngx_int_t )-1);
  }
  {
#line 904
  sp->end = zn->shm.addr + zn->shm.size;
#line 905
  sp->min_shift = (size_t___0 )3;
#line 906
  sp->addr = (void *)zn->shm.addr;
#line 910
  file = (u_char *)((void *)0);
#line 923
  tmp = ngx_shmtx_create(& sp->mutex, & sp->lock, file);
  }
#line 923
  if (tmp != 0L) {
#line 924
    return ((ngx_int_t )-1);
  }
  {
#line 927
  ngx_slab_init(sp);
  }
#line 929
  return ((ngx_int_t )0);
}
}
#line 933 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
ngx_int_t ngx_create_pidfile(ngx_str_t *name , ngx_log_t *log ) 
{ 
  size_t___0 len ;
  ngx_uint_t create ;
  ngx_file_t file ;
  u_char pid[(sizeof("-9223372036854775808") - 1UL) + 2UL] ;
  int *tmp ;
  u_char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 941
  if (ngx_process > 1UL) {
#line 942
    return ((ngx_int_t )0);
  }
  {
#line 945
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 947
  file.name = *name;
#line 948
  file.log = log;
  }
#line 950
  if (ngx_test_config) {
#line 950
    create = (ngx_uint_t )64;
  } else {
#line 950
    create = (ngx_uint_t )576;
  }
  {
#line 952
  file.fd = open((char const   *)file.name.data, (int )(2UL | create), 420);
  }
#line 955
  if (file.fd == -1) {
#line 956
    if (log->log_level >= 1UL) {
      {
#line 956
      tmp = __errno_location();
#line 956
      ngx_log_error_core((ngx_uint_t )1, log, *tmp, "open() \"%s\" failed", file.name.data);
      }
    }
#line 958
    return ((ngx_int_t )-1);
  }
#line 961
  if (! ngx_test_config) {
    {
#line 962
    tmp___0 = ngx_snprintf(pid, (sizeof("-9223372036854775808") - 1UL) + 2UL, "%P%N",
                           ngx_pid);
#line 962
    len = (size_t___0 )(tmp___0 - pid);
#line 964
    tmp___1 = ngx_write_file(& file, pid, len, (off_t )0);
    }
#line 964
    if (tmp___1 == -1L) {
#line 965
      return ((ngx_int_t )-1);
    }
  }
  {
#line 969
  tmp___3 = close(file.fd);
  }
#line 969
  if (tmp___3 == -1) {
#line 970
    if (log->log_level >= 2UL) {
      {
#line 970
      tmp___2 = __errno_location();
#line 970
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___2, "close() \"%s\" failed", file.name.data);
      }
    }
  }
#line 974
  return ((ngx_int_t )0);
}
}
#line 978 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
void ngx_delete_pidfile(ngx_cycle_t *cycle ) 
{ 
  u_char *name ;
  ngx_core_conf_t *ccf ;
  int *tmp ;
  int tmp___0 ;

  {
#line 984
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 986
  if (ngx_new_binary) {
#line 986
    name = ccf->oldpid.data;
  } else {
#line 986
    name = ccf->pid.data;
  }
  {
#line 988
  tmp___0 = unlink((char const   *)name);
  }
#line 988
  if (tmp___0 == -1) {
#line 989
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 989
      tmp = __errno_location();
#line 989
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "unlink() \"%s\" failed",
                         name);
      }
    }
  }
#line 992
  return;
}
}
#line 995 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
ngx_int_t ngx_signal_process(ngx_cycle_t *cycle , char *sig ) 
{ 
  ssize_t n ;
  ngx_pid_t pid ;
  ngx_file_t file ;
  ngx_core_conf_t *ccf ;
  u_char buf[(sizeof("-9223372036854775808") - 1UL) + 2UL] ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 1004
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 1004
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "signal process started");
    }
  }
  {
#line 1006
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 1008
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 1010
  file.name = ccf->pid;
#line 1011
  file.log = cycle->log;
#line 1013
  file.fd = open((char const   *)file.name.data, 0, 420);
  }
#line 1016
  if (file.fd == -1) {
#line 1017
    if ((cycle->log)->log_level >= 4UL) {
      {
#line 1017
      tmp = __errno_location();
#line 1017
      ngx_log_error_core((ngx_uint_t )4, cycle->log, *tmp, "open() \"%s\" failed",
                         file.name.data);
      }
    }
#line 1019
    return ((ngx_int_t )1);
  }
  {
#line 1022
  n = ngx_read_file(& file, buf, (sizeof("-9223372036854775808") - 1UL) + 2UL, (off_t )0);
#line 1024
  tmp___1 = close(file.fd);
  }
#line 1024
  if (tmp___1 == -1) {
#line 1025
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 1025
      tmp___0 = __errno_location();
#line 1025
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "close() \"%s\" failed",
                         file.name.data);
      }
    }
  }
#line 1029
  if (n == -1L) {
#line 1030
    return ((ngx_int_t )1);
  }
  {
#line 1033
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1033
    tmp___2 = n;
#line 1033
    n --;
#line 1033
    if (tmp___2) {
#line 1033
      if (! ((int )buf[n] == 13)) {
#line 1033
        if (! ((int )buf[n] == 10)) {
#line 1033
          goto while_break;
        }
      }
    } else {
#line 1033
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1035
  n ++;
#line 1035
  tmp___3 = ngx_atoi(buf, (size_t___0 )n);
#line 1035
  pid = (ngx_pid_t )tmp___3;
  }
#line 1037
  if (pid == -1) {
#line 1038
    if ((cycle->log)->log_level >= 4UL) {
      {
#line 1038
      ngx_log_error_core((ngx_uint_t )4, cycle->log, 0, "invalid PID number \"%*s\" in \"%s\"",
                         n, buf, file.name.data);
      }
    }
#line 1041
    return ((ngx_int_t )1);
  }
  {
#line 1044
  tmp___4 = ngx_os_signal_process(cycle, sig, pid);
  }
#line 1044
  return (tmp___4);
}
}
#line 1049 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static ngx_int_t ngx_test_lockfile(u_char *file , ngx_log_t *log ) 
{ 


  {
#line 1076
  return ((ngx_int_t )0);
}
}
#line 1080 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
void ngx_reopen_files(ngx_cycle_t *cycle , ngx_uid_t user ) 
{ 
  ngx_fd_t fd ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_open_file_t *file ;
  int *tmp ;
  ngx_file_info_t fi ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;

  {
#line 1088
  part = & cycle->open_files.part;
#line 1089
  file = (ngx_open_file_t *)part->elts;
#line 1091
  i = (ngx_uint_t )0;
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    if (i >= part->nelts) {
#line 1094
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1095
        goto while_break;
      }
#line 1097
      part = part->next;
#line 1098
      file = (ngx_open_file_t *)part->elts;
#line 1099
      i = (ngx_uint_t )0;
    }
#line 1102
    if ((file + i)->name.len == 0UL) {
#line 1103
      goto __Cont;
    }
#line 1106
    if ((file + i)->flush) {
      {
#line 1107
      (*((file + i)->flush))(file + i, cycle->log);
      }
    }
    {
#line 1110
    fd = open((char const   *)(file + i)->name.data, 1089, 420);
    }
#line 1117
    if (fd == -1) {
#line 1118
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1118
        tmp = __errno_location();
#line 1118
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp, "open() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
#line 1120
      goto __Cont;
    }
#line 1124
    if (user != 4294967295U) {
      {
#line 1127
      tmp___3 = stat((char const   */* __restrict  */)((char const   *)(file + i)->name.data),
                     (struct stat */* __restrict  */)(& fi));
      }
#line 1127
      if (tmp___3 == -1) {
#line 1128
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1128
          tmp___0 = __errno_location();
#line 1128
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___0, "stat() \"%s\" failed",
                             (file + i)->name.data);
          }
        }
        {
#line 1132
        tmp___2 = close(fd);
        }
#line 1132
        if (tmp___2 == -1) {
#line 1133
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 1133
            tmp___1 = __errno_location();
#line 1133
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___1, "close() \"%s\" failed",
                               (file + i)->name.data);
            }
          }
        }
#line 1138
        goto __Cont;
      }
#line 1141
      if (fi.st_uid != user) {
        {
#line 1142
        tmp___7 = chown((char const   *)(file + i)->name.data, user, (__gid_t )-1);
        }
#line 1142
        if (tmp___7 == -1) {
#line 1143
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 1143
            tmp___4 = __errno_location();
#line 1143
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___4, "chown(\"%s\", %d) failed",
                               (file + i)->name.data, user);
            }
          }
          {
#line 1147
          tmp___6 = close(fd);
          }
#line 1147
          if (tmp___6 == -1) {
#line 1148
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 1148
              tmp___5 = __errno_location();
#line 1148
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___5, "close() \"%s\" failed",
                                 (file + i)->name.data);
              }
            }
          }
#line 1153
          goto __Cont;
        }
      }
#line 1157
      if ((fi.st_mode & 384U) != 384U) {
        {
#line 1159
        fi.st_mode |= 384U;
#line 1161
        tmp___11 = chmod((char const   *)(file + i)->name.data, fi.st_mode);
        }
#line 1161
        if (tmp___11 == -1) {
#line 1162
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 1162
            tmp___8 = __errno_location();
#line 1162
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___8, "chmod() \"%s\" failed",
                               (file + i)->name.data);
            }
          }
          {
#line 1165
          tmp___10 = close(fd);
          }
#line 1165
          if (tmp___10 == -1) {
#line 1166
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 1166
              tmp___9 = __errno_location();
#line 1166
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___9, "close() \"%s\" failed",
                                 (file + i)->name.data);
              }
            }
          }
#line 1171
          goto __Cont;
        }
      }
    }
    {
#line 1176
    tmp___15 = fcntl(fd, 2, 1);
    }
#line 1176
    if (tmp___15 == -1) {
#line 1177
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1177
        tmp___12 = __errno_location();
#line 1177
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___12, "fcntl(FD_CLOEXEC) \"%s\" failed",
                           (file + i)->name.data);
        }
      }
      {
#line 1181
      tmp___14 = close(fd);
      }
#line 1181
      if (tmp___14 == -1) {
#line 1182
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1182
          tmp___13 = __errno_location();
#line 1182
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___13, "close() \"%s\" failed",
                             (file + i)->name.data);
          }
        }
      }
#line 1187
      goto __Cont;
    }
    {
#line 1191
    tmp___17 = close((file + i)->fd);
    }
#line 1191
    if (tmp___17 == -1) {
#line 1192
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1192
        tmp___16 = __errno_location();
#line 1192
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___16, "close() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
    }
#line 1197
    (file + i)->fd = fd;
    __Cont: /* CIL Label */ 
#line 1091
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1200
  ngx_log_redirect_stderr(cycle);
  }
#line 1201
  return;
}
}
#line 1204 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf , ngx_str_t *name , size_t___0 size ,
                                      void *tag ) 
{ 
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_list_part_t *part ;
  int tmp ;
  void *tmp___0 ;

  {
#line 1211
  part = & (cf->cycle)->shared_memory.part;
#line 1212
  shm_zone = (ngx_shm_zone_t *)part->elts;
#line 1214
  i = (ngx_uint_t )0;
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    if (i >= part->nelts) {
#line 1217
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1218
        goto while_break;
      }
#line 1220
      part = part->next;
#line 1221
      shm_zone = (ngx_shm_zone_t *)part->elts;
#line 1222
      i = (ngx_uint_t )0;
    }
#line 1225
    if (name->len != (shm_zone + i)->shm.name.len) {
#line 1226
      goto __Cont;
    }
    {
#line 1229
    tmp = strncmp((char const   *)name->data, (char const   *)(shm_zone + i)->shm.name.data,
                  name->len);
    }
#line 1229
    if (tmp != 0) {
#line 1232
      goto __Cont;
    }
#line 1235
    if ((unsigned long )tag != (unsigned long )(shm_zone + i)->tag) {
      {
#line 1236
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the shared memory zone \"%V\" is already declared for a different use",
                         & (shm_zone + i)->shm.name);
      }
#line 1240
      return ((ngx_shm_zone_t *)((void *)0));
    }
#line 1243
    if ((shm_zone + i)->shm.size == 0UL) {
#line 1244
      (shm_zone + i)->shm.size = size;
    }
#line 1247
    if (size) {
#line 1247
      if (size != (shm_zone + i)->shm.size) {
        {
#line 1248
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the size %uz of shared memory zone \"%V\" conflicts with already declared size %uz",
                           size, & (shm_zone + i)->shm.name, (shm_zone + i)->shm.size);
        }
#line 1252
        return ((ngx_shm_zone_t *)((void *)0));
      }
    }
#line 1255
    return (shm_zone + i);
    __Cont: /* CIL Label */ 
#line 1214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1258
  tmp___0 = ngx_list_push(& (cf->cycle)->shared_memory);
#line 1258
  shm_zone = (ngx_shm_zone_t *)tmp___0;
  }
#line 1260
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 1261
    return ((ngx_shm_zone_t *)((void *)0));
  }
#line 1264
  shm_zone->data = (void *)0;
#line 1265
  shm_zone->shm.log = (cf->cycle)->log;
#line 1266
  shm_zone->shm.size = size;
#line 1267
  shm_zone->shm.name = *name;
#line 1268
  shm_zone->shm.exists = (ngx_uint_t )0;
#line 1269
  shm_zone->init = (ngx_int_t (*)(ngx_shm_zone_t *zone , void *data ))((void *)0);
#line 1270
  shm_zone->tag = tag;
#line 1271
  shm_zone->noreuse = (ngx_uint_t )0;
#line 1273
  return (shm_zone);
}
}
#line 1277 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static void ngx_clean_old_cycles(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t found ;
  ngx_uint_t live ;
  ngx_log_t *log ;
  ngx_cycle_t **cycle ;

  {
#line 1284
  log = (ngx_log_t *)ngx_cycle->log;
#line 1285
  ngx_temp_pool->log = log;
#line 1289
  live = (ngx_uint_t )0;
#line 1291
  cycle = (ngx_cycle_t **)ngx_old_cycles.elts;
#line 1292
  i = (ngx_uint_t )0;
  {
#line 1292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1292
    if (! (i < ngx_old_cycles.nelts)) {
#line 1292
      goto while_break;
    }
#line 1294
    if ((unsigned long )*(cycle + i) == (unsigned long )((void *)0)) {
#line 1295
      goto __Cont;
    }
#line 1298
    found = (ngx_uint_t )0;
#line 1300
    n = (ngx_uint_t )0;
    {
#line 1300
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1300
      if (! (n < (*(cycle + i))->connection_n)) {
#line 1300
        goto while_break___0;
      }
#line 1301
      if (((*(cycle + i))->connections + n)->fd != -1) {
#line 1302
        found = (ngx_uint_t )1;
#line 1306
        goto while_break___0;
      }
#line 1300
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1310
    if (found) {
#line 1311
      live = (ngx_uint_t )1;
#line 1312
      goto __Cont;
    }
    {
#line 1317
    ngx_destroy_pool((*(cycle + i))->pool);
#line 1318
    *(cycle + i) = (ngx_cycle_t *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 1292
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1323
  if (live) {
    {
#line 1324
    ngx_event_add_timer(ev, (ngx_msec_t )30000);
    }
  } else {
    {
#line 1327
    ngx_destroy_pool(ngx_temp_pool);
#line 1328
    ngx_temp_pool = (ngx_pool_t *)((void *)0);
#line 1329
    ngx_old_cycles.nelts = (ngx_uint_t )0;
    }
  }
#line 1331
  return;
}
}
#line 1334 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
void ngx_set_shutdown_timer(ngx_cycle_t *cycle ) 
{ 
  ngx_core_conf_t *ccf ;

  {
#line 1339
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 1341
  if (ccf->shutdown_timeout) {
    {
#line 1342
    ngx_shutdown_event.handler = & ngx_shutdown_timer_handler;
#line 1343
    ngx_shutdown_event.data = (void *)cycle;
#line 1344
    ngx_shutdown_event.log = cycle->log;
#line 1345
    ngx_shutdown_event.cancelable = 1U;
#line 1347
    ngx_event_add_timer(& ngx_shutdown_event, ccf->shutdown_timeout);
    }
  }
#line 1349
  return;
}
}
#line 1352 "/tmp/nginx-1.13.2/src/core/ngx_cycle.c"
static void ngx_shutdown_timer_handler(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_cycle_t *cycle ;
  ngx_connection_t *c ;

  {
#line 1359
  cycle = (ngx_cycle_t *)ev->data;
#line 1361
  c = cycle->connections;
#line 1363
  i = (ngx_uint_t )0;
  {
#line 1363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1363
    if (! (i < cycle->connection_n)) {
#line 1363
      goto while_break;
    }
#line 1365
    if ((c + i)->fd == -1) {
#line 1371
      goto __Cont;
    } else
#line 1365
    if ((unsigned long )(c + i)->read == (unsigned long )((void *)0)) {
#line 1371
      goto __Cont;
    } else
#line 1365
    if (((c + i)->read)->accept) {
#line 1371
      goto __Cont;
    } else
#line 1365
    if (((c + i)->read)->channel) {
#line 1371
      goto __Cont;
    } else
#line 1365
    if (((c + i)->read)->resolver) {
#line 1371
      goto __Cont;
    }
    {
#line 1377
    (c + i)->close = 1U;
#line 1378
    (c + i)->error = 1U;
#line 1380
    (*(((c + i)->read)->handler))((c + i)->read);
    }
    __Cont: /* CIL Label */ 
#line 1363
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1382
  return;
}
}
#line 116 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 222
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209 "src/core/ngx_connection.h"
ngx_int_t ngx_set_inherited_sockets(ngx_cycle_t *cycle ) ;
#line 425 "src/event/ngx_event.h"
ngx_os_io_t ngx_io  ;
#line 16 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
static void ngx_drain_connections(ngx_cycle_t *cycle ) ;
#line 19 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_listening_t *ngx_create_listening(ngx_conf_t *cf , struct sockaddr *sockaddr ,
                                      socklen_t socklen ) 
{ 
  size_t___0 len ;
  ngx_listening_t *ls ;
  struct sockaddr *sa ;
  u_char text[(sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path))] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 28
  tmp = ngx_array_push(& (cf->cycle)->listening);
#line 28
  ls = (ngx_listening_t *)tmp;
  }
#line 29
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 30
    return ((ngx_listening_t *)((void *)0));
  }
  {
#line 33
  memset((void *)ls, 0, sizeof(ngx_listening_t ));
#line 35
  tmp___0 = ngx_palloc(cf->pool, (size_t___0 )socklen);
#line 35
  sa = (struct sockaddr *)tmp___0;
  }
#line 36
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 37
    return ((ngx_listening_t *)((void *)0));
  }
  {
#line 40
  memcpy((void */* __restrict  */)sa, (void const   */* __restrict  */)sockaddr, (size_t )socklen);
#line 42
  ls->sockaddr = sa;
#line 43
  ls->socklen = socklen;
#line 45
  len = ngx_sock_ntop(sa, socklen, text, (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)),
                      (ngx_uint_t )1);
#line 46
  ls->addr_text.len = len;
  }
  {
#line 50
  if ((int )(ls->sockaddr)->sa_family == 10) {
#line 50
    goto case_10;
  }
#line 55
  if ((int )(ls->sockaddr)->sa_family == 1) {
#line 55
    goto case_1;
  }
#line 60
  if ((int )(ls->sockaddr)->sa_family == 2) {
#line 60
    goto case_2;
  }
#line 63
  goto switch_default;
  case_10: /* CIL Label */ 
#line 51
  ls->addr_text_max_len = sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL;
#line 52
  goto switch_break;
  case_1: /* CIL Label */ 
#line 56
  ls->addr_text_max_len = sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 57
  len ++;
#line 58
  goto switch_break;
  case_2: /* CIL Label */ 
#line 61
  ls->addr_text_max_len = sizeof("255.255.255.255") - 1UL;
#line 62
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 64
  ls->addr_text_max_len = (sizeof("unix:") - 1UL) + (sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path));
#line 65
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp___1 = ngx_pnalloc(cf->pool, len);
#line 68
  ls->addr_text.data = (u_char *)tmp___1;
  }
#line 69
  if ((unsigned long )ls->addr_text.data == (unsigned long )((void *)0)) {
#line 70
    return ((ngx_listening_t *)((void *)0));
  }
  {
#line 73
  memcpy((void */* __restrict  */)ls->addr_text.data, (void const   */* __restrict  */)(text),
         len);
#line 75
  ls->fd = -1;
#line 76
  ls->type = 1;
#line 78
  ls->backlog = 511;
#line 79
  ls->rcvbuf = -1;
#line 80
  ls->sndbuf = -1;
#line 87
  ls->fastopen = -1;
  }
#line 90
  return (ls);
}
}
#line 94 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_int_t ngx_clone_listening(ngx_conf_t *cf , ngx_listening_t *ls ) 
{ 
  ngx_int_t n ;
  ngx_core_conf_t *ccf ;
  ngx_listening_t ols ;
  void *tmp ;

  {
#line 103
  if (! ls->reuseport) {
#line 104
    return ((ngx_int_t )0);
  }
#line 107
  ols = *ls;
#line 109
  ccf = (ngx_core_conf_t *)*((cf->cycle)->conf_ctx + ngx_core_module.index);
#line 112
  n = (ngx_int_t )1;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (n < ccf->worker_processes)) {
#line 112
      goto while_break;
    }
    {
#line 116
    tmp = ngx_array_push(& (cf->cycle)->listening);
#line 116
    ls = (ngx_listening_t *)tmp;
    }
#line 117
    if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 118
      return ((ngx_int_t )-1);
    }
#line 121
    *ls = ols;
#line 122
    ls->worker = (ngx_uint_t )n;
#line 112
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return ((ngx_int_t )0);
}
}
#line 131 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_int_t ngx_set_inherited_sockets(ngx_cycle_t *cycle ) 
{ 
  size_t___0 len ;
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  socklen_t olen ;
  ngx_err_t err ;
  int timeout ;
  int reuseport ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;

  {
#line 151
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 152
  i = (ngx_uint_t )0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < cycle->listening.nelts)) {
#line 152
      goto while_break;
    }
    {
#line 154
    tmp = ngx_palloc(cycle->pool, sizeof(ngx_sockaddr_t ));
#line 154
    (ls + i)->sockaddr = (struct sockaddr *)tmp;
    }
#line 155
    if ((unsigned long )(ls + i)->sockaddr == (unsigned long )((void *)0)) {
#line 156
      return ((ngx_int_t )-1);
    }
    {
#line 159
    (ls + i)->socklen = (socklen_t )sizeof(ngx_sockaddr_t );
#line 160
    tmp___1 = getsockname((ls + i)->fd, (struct sockaddr */* __restrict  */)(ls + i)->sockaddr,
                          (socklen_t */* __restrict  */)(& (ls + i)->socklen));
    }
#line 160
    if (tmp___1 == -1) {
#line 161
      if ((cycle->log)->log_level >= 3UL) {
        {
#line 161
        tmp___0 = __errno_location();
#line 161
        ngx_log_error_core((ngx_uint_t )3, cycle->log, *tmp___0, "getsockname() of the inherited socket #%d failed",
                           (ls + i)->fd);
        }
      }
#line 164
      (ls + i)->ignore = 1U;
#line 165
      goto __Cont;
    }
    {
#line 171
    if ((int )((ls + i)->sockaddr)->sa_family == 10) {
#line 171
      goto case_10;
    }
#line 178
    if ((int )((ls + i)->sockaddr)->sa_family == 1) {
#line 178
      goto case_1;
    }
#line 184
    if ((int )((ls + i)->sockaddr)->sa_family == 2) {
#line 184
      goto case_2;
    }
#line 189
    goto switch_default;
    case_10: /* CIL Label */ 
#line 172
    (ls + i)->addr_text_max_len = sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL;
#line 173
    len = ((sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL) + sizeof("[]:65535")) - 1UL;
#line 174
    goto switch_break;
    case_1: /* CIL Label */ 
#line 179
    (ls + i)->addr_text_max_len = sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 180
    len = sizeof(struct sockaddr_un ) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 181
    goto switch_break;
    case_2: /* CIL Label */ 
#line 185
    (ls + i)->addr_text_max_len = sizeof("255.255.255.255") - 1UL;
#line 186
    len = ((sizeof("255.255.255.255") - 1UL) + sizeof(":65535")) - 1UL;
#line 187
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 190
    if ((cycle->log)->log_level >= 3UL) {
      {
#line 190
      tmp___2 = __errno_location();
#line 190
      ngx_log_error_core((ngx_uint_t )3, cycle->log, *tmp___2, "the inherited socket #%d has an unsupported protocol family",
                         (ls + i)->fd);
      }
    }
#line 193
    (ls + i)->ignore = 1U;
#line 194
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    {
#line 197
    tmp___3 = ngx_pnalloc(cycle->pool, len);
#line 197
    (ls + i)->addr_text.data = (u_char *)tmp___3;
    }
#line 198
    if ((unsigned long )(ls + i)->addr_text.data == (unsigned long )((void *)0)) {
#line 199
      return ((ngx_int_t )-1);
    }
    {
#line 202
    len = ngx_sock_ntop((ls + i)->sockaddr, (ls + i)->socklen, (ls + i)->addr_text.data,
                        len, (ngx_uint_t )1);
    }
#line 204
    if (len == 0UL) {
#line 205
      return ((ngx_int_t )-1);
    }
    {
#line 208
    (ls + i)->addr_text.len = len;
#line 210
    (ls + i)->backlog = 511;
#line 212
    olen = (socklen_t )sizeof(int );
#line 214
    tmp___5 = getsockopt((ls + i)->fd, 1, 3, (void */* __restrict  */)((void *)(& (ls + i)->type)),
                         (socklen_t */* __restrict  */)(& olen));
    }
#line 214
    if (tmp___5 == -1) {
#line 218
      if ((cycle->log)->log_level >= 3UL) {
        {
#line 218
        tmp___4 = __errno_location();
#line 218
        ngx_log_error_core((ngx_uint_t )3, cycle->log, *tmp___4, "getsockopt(SO_TYPE) %V failed",
                           & (ls + i)->addr_text);
        }
      }
#line 220
      (ls + i)->ignore = 1U;
#line 221
      goto __Cont;
    }
    {
#line 224
    olen = (socklen_t )sizeof(int );
#line 226
    tmp___7 = getsockopt((ls + i)->fd, 1, 8, (void */* __restrict  */)((void *)(& (ls + i)->rcvbuf)),
                         (socklen_t */* __restrict  */)(& olen));
    }
#line 226
    if (tmp___7 == -1) {
#line 230
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 230
        tmp___6 = __errno_location();
#line 230
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___6, "getsockopt(SO_RCVBUF) %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
#line 234
      (ls + i)->rcvbuf = -1;
    }
    {
#line 237
    olen = (socklen_t )sizeof(int );
#line 239
    tmp___9 = getsockopt((ls + i)->fd, 1, 7, (void */* __restrict  */)((void *)(& (ls + i)->sndbuf)),
                         (socklen_t */* __restrict  */)(& olen));
    }
#line 239
    if (tmp___9 == -1) {
#line 243
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 243
        tmp___8 = __errno_location();
#line 243
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___8, "getsockopt(SO_SNDBUF) %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
#line 247
      (ls + i)->sndbuf = -1;
    }
    {
#line 273
    reuseport = 0;
#line 274
    olen = (socklen_t )sizeof(int );
#line 276
    tmp___11 = getsockopt((ls + i)->fd, 1, 15, (void */* __restrict  */)((void *)(& reuseport)),
                          (socklen_t */* __restrict  */)(& olen));
    }
#line 276
    if (tmp___11 == -1) {
#line 280
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 280
        tmp___10 = __errno_location();
#line 280
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___10, "getsockopt(SO_REUSEPORT) %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
    } else
#line 285
    if (reuseport) {
#line 285
      (ls + i)->reuseport = 1U;
    } else {
#line 285
      (ls + i)->reuseport = 0U;
    }
#line 290
    if ((ls + i)->type != 1) {
#line 291
      goto __Cont;
    }
    {
#line 296
    olen = (socklen_t )sizeof(int );
#line 298
    tmp___13 = getsockopt((ls + i)->fd, 6, 23, (void */* __restrict  */)((void *)(& (ls + i)->fastopen)),
                          (socklen_t */* __restrict  */)(& olen));
    }
#line 298
    if (tmp___13 == -1) {
      {
#line 302
      tmp___12 = __errno_location();
#line 302
      err = *tmp___12;
      }
#line 304
      if (err != 95) {
#line 304
        if (err != 92) {
#line 305
          if ((cycle->log)->log_level >= 6UL) {
            {
#line 305
            ngx_log_error_core((ngx_uint_t )6, cycle->log, err, "getsockopt(TCP_FASTOPEN) %V failed, ignored",
                               & (ls + i)->addr_text);
            }
          }
        }
      }
#line 310
      (ls + i)->fastopen = -1;
    }
    {
#line 350
    timeout = 0;
#line 351
    olen = (socklen_t )sizeof(int );
#line 353
    tmp___15 = getsockopt((ls + i)->fd, 6, 9, (void */* __restrict  */)(& timeout),
                          (socklen_t */* __restrict  */)(& olen));
    }
#line 353
    if (tmp___15 == -1) {
      {
#line 356
      tmp___14 = __errno_location();
#line 356
      err = *tmp___14;
      }
#line 358
      if (err == 95) {
#line 359
        goto __Cont;
      }
#line 362
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 362
        ngx_log_error_core((ngx_uint_t )6, cycle->log, err, "getsockopt(TCP_DEFER_ACCEPT) for %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
#line 365
      goto __Cont;
    }
#line 368
    if ((unsigned long )olen < sizeof(int )) {
#line 369
      goto __Cont;
    } else
#line 368
    if (timeout == 0) {
#line 369
      goto __Cont;
    }
#line 372
    (ls + i)->deferred_accept = 1U;
    __Cont: /* CIL Label */ 
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return ((ngx_int_t )0);
}
}
#line 380 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle ) 
{ 
  int reuseaddr ;
  ngx_uint_t i ;
  ngx_uint_t tries ;
  ngx_uint_t failed ;
  ngx_err_t err ;
  ngx_log_t *log ;
  ngx_socket_t s ;
  ngx_listening_t *ls ;
  int reuseport ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int reuseport___0 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int ipv6only ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  mode_t mode ;
  u_char *name ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  int *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
#line 390
  reuseaddr = 1;
#line 392
  failed = (ngx_uint_t )0;
#line 395
  log = cycle->log;
#line 399
  tries = (ngx_uint_t )5;
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! tries) {
#line 399
      goto while_break;
    }
#line 400
    failed = (ngx_uint_t )0;
#line 404
    ls = (ngx_listening_t *)cycle->listening.elts;
#line 405
    i = (ngx_uint_t )0;
    {
#line 405
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 405
      if (! (i < cycle->listening.nelts)) {
#line 405
        goto while_break___0;
      }
#line 407
      if ((ls + i)->ignore) {
#line 408
        goto __Cont;
      }
#line 413
      if ((ls + i)->add_reuseport) {
        {
#line 421
        reuseport = 1;
#line 423
        tmp___0 = setsockopt((ls + i)->fd, 1, 15, (void const   *)(& reuseport), (socklen_t )sizeof(int ));
        }
#line 423
        if (tmp___0 == -1) {
#line 427
          if ((cycle->log)->log_level >= 2UL) {
            {
#line 427
            tmp = __errno_location();
#line 427
            ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "setsockopt(SO_REUSEPORT) %V failed, ignored",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 432
        (ls + i)->add_reuseport = 0U;
      }
#line 436
      if ((ls + i)->fd != -1) {
#line 437
        goto __Cont;
      }
#line 440
      if ((ls + i)->inherited) {
#line 446
        goto __Cont;
      }
      {
#line 449
      s = socket((int )((ls + i)->sockaddr)->sa_family, (ls + i)->type, 0);
      }
#line 451
      if (s == -1) {
#line 452
        if (log->log_level >= 1UL) {
          {
#line 452
          tmp___1 = __errno_location();
#line 452
          ngx_log_error_core((ngx_uint_t )1, log, *tmp___1, "socket() %V failed",
                             & (ls + i)->addr_text);
          }
        }
#line 454
        return ((ngx_int_t )-1);
      }
      {
#line 457
      tmp___5 = setsockopt(s, 1, 2, (void const   *)(& reuseaddr), (socklen_t )sizeof(int ));
      }
#line 457
      if (tmp___5 == -1) {
#line 461
        if (log->log_level >= 1UL) {
          {
#line 461
          tmp___2 = __errno_location();
#line 461
          ngx_log_error_core((ngx_uint_t )1, log, *tmp___2, "setsockopt(SO_REUSEADDR) %V failed",
                             & (ls + i)->addr_text);
          }
        }
        {
#line 465
        tmp___4 = close(s);
        }
#line 465
        if (tmp___4 == -1) {
#line 466
          if (log->log_level >= 1UL) {
            {
#line 466
            tmp___3 = __errno_location();
#line 466
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___3, "close() socket %V failed",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 471
        return ((ngx_int_t )-1);
      }
#line 476
      if ((ls + i)->reuseport) {
        {
#line 479
        reuseport___0 = 1;
#line 481
        tmp___9 = setsockopt(s, 1, 15, (void const   *)(& reuseport___0), (socklen_t )sizeof(int ));
        }
#line 481
        if (tmp___9 == -1) {
#line 485
          if (log->log_level >= 1UL) {
            {
#line 485
            tmp___6 = __errno_location();
#line 485
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___6, "setsockopt(SO_REUSEPORT) %V failed, ignored",
                               & (ls + i)->addr_text);
            }
          }
          {
#line 489
          tmp___8 = close(s);
          }
#line 489
          if (tmp___8 == -1) {
#line 490
            if (log->log_level >= 1UL) {
              {
#line 490
              tmp___7 = __errno_location();
#line 490
              ngx_log_error_core((ngx_uint_t )1, log, *tmp___7, "close() socket %V failed",
                                 & (ls + i)->addr_text);
              }
            }
          }
#line 495
          return ((ngx_int_t )-1);
        }
      }
#line 502
      if ((int )((ls + i)->sockaddr)->sa_family == 10) {
        {
#line 505
        ipv6only = (int )(ls + i)->ipv6only;
#line 507
        tmp___11 = setsockopt(s, 41, 26, (void const   *)(& ipv6only), (socklen_t )sizeof(int ));
        }
#line 507
        if (tmp___11 == -1) {
#line 511
          if (log->log_level >= 1UL) {
            {
#line 511
            tmp___10 = __errno_location();
#line 511
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___10, "setsockopt(IPV6_V6ONLY) %V failed, ignored",
                               & (ls + i)->addr_text);
            }
          }
        }
      }
#line 519
      if (! (ngx_event_flags & 512UL)) {
        {
#line 520
        tmp___15 = ngx_nonblocking(s);
        }
#line 520
        if (tmp___15 == -1) {
#line 521
          if (log->log_level >= 1UL) {
            {
#line 521
            tmp___12 = __errno_location();
#line 521
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___12, "ioctl(FIONBIO) %V failed",
                               & (ls + i)->addr_text);
            }
          }
          {
#line 525
          tmp___14 = close(s);
          }
#line 525
          if (tmp___14 == -1) {
#line 526
            if (log->log_level >= 1UL) {
              {
#line 526
              tmp___13 = __errno_location();
#line 526
              ngx_log_error_core((ngx_uint_t )1, log, *tmp___13, "close() socket %V failed",
                                 & (ls + i)->addr_text);
              }
            }
          }
#line 531
          return ((ngx_int_t )-1);
        }
      }
      {
#line 538
      tmp___19 = bind(s, (struct sockaddr  const  */* __restrict  */)(ls + i)->sockaddr,
                      (ls + i)->socklen);
      }
#line 538
      if (tmp___19 == -1) {
        {
#line 539
        tmp___16 = __errno_location();
#line 539
        err = *tmp___16;
        }
#line 541
        if (err != 98) {
#line 541
          goto _L;
        } else
#line 541
        if (! ngx_test_config) {
          _L: /* CIL Label */ 
#line 542
          if (log->log_level >= 1UL) {
            {
#line 542
            ngx_log_error_core((ngx_uint_t )1, log, err, "bind() to %V failed", & (ls + i)->addr_text);
            }
          }
        }
        {
#line 546
        tmp___18 = close(s);
        }
#line 546
        if (tmp___18 == -1) {
#line 547
          if (log->log_level >= 1UL) {
            {
#line 547
            tmp___17 = __errno_location();
#line 547
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___17, "close() socket %V failed",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 552
        if (err != 98) {
#line 553
          return ((ngx_int_t )-1);
        }
#line 556
        if (! ngx_test_config) {
#line 557
          failed = (ngx_uint_t )1;
        }
#line 560
        goto __Cont;
      }
#line 565
      if ((int )((ls + i)->sockaddr)->sa_family == 1) {
        {
#line 569
        name = ((ls + i)->addr_text.data + sizeof("unix:")) - 1;
#line 570
        mode = (mode_t )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 572
        tmp___21 = chmod((char const   *)((char *)name), mode);
        }
#line 572
        if (tmp___21 == -1) {
#line 573
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 573
            tmp___20 = __errno_location();
#line 573
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___20, "chmod() \"%s\" failed",
                               name);
            }
          }
        }
#line 577
        if (ngx_test_config) {
          {
#line 578
          tmp___23 = unlink((char const   *)name);
          }
#line 578
          if (tmp___23 == -1) {
#line 579
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 579
              tmp___22 = __errno_location();
#line 579
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___22, "unlink() %s failed",
                                 name);
              }
            }
          }
        }
      }
#line 586
      if ((ls + i)->type != 1) {
#line 587
        (ls + i)->fd = s;
#line 588
        goto __Cont;
      }
      {
#line 591
      tmp___27 = listen(s, (ls + i)->backlog);
      }
#line 591
      if (tmp___27 == -1) {
        {
#line 592
        tmp___24 = __errno_location();
#line 592
        err = *tmp___24;
        }
#line 600
        if (err != 98) {
#line 600
          goto _L___0;
        } else
#line 600
        if (! ngx_test_config) {
          _L___0: /* CIL Label */ 
#line 601
          if (log->log_level >= 1UL) {
            {
#line 601
            ngx_log_error_core((ngx_uint_t )1, log, err, "listen() to %V, backlog %d failed",
                               & (ls + i)->addr_text, (ls + i)->backlog);
            }
          }
        }
        {
#line 606
        tmp___26 = close(s);
        }
#line 606
        if (tmp___26 == -1) {
#line 607
          if (log->log_level >= 1UL) {
            {
#line 607
            tmp___25 = __errno_location();
#line 607
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___25, "close() socket %V failed",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 612
        if (err != 98) {
#line 613
          return ((ngx_int_t )-1);
        }
#line 616
        if (! ngx_test_config) {
#line 617
          failed = (ngx_uint_t )1;
        }
#line 620
        goto __Cont;
      }
#line 623
      (ls + i)->listen = 1U;
#line 625
      (ls + i)->fd = s;
      __Cont: /* CIL Label */ 
#line 405
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 628
    if (! failed) {
#line 629
      goto while_break;
    }
#line 634
    if (log->log_level >= 6UL) {
      {
#line 634
      ngx_log_error_core((ngx_uint_t )6, log, 0, "try again to bind() after 500ms");
      }
    }
    {
#line 637
    usleep((__useconds_t )500000);
#line 399
    tries --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  if (failed) {
#line 641
    if (log->log_level >= 1UL) {
      {
#line 641
      ngx_log_error_core((ngx_uint_t )1, log, 0, "still could not bind()");
      }
    }
#line 642
    return ((ngx_int_t )-1);
  }
#line 645
  return ((ngx_int_t )0);
}
}
#line 649 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
void ngx_configure_listening_sockets(ngx_cycle_t *cycle ) 
{ 
  int value ;
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;

  {
#line 660
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 661
  i = (ngx_uint_t )0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (i < cycle->listening.nelts)) {
#line 661
      goto while_break;
    }
#line 663
    (ls + i)->log = *((ls + i)->logp);
#line 665
    if ((ls + i)->rcvbuf != -1) {
      {
#line 666
      tmp___0 = setsockopt((ls + i)->fd, 1, 8, (void const   *)(& (ls + i)->rcvbuf),
                           (socklen_t )sizeof(int ));
      }
#line 666
      if (tmp___0 == -1) {
#line 670
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 670
          tmp = __errno_location();
#line 670
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "setsockopt(SO_RCVBUF, %d) %V failed, ignored",
                             (ls + i)->rcvbuf, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 676
    if ((ls + i)->sndbuf != -1) {
      {
#line 677
      tmp___2 = setsockopt((ls + i)->fd, 1, 7, (void const   *)(& (ls + i)->sndbuf),
                           (socklen_t )sizeof(int ));
      }
#line 677
      if (tmp___2 == -1) {
#line 681
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 681
          tmp___1 = __errno_location();
#line 681
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "setsockopt(SO_SNDBUF, %d) %V failed, ignored",
                             (ls + i)->sndbuf, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 687
    if ((ls + i)->keepalive) {
#line 688
      if ((ls + i)->keepalive == 1U) {
#line 688
        value = 1;
      } else {
#line 688
        value = 0;
      }
      {
#line 690
      tmp___4 = setsockopt((ls + i)->fd, 1, 9, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 690
      if (tmp___4 == -1) {
#line 694
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 694
          tmp___3 = __errno_location();
#line 694
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "setsockopt(SO_KEEPALIVE, %d) %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 702
    if ((ls + i)->keepidle) {
      {
#line 703
      value = (ls + i)->keepidle;
#line 709
      tmp___6 = setsockopt((ls + i)->fd, 6, 4, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 709
      if (tmp___6 == -1) {
#line 713
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 713
          tmp___5 = __errno_location();
#line 713
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "setsockopt(TCP_KEEPIDLE, %d) %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 719
    if ((ls + i)->keepintvl) {
      {
#line 720
      value = (ls + i)->keepintvl;
#line 726
      tmp___8 = setsockopt((ls + i)->fd, 6, 5, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 726
      if (tmp___8 == -1) {
#line 730
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 730
          tmp___7 = __errno_location();
#line 730
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___7, "setsockopt(TCP_KEEPINTVL, %d) %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 736
    if ((ls + i)->keepcnt) {
      {
#line 737
      tmp___10 = setsockopt((ls + i)->fd, 6, 6, (void const   *)(& (ls + i)->keepcnt),
                            (socklen_t )sizeof(int ));
      }
#line 737
      if (tmp___10 == -1) {
#line 741
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 741
          tmp___9 = __errno_location();
#line 741
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___9, "setsockopt(TCP_KEEPCNT, %d) %V failed, ignored",
                             (ls + i)->keepcnt, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 763
    if ((ls + i)->fastopen != -1) {
      {
#line 764
      tmp___12 = setsockopt((ls + i)->fd, 6, 23, (void const   *)(& (ls + i)->fastopen),
                            (socklen_t )sizeof(int ));
      }
#line 764
      if (tmp___12 == -1) {
#line 768
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 768
          tmp___11 = __errno_location();
#line 768
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___11, "setsockopt(TCP_FASTOPEN, %d) %V failed, ignored",
                             (ls + i)->fastopen, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 790
    if ((ls + i)->listen) {
      {
#line 794
      tmp___14 = listen((ls + i)->fd, (ls + i)->backlog);
      }
#line 794
      if (tmp___14 == -1) {
#line 795
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 795
          tmp___13 = __errno_location();
#line 795
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___13, "listen() to %V, backlog %d failed, ignored",
                             & (ls + i)->addr_text, (ls + i)->backlog);
          }
        }
      }
    }
#line 855
    if ((ls + i)->add_deferred) {
#line 855
      goto _L;
    } else
#line 855
    if ((ls + i)->delete_deferred) {
      _L: /* CIL Label */ 
#line 857
      if ((ls + i)->add_deferred) {
#line 864
        value = 1;
      } else {
#line 867
        value = 0;
      }
      {
#line 870
      tmp___16 = setsockopt((ls + i)->fd, 6, 9, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 870
      if (tmp___16 == -1) {
#line 874
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 874
          tmp___15 = __errno_location();
#line 874
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___15, "setsockopt(TCP_DEFER_ACCEPT, %d) for %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
#line 879
        goto __Cont;
      }
    }
#line 883
    if ((ls + i)->add_deferred) {
#line 884
      (ls + i)->deferred_accept = 1U;
    }
#line 912
    if ((ls + i)->wildcard) {
#line 912
      if ((ls + i)->type == 2) {
#line 912
        if ((int )((ls + i)->sockaddr)->sa_family == 2) {
          {
#line 916
          value = 1;
#line 918
          tmp___18 = setsockopt((ls + i)->fd, 0, 8, (void const   *)(& value), (socklen_t )sizeof(int ));
          }
#line 918
          if (tmp___18 == -1) {
#line 922
            if ((cycle->log)->log_level >= 2UL) {
              {
#line 922
              tmp___17 = __errno_location();
#line 922
              ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___17, "setsockopt(IP_PKTINFO) for %V failed, ignored",
                                 & (ls + i)->addr_text);
              }
            }
          }
        }
      }
    }
#line 933
    if ((ls + i)->wildcard) {
#line 933
      if ((ls + i)->type == 2) {
#line 933
        if ((int )((ls + i)->sockaddr)->sa_family == 10) {
          {
#line 937
          value = 1;
#line 939
          tmp___20 = setsockopt((ls + i)->fd, 41, 49, (void const   *)(& value), (socklen_t )sizeof(int ));
          }
#line 939
          if (tmp___20 == -1) {
#line 943
            if ((cycle->log)->log_level >= 2UL) {
              {
#line 943
              tmp___19 = __errno_location();
#line 943
              ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___19, "setsockopt(IPV6_RECVPKTINFO) for %V failed, ignored",
                                 & (ls + i)->addr_text);
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 661
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 953
  return;
}
}
#line 957 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
void ngx_close_listening_sockets(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  int *tmp ;
  int tmp___0 ;
  u_char *name ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 964
  if (ngx_event_flags & 512UL) {
#line 965
    return;
  }
#line 968
  ngx_accept_mutex_held = (ngx_uint_t )0;
#line 969
  ngx_use_accept_mutex = (ngx_uint_t )0;
#line 971
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 972
  i = (ngx_uint_t )0;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! (i < cycle->listening.nelts)) {
#line 972
      goto while_break;
    }
#line 974
    c = (ls + i)->connection;
#line 976
    if (c) {
#line 977
      if ((c->read)->active) {
#line 978
        if (ngx_event_flags & 64UL) {
          {
#line 986
          (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )0);
          }
        } else {
          {
#line 989
          (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )1);
          }
        }
      }
      {
#line 993
      ngx_free_connection(c);
#line 995
      c->fd = -1;
      }
    }
    {
#line 1001
    tmp___0 = close((ls + i)->fd);
    }
#line 1001
    if (tmp___0 == -1) {
#line 1002
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1002
        tmp = __errno_location();
#line 1002
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp, "close() socket %V failed",
                           & (ls + i)->addr_text);
        }
      }
    }
#line 1008
    if ((int )((ls + i)->sockaddr)->sa_family == 1) {
#line 1008
      if (ngx_process <= 1UL) {
#line 1008
        if (ngx_new_binary == 0) {
          {
#line 1012
          name = ((ls + i)->addr_text.data + sizeof("unix:")) - 1;
#line 1014
          tmp___2 = unlink((char const   *)name);
          }
#line 1014
          if (tmp___2 == -1) {
#line 1015
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 1015
              tmp___1 = __errno_location();
#line 1015
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___1, "unlink() %s failed",
                                 name);
              }
            }
          }
        }
      }
    }
#line 1022
    (ls + i)->fd = -1;
#line 972
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1025
  cycle->listening.nelts = (ngx_uint_t )0;
#line 1026
  return;
}
}
#line 1029 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_connection_t *ngx_get_connection(ngx_socket_t s , ngx_log_t *log ) 
{ 
  ngx_uint_t instance ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;

  {
#line 1038
  if (ngx_cycle->files) {
#line 1038
    if ((ngx_uint_t )s >= (ngx_uint_t )ngx_cycle->files_n) {
#line 1039
      if (log->log_level >= 2UL) {
        {
#line 1039
        ngx_log_error_core((ngx_uint_t )2, log, 0, "the new socket has number %d, but only %ui files are available",
                           s, ngx_cycle->files_n);
        }
      }
#line 1043
      return ((ngx_connection_t *)((void *)0));
    }
  }
#line 1046
  c = (ngx_connection_t *)ngx_cycle->free_connections;
#line 1048
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 1049
    ngx_drain_connections((ngx_cycle_t *)ngx_cycle);
#line 1050
    c = (ngx_connection_t *)ngx_cycle->free_connections;
    }
  }
#line 1053
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1054
    if (log->log_level >= 2UL) {
      {
#line 1054
      ngx_log_error_core((ngx_uint_t )2, log, 0, "%ui worker_connections are not enough",
                         ngx_cycle->connection_n);
      }
    }
#line 1058
    return ((ngx_connection_t *)((void *)0));
  }
#line 1061
  ngx_cycle->free_connections = (ngx_connection_t */* volatile  */)c->data;
#line 1062
  ngx_cycle->free_connection_n -= (ngx_uint_t volatile   )1;
#line 1064
  if (ngx_cycle->files) {
#line 1064
    if ((unsigned long )*(ngx_cycle->files + s) == (unsigned long )((void *)0)) {
#line 1065
      *(ngx_cycle->files + s) = c;
    }
  }
  {
#line 1068
  rev = c->read;
#line 1069
  wev = c->write;
#line 1071
  memset((void *)c, 0, sizeof(ngx_connection_t ));
#line 1073
  c->read = rev;
#line 1074
  c->write = wev;
#line 1075
  c->fd = s;
#line 1076
  c->log = log;
#line 1078
  instance = (ngx_uint_t )rev->instance;
#line 1080
  memset((void *)rev, 0, sizeof(ngx_event_t ));
#line 1081
  memset((void *)wev, 0, sizeof(ngx_event_t ));
#line 1083
  rev->instance = (unsigned int )(! instance);
#line 1084
  wev->instance = (unsigned int )(! instance);
#line 1086
  rev->index = (ngx_uint_t )3503345872U;
#line 1087
  wev->index = (ngx_uint_t )3503345872U;
#line 1089
  rev->data = (void *)c;
#line 1090
  wev->data = (void *)c;
#line 1092
  wev->write = 1U;
  }
#line 1094
  return (c);
}
}
#line 1098 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
void ngx_free_connection(ngx_connection_t *c ) 
{ 


  {
#line 1101
  c->data = (void *)ngx_cycle->free_connections;
#line 1102
  ngx_cycle->free_connections = (ngx_connection_t */* volatile  */)c;
#line 1103
  ngx_cycle->free_connection_n += (ngx_uint_t volatile   )1;
#line 1105
  if (ngx_cycle->files) {
#line 1105
    if ((unsigned long )*(ngx_cycle->files + c->fd) == (unsigned long )c) {
#line 1106
      *(ngx_cycle->files + c->fd) = (ngx_connection_t *)((void *)0);
    }
  }
#line 1108
  return;
}
}
#line 1111 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
void ngx_close_connection(ngx_connection_t *c ) 
{ 
  ngx_err_t err ;
  ngx_uint_t log_error ;
  ngx_uint_t level ;
  ngx_socket_t fd ;
  int *tmp ;
  int tmp___0 ;

  {
#line 1118
  if (c->fd == -1) {
#line 1119
    if ((c->log)->log_level >= 2UL) {
      {
#line 1119
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "connection already closed");
      }
    }
#line 1120
    return;
  }
#line 1123
  if ((c->read)->timer_set) {
    {
#line 1124
    ngx_event_del_timer(c->read);
    }
  }
#line 1127
  if ((c->write)->timer_set) {
    {
#line 1128
    ngx_event_del_timer(c->write);
    }
  }
#line 1131
  if (! c->shared) {
#line 1132
    if (ngx_event_actions.del_conn) {
      {
#line 1133
      (*(ngx_event_actions.del_conn))(c, (ngx_uint_t )1);
      }
    } else {
#line 1136
      if ((c->read)->active) {
        {
#line 1137
        (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )1);
        }
      } else
#line 1136
      if ((c->read)->disabled) {
        {
#line 1137
        (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )1);
        }
      }
#line 1140
      if ((c->write)->active) {
        {
#line 1141
        (*(ngx_event_actions.del))(c->write, (ngx_int_t )4, (ngx_uint_t )1);
        }
      } else
#line 1140
      if ((c->write)->disabled) {
        {
#line 1141
        (*(ngx_event_actions.del))(c->write, (ngx_int_t )4, (ngx_uint_t )1);
        }
      }
    }
  }
#line 1146
  if ((c->read)->posted) {
#line 1147
    (c->read)->posted = 0U;
#line 1147
    ((c->read)->queue.next)->prev = (c->read)->queue.prev;
#line 1147
    ((c->read)->queue.prev)->next = (c->read)->queue.next;
  }
#line 1150
  if ((c->write)->posted) {
#line 1151
    (c->write)->posted = 0U;
#line 1151
    ((c->write)->queue.next)->prev = (c->write)->queue.prev;
#line 1151
    ((c->write)->queue.prev)->next = (c->write)->queue.next;
  }
  {
#line 1154
  (c->read)->closed = 1U;
#line 1155
  (c->write)->closed = 1U;
#line 1157
  ngx_reusable_connection(c, (ngx_uint_t )0);
#line 1159
  log_error = (ngx_uint_t )c->log_error;
#line 1161
  ngx_free_connection(c);
#line 1163
  fd = c->fd;
#line 1164
  c->fd = -1;
  }
#line 1166
  if (c->shared) {
#line 1167
    return;
  }
  {
#line 1170
  tmp___0 = close(fd);
  }
#line 1170
  if (tmp___0 == -1) {
    {
#line 1172
    tmp = __errno_location();
#line 1172
    err = *tmp;
    }
#line 1174
    if (err == 104) {
#line 1174
      goto _L;
    } else
#line 1174
    if (err == 107) {
      _L: /* CIL Label */ 
      {
#line 1178
      if (log_error == 2UL) {
#line 1178
        goto case_2;
      }
#line 1182
      if (log_error == 1UL) {
#line 1182
        goto case_1;
      }
#line 1186
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1179
      level = (ngx_uint_t )7;
#line 1180
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1183
      level = (ngx_uint_t )4;
#line 1184
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1187
      level = (ngx_uint_t )3;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1191
      level = (ngx_uint_t )3;
    }
#line 1194
    if ((c->log)->log_level >= level) {
      {
#line 1194
      ngx_log_error_core(level, c->log, err, "close() socket %d failed", fd);
      }
    }
  }
#line 1196
  return;
}
}
#line 1199 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
void ngx_reusable_connection(ngx_connection_t *c , ngx_uint_t reusable ) 
{ 


  {
#line 1205
  if (c->reusable) {
#line 1206
    (c->queue.next)->prev = c->queue.prev;
#line 1206
    (c->queue.prev)->next = c->queue.next;
#line 1207
    ngx_cycle->reusable_connections_n -= (ngx_uint_t volatile   )1;
  }
#line 1214
  c->reusable = (unsigned int )reusable;
#line 1216
  if (reusable) {
#line 1219
    c->queue.next = ((ngx_queue_t *)(& ngx_cycle->reusable_connections_queue))->next;
#line 1219
    (c->queue.next)->prev = & c->queue;
#line 1219
    c->queue.prev = (ngx_queue_t *)(& ngx_cycle->reusable_connections_queue);
#line 1219
    ((ngx_queue_t *)(& ngx_cycle->reusable_connections_queue))->next = & c->queue;
#line 1221
    ngx_cycle->reusable_connections_n += (ngx_uint_t volatile   )1;
  }
#line 1227
  return;
}
}
#line 1230 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
static void ngx_drain_connections(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_queue_t *q ;
  ngx_connection_t *c ;
  ngx_uint_t tmp___0 ;
  ngx_uint_t tmp___1 ;

  {
#line 1237
  if (32UL > cycle->reusable_connections_n / 8UL) {
#line 1237
    tmp___1 = cycle->reusable_connections_n / 8UL;
  } else {
#line 1237
    tmp___1 = (ngx_uint_t )32;
  }
#line 1237
  if (tmp___1 < 1UL) {
#line 1237
    n = (ngx_uint_t )1;
  } else {
#line 1237
    if (32UL > cycle->reusable_connections_n / 8UL) {
#line 1237
      tmp___0 = cycle->reusable_connections_n / 8UL;
    } else {
#line 1237
      tmp___0 = (ngx_uint_t )32;
    }
#line 1237
    n = tmp___0;
  }
#line 1239
  i = (ngx_uint_t )0;
  {
#line 1239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1239
    if (! (i < n)) {
#line 1239
      goto while_break;
    }
#line 1240
    if ((unsigned long )(& cycle->reusable_connections_queue) == (unsigned long )cycle->reusable_connections_queue.prev) {
#line 1241
      goto while_break;
    }
    {
#line 1244
    q = cycle->reusable_connections_queue.prev;
#line 1245
    c = (ngx_connection_t *)((u_char *)q - (unsigned long )(& ((ngx_connection_t *)0)->queue));
#line 1250
    c->close = 1U;
#line 1251
    (*((c->read)->handler))(c->read);
#line 1239
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  return;
}
}
#line 1256 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
void ngx_close_idle_connections(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_connection_t *c ;

  {
#line 1262
  c = cycle->connections;
#line 1264
  i = (ngx_uint_t )0;
  {
#line 1264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1264
    if (! (i < cycle->connection_n)) {
#line 1264
      goto while_break;
    }
#line 1268
    if ((c + i)->fd != -1) {
#line 1268
      if ((c + i)->idle) {
        {
#line 1269
        (c + i)->close = 1U;
#line 1270
        (*(((c + i)->read)->handler))((c + i)->read);
        }
      }
    }
#line 1264
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1273
  return;
}
}
#line 1276 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_int_t ngx_connection_local_sockaddr(ngx_connection_t *c , ngx_str_t *s , ngx_uint_t port ) 
{ 
  socklen_t len ;
  ngx_uint_t addr ;
  ngx_sockaddr_t sa ;
  struct sockaddr_in *sin ;
  ngx_uint_t i ;
  struct sockaddr_in6 *sin6 ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1289
  addr = (ngx_uint_t )0;
#line 1291
  if (c->local_socklen) {
    {
#line 1295
    if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 1295
      goto case_10;
    }
#line 1306
    if ((int )(c->local_sockaddr)->sa_family == 1) {
#line 1306
      goto case_1;
    }
#line 1311
    goto switch_default;
    case_10: /* CIL Label */ 
#line 1296
    sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 1298
    i = (ngx_uint_t )0;
    {
#line 1298
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1298
      if (addr == 0UL) {
#line 1298
        if (! (i < 16UL)) {
#line 1298
          goto while_break;
        }
      } else {
#line 1298
        goto while_break;
      }
#line 1299
      addr |= (unsigned long )sin6->sin6_addr.__in6_u.__u6_addr8[i];
#line 1298
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1302
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1307
    addr = (ngx_uint_t )1;
#line 1308
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1312
    sin = (struct sockaddr_in *)c->local_sockaddr;
#line 1313
    addr = (ngx_uint_t )sin->sin_addr.s_addr;
#line 1314
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1318
  if (addr == 0UL) {
    {
#line 1320
    len = (socklen_t )sizeof(ngx_sockaddr_t );
#line 1322
    tmp___0 = getsockname(c->fd, (struct sockaddr */* __restrict  */)(& sa.sockaddr),
                          (socklen_t */* __restrict  */)(& len));
    }
#line 1322
    if (tmp___0 == -1) {
      {
#line 1323
      tmp = __errno_location();
#line 1323
      ngx_connection_error(c, *tmp, (char *)"getsockname() failed");
      }
#line 1324
      return ((ngx_int_t )-1);
    }
    {
#line 1327
    tmp___1 = ngx_palloc(c->pool, (size_t___0 )len);
#line 1327
    c->local_sockaddr = (struct sockaddr *)tmp___1;
    }
#line 1328
    if ((unsigned long )c->local_sockaddr == (unsigned long )((void *)0)) {
#line 1329
      return ((ngx_int_t )-1);
    }
    {
#line 1332
    memcpy((void */* __restrict  */)c->local_sockaddr, (void const   */* __restrict  */)(& sa),
           (size_t )len);
#line 1334
    c->local_socklen = len;
    }
  }
#line 1337
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1338
    return ((ngx_int_t )0);
  }
  {
#line 1341
  s->len = ngx_sock_ntop(c->local_sockaddr, c->local_socklen, s->data, s->len, port);
  }
#line 1344
  return ((ngx_int_t )0);
}
}
#line 1348 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_int_t ngx_tcp_nodelay(ngx_connection_t *c ) 
{ 
  int tcp_nodelay ;
  int *tmp ;
  int tmp___0 ;

  {
#line 1353
  if (c->tcp_nodelay != 0U) {
#line 1354
    return ((ngx_int_t )0);
  }
  {
#line 1359
  tcp_nodelay = 1;
#line 1361
  tmp___0 = setsockopt(c->fd, 6, 1, (void const   *)(& tcp_nodelay), (socklen_t )sizeof(int ));
  }
#line 1361
  if (tmp___0 == -1) {
    {
#line 1380
    tmp = __errno_location();
#line 1380
    ngx_connection_error(c, *tmp, (char *)"setsockopt(TCP_NODELAY) failed");
    }
#line 1382
    return ((ngx_int_t )-1);
  }
#line 1385
  c->tcp_nodelay = 1U;
#line 1387
  return ((ngx_int_t )0);
}
}
#line 1391 "/tmp/nginx-1.13.2/src/core/ngx_connection.c"
ngx_int_t ngx_connection_error(ngx_connection_t *c , ngx_err_t err , char *text ) 
{ 
  ngx_uint_t level ;

  {
#line 1398
  if (err == 104) {
#line 1398
    if (c->log_error == 3U) {
#line 1404
      return ((ngx_int_t )0);
    }
  }
#line 1413
  if (err == 0) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 104) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 32) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 107) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 110) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 111) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 100) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 101) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 112) {
#line 1413
    goto _L;
  } else
#line 1413
  if (err == 113) {
    _L: /* CIL Label */ 
    {
#line 1432
    if (c->log_error == 2U) {
#line 1432
      goto case_2;
    }
#line 1432
    if (c->log_error == 3U) {
#line 1432
      goto case_2;
    }
#line 1432
    if (c->log_error == 4U) {
#line 1432
      goto case_2;
    }
#line 1436
    goto switch_default;
    case_2: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1433
    level = (ngx_uint_t )7;
#line 1434
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1437
    level = (ngx_uint_t )4;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1441
    level = (ngx_uint_t )2;
  }
#line 1444
  if ((c->log)->log_level >= level) {
    {
#line 1444
    ngx_log_error_core(level, c->log, err, (char const   *)text);
    }
  }
#line 1446
  return ((ngx_int_t )-1);
}
}
#line 35 "/usr/include/semaphore.h"
extern  __attribute__((__nothrow__)) int sem_init(sem_t *__sem , int __pshared , unsigned int __value ) ;
#line 38
extern  __attribute__((__nothrow__)) int sem_destroy(sem_t *__sem ) ;
#line 53
extern int sem_wait(sem_t *__sem ) ;
#line 68
extern  __attribute__((__nothrow__)) int sem_post(sem_t *__sem ) ;
#line 42 "src/core/ngx_shmtx.h"
void ngx_shmtx_destroy(ngx_shmtx_t *mtx ) ;
#line 15 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
static void ngx_shmtx_wakeup(ngx_shmtx_t *mtx ) ;
#line 18 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
ngx_int_t ngx_shmtx_create(ngx_shmtx_t *mtx , ngx_shmtx_sh_t *addr , u_char *name ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 21
  mtx->lock = & addr->lock;
#line 23
  if (mtx->spin == 0xffffffffffffffffUL) {
#line 24
    return ((ngx_int_t )0);
  }
  {
#line 27
  mtx->spin = (ngx_uint_t )2048;
#line 31
  mtx->wait = & addr->wait;
#line 33
  tmp___0 = sem_init(& mtx->sem, 1, 0U);
  }
#line 33
  if (tmp___0 == -1) {
#line 34
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 34
      tmp = __errno_location();
#line 34
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "sem_init() failed");
      }
    }
  } else {
#line 37
    mtx->semaphore = (ngx_uint_t )1;
  }
#line 42
  return ((ngx_int_t )0);
}
}
#line 46 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
void ngx_shmtx_destroy(ngx_shmtx_t *mtx ) 
{ 
  int *tmp ;
  int tmp___0 ;

  {
#line 51
  if (mtx->semaphore) {
    {
#line 52
    tmp___0 = sem_destroy(& mtx->sem);
    }
#line 52
    if (tmp___0 == -1) {
#line 53
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 53
        tmp = __errno_location();
#line 53
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "sem_destroy() failed");
        }
      }
    }
  }
#line 59
  return;
}
}
#line 62 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
ngx_uint_t ngx_shmtx_trylock(ngx_shmtx_t *mtx ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 65
  if (*(mtx->lock) == (ngx_atomic_t )0) {
    {
#line 65
    tmp = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
    }
#line 65
    if (tmp) {
#line 65
      tmp___0 = 1;
    } else {
#line 65
      tmp___0 = 0;
    }
  } else {
#line 65
    tmp___0 = 0;
  }
#line 65
  return ((ngx_uint_t )tmp___0);
}
}
#line 69 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
void ngx_shmtx_lock(ngx_shmtx_t *mtx ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  ngx_err_t err ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (*(mtx->lock) == (ngx_atomic_t )0) {
      {
#line 78
      tmp = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
      }
#line 78
      if (tmp) {
#line 79
        return;
      }
    }
#line 82
    if (ngx_ncpu > 1L) {
#line 84
      n = (ngx_uint_t )1;
      {
#line 84
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 84
        if (! (n < mtx->spin)) {
#line 84
          goto while_break___0;
        }
#line 86
        i = (ngx_uint_t )0;
        {
#line 86
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 86
          if (! (i < n)) {
#line 86
            goto while_break___1;
          }
#line 87
          __asm__  ("pause":);
#line 86
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 90
        if (*(mtx->lock) == (ngx_atomic_t )0) {
          {
#line 90
          tmp___0 = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
          }
#line 90
          if (tmp___0) {
#line 93
            return;
          }
        }
#line 84
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 100
    if (mtx->semaphore) {
      {
#line 101
      __sync_fetch_and_add(mtx->wait, 1);
      }
#line 103
      if (*(mtx->lock) == (ngx_atomic_t )0) {
        {
#line 103
        tmp___1 = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
        }
#line 103
        if (tmp___1) {
          {
#line 104
          __sync_fetch_and_add(mtx->wait, -1);
          }
#line 105
          return;
        }
      }
      {
#line 111
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 111
        tmp___3 = sem_wait(& mtx->sem);
        }
#line 111
        if (! (tmp___3 == -1)) {
#line 111
          goto while_break___2;
        }
        {
#line 114
        tmp___2 = __errno_location();
#line 114
        err = *tmp___2;
        }
#line 116
        if (err != 4) {
#line 117
          if ((ngx_cycle->log)->log_level >= 2UL) {
            {
#line 117
            ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, err, "sem_wait() failed while waiting on shmtx");
            }
          }
#line 119
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 126
      goto __Cont;
    }
    {
#line 131
    sched_yield();
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 136 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
void ngx_shmtx_unlock(ngx_shmtx_t *mtx ) 
{ 
  _Bool tmp ;

  {
  {
#line 143
  tmp = __sync_bool_compare_and_swap(mtx->lock, ngx_pid, 0);
  }
#line 143
  if (tmp) {
    {
#line 144
    ngx_shmtx_wakeup(mtx);
    }
  }
#line 146
  return;
}
}
#line 149 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
ngx_uint_t ngx_shmtx_force_unlock(ngx_shmtx_t *mtx , ngx_pid_t pid ) 
{ 
  _Bool tmp ;

  {
  {
#line 155
  tmp = __sync_bool_compare_and_swap(mtx->lock, pid, 0);
  }
#line 155
  if (tmp) {
    {
#line 156
    ngx_shmtx_wakeup(mtx);
    }
#line 157
    return ((ngx_uint_t )1);
  }
#line 160
  return ((ngx_uint_t )0);
}
}
#line 164 "/tmp/nginx-1.13.2/src/core/ngx_shmtx.c"
static void ngx_shmtx_wakeup(ngx_shmtx_t *mtx ) 
{ 
  ngx_atomic_uint_t wait___0 ;
  _Bool tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 170
  if (! mtx->semaphore) {
#line 171
    return;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    wait___0 = (ngx_atomic_uint_t )*(mtx->wait);
#line 178
    if ((ngx_atomic_int_t )wait___0 <= 0L) {
#line 179
      return;
    }
    {
#line 182
    tmp = __sync_bool_compare_and_swap(mtx->wait, wait___0, wait___0 - 1UL);
    }
#line 182
    if (tmp) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  tmp___1 = sem_post(& mtx->sem);
  }
#line 190
  if (tmp___1 == -1) {
#line 191
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 191
      tmp___0 = __errno_location();
#line 191
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___0, "sem_post() failed while wake shmtx");
      }
    }
  }
#line 196
  return;
}
}
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
#line 82 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 23 "src/core/ngx_times.h"
void ngx_time_init(void) ;
#line 34 "src/core/ngx_times.h"
ngx_time_t volatile   *ngx_cached_time  ;
#line 39 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_err_log_time  ;
#line 40 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_time  ;
#line 41 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_log_time  ;
#line 42 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_log_iso8601  ;
#line 43 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_syslog_time  ;
#line 49 "src/core/ngx_times.h"
ngx_msec_t volatile   ngx_current_msec  ;
#line 23 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static ngx_uint_t slot  ;
#line 24 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static ngx_atomic_t ngx_time_lock  ;
#line 42 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static ngx_int_t cached_gmtoff  ;
#line 45 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static ngx_time_t cached_time[64]  ;
#line 46 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static u_char cached_err_log_time[64][sizeof("1970/09/28 12:00:00")]  ;
#line 48 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static u_char cached_http_time[64][sizeof("Mon, 28 Sep 1970 06:00:00 GMT")]  ;
#line 50 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static u_char cached_http_log_time[64][sizeof("28/Sep/1970:12:00:00 +0600")]  ;
#line 52 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static u_char cached_http_log_iso8601[64][sizeof("1970-09-28T12:00:00+06:00")]  ;
#line 54 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static u_char cached_syslog_time[64][sizeof("Sep 28 12:00:00")]  ;
#line 58 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static char *week[7]  = {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat"};
#line 59 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
static char *months___0[12]  = 
#line 59
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 62 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
void ngx_time_init(void) 
{ 


  {
  {
#line 65
  ngx_cached_err_log_time.len = (size_t___0 volatile   )(sizeof("1970/09/28 12:00:00") - 1UL);
#line 66
  ngx_cached_http_time.len = (size_t___0 volatile   )(sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1UL);
#line 67
  ngx_cached_http_log_time.len = (size_t___0 volatile   )(sizeof("28/Sep/1970:12:00:00 +0600") - 1UL);
#line 68
  ngx_cached_http_log_iso8601.len = (size_t___0 volatile   )(sizeof("1970-09-28T12:00:00+06:00") - 1UL);
#line 69
  ngx_cached_syslog_time.len = (size_t___0 volatile   )(sizeof("Sep 28 12:00:00") - 1UL);
#line 71
  ngx_cached_time = (ngx_time_t volatile   *)(& cached_time[0]);
#line 73
  ngx_time_update();
  }
#line 74
  return;
}
}
#line 77 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
void ngx_time_update(void) 
{ 
  u_char *p0 ;
  u_char *p1 ;
  u_char *p2 ;
  u_char *p3 ;
  u_char *p4 ;
  ngx_tm_t tm ;
  ngx_tm_t gmt ;
  time_t sec ;
  ngx_uint_t msec ;
  ngx_time_t *tp ;
  struct timeval tv ;
  _Bool tmp ;
  long tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  ngx_int_t tmp___4 ;
  int tmp___5 ;

  {
#line 87
  if (ngx_time_lock == (ngx_atomic_t )0) {
    {
#line 87
    tmp = __sync_bool_compare_and_swap(& ngx_time_lock, 0, 1);
    }
#line 87
    if (! tmp) {
#line 88
      return;
    }
  } else {
#line 88
    return;
  }
  {
#line 91
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 93
  sec = tv.tv_sec;
#line 94
  msec = (ngx_uint_t )(tv.tv_usec / 1000L);
#line 96
  ngx_current_msec = (ngx_msec_t volatile   )((ngx_msec_t )sec * 1000UL + msec);
#line 98
  tp = & cached_time[slot];
  }
#line 100
  if (tp->sec == sec) {
#line 101
    tp->msec = msec;
#line 102
    ngx_time_lock = (ngx_atomic_t )0;
#line 103
    return;
  }
#line 106
  if (slot == 63UL) {
#line 107
    slot = (ngx_uint_t )0;
  } else {
#line 109
    slot ++;
  }
  {
#line 112
  tp = & cached_time[slot];
#line 114
  tp->sec = sec;
#line 115
  tp->msec = msec;
#line 117
  ngx_gmtime(sec, & gmt);
#line 120
  p0 = & cached_http_time[slot][0];
#line 122
  ngx_sprintf(p0, "%s, %02d %s %4d %02d:%02d:%02d GMT", week[gmt.tm_wday], gmt.tm_mday,
              months___0[gmt.tm_mon - 1], gmt.tm_year, gmt.tm_hour, gmt.tm_min, gmt.tm_sec);
#line 134
  ngx_localtime(sec, & tm);
#line 135
  cached_gmtoff = tm.tm_gmtoff / 60L;
#line 136
  tp->gmtoff = cached_gmtoff;
#line 147
  p1 = & cached_err_log_time[slot][0];
#line 149
  ngx_sprintf(p1, "%4d/%02d/%02d %02d:%02d:%02d", tm.tm_year, tm.tm_mon, tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 155
  p2 = & cached_http_log_time[slot][0];
  }
#line 157
  if (tp->gmtoff % 60L >= 0L) {
#line 157
    tmp___0 = tp->gmtoff % 60L;
  } else {
#line 157
    tmp___0 = - (tp->gmtoff % 60L);
  }
#line 157
  if (tp->gmtoff / 60L >= 0L) {
#line 157
    tmp___1 = tp->gmtoff / 60L;
  } else {
#line 157
    tmp___1 = - (tp->gmtoff / 60L);
  }
#line 157
  if (tp->gmtoff < 0L) {
#line 157
    tmp___2 = '-';
  } else {
#line 157
    tmp___2 = '+';
  }
  {
#line 157
  ngx_sprintf(p2, "%02d/%s/%d:%02d:%02d:%02d %c%02i%02i", tm.tm_mday, months___0[tm.tm_mon - 1],
              tm.tm_year, tm.tm_hour, tm.tm_min, tm.tm_sec, tmp___2, tmp___1, tmp___0);
#line 164
  p3 = & cached_http_log_iso8601[slot][0];
  }
#line 166
  if (tp->gmtoff % 60L >= 0L) {
#line 166
    tmp___3 = tp->gmtoff % 60L;
  } else {
#line 166
    tmp___3 = - (tp->gmtoff % 60L);
  }
#line 166
  if (tp->gmtoff / 60L >= 0L) {
#line 166
    tmp___4 = tp->gmtoff / 60L;
  } else {
#line 166
    tmp___4 = - (tp->gmtoff / 60L);
  }
#line 166
  if (tp->gmtoff < 0L) {
#line 166
    tmp___5 = '-';
  } else {
#line 166
    tmp___5 = '+';
  }
  {
#line 166
  ngx_sprintf(p3, "%4d-%02d-%02dT%02d:%02d:%02d%c%02i:%02i", tm.tm_year, tm.tm_mon,
              tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, tmp___5, tmp___4, tmp___3);
#line 173
  p4 = & cached_syslog_time[slot][0];
#line 175
  ngx_sprintf(p4, "%s %2d %02d:%02d:%02d", months___0[tm.tm_mon - 1], tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 179
  __sync_synchronize();
#line 181
  ngx_cached_time = (ngx_time_t volatile   *)tp;
#line 182
  ngx_cached_http_time.data = (u_char */* volatile  */)p0;
#line 183
  ngx_cached_err_log_time.data = (u_char */* volatile  */)p1;
#line 184
  ngx_cached_http_log_time.data = (u_char */* volatile  */)p2;
#line 185
  ngx_cached_http_log_iso8601.data = (u_char */* volatile  */)p3;
#line 186
  ngx_cached_syslog_time.data = (u_char */* volatile  */)p4;
#line 188
  ngx_time_lock = (ngx_atomic_t )0;
  }
#line 189
  return;
}
}
#line 194 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
void ngx_time_sigsafe_update(void) 
{ 
  u_char *p ;
  u_char *p2 ;
  ngx_tm_t tm ;
  time_t sec ;
  ngx_time_t *tp ;
  struct timeval tv ;
  _Bool tmp ;

  {
#line 203
  if (ngx_time_lock == (ngx_atomic_t )0) {
    {
#line 203
    tmp = __sync_bool_compare_and_swap(& ngx_time_lock, 0, 1);
    }
#line 203
    if (! tmp) {
#line 204
      return;
    }
  } else {
#line 204
    return;
  }
  {
#line 207
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 209
  sec = tv.tv_sec;
#line 211
  tp = & cached_time[slot];
  }
#line 213
  if (tp->sec == sec) {
#line 214
    ngx_time_lock = (ngx_atomic_t )0;
#line 215
    return;
  }
#line 218
  if (slot == 63UL) {
#line 219
    slot = (ngx_uint_t )0;
  } else {
#line 221
    slot ++;
  }
  {
#line 224
  tp = & cached_time[slot];
#line 226
  tp->sec = (time_t )0;
#line 228
  ngx_gmtime(sec + cached_gmtoff * 60L, & tm);
#line 230
  p = & cached_err_log_time[slot][0];
#line 232
  ngx_sprintf(p, "%4d/%02d/%02d %02d:%02d:%02d", tm.tm_year, tm.tm_mon, tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 237
  p2 = & cached_syslog_time[slot][0];
#line 239
  ngx_sprintf(p2, "%s %2d %02d:%02d:%02d", months___0[tm.tm_mon - 1], tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 243
  __sync_synchronize();
#line 245
  ngx_cached_err_log_time.data = (u_char */* volatile  */)p;
#line 246
  ngx_cached_syslog_time.data = (u_char */* volatile  */)p2;
#line 248
  ngx_time_lock = (ngx_atomic_t )0;
  }
#line 249
  return;
}
}
#line 254 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
u_char *ngx_http_time(u_char *buf , time_t t ) 
{ 
  ngx_tm_t tm ;
  u_char *tmp ;

  {
  {
#line 259
  ngx_gmtime(t, & tm);
#line 261
  tmp = ngx_sprintf(buf, "%s, %02d %s %4d %02d:%02d:%02d GMT", week[tm.tm_wday], tm.tm_mday,
                    months___0[tm.tm_mon - 1], tm.tm_year, tm.tm_hour, tm.tm_min,
                    tm.tm_sec);
  }
#line 261
  return (tmp);
}
}
#line 272 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
u_char *ngx_http_cookie_time(u_char *buf , time_t t ) 
{ 
  ngx_tm_t tm ;
  int tmp ;
  char const   *tmp___0 ;
  u_char *tmp___1 ;

  {
  {
#line 277
  ngx_gmtime(t, & tm);
  }
#line 284
  if (tm.tm_year > 2037) {
#line 284
    tmp = tm.tm_year;
  } else {
#line 284
    tmp = tm.tm_year % 100;
  }
#line 284
  if (tm.tm_year > 2037) {
#line 284
    tmp___0 = "%s, %02d-%s-%d %02d:%02d:%02d GMT";
  } else {
#line 284
    tmp___0 = "%s, %02d-%s-%02d %02d:%02d:%02d GMT";
  }
  {
#line 284
  tmp___1 = ngx_sprintf(buf, tmp___0, week[tm.tm_wday], tm.tm_mday, months___0[tm.tm_mon - 1],
                        tmp, tm.tm_hour, tm.tm_min, tm.tm_sec);
  }
#line 284
  return (tmp___1);
}
}
#line 299 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
void ngx_gmtime(time_t t , ngx_tm_t *tp ) 
{ 
  ngx_int_t yday ;
  ngx_uint_t n ;
  ngx_uint_t sec ;
  ngx_uint_t min ;
  ngx_uint_t hour ;
  ngx_uint_t mday___0 ;
  ngx_uint_t mon ;
  ngx_uint_t year ;
  ngx_uint_t wday ;
  ngx_uint_t days ;
  ngx_uint_t leap ;
  int tmp ;

  {
#line 307
  n = (ngx_uint_t )t;
#line 309
  days = n / 86400UL;
#line 313
  wday = (4UL + days) % 7UL;
#line 315
  n %= 86400UL;
#line 316
  hour = n / 3600UL;
#line 317
  n %= 3600UL;
#line 318
  min = n / 60UL;
#line 319
  sec = n % 60UL;
#line 327
  days = (days - 59UL) + 719527UL;
#line 336
  year = ((days + 2UL) * 400UL) / 146097UL;
#line 338
  yday = (ngx_int_t )(days - (((365UL * year + year / 4UL) - year / 100UL) + year / 400UL));
#line 340
  if (yday < 0L) {
#line 341
    if (year % 4UL == 0UL) {
#line 341
      if (year % 100UL) {
#line 341
        tmp = 1;
      } else
#line 341
      if (year % 400UL == 0UL) {
#line 341
        tmp = 1;
      } else {
#line 341
        tmp = 0;
      }
    } else {
#line 341
      tmp = 0;
    }
#line 341
    leap = (ngx_uint_t )tmp;
#line 342
    yday = (ngx_int_t )((365UL + leap) + (ngx_uint_t )yday);
#line 343
    year --;
  }
#line 354
  mon = (ngx_uint_t )(((yday + 31L) * 10L) / 306L);
#line 358
  mday___0 = ((ngx_uint_t )yday - ((367UL * mon) / 12UL - 30UL)) + 1UL;
#line 360
  if (yday >= 306L) {
#line 362
    year ++;
#line 363
    mon -= 10UL;
  } else {
#line 373
    mon += 2UL;
  }
#line 382
  tp->tm_sec = (int )sec;
#line 383
  tp->tm_min = (int )min;
#line 384
  tp->tm_hour = (int )hour;
#line 385
  tp->tm_mday = (int )mday___0;
#line 386
  tp->tm_mon = (int )mon;
#line 387
  tp->tm_year = (int )year;
#line 388
  tp->tm_wday = (int )wday;
#line 389
  return;
}
}
#line 392 "/tmp/nginx-1.13.2/src/core/ngx_times.c"
time_t ngx_next_time(time_t when ) 
{ 
  time_t now ;
  time_t next ;
  struct tm tm ;

  {
  {
#line 398
  now = (time_t )ngx_cached_time->sec;
#line 400
  ngx_libc_localtime(now, & tm);
#line 402
  tm.tm_hour = (int )(when / 3600L);
#line 403
  when %= 3600L;
#line 404
  tm.tm_min = (int )(when / 60L);
#line 405
  tm.tm_sec = (int )(when % 60L);
#line 407
  next = mktime(& tm);
  }
#line 409
  if (next == -1L) {
#line 410
    return ((time_t )-1);
  }
#line 413
  if (next - now > 0L) {
#line 414
    return (next);
  }
  {
#line 417
  (tm.tm_mday) ++;
#line 421
  next = mktime(& tm);
  }
#line 423
  if (next != -1L) {
#line 424
    return (next);
  }
#line 427
  return ((time_t )-1);
}
}
#line 65 "src/core/ngx_slab.h"
void *ngx_slab_calloc(ngx_slab_pool_t *pool , size_t___0 size ) ;
#line 67
void ngx_slab_free(ngx_slab_pool_t *pool , void *p ) ;
#line 72 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
static ngx_slab_page_t *ngx_slab_alloc_pages(ngx_slab_pool_t *pool , ngx_uint_t pages ) ;
#line 74
static void ngx_slab_free_pages(ngx_slab_pool_t *pool , ngx_slab_page_t *page , ngx_uint_t pages ) ;
#line 76
static void ngx_slab_error(ngx_slab_pool_t *pool , ngx_uint_t level , char *text ) ;
#line 80 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
static ngx_uint_t ngx_slab_max_size  ;
#line 81 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
static ngx_uint_t ngx_slab_exact_size  ;
#line 82 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
static ngx_uint_t ngx_slab_exact_shift  ;
#line 85 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
void ngx_slab_init(ngx_slab_pool_t *pool ) 
{ 
  u_char *p ;
  size_t___0 size ;
  ngx_int_t m ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t pages ;
  ngx_slab_page_t *slots ;
  ngx_slab_page_t *page ;

  {
#line 95
  if (ngx_slab_max_size == 0UL) {
#line 96
    ngx_slab_max_size = ngx_pagesize / 2UL;
#line 97
    ngx_slab_exact_size = ngx_pagesize / (8UL * sizeof(uintptr_t ));
#line 98
    n = ngx_slab_exact_size;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      n >>= 1;
#line 98
      if (! n) {
#line 98
        goto while_break;
      }
#line 98
      ngx_slab_exact_shift ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 104
  pool->min_size = 1UL << pool->min_shift;
#line 106
  slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 108
  p = (u_char *)slots;
#line 109
  size = (size_t___0 )(pool->end - p);
#line 113
  n = ngx_pagesize_shift - pool->min_shift;
#line 115
  i = (ngx_uint_t )0;
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 115
    if (! (i < n)) {
#line 115
      goto while_break___0;
    }
#line 117
    (slots + i)->slab = (uintptr_t )0;
#line 118
    (slots + i)->next = slots + i;
#line 119
    (slots + i)->prev = (uintptr_t )0;
#line 115
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 122
  p += n * sizeof(ngx_slab_page_t );
#line 124
  pool->stats = (ngx_slab_stat_t *)p;
#line 125
  memset((void *)pool->stats, 0, n * sizeof(ngx_slab_stat_t ));
#line 127
  p += n * sizeof(ngx_slab_stat_t );
#line 129
  size -= n * (sizeof(ngx_slab_page_t ) + sizeof(ngx_slab_stat_t ));
#line 131
  pages = size / (ngx_pagesize + sizeof(ngx_slab_page_t ));
#line 133
  pool->pages = (ngx_slab_page_t *)p;
#line 134
  memset((void *)pool->pages, 0, pages * sizeof(ngx_slab_page_t ));
#line 136
  page = pool->pages;
#line 139
  pool->free.slab = (uintptr_t )0;
#line 140
  pool->free.next = page;
#line 141
  pool->free.prev = (uintptr_t )0;
#line 143
  page->slab = pages;
#line 144
  page->next = & pool->free;
#line 145
  page->prev = (uintptr_t )(& pool->free);
#line 147
  pool->start = (u_char *)(((uintptr_t )(p + pages * sizeof(ngx_slab_page_t )) + (ngx_pagesize - 1UL)) & ~ (ngx_pagesize - 1UL));
#line 150
  m = (ngx_int_t )(pages - (ngx_uint_t )(pool->end - pool->start) / ngx_pagesize);
  }
#line 151
  if (m > 0L) {
#line 152
    pages -= (ngx_uint_t )m;
#line 153
    page->slab = pages;
  }
#line 156
  pool->last = pool->pages + pages;
#line 157
  pool->pfree = pages;
#line 159
  pool->log_nomem = 1U;
#line 160
  pool->log_ctx = & pool->zero;
#line 161
  pool->zero = (u_char )'\000';
#line 162
  return;
}
}
#line 165 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
void *ngx_slab_alloc(ngx_slab_pool_t *pool , size_t___0 size ) 
{ 
  void *p ;

  {
  {
#line 170
  ngx_shmtx_lock(& pool->mutex);
#line 172
  p = ngx_slab_alloc_locked(pool, size);
#line 174
  ngx_shmtx_unlock(& pool->mutex);
  }
#line 176
  return (p);
}
}
#line 180 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool , size_t___0 size ) 
{ 
  size_t___0 s ;
  uintptr_t p ;
  uintptr_t n ;
  uintptr_t m ;
  uintptr_t mask ;
  uintptr_t *bitmap ;
  ngx_uint_t i ;
  ngx_uint_t slot___0 ;
  ngx_uint_t shift ;
  ngx_uint_t map___0 ;
  ngx_slab_page_t *page ;
  ngx_slab_page_t *prev ;
  ngx_slab_page_t *slots ;
  int tmp ;

  {
#line 188
  if (size > ngx_slab_max_size) {
#line 193
    if (size % ngx_pagesize) {
#line 193
      tmp = 1;
    } else {
#line 193
      tmp = 0;
    }
    {
#line 193
    page = ngx_slab_alloc_pages(pool, (size >> ngx_pagesize_shift) + (size_t___0 )tmp);
    }
#line 195
    if (page) {
#line 196
      p = (uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start;
    } else {
#line 199
      p = (uintptr_t )0;
    }
#line 202
    goto done;
  }
#line 205
  if (size > pool->min_size) {
#line 206
    shift = (ngx_uint_t )1;
#line 207
    s = size - 1UL;
    {
#line 207
    while (1) {
      while_continue: /* CIL Label */ ;
#line 207
      s >>= 1;
#line 207
      if (! s) {
#line 207
        goto while_break;
      }
#line 207
      shift ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 208
    slot___0 = shift - pool->min_shift;
  } else {
#line 211
    shift = pool->min_shift;
#line 212
    slot___0 = (ngx_uint_t )0;
  }
#line 215
  ((pool->stats + slot___0)->reqs) ++;
#line 220
  slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 221
  page = (slots + slot___0)->next;
#line 223
  if ((unsigned long )page->next != (unsigned long )page) {
#line 225
    if (shift < ngx_slab_exact_shift) {
#line 227
      bitmap = (uintptr_t *)((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start);
#line 229
      map___0 = (ngx_pagesize >> shift) / (sizeof(uintptr_t ) * 8UL);
#line 231
      n = (uintptr_t )0;
      {
#line 231
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 231
        if (! (n < map___0)) {
#line 231
          goto while_break___0;
        }
#line 233
        if (*(bitmap + n) != 0xffffffffffffffffUL) {
#line 235
          m = (uintptr_t )1;
#line 235
          i = (ngx_uint_t )0;
          {
#line 235
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 235
            if (! m) {
#line 235
              goto while_break___1;
            }
#line 236
            if (*(bitmap + n) & m) {
#line 237
              goto __Cont;
            }
#line 240
            *(bitmap + n) |= m;
#line 242
            i = ((n * sizeof(uintptr_t )) * 8UL + i) << shift;
#line 244
            p = (uintptr_t )bitmap + i;
#line 246
            ((pool->stats + slot___0)->used) ++;
#line 248
            if (*(bitmap + n) == 0xffffffffffffffffUL) {
#line 249
              n ++;
              {
#line 249
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 249
                if (! (n < map___0)) {
#line 249
                  goto while_break___2;
                }
#line 250
                if (*(bitmap + n) != 0xffffffffffffffffUL) {
#line 251
                  goto done;
                }
#line 249
                n ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 255
              prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 256
              prev->next = page->next;
#line 257
              (page->next)->prev = page->prev;
#line 259
              page->next = (ngx_slab_page_t *)((void *)0);
#line 260
              page->prev = (uintptr_t )3;
            }
#line 263
            goto done;
            __Cont: /* CIL Label */ 
#line 235
            m <<= 1;
#line 235
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 231
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 268
    if (shift == ngx_slab_exact_shift) {
#line 270
      m = (uintptr_t )1;
#line 270
      i = (ngx_uint_t )0;
      {
#line 270
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 270
        if (! m) {
#line 270
          goto while_break___3;
        }
#line 271
        if (page->slab & m) {
#line 272
          goto __Cont___0;
        }
#line 275
        page->slab |= m;
#line 277
        if (page->slab == 0xffffffffffffffffUL) {
#line 278
          prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 279
          prev->next = page->next;
#line 280
          (page->next)->prev = page->prev;
#line 282
          page->next = (ngx_slab_page_t *)((void *)0);
#line 283
          page->prev = (uintptr_t )2;
        }
#line 286
        p = ((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start) + (i << shift);
#line 288
        ((pool->stats + slot___0)->used) ++;
#line 290
        goto done;
        __Cont___0: /* CIL Label */ 
#line 270
        m <<= 1;
#line 270
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 295
      mask = (1UL << (ngx_pagesize >> shift)) - 1UL;
#line 296
      mask <<= 32;
#line 298
      m = 1UL << 32;
#line 298
      i = (ngx_uint_t )0;
      {
#line 298
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 298
        if (! (m & mask)) {
#line 298
          goto while_break___4;
        }
#line 302
        if (page->slab & m) {
#line 303
          goto __Cont___1;
        }
#line 306
        page->slab |= m;
#line 308
        if ((page->slab & 0xffffffff00000000UL) == mask) {
#line 309
          prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 310
          prev->next = page->next;
#line 311
          (page->next)->prev = page->prev;
#line 313
          page->next = (ngx_slab_page_t *)((void *)0);
#line 314
          page->prev = (uintptr_t )1;
        }
#line 317
        p = ((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start) + (i << shift);
#line 319
        ((pool->stats + slot___0)->used) ++;
#line 321
        goto done;
        __Cont___1: /* CIL Label */ 
#line 298
        m <<= 1;
#line 298
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 325
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_alloc(): page is busy");
#line 326
    ngx_debug_point();
    }
  }
  {
#line 329
  page = ngx_slab_alloc_pages(pool, (ngx_uint_t )1);
  }
#line 331
  if (page) {
#line 332
    if (shift < ngx_slab_exact_shift) {
#line 333
      bitmap = (uintptr_t *)((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start);
#line 335
      n = (ngx_pagesize >> shift) / (ngx_uint_t )((1 << shift) * 8);
#line 337
      if (n == 0UL) {
#line 338
        n = (uintptr_t )1;
      }
#line 342
      *(bitmap + 0) = (2UL << n) - 1UL;
#line 344
      map___0 = (ngx_pagesize >> shift) / (sizeof(uintptr_t ) * 8UL);
#line 346
      i = (ngx_uint_t )1;
      {
#line 346
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 346
        if (! (i < map___0)) {
#line 346
          goto while_break___5;
        }
#line 347
        *(bitmap + i) = (uintptr_t )0;
#line 346
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 350
      page->slab = shift;
#line 351
      page->next = slots + slot___0;
#line 352
      page->prev = (uintptr_t )(slots + slot___0) | 3UL;
#line 354
      (slots + slot___0)->next = page;
#line 356
      (pool->stats + slot___0)->total += (ngx_pagesize >> shift) - n;
#line 358
      p = ((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start) + (n << shift);
#line 360
      ((pool->stats + slot___0)->used) ++;
#line 362
      goto done;
    } else
#line 364
    if (shift == ngx_slab_exact_shift) {
#line 366
      page->slab = (uintptr_t )1;
#line 367
      page->next = slots + slot___0;
#line 368
      page->prev = (uintptr_t )(slots + slot___0) | 2UL;
#line 370
      (slots + slot___0)->next = page;
#line 372
      (pool->stats + slot___0)->total += sizeof(uintptr_t ) * 8UL;
#line 374
      p = (uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start;
#line 376
      ((pool->stats + slot___0)->used) ++;
#line 378
      goto done;
    } else {
#line 382
      page->slab = (1UL << 32) | shift;
#line 383
      page->next = slots + slot___0;
#line 384
      page->prev = (uintptr_t )(slots + slot___0) | 1UL;
#line 386
      (slots + slot___0)->next = page;
#line 388
      (pool->stats + slot___0)->total += ngx_pagesize >> shift;
#line 390
      p = (uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start;
#line 392
      ((pool->stats + slot___0)->used) ++;
#line 394
      goto done;
    }
  }
#line 398
  p = (uintptr_t )0;
#line 400
  ((pool->stats + slot___0)->fails) ++;
  done: ;
#line 407
  return ((void *)p);
}
}
#line 411 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
void *ngx_slab_calloc(ngx_slab_pool_t *pool , size_t___0 size ) 
{ 
  void *p ;

  {
  {
#line 416
  ngx_shmtx_lock(& pool->mutex);
#line 418
  p = ngx_slab_calloc_locked(pool, size);
#line 420
  ngx_shmtx_unlock(& pool->mutex);
  }
#line 422
  return (p);
}
}
#line 426 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
void *ngx_slab_calloc_locked(ngx_slab_pool_t *pool , size_t___0 size ) 
{ 
  void *p ;

  {
  {
#line 431
  p = ngx_slab_alloc_locked(pool, size);
  }
#line 432
  if (p) {
    {
#line 433
    memset(p, 0, size);
    }
  }
#line 436
  return (p);
}
}
#line 440 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
void ngx_slab_free(ngx_slab_pool_t *pool , void *p ) 
{ 


  {
  {
#line 443
  ngx_shmtx_lock(& pool->mutex);
#line 445
  ngx_slab_free_locked(pool, p);
#line 447
  ngx_shmtx_unlock(& pool->mutex);
  }
#line 448
  return;
}
}
#line 451 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
void ngx_slab_free_locked(ngx_slab_pool_t *pool , void *p ) 
{ 
  size_t___0 size ;
  uintptr_t slab ;
  uintptr_t m ;
  uintptr_t *bitmap ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t type ;
  ngx_uint_t slot___0 ;
  ngx_uint_t shift ;
  ngx_uint_t map___0 ;
  ngx_slab_page_t *slots ;
  ngx_slab_page_t *page ;

  {
#line 461
  if ((unsigned long )((u_char *)p) < (unsigned long )pool->start) {
    {
#line 462
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): outside of pool");
    }
#line 463
    goto fail;
  } else
#line 461
  if ((unsigned long )((u_char *)p) > (unsigned long )pool->end) {
    {
#line 462
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): outside of pool");
    }
#line 463
    goto fail;
  }
#line 466
  n = (ngx_uint_t )(((u_char *)p - pool->start) >> ngx_pagesize_shift);
#line 467
  page = pool->pages + n;
#line 468
  slab = page->slab;
#line 469
  type = page->prev & 3UL;
  {
#line 473
  if (type == 3UL) {
#line 473
    goto case_3;
  }
#line 530
  if (type == 2UL) {
#line 530
    goto case_2;
  }
#line 568
  if (type == 1UL) {
#line 568
    goto case_1;
  }
#line 608
  if (type == 0UL) {
#line 608
    goto case_0;
  }
#line 471
  goto switch_break;
  case_3: /* CIL Label */ 
#line 475
  shift = slab & 15UL;
#line 476
  size = 1UL << shift;
#line 478
  if ((uintptr_t )p & (size - 1UL)) {
#line 479
    goto wrong_chunk;
  }
#line 482
  n = ((uintptr_t )p & (ngx_pagesize - 1UL)) >> shift;
#line 483
  m = 1UL << n % (sizeof(uintptr_t ) * 8UL);
#line 484
  n /= sizeof(uintptr_t ) * 8UL;
#line 485
  bitmap = (uintptr_t *)((uintptr_t )p & ~ (ngx_pagesize - 1UL));
#line 488
  if (*(bitmap + n) & m) {
#line 489
    slot___0 = shift - pool->min_shift;
#line 491
    if ((unsigned long )page->next == (unsigned long )((void *)0)) {
#line 492
      slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 494
      page->next = (slots + slot___0)->next;
#line 495
      (slots + slot___0)->next = page;
#line 497
      page->prev = (uintptr_t )(slots + slot___0) | 3UL;
#line 498
      (page->next)->prev = (uintptr_t )page | 3UL;
    }
#line 501
    *(bitmap + n) &= ~ m;
#line 503
    n = (ngx_pagesize >> shift) / (ngx_uint_t )((1 << shift) * 8);
#line 505
    if (n == 0UL) {
#line 506
      n = (ngx_uint_t )1;
    }
#line 509
    if (*(bitmap + 0) & ~ ((1UL << n) - 1UL)) {
#line 510
      goto done;
    }
#line 513
    map___0 = (ngx_pagesize >> shift) / (sizeof(uintptr_t ) * 8UL);
#line 515
    i = (ngx_uint_t )1;
    {
#line 515
    while (1) {
      while_continue: /* CIL Label */ ;
#line 515
      if (! (i < map___0)) {
#line 515
        goto while_break;
      }
#line 516
      if (*(bitmap + i)) {
#line 517
        goto done;
      }
#line 515
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 521
    ngx_slab_free_pages(pool, page, (ngx_uint_t )1);
#line 523
    (pool->stats + slot___0)->total -= (ngx_pagesize >> shift) - n;
    }
#line 525
    goto done;
  }
#line 528
  goto chunk_already_free;
  case_2: /* CIL Label */ 
#line 532
  m = 1UL << (((uintptr_t )p & (ngx_pagesize - 1UL)) >> ngx_slab_exact_shift);
#line 534
  size = ngx_slab_exact_size;
#line 536
  if ((uintptr_t )p & (size - 1UL)) {
#line 537
    goto wrong_chunk;
  }
#line 540
  if (slab & m) {
#line 541
    slot___0 = ngx_slab_exact_shift - pool->min_shift;
#line 543
    if (slab == 0xffffffffffffffffUL) {
#line 544
      slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 546
      page->next = (slots + slot___0)->next;
#line 547
      (slots + slot___0)->next = page;
#line 549
      page->prev = (uintptr_t )(slots + slot___0) | 2UL;
#line 550
      (page->next)->prev = (uintptr_t )page | 2UL;
    }
#line 553
    page->slab &= ~ m;
#line 555
    if (page->slab) {
#line 556
      goto done;
    }
    {
#line 559
    ngx_slab_free_pages(pool, page, (ngx_uint_t )1);
#line 561
    (pool->stats + slot___0)->total -= sizeof(uintptr_t ) * 8UL;
    }
#line 563
    goto done;
  }
#line 566
  goto chunk_already_free;
  case_1: /* CIL Label */ 
#line 570
  shift = slab & 15UL;
#line 571
  size = 1UL << shift;
#line 573
  if ((uintptr_t )p & (size - 1UL)) {
#line 574
    goto wrong_chunk;
  }
#line 577
  m = 1UL << ((((uintptr_t )p & (ngx_pagesize - 1UL)) >> shift) + 32UL);
#line 580
  if (slab & m) {
#line 581
    slot___0 = shift - pool->min_shift;
#line 583
    if ((unsigned long )page->next == (unsigned long )((void *)0)) {
#line 584
      slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 586
      page->next = (slots + slot___0)->next;
#line 587
      (slots + slot___0)->next = page;
#line 589
      page->prev = (uintptr_t )(slots + slot___0) | 1UL;
#line 590
      (page->next)->prev = (uintptr_t )page | 1UL;
    }
#line 593
    page->slab &= ~ m;
#line 595
    if (page->slab & 0xffffffff00000000UL) {
#line 596
      goto done;
    }
    {
#line 599
    ngx_slab_free_pages(pool, page, (ngx_uint_t )1);
#line 601
    (pool->stats + slot___0)->total -= ngx_pagesize >> shift;
    }
#line 603
    goto done;
  }
#line 606
  goto chunk_already_free;
  case_0: /* CIL Label */ 
#line 610
  if ((uintptr_t )p & (ngx_pagesize - 1UL)) {
#line 611
    goto wrong_chunk;
  }
#line 614
  if (! (slab & 0x8000000000000000UL)) {
    {
#line 615
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): page is already free");
    }
#line 617
    goto fail;
  }
#line 620
  if (slab == 0xffffffffffffffffUL) {
    {
#line 621
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): pointer to wrong page");
    }
#line 623
    goto fail;
  }
  {
#line 626
  n = (ngx_uint_t )(((u_char *)p - pool->start) >> ngx_pagesize_shift);
#line 627
  size = slab & 9223372036854775807UL;
#line 629
  ngx_slab_free_pages(pool, pool->pages + n, size);
  }
#line 633
  return;
  switch_break: /* CIL Label */ ;
  }
#line 638
  return;
  done: 
#line 642
  ((pool->stats + slot___0)->used) --;
#line 646
  return;
  wrong_chunk: 
  {
#line 650
  ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): pointer to wrong chunk");
  }
#line 653
  goto fail;
  chunk_already_free: 
  {
#line 657
  ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): chunk is already free");
  }
  fail: 
#line 662
  return;
}
}
#line 666 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
static ngx_slab_page_t *ngx_slab_alloc_pages(ngx_slab_pool_t *pool , ngx_uint_t pages ) 
{ 
  ngx_slab_page_t *page ;
  ngx_slab_page_t *p ;

  {
#line 671
  page = pool->free.next;
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! ((unsigned long )page != (unsigned long )(& pool->free))) {
#line 671
      goto while_break;
    }
#line 673
    if (page->slab >= pages) {
#line 675
      if (page->slab > pages) {
#line 676
        (page + (page->slab - 1UL))->prev = (uintptr_t )(page + pages);
#line 678
        (page + pages)->slab = page->slab - pages;
#line 679
        (page + pages)->next = page->next;
#line 680
        (page + pages)->prev = page->prev;
#line 682
        p = (ngx_slab_page_t *)page->prev;
#line 683
        p->next = page + pages;
#line 684
        (page->next)->prev = (uintptr_t )(page + pages);
      } else {
#line 687
        p = (ngx_slab_page_t *)page->prev;
#line 688
        p->next = page->next;
#line 689
        (page->next)->prev = page->prev;
      }
#line 692
      page->slab = pages | 0x8000000000000000UL;
#line 693
      page->next = (ngx_slab_page_t *)((void *)0);
#line 694
      page->prev = (uintptr_t )0;
#line 696
      pool->pfree -= pages;
#line 698
      pages --;
#line 698
      if (pages == 0UL) {
#line 699
        return (page);
      }
#line 702
      p = page + 1;
      {
#line 702
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 702
        if (! pages) {
#line 702
          goto while_break___0;
        }
#line 703
        p->slab = 0xffffffffffffffffUL;
#line 704
        p->next = (ngx_slab_page_t *)((void *)0);
#line 705
        p->prev = (uintptr_t )0;
#line 706
        p ++;
#line 702
        pages --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 709
      return (page);
    }
#line 671
    page = page->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 713
  if (pool->log_nomem) {
    {
#line 714
    ngx_slab_error(pool, (ngx_uint_t )3, (char *)"ngx_slab_alloc() failed: no memory");
    }
  }
#line 718
  return ((ngx_slab_page_t *)((void *)0));
}
}
#line 722 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
static void ngx_slab_free_pages(ngx_slab_pool_t *pool , ngx_slab_page_t *page , ngx_uint_t pages ) 
{ 
  ngx_slab_page_t *prev ;
  ngx_slab_page_t *join ;
  ngx_uint_t tmp ;

  {
#line 728
  pool->pfree += pages;
#line 730
  tmp = pages;
#line 730
  pages --;
#line 730
  page->slab = tmp;
#line 732
  if (pages) {
    {
#line 733
    memset((void *)(page + 1), 0, pages * sizeof(ngx_slab_page_t ));
    }
  }
#line 736
  if (page->next) {
#line 737
    prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 738
    prev->next = page->next;
#line 739
    (page->next)->prev = page->prev;
  }
#line 742
  join = page + page->slab;
#line 744
  if ((unsigned long )join < (unsigned long )pool->last) {
#line 746
    if ((join->prev & 3UL) == 0UL) {
#line 748
      if ((unsigned long )join->next != (unsigned long )((void *)0)) {
#line 749
        pages += join->slab;
#line 750
        page->slab += join->slab;
#line 752
        prev = (ngx_slab_page_t *)(join->prev & 0xfffffffffffffffcUL);
#line 753
        prev->next = join->next;
#line 754
        (join->next)->prev = join->prev;
#line 756
        join->slab = (uintptr_t )0;
#line 757
        join->next = (ngx_slab_page_t *)((void *)0);
#line 758
        join->prev = (uintptr_t )0;
      }
    }
  }
#line 763
  if ((unsigned long )page > (unsigned long )pool->pages) {
#line 764
    join = page - 1;
#line 766
    if ((join->prev & 3UL) == 0UL) {
#line 768
      if (join->slab == 0UL) {
#line 769
        join = (ngx_slab_page_t *)(join->prev & 0xfffffffffffffffcUL);
      }
#line 772
      if ((unsigned long )join->next != (unsigned long )((void *)0)) {
#line 773
        pages += join->slab;
#line 774
        join->slab += page->slab;
#line 776
        prev = (ngx_slab_page_t *)(join->prev & 0xfffffffffffffffcUL);
#line 777
        prev->next = join->next;
#line 778
        (join->next)->prev = join->prev;
#line 780
        page->slab = (uintptr_t )0;
#line 781
        page->next = (ngx_slab_page_t *)((void *)0);
#line 782
        page->prev = (uintptr_t )0;
#line 784
        page = join;
      }
    }
  }
#line 789
  if (pages) {
#line 790
    (page + pages)->prev = (uintptr_t )page;
  }
#line 793
  page->prev = (uintptr_t )(& pool->free);
#line 794
  page->next = pool->free.next;
#line 796
  (page->next)->prev = (uintptr_t )page;
#line 798
  pool->free.next = page;
#line 799
  return;
}
}
#line 802 "/tmp/nginx-1.13.2/src/core/ngx_slab.c"
static void ngx_slab_error(ngx_slab_pool_t *pool , ngx_uint_t level , char *text ) 
{ 


  {
#line 805
  if ((ngx_cycle->log)->log_level >= level) {
    {
#line 805
    ngx_log_error_core(level, (ngx_log_t *)ngx_cycle->log, 0, "%s%s", text, pool->log_ctx);
    }
  }
#line 806
  return;
}
}
#line 82 "src/core/ngx_palloc.h"
void *ngx_pmemalign(ngx_pool_t *pool , size_t___0 size , size_t___0 alignment ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
static ngx_radix_node_t *ngx_radix_alloc(ngx_radix_tree_t *tree ) ;
#line 15 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
ngx_radix_tree_t *ngx_radix_tree_create(ngx_pool_t *pool , ngx_int_t preallocate ) 
{ 
  uint32_t key ;
  uint32_t mask ;
  uint32_t inc___0 ;
  ngx_radix_tree_t *tree ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 21
  tmp = ngx_palloc(pool, sizeof(ngx_radix_tree_t ));
#line 21
  tree = (ngx_radix_tree_t *)tmp;
  }
#line 22
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 23
    return ((ngx_radix_tree_t *)((void *)0));
  }
  {
#line 26
  tree->pool = pool;
#line 27
  tree->free = (ngx_radix_node_t *)((void *)0);
#line 28
  tree->start = (char *)((void *)0);
#line 29
  tree->size = (size_t___0 )0;
#line 31
  tree->root = ngx_radix_alloc(tree);
  }
#line 32
  if ((unsigned long )tree->root == (unsigned long )((void *)0)) {
#line 33
    return ((ngx_radix_tree_t *)((void *)0));
  }
#line 36
  (tree->root)->right = (ngx_radix_node_t *)((void *)0);
#line 37
  (tree->root)->left = (ngx_radix_node_t *)((void *)0);
#line 38
  (tree->root)->parent = (ngx_radix_node_t *)((void *)0);
#line 39
  (tree->root)->value = (uintptr_t )-1;
#line 41
  if (preallocate == 0L) {
#line 42
    return (tree);
  }
#line 62
  if (preallocate == -1L) {
    {
#line 66
    if (ngx_pagesize / sizeof(ngx_radix_node_t ) == 128UL) {
#line 66
      goto case_128;
    }
#line 71
    if (ngx_pagesize / sizeof(ngx_radix_node_t ) == 256UL) {
#line 71
      goto case_256;
    }
#line 76
    goto switch_default;
    case_128: /* CIL Label */ 
#line 67
    preallocate = (ngx_int_t )6;
#line 68
    goto switch_break;
    case_256: /* CIL Label */ 
#line 72
    preallocate = (ngx_int_t )7;
#line 73
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 77
    preallocate = (ngx_int_t )8;
    switch_break: /* CIL Label */ ;
    }
  }
#line 81
  mask = (uint32_t )0;
#line 82
  inc___0 = 2147483648U;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    tmp___1 = preallocate;
#line 84
    preallocate --;
#line 84
    if (! tmp___1) {
#line 84
      goto while_break;
    }
#line 86
    key = (uint32_t )0;
#line 87
    mask >>= 1;
#line 88
    mask |= 2147483648U;
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 91
      tmp___0 = ngx_radix32tree_insert(tree, key, mask, (uintptr_t )-1);
      }
#line 91
      if (tmp___0 != 0L) {
#line 94
        return ((ngx_radix_tree_t *)((void *)0));
      }
#line 97
      key += inc___0;
#line 90
      if (! key) {
#line 90
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    inc___0 >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (tree);
}
}
#line 108 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix32tree_insert(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ,
                                 uintptr_t value ) 
{ 
  uint32_t bit ;
  ngx_radix_node_t *node ;
  ngx_radix_node_t *next ;

  {
#line 115
  bit = 2147483648U;
#line 117
  node = tree->root;
#line 118
  next = tree->root;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (bit & mask)) {
#line 120
      goto while_break;
    }
#line 121
    if (key & bit) {
#line 122
      next = node->right;
    } else {
#line 125
      next = node->left;
    }
#line 128
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 129
      goto while_break;
    }
#line 132
    bit >>= 1;
#line 133
    node = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (next) {
#line 137
    if (node->value != 0xffffffffffffffffUL) {
#line 138
      return ((ngx_int_t )-3);
    }
#line 141
    node->value = value;
#line 142
    return ((ngx_int_t )0);
  }
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (! (bit & mask)) {
#line 145
      goto while_break___0;
    }
    {
#line 146
    next = ngx_radix_alloc(tree);
    }
#line 147
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 148
      return ((ngx_int_t )-1);
    }
#line 151
    next->right = (ngx_radix_node_t *)((void *)0);
#line 152
    next->left = (ngx_radix_node_t *)((void *)0);
#line 153
    next->parent = node;
#line 154
    next->value = (uintptr_t )-1;
#line 156
    if (key & bit) {
#line 157
      node->right = next;
    } else {
#line 160
      node->left = next;
    }
#line 163
    bit >>= 1;
#line 164
    node = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  node->value = value;
#line 169
  return ((ngx_int_t )0);
}
}
#line 173 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix32tree_delete(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ) 
{ 
  uint32_t bit ;
  ngx_radix_node_t *node ;

  {
#line 179
  bit = 2147483648U;
#line 180
  node = tree->root;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (node) {
#line 182
      if (! (bit & mask)) {
#line 182
        goto while_break;
      }
    } else {
#line 182
      goto while_break;
    }
#line 183
    if (key & bit) {
#line 184
      node = node->right;
    } else {
#line 187
      node = node->left;
    }
#line 190
    bit >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 194
    return ((ngx_int_t )-1);
  }
#line 197
  if (node->right) {
#line 197
    goto _L;
  } else
#line 197
  if (node->left) {
    _L: /* CIL Label */ 
#line 198
    if (node->value != 0xffffffffffffffffUL) {
#line 199
      node->value = (uintptr_t )-1;
#line 200
      return ((ngx_int_t )0);
    }
#line 203
    return ((ngx_int_t )-1);
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 208
      (node->parent)->right = (ngx_radix_node_t *)((void *)0);
    } else {
#line 211
      (node->parent)->left = (ngx_radix_node_t *)((void *)0);
    }
#line 214
    node->right = tree->free;
#line 215
    tree->free = node;
#line 217
    node = node->parent;
#line 219
    if (node->right) {
#line 220
      goto while_break___0;
    } else
#line 219
    if (node->left) {
#line 220
      goto while_break___0;
    }
#line 223
    if (node->value != 0xffffffffffffffffUL) {
#line 224
      goto while_break___0;
    }
#line 227
    if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 228
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  return ((ngx_int_t )0);
}
}
#line 236 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
uintptr_t ngx_radix32tree_find(ngx_radix_tree_t *tree , uint32_t key ) 
{ 
  uint32_t bit ;
  uintptr_t value ;
  ngx_radix_node_t *node ;

  {
#line 243
  bit = 2147483648U;
#line 244
  value = (uintptr_t )-1;
#line 245
  node = tree->root;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! node) {
#line 247
      goto while_break;
    }
#line 248
    if (node->value != 0xffffffffffffffffUL) {
#line 249
      value = node->value;
    }
#line 252
    if (key & bit) {
#line 253
      node = node->right;
    } else {
#line 256
      node = node->left;
    }
#line 259
    bit >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (value);
}
}
#line 268 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix128tree_insert(ngx_radix_tree_t *tree , u_char *key , u_char *mask ,
                                  uintptr_t value ) 
{ 
  u_char bit ;
  ngx_uint_t i ;
  ngx_radix_node_t *node ;
  ngx_radix_node_t *next ;

  {
#line 276
  i = (ngx_uint_t )0;
#line 277
  bit = (u_char )128;
#line 279
  node = tree->root;
#line 280
  next = tree->root;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! ((int )bit & (int )*(mask + i))) {
#line 282
      goto while_break;
    }
#line 283
    if ((int )*(key + i) & (int )bit) {
#line 284
      next = node->right;
    } else {
#line 287
      next = node->left;
    }
#line 290
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 291
      goto while_break;
    }
#line 294
    bit = (u_char )((int )bit >> 1);
#line 295
    node = next;
#line 297
    if ((int )bit == 0) {
#line 298
      i ++;
#line 298
      if (i == 16UL) {
#line 299
        goto while_break;
      }
#line 302
      bit = (u_char )128;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (next) {
#line 307
    if (node->value != 0xffffffffffffffffUL) {
#line 308
      return ((ngx_int_t )-3);
    }
#line 311
    node->value = value;
#line 312
    return ((ngx_int_t )0);
  }
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 315
    if (! ((int )bit & (int )*(mask + i))) {
#line 315
      goto while_break___0;
    }
    {
#line 316
    next = ngx_radix_alloc(tree);
    }
#line 317
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 318
      return ((ngx_int_t )-1);
    }
#line 321
    next->right = (ngx_radix_node_t *)((void *)0);
#line 322
    next->left = (ngx_radix_node_t *)((void *)0);
#line 323
    next->parent = node;
#line 324
    next->value = (uintptr_t )-1;
#line 326
    if ((int )*(key + i) & (int )bit) {
#line 327
      node->right = next;
    } else {
#line 330
      node->left = next;
    }
#line 333
    bit = (u_char )((int )bit >> 1);
#line 334
    node = next;
#line 336
    if ((int )bit == 0) {
#line 337
      i ++;
#line 337
      if (i == 16UL) {
#line 338
        goto while_break___0;
      }
#line 341
      bit = (u_char )128;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 345
  node->value = value;
#line 347
  return ((ngx_int_t )0);
}
}
#line 351 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix128tree_delete(ngx_radix_tree_t *tree , u_char *key , u_char *mask ) 
{ 
  u_char bit ;
  ngx_uint_t i ;
  ngx_radix_node_t *node ;

  {
#line 358
  i = (ngx_uint_t )0;
#line 359
  bit = (u_char )128;
#line 360
  node = tree->root;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (node) {
#line 362
      if (! ((int )bit & (int )*(mask + i))) {
#line 362
        goto while_break;
      }
    } else {
#line 362
      goto while_break;
    }
#line 363
    if ((int )*(key + i) & (int )bit) {
#line 364
      node = node->right;
    } else {
#line 367
      node = node->left;
    }
#line 370
    bit = (u_char )((int )bit >> 1);
#line 372
    if ((int )bit == 0) {
#line 373
      i ++;
#line 373
      if (i == 16UL) {
#line 374
        goto while_break;
      }
#line 377
      bit = (u_char )128;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 382
    return ((ngx_int_t )-1);
  }
#line 385
  if (node->right) {
#line 385
    goto _L;
  } else
#line 385
  if (node->left) {
    _L: /* CIL Label */ 
#line 386
    if (node->value != 0xffffffffffffffffUL) {
#line 387
      node->value = (uintptr_t )-1;
#line 388
      return ((ngx_int_t )0);
    }
#line 391
    return ((ngx_int_t )-1);
  }
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 396
      (node->parent)->right = (ngx_radix_node_t *)((void *)0);
    } else {
#line 399
      (node->parent)->left = (ngx_radix_node_t *)((void *)0);
    }
#line 402
    node->right = tree->free;
#line 403
    tree->free = node;
#line 405
    node = node->parent;
#line 407
    if (node->right) {
#line 408
      goto while_break___0;
    } else
#line 407
    if (node->left) {
#line 408
      goto while_break___0;
    }
#line 411
    if (node->value != 0xffffffffffffffffUL) {
#line 412
      goto while_break___0;
    }
#line 415
    if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 416
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return ((ngx_int_t )0);
}
}
#line 424 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
uintptr_t ngx_radix128tree_find(ngx_radix_tree_t *tree , u_char *key ) 
{ 
  u_char bit ;
  uintptr_t value ;
  ngx_uint_t i ;
  ngx_radix_node_t *node ;

  {
#line 432
  i = (ngx_uint_t )0;
#line 433
  bit = (u_char )128;
#line 434
  value = (uintptr_t )-1;
#line 435
  node = tree->root;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! node) {
#line 437
      goto while_break;
    }
#line 438
    if (node->value != 0xffffffffffffffffUL) {
#line 439
      value = node->value;
    }
#line 442
    if ((int )*(key + i) & (int )bit) {
#line 443
      node = node->right;
    } else {
#line 446
      node = node->left;
    }
#line 449
    bit = (u_char )((int )bit >> 1);
#line 451
    if ((int )bit == 0) {
#line 452
      i ++;
#line 453
      bit = (u_char )128;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  return (value);
}
}
#line 463 "/tmp/nginx-1.13.2/src/core/ngx_radix_tree.c"
static ngx_radix_node_t *ngx_radix_alloc(ngx_radix_tree_t *tree ) 
{ 
  ngx_radix_node_t *p ;
  void *tmp ;

  {
#line 468
  if (tree->free) {
#line 469
    p = tree->free;
#line 470
    tree->free = (tree->free)->right;
#line 471
    return (p);
  }
#line 474
  if (tree->size < sizeof(ngx_radix_node_t )) {
    {
#line 475
    tmp = ngx_pmemalign(tree->pool, ngx_pagesize, ngx_pagesize);
#line 475
    tree->start = (char *)tmp;
    }
#line 476
    if ((unsigned long )tree->start == (unsigned long )((void *)0)) {
#line 477
      return ((ngx_radix_node_t *)((void *)0));
    }
#line 480
    tree->size = ngx_pagesize;
  }
#line 483
  p = (ngx_radix_node_t *)tree->start;
#line 484
  tree->start += sizeof(ngx_radix_node_t );
#line 485
  tree->size -= sizeof(ngx_radix_node_t );
#line 487
  return (p);
}
}
#line 18 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
__inline static void ngx_rbtree_left_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                            ngx_rbtree_node_t *node ) ;
#line 20
__inline static void ngx_rbtree_right_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                             ngx_rbtree_node_t *node ) ;
#line 24 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
void ngx_rbtree_insert(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t **root ;
  ngx_rbtree_node_t *temp ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 31
  root = & tree->root;
#line 32
  sentinel = tree->sentinel;
#line 34
  if ((unsigned long )*root == (unsigned long )sentinel) {
#line 35
    node->parent = (ngx_rbtree_node_t *)((void *)0);
#line 36
    node->left = sentinel;
#line 37
    node->right = sentinel;
#line 38
    node->color = (u_char )0;
#line 39
    *root = node;
#line 41
    return;
  }
  {
#line 44
  (*(tree->insert))(*root, node, sentinel);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if ((unsigned long )node != (unsigned long )*root) {
#line 48
      if (! (node->parent)->color) {
#line 48
        goto while_break;
      }
    } else {
#line 48
      goto while_break;
    }
#line 50
    if ((unsigned long )node->parent == (unsigned long )((node->parent)->parent)->left) {
#line 51
      temp = ((node->parent)->parent)->right;
#line 53
      if (temp->color) {
#line 54
        (node->parent)->color = (u_char )0;
#line 55
        temp->color = (u_char )0;
#line 56
        ((node->parent)->parent)->color = (u_char )1;
#line 57
        node = (node->parent)->parent;
      } else {
#line 60
        if ((unsigned long )node == (unsigned long )(node->parent)->right) {
          {
#line 61
          node = node->parent;
#line 62
          ngx_rbtree_left_rotate(root, sentinel, node);
          }
        }
        {
#line 65
        (node->parent)->color = (u_char )0;
#line 66
        ((node->parent)->parent)->color = (u_char )1;
#line 67
        ngx_rbtree_right_rotate(root, sentinel, (node->parent)->parent);
        }
      }
    } else {
#line 71
      temp = ((node->parent)->parent)->left;
#line 73
      if (temp->color) {
#line 74
        (node->parent)->color = (u_char )0;
#line 75
        temp->color = (u_char )0;
#line 76
        ((node->parent)->parent)->color = (u_char )1;
#line 77
        node = (node->parent)->parent;
      } else {
#line 80
        if ((unsigned long )node == (unsigned long )(node->parent)->left) {
          {
#line 81
          node = node->parent;
#line 82
          ngx_rbtree_right_rotate(root, sentinel, node);
          }
        }
        {
#line 85
        (node->parent)->color = (u_char )0;
#line 86
        ((node->parent)->parent)->color = (u_char )1;
#line 87
        ngx_rbtree_left_rotate(root, sentinel, (node->parent)->parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  (*root)->color = (u_char )0;
#line 93
  return;
}
}
#line 96 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
void ngx_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (node->key < temp->key) {
#line 104
      p = & temp->left;
    } else {
#line 104
      p = & temp->right;
    }
#line 106
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 107
      goto while_break;
    }
#line 110
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  *p = node;
#line 114
  node->parent = temp;
#line 115
  node->left = sentinel;
#line 116
  node->right = sentinel;
#line 117
  node->color = (u_char )1;
#line 118
  return;
}
}
#line 121 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
void ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                   ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if ((ngx_rbtree_key_int_t )(node->key - temp->key) < 0L) {
#line 138
      p = & temp->left;
    } else {
#line 138
      p = & temp->right;
    }
#line 141
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 142
      goto while_break;
    }
#line 145
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  *p = node;
#line 149
  node->parent = temp;
#line 150
  node->left = sentinel;
#line 151
  node->right = sentinel;
#line 152
  node->color = (u_char )1;
#line 153
  return;
}
}
#line 156 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
void ngx_rbtree_delete(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) 
{ 
  ngx_uint_t red ;
  ngx_rbtree_node_t **root ;
  ngx_rbtree_node_t *sentinel ;
  ngx_rbtree_node_t *subst ;
  ngx_rbtree_node_t *temp ;
  ngx_rbtree_node_t *w ;

  {
#line 164
  root = & tree->root;
#line 165
  sentinel = tree->sentinel;
#line 167
  if ((unsigned long )node->left == (unsigned long )sentinel) {
#line 168
    temp = node->right;
#line 169
    subst = node;
  } else
#line 171
  if ((unsigned long )node->right == (unsigned long )sentinel) {
#line 172
    temp = node->left;
#line 173
    subst = node;
  } else {
    {
#line 176
    subst = ngx_rbtree_min(node->right, sentinel);
    }
#line 178
    if ((unsigned long )subst->left != (unsigned long )sentinel) {
#line 179
      temp = subst->left;
    } else {
#line 181
      temp = subst->right;
    }
  }
#line 185
  if ((unsigned long )subst == (unsigned long )*root) {
#line 186
    *root = temp;
#line 187
    temp->color = (u_char )0;
#line 190
    node->left = (ngx_rbtree_node_t *)((void *)0);
#line 191
    node->right = (ngx_rbtree_node_t *)((void *)0);
#line 192
    node->parent = (ngx_rbtree_node_t *)((void *)0);
#line 193
    node->key = (ngx_rbtree_key_t )0;
#line 195
    return;
  }
#line 198
  red = (ngx_uint_t )subst->color;
#line 200
  if ((unsigned long )subst == (unsigned long )(subst->parent)->left) {
#line 201
    (subst->parent)->left = temp;
  } else {
#line 204
    (subst->parent)->right = temp;
  }
#line 207
  if ((unsigned long )subst == (unsigned long )node) {
#line 209
    temp->parent = subst->parent;
  } else {
#line 213
    if ((unsigned long )subst->parent == (unsigned long )node) {
#line 214
      temp->parent = subst;
    } else {
#line 217
      temp->parent = subst->parent;
    }
#line 220
    subst->left = node->left;
#line 221
    subst->right = node->right;
#line 222
    subst->parent = node->parent;
#line 223
    subst->color = node->color;
#line 225
    if ((unsigned long )node == (unsigned long )*root) {
#line 226
      *root = subst;
    } else
#line 229
    if ((unsigned long )node == (unsigned long )(node->parent)->left) {
#line 230
      (node->parent)->left = subst;
    } else {
#line 232
      (node->parent)->right = subst;
    }
#line 236
    if ((unsigned long )subst->left != (unsigned long )sentinel) {
#line 237
      (subst->left)->parent = subst;
    }
#line 240
    if ((unsigned long )subst->right != (unsigned long )sentinel) {
#line 241
      (subst->right)->parent = subst;
    }
  }
#line 246
  node->left = (ngx_rbtree_node_t *)((void *)0);
#line 247
  node->right = (ngx_rbtree_node_t *)((void *)0);
#line 248
  node->parent = (ngx_rbtree_node_t *)((void *)0);
#line 249
  node->key = (ngx_rbtree_key_t )0;
#line 251
  if (red) {
#line 252
    return;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if ((unsigned long )temp != (unsigned long )*root) {
#line 257
      if (! (! temp->color)) {
#line 257
        goto while_break;
      }
    } else {
#line 257
      goto while_break;
    }
#line 259
    if ((unsigned long )temp == (unsigned long )(temp->parent)->left) {
#line 260
      w = (temp->parent)->right;
#line 262
      if (w->color) {
        {
#line 263
        w->color = (u_char )0;
#line 264
        (temp->parent)->color = (u_char )1;
#line 265
        ngx_rbtree_left_rotate(root, sentinel, temp->parent);
#line 266
        w = (temp->parent)->right;
        }
      }
#line 269
      if (! (w->left)->color) {
#line 269
        if (! (w->right)->color) {
#line 270
          w->color = (u_char )1;
#line 271
          temp = temp->parent;
        } else {
#line 269
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 274
        if (! (w->right)->color) {
          {
#line 275
          (w->left)->color = (u_char )0;
#line 276
          w->color = (u_char )1;
#line 277
          ngx_rbtree_right_rotate(root, sentinel, w);
#line 278
          w = (temp->parent)->right;
          }
        }
        {
#line 281
        w->color = (temp->parent)->color;
#line 282
        (temp->parent)->color = (u_char )0;
#line 283
        (w->right)->color = (u_char )0;
#line 284
        ngx_rbtree_left_rotate(root, sentinel, temp->parent);
#line 285
        temp = *root;
        }
      }
    } else {
#line 289
      w = (temp->parent)->left;
#line 291
      if (w->color) {
        {
#line 292
        w->color = (u_char )0;
#line 293
        (temp->parent)->color = (u_char )1;
#line 294
        ngx_rbtree_right_rotate(root, sentinel, temp->parent);
#line 295
        w = (temp->parent)->left;
        }
      }
#line 298
      if (! (w->left)->color) {
#line 298
        if (! (w->right)->color) {
#line 299
          w->color = (u_char )1;
#line 300
          temp = temp->parent;
        } else {
#line 298
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 303
        if (! (w->left)->color) {
          {
#line 304
          (w->right)->color = (u_char )0;
#line 305
          w->color = (u_char )1;
#line 306
          ngx_rbtree_left_rotate(root, sentinel, w);
#line 307
          w = (temp->parent)->left;
          }
        }
        {
#line 310
        w->color = (temp->parent)->color;
#line 311
        (temp->parent)->color = (u_char )0;
#line 312
        (w->left)->color = (u_char )0;
#line 313
        ngx_rbtree_right_rotate(root, sentinel, temp->parent);
#line 314
        temp = *root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  temp->color = (u_char )0;
#line 320
  return;
}
}
#line 323 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
__inline static void ngx_rbtree_left_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                            ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t *temp ;

  {
#line 329
  temp = node->right;
#line 330
  node->right = temp->left;
#line 332
  if ((unsigned long )temp->left != (unsigned long )sentinel) {
#line 333
    (temp->left)->parent = node;
  }
#line 336
  temp->parent = node->parent;
#line 338
  if ((unsigned long )node == (unsigned long )*root) {
#line 339
    *root = temp;
  } else
#line 341
  if ((unsigned long )node == (unsigned long )(node->parent)->left) {
#line 342
    (node->parent)->left = temp;
  } else {
#line 345
    (node->parent)->right = temp;
  }
#line 348
  temp->left = node;
#line 349
  node->parent = temp;
#line 350
  return;
}
}
#line 353 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
__inline static void ngx_rbtree_right_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                             ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t *temp ;

  {
#line 359
  temp = node->left;
#line 360
  node->left = temp->right;
#line 362
  if ((unsigned long )temp->right != (unsigned long )sentinel) {
#line 363
    (temp->right)->parent = node;
  }
#line 366
  temp->parent = node->parent;
#line 368
  if ((unsigned long )node == (unsigned long )*root) {
#line 369
    *root = temp;
  } else
#line 371
  if ((unsigned long )node == (unsigned long )(node->parent)->right) {
#line 372
    (node->parent)->right = temp;
  } else {
#line 375
    (node->parent)->left = temp;
  }
#line 378
  temp->right = node;
#line 379
  node->parent = temp;
#line 380
  return;
}
}
#line 383 "/tmp/nginx-1.13.2/src/core/ngx_rbtree.c"
ngx_rbtree_node_t *ngx_rbtree_next(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;
  ngx_rbtree_node_t *parent ;
  ngx_rbtree_node_t *tmp ;

  {
#line 388
  sentinel = tree->sentinel;
#line 390
  if ((unsigned long )node->right != (unsigned long )sentinel) {
    {
#line 391
    tmp = ngx_rbtree_min(node->right, sentinel);
    }
#line 391
    return (tmp);
  }
#line 394
  root = tree->root;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    parent = node->parent;
#line 399
    if ((unsigned long )node == (unsigned long )root) {
#line 400
      return ((ngx_rbtree_node_t *)((void *)0));
    }
#line 403
    if ((unsigned long )node == (unsigned long )parent->left) {
#line 404
      return (parent);
    }
#line 407
    node = parent;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 15 "/tmp/nginx-1.13.2/src/core/ngx_sha1.c"
static u_char const   *ngx_sha1_body(ngx_sha1_t *ctx , u_char const   *data , size_t___0 size ) ;
#line 19 "/tmp/nginx-1.13.2/src/core/ngx_sha1.c"
void ngx_sha1_init(ngx_sha1_t *ctx ) 
{ 


  {
#line 22
  ctx->a = (uint32_t )1732584193;
#line 23
  ctx->b = 4023233417U;
#line 24
  ctx->c = 2562383102U;
#line 25
  ctx->d = (uint32_t )271733878;
#line 26
  ctx->e = 3285377520U;
#line 28
  ctx->bytes = (uint64_t )0;
#line 29
  return;
}
}
#line 32 "/tmp/nginx-1.13.2/src/core/ngx_sha1.c"
void ngx_sha1_update(ngx_sha1_t *ctx , void const   *data , size_t___0 size ) 
{ 
  size_t___0 used ;
  size_t___0 free___0 ;
  u_char const   *tmp ;

  {
#line 37
  used = ctx->bytes & 63UL;
#line 38
  ctx->bytes += size;
#line 40
  if (used) {
#line 41
    free___0 = 64UL - used;
#line 43
    if (size < free___0) {
      {
#line 44
      memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
             size);
      }
#line 45
      return;
    }
    {
#line 48
    memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
           free___0);
#line 49
    data = (void const   *)((u_char *)data + free___0);
#line 50
    size -= free___0;
#line 51
    ngx_sha1_body(ctx, (u_char const   *)(ctx->buffer), (size_t___0 )64);
    }
  }
#line 54
  if (size >= 64UL) {
    {
#line 55
    tmp = ngx_sha1_body(ctx, (u_char const   *)data, size & 0xffffffffffffffc0UL);
#line 55
    data = (void const   *)tmp;
#line 56
    size &= 63UL;
    }
  }
  {
#line 59
  memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)data,
         size);
  }
#line 60
  return;
}
}
#line 63 "/tmp/nginx-1.13.2/src/core/ngx_sha1.c"
void ngx_sha1_final(u_char *result___0 , ngx_sha1_t *ctx ) 
{ 
  size_t___0 used ;
  size_t___0 free___0 ;
  size_t___0 tmp ;

  {
#line 68
  used = ctx->bytes & 63UL;
#line 70
  tmp = used;
#line 70
  used ++;
#line 70
  ctx->buffer[tmp] = (u_char )128;
#line 72
  free___0 = 64UL - used;
#line 74
  if (free___0 < 8UL) {
    {
#line 75
    memset((void *)(& ctx->buffer[used]), 0, free___0);
#line 76
    ngx_sha1_body(ctx, (u_char const   *)(ctx->buffer), (size_t___0 )64);
#line 77
    used = (size_t___0 )0;
#line 78
    free___0 = (size_t___0 )64;
    }
  }
  {
#line 81
  memset((void *)(& ctx->buffer[used]), 0, free___0 - 8UL);
#line 83
  ctx->bytes <<= 3;
#line 84
  ctx->buffer[56] = (u_char )(ctx->bytes >> 56);
#line 85
  ctx->buffer[57] = (u_char )(ctx->bytes >> 48);
#line 86
  ctx->buffer[58] = (u_char )(ctx->bytes >> 40);
#line 87
  ctx->buffer[59] = (u_char )(ctx->bytes >> 32);
#line 88
  ctx->buffer[60] = (u_char )(ctx->bytes >> 24);
#line 89
  ctx->buffer[61] = (u_char )(ctx->bytes >> 16);
#line 90
  ctx->buffer[62] = (u_char )(ctx->bytes >> 8);
#line 91
  ctx->buffer[63] = (u_char )ctx->bytes;
#line 93
  ngx_sha1_body(ctx, (u_char const   *)(ctx->buffer), (size_t___0 )64);
#line 95
  *(result___0 + 0) = (u_char )(ctx->a >> 24);
#line 96
  *(result___0 + 1) = (u_char )(ctx->a >> 16);
#line 97
  *(result___0 + 2) = (u_char )(ctx->a >> 8);
#line 98
  *(result___0 + 3) = (u_char )ctx->a;
#line 99
  *(result___0 + 4) = (u_char )(ctx->b >> 24);
#line 100
  *(result___0 + 5) = (u_char )(ctx->b >> 16);
#line 101
  *(result___0 + 6) = (u_char )(ctx->b >> 8);
#line 102
  *(result___0 + 7) = (u_char )ctx->b;
#line 103
  *(result___0 + 8) = (u_char )(ctx->c >> 24);
#line 104
  *(result___0 + 9) = (u_char )(ctx->c >> 16);
#line 105
  *(result___0 + 10) = (u_char )(ctx->c >> 8);
#line 106
  *(result___0 + 11) = (u_char )ctx->c;
#line 107
  *(result___0 + 12) = (u_char )(ctx->d >> 24);
#line 108
  *(result___0 + 13) = (u_char )(ctx->d >> 16);
#line 109
  *(result___0 + 14) = (u_char )(ctx->d >> 8);
#line 110
  *(result___0 + 15) = (u_char )ctx->d;
#line 111
  *(result___0 + 16) = (u_char )(ctx->e >> 24);
#line 112
  *(result___0 + 17) = (u_char )(ctx->e >> 16);
#line 113
  *(result___0 + 18) = (u_char )(ctx->e >> 8);
#line 114
  *(result___0 + 19) = (u_char )ctx->e;
#line 116
  memset((void *)ctx, 0, sizeof(*ctx));
  }
#line 117
  return;
}
}
#line 156 "/tmp/nginx-1.13.2/src/core/ngx_sha1.c"
static u_char const   *ngx_sha1_body(ngx_sha1_t *ctx , u_char const   *data , size_t___0 size ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t temp ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  uint32_t saved_e ;
  uint32_t words[80] ;
  ngx_uint_t i ;
  u_char const   *p ;

  {
#line 165
  p = data;
#line 167
  a = ctx->a;
#line 168
  b = ctx->b;
#line 169
  c = ctx->c;
#line 170
  d = ctx->d;
#line 171
  e = ctx->e;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    saved_a = a;
#line 175
    saved_b = b;
#line 176
    saved_c = c;
#line 177
    saved_d = d;
#line 178
    saved_e = e;
#line 182
    i = (ngx_uint_t )0;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      if (! (i < 16UL)) {
#line 182
        goto while_break___0;
      }
#line 183
      words[i] = (((uint32_t )*(p + (i * 4UL + 3UL)) | ((uint32_t )*(p + (i * 4UL + 2UL)) << 8)) | ((uint32_t )*(p + (i * 4UL + 1UL)) << 16)) | ((uint32_t )*(p + i * 4UL) << 24);
#line 182
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 186
    i = (ngx_uint_t )16;
    {
#line 186
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 186
      if (! (i < 80UL)) {
#line 186
        goto while_break___1;
      }
#line 187
      words[i] = ((((words[i - 3UL] ^ words[i - 8UL]) ^ words[i - 14UL]) ^ words[i - 16UL]) << 1) | ((((words[i - 3UL] ^ words[i - 8UL]) ^ words[i - 14UL]) ^ words[i - 16UL]) >> 31);
#line 186
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 193
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[0]) + 1518500249U;
#line 193
    e = d;
#line 193
    d = c;
#line 193
    c = (b << 30) | (b >> 2);
#line 193
    b = a;
#line 193
    a = temp;
#line 194
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[1]) + 1518500249U;
#line 194
    e = d;
#line 194
    d = c;
#line 194
    c = (b << 30) | (b >> 2);
#line 194
    b = a;
#line 194
    a = temp;
#line 195
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[2]) + 1518500249U;
#line 195
    e = d;
#line 195
    d = c;
#line 195
    c = (b << 30) | (b >> 2);
#line 195
    b = a;
#line 195
    a = temp;
#line 196
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[3]) + 1518500249U;
#line 196
    e = d;
#line 196
    d = c;
#line 196
    c = (b << 30) | (b >> 2);
#line 196
    b = a;
#line 196
    a = temp;
#line 197
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[4]) + 1518500249U;
#line 197
    e = d;
#line 197
    d = c;
#line 197
    c = (b << 30) | (b >> 2);
#line 197
    b = a;
#line 197
    a = temp;
#line 198
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[5]) + 1518500249U;
#line 198
    e = d;
#line 198
    d = c;
#line 198
    c = (b << 30) | (b >> 2);
#line 198
    b = a;
#line 198
    a = temp;
#line 199
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[6]) + 1518500249U;
#line 199
    e = d;
#line 199
    d = c;
#line 199
    c = (b << 30) | (b >> 2);
#line 199
    b = a;
#line 199
    a = temp;
#line 200
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[7]) + 1518500249U;
#line 200
    e = d;
#line 200
    d = c;
#line 200
    c = (b << 30) | (b >> 2);
#line 200
    b = a;
#line 200
    a = temp;
#line 201
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[8]) + 1518500249U;
#line 201
    e = d;
#line 201
    d = c;
#line 201
    c = (b << 30) | (b >> 2);
#line 201
    b = a;
#line 201
    a = temp;
#line 202
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[9]) + 1518500249U;
#line 202
    e = d;
#line 202
    d = c;
#line 202
    c = (b << 30) | (b >> 2);
#line 202
    b = a;
#line 202
    a = temp;
#line 203
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[10]) + 1518500249U;
#line 203
    e = d;
#line 203
    d = c;
#line 203
    c = (b << 30) | (b >> 2);
#line 203
    b = a;
#line 203
    a = temp;
#line 204
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[11]) + 1518500249U;
#line 204
    e = d;
#line 204
    d = c;
#line 204
    c = (b << 30) | (b >> 2);
#line 204
    b = a;
#line 204
    a = temp;
#line 205
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[12]) + 1518500249U;
#line 205
    e = d;
#line 205
    d = c;
#line 205
    c = (b << 30) | (b >> 2);
#line 205
    b = a;
#line 205
    a = temp;
#line 206
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[13]) + 1518500249U;
#line 206
    e = d;
#line 206
    d = c;
#line 206
    c = (b << 30) | (b >> 2);
#line 206
    b = a;
#line 206
    a = temp;
#line 207
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[14]) + 1518500249U;
#line 207
    e = d;
#line 207
    d = c;
#line 207
    c = (b << 30) | (b >> 2);
#line 207
    b = a;
#line 207
    a = temp;
#line 208
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[15]) + 1518500249U;
#line 208
    e = d;
#line 208
    d = c;
#line 208
    c = (b << 30) | (b >> 2);
#line 208
    b = a;
#line 208
    a = temp;
#line 209
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[16]) + 1518500249U;
#line 209
    e = d;
#line 209
    d = c;
#line 209
    c = (b << 30) | (b >> 2);
#line 209
    b = a;
#line 209
    a = temp;
#line 210
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[17]) + 1518500249U;
#line 210
    e = d;
#line 210
    d = c;
#line 210
    c = (b << 30) | (b >> 2);
#line 210
    b = a;
#line 210
    a = temp;
#line 211
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[18]) + 1518500249U;
#line 211
    e = d;
#line 211
    d = c;
#line 211
    c = (b << 30) | (b >> 2);
#line 211
    b = a;
#line 211
    a = temp;
#line 212
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[19]) + 1518500249U;
#line 212
    e = d;
#line 212
    d = c;
#line 212
    c = (b << 30) | (b >> 2);
#line 212
    b = a;
#line 212
    a = temp;
#line 214
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[20]) + 1859775393U;
#line 214
    e = d;
#line 214
    d = c;
#line 214
    c = (b << 30) | (b >> 2);
#line 214
    b = a;
#line 214
    a = temp;
#line 215
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[21]) + 1859775393U;
#line 215
    e = d;
#line 215
    d = c;
#line 215
    c = (b << 30) | (b >> 2);
#line 215
    b = a;
#line 215
    a = temp;
#line 216
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[22]) + 1859775393U;
#line 216
    e = d;
#line 216
    d = c;
#line 216
    c = (b << 30) | (b >> 2);
#line 216
    b = a;
#line 216
    a = temp;
#line 217
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[23]) + 1859775393U;
#line 217
    e = d;
#line 217
    d = c;
#line 217
    c = (b << 30) | (b >> 2);
#line 217
    b = a;
#line 217
    a = temp;
#line 218
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[24]) + 1859775393U;
#line 218
    e = d;
#line 218
    d = c;
#line 218
    c = (b << 30) | (b >> 2);
#line 218
    b = a;
#line 218
    a = temp;
#line 219
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[25]) + 1859775393U;
#line 219
    e = d;
#line 219
    d = c;
#line 219
    c = (b << 30) | (b >> 2);
#line 219
    b = a;
#line 219
    a = temp;
#line 220
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[26]) + 1859775393U;
#line 220
    e = d;
#line 220
    d = c;
#line 220
    c = (b << 30) | (b >> 2);
#line 220
    b = a;
#line 220
    a = temp;
#line 221
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[27]) + 1859775393U;
#line 221
    e = d;
#line 221
    d = c;
#line 221
    c = (b << 30) | (b >> 2);
#line 221
    b = a;
#line 221
    a = temp;
#line 222
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[28]) + 1859775393U;
#line 222
    e = d;
#line 222
    d = c;
#line 222
    c = (b << 30) | (b >> 2);
#line 222
    b = a;
#line 222
    a = temp;
#line 223
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[29]) + 1859775393U;
#line 223
    e = d;
#line 223
    d = c;
#line 223
    c = (b << 30) | (b >> 2);
#line 223
    b = a;
#line 223
    a = temp;
#line 224
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[30]) + 1859775393U;
#line 224
    e = d;
#line 224
    d = c;
#line 224
    c = (b << 30) | (b >> 2);
#line 224
    b = a;
#line 224
    a = temp;
#line 225
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[31]) + 1859775393U;
#line 225
    e = d;
#line 225
    d = c;
#line 225
    c = (b << 30) | (b >> 2);
#line 225
    b = a;
#line 225
    a = temp;
#line 226
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[32]) + 1859775393U;
#line 226
    e = d;
#line 226
    d = c;
#line 226
    c = (b << 30) | (b >> 2);
#line 226
    b = a;
#line 226
    a = temp;
#line 227
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[33]) + 1859775393U;
#line 227
    e = d;
#line 227
    d = c;
#line 227
    c = (b << 30) | (b >> 2);
#line 227
    b = a;
#line 227
    a = temp;
#line 228
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[34]) + 1859775393U;
#line 228
    e = d;
#line 228
    d = c;
#line 228
    c = (b << 30) | (b >> 2);
#line 228
    b = a;
#line 228
    a = temp;
#line 229
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[35]) + 1859775393U;
#line 229
    e = d;
#line 229
    d = c;
#line 229
    c = (b << 30) | (b >> 2);
#line 229
    b = a;
#line 229
    a = temp;
#line 230
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[36]) + 1859775393U;
#line 230
    e = d;
#line 230
    d = c;
#line 230
    c = (b << 30) | (b >> 2);
#line 230
    b = a;
#line 230
    a = temp;
#line 231
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[37]) + 1859775393U;
#line 231
    e = d;
#line 231
    d = c;
#line 231
    c = (b << 30) | (b >> 2);
#line 231
    b = a;
#line 231
    a = temp;
#line 232
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[38]) + 1859775393U;
#line 232
    e = d;
#line 232
    d = c;
#line 232
    c = (b << 30) | (b >> 2);
#line 232
    b = a;
#line 232
    a = temp;
#line 233
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[39]) + 1859775393U;
#line 233
    e = d;
#line 233
    d = c;
#line 233
    c = (b << 30) | (b >> 2);
#line 233
    b = a;
#line 233
    a = temp;
#line 235
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[40]) + 2400959708U;
#line 235
    e = d;
#line 235
    d = c;
#line 235
    c = (b << 30) | (b >> 2);
#line 235
    b = a;
#line 235
    a = temp;
#line 236
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[41]) + 2400959708U;
#line 236
    e = d;
#line 236
    d = c;
#line 236
    c = (b << 30) | (b >> 2);
#line 236
    b = a;
#line 236
    a = temp;
#line 237
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[42]) + 2400959708U;
#line 237
    e = d;
#line 237
    d = c;
#line 237
    c = (b << 30) | (b >> 2);
#line 237
    b = a;
#line 237
    a = temp;
#line 238
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[43]) + 2400959708U;
#line 238
    e = d;
#line 238
    d = c;
#line 238
    c = (b << 30) | (b >> 2);
#line 238
    b = a;
#line 238
    a = temp;
#line 239
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[44]) + 2400959708U;
#line 239
    e = d;
#line 239
    d = c;
#line 239
    c = (b << 30) | (b >> 2);
#line 239
    b = a;
#line 239
    a = temp;
#line 240
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[45]) + 2400959708U;
#line 240
    e = d;
#line 240
    d = c;
#line 240
    c = (b << 30) | (b >> 2);
#line 240
    b = a;
#line 240
    a = temp;
#line 241
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[46]) + 2400959708U;
#line 241
    e = d;
#line 241
    d = c;
#line 241
    c = (b << 30) | (b >> 2);
#line 241
    b = a;
#line 241
    a = temp;
#line 242
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[47]) + 2400959708U;
#line 242
    e = d;
#line 242
    d = c;
#line 242
    c = (b << 30) | (b >> 2);
#line 242
    b = a;
#line 242
    a = temp;
#line 243
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[48]) + 2400959708U;
#line 243
    e = d;
#line 243
    d = c;
#line 243
    c = (b << 30) | (b >> 2);
#line 243
    b = a;
#line 243
    a = temp;
#line 244
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[49]) + 2400959708U;
#line 244
    e = d;
#line 244
    d = c;
#line 244
    c = (b << 30) | (b >> 2);
#line 244
    b = a;
#line 244
    a = temp;
#line 245
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[50]) + 2400959708U;
#line 245
    e = d;
#line 245
    d = c;
#line 245
    c = (b << 30) | (b >> 2);
#line 245
    b = a;
#line 245
    a = temp;
#line 246
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[51]) + 2400959708U;
#line 246
    e = d;
#line 246
    d = c;
#line 246
    c = (b << 30) | (b >> 2);
#line 246
    b = a;
#line 246
    a = temp;
#line 247
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[52]) + 2400959708U;
#line 247
    e = d;
#line 247
    d = c;
#line 247
    c = (b << 30) | (b >> 2);
#line 247
    b = a;
#line 247
    a = temp;
#line 248
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[53]) + 2400959708U;
#line 248
    e = d;
#line 248
    d = c;
#line 248
    c = (b << 30) | (b >> 2);
#line 248
    b = a;
#line 248
    a = temp;
#line 249
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[54]) + 2400959708U;
#line 249
    e = d;
#line 249
    d = c;
#line 249
    c = (b << 30) | (b >> 2);
#line 249
    b = a;
#line 249
    a = temp;
#line 250
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[55]) + 2400959708U;
#line 250
    e = d;
#line 250
    d = c;
#line 250
    c = (b << 30) | (b >> 2);
#line 250
    b = a;
#line 250
    a = temp;
#line 251
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[56]) + 2400959708U;
#line 251
    e = d;
#line 251
    d = c;
#line 251
    c = (b << 30) | (b >> 2);
#line 251
    b = a;
#line 251
    a = temp;
#line 252
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[57]) + 2400959708U;
#line 252
    e = d;
#line 252
    d = c;
#line 252
    c = (b << 30) | (b >> 2);
#line 252
    b = a;
#line 252
    a = temp;
#line 253
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[58]) + 2400959708U;
#line 253
    e = d;
#line 253
    d = c;
#line 253
    c = (b << 30) | (b >> 2);
#line 253
    b = a;
#line 253
    a = temp;
#line 254
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[59]) + 2400959708U;
#line 254
    e = d;
#line 254
    d = c;
#line 254
    c = (b << 30) | (b >> 2);
#line 254
    b = a;
#line 254
    a = temp;
#line 256
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[60]) + 3395469782U;
#line 256
    e = d;
#line 256
    d = c;
#line 256
    c = (b << 30) | (b >> 2);
#line 256
    b = a;
#line 256
    a = temp;
#line 257
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[61]) + 3395469782U;
#line 257
    e = d;
#line 257
    d = c;
#line 257
    c = (b << 30) | (b >> 2);
#line 257
    b = a;
#line 257
    a = temp;
#line 258
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[62]) + 3395469782U;
#line 258
    e = d;
#line 258
    d = c;
#line 258
    c = (b << 30) | (b >> 2);
#line 258
    b = a;
#line 258
    a = temp;
#line 259
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[63]) + 3395469782U;
#line 259
    e = d;
#line 259
    d = c;
#line 259
    c = (b << 30) | (b >> 2);
#line 259
    b = a;
#line 259
    a = temp;
#line 260
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[64]) + 3395469782U;
#line 260
    e = d;
#line 260
    d = c;
#line 260
    c = (b << 30) | (b >> 2);
#line 260
    b = a;
#line 260
    a = temp;
#line 261
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[65]) + 3395469782U;
#line 261
    e = d;
#line 261
    d = c;
#line 261
    c = (b << 30) | (b >> 2);
#line 261
    b = a;
#line 261
    a = temp;
#line 262
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[66]) + 3395469782U;
#line 262
    e = d;
#line 262
    d = c;
#line 262
    c = (b << 30) | (b >> 2);
#line 262
    b = a;
#line 262
    a = temp;
#line 263
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[67]) + 3395469782U;
#line 263
    e = d;
#line 263
    d = c;
#line 263
    c = (b << 30) | (b >> 2);
#line 263
    b = a;
#line 263
    a = temp;
#line 264
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[68]) + 3395469782U;
#line 264
    e = d;
#line 264
    d = c;
#line 264
    c = (b << 30) | (b >> 2);
#line 264
    b = a;
#line 264
    a = temp;
#line 265
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[69]) + 3395469782U;
#line 265
    e = d;
#line 265
    d = c;
#line 265
    c = (b << 30) | (b >> 2);
#line 265
    b = a;
#line 265
    a = temp;
#line 266
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[70]) + 3395469782U;
#line 266
    e = d;
#line 266
    d = c;
#line 266
    c = (b << 30) | (b >> 2);
#line 266
    b = a;
#line 266
    a = temp;
#line 267
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[71]) + 3395469782U;
#line 267
    e = d;
#line 267
    d = c;
#line 267
    c = (b << 30) | (b >> 2);
#line 267
    b = a;
#line 267
    a = temp;
#line 268
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[72]) + 3395469782U;
#line 268
    e = d;
#line 268
    d = c;
#line 268
    c = (b << 30) | (b >> 2);
#line 268
    b = a;
#line 268
    a = temp;
#line 269
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[73]) + 3395469782U;
#line 269
    e = d;
#line 269
    d = c;
#line 269
    c = (b << 30) | (b >> 2);
#line 269
    b = a;
#line 269
    a = temp;
#line 270
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[74]) + 3395469782U;
#line 270
    e = d;
#line 270
    d = c;
#line 270
    c = (b << 30) | (b >> 2);
#line 270
    b = a;
#line 270
    a = temp;
#line 271
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[75]) + 3395469782U;
#line 271
    e = d;
#line 271
    d = c;
#line 271
    c = (b << 30) | (b >> 2);
#line 271
    b = a;
#line 271
    a = temp;
#line 272
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[76]) + 3395469782U;
#line 272
    e = d;
#line 272
    d = c;
#line 272
    c = (b << 30) | (b >> 2);
#line 272
    b = a;
#line 272
    a = temp;
#line 273
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[77]) + 3395469782U;
#line 273
    e = d;
#line 273
    d = c;
#line 273
    c = (b << 30) | (b >> 2);
#line 273
    b = a;
#line 273
    a = temp;
#line 274
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[78]) + 3395469782U;
#line 274
    e = d;
#line 274
    d = c;
#line 274
    c = (b << 30) | (b >> 2);
#line 274
    b = a;
#line 274
    a = temp;
#line 275
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[79]) + 3395469782U;
#line 275
    e = d;
#line 275
    d = c;
#line 275
    c = (b << 30) | (b >> 2);
#line 275
    b = a;
#line 275
    a = temp;
#line 277
    a += saved_a;
#line 278
    b += saved_b;
#line 279
    c += saved_c;
#line 280
    d += saved_d;
#line 281
    e += saved_e;
#line 283
    p += 64;
#line 173
    size -= 64UL;
#line 173
    if (! size) {
#line 173
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  ctx->a = a;
#line 288
  ctx->b = b;
#line 289
  ctx->c = c;
#line 290
  ctx->d = d;
#line 291
  ctx->e = e;
#line 293
  return (p);
}
}
#line 14 "/tmp/nginx-1.13.2/src/core/ngx_md5.c"
static u_char const   *ngx_md5_body(ngx_md5_t *ctx , u_char const   *data , size_t___0 size ) ;
#line 18 "/tmp/nginx-1.13.2/src/core/ngx_md5.c"
void ngx_md5_init(ngx_md5_t *ctx ) 
{ 


  {
#line 21
  ctx->a = (uint32_t )1732584193;
#line 22
  ctx->b = 4023233417U;
#line 23
  ctx->c = 2562383102U;
#line 24
  ctx->d = (uint32_t )271733878;
#line 26
  ctx->bytes = (uint64_t )0;
#line 27
  return;
}
}
#line 30 "/tmp/nginx-1.13.2/src/core/ngx_md5.c"
void ngx_md5_update(ngx_md5_t *ctx , void const   *data , size_t___0 size ) 
{ 
  size_t___0 used ;
  size_t___0 free___0 ;
  u_char const   *tmp ;

  {
#line 35
  used = ctx->bytes & 63UL;
#line 36
  ctx->bytes += size;
#line 38
  if (used) {
#line 39
    free___0 = 64UL - used;
#line 41
    if (size < free___0) {
      {
#line 42
      memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
             size);
      }
#line 43
      return;
    }
    {
#line 46
    memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
           free___0);
#line 47
    data = (void const   *)((u_char *)data + free___0);
#line 48
    size -= free___0;
#line 49
    ngx_md5_body(ctx, (u_char const   *)(ctx->buffer), (size_t___0 )64);
    }
  }
#line 52
  if (size >= 64UL) {
    {
#line 53
    tmp = ngx_md5_body(ctx, (u_char const   *)data, size & 0xffffffffffffffc0UL);
#line 53
    data = (void const   *)tmp;
#line 54
    size &= 63UL;
    }
  }
  {
#line 57
  memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)data,
         size);
  }
#line 58
  return;
}
}
#line 61 "/tmp/nginx-1.13.2/src/core/ngx_md5.c"
void ngx_md5_final(u_char *result___0 , ngx_md5_t *ctx ) 
{ 
  size_t___0 used ;
  size_t___0 free___0 ;
  size_t___0 tmp ;

  {
#line 66
  used = ctx->bytes & 63UL;
#line 68
  tmp = used;
#line 68
  used ++;
#line 68
  ctx->buffer[tmp] = (u_char )128;
#line 70
  free___0 = 64UL - used;
#line 72
  if (free___0 < 8UL) {
    {
#line 73
    memset((void *)(& ctx->buffer[used]), 0, free___0);
#line 74
    ngx_md5_body(ctx, (u_char const   *)(ctx->buffer), (size_t___0 )64);
#line 75
    used = (size_t___0 )0;
#line 76
    free___0 = (size_t___0 )64;
    }
  }
  {
#line 79
  memset((void *)(& ctx->buffer[used]), 0, free___0 - 8UL);
#line 81
  ctx->bytes <<= 3;
#line 82
  ctx->buffer[56] = (u_char )ctx->bytes;
#line 83
  ctx->buffer[57] = (u_char )(ctx->bytes >> 8);
#line 84
  ctx->buffer[58] = (u_char )(ctx->bytes >> 16);
#line 85
  ctx->buffer[59] = (u_char )(ctx->bytes >> 24);
#line 86
  ctx->buffer[60] = (u_char )(ctx->bytes >> 32);
#line 87
  ctx->buffer[61] = (u_char )(ctx->bytes >> 40);
#line 88
  ctx->buffer[62] = (u_char )(ctx->bytes >> 48);
#line 89
  ctx->buffer[63] = (u_char )(ctx->bytes >> 56);
#line 91
  ngx_md5_body(ctx, (u_char const   *)(ctx->buffer), (size_t___0 )64);
#line 93
  *(result___0 + 0) = (u_char )ctx->a;
#line 94
  *(result___0 + 1) = (u_char )(ctx->a >> 8);
#line 95
  *(result___0 + 2) = (u_char )(ctx->a >> 16);
#line 96
  *(result___0 + 3) = (u_char )(ctx->a >> 24);
#line 97
  *(result___0 + 4) = (u_char )ctx->b;
#line 98
  *(result___0 + 5) = (u_char )(ctx->b >> 8);
#line 99
  *(result___0 + 6) = (u_char )(ctx->b >> 16);
#line 100
  *(result___0 + 7) = (u_char )(ctx->b >> 24);
#line 101
  *(result___0 + 8) = (u_char )ctx->c;
#line 102
  *(result___0 + 9) = (u_char )(ctx->c >> 8);
#line 103
  *(result___0 + 10) = (u_char )(ctx->c >> 16);
#line 104
  *(result___0 + 11) = (u_char )(ctx->c >> 24);
#line 105
  *(result___0 + 12) = (u_char )ctx->d;
#line 106
  *(result___0 + 13) = (u_char )(ctx->d >> 8);
#line 107
  *(result___0 + 14) = (u_char )(ctx->d >> 16);
#line 108
  *(result___0 + 15) = (u_char )(ctx->d >> 24);
#line 110
  memset((void *)ctx, 0, sizeof(*ctx));
  }
#line 111
  return;
}
}
#line 169 "/tmp/nginx-1.13.2/src/core/ngx_md5.c"
static u_char const   *ngx_md5_body(ngx_md5_t *ctx , u_char const   *data , size_t___0 size ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  u_char const   *p ;

  {
#line 179
  p = data;
#line 181
  a = ctx->a;
#line 182
  b = ctx->b;
#line 183
  c = ctx->c;
#line 184
  d = ctx->d;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    saved_a = a;
#line 188
    saved_b = b;
#line 189
    saved_c = c;
#line 190
    saved_d = d;
#line 194
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 0))) + 3614090360U;
#line 194
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 194
    a += b;
#line 195
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 4))) + 3905402710U;
#line 195
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 195
    d += a;
#line 196
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 8))) + 606105819U;
#line 196
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 196
    c += d;
#line 197
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 12))) + 3250441966U;
#line 197
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 197
    b += c;
#line 198
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 16))) + 4118548399U;
#line 198
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 198
    a += b;
#line 199
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 20))) + 1200080426U;
#line 199
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 199
    d += a;
#line 200
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 24))) + 2821735955U;
#line 200
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 200
    c += d;
#line 201
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 28))) + 4249261313U;
#line 201
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 201
    b += c;
#line 202
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 32))) + 1770035416U;
#line 202
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 202
    a += b;
#line 203
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 36))) + 2336552879U;
#line 203
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 203
    d += a;
#line 204
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 40))) + 4294925233U;
#line 204
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 204
    c += d;
#line 205
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 44))) + 2304563134U;
#line 205
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 205
    b += c;
#line 206
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 48))) + 1804603682U;
#line 206
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 206
    a += b;
#line 207
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 52))) + 4254626195U;
#line 207
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 207
    d += a;
#line 208
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 56))) + 2792965006U;
#line 208
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 208
    c += d;
#line 209
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 60))) + 1236535329U;
#line 209
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 209
    b += c;
#line 213
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 4))) + 4129170786U;
#line 213
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 213
    a += b;
#line 214
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 24))) + 3225465664U;
#line 214
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 214
    d += a;
#line 215
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 44))) + 643717713U;
#line 215
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 215
    c += d;
#line 216
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 0))) + 3921069994U;
#line 216
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 216
    b += c;
#line 217
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 20))) + 3593408605U;
#line 217
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 217
    a += b;
#line 218
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 40))) + 38016083U;
#line 218
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 218
    d += a;
#line 219
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 60))) + 3634488961U;
#line 219
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 219
    c += d;
#line 220
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 16))) + 3889429448U;
#line 220
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 220
    b += c;
#line 221
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 36))) + 568446438U;
#line 221
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 221
    a += b;
#line 222
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 56))) + 3275163606U;
#line 222
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 222
    d += a;
#line 223
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 12))) + 4107603335U;
#line 223
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 223
    c += d;
#line 224
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 32))) + 1163531501U;
#line 224
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 224
    b += c;
#line 225
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 52))) + 2850285829U;
#line 225
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 225
    a += b;
#line 226
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 8))) + 4243563512U;
#line 226
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 226
    d += a;
#line 227
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 28))) + 1735328473U;
#line 227
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 227
    c += d;
#line 228
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 48))) + 2368359562U;
#line 228
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 228
    b += c;
#line 232
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 20))) + 4294588738U;
#line 232
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 232
    a += b;
#line 233
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 32))) + 2272392833U;
#line 233
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 233
    d += a;
#line 234
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 44))) + 1839030562U;
#line 234
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 234
    c += d;
#line 235
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 56))) + 4259657740U;
#line 235
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 235
    b += c;
#line 236
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 4))) + 2763975236U;
#line 236
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 236
    a += b;
#line 237
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 16))) + 1272893353U;
#line 237
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 237
    d += a;
#line 238
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 28))) + 4139469664U;
#line 238
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 238
    c += d;
#line 239
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 40))) + 3200236656U;
#line 239
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 239
    b += c;
#line 240
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 52))) + 681279174U;
#line 240
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 240
    a += b;
#line 241
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 0))) + 3936430074U;
#line 241
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 241
    d += a;
#line 242
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 12))) + 3572445317U;
#line 242
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 242
    c += d;
#line 243
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 24))) + 76029189U;
#line 243
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 243
    b += c;
#line 244
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 36))) + 3654602809U;
#line 244
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 244
    a += b;
#line 245
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 48))) + 3873151461U;
#line 245
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 245
    d += a;
#line 246
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 60))) + 530742520U;
#line 246
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 246
    c += d;
#line 247
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 8))) + 3299628645U;
#line 247
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 247
    b += c;
#line 251
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 0))) + 4096336452U;
#line 251
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 251
    a += b;
#line 252
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 28))) + 1126891415U;
#line 252
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 252
    d += a;
#line 253
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 56))) + 2878612391U;
#line 253
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 253
    c += d;
#line 254
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 20))) + 4237533241U;
#line 254
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 254
    b += c;
#line 255
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 48))) + 1700485571U;
#line 255
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 255
    a += b;
#line 256
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 12))) + 2399980690U;
#line 256
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 256
    d += a;
#line 257
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 40))) + 4293915773U;
#line 257
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 257
    c += d;
#line 258
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 4))) + 2240044497U;
#line 258
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 258
    b += c;
#line 259
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 32))) + 1873313359U;
#line 259
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 259
    a += b;
#line 260
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 60))) + 4264355552U;
#line 260
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 260
    d += a;
#line 261
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 24))) + 2734768916U;
#line 261
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 261
    c += d;
#line 262
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 52))) + 1309151649U;
#line 262
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 262
    b += c;
#line 263
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 16))) + 4149444226U;
#line 263
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 263
    a += b;
#line 264
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 44))) + 3174756917U;
#line 264
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 264
    d += a;
#line 265
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 8))) + 718787259U;
#line 265
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 265
    c += d;
#line 266
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 36))) + 3951481745U;
#line 266
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 266
    b += c;
#line 268
    a += saved_a;
#line 269
    b += saved_b;
#line 270
    c += saved_c;
#line 271
    d += saved_d;
#line 273
    p += 64;
#line 186
    size -= 64UL;
#line 186
    if (! size) {
#line 186
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  ctx->a = a;
#line 278
  ctx->b = b;
#line 279
  ctx->c = c;
#line 280
  ctx->d = d;
#line 282
  return (p);
}
}
#line 11 "/tmp/nginx-1.13.2/src/core/ngx_murmurhash.c"
uint32_t ngx_murmur_hash2(u_char *data , size_t___0 len ) 
{ 
  uint32_t h ;
  uint32_t k ;

  {
#line 16
  h = (uint32_t )len;
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (len >= 4UL)) {
#line 18
      goto while_break;
    }
#line 19
    k = (uint32_t )*(data + 0);
#line 20
    k |= (unsigned int )((int )*(data + 1) << 8);
#line 21
    k |= (unsigned int )((int )*(data + 2) << 16);
#line 22
    k |= (unsigned int )((int )*(data + 3) << 24);
#line 24
    k *= 1540483477U;
#line 25
    k ^= k >> 24;
#line 26
    k *= 1540483477U;
#line 28
    h *= 1540483477U;
#line 29
    h ^= k;
#line 31
    data += 4;
#line 32
    len -= 4UL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 36
  if (len == 3UL) {
#line 36
    goto case_3;
  }
#line 39
  if (len == 2UL) {
#line 39
    goto case_2;
  }
#line 42
  if (len == 1UL) {
#line 42
    goto case_1;
  }
#line 35
  goto switch_break;
  case_3: /* CIL Label */ 
#line 37
  h ^= (unsigned int )((int )*(data + 2) << 16);
  case_2: /* CIL Label */ 
#line 40
  h ^= (unsigned int )((int )*(data + 1) << 8);
  case_1: /* CIL Label */ 
#line 43
  h ^= (unsigned int )*(data + 0);
#line 44
  h *= 1540483477U;
  switch_break: /* CIL Label */ ;
  }
#line 47
  h ^= h >> 13;
#line 48
  h *= 1540483477U;
#line 49
  h ^= h >> 15;
#line 51
  return (h);
}
}
#line 76 "src/core/ngx_crc32.h"
ngx_int_t ngx_crc32_table_init(void) ;
#line 26 "/tmp/nginx-1.13.2/src/core/ngx_crc32.c"
static uint32_t ngx_crc32_table16[16]  = 
#line 26 "/tmp/nginx-1.13.2/src/core/ngx_crc32.c"
  {      (uint32_t )0,      (uint32_t )498536548,      (uint32_t )997073096,      (uint32_t )651767980, 
        (uint32_t )1994146192,      (uint32_t )1802195444,      (uint32_t )1303535960,      (uint32_t )1342533948, 
        3988292384U,      4027552580U,      3604390888U,      3412177804U, 
        2607071920U,      2262029012U,      2685067896U,      3183342108U};
#line 34 "/tmp/nginx-1.13.2/src/core/ngx_crc32.c"
uint32_t ngx_crc32_table256[256]  = 
#line 34
  {      (uint32_t )0,      (uint32_t )1996959894,      3993919788U,      2567524794U, 
        (uint32_t )124634137,      (uint32_t )1886057615,      3915621685U,      2657392035U, 
        (uint32_t )249268274,      (uint32_t )2044508324,      3772115230U,      2547177864U, 
        (uint32_t )162941995,      (uint32_t )2125561021,      3887607047U,      2428444049U, 
        (uint32_t )498536548,      (uint32_t )1789927666,      4089016648U,      2227061214U, 
        (uint32_t )450548861,      (uint32_t )1843258603,      4107580753U,      2211677639U, 
        (uint32_t )325883990,      (uint32_t )1684777152,      4251122042U,      2321926636U, 
        (uint32_t )335633487,      (uint32_t )1661365465,      4195302755U,      2366115317U, 
        (uint32_t )997073096,      (uint32_t )1281953886,      3579855332U,      2724688242U, 
        (uint32_t )1006888145,      (uint32_t )1258607687,      3524101629U,      2768942443U, 
        (uint32_t )901097722,      (uint32_t )1119000684,      3686517206U,      2898065728U, 
        (uint32_t )853044451,      (uint32_t )1172266101,      3705015759U,      2882616665U, 
        (uint32_t )651767980,      (uint32_t )1373503546,      3369554304U,      3218104598U, 
        (uint32_t )565507253,      (uint32_t )1454621731,      3485111705U,      3099436303U, 
        (uint32_t )671266974,      (uint32_t )1594198024,      3322730930U,      2970347812U, 
        (uint32_t )795835527,      (uint32_t )1483230225,      3244367275U,      3060149565U, 
        (uint32_t )1994146192,      (uint32_t )31158534,      2563907772U,      4023717930U, 
        (uint32_t )1907459465,      (uint32_t )112637215,      2680153253U,      3904427059U, 
        (uint32_t )2013776290,      (uint32_t )251722036,      2517215374U,      3775830040U, 
        (uint32_t )2137656763,      (uint32_t )141376813,      2439277719U,      3865271297U, 
        (uint32_t )1802195444,      (uint32_t )476864866,      2238001368U,      4066508878U, 
        (uint32_t )1812370925,      (uint32_t )453092731,      2181625025U,      4111451223U, 
        (uint32_t )1706088902,      (uint32_t )314042704,      2344532202U,      4240017532U, 
        (uint32_t )1658658271,      (uint32_t )366619977,      2362670323U,      4224994405U, 
        (uint32_t )1303535960,      (uint32_t )984961486,      2747007092U,      3569037538U, 
        (uint32_t )1256170817,      (uint32_t )1037604311,      2765210733U,      3554079995U, 
        (uint32_t )1131014506,      (uint32_t )879679996,      2909243462U,      3663771856U, 
        (uint32_t )1141124467,      (uint32_t )855842277,      2852801631U,      3708648649U, 
        (uint32_t )1342533948,      (uint32_t )654459306,      3188396048U,      3373015174U, 
        (uint32_t )1466479909,      (uint32_t )544179635,      3110523913U,      3462522015U, 
        (uint32_t )1591671054,      (uint32_t )702138776,      2966460450U,      3352799412U, 
        (uint32_t )1504918807,      (uint32_t )783551873,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      (uint32_t )62317068,      (uint32_t )1957810842, 
        3939845945U,      2647816111U,      (uint32_t )81470997,      (uint32_t )1943803523, 
        3814918930U,      2489596804U,      (uint32_t )225274430,      (uint32_t )2053790376, 
        3826175755U,      2466906013U,      (uint32_t )167816743,      (uint32_t )2097651377, 
        4027552580U,      2265490386U,      (uint32_t )503444072,      (uint32_t )1762050814, 
        4150417245U,      2154129355U,      (uint32_t )426522225,      (uint32_t )1852507879, 
        4275313526U,      2312317920U,      (uint32_t )282753626,      (uint32_t )1742555852, 
        4189708143U,      2394877945U,      (uint32_t )397917763,      (uint32_t )1622183637, 
        3604390888U,      2714866558U,      (uint32_t )953729732,      (uint32_t )1340076626, 
        3518719985U,      2797360999U,      (uint32_t )1068828381,      (uint32_t )1219638859, 
        3624741850U,      2936675148U,      (uint32_t )906185462,      (uint32_t )1090812512, 
        3747672003U,      2825379669U,      (uint32_t )829329135,      (uint32_t )1181335161, 
        3412177804U,      3160834842U,      (uint32_t )628085408,      (uint32_t )1382605366, 
        3423369109U,      3138078467U,      (uint32_t )570562233,      (uint32_t )1426400815, 
        3317316542U,      2998733608U,      (uint32_t )733239954,      (uint32_t )1555261956, 
        3268935591U,      3050360625U,      (uint32_t )752459403,      (uint32_t )1541320221, 
        2607071920U,      3965973030U,      (uint32_t )1969922972,      (uint32_t )40735498, 
        2617837225U,      3943577151U,      (uint32_t )1913087877,      (uint32_t )83908371, 
        2512341634U,      3803740692U,      (uint32_t )2075208622,      (uint32_t )213261112, 
        2463272603U,      3855990285U,      (uint32_t )2094854071,      (uint32_t )198958881, 
        2262029012U,      4057260610U,      (uint32_t )1759359992,      (uint32_t )534414190, 
        2176718541U,      4139329115U,      (uint32_t )1873836001,      (uint32_t )414664567, 
        2282248934U,      4279200368U,      (uint32_t )1711684554,      (uint32_t )285281116, 
        2405801727U,      4167216745U,      (uint32_t )1634467795,      (uint32_t )376229701, 
        2685067896U,      3608007406U,      (uint32_t )1308918612,      (uint32_t )956543938, 
        2808555105U,      3495958263U,      (uint32_t )1231636301,      (uint32_t )1047427035, 
        2932959818U,      3654703836U,      (uint32_t )1088359270,      (uint32_t )936918000, 
        2847714899U,      3736837829U,      (uint32_t )1202900863,      (uint32_t )817233897, 
        3183342108U,      3401237130U,      (uint32_t )1404277552,      (uint32_t )615818150, 
        3134207493U,      3453421203U,      (uint32_t )1423857449,      (uint32_t )601450431, 
        3009837614U,      3294710456U,      (uint32_t )1567103746,      (uint32_t )711928724, 
        3020668471U,      3272380065U,      (uint32_t )1510334235,      (uint32_t )755167117};
#line 102 "/tmp/nginx-1.13.2/src/core/ngx_crc32.c"
uint32_t *ngx_crc32_table_short  =    ngx_crc32_table16;
#line 105 "/tmp/nginx-1.13.2/src/core/ngx_crc32.c"
ngx_int_t ngx_crc32_table_init(void) 
{ 
  void *p ;

  {
#line 110
  if (((uintptr_t )ngx_crc32_table_short & ~ (ngx_cacheline_size - 1UL)) == (uintptr_t )ngx_crc32_table_short) {
#line 114
    return ((ngx_int_t )0);
  }
  {
#line 117
  p = ngx_alloc(16UL * sizeof(uint32_t ) + ngx_cacheline_size, (ngx_log_t *)ngx_cycle->log);
  }
#line 118
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 119
    return ((ngx_int_t )-1);
  }
  {
#line 122
  p = (void *)((u_char *)(((uintptr_t )p + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL)));
#line 124
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ngx_crc32_table16),
         16UL * sizeof(uint32_t ));
#line 126
  ngx_crc32_table_short = (uint32_t *)p;
  }
#line 128
  return ((ngx_int_t )0);
}
}
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 89 "src/core/ngx_palloc.h"
void ngx_pool_delete_file(void *data ) ;
#line 143 "src/core/ngx_file.h"
ngx_int_t ngx_create_path(ngx_file_t *file , ngx_path_t *path ) ;
#line 144
ngx_err_t ngx_create_full_path(u_char *dir , ngx_uint_t access___0 ) ;
#line 149
ngx_int_t ngx_copy_file(u_char *from , u_char *to , ngx_copy_file_t *cf ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
static ngx_int_t ngx_test_full_name(ngx_str_t *name ) ;
#line 15 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
static unsigned long volatile   temp_number  =    (ngx_atomic_t )0;
#line 16 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_atomic_t *ngx_temp_number  =    & temp_number;
#line 17 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_atomic_int_t ngx_random_number  =    (ngx_atomic_int_t )123456;
#line 20 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_get_full_name(ngx_pool_t *pool , ngx_str_t *prefix , ngx_str_t *name ) 
{ 
  size_t___0 len ;
  u_char *p ;
  u_char *n ;
  ngx_int_t rc ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 27
  rc = ngx_test_full_name(name);
  }
#line 29
  if (rc == 0L) {
#line 30
    return (rc);
  }
  {
#line 33
  len = prefix->len;
#line 43
  tmp = ngx_pnalloc(pool, (len + name->len) + 1UL);
#line 43
  n = (u_char *)tmp;
  }
#line 44
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 45
    return ((ngx_int_t )-1);
  }
  {
#line 48
  tmp___0 = memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)prefix->data,
                   len);
#line 48
  p = (u_char *)tmp___0 + len;
#line 49
  ngx_cpystrn(p, name->data, name->len + 1UL);
#line 51
  name->len += len;
#line 52
  name->data = n;
  }
#line 54
  return ((ngx_int_t )0);
}
}
#line 58 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
static ngx_int_t ngx_test_full_name(ngx_str_t *name ) 
{ 


  {
#line 98
  if ((int )*(name->data + 0) == 47) {
#line 99
    return ((ngx_int_t )0);
  }
#line 102
  return ((ngx_int_t )-5);
}
}
#line 108 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ssize_t ngx_write_chain_to_temp_file(ngx_temp_file_t *tf , ngx_chain_t *chain ) 
{ 
  ngx_int_t rc ;
  ssize_t tmp ;

  {
#line 113
  if (tf->file.fd == -1) {
    {
#line 114
    rc = ngx_create_temp_file(& tf->file, tf->path, tf->pool, (ngx_uint_t )tf->persistent,
                              (ngx_uint_t )tf->clean, tf->access);
    }
#line 117
    if (rc != 0L) {
#line 118
      return (rc);
    }
#line 121
    if (tf->log_level) {
#line 122
      if ((tf->file.log)->log_level >= (ngx_uint_t )tf->log_level) {
        {
#line 122
        ngx_log_error_core((ngx_uint_t )tf->log_level, tf->file.log, 0, "%s %V", tf->warn,
                           & tf->file.name);
        }
      }
    }
  }
  {
#line 136
  tmp = ngx_write_chain_to_file(& tf->file, chain, tf->offset, tf->pool);
  }
#line 136
  return (tmp);
}
}
#line 140 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_create_temp_file(ngx_file_t *file , ngx_path_t *path , ngx_pool_t *pool ,
                               ngx_uint_t persistent , ngx_uint_t clean , ngx_uint_t access___0 ) 
{ 
  size_t___0 levels ;
  u_char *p ;
  uint32_t n ;
  ngx_err_t err ;
  ngx_str_t name ;
  ngx_uint_t prefix ;
  ngx_pool_cleanup_t *cln ;
  ngx_pool_cleanup_file_t *clnf ;
  void *tmp ;
  void *tmp___0 ;
  ngx_atomic_uint_t tmp___1 ;
  int *tmp___2 ;
  ngx_atomic_uint_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 153
  if (file->name.len) {
#line 154
    name = file->name;
#line 155
    levels = (size_t___0 )0;
#line 156
    prefix = (ngx_uint_t )1;
  } else {
#line 159
    name = path->name;
#line 160
    levels = path->len;
#line 161
    prefix = (ngx_uint_t )0;
  }
  {
#line 164
  file->name.len = ((name.len + 1UL) + levels) + 10UL;
#line 166
  tmp = ngx_pnalloc(pool, file->name.len + 1UL);
#line 166
  file->name.data = (u_char *)tmp;
  }
#line 167
  if ((unsigned long )file->name.data == (unsigned long )((void *)0)) {
#line 168
    return ((ngx_int_t )-1);
  }
  {
#line 177
  tmp___0 = memcpy((void */* __restrict  */)file->name.data, (void const   */* __restrict  */)name.data,
                   name.len);
#line 177
  p = (u_char *)tmp___0 + name.len;
  }
#line 179
  if (prefix) {
#line 180
    *p = (u_char )'.';
  }
  {
#line 183
  p += 1UL + levels;
#line 185
  tmp___1 = ngx_next_temp_number((ngx_uint_t )0);
#line 185
  n = (uint32_t )tmp___1;
#line 187
  cln = ngx_pool_cleanup_add(pool, sizeof(ngx_pool_cleanup_file_t ));
  }
#line 188
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 189
    return ((ngx_int_t )-1);
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    ngx_sprintf(p, "%010uD%Z", n);
    }
#line 195
    if (! prefix) {
      {
#line 196
      ngx_create_hashed_filename(path, file->name.data, file->name.len);
      }
    }
    {
#line 202
    file->fd = ngx_open_tempfile(file->name.data, persistent, access___0);
    }
#line 207
    if (file->fd != -1) {
#line 209
      if (clean) {
#line 209
        cln->handler = & ngx_pool_delete_file;
      } else {
#line 209
        cln->handler = & ngx_pool_cleanup_file;
      }
#line 210
      clnf = (ngx_pool_cleanup_file_t *)cln->data;
#line 212
      clnf->fd = file->fd;
#line 213
      clnf->name = file->name.data;
#line 214
      clnf->log = pool->log;
#line 216
      return ((ngx_int_t )0);
    }
    {
#line 219
    tmp___2 = __errno_location();
#line 219
    err = *tmp___2;
    }
#line 221
    if (err == 17) {
      {
#line 222
      tmp___3 = ngx_next_temp_number((ngx_uint_t )1);
#line 222
      n = (uint32_t )tmp___3;
      }
#line 223
      goto __Cont;
    }
#line 226
    if (path->level[0] == 0UL) {
#line 226
      goto _L;
    } else
#line 226
    if (err != 2) {
      _L: /* CIL Label */ 
#line 227
      if ((file->log)->log_level >= 3UL) {
        {
#line 227
        ngx_log_error_core((ngx_uint_t )3, file->log, err, "open() \"%s\" failed",
                           file->name.data);
        }
      }
#line 230
      return ((ngx_int_t )-1);
    }
    {
#line 233
    tmp___4 = ngx_create_path(file, path);
    }
#line 233
    if (tmp___4 == -1L) {
#line 234
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 240 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
void ngx_create_hashed_filename(ngx_path_t *path , u_char *file , size_t___0 len ) 
{ 
  size_t___0 i ;
  size_t___0 level ;
  ngx_uint_t n ;

  {
#line 246
  i = path->name.len + 1UL;
#line 248
  *(file + (path->name.len + path->len)) = (u_char )'/';
#line 250
  n = (ngx_uint_t )0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (n < 3UL)) {
#line 250
      goto while_break;
    }
#line 251
    level = path->level[n];
#line 253
    if (level == 0UL) {
#line 254
      goto while_break;
    }
    {
#line 257
    len -= level;
#line 258
    *(file + (i - 1UL)) = (u_char )'/';
#line 259
    memcpy((void */* __restrict  */)(file + i), (void const   */* __restrict  */)(file + len),
           level);
#line 260
    i += level + 1UL;
#line 250
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 265 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_create_path(ngx_file_t *file , ngx_path_t *path ) 
{ 
  size_t___0 pos ;
  ngx_err_t err ;
  ngx_uint_t i ;
  int *tmp ;
  int tmp___0 ;

  {
#line 272
  pos = path->name.len;
#line 274
  i = (ngx_uint_t )0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < 3UL)) {
#line 274
      goto while_break;
    }
#line 275
    if (path->level[i] == 0UL) {
#line 276
      goto while_break;
    }
    {
#line 279
    pos += path->level[i] + 1UL;
#line 281
    *(file->name.data + pos) = (u_char )'\000';
#line 286
    tmp___0 = mkdir((char const   *)file->name.data, (__mode_t )448);
    }
#line 286
    if (tmp___0 == -1) {
      {
#line 287
      tmp = __errno_location();
#line 287
      err = *tmp;
      }
#line 288
      if (err != 17) {
#line 289
        if ((file->log)->log_level >= 3UL) {
          {
#line 289
          ngx_log_error_core((ngx_uint_t )3, file->log, err, "mkdir() \"%s\" failed",
                             file->name.data);
          }
        }
#line 292
        return ((ngx_int_t )-1);
      }
    }
#line 296
    *(file->name.data + pos) = (u_char )'/';
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return ((ngx_int_t )0);
}
}
#line 303 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_err_t ngx_create_full_path(u_char *dir , ngx_uint_t access___0 ) 
{ 
  u_char *p ;
  u_char ch ;
  ngx_err_t err ;
  int *tmp ;
  int tmp___0 ;

  {
#line 309
  err = 0;
#line 314
  p = dir + 1;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! *p) {
#line 317
      goto while_break;
    }
#line 318
    ch = *p;
#line 320
    if ((int )ch != 47) {
#line 321
      goto __Cont;
    }
    {
#line 324
    *p = (u_char )'\000';
#line 326
    tmp___0 = mkdir((char const   *)dir, (__mode_t )access___0);
    }
#line 326
    if (tmp___0 == -1) {
      {
#line 327
      tmp = __errno_location();
#line 327
      err = *tmp;
      }
      {
#line 330
      if (err == 17) {
#line 330
        goto case_17;
      }
#line 332
      if (err == 13) {
#line 332
        goto case_13;
      }
#line 335
      goto switch_default;
      case_17: /* CIL Label */ 
#line 331
      err = 0;
      case_13: /* CIL Label */ 
#line 333
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 336
      return (err);
      switch_break: /* CIL Label */ ;
      }
    }
#line 340
    *p = (u_char )'/';
    __Cont: /* CIL Label */ 
#line 317
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (err);
}
}
#line 347 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_atomic_uint_t ngx_next_temp_number(ngx_uint_t collision ) 
{ 
  ngx_atomic_uint_t n ;
  ngx_atomic_uint_t add ;
  ngx_atomic_t tmp ;

  {
#line 352
  if (collision) {
#line 352
    add = (ngx_atomic_uint_t )ngx_random_number;
  } else {
#line 352
    add = (ngx_atomic_uint_t )1;
  }
  {
#line 354
  tmp = (ngx_atomic_t )__sync_fetch_and_add(ngx_temp_number, add);
#line 354
  n = (ngx_atomic_uint_t )tmp;
  }
#line 356
  return (n + add);
}
}
#line 360 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
char *ngx_conf_set_path_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ssize_t level ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_path_t *path ;
  ngx_path_t **slot___0 ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 363
  p = (char *)conf;
#line 370
  slot___0 = (ngx_path_t **)(p + cmd->offset);
#line 372
  if (*slot___0) {
#line 373
    return ((char *)"is duplicate");
  }
  {
#line 376
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_path_t ));
#line 376
  path = (ngx_path_t *)tmp;
  }
#line 377
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 378
    return ((char *)((void *)-1));
  }
#line 381
  value = (ngx_str_t *)(cf->args)->elts;
#line 383
  path->name = *(value + 1);
#line 385
  if ((int )*(path->name.data + (path->name.len - 1UL)) == 47) {
#line 386
    (path->name.len) --;
  }
  {
#line 389
  tmp___0 = ngx_conf_full_name(cf->cycle, & path->name, (ngx_uint_t )0);
  }
#line 389
  if (tmp___0 != 0L) {
#line 390
    return ((char *)((void *)-1));
  }
#line 393
  path->conf_file = (cf->conf_file)->file.name.data;
#line 394
  path->line = (cf->conf_file)->line;
#line 396
  i = (ngx_uint_t )0;
#line 396
  n = (ngx_uint_t )2;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (n < (cf->args)->nelts)) {
#line 396
      goto while_break;
    }
    {
#line 397
    level = ngx_atoi((value + n)->data, (value + n)->len);
    }
#line 398
    if (level == -1L) {
#line 399
      return ((char *)"invalid value");
    } else
#line 398
    if (level == 0L) {
#line 399
      return ((char *)"invalid value");
    }
#line 402
    path->level[i] = (size_t___0 )level;
#line 403
    path->len += (size_t___0 )(level + 1L);
#line 396
    i ++;
#line 396
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if (path->len > 10UL + i) {
#line 407
    return ((char *)"invalid value");
  }
  {
#line 410
  *slot___0 = path;
#line 412
  tmp___1 = ngx_add_path(cf, slot___0);
  }
#line 412
  if (tmp___1 == -1L) {
#line 413
    return ((char *)((void *)-1));
  }
#line 416
  return ((char *)((void *)0));
}
}
#line 420 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
char *ngx_conf_merge_path_value(ngx_conf_t *cf , ngx_path_t **path , ngx_path_t *prev ,
                                ngx_path_init_t *init ) 
{ 
  ngx_uint_t i ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 426
  if (*path) {
#line 427
    return ((char *)((void *)0));
  }
#line 430
  if (prev) {
#line 431
    *path = prev;
#line 432
    return ((char *)((void *)0));
  }
  {
#line 435
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_path_t ));
#line 435
  *path = (ngx_path_t *)tmp;
  }
#line 436
  if ((unsigned long )*path == (unsigned long )((void *)0)) {
#line 437
    return ((char *)((void *)-1));
  }
  {
#line 440
  (*path)->name = init->name;
#line 442
  tmp___0 = ngx_conf_full_name(cf->cycle, & (*path)->name, (ngx_uint_t )0);
  }
#line 442
  if (tmp___0 != 0L) {
#line 443
    return ((char *)((void *)-1));
  }
#line 446
  i = (ngx_uint_t )0;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (i < 3UL)) {
#line 446
      goto while_break;
    }
#line 447
    (*path)->level[i] = init->level[i];
#line 448
    if (init->level[i]) {
#line 448
      tmp___1 = 1;
    } else {
#line 448
      tmp___1 = 0;
    }
#line 448
    (*path)->len += init->level[i] + (size_t___0 )tmp___1;
#line 446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 451
  tmp___2 = ngx_add_path(cf, path);
  }
#line 451
  if (tmp___2 != 0L) {
#line 452
    return ((char *)((void *)-1));
  }
#line 455
  return ((char *)((void *)0));
}
}
#line 459 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
char *ngx_conf_set_access_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *confp ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t right ;
  ngx_uint_t shift ;
  ngx_uint_t *access___0 ;
  ngx_uint_t user ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 462
  confp = (char *)conf;
#line 468
  access___0 = (ngx_uint_t *)(confp + cmd->offset);
#line 470
  if (*access___0 != 0xffffffffffffffffUL) {
#line 471
    return ((char *)"is duplicate");
  }
#line 474
  value = (ngx_str_t *)(cf->args)->elts;
#line 476
  *access___0 = (ngx_uint_t )0;
#line 477
  user = (ngx_uint_t )384;
#line 479
  i = (ngx_uint_t )1;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < (cf->args)->nelts)) {
#line 479
      goto while_break;
    }
    {
#line 481
    p = (value + i)->data;
#line 483
    tmp___1 = strncmp((char const   *)p, "user:", sizeof("user:") - 1UL);
    }
#line 483
    if (tmp___1 == 0) {
#line 484
      shift = (ngx_uint_t )6;
#line 485
      p += sizeof("user:") - 1UL;
#line 486
      user = (ngx_uint_t )0;
    } else {
      {
#line 488
      tmp___0 = strncmp((char const   *)p, "group:", sizeof("group:") - 1UL);
      }
#line 488
      if (tmp___0 == 0) {
#line 489
        shift = (ngx_uint_t )3;
#line 490
        p += sizeof("group:") - 1UL;
      } else {
        {
#line 492
        tmp = strncmp((char const   *)p, "all:", sizeof("all:") - 1UL);
        }
#line 492
        if (tmp == 0) {
#line 493
          shift = (ngx_uint_t )0;
#line 494
          p += sizeof("all:") - 1UL;
        } else {
#line 497
          goto invalid;
        }
      }
    }
    {
#line 500
    tmp___3 = strcmp((char const   *)p, "rw");
    }
#line 500
    if (tmp___3 == 0) {
#line 501
      right = (ngx_uint_t )6;
    } else {
      {
#line 503
      tmp___2 = strcmp((char const   *)p, "r");
      }
#line 503
      if (tmp___2 == 0) {
#line 504
        right = (ngx_uint_t )4;
      } else {
#line 507
        goto invalid;
      }
    }
#line 510
    *access___0 |= right << shift;
#line 479
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  *access___0 |= user;
#line 515
  return ((char *)((void *)0));
  invalid: 
  {
#line 519
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
  }
#line 521
  return ((char *)((void *)-1));
}
}
#line 525 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_add_path(ngx_conf_t *cf , ngx_path_t **slot___0 ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_path_t *path ;
  ngx_path_t **p ;
  int tmp ;
  void *tmp___0 ;

  {
#line 531
  path = *slot___0;
#line 533
  p = (ngx_path_t **)(cf->cycle)->paths.elts;
#line 534
  i = (ngx_uint_t )0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (i < (cf->cycle)->paths.nelts)) {
#line 534
      goto while_break;
    }
#line 535
    if ((*(p + i))->name.len == path->name.len) {
      {
#line 535
      tmp = strcmp((char const   *)(*(p + i))->name.data, (char const   *)path->name.data);
      }
#line 535
      if (tmp == 0) {
#line 538
        if ((unsigned long )(*(p + i))->data != (unsigned long )path->data) {
          {
#line 539
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the same path name \"%V\" used in %s:%ui and",
                             & (*(p + i))->name, (*(p + i))->conf_file, (*(p + i))->line);
          }
#line 543
          return ((ngx_int_t )-1);
        }
#line 546
        n = (ngx_uint_t )0;
        {
#line 546
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 546
          if (! (n < 3UL)) {
#line 546
            goto while_break___0;
          }
#line 547
          if ((*(p + i))->level[n] != path->level[n]) {
#line 548
            if ((unsigned long )path->conf_file == (unsigned long )((void *)0)) {
#line 549
              if ((unsigned long )(*(p + i))->conf_file == (unsigned long )((void *)0)) {
#line 550
                if ((cf->log)->log_level >= 1UL) {
                  {
#line 550
                  ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "the default path name \"%V\" has the same name as another default path, but the different levels, you need to redefine one of them in http section",
                                     & (*(p + i))->name);
                  }
                }
#line 556
                return ((ngx_int_t )-1);
              }
#line 559
              if ((cf->log)->log_level >= 1UL) {
                {
#line 559
                ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "the path name \"%V\" in %s:%ui has the same name as default path, but the different levels, you need to define default path in http section",
                                   & (*(p + i))->name, (*(p + i))->conf_file, (*(p + i))->line);
                }
              }
#line 565
              return ((ngx_int_t )-1);
            }
            {
#line 568
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the same path name \"%V\" in %s:%ui has the different levels than",
                               & (*(p + i))->name, (*(p + i))->conf_file, (*(p + i))->line);
            }
#line 572
            return ((ngx_int_t )-1);
          }
#line 575
          if ((*(p + i))->level[n] == 0UL) {
#line 576
            goto while_break___0;
          }
#line 546
          n ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 580
        *slot___0 = *(p + i);
#line 582
        return ((ngx_int_t )0);
      }
    }
#line 534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 586
  tmp___0 = ngx_array_push(& (cf->cycle)->paths);
#line 586
  p = (ngx_path_t **)tmp___0;
  }
#line 587
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 588
    return ((ngx_int_t )-1);
  }
#line 591
  *p = path;
#line 593
  return ((ngx_int_t )0);
}
}
#line 597 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_create_paths(ngx_cycle_t *cycle , ngx_uid_t user ) 
{ 
  ngx_err_t err ;
  ngx_uint_t i ;
  ngx_path_t **path ;
  int *tmp ;
  int tmp___0 ;
  ngx_file_info_t fi ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 604
  path = (ngx_path_t **)cycle->paths.elts;
#line 605
  i = (ngx_uint_t )0;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < cycle->paths.nelts)) {
#line 605
      goto while_break;
    }
    {
#line 607
    tmp___0 = mkdir((char const   *)(*(path + i))->name.data, (__mode_t )448);
    }
#line 607
    if (tmp___0 == -1) {
      {
#line 608
      tmp = __errno_location();
#line 608
      err = *tmp;
      }
#line 609
      if (err != 17) {
#line 610
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 610
          ngx_log_error_core((ngx_uint_t )1, cycle->log, err, "mkdir() \"%s\" failed",
                             (*(path + i))->name.data);
          }
        }
#line 613
        return ((ngx_int_t )-1);
      }
    }
#line 617
    if (user == 4294967295U) {
#line 618
      goto __Cont;
    }
    {
#line 625
    tmp___2 = stat((char const   */* __restrict  */)((char const   *)(*(path + i))->name.data),
                   (struct stat */* __restrict  */)(& fi));
    }
#line 625
    if (tmp___2 == -1) {
#line 626
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 626
        tmp___1 = __errno_location();
#line 626
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___1, "stat() \"%s\" failed",
                           (*(path + i))->name.data);
        }
      }
#line 628
      return ((ngx_int_t )-1);
    }
#line 631
    if (fi.st_uid != user) {
      {
#line 632
      tmp___4 = chown((char const   *)(*(path + i))->name.data, user, (__gid_t )-1);
      }
#line 632
      if (tmp___4 == -1) {
#line 633
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 633
          tmp___3 = __errno_location();
#line 633
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___3, "chown(\"%s\", %d) failed",
                             (*(path + i))->name.data, user);
          }
        }
#line 636
        return ((ngx_int_t )-1);
      }
    }
#line 640
    if ((fi.st_mode & 448U) != 448U) {
      {
#line 643
      fi.st_mode |= 448U;
#line 645
      tmp___6 = chmod((char const   *)(*(path + i))->name.data, fi.st_mode);
      }
#line 645
      if (tmp___6 == -1) {
#line 646
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 646
          tmp___5 = __errno_location();
#line 646
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___5, "chmod() \"%s\" failed",
                             (*(path + i))->name.data);
          }
        }
#line 648
        return ((ngx_int_t )-1);
      }
    }
    __Cont: /* CIL Label */ 
#line 605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  return ((ngx_int_t )0);
}
}
#line 659 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_ext_rename_file(ngx_str_t *src , ngx_str_t *to , ngx_ext_rename_file_t *ext ) 
{ 
  u_char *name ;
  ngx_err_t err ;
  ngx_copy_file_t cf ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  ngx_int_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;
  ngx_atomic_uint_t tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  ngx_int_t tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;

  {
#line 668
  if (ext->access) {
    {
#line 669
    tmp___0 = chmod((char const   *)src->data, (__mode_t )ext->access);
    }
#line 669
    if (tmp___0 == -1) {
#line 670
      if ((ext->log)->log_level >= 3UL) {
        {
#line 670
        tmp = __errno_location();
#line 670
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp, "chmod() \"%s\" failed",
                           src->data);
        }
      }
#line 672
      err = 0;
#line 673
      goto failed;
    }
  }
#line 679
  if (ext->time != -1L) {
    {
#line 680
    tmp___2 = ngx_set_file_time(src->data, ext->fd, ext->time);
    }
#line 680
    if (tmp___2 != 0L) {
#line 681
      if ((ext->log)->log_level >= 3UL) {
        {
#line 681
        tmp___1 = __errno_location();
#line 681
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___1, "utimes() \"%s\" failed",
                           src->data);
        }
      }
#line 683
      err = 0;
#line 684
      goto failed;
    }
  }
  {
#line 688
  tmp___3 = rename((char const   *)src->data, (char const   *)to->data);
  }
#line 688
  if (tmp___3 != -1) {
#line 689
    return ((ngx_int_t )0);
  }
  {
#line 692
  tmp___4 = __errno_location();
#line 692
  err = *tmp___4;
  }
#line 694
  if (err == 2) {
#line 696
    if (! ext->create_path) {
#line 697
      goto failed;
    }
    {
#line 700
    err = ngx_create_full_path(to->data, ext->path_access | ((ext->path_access & 292UL) >> 2));
    }
#line 702
    if (err) {
#line 703
      if ((ext->log)->log_level >= 3UL) {
        {
#line 703
        ngx_log_error_core((ngx_uint_t )3, ext->log, err, "mkdir() \"%s\" failed",
                           to->data);
        }
      }
#line 705
      err = 0;
#line 706
      goto failed;
    }
    {
#line 709
    tmp___5 = rename((char const   *)src->data, (char const   *)to->data);
    }
#line 709
    if (tmp___5 != -1) {
#line 710
      return ((ngx_int_t )0);
    }
    {
#line 713
    tmp___6 = __errno_location();
#line 713
    err = *tmp___6;
    }
  }
#line 728
  if (err == 18) {
    {
#line 730
    cf.size = (off_t )-1;
#line 731
    cf.buf_size = (size_t___0 )0;
#line 732
    cf.access = ext->access;
#line 733
    cf.time = ext->time;
#line 734
    cf.log = ext->log;
#line 736
    tmp___7 = ngx_alloc(((to->len + 1UL) + 10UL) + 1UL, ext->log);
#line 736
    name = (u_char *)tmp___7;
    }
#line 737
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 738
      return ((ngx_int_t )-1);
    }
    {
#line 741
    tmp___8 = ngx_next_temp_number((ngx_uint_t )0);
#line 741
    ngx_sprintf(name, "%*s.%010uD%Z", to->len, to->data, (uint32_t )tmp___8);
#line 744
    tmp___15 = ngx_copy_file(src->data, name, & cf);
    }
#line 744
    if (tmp___15 == 0L) {
      {
#line 746
      tmp___11 = rename((char const   *)name, (char const   *)to->data);
      }
#line 746
      if (tmp___11 != -1) {
        {
#line 747
        free((void *)name);
#line 749
        tmp___10 = unlink((char const   *)src->data);
        }
#line 749
        if (tmp___10 == -1) {
#line 750
          if ((ext->log)->log_level >= 3UL) {
            {
#line 750
            tmp___9 = __errno_location();
#line 750
            ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___9, "unlink() \"%s\" failed",
                               src->data);
            }
          }
#line 753
          return ((ngx_int_t )-1);
        }
#line 756
        return ((ngx_int_t )0);
      }
#line 759
      if ((ext->log)->log_level >= 3UL) {
        {
#line 759
        tmp___12 = __errno_location();
#line 759
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___12, "rename() \"%s\" to \"%s\" failed",
                           name, to->data);
        }
      }
      {
#line 763
      tmp___14 = unlink((char const   *)name);
      }
#line 763
      if (tmp___14 == -1) {
#line 764
        if ((ext->log)->log_level >= 3UL) {
          {
#line 764
          tmp___13 = __errno_location();
#line 764
          ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___13, "unlink() \"%s\" failed",
                             name);
          }
        }
      }
    }
    {
#line 770
    free((void *)name);
#line 772
    err = 0;
    }
  }
  failed: 
#line 777
  if (ext->delete_file) {
    {
#line 778
    tmp___17 = unlink((char const   *)src->data);
    }
#line 778
    if (tmp___17 == -1) {
#line 779
      if ((ext->log)->log_level >= 3UL) {
        {
#line 779
        tmp___16 = __errno_location();
#line 779
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___16, "unlink() \"%s\" failed",
                           src->data);
        }
      }
    }
  }
#line 784
  if (err) {
#line 785
    if ((ext->log)->log_level >= 3UL) {
      {
#line 785
      ngx_log_error_core((ngx_uint_t )3, ext->log, err, "rename() \"%s\" to \"%s\" failed",
                         src->data, to->data);
      }
    }
  }
#line 790
  return ((ngx_int_t )-1);
}
}
#line 794 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_copy_file(u_char *from , u_char *to , ngx_copy_file_t *cf ) 
{ 
  char *buf ;
  off_t size ;
  size_t___0 len ;
  ssize_t n ;
  ngx_fd_t fd ;
  ngx_fd_t nfd ;
  ngx_int_t rc ;
  ngx_file_info_t fi ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  ngx_int_t tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 805
  rc = (ngx_int_t )-1;
#line 806
  buf = (char *)((void *)0);
#line 807
  nfd = -1;
#line 809
  fd = open((char const   *)from, 0, 0);
  }
#line 811
  if (fd == -1) {
#line 812
    if ((cf->log)->log_level >= 3UL) {
      {
#line 812
      tmp = __errno_location();
#line 812
      ngx_log_error_core((ngx_uint_t )3, cf->log, *tmp, "open() \"%s\" failed", from);
      }
    }
#line 814
    goto failed;
  }
#line 817
  if (cf->size != -1L) {
#line 818
    size = cf->size;
  } else {
    {
#line 821
    tmp___1 = fstat(fd, & fi);
    }
#line 821
    if (tmp___1 == -1) {
#line 822
      if ((cf->log)->log_level >= 2UL) {
        {
#line 822
        tmp___0 = __errno_location();
#line 822
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___0, "fstat() \"%s\" failed",
                           from);
        }
      }
#line 825
      goto failed;
    }
#line 828
    size = fi.st_size;
  }
#line 831
  if (cf->buf_size) {
#line 831
    len = cf->buf_size;
  } else {
#line 831
    len = (size_t___0 )65536;
  }
#line 833
  if ((off_t )len > size) {
#line 834
    len = (size_t___0 )size;
  }
  {
#line 837
  tmp___2 = ngx_alloc(len, cf->log);
#line 837
  buf = (char *)tmp___2;
  }
#line 838
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 839
    goto failed;
  }
  {
#line 842
  nfd = open((char const   *)to, 65, cf->access);
  }
#line 845
  if (nfd == -1) {
#line 846
    if ((cf->log)->log_level >= 3UL) {
      {
#line 846
      tmp___3 = __errno_location();
#line 846
      ngx_log_error_core((ngx_uint_t )3, cf->log, *tmp___3, "open() \"%s\" failed",
                         to);
      }
    }
#line 848
    goto failed;
  }
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (size > 0L)) {
#line 851
      goto while_break;
    }
#line 853
    if ((off_t )len > size) {
#line 854
      len = (size_t___0 )size;
    }
    {
#line 857
    n = read(fd, (void *)buf, len);
    }
#line 859
    if (n == -1L) {
#line 860
      if ((cf->log)->log_level >= 2UL) {
        {
#line 860
        tmp___4 = __errno_location();
#line 860
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___4, "read() \"%s\" failed",
                           from);
        }
      }
#line 862
      goto failed;
    }
#line 865
    if ((size_t___0 )n != len) {
#line 866
      if ((cf->log)->log_level >= 2UL) {
        {
#line 866
        ngx_log_error_core((ngx_uint_t )2, cf->log, 0, "read() has read only %z of %O from %s",
                           n, size, from);
        }
      }
#line 869
      goto failed;
    }
    {
#line 872
    n = ngx_write_fd(nfd, (void *)buf, len);
    }
#line 874
    if (n == -1L) {
#line 875
      if ((cf->log)->log_level >= 2UL) {
        {
#line 875
        tmp___5 = __errno_location();
#line 875
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___5, "write() \"%s\" failed",
                           to);
        }
      }
#line 877
      goto failed;
    }
#line 880
    if ((size_t___0 )n != len) {
#line 881
      if ((cf->log)->log_level >= 2UL) {
        {
#line 881
        ngx_log_error_core((ngx_uint_t )2, cf->log, 0, "write() has written only %z of %O to %s",
                           n, size, to);
        }
      }
#line 884
      goto failed;
    }
#line 887
    size -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 890
  if (cf->time != -1L) {
    {
#line 891
    tmp___7 = ngx_set_file_time(to, nfd, cf->time);
    }
#line 891
    if (tmp___7 != 0L) {
#line 892
      if ((cf->log)->log_level >= 2UL) {
        {
#line 892
        tmp___6 = __errno_location();
#line 892
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___6, "utimes() \"%s\" failed",
                           to);
        }
      }
#line 894
      goto failed;
    }
  }
#line 898
  rc = (ngx_int_t )0;
  failed: 
#line 902
  if (nfd != -1) {
    {
#line 903
    tmp___9 = close(nfd);
    }
#line 903
    if (tmp___9 == -1) {
#line 904
      if ((cf->log)->log_level >= 2UL) {
        {
#line 904
        tmp___8 = __errno_location();
#line 904
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___8, "close() \"%s\" failed",
                           to);
        }
      }
    }
  }
#line 909
  if (fd != -1) {
    {
#line 910
    tmp___11 = close(fd);
    }
#line 910
    if (tmp___11 == -1) {
#line 911
      if ((cf->log)->log_level >= 2UL) {
        {
#line 911
        tmp___10 = __errno_location();
#line 911
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___10, "close() \"%s\" failed",
                           from);
        }
      }
    }
  }
#line 916
  if (buf) {
    {
#line 917
    free((void *)buf);
    }
  }
#line 920
  return (rc);
}
}
#line 942 "/tmp/nginx-1.13.2/src/core/ngx_file.c"
ngx_int_t ngx_walk_tree(ngx_tree_ctx_t *ctx , ngx_str_t *tree ) 
{ 
  void *data ;
  void *prev ;
  u_char *p ;
  u_char *name ;
  size_t___0 len ;
  ngx_int_t rc ;
  ngx_err_t err ;
  ngx_str_t file ;
  ngx_str_t buf ;
  ngx_dir_t dir ;
  int *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  u_char *tmp___7 ;
  int *tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;
  ngx_int_t tmp___11 ;
  ngx_int_t tmp___12 ;
  ngx_int_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;

  {
  {
#line 953
  buf.len = (size_t___0 )0;
#line 953
  buf.data = (u_char *)((void *)0);
#line 958
  tmp___0 = ngx_open_dir(tree, & dir);
  }
#line 958
  if (tmp___0 == -1L) {
#line 959
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 959
      tmp = __errno_location();
#line 959
      ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp, "opendir() \"%s\" failed",
                         tree->data);
      }
    }
#line 961
    return ((ngx_int_t )-1);
  }
#line 964
  prev = ctx->data;
#line 966
  if (ctx->alloc) {
    {
#line 967
    data = ngx_alloc(ctx->alloc, ctx->log);
    }
#line 968
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 969
      goto failed;
    }
    {
#line 972
    tmp___1 = (*(ctx->init_handler))(data, prev);
    }
#line 972
    if (tmp___1 == -6L) {
#line 973
      goto failed;
    }
#line 976
    ctx->data = data;
  } else {
#line 979
    data = (void *)0;
  }
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 984
    tmp___2 = __errno_location();
#line 984
    *tmp___2 = 0;
#line 986
    tmp___4 = ngx_read_dir(& dir);
    }
#line 986
    if (tmp___4 == -1L) {
      {
#line 987
      tmp___3 = __errno_location();
#line 987
      err = *tmp___3;
      }
#line 989
      if (err == 0) {
#line 990
        rc = (ngx_int_t )0;
      } else {
#line 993
        if ((ctx->log)->log_level >= 3UL) {
          {
#line 993
          ngx_log_error_core((ngx_uint_t )3, ctx->log, err, "readdir() \"%s\" failed",
                             tree->data);
          }
        }
#line 995
        rc = (ngx_int_t )-1;
      }
#line 998
      goto done;
    }
    {
#line 1001
    len = strlen((char const   *)((dir.de)->d_name));
#line 1002
    name = (u_char *)((dir.de)->d_name);
    }
#line 1007
    if (len == 1UL) {
#line 1007
      if ((int )*(name + 0) == 46) {
#line 1008
        goto __Cont;
      }
    }
#line 1011
    if (len == 2UL) {
#line 1011
      if ((int )*(name + 0) == 46) {
#line 1011
        if ((int )*(name + 1) == 46) {
#line 1012
          goto __Cont;
        }
      }
    }
#line 1015
    file.len = (tree->len + 1UL) + len;
#line 1017
    if (file.len > buf.len) {
#line 1019
      if (buf.len) {
        {
#line 1020
        free((void *)buf.data);
        }
      }
      {
#line 1023
      buf.len = (tree->len + 1UL) + len;
#line 1025
      tmp___5 = ngx_alloc(buf.len + 1UL, ctx->log);
#line 1025
      buf.data = (u_char *)tmp___5;
      }
#line 1026
      if ((unsigned long )buf.data == (unsigned long )((void *)0)) {
#line 1027
        goto failed;
      }
    }
    {
#line 1031
    tmp___6 = memcpy((void */* __restrict  */)buf.data, (void const   */* __restrict  */)tree->data,
                     tree->len);
#line 1031
    p = (u_char *)tmp___6 + tree->len;
#line 1032
    tmp___7 = p;
#line 1032
    p ++;
#line 1032
    *tmp___7 = (u_char )'/';
#line 1033
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)name, len + 1UL);
#line 1035
    file.data = buf.data;
    }
#line 1040
    if (! dir.valid_info) {
      {
#line 1041
      tmp___9 = ngx_de_info(file.data, & dir);
      }
#line 1041
      if (tmp___9 == -1L) {
#line 1042
        if ((ctx->log)->log_level >= 3UL) {
          {
#line 1042
          tmp___8 = __errno_location();
#line 1042
          ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp___8, "stat() \"%s\" failed",
                             file.data);
          }
        }
#line 1044
        goto __Cont;
      }
    }
#line 1048
    if (dir.type) {
#line 1048
      tmp___15 = dir.type == 8U;
    } else {
#line 1048
      tmp___15 = (dir.info.st_mode & 61440U) == 32768U;
    }
#line 1048
    if (tmp___15) {
#line 1053
      ctx->size = dir.info.st_size;
#line 1054
      if (dir.info.st_size < dir.info.st_blocks * 512L) {
#line 1054
        ctx->fs_size = dir.info.st_blocks * 512L;
      } else {
#line 1054
        ctx->fs_size = dir.info.st_size;
      }
      {
#line 1055
      ctx->access = (ngx_uint_t )(dir.info.st_mode & 511U);
#line 1056
      ctx->mtime = dir.info.st_mtim.tv_sec;
#line 1058
      tmp___10 = (*(ctx->file_handler))(ctx, & file);
      }
#line 1058
      if (tmp___10 == -6L) {
#line 1059
        goto failed;
      }
    } else {
#line 1062
      if (dir.type) {
#line 1062
        tmp___14 = dir.type == 4U;
      } else {
#line 1062
        tmp___14 = (dir.info.st_mode & 61440U) == 16384U;
      }
#line 1062
      if (tmp___14) {
        {
#line 1067
        ctx->access = (ngx_uint_t )(dir.info.st_mode & 511U);
#line 1068
        ctx->mtime = dir.info.st_mtim.tv_sec;
#line 1070
        rc = (*(ctx->pre_tree_handler))(ctx, & file);
        }
#line 1072
        if (rc == -6L) {
#line 1073
          goto failed;
        }
#line 1076
        if (rc == -5L) {
#line 1079
          goto __Cont;
        }
        {
#line 1082
        tmp___11 = ngx_walk_tree(ctx, & file);
        }
#line 1082
        if (tmp___11 == -6L) {
#line 1083
          goto failed;
        }
        {
#line 1086
        ctx->access = (ngx_uint_t )(dir.info.st_mode & 511U);
#line 1087
        ctx->mtime = dir.info.st_mtim.tv_sec;
#line 1089
        tmp___12 = (*(ctx->post_tree_handler))(ctx, & file);
        }
#line 1089
        if (tmp___12 == -6L) {
#line 1090
          goto failed;
        }
      } else {
        {
#line 1098
        tmp___13 = (*(ctx->spec_handler))(ctx, & file);
        }
#line 1098
        if (tmp___13 == -6L) {
#line 1099
          goto failed;
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 1106
  rc = (ngx_int_t )-6;
  done: 
#line 1110
  if (buf.len) {
    {
#line 1111
    free((void *)buf.data);
    }
  }
#line 1114
  if (data) {
    {
#line 1115
    free(data);
#line 1116
    ctx->data = prev;
    }
  }
  {
#line 1119
  tmp___17 = closedir(dir.dir);
  }
#line 1119
  if (tmp___17 == -1) {
#line 1120
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 1120
      tmp___16 = __errno_location();
#line 1120
      ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp___16, "closedir() \"%s\" failed",
                         tree->data);
      }
    }
  }
#line 1124
  return (rc);
}
}
#line 660 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 666
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
#line 109 "src/core/ngx_inet.h"
ngx_int_t ngx_inet6_addr(u_char *p , size_t___0 len , u_char *addr ) ;
#line 110
size_t___0 ngx_inet6_ntop(u_char *p , u_char *text , size_t___0 len ) ;
#line 114
size_t___0 ngx_inet_ntop(int family , void *addr , u_char *text , size_t___0 len ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_unix_domain_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 13
static ngx_int_t ngx_parse_inet_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 14
static ngx_int_t ngx_parse_inet6_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 17 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
in_addr_t ngx_inet_addr(u_char *text , size_t___0 len ) 
{ 
  u_char *p ;
  u_char c ;
  in_addr_t addr ;
  ngx_uint_t octet ;
  ngx_uint_t n ;
  unsigned int __v ;
  unsigned int __x ;

  {
#line 24
  addr = (in_addr_t )0;
#line 25
  octet = (ngx_uint_t )0;
#line 26
  n = (ngx_uint_t )0;
#line 28
  p = text;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! ((unsigned long )p < (unsigned long )(text + len))) {
#line 28
      goto while_break;
    }
#line 29
    c = *p;
#line 31
    if ((int )c >= 48) {
#line 31
      if ((int )c <= 57) {
#line 32
        octet = octet * 10UL + (ngx_uint_t )((int )c - 48);
#line 34
        if (octet > 255UL) {
#line 35
          return (4294967295U);
        }
#line 38
        goto __Cont;
      }
    }
#line 41
    if ((int )c == 46) {
#line 42
      addr = (in_addr_t )((ngx_uint_t )(addr << 8) + octet);
#line 43
      octet = (ngx_uint_t )0;
#line 44
      n ++;
#line 45
      goto __Cont;
    }
#line 48
    return (4294967295U);
    __Cont: /* CIL Label */ 
#line 28
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if (n == 3UL) {
#line 52
    addr = (in_addr_t )((ngx_uint_t )(addr << 8) + octet);
#line 53
    __x = addr;
#line 53
    __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 53
    return (__v);
  }
#line 56
  return (4294967295U);
}
}
#line 62 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_inet6_addr(u_char *p , size_t___0 len , u_char *addr ) 
{ 
  u_char c ;
  u_char *zero___0 ;
  u_char *digit ;
  u_char *s ;
  u_char *d ;
  size_t___0 len4 ;
  ngx_uint_t n ;
  ngx_uint_t nibbles ;
  ngx_uint_t word ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  in_addr_t tmp___2 ;
  unsigned int __v ;
  unsigned int __x ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;

  {
#line 69
  if (len == 0UL) {
#line 70
    return ((ngx_int_t )-1);
  }
#line 73
  zero___0 = (u_char *)((void *)0);
#line 74
  digit = (u_char *)((void *)0);
#line 75
  len4 = (size_t___0 )0;
#line 76
  nibbles = (ngx_uint_t )0;
#line 77
  word = (ngx_uint_t )0;
#line 78
  n = (ngx_uint_t )8;
#line 80
  if ((int )*(p + 0) == 58) {
#line 81
    p ++;
#line 82
    len --;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! len) {
#line 85
      goto while_break;
    }
#line 86
    tmp = p;
#line 86
    p ++;
#line 86
    c = *tmp;
#line 88
    if ((int )c == 58) {
#line 89
      if (nibbles) {
#line 90
        digit = p;
#line 91
        len4 = len;
#line 92
        tmp___0 = addr;
#line 92
        addr ++;
#line 92
        *tmp___0 = (u_char )(word >> 8);
#line 93
        tmp___1 = addr;
#line 93
        addr ++;
#line 93
        *tmp___1 = (u_char )(word & 255UL);
#line 95
        n --;
#line 95
        if (n) {
#line 96
          nibbles = (ngx_uint_t )0;
#line 97
          word = (ngx_uint_t )0;
#line 98
          goto __Cont;
        }
      } else
#line 102
      if ((unsigned long )zero___0 == (unsigned long )((void *)0)) {
#line 103
        digit = p;
#line 104
        len4 = len;
#line 105
        zero___0 = addr;
#line 106
        goto __Cont;
      }
#line 110
      return ((ngx_int_t )-1);
    }
#line 113
    if ((int )c == 46) {
#line 113
      if (nibbles) {
#line 114
        if (n < 2UL) {
#line 115
          return ((ngx_int_t )-1);
        } else
#line 114
        if ((unsigned long )digit == (unsigned long )((void *)0)) {
#line 115
          return ((ngx_int_t )-1);
        }
        {
#line 118
        tmp___2 = ngx_inet_addr(digit, len4 - 1UL);
#line 118
        word = (ngx_uint_t )tmp___2;
        }
#line 119
        if (word == 4294967295UL) {
#line 120
          return ((ngx_int_t )-1);
        }
#line 123
        __x = (unsigned int )word;
#line 123
        __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 123
        word = (ngx_uint_t )__v;
#line 124
        tmp___3 = addr;
#line 124
        addr ++;
#line 124
        *tmp___3 = (u_char )((word >> 24) & 255UL);
#line 125
        tmp___4 = addr;
#line 125
        addr ++;
#line 125
        *tmp___4 = (u_char )((word >> 16) & 255UL);
#line 126
        n --;
#line 127
        goto while_break;
      }
    }
#line 130
    nibbles ++;
#line 130
    if (nibbles > 4UL) {
#line 131
      return ((ngx_int_t )-1);
    }
#line 134
    if ((int )c >= 48) {
#line 134
      if ((int )c <= 57) {
#line 135
        word = word * 16UL + (ngx_uint_t )((int )c - 48);
#line 136
        goto __Cont;
      }
    }
#line 139
    c = (u_char )((int )c | 32);
#line 141
    if ((int )c >= 97) {
#line 141
      if ((int )c <= 102) {
#line 142
        word = (word * 16UL + (ngx_uint_t )((int )c - 97)) + 10UL;
#line 143
        goto __Cont;
      }
    }
#line 146
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ 
#line 85
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (nibbles == 0UL) {
#line 149
    if ((unsigned long )zero___0 == (unsigned long )((void *)0)) {
#line 150
      return ((ngx_int_t )-1);
    }
  }
#line 153
  tmp___5 = addr;
#line 153
  addr ++;
#line 153
  *tmp___5 = (u_char )(word >> 8);
#line 154
  tmp___6 = addr;
#line 154
  addr ++;
#line 154
  *tmp___6 = (u_char )(word & 255UL);
#line 156
  n --;
#line 156
  if (n) {
#line 157
    if (zero___0) {
#line 158
      n *= 2UL;
#line 159
      s = addr - 1;
#line 160
      d = s + n;
      {
#line 161
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 161
        if (! ((unsigned long )s >= (unsigned long )zero___0)) {
#line 161
          goto while_break___0;
        }
#line 162
        tmp___7 = d;
#line 162
        d --;
#line 162
        tmp___8 = s;
#line 162
        s --;
#line 162
        *tmp___7 = *tmp___8;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 164
      memset((void *)zero___0, 0, n);
      }
#line 165
      return ((ngx_int_t )0);
    }
  } else
#line 169
  if ((unsigned long )zero___0 == (unsigned long )((void *)0)) {
#line 170
    return ((ngx_int_t )0);
  }
#line 174
  return ((ngx_int_t )-1);
}
}
#line 180 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
size_t___0 ngx_sock_ntop(struct sockaddr *sa , socklen_t socklen , u_char *text ,
                         size_t___0 len , ngx_uint_t port ) 
{ 
  u_char *p ;
  struct sockaddr_in *sin ;
  size_t___0 n ;
  struct sockaddr_in6 *sin6 ;
  struct sockaddr_un *saun ;
  unsigned short __v ;
  unsigned short __x ;
  size_t___0 tmp ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;
  u_char *tmp___0 ;

  {
  {
#line 196
  if ((int )sa->sa_family == 2) {
#line 196
    goto case_2;
  }
#line 213
  if ((int )sa->sa_family == 10) {
#line 213
    goto case_10;
  }
#line 235
  if ((int )sa->sa_family == 1) {
#line 235
    goto case_1;
  }
#line 253
  goto switch_default;
  case_2: /* CIL Label */ 
#line 198
  sin = (struct sockaddr_in *)sa;
#line 199
  p = (u_char *)(& sin->sin_addr);
#line 201
  if (port) {
    {
#line 203
    __x = sin->sin_port;
#line 203
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 203
    p = ngx_snprintf(text, len, "%ud.%ud.%ud.%ud:%d", (int )*(p + 0), (int )*(p + 1),
                     (int )*(p + 2), (int )*(p + 3), (int )__v);
    }
  } else {
    {
#line 205
    p = ngx_snprintf(text, len, "%ud.%ud.%ud.%ud", (int )*(p + 0), (int )*(p + 1),
                     (int )*(p + 2), (int )*(p + 3));
    }
  }
#line 209
  return ((size_t___0 )(p - text));
  case_10: /* CIL Label */ 
#line 215
  sin6 = (struct sockaddr_in6 *)sa;
#line 217
  n = (size_t___0 )0;
#line 219
  if (port) {
#line 220
    tmp = n;
#line 220
    n ++;
#line 220
    *(text + tmp) = (u_char )'[';
  }
  {
#line 223
  n = ngx_inet6_ntop(sin6->sin6_addr.__in6_u.__u6_addr8, text + n, len);
  }
#line 225
  if (port) {
    {
#line 227
    __x___0 = sin6->sin6_port;
#line 227
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 227
    tmp___0 = ngx_sprintf(text + (1UL + n), "]:%d", (int )__v___0);
#line 227
    n = (size_t___0 )(tmp___0 - text);
    }
  }
#line 230
  return (n);
  case_1: /* CIL Label */ 
#line 236
  saun = (struct sockaddr_un *)sa;
#line 240
  if (socklen <= (socklen_t )((unsigned long )(& ((struct sockaddr_un *)0)->sun_path))) {
    {
#line 241
    p = ngx_snprintf(text, len, "unix:%Z");
    }
  } else {
    {
#line 244
    p = ngx_snprintf(text, len, "unix:%s%Z", saun->sun_path);
    }
  }
#line 249
  return ((size_t___0 )((p - text) - 1L));
  switch_default: /* CIL Label */ 
#line 254
  return ((size_t___0 )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 259 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
size_t___0 ngx_inet_ntop(int family , void *addr , u_char *text , size_t___0 len ) 
{ 
  u_char *p ;
  u_char *tmp ;
  size_t___0 tmp___0 ;

  {
  {
#line 266
  if (family == 2) {
#line 266
    goto case_2;
  }
#line 276
  if (family == 10) {
#line 276
    goto case_10;
  }
#line 281
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 268
  p = (u_char *)addr;
#line 270
  tmp = ngx_snprintf(text, len, "%ud.%ud.%ud.%ud", (int )*(p + 0), (int )*(p + 1),
                     (int )*(p + 2), (int )*(p + 3));
  }
#line 270
  return ((size_t___0 )(tmp - text));
  case_10: /* CIL Label */ 
  {
#line 277
  tmp___0 = ngx_inet6_ntop((u_char *)addr, text, len);
  }
#line 277
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 282
  return ((size_t___0 )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 289 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
size_t___0 ngx_inet6_ntop(u_char *p , u_char *text , size_t___0 len ) 
{ 
  u_char *dst ;
  size_t___0 max ;
  size_t___0 n ;
  ngx_uint_t i ;
  ngx_uint_t zero___0 ;
  ngx_uint_t last ;
  size_t___0 tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 296
  if (len < sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL) {
#line 297
    return ((size_t___0 )0);
  }
#line 300
  zero___0 = (ngx_uint_t )-1;
#line 301
  last = (ngx_uint_t )-1;
#line 302
  max = (size_t___0 )1;
#line 303
  n = (size_t___0 )0;
#line 305
  i = (ngx_uint_t )0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < 16UL)) {
#line 305
      goto while_break;
    }
#line 307
    if (*(p + i)) {
#line 307
      goto _L;
    } else
#line 307
    if (*(p + (i + 1UL))) {
      _L: /* CIL Label */ 
#line 309
      if (max < n) {
#line 310
        zero___0 = last;
#line 311
        max = n;
      }
#line 314
      n = (size_t___0 )0;
#line 315
      goto __Cont;
    }
#line 318
    tmp = n;
#line 318
    n ++;
#line 318
    if (tmp == 0UL) {
#line 319
      last = i;
    }
    __Cont: /* CIL Label */ 
#line 305
    i += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  if (max < n) {
#line 324
    zero___0 = last;
#line 325
    max = n;
  }
#line 328
  dst = text;
#line 329
  n = (size_t___0 )16;
#line 331
  if (zero___0 == 0UL) {
#line 333
    if (max == 5UL) {
#line 333
      if ((int )*(p + 10) == 255) {
#line 333
        if ((int )*(p + 11) == 255) {
#line 337
          n = (size_t___0 )12;
        } else {
#line 333
          goto _L___1;
        }
      } else {
#line 333
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 333
    if (max == 6UL) {
#line 337
      n = (size_t___0 )12;
    } else
#line 333
    if (max == 7UL) {
#line 333
      if ((int )*(p + 14) != 0) {
#line 333
        if ((int )*(p + 15) != 1) {
#line 337
          n = (size_t___0 )12;
        }
      }
    }
#line 340
    tmp___0 = dst;
#line 340
    dst ++;
#line 340
    *tmp___0 = (u_char )':';
  }
#line 343
  i = (ngx_uint_t )0;
  {
#line 343
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 343
    if (! (i < n)) {
#line 343
      goto while_break___0;
    }
#line 345
    if (i == zero___0) {
#line 346
      tmp___1 = dst;
#line 346
      dst ++;
#line 346
      *tmp___1 = (u_char )':';
#line 347
      i += (max - 1UL) * 2UL;
#line 348
      goto __Cont___0;
    }
    {
#line 351
    dst = ngx_sprintf(dst, "%xd", (int )*(p + i) * 256 + (int )*(p + (i + 1UL)));
    }
#line 353
    if (i < 14UL) {
#line 354
      tmp___2 = dst;
#line 354
      dst ++;
#line 354
      *tmp___2 = (u_char )':';
    }
    __Cont___0: /* CIL Label */ 
#line 343
    i += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 358
  if (n == 12UL) {
    {
#line 359
    dst = ngx_sprintf(dst, "%ud.%ud.%ud.%ud", (int )*(p + 12), (int )*(p + 13), (int )*(p + 14),
                      (int )*(p + 15));
    }
  }
#line 362
  return ((size_t___0 )(dst - text));
}
}
#line 368 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_ptocidr(ngx_str_t *text , ngx_cidr_t *cidr ) 
{ 
  u_char *addr ;
  u_char *mask ;
  u_char *last ;
  size_t___0 len ;
  ngx_int_t shift ;
  ngx_int_t rc ;
  ngx_uint_t s ;
  ngx_uint_t i ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  unsigned int __v ;
  unsigned int __x ;

  {
  {
#line 379
  addr = text->data;
#line 380
  last = addr + text->len;
#line 382
  mask = ngx_strlchr(addr, last, (u_char )'/');
  }
#line 383
  if (mask) {
#line 383
    tmp = mask;
  } else {
#line 383
    tmp = last;
  }
  {
#line 383
  len = (size_t___0 )(tmp - addr);
#line 385
  cidr->u.in.addr = ngx_inet_addr(addr, len);
  }
#line 387
  if (cidr->u.in.addr != 4294967295U) {
#line 388
    cidr->family = (ngx_uint_t )2;
#line 390
    if ((unsigned long )mask == (unsigned long )((void *)0)) {
#line 391
      cidr->u.in.mask = 4294967295U;
#line 392
      return ((ngx_int_t )0);
    }
  } else {
    {
#line 396
    tmp___0 = ngx_inet6_addr(addr, len, cidr->u.in6.addr.__in6_u.__u6_addr8);
    }
#line 396
    if (tmp___0 == 0L) {
#line 397
      cidr->family = (ngx_uint_t )10;
#line 399
      if ((unsigned long )mask == (unsigned long )((void *)0)) {
        {
#line 400
        memset((void *)(cidr->u.in6.mask.__in6_u.__u6_addr8), 255, (size_t )16);
        }
#line 401
        return ((ngx_int_t )0);
      }
    } else {
#line 406
      return ((ngx_int_t )-1);
    }
  }
  {
#line 409
  mask ++;
#line 411
  shift = ngx_atoi(mask, (size_t___0 )(last - mask));
  }
#line 412
  if (shift == -1L) {
#line 413
    return ((ngx_int_t )-1);
  }
  {
#line 419
  if (cidr->family == 10UL) {
#line 419
    goto case_10;
  }
#line 444
  goto switch_default;
  case_10: /* CIL Label */ 
#line 420
  if (shift > 128L) {
#line 421
    return ((ngx_int_t )-1);
  }
#line 424
  addr = cidr->u.in6.addr.__in6_u.__u6_addr8;
#line 425
  mask = cidr->u.in6.mask.__in6_u.__u6_addr8;
#line 426
  rc = (ngx_int_t )0;
#line 428
  i = (ngx_uint_t )0;
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < 16UL)) {
#line 428
      goto while_break;
    }
#line 430
    if (shift > 8L) {
#line 430
      s = (ngx_uint_t )8;
    } else {
#line 430
      s = (ngx_uint_t )shift;
    }
#line 431
    shift = (ngx_int_t )((ngx_uint_t )shift - s);
#line 433
    *(mask + i) = (u_char )(255U << (8UL - s));
#line 435
    if ((int )*(addr + i) != ((int )*(addr + i) & (int )*(mask + i))) {
#line 436
      rc = (ngx_int_t )-4;
#line 437
      *(addr + i) = (u_char )((int )*(addr + i) & (int )*(mask + i));
    }
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 441
  return (rc);
  switch_default: /* CIL Label */ 
#line 445
  if (shift > 32L) {
#line 446
    return ((ngx_int_t )-1);
  }
#line 449
  if (shift) {
#line 450
    __x = 4294967295U << (32L - shift);
#line 450
    __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 450
    cidr->u.in.mask = __v;
  } else {
#line 454
    cidr->u.in.mask = (in_addr_t )0;
  }
#line 457
  if (cidr->u.in.addr == (cidr->u.in.addr & cidr->u.in.mask)) {
#line 458
    return ((ngx_int_t )0);
  }
#line 461
  cidr->u.in.addr &= cidr->u.in.mask;
#line 463
  return ((ngx_int_t )-4);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 468 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_cidr_match(struct sockaddr *sa , ngx_array_t *cidrs ) 
{ 
  u_char *p ;
  in_addr_t inaddr ;
  ngx_cidr_t *cidr ;
  ngx_uint_t family ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  struct in6_addr *inaddr6 ;
  unsigned int __v ;
  unsigned int __x ;
  struct in6_addr  const  *__a ;
  unsigned int __v___0 ;
  unsigned int __x___0 ;
  int tmp ;

  {
#line 483
  inaddr = (in_addr_t )0;
#line 485
  inaddr6 = (struct in6_addr *)((void *)0);
#line 489
  family = (ngx_uint_t )sa->sa_family;
#line 491
  if (family == 2UL) {
#line 492
    inaddr = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
  } else
#line 496
  if (family == 10UL) {
#line 497
    inaddr6 = & ((struct sockaddr_in6 *)sa)->sin6_addr;
#line 499
    __a = (struct in6_addr  const  *)inaddr6;
#line 499
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 499
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 499
        __x___0 = 65535U;
#line 499
        __asm__  ("bswap %0": "=r" (__v___0): "0" (__x___0));
#line 499
        if (__a->__in6_u.__u6_addr32[2] == __v___0) {
#line 499
          tmp = 1;
        } else {
#line 499
          tmp = 0;
        }
      } else {
#line 499
        tmp = 0;
      }
    } else {
#line 499
      tmp = 0;
    }
#line 499
    if (tmp) {
#line 500
      family = (ngx_uint_t )2;
#line 502
      p = inaddr6->__in6_u.__u6_addr8;
#line 504
      inaddr = (in_addr_t )((int )*(p + 12) << 24);
#line 505
      inaddr += (in_addr_t )((int )*(p + 13) << 16);
#line 506
      inaddr += (in_addr_t )((int )*(p + 14) << 8);
#line 507
      inaddr += (in_addr_t )*(p + 15);
#line 509
      __x = inaddr;
#line 509
      __asm__  ("bswap %0": "=r" (__v): "0" (__x));
#line 509
      inaddr = __v;
    }
  }
#line 514
  cidr = (ngx_cidr_t *)cidrs->elts;
#line 514
  i = (ngx_uint_t )0;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! (i < cidrs->nelts)) {
#line 514
      goto while_break;
    }
#line 515
    if ((cidr + i)->family != family) {
#line 516
      goto next;
    }
    {
#line 522
    if (family == 10UL) {
#line 522
      goto case_10;
    }
#line 534
    if (family == 1UL) {
#line 534
      goto case_1;
    }
#line 538
    goto switch_default;
    case_10: /* CIL Label */ 
#line 523
    n = (ngx_uint_t )0;
    {
#line 523
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 523
      if (! (n < 16UL)) {
#line 523
        goto while_break___0;
      }
#line 524
      if (((int )inaddr6->__in6_u.__u6_addr8[n] & (int )(cidr + i)->u.in6.mask.__in6_u.__u6_addr8[n]) != (int )(cidr + i)->u.in6.addr.__in6_u.__u6_addr8[n]) {
#line 527
        goto next;
      }
#line 523
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 530
    goto switch_break;
    case_1: /* CIL Label */ 
#line 535
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 539
    if ((inaddr & (cidr + i)->u.in.mask) != (cidr + i)->u.in.addr) {
#line 540
      goto next;
    }
#line 542
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 545
    return ((ngx_int_t )0);
    next: 
#line 548
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 514
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 551
  return ((ngx_int_t )-5);
}
}
#line 555 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_parse_addr(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text , size_t___0 len ) 
{ 
  in_addr_t inaddr ;
  ngx_uint_t family ;
  struct sockaddr_in *sin ;
  struct in6_addr inaddr6 ;
  struct sockaddr_in6 *sin6 ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
  {
#line 569
  memset((void *)(& inaddr6), 0, sizeof(struct in6_addr ));
#line 572
  inaddr = ngx_inet_addr(text, len);
  }
#line 574
  if (inaddr != 4294967295U) {
#line 575
    family = (ngx_uint_t )2;
#line 576
    len = sizeof(struct sockaddr_in );
  } else {
    {
#line 579
    tmp = ngx_inet6_addr(text, len, inaddr6.__in6_u.__u6_addr8);
    }
#line 579
    if (tmp == 0L) {
#line 580
      family = (ngx_uint_t )10;
#line 581
      len = sizeof(struct sockaddr_in6 );
    } else {
#line 585
      return ((ngx_int_t )-5);
    }
  }
  {
#line 588
  tmp___0 = ngx_pcalloc(pool, len);
#line 588
  addr->sockaddr = (struct sockaddr *)tmp___0;
  }
#line 589
  if ((unsigned long )addr->sockaddr == (unsigned long )((void *)0)) {
#line 590
    return ((ngx_int_t )-1);
  }
#line 593
  (addr->sockaddr)->sa_family = (sa_family_t )((u_char )family);
#line 594
  addr->socklen = (socklen_t )len;
  {
#line 599
  if (family == 10UL) {
#line 599
    goto case_10;
  }
#line 605
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 600
  sin6 = (struct sockaddr_in6 *)addr->sockaddr;
#line 601
  memcpy((void */* __restrict  */)(sin6->sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(inaddr6.__in6_u.__u6_addr8),
         (size_t )16);
  }
#line 602
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 606
  sin = (struct sockaddr_in *)addr->sockaddr;
#line 607
  sin->sin_addr.s_addr = inaddr;
#line 608
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 611
  return ((ngx_int_t )0);
}
}
#line 615 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_parse_addr_port(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text ,
                              size_t___0 len ) 
{ 
  u_char *p ;
  u_char *last ;
  size_t___0 plen ;
  ngx_int_t rc ;
  ngx_int_t port ;

  {
  {
#line 623
  rc = ngx_parse_addr(pool, addr, text, len);
  }
#line 625
  if (rc != -5L) {
#line 626
    return (rc);
  }
#line 629
  last = text + len;
#line 632
  if (len) {
#line 632
    if ((int )*(text + 0) == 91) {
      {
#line 634
      p = ngx_strlchr(text, last, (u_char )']');
      }
#line 636
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 637
        return ((ngx_int_t )-5);
      } else
#line 636
      if ((unsigned long )p == (unsigned long )(last - 1)) {
#line 637
        return ((ngx_int_t )-5);
      } else {
#line 636
        p ++;
#line 636
        if ((int )*p != 58) {
#line 637
          return ((ngx_int_t )-5);
        }
      }
#line 640
      text ++;
#line 641
      len -= 2UL;
    } else {
#line 632
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 647
    p = ngx_strlchr(text, last, (u_char )':');
    }
#line 649
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 650
      return ((ngx_int_t )-5);
    }
  }
  {
#line 654
  p ++;
#line 655
  plen = (size_t___0 )(last - p);
#line 657
  port = ngx_atoi(p, plen);
  }
#line 659
  if (port < 1L) {
#line 660
    return ((ngx_int_t )-5);
  } else
#line 659
  if (port > 65535L) {
#line 660
    return ((ngx_int_t )-5);
  }
  {
#line 663
  len -= plen + 1UL;
#line 665
  rc = ngx_parse_addr(pool, addr, text, len);
  }
#line 667
  if (rc != 0L) {
#line 668
    return (rc);
  }
  {
#line 671
  ngx_inet_set_port(addr->sockaddr, (in_port_t )port);
  }
#line 673
  return ((ngx_int_t )0);
}
}
#line 677 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_parse_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  size_t___0 len ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 683
  p = u->url.data;
#line 684
  len = u->url.len;
#line 686
  if (len >= 5UL) {
    {
#line 686
    tmp___0 = ngx_strncasecmp(p, (u_char *)"unix:", (size_t___0 )5);
    }
#line 686
    if (tmp___0 == 0L) {
      {
#line 687
      tmp = ngx_parse_unix_domain_url(pool, u);
      }
#line 687
      return (tmp);
    }
  }
#line 690
  if (len) {
#line 690
    if ((int )*(p + 0) == 91) {
      {
#line 691
      tmp___1 = ngx_parse_inet6_url(pool, u);
      }
#line 691
      return (tmp___1);
    }
  }
  {
#line 694
  tmp___2 = ngx_parse_inet_url(pool, u);
  }
#line 694
  return (tmp___2);
}
}
#line 698 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_unix_domain_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *path ;
  u_char *uri___0 ;
  u_char *last ;
  size_t___0 len ;
  struct sockaddr_un *saun ;
  size_t___0 tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 706
  len = u->url.len;
#line 707
  path = u->url.data;
#line 709
  path += 5;
#line 710
  len -= 5UL;
#line 712
  if (u->uri_part) {
    {
#line 714
    last = path + len;
#line 715
    uri___0 = ngx_strlchr(path, last, (u_char )':');
    }
#line 717
    if (uri___0) {
#line 718
      len = (size_t___0 )(uri___0 - path);
#line 719
      uri___0 ++;
#line 720
      u->uri.len = (size_t___0 )(last - uri___0);
#line 721
      u->uri.data = uri___0;
    }
  }
#line 725
  if (len == 0UL) {
#line 726
    u->err = (char *)"no path in the unix domain socket";
#line 727
    return ((ngx_int_t )-1);
  }
#line 730
  tmp = len;
#line 730
  len ++;
#line 730
  u->host.len = tmp;
#line 731
  u->host.data = path;
#line 733
  if (len > sizeof(saun->sun_path)) {
#line 734
    u->err = (char *)"too long path in the unix domain socket";
#line 735
    return ((ngx_int_t )-1);
  }
  {
#line 738
  u->socklen = (socklen_t )sizeof(struct sockaddr_un );
#line 739
  saun = (struct sockaddr_un *)(& u->sockaddr);
#line 740
  saun->sun_family = (sa_family_t )1;
#line 741
  ngx_cpystrn((u_char *)(saun->sun_path), path, len);
#line 743
  tmp___0 = ngx_pcalloc(pool, sizeof(ngx_addr_t ));
#line 743
  u->addrs = (ngx_addr_t *)tmp___0;
  }
#line 744
  if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 745
    return ((ngx_int_t )-1);
  }
  {
#line 748
  tmp___1 = ngx_pcalloc(pool, sizeof(struct sockaddr_un ));
#line 748
  saun = (struct sockaddr_un *)tmp___1;
  }
#line 749
  if ((unsigned long )saun == (unsigned long )((void *)0)) {
#line 750
    return ((ngx_int_t )-1);
  }
  {
#line 753
  u->family = 1;
#line 754
  u->naddrs = (ngx_uint_t )1;
#line 756
  saun->sun_family = (sa_family_t )1;
#line 757
  ngx_cpystrn((u_char *)(saun->sun_path), path, len);
#line 759
  (u->addrs + 0)->sockaddr = (struct sockaddr *)saun;
#line 760
  (u->addrs + 0)->socklen = (socklen_t )sizeof(struct sockaddr_un );
#line 761
  (u->addrs + 0)->name.len = len + 4UL;
#line 762
  (u->addrs + 0)->name.data = u->url.data;
  }
#line 764
  return ((ngx_int_t )0);
}
}
#line 776 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_inet_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  u_char *host ;
  u_char *port ;
  u_char *last ;
  u_char *uri___0 ;
  u_char *args___0 ;
  size_t___0 len ;
  ngx_int_t n ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;
  unsigned short __v___1 ;
  unsigned short __x___1 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  struct in6_addr  const  *__a ;
  int tmp___4 ;

  {
  {
#line 787
  u->socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 788
  sin = (struct sockaddr_in *)(& u->sockaddr);
#line 789
  sin->sin_family = (sa_family_t )2;
#line 791
  u->family = 2;
#line 793
  host = u->url.data;
#line 795
  last = host + u->url.len;
#line 797
  port = ngx_strlchr(host, last, (u_char )':');
#line 799
  uri___0 = ngx_strlchr(host, last, (u_char )'/');
#line 801
  args___0 = ngx_strlchr(host, last, (u_char )'?');
  }
#line 803
  if (args___0) {
#line 804
    if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 805
      uri___0 = args___0;
    } else
#line 804
    if ((unsigned long )args___0 < (unsigned long )uri___0) {
#line 805
      uri___0 = args___0;
    }
  }
#line 809
  if (uri___0) {
#line 810
    if (u->listen) {
#line 811
      u->err = (char *)"invalid host";
#line 812
      return ((ngx_int_t )-1);
    } else
#line 810
    if (! u->uri_part) {
#line 811
      u->err = (char *)"invalid host";
#line 812
      return ((ngx_int_t )-1);
    }
#line 815
    u->uri.len = (size_t___0 )(last - uri___0);
#line 816
    u->uri.data = uri___0;
#line 818
    last = uri___0;
#line 820
    if ((unsigned long )uri___0 < (unsigned long )port) {
#line 821
      port = (u_char *)((void *)0);
    }
  }
#line 825
  if (port) {
    {
#line 826
    port ++;
#line 828
    len = (size_t___0 )(last - port);
#line 830
    n = ngx_atoi(port, len);
    }
#line 832
    if (n < 1L) {
#line 833
      u->err = (char *)"invalid port";
#line 834
      return ((ngx_int_t )-1);
    } else
#line 832
    if (n > 65535L) {
#line 833
      u->err = (char *)"invalid port";
#line 834
      return ((ngx_int_t )-1);
    }
#line 837
    u->port = (in_port_t )n;
#line 838
    __x = (in_port_t )n;
#line 838
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 838
    sin->sin_port = __v;
#line 840
    u->port_text.len = len;
#line 841
    u->port_text.data = port;
#line 843
    last = port - 1;
  } else {
#line 846
    if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 848
      if (u->listen) {
        {
#line 852
        n = ngx_atoi(host, (size_t___0 )(last - host));
        }
#line 854
        if (n != -1L) {
#line 856
          if (n < 1L) {
#line 857
            u->err = (char *)"invalid port";
#line 858
            return ((ngx_int_t )-1);
          } else
#line 856
          if (n > 65535L) {
#line 857
            u->err = (char *)"invalid port";
#line 858
            return ((ngx_int_t )-1);
          }
#line 861
          u->port = (in_port_t )n;
#line 862
          __x___0 = (in_port_t )n;
#line 862
          __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 862
          sin->sin_port = __v___0;
#line 864
          u->port_text.len = (size_t___0 )(last - host);
#line 865
          u->port_text.data = host;
#line 867
          u->wildcard = 1U;
#line 869
          return ((ngx_int_t )0);
        }
      }
    }
#line 874
    u->no_port = 1U;
#line 875
    u->port = u->default_port;
#line 876
    __x___1 = u->default_port;
#line 876
    __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 876
    sin->sin_port = __v___1;
  }
#line 879
  len = (size_t___0 )(last - host);
#line 881
  if (len == 0UL) {
#line 882
    u->err = (char *)"no host";
#line 883
    return ((ngx_int_t )-1);
  }
#line 886
  u->host.len = len;
#line 887
  u->host.data = host;
#line 889
  if (u->listen) {
#line 889
    if (len == 1UL) {
#line 889
      if ((int )*host == 42) {
#line 890
        sin->sin_addr.s_addr = (in_addr_t )0;
#line 891
        u->wildcard = 1U;
#line 892
        return ((ngx_int_t )0);
      }
    }
  }
  {
#line 895
  sin->sin_addr.s_addr = ngx_inet_addr(host, len);
  }
#line 897
  if (sin->sin_addr.s_addr != 4294967295U) {
#line 899
    if (sin->sin_addr.s_addr == 0U) {
#line 900
      u->wildcard = 1U;
    }
    {
#line 903
    u->naddrs = (ngx_uint_t )1;
#line 905
    tmp = ngx_pcalloc(pool, sizeof(ngx_addr_t ));
#line 905
    u->addrs = (ngx_addr_t *)tmp;
    }
#line 906
    if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 907
      return ((ngx_int_t )-1);
    }
    {
#line 910
    tmp___0 = ngx_pcalloc(pool, sizeof(struct sockaddr_in ));
#line 910
    sin = (struct sockaddr_in *)tmp___0;
    }
#line 911
    if ((unsigned long )sin == (unsigned long )((void *)0)) {
#line 912
      return ((ngx_int_t )-1);
    }
    {
#line 915
    memcpy((void */* __restrict  */)sin, (void const   */* __restrict  */)(& u->sockaddr),
           sizeof(struct sockaddr_in ));
#line 917
    (u->addrs + 0)->sockaddr = (struct sockaddr *)sin;
#line 918
    (u->addrs + 0)->socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 920
    tmp___1 = ngx_pnalloc(pool, (u->host.len + sizeof(":65535")) - 1UL);
#line 920
    p = (u_char *)tmp___1;
    }
#line 921
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 922
      return ((ngx_int_t )-1);
    }
    {
#line 925
    tmp___2 = ngx_sprintf(p, "%V:%d", & u->host, (int )u->port);
#line 925
    (u->addrs + 0)->name.len = (size_t___0 )(tmp___2 - p);
#line 927
    (u->addrs + 0)->name.data = p;
    }
#line 929
    return ((ngx_int_t )0);
  }
#line 932
  if (u->no_resolve) {
#line 933
    return ((ngx_int_t )0);
  }
  {
#line 936
  tmp___3 = ngx_inet_resolve_host(pool, u);
  }
#line 936
  if (tmp___3 != 0L) {
#line 937
    return ((ngx_int_t )-1);
  }
  {
#line 940
  u->family = (int )((u->addrs + 0)->sockaddr)->sa_family;
#line 941
  u->socklen = (u->addrs + 0)->socklen;
#line 942
  memcpy((void */* __restrict  */)(& u->sockaddr), (void const   */* __restrict  */)(u->addrs + 0)->sockaddr,
         (size_t )(u->addrs + 0)->socklen);
  }
  {
#line 947
  if (u->family == 10) {
#line 947
    goto case_10;
  }
#line 957
  goto switch_default;
  case_10: /* CIL Label */ 
#line 948
  sin6 = (struct sockaddr_in6 *)(& u->sockaddr);
#line 950
  __a = (struct in6_addr  const  *)(& sin6->sin6_addr);
#line 950
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 950
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 950
      if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 950
        if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 950
          tmp___4 = 1;
        } else {
#line 950
          tmp___4 = 0;
        }
      } else {
#line 950
        tmp___4 = 0;
      }
    } else {
#line 950
      tmp___4 = 0;
    }
  } else {
#line 950
    tmp___4 = 0;
  }
#line 950
  if (tmp___4) {
#line 951
    u->wildcard = 1U;
  }
#line 954
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 958
  sin = (struct sockaddr_in *)(& u->sockaddr);
#line 960
  if (sin->sin_addr.s_addr == 0U) {
#line 961
    u->wildcard = 1U;
  }
#line 964
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 967
  return ((ngx_int_t )0);
}
}
#line 971 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_inet6_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  u_char *host ;
  u_char *port ;
  u_char *last ;
  u_char *uri___0 ;
  size_t___0 len ;
  ngx_int_t n ;
  struct sockaddr_in6 *sin6 ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;
  ngx_int_t tmp ;
  struct in6_addr  const  *__a ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;

  {
  {
#line 980
  u->socklen = (socklen_t )sizeof(struct sockaddr_in6 );
#line 981
  sin6 = (struct sockaddr_in6 *)(& u->sockaddr);
#line 982
  sin6->sin6_family = (sa_family_t )10;
#line 984
  host = u->url.data + 1;
#line 986
  last = u->url.data + u->url.len;
#line 988
  p = ngx_strlchr(host, last, (u_char )']');
  }
#line 990
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 991
    u->err = (char *)"invalid host";
#line 992
    return ((ngx_int_t )-1);
  }
  {
#line 995
  port = p + 1;
#line 997
  uri___0 = ngx_strlchr(port, last, (u_char )'/');
  }
#line 999
  if (uri___0) {
#line 1000
    if (u->listen) {
#line 1001
      u->err = (char *)"invalid host";
#line 1002
      return ((ngx_int_t )-1);
    } else
#line 1000
    if (! u->uri_part) {
#line 1001
      u->err = (char *)"invalid host";
#line 1002
      return ((ngx_int_t )-1);
    }
#line 1005
    u->uri.len = (size_t___0 )(last - uri___0);
#line 1006
    u->uri.data = uri___0;
#line 1008
    last = uri___0;
  }
#line 1011
  if ((unsigned long )port < (unsigned long )last) {
#line 1012
    if ((int )*port != 58) {
#line 1013
      u->err = (char *)"invalid host";
#line 1014
      return ((ngx_int_t )-1);
    }
    {
#line 1017
    port ++;
#line 1019
    len = (size_t___0 )(last - port);
#line 1021
    n = ngx_atoi(port, len);
    }
#line 1023
    if (n < 1L) {
#line 1024
      u->err = (char *)"invalid port";
#line 1025
      return ((ngx_int_t )-1);
    } else
#line 1023
    if (n > 65535L) {
#line 1024
      u->err = (char *)"invalid port";
#line 1025
      return ((ngx_int_t )-1);
    }
#line 1028
    u->port = (in_port_t )n;
#line 1029
    __x = (in_port_t )n;
#line 1029
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1029
    sin6->sin6_port = __v;
#line 1031
    u->port_text.len = len;
#line 1032
    u->port_text.data = port;
  } else {
#line 1035
    u->no_port = 1U;
#line 1036
    u->port = u->default_port;
#line 1037
    __x___0 = u->default_port;
#line 1037
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1037
    sin6->sin6_port = __v___0;
  }
#line 1040
  len = (size_t___0 )(p - host);
#line 1042
  if (len == 0UL) {
#line 1043
    u->err = (char *)"no host";
#line 1044
    return ((ngx_int_t )-1);
  }
  {
#line 1047
  u->host.len = len + 2UL;
#line 1048
  u->host.data = host - 1;
#line 1050
  tmp = ngx_inet6_addr(host, len, sin6->sin6_addr.__in6_u.__u6_addr8);
  }
#line 1050
  if (tmp != 0L) {
#line 1051
    u->err = (char *)"invalid IPv6 address";
#line 1052
    return ((ngx_int_t )-1);
  }
#line 1055
  __a = (struct in6_addr  const  *)(& sin6->sin6_addr);
#line 1055
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 1055
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 1055
      if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 1055
        if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 1055
          tmp___0 = 1;
        } else {
#line 1055
          tmp___0 = 0;
        }
      } else {
#line 1055
        tmp___0 = 0;
      }
    } else {
#line 1055
      tmp___0 = 0;
    }
  } else {
#line 1055
    tmp___0 = 0;
  }
#line 1055
  if (tmp___0) {
#line 1056
    u->wildcard = 1U;
  }
  {
#line 1059
  u->family = 10;
#line 1060
  u->naddrs = (ngx_uint_t )1;
#line 1062
  tmp___1 = ngx_pcalloc(pool, sizeof(ngx_addr_t ));
#line 1062
  u->addrs = (ngx_addr_t *)tmp___1;
  }
#line 1063
  if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 1064
    return ((ngx_int_t )-1);
  }
  {
#line 1067
  tmp___2 = ngx_pcalloc(pool, sizeof(struct sockaddr_in6 ));
#line 1067
  sin6 = (struct sockaddr_in6 *)tmp___2;
  }
#line 1068
  if ((unsigned long )sin6 == (unsigned long )((void *)0)) {
#line 1069
    return ((ngx_int_t )-1);
  }
  {
#line 1072
  memcpy((void */* __restrict  */)sin6, (void const   */* __restrict  */)(& u->sockaddr),
         sizeof(struct sockaddr_in6 ));
#line 1074
  (u->addrs + 0)->sockaddr = (struct sockaddr *)sin6;
#line 1075
  (u->addrs + 0)->socklen = (socklen_t )sizeof(struct sockaddr_in6 );
#line 1077
  tmp___3 = ngx_pnalloc(pool, (u->host.len + sizeof(":65535")) - 1UL);
#line 1077
  p = (u_char *)tmp___3;
  }
#line 1078
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1079
    return ((ngx_int_t )-1);
  }
  {
#line 1082
  tmp___4 = ngx_sprintf(p, "%V:%d", & u->host, (int )u->port);
#line 1082
  (u->addrs + 0)->name.len = (size_t___0 )(tmp___4 - p);
#line 1084
  (u->addrs + 0)->name.data = p;
  }
#line 1086
  return ((ngx_int_t )0);
}
}
#line 1100 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_inet_resolve_host(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  u_char *host ;
  size_t___0 len ;
  in_port_t port ;
  ngx_uint_t i ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *rp ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  unsigned short __v ;
  unsigned short __x ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 1111
  __x = u->port;
#line 1111
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1111
  port = __v;
#line 1113
  tmp = ngx_alloc(u->host.len + 1UL, pool->log);
#line 1113
  host = (u_char *)tmp;
  }
#line 1114
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1115
    return ((ngx_int_t )-1);
  }
  {
#line 1118
  ngx_cpystrn(host, u->host.data, u->host.len + 1UL);
#line 1120
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 1121
  hints.ai_family = 0;
#line 1122
  hints.ai_socktype = 1;
#line 1124
  hints.ai_flags = 32;
#line 1127
  tmp___0 = getaddrinfo((char const   */* __restrict  */)((char *)host), (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 1127
  if (tmp___0 != 0) {
    {
#line 1128
    u->err = (char *)"host not found";
#line 1129
    free((void *)host);
    }
#line 1130
    return ((ngx_int_t )-1);
  }
  {
#line 1133
  free((void *)host);
#line 1135
  i = (ngx_uint_t )0;
#line 1135
  rp = res;
  }
  {
#line 1135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1135
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1135
      goto while_break;
    }
    {
#line 1140
    if (rp->ai_family == 10) {
#line 1140
      goto case_10;
    }
#line 1140
    if (rp->ai_family == 2) {
#line 1140
      goto case_10;
    }
#line 1143
    goto switch_default;
    case_10: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1141
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1144
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 1147
    i ++;
    __Cont: /* CIL Label */ 
#line 1135
    rp = rp->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1150
  if (i == 0UL) {
#line 1151
    u->err = (char *)"host not found";
#line 1152
    goto failed;
  }
  {
#line 1157
  tmp___1 = ngx_pcalloc(pool, i * sizeof(ngx_addr_t ));
#line 1157
  u->addrs = (ngx_addr_t *)tmp___1;
  }
#line 1158
  if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 1159
    goto failed;
  }
#line 1162
  u->naddrs = i;
#line 1164
  i = (ngx_uint_t )0;
#line 1168
  rp = res;
  {
#line 1168
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1168
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1168
      goto while_break___0;
    }
#line 1170
    if (rp->ai_family != 2) {
#line 1171
      goto __Cont___0;
    }
    {
#line 1174
    tmp___2 = ngx_pcalloc(pool, (size_t___0 )rp->ai_addrlen);
#line 1174
    sin = (struct sockaddr_in *)tmp___2;
    }
#line 1175
    if ((unsigned long )sin == (unsigned long )((void *)0)) {
#line 1176
      goto failed;
    }
    {
#line 1179
    memcpy((void */* __restrict  */)sin, (void const   */* __restrict  */)rp->ai_addr,
           (size_t )rp->ai_addrlen);
#line 1181
    sin->sin_port = port;
#line 1183
    (u->addrs + i)->sockaddr = (struct sockaddr *)sin;
#line 1184
    (u->addrs + i)->socklen = rp->ai_addrlen;
#line 1186
    len = ((sizeof("255.255.255.255") - 1UL) + sizeof(":65535")) - 1UL;
#line 1188
    tmp___3 = ngx_pnalloc(pool, len);
#line 1188
    p = (u_char *)tmp___3;
    }
#line 1189
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1190
      goto failed;
    }
    {
#line 1193
    len = ngx_sock_ntop((struct sockaddr *)sin, rp->ai_addrlen, p, len, (ngx_uint_t )1);
#line 1195
    (u->addrs + i)->name.len = len;
#line 1196
    (u->addrs + i)->name.data = p;
#line 1198
    i ++;
    }
    __Cont___0: /* CIL Label */ 
#line 1168
    rp = rp->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1201
  rp = res;
  {
#line 1201
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1201
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1201
      goto while_break___1;
    }
#line 1203
    if (rp->ai_family != 10) {
#line 1204
      goto __Cont___1;
    }
    {
#line 1207
    tmp___4 = ngx_pcalloc(pool, (size_t___0 )rp->ai_addrlen);
#line 1207
    sin6 = (struct sockaddr_in6 *)tmp___4;
    }
#line 1208
    if ((unsigned long )sin6 == (unsigned long )((void *)0)) {
#line 1209
      goto failed;
    }
    {
#line 1212
    memcpy((void */* __restrict  */)sin6, (void const   */* __restrict  */)rp->ai_addr,
           (size_t )rp->ai_addrlen);
#line 1214
    sin6->sin6_port = port;
#line 1216
    (u->addrs + i)->sockaddr = (struct sockaddr *)sin6;
#line 1217
    (u->addrs + i)->socklen = rp->ai_addrlen;
#line 1219
    len = ((sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL) + sizeof("[]:65535")) - 1UL;
#line 1221
    tmp___5 = ngx_pnalloc(pool, len);
#line 1221
    p = (u_char *)tmp___5;
    }
#line 1222
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1223
      goto failed;
    }
    {
#line 1226
    len = ngx_sock_ntop((struct sockaddr *)sin6, rp->ai_addrlen, p, len, (ngx_uint_t )1);
#line 1229
    (u->addrs + i)->name.len = len;
#line 1230
    (u->addrs + i)->name.data = p;
#line 1232
    i ++;
    }
    __Cont___1: /* CIL Label */ 
#line 1201
    rp = rp->ai_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1235
  freeaddrinfo(res);
  }
#line 1236
  return ((ngx_int_t )0);
  failed: 
  {
#line 1240
  freeaddrinfo(res);
  }
#line 1241
  return ((ngx_int_t )-1);
}
}
#line 1358 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
ngx_int_t ngx_cmp_sockaddr(struct sockaddr *sa1 , socklen_t slen1 , struct sockaddr *sa2 ,
                           socklen_t slen2 , ngx_uint_t cmp_port ) 
{ 
  struct sockaddr_in *sin1 ;
  struct sockaddr_in *sin2 ;
  struct sockaddr_in6 *sin61 ;
  struct sockaddr_in6 *sin62 ;
  size_t___0 len ;
  struct sockaddr_un *saun1 ;
  struct sockaddr_un *saun2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1371
  if ((int )sa1->sa_family != (int )sa2->sa_family) {
#line 1372
    return ((ngx_int_t )-5);
  }
  {
#line 1378
  if ((int )sa1->sa_family == 10) {
#line 1378
    goto case_10;
  }
#line 1395
  if ((int )sa1->sa_family == 1) {
#line 1395
    goto case_1;
  }
#line 1418
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1380
  sin61 = (struct sockaddr_in6 *)sa1;
#line 1381
  sin62 = (struct sockaddr_in6 *)sa2;
#line 1383
  if (cmp_port) {
#line 1383
    if ((int )sin61->sin6_port != (int )sin62->sin6_port) {
#line 1384
      return ((ngx_int_t )-5);
    }
  }
  {
#line 1387
  tmp = memcmp((void const   *)((char const   *)(& sin61->sin6_addr)), (void const   *)((char const   *)(& sin62->sin6_addr)),
               (size_t )16);
  }
#line 1387
  if (tmp != 0) {
#line 1388
    return ((ngx_int_t )-5);
  }
#line 1391
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1397
  saun1 = (struct sockaddr_un *)sa1;
#line 1398
  saun2 = (struct sockaddr_un *)sa2;
#line 1400
  if (slen1 < slen2) {
#line 1401
    len = (unsigned long )slen1 - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
  } else {
#line 1404
    len = (unsigned long )slen2 - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
  }
#line 1407
  if (len > sizeof(saun1->sun_path)) {
#line 1408
    len = sizeof(saun1->sun_path);
  }
  {
#line 1411
  tmp___0 = memcmp((void const   *)((char const   *)(& saun1->sun_path)), (void const   *)((char const   *)(& saun2->sun_path)),
                   len);
  }
#line 1411
  if (tmp___0 != 0) {
#line 1412
    return ((ngx_int_t )-5);
  }
#line 1415
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1420
  sin1 = (struct sockaddr_in *)sa1;
#line 1421
  sin2 = (struct sockaddr_in *)sa2;
#line 1423
  if (cmp_port) {
#line 1423
    if ((int )sin1->sin_port != (int )sin2->sin_port) {
#line 1424
      return ((ngx_int_t )-5);
    }
  }
#line 1427
  if (sin1->sin_addr.s_addr != sin2->sin_addr.s_addr) {
#line 1428
    return ((ngx_int_t )-5);
  }
#line 1431
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1434
  return ((ngx_int_t )0);
}
}
#line 1438 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
in_port_t ngx_inet_get_port(struct sockaddr *sa ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;

  {
  {
#line 1449
  if ((int )sa->sa_family == 10) {
#line 1449
    goto case_10;
  }
#line 1455
  if ((int )sa->sa_family == 1) {
#line 1455
    goto case_1;
  }
#line 1459
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1450
  sin6 = (struct sockaddr_in6 *)sa;
#line 1451
  __x = sin6->sin6_port;
#line 1451
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1451
  return (__v);
  case_1: /* CIL Label */ 
#line 1456
  return ((in_port_t )0);
  switch_default: /* CIL Label */ 
#line 1460
  sin = (struct sockaddr_in *)sa;
#line 1461
  __x___0 = sin->sin_port;
#line 1461
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1461
  return (__v___0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1466 "/tmp/nginx-1.13.2/src/core/ngx_inet.c"
void ngx_inet_set_port(struct sockaddr *sa , in_port_t port ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  unsigned short __v ;
  unsigned short __x ;
  unsigned short __v___0 ;
  unsigned short __x___0 ;

  {
  {
#line 1477
  if ((int )sa->sa_family == 10) {
#line 1477
    goto case_10;
  }
#line 1484
  if ((int )sa->sa_family == 1) {
#line 1484
    goto case_1;
  }
#line 1488
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1478
  sin6 = (struct sockaddr_in6 *)sa;
#line 1479
  __x = port;
#line 1479
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 1479
  sin6->sin6_port = __v;
#line 1480
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1485
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1489
  sin = (struct sockaddr_in *)sa;
#line 1490
  __x___0 = port;
#line 1490
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 1490
  sin->sin_port = __v___0;
#line 1491
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1493
  return;
}
}
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_parse_time.c"
static ngx_uint_t mday[12]  = 
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_parse_time.c"
  {      (ngx_uint_t )31,      (ngx_uint_t )28,      (ngx_uint_t )31,      (ngx_uint_t )30, 
        (ngx_uint_t )31,      (ngx_uint_t )30,      (ngx_uint_t )31,      (ngx_uint_t )31, 
        (ngx_uint_t )30,      (ngx_uint_t )31,      (ngx_uint_t )30,      (ngx_uint_t )31};
#line 14 "/tmp/nginx-1.13.2/src/core/ngx_parse_time.c"
time_t ngx_parse_http_time(u_char *value , size_t___0 len ) 
{ 
  u_char *p ;
  u_char *end ;
  ngx_int_t month ;
  ngx_uint_t day ;
  ngx_uint_t year ;
  ngx_uint_t hour ;
  ngx_uint_t min ;
  ngx_uint_t sec ;
  uint64_t time___0 ;
  enum __anonenum_fmt_28532488 fmt ;
  int tmp ;
  int tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 28
  fmt = (enum __anonenum_fmt_28532488 )0;
#line 29
  end = value + len;
#line 32
  day = (ngx_uint_t )32;
#line 33
  year = (ngx_uint_t )2038;
#line 36
  p = value;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 36
      goto while_break;
    }
#line 37
    if ((int )*p == 44) {
#line 38
      goto while_break;
    }
#line 41
    if ((int )*p == 32) {
#line 42
      fmt = (enum __anonenum_fmt_28532488 )3;
#line 43
      goto while_break;
    }
#line 36
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  p ++;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 47
      goto while_break___0;
    }
#line 48
    if ((int )*p != 32) {
#line 49
      goto while_break___0;
    }
#line 47
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  if (end - p < 18L) {
#line 53
    return ((time_t )-1);
  }
#line 56
  if ((unsigned int )fmt != 3U) {
#line 57
    if ((int )*p < 48) {
#line 58
      return ((time_t )-1);
    } else
#line 57
    if ((int )*p > 57) {
#line 58
      return ((time_t )-1);
    } else
#line 57
    if ((int )*(p + 1) < 48) {
#line 58
      return ((time_t )-1);
    } else
#line 57
    if ((int )*(p + 1) > 57) {
#line 58
      return ((time_t )-1);
    }
#line 61
    day = (ngx_uint_t )((((int )*p - 48) * 10 + (int )*(p + 1)) - 48);
#line 62
    p += 2;
#line 64
    if ((int )*p == 32) {
#line 65
      if (end - p < 18L) {
#line 66
        return ((time_t )-1);
      }
#line 68
      fmt = (enum __anonenum_fmt_28532488 )1;
    } else
#line 70
    if ((int )*p == 45) {
#line 71
      fmt = (enum __anonenum_fmt_28532488 )2;
    } else {
#line 74
      return ((time_t )-1);
    }
#line 77
    p ++;
  }
  {
#line 82
  if ((int )*p == 74) {
#line 82
    goto case_74;
  }
#line 86
  if ((int )*p == 70) {
#line 86
    goto case_70;
  }
#line 90
  if ((int )*p == 77) {
#line 90
    goto case_77;
  }
#line 94
  if ((int )*p == 65) {
#line 94
    goto case_65;
  }
#line 98
  if ((int )*p == 83) {
#line 98
    goto case_83;
  }
#line 102
  if ((int )*p == 79) {
#line 102
    goto case_79;
  }
#line 106
  if ((int )*p == 78) {
#line 106
    goto case_78;
  }
#line 110
  if ((int )*p == 68) {
#line 110
    goto case_68;
  }
#line 114
  goto switch_default;
  case_74: /* CIL Label */ 
#line 83
  if ((int )*(p + 1) == 97) {
#line 83
    month = (ngx_int_t )0;
  } else {
#line 83
    if ((int )*(p + 2) == 110) {
#line 83
      tmp = 5;
    } else {
#line 83
      tmp = 6;
    }
#line 83
    month = (ngx_int_t )tmp;
  }
#line 84
  goto switch_break;
  case_70: /* CIL Label */ 
#line 87
  month = (ngx_int_t )1;
#line 88
  goto switch_break;
  case_77: /* CIL Label */ 
#line 91
  if ((int )*(p + 2) == 114) {
#line 91
    month = (ngx_int_t )2;
  } else {
#line 91
    month = (ngx_int_t )4;
  }
#line 92
  goto switch_break;
  case_65: /* CIL Label */ 
#line 95
  if ((int )*(p + 1) == 112) {
#line 95
    month = (ngx_int_t )3;
  } else {
#line 95
    month = (ngx_int_t )7;
  }
#line 96
  goto switch_break;
  case_83: /* CIL Label */ 
#line 99
  month = (ngx_int_t )8;
#line 100
  goto switch_break;
  case_79: /* CIL Label */ 
#line 103
  month = (ngx_int_t )9;
#line 104
  goto switch_break;
  case_78: /* CIL Label */ 
#line 107
  month = (ngx_int_t )10;
#line 108
  goto switch_break;
  case_68: /* CIL Label */ 
#line 111
  month = (ngx_int_t )11;
#line 112
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 115
  return ((time_t )-1);
  switch_break: /* CIL Label */ ;
  }
#line 118
  p += 3;
#line 120
  if ((unsigned int )fmt == 1U) {
#line 120
    if ((int )*p != 32) {
#line 121
      return ((time_t )-1);
    } else {
#line 120
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 120
  if ((unsigned int )fmt == 2U) {
#line 120
    if ((int )*p != 45) {
#line 121
      return ((time_t )-1);
    }
  }
#line 124
  p ++;
#line 126
  if ((unsigned int )fmt == 1U) {
#line 127
    if ((int )*p < 48) {
#line 131
      return ((time_t )-1);
    } else
#line 127
    if ((int )*p > 57) {
#line 131
      return ((time_t )-1);
    } else
#line 127
    if ((int )*(p + 1) < 48) {
#line 131
      return ((time_t )-1);
    } else
#line 127
    if ((int )*(p + 1) > 57) {
#line 131
      return ((time_t )-1);
    } else
#line 127
    if ((int )*(p + 2) < 48) {
#line 131
      return ((time_t )-1);
    } else
#line 127
    if ((int )*(p + 2) > 57) {
#line 131
      return ((time_t )-1);
    } else
#line 127
    if ((int )*(p + 3) < 48) {
#line 131
      return ((time_t )-1);
    } else
#line 127
    if ((int )*(p + 3) > 57) {
#line 131
      return ((time_t )-1);
    }
#line 134
    year = (ngx_uint_t )((((((int )*p - 48) * 1000 + ((int )*(p + 1) - 48) * 100) + ((int )*(p + 2) - 48) * 10) + (int )*(p + 3)) - 48);
#line 136
    p += 4;
  } else
#line 138
  if ((unsigned int )fmt == 2U) {
#line 139
    if ((int )*p < 48) {
#line 140
      return ((time_t )-1);
    } else
#line 139
    if ((int )*p > 57) {
#line 140
      return ((time_t )-1);
    } else
#line 139
    if ((int )*(p + 1) < 48) {
#line 140
      return ((time_t )-1);
    } else
#line 139
    if ((int )*(p + 1) > 57) {
#line 140
      return ((time_t )-1);
    }
#line 143
    year = (ngx_uint_t )((((int )*p - 48) * 10 + (int )*(p + 1)) - 48);
#line 144
    if (year < 70UL) {
#line 144
      tmp___0 = 2000;
    } else {
#line 144
      tmp___0 = 1900;
    }
#line 144
    year += (ngx_uint_t )tmp___0;
#line 145
    p += 2;
  }
#line 148
  if ((unsigned int )fmt == 3U) {
#line 149
    if ((int )*p == 32) {
#line 150
      p ++;
    }
#line 153
    if ((int )*p < 48) {
#line 154
      return ((time_t )-1);
    } else
#line 153
    if ((int )*p > 57) {
#line 154
      return ((time_t )-1);
    }
#line 157
    tmp___1 = p;
#line 157
    p ++;
#line 157
    day = (ngx_uint_t )((int )*tmp___1 - 48);
#line 159
    if ((int )*p != 32) {
#line 160
      if ((int )*p < 48) {
#line 161
        return ((time_t )-1);
      } else
#line 160
      if ((int )*p > 57) {
#line 161
        return ((time_t )-1);
      }
#line 164
      tmp___2 = p;
#line 164
      p ++;
#line 164
      day = (day * 10UL + (ngx_uint_t )*tmp___2) - 48UL;
    }
#line 167
    if (end - p < 14L) {
#line 168
      return ((time_t )-1);
    }
  }
#line 172
  tmp___3 = p;
#line 172
  p ++;
#line 172
  if ((int )*tmp___3 != 32) {
#line 173
    return ((time_t )-1);
  }
#line 176
  if ((int )*p < 48) {
#line 177
    return ((time_t )-1);
  } else
#line 176
  if ((int )*p > 57) {
#line 177
    return ((time_t )-1);
  } else
#line 176
  if ((int )*(p + 1) < 48) {
#line 177
    return ((time_t )-1);
  } else
#line 176
  if ((int )*(p + 1) > 57) {
#line 177
    return ((time_t )-1);
  }
#line 180
  hour = (ngx_uint_t )((((int )*p - 48) * 10 + (int )*(p + 1)) - 48);
#line 181
  p += 2;
#line 183
  tmp___4 = p;
#line 183
  p ++;
#line 183
  if ((int )*tmp___4 != 58) {
#line 184
    return ((time_t )-1);
  }
#line 187
  if ((int )*p < 48) {
#line 188
    return ((time_t )-1);
  } else
#line 187
  if ((int )*p > 57) {
#line 188
    return ((time_t )-1);
  } else
#line 187
  if ((int )*(p + 1) < 48) {
#line 188
    return ((time_t )-1);
  } else
#line 187
  if ((int )*(p + 1) > 57) {
#line 188
    return ((time_t )-1);
  }
#line 191
  min = (ngx_uint_t )((((int )*p - 48) * 10 + (int )*(p + 1)) - 48);
#line 192
  p += 2;
#line 194
  tmp___5 = p;
#line 194
  p ++;
#line 194
  if ((int )*tmp___5 != 58) {
#line 195
    return ((time_t )-1);
  }
#line 198
  if ((int )*p < 48) {
#line 199
    return ((time_t )-1);
  } else
#line 198
  if ((int )*p > 57) {
#line 199
    return ((time_t )-1);
  } else
#line 198
  if ((int )*(p + 1) < 48) {
#line 199
    return ((time_t )-1);
  } else
#line 198
  if ((int )*(p + 1) > 57) {
#line 199
    return ((time_t )-1);
  }
#line 202
  sec = (ngx_uint_t )((((int )*p - 48) * 10 + (int )*(p + 1)) - 48);
#line 204
  if ((unsigned int )fmt == 3U) {
#line 205
    p += 2;
#line 207
    tmp___6 = p;
#line 207
    p ++;
#line 207
    if ((int )*tmp___6 != 32) {
#line 208
      return ((time_t )-1);
    }
#line 211
    if ((int )*p < 48) {
#line 215
      return ((time_t )-1);
    } else
#line 211
    if ((int )*p > 57) {
#line 215
      return ((time_t )-1);
    } else
#line 211
    if ((int )*(p + 1) < 48) {
#line 215
      return ((time_t )-1);
    } else
#line 211
    if ((int )*(p + 1) > 57) {
#line 215
      return ((time_t )-1);
    } else
#line 211
    if ((int )*(p + 2) < 48) {
#line 215
      return ((time_t )-1);
    } else
#line 211
    if ((int )*(p + 2) > 57) {
#line 215
      return ((time_t )-1);
    } else
#line 211
    if ((int )*(p + 3) < 48) {
#line 215
      return ((time_t )-1);
    } else
#line 211
    if ((int )*(p + 3) > 57) {
#line 215
      return ((time_t )-1);
    }
#line 218
    year = (ngx_uint_t )((((((int )*p - 48) * 1000 + ((int )*(p + 1) - 48) * 100) + ((int )*(p + 2) - 48) * 10) + (int )*(p + 3)) - 48);
  }
#line 222
  if (hour > 23UL) {
#line 223
    return ((time_t )-1);
  } else
#line 222
  if (min > 59UL) {
#line 223
    return ((time_t )-1);
  } else
#line 222
  if (sec > 59UL) {
#line 223
    return ((time_t )-1);
  }
#line 226
  if (day == 29UL) {
#line 226
    if (month == 1L) {
#line 227
      if (year & 3UL) {
#line 228
        return ((time_t )-1);
      } else
#line 227
      if (year % 100UL == 0UL) {
#line 227
        if (year % 400UL != 0UL) {
#line 228
          return ((time_t )-1);
        }
      }
    } else {
#line 226
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 231
  if (day > mday[month]) {
#line 232
    return ((time_t )-1);
  }
#line 240
  month --;
#line 240
  if (month <= 0L) {
#line 241
    month += 12L;
#line 242
    year --;
  }
#line 247
  time___0 = ((((((((((((365UL * year + year / 4UL) - year / 100UL) + year / 400UL) + (ngx_uint_t )((367L * month) / 12L)) - 30UL) + day) - 1UL) - 719527UL) + 31UL) + 28UL) * 86400UL + hour * 3600UL) + min * 60UL) + sec;
#line 275
  return ((time_t )time___0);
}
}
#line 174 "src/core/ngx_string.h"
ssize_t ngx_atosz(u_char *line , size_t___0 n ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_parse.c"
ssize_t ngx_parse_size(ngx_str_t *line ) 
{ 
  u_char unit ;
  size_t___0 len ;
  ssize_t size ;
  ssize_t scale ;
  ssize_t max ;

  {
#line 19
  len = line->len;
#line 21
  if (len == 0UL) {
#line 22
    return ((ssize_t )-1);
  }
#line 25
  unit = *(line->data + (len - 1UL));
  {
#line 29
  if ((int )unit == 107) {
#line 29
    goto case_107;
  }
#line 29
  if ((int )unit == 75) {
#line 29
    goto case_107;
  }
#line 36
  if ((int )unit == 109) {
#line 36
    goto case_109;
  }
#line 36
  if ((int )unit == 77) {
#line 36
    goto case_109;
  }
#line 42
  goto switch_default;
  case_107: /* CIL Label */ 
  case_75: /* CIL Label */ 
#line 30
  len --;
#line 31
  max = (ssize_t )9007199254740991LL;
#line 32
  scale = (ssize_t )1024;
#line 33
  goto switch_break;
  case_109: /* CIL Label */ 
  case_77: /* CIL Label */ 
#line 37
  len --;
#line 38
  max = (ssize_t )8796093022207LL;
#line 39
  scale = (ssize_t )1048576;
#line 40
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 43
  max = (ssize_t )9223372036854775807LL;
#line 44
  scale = (ssize_t )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 47
  size = ngx_atosz(line->data, len);
  }
#line 48
  if (size == -1L) {
#line 49
    return ((ssize_t )-1);
  } else
#line 48
  if (size > max) {
#line 49
    return ((ssize_t )-1);
  }
#line 52
  size *= scale;
#line 54
  return (size);
}
}
#line 58 "/tmp/nginx-1.13.2/src/core/ngx_parse.c"
off_t ngx_parse_offset(ngx_str_t *line ) 
{ 
  u_char unit ;
  off_t offset ;
  off_t scale ;
  off_t max ;
  size_t___0 len ;

  {
#line 65
  len = line->len;
#line 67
  if (len == 0UL) {
#line 68
    return ((off_t )-1);
  }
#line 71
  unit = *(line->data + (len - 1UL));
  {
#line 75
  if ((int )unit == 107) {
#line 75
    goto case_107;
  }
#line 75
  if ((int )unit == 75) {
#line 75
    goto case_107;
  }
#line 82
  if ((int )unit == 109) {
#line 82
    goto case_109;
  }
#line 82
  if ((int )unit == 77) {
#line 82
    goto case_109;
  }
#line 89
  if ((int )unit == 103) {
#line 89
    goto case_103;
  }
#line 89
  if ((int )unit == 71) {
#line 89
    goto case_103;
  }
#line 95
  goto switch_default;
  case_107: /* CIL Label */ 
  case_75: /* CIL Label */ 
#line 76
  len --;
#line 77
  max = (off_t )9007199254740991LL;
#line 78
  scale = (off_t )1024;
#line 79
  goto switch_break;
  case_109: /* CIL Label */ 
  case_77: /* CIL Label */ 
#line 83
  len --;
#line 84
  max = (off_t )8796093022207LL;
#line 85
  scale = (off_t )1048576;
#line 86
  goto switch_break;
  case_103: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 90
  len --;
#line 91
  max = (off_t )8589934591LL;
#line 92
  scale = (off_t )1073741824;
#line 93
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 96
  max = (off_t )9223372036854775807LL;
#line 97
  scale = (off_t )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 100
  offset = ngx_atoof(line->data, len);
  }
#line 101
  if (offset == -1L) {
#line 102
    return ((off_t )-1);
  } else
#line 101
  if (offset > max) {
#line 102
    return ((off_t )-1);
  }
#line 105
  offset *= scale;
#line 107
  return (offset);
}
}
#line 111 "/tmp/nginx-1.13.2/src/core/ngx_parse.c"
ngx_int_t ngx_parse_time(ngx_str_t *line , ngx_uint_t is_sec ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_int_t value ;
  ngx_int_t total ;
  ngx_int_t scale ;
  ngx_int_t max ;
  ngx_int_t cutoff ;
  ngx_int_t cutlim ;
  ngx_uint_t valid ;
  enum __anonenum_step_271427946 step ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
#line 131
  valid = (ngx_uint_t )0;
#line 132
  value = (ngx_int_t )0;
#line 133
  total = (ngx_int_t )0;
#line 134
  cutoff = 922337203685477580L;
#line 135
  cutlim = 7L;
#line 136
  if (is_sec) {
#line 136
    step = (enum __anonenum_step_271427946 )0;
  } else {
#line 136
    step = (enum __anonenum_step_271427946 )2;
  }
#line 138
  p = line->data;
#line 139
  last = p + line->len;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 141
      goto while_break;
    }
#line 143
    if ((int )*p >= 48) {
#line 143
      if ((int )*p <= 57) {
#line 144
        if (value >= cutoff) {
#line 144
          if (value > cutoff) {
#line 145
            return ((ngx_int_t )-1);
          } else
#line 144
          if ((ngx_int_t )((int )*p - 48) > cutlim) {
#line 145
            return ((ngx_int_t )-1);
          }
        }
#line 148
        tmp = p;
#line 148
        p ++;
#line 148
        value = value * 10L + (ngx_int_t )((int )*tmp - 48);
#line 149
        valid = (ngx_uint_t )1;
#line 150
        goto while_continue;
      }
    }
#line 153
    tmp___0 = p;
#line 153
    p ++;
    {
#line 155
    if ((int )*tmp___0 == 121) {
#line 155
      goto case_121;
    }
#line 164
    if ((int )*tmp___0 == 77) {
#line 164
      goto case_77;
    }
#line 173
    if ((int )*tmp___0 == 119) {
#line 173
      goto case_119;
    }
#line 182
    if ((int )*tmp___0 == 100) {
#line 182
      goto case_100;
    }
#line 191
    if ((int )*tmp___0 == 104) {
#line 191
      goto case_104;
    }
#line 200
    if ((int )*tmp___0 == 109) {
#line 200
      goto case_109;
    }
#line 220
    if ((int )*tmp___0 == 115) {
#line 220
      goto case_115;
    }
#line 229
    if ((int )*tmp___0 == 32) {
#line 229
      goto case_32;
    }
#line 238
    goto switch_default;
    case_121: /* CIL Label */ 
#line 156
    if ((unsigned int )step > 0U) {
#line 157
      return ((ngx_int_t )-1);
    }
#line 159
    step = (enum __anonenum_step_271427946 )1;
#line 160
    max = 292471208677L;
#line 161
    scale = (ngx_int_t )31536000;
#line 162
    goto switch_break;
    case_77: /* CIL Label */ 
#line 165
    if ((unsigned int )step >= 2U) {
#line 166
      return ((ngx_int_t )-1);
    }
#line 168
    step = (enum __anonenum_step_271427946 )2;
#line 169
    max = 3558399705576L;
#line 170
    scale = (ngx_int_t )2592000;
#line 171
    goto switch_break;
    case_119: /* CIL Label */ 
#line 174
    if ((unsigned int )step >= 3U) {
#line 175
      return ((ngx_int_t )-1);
    }
#line 177
    step = (enum __anonenum_step_271427946 )3;
#line 178
    max = 15250284452471L;
#line 179
    scale = (ngx_int_t )604800;
#line 180
    goto switch_break;
    case_100: /* CIL Label */ 
#line 183
    if ((unsigned int )step >= 4U) {
#line 184
      return ((ngx_int_t )-1);
    }
#line 186
    step = (enum __anonenum_step_271427946 )4;
#line 187
    max = 106751991167300L;
#line 188
    scale = (ngx_int_t )86400;
#line 189
    goto switch_break;
    case_104: /* CIL Label */ 
#line 192
    if ((unsigned int )step >= 5U) {
#line 193
      return ((ngx_int_t )-1);
    }
#line 195
    step = (enum __anonenum_step_271427946 )5;
#line 196
    max = 2562047788015215L;
#line 197
    scale = (ngx_int_t )3600;
#line 198
    goto switch_break;
    case_109: /* CIL Label */ 
#line 201
    if ((unsigned long )p < (unsigned long )last) {
#line 201
      if ((int )*p == 115) {
#line 202
        if (is_sec) {
#line 203
          return ((ngx_int_t )-1);
        } else
#line 202
        if ((unsigned int )step >= 8U) {
#line 203
          return ((ngx_int_t )-1);
        }
#line 205
        p ++;
#line 206
        step = (enum __anonenum_step_271427946 )8;
#line 207
        max = 9223372036854775807L;
#line 208
        scale = (ngx_int_t )1;
#line 209
        goto switch_break;
      }
    }
#line 212
    if ((unsigned int )step >= 6U) {
#line 213
      return ((ngx_int_t )-1);
    }
#line 215
    step = (enum __anonenum_step_271427946 )6;
#line 216
    max = 153722867280912930L;
#line 217
    scale = (ngx_int_t )60;
#line 218
    goto switch_break;
    case_115: /* CIL Label */ 
#line 221
    if ((unsigned int )step >= 7U) {
#line 222
      return ((ngx_int_t )-1);
    }
#line 224
    step = (enum __anonenum_step_271427946 )7;
#line 225
    max = 9223372036854775807L;
#line 226
    scale = (ngx_int_t )1;
#line 227
    goto switch_break;
    case_32: /* CIL Label */ 
#line 230
    if ((unsigned int )step >= 7U) {
#line 231
      return ((ngx_int_t )-1);
    }
#line 233
    step = (enum __anonenum_step_271427946 )9;
#line 234
    max = 9223372036854775807L;
#line 235
    scale = (ngx_int_t )1;
#line 236
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 239
    return ((ngx_int_t )-1);
    switch_break: /* CIL Label */ ;
    }
#line 242
    if ((unsigned int )step != 8U) {
#line 242
      if (! is_sec) {
#line 243
        scale *= 1000L;
#line 244
        max /= 1000L;
      }
    }
#line 247
    if (value > max) {
#line 248
      return ((ngx_int_t )-1);
    }
#line 251
    value *= scale;
#line 253
    if (total > 9223372036854775807L - value) {
#line 254
      return ((ngx_int_t )-1);
    }
#line 257
    total += value;
#line 259
    value = (ngx_int_t )0;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if ((unsigned long )p < (unsigned long )last) {
#line 261
        if (! ((int )*p == 32)) {
#line 261
          goto while_break___0;
        }
      } else {
#line 261
        goto while_break___0;
      }
#line 262
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  if (! valid) {
#line 267
    return ((ngx_int_t )-1);
  }
#line 270
  if (! is_sec) {
#line 271
    if (value > 9223372036854775L) {
#line 272
      return ((ngx_int_t )-1);
    }
#line 275
    value *= 1000L;
  }
#line 278
  if (total > 9223372036854775807L - value) {
#line 279
    return ((ngx_int_t )-1);
  }
#line 282
  return (total + value);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 186 "src/core/ngx_string.h"
void ngx_encode_base64url(ngx_str_t *dst , ngx_str_t *src ) ;
#line 188
ngx_int_t ngx_decode_base64url(ngx_str_t *dst , ngx_str_t *src ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char *ngx_sprintf_num(u_char *buf , u_char *last , uint64_t ui64 , u_char zero___0 ,
                               ngx_uint_t hexadecimal , ngx_uint_t width ) ;
#line 14
static void ngx_encode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ,
                                       ngx_uint_t padding ) ;
#line 16
static ngx_int_t ngx_decode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ) ;
#line 20 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
void ngx_strlow(u_char *dst , u_char *src , size_t___0 n ) 
{ 
  int tmp ;

  {
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! n) {
#line 23
      goto while_break;
    }
#line 24
    if ((int )*src >= 65) {
#line 24
      if ((int )*src <= 90) {
#line 24
        tmp = (int )*src | 32;
      } else {
#line 24
        tmp = (int )*src;
      }
    } else {
#line 24
      tmp = (int )*src;
    }
#line 24
    *dst = (u_char )tmp;
#line 25
    dst ++;
#line 26
    src ++;
#line 27
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 32 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_cpystrn(u_char *dst , u_char *src , size_t___0 n ) 
{ 


  {
#line 35
  if (n == 0UL) {
#line 36
    return (dst);
  }
  {
#line 39
  while (1) {
    while_continue: /* CIL Label */ ;
#line 39
    n --;
#line 39
    if (! n) {
#line 39
      goto while_break;
    }
#line 40
    *dst = *src;
#line 42
    if ((int )*dst == 0) {
#line 43
      return (dst);
    }
#line 46
    dst ++;
#line 47
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  *dst = (u_char )'\000';
#line 52
  return (dst);
}
}
#line 56 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_pstrdup(ngx_pool_t *pool , ngx_str_t *src ) 
{ 
  u_char *dst ;
  void *tmp ;

  {
  {
#line 61
  tmp = ngx_pnalloc(pool, src->len);
#line 61
  dst = (u_char *)tmp;
  }
#line 62
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 63
    return ((u_char *)((void *)0));
  }
  {
#line 66
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src->data,
         src->len);
  }
#line 68
  return (dst);
}
}
#line 104 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_sprintf(u_char *buf , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list___0 args___0 ;

  {
  {
#line 110
  __builtin_va_start(args___0, fmt);
#line 111
  p = ngx_vslprintf(buf, (u_char *)((void *)-1), fmt, args___0);
#line 112
  __builtin_va_end(args___0);
  }
#line 114
  return (p);
}
}
#line 118 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_snprintf(u_char *buf , size_t___0 max , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list___0 args___0 ;

  {
  {
#line 124
  __builtin_va_start(args___0, fmt);
#line 125
  p = ngx_vslprintf(buf, buf + max, fmt, args___0);
#line 126
  __builtin_va_end(args___0);
  }
#line 128
  return (p);
}
}
#line 132 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_slprintf(u_char *buf , u_char *last , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list___0 args___0 ;

  {
  {
#line 138
  __builtin_va_start(args___0, fmt);
#line 139
  p = ngx_vslprintf(buf, last, fmt, args___0);
#line 140
  __builtin_va_end(args___0);
  }
#line 142
  return (p);
}
}
#line 146 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_vslprintf(u_char *buf , u_char *last , char const   *fmt , va_list___0 args___0 ) 
{ 
  u_char *p ;
  u_char zero___0 ;
  int d ;
  double f ;
  size_t___0 len ;
  size_t___0 slen ;
  int64_t i64 ;
  uint64_t ui64 ;
  uint64_t frac ;
  ngx_msec_t ms ;
  ngx_uint_t width ;
  ngx_uint_t sign ;
  ngx_uint_t hex___3 ;
  ngx_uint_t max_width ;
  ngx_uint_t frac_width ;
  ngx_uint_t scale ;
  ngx_uint_t n ;
  ngx_str_t *v ;
  ngx_variable_value_t *vv ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t___0 tmp___2 ;
  ngx_str_t *tmp___3 ;
  void *tmp___4 ;
  ngx_variable_value_t *tmp___5 ;
  void *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  void *tmp___10 ;
  off_t tmp___12 ;
  ngx_pid_t tmp___14 ;
  time_t tmp___16 ;
  ngx_msec_t tmp___18 ;
  ssize_t tmp___20 ;
  size_t___0 tmp___22 ;
  ngx_int_t tmp___24 ;
  ngx_uint_t tmp___26 ;
  int tmp___28 ;
  u_int tmp___30 ;
  long tmp___32 ;
  u_long tmp___34 ;
  int32_t tmp___36 ;
  uint32_t tmp___38 ;
  int64_t tmp___39 ;
  uint64_t tmp___40 ;
  ngx_atomic_int_t tmp___42 ;
  ngx_atomic_uint_t tmp___44 ;
  double tmp___45 ;
  u_char *tmp___46 ;
  u_char *tmp___47 ;
  rlim_t tmp___49 ;
  void *tmp___51 ;
  int tmp___52 ;
  u_char *tmp___53 ;
  u_char *tmp___54 ;
  u_char *tmp___55 ;
  u_char *tmp___56 ;
  u_char *tmp___57 ;
  char const   *tmp___58 ;
  u_char *tmp___59 ;
  u_char *tmp___60 ;
  char const   *tmp___61 ;

  {
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (*fmt) {
#line 160
      if (! ((unsigned long )buf < (unsigned long )last)) {
#line 160
        goto while_break;
      }
    } else {
#line 160
      goto while_break;
    }
#line 167
    if ((int const   )*fmt == 37) {
#line 169
      i64 = (int64_t )0;
#line 170
      ui64 = (uint64_t )0;
#line 172
      fmt ++;
#line 172
      if ((int const   )*fmt == 48) {
#line 172
        tmp = '0';
      } else {
#line 172
        tmp = ' ';
      }
#line 172
      zero___0 = (u_char )tmp;
#line 173
      width = (ngx_uint_t )0;
#line 174
      sign = (ngx_uint_t )1;
#line 175
      hex___3 = (ngx_uint_t )0;
#line 176
      max_width = (ngx_uint_t )0;
#line 177
      frac_width = (ngx_uint_t )0;
#line 178
      slen = (size_t___0 )-1;
      {
#line 180
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 180
        if ((int const   )*fmt >= 48) {
#line 180
          if (! ((int const   )*fmt <= 57)) {
#line 180
            goto while_break___0;
          }
        } else {
#line 180
          goto while_break___0;
        }
#line 181
        tmp___0 = fmt;
#line 181
        fmt ++;
#line 181
        width = (width * 10UL + (ngx_uint_t )*tmp___0) - 48UL;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 185
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 188
        if ((int const   )*fmt == 117) {
#line 188
          goto case_117;
        }
#line 193
        if ((int const   )*fmt == 109) {
#line 193
          goto case_109;
        }
#line 198
        if ((int const   )*fmt == 88) {
#line 198
          goto case_88;
        }
#line 204
        if ((int const   )*fmt == 120) {
#line 204
          goto case_120;
        }
#line 210
        if ((int const   )*fmt == 46) {
#line 210
          goto case_46;
        }
#line 219
        if ((int const   )*fmt == 42) {
#line 219
          goto case_42;
        }
#line 224
        goto switch_default;
        case_117: /* CIL Label */ 
#line 189
        sign = (ngx_uint_t )0;
#line 190
        fmt ++;
#line 191
        goto __Cont;
        case_109: /* CIL Label */ 
#line 194
        max_width = (ngx_uint_t )1;
#line 195
        fmt ++;
#line 196
        goto __Cont;
        case_88: /* CIL Label */ 
#line 199
        hex___3 = (ngx_uint_t )2;
#line 200
        sign = (ngx_uint_t )0;
#line 201
        fmt ++;
#line 202
        goto __Cont;
        case_120: /* CIL Label */ 
#line 205
        hex___3 = (ngx_uint_t )1;
#line 206
        sign = (ngx_uint_t )0;
#line 207
        fmt ++;
#line 208
        goto __Cont;
        case_46: /* CIL Label */ 
#line 211
        fmt ++;
        {
#line 213
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 213
          if ((int const   )*fmt >= 48) {
#line 213
            if (! ((int const   )*fmt <= 57)) {
#line 213
              goto while_break___2;
            }
          } else {
#line 213
            goto while_break___2;
          }
#line 214
          tmp___1 = fmt;
#line 214
          fmt ++;
#line 214
          frac_width = (frac_width * 10UL + (ngx_uint_t )*tmp___1) - 48UL;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 217
        goto switch_break;
        case_42: /* CIL Label */ 
        {
#line 220
        tmp___2 = __builtin_va_arg(args___0, size_t___0 );
#line 220
        slen = tmp___2;
#line 221
        fmt ++;
        }
#line 222
        goto __Cont;
        switch_default: /* CIL Label */ 
#line 225
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 228
        goto while_break___1;
        __Cont: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 234
      if ((int const   )*fmt == 86) {
#line 234
        goto case_86;
      }
#line 243
      if ((int const   )*fmt == 118) {
#line 243
        goto case_118;
      }
#line 252
      if ((int const   )*fmt == 115) {
#line 252
        goto case_115;
      }
#line 269
      if ((int const   )*fmt == 79) {
#line 269
        goto case_79;
      }
#line 274
      if ((int const   )*fmt == 80) {
#line 274
        goto case_80;
      }
#line 279
      if ((int const   )*fmt == 84) {
#line 279
        goto case_84;
      }
#line 284
      if ((int const   )*fmt == 77) {
#line 284
        goto case_77;
      }
#line 295
      if ((int const   )*fmt == 122) {
#line 295
        goto case_122;
      }
#line 303
      if ((int const   )*fmt == 105) {
#line 303
        goto case_105;
      }
#line 316
      if ((int const   )*fmt == 100) {
#line 316
        goto case_100;
      }
#line 324
      if ((int const   )*fmt == 108) {
#line 324
        goto case_108;
      }
#line 332
      if ((int const   )*fmt == 68) {
#line 332
        goto case_68;
      }
#line 340
      if ((int const   )*fmt == 76) {
#line 340
        goto case_76;
      }
#line 348
      if ((int const   )*fmt == 65) {
#line 348
        goto case_65;
      }
#line 361
      if ((int const   )*fmt == 102) {
#line 361
        goto case_102;
      }
#line 402
      if ((int const   )*fmt == 114) {
#line 402
        goto case_114;
      }
#line 408
      if ((int const   )*fmt == 112) {
#line 408
        goto case_112;
      }
#line 416
      if ((int const   )*fmt == 99) {
#line 416
        goto case_99;
      }
#line 423
      if ((int const   )*fmt == 90) {
#line 423
        goto case_90;
      }
#line 429
      if ((int const   )*fmt == 78) {
#line 429
        goto case_78;
      }
#line 442
      if ((int const   )*fmt == 37) {
#line 442
        goto case_37;
      }
#line 448
      goto switch_default___0;
      case_86: /* CIL Label */ 
      {
#line 235
      tmp___3 = __builtin_va_arg(args___0, ngx_str_t *);
#line 235
      v = tmp___3;
      }
#line 237
      if ((size_t___0 )(last - buf) > v->len) {
#line 237
        len = v->len;
      } else {
#line 237
        len = (size_t___0 )(last - buf);
      }
      {
#line 238
      tmp___4 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)v->data,
                       len);
#line 238
      buf = (u_char *)tmp___4 + len;
#line 239
      fmt ++;
      }
#line 241
      goto while_continue;
      case_118: /* CIL Label */ 
      {
#line 244
      tmp___5 = __builtin_va_arg(args___0, ngx_variable_value_t *);
#line 244
      vv = tmp___5;
      }
#line 246
      if ((size_t___0 )(last - buf) > (size_t___0 )vv->len) {
#line 246
        len = (size_t___0 )vv->len;
      } else {
#line 246
        len = (size_t___0 )(last - buf);
      }
      {
#line 247
      tmp___6 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)vv->data,
                       len);
#line 247
      buf = (u_char *)tmp___6 + len;
#line 248
      fmt ++;
      }
#line 250
      goto while_continue;
      case_115: /* CIL Label */ 
      {
#line 253
      tmp___7 = __builtin_va_arg(args___0, u_char *);
#line 253
      p = tmp___7;
      }
#line 255
      if (slen == 0xffffffffffffffffUL) {
        {
#line 256
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 256
          if (*p) {
#line 256
            if (! ((unsigned long )buf < (unsigned long )last)) {
#line 256
              goto while_break___3;
            }
          } else {
#line 256
            goto while_break___3;
          }
#line 257
          tmp___8 = buf;
#line 257
          buf ++;
#line 257
          tmp___9 = p;
#line 257
          p ++;
#line 257
          *tmp___8 = *tmp___9;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 261
        if ((size_t___0 )(last - buf) > slen) {
#line 261
          len = slen;
        } else {
#line 261
          len = (size_t___0 )(last - buf);
        }
        {
#line 262
        tmp___10 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)p,
                          len);
#line 262
        buf = (u_char *)tmp___10 + len;
        }
      }
#line 265
      fmt ++;
#line 267
      goto while_continue;
      case_79: /* CIL Label */ 
      {
#line 270
      tmp___12 = __builtin_va_arg(args___0, off_t );
#line 270
      i64 = tmp___12;
#line 271
      sign = (ngx_uint_t )1;
      }
#line 272
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 275
      tmp___14 = __builtin_va_arg(args___0, ngx_pid_t );
#line 275
      i64 = (int64_t )tmp___14;
#line 276
      sign = (ngx_uint_t )1;
      }
#line 277
      goto switch_break___0;
      case_84: /* CIL Label */ 
      {
#line 280
      tmp___16 = __builtin_va_arg(args___0, time_t );
#line 280
      i64 = tmp___16;
#line 281
      sign = (ngx_uint_t )1;
      }
#line 282
      goto switch_break___0;
      case_77: /* CIL Label */ 
      {
#line 285
      tmp___18 = __builtin_va_arg(args___0, ngx_msec_t );
#line 285
      ms = tmp___18;
      }
#line 286
      if ((ngx_msec_int_t )ms == -1L) {
#line 287
        sign = (ngx_uint_t )1;
#line 288
        i64 = (int64_t )-1;
      } else {
#line 290
        sign = (ngx_uint_t )0;
#line 291
        ui64 = ms;
      }
#line 293
      goto switch_break___0;
      case_122: /* CIL Label */ 
#line 296
      if (sign) {
        {
#line 297
        tmp___20 = __builtin_va_arg(args___0, ssize_t );
#line 297
        i64 = tmp___20;
        }
      } else {
        {
#line 299
        tmp___22 = __builtin_va_arg(args___0, size_t___0 );
#line 299
        ui64 = tmp___22;
        }
      }
#line 301
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 304
      if (sign) {
        {
#line 305
        tmp___24 = __builtin_va_arg(args___0, ngx_int_t );
#line 305
        i64 = tmp___24;
        }
      } else {
        {
#line 307
        tmp___26 = __builtin_va_arg(args___0, ngx_uint_t );
#line 307
        ui64 = tmp___26;
        }
      }
#line 310
      if (max_width) {
#line 311
        width = sizeof("-9223372036854775808") - 1UL;
      }
#line 314
      goto switch_break___0;
      case_100: /* CIL Label */ 
#line 317
      if (sign) {
        {
#line 318
        tmp___28 = __builtin_va_arg(args___0, int );
#line 318
        i64 = (int64_t )tmp___28;
        }
      } else {
        {
#line 320
        tmp___30 = __builtin_va_arg(args___0, u_int );
#line 320
        ui64 = (uint64_t )tmp___30;
        }
      }
#line 322
      goto switch_break___0;
      case_108: /* CIL Label */ 
#line 325
      if (sign) {
        {
#line 326
        tmp___32 = __builtin_va_arg(args___0, long );
#line 326
        i64 = tmp___32;
        }
      } else {
        {
#line 328
        tmp___34 = __builtin_va_arg(args___0, u_long );
#line 328
        ui64 = tmp___34;
        }
      }
#line 330
      goto switch_break___0;
      case_68: /* CIL Label */ 
#line 333
      if (sign) {
        {
#line 334
        tmp___36 = __builtin_va_arg(args___0, int32_t );
#line 334
        i64 = (int64_t )tmp___36;
        }
      } else {
        {
#line 336
        tmp___38 = __builtin_va_arg(args___0, uint32_t );
#line 336
        ui64 = (uint64_t )tmp___38;
        }
      }
#line 338
      goto switch_break___0;
      case_76: /* CIL Label */ 
#line 341
      if (sign) {
        {
#line 342
        tmp___39 = __builtin_va_arg(args___0, int64_t );
#line 342
        i64 = tmp___39;
        }
      } else {
        {
#line 344
        tmp___40 = __builtin_va_arg(args___0, uint64_t );
#line 344
        ui64 = tmp___40;
        }
      }
#line 346
      goto switch_break___0;
      case_65: /* CIL Label */ 
#line 349
      if (sign) {
        {
#line 350
        tmp___42 = __builtin_va_arg(args___0, ngx_atomic_int_t );
#line 350
        i64 = tmp___42;
        }
      } else {
        {
#line 352
        tmp___44 = __builtin_va_arg(args___0, ngx_atomic_uint_t );
#line 352
        ui64 = tmp___44;
        }
      }
#line 355
      if (max_width) {
#line 356
        width = sizeof("-9223372036854775808") - 1UL;
      }
#line 359
      goto switch_break___0;
      case_102: /* CIL Label */ 
      {
#line 362
      tmp___45 = __builtin_va_arg(args___0, double );
#line 362
      f = tmp___45;
      }
#line 364
      if (f < (double )0) {
#line 365
        tmp___46 = buf;
#line 365
        buf ++;
#line 365
        *tmp___46 = (u_char )'-';
#line 366
        f = - f;
      }
#line 369
      ui64 = (uint64_t )((int64_t )f);
#line 370
      frac = (uint64_t )0;
#line 372
      if (frac_width) {
#line 374
        scale = (ngx_uint_t )1;
#line 375
        n = frac_width;
        {
#line 375
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 375
          if (! n) {
#line 375
            goto while_break___4;
          }
#line 376
          scale *= 10UL;
#line 375
          n --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 379
        frac = (uint64_t )((f - (double )ui64) * (double )scale + 0.5);
#line 381
        if (frac == scale) {
#line 382
          ui64 ++;
#line 383
          frac = (uint64_t )0;
        }
      }
      {
#line 387
      buf = ngx_sprintf_num(buf, last, ui64, zero___0, (ngx_uint_t )0, width);
      }
#line 389
      if (frac_width) {
#line 390
        if ((unsigned long )buf < (unsigned long )last) {
#line 391
          tmp___47 = buf;
#line 391
          buf ++;
#line 391
          *tmp___47 = (u_char )'.';
        }
        {
#line 394
        buf = ngx_sprintf_num(buf, last, frac, (u_char )'0', (ngx_uint_t )0, frac_width);
        }
      }
#line 397
      fmt ++;
#line 399
      goto while_continue;
      case_114: /* CIL Label */ 
      {
#line 403
      tmp___49 = __builtin_va_arg(args___0, rlim_t );
#line 403
      i64 = (int64_t )tmp___49;
#line 404
      sign = (ngx_uint_t )1;
      }
#line 405
      goto switch_break___0;
      case_112: /* CIL Label */ 
      {
#line 409
      tmp___51 = __builtin_va_arg(args___0, void *);
#line 409
      ui64 = (uintptr_t )tmp___51;
#line 410
      hex___3 = (ngx_uint_t )2;
#line 411
      sign = (ngx_uint_t )0;
#line 412
      zero___0 = (u_char )'0';
#line 413
      width = 2UL * sizeof(void *);
      }
#line 414
      goto switch_break___0;
      case_99: /* CIL Label */ 
      {
#line 417
      tmp___52 = __builtin_va_arg(args___0, int );
#line 417
      d = tmp___52;
#line 418
      tmp___53 = buf;
#line 418
      buf ++;
#line 418
      *tmp___53 = (u_char )(d & 255);
#line 419
      fmt ++;
      }
#line 421
      goto while_continue;
      case_90: /* CIL Label */ 
#line 424
      tmp___54 = buf;
#line 424
      buf ++;
#line 424
      *tmp___54 = (u_char )'\000';
#line 425
      fmt ++;
#line 427
      goto while_continue;
      case_78: /* CIL Label */ 
#line 436
      tmp___55 = buf;
#line 436
      buf ++;
#line 436
      *tmp___55 = (u_char )'\n';
#line 438
      fmt ++;
#line 440
      goto while_continue;
      case_37: /* CIL Label */ 
#line 443
      tmp___56 = buf;
#line 443
      buf ++;
#line 443
      *tmp___56 = (u_char )'%';
#line 444
      fmt ++;
#line 446
      goto while_continue;
      switch_default___0: /* CIL Label */ 
#line 449
      tmp___57 = buf;
#line 449
      buf ++;
#line 449
      tmp___58 = fmt;
#line 449
      fmt ++;
#line 449
      *tmp___57 = (u_char )*tmp___58;
#line 451
      goto while_continue;
      switch_break___0: /* CIL Label */ ;
      }
#line 454
      if (sign) {
#line 455
        if (i64 < 0L) {
#line 456
          tmp___59 = buf;
#line 456
          buf ++;
#line 456
          *tmp___59 = (u_char )'-';
#line 457
          ui64 = (uint64_t )(- i64);
        } else {
#line 460
          ui64 = (uint64_t )i64;
        }
      }
      {
#line 464
      buf = ngx_sprintf_num(buf, last, ui64, zero___0, hex___3, width);
#line 466
      fmt ++;
      }
    } else {
#line 469
      tmp___60 = buf;
#line 469
      buf ++;
#line 469
      tmp___61 = fmt;
#line 469
      fmt ++;
#line 469
      *tmp___60 = (u_char )*tmp___61;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  return (buf);
}
}
#line 488 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char hex___0[17]  = 
#line 488
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'\000'};
#line 489 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char HEX[17]  = 
#line 489
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'A',      (u_char )'B', 
        (u_char )'C',      (u_char )'D',      (u_char )'E',      (u_char )'F', 
        (u_char )'\000'};
#line 477 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char *ngx_sprintf_num(u_char *buf , u_char *last , uint64_t ui64 , u_char zero___0 ,
                               ngx_uint_t hexadecimal , ngx_uint_t width ) 
{ 
  u_char *p ;
  u_char temp[(sizeof("-9223372036854775808") - 1UL) + 1UL] ;
  size_t___0 len ;
  uint32_t ui32 ;
  u_char *tmp ;
  size_t___0 tmp___0 ;
  void *tmp___1 ;

  {
#line 491
  p = temp + (sizeof("-9223372036854775808") - 1UL);
#line 493
  if (hexadecimal == 0UL) {
#line 495
    if (ui64 <= 4294967295UL) {
#line 512
      ui32 = (uint32_t )ui64;
      {
#line 514
      while (1) {
        while_continue: /* CIL Label */ ;
#line 515
        p --;
#line 515
        *p = (u_char )(ui32 % 10U + 48U);
#line 514
        ui32 /= 10U;
#line 514
        if (! ui32) {
#line 514
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 519
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 520
        p --;
#line 520
        *p = (u_char )(ui64 % 10UL + 48UL);
#line 519
        ui64 /= 10UL;
#line 519
        if (! ui64) {
#line 519
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 524
  if (hexadecimal == 1UL) {
    {
#line 526
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 529
      p --;
#line 529
      *p = hex___0[(uint32_t )(ui64 & 15UL)];
#line 526
      ui64 >>= 4;
#line 526
      if (! ui64) {
#line 526
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 535
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 538
      p --;
#line 538
      *p = HEX[(uint32_t )(ui64 & 15UL)];
#line 535
      ui64 >>= 4;
#line 535
      if (! ui64) {
#line 535
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 545
  len = (size_t___0 )((temp + (sizeof("-9223372036854775808") - 1UL)) - p);
  {
#line 547
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 547
    tmp___0 = len;
#line 547
    len ++;
#line 547
    if (tmp___0 < width) {
#line 547
      if (! ((unsigned long )buf < (unsigned long )last)) {
#line 547
        goto while_break___3;
      }
    } else {
#line 547
      goto while_break___3;
    }
#line 548
    tmp = buf;
#line 548
    buf ++;
#line 548
    *tmp = zero___0;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 553
  len = (size_t___0 )((temp + (sizeof("-9223372036854775808") - 1UL)) - p);
#line 555
  if ((unsigned long )(buf + len) > (unsigned long )last) {
#line 556
    len = (size_t___0 )(last - buf);
  }
  {
#line 559
  tmp___1 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)p,
                   len);
  }
#line 559
  return ((u_char *)tmp___1 + len);
}
}
#line 570 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_strcasecmp(u_char *s1 , u_char *s2 ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    tmp = s1;
#line 576
    s1 ++;
#line 576
    c1 = (ngx_uint_t )*tmp;
#line 577
    tmp___0 = s2;
#line 577
    s2 ++;
#line 577
    c2 = (ngx_uint_t )*tmp___0;
#line 579
    if (c1 >= 65UL) {
#line 579
      if (c1 <= 90UL) {
#line 579
        c1 |= 32UL;
      } else {
#line 579
        c1 = c1;
      }
    } else {
#line 579
      c1 = c1;
    }
#line 580
    if (c2 >= 65UL) {
#line 580
      if (c2 <= 90UL) {
#line 580
        c2 |= 32UL;
      } else {
#line 580
        c2 = c2;
      }
    } else {
#line 580
      c2 = c2;
    }
#line 582
    if (c1 == c2) {
#line 584
      if (c1) {
#line 585
        goto __Cont;
      }
#line 588
      return ((ngx_int_t )0);
    }
#line 591
    return ((ngx_int_t )(c1 - c2));
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 596 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_strncasecmp(u_char *s1 , u_char *s2 , size_t___0 n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (! n) {
#line 601
      goto while_break;
    }
#line 602
    tmp = s1;
#line 602
    s1 ++;
#line 602
    c1 = (ngx_uint_t )*tmp;
#line 603
    tmp___0 = s2;
#line 603
    s2 ++;
#line 603
    c2 = (ngx_uint_t )*tmp___0;
#line 605
    if (c1 >= 65UL) {
#line 605
      if (c1 <= 90UL) {
#line 605
        c1 |= 32UL;
      } else {
#line 605
        c1 = c1;
      }
    } else {
#line 605
      c1 = c1;
    }
#line 606
    if (c2 >= 65UL) {
#line 606
      if (c2 <= 90UL) {
#line 606
        c2 |= 32UL;
      } else {
#line 606
        c2 = c2;
      }
    } else {
#line 606
      c2 = c2;
    }
#line 608
    if (c1 == c2) {
#line 610
      if (c1) {
#line 611
        n --;
#line 612
        goto while_continue;
      }
#line 615
      return ((ngx_int_t )0);
    }
#line 618
    return ((ngx_int_t )(c1 - c2));
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return ((ngx_int_t )0);
}
}
#line 625 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_strnstr(u_char *s1 , char *s2 , size_t___0 len ) 
{ 
  u_char c1 ;
  u_char c2 ;
  size_t___0 n ;
  char *tmp ;
  size_t___0 tmp___0 ;
  u_char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 631
  tmp = s2;
#line 631
  s2 ++;
#line 631
  c2 = *((u_char *)tmp);
#line 633
  n = strlen((char const   *)s2);
  }
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 636
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 637
      tmp___0 = len;
#line 637
      len --;
#line 637
      if (tmp___0 == 0UL) {
#line 638
        return ((u_char *)((void *)0));
      }
#line 641
      tmp___1 = s1;
#line 641
      s1 ++;
#line 641
      c1 = *tmp___1;
#line 643
      if ((int )c1 == 0) {
#line 644
        return ((u_char *)((void *)0));
      }
#line 636
      if (! ((int )c1 != (int )c2)) {
#line 636
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 649
    if (n > len) {
#line 650
      return ((u_char *)((void *)0));
    }
    {
#line 635
    tmp___2 = strncmp((char const   *)s1, (char const   *)((u_char *)s2), n);
    }
#line 635
    if (! (tmp___2 != 0)) {
#line 635
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  s1 --;
#line 655
  return (s1);
}
}
#line 665 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_strstrn(u_char *s1 , char *s2 , size_t___0 n ) 
{ 
  u_char c1 ;
  u_char c2 ;
  char *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;

  {
#line 670
  tmp = s2;
#line 670
  s2 ++;
#line 670
  c2 = *((u_char *)tmp);
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 673
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 674
      tmp___0 = s1;
#line 674
      s1 ++;
#line 674
      c1 = *tmp___0;
#line 676
      if ((int )c1 == 0) {
#line 677
        return ((u_char *)((void *)0));
      }
#line 673
      if (! ((int )c1 != (int )c2)) {
#line 673
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 672
    tmp___1 = strncmp((char const   *)s1, (char const   *)((u_char *)s2), n);
    }
#line 672
    if (! (tmp___1 != 0)) {
#line 672
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 684
  s1 --;
#line 684
  return (s1);
}
}
#line 688 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_strcasestrn(u_char *s1 , char *s2 , size_t___0 n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  char *tmp ;
  u_char *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 693
  tmp = s2;
#line 693
  s2 ++;
#line 693
  c2 = (ngx_uint_t )*tmp;
#line 694
  if (c2 >= 65UL) {
#line 694
    if (c2 <= 90UL) {
#line 694
      c2 |= 32UL;
    } else {
#line 694
      c2 = c2;
    }
  } else {
#line 694
    c2 = c2;
  }
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 697
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 698
      tmp___0 = s1;
#line 698
      s1 ++;
#line 698
      c1 = (ngx_uint_t )*tmp___0;
#line 700
      if (c1 == 0UL) {
#line 701
        return ((u_char *)((void *)0));
      }
#line 704
      if (c1 >= 65UL) {
#line 704
        if (c1 <= 90UL) {
#line 704
          c1 |= 32UL;
        } else {
#line 704
          c1 = c1;
        }
      } else {
#line 704
        c1 = c1;
      }
#line 697
      if (! (c1 != c2)) {
#line 697
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 696
    tmp___1 = ngx_strncasecmp(s1, (u_char *)s2, n);
    }
#line 696
    if (! (tmp___1 != 0L)) {
#line 696
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  s1 --;
#line 710
  return (s1);
}
}
#line 720 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_strlcasestrn(u_char *s1 , u_char *last , u_char *s2 , size_t___0 n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 725
  tmp = s2;
#line 725
  s2 ++;
#line 725
  c2 = (ngx_uint_t )*tmp;
#line 726
  if (c2 >= 65UL) {
#line 726
    if (c2 <= 90UL) {
#line 726
      c2 |= 32UL;
    } else {
#line 726
      c2 = c2;
    }
  } else {
#line 726
    c2 = c2;
  }
#line 727
  last -= n;
  {
#line 729
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 730
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 731
      if ((unsigned long )s1 >= (unsigned long )last) {
#line 732
        return ((u_char *)((void *)0));
      }
#line 735
      tmp___0 = s1;
#line 735
      s1 ++;
#line 735
      c1 = (ngx_uint_t )*tmp___0;
#line 737
      if (c1 >= 65UL) {
#line 737
        if (c1 <= 90UL) {
#line 737
          c1 |= 32UL;
        } else {
#line 737
          c1 = c1;
        }
      } else {
#line 737
        c1 = c1;
      }
#line 730
      if (! (c1 != c2)) {
#line 730
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 729
    tmp___1 = ngx_strncasecmp(s1, s2, n);
    }
#line 729
    if (! (tmp___1 != 0L)) {
#line 729
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  s1 --;
#line 743
  return (s1);
}
}
#line 747 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_rstrncmp(u_char *s1 , u_char *s2 , size_t___0 n ) 
{ 


  {
#line 750
  if (n == 0UL) {
#line 751
    return ((ngx_int_t )0);
  }
#line 754
  n --;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 757
    if ((int )*(s1 + n) != (int )*(s2 + n)) {
#line 758
      return ((ngx_int_t )((int )*(s1 + n) - (int )*(s2 + n)));
    }
#line 761
    if (n == 0UL) {
#line 762
      return ((ngx_int_t )0);
    }
#line 765
    n --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 770 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_rstrncasecmp(u_char *s1 , u_char *s2 , size_t___0 n ) 
{ 
  u_char c1 ;
  u_char c2 ;

  {
#line 775
  if (n == 0UL) {
#line 776
    return ((ngx_int_t )0);
  }
#line 779
  n --;
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 782
    c1 = *(s1 + n);
#line 783
    if ((int )c1 >= 97) {
#line 783
      if ((int )c1 <= 122) {
#line 784
        c1 = (u_char )((int )c1 - 32);
      }
    }
#line 787
    c2 = *(s2 + n);
#line 788
    if ((int )c2 >= 97) {
#line 788
      if ((int )c2 <= 122) {
#line 789
        c2 = (u_char )((int )c2 - 32);
      }
    }
#line 792
    if ((int )c1 != (int )c2) {
#line 793
      return ((ngx_int_t )((int )c1 - (int )c2));
    }
#line 796
    if (n == 0UL) {
#line 797
      return ((ngx_int_t )0);
    }
#line 800
    n --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 805 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_memn2cmp(u_char *s1 , u_char *s2 , size_t___0 n1 , size_t___0 n2 ) 
{ 
  size_t___0 n ;
  ngx_int_t m ;
  ngx_int_t z ;
  int tmp ;

  {
#line 811
  if (n1 <= n2) {
#line 812
    n = n1;
#line 813
    z = (ngx_int_t )-1;
  } else {
#line 816
    n = n2;
#line 817
    z = (ngx_int_t )1;
  }
  {
#line 820
  tmp = memcmp((void const   *)((char const   *)s1), (void const   *)((char const   *)s2),
               n);
#line 820
  m = (ngx_int_t )tmp;
  }
#line 822
  if (m) {
#line 823
    return (m);
  } else
#line 822
  if (n1 == n2) {
#line 823
    return (m);
  }
#line 826
  return (z);
}
}
#line 830 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_dns_strcmp(u_char *s1 , u_char *s2 ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    tmp = s1;
#line 836
    s1 ++;
#line 836
    c1 = (ngx_uint_t )*tmp;
#line 837
    tmp___0 = s2;
#line 837
    s2 ++;
#line 837
    c2 = (ngx_uint_t )*tmp___0;
#line 839
    if (c1 >= 65UL) {
#line 839
      if (c1 <= 90UL) {
#line 839
        c1 |= 32UL;
      } else {
#line 839
        c1 = c1;
      }
    } else {
#line 839
      c1 = c1;
    }
#line 840
    if (c2 >= 65UL) {
#line 840
      if (c2 <= 90UL) {
#line 840
        c2 |= 32UL;
      } else {
#line 840
        c2 = c2;
      }
    } else {
#line 840
      c2 = c2;
    }
#line 842
    if (c1 == c2) {
#line 844
      if (c1) {
#line 845
        goto __Cont;
      }
#line 848
      return ((ngx_int_t )0);
    }
#line 853
    if (c1 == 46UL) {
#line 853
      c1 = (ngx_uint_t )' ';
    } else {
#line 853
      c1 = c1;
    }
#line 854
    if (c2 == 46UL) {
#line 854
      c2 = (ngx_uint_t )' ';
    } else {
#line 854
      c2 = c2;
    }
#line 856
    return ((ngx_int_t )(c1 - c2));
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 861 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_filename_cmp(u_char *s1 , u_char *s2 , size_t___0 n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! n) {
#line 866
      goto while_break;
    }
#line 867
    tmp = s1;
#line 867
    s1 ++;
#line 867
    c1 = (ngx_uint_t )*tmp;
#line 868
    tmp___0 = s2;
#line 868
    s2 ++;
#line 868
    c2 = (ngx_uint_t )*tmp___0;
#line 875
    if (c1 == c2) {
#line 877
      if (c1) {
#line 878
        n --;
#line 879
        goto while_continue;
      }
#line 882
      return ((ngx_int_t )0);
    }
#line 887
    if (c1 == 0UL) {
#line 888
      return ((ngx_int_t )(c1 - c2));
    } else
#line 887
    if (c2 == 0UL) {
#line 888
      return ((ngx_int_t )(c1 - c2));
    }
#line 891
    if (c1 == 47UL) {
#line 891
      c1 = (ngx_uint_t )0;
    } else {
#line 891
      c1 = c1;
    }
#line 892
    if (c2 == 47UL) {
#line 892
      c2 = (ngx_uint_t )0;
    } else {
#line 892
      c2 = c2;
    }
#line 894
    return ((ngx_int_t )(c1 - c2));
  }
  while_break: /* CIL Label */ ;
  }
#line 897
  return ((ngx_int_t )0);
}
}
#line 901 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_atoi(u_char *line , size_t___0 n ) 
{ 
  ngx_int_t value ;
  ngx_int_t cutoff ;
  ngx_int_t cutlim ;
  size_t___0 tmp ;

  {
#line 906
  if (n == 0UL) {
#line 907
    return ((ngx_int_t )-1);
  }
#line 910
  cutoff = 922337203685477580L;
#line 911
  cutlim = 7L;
#line 913
  value = (ngx_int_t )0;
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    tmp = n;
#line 913
    n --;
#line 913
    if (! tmp) {
#line 913
      goto while_break;
    }
#line 914
    if ((int )*line < 48) {
#line 915
      return ((ngx_int_t )-1);
    } else
#line 914
    if ((int )*line > 57) {
#line 915
      return ((ngx_int_t )-1);
    }
#line 918
    if (value >= cutoff) {
#line 918
      if (value > cutoff) {
#line 919
        return ((ngx_int_t )-1);
      } else
#line 918
      if ((ngx_int_t )((int )*line - 48) > cutlim) {
#line 919
        return ((ngx_int_t )-1);
      }
    }
#line 922
    value = value * 10L + (ngx_int_t )((int )*line - 48);
#line 913
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 925
  return (value);
}
}
#line 931 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_atofp(u_char *line , size_t___0 n , size_t___0 point ) 
{ 
  ngx_int_t value ;
  ngx_int_t cutoff ;
  ngx_int_t cutlim ;
  ngx_uint_t dot ;
  size_t___0 tmp ;
  size_t___0 tmp___0 ;

  {
#line 937
  if (n == 0UL) {
#line 938
    return ((ngx_int_t )-1);
  }
#line 941
  cutoff = 922337203685477580L;
#line 942
  cutlim = 7L;
#line 944
  dot = (ngx_uint_t )0;
#line 946
  value = (ngx_int_t )0;
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;
#line 946
    tmp = n;
#line 946
    n --;
#line 946
    if (! tmp) {
#line 946
      goto while_break;
    }
#line 948
    if (point == 0UL) {
#line 949
      return ((ngx_int_t )-1);
    }
#line 952
    if ((int )*line == 46) {
#line 953
      if (dot) {
#line 954
        return ((ngx_int_t )-1);
      }
#line 957
      dot = (ngx_uint_t )1;
#line 958
      goto __Cont;
    }
#line 961
    if ((int )*line < 48) {
#line 962
      return ((ngx_int_t )-1);
    } else
#line 961
    if ((int )*line > 57) {
#line 962
      return ((ngx_int_t )-1);
    }
#line 965
    if (value >= cutoff) {
#line 965
      if (value > cutoff) {
#line 966
        return ((ngx_int_t )-1);
      } else
#line 965
      if ((ngx_int_t )((int )*line - 48) > cutlim) {
#line 966
        return ((ngx_int_t )-1);
      }
    }
#line 969
    value = value * 10L + (ngx_int_t )((int )*line - 48);
#line 970
    point -= dot;
    __Cont: /* CIL Label */ 
#line 946
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 973
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 973
    tmp___0 = point;
#line 973
    point --;
#line 973
    if (! tmp___0) {
#line 973
      goto while_break___0;
    }
#line 974
    if (value > cutoff) {
#line 975
      return ((ngx_int_t )-1);
    }
#line 978
    value *= 10L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 981
  return (value);
}
}
#line 985 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ssize_t ngx_atosz(u_char *line , size_t___0 n ) 
{ 
  ssize_t value ;
  ssize_t cutoff ;
  ssize_t cutlim ;
  size_t___0 tmp ;

  {
#line 990
  if (n == 0UL) {
#line 991
    return ((ssize_t )-1);
  }
#line 994
  cutoff = (ssize_t )922337203685477580LL;
#line 995
  cutlim = (ssize_t )7LL;
#line 997
  value = (ssize_t )0;
  {
#line 997
  while (1) {
    while_continue: /* CIL Label */ ;
#line 997
    tmp = n;
#line 997
    n --;
#line 997
    if (! tmp) {
#line 997
      goto while_break;
    }
#line 998
    if ((int )*line < 48) {
#line 999
      return ((ssize_t )-1);
    } else
#line 998
    if ((int )*line > 57) {
#line 999
      return ((ssize_t )-1);
    }
#line 1002
    if (value >= cutoff) {
#line 1002
      if (value > cutoff) {
#line 1003
        return ((ssize_t )-1);
      } else
#line 1002
      if ((ssize_t )((int )*line - 48) > cutlim) {
#line 1003
        return ((ssize_t )-1);
      }
    }
#line 1006
    value = value * 10L + (ssize_t )((int )*line - 48);
#line 997
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1009
  return (value);
}
}
#line 1013 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
off_t ngx_atoof(u_char *line , size_t___0 n ) 
{ 
  off_t value ;
  off_t cutoff ;
  off_t cutlim ;
  size_t___0 tmp ;

  {
#line 1018
  if (n == 0UL) {
#line 1019
    return ((off_t )-1);
  }
#line 1022
  cutoff = (off_t )922337203685477580LL;
#line 1023
  cutlim = (off_t )7LL;
#line 1025
  value = (off_t )0;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    tmp = n;
#line 1025
    n --;
#line 1025
    if (! tmp) {
#line 1025
      goto while_break;
    }
#line 1026
    if ((int )*line < 48) {
#line 1027
      return ((off_t )-1);
    } else
#line 1026
    if ((int )*line > 57) {
#line 1027
      return ((off_t )-1);
    }
#line 1030
    if (value >= cutoff) {
#line 1030
      if (value > cutoff) {
#line 1031
        return ((off_t )-1);
      } else
#line 1030
      if ((off_t )((int )*line - 48) > cutlim) {
#line 1031
        return ((off_t )-1);
      }
    }
#line 1034
    value = value * 10L + (off_t )((int )*line - 48);
#line 1025
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1037
  return (value);
}
}
#line 1041 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
time_t ngx_atotm(u_char *line , size_t___0 n ) 
{ 
  time_t value ;
  time_t cutoff ;
  time_t cutlim ;
  size_t___0 tmp ;

  {
#line 1046
  if (n == 0UL) {
#line 1047
    return ((time_t )-1);
  }
#line 1050
  cutoff = (time_t )922337203685477580LL;
#line 1051
  cutlim = (time_t )7LL;
#line 1053
  value = (time_t )0;
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    tmp = n;
#line 1053
    n --;
#line 1053
    if (! tmp) {
#line 1053
      goto while_break;
    }
#line 1054
    if ((int )*line < 48) {
#line 1055
      return ((time_t )-1);
    } else
#line 1054
    if ((int )*line > 57) {
#line 1055
      return ((time_t )-1);
    }
#line 1058
    if (value >= cutoff) {
#line 1058
      if (value > cutoff) {
#line 1059
        return ((time_t )-1);
      } else
#line 1058
      if ((time_t )((int )*line - 48) > cutlim) {
#line 1059
        return ((time_t )-1);
      }
    }
#line 1062
    value = value * 10L + (time_t )((int )*line - 48);
#line 1053
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1065
  return (value);
}
}
#line 1069 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_hextoi(u_char *line , size_t___0 n ) 
{ 
  u_char c ;
  u_char ch ;
  ngx_int_t value ;
  ngx_int_t cutoff ;
  size_t___0 tmp ;

  {
#line 1075
  if (n == 0UL) {
#line 1076
    return ((ngx_int_t )-1);
  }
#line 1079
  cutoff = 576460752303423487L;
#line 1081
  value = (ngx_int_t )0;
  {
#line 1081
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1081
    tmp = n;
#line 1081
    n --;
#line 1081
    if (! tmp) {
#line 1081
      goto while_break;
    }
#line 1082
    if (value > cutoff) {
#line 1083
      return ((ngx_int_t )-1);
    }
#line 1086
    ch = *line;
#line 1088
    if ((int )ch >= 48) {
#line 1088
      if ((int )ch <= 57) {
#line 1089
        value = value * 16L + (ngx_int_t )((int )ch - 48);
#line 1090
        goto __Cont;
      }
    }
#line 1093
    c = (u_char )((int )ch | 32);
#line 1095
    if ((int )c >= 97) {
#line 1095
      if ((int )c <= 102) {
#line 1096
        value = value * 16L + (ngx_int_t )(((int )c - 97) + 10);
#line 1097
        goto __Cont;
      }
    }
#line 1100
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ 
#line 1081
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1103
  return (value);
}
}
#line 1110 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char hex___1[17]  = 
#line 1110
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'\000'};
#line 1107 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_hex_dump(u_char *dst , u_char *src , size_t___0 len ) 
{ 
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  size_t___0 tmp___2 ;

  {
  {
#line 1112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1112
    tmp___2 = len;
#line 1112
    len --;
#line 1112
    if (! tmp___2) {
#line 1112
      goto while_break;
    }
#line 1113
    tmp = dst;
#line 1113
    dst ++;
#line 1113
    *tmp = hex___1[(int )*src >> 4];
#line 1114
    tmp___0 = dst;
#line 1114
    dst ++;
#line 1114
    tmp___1 = src;
#line 1114
    src ++;
#line 1114
    *tmp___0 = hex___1[(int )*tmp___1 & 15];
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  return (dst);
}
}
#line 1124 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char basis64[65]  = 
#line 1124
  {      (u_char )'A',      (u_char )'B',      (u_char )'C',      (u_char )'D', 
        (u_char )'E',      (u_char )'F',      (u_char )'G',      (u_char )'H', 
        (u_char )'I',      (u_char )'J',      (u_char )'K',      (u_char )'L', 
        (u_char )'M',      (u_char )'N',      (u_char )'O',      (u_char )'P', 
        (u_char )'Q',      (u_char )'R',      (u_char )'S',      (u_char )'T', 
        (u_char )'U',      (u_char )'V',      (u_char )'W',      (u_char )'X', 
        (u_char )'Y',      (u_char )'Z',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'g',      (u_char )'h',      (u_char )'i',      (u_char )'j', 
        (u_char )'k',      (u_char )'l',      (u_char )'m',      (u_char )'n', 
        (u_char )'o',      (u_char )'p',      (u_char )'q',      (u_char )'r', 
        (u_char )'s',      (u_char )'t',      (u_char )'u',      (u_char )'v', 
        (u_char )'w',      (u_char )'x',      (u_char )'y',      (u_char )'z', 
        (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'+',      (u_char )'/', 
        (u_char )'\000'};
#line 1121 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
void ngx_encode_base64(ngx_str_t *dst , ngx_str_t *src ) 
{ 


  {
  {
#line 1127
  ngx_encode_base64_internal(dst, src, (u_char const   *)(basis64), (ngx_uint_t )1);
  }
#line 1128
  return;
}
}
#line 1134 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char basis64___0[65]  = 
#line 1134
  {      (u_char )'A',      (u_char )'B',      (u_char )'C',      (u_char )'D', 
        (u_char )'E',      (u_char )'F',      (u_char )'G',      (u_char )'H', 
        (u_char )'I',      (u_char )'J',      (u_char )'K',      (u_char )'L', 
        (u_char )'M',      (u_char )'N',      (u_char )'O',      (u_char )'P', 
        (u_char )'Q',      (u_char )'R',      (u_char )'S',      (u_char )'T', 
        (u_char )'U',      (u_char )'V',      (u_char )'W',      (u_char )'X', 
        (u_char )'Y',      (u_char )'Z',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'g',      (u_char )'h',      (u_char )'i',      (u_char )'j', 
        (u_char )'k',      (u_char )'l',      (u_char )'m',      (u_char )'n', 
        (u_char )'o',      (u_char )'p',      (u_char )'q',      (u_char )'r', 
        (u_char )'s',      (u_char )'t',      (u_char )'u',      (u_char )'v', 
        (u_char )'w',      (u_char )'x',      (u_char )'y',      (u_char )'z', 
        (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'-',      (u_char )'_', 
        (u_char )'\000'};
#line 1131 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
void ngx_encode_base64url(ngx_str_t *dst , ngx_str_t *src ) 
{ 


  {
  {
#line 1137
  ngx_encode_base64_internal(dst, src, (u_char const   *)(basis64___0), (ngx_uint_t )0);
  }
#line 1138
  return;
}
}
#line 1141 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static void ngx_encode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ,
                                       ngx_uint_t padding ) 
{ 
  u_char *d ;
  u_char *s ;
  size_t___0 len ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;

  {
#line 1148
  len = src->len;
#line 1149
  s = src->data;
#line 1150
  d = dst->data;
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    if (! (len > 2UL)) {
#line 1152
      goto while_break;
    }
#line 1153
    tmp = d;
#line 1153
    d ++;
#line 1153
    *tmp = (u_char )*(basis + (((int )*(s + 0) >> 2) & 63));
#line 1154
    tmp___0 = d;
#line 1154
    d ++;
#line 1154
    *tmp___0 = (u_char )*(basis + ((((int )*(s + 0) & 3) << 4) | ((int )*(s + 1) >> 4)));
#line 1155
    tmp___1 = d;
#line 1155
    d ++;
#line 1155
    *tmp___1 = (u_char )*(basis + ((((int )*(s + 1) & 15) << 2) | ((int )*(s + 2) >> 6)));
#line 1156
    tmp___2 = d;
#line 1156
    d ++;
#line 1156
    *tmp___2 = (u_char )*(basis + ((int )*(s + 2) & 63));
#line 1158
    s += 3;
#line 1159
    len -= 3UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 1162
  if (len) {
#line 1163
    tmp___3 = d;
#line 1163
    d ++;
#line 1163
    *tmp___3 = (u_char )*(basis + (((int )*(s + 0) >> 2) & 63));
#line 1165
    if (len == 1UL) {
#line 1166
      tmp___4 = d;
#line 1166
      d ++;
#line 1166
      *tmp___4 = (u_char )*(basis + (((int )*(s + 0) & 3) << 4));
#line 1167
      if (padding) {
#line 1168
        tmp___5 = d;
#line 1168
        d ++;
#line 1168
        *tmp___5 = (u_char )'=';
      }
    } else {
#line 1172
      tmp___6 = d;
#line 1172
      d ++;
#line 1172
      *tmp___6 = (u_char )*(basis + ((((int )*(s + 0) & 3) << 4) | ((int )*(s + 1) >> 4)));
#line 1173
      tmp___7 = d;
#line 1173
      d ++;
#line 1173
      *tmp___7 = (u_char )*(basis + (((int )*(s + 1) & 15) << 2));
    }
#line 1176
    if (padding) {
#line 1177
      tmp___8 = d;
#line 1177
      d ++;
#line 1177
      *tmp___8 = (u_char )'=';
    }
  }
#line 1181
  dst->len = (size_t___0 )(d - dst->data);
#line 1182
  return;
}
}
#line 1188 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char basis64___1[256]  = 
#line 1188
  {      (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )62, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )63, 
        (u_char )52,      (u_char )53,      (u_char )54,      (u_char )55, 
        (u_char )56,      (u_char )57,      (u_char )58,      (u_char )59, 
        (u_char )60,      (u_char )61,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )0,      (u_char )1,      (u_char )2, 
        (u_char )3,      (u_char )4,      (u_char )5,      (u_char )6, 
        (u_char )7,      (u_char )8,      (u_char )9,      (u_char )10, 
        (u_char )11,      (u_char )12,      (u_char )13,      (u_char )14, 
        (u_char )15,      (u_char )16,      (u_char )17,      (u_char )18, 
        (u_char )19,      (u_char )20,      (u_char )21,      (u_char )22, 
        (u_char )23,      (u_char )24,      (u_char )25,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )26,      (u_char )27,      (u_char )28, 
        (u_char )29,      (u_char )30,      (u_char )31,      (u_char )32, 
        (u_char )33,      (u_char )34,      (u_char )35,      (u_char )36, 
        (u_char )37,      (u_char )38,      (u_char )39,      (u_char )40, 
        (u_char )41,      (u_char )42,      (u_char )43,      (u_char )44, 
        (u_char )45,      (u_char )46,      (u_char )47,      (u_char )48, 
        (u_char )49,      (u_char )50,      (u_char )51,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77};
#line 1185 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_decode_base64(ngx_str_t *dst , ngx_str_t *src ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 1208
  tmp = ngx_decode_base64_internal(dst, src, (u_char const   *)(basis64___1));
  }
#line 1208
  return (tmp);
}
}
#line 1215 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char basis64___2[256]  = 
#line 1215
  {      (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )62,      (u_char )77,      (u_char )77, 
        (u_char )52,      (u_char )53,      (u_char )54,      (u_char )55, 
        (u_char )56,      (u_char )57,      (u_char )58,      (u_char )59, 
        (u_char )60,      (u_char )61,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )0,      (u_char )1,      (u_char )2, 
        (u_char )3,      (u_char )4,      (u_char )5,      (u_char )6, 
        (u_char )7,      (u_char )8,      (u_char )9,      (u_char )10, 
        (u_char )11,      (u_char )12,      (u_char )13,      (u_char )14, 
        (u_char )15,      (u_char )16,      (u_char )17,      (u_char )18, 
        (u_char )19,      (u_char )20,      (u_char )21,      (u_char )22, 
        (u_char )23,      (u_char )24,      (u_char )25,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )63, 
        (u_char )77,      (u_char )26,      (u_char )27,      (u_char )28, 
        (u_char )29,      (u_char )30,      (u_char )31,      (u_char )32, 
        (u_char )33,      (u_char )34,      (u_char )35,      (u_char )36, 
        (u_char )37,      (u_char )38,      (u_char )39,      (u_char )40, 
        (u_char )41,      (u_char )42,      (u_char )43,      (u_char )44, 
        (u_char )45,      (u_char )46,      (u_char )47,      (u_char )48, 
        (u_char )49,      (u_char )50,      (u_char )51,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77};
#line 1212 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_int_t ngx_decode_base64url(ngx_str_t *dst , ngx_str_t *src ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 1235
  tmp = ngx_decode_base64_internal(dst, src, (u_char const   *)(basis64___2));
  }
#line 1235
  return (tmp);
}
}
#line 1239 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static ngx_int_t ngx_decode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ) 
{ 
  size_t___0 len ;
  u_char *d ;
  u_char *s ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;

  {
#line 1245
  len = (size_t___0 )0;
  {
#line 1245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1245
    if (! (len < src->len)) {
#line 1245
      goto while_break;
    }
#line 1246
    if ((int )*(src->data + len) == 61) {
#line 1247
      goto while_break;
    }
#line 1250
    if ((int const   )*(basis + *(src->data + len)) == 77) {
#line 1251
      return ((ngx_int_t )-1);
    }
#line 1245
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1255
  if (len % 4UL == 1UL) {
#line 1256
    return ((ngx_int_t )-1);
  }
#line 1259
  s = src->data;
#line 1260
  d = dst->data;
  {
#line 1262
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1262
    if (! (len > 3UL)) {
#line 1262
      goto while_break___0;
    }
#line 1263
    tmp = d;
#line 1263
    d ++;
#line 1263
    *tmp = (u_char )(((int const   )*(basis + *(s + 0)) << 2) | ((int const   )*(basis + *(s + 1)) >> 4));
#line 1264
    tmp___0 = d;
#line 1264
    d ++;
#line 1264
    *tmp___0 = (u_char )(((int const   )*(basis + *(s + 1)) << 4) | ((int const   )*(basis + *(s + 2)) >> 2));
#line 1265
    tmp___1 = d;
#line 1265
    d ++;
#line 1265
    *tmp___1 = (u_char )(((int const   )*(basis + *(s + 2)) << 6) | (int const   )*(basis + *(s + 3)));
#line 1267
    s += 4;
#line 1268
    len -= 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1271
  if (len > 1UL) {
#line 1272
    tmp___2 = d;
#line 1272
    d ++;
#line 1272
    *tmp___2 = (u_char )(((int const   )*(basis + *(s + 0)) << 2) | ((int const   )*(basis + *(s + 1)) >> 4));
  }
#line 1275
  if (len > 2UL) {
#line 1276
    tmp___3 = d;
#line 1276
    d ++;
#line 1276
    *tmp___3 = (u_char )(((int const   )*(basis + *(s + 1)) << 4) | ((int const   )*(basis + *(s + 2)) >> 2));
  }
#line 1279
  dst->len = (size_t___0 )(d - dst->data);
#line 1281
  return ((ngx_int_t )0);
}
}
#line 1294 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
uint32_t ngx_utf8_decode(u_char **p , size_t___0 n ) 
{ 
  size_t___0 len ;
  uint32_t u ;
  uint32_t i ;
  uint32_t valid ;
  u_char *tmp ;

  {
#line 1300
  u = (uint32_t )*(*p);
#line 1302
  if (u >= 240U) {
#line 1304
    u &= 7U;
#line 1305
    valid = (uint32_t )65535;
#line 1306
    len = (size_t___0 )3;
  } else
#line 1308
  if (u >= 224U) {
#line 1310
    u &= 15U;
#line 1311
    valid = (uint32_t )2047;
#line 1312
    len = (size_t___0 )2;
  } else
#line 1314
  if (u >= 194U) {
#line 1316
    u &= 31U;
#line 1317
    valid = (uint32_t )127;
#line 1318
    len = (size_t___0 )1;
  } else {
#line 1321
    (*p) ++;
#line 1322
    return (4294967295U);
  }
#line 1325
  if (n - 1UL < len) {
#line 1326
    return (4294967294U);
  }
#line 1329
  (*p) ++;
  {
#line 1331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1331
    if (! len) {
#line 1331
      goto while_break;
    }
#line 1332
    tmp = *p;
#line 1332
    (*p) ++;
#line 1332
    i = (uint32_t )*tmp;
#line 1334
    if (i < 128U) {
#line 1335
      return (4294967295U);
    }
#line 1338
    u = (u << 6) | (i & 63U);
#line 1340
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1343
  if (u > valid) {
#line 1344
    return (u);
  }
#line 1347
  return (4294967295U);
}
}
#line 1351 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
size_t___0 ngx_utf8_length(u_char *p , size_t___0 n ) 
{ 
  u_char c ;
  u_char *last ;
  size_t___0 len ;
  uint32_t tmp ;

  {
#line 1357
  last = p + n;
#line 1359
  len = (size_t___0 )0;
  {
#line 1359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1359
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 1359
      goto while_break;
    }
#line 1361
    c = *p;
#line 1363
    if ((int )c < 128) {
#line 1364
      p ++;
#line 1365
      goto __Cont;
    }
    {
#line 1368
    tmp = ngx_utf8_decode(& p, n);
    }
#line 1368
    if (tmp > 1114111U) {
#line 1370
      return (n);
    }
    __Cont: /* CIL Label */ 
#line 1359
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1374
  return (len);
}
}
#line 1378 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
u_char *ngx_utf8_cpystrn(u_char *dst , u_char *src , size_t___0 n , size_t___0 len ) 
{ 
  u_char c ;
  u_char *next ;
  uint32_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 1383
  if (n == 0UL) {
#line 1384
    return (dst);
  }
  {
#line 1387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    n --;
#line 1387
    if (! n) {
#line 1387
      goto while_break;
    }
#line 1389
    c = *src;
#line 1390
    *dst = c;
#line 1392
    if ((int )c < 128) {
#line 1394
      if ((int )c != 0) {
#line 1395
        dst ++;
#line 1396
        src ++;
#line 1397
        len --;
#line 1399
        goto while_continue;
      }
#line 1402
      return (dst);
    }
    {
#line 1405
    next = src;
#line 1407
    tmp = ngx_utf8_decode(& next, len);
    }
#line 1407
    if (tmp > 1114111U) {
#line 1409
      goto while_break;
    }
    {
#line 1412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1412
      if (! ((unsigned long )src < (unsigned long )next)) {
#line 1412
        goto while_break___0;
      }
#line 1413
      tmp___0 = dst;
#line 1413
      dst ++;
#line 1413
      tmp___1 = src;
#line 1413
      src ++;
#line 1413
      *tmp___0 = *tmp___1;
#line 1414
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1418
  *dst = (u_char )'\000';
#line 1420
  return (dst);
}
}
#line 1429 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static u_char hex___2[17]  = 
#line 1429
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'A',      (u_char )'B', 
        (u_char )'C',      (u_char )'D',      (u_char )'E',      (u_char )'F', 
        (u_char )'\000'};
#line 1433 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static uint32_t uri[8]  = 
#line 1433
  {      4294967295U,      2147483689U,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1453 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static uint32_t args[8]  = 
#line 1453
  {      4294967295U,      2281703529U,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1473 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static uint32_t uri_component[8]  = 
#line 1473
  {      4294967295U,      4227899391U,      (uint32_t )2013265921,      3087007745U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1493 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static uint32_t html[8]  = 
#line 1493
  {      4294967295U,      (uint32_t )173,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1513 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static uint32_t refresh[8]  = 
#line 1513
  {      4294967295U,      (uint32_t )133,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1533 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static uint32_t memcached[8]  = 
#line 1533
  {      4294967295U,      (uint32_t )33,      (uint32_t )0,      (uint32_t )0, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0};
#line 1553 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
static uint32_t *map[7]  = {      uri,      args,      uri_component,      html, 
        refresh,      memcached,      memcached};
#line 1424 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
uintptr_t ngx_escape_uri(u_char *dst , u_char *src , size_t___0 size , ngx_uint_t type ) 
{ 
  ngx_uint_t n ;
  uint32_t *escape___0 ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;

  {
#line 1557
  escape___0 = map[type];
#line 1559
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1563
    n = (ngx_uint_t )0;
    {
#line 1565
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1565
      if (! size) {
#line 1565
        goto while_break;
      }
#line 1566
      if (*(escape___0 + ((int )*src >> 5)) & (1U << ((int )*src & 31))) {
#line 1567
        n ++;
      }
#line 1569
      src ++;
#line 1570
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1573
    return (n);
  }
  {
#line 1576
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1576
    if (! size) {
#line 1576
      goto while_break___0;
    }
#line 1577
    if (*(escape___0 + ((int )*src >> 5)) & (1U << ((int )*src & 31))) {
#line 1578
      tmp = dst;
#line 1578
      dst ++;
#line 1578
      *tmp = (u_char )'%';
#line 1579
      tmp___0 = dst;
#line 1579
      dst ++;
#line 1579
      *tmp___0 = hex___2[(int )*src >> 4];
#line 1580
      tmp___1 = dst;
#line 1580
      dst ++;
#line 1580
      *tmp___1 = hex___2[(int )*src & 15];
#line 1581
      src ++;
    } else {
#line 1584
      tmp___2 = dst;
#line 1584
      dst ++;
#line 1584
      tmp___3 = src;
#line 1584
      src ++;
#line 1584
      *tmp___2 = *tmp___3;
    }
#line 1586
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1589
  return ((uintptr_t )dst);
}
}
#line 1593 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
void ngx_unescape_uri(u_char **dst , u_char **src , size_t___0 size , ngx_uint_t type ) 
{ 
  u_char *d ;
  u_char *s ;
  u_char ch ;
  u_char c ;
  u_char decoded ;
  enum __anonenum_state_948761466 state ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  size_t___0 tmp___16 ;

  {
#line 1603
  d = *dst;
#line 1604
  s = *src;
#line 1606
  state = (enum __anonenum_state_948761466 )0;
#line 1607
  decoded = (u_char )0;
  {
#line 1609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1609
    tmp___16 = size;
#line 1609
    size --;
#line 1609
    if (! tmp___16) {
#line 1609
      goto while_break;
    }
#line 1611
    tmp = s;
#line 1611
    s ++;
#line 1611
    ch = *tmp;
    {
#line 1614
    if ((unsigned int )state == 0U) {
#line 1614
      goto case_0;
    }
#line 1630
    if ((unsigned int )state == 1U) {
#line 1630
      goto case_1;
    }
#line 1653
    if ((unsigned int )state == 2U) {
#line 1653
      goto case_2;
    }
#line 1613
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1615
    if ((int )ch == 63) {
#line 1615
      if (type & 3UL) {
#line 1618
        tmp___0 = d;
#line 1618
        d ++;
#line 1618
        *tmp___0 = ch;
#line 1619
        goto done;
      }
    }
#line 1622
    if ((int )ch == 37) {
#line 1623
      state = (enum __anonenum_state_948761466 )1;
#line 1624
      goto switch_break;
    }
#line 1627
    tmp___1 = d;
#line 1627
    d ++;
#line 1627
    *tmp___1 = ch;
#line 1628
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1632
    if ((int )ch >= 48) {
#line 1632
      if ((int )ch <= 57) {
#line 1633
        decoded = (u_char )((int )ch - 48);
#line 1634
        state = (enum __anonenum_state_948761466 )2;
#line 1635
        goto switch_break;
      }
    }
#line 1638
    c = (u_char )((int )ch | 32);
#line 1639
    if ((int )c >= 97) {
#line 1639
      if ((int )c <= 102) {
#line 1640
        decoded = (u_char )(((int )c - 97) + 10);
#line 1641
        state = (enum __anonenum_state_948761466 )2;
#line 1642
        goto switch_break;
      }
    }
#line 1647
    state = (enum __anonenum_state_948761466 )0;
#line 1649
    tmp___2 = d;
#line 1649
    d ++;
#line 1649
    *tmp___2 = ch;
#line 1651
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1655
    state = (enum __anonenum_state_948761466 )0;
#line 1657
    if ((int )ch >= 48) {
#line 1657
      if ((int )ch <= 57) {
#line 1658
        ch = (u_char )((((int )decoded << 4) + (int )ch) - 48);
#line 1660
        if (type & 2UL) {
#line 1661
          if ((int )ch > 37) {
#line 1661
            if ((int )ch < 127) {
#line 1662
              tmp___3 = d;
#line 1662
              d ++;
#line 1662
              *tmp___3 = ch;
#line 1663
              goto switch_break;
            }
          }
#line 1666
          tmp___4 = d;
#line 1666
          d ++;
#line 1666
          *tmp___4 = (u_char )'%';
#line 1666
          tmp___5 = d;
#line 1666
          d ++;
#line 1666
          *tmp___5 = *(s - 2);
#line 1666
          tmp___6 = d;
#line 1666
          d ++;
#line 1666
          *tmp___6 = *(s - 1);
#line 1668
          goto switch_break;
        }
#line 1671
        tmp___7 = d;
#line 1671
        d ++;
#line 1671
        *tmp___7 = ch;
#line 1673
        goto switch_break;
      }
    }
#line 1676
    c = (u_char )((int )ch | 32);
#line 1677
    if ((int )c >= 97) {
#line 1677
      if ((int )c <= 102) {
#line 1678
        ch = (u_char )(((((int )decoded << 4) + (int )c) - 97) + 10);
#line 1680
        if (type & 1UL) {
#line 1681
          if ((int )ch == 63) {
#line 1682
            tmp___8 = d;
#line 1682
            d ++;
#line 1682
            *tmp___8 = ch;
#line 1683
            goto done;
          }
#line 1686
          tmp___9 = d;
#line 1686
          d ++;
#line 1686
          *tmp___9 = ch;
#line 1687
          goto switch_break;
        }
#line 1690
        if (type & 2UL) {
#line 1691
          if ((int )ch == 63) {
#line 1692
            tmp___10 = d;
#line 1692
            d ++;
#line 1692
            *tmp___10 = ch;
#line 1693
            goto done;
          }
#line 1696
          if ((int )ch > 37) {
#line 1696
            if ((int )ch < 127) {
#line 1697
              tmp___11 = d;
#line 1697
              d ++;
#line 1697
              *tmp___11 = ch;
#line 1698
              goto switch_break;
            }
          }
#line 1701
          tmp___12 = d;
#line 1701
          d ++;
#line 1701
          *tmp___12 = (u_char )'%';
#line 1701
          tmp___13 = d;
#line 1701
          d ++;
#line 1701
          *tmp___13 = *(s - 2);
#line 1701
          tmp___14 = d;
#line 1701
          d ++;
#line 1701
          *tmp___14 = *(s - 1);
#line 1702
          goto switch_break;
        }
#line 1705
        tmp___15 = d;
#line 1705
        d ++;
#line 1705
        *tmp___15 = ch;
#line 1707
        goto switch_break;
      }
    }
#line 1712
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1718
  *dst = d;
#line 1719
  *src = s;
#line 1720
  return;
}
}
#line 1723 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
uintptr_t ngx_escape_html(u_char *dst , u_char *src , size_t___0 size ) 
{ 
  u_char ch ;
  ngx_uint_t len ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;

  {
#line 1729
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1731
    len = (ngx_uint_t )0;
    {
#line 1733
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1733
      if (! size) {
#line 1733
        goto while_break;
      }
#line 1734
      tmp = src;
#line 1734
      src ++;
      {
#line 1736
      if ((int )*tmp == 60) {
#line 1736
        goto case_60;
      }
#line 1740
      if ((int )*tmp == 62) {
#line 1740
        goto case_62;
      }
#line 1744
      if ((int )*tmp == 38) {
#line 1744
        goto case_38;
      }
#line 1748
      if ((int )*tmp == 34) {
#line 1748
        goto case_34;
      }
#line 1752
      goto switch_default;
      case_60: /* CIL Label */ 
#line 1737
      len += sizeof("&lt;") - 2UL;
#line 1738
      goto switch_break;
      case_62: /* CIL Label */ 
#line 1741
      len += sizeof("&gt;") - 2UL;
#line 1742
      goto switch_break;
      case_38: /* CIL Label */ 
#line 1745
      len += sizeof("&amp;") - 2UL;
#line 1746
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1749
      len += sizeof("&quot;") - 2UL;
#line 1750
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1753
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1755
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1758
    return (len);
  }
  {
#line 1761
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1761
    if (! size) {
#line 1761
      goto while_break___0;
    }
#line 1762
    tmp___0 = src;
#line 1762
    src ++;
#line 1762
    ch = *tmp___0;
    {
#line 1766
    if ((int )ch == 60) {
#line 1766
      goto case_60___0;
    }
#line 1770
    if ((int )ch == 62) {
#line 1770
      goto case_62___0;
    }
#line 1774
    if ((int )ch == 38) {
#line 1774
      goto case_38___0;
    }
#line 1779
    if ((int )ch == 34) {
#line 1779
      goto case_34___0;
    }
#line 1784
    goto switch_default___0;
    case_60___0: /* CIL Label */ 
#line 1767
    tmp___1 = dst;
#line 1767
    dst ++;
#line 1767
    *tmp___1 = (u_char )'&';
#line 1767
    tmp___2 = dst;
#line 1767
    dst ++;
#line 1767
    *tmp___2 = (u_char )'l';
#line 1767
    tmp___3 = dst;
#line 1767
    dst ++;
#line 1767
    *tmp___3 = (u_char )'t';
#line 1767
    tmp___4 = dst;
#line 1767
    dst ++;
#line 1767
    *tmp___4 = (u_char )';';
#line 1768
    goto switch_break___0;
    case_62___0: /* CIL Label */ 
#line 1771
    tmp___5 = dst;
#line 1771
    dst ++;
#line 1771
    *tmp___5 = (u_char )'&';
#line 1771
    tmp___6 = dst;
#line 1771
    dst ++;
#line 1771
    *tmp___6 = (u_char )'g';
#line 1771
    tmp___7 = dst;
#line 1771
    dst ++;
#line 1771
    *tmp___7 = (u_char )'t';
#line 1771
    tmp___8 = dst;
#line 1771
    dst ++;
#line 1771
    *tmp___8 = (u_char )';';
#line 1772
    goto switch_break___0;
    case_38___0: /* CIL Label */ 
#line 1775
    tmp___9 = dst;
#line 1775
    dst ++;
#line 1775
    *tmp___9 = (u_char )'&';
#line 1775
    tmp___10 = dst;
#line 1775
    dst ++;
#line 1775
    *tmp___10 = (u_char )'a';
#line 1775
    tmp___11 = dst;
#line 1775
    dst ++;
#line 1775
    *tmp___11 = (u_char )'m';
#line 1775
    tmp___12 = dst;
#line 1775
    dst ++;
#line 1775
    *tmp___12 = (u_char )'p';
#line 1776
    tmp___13 = dst;
#line 1776
    dst ++;
#line 1776
    *tmp___13 = (u_char )';';
#line 1777
    goto switch_break___0;
    case_34___0: /* CIL Label */ 
#line 1780
    tmp___14 = dst;
#line 1780
    dst ++;
#line 1780
    *tmp___14 = (u_char )'&';
#line 1780
    tmp___15 = dst;
#line 1780
    dst ++;
#line 1780
    *tmp___15 = (u_char )'q';
#line 1780
    tmp___16 = dst;
#line 1780
    dst ++;
#line 1780
    *tmp___16 = (u_char )'u';
#line 1780
    tmp___17 = dst;
#line 1780
    dst ++;
#line 1780
    *tmp___17 = (u_char )'o';
#line 1781
    tmp___18 = dst;
#line 1781
    dst ++;
#line 1781
    *tmp___18 = (u_char )'t';
#line 1781
    tmp___19 = dst;
#line 1781
    dst ++;
#line 1781
    *tmp___19 = (u_char )';';
#line 1782
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1785
    tmp___20 = dst;
#line 1785
    dst ++;
#line 1785
    *tmp___20 = ch;
#line 1786
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1788
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1791
  return ((uintptr_t )dst);
}
}
#line 1795 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
uintptr_t ngx_escape_json(u_char *dst , u_char *src , size_t___0 size ) 
{ 
  u_char ch ;
  ngx_uint_t len ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;

  {
#line 1801
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1802
    len = (ngx_uint_t )0;
    {
#line 1804
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1804
      if (! size) {
#line 1804
        goto while_break;
      }
#line 1805
      tmp = src;
#line 1805
      src ++;
#line 1805
      ch = *tmp;
#line 1807
      if ((int )ch == 92) {
#line 1808
        len ++;
      } else
#line 1807
      if ((int )ch == 34) {
#line 1808
        len ++;
      } else
#line 1810
      if ((int )ch <= 31) {
        {
#line 1817
        if ((int )ch == 12) {
#line 1817
          goto case_12;
        }
#line 1817
        if ((int )ch == 8) {
#line 1817
          goto case_12;
        }
#line 1817
        if ((int )ch == 9) {
#line 1817
          goto case_12;
        }
#line 1817
        if ((int )ch == 13) {
#line 1817
          goto case_12;
        }
#line 1817
        if ((int )ch == 10) {
#line 1817
          goto case_12;
        }
#line 1821
        goto switch_default;
        case_12: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_9: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_10: /* CIL Label */ 
#line 1818
        len ++;
#line 1819
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1822
        len += sizeof("\\u001F") - 2UL;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1826
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1829
    return (len);
  }
  {
#line 1832
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1832
    if (! size) {
#line 1832
      goto while_break___0;
    }
#line 1833
    tmp___0 = src;
#line 1833
    src ++;
#line 1833
    ch = *tmp___0;
#line 1835
    if ((int )ch > 31) {
#line 1837
      if ((int )ch == 92) {
#line 1838
        tmp___1 = dst;
#line 1838
        dst ++;
#line 1838
        *tmp___1 = (u_char )'\\';
      } else
#line 1837
      if ((int )ch == 34) {
#line 1838
        tmp___1 = dst;
#line 1838
        dst ++;
#line 1838
        *tmp___1 = (u_char )'\\';
      }
#line 1841
      tmp___2 = dst;
#line 1841
      dst ++;
#line 1841
      *tmp___2 = ch;
    } else {
#line 1844
      tmp___3 = dst;
#line 1844
      dst ++;
#line 1844
      *tmp___3 = (u_char )'\\';
      {
#line 1847
      if ((int )ch == 10) {
#line 1847
        goto case_10___0;
      }
#line 1851
      if ((int )ch == 13) {
#line 1851
        goto case_13___0;
      }
#line 1855
      if ((int )ch == 9) {
#line 1855
        goto case_9___0;
      }
#line 1859
      if ((int )ch == 8) {
#line 1859
        goto case_8___0;
      }
#line 1863
      if ((int )ch == 12) {
#line 1863
        goto case_12___0;
      }
#line 1867
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
#line 1848
      tmp___4 = dst;
#line 1848
      dst ++;
#line 1848
      *tmp___4 = (u_char )'n';
#line 1849
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
#line 1852
      tmp___5 = dst;
#line 1852
      dst ++;
#line 1852
      *tmp___5 = (u_char )'r';
#line 1853
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
#line 1856
      tmp___6 = dst;
#line 1856
      dst ++;
#line 1856
      *tmp___6 = (u_char )'t';
#line 1857
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
#line 1860
      tmp___7 = dst;
#line 1860
      dst ++;
#line 1860
      *tmp___7 = (u_char )'b';
#line 1861
      goto switch_break___0;
      case_12___0: /* CIL Label */ 
#line 1864
      tmp___8 = dst;
#line 1864
      dst ++;
#line 1864
      *tmp___8 = (u_char )'f';
#line 1865
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1868
      tmp___9 = dst;
#line 1868
      dst ++;
#line 1868
      *tmp___9 = (u_char )'u';
#line 1868
      tmp___10 = dst;
#line 1868
      dst ++;
#line 1868
      *tmp___10 = (u_char )'0';
#line 1868
      tmp___11 = dst;
#line 1868
      dst ++;
#line 1868
      *tmp___11 = (u_char )'0';
#line 1869
      tmp___12 = dst;
#line 1869
      dst ++;
#line 1869
      *tmp___12 = (u_char )(48 + ((int )ch >> 4));
#line 1871
      ch = (u_char )((int )ch & 15);
#line 1873
      tmp___13 = dst;
#line 1873
      dst ++;
#line 1873
      if ((int )ch < 10) {
#line 1873
        *tmp___13 = (u_char )(48 + (int )ch);
      } else {
#line 1873
        *tmp___13 = (u_char )((65 + (int )ch) - 10);
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1877
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1880
  return ((uintptr_t )dst);
}
}
#line 1884 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                 ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_str_node_t *n ;
  ngx_str_node_t *t ;
  ngx_rbtree_node_t **p ;
  int tmp___0 ;

  {
  {
#line 1891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1893
    n = (ngx_str_node_t *)node;
#line 1894
    t = (ngx_str_node_t *)temp;
#line 1896
    if (node->key != temp->key) {
#line 1898
      if (node->key < temp->key) {
#line 1898
        p = & temp->left;
      } else {
#line 1898
        p = & temp->right;
      }
    } else
#line 1900
    if (n->str.len != t->str.len) {
#line 1902
      if (n->str.len < t->str.len) {
#line 1902
        p = & temp->left;
      } else {
#line 1902
        p = & temp->right;
      }
    } else {
      {
#line 1905
      tmp___0 = memcmp((void const   *)((char const   *)n->str.data), (void const   *)((char const   *)t->str.data),
                       n->str.len);
      }
#line 1905
      if (tmp___0 < 0) {
#line 1905
        p = & temp->left;
      } else {
#line 1905
        p = & temp->right;
      }
    }
#line 1909
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 1910
      goto while_break;
    }
#line 1913
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 1916
  *p = node;
#line 1917
  node->parent = temp;
#line 1918
  node->left = sentinel;
#line 1919
  node->right = sentinel;
#line 1920
  node->color = (u_char )1;
#line 1921
  return;
}
}
#line 1924 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
ngx_str_node_t *ngx_str_rbtree_lookup(ngx_rbtree_t *rbtree , ngx_str_t *val , uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_str_node_t *n ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  int tmp ;

  {
#line 1931
  node = rbtree->root;
#line 1932
  sentinel = rbtree->sentinel;
  {
#line 1934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1934
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 1934
      goto while_break;
    }
#line 1936
    n = (ngx_str_node_t *)node;
#line 1938
    if ((ngx_rbtree_key_t )hash != node->key) {
#line 1939
      if ((ngx_rbtree_key_t )hash < node->key) {
#line 1939
        node = node->left;
      } else {
#line 1939
        node = node->right;
      }
#line 1940
      goto while_continue;
    }
#line 1943
    if (val->len != n->str.len) {
#line 1944
      if (val->len < n->str.len) {
#line 1944
        node = node->left;
      } else {
#line 1944
        node = node->right;
      }
#line 1945
      goto while_continue;
    }
    {
#line 1948
    tmp = memcmp((void const   *)((char const   *)val->data), (void const   *)((char const   *)n->str.data),
                 val->len);
#line 1948
    rc = (ngx_int_t )tmp;
    }
#line 1950
    if (rc < 0L) {
#line 1951
      node = node->left;
#line 1952
      goto while_continue;
    }
#line 1955
    if (rc > 0L) {
#line 1956
      node = node->right;
#line 1957
      goto while_continue;
    }
#line 1960
    return (n);
  }
  while_break: /* CIL Label */ ;
  }
#line 1963
  return ((ngx_str_node_t *)((void *)0));
}
}
#line 1969 "/tmp/nginx-1.13.2/src/core/ngx_string.c"
void ngx_sort(void *base , size_t___0 n , size_t___0 size , ngx_int_t (*cmp)(void const   * ,
                                                                             void const   * ) ) 
{ 
  u_char *p1 ;
  u_char *p2 ;
  u_char *p ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1975
  tmp = ngx_alloc(size, (ngx_log_t *)ngx_cycle->log);
#line 1975
  p = (u_char *)tmp;
  }
#line 1976
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1977
    return;
  }
#line 1980
  p1 = (u_char *)base + size;
  {
#line 1980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1980
    if (! ((unsigned long )p1 < (unsigned long )((u_char *)base + n * size))) {
#line 1980
      goto while_break;
    }
    {
#line 1984
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)p1, size);
#line 1986
    p2 = p1;
    }
    {
#line 1986
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1986
      if ((unsigned long )p2 > (unsigned long )((u_char *)base)) {
        {
#line 1986
        tmp___0 = (*cmp)((void const   *)(p2 - size), (void const   *)p);
        }
#line 1986
        if (! (tmp___0 > 0L)) {
#line 1986
          goto while_break___0;
        }
      } else {
#line 1986
        goto while_break___0;
      }
      {
#line 1990
      memcpy((void */* __restrict  */)p2, (void const   */* __restrict  */)(p2 - size),
             size);
#line 1986
      p2 -= size;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1993
    memcpy((void */* __restrict  */)p2, (void const   */* __restrict  */)p, size);
#line 1980
    p1 += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1996
  free((void *)p);
  }
#line 1997
  return;
}
}
#line 30 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
__inline static ngx_int_t ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx , ngx_buf_t *buf ) ;
#line 36
static ngx_int_t ngx_output_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain ,
                                           ngx_chain_t *in ) ;
#line 38
static ngx_int_t ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) ;
#line 40
static ngx_int_t ngx_output_chain_get_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) ;
#line 42
static ngx_int_t ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx ) ;
#line 45 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
ngx_int_t ngx_output_chain(ngx_output_chain_ctx_t *ctx , ngx_chain_t *in ) 
{ 
  off_t bsize ;
  ngx_int_t rc ;
  ngx_int_t last ;
  ngx_chain_t *cl ;
  ngx_chain_t *out ;
  ngx_chain_t **last_out ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  off_t tmp___5 ;

  {
#line 52
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 52
    if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 64
      if ((unsigned long )in == (unsigned long )((void *)0)) {
        {
#line 65
        tmp = (*(ctx->output_filter))(ctx->filter_ctx, in);
        }
#line 65
        return (tmp);
      }
#line 68
      if ((unsigned long )in->next == (unsigned long )((void *)0)) {
        {
#line 68
        tmp___1 = ngx_output_chain_as_is(ctx, in->buf);
        }
#line 68
        if (tmp___1) {
          {
#line 74
          tmp___0 = (*(ctx->output_filter))(ctx->filter_ctx, in);
          }
#line 74
          return (tmp___0);
        }
      }
    }
  }
#line 80
  if (in) {
    {
#line 81
    tmp___2 = ngx_output_chain_add_copy(ctx->pool, & ctx->in, in);
    }
#line 81
    if (tmp___2 == -1L) {
#line 82
      return ((ngx_int_t )-1);
    }
  }
#line 86
  out = (ngx_chain_t *)((void *)0);
#line 87
  last_out = & out;
#line 88
  last = (ngx_int_t )1;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! ctx->in) {
#line 98
        goto while_break___0;
      }
#line 105
      if (((ctx->in)->buf)->temporary) {
#line 105
        bsize = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 105
      if (((ctx->in)->buf)->memory) {
#line 105
        bsize = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 105
      if (((ctx->in)->buf)->mmap) {
#line 105
        bsize = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else {
#line 105
        bsize = ((ctx->in)->buf)->file_last - ((ctx->in)->buf)->file_pos;
      }
#line 107
      if (bsize == 0L) {
#line 107
        if (((ctx->in)->buf)->flush) {
#line 107
          goto _L___1;
        } else
#line 107
        if (((ctx->in)->buf)->last_buf) {
#line 107
          goto _L___1;
        } else
#line 107
        if (((ctx->in)->buf)->sync) {
          _L___1: /* CIL Label */ 
#line 107
          if (((ctx->in)->buf)->temporary) {
#line 107
            goto _L___0;
          } else
#line 107
          if (((ctx->in)->buf)->memory) {
#line 107
            goto _L___0;
          } else
#line 107
          if (((ctx->in)->buf)->mmap) {
#line 107
            goto _L___0;
          } else
#line 107
          if (! (! ((ctx->in)->buf)->in_file)) {
#line 107
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 109
          if (((ctx->pool)->log)->log_level >= 2UL) {
            {
#line 109
            ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "zero size buf in output t:%d r:%d f:%d %p %p-%p %p %O-%O",
                               ((ctx->in)->buf)->temporary, ((ctx->in)->buf)->recycled,
                               ((ctx->in)->buf)->in_file, ((ctx->in)->buf)->start,
                               ((ctx->in)->buf)->pos, ((ctx->in)->buf)->last, ((ctx->in)->buf)->file,
                               ((ctx->in)->buf)->file_pos, ((ctx->in)->buf)->file_last);
            }
          }
          {
#line 122
          ngx_debug_point();
#line 124
          ctx->in = (ctx->in)->next;
          }
#line 126
          goto while_continue___0;
        }
      }
      {
#line 129
      tmp___3 = ngx_output_chain_as_is(ctx, (ctx->in)->buf);
      }
#line 129
      if (tmp___3) {
#line 133
        cl = ctx->in;
#line 134
        ctx->in = cl->next;
#line 136
        *last_out = cl;
#line 137
        last_out = & cl->next;
#line 138
        cl->next = (ngx_chain_t *)((void *)0);
#line 140
        goto while_continue___0;
      }
#line 143
      if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
        {
#line 145
        rc = ngx_output_chain_align_file_buf(ctx, bsize);
        }
#line 147
        if (rc == -1L) {
#line 148
          return ((ngx_int_t )-1);
        }
#line 151
        if (rc != 0L) {
#line 153
          if (ctx->free) {
#line 157
            cl = ctx->free;
#line 158
            ctx->buf = cl->buf;
#line 159
            ctx->free = cl->next;
#line 161
            cl->next = (ctx->pool)->chain;
#line 161
            (ctx->pool)->chain = cl;
          } else
#line 163
          if (out) {
#line 165
            goto while_break___0;
          } else
#line 163
          if (ctx->allocated == ctx->bufs.num) {
#line 165
            goto while_break___0;
          } else {
            {
#line 167
            tmp___4 = ngx_output_chain_get_buf(ctx, bsize);
            }
#line 167
            if (tmp___4 != 0L) {
#line 168
              return ((ngx_int_t )-1);
            }
          }
        }
      }
      {
#line 173
      rc = ngx_output_chain_copy_buf(ctx);
      }
#line 175
      if (rc == -1L) {
#line 176
        return (rc);
      }
#line 179
      if (rc == -2L) {
#line 180
        if (out) {
#line 181
          goto while_break___0;
        }
#line 184
        return (rc);
      }
#line 189
      if (((ctx->in)->buf)->temporary) {
#line 189
        tmp___5 = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 189
      if (((ctx->in)->buf)->memory) {
#line 189
        tmp___5 = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 189
      if (((ctx->in)->buf)->mmap) {
#line 189
        tmp___5 = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else {
#line 189
        tmp___5 = ((ctx->in)->buf)->file_last - ((ctx->in)->buf)->file_pos;
      }
#line 189
      if (tmp___5 == 0L) {
#line 190
        ctx->in = (ctx->in)->next;
      }
      {
#line 193
      cl = ngx_alloc_chain_link(ctx->pool);
      }
#line 194
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 195
        return ((ngx_int_t )-1);
      }
#line 198
      cl->buf = ctx->buf;
#line 199
      cl->next = (ngx_chain_t *)((void *)0);
#line 200
      *last_out = cl;
#line 201
      last_out = & cl->next;
#line 202
      ctx->buf = (ngx_buf_t *)((void *)0);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 205
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 205
      if (last != 1L) {
#line 207
        if (ctx->in) {
#line 208
          return ((ngx_int_t )-2);
        }
#line 211
        return (last);
      }
    }
    {
#line 214
    last = (*(ctx->output_filter))(ctx->filter_ctx, out);
    }
#line 216
    if (last == -1L) {
#line 217
      return (last);
    } else
#line 216
    if (last == -4L) {
#line 217
      return (last);
    }
    {
#line 220
    ngx_chain_update_chains(ctx->pool, & ctx->free, & ctx->busy, & out, ctx->tag);
#line 222
    last_out = & out;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 227 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
__inline static ngx_int_t ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx , ngx_buf_t *buf ) 
{ 
  ngx_uint_t sendfile___0 ;

  {
#line 232
  if (buf->flush) {
#line 232
    goto _L;
  } else
#line 232
  if (buf->last_buf) {
#line 232
    goto _L;
  } else
#line 232
  if (buf->sync) {
    _L: /* CIL Label */ 
#line 232
    if (! buf->temporary) {
#line 232
      if (! buf->memory) {
#line 232
        if (! buf->mmap) {
#line 232
          if (! buf->in_file) {
#line 233
            return ((ngx_int_t )1);
          }
        }
      }
    }
  }
#line 243
  if (buf->in_file) {
#line 243
    if ((buf->file)->directio) {
#line 244
      return ((ngx_int_t )0);
    }
  }
#line 247
  sendfile___0 = (ngx_uint_t )ctx->sendfile;
#line 257
  if (! sendfile___0) {
#line 259
    if (! buf->temporary) {
#line 259
      if (! buf->memory) {
#line 259
        if (! buf->mmap) {
#line 260
          return ((ngx_int_t )0);
        }
      }
    }
#line 263
    buf->in_file = 0U;
  }
#line 272
  if (ctx->need_in_memory) {
#line 272
    if (! buf->temporary) {
#line 272
      if (! buf->memory) {
#line 272
        if (! buf->mmap) {
#line 273
          return ((ngx_int_t )0);
        }
      }
    }
  }
#line 276
  if (ctx->need_in_temp) {
#line 276
    if (buf->memory) {
#line 277
      return ((ngx_int_t )0);
    } else
#line 276
    if (buf->mmap) {
#line 277
      return ((ngx_int_t )0);
    }
  }
#line 280
  return ((ngx_int_t )1);
}
}
#line 306 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain ,
                                           ngx_chain_t *in ) 
{ 
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;

  {
#line 315
  ll = chain;
#line 317
  cl = *chain;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! cl) {
#line 317
      goto while_break;
    }
#line 318
    ll = & cl->next;
#line 317
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! in) {
#line 321
      goto while_break___0;
    }
    {
#line 323
    cl = ngx_alloc_chain_link(pool);
    }
#line 324
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 325
      return ((ngx_int_t )-1);
    }
#line 361
    cl->buf = in->buf;
#line 362
    in = in->next;
#line 366
    cl->next = (ngx_chain_t *)((void *)0);
#line 367
    *ll = cl;
#line 368
    ll = & cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  return ((ngx_int_t )0);
}
}
#line 375 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) 
{ 
  size_t___0 size ;
  ngx_buf_t *in ;

  {
#line 381
  in = (ctx->in)->buf;
#line 383
  if ((unsigned long )in->file == (unsigned long )((void *)0)) {
#line 384
    return ((ngx_int_t )-5);
  } else
#line 383
  if (! (in->file)->directio) {
#line 384
    return ((ngx_int_t )-5);
  }
#line 387
  ctx->directio = 1U;
#line 389
  size = (size_t___0 )(in->file_pos - (in->file_pos & ~ (ctx->alignment - 1L)));
#line 391
  if (size == 0UL) {
#line 393
    if (bsize >= (off_t )ctx->bufs.size) {
#line 394
      return ((ngx_int_t )-5);
    }
#line 397
    size = (size_t___0 )bsize;
  } else {
#line 400
    size = (size_t___0 )ctx->alignment - size;
#line 402
    if ((off_t )size > bsize) {
#line 403
      size = (size_t___0 )bsize;
    }
  }
  {
#line 407
  ctx->buf = ngx_create_temp_buf(ctx->pool, size);
  }
#line 408
  if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
#line 409
    return ((ngx_int_t )-1);
  }
#line 418
  ctx->unaligned = 1U;
#line 421
  return ((ngx_int_t )0);
}
}
#line 425 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_get_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) 
{ 
  size_t___0 size ;
  ngx_buf_t *b ;
  ngx_buf_t *in ;
  ngx_uint_t recycled ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 432
  in = (ctx->in)->buf;
#line 433
  size = ctx->bufs.size;
#line 434
  recycled = (ngx_uint_t )1;
#line 436
  if (in->last_in_chain) {
#line 438
    if (bsize < (off_t )size) {
#line 445
      size = (size_t___0 )bsize;
#line 446
      recycled = (ngx_uint_t )0;
    } else
#line 448
    if (! ctx->directio) {
#line 448
      if (ctx->bufs.num == 1L) {
#line 448
        if (bsize < (off_t )(size + size / 4UL)) {
#line 458
          size = (size_t___0 )bsize;
#line 459
          recycled = (ngx_uint_t )0;
        }
      }
    }
  }
  {
#line 463
  tmp = ngx_pcalloc(ctx->pool, sizeof(ngx_buf_t ));
#line 463
  b = (ngx_buf_t *)tmp;
  }
#line 464
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 465
    return ((ngx_int_t )-1);
  }
#line 468
  if (ctx->directio) {
    {
#line 475
    tmp___0 = ngx_pmemalign(ctx->pool, size, (size_t___0 )ctx->alignment);
#line 475
    b->start = (u_char *)tmp___0;
    }
#line 476
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 477
      return ((ngx_int_t )-1);
    }
  } else {
    {
#line 481
    tmp___1 = ngx_palloc(ctx->pool, size);
#line 481
    b->start = (u_char *)tmp___1;
    }
#line 482
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 483
      return ((ngx_int_t )-1);
    }
  }
#line 487
  b->pos = b->start;
#line 488
  b->last = b->start;
#line 489
  b->end = b->last + size;
#line 490
  b->temporary = 1U;
#line 491
  b->tag = ctx->tag;
#line 492
  b->recycled = (unsigned int )recycled;
#line 494
  ctx->buf = b;
#line 495
  (ctx->allocated) ++;
#line 497
  return ((ngx_int_t )0);
}
}
#line 501 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx ) 
{ 
  off_t size ;
  ssize_t n ;
  ngx_buf_t *src ;
  ngx_buf_t *dst ;
  ngx_uint_t sendfile___0 ;
  int tmp ;
  int *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_err_t err ;
  int *tmp___2 ;
  int *tmp___3 ;
  ngx_int_t tmp___4 ;
  int *tmp___5 ;

  {
#line 509
  src = (ctx->in)->buf;
#line 510
  dst = ctx->buf;
#line 512
  if (src->temporary) {
#line 512
    size = src->last - src->pos;
  } else
#line 512
  if (src->memory) {
#line 512
    size = src->last - src->pos;
  } else
#line 512
  if (src->mmap) {
#line 512
    size = src->last - src->pos;
  } else {
#line 512
    size = src->file_last - src->file_pos;
  }
#line 513
  if (size > dst->end - dst->pos) {
#line 513
    size = dst->end - dst->pos;
  } else {
#line 513
    size = size;
  }
#line 515
  if (ctx->sendfile) {
#line 515
    if (! ctx->directio) {
#line 515
      tmp = 1;
    } else {
#line 515
      tmp = 0;
    }
  } else {
#line 515
    tmp = 0;
  }
#line 515
  sendfile___0 = (ngx_uint_t )tmp;
#line 525
  if (src->temporary) {
#line 525
    goto _L;
  } else
#line 525
  if (src->memory) {
#line 525
    goto _L;
  } else
#line 525
  if (src->mmap) {
    _L: /* CIL Label */ 
    {
#line 526
    memcpy((void */* __restrict  */)dst->pos, (void const   */* __restrict  */)src->pos,
           (size_t___0 )size);
#line 527
    src->pos += (size_t___0 )size;
#line 528
    dst->last += (size_t___0 )size;
    }
#line 530
    if (src->in_file) {
#line 532
      if (sendfile___0) {
#line 533
        dst->in_file = 1U;
#line 534
        dst->file = src->file;
#line 535
        dst->file_pos = src->file_pos;
#line 536
        dst->file_last = src->file_pos + size;
      } else {
#line 539
        dst->in_file = 0U;
      }
#line 542
      src->file_pos += size;
    } else {
#line 545
      dst->in_file = 0U;
    }
#line 548
    if ((unsigned long )src->pos == (unsigned long )src->last) {
#line 549
      dst->flush = src->flush;
#line 550
      dst->last_buf = src->last_buf;
#line 551
      dst->last_in_chain = src->last_in_chain;
    }
  } else {
#line 558
    if (ctx->unaligned) {
      {
#line 559
      tmp___1 = ngx_directio_off((src->file)->fd);
      }
#line 559
      if (tmp___1 == -1L) {
#line 560
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 560
          tmp___0 = __errno_location();
#line 560
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, *tmp___0, "fcntl(!O_DIRECT) \"%s\" failed",
                             (src->file)->name.data);
          }
        }
      }
    }
    {
#line 595
    n = ngx_read_file(src->file, dst->pos, (size_t___0 )size, src->file_pos);
    }
#line 601
    if (ctx->unaligned) {
      {
#line 604
      tmp___2 = __errno_location();
#line 604
      err = *tmp___2;
#line 606
      tmp___4 = ngx_directio_on((src->file)->fd);
      }
#line 606
      if (tmp___4 == -1L) {
#line 607
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 607
          tmp___3 = __errno_location();
#line 607
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, *tmp___3, "fcntl(O_DIRECT) \"%s\" failed",
                             (src->file)->name.data);
          }
        }
      }
      {
#line 612
      tmp___5 = __errno_location();
#line 612
      *tmp___5 = err;
#line 614
      ctx->unaligned = 0U;
      }
    }
#line 619
    if (n == -1L) {
#line 620
      return (n);
    }
#line 623
    if (n != size) {
#line 624
      if (((ctx->pool)->log)->log_level >= 2UL) {
        {
#line 624
        ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "pread() read only %z of %O from \"%s\"",
                           n, size, (src->file)->name.data);
        }
      }
#line 627
      return ((ngx_int_t )-1);
    }
#line 630
    dst->last += n;
#line 632
    if (sendfile___0) {
#line 633
      dst->in_file = 1U;
#line 634
      dst->file = src->file;
#line 635
      dst->file_pos = src->file_pos;
#line 636
      dst->file_last = src->file_pos + n;
    } else {
#line 639
      dst->in_file = 0U;
    }
#line 642
    src->file_pos += n;
#line 644
    if (src->file_pos == src->file_last) {
#line 645
      dst->flush = src->flush;
#line 646
      dst->last_buf = src->last_buf;
#line 647
      dst->last_in_chain = src->last_in_chain;
    }
  }
#line 651
  return ((ngx_int_t )0);
}
}
#line 655 "/tmp/nginx-1.13.2/src/core/ngx_output_chain.c"
ngx_int_t ngx_chain_writer(void *data , ngx_chain_t *in ) 
{ 
  ngx_chain_writer_ctx_t *ctx ;
  off_t size ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_chain_t *chain ;
  ngx_connection_t *c ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  off_t tmp___2 ;

  {
#line 658
  ctx = (ngx_chain_writer_ctx_t *)data;
#line 664
  c = ctx->connection;
#line 666
  size = (off_t )0;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! in) {
#line 666
      goto while_break;
    }
#line 669
    if ((in->buf)->temporary) {
#line 669
      tmp = (in->buf)->last - (in->buf)->pos;
    } else
#line 669
    if ((in->buf)->memory) {
#line 669
      tmp = (in->buf)->last - (in->buf)->pos;
    } else
#line 669
    if ((in->buf)->mmap) {
#line 669
      tmp = (in->buf)->last - (in->buf)->pos;
    } else {
#line 669
      tmp = (in->buf)->file_last - (in->buf)->file_pos;
    }
#line 669
    if (tmp == 0L) {
#line 669
      if ((in->buf)->flush) {
#line 669
        goto _L___1;
      } else
#line 669
      if ((in->buf)->last_buf) {
#line 669
        goto _L___1;
      } else
#line 669
      if ((in->buf)->sync) {
        _L___1: /* CIL Label */ 
#line 669
        if ((in->buf)->temporary) {
#line 669
          goto _L___0;
        } else
#line 669
        if ((in->buf)->memory) {
#line 669
          goto _L___0;
        } else
#line 669
        if ((in->buf)->mmap) {
#line 669
          goto _L___0;
        } else
#line 669
        if (! (! (in->buf)->in_file)) {
#line 669
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 671
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 671
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "zero size buf in chain writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (in->buf)->temporary, (in->buf)->recycled, (in->buf)->in_file,
                             (in->buf)->start, (in->buf)->pos, (in->buf)->last, (in->buf)->file,
                             (in->buf)->file_pos, (in->buf)->file_last);
          }
        }
        {
#line 684
        ngx_debug_point();
        }
#line 686
        goto __Cont;
      }
    }
#line 690
    if ((in->buf)->temporary) {
#line 690
      tmp___0 = (in->buf)->last - (in->buf)->pos;
    } else
#line 690
    if ((in->buf)->memory) {
#line 690
      tmp___0 = (in->buf)->last - (in->buf)->pos;
    } else
#line 690
    if ((in->buf)->mmap) {
#line 690
      tmp___0 = (in->buf)->last - (in->buf)->pos;
    } else {
#line 690
      tmp___0 = (in->buf)->file_last - (in->buf)->file_pos;
    }
    {
#line 690
    size += tmp___0;
#line 696
    cl = ngx_alloc_chain_link(ctx->pool);
    }
#line 697
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 698
      return ((ngx_int_t )-1);
    }
#line 701
    cl->buf = in->buf;
#line 702
    cl->next = (ngx_chain_t *)((void *)0);
#line 703
    *(ctx->last) = cl;
#line 704
    ctx->last = & cl->next;
    __Cont: /* CIL Label */ 
#line 666
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  cl = ctx->out;
  {
#line 710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 710
    if (! cl) {
#line 710
      goto while_break___0;
    }
#line 713
    if ((cl->buf)->temporary) {
#line 713
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 713
    if ((cl->buf)->memory) {
#line 713
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 713
    if ((cl->buf)->mmap) {
#line 713
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 713
      tmp___1 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 713
    if (tmp___1 == 0L) {
#line 713
      if ((cl->buf)->flush) {
#line 713
        goto _L___4;
      } else
#line 713
      if ((cl->buf)->last_buf) {
#line 713
        goto _L___4;
      } else
#line 713
      if ((cl->buf)->sync) {
        _L___4: /* CIL Label */ 
#line 713
        if ((cl->buf)->temporary) {
#line 713
          goto _L___3;
        } else
#line 713
        if ((cl->buf)->memory) {
#line 713
          goto _L___3;
        } else
#line 713
        if ((cl->buf)->mmap) {
#line 713
          goto _L___3;
        } else
#line 713
        if (! (! (cl->buf)->in_file)) {
#line 713
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 715
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 715
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "zero size buf in chain writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 728
        ngx_debug_point();
        }
#line 730
        goto __Cont___0;
      }
    }
#line 734
    if ((cl->buf)->temporary) {
#line 734
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 734
    if ((cl->buf)->memory) {
#line 734
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 734
    if ((cl->buf)->mmap) {
#line 734
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 734
      tmp___2 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 734
    size += tmp___2;
    __Cont___0: /* CIL Label */ 
#line 710
    cl = cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 737
  if (size == 0L) {
#line 737
    if (! c->buffered) {
#line 738
      return ((ngx_int_t )0);
    }
  }
  {
#line 741
  chain = (*(c->send_chain))(c, ctx->out, ctx->limit);
  }
#line 746
  if ((unsigned long )chain == (unsigned long )((ngx_chain_t *)-1)) {
#line 747
    return ((ngx_int_t )-1);
  }
#line 750
  cl = ctx->out;
  {
#line 750
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 750
    if (cl) {
#line 750
      if (! ((unsigned long )cl != (unsigned long )chain)) {
#line 750
        goto while_break___1;
      }
    } else {
#line 750
      goto while_break___1;
    }
#line 751
    ln = cl;
#line 752
    cl = cl->next;
#line 753
    ln->next = (ctx->pool)->chain;
#line 753
    (ctx->pool)->chain = ln;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 756
  ctx->out = chain;
#line 758
  if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
#line 759
    ctx->last = & ctx->out;
#line 761
    if (! c->buffered) {
#line 762
      return ((ngx_int_t )0);
    }
  }
#line 766
  return ((ngx_int_t )-2);
}
}
#line 17 "/tmp/nginx-1.13.2/src/core/ngx_queue.c"
ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue ) 
{ 
  ngx_queue_t *middle ;
  ngx_queue_t *next ;

  {
#line 22
  middle = queue->next;
#line 24
  if ((unsigned long )middle == (unsigned long )queue->prev) {
#line 25
    return (middle);
  }
#line 28
  next = queue->next;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    middle = middle->next;
#line 33
    next = next->next;
#line 35
    if ((unsigned long )next == (unsigned long )queue->prev) {
#line 36
      return (middle);
    }
#line 39
    next = next->next;
#line 41
    if ((unsigned long )next == (unsigned long )queue->prev) {
#line 42
      return (middle);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 50 "/tmp/nginx-1.13.2/src/core/ngx_queue.c"
void ngx_queue_sort(ngx_queue_t *queue , ngx_int_t (*cmp)(ngx_queue_t const   * ,
                                                          ngx_queue_t const   * ) ) 
{ 
  ngx_queue_t *q ;
  ngx_queue_t *prev ;
  ngx_queue_t *next ;
  ngx_int_t tmp ;

  {
#line 56
  q = queue->next;
#line 58
  if ((unsigned long )q == (unsigned long )queue->prev) {
#line 59
    return;
  }
#line 62
  q = q->next;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )q != (unsigned long )queue)) {
#line 62
      goto while_break;
    }
#line 64
    prev = q->prev;
#line 65
    next = q->next;
#line 67
    (q->next)->prev = q->prev;
#line 67
    (q->prev)->next = q->next;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 70
      tmp = (*cmp)((ngx_queue_t const   *)prev, (ngx_queue_t const   *)q);
      }
#line 70
      if (tmp <= 0L) {
#line 71
        goto while_break___0;
      }
#line 74
      prev = prev->prev;
#line 69
      if (! ((unsigned long )prev != (unsigned long )queue)) {
#line 69
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    q->next = prev->next;
#line 78
    (q->next)->prev = q;
#line 78
    q->prev = prev;
#line 78
    prev->next = q;
#line 62
    q = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 144 "src/core/ngx_buf.h"
ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool , ngx_bufs_t *bufs ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool , size_t___0 size ) 
{ 
  ngx_buf_t *b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 17
  tmp = ngx_pcalloc(pool, sizeof(ngx_buf_t ));
#line 17
  b = (ngx_buf_t *)tmp;
  }
#line 18
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 19
    return ((ngx_buf_t *)((void *)0));
  }
  {
#line 22
  tmp___0 = ngx_palloc(pool, size);
#line 22
  b->start = (u_char *)tmp___0;
  }
#line 23
  if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 24
    return ((ngx_buf_t *)((void *)0));
  }
#line 38
  b->pos = b->start;
#line 39
  b->last = b->start;
#line 40
  b->end = b->last + size;
#line 41
  b->temporary = 1U;
#line 43
  return (b);
}
}
#line 47 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool ) 
{ 
  ngx_chain_t *cl ;
  void *tmp ;

  {
#line 52
  cl = pool->chain;
#line 54
  if (cl) {
#line 55
    pool->chain = cl->next;
#line 56
    return (cl);
  }
  {
#line 59
  tmp = ngx_palloc(pool, sizeof(ngx_chain_t ));
#line 59
  cl = (ngx_chain_t *)tmp;
  }
#line 60
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 61
    return ((ngx_chain_t *)((void *)0));
  }
#line 64
  return (cl);
}
}
#line 68 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool , ngx_bufs_t *bufs ) 
{ 
  u_char *p ;
  ngx_int_t i ;
  ngx_buf_t *b ;
  ngx_chain_t *chain ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 76
  tmp = ngx_palloc(pool, (size_t___0 )bufs->num * bufs->size);
#line 76
  p = (u_char *)tmp;
  }
#line 77
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 78
    return ((ngx_chain_t *)((void *)0));
  }
#line 81
  ll = & chain;
#line 83
  i = (ngx_int_t )0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < bufs->num)) {
#line 83
      goto while_break;
    }
    {
#line 85
    tmp___0 = ngx_pcalloc(pool, sizeof(ngx_buf_t ));
#line 85
    b = (ngx_buf_t *)tmp___0;
    }
#line 86
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 87
      return ((ngx_chain_t *)((void *)0));
    }
    {
#line 102
    b->pos = p;
#line 103
    b->last = p;
#line 104
    b->temporary = 1U;
#line 106
    b->start = p;
#line 107
    p += bufs->size;
#line 108
    b->end = p;
#line 110
    cl = ngx_alloc_chain_link(pool);
    }
#line 111
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 112
      return ((ngx_chain_t *)((void *)0));
    }
#line 115
    cl->buf = b;
#line 116
    *ll = cl;
#line 117
    ll = & cl->next;
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  *ll = (ngx_chain_t *)((void *)0);
#line 122
  return (chain);
}
}
#line 126 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
ngx_int_t ngx_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain , ngx_chain_t *in ) 
{ 
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;

  {
#line 131
  ll = chain;
#line 133
  cl = *chain;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! cl) {
#line 133
      goto while_break;
    }
#line 134
    ll = & cl->next;
#line 133
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 137
    if (! in) {
#line 137
      goto while_break___0;
    }
    {
#line 138
    cl = ngx_alloc_chain_link(pool);
    }
#line 139
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 140
      return ((ngx_int_t )-1);
    }
#line 143
    cl->buf = in->buf;
#line 144
    *ll = cl;
#line 145
    ll = & cl->next;
#line 146
    in = in->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 149
  *ll = (ngx_chain_t *)((void *)0);
#line 151
  return ((ngx_int_t )0);
}
}
#line 155 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
ngx_chain_t *ngx_chain_get_free_buf(ngx_pool_t *p , ngx_chain_t **free___0 ) 
{ 
  ngx_chain_t *cl ;
  void *tmp ;

  {
#line 160
  if (*free___0) {
#line 161
    cl = *free___0;
#line 162
    *free___0 = cl->next;
#line 163
    cl->next = (ngx_chain_t *)((void *)0);
#line 164
    return (cl);
  }
  {
#line 167
  cl = ngx_alloc_chain_link(p);
  }
#line 168
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 169
    return ((ngx_chain_t *)((void *)0));
  }
  {
#line 172
  tmp = ngx_pcalloc(p, sizeof(ngx_buf_t ));
#line 172
  cl->buf = (ngx_buf_t *)tmp;
  }
#line 173
  if ((unsigned long )cl->buf == (unsigned long )((void *)0)) {
#line 174
    return ((ngx_chain_t *)((void *)0));
  }
#line 177
  cl->next = (ngx_chain_t *)((void *)0);
#line 179
  return (cl);
}
}
#line 183 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
void ngx_chain_update_chains(ngx_pool_t *p , ngx_chain_t **free___0 , ngx_chain_t **busy ,
                             ngx_chain_t **out , ngx_buf_tag_t tag ) 
{ 
  ngx_chain_t *cl ;
  off_t tmp ;

  {
#line 189
  if (*out) {
#line 190
    if ((unsigned long )*busy == (unsigned long )((void *)0)) {
#line 191
      *busy = *out;
    } else {
#line 194
      cl = *busy;
      {
#line 194
      while (1) {
        while_continue: /* CIL Label */ ;
#line 194
        if (! cl->next) {
#line 194
          goto while_break;
        }
#line 194
        cl = cl->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 196
      cl->next = *out;
    }
#line 199
    *out = (ngx_chain_t *)((void *)0);
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! *busy) {
#line 202
      goto while_break___0;
    }
#line 203
    cl = *busy;
#line 205
    if ((cl->buf)->temporary) {
#line 205
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 205
    if ((cl->buf)->memory) {
#line 205
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 205
    if ((cl->buf)->mmap) {
#line 205
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 205
      tmp = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 205
    if (tmp != 0L) {
#line 206
      goto while_break___0;
    }
#line 209
    if ((unsigned long )(cl->buf)->tag != (unsigned long )tag) {
#line 210
      *busy = cl->next;
#line 211
      cl->next = p->chain;
#line 211
      p->chain = cl;
#line 212
      goto while_continue___0;
    }
#line 215
    (cl->buf)->pos = (cl->buf)->start;
#line 216
    (cl->buf)->last = (cl->buf)->start;
#line 218
    *busy = cl->next;
#line 219
    cl->next = *free___0;
#line 220
    *free___0 = cl;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 225 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
off_t ngx_chain_coalesce_file(ngx_chain_t **in , off_t limit ) 
{ 
  off_t total ;
  off_t size ;
  off_t aligned ;
  off_t fprev ;
  ngx_fd_t fd ;
  ngx_chain_t *cl ;

  {
#line 232
  total = (off_t )0;
#line 234
  cl = *in;
#line 235
  fd = ((cl->buf)->file)->fd;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    size = (cl->buf)->file_last - (cl->buf)->file_pos;
#line 240
    if (size > limit - total) {
#line 241
      size = limit - total;
#line 243
      aligned = (off_t )((((ngx_uint_t )((cl->buf)->file_pos + size) + ngx_pagesize) - 1UL) & (unsigned long )(~ ((off_t )ngx_pagesize - 1L)));
#line 246
      if (aligned <= (cl->buf)->file_last) {
#line 247
        size = aligned - (cl->buf)->file_pos;
      }
#line 250
      total += size;
#line 251
      goto while_break;
    }
#line 254
    total += size;
#line 255
    fprev = (cl->buf)->file_pos + size;
#line 256
    cl = cl->next;
#line 237
    if (cl) {
#line 237
      if ((cl->buf)->in_file) {
#line 237
        if (total < limit) {
#line 237
          if (fd == ((cl->buf)->file)->fd) {
#line 237
            if (! (fprev == (cl->buf)->file_pos)) {
#line 237
              goto while_break;
            }
          } else {
#line 237
            goto while_break;
          }
        } else {
#line 237
          goto while_break;
        }
      } else {
#line 237
        goto while_break;
      }
    } else {
#line 237
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  *in = cl;
#line 266
  return (total);
}
}
#line 270 "/tmp/nginx-1.13.2/src/core/ngx_buf.c"
ngx_chain_t *ngx_chain_update_sent(ngx_chain_t *in , off_t sent ) 
{ 
  off_t size ;

  {
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! in) {
#line 275
      goto while_break;
    }
#line 277
    if ((in->buf)->flush) {
#line 277
      goto _L;
    } else
#line 277
    if ((in->buf)->last_buf) {
#line 277
      goto _L;
    } else
#line 277
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 277
      if (! (in->buf)->temporary) {
#line 277
        if (! (in->buf)->memory) {
#line 277
          if (! (in->buf)->mmap) {
#line 277
            if (! (in->buf)->in_file) {
#line 278
              goto __Cont;
            }
          }
        }
      }
    }
#line 281
    if (sent == 0L) {
#line 282
      goto while_break;
    }
#line 285
    if ((in->buf)->temporary) {
#line 285
      size = (in->buf)->last - (in->buf)->pos;
    } else
#line 285
    if ((in->buf)->memory) {
#line 285
      size = (in->buf)->last - (in->buf)->pos;
    } else
#line 285
    if ((in->buf)->mmap) {
#line 285
      size = (in->buf)->last - (in->buf)->pos;
    } else {
#line 285
      size = (in->buf)->file_last - (in->buf)->file_pos;
    }
#line 287
    if (sent >= size) {
#line 288
      sent -= size;
#line 290
      if ((in->buf)->temporary) {
#line 291
        (in->buf)->pos = (in->buf)->last;
      } else
#line 290
      if ((in->buf)->memory) {
#line 291
        (in->buf)->pos = (in->buf)->last;
      } else
#line 290
      if ((in->buf)->mmap) {
#line 291
        (in->buf)->pos = (in->buf)->last;
      }
#line 294
      if ((in->buf)->in_file) {
#line 295
        (in->buf)->file_pos = (in->buf)->file_last;
      }
#line 298
      goto __Cont;
    }
#line 301
    if ((in->buf)->temporary) {
#line 302
      (in->buf)->pos += (size_t___0 )sent;
    } else
#line 301
    if ((in->buf)->memory) {
#line 302
      (in->buf)->pos += (size_t___0 )sent;
    } else
#line 301
    if ((in->buf)->mmap) {
#line 302
      (in->buf)->pos += (size_t___0 )sent;
    }
#line 305
    if ((in->buf)->in_file) {
#line 306
      (in->buf)->file_pos += sent;
    }
#line 309
    goto while_break;
    __Cont: /* CIL Label */ 
#line 275
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return (in);
}
}
#line 101 "src/core/ngx_hash.h"
void *ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc , u_char *name , size_t___0 len ) ;
#line 102
void *ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc , u_char *name , size_t___0 len ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
void *ngx_hash_find(ngx_hash_t *hash , ngx_uint_t key , u_char *name , size_t___0 len ) 
{ 
  ngx_uint_t i ;
  ngx_hash_elt_t *elt ;

  {
#line 22
  elt = *(hash->buckets + key % hash->size);
#line 24
  if ((unsigned long )elt == (unsigned long )((void *)0)) {
#line 25
    return ((void *)0);
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! elt->value) {
#line 28
      goto while_break;
    }
#line 29
    if (len != (size_t___0 )elt->len) {
#line 30
      goto next;
    }
#line 33
    i = (ngx_uint_t )0;
    {
#line 33
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 33
      if (! (i < len)) {
#line 33
        goto while_break___0;
      }
#line 34
      if ((int )*(name + i) != (int )elt->name[i]) {
#line 35
        goto next;
      }
#line 33
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    return (elt->value);
    next: 
#line 43
    elt = (ngx_hash_elt_t *)((u_char *)(((uintptr_t )(& elt->name[0] + (int )elt->len) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL)));
#line 45
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return ((void *)0);
}
}
#line 52 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
void *ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc , u_char *name , size_t___0 len ) 
{ 
  void *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t key ;

  {
#line 62
  n = len;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! n) {
#line 64
      goto while_break;
    }
#line 65
    if ((int )*(name + (n - 1UL)) == 46) {
#line 66
      goto while_break;
    }
#line 69
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  key = (ngx_uint_t )0;
#line 74
  i = n;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (i < len)) {
#line 74
      goto while_break___0;
    }
#line 75
    key = key * 31UL + (ngx_uint_t )*(name + i);
#line 74
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 82
  value = ngx_hash_find(& hwc->hash, key, name + n, len - n);
  }
#line 88
  if (value) {
#line 101
    if ((uintptr_t )value & 2UL) {
#line 103
      if (n == 0UL) {
#line 107
        if ((uintptr_t )value & 1UL) {
#line 108
          return ((void *)0);
        }
#line 111
        hwc = (ngx_hash_wildcard_t *)((uintptr_t )value & 0xfffffffffffffffcUL);
#line 113
        return (hwc->value);
      }
      {
#line 116
      hwc = (ngx_hash_wildcard_t *)((uintptr_t )value & 0xfffffffffffffffcUL);
#line 118
      value = ngx_hash_find_wc_head(hwc, name, n - 1UL);
      }
#line 120
      if (value) {
#line 121
        return (value);
      }
#line 124
      return (hwc->value);
    }
#line 127
    if ((uintptr_t )value & 1UL) {
#line 129
      if (n == 0UL) {
#line 133
        return ((void *)0);
      }
#line 136
      return ((void *)((uintptr_t )value & 0xfffffffffffffffcUL));
    }
#line 139
    return (value);
  }
#line 142
  return (hwc->value);
}
}
#line 146 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
void *ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc , u_char *name , size_t___0 len ) 
{ 
  void *value ;
  ngx_uint_t i ;
  ngx_uint_t key ;

  {
#line 156
  key = (ngx_uint_t )0;
#line 158
  i = (ngx_uint_t )0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < len)) {
#line 158
      goto while_break;
    }
#line 159
    if ((int )*(name + i) == 46) {
#line 160
      goto while_break;
    }
#line 163
    key = key * 31UL + (ngx_uint_t )*(name + i);
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if (i == len) {
#line 167
    return ((void *)0);
  }
  {
#line 174
  value = ngx_hash_find(& hwc->hash, key, name, i);
  }
#line 180
  if (value) {
#line 188
    if ((uintptr_t )value & 2UL) {
      {
#line 190
      i ++;
#line 192
      hwc = (ngx_hash_wildcard_t *)((uintptr_t )value & 0xfffffffffffffffcUL);
#line 194
      value = ngx_hash_find_wc_tail(hwc, name + i, len - i);
      }
#line 196
      if (value) {
#line 197
        return (value);
      }
#line 200
      return (hwc->value);
    }
#line 203
    return (value);
  }
#line 206
  return (hwc->value);
}
}
#line 210 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
void *ngx_hash_find_combined(ngx_hash_combined_t *hash , ngx_uint_t key , u_char *name ,
                             size_t___0 len ) 
{ 
  void *value ;

  {
#line 216
  if (hash->hash.buckets) {
    {
#line 217
    value = ngx_hash_find(& hash->hash, key, name, len);
    }
#line 219
    if (value) {
#line 220
      return (value);
    }
  }
#line 224
  if (len == 0UL) {
#line 225
    return ((void *)0);
  }
#line 228
  if (hash->wc_head) {
#line 228
    if ((hash->wc_head)->hash.buckets) {
      {
#line 229
      value = ngx_hash_find_wc_head(hash->wc_head, name, len);
      }
#line 231
      if (value) {
#line 232
        return (value);
      }
    }
  }
#line 236
  if (hash->wc_tail) {
#line 236
    if ((hash->wc_tail)->hash.buckets) {
      {
#line 237
      value = ngx_hash_find_wc_tail(hash->wc_tail, name, len);
      }
#line 239
      if (value) {
#line 240
        return (value);
      }
    }
  }
#line 244
  return ((void *)0);
}
}
#line 251 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names , ngx_uint_t nelts ) 
{ 
  u_char *elts ;
  size_t___0 len ;
  u_short *test ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t key ;
  ngx_uint_t size ;
  ngx_uint_t start ;
  ngx_uint_t bucket_size ;
  ngx_hash_elt_t *elt ;
  ngx_hash_elt_t **buckets ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 260
  if (hinit->max_size == 0UL) {
#line 261
    if (((hinit->pool)->log)->log_level >= 1UL) {
      {
#line 261
      ngx_log_error_core((ngx_uint_t )1, (hinit->pool)->log, 0, "could not build %s, you should increase %s_max_size: %i",
                         hinit->name, hinit->name, hinit->max_size);
      }
    }
#line 265
    return ((ngx_int_t )-1);
  }
#line 268
  n = (ngx_uint_t )0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (n < nelts)) {
#line 268
      goto while_break;
    }
#line 269
    if (hinit->bucket_size < (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))) + sizeof(void *)) {
#line 271
      if (((hinit->pool)->log)->log_level >= 1UL) {
        {
#line 271
        ngx_log_error_core((ngx_uint_t )1, (hinit->pool)->log, 0, "could not build %s, you should increase %s_bucket_size: %i",
                           hinit->name, hinit->name, hinit->bucket_size);
        }
      }
#line 275
      return ((ngx_int_t )-1);
    }
#line 268
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  tmp = ngx_alloc(hinit->max_size * sizeof(u_short ), (hinit->pool)->log);
#line 279
  test = (u_short *)tmp;
  }
#line 280
  if ((unsigned long )test == (unsigned long )((void *)0)) {
#line 281
    return ((ngx_int_t )-1);
  }
#line 284
  bucket_size = hinit->bucket_size - sizeof(void *);
#line 286
  start = nelts / (bucket_size / (2UL * sizeof(void *)));
#line 287
  if (start) {
#line 287
    start = start;
  } else {
#line 287
    start = (ngx_uint_t )1;
  }
#line 289
  if (hinit->max_size > 10000UL) {
#line 289
    if (nelts) {
#line 289
      if (hinit->max_size / nelts < 100UL) {
#line 290
        start = hinit->max_size - 1000UL;
      }
    }
  }
#line 293
  size = start;
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (size <= hinit->max_size)) {
#line 293
      goto while_break___0;
    }
    {
#line 295
    memset((void *)test, 0, size * sizeof(u_short ));
#line 297
    n = (ngx_uint_t )0;
    }
    {
#line 297
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 297
      if (! (n < nelts)) {
#line 297
        goto while_break___1;
      }
#line 298
      if ((unsigned long )(names + n)->key.data == (unsigned long )((void *)0)) {
#line 299
        goto __Cont;
      }
#line 302
      key = (names + n)->key_hash % size;
#line 303
      *(test + key) = (u_short )((unsigned long )*(test + key) + (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))));
#line 311
      if ((int )*(test + key) > (int )((u_short )bucket_size)) {
#line 312
        goto next;
      }
      __Cont: /* CIL Label */ 
#line 297
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 316
    goto found;
    next: 
#line 320
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 293
    size ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  size = hinit->max_size;
#line 325
  if (((hinit->pool)->log)->log_level >= 5UL) {
    {
#line 325
    ngx_log_error_core((ngx_uint_t )5, (hinit->pool)->log, 0, "could not build optimal %s, you should increase either %s_max_size: %i or %s_bucket_size: %i; ignoring %s_bucket_size",
                       hinit->name, hinit->name, hinit->max_size, hinit->name, hinit->bucket_size,
                       hinit->name);
    }
  }
  found: 
#line 334
  i = (ngx_uint_t )0;
  {
#line 334
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 334
    if (! (i < size)) {
#line 334
      goto while_break___2;
    }
#line 335
    *(test + i) = (u_short )sizeof(void *);
#line 334
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 338
  n = (ngx_uint_t )0;
  {
#line 338
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 338
    if (! (n < nelts)) {
#line 338
      goto while_break___3;
    }
#line 339
    if ((unsigned long )(names + n)->key.data == (unsigned long )((void *)0)) {
#line 340
      goto __Cont___1;
    }
#line 343
    key = (names + n)->key_hash % size;
#line 344
    *(test + key) = (u_short )((unsigned long )*(test + key) + (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))));
    __Cont___1: /* CIL Label */ 
#line 338
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 347
  len = (size_t___0 )0;
#line 349
  i = (ngx_uint_t )0;
  {
#line 349
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 349
    if (! (i < size)) {
#line 349
      goto while_break___4;
    }
#line 350
    if ((unsigned long )*(test + i) == sizeof(void *)) {
#line 351
      goto __Cont___2;
    }
#line 354
    *(test + i) = (u_short )(((ngx_uint_t )*(test + i) + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL));
#line 356
    len += (size_t___0 )*(test + i);
    __Cont___2: /* CIL Label */ 
#line 349
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 359
  if ((unsigned long )hinit->hash == (unsigned long )((void *)0)) {
    {
#line 360
    tmp___0 = ngx_pcalloc(hinit->pool, sizeof(ngx_hash_wildcard_t ) + size * sizeof(ngx_hash_elt_t *));
#line 360
    hinit->hash = (ngx_hash_t *)tmp___0;
    }
#line 362
    if ((unsigned long )hinit->hash == (unsigned long )((void *)0)) {
      {
#line 363
      free((void *)test);
      }
#line 364
      return ((ngx_int_t )-1);
    }
#line 367
    buckets = (ngx_hash_elt_t **)((u_char *)hinit->hash + sizeof(ngx_hash_wildcard_t ));
  } else {
    {
#line 371
    tmp___1 = ngx_pcalloc(hinit->pool, size * sizeof(ngx_hash_elt_t *));
#line 371
    buckets = (ngx_hash_elt_t **)tmp___1;
    }
#line 372
    if ((unsigned long )buckets == (unsigned long )((void *)0)) {
      {
#line 373
      free((void *)test);
      }
#line 374
      return ((ngx_int_t )-1);
    }
  }
  {
#line 378
  tmp___2 = ngx_palloc(hinit->pool, len + ngx_cacheline_size);
#line 378
  elts = (u_char *)tmp___2;
  }
#line 379
  if ((unsigned long )elts == (unsigned long )((void *)0)) {
    {
#line 380
    free((void *)test);
    }
#line 381
    return ((ngx_int_t )-1);
  }
#line 384
  elts = (u_char *)(((uintptr_t )elts + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL));
#line 386
  i = (ngx_uint_t )0;
  {
#line 386
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 386
    if (! (i < size)) {
#line 386
      goto while_break___5;
    }
#line 387
    if ((unsigned long )*(test + i) == sizeof(void *)) {
#line 388
      goto __Cont___3;
    }
#line 391
    *(buckets + i) = (ngx_hash_elt_t *)elts;
#line 392
    elts += (int )*(test + i);
    __Cont___3: /* CIL Label */ 
#line 386
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 395
  i = (ngx_uint_t )0;
  {
#line 395
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 395
    if (! (i < size)) {
#line 395
      goto while_break___6;
    }
#line 396
    *(test + i) = (u_short )0;
#line 395
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 399
  n = (ngx_uint_t )0;
  {
#line 399
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 399
    if (! (n < nelts)) {
#line 399
      goto while_break___7;
    }
#line 400
    if ((unsigned long )(names + n)->key.data == (unsigned long )((void *)0)) {
#line 401
      goto __Cont___4;
    }
    {
#line 404
    key = (names + n)->key_hash % size;
#line 405
    elt = (ngx_hash_elt_t *)((u_char *)*(buckets + key) + (int )*(test + key));
#line 407
    elt->value = (names + n)->value;
#line 408
    elt->len = (u_short )(names + n)->key.len;
#line 410
    ngx_strlow(elt->name, (names + n)->key.data, (names + n)->key.len);
#line 412
    *(test + key) = (u_short )((unsigned long )*(test + key) + (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))));
    }
    __Cont___4: /* CIL Label */ 
#line 399
    n ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 415
  i = (ngx_uint_t )0;
  {
#line 415
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 415
    if (! (i < size)) {
#line 415
      goto while_break___8;
    }
#line 416
    if ((unsigned long )*(buckets + i) == (unsigned long )((void *)0)) {
#line 417
      goto __Cont___5;
    }
#line 420
    elt = (ngx_hash_elt_t *)((u_char *)*(buckets + i) + (int )*(test + i));
#line 422
    elt->value = (void *)0;
    __Cont___5: /* CIL Label */ 
#line 415
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 425
  free((void *)test);
#line 427
  (hinit->hash)->buckets = buckets;
#line 428
  (hinit->hash)->size = size;
  }
#line 460
  return ((ngx_int_t )0);
}
}
#line 464 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
ngx_int_t ngx_hash_wildcard_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names ,
                                 ngx_uint_t nelts ) 
{ 
  size_t___0 len ;
  size_t___0 dot_len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t dot ;
  ngx_array_t curr_names ;
  ngx_array_t next_names ;
  ngx_hash_key_t *name ;
  ngx_hash_key_t *next_name ;
  ngx_hash_init_t h ;
  ngx_hash_wildcard_t *wdc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  ngx_int_t tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;

  {
  {
#line 475
  tmp = ngx_array_init(& curr_names, hinit->temp_pool, nelts, sizeof(ngx_hash_key_t ));
  }
#line 475
  if (tmp != 0L) {
#line 479
    return ((ngx_int_t )-1);
  }
  {
#line 482
  tmp___0 = ngx_array_init(& next_names, hinit->temp_pool, nelts, sizeof(ngx_hash_key_t ));
  }
#line 482
  if (tmp___0 != 0L) {
#line 486
    return ((ngx_int_t )-1);
  }
#line 489
  n = (ngx_uint_t )0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (n < nelts)) {
#line 489
      goto while_break;
    }
#line 496
    dot = (ngx_uint_t )0;
#line 498
    len = (size_t___0 )0;
    {
#line 498
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 498
      if (! (len < (names + n)->key.len)) {
#line 498
        goto while_break___0;
      }
#line 499
      if ((int )*((names + n)->key.data + len) == 46) {
#line 500
        dot = (ngx_uint_t )1;
#line 501
        goto while_break___0;
      }
#line 498
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 505
    tmp___1 = ngx_array_push(& curr_names);
#line 505
    name = (ngx_hash_key_t *)tmp___1;
    }
#line 506
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 507
      return ((ngx_int_t )-1);
    }
    {
#line 510
    name->key.len = len;
#line 511
    name->key.data = (names + n)->key.data;
#line 512
    name->key_hash = (*(hinit->key))(name->key.data, name->key.len);
#line 513
    name->value = (names + n)->value;
#line 520
    dot_len = len + 1UL;
    }
#line 522
    if (dot) {
#line 523
      len ++;
    }
#line 526
    next_names.nelts = (ngx_uint_t )0;
#line 528
    if ((names + n)->key.len != len) {
      {
#line 529
      tmp___2 = ngx_array_push(& next_names);
#line 529
      next_name = (ngx_hash_key_t *)tmp___2;
      }
#line 530
      if ((unsigned long )next_name == (unsigned long )((void *)0)) {
#line 531
        return ((ngx_int_t )-1);
      }
#line 534
      next_name->key.len = (names + n)->key.len - len;
#line 535
      next_name->key.data = (names + n)->key.data + len;
#line 536
      next_name->key_hash = (ngx_uint_t )0;
#line 537
      next_name->value = (names + n)->value;
    }
#line 545
    i = n + 1UL;
    {
#line 545
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 545
      if (! (i < nelts)) {
#line 545
        goto while_break___1;
      }
      {
#line 546
      tmp___3 = strncmp((char const   *)(names + n)->key.data, (char const   *)(names + i)->key.data,
                        len);
      }
#line 546
      if (tmp___3 != 0) {
#line 547
        goto while_break___1;
      }
#line 550
      if (! dot) {
#line 550
        if ((names + i)->key.len > len) {
#line 550
          if ((int )*((names + i)->key.data + len) != 46) {
#line 554
            goto while_break___1;
          }
        }
      }
      {
#line 557
      tmp___4 = ngx_array_push(& next_names);
#line 557
      next_name = (ngx_hash_key_t *)tmp___4;
      }
#line 558
      if ((unsigned long )next_name == (unsigned long )((void *)0)) {
#line 559
        return ((ngx_int_t )-1);
      }
#line 562
      next_name->key.len = (names + i)->key.len - dot_len;
#line 563
      next_name->key.data = (names + i)->key.data + dot_len;
#line 564
      next_name->key_hash = (ngx_uint_t )0;
#line 565
      next_name->value = (names + i)->value;
#line 545
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 573
    if (next_names.nelts) {
      {
#line 575
      h = *hinit;
#line 576
      h.hash = (ngx_hash_t *)((void *)0);
#line 578
      tmp___5 = ngx_hash_wildcard_init(& h, (ngx_hash_key_t *)next_names.elts, next_names.nelts);
      }
#line 578
      if (tmp___5 != 0L) {
#line 582
        return ((ngx_int_t )-1);
      }
#line 585
      wdc = (ngx_hash_wildcard_t *)h.hash;
#line 587
      if ((names + n)->key.len == len) {
#line 588
        wdc->value = (names + n)->value;
      }
#line 591
      if (dot) {
#line 591
        tmp___6 = 3;
      } else {
#line 591
        tmp___6 = 2;
      }
#line 591
      name->value = (void *)((uintptr_t )wdc | (unsigned long )tmp___6);
    } else
#line 593
    if (dot) {
#line 594
      name->value = (void *)((uintptr_t )name->value | 1UL);
    }
#line 489
    n = i;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 598
  tmp___7 = ngx_hash_init(hinit, (ngx_hash_key_t *)curr_names.elts, curr_names.nelts);
  }
#line 598
  if (tmp___7 != 0L) {
#line 602
    return ((ngx_int_t )-1);
  }
#line 605
  return ((ngx_int_t )0);
}
}
#line 609 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
ngx_uint_t ngx_hash_key(u_char *data , size_t___0 len ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t key ;

  {
#line 614
  key = (ngx_uint_t )0;
#line 616
  i = (ngx_uint_t )0;
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! (i < len)) {
#line 616
      goto while_break;
    }
#line 617
    key = key * 31UL + (ngx_uint_t )*(data + i);
#line 616
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  return (key);
}
}
#line 624 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
ngx_uint_t ngx_hash_key_lc(u_char *data , size_t___0 len ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t key ;
  int tmp ;

  {
#line 629
  key = (ngx_uint_t )0;
#line 631
  i = (ngx_uint_t )0;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (i < len)) {
#line 631
      goto while_break;
    }
#line 632
    if ((int )*(data + i) >= 65) {
#line 632
      if ((int )*(data + i) <= 90) {
#line 632
        tmp = (int )*(data + i) | 32;
      } else {
#line 632
        tmp = (int )*(data + i);
      }
    } else {
#line 632
      tmp = (int )*(data + i);
    }
#line 632
    key = key * 31UL + (ngx_uint_t )((u_char )tmp);
#line 631
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  return (key);
}
}
#line 639 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
ngx_uint_t ngx_hash_strlow(u_char *dst , u_char *src , size_t___0 n ) 
{ 
  ngx_uint_t key ;
  int tmp ;
  size_t___0 tmp___0 ;

  {
#line 644
  key = (ngx_uint_t )0;
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    tmp___0 = n;
#line 646
    n --;
#line 646
    if (! tmp___0) {
#line 646
      goto while_break;
    }
#line 647
    if ((int )*src >= 65) {
#line 647
      if ((int )*src <= 90) {
#line 647
        tmp = (int )*src | 32;
      } else {
#line 647
        tmp = (int )*src;
      }
    } else {
#line 647
      tmp = (int )*src;
    }
#line 647
    *dst = (u_char )tmp;
#line 648
    key = key * 31UL + (ngx_uint_t )*dst;
#line 649
    dst ++;
#line 650
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  return (key);
}
}
#line 657 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
ngx_int_t ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha , ngx_uint_t type ) 
{ 
  ngx_uint_t asize ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 662
  if (type == 1UL) {
#line 663
    asize = (ngx_uint_t )4;
#line 664
    ha->hsize = (ngx_uint_t )107;
  } else {
#line 667
    asize = (ngx_uint_t )16384;
#line 668
    ha->hsize = (ngx_uint_t )10007;
  }
  {
#line 671
  tmp = ngx_array_init(& ha->keys, ha->temp_pool, asize, sizeof(ngx_hash_key_t ));
  }
#line 671
  if (tmp != 0L) {
#line 674
    return ((ngx_int_t )-1);
  }
  {
#line 677
  tmp___0 = ngx_array_init(& ha->dns_wc_head, ha->temp_pool, asize, sizeof(ngx_hash_key_t ));
  }
#line 677
  if (tmp___0 != 0L) {
#line 681
    return ((ngx_int_t )-1);
  }
  {
#line 684
  tmp___1 = ngx_array_init(& ha->dns_wc_tail, ha->temp_pool, asize, sizeof(ngx_hash_key_t ));
  }
#line 684
  if (tmp___1 != 0L) {
#line 688
    return ((ngx_int_t )-1);
  }
  {
#line 691
  tmp___2 = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t ) * ha->hsize);
#line 691
  ha->keys_hash = (ngx_array_t *)tmp___2;
  }
#line 692
  if ((unsigned long )ha->keys_hash == (unsigned long )((void *)0)) {
#line 693
    return ((ngx_int_t )-1);
  }
  {
#line 696
  tmp___3 = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t ) * ha->hsize);
#line 696
  ha->dns_wc_head_hash = (ngx_array_t *)tmp___3;
  }
#line 698
  if ((unsigned long )ha->dns_wc_head_hash == (unsigned long )((void *)0)) {
#line 699
    return ((ngx_int_t )-1);
  }
  {
#line 702
  tmp___4 = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t ) * ha->hsize);
#line 702
  ha->dns_wc_tail_hash = (ngx_array_t *)tmp___4;
  }
#line 704
  if ((unsigned long )ha->dns_wc_tail_hash == (unsigned long )((void *)0)) {
#line 705
    return ((ngx_int_t )-1);
  }
#line 708
  return ((ngx_int_t )0);
}
}
#line 712 "/tmp/nginx-1.13.2/src/core/ngx_hash.c"
ngx_int_t ngx_hash_add_key(ngx_hash_keys_arrays_t *ha , ngx_str_t *key , void *value ,
                           ngx_uint_t flags ) 
{ 
  size_t___0 len ;
  u_char *p ;
  ngx_str_t *name ;
  ngx_uint_t i ;
  ngx_uint_t k ;
  ngx_uint_t n ;
  ngx_uint_t skip ;
  ngx_uint_t last ;
  ngx_array_t *keys ;
  ngx_array_t *hwc ;
  ngx_hash_key_t *hk ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ngx_int_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_uint_t tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  ngx_int_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
#line 723
  last = key->len;
#line 725
  if (flags & 1UL) {
#line 732
    n = (ngx_uint_t )0;
#line 734
    i = (ngx_uint_t )0;
    {
#line 734
    while (1) {
      while_continue: /* CIL Label */ ;
#line 734
      if (! (i < key->len)) {
#line 734
        goto while_break;
      }
#line 736
      if ((int )*(key->data + i) == 42) {
#line 737
        n ++;
#line 737
        if (n > 1UL) {
#line 738
          return ((ngx_int_t )-5);
        }
      }
#line 742
      if ((int )*(key->data + i) == 46) {
#line 742
        if ((int )*(key->data + (i + 1UL)) == 46) {
#line 743
          return ((ngx_int_t )-5);
        }
      }
#line 746
      if ((int )*(key->data + i) == 0) {
#line 747
        return ((ngx_int_t )-5);
      }
#line 734
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 751
    if (key->len > 1UL) {
#line 751
      if ((int )*(key->data + 0) == 46) {
#line 752
        skip = (ngx_uint_t )1;
#line 753
        goto wildcard;
      }
    }
#line 756
    if (key->len > 2UL) {
#line 758
      if ((int )*(key->data + 0) == 42) {
#line 758
        if ((int )*(key->data + 1) == 46) {
#line 759
          skip = (ngx_uint_t )2;
#line 760
          goto wildcard;
        }
      }
#line 763
      if ((int )*(key->data + (i - 2UL)) == 46) {
#line 763
        if ((int )*(key->data + (i - 1UL)) == 42) {
#line 764
          skip = (ngx_uint_t )0;
#line 765
          last -= 2UL;
#line 766
          goto wildcard;
        }
      }
    }
#line 770
    if (n) {
#line 771
      return ((ngx_int_t )-5);
    }
  }
#line 777
  k = (ngx_uint_t )0;
#line 779
  i = (ngx_uint_t )0;
  {
#line 779
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 779
    if (! (i < last)) {
#line 779
      goto while_break___0;
    }
#line 780
    if (! (flags & 2UL)) {
#line 781
      if ((int )*(key->data + i) >= 65) {
#line 781
        if ((int )*(key->data + i) <= 90) {
#line 781
          tmp = (int )*(key->data + i) | 32;
        } else {
#line 781
          tmp = (int )*(key->data + i);
        }
      } else {
#line 781
        tmp = (int )*(key->data + i);
      }
#line 781
      *(key->data + i) = (u_char )tmp;
    }
#line 783
    k = k * 31UL + (ngx_uint_t )*(key->data + i);
#line 779
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 786
  k %= ha->hsize;
#line 790
  name = (ngx_str_t *)(ha->keys_hash + k)->elts;
#line 792
  if (name) {
#line 793
    i = (ngx_uint_t )0;
    {
#line 793
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 793
      if (! (i < (ha->keys_hash + k)->nelts)) {
#line 793
        goto while_break___1;
      }
#line 794
      if (last != (name + i)->len) {
#line 795
        goto __Cont;
      }
      {
#line 798
      tmp___0 = strncmp((char const   *)key->data, (char const   *)(name + i)->data,
                        last);
      }
#line 798
      if (tmp___0 == 0) {
#line 799
        return ((ngx_int_t )-3);
      }
      __Cont: /* CIL Label */ 
#line 793
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 804
    tmp___1 = ngx_array_init(ha->keys_hash + k, ha->temp_pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
    }
#line 804
    if (tmp___1 != 0L) {
#line 808
      return ((ngx_int_t )-1);
    }
  }
  {
#line 812
  tmp___2 = ngx_array_push(ha->keys_hash + k);
#line 812
  name = (ngx_str_t *)tmp___2;
  }
#line 813
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 814
    return ((ngx_int_t )-1);
  }
  {
#line 817
  *name = *key;
#line 819
  tmp___3 = ngx_array_push(& ha->keys);
#line 819
  hk = (ngx_hash_key_t *)tmp___3;
  }
#line 820
  if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 821
    return ((ngx_int_t )-1);
  }
  {
#line 824
  hk->key = *key;
#line 825
  hk->key_hash = ngx_hash_key(key->data, last);
#line 826
  hk->value = value;
  }
#line 828
  return ((ngx_int_t )0);
  wildcard: 
  {
#line 835
  k = ngx_hash_strlow(key->data + skip, key->data + skip, last - skip);
#line 837
  k %= ha->hsize;
  }
#line 839
  if (skip == 1UL) {
#line 843
    name = (ngx_str_t *)(ha->keys_hash + k)->elts;
#line 845
    if (name) {
#line 846
      len = last - skip;
#line 848
      i = (ngx_uint_t )0;
      {
#line 848
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 848
        if (! (i < (ha->keys_hash + k)->nelts)) {
#line 848
          goto while_break___2;
        }
#line 849
        if (len != (name + i)->len) {
#line 850
          goto __Cont___0;
        }
        {
#line 853
        tmp___4 = strncmp((char const   *)(key->data + 1), (char const   *)(name + i)->data,
                          len);
        }
#line 853
        if (tmp___4 == 0) {
#line 854
          return ((ngx_int_t )-3);
        }
        __Cont___0: /* CIL Label */ 
#line 848
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 859
      tmp___5 = ngx_array_init(ha->keys_hash + k, ha->temp_pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
      }
#line 859
      if (tmp___5 != 0L) {
#line 863
        return ((ngx_int_t )-1);
      }
    }
    {
#line 867
    tmp___6 = ngx_array_push(ha->keys_hash + k);
#line 867
    name = (ngx_str_t *)tmp___6;
    }
#line 868
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 869
      return ((ngx_int_t )-1);
    }
    {
#line 872
    name->len = last - 1UL;
#line 873
    tmp___7 = ngx_pnalloc(ha->temp_pool, name->len);
#line 873
    name->data = (u_char *)tmp___7;
    }
#line 874
    if ((unsigned long )name->data == (unsigned long )((void *)0)) {
#line 875
      return ((ngx_int_t )-1);
    }
    {
#line 878
    memcpy((void */* __restrict  */)name->data, (void const   */* __restrict  */)(key->data + 1),
           name->len);
    }
  }
#line 882
  if (skip) {
    {
#line 889
    tmp___8 = ngx_pnalloc(ha->temp_pool, last);
#line 889
    p = (u_char *)tmp___8;
    }
#line 890
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 891
      return ((ngx_int_t )-1);
    }
#line 894
    len = (size_t___0 )0;
#line 895
    n = (ngx_uint_t )0;
#line 897
    i = last - 1UL;
    {
#line 897
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 897
      if (! i) {
#line 897
        goto while_break___3;
      }
#line 898
      if ((int )*(key->data + i) == 46) {
        {
#line 899
        memcpy((void */* __restrict  */)(p + n), (void const   */* __restrict  */)(key->data + (i + 1UL)),
               len);
#line 900
        n += len;
#line 901
        tmp___9 = n;
#line 901
        n ++;
#line 901
        *(p + tmp___9) = (u_char )'.';
#line 902
        len = (size_t___0 )0;
        }
#line 903
        goto __Cont___1;
      }
#line 906
      len ++;
      __Cont___1: /* CIL Label */ 
#line 897
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 909
    if (len) {
      {
#line 910
      memcpy((void */* __restrict  */)(p + n), (void const   */* __restrict  */)(key->data + 1),
             len);
#line 911
      n += len;
      }
    }
#line 914
    *(p + n) = (u_char )'\000';
#line 916
    hwc = & ha->dns_wc_head;
#line 917
    keys = ha->dns_wc_head_hash + k;
  } else {
    {
#line 923
    last ++;
#line 925
    tmp___10 = ngx_pnalloc(ha->temp_pool, last);
#line 925
    p = (u_char *)tmp___10;
    }
#line 926
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 927
      return ((ngx_int_t )-1);
    }
    {
#line 930
    ngx_cpystrn(p, key->data, last);
#line 932
    hwc = & ha->dns_wc_tail;
#line 933
    keys = ha->dns_wc_tail_hash + k;
    }
  }
#line 939
  name = (ngx_str_t *)keys->elts;
#line 941
  if (name) {
#line 942
    len = last - skip;
#line 944
    i = (ngx_uint_t )0;
    {
#line 944
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 944
      if (! (i < keys->nelts)) {
#line 944
        goto while_break___4;
      }
#line 945
      if (len != (name + i)->len) {
#line 946
        goto __Cont___2;
      }
      {
#line 949
      tmp___11 = strncmp((char const   *)key->data + skip, (char const   *)(name + i)->data,
                         len);
      }
#line 949
      if (tmp___11 == 0) {
#line 950
        return ((ngx_int_t )-3);
      }
      __Cont___2: /* CIL Label */ 
#line 944
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 955
    tmp___12 = ngx_array_init(keys, ha->temp_pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
    }
#line 955
    if (tmp___12 != 0L) {
#line 957
      return ((ngx_int_t )-1);
    }
  }
  {
#line 961
  tmp___13 = ngx_array_push(keys);
#line 961
  name = (ngx_str_t *)tmp___13;
  }
#line 962
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 963
    return ((ngx_int_t )-1);
  }
  {
#line 966
  name->len = last - skip;
#line 967
  tmp___14 = ngx_pnalloc(ha->temp_pool, name->len);
#line 967
  name->data = (u_char *)tmp___14;
  }
#line 968
  if ((unsigned long )name->data == (unsigned long )((void *)0)) {
#line 969
    return ((ngx_int_t )-1);
  }
  {
#line 972
  memcpy((void */* __restrict  */)name->data, (void const   */* __restrict  */)(key->data + skip),
         name->len);
#line 977
  tmp___15 = ngx_array_push(hwc);
#line 977
  hk = (ngx_hash_key_t *)tmp___15;
  }
#line 978
  if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 979
    return ((ngx_int_t )-1);
  }
#line 982
  hk->key.len = last - 1UL;
#line 983
  hk->key.data = p;
#line 984
  hk->key_hash = (ngx_uint_t )0;
#line 985
  hk->value = value;
#line 987
  return ((ngx_int_t )0);
}
}
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_list.c"
ngx_list_t *ngx_list_create(ngx_pool_t *pool , ngx_uint_t n , size_t___0 size ) 
{ 
  ngx_list_t *list ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 17
  tmp = ngx_palloc(pool, sizeof(ngx_list_t ));
#line 17
  list = (ngx_list_t *)tmp;
  }
#line 18
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 19
    return ((ngx_list_t *)((void *)0));
  }
  {
#line 22
  tmp___0 = ngx_list_init(list, pool, n, size);
  }
#line 22
  if (tmp___0 != 0L) {
#line 23
    return ((ngx_list_t *)((void *)0));
  }
#line 26
  return (list);
}
}
#line 30 "/tmp/nginx-1.13.2/src/core/ngx_list.c"
void *ngx_list_push(ngx_list_t *l ) 
{ 
  void *elt ;
  ngx_list_part_t *last ;
  void *tmp ;

  {
#line 36
  last = l->last;
#line 38
  if (last->nelts == l->nalloc) {
    {
#line 42
    tmp = ngx_palloc(l->pool, sizeof(ngx_list_part_t ));
#line 42
    last = (ngx_list_part_t *)tmp;
    }
#line 43
    if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 44
      return ((void *)0);
    }
    {
#line 47
    last->elts = ngx_palloc(l->pool, l->nalloc * l->size);
    }
#line 48
    if ((unsigned long )last->elts == (unsigned long )((void *)0)) {
#line 49
      return ((void *)0);
    }
#line 52
    last->nelts = (ngx_uint_t )0;
#line 53
    last->next = (ngx_list_part_t *)((void *)0);
#line 55
    (l->last)->next = last;
#line 56
    l->last = last;
  }
#line 59
  elt = (void *)((char *)last->elts + l->size * last->nelts);
#line 60
  (last->nelts) ++;
#line 62
  return (elt);
}
}
#line 26 "src/core/ngx_array.h"
void ngx_array_destroy(ngx_array_t *a ) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_array.c"
ngx_array_t *ngx_array_create(ngx_pool_t *p , ngx_uint_t n , size_t___0 size ) 
{ 
  ngx_array_t *a ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 17
  tmp = ngx_palloc(p, sizeof(ngx_array_t ));
#line 17
  a = (ngx_array_t *)tmp;
  }
#line 18
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 19
    return ((ngx_array_t *)((void *)0));
  }
  {
#line 22
  tmp___0 = ngx_array_init(a, p, n, size);
  }
#line 22
  if (tmp___0 != 0L) {
#line 23
    return ((ngx_array_t *)((void *)0));
  }
#line 26
  return (a);
}
}
#line 30 "/tmp/nginx-1.13.2/src/core/ngx_array.c"
void ngx_array_destroy(ngx_array_t *a ) 
{ 
  ngx_pool_t *p ;

  {
#line 35
  p = a->pool;
#line 37
  if ((unsigned long )((u_char *)a->elts + a->size * a->nalloc) == (unsigned long )p->d.last) {
#line 38
    p->d.last -= a->size * a->nalloc;
  }
#line 41
  if ((unsigned long )((u_char *)a + sizeof(ngx_array_t )) == (unsigned long )p->d.last) {
#line 42
    p->d.last = (u_char *)a;
  }
#line 44
  return;
}
}
#line 47 "/tmp/nginx-1.13.2/src/core/ngx_array.c"
void *ngx_array_push(ngx_array_t *a ) 
{ 
  void *elt ;
  void *new ;
  size_t___0 size ;
  ngx_pool_t *p ;

  {
#line 54
  if (a->nelts == a->nalloc) {
#line 58
    size = a->size * a->nalloc;
#line 60
    p = a->pool;
#line 62
    if ((unsigned long )((u_char *)a->elts + size) == (unsigned long )p->d.last) {
#line 62
      if ((unsigned long )(p->d.last + a->size) <= (unsigned long )p->d.end) {
#line 70
        p->d.last += a->size;
#line 71
        (a->nalloc) ++;
      } else {
#line 62
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 76
      new = ngx_palloc(p, 2UL * size);
      }
#line 77
      if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 78
        return ((void *)0);
      }
      {
#line 81
      memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)a->elts,
             size);
#line 82
      a->elts = new;
#line 83
      a->nalloc *= 2UL;
      }
    }
  }
#line 87
  elt = (void *)((u_char *)a->elts + a->size * a->nelts);
#line 88
  (a->nelts) ++;
#line 90
  return (elt);
}
}
#line 94 "/tmp/nginx-1.13.2/src/core/ngx_array.c"
void *ngx_array_push_n(ngx_array_t *a , ngx_uint_t n ) 
{ 
  void *elt ;
  void *new ;
  size_t___0 size ;
  ngx_uint_t nalloc ;
  ngx_pool_t *p ;
  ngx_uint_t tmp ;

  {
#line 102
  size = n * a->size;
#line 104
  if (a->nelts + n > a->nalloc) {
#line 108
    p = a->pool;
#line 110
    if ((unsigned long )((u_char *)a->elts + a->size * a->nalloc) == (unsigned long )p->d.last) {
#line 110
      if ((unsigned long )(p->d.last + size) <= (unsigned long )p->d.end) {
#line 118
        p->d.last += size;
#line 119
        a->nalloc += n;
      } else {
#line 110
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 124
      if (n >= a->nalloc) {
#line 124
        tmp = n;
      } else {
#line 124
        tmp = a->nalloc;
      }
      {
#line 124
      nalloc = 2UL * tmp;
#line 126
      new = ngx_palloc(p, nalloc * a->size);
      }
#line 127
      if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 128
        return ((void *)0);
      }
      {
#line 131
      memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)a->elts,
             a->nelts * a->size);
#line 132
      a->elts = new;
#line 133
      a->nalloc = nalloc;
      }
    }
  }
#line 137
  elt = (void *)((u_char *)a->elts + a->size * a->nelts);
#line 138
  a->nelts += n;
#line 140
  return (elt);
}
}
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
__inline static void *ngx_palloc_small(ngx_pool_t *pool , size_t___0 size , ngx_uint_t align ) ;
#line 14
static void *ngx_palloc_block(ngx_pool_t *pool , size_t___0 size ) ;
#line 15
static void *ngx_palloc_large(ngx_pool_t *pool , size_t___0 size ) ;
#line 18 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
ngx_pool_t *ngx_create_pool(size_t___0 size , ngx_log_t *log ) 
{ 
  ngx_pool_t *p ;
  void *tmp ;

  {
  {
#line 23
  tmp = ngx_memalign((size_t___0 )16, size, log);
#line 23
  p = (ngx_pool_t *)tmp;
  }
#line 24
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 25
    return ((ngx_pool_t *)((void *)0));
  }
#line 28
  p->d.last = (u_char *)p + sizeof(ngx_pool_t );
#line 29
  p->d.end = (u_char *)p + size;
#line 30
  p->d.next = (ngx_pool_t *)((void *)0);
#line 31
  p->d.failed = (ngx_uint_t )0;
#line 33
  size -= sizeof(ngx_pool_t );
#line 34
  if (size < ngx_pagesize - 1UL) {
#line 34
    p->max = size;
  } else {
#line 34
    p->max = ngx_pagesize - 1UL;
  }
#line 36
  p->current = p;
#line 37
  p->chain = (ngx_chain_t *)((void *)0);
#line 38
  p->large = (ngx_pool_large_t *)((void *)0);
#line 39
  p->cleanup = (ngx_pool_cleanup_t *)((void *)0);
#line 40
  p->log = log;
#line 42
  return (p);
}
}
#line 46 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void ngx_destroy_pool(ngx_pool_t *pool ) 
{ 
  ngx_pool_t *p ;
  ngx_pool_t *n ;
  ngx_pool_large_t *l ;
  ngx_pool_cleanup_t *c ;

  {
#line 53
  c = pool->cleanup;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! c) {
#line 53
      goto while_break;
    }
#line 54
    if (c->handler) {
      {
#line 57
      (*(c->handler))(c->data);
      }
    }
#line 53
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  l = pool->large;
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! l) {
#line 83
      goto while_break___0;
    }
#line 84
    if (l->alloc) {
      {
#line 85
      free(l->alloc);
      }
    }
#line 83
    l = l->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 89
  p = pool;
#line 89
  n = pool->d.next;
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 90
    free((void *)p);
    }
#line 92
    if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 93
      goto while_break___1;
    }
#line 89
    p = n;
#line 89
    n = n->d.next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 99 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void ngx_reset_pool(ngx_pool_t *pool ) 
{ 
  ngx_pool_t *p ;
  ngx_pool_large_t *l ;

  {
#line 105
  l = pool->large;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! l) {
#line 105
      goto while_break;
    }
#line 106
    if (l->alloc) {
      {
#line 107
      free(l->alloc);
      }
    }
#line 105
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  p = pool;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! p) {
#line 111
      goto while_break___0;
    }
#line 112
    p->d.last = (u_char *)p + sizeof(ngx_pool_t );
#line 113
    p->d.failed = (ngx_uint_t )0;
#line 111
    p = p->d.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  pool->current = pool;
#line 117
  pool->chain = (ngx_chain_t *)((void *)0);
#line 118
  pool->large = (ngx_pool_large_t *)((void *)0);
#line 119
  return;
}
}
#line 122 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void *ngx_palloc(ngx_pool_t *pool , size_t___0 size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 126
  if (size <= pool->max) {
    {
#line 127
    tmp = ngx_palloc_small(pool, size, (ngx_uint_t )1);
    }
#line 127
    return (tmp);
  }
  {
#line 131
  tmp___0 = ngx_palloc_large(pool, size);
  }
#line 131
  return (tmp___0);
}
}
#line 135 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void *ngx_pnalloc(ngx_pool_t *pool , size_t___0 size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 139
  if (size <= pool->max) {
    {
#line 140
    tmp = ngx_palloc_small(pool, size, (ngx_uint_t )0);
    }
#line 140
    return (tmp);
  }
  {
#line 144
  tmp___0 = ngx_palloc_large(pool, size);
  }
#line 144
  return (tmp___0);
}
}
#line 148 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
__inline static void *ngx_palloc_small(ngx_pool_t *pool , size_t___0 size , ngx_uint_t align ) 
{ 
  u_char *m ;
  ngx_pool_t *p ;
  void *tmp ;

  {
#line 154
  p = pool->current;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    m = p->d.last;
#line 159
    if (align) {
#line 160
      m = (u_char *)(((uintptr_t )m + (sizeof(unsigned long ) - 1UL)) & ~ (sizeof(unsigned long ) - 1UL));
    }
#line 163
    if ((size_t___0 )(p->d.end - m) >= size) {
#line 164
      p->d.last = m + size;
#line 166
      return ((void *)m);
    }
#line 169
    p = p->d.next;
#line 156
    if (! p) {
#line 156
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  tmp = ngx_palloc_block(pool, size);
  }
#line 173
  return (tmp);
}
}
#line 177 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
static void *ngx_palloc_block(ngx_pool_t *pool , size_t___0 size ) 
{ 
  u_char *m ;
  size_t___0 psize ;
  ngx_pool_t *p ;
  ngx_pool_t *new ;
  void *tmp ;
  ngx_uint_t tmp___0 ;

  {
  {
#line 184
  psize = (size_t___0 )(pool->d.end - (u_char *)pool);
#line 186
  tmp = ngx_memalign((size_t___0 )16, psize, pool->log);
#line 186
  m = (u_char *)tmp;
  }
#line 187
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 188
    return ((void *)0);
  }
#line 191
  new = (ngx_pool_t *)m;
#line 193
  new->d.end = m + psize;
#line 194
  new->d.next = (ngx_pool_t *)((void *)0);
#line 195
  new->d.failed = (ngx_uint_t )0;
#line 197
  m += sizeof(ngx_pool_data_t );
#line 198
  m = (u_char *)(((uintptr_t )m + (sizeof(unsigned long ) - 1UL)) & ~ (sizeof(unsigned long ) - 1UL));
#line 199
  new->d.last = m + size;
#line 201
  p = pool->current;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! p->d.next) {
#line 201
      goto while_break;
    }
#line 202
    tmp___0 = p->d.failed;
#line 202
    (p->d.failed) ++;
#line 202
    if (tmp___0 > 4UL) {
#line 203
      pool->current = p->d.next;
    }
#line 201
    p = p->d.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  p->d.next = new;
#line 209
  return ((void *)m);
}
}
#line 213 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
static void *ngx_palloc_large(ngx_pool_t *pool , size_t___0 size ) 
{ 
  void *p ;
  ngx_uint_t n ;
  ngx_pool_large_t *large ;
  ngx_uint_t tmp ;
  void *tmp___0 ;

  {
  {
#line 220
  p = ngx_alloc(size, pool->log);
  }
#line 221
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 222
    return ((void *)0);
  }
#line 225
  n = (ngx_uint_t )0;
#line 227
  large = pool->large;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! large) {
#line 227
      goto while_break;
    }
#line 228
    if ((unsigned long )large->alloc == (unsigned long )((void *)0)) {
#line 229
      large->alloc = p;
#line 230
      return (p);
    }
#line 233
    tmp = n;
#line 233
    n ++;
#line 233
    if (tmp > 3UL) {
#line 234
      goto while_break;
    }
#line 227
    large = large->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 238
  tmp___0 = ngx_palloc_small(pool, sizeof(ngx_pool_large_t ), (ngx_uint_t )1);
#line 238
  large = (ngx_pool_large_t *)tmp___0;
  }
#line 239
  if ((unsigned long )large == (unsigned long )((void *)0)) {
    {
#line 240
    free(p);
    }
#line 241
    return ((void *)0);
  }
#line 244
  large->alloc = p;
#line 245
  large->next = pool->large;
#line 246
  pool->large = large;
#line 248
  return (p);
}
}
#line 252 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void *ngx_pmemalign(ngx_pool_t *pool , size_t___0 size , size_t___0 alignment ) 
{ 
  void *p ;
  ngx_pool_large_t *large ;
  void *tmp ;

  {
  {
#line 258
  p = ngx_memalign(alignment, size, pool->log);
  }
#line 259
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 260
    return ((void *)0);
  }
  {
#line 263
  tmp = ngx_palloc_small(pool, sizeof(ngx_pool_large_t ), (ngx_uint_t )1);
#line 263
  large = (ngx_pool_large_t *)tmp;
  }
#line 264
  if ((unsigned long )large == (unsigned long )((void *)0)) {
    {
#line 265
    free(p);
    }
#line 266
    return ((void *)0);
  }
#line 269
  large->alloc = p;
#line 270
  large->next = pool->large;
#line 271
  pool->large = large;
#line 273
  return (p);
}
}
#line 277 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
ngx_int_t ngx_pfree(ngx_pool_t *pool , void *p ) 
{ 
  ngx_pool_large_t *l ;

  {
#line 282
  l = pool->large;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! l) {
#line 282
      goto while_break;
    }
#line 283
    if ((unsigned long )p == (unsigned long )l->alloc) {
      {
#line 286
      free(l->alloc);
#line 287
      l->alloc = (void *)0;
      }
#line 289
      return ((ngx_int_t )0);
    }
#line 282
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return ((ngx_int_t )-5);
}
}
#line 297 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void *ngx_pcalloc(ngx_pool_t *pool , size_t___0 size ) 
{ 
  void *p ;

  {
  {
#line 302
  p = ngx_palloc(pool, size);
  }
#line 303
  if (p) {
    {
#line 304
    memset(p, 0, size);
    }
  }
#line 307
  return (p);
}
}
#line 311 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p , size_t___0 size ) 
{ 
  ngx_pool_cleanup_t *c ;
  void *tmp ;

  {
  {
#line 316
  tmp = ngx_palloc(p, sizeof(ngx_pool_cleanup_t ));
#line 316
  c = (ngx_pool_cleanup_t *)tmp;
  }
#line 317
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 318
    return ((ngx_pool_cleanup_t *)((void *)0));
  }
#line 321
  if (size) {
    {
#line 322
    c->data = ngx_palloc(p, size);
    }
#line 323
    if ((unsigned long )c->data == (unsigned long )((void *)0)) {
#line 324
      return ((ngx_pool_cleanup_t *)((void *)0));
    }
  } else {
#line 328
    c->data = (void *)0;
  }
#line 331
  c->handler = (void (*)(void *data ))((void *)0);
#line 332
  c->next = p->cleanup;
#line 334
  p->cleanup = c;
#line 338
  return (c);
}
}
#line 342 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void ngx_pool_run_cleanup_file(ngx_pool_t *p , ngx_fd_t fd ) 
{ 
  ngx_pool_cleanup_t *c ;
  ngx_pool_cleanup_file_t *cf ;

  {
#line 348
  c = p->cleanup;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! c) {
#line 348
      goto while_break;
    }
#line 349
    if ((unsigned long )c->handler == (unsigned long )(& ngx_pool_cleanup_file)) {
#line 351
      cf = (ngx_pool_cleanup_file_t *)c->data;
#line 353
      if (cf->fd == fd) {
        {
#line 354
        (*(c->handler))((void *)cf);
#line 355
        c->handler = (void (*)(void *data ))((void *)0);
        }
#line 356
        return;
      }
    }
#line 348
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return;
}
}
#line 363 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void ngx_pool_cleanup_file(void *data ) 
{ 
  ngx_pool_cleanup_file_t *c ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 366
  c = (ngx_pool_cleanup_file_t *)data;
#line 371
  tmp___0 = close(c->fd);
  }
#line 371
  if (tmp___0 == -1) {
#line 372
    if ((c->log)->log_level >= 2UL) {
      {
#line 372
      tmp = __errno_location();
#line 372
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "close() \"%s\" failed", c->name);
      }
    }
  }
#line 375
  return;
}
}
#line 378 "/tmp/nginx-1.13.2/src/core/ngx_palloc.c"
void ngx_pool_delete_file(void *data ) 
{ 
  ngx_pool_cleanup_file_t *c ;
  ngx_err_t err ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 381
  c = (ngx_pool_cleanup_file_t *)data;
#line 388
  tmp___0 = unlink((char const   *)c->name);
  }
#line 388
  if (tmp___0 == -1) {
    {
#line 389
    tmp = __errno_location();
#line 389
    err = *tmp;
    }
#line 391
    if (err != 2) {
#line 392
      if ((c->log)->log_level >= 3UL) {
        {
#line 392
        ngx_log_error_core((ngx_uint_t )3, c->log, err, "unlink() \"%s\" failed",
                           c->name);
        }
      }
    }
  }
  {
#line 397
  tmp___2 = close(c->fd);
  }
#line 397
  if (tmp___2 == -1) {
#line 398
    if ((c->log)->log_level >= 2UL) {
      {
#line 398
      tmp___1 = __errno_location();
#line 398
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp___1, "close() \"%s\" failed",
                         c->name);
      }
    }
  }
#line 401
  return;
}
}
#line 231 "src/core/ngx_log.h"
ngx_log_t *ngx_log_init(u_char *prefix ) ;
#line 232
void ngx_log_abort(ngx_err_t err , char const   *fmt  , ...) ;
#line 12 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static char *ngx_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 13
static char *ngx_log_set_levels(ngx_conf_t *cf , ngx_log_t *log ) ;
#line 14
static void ngx_log_insert(ngx_log_t *log , ngx_log_t *new_log ) ;
#line 34 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static ngx_command_t ngx_errlog_commands[2]  = {      {{sizeof("error_log") - 1UL, (u_char *)"error_log"}, (ngx_uint_t )16779264, & ngx_error_log,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 47 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static ngx_core_module_t ngx_errlog_module_ctx  =    {{sizeof("errlog") - 1UL, (u_char *)"errlog"}, (void *(*)(ngx_cycle_t *cycle ))((void *)0),
    (char *(*)(ngx_cycle_t *cycle , void *conf ))((void *)0)};
#line 54 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
ngx_module_t ngx_errlog_module  = 
#line 54
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_errlog_module_ctx),
    ngx_errlog_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 70 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static ngx_log_t ngx_log  ;
#line 71 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static ngx_open_file_t ngx_log_file  ;
#line 72 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
ngx_uint_t ngx_use_stderr  =    (ngx_uint_t )1;
#line 75 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static ngx_str_t err_levels[9]  = 
#line 75
  {      {(size_t___0 )0, (u_char *)((void *)0)}, 
        {sizeof("emerg") - 1UL, (u_char *)"emerg"}, 
        {sizeof("alert") - 1UL, (u_char *)"alert"}, 
        {sizeof("crit") - 1UL, (u_char *)"crit"}, 
        {sizeof("error") - 1UL, (u_char *)"error"}, 
        {sizeof("warn") - 1UL, (u_char *)"warn"}, 
        {sizeof("notice") - 1UL, (u_char *)"notice"}, 
        {sizeof("info") - 1UL, (u_char *)"info"}, 
        {sizeof("debug") - 1UL, (u_char *)"debug"}};
#line 87 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static char const   *debug_levels[7]  = {      "debug_core",      "debug_alloc",      "debug_mutex",      "debug_event", 
        "debug_http",      "debug_mail",      "debug_stream"};
#line 95 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
void ngx_log_error_core(ngx_uint_t level , ngx_log_t *log , ngx_err_t err , char const   *fmt 
                        , ...) 
{ 
  va_list___0 args___0 ;
  u_char *p ;
  u_char *last ;
  u_char *msg ;
  ssize_t n ;
  ngx_uint_t wrote_stderr ;
  ngx_uint_t debug_connection ;
  u_char errstr[2048] ;
  void *tmp ;
  u_char *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 115
  last = errstr + 2048;
#line 117
  tmp = memcpy((void */* __restrict  */)(errstr), (void const   */* __restrict  */)ngx_cached_err_log_time.data,
               (size_t )ngx_cached_err_log_time.len);
#line 117
  p = (u_char *)tmp + ngx_cached_err_log_time.len;
#line 120
  p = ngx_slprintf(p, last, " [%V] ", & err_levels[level]);
#line 123
  p = ngx_slprintf(p, last, "%P#%d: ", ngx_pid, 0);
  }
#line 126
  if (log->connection) {
    {
#line 127
    p = ngx_slprintf(p, last, "*%uA ", log->connection);
    }
  }
  {
#line 130
  msg = p;
#line 134
  __builtin_va_start(args___0, fmt);
#line 135
  p = ngx_vslprintf(p, last, fmt, args___0);
#line 136
  __builtin_va_end(args___0);
  }
#line 144
  if (err) {
    {
#line 145
    p = ngx_log_errno(p, last, err);
    }
  }
#line 148
  if (level != 8UL) {
#line 148
    if (log->handler) {
      {
#line 149
      p = (*(log->handler))(log, p, (size_t___0 )(last - p));
      }
    }
  }
#line 152
  if ((unsigned long )p > (unsigned long )(last - 1)) {
#line 153
    p = last - 1;
  }
#line 156
  tmp___0 = p;
#line 156
  p ++;
#line 156
  *tmp___0 = (u_char )'\n';
#line 158
  wrote_stderr = (ngx_uint_t )0;
#line 159
  debug_connection = (ngx_uint_t )((log->log_level & 2147483648UL) != 0UL);
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! log) {
#line 161
      goto while_break;
    }
#line 163
    if (log->log_level < level) {
#line 163
      if (! debug_connection) {
#line 164
        goto while_break;
      }
    }
#line 167
    if (log->writer) {
      {
#line 168
      (*(log->writer))(log, level, errstr, (size_t___0 )(p - errstr));
      }
#line 169
      goto next;
    }
#line 172
    if (ngx_cached_time->sec == (time_t volatile   )log->disk_full_time) {
#line 180
      goto next;
    }
    {
#line 183
    n = ngx_write_fd((log->file)->fd, (void *)(errstr), (size_t___0 )(p - errstr));
    }
#line 185
    if (n == -1L) {
      {
#line 185
      tmp___1 = __errno_location();
      }
#line 185
      if (*tmp___1 == 28) {
#line 186
        log->disk_full_time = (time_t )ngx_cached_time->sec;
      }
    }
#line 189
    if ((log->file)->fd == 2) {
#line 190
      wrote_stderr = (ngx_uint_t )1;
    }
    next: 
#line 195
    log = log->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if (! ngx_use_stderr) {
#line 202
    return;
  } else
#line 198
  if (level > 5UL) {
#line 202
    return;
  } else
#line 198
  if (wrote_stderr) {
#line 202
    return;
  }
  {
#line 205
  msg -= (7UL + err_levels[level].len) + 3UL;
#line 207
  ngx_sprintf(msg, "nginx: [%V] ", & err_levels[level]);
#line 209
  ngx_write_fd(2, (void *)msg, (size_t___0 )(p - msg));
  }
#line 210
  return;
}
}
#line 242 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
void ngx_log_abort(ngx_err_t err , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list___0 args___0 ;
  u_char errstr[1024] ;

  {
  {
#line 249
  __builtin_va_start(args___0, fmt);
#line 250
  p = ngx_vslprintf(errstr, errstr + (sizeof(errstr) - 1UL), fmt, args___0);
#line 251
  __builtin_va_end(args___0);
  }
#line 253
  if ((ngx_cycle->log)->log_level >= 2UL) {
    {
#line 253
    ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, err, "%*s", p - errstr,
                       errstr);
    }
  }
#line 255
  return;
}
}
#line 258 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
void ngx_log_stderr(ngx_err_t err , char const   *fmt  , ...) 
{ 
  u_char *p ;
  u_char *last ;
  va_list___0 args___0 ;
  u_char errstr[2048] ;
  void *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 265
  last = errstr + 2048;
#line 267
  tmp = memcpy((void */* __restrict  */)(errstr), (void const   */* __restrict  */)"nginx: ",
               (size_t )7);
#line 267
  p = (u_char *)tmp + 7;
#line 269
  __builtin_va_start(args___0, fmt);
#line 270
  p = ngx_vslprintf(p, last, fmt, args___0);
#line 271
  __builtin_va_end(args___0);
  }
#line 273
  if (err) {
    {
#line 274
    p = ngx_log_errno(p, last, err);
    }
  }
#line 277
  if ((unsigned long )p > (unsigned long )(last - 1)) {
#line 278
    p = last - 1;
  }
  {
#line 281
  tmp___0 = p;
#line 281
  p ++;
#line 281
  *tmp___0 = (u_char )'\n';
#line 283
  ngx_write_fd(2, (void *)(errstr), (size_t___0 )(p - errstr));
  }
#line 284
  return;
}
}
#line 287 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
u_char *ngx_log_errno(u_char *buf , u_char *last , ngx_err_t err ) 
{ 
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 290
  if ((unsigned long )buf > (unsigned long )(last - 50)) {
#line 294
    buf = last - 50;
#line 295
    tmp = buf;
#line 295
    buf ++;
#line 295
    *tmp = (u_char )'.';
#line 296
    tmp___0 = buf;
#line 296
    buf ++;
#line 296
    *tmp___0 = (u_char )'.';
#line 297
    tmp___1 = buf;
#line 297
    buf ++;
#line 297
    *tmp___1 = (u_char )'.';
  }
  {
#line 304
  buf = ngx_slprintf(buf, last, " (%d: ", err);
#line 307
  buf = ngx_strerror(err, buf, (size_t___0 )(last - buf));
  }
#line 309
  if ((unsigned long )buf < (unsigned long )last) {
#line 310
    tmp___2 = buf;
#line 310
    buf ++;
#line 310
    *tmp___2 = (u_char )')';
  }
#line 313
  return (buf);
}
}
#line 317 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
ngx_log_t *ngx_log_init(u_char *prefix ) 
{ 
  u_char *p ;
  u_char *name ;
  size_t___0 nlen ;
  size_t___0 plen ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 323
  ngx_log.file = & ngx_log_file;
#line 324
  ngx_log.log_level = (ngx_uint_t )6;
#line 326
  name = (u_char *)"logs/error.log";
#line 333
  nlen = strlen((char const   *)name);
  }
#line 335
  if (nlen == 0UL) {
#line 336
    ngx_log_file.fd = 2;
#line 337
    return (& ngx_log);
  }
#line 340
  p = (u_char *)((void *)0);
#line 345
  if ((int )*(name + 0) != 47) {
#line 348
    if (prefix) {
      {
#line 349
      plen = strlen((char const   *)prefix);
      }
    } else {
      {
#line 353
      prefix = (u_char *)"/usr/local/nginx/";
#line 354
      plen = strlen((char const   *)prefix);
      }
    }
#line 360
    if (plen) {
      {
#line 361
      tmp = malloc((plen + nlen) + 2UL);
#line 361
      name = (u_char *)tmp;
      }
#line 362
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 363
        return ((ngx_log_t *)((void *)0));
      }
      {
#line 366
      tmp___0 = memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)prefix,
                       plen);
#line 366
      p = (u_char *)tmp___0 + plen;
      }
#line 368
      if (! ((int )*(p - 1) == 47)) {
#line 369
        tmp___1 = p;
#line 369
        p ++;
#line 369
        *tmp___1 = (u_char )'/';
      }
      {
#line 372
      ngx_cpystrn(p, (u_char *)"logs/error.log", nlen + 1UL);
#line 374
      p = name;
      }
    }
  }
  {
#line 378
  ngx_log_file.fd = open((char const   *)name, 1089, 420);
  }
#line 382
  if (ngx_log_file.fd == -1) {
    {
#line 383
    tmp___2 = __errno_location();
#line 383
    ngx_log_stderr(*tmp___2, "[alert] could not open error log file: open() \"%s\" failed",
                   name);
#line 392
    ngx_log_file.fd = 2;
    }
  }
#line 395
  if (p) {
    {
#line 396
    free((void *)p);
    }
  }
#line 399
  return (& ngx_log);
}
}
#line 407 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static ngx_str_t error_log  =    {sizeof("logs/error.log") - 1UL, (u_char *)"logs/error.log"};
#line 403 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
ngx_int_t ngx_log_open_default(ngx_cycle_t *cycle ) 
{ 
  ngx_log_t *log ;
  ngx_log_t *tmp ;
  void *tmp___0 ;

  {
  {
#line 409
  tmp = ngx_log_get_file_log(& cycle->new_log);
  }
#line 409
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 410
    return ((ngx_int_t )0);
  }
#line 413
  if (cycle->new_log.log_level != 0UL) {
    {
#line 416
    tmp___0 = ngx_pcalloc(cycle->pool, sizeof(ngx_log_t ));
#line 416
    log = (ngx_log_t *)tmp___0;
    }
#line 417
    if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 418
      return ((ngx_int_t )-1);
    }
  } else {
#line 423
    log = & cycle->new_log;
  }
  {
#line 426
  log->log_level = (ngx_uint_t )4;
#line 428
  log->file = ngx_conf_open_file(cycle, & error_log);
  }
#line 429
  if ((unsigned long )log->file == (unsigned long )((void *)0)) {
#line 430
    return ((ngx_int_t )-1);
  }
#line 433
  if ((unsigned long )log != (unsigned long )(& cycle->new_log)) {
    {
#line 434
    ngx_log_insert(& cycle->new_log, log);
    }
  }
#line 437
  return ((ngx_int_t )0);
}
}
#line 441 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
ngx_int_t ngx_log_redirect_stderr(ngx_cycle_t *cycle ) 
{ 
  ngx_fd_t fd ;
  ngx_log_t *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 446
  if (cycle->log_use_stderr) {
#line 447
    return ((ngx_int_t )0);
  }
  {
#line 451
  tmp = ngx_log_get_file_log(cycle->log);
#line 451
  fd = (tmp->file)->fd;
  }
#line 453
  if (fd != 2) {
    {
#line 454
    tmp___1 = dup2(fd, 2);
    }
#line 454
    if (tmp___1 == -1) {
#line 455
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 455
        tmp___0 = __errno_location();
#line 455
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "dup2(STDERR_FILENO) failed");
        }
      }
#line 458
      return ((ngx_int_t )-1);
    }
  }
#line 462
  return ((ngx_int_t )0);
}
}
#line 466 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
ngx_log_t *ngx_log_get_file_log(ngx_log_t *head___0 ) 
{ 
  ngx_log_t *log ;

  {
#line 471
  log = head___0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! log) {
#line 471
      goto while_break;
    }
#line 472
    if ((unsigned long )log->file != (unsigned long )((void *)0)) {
#line 473
      return (log);
    }
#line 471
    log = log->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return ((ngx_log_t *)((void *)0));
}
}
#line 481 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static char *ngx_log_set_levels(ngx_conf_t *cf , ngx_log_t *log ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t d ;
  ngx_uint_t found ;
  ngx_str_t *value ;
  int tmp ;
  ngx_uint_t tmp___0 ;
  int tmp___1 ;

  {
#line 487
  if ((cf->args)->nelts == 2UL) {
#line 488
    log->log_level = (ngx_uint_t )4;
#line 489
    return ((char *)((void *)0));
  }
#line 492
  value = (ngx_str_t *)(cf->args)->elts;
#line 494
  i = (ngx_uint_t )2;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! (i < (cf->args)->nelts)) {
#line 494
      goto while_break;
    }
#line 495
    found = (ngx_uint_t )0;
#line 497
    n = (ngx_uint_t )1;
    {
#line 497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 497
      if (! (n <= 8UL)) {
#line 497
        goto while_break___0;
      }
      {
#line 498
      tmp = strcmp((char const   *)(value + i)->data, (char const   *)err_levels[n].data);
      }
#line 498
      if (tmp == 0) {
#line 500
        if (log->log_level != 0UL) {
          {
#line 501
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate log level \"%V\"",
                             value + i);
          }
#line 504
          return ((char *)((void *)-1));
        }
#line 507
        log->log_level = n;
#line 508
        found = (ngx_uint_t )1;
#line 509
        goto while_break___0;
      }
#line 497
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 513
    n = (ngx_uint_t )0;
#line 513
    d = (ngx_uint_t )16;
    {
#line 513
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 513
      if (! (d <= 1024UL)) {
#line 513
        goto while_break___1;
      }
      {
#line 514
      tmp___0 = n;
#line 514
      n ++;
#line 514
      tmp___1 = strcmp((char const   *)(value + i)->data, debug_levels[tmp___0]);
      }
#line 514
      if (tmp___1 == 0) {
#line 515
        if (log->log_level & 0xffffffff8000000fUL) {
          {
#line 516
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid log level \"%V\"", value + i);
          }
#line 519
          return ((char *)((void *)-1));
        }
#line 522
        log->log_level |= d;
#line 523
        found = (ngx_uint_t )1;
#line 524
        goto while_break___1;
      }
#line 513
      d <<= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 529
    if (! found) {
      {
#line 530
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid log level \"%V\"", value + i);
      }
#line 532
      return ((char *)((void *)-1));
    }
#line 494
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (log->log_level == 8UL) {
#line 537
    log->log_level = (ngx_uint_t )2147483632;
  }
#line 540
  return ((char *)((void *)0));
}
}
#line 544 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static char *ngx_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_log_t *dummy ;
  char *tmp ;

  {
  {
#line 549
  dummy = & (cf->cycle)->new_log;
#line 551
  tmp = ngx_log_set_log(cf, & dummy);
  }
#line 551
  return (tmp);
}
}
#line 555 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
char *ngx_log_set_log(ngx_conf_t *cf , ngx_log_t **head___0 ) 
{ 
  ngx_log_t *new_log ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_syslog_peer_t *peer ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
#line 562
  if ((unsigned long )*head___0 != (unsigned long )((void *)0)) {
#line 562
    if ((*head___0)->log_level == 0UL) {
#line 563
      new_log = *head___0;
    } else {
#line 562
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 567
    tmp = ngx_pcalloc(cf->pool, sizeof(ngx_log_t ));
#line 567
    new_log = (ngx_log_t *)tmp;
    }
#line 568
    if ((unsigned long )new_log == (unsigned long )((void *)0)) {
#line 569
      return ((char *)((void *)-1));
    }
#line 572
    if ((unsigned long )*head___0 == (unsigned long )((void *)0)) {
#line 573
      *head___0 = new_log;
    }
  }
  {
#line 577
  value = (ngx_str_t *)(cf->args)->elts;
#line 579
  tmp___4 = strcmp((char const   *)(value + 1)->data, "stderr");
  }
#line 579
  if (tmp___4 == 0) {
    {
#line 580
    name.len = (size_t___0 )0;
#line 580
    name.data = (u_char *)((void *)0);
#line 581
    (cf->cycle)->log_use_stderr = (ngx_uint_t )1;
#line 583
    new_log->file = ngx_conf_open_file(cf->cycle, & name);
    }
#line 584
    if ((unsigned long )new_log->file == (unsigned long )((void *)0)) {
#line 585
      return ((char *)((void *)-1));
    }
  } else {
    {
#line 588
    tmp___3 = strncmp((char const   *)(value + 1)->data, "memory:", (size_t )7);
    }
#line 588
    if (tmp___3 == 0) {
      {
#line 642
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "nginx was built without debug support");
      }
#line 644
      return ((char *)((void *)-1));
    } else {
      {
#line 647
      tmp___2 = strncmp((char const   *)(value + 1)->data, "syslog:", (size_t )7);
      }
#line 647
      if (tmp___2 == 0) {
        {
#line 648
        tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_syslog_peer_t ));
#line 648
        peer = (ngx_syslog_peer_t *)tmp___0;
        }
#line 649
        if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 650
          return ((char *)((void *)-1));
        }
        {
#line 653
        tmp___1 = ngx_syslog_process_conf(cf, peer);
        }
#line 653
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 654
          return ((char *)((void *)-1));
        }
#line 657
        new_log->writer = & ngx_syslog_writer;
#line 658
        new_log->wdata = (void *)peer;
      } else {
        {
#line 661
        new_log->file = ngx_conf_open_file(cf->cycle, value + 1);
        }
#line 662
        if ((unsigned long )new_log->file == (unsigned long )((void *)0)) {
#line 663
          return ((char *)((void *)-1));
        }
      }
    }
  }
  {
#line 667
  tmp___5 = ngx_log_set_levels(cf, new_log);
  }
#line 667
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 668
    return ((char *)((void *)-1));
  }
#line 671
  if ((unsigned long )*head___0 != (unsigned long )new_log) {
    {
#line 672
    ngx_log_insert(*head___0, new_log);
    }
  }
#line 675
  return ((char *)((void *)0));
}
}
#line 679 "/tmp/nginx-1.13.2/src/core/ngx_log.c"
static void ngx_log_insert(ngx_log_t *log , ngx_log_t *new_log ) 
{ 
  ngx_log_t tmp ;

  {
#line 684
  if (new_log->log_level > log->log_level) {
#line 691
    tmp = *log;
#line 692
    *log = *new_log;
#line 693
    *new_log = tmp;
#line 695
    log->next = new_log;
#line 696
    return;
  }
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! log->next) {
#line 699
      goto while_break;
    }
#line 700
    if (new_log->log_level > (log->next)->log_level) {
#line 701
      new_log->next = log->next;
#line 702
      log->next = new_log;
#line 703
      return;
    }
#line 706
    log = log->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  log->next = new_log;
#line 710
  return;
}
}
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 115 "/usr/include/pwd.h"
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
#line 107 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
#line 250 "src/core/ngx_log.h"
__inline static void ngx_write_stderr(char *text ) 
{ 
  size_t tmp ;

  {
  {
#line 253
  tmp = strlen((char const   *)text);
#line 253
  ngx_write_fd(2, (void *)text, tmp);
  }
#line 254
  return;
}
}
#line 257 "src/core/ngx_log.h"
__inline static void ngx_write_stdout(char *text ) 
{ 
  size_t tmp ;

  {
  {
#line 260
  tmp = strlen((char const   *)text);
#line 260
  ngx_write_fd(1, (void *)text, tmp);
  }
#line 261
  return;
}
}
#line 13 "/tmp/nginx-1.13.2/src/core/nginx.c"
static void ngx_show_version_info(void) ;
#line 14
static ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle ) ;
#line 15
static void ngx_cleanup_environment(void *data ) ;
#line 16
static ngx_int_t ngx_get_options(int argc , char * const  *argv ) ;
#line 17
static ngx_int_t ngx_process_options(ngx_cycle_t *cycle ) ;
#line 18
static ngx_int_t ngx_save_argv(ngx_cycle_t *cycle , int argc , char * const  *argv ) ;
#line 19
static void *ngx_core_module_create_conf(ngx_cycle_t *cycle ) ;
#line 20
static char *ngx_core_module_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 21
static char *ngx_set_user(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 22
static char *ngx_set_env(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 23
static char *ngx_set_priority(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 24
static char *ngx_set_cpu_affinity(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 26
static char *ngx_set_worker_processes(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 28
static char *ngx_load_module(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 30
static void ngx_unload_module(void *data ) ;
#line 34 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_conf_enum_t ngx_debug_points[3]  = {      {{sizeof("stop") - 1UL, (u_char *)"stop"}, (ngx_uint_t )1}, 
        {{sizeof("abort") - 1UL, (u_char *)"abort"}, (ngx_uint_t )2}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 41 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_command_t ngx_core_commands[17]  = 
#line 41
  {      {{sizeof("daemon") - 1UL, (u_char *)"daemon"}, (ngx_uint_t )16843264, & ngx_conf_set_flag_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->daemon), (void *)0}, 
        {{sizeof("master_process") - 1UL,
       (u_char *)"master_process"}, (ngx_uint_t )16843264, & ngx_conf_set_flag_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->master), (void *)0}, 
        {{sizeof("timer_resolution") - 1UL,
       (u_char *)"timer_resolution"}, (ngx_uint_t )16842754, & ngx_conf_set_msec_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->timer_resolution),
      (void *)0}, 
        {{sizeof("pid") - 1UL, (u_char *)"pid"}, (ngx_uint_t )16842754, & ngx_conf_set_str_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->pid), (void *)0}, 
        {{sizeof("lock_file") - 1UL,
       (u_char *)"lock_file"}, (ngx_uint_t )16842754, & ngx_conf_set_str_slot, (ngx_uint_t )0,
      (unsigned long )(& ((ngx_core_conf_t *)0)->lock_file), (void *)0}, 
        {{sizeof("worker_processes") - 1UL, (u_char *)"worker_processes"}, (ngx_uint_t )16842754,
      & ngx_set_worker_processes, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("debug_points") - 1UL, (u_char *)"debug_points"}, (ngx_uint_t )16842754,
      & ngx_conf_set_enum_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->debug_points),
      (void *)(& ngx_debug_points)}, 
        {{sizeof("user") - 1UL, (u_char *)"user"}, (ngx_uint_t )16842758, & ngx_set_user,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("worker_priority") - 1UL, (u_char *)"worker_priority"}, (ngx_uint_t )16842754,
      & ngx_set_priority, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("worker_cpu_affinity") - 1UL, (u_char *)"worker_cpu_affinity"}, (ngx_uint_t )16844800,
      & ngx_set_cpu_affinity, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("worker_rlimit_nofile") - 1UL, (u_char *)"worker_rlimit_nofile"}, (ngx_uint_t )16842754,
      & ngx_conf_set_num_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->rlimit_nofile),
      (void *)0}, 
        {{sizeof("worker_rlimit_core") - 1UL, (u_char *)"worker_rlimit_core"}, (ngx_uint_t )16842754,
      & ngx_conf_set_off_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->rlimit_core),
      (void *)0}, 
        {{sizeof("worker_shutdown_timeout") - 1UL, (u_char *)"worker_shutdown_timeout"},
      (ngx_uint_t )16842754, & ngx_conf_set_msec_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->shutdown_timeout),
      (void *)0}, 
        {{sizeof("working_directory") - 1UL, (u_char *)"working_directory"}, (ngx_uint_t )16842754,
      & ngx_conf_set_str_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->working_directory),
      (void *)0}, 
        {{sizeof("env") - 1UL, (u_char *)"env"}, (ngx_uint_t )16842754, & ngx_set_env,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("load_module") - 1UL, (u_char *)"load_module"}, (ngx_uint_t )16842754,
      & ngx_load_module, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t___0 )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                          ngx_command_t *cmd ,
                                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 159 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_core_module_t ngx_core_module_ctx  =    {{sizeof("core") - 1UL, (u_char *)"core"}, & ngx_core_module_create_conf, & ngx_core_module_init_conf};
#line 166 "/tmp/nginx-1.13.2/src/core/nginx.c"
ngx_module_t ngx_core_module  = 
#line 166
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013002, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_core_module_ctx),
    ngx_core_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 182 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_uint_t ngx_show_help  ;
#line 183 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_uint_t ngx_show_version  ;
#line 184 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_uint_t ngx_show_configure  ;
#line 185 "/tmp/nginx-1.13.2/src/core/nginx.c"
static u_char *ngx_prefix  ;
#line 186 "/tmp/nginx-1.13.2/src/core/nginx.c"
static u_char *ngx_conf_file  ;
#line 187 "/tmp/nginx-1.13.2/src/core/nginx.c"
static u_char *ngx_conf_params  ;
#line 188 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_signal  ;
#line 191 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char **ngx_os_environ  ;
#line 194 "/tmp/nginx-1.13.2/src/core/nginx.c"
int main(int argc , char * const  *argv ) 
{ 
  ngx_buf_t *b ;
  ngx_log_t *log ;
  ngx_uint_t i ;
  ngx_cycle_t *cycle ;
  ngx_cycle_t init_cycle ;
  ngx_conf_dump_t *cd ;
  ngx_core_conf_t *ccf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;
  ngx_int_t tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
  {
#line 206
  tmp = ngx_strerror_init();
  }
#line 206
  if (tmp != 0L) {
#line 207
    return (1);
  }
  {
#line 210
  tmp___0 = ngx_get_options(argc, argv);
  }
#line 210
  if (tmp___0 != 0L) {
#line 211
    return (1);
  }
#line 214
  if (ngx_show_version) {
    {
#line 215
    ngx_show_version_info();
    }
#line 217
    if (! ngx_test_config) {
#line 218
      return (0);
    }
  }
  {
#line 222
  ngx_max_sockets = (ngx_int_t )-1;
#line 224
  ngx_time_init();
#line 227
  ngx_regex_init();
#line 230
  ngx_pid = getpid();
#line 232
  log = ngx_log_init(ngx_prefix);
  }
#line 233
  if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 234
    return (1);
  }
  {
#line 247
  memset((void *)(& init_cycle), 0, sizeof(ngx_cycle_t ));
#line 248
  init_cycle.log = log;
#line 249
  ngx_cycle = (ngx_cycle_t volatile   *)(& init_cycle);
#line 251
  init_cycle.pool = ngx_create_pool((size_t___0 )1024, log);
  }
#line 252
  if ((unsigned long )init_cycle.pool == (unsigned long )((void *)0)) {
#line 253
    return (1);
  }
  {
#line 256
  tmp___1 = ngx_save_argv(& init_cycle, argc, argv);
  }
#line 256
  if (tmp___1 != 0L) {
#line 257
    return (1);
  }
  {
#line 260
  tmp___2 = ngx_process_options(& init_cycle);
  }
#line 260
  if (tmp___2 != 0L) {
#line 261
    return (1);
  }
  {
#line 264
  tmp___3 = ngx_os_init(log);
  }
#line 264
  if (tmp___3 != 0L) {
#line 265
    return (1);
  }
  {
#line 272
  tmp___4 = ngx_crc32_table_init();
  }
#line 272
  if (tmp___4 != 0L) {
#line 273
    return (1);
  }
  {
#line 276
  tmp___5 = ngx_add_inherited_sockets(& init_cycle);
  }
#line 276
  if (tmp___5 != 0L) {
#line 277
    return (1);
  }
  {
#line 280
  tmp___6 = ngx_preinit_modules();
  }
#line 280
  if (tmp___6 != 0L) {
#line 281
    return (1);
  }
  {
#line 284
  cycle = ngx_init_cycle(& init_cycle);
  }
#line 285
  if ((unsigned long )cycle == (unsigned long )((void *)0)) {
#line 286
    if (ngx_test_config) {
      {
#line 287
      ngx_log_stderr(0, "configuration file %s test failed", init_cycle.conf_file.data);
      }
    }
#line 291
    return (1);
  }
#line 294
  if (ngx_test_config) {
#line 295
    if (! ngx_quiet_mode) {
      {
#line 296
      ngx_log_stderr(0, "configuration file %s test is successful", cycle->conf_file.data);
      }
    }
#line 300
    if (ngx_dump_config) {
#line 301
      cd = (ngx_conf_dump_t *)cycle->config_dump.elts;
#line 303
      i = (ngx_uint_t )0;
      {
#line 303
      while (1) {
        while_continue: /* CIL Label */ ;
#line 303
        if (! (i < cycle->config_dump.nelts)) {
#line 303
          goto while_break;
        }
        {
#line 305
        ngx_write_stdout((char *)"# configuration file ");
#line 306
        ngx_write_fd(1, (void *)(cd + i)->name.data, (cd + i)->name.len);
#line 308
        ngx_write_stdout((char *)":\n");
#line 310
        b = (cd + i)->buffer;
#line 312
        ngx_write_fd(1, (void *)b->pos, (size_t___0 )(b->last - b->pos));
#line 313
        ngx_write_stdout((char *)"\n");
#line 303
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 317
    return (0);
  }
#line 320
  if (ngx_signal) {
    {
#line 321
    tmp___7 = ngx_signal_process(cycle, ngx_signal);
    }
#line 321
    return ((int )tmp___7);
  }
  {
#line 324
  ngx_os_status(cycle->log);
#line 326
  ngx_cycle = (ngx_cycle_t volatile   *)cycle;
#line 328
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
  }
#line 330
  if (ccf->master) {
#line 330
    if (ngx_process == 0UL) {
#line 331
      ngx_process = (ngx_uint_t )1;
    }
  }
  {
#line 336
  tmp___8 = ngx_init_signals(cycle->log);
  }
#line 336
  if (tmp___8 != 0L) {
#line 337
    return (1);
  }
#line 340
  if (! ngx_inherited) {
#line 340
    if (ccf->daemon) {
      {
#line 341
      tmp___9 = ngx_daemon(cycle->log);
      }
#line 341
      if (tmp___9 != 0L) {
#line 342
        return (1);
      }
#line 345
      ngx_daemonized = (ngx_uint_t )1;
    }
  }
#line 348
  if (ngx_inherited) {
#line 349
    ngx_daemonized = (ngx_uint_t )1;
  }
  {
#line 354
  tmp___10 = ngx_create_pidfile(& ccf->pid, cycle->log);
  }
#line 354
  if (tmp___10 != 0L) {
#line 355
    return (1);
  }
  {
#line 358
  tmp___11 = ngx_log_redirect_stderr(cycle);
  }
#line 358
  if (tmp___11 != 0L) {
#line 359
    return (1);
  }
#line 362
  if ((log->file)->fd != 2) {
    {
#line 363
    tmp___13 = close((log->file)->fd);
    }
#line 363
    if (tmp___13 == -1) {
#line 364
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 364
        tmp___12 = __errno_location();
#line 364
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___12, "close() built-in log failed");
        }
      }
    }
  }
#line 369
  ngx_use_stderr = (ngx_uint_t )0;
#line 371
  if (ngx_process == 0UL) {
    {
#line 372
    ngx_single_process_cycle(cycle);
    }
  } else {
    {
#line 375
    ngx_master_process_cycle(cycle);
    }
  }
#line 378
  return (0);
}
}
#line 382 "/tmp/nginx-1.13.2/src/core/nginx.c"
static void ngx_show_version_info(void) 
{ 


  {
  {
#line 385
  ngx_write_stderr((char *)"nginx version: nginx/1.13.2\n");
  }
#line 387
  if (ngx_show_help) {
    {
#line 388
    ngx_write_stderr((char *)"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]\n\nOptions:\n  -?,-h         : this help\n  -v            : show version and exit\n  -V            : show version and configure options then exit\n  -t            : test configuration and exit\n  -T            : test configuration, dump it and exit\n  -q            : suppress non-error messages during configuration testing\n  -s signal     : send signal to a master process: stop, quit, reopen, reload\n  -p prefix     : set prefix path (default: /usr/local/nginx/)\n  -c filename   : set configuration file (default: conf/nginx.conf)\n  -g directives : set global directives out of configuration file\n\n");
    }
  }
#line 417
  if (ngx_show_configure) {
    {
#line 420
    ngx_write_stderr((char *)"built by clang 11.0.0 (https://github.com/llvm/llvm-project.git 48a8c7dcbfb90e917920e90fa2b3ec402e72f4cd)\n");
#line 439
    ngx_write_stderr((char *)"configure arguments:\n");
    }
  }
#line 441
  return;
}
}
#line 444 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle ) 
{ 
  u_char *p ;
  u_char *v ;
  u_char *inherited ;
  ngx_int_t s ;
  ngx_listening_t *ls ;
  char *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 451
  tmp = getenv("NGINX");
#line 451
  inherited = (u_char *)tmp;
  }
#line 453
  if ((unsigned long )inherited == (unsigned long )((void *)0)) {
#line 454
    return ((ngx_int_t )0);
  }
#line 457
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 457
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "using inherited sockets from \"%s\"",
                       inherited);
    }
  }
  {
#line 460
  tmp___0 = ngx_array_init(& cycle->listening, cycle->pool, (ngx_uint_t )10, sizeof(ngx_listening_t ));
  }
#line 460
  if (tmp___0 != 0L) {
#line 464
    return ((ngx_int_t )-1);
  }
#line 467
  p = inherited;
#line 467
  v = p;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! *p) {
#line 467
      goto while_break;
    }
#line 468
    if ((int )*p == 58) {
#line 468
      goto _L;
    } else
#line 468
    if ((int )*p == 59) {
      _L: /* CIL Label */ 
      {
#line 469
      s = ngx_atoi(v, (size_t___0 )(p - v));
      }
#line 470
      if (s == -1L) {
#line 471
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 471
          ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "invalid socket number \"%s\" in NGINX environment variable, ignoring the rest of the variable",
                             v);
          }
        }
#line 475
        goto while_break;
      }
      {
#line 478
      v = p + 1;
#line 480
      tmp___1 = ngx_array_push(& cycle->listening);
#line 480
      ls = (ngx_listening_t *)tmp___1;
      }
#line 481
      if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 482
        return ((ngx_int_t )-1);
      }
      {
#line 485
      memset((void *)ls, 0, sizeof(ngx_listening_t ));
#line 487
      ls->fd = (ngx_socket_t )s;
      }
    }
#line 467
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 491
  if ((unsigned long )v != (unsigned long )p) {
#line 492
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 492
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "invalid socket number \"%s\" in NGINX environment variable, ignoring",
                         v);
      }
    }
  }
  {
#line 497
  ngx_inherited = (ngx_uint_t )1;
#line 499
  tmp___2 = ngx_set_inherited_sockets(cycle);
  }
#line 499
  return (tmp___2);
}
}
#line 503 "/tmp/nginx-1.13.2/src/core/nginx.c"
char **ngx_set_environment(ngx_cycle_t *cycle , ngx_uint_t *last ) 
{ 
  char **p ;
  char **env ;
  ngx_str_t *var ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_core_conf_t *ccf ;
  ngx_pool_cleanup_t *cln ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_uint_t tmp___5 ;
  ngx_uint_t tmp___6 ;
  int tmp___7 ;

  {
#line 512
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 514
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 514
    if (ccf->environment) {
#line 515
      return (ccf->environment);
    }
  }
#line 518
  var = (ngx_str_t *)ccf->env.elts;
#line 520
  i = (ngx_uint_t )0;
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 520
    if (! (i < ccf->env.nelts)) {
#line 520
      goto while_break;
    }
    {
#line 521
    tmp = strcmp((char const   *)(var + i)->data, "TZ");
    }
#line 521
    if (tmp == 0) {
#line 524
      goto tz_found;
    } else {
      {
#line 521
      tmp___0 = strncmp((char const   *)(var + i)->data, "TZ=", (size_t )3);
      }
#line 521
      if (tmp___0 == 0) {
#line 524
        goto tz_found;
      }
    }
#line 520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 528
  tmp___1 = ngx_array_push(& ccf->env);
#line 528
  var = (ngx_str_t *)tmp___1;
  }
#line 529
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 530
    return ((char **)((void *)0));
  }
#line 533
  var->len = (size_t___0 )2;
#line 534
  var->data = (u_char *)"TZ";
#line 536
  var = (ngx_str_t *)ccf->env.elts;
  tz_found: 
#line 540
  n = (ngx_uint_t )0;
#line 542
  i = (ngx_uint_t )0;
  {
#line 542
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 542
    if (! (i < ccf->env.nelts)) {
#line 542
      goto while_break___0;
    }
#line 544
    if ((int )*((var + i)->data + (var + i)->len) == 61) {
#line 545
      n ++;
#line 546
      goto __Cont;
    }
#line 549
    p = ngx_os_environ;
    {
#line 549
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 549
      if (! *p) {
#line 549
        goto while_break___1;
      }
      {
#line 551
      tmp___2 = strncmp((char const   *)*p, (char const   *)(var + i)->data, (var + i)->len);
      }
#line 551
      if (tmp___2 == 0) {
#line 551
        if ((int )*(*p + (var + i)->len) == 61) {
#line 554
          n ++;
#line 555
          goto while_break___1;
        }
      }
#line 549
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 542
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 560
  if (last) {
    {
#line 561
    tmp___3 = ngx_alloc(((*last + n) + 1UL) * sizeof(char *), cycle->log);
#line 561
    env = (char **)tmp___3;
    }
#line 562
    if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 563
      return ((char **)((void *)0));
    }
#line 566
    *last = n;
  } else {
    {
#line 569
    cln = ngx_pool_cleanup_add(cycle->pool, (size_t___0 )0);
    }
#line 570
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 571
      return ((char **)((void *)0));
    }
    {
#line 574
    tmp___4 = ngx_alloc((n + 1UL) * sizeof(char *), cycle->log);
#line 574
    env = (char **)tmp___4;
    }
#line 575
    if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 576
      return ((char **)((void *)0));
    }
#line 579
    cln->handler = & ngx_cleanup_environment;
#line 580
    cln->data = (void *)env;
  }
#line 583
  n = (ngx_uint_t )0;
#line 585
  i = (ngx_uint_t )0;
  {
#line 585
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 585
    if (! (i < ccf->env.nelts)) {
#line 585
      goto while_break___2;
    }
#line 587
    if ((int )*((var + i)->data + (var + i)->len) == 61) {
#line 588
      tmp___5 = n;
#line 588
      n ++;
#line 588
      *(env + tmp___5) = (char *)(var + i)->data;
#line 589
      goto __Cont___0;
    }
#line 592
    p = ngx_os_environ;
    {
#line 592
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 592
      if (! *p) {
#line 592
        goto while_break___3;
      }
      {
#line 594
      tmp___7 = strncmp((char const   *)*p, (char const   *)(var + i)->data, (var + i)->len);
      }
#line 594
      if (tmp___7 == 0) {
#line 594
        if ((int )*(*p + (var + i)->len) == 61) {
#line 597
          tmp___6 = n;
#line 597
          n ++;
#line 597
          *(env + tmp___6) = *p;
#line 598
          goto while_break___3;
        }
      }
#line 592
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 585
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 603
  *(env + n) = (char *)((void *)0);
#line 605
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 606
    ccf->environment = env;
#line 607
    environ = env;
  }
#line 610
  return (env);
}
}
#line 614 "/tmp/nginx-1.13.2/src/core/nginx.c"
static void ngx_cleanup_environment(void *data ) 
{ 
  char **env ;

  {
#line 617
  env = (char **)data;
#line 619
  if ((unsigned long )environ == (unsigned long )env) {
#line 626
    return;
  }
  {
#line 629
  free((void *)env);
  }
#line 630
  return;
}
}
#line 633 "/tmp/nginx-1.13.2/src/core/nginx.c"
ngx_pid_t ngx_exec_new_binary(ngx_cycle_t *cycle , char * const  *argv ) 
{ 
  char **env ;
  char *var ;
  u_char *p ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_pid_t pid ;
  ngx_exec_ctx_t ctx ;
  ngx_core_conf_t *ccf ;
  ngx_listening_t *ls ;
  void *tmp ;
  void *tmp___0 ;
  ngx_uint_t tmp___1 ;
  ngx_uint_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 644
  memset((void *)(& ctx), 0, sizeof(ngx_exec_ctx_t ));
#line 646
  ctx.path = (char *)*(argv + 0);
#line 647
  ctx.name = (char *)"new binary process";
#line 648
  ctx.argv = argv;
#line 650
  n = (ngx_uint_t )2;
#line 651
  env = ngx_set_environment(cycle, & n);
  }
#line 652
  if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 653
    return (-1);
  }
  {
#line 656
  tmp = ngx_alloc((sizeof("NGINX") + cycle->listening.nelts * ((sizeof("-2147483648") - 1UL) + 1UL)) + 2UL,
                  cycle->log);
#line 656
  var = (char *)tmp;
  }
#line 659
  if ((unsigned long )var == (unsigned long )((void *)0)) {
    {
#line 660
    free((void *)env);
    }
#line 661
    return (-1);
  }
  {
#line 664
  tmp___0 = memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)"NGINX=",
                   sizeof("NGINX"));
#line 664
  p = (u_char *)tmp___0 + sizeof("NGINX");
#line 666
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 667
  i = (ngx_uint_t )0;
  }
  {
#line 667
  while (1) {
    while_continue: /* CIL Label */ ;
#line 667
    if (! (i < cycle->listening.nelts)) {
#line 667
      goto while_break;
    }
    {
#line 668
    p = ngx_sprintf(p, "%ud;", (ls + i)->fd);
#line 667
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 671
  *p = (u_char )'\000';
#line 673
  tmp___1 = n;
#line 673
  n ++;
#line 673
  *(env + tmp___1) = var;
#line 679
  tmp___2 = n;
#line 679
  n ++;
#line 679
  *(env + tmp___2) = (char *)"SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
#line 687
  *(env + n) = (char *)((void *)0);
#line 698
  ctx.envp = (char * const  *)env;
#line 700
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 702
  tmp___4 = rename((char const   *)ccf->pid.data, (char const   *)ccf->oldpid.data);
  }
#line 702
  if (tmp___4 == -1) {
#line 703
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 703
      tmp___3 = __errno_location();
#line 703
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "rename() %s to %s failed before executing new binary process \"%s\"",
                         ccf->pid.data, ccf->oldpid.data, *(argv + 0));
      }
    }
    {
#line 708
    free((void *)env);
#line 709
    free((void *)var);
    }
#line 711
    return (-1);
  }
  {
#line 714
  pid = ngx_execute(cycle, & ctx);
  }
#line 716
  if (pid == -1) {
    {
#line 717
    tmp___6 = rename((char const   *)ccf->oldpid.data, (char const   *)ccf->pid.data);
    }
#line 717
    if (tmp___6 == -1) {
#line 720
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 720
        tmp___5 = __errno_location();
#line 720
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "rename() %s back to %s failed after an attempt to execute new binary process \"%s\"",
                           ccf->oldpid.data, ccf->pid.data, *(argv + 0));
        }
      }
    }
  }
  {
#line 727
  free((void *)env);
#line 728
  free((void *)var);
  }
#line 730
  return (pid);
}
}
#line 734 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_int_t ngx_get_options(int argc , char * const  *argv ) 
{ 
  u_char *p ;
  ngx_int_t i ;
  u_char *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 740
  i = (ngx_int_t )1;
  {
#line 740
  while (1) {
    while_continue: /* CIL Label */ ;
#line 740
    if (! (i < (ngx_int_t )argc)) {
#line 740
      goto while_break;
    }
#line 742
    p = (u_char *)*(argv + i);
#line 744
    tmp = p;
#line 744
    p ++;
#line 744
    if ((int )*tmp != 45) {
      {
#line 745
      ngx_log_stderr(0, "invalid option: \"%s\"", *(argv + i));
      }
#line 746
      return ((ngx_int_t )-1);
    }
    {
#line 749
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 749
      if (! *p) {
#line 749
        goto while_break___0;
      }
#line 751
      tmp___0 = p;
#line 751
      p ++;
      {
#line 754
      if ((int )*tmp___0 == 104) {
#line 754
        goto case_104;
      }
#line 754
      if ((int )*tmp___0 == 63) {
#line 754
        goto case_104;
      }
#line 759
      if ((int )*tmp___0 == 118) {
#line 759
        goto case_118;
      }
#line 763
      if ((int )*tmp___0 == 86) {
#line 763
        goto case_86;
      }
#line 768
      if ((int )*tmp___0 == 116) {
#line 768
        goto case_116;
      }
#line 772
      if ((int )*tmp___0 == 84) {
#line 772
        goto case_84;
      }
#line 777
      if ((int )*tmp___0 == 113) {
#line 777
        goto case_113;
      }
#line 781
      if ((int )*tmp___0 == 112) {
#line 781
        goto case_112;
      }
#line 795
      if ((int )*tmp___0 == 99) {
#line 795
        goto case_99;
      }
#line 809
      if ((int )*tmp___0 == 103) {
#line 809
        goto case_103;
      }
#line 823
      if ((int )*tmp___0 == 115) {
#line 823
        goto case_115;
      }
#line 847
      goto switch_default;
      case_104: /* CIL Label */ 
      case_63: /* CIL Label */ 
#line 755
      ngx_show_version = (ngx_uint_t )1;
#line 756
      ngx_show_help = (ngx_uint_t )1;
#line 757
      goto switch_break;
      case_118: /* CIL Label */ 
#line 760
      ngx_show_version = (ngx_uint_t )1;
#line 761
      goto switch_break;
      case_86: /* CIL Label */ 
#line 764
      ngx_show_version = (ngx_uint_t )1;
#line 765
      ngx_show_configure = (ngx_uint_t )1;
#line 766
      goto switch_break;
      case_116: /* CIL Label */ 
#line 769
      ngx_test_config = (ngx_uint_t )1;
#line 770
      goto switch_break;
      case_84: /* CIL Label */ 
#line 773
      ngx_test_config = (ngx_uint_t )1;
#line 774
      ngx_dump_config = (ngx_uint_t )1;
#line 775
      goto switch_break;
      case_113: /* CIL Label */ 
#line 778
      ngx_quiet_mode = (ngx_uint_t )1;
#line 779
      goto switch_break;
      case_112: /* CIL Label */ 
#line 782
      if (*p) {
#line 783
        ngx_prefix = p;
#line 784
        goto next;
      }
#line 787
      i ++;
#line 787
      if (*(argv + i)) {
#line 788
        ngx_prefix = (u_char *)*(argv + i);
#line 789
        goto next;
      }
      {
#line 792
      ngx_log_stderr(0, "option \"-p\" requires directory name");
      }
#line 793
      return ((ngx_int_t )-1);
      case_99: /* CIL Label */ 
#line 796
      if (*p) {
#line 797
        ngx_conf_file = p;
#line 798
        goto next;
      }
#line 801
      i ++;
#line 801
      if (*(argv + i)) {
#line 802
        ngx_conf_file = (u_char *)*(argv + i);
#line 803
        goto next;
      }
      {
#line 806
      ngx_log_stderr(0, "option \"-c\" requires file name");
      }
#line 807
      return ((ngx_int_t )-1);
      case_103: /* CIL Label */ 
#line 810
      if (*p) {
#line 811
        ngx_conf_params = p;
#line 812
        goto next;
      }
#line 815
      i ++;
#line 815
      if (*(argv + i)) {
#line 816
        ngx_conf_params = (u_char *)*(argv + i);
#line 817
        goto next;
      }
      {
#line 820
      ngx_log_stderr(0, "option \"-g\" requires parameter");
      }
#line 821
      return ((ngx_int_t )-1);
      case_115: /* CIL Label */ 
#line 824
      if (*p) {
#line 825
        ngx_signal = (char *)p;
      } else {
#line 827
        i ++;
#line 827
        if (*(argv + i)) {
#line 828
          ngx_signal = (char *)*(argv + i);
        } else {
          {
#line 831
          ngx_log_stderr(0, "option \"-s\" requires parameter");
          }
#line 832
          return ((ngx_int_t )-1);
        }
      }
      {
#line 835
      tmp___1 = strcmp((char const   *)ngx_signal, "stop");
      }
#line 835
      if (tmp___1 == 0) {
#line 840
        ngx_process = (ngx_uint_t )2;
#line 841
        goto next;
      } else {
        {
#line 835
        tmp___2 = strcmp((char const   *)ngx_signal, "quit");
        }
#line 835
        if (tmp___2 == 0) {
#line 840
          ngx_process = (ngx_uint_t )2;
#line 841
          goto next;
        } else {
          {
#line 835
          tmp___3 = strcmp((char const   *)ngx_signal, "reopen");
          }
#line 835
          if (tmp___3 == 0) {
#line 840
            ngx_process = (ngx_uint_t )2;
#line 841
            goto next;
          } else {
            {
#line 835
            tmp___4 = strcmp((char const   *)ngx_signal, "reload");
            }
#line 835
            if (tmp___4 == 0) {
#line 840
              ngx_process = (ngx_uint_t )2;
#line 841
              goto next;
            }
          }
        }
      }
      {
#line 844
      ngx_log_stderr(0, "invalid option: \"-s %s\"", ngx_signal);
      }
#line 845
      return ((ngx_int_t )-1);
      switch_default: /* CIL Label */ 
      {
#line 848
      ngx_log_stderr(0, "invalid option: \"%c\"", (int )*(p - 1));
      }
#line 849
      return ((ngx_int_t )-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    next: 
#line 855
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 740
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 858
  return ((ngx_int_t )0);
}
}
#line 862 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_int_t ngx_save_argv(ngx_cycle_t *cycle , int argc , char * const  *argv ) 
{ 
  size_t___0 len ;
  ngx_int_t i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 875
  ngx_os_argv = (char **)argv;
#line 876
  ngx_argc = argc;
#line 878
  tmp = ngx_alloc((unsigned long )(argc + 1) * sizeof(char *), cycle->log);
#line 878
  ngx_argv = (char **)tmp;
  }
#line 879
  if ((unsigned long )ngx_argv == (unsigned long )((void *)0)) {
#line 880
    return ((ngx_int_t )-1);
  }
#line 883
  i = (ngx_int_t )0;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (! (i < (ngx_int_t )argc)) {
#line 883
      goto while_break;
    }
    {
#line 884
    tmp___0 = strlen((char const   *)*(argv + i));
#line 884
    len = tmp___0 + 1UL;
#line 886
    tmp___1 = ngx_alloc(len, cycle->log);
#line 886
    *(ngx_argv + i) = (char *)tmp___1;
    }
#line 887
    if ((unsigned long )*(ngx_argv + i) == (unsigned long )((void *)0)) {
#line 888
      return ((ngx_int_t )-1);
    }
    {
#line 891
    ngx_cpystrn((u_char *)*(ngx_argv + i), (u_char *)*(argv + i), len);
#line 883
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 894
  *(ngx_argv + i) = (char *)((void *)0);
#line 898
  ngx_os_environ = environ;
#line 900
  return ((ngx_int_t )0);
}
}
#line 904 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_int_t ngx_process_options(ngx_cycle_t *cycle ) 
{ 
  u_char *p ;
  size_t___0 len ;
  void *tmp ;
  size_t___0 tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 910
  if (ngx_prefix) {
    {
#line 911
    len = strlen((char const   *)ngx_prefix);
#line 912
    p = ngx_prefix;
    }
#line 914
    if (len) {
#line 914
      if (! ((int )*(p + (len - 1UL)) == 47)) {
        {
#line 915
        tmp = ngx_pnalloc(cycle->pool, len + 1UL);
#line 915
        p = (u_char *)tmp;
        }
#line 916
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 917
          return ((ngx_int_t )-1);
        }
        {
#line 920
        memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ngx_prefix,
               len);
#line 921
        tmp___0 = len;
#line 921
        len ++;
#line 921
        *(p + tmp___0) = (u_char )'/';
        }
      }
    }
#line 924
    cycle->conf_prefix.len = len;
#line 925
    cycle->conf_prefix.data = p;
#line 926
    cycle->prefix.len = len;
#line 927
    cycle->prefix.data = p;
  } else {
#line 955
    cycle->conf_prefix.len = sizeof("conf/") - 1UL;
#line 955
    cycle->conf_prefix.data = (u_char *)"conf/";
#line 959
    cycle->prefix.len = sizeof("/usr/local/nginx/") - 1UL;
#line 959
    cycle->prefix.data = (u_char *)"/usr/local/nginx/";
  }
#line 964
  if (ngx_conf_file) {
    {
#line 965
    cycle->conf_file.len = strlen((char const   *)ngx_conf_file);
#line 966
    cycle->conf_file.data = ngx_conf_file;
    }
  } else {
#line 969
    cycle->conf_file.len = sizeof("conf/nginx.conf") - 1UL;
#line 969
    cycle->conf_file.data = (u_char *)"conf/nginx.conf";
  }
  {
#line 972
  tmp___1 = ngx_conf_full_name(cycle, & cycle->conf_file, (ngx_uint_t )0);
  }
#line 972
  if (tmp___1 != 0L) {
#line 973
    return ((ngx_int_t )-1);
  }
#line 976
  p = (cycle->conf_file.data + cycle->conf_file.len) - 1;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! ((unsigned long )p > (unsigned long )cycle->conf_file.data)) {
#line 976
      goto while_break;
    }
#line 980
    if ((int )*p == 47) {
#line 981
      cycle->conf_prefix.len = (size_t___0 )((p - (u_char *)ngx_cycle->conf_file.data) + 1L);
#line 982
      cycle->conf_prefix.data = (u_char *)ngx_cycle->conf_file.data;
#line 983
      goto while_break;
    }
#line 976
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  if (ngx_conf_params) {
    {
#line 988
    cycle->conf_param.len = strlen((char const   *)ngx_conf_params);
#line 989
    cycle->conf_param.data = ngx_conf_params;
    }
  }
#line 992
  if (ngx_test_config) {
#line 993
    (cycle->log)->log_level = (ngx_uint_t )7;
  }
#line 996
  return ((ngx_int_t )0);
}
}
#line 1000 "/tmp/nginx-1.13.2/src/core/nginx.c"
static void *ngx_core_module_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_core_conf_t *ccf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1005
  tmp = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t ));
#line 1005
  ccf = (ngx_core_conf_t *)tmp;
  }
#line 1006
  if ((unsigned long )ccf == (unsigned long )((void *)0)) {
#line 1007
    return ((void *)0);
  }
  {
#line 1021
  ccf->daemon = (ngx_flag_t )-1;
#line 1022
  ccf->master = (ngx_flag_t )-1;
#line 1023
  ccf->timer_resolution = (ngx_msec_t )-1;
#line 1024
  ccf->shutdown_timeout = (ngx_msec_t )-1;
#line 1026
  ccf->worker_processes = (ngx_int_t )-1;
#line 1027
  ccf->debug_points = (ngx_int_t )-1;
#line 1029
  ccf->rlimit_nofile = (ngx_int_t )-1;
#line 1030
  ccf->rlimit_core = (off_t )-1;
#line 1032
  ccf->user = (ngx_uid_t )((ngx_uint_t )-1);
#line 1033
  ccf->group = (ngx_gid_t )((ngx_uint_t )-1);
#line 1035
  tmp___0 = ngx_array_init(& ccf->env, cycle->pool, (ngx_uint_t )1, sizeof(ngx_str_t ));
  }
#line 1035
  if (tmp___0 != 0L) {
#line 1038
    return ((void *)0);
  }
#line 1041
  return ((void *)ccf);
}
}
#line 1045 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_core_module_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct group *grp ;
  struct passwd *pwd ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  __uid_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_str_t lock_file ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
#line 1048
  ccf = (ngx_core_conf_t *)conf;
#line 1050
  if (ccf->daemon == -1L) {
#line 1050
    ccf->daemon = (ngx_flag_t )1;
  }
#line 1051
  if (ccf->master == -1L) {
#line 1051
    ccf->master = (ngx_flag_t )1;
  }
#line 1052
  if (ccf->timer_resolution == 0xffffffffffffffffUL) {
#line 1052
    ccf->timer_resolution = (ngx_msec_t )0;
  }
#line 1053
  if (ccf->shutdown_timeout == 0xffffffffffffffffUL) {
#line 1053
    ccf->shutdown_timeout = (ngx_msec_t )0;
  }
#line 1055
  if (ccf->worker_processes == -1L) {
#line 1055
    ccf->worker_processes = (ngx_int_t )1;
  }
#line 1056
  if (ccf->debug_points == -1L) {
#line 1056
    ccf->debug_points = (ngx_int_t )0;
  }
#line 1060
  if (! ccf->cpu_affinity_auto) {
#line 1060
    if (ccf->cpu_affinity_n) {
#line 1060
      if (ccf->cpu_affinity_n != 1UL) {
#line 1060
        if (ccf->cpu_affinity_n != (ngx_uint_t )ccf->worker_processes) {
#line 1065
          if ((cycle->log)->log_level >= 5UL) {
            {
#line 1065
            ngx_log_error_core((ngx_uint_t )5, cycle->log, 0, "the number of \"worker_processes\" is not equal to the number of \"worker_cpu_affinity\" masks, using last mask for remaining worker processes");
            }
          }
        }
      }
    }
  }
#line 1074
  if (ccf->pid.len == 0UL) {
#line 1075
    ccf->pid.len = sizeof("logs/nginx.pid") - 1UL;
#line 1075
    ccf->pid.data = (u_char *)"logs/nginx.pid";
  }
  {
#line 1078
  tmp = ngx_conf_full_name(cycle, & ccf->pid, (ngx_uint_t )0);
  }
#line 1078
  if (tmp != 0L) {
#line 1079
    return ((char *)((void *)-1));
  }
  {
#line 1082
  ccf->oldpid.len = ccf->pid.len + sizeof(".oldbin");
#line 1084
  tmp___0 = ngx_pnalloc(cycle->pool, ccf->oldpid.len);
#line 1084
  ccf->oldpid.data = (u_char *)tmp___0;
  }
#line 1085
  if ((unsigned long )ccf->oldpid.data == (unsigned long )((void *)0)) {
#line 1086
    return ((char *)((void *)-1));
  }
  {
#line 1089
  tmp___1 = memcpy((void */* __restrict  */)ccf->oldpid.data, (void const   */* __restrict  */)ccf->pid.data,
                   ccf->pid.len);
#line 1089
  memcpy((void */* __restrict  */)((u_char *)tmp___1 + ccf->pid.len), (void const   */* __restrict  */)".oldbin",
         sizeof(".oldbin"));
  }
#line 1095
  if (ccf->user == 4294967295U) {
    {
#line 1095
    tmp___6 = geteuid();
    }
#line 1095
    if (tmp___6 == 0U) {
      {
#line 1099
      tmp___2 = __errno_location();
#line 1099
      *tmp___2 = 0;
#line 1100
      pwd = getpwnam("nobody");
      }
#line 1101
      if ((unsigned long )pwd == (unsigned long )((void *)0)) {
#line 1102
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1102
          tmp___3 = __errno_location();
#line 1102
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___3, "getpwnam(\"nobody\") failed");
          }
        }
#line 1104
        return ((char *)((void *)-1));
      }
      {
#line 1107
      ccf->username = (char *)"nobody";
#line 1108
      ccf->user = pwd->pw_uid;
#line 1110
      tmp___4 = __errno_location();
#line 1110
      *tmp___4 = 0;
#line 1111
      grp = getgrnam("nogroup");
      }
#line 1112
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
#line 1113
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1113
          tmp___5 = __errno_location();
#line 1113
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___5, "getgrnam(\"nogroup\") failed");
          }
        }
#line 1115
        return ((char *)((void *)-1));
      }
#line 1118
      ccf->group = grp->gr_gid;
    }
  }
#line 1122
  if (ccf->lock_file.len == 0UL) {
#line 1123
    ccf->lock_file.len = sizeof("logs/nginx.lock") - 1UL;
#line 1123
    ccf->lock_file.data = (u_char *)"logs/nginx.lock";
  }
  {
#line 1126
  tmp___7 = ngx_conf_full_name(cycle, & ccf->lock_file, (ngx_uint_t )0);
  }
#line 1126
  if (tmp___7 != 0L) {
#line 1127
    return ((char *)((void *)-1));
  }
#line 1133
  lock_file = (cycle->old_cycle)->lock_file;
#line 1135
  if (lock_file.len) {
#line 1136
    (lock_file.len) --;
#line 1138
    if (ccf->lock_file.len != lock_file.len) {
#line 1138
      goto _L;
    } else {
      {
#line 1138
      tmp___8 = strncmp((char const   *)ccf->lock_file.data, (char const   *)lock_file.data,
                        lock_file.len);
      }
#line 1138
      if (tmp___8 != 0) {
        _L: /* CIL Label */ 
#line 1142
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1142
          ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "\"lock_file\" could not be changed, ignored");
          }
        }
      }
    }
    {
#line 1146
    cycle->lock_file.len = lock_file.len + 1UL;
#line 1147
    lock_file.len += sizeof(".accept");
#line 1149
    cycle->lock_file.data = ngx_pstrdup(cycle->pool, & lock_file);
    }
#line 1150
    if ((unsigned long )cycle->lock_file.data == (unsigned long )((void *)0)) {
#line 1151
      return ((char *)((void *)-1));
    }
  } else {
    {
#line 1155
    cycle->lock_file.len = ccf->lock_file.len + 1UL;
#line 1156
    tmp___9 = ngx_pnalloc(cycle->pool, ccf->lock_file.len + sizeof(".accept"));
#line 1156
    cycle->lock_file.data = (u_char *)tmp___9;
    }
#line 1158
    if ((unsigned long )cycle->lock_file.data == (unsigned long )((void *)0)) {
#line 1159
      return ((char *)((void *)-1));
    }
    {
#line 1162
    tmp___10 = memcpy((void */* __restrict  */)cycle->lock_file.data, (void const   */* __restrict  */)ccf->lock_file.data,
                      ccf->lock_file.len);
#line 1162
    memcpy((void */* __restrict  */)((u_char *)tmp___10 + ccf->lock_file.len), (void const   */* __restrict  */)".accept",
           sizeof(".accept"));
    }
  }
#line 1170
  return ((char *)((void *)0));
}
}
#line 1174 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_set_user(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  char *group ;
  struct passwd *pwd ;
  struct group *grp ;
  ngx_str_t *value ;
  __uid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  u_char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 1186
  ccf = (ngx_core_conf_t *)conf;
#line 1193
  if (ccf->user != 4294967295U) {
#line 1194
    return ((char *)"is duplicate");
  }
  {
#line 1197
  tmp = geteuid();
  }
#line 1197
  if (tmp != 0U) {
    {
#line 1198
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "the \"user\" directive makes sense only if the master process runs with super-user privileges, ignored");
    }
#line 1202
    return ((char *)((void *)0));
  }
  {
#line 1205
  value = (ngx_str_t *)(cf->args)->elts;
#line 1207
  ccf->username = (char *)(value + 1)->data;
#line 1209
  tmp___0 = __errno_location();
#line 1209
  *tmp___0 = 0;
#line 1210
  pwd = getpwnam((char const   *)(value + 1)->data);
  }
#line 1211
  if ((unsigned long )pwd == (unsigned long )((void *)0)) {
    {
#line 1212
    tmp___1 = __errno_location();
#line 1212
    ngx_conf_log_error((ngx_uint_t )1, cf, *tmp___1, "getpwnam(\"%s\") failed", (value + 1)->data);
    }
#line 1214
    return ((char *)((void *)-1));
  }
#line 1217
  ccf->user = pwd->pw_uid;
#line 1219
  if ((cf->args)->nelts == 2UL) {
#line 1219
    tmp___2 = (value + 1)->data;
  } else {
#line 1219
    tmp___2 = (value + 2)->data;
  }
  {
#line 1219
  group = (char *)tmp___2;
#line 1221
  tmp___3 = __errno_location();
#line 1221
  *tmp___3 = 0;
#line 1222
  grp = getgrnam((char const   *)group);
  }
#line 1223
  if ((unsigned long )grp == (unsigned long )((void *)0)) {
    {
#line 1224
    tmp___4 = __errno_location();
#line 1224
    ngx_conf_log_error((ngx_uint_t )1, cf, *tmp___4, "getgrnam(\"%s\") failed", group);
    }
#line 1226
    return ((char *)((void *)-1));
  }
#line 1229
  ccf->group = grp->gr_gid;
#line 1231
  return ((char *)((void *)0));
}
}
#line 1237 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_set_env(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  ngx_str_t *value ;
  ngx_str_t *var ;
  ngx_uint_t i ;
  void *tmp ;

  {
  {
#line 1240
  ccf = (ngx_core_conf_t *)conf;
#line 1245
  tmp = ngx_array_push(& ccf->env);
#line 1245
  var = (ngx_str_t *)tmp;
  }
#line 1246
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 1247
    return ((char *)((void *)-1));
  }
#line 1250
  value = (ngx_str_t *)(cf->args)->elts;
#line 1251
  *var = *(value + 1);
#line 1253
  i = (ngx_uint_t )0;
  {
#line 1253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1253
    if (! (i < (value + 1)->len)) {
#line 1253
      goto while_break;
    }
#line 1255
    if ((int )*((value + 1)->data + i) == 61) {
#line 1257
      var->len = i;
#line 1259
      return ((char *)((void *)0));
    }
#line 1253
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  return ((char *)((void *)0));
}
}
#line 1267 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_set_priority(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  ngx_str_t *value ;
  ngx_uint_t n ;
  ngx_uint_t minus ;
  ngx_int_t tmp ;

  {
#line 1270
  ccf = (ngx_core_conf_t *)conf;
#line 1275
  if (ccf->priority != 0) {
#line 1276
    return ((char *)"is duplicate");
  }
#line 1279
  value = (ngx_str_t *)(cf->args)->elts;
#line 1281
  if ((int )*((value + 1)->data + 0) == 45) {
#line 1282
    n = (ngx_uint_t )1;
#line 1283
    minus = (ngx_uint_t )1;
  } else
#line 1285
  if ((int )*((value + 1)->data + 0) == 43) {
#line 1286
    n = (ngx_uint_t )1;
#line 1287
    minus = (ngx_uint_t )0;
  } else {
#line 1290
    n = (ngx_uint_t )0;
#line 1291
    minus = (ngx_uint_t )0;
  }
  {
#line 1294
  tmp = ngx_atoi((value + 1)->data + n, (value + 1)->len - n);
#line 1294
  ccf->priority = (int )tmp;
  }
#line 1295
  if (ccf->priority == -1) {
#line 1296
    return ((char *)"invalid number");
  }
#line 1299
  if (minus) {
#line 1300
    ccf->priority = - ccf->priority;
  }
#line 1303
  return ((char *)((void *)0));
}
}
#line 1307 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_set_cpu_affinity(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  u_char ch ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_cpuset_t *mask ;
  void *tmp ;
  size_t___0 __cpu ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  size_t___0 __cpu___0 ;

  {
#line 1311
  ccf = (ngx_core_conf_t *)conf;
#line 1318
  if (ccf->cpu_affinity) {
#line 1319
    return ((char *)"is duplicate");
  }
  {
#line 1322
  tmp = ngx_palloc(cf->pool, ((cf->args)->nelts - 1UL) * sizeof(ngx_cpuset_t ));
#line 1322
  mask = (ngx_cpuset_t *)tmp;
  }
#line 1323
  if ((unsigned long )mask == (unsigned long )((void *)0)) {
#line 1324
    return ((char *)((void *)-1));
  }
  {
#line 1327
  ccf->cpu_affinity_n = (cf->args)->nelts - 1UL;
#line 1328
  ccf->cpu_affinity = mask;
#line 1330
  value = (ngx_str_t *)(cf->args)->elts;
#line 1332
  tmp___1 = strcmp((char const   *)(value + 1)->data, "auto");
  }
#line 1332
  if (tmp___1 == 0) {
#line 1334
    if ((cf->args)->nelts > 3UL) {
      {
#line 1335
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of arguments in \"worker_cpu_affinity\" directive");
      }
#line 1338
      return ((char *)((void *)-1));
    }
#line 1341
    ccf->cpu_affinity_auto = (ngx_uint_t )1;
    {
#line 1343
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1343
      __builtin_memset((void *)(mask + 0), '\000', (int )sizeof(cpu_set_t ));
      }
#line 1343
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1344
    i = (ngx_uint_t )0;
    {
#line 1344
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1344
      if (ngx_ncpu > 1024L) {
#line 1344
        tmp___0 = (ngx_int_t )1024;
      } else {
#line 1344
        tmp___0 = ngx_ncpu;
      }
#line 1344
      if (! (i < (ngx_uint_t )tmp___0)) {
#line 1344
        goto while_break___0;
      }
#line 1345
      __cpu = i;
#line 1345
      if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 1345
        (mask + 0)->__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
      }
#line 1344
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1348
    n = (ngx_uint_t )2;
  } else {
#line 1351
    n = (ngx_uint_t )1;
  }
  {
#line 1354
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1354
    if (! (n < (cf->args)->nelts)) {
#line 1354
      goto while_break___1;
    }
#line 1356
    if ((value + n)->len > 1024UL) {
      {
#line 1357
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"worker_cpu_affinity\" supports up to %d CPUs only",
                         1024);
      }
#line 1360
      return ((char *)((void *)-1));
    }
#line 1363
    i = (ngx_uint_t )0;
    {
#line 1364
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1364
      __builtin_memset((void *)(mask + (n - 1UL)), '\000', (int )sizeof(cpu_set_t ));
      }
#line 1364
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1366
    p = ((value + n)->data + (value + n)->len) - 1;
    {
#line 1366
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1366
      if (! ((unsigned long )p >= (unsigned long )(value + n)->data)) {
#line 1366
        goto while_break___3;
      }
#line 1370
      ch = *p;
#line 1372
      if ((int )ch == 32) {
#line 1373
        goto __Cont;
      }
#line 1376
      i ++;
#line 1378
      if ((int )ch == 48) {
#line 1379
        goto __Cont;
      }
#line 1382
      if ((int )ch == 49) {
#line 1383
        __cpu___0 = i - 1UL;
#line 1383
        if (__cpu___0 / 8UL < sizeof(cpu_set_t )) {
#line 1383
          (mask + (n - 1UL))->__bits[__cpu___0 / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu___0 % (8UL * sizeof(__cpu_mask ));
        }
#line 1384
        goto __Cont;
      }
      {
#line 1387
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid character \"%c\" in \"worker_cpu_affinity\"",
                         (int )ch);
      }
#line 1390
      return ((char *)((void *)-1));
      __Cont: /* CIL Label */ 
#line 1366
      p --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1354
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1401
  return ((char *)((void *)0));
}
}
#line 1413 "/tmp/nginx-1.13.2/src/core/nginx.c"
static ngx_cpuset_t result  ;
#line 1405 "/tmp/nginx-1.13.2/src/core/nginx.c"
ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_cpuset_t *mask ;
  ngx_core_conf_t *ccf ;
  size_t___0 __cpu ;
  int tmp ;
  ngx_uint_t tmp___0 ;
  size_t___0 __cpu___0 ;

  {
#line 1415
  ccf = (ngx_core_conf_t *)*(ngx_cycle->conf_ctx + ngx_core_module.index);
#line 1418
  if ((unsigned long )ccf->cpu_affinity == (unsigned long )((void *)0)) {
#line 1419
    return ((ngx_cpuset_t *)((void *)0));
  }
#line 1422
  if (ccf->cpu_affinity_auto) {
#line 1423
    mask = ccf->cpu_affinity + (ccf->cpu_affinity_n - 1UL);
#line 1425
    i = (ngx_uint_t )0;
#line 1425
    j = n;
    {
#line 1425
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1427
      __cpu = i % 1024UL;
#line 1427
      if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 1427
        tmp = (*((__cpu_mask const   *)(mask->__bits) + __cpu / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu % (8UL * sizeof(__cpu_mask )))) != 0UL;
      } else {
#line 1427
        tmp = 0;
      }
#line 1427
      if (tmp) {
#line 1427
        tmp___0 = j;
#line 1427
        j --;
#line 1427
        if (tmp___0 == 0UL) {
#line 1428
          goto while_break;
        }
      }
#line 1431
      if (i == 1024UL) {
#line 1431
        if (j == n) {
#line 1433
          return ((ngx_cpuset_t *)((void *)0));
        }
      }
#line 1425
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1439
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1439
      __builtin_memset((void *)(& result), '\000', (int )sizeof(cpu_set_t ));
      }
#line 1439
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1440
    __cpu___0 = i % 1024UL;
#line 1440
    if (__cpu___0 / 8UL < sizeof(cpu_set_t )) {
#line 1440
      result.__bits[__cpu___0 / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu___0 % (8UL * sizeof(__cpu_mask ));
    }
#line 1442
    return (& result);
  }
#line 1445
  if (ccf->cpu_affinity_n > n) {
#line 1446
    return (ccf->cpu_affinity + n);
  }
#line 1449
  return (ccf->cpu_affinity + (ccf->cpu_affinity_n - 1UL));
}
}
#line 1459 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_set_worker_processes(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_str_t *value ;
  ngx_core_conf_t *ccf ;
  int tmp ;

  {
#line 1465
  ccf = (ngx_core_conf_t *)conf;
#line 1467
  if (ccf->worker_processes != -1L) {
#line 1468
    return ((char *)"is duplicate");
  }
  {
#line 1471
  value = (ngx_str_t *)(cf->args)->elts;
#line 1473
  tmp = strcmp((char const   *)(value + 1)->data, "auto");
  }
#line 1473
  if (tmp == 0) {
#line 1474
    ccf->worker_processes = ngx_ncpu;
#line 1475
    return ((char *)((void *)0));
  }
  {
#line 1478
  ccf->worker_processes = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 1480
  if (ccf->worker_processes == -1L) {
#line 1481
    return ((char *)"invalid value");
  }
#line 1484
  return ((char *)((void *)0));
}
}
#line 1488 "/tmp/nginx-1.13.2/src/core/nginx.c"
static char *ngx_load_module(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  void *handle ;
  char **names ;
  char **order ;
  ngx_str_t *value ;
  ngx_str_t file ;
  ngx_uint_t i ;
  ngx_module_t *module ;
  ngx_module_t **modules ;
  ngx_pool_cleanup_t *cln ;
  ngx_int_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;

  {
#line 1499
  if ((cf->cycle)->modules_used) {
#line 1500
    return ((char *)"is specified too late");
  }
  {
#line 1503
  value = (ngx_str_t *)(cf->args)->elts;
#line 1505
  file = *(value + 1);
#line 1507
  tmp = ngx_conf_full_name(cf->cycle, & file, (ngx_uint_t )0);
  }
#line 1507
  if (tmp != 0L) {
#line 1508
    return ((char *)((void *)-1));
  }
  {
#line 1511
  cln = ngx_pool_cleanup_add((cf->cycle)->pool, (size_t___0 )0);
  }
#line 1512
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 1513
    return ((char *)((void *)-1));
  }
  {
#line 1516
  handle = dlopen((char const   *)((char *)file.data), 258);
  }
#line 1517
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
    {
#line 1518
    tmp___0 = ngx_dlerror();
#line 1518
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "dlopen() \"%s\" failed (%s)", file.data,
                       tmp___0);
    }
#line 1521
    return ((char *)((void *)-1));
  }
  {
#line 1524
  cln->handler = & ngx_unload_module;
#line 1525
  cln->data = handle;
#line 1527
  tmp___1 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)"ngx_modules");
#line 1527
  modules = (ngx_module_t **)tmp___1;
  }
#line 1528
  if ((unsigned long )modules == (unsigned long )((void *)0)) {
    {
#line 1529
    tmp___2 = ngx_dlerror();
#line 1529
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "dlsym() \"%V\", \"%s\" failed (%s)",
                       value + 1, "ngx_modules", tmp___2);
    }
#line 1532
    return ((char *)((void *)-1));
  }
  {
#line 1535
  tmp___3 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)"ngx_module_names");
#line 1535
  names = (char **)tmp___3;
  }
#line 1536
  if ((unsigned long )names == (unsigned long )((void *)0)) {
    {
#line 1537
    tmp___4 = ngx_dlerror();
#line 1537
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "dlsym() \"%V\", \"%s\" failed (%s)",
                       value + 1, "ngx_module_names", tmp___4);
    }
#line 1540
    return ((char *)((void *)-1));
  }
  {
#line 1543
  tmp___5 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)"ngx_module_order");
#line 1543
  order = (char **)tmp___5;
#line 1545
  i = (ngx_uint_t )0;
  }
  {
#line 1545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1545
    if (! *(modules + i)) {
#line 1545
      goto while_break;
    }
    {
#line 1546
    module = *(modules + i);
#line 1547
    module->name = *(names + i);
#line 1549
    tmp___6 = ngx_add_module(cf, & file, module, order);
    }
#line 1549
    if (tmp___6 != 0L) {
#line 1550
      return ((char *)((void *)-1));
    }
#line 1545
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1557
  return ((char *)((void *)0));
}
}
#line 1572 "/tmp/nginx-1.13.2/src/core/nginx.c"
static void ngx_unload_module(void *data ) 
{ 
  void *handle ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1575
  handle = data;
#line 1577
  tmp___0 = dlclose(handle);
  }
#line 1577
  if (tmp___0 != 0) {
#line 1578
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 1578
      tmp = ngx_dlerror();
#line 1578
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "dlclose() failed (%s)",
                         tmp);
      }
    }
  }
#line 1581
  return;
}
}
