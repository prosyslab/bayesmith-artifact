/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 42 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/minitiff.h"
struct minitiff_info {
   void (*error_handler)(char const   *msg ) ;
   void (*warning_handler)(char const   *msg ) ;
   int byte_order ;
   size_t width ;
   size_t height ;
   unsigned int bits_per_sample ;
   unsigned int compression ;
   unsigned int photometric ;
   size_t strip_offsets_count ;
   long *strip_offsets ;
   unsigned int samples_per_pixel ;
   unsigned int rows_per_strip ;
};
#line 54 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
struct minitiff_get_struct {
   unsigned int (*get_ushort)(unsigned char const   *buf_ptr ) ;
   unsigned long (*get_ulong)(unsigned char const   *buf_ptr ) ;
};
#line 57 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmio.h"
struct pnm_struct {
   unsigned int format ;
   unsigned int depth ;
   unsigned int width ;
   unsigned int height ;
   unsigned int maxval ;
};
#line 57 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmio.h"
typedef struct pnm_struct pnm_struct;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 55 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.h"
struct GIFScreen {
   unsigned int Width ;
   unsigned int Height ;
   unsigned int GlobalColorFlag ;
   unsigned int ColorResolution ;
   unsigned int SortFlag ;
   unsigned int GlobalNumColors ;
   unsigned int Background ;
   unsigned int PixelAspectRatio ;
   unsigned char GlobalColorTable[768] ;
};
#line 71 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.h"
struct GIFImage {
   struct GIFScreen *Screen ;
   unsigned int LeftPos ;
   unsigned int TopPos ;
   unsigned int Width ;
   unsigned int Height ;
   unsigned int LocalColorFlag ;
   unsigned int InterlaceFlag ;
   unsigned int SortFlag ;
   unsigned int LocalNumColors ;
   unsigned char LocalColorTable[768] ;
   unsigned char **Rows ;
};
#line 89 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.h"
struct GIFExtension {
   struct GIFScreen *Screen ;
   unsigned char *Buffer ;
   unsigned int BufferSize ;
   unsigned char Label ;
};
#line 100 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.h"
struct GIFGraphicCtlExt {
   unsigned int DisposalMethod ;
   unsigned int InputFlag ;
   unsigned int TransparentFlag ;
   unsigned int DelayTime ;
   unsigned int Transparent ;
};
#line 370 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef unsigned int uInt;
#line 371 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef unsigned long uLong;
#line 386 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef void *voidpf;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 368 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef unsigned char Byte;
#line 377 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef Byte Bytef;
#line 382 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef uLong uLongf;
#line 101 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
struct internal_state ;
#line 103 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
struct z_stream_s {
   Bytef const   *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char const   *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 103 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
typedef struct z_stream_s z_stream;
#line 124 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
typedef z_stream *z_streamp;
#line 1760 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
struct internal_state {
   int dummy ;
};
#line 379 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef char charf;
#line 380 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef int intf;
#line 103 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
struct z_stream_s___0 {
   Bytef const   *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char const   *msg ;
   struct internal_state___0 *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 103 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
typedef struct z_stream_s___0 z_stream___0;
#line 124 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
typedef z_stream___0 *z_streamp___0;
#line 130 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
struct gz_header_s {
   int text ;
   uLong time ;
   int xflags ;
   int os ;
   Bytef *extra ;
   uInt extra_len ;
   uInt extra_max ;
   Bytef *name ;
   uInt name_max ;
   Bytef *comment ;
   uInt comm_max ;
   int hcrc ;
   int done ;
};
#line 130 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
typedef struct gz_header_s gz_header;
#line 147 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
typedef gz_header *gz_headerp;
#line 41 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.h"
typedef unsigned char uch;
#line 42 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.h"
typedef uch uchf;
#line 43 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.h"
typedef unsigned short ush;
#line 44 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.h"
typedef ush ushf;
#line 45 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.h"
typedef unsigned long ulg;
#line 65 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
union __anonunion_fc_152553610 {
   ush freq ;
   ush code ;
};
#line 65 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
union __anonunion_dl_152553611 {
   ush dad ;
   ush len ;
};
#line 65 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
struct ct_data_s {
   union __anonunion_fc_152553610 fc ;
   union __anonunion_dl_152553611 dl ;
};
#line 65 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef struct ct_data_s ct_data;
#line 81
struct static_tree_desc_s ;
#line 81 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef struct static_tree_desc_s static_tree_desc;
#line 83 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
struct tree_desc_s {
   ct_data *dyn_tree ;
   int max_code ;
   static_tree_desc *stat_desc ;
};
#line 83 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef struct tree_desc_s tree_desc;
#line 89 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef ush Pos;
#line 90 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef Pos Posf;
#line 91 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef unsigned int IPos;
#line 97 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
struct internal_state___0 {
   z_streamp___0 strm ;
   int status ;
   Bytef *pending_buf ;
   ulg pending_buf_size ;
   Bytef *pending_out ;
   uInt pending ;
   int wrap ;
   gz_headerp gzhead ;
   uInt gzindex ;
   Byte method ;
   int last_flush ;
   uInt w_size ;
   uInt w_bits ;
   uInt w_mask ;
   Bytef *window ;
   ulg window_size ;
   Posf *prev ;
   Posf *head ;
   uInt ins_h ;
   uInt hash_size ;
   uInt hash_bits ;
   uInt hash_mask ;
   uInt hash_shift ;
   long block_start ;
   uInt match_length ;
   IPos prev_match ;
   int match_available ;
   uInt strstart ;
   uInt match_start ;
   uInt lookahead ;
   uInt prev_length ;
   uInt max_chain_length ;
   uInt max_lazy_match ;
   int level ;
   int strategy ;
   uInt good_match ;
   int nice_match ;
   struct ct_data_s dyn_ltree[573] ;
   struct ct_data_s dyn_dtree[61] ;
   struct ct_data_s bl_tree[39] ;
   struct tree_desc_s l_desc ;
   struct tree_desc_s d_desc ;
   struct tree_desc_s bl_desc ;
   ush bl_count[16] ;
   int heap[573] ;
   int heap_len ;
   int heap_max ;
   uch depth[573] ;
   uchf *l_buf ;
   uInt lit_bufsize ;
   uInt last_lit ;
   ushf *d_buf ;
   ulg opt_len ;
   ulg static_len ;
   uInt matches ;
   uInt insert ;
   ush bi_buf ;
   int bi_valid ;
   ulg high_water ;
};
#line 97 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef struct internal_state___0 deflate_state;
#line 117 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
struct static_tree_desc_s {
   ct_data const   *static_tree ;
   intf const   *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
};
#line 24 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.h"
struct __anonstruct_code_1002866527 {
   unsigned char op ;
   unsigned char bits ;
   unsigned short val ;
};
#line 24 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.h"
typedef struct __anonstruct_code_1002866527 code;
#line 54
enum __anonenum_codetype_576538390 {
    CODES = 0,
    LENS = 1,
    DISTS = 2
} ;
#line 54 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.h"
typedef enum __anonenum_codetype_576538390 codetype;
#line 20 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.h"
enum __anonenum_inflate_mode_1063025839 {
    HEAD = 0,
    FLAGS = 1,
    TIME = 2,
    OS = 3,
    EXLEN = 4,
    EXTRA = 5,
    NAME = 6,
    COMMENT = 7,
    HCRC = 8,
    DICTID = 9,
    DICT = 10,
    TYPE = 11,
    TYPEDO = 12,
    STORED = 13,
    COPY_ = 14,
    COPY = 15,
    TABLE = 16,
    LENLENS = 17,
    CODELENS = 18,
    LEN_ = 19,
    LEN = 20,
    LENEXT = 21,
    DIST = 22,
    DISTEXT = 23,
    MATCH = 24,
    LIT = 25,
    CHECK = 26,
    LENGTH = 27,
    DONE = 28,
    BAD = 29,
    MEM = 30,
    SYNC = 31
} ;
#line 20 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.h"
typedef enum __anonenum_inflate_mode_1063025839 inflate_mode;
#line 81 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.h"
struct inflate_state {
   inflate_mode mode ;
   int last ;
   int wrap ;
   int havedict ;
   int flags ;
   unsigned int dmax ;
   unsigned long check ;
   unsigned long total ;
   gz_headerp head ;
   unsigned int wbits ;
   unsigned int wsize ;
   unsigned int whave ;
   unsigned int wnext ;
   unsigned char *window ;
   unsigned long hold ;
   unsigned int bits ;
   unsigned int length ;
   unsigned int offset ;
   unsigned int extra ;
   code const   *lencode ;
   code const   *distcode ;
   unsigned int lenbits ;
   unsigned int distbits ;
   unsigned int ncode ;
   unsigned int nlen ;
   unsigned int ndist ;
   unsigned int have ;
   code *next ;
   unsigned short lens[320] ;
   unsigned short work[288] ;
   code codes[1444] ;
   int sane ;
   int back ;
   unsigned int was ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 64 "/usr/include/stdio.h"
typedef __off64_t off64_t;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 385 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef void const   *voidpc;
#line 1242 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
struct gzFile_s ;
#line 1242 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1688 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off64_t pos ;
};
#line 161 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzguts.h"
struct __anonstruct_gz_state_943293388 {
   struct gzFile_s x ;
   int mode ;
   int fd ;
   char *path ;
   unsigned int size ;
   unsigned int want ;
   unsigned char *in ;
   unsigned char *out ;
   int direct ;
   int how ;
   off64_t start ;
   int eof ;
   int past ;
   int level ;
   int strategy ;
   off64_t skip ;
   int seek ;
   int err ;
   char *msg ;
   z_stream strm ;
};
#line 161 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzguts.h"
typedef struct __anonstruct_gz_state_943293388 gz_state;
#line 193 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzguts.h"
typedef gz_state *gz_statep;
#line 387 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef void *voidp;
#line 81 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef struct static_tree_desc_s___0 static_tree_desc___0;
#line 83 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
struct tree_desc_s___0 {
   ct_data *dyn_tree ;
   int max_code ;
   static_tree_desc___0 *stat_desc ;
};
#line 97 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
struct internal_state___1 {
   z_streamp___0 strm ;
   int status ;
   Bytef *pending_buf ;
   ulg pending_buf_size ;
   Bytef *pending_out ;
   uInt pending ;
   int wrap ;
   gz_headerp gzhead ;
   uInt gzindex ;
   Byte method ;
   int last_flush ;
   uInt w_size ;
   uInt w_bits ;
   uInt w_mask ;
   Bytef *window ;
   ulg window_size ;
   Posf *prev ;
   Posf *head ;
   uInt ins_h ;
   uInt hash_size ;
   uInt hash_bits ;
   uInt hash_mask ;
   uInt hash_shift ;
   long block_start ;
   uInt match_length ;
   IPos prev_match ;
   int match_available ;
   uInt strstart ;
   uInt match_start ;
   uInt lookahead ;
   uInt prev_length ;
   uInt max_chain_length ;
   uInt max_lazy_match ;
   int level ;
   int strategy ;
   uInt good_match ;
   int nice_match ;
   struct ct_data_s dyn_ltree[573] ;
   struct ct_data_s dyn_dtree[61] ;
   struct ct_data_s bl_tree[39] ;
   struct tree_desc_s___0 l_desc ;
   struct tree_desc_s___0 d_desc ;
   struct tree_desc_s___0 bl_desc ;
   ush bl_count[16] ;
   int heap[573] ;
   int heap_len ;
   int heap_max ;
   uch depth[573] ;
   uchf *l_buf ;
   uInt lit_bufsize ;
   uInt last_lit ;
   ushf *d_buf ;
   ulg opt_len ;
   ulg static_len ;
   uInt matches ;
   uInt insert ;
   ush bi_buf ;
   int bi_valid ;
   ulg high_water ;
};
#line 97 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
typedef struct internal_state___1 deflate_state___0;
#line 66 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
enum __anonenum_block_state_307922230 {
    need_more = 0,
    block_done = 1,
    finish_started = 2,
    finish_done = 3
} ;
#line 66 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
typedef enum __anonenum_block_state_307922230 block_state;
#line 117 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
struct config_s {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
   block_state (*func)(deflate_state___0 *s , int flush ) ;
};
#line 117 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
typedef struct config_s config;
#line 155 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
struct static_tree_desc_s___0 {
   int dummy ;
};
#line 406 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zconf.h"
typedef unsigned int z_crc_t;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 481 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef unsigned char png_byte;
#line 497 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef unsigned short png_uint_16;
#line 503 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef int png_int_32;
#line 511 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef unsigned int png_uint_32;
#line 521 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef size_t png_size_t;
#line 556 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_size_t png_alloc_size_t;
#line 573 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 576 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef void *png_voidp;
#line 578 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_byte *png_bytep;
#line 579 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_byte const   *png_const_bytep;
#line 585 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_uint_16 const   *png_const_uint_16p;
#line 588 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef char *png_charp;
#line 589 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef char const   *png_const_charp;
#line 444 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
struct png_struct_def ;
#line 444 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef struct png_struct_def png_struct;
#line 446 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_struct *png_structp;
#line 474 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_struct * __restrict  png_structrp;
#line 475 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_struct const   * __restrict  png_const_structrp;
#line 483 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 483 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef struct png_color_struct png_color;
#line 489 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_color *png_colorp;
#line 490 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_color const   *png_const_colorp;
#line 493 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 493 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef struct png_color_16_struct png_color_16;
#line 502 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_color_16 const   *png_const_color_16p;
#line 505 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 505 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef struct png_color_8_struct png_color_8;
#line 514 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_color_8 const   *png_const_color_8p;
#line 627 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   png_size_t size ;
   png_byte location ;
};
#line 627 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 760 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   png_size_t rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 760 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef struct png_row_info_struct png_row_info;
#line 770 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_row_info *png_row_infop;
#line 61 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngstruct.h"
struct png_compression_buffer {
   struct png_compression_buffer *next ;
   png_byte output[1] ;
};
#line 61 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngstruct.h"
typedef struct png_compression_buffer png_compression_buffer;
#line 61 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngstruct.h"
typedef struct png_compression_buffer *png_compression_bufferp;
#line 143 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngstruct.h"
struct png_struct_def {
   void (*error_fn)(png_structp  , png_const_charp  ) ;
   void (*warning_fn)(png_structp  , png_const_charp  ) ;
   png_voidp error_ptr ;
   void (*write_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   void (*read_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   png_voidp io_ptr ;
   png_uint_32 mode ;
   png_uint_32 flags ;
   png_uint_32 transformations ;
   png_uint_32 zowner ;
   z_stream zstream ;
   png_compression_bufferp zbuffer_list ;
   uInt zbuffer_size ;
   int zlib_level ;
   int zlib_method ;
   int zlib_window_bits ;
   int zlib_mem_level ;
   int zlib_strategy ;
   int zlib_set_level ;
   int zlib_set_method ;
   int zlib_set_window_bits ;
   int zlib_set_mem_level ;
   int zlib_set_strategy ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 num_rows ;
   png_uint_32 usr_width ;
   png_size_t rowbytes ;
   png_uint_32 iwidth ;
   png_uint_32 row_number ;
   png_uint_32 chunk_name ;
   png_bytep prev_row ;
   png_bytep row_buf ;
   png_bytep try_row ;
   png_bytep tst_row ;
   png_size_t info_rowbytes ;
   png_uint_32 idat_size ;
   png_uint_32 crc ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   int num_palette_max ;
   png_uint_16 num_trans ;
   png_byte compression ;
   png_byte filter ;
   png_byte interlaced ;
   png_byte pass ;
   png_byte do_filter ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte usr_bit_depth ;
   png_byte pixel_depth ;
   png_byte channels ;
   png_byte usr_channels ;
   png_byte sig_bytes ;
   png_byte maximum_pixel_depth ;
   png_byte transformed_pixel_depth ;
   png_byte background_gamma_type ;
   png_fixed_point background_gamma ;
   png_color_16 background ;
   void (*output_flush_fn)(png_structp  ) ;
   png_uint_32 flush_dist ;
   png_uint_32 flush_rows ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   void (*read_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*write_row_fn)(png_structp  , png_uint_32  , int  ) ;
   png_uint_32 free_me ;
   int unknown_default ;
   unsigned int num_chunk_list ;
   png_bytep chunk_list ;
   png_bytep big_row_buf ;
   png_byte compression_type ;
   png_uint_32 user_width_max ;
   png_uint_32 user_height_max ;
   png_uint_32 user_chunk_cache_max ;
   png_alloc_size_t user_chunk_malloc_max ;
   png_unknown_chunk unknown_chunk ;
   png_size_t old_big_row_buf_size ;
   png_bytep read_buffer ;
   png_alloc_size_t read_buffer_size ;
   uInt IDAT_read_size ;
   png_uint_32 io_state ;
   png_bytep big_prev_row ;
   void (*read_filter[4])(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) ;
};
#line 584 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 605 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_byte **png_bytepp;
#line 447 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_struct **png_structpp;
#line 458
struct png_info_def ;
#line 458 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef struct png_info_def png_info;
#line 461 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_info **png_infopp;
#line 476 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_info * __restrict  png_inforp;
#line 477 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_info const   * __restrict  png_const_inforp;
#line 643 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 644 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_unknown_chunk const   *png_const_unknown_chunkp;
#line 55 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pnginfo.h"
struct png_info_def {
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 valid ;
   png_size_t rowbytes ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte bit_depth ;
   png_byte color_type ;
   png_byte compression_type ;
   png_byte filter_type ;
   png_byte interlace_type ;
   png_byte channels ;
   png_byte pixel_depth ;
   png_byte spare_byte ;
   png_byte signature[8] ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   png_color_16 background ;
   png_uint_16p hist ;
   png_uint_32 free_me ;
   png_unknown_chunkp unknown_chunks ;
   int unknown_chunks_num ;
   png_bytepp row_pointers ;
};
#line 596 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef FILE *png_FILE_p;
#line 577 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef void const   *png_const_voidp;
#line 580 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_uint_32 *png_uint_32p;
#line 581 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngconf.h"
typedef png_uint_32 const   *png_const_uint_32p;
#line 459 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_info *png_infop;
#line 445 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_struct const   *png_const_structp;
#line 460 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_info const   *png_const_infop;
#line 501 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_color_16 *png_color_16p;
#line 513 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_color_8 *png_color_8p;
#line 645 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
typedef png_unknown_chunk **png_unknown_chunkpp;
#line 610 "../libpng/pngconf.h"
typedef char const   **png_const_charpp;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_290024058 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_290024058 __mbstate_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/_G_config.h"
struct __anonstruct__G_fpos_t_800156284 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/_G_config.h"
typedef struct __anonstruct__G_fpos_t_800156284 _G_fpos_t;
#line 78 "/usr/include/stdio.h"
typedef _G_fpos_t fpos_t;
#line 30 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxutil.h"
typedef png_alloc_size_t pngx_alloc_size_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 40 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.h"
typedef long osys_foffset_t;
#line 49 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.h"
typedef unsigned long osys_fsize_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 28 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.h"
typedef unsigned long long opng_ullong_t;
#line 78 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.h"
struct opng_ulratio {
   unsigned long num ;
   unsigned long denom ;
};
#line 98 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.h"
struct opng_ullratio {
   opng_ullong_t num ;
   opng_ullong_t denom ;
};
#line 21 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.c"
typedef opng_ullong_t opng_ulongest_impl_t;
#line 26 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.h"
typedef unsigned int opng_bitset_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 25 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.h"
struct opng_options {
   int backup ;
   int clobber ;
   int debug ;
   int fix ;
   int force ;
   int full ;
   int preserve ;
   int quiet ;
   int simulate ;
   int verbose ;
   char const   *out_name ;
   char const   *dir_name ;
   char const   *log_name ;
   int interlace ;
   int nb ;
   int nc ;
   int np ;
   int nz ;
   int optim_level ;
   opng_bitset_t compr_level_set ;
   opng_bitset_t mem_level_set ;
   opng_bitset_t strategy_set ;
   opng_bitset_t filter_set ;
   int window_bits ;
   int snip ;
   int strip_all ;
};
#line 61 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.h"
struct opng_ui {
   void (*printf_fn)(char const   *fmt  , ...) ;
   void (*print_cntrl_fn)(int cntrl_code ) ;
   void (*progress_fn)(unsigned long current_step , unsigned long total_steps ) ;
   void (*panic_fn)(char const   *msg ) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 34 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct __anonstruct_v_1022237947 {
   char const   *etmp ;
};
#line 34 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct exception_context {
   jmp_buf *penv ;
   int caught ;
   struct __anonstruct_v_1022237947  volatile  v ;
};
#line 41 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct opng_preset {
   char const   *compr_level ;
   char const   *mem_level ;
   char const   *strategy ;
   char const   *filter ;
};
#line 111 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct opng_engine_struct {
   int started ;
};
#line 119 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct opng_process_struct {
   unsigned int status ;
   int num_iterations ;
   osys_foffset_t in_datastream_offset ;
   osys_fsize_t in_file_size ;
   osys_fsize_t out_file_size ;
   osys_fsize_t in_idat_size ;
   osys_fsize_t out_idat_size ;
   osys_fsize_t best_idat_size ;
   osys_fsize_t max_idat_size ;
   png_uint_32 in_plte_trns_size ;
   png_uint_32 out_plte_trns_size ;
   png_uint_32 reductions ;
   opng_bitset_t compr_level_set ;
   opng_bitset_t mem_level_set ;
   opng_bitset_t strategy_set ;
   opng_bitset_t filter_set ;
   int best_compr_level ;
   int best_mem_level ;
   int best_strategy ;
   int best_filter ;
};
#line 142 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct opng_summary_struct {
   unsigned int file_count ;
   unsigned int err_count ;
   unsigned int fix_count ;
   unsigned int snip_count ;
};
#line 153 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct opng_image_struct {
   png_uint_32 width ;
   png_uint_32 height ;
   int bit_depth ;
   int color_type ;
   int compression_type ;
   int filter_type ;
   int interlace_type ;
   png_bytepp row_pointers ;
   png_colorp palette ;
   int num_palette ;
   png_color_16p background_ptr ;
   png_color_16 background ;
   png_uint_16p hist ;
   png_color_8p sig_bit_ptr ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   int num_trans ;
   png_color_16p trans_color_ptr ;
   png_color_16 trans_color ;
   png_unknown_chunkp unknowns ;
   int num_unknowns ;
};
#line 124 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
enum __anonenum_operation_981116399 {
    OP_RUN = 0,
    OP_SHOW_HELP = 1,
    OP_SHOW_VERSION = 2
} ;
#line 131 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
struct __anonstruct_local_options_1002814925 {
   int help ;
   int version ;
};
#line 646 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 69 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/minitiff.h"
void minitiff_read_info(struct minitiff_info *tiff_ptr , FILE *fp ) ;
#line 70
void minitiff_read_row(struct minitiff_info *tiff_ptr , unsigned char *row_ptr , size_t row_index ,
                       FILE *fp ) ;
#line 87
void minitiff_error(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) ;
#line 88
void minitiff_warning(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) ;
#line 95
char const   minitiff_sig_m[4] ;
#line 96
char const   minitiff_sig_i[4] ;
#line 23 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_err_read  =    "Error reading TIFF file";
#line 26 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_err_notiff  =    "Not a TIFF file";
#line 29 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_err_invalid  =    "Invalid TIFF file";
#line 32 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_err_unsupported  =    "Unsupported data format in TIFF file";
#line 35 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_err_compr  =    "Unsupported compression in TIFF file";
#line 38 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_err_memory  =    "Out of memory";
#line 41 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_warn_tag  =    "Unrecognized tag(s) in TIFF file";
#line 44 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_warn_metadata  =    "Unrecognized EXIF/IPTC/XMP metadata in TIFF file";
#line 47 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static char const   *tiff_warn_multiple  =    "Selected first image from multi-image TIFF file";
#line 61 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static unsigned int get_ushort_m(unsigned char const   *buf_ptr ) 
{ 


  {
#line 64
  return (((unsigned int )*(buf_ptr + 0) << 8) + (unsigned int )*(buf_ptr + 1));
}
}
#line 68 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static unsigned int get_ushort_i(unsigned char const   *buf_ptr ) 
{ 


  {
#line 71
  return ((unsigned int )*(buf_ptr + 0) + ((unsigned int )*(buf_ptr + 1) << 8));
}
}
#line 75 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static unsigned long get_ulong_m(unsigned char const   *buf_ptr ) 
{ 


  {
#line 78
  return (((((unsigned long )*(buf_ptr + 0) << 24) + ((unsigned long )*(buf_ptr + 1) << 16)) + ((unsigned long )*(buf_ptr + 2) << 8)) + (unsigned long )*(buf_ptr + 3));
}
}
#line 84 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static unsigned long get_ulong_i(unsigned char const   *buf_ptr ) 
{ 


  {
#line 87
  return ((((unsigned long )*(buf_ptr + 0) + ((unsigned long )*(buf_ptr + 1) << 8)) + ((unsigned long )*(buf_ptr + 2) << 16)) + ((unsigned long )*(buf_ptr + 3) << 24));
}
}
#line 93 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static unsigned long get_ulong_value(struct minitiff_get_struct *get_ptr , int tag_type ,
                                     unsigned char const   *buf_ptr ) 
{ 
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 99
  if (tag_type == 1) {
#line 99
    goto case_1;
  }
#line 101
  if (tag_type == 3) {
#line 101
    goto case_3;
  }
#line 103
  if (tag_type == 4) {
#line 103
    goto case_4;
  }
#line 105
  goto switch_default;
  case_1: /* CIL Label */ 
#line 100
  return ((unsigned long )*(buf_ptr + 0));
  case_3: /* CIL Label */ 
  {
#line 102
  tmp = (*(get_ptr->get_ushort))(buf_ptr);
  }
#line 102
  return ((unsigned long )tmp);
  case_4: /* CIL Label */ 
  {
#line 104
  tmp___0 = (*(get_ptr->get_ulong))(buf_ptr);
  }
#line 104
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 106
  return (0xffffffffffffffffUL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 110 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
static size_t read_ulong_values(struct minitiff_get_struct *get_ptr , int tag_type ,
                                unsigned long *values , size_t count , FILE *fp ) 
{ 
  unsigned char buf[4] ;
  size_t value_size ;
  size_t i ;
  size_t tmp ;

  {
#line 118
  if (tag_type == 1) {
#line 119
    value_size = (size_t )1;
  } else
#line 120
  if (tag_type == 3) {
#line 121
    value_size = (size_t )2;
  } else
#line 122
  if (tag_type == 4) {
#line 123
    value_size = (size_t )4;
  } else {
#line 125
    return ((size_t )0);
  }
#line 127
  i = (size_t )0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < count)) {
#line 127
      goto while_break;
    }
    {
#line 129
    tmp = fread((void */* __restrict  */)(buf), value_size, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 129
    if (tmp != 1UL) {
#line 130
      goto while_break;
    }
    {
#line 131
    *(values + i) = get_ulong_value(get_ptr, tag_type, (unsigned char const   *)(buf));
#line 127
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (i);
}
}
#line 141 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
void minitiff_read_info(struct minitiff_info *tiff_ptr , FILE *fp ) 
{ 
  struct minitiff_get_struct getter ;
  unsigned char buf[12] ;
  unsigned char *vbuf ;
  long dir_offset ;
  unsigned int dir_size ;
  unsigned int i ;
  unsigned int tag_id ;
  unsigned int tag_type ;
  size_t count ;
  size_t bits_per_sample_count ;
  unsigned int bits_per_sample_tag_type ;
  unsigned int strip_offsets_tag_type ;
  long bits_per_sample_offset ;
  long strip_offsets_offset ;
  int unknown_tag_found ;
  int unknown_metadata_found ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  void *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  unsigned long tmp___19 ;
  unsigned long tmp___20 ;
  size_t tmp___21 ;
  unsigned long tmp___22 ;
  unsigned long values[4] ;
  int tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;

  {
  {
#line 146
  vbuf = buf + 8;
#line 157
  tmp = fread((void */* __restrict  */)(buf), (size_t )8, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 157
  if (tmp != 1UL) {
#line 158
    goto err_read;
  }
  {
#line 159
  tmp___1 = memcmp((void const   *)(buf), (void const   *)(minitiff_sig_m), (size_t )4);
  }
#line 159
  if (tmp___1 == 0) {
#line 161
    tiff_ptr->byte_order = 'M';
#line 162
    getter.get_ushort = & get_ushort_m;
#line 163
    getter.get_ulong = & get_ulong_m;
  } else {
    {
#line 165
    tmp___0 = memcmp((void const   *)(buf), (void const   *)(minitiff_sig_i), (size_t )4);
    }
#line 165
    if (tmp___0 == 0) {
#line 167
      tiff_ptr->byte_order = 'I';
#line 168
      getter.get_ushort = & get_ushort_i;
#line 169
      getter.get_ulong = & get_ulong_i;
    } else {
      {
#line 173
      minitiff_error(tiff_ptr, tiff_err_notiff);
      }
#line 174
      return;
    }
  }
  {
#line 176
  bits_per_sample_count = (size_t )0;
#line 177
  strip_offsets_tag_type = 0U;
#line 177
  bits_per_sample_tag_type = strip_offsets_tag_type;
#line 178
  strip_offsets_offset = 0L;
#line 178
  bits_per_sample_offset = strip_offsets_offset;
#line 179
  tmp___2 = (*(getter.get_ulong))((unsigned char const   *)(buf + 4));
#line 179
  dir_offset = (long )tmp___2;
  }
#line 180
  if (dir_offset < 8L) {
#line 181
    goto err_invalid;
  }
  {
#line 182
  tmp___3 = fseek(fp, dir_offset, 0);
  }
#line 182
  if (tmp___3 != 0) {
#line 183
    goto err_read;
  }
  {
#line 186
  tmp___4 = fread((void */* __restrict  */)(buf), (size_t )2, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 186
  if (tmp___4 != 1UL) {
#line 187
    goto err_read;
  }
  {
#line 188
  dir_size = (*(getter.get_ushort))((unsigned char const   *)(buf));
#line 189
  unknown_metadata_found = 0;
#line 189
  unknown_tag_found = unknown_metadata_found;
#line 190
  i = 0U;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < dir_size)) {
#line 190
      goto while_break;
    }
    {
#line 192
    tmp___5 = fread((void */* __restrict  */)(buf), (size_t )12, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 192
    if (tmp___5 != 1UL) {
#line 193
      goto err_read;
    }
    {
#line 194
    tag_id = (*(getter.get_ushort))((unsigned char const   *)(buf));
#line 195
    tag_type = (*(getter.get_ushort))((unsigned char const   *)(buf + 2));
#line 196
    tmp___6 = (*(getter.get_ulong))((unsigned char const   *)(buf + 4));
#line 196
    count = tmp___6;
    }
#line 197
    if (count == 0UL) {
#line 198
      goto err_unsupported;
    }
    {
#line 201
    if (tag_id == 254U) {
#line 201
      goto case_254;
    }
#line 206
    if (tag_id == 256U) {
#line 206
      goto case_256;
    }
#line 211
    if (tag_id == 257U) {
#line 211
      goto case_257;
    }
#line 216
    if (tag_id == 258U) {
#line 216
      goto case_258;
    }
#line 227
    if (tag_id == 259U) {
#line 227
      goto case_259;
    }
#line 233
    if (tag_id == 262U) {
#line 233
      goto case_262;
    }
#line 239
    if (tag_id == 273U) {
#line 239
      goto case_273;
    }
#line 257
    if (tag_id == 274U) {
#line 257
      goto case_274;
    }
#line 262
    if (tag_id == 277U) {
#line 262
      goto case_277;
    }
#line 268
    if (tag_id == 278U) {
#line 268
      goto case_278;
    }
#line 274
    if (tag_id == 279U) {
#line 274
      goto case_279;
    }
#line 278
    if (tag_id == 317U) {
#line 278
      goto case_317;
    }
#line 278
    if (tag_id == 284U) {
#line 278
      goto case_317;
    }
#line 298
    if (tag_id == 316U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 315U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 306U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 305U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 297U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 285U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 296U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 287U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 286U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 283U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 282U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 281U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 280U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 272U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 271U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 270U) {
#line 298
      goto case_316;
    }
#line 298
    if (tag_id == 269U) {
#line 298
      goto case_316;
    }
#line 306
    if (tag_id == 50341U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 40965U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 34853U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 34665U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 33723U) {
#line 306
      goto case_50341;
    }
#line 306
    if (tag_id == 700U) {
#line 306
      goto case_50341;
    }
#line 313
    goto switch_default;
    case_254: /* CIL Label */ 
#line 202
    if (count != 1UL) {
#line 204
      goto err_unsupported;
    } else {
      {
#line 202
      tmp___7 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 202
      if ((tmp___7 & 0xfffffffffffffffdUL) != 0UL) {
#line 204
        goto err_unsupported;
      }
    }
#line 205
    goto switch_break;
    case_256: /* CIL Label */ 
#line 207
    if (count != 1UL) {
#line 208
      goto err_unsupported;
    }
    {
#line 209
    tmp___8 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 209
    tiff_ptr->width = tmp___8;
    }
#line 210
    goto switch_break;
    case_257: /* CIL Label */ 
#line 212
    if (count != 1UL) {
#line 213
      goto err_unsupported;
    }
    {
#line 214
    tmp___9 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 214
    tiff_ptr->height = tmp___9;
    }
#line 215
    goto switch_break;
    case_258: /* CIL Label */ 
#line 217
    if (count == 1UL) {
      {
#line 218
      tmp___10 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 218
      tiff_ptr->bits_per_sample = (unsigned int )tmp___10;
      }
    } else {
      {
#line 222
      bits_per_sample_count = count;
#line 223
      bits_per_sample_tag_type = tag_type;
#line 224
      tmp___11 = (*(getter.get_ulong))((unsigned char const   *)vbuf);
#line 224
      bits_per_sample_offset = (long )tmp___11;
      }
    }
#line 226
    goto switch_break;
    case_259: /* CIL Label */ 
#line 228
    if (count == 1UL) {
      {
#line 228
      tmp___12 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 228
      if (tmp___12 == 1UL) {
#line 229
        tiff_ptr->compression = 1U;
      } else {
        {
#line 231
        minitiff_error(tiff_ptr, tiff_err_compr);
        }
      }
    } else {
      {
#line 231
      minitiff_error(tiff_ptr, tiff_err_compr);
      }
    }
#line 232
    goto switch_break;
    case_262: /* CIL Label */ 
#line 234
    if (count != 1UL) {
#line 235
      goto err_unsupported;
    }
    {
#line 236
    tmp___13 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 236
    tiff_ptr->photometric = (unsigned int )tmp___13;
    }
#line 238
    goto switch_break;
    case_273: /* CIL Label */ 
#line 240
    tiff_ptr->strip_offsets_count = count;
#line 241
    if (count == 1UL) {
#line 243
      if ((unsigned long )tiff_ptr->strip_offsets != (unsigned long )((void *)0)) {
#line 244
        goto err_invalid;
      }
      {
#line 245
      tmp___14 = malloc(sizeof(long ));
#line 245
      tiff_ptr->strip_offsets = (long *)tmp___14;
      }
#line 246
      if ((unsigned long )tiff_ptr->strip_offsets == (unsigned long )((void *)0)) {
#line 247
        goto err_memory;
      }
      {
#line 248
      tmp___15 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 248
      *(tiff_ptr->strip_offsets + 0) = (long )tmp___15;
      }
    } else {
      {
#line 253
      strip_offsets_tag_type = tag_type;
#line 254
      tmp___16 = (*(getter.get_ulong))((unsigned char const   *)vbuf);
#line 254
      strip_offsets_offset = (long )tmp___16;
      }
    }
#line 256
    goto switch_break;
    case_274: /* CIL Label */ 
#line 258
    if (count != 1UL) {
      {
#line 259
      minitiff_warning(tiff_ptr, "Non-default TIFF image orientation");
      }
    } else {
      {
#line 258
      tmp___17 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 258
      if (tmp___17 != 1UL) {
        {
#line 259
        minitiff_warning(tiff_ptr, "Non-default TIFF image orientation");
        }
      }
    }
#line 261
    goto switch_break;
    case_277: /* CIL Label */ 
#line 263
    if (count != 1UL) {
#line 264
      goto err_unsupported;
    }
    {
#line 265
    tmp___18 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 265
    tiff_ptr->samples_per_pixel = (unsigned int )tmp___18;
    }
#line 267
    goto switch_break;
    case_278: /* CIL Label */ 
#line 269
    if (count != 1UL) {
#line 270
      goto err_unsupported;
    }
    {
#line 271
    tmp___19 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
#line 271
    tiff_ptr->rows_per_strip = (unsigned int )tmp___19;
    }
#line 273
    goto switch_break;
    case_279: /* CIL Label */ 
#line 276
    goto switch_break;
    case_317: /* CIL Label */ 
    case_284: /* CIL Label */ 
#line 279
    if (count != 1UL) {
#line 280
      goto err_unsupported;
    } else {
      {
#line 279
      tmp___20 = get_ulong_value(& getter, (int )tag_type, (unsigned char const   *)vbuf);
      }
#line 279
      if (tmp___20 != 1UL) {
#line 280
        goto err_unsupported;
      }
    }
#line 281
    goto switch_break;
    case_316: /* CIL Label */ 
    case_315: /* CIL Label */ 
    case_306: /* CIL Label */ 
    case_305: /* CIL Label */ 
    case_297: /* CIL Label */ 
    case_285: /* CIL Label */ 
    case_296: /* CIL Label */ 
    case_287: /* CIL Label */ 
    case_286: /* CIL Label */ 
    case_283: /* CIL Label */ 
    case_282: /* CIL Label */ 
    case_281: /* CIL Label */ 
    case_280: /* CIL Label */ 
    case_272: /* CIL Label */ 
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ 
    case_269: /* CIL Label */ 
#line 300
    goto switch_break;
    case_50341: /* CIL Label */ 
    case_40965: /* CIL Label */ 
    case_34853: /* CIL Label */ 
    case_34665: /* CIL Label */ 
    case_33723: /* CIL Label */ 
    case_700: /* CIL Label */ 
#line 307
    if (! unknown_metadata_found) {
      {
#line 309
      unknown_metadata_found = 1;
#line 310
      minitiff_warning(tiff_ptr, tiff_warn_metadata);
      }
    }
#line 312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 314
    if (! unknown_tag_found) {
      {
#line 316
      unknown_tag_found = 1;
#line 317
      minitiff_warning(tiff_ptr, tiff_warn_tag);
      }
    }
#line 319
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  tmp___21 = fread((void */* __restrict  */)(buf), (size_t )4, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 324
  if (tmp___21 != 1UL) {
#line 325
    goto err_read;
  }
  {
#line 326
  tmp___22 = (*(getter.get_ulong))((unsigned char const   *)(buf));
  }
#line 326
  if (tmp___22 != 0UL) {
    {
#line 327
    minitiff_warning(tiff_ptr, tiff_warn_multiple);
    }
  }
#line 330
  if (bits_per_sample_offset != 0L) {
#line 333
    count = bits_per_sample_count;
#line 334
    if (count != (size_t )tiff_ptr->samples_per_pixel) {
#line 335
      goto err_invalid;
    }
#line 336
    if (count > 4UL) {
#line 337
      goto err_unsupported;
    }
    {
#line 338
    tmp___23 = fseek(fp, bits_per_sample_offset, 0);
    }
#line 338
    if (tmp___23 != 0) {
#line 339
      goto err_read;
    }
    {
#line 340
    tmp___24 = read_ulong_values(& getter, (int )bits_per_sample_tag_type, values,
                                 count, fp);
    }
#line 340
    if (tmp___24 != count) {
#line 342
      goto err_read;
    }
    {
#line 343
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 343
      count --;
#line 343
      if (! (count > 0UL)) {
#line 343
        goto while_break___0;
      }
#line 344
      if (values[0] != values[count]) {
#line 345
        goto err_unsupported;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 346
    tiff_ptr->bits_per_sample = (unsigned int )values[0];
  }
#line 348
  if (strip_offsets_offset != 0L) {
#line 350
    count = tiff_ptr->strip_offsets_count;
#line 351
    if (count == 0UL) {
#line 352
      goto err_invalid;
    } else
#line 351
    if (count > tiff_ptr->height) {
#line 352
      goto err_invalid;
    }
    {
#line 353
    tmp___25 = malloc(count * sizeof(long ));
#line 353
    tiff_ptr->strip_offsets = (long *)tmp___25;
    }
#line 354
    if ((unsigned long )tiff_ptr->strip_offsets == (unsigned long )((void *)0)) {
#line 355
      goto err_memory;
    }
    {
#line 356
    tmp___26 = fseek(fp, strip_offsets_offset, 0);
    }
#line 356
    if (tmp___26 != 0) {
#line 357
      goto err_read;
    }
    {
#line 358
    tmp___27 = read_ulong_values(& getter, (int )strip_offsets_tag_type, (unsigned long *)tiff_ptr->strip_offsets,
                                 count, fp);
    }
#line 358
    if (tmp___27 != count) {
#line 360
      goto err_read;
    }
  }
#line 364
  return;
  err_read: 
  {
#line 368
  minitiff_error(tiff_ptr, tiff_err_read);
  }
  err_invalid: 
  {
#line 370
  minitiff_error(tiff_ptr, tiff_err_invalid);
  }
  err_unsupported: 
  {
#line 372
  minitiff_error(tiff_ptr, tiff_err_unsupported);
  }
  err_memory: 
  {
#line 374
  minitiff_error(tiff_ptr, tiff_err_memory);
  }
#line 375
  return;
}
}
#line 381 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffread.c"
void minitiff_read_row(struct minitiff_info *tiff_ptr , unsigned char *row_ptr , size_t row_index ,
                       FILE *fp ) 
{ 
  size_t row_size ;
  size_t strip_index ;
  unsigned int bytes_per_sample ;
  unsigned int sample_max ;
  long offset ;
  size_t i ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;

  {
#line 393
  bytes_per_sample = (tiff_ptr->bits_per_sample + 7U) / 8U;
#line 394
  row_size = (tiff_ptr->width * (size_t )tiff_ptr->samples_per_pixel) * (size_t )bytes_per_sample;
#line 400
  strip_index = row_index / (size_t )tiff_ptr->rows_per_strip;
#line 401
  if (strip_index >= tiff_ptr->strip_offsets_count) {
#line 402
    goto err_invalid;
  }
#line 403
  offset = (long )((size_t )*(tiff_ptr->strip_offsets + strip_index) + row_size * (row_index % (unsigned long )tiff_ptr->rows_per_strip));
#line 405
  if (offset <= 0L) {
#line 406
    goto err_invalid;
  }
  {
#line 407
  tmp___0 = ftell(fp);
  }
#line 407
  if (tmp___0 != offset) {
    {
#line 408
    tmp = fseek(fp, offset, 0);
    }
#line 408
    if (tmp != 0) {
#line 409
      goto err_read;
    }
  }
  {
#line 412
  tmp___1 = fread((void */* __restrict  */)row_ptr, row_size, (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 412
  if (tmp___1 != 1UL) {
#line 413
    goto err_read;
  }
#line 414
  if (tiff_ptr->photometric == 0U) {
#line 416
    if (bytes_per_sample > 1U) {
#line 417
      goto err_unsupported;
    }
#line 418
    sample_max = (unsigned int )((1 << tiff_ptr->bits_per_sample) - 1);
#line 419
    i = (size_t )0;
    {
#line 419
    while (1) {
      while_continue: /* CIL Label */ ;
#line 419
      if (! (i < row_size)) {
#line 419
        goto while_break;
      }
#line 420
      *(row_ptr + i) = (unsigned char )(sample_max - (unsigned int )*(row_ptr + i));
#line 419
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 424
  return;
  err_read: 
  {
#line 428
  minitiff_error(tiff_ptr, tiff_err_read);
  }
  err_invalid: 
  {
#line 430
  minitiff_error(tiff_ptr, tiff_err_invalid);
  }
  err_unsupported: 
  {
#line 432
  minitiff_error(tiff_ptr, tiff_err_unsupported);
  }
#line 433
  return;
}
}
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 588
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 61 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/minitiff.h"
void minitiff_init_info(struct minitiff_info *minitiff_ptr ) ;
#line 62
void minitiff_validate_info(struct minitiff_info *tiff_ptr ) ;
#line 63
void minitiff_destroy_info(struct minitiff_info *minitiff_ptr ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
void minitiff_init_info(struct minitiff_info *minitiff_ptr ) 
{ 


  {
  {
#line 23
  memset((void *)minitiff_ptr, 0, sizeof(*minitiff_ptr));
#line 24
  minitiff_ptr->photometric = 4294967295U;
  }
#line 25
  return;
}
}
#line 31 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
void minitiff_validate_info(struct minitiff_info *tiff_ptr ) 
{ 


  {
#line 33
  if (tiff_ptr->width == 0UL) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  } else
#line 33
  if (tiff_ptr->height == 0UL) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  } else
#line 33
  if (tiff_ptr->bits_per_sample == 0U) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  } else
#line 33
  if (tiff_ptr->samples_per_pixel == 0U) {
    {
#line 35
    minitiff_error(tiff_ptr, "Invalid TIFF dimensions");
    }
  }
#line 36
  if ((unsigned long )tiff_ptr->strip_offsets == (unsigned long )((void *)0)) {
    {
#line 37
    minitiff_error(tiff_ptr, "Invalid TIFF strip info");
    }
  } else
#line 36
  if (tiff_ptr->rows_per_strip == 0U) {
    {
#line 37
    minitiff_error(tiff_ptr, "Invalid TIFF strip info");
    }
  }
#line 38
  if (tiff_ptr->photometric >= 3U) {
    {
#line 39
    minitiff_error(tiff_ptr, "Unknown photometric interpretation");
    }
  }
#line 40
  return;
}
}
#line 46 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
void minitiff_destroy_info(struct minitiff_info *minitiff_ptr ) 
{ 


  {
#line 48
  if ((unsigned long )minitiff_ptr->strip_offsets != (unsigned long )((void *)0)) {
    {
#line 49
    free((void *)minitiff_ptr->strip_offsets);
    }
  }
#line 50
  return;
}
}
#line 56 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
static void minitiff_default_error_handler(char const   *msg___0 ) 
{ 


  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Error: %s\n",
          msg___0);
#line 59
  exit(1);
  }
}
}
#line 62 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
void minitiff_error(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) 
{ 


  {
#line 64
  if ((unsigned long )minitiff_ptr->error_handler != (unsigned long )((void *)0)) {
    {
#line 65
    (*(minitiff_ptr->error_handler))(msg___0);
    }
  } else {
    {
#line 67
    minitiff_default_error_handler(msg___0);
    }
  }
  {
#line 68
  abort();
  }
}
}
#line 71 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
static void minitiff_default_warning_handler(char const   *msg___0 ) 
{ 


  {
  {
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Warning: %s\n",
          msg___0);
  }
#line 74
  return;
}
}
#line 76 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
void minitiff_warning(struct minitiff_info *minitiff_ptr , char const   *msg___0 ) 
{ 


  {
#line 78
  if ((unsigned long )minitiff_ptr->warning_handler != (unsigned long )((void *)0)) {
    {
#line 79
    (*(minitiff_ptr->warning_handler))(msg___0);
    }
  } else {
    {
#line 81
    minitiff_default_warning_handler(msg___0);
    }
  }
#line 82
  return;
}
}
#line 89 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
char const   minitiff_sig_m[4]  = {      (char const   )77,      (char const   )77,      (char const   )0,      (char const   )42};
#line 90 "/home/khheo/project/benchmark/optipng-0.7.6/src/minitiff/tiffbase.c"
char const   minitiff_sig_i[4]  = {      (char const   )73,      (char const   )73,      (char const   )42,      (char const   )0};
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmio.h"
int pnm_is_valid(pnm_struct const   *pnm_ptr ) ;
#line 103
size_t pnm_raw_sample_size(pnm_struct const   *pnm_ptr ) ;
#line 104
size_t pnm_mem_size(pnm_struct const   *pnm_ptr , size_t sample_size , unsigned int num_rows ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmutil.c"
int pnm_is_valid(pnm_struct const   *pnm_ptr ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int height ;
  unsigned int maxval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 23
  format = (unsigned int )pnm_ptr->format;
#line 24
  depth = (unsigned int )pnm_ptr->depth;
#line 25
  width = (unsigned int )pnm_ptr->width;
#line 26
  height = (unsigned int )pnm_ptr->height;
#line 27
  maxval = (unsigned int )pnm_ptr->maxval;
#line 29
  if (depth == 0U) {
#line 30
    return (0);
  } else
#line 29
  if (width == 0U) {
#line 30
    return (0);
  } else
#line 29
  if (height == 0U) {
#line 30
    return (0);
  } else
#line 29
  if (maxval == 0U) {
#line 30
    return (0);
  }
  {
#line 40
  if (format == 4U) {
#line 40
    goto case_4;
  }
#line 40
  if (format == 1U) {
#line 40
    goto case_4;
  }
#line 44
  if (format == 5U) {
#line 44
    goto case_5;
  }
#line 44
  if (format == 2U) {
#line 44
    goto case_5;
  }
#line 48
  if (format == 6U) {
#line 48
    goto case_6;
  }
#line 48
  if (format == 3U) {
#line 48
    goto case_6;
  }
#line 51
  if (format == 7U) {
#line 51
    goto case_7;
  }
#line 54
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 42
  if (depth == 1U) {
#line 42
    if (maxval == 1U) {
#line 42
      tmp = 1;
    } else {
#line 42
      tmp = 0;
    }
  } else {
#line 42
    tmp = 0;
  }
#line 42
  return (tmp);
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 46
  if (depth == 1U) {
#line 46
    tmp___0 = 1;
  } else {
#line 46
    tmp___0 = 0;
  }
#line 46
  return (tmp___0);
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 50
  if (depth == 3U) {
#line 50
    tmp___1 = 1;
  } else {
#line 50
    tmp___1 = 0;
  }
#line 50
  return (tmp___1);
  case_7: /* CIL Label */ 
#line 53
  return (1);
  switch_default: /* CIL Label */ 
#line 55
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 66 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmutil.c"
size_t pnm_raw_sample_size(pnm_struct const   *pnm_ptr ) 
{ 
  unsigned int maxval ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 68
  maxval = (unsigned int )pnm_ptr->maxval;
#line 70
  if (maxval == 0U) {
    {
#line 71
    tmp = __errno_location();
#line 71
    *tmp = 22;
    }
  }
#line 73
  if (maxval <= 255U) {
#line 74
    return ((size_t )1);
  } else
#line 75
  if (maxval <= 65535U) {
#line 76
    return ((size_t )2);
  } else
#line 78
  if (maxval <= 16777215U) {
#line 79
    return ((size_t )3);
  } else
#line 80
  if (maxval <= 4294967295U) {
#line 81
    return ((size_t )4);
  } else {
    {
#line 85
    tmp___0 = __errno_location();
#line 85
    *tmp___0 = 22;
    }
#line 86
    return ((size_t )0);
  }
}
}
#line 97 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmutil.c"
size_t pnm_mem_size(pnm_struct const   *pnm_ptr , size_t sample_size , unsigned int num_rows ) 
{ 
  unsigned int depth ;
  unsigned int width ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 100
  depth = (unsigned int )pnm_ptr->depth;
#line 101
  width = (unsigned int )pnm_ptr->width;
#line 103
  if (sample_size == 0UL) {
    {
#line 105
    tmp = __errno_location();
#line 105
    *tmp = 22;
    }
#line 106
    return ((size_t )0);
  } else
#line 103
  if (depth == 0U) {
    {
#line 105
    tmp = __errno_location();
#line 105
    *tmp = 22;
    }
#line 106
    return ((size_t )0);
  } else
#line 103
  if (width == 0U) {
    {
#line 105
    tmp = __errno_location();
#line 105
    *tmp = 22;
    }
#line 106
    return ((size_t )0);
  }
#line 109
  if ((size_t )num_rows > ((0xffffffffffffffffUL / sample_size) / (size_t )depth) / (size_t )width) {
    {
#line 111
    tmp___0 = __errno_location();
#line 111
    *tmp___0 = 34;
    }
#line 112
    return ((size_t )0);
  }
#line 115
  return (((sample_size * (size_t )depth) * (size_t )width) * (size_t )num_rows);
}
}
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 652 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 86 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmio.h"
int pnm_fput_header(pnm_struct const   *pnm_ptr , FILE *stream ) ;
#line 88
int pnm_fput_values(pnm_struct const   *pnm_ptr , unsigned int const   *sample_values ,
                    unsigned int num_rows , FILE *stream ) ;
#line 92
int pnm_fput_bytes(pnm_struct const   *pnm_ptr , unsigned char const   *sample_bytes ,
                   size_t sample_size , unsigned int num_rows , FILE *stream ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmout.c"
int pnm_fput_header(pnm_struct const   *pnm_ptr , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int height ;
  unsigned int maxval ;
  int result ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 23
  format = (unsigned int )pnm_ptr->format;
#line 24
  depth = (unsigned int )pnm_ptr->depth;
#line 25
  width = (unsigned int )pnm_ptr->width;
#line 26
  height = (unsigned int )pnm_ptr->height;
#line 27
  maxval = (unsigned int )pnm_ptr->maxval;
#line 31
  tmp = pnm_is_valid(pnm_ptr);
  }
#line 31
  if (! tmp) {
#line 32
    return (0);
  }
  {
#line 38
  if (format == 4U) {
#line 38
    goto case_4;
  }
#line 38
  if (format == 1U) {
#line 38
    goto case_4;
  }
#line 45
  if (format == 6U) {
#line 45
    goto case_6;
  }
#line 45
  if (format == 5U) {
#line 45
    goto case_6;
  }
#line 45
  if (format == 3U) {
#line 45
    goto case_6;
  }
#line 45
  if (format == 2U) {
#line 45
    goto case_6;
  }
#line 49
  if (format == 7U) {
#line 49
    goto case_7;
  }
#line 54
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 39
  result = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"P%c\n%u %u\n",
                   format + 48U, width, height);
  }
#line 41
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 46
  result = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"P%c\n%u %u\n%u\n",
                   format + 48U, width, height, maxval);
  }
#line 48
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 50
  result = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"P7\nDEPTH %u\nWIDTH %u\nHEIGHT %u\nMAXVAL %u\nENDHDR\n",
                   depth, width, height, maxval);
  }
#line 53
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 55
  tmp___0 = __errno_location();
#line 55
  *tmp___0 = 22;
  }
#line 56
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 60
  if (result > 0) {
#line 60
    tmp___1 = 1;
  } else {
#line 60
    tmp___1 = -1;
  }
#line 60
  return (tmp___1);
}
}
#line 71 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmout.c"
int pnm_fput_values(pnm_struct const   *pnm_ptr , unsigned int const   *sample_values ,
                    unsigned int num_rows , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  int ch ;
  int mask ;
  size_t i ;
  size_t j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;

  {
#line 76
  format = (unsigned int )pnm_ptr->format;
#line 77
  depth = (unsigned int )pnm_ptr->depth;
#line 78
  width = (unsigned int )pnm_ptr->width;
#line 79
  maxval = (unsigned int )pnm_ptr->maxval;
#line 80
  row_length = (size_t )depth * (size_t )width;
#line 81
  num_samples = (size_t )num_rows * row_length;
  {
#line 88
  if (format == 1U) {
#line 88
    goto case_1;
  }
#line 102
  if (format == 3U) {
#line 102
    goto case_3;
  }
#line 102
  if (format == 2U) {
#line 102
    goto case_3;
  }
#line 112
  if (format == 4U) {
#line 112
    goto case_4;
  }
#line 132
  if (format == 7U) {
#line 132
    goto case_7;
  }
#line 132
  if (format == 6U) {
#line 132
    goto case_7;
  }
#line 132
  if (format == 5U) {
#line 132
    goto case_7;
  }
#line 171
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  j = (size_t )0;
#line 89
  i = j;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < num_samples)) {
#line 89
      goto while_break;
    }
#line 91
    if (*(sample_values + i) != 0U) {
#line 91
      tmp = '0';
    } else {
#line 91
      tmp = '1';
    }
    {
#line 91
    tmp___0 = _IO_putc(tmp, stream);
    }
#line 91
    if (tmp___0 == -1) {
#line 92
      goto while_break;
    }
#line 93
    j ++;
#line 93
    if (j == row_length) {
      {
#line 95
      j = (size_t )0;
#line 96
      tmp___1 = _IO_putc('\n', stream);
      }
#line 96
      if (tmp___1 == -1) {
#line 97
        goto while_break;
      }
    }
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 103
  j = (size_t )0;
#line 103
  i = j;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (i < num_samples)) {
#line 103
      goto while_break___0;
    }
#line 105
    j ++;
#line 105
    if (j == row_length) {
#line 106
      j = (size_t )0;
    }
#line 107
    if (j == 0UL) {
#line 107
      tmp___2 = "%u\n";
    } else {
#line 107
      tmp___2 = "%u ";
    }
    {
#line 107
    tmp___3 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
                      *(sample_values + i));
    }
#line 107
    if (tmp___3 <= 0) {
#line 109
      goto while_break___0;
    }
#line 103
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  goto switch_break;
  case_4: /* CIL Label */ 
#line 113
  j = (size_t )0;
#line 113
  i = j;
  {
#line 113
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 113
    if (! (i < num_samples)) {
#line 113
      goto while_break___1;
    }
#line 115
    ch = 0;
#line 116
    mask = 128;
    {
#line 116
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 116
      if (! (mask != 0)) {
#line 116
        goto while_break___2;
      }
#line 118
      tmp___4 = i;
#line 118
      i ++;
#line 118
      if (*(sample_values + tmp___4) == 0U) {
#line 119
        ch |= mask;
      }
#line 120
      j ++;
#line 120
      if (j == row_length) {
#line 122
        j = (size_t )0;
#line 123
        goto while_break___2;
      }
#line 116
      mask >>= 1;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 126
    tmp___5 = _IO_putc(ch, stream);
    }
#line 126
    if (tmp___5 == -1) {
#line 127
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 129
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 133
  if (maxval <= 255U) {
#line 135
    i = (size_t )0;
    {
#line 135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 135
      if (! (i < num_samples)) {
#line 135
        goto while_break___3;
      }
      {
#line 137
      tmp___6 = _IO_putc((int )(*(sample_values + i) & 255U), stream);
      }
#line 137
      if (tmp___6 == -1) {
#line 138
        goto while_break___3;
      }
#line 135
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 141
  if (maxval <= 65535U) {
#line 143
    i = (size_t )0;
    {
#line 143
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 143
      if (! (i < num_samples)) {
#line 143
        goto while_break___4;
      }
      {
#line 145
      tmp___7 = _IO_putc((int )((*(sample_values + i) >> 8) & 255U), stream);
      }
#line 145
      if (tmp___7 == -1) {
#line 147
        goto while_break___4;
      } else {
        {
#line 145
        tmp___8 = _IO_putc((int )(*(sample_values + i) & 255U), stream);
        }
#line 145
        if (tmp___8 == -1) {
#line 147
          goto while_break___4;
        }
      }
#line 143
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 151
  if (maxval <= 4294967295U) {
#line 153
    i = (size_t )0;
    {
#line 153
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 153
      if (! (i < num_samples)) {
#line 153
        goto while_break___5;
      }
#line 155
      if (maxval > 16777215U) {
        {
#line 156
        tmp___9 = _IO_putc((int )((*(sample_values + i) >> 24) & 255U), stream);
        }
#line 156
        if (tmp___9 == -1) {
#line 157
          goto while_break___5;
        }
      }
      {
#line 158
      tmp___10 = _IO_putc((int )((*(sample_values + i) >> 16) & 255U), stream);
      }
#line 158
      if (tmp___10 == -1) {
#line 161
        goto while_break___5;
      } else {
        {
#line 158
        tmp___11 = _IO_putc((int )((*(sample_values + i) >> 8) & 255U), stream);
        }
#line 158
        if (tmp___11 == -1) {
#line 161
          goto while_break___5;
        } else {
          {
#line 158
          tmp___12 = _IO_putc((int )(*(sample_values + i) & 255U), stream);
          }
#line 158
          if (tmp___12 == -1) {
#line 161
            goto while_break___5;
          }
        }
      }
#line 153
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
    {
#line 167
    tmp___13 = __errno_location();
#line 167
    *tmp___13 = 22;
    }
#line 168
    return (0);
  }
#line 170
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 172
  tmp___14 = __errno_location();
#line 172
  *tmp___14 = 22;
  }
#line 173
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 177
  if (i == num_samples) {
#line 177
    tmp___15 = 1;
  } else {
#line 177
    tmp___15 = -1;
  }
#line 177
  return (tmp___15);
}
}
#line 188 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmout.c"
int pnm_fput_bytes(pnm_struct const   *pnm_ptr , unsigned char const   *sample_bytes ,
                   size_t sample_size , unsigned int num_rows , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  size_t raw_sample_size ;
  int ch ;
  int mask ;
  size_t i ;
  size_t j ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 194
  format = (unsigned int )pnm_ptr->format;
#line 195
  depth = (unsigned int )pnm_ptr->depth;
#line 196
  width = (unsigned int )pnm_ptr->width;
#line 197
  maxval = (unsigned int )pnm_ptr->maxval;
#line 198
  row_length = (size_t )depth * (size_t )width;
#line 199
  num_samples = (size_t )num_rows * row_length;
#line 205
  if (maxval <= 255U) {
#line 206
    raw_sample_size = (size_t )1;
  } else
#line 207
  if (maxval <= 65535U) {
#line 208
    raw_sample_size = (size_t )2;
  } else
#line 210
  if (maxval <= 16777215U) {
#line 211
    raw_sample_size = (size_t )3;
  } else
#line 212
  if (maxval <= 4294967295U) {
#line 213
    raw_sample_size = (size_t )4;
  } else {
#line 216
    raw_sample_size = (size_t )(! sample_size);
  }
#line 217
  if (raw_sample_size != sample_size) {
    {
#line 219
    tmp = __errno_location();
#line 219
    *tmp = 22;
    }
#line 220
    return (0);
  }
  {
#line 226
  if (format == 4U) {
#line 226
    goto case_4;
  }
#line 246
  if (format == 7U) {
#line 246
    goto case_7;
  }
#line 246
  if (format == 6U) {
#line 246
    goto case_7;
  }
#line 246
  if (format == 5U) {
#line 246
    goto case_7;
  }
#line 249
  goto switch_default;
  case_4: /* CIL Label */ 
#line 227
  j = (size_t )0;
#line 227
  i = j;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < num_samples)) {
#line 227
      goto while_break;
    }
#line 229
    ch = 0;
#line 230
    mask = 128;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 230
      if (! (mask != 0)) {
#line 230
        goto while_break___0;
      }
#line 232
      tmp___0 = i;
#line 232
      i ++;
#line 232
      if ((int const   )*(sample_bytes + tmp___0) == 0) {
#line 233
        ch |= mask;
      }
#line 234
      j ++;
#line 234
      if (j == row_length) {
#line 236
        j = (size_t )0;
#line 237
        goto while_break___0;
      }
#line 230
      mask >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 240
    tmp___1 = _IO_putc(ch, stream);
    }
#line 240
    if (tmp___1 == -1) {
#line 241
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 247
  i = fwrite((void const   */* __restrict  */)sample_bytes, sample_size, num_samples,
             (FILE */* __restrict  */)stream);
  }
#line 248
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 250
  tmp___2 = __errno_location();
#line 250
  *tmp___2 = 22;
  }
#line 251
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 255
  if (i == num_samples) {
#line 255
    tmp___3 = 1;
  } else {
#line 255
    tmp___3 = -1;
  }
#line 255
  return (tmp___3);
}
}
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 639 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 70 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmio.h"
int pnm_fget_header(pnm_struct *pnm_ptr , FILE *stream ) ;
#line 72
int pnm_fget_values(pnm_struct const   *pnm_ptr , unsigned int *sample_values , unsigned int num_rows ,
                    FILE *stream ) ;
#line 76
int pnm_fget_bytes(pnm_struct const   *pnm_ptr , unsigned char *sample_bytes , size_t sample_size ,
                   unsigned int num_rows , FILE *stream ) ;
#line 39 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmin.c"
static int pnm_fget_char(FILE *stream ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 41
  tmp = _IO_getc(stream);
#line 41
  ch = tmp;
  }
#line 44
  if (ch == 35) {
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 48
      ch = _IO_getc(stream);
      }
#line 46
      if (ch != -1) {
#line 46
        if (ch != 10) {
#line 46
          if (! (ch != 13)) {
#line 46
            goto while_break;
          }
        } else {
#line 46
          goto while_break;
        }
      } else {
#line 46
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 53
  if (ch == 13) {
    {
#line 55
    ch = _IO_getc(stream);
    }
#line 56
    if (ch != 10) {
      {
#line 58
      ungetc(ch, stream);
#line 59
      ch = '\n';
      }
    }
  }
#line 63
  return (ch);
}
}
#line 71 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmin.c"
static int pnm_fscan_uint(FILE *stream , unsigned int *value ) 
{ 
  int ch ;
  unsigned int tmp ;
  int *tmp___0 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    ch = pnm_fget_char(stream);
    }
#line 77
    if (! (ch == 32)) {
#line 77
      if (! (ch == 9)) {
#line 77
        if (! (ch == 10)) {
#line 77
          if (! (ch == 13)) {
#line 77
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (ch == -1) {
#line 82
    return (-1);
  }
#line 83
  if (ch >= 48) {
#line 83
    if (! (ch <= 57)) {
      {
#line 85
      ungetc(ch, stream);
      }
#line 86
      return (0);
    }
  } else {
    {
#line 85
    ungetc(ch, stream);
    }
#line 86
    return (0);
  }
#line 90
  *value = 0U;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    tmp = *value * 10U + (unsigned int )(ch - 48);
#line 94
    if (tmp >= *value) {
#line 95
      *value = tmp;
    } else {
      {
#line 98
      *value = 4294967295U;
#line 99
      tmp___0 = __errno_location();
#line 99
      *tmp___0 = 34;
      }
    }
    {
#line 101
    ch = _IO_getc(stream);
    }
#line 91
    if (ch >= 48) {
#line 91
      if (! (ch <= 57)) {
#line 91
        goto while_break___0;
      }
    } else {
#line 91
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  if (! (ch == 32)) {
#line 105
    if (! (ch == 9)) {
#line 105
      if (! (ch == 10)) {
#line 105
        if (! (ch == 13)) {
          {
#line 106
          ungetc(ch, stream);
          }
        }
      }
    }
  }
#line 108
  return (1);
}
}
#line 118 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmin.c"
int pnm_fget_header(pnm_struct *pnm_ptr , FILE *stream ) 
{ 
  unsigned int format ;
  int ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 124
  memset((void *)pnm_ptr, 0, sizeof(pnm_struct ));
#line 127
  ch = _IO_getc(stream);
  }
#line 128
  if (ch == -1) {
#line 129
    return (-1);
  }
#line 131
  if (ch != 80) {
#line 132
    return (-1);
  }
  {
#line 133
  ch = _IO_getc(stream);
  }
#line 134
  if (ch < 49) {
#line 135
    return (-1);
  } else
#line 134
  if (ch > 57) {
#line 135
    return (-1);
  }
  {
#line 136
  format = (unsigned int )(ch - 48);
#line 137
  ch = pnm_fget_char(stream);
  }
#line 138
  if (! (ch == 32)) {
#line 138
    if (! (ch == 9)) {
#line 138
      if (! (ch == 10)) {
#line 138
        if (! (ch == 13)) {
#line 139
          return (-1);
        }
      }
    }
  }
#line 142
  pnm_ptr->format = format;
#line 143
  if (format >= 1U) {
#line 143
    if (format <= 6U) {
#line 145
      if (format == 3U) {
#line 145
        pnm_ptr->depth = 3U;
      } else
#line 145
      if (format == 6U) {
#line 145
        pnm_ptr->depth = 3U;
      } else {
#line 145
        pnm_ptr->depth = 1U;
      }
      {
#line 146
      tmp = pnm_fscan_uint(stream, & pnm_ptr->width);
      }
#line 146
      if (tmp != 1) {
#line 148
        return (-1);
      } else {
        {
#line 146
        tmp___0 = pnm_fscan_uint(stream, & pnm_ptr->height);
        }
#line 146
        if (tmp___0 != 1) {
#line 148
          return (-1);
        }
      }
#line 149
      if (format == 1U) {
#line 150
        pnm_ptr->maxval = 1U;
      } else
#line 149
      if (format == 4U) {
#line 150
        pnm_ptr->maxval = 1U;
      } else {
        {
#line 153
        tmp___1 = pnm_fscan_uint(stream, & pnm_ptr->maxval);
        }
#line 153
        if (tmp___1 != 1) {
#line 154
          return (-1);
        }
      }
      {
#line 156
      tmp___4 = pnm_is_valid((pnm_struct const   *)pnm_ptr);
      }
#line 156
      if (tmp___4) {
#line 156
        tmp___3 = 1;
      } else {
#line 156
        tmp___3 = 0;
      }
#line 156
      return (tmp___3);
    } else {
#line 159
      return (-1);
    }
  } else {
#line 159
    return (-1);
  }
}
}
#line 172 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmin.c"
int pnm_fget_values(pnm_struct const   *pnm_ptr , unsigned int *sample_values , unsigned int num_rows ,
                    FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  int ch ;
  int ch8 ;
  int ch16 ;
  int ch24 ;
  int mask ;
  size_t i ;
  size_t j ;
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 177
  format = (unsigned int )pnm_ptr->format;
#line 178
  depth = (unsigned int )pnm_ptr->depth;
#line 179
  width = (unsigned int )pnm_ptr->width;
#line 180
  maxval = (unsigned int )pnm_ptr->maxval;
#line 181
  row_length = (size_t )depth * (size_t )width;
#line 182
  num_samples = (size_t )num_rows * row_length;
  {
#line 193
  if (format == 1U) {
#line 193
    goto case_1;
  }
#line 209
  if (format == 3U) {
#line 209
    goto case_3;
  }
#line 209
  if (format == 2U) {
#line 209
    goto case_3;
  }
#line 216
  if (format == 4U) {
#line 216
    goto case_4;
  }
#line 235
  if (format == 7U) {
#line 235
    goto case_7;
  }
#line 235
  if (format == 6U) {
#line 235
    goto case_7;
  }
#line 235
  if (format == 5U) {
#line 235
    goto case_7;
  }
#line 282
  goto switch_default;
  case_1: /* CIL Label */ 
#line 194
  i = (size_t )0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < num_samples)) {
#line 194
      goto while_break;
    }
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 198
      ch = pnm_fget_char(stream);
      }
#line 196
      if (! (ch == 32)) {
#line 196
        if (! (ch == 9)) {
#line 196
          if (! (ch == 10)) {
#line 196
            if (! (ch == 13)) {
#line 196
              goto while_break___0;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    if (ch != 48) {
#line 200
      if (ch != 49) {
        {
#line 202
        ungetc(ch, stream);
        }
#line 203
        goto while_break;
      }
    }
#line 205
    if (ch == 48) {
#line 205
      *(sample_values + i) = 1U;
    } else {
#line 205
      *(sample_values + i) = 0U;
    }
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 210
  i = (size_t )0;
  {
#line 210
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 210
    if (! (i < num_samples)) {
#line 210
      goto while_break___1;
    }
    {
#line 212
    tmp = pnm_fscan_uint(stream, sample_values + i);
    }
#line 212
    if (tmp != 1) {
#line 213
      goto while_break___1;
    }
#line 210
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 215
  goto switch_break;
  case_4: /* CIL Label */ 
#line 217
  j = (size_t )0;
#line 217
  i = j;
  {
#line 217
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 217
    if (! (i < num_samples)) {
#line 217
      goto while_break___2;
    }
    {
#line 219
    ch = _IO_getc(stream);
    }
#line 220
    if (ch == -1) {
#line 221
      goto while_break___2;
    }
#line 222
    mask = 128;
    {
#line 222
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 222
      if (! (mask != 0)) {
#line 222
        goto while_break___3;
      }
#line 224
      tmp___0 = i;
#line 224
      i ++;
#line 224
      if (ch & mask) {
#line 224
        *(sample_values + tmp___0) = 0U;
      } else {
#line 224
        *(sample_values + tmp___0) = 1U;
      }
#line 225
      j ++;
#line 225
      if (j == row_length) {
#line 227
        j = (size_t )0;
#line 228
        goto while_break___3;
      }
#line 222
      mask >>= 1;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 232
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 236
  if (maxval <= 255U) {
#line 238
    i = (size_t )0;
    {
#line 238
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 238
      if (! (i < num_samples)) {
#line 238
        goto while_break___4;
      }
      {
#line 240
      ch = _IO_getc(stream);
      }
#line 241
      if (ch == -1) {
#line 242
        goto while_break___4;
      }
#line 243
      *(sample_values + i) = (unsigned int )ch;
#line 238
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 246
  if (maxval <= 65535U) {
#line 248
    i = (size_t )0;
    {
#line 248
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 248
      if (! (i < num_samples)) {
#line 248
        goto while_break___5;
      }
      {
#line 250
      ch8 = _IO_getc(stream);
#line 251
      ch = _IO_getc(stream);
      }
#line 252
      if (ch == -1) {
#line 253
        goto while_break___5;
      }
#line 254
      *(sample_values + i) = ((unsigned int )ch8 << 8) + (unsigned int )ch;
#line 248
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 258
  if (maxval <= 4294967295U) {
#line 260
    ch24 = 0;
#line 261
    i = (size_t )0;
    {
#line 261
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 261
      if (! (i < num_samples)) {
#line 261
        goto while_break___6;
      }
#line 263
      if (maxval > 16777215U) {
        {
#line 264
        ch24 = _IO_getc(stream);
        }
      }
      {
#line 265
      ch16 = _IO_getc(stream);
#line 266
      ch8 = _IO_getc(stream);
#line 267
      ch = _IO_getc(stream);
      }
#line 268
      if (ch == -1) {
#line 269
        goto while_break___6;
      }
#line 270
      *(sample_values + i) = ((((unsigned int )ch24 << 24) + ((unsigned int )ch16 << 16)) + ((unsigned int )ch8 << 8)) + (unsigned int )ch;
#line 261
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
    {
#line 278
    tmp___1 = __errno_location();
#line 278
    *tmp___1 = 22;
    }
#line 279
    return (0);
  }
#line 281
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 283
  tmp___2 = __errno_location();
#line 283
  *tmp___2 = 22;
  }
#line 284
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 288
  if (i < num_samples) {
    {
#line 290
    memset((void *)(sample_values + i), 0, (num_samples - i) * sizeof(unsigned int ));
    }
#line 291
    return (-1);
  }
#line 293
  return (1);
}
}
#line 305 "/home/khheo/project/benchmark/optipng-0.7.6/src/pnmio/pnmin.c"
int pnm_fget_bytes(pnm_struct const   *pnm_ptr , unsigned char *sample_bytes , size_t sample_size ,
                   unsigned int num_rows , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  size_t raw_sample_size ;
  int ch ;
  int mask ;
  size_t i ;
  size_t j ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
#line 311
  format = (unsigned int )pnm_ptr->format;
#line 312
  depth = (unsigned int )pnm_ptr->depth;
#line 313
  width = (unsigned int )pnm_ptr->width;
#line 314
  maxval = (unsigned int )pnm_ptr->maxval;
#line 315
  row_length = (size_t )depth * (size_t )width;
#line 316
  num_samples = (size_t )num_rows * row_length;
#line 322
  if (maxval <= 255U) {
#line 323
    raw_sample_size = (size_t )1;
  } else
#line 324
  if (maxval <= 65535U) {
#line 325
    raw_sample_size = (size_t )2;
  } else
#line 327
  if (maxval <= 16777215U) {
#line 328
    raw_sample_size = (size_t )3;
  } else
#line 329
  if (maxval <= 4294967295U) {
#line 330
    raw_sample_size = (size_t )4;
  } else {
#line 333
    raw_sample_size = (size_t )(! sample_size);
  }
#line 334
  if (raw_sample_size != sample_size) {
    {
#line 336
    tmp = __errno_location();
#line 336
    *tmp = 22;
    }
#line 337
    return (0);
  }
  {
#line 343
  if (format == 4U) {
#line 343
    goto case_4;
  }
#line 362
  if (format == 7U) {
#line 362
    goto case_7;
  }
#line 362
  if (format == 6U) {
#line 362
    goto case_7;
  }
#line 362
  if (format == 5U) {
#line 362
    goto case_7;
  }
#line 365
  goto switch_default;
  case_4: /* CIL Label */ 
#line 344
  j = (size_t )0;
#line 344
  i = j;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (i < num_samples)) {
#line 344
      goto while_break;
    }
    {
#line 346
    ch = _IO_getc(stream);
    }
#line 347
    if (ch == -1) {
#line 348
      goto while_break;
    }
#line 349
    mask = 128;
    {
#line 349
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 349
      if (! (mask != 0)) {
#line 349
        goto while_break___0;
      }
#line 351
      tmp___0 = i;
#line 351
      i ++;
#line 351
      if (ch & mask) {
#line 351
        tmp___1 = 0;
      } else {
#line 351
        tmp___1 = 1;
      }
#line 351
      *(sample_bytes + tmp___0) = (unsigned char )tmp___1;
#line 352
      j ++;
#line 352
      if (j == row_length) {
#line 354
        j = (size_t )0;
#line 355
        goto while_break___0;
      }
#line 349
      mask >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 363
  i = fread((void */* __restrict  */)sample_bytes, sample_size, num_samples, (FILE */* __restrict  */)stream);
  }
#line 364
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 366
  tmp___2 = __errno_location();
#line 366
  *tmp___2 = 22;
  }
#line 367
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 371
  if (i < num_samples) {
    {
#line 373
    memset((void *)(sample_bytes + i), 0, sample_size * num_samples - i);
    }
#line 374
    return (-1);
  }
#line 376
  return (1);
}
}
#line 115 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.h"
void GIFReadScreen(struct GIFScreen *screen , FILE *stream ) ;
#line 123
void GIFInitImage(struct GIFImage *image___0 , struct GIFScreen *screen , unsigned char **rows ) ;
#line 130
void GIFDestroyImage(struct GIFImage *image___0 ) ;
#line 139
int GIFReadNextBlock(struct GIFImage *image___0 , struct GIFExtension *ext , FILE *stream ) ;
#line 149
void GIFGetColorTable(unsigned char **colors , unsigned int *numColors , struct GIFImage *image___0 ) ;
#line 158
void GIFInitExtension(struct GIFExtension *ext , struct GIFScreen *screen , unsigned int initBufferSize ) ;
#line 165
void GIFDestroyExtension(struct GIFExtension *ext ) ;
#line 173
void GIFGetGraphicCtl(struct GIFGraphicCtlExt *graphicExt , struct GIFExtension *ext ) ;
#line 181
void (*GIFError)(char const   *message ) ;
#line 187
void (*GIFWarning)(char const   *message ) ;
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 49 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void GIFReadNextImage(struct GIFImage *image___0 , FILE *stream ) ;
#line 50
static void GIFReadImageData(struct GIFImage *image___0 , FILE *stream ) ;
#line 51
static int GIFReadDataBlock(unsigned char *buffer___0 , FILE *stream ) ;
#line 52
static void GIFSkipDataBlocks(FILE *stream ) ;
#line 53
static int LZWGetCode(int code_size___0 , int init_flag , FILE *stream ) ;
#line 54
static int LZWReadByte(int init_flag , int input_code_size , FILE *stream ) ;
#line 55
static void GIFReadNextExtension(struct GIFExtension *ext , FILE *stream ) ;
#line 57
static void DefaultError(char const   *message ) ;
#line 58
static void DefaultWarning(char const   *message ) ;
#line 59
static void MemoryError(void) ;
#line 60
static void ReadError(void) ;
#line 82 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void GIFReadScreen(struct GIFScreen *screen , FILE *stream ) 
{ 
  unsigned char buffer___0[7] ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 87
  tmp = fread((void */* __restrict  */)(buffer___0), (size_t )6, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 87
  if (tmp <= 0UL) {
    {
#line 87
    ReadError();
    }
  }
  {
#line 88
  tmp___0 = memcmp((void const   *)(buffer___0), (void const   *)"GIF", (size_t )3);
  }
#line 88
  if (tmp___0 != 0) {
    {
#line 89
    (*GIFError)("Not a GIF file");
    }
  }
  {
#line 90
  tmp___1 = memcmp((void const   *)(buffer___0 + 3), (void const   *)"87a", (size_t )3);
  }
#line 90
  if (tmp___1 != 0) {
    {
#line 90
    tmp___2 = memcmp((void const   *)(buffer___0 + 3), (void const   *)"89a", (size_t )3);
    }
#line 90
    if (tmp___2 != 0) {
      {
#line 92
      (*GIFWarning)("Invalid GIF version number, not \"87a\" or \"89a\"");
      }
    }
  }
  {
#line 95
  tmp___3 = fread((void */* __restrict  */)(buffer___0), (size_t )7, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 95
  if (tmp___3 <= 0UL) {
    {
#line 95
    ReadError();
    }
  }
#line 96
  screen->Width = (unsigned int )((int )*((buffer___0 + 0) + 0) + ((int )*((buffer___0 + 0) + 1) << 8));
#line 97
  screen->Height = (unsigned int )((int )*((buffer___0 + 2) + 0) + ((int )*((buffer___0 + 2) + 1) << 8));
#line 98
  if ((int )buffer___0[4] & 128) {
#line 98
    screen->GlobalColorFlag = 1U;
  } else {
#line 98
    screen->GlobalColorFlag = 0U;
  }
#line 99
  screen->ColorResolution = (unsigned int )((((int )buffer___0[4] & 112) >> 3) + 1);
#line 100
  if ((int )buffer___0[4] & 8) {
#line 100
    screen->SortFlag = 1U;
  } else {
#line 100
    screen->SortFlag = 0U;
  }
#line 101
  screen->GlobalNumColors = (unsigned int )(2 << ((int )buffer___0[4] & 7));
#line 102
  screen->Background = (unsigned int )buffer___0[5];
#line 103
  screen->PixelAspectRatio = (unsigned int )buffer___0[6];
#line 105
  if (screen->GlobalColorFlag) {
    {
#line 108
    tmp___4 = fread((void */* __restrict  */)(screen->GlobalColorTable), (size_t )(3U * screen->GlobalNumColors),
                    (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 108
    if (tmp___4 <= 0UL) {
      {
#line 108
      ReadError();
      }
    }
  }
#line 113
  if (screen->Width == 0U) {
    {
#line 114
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 113
  if (screen->Height == 0U) {
    {
#line 114
    (*GIFError)("Invalid image dimensions");
    }
  }
#line 115
  if (screen->Background > 0U) {
#line 117
    if (screen->GlobalColorFlag) {
#line 117
      if (screen->Background >= screen->GlobalNumColors) {
#line 124
        screen->Background = 0U;
      } else {
#line 117
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 117
    if (! screen->GlobalColorFlag) {
#line 124
      screen->Background = 0U;
    }
  }
#line 127
  return;
}
}
#line 132 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void GIFInitImage(struct GIFImage *image___0 , struct GIFScreen *screen , unsigned char **rows ) 
{ 


  {
#line 135
  image___0->Screen = screen;
#line 136
  image___0->Rows = rows;
#line 137
  return;
}
}
#line 142 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void GIFDestroyImage(struct GIFImage *image___0 ) 
{ 


  {
#line 145
  return;
}
}
#line 150 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
int GIFReadNextBlock(struct GIFImage *image___0 , struct GIFExtension *ext , FILE *stream ) 
{ 
  int ch ;
  int foundBogus ;

  {
#line 156
  foundBogus = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    ch = _IO_getc(stream);
    }
#line 159
    if (ch == -1) {
      {
#line 159
      ReadError();
      }
    }
    {
#line 162
    if (ch == 44) {
#line 162
      goto case_44;
    }
#line 165
    if (ch == 33) {
#line 165
      goto case_33;
    }
#line 168
    if (ch == 59) {
#line 168
      goto case_59;
    }
#line 170
    goto switch_default;
    case_44: /* CIL Label */ 
    {
#line 163
    GIFReadNextImage(image___0, stream);
    }
#line 164
    return (ch);
    case_33: /* CIL Label */ 
    {
#line 166
    GIFReadNextExtension(ext, stream);
    }
#line 167
    return (ch);
    case_59: /* CIL Label */ 
#line 169
    return (ch);
    switch_default: /* CIL Label */ 
#line 171
    if (! foundBogus) {
      {
#line 172
      (*GIFWarning)("Bogus data in GIF");
      }
    }
#line 173
    foundBogus = 1;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 181 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void GIFReadNextImage(struct GIFImage *image___0 , FILE *stream ) 
{ 
  struct GIFScreen *screen ;
  unsigned char buffer___0[9] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 187
  tmp = fread((void */* __restrict  */)(buffer___0), (size_t )9, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 187
  if (tmp <= 0UL) {
    {
#line 187
    ReadError();
    }
  }
#line 188
  if ((unsigned long )image___0 == (unsigned long )((void *)0)) {
    {
#line 190
    GIFSkipDataBlocks(stream);
    }
#line 191
    return;
  }
#line 194
  image___0->LeftPos = (unsigned int )((int )*((buffer___0 + 0) + 0) + ((int )*((buffer___0 + 0) + 1) << 8));
#line 195
  image___0->TopPos = (unsigned int )((int )*((buffer___0 + 2) + 0) + ((int )*((buffer___0 + 2) + 1) << 8));
#line 196
  image___0->Width = (unsigned int )((int )*((buffer___0 + 4) + 0) + ((int )*((buffer___0 + 4) + 1) << 8));
#line 197
  image___0->Height = (unsigned int )((int )*((buffer___0 + 6) + 0) + ((int )*((buffer___0 + 6) + 1) << 8));
#line 198
  if ((int )buffer___0[8] & 128) {
#line 198
    image___0->LocalColorFlag = 1U;
  } else {
#line 198
    image___0->LocalColorFlag = 0U;
  }
#line 199
  if ((int )buffer___0[8] & 64) {
#line 199
    image___0->InterlaceFlag = 1U;
  } else {
#line 199
    image___0->InterlaceFlag = 0U;
  }
#line 200
  if ((int )buffer___0[8] & 32) {
#line 200
    image___0->SortFlag = 1U;
  } else {
#line 200
    image___0->SortFlag = 0U;
  }
#line 201
  if (image___0->LocalColorFlag) {
#line 201
    image___0->LocalNumColors = (unsigned int )(2 << ((int )buffer___0[8] & 7));
  } else {
#line 201
    image___0->LocalNumColors = 0U;
  }
#line 203
  if (image___0->LocalColorFlag) {
    {
#line 206
    tmp___0 = fread((void */* __restrict  */)(image___0->LocalColorTable), (size_t )(3U * image___0->LocalNumColors),
                    (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 206
    if (tmp___0 <= 0UL) {
      {
#line 206
      ReadError();
      }
    }
  }
#line 210
  screen = image___0->Screen;
#line 212
  if (image___0->Width == 0U) {
    {
#line 215
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 212
  if (image___0->Height == 0U) {
    {
#line 215
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 212
  if (image___0->LeftPos + image___0->Width > screen->Width) {
    {
#line 215
    (*GIFError)("Invalid image dimensions");
    }
  } else
#line 212
  if (image___0->TopPos + image___0->Height > screen->Height) {
    {
#line 215
    (*GIFError)("Invalid image dimensions");
    }
  }
  {
#line 217
  GIFReadImageData(image___0, stream);
  }
#line 218
  return;
}
}
#line 220 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void GIFReadImageData(struct GIFImage *image___0 , FILE *stream ) 
{ 
  int minCodeSize ;
  unsigned char **rows ;
  unsigned int width ;
  unsigned int height ;
  unsigned int interlaced ;
  unsigned char *colors ;
  unsigned int numColors ;
  unsigned int xpos ;
  unsigned int ypos ;
  int pass ;
  int val ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 233
  minCodeSize = _IO_getc(stream);
  }
#line 233
  if (minCodeSize == -1) {
    {
#line 233
    ReadError();
    }
  }
#line 234
  if (minCodeSize >= 12) {
    {
#line 235
    (*GIFError)("GIF/LZW error: invalid LZW code size");
    }
  }
  {
#line 237
  tmp = LZWReadByte(1, minCodeSize, stream);
  }
#line 237
  if (tmp < 0) {
    {
#line 238
    (*GIFError)("Error reading GIF image");
    }
  }
#line 241
  rows = image___0->Rows;
#line 242
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
    {
#line 250
    GIFSkipDataBlocks(stream);
    }
#line 252
    return;
  }
  {
#line 255
  width = image___0->Width;
#line 256
  height = image___0->Height;
#line 257
  interlaced = image___0->InterlaceFlag;
#line 258
  GIFGetColorTable(& colors, & numColors, image___0);
#line 259
  ypos = 0U;
#line 259
  xpos = ypos;
#line 260
  pass = 0;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 261
    val = LZWReadByte(0, minCodeSize, stream);
    }
#line 261
    if (! (val >= 0)) {
#line 261
      goto while_break;
    }
#line 263
    if ((unsigned int )val >= numColors) {
      {
#line 265
      (*GIFWarning)("Pixel value out of range");
#line 266
      val = (int )(numColors - 1U);
      }
    }
#line 268
    *(*(rows + ypos) + xpos) = (unsigned char )val;
#line 269
    xpos ++;
#line 269
    if (xpos == width) {
#line 271
      xpos = 0U;
#line 272
      if (interlaced) {
        {
#line 277
        if (pass == 1) {
#line 277
          goto case_1;
        }
#line 277
        if (pass == 0) {
#line 277
          goto case_1;
        }
#line 280
        if (pass == 2) {
#line 280
          goto case_2;
        }
#line 283
        if (pass == 3) {
#line 283
          goto case_3;
        }
#line 274
        goto switch_break;
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 278
        ypos += 8U;
#line 279
        goto switch_break;
        case_2: /* CIL Label */ 
#line 281
        ypos += 4U;
#line 282
        goto switch_break;
        case_3: /* CIL Label */ 
#line 284
        ypos += 2U;
#line 285
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 287
        if (ypos >= height) {
#line 289
          pass ++;
          {
#line 291
          if (pass == 1) {
#line 291
            goto case_1___0;
          }
#line 294
          if (pass == 2) {
#line 294
            goto case_2___0;
          }
#line 297
          if (pass == 3) {
#line 297
            goto case_3___0;
          }
#line 300
          goto switch_default;
          case_1___0: /* CIL Label */ 
#line 292
          ypos = 4U;
#line 293
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
#line 295
          ypos = 2U;
#line 296
          goto switch_break___0;
          case_3___0: /* CIL Label */ 
#line 298
          ypos = 1U;
#line 299
          goto switch_break___0;
          switch_default: /* CIL Label */ 
#line 301
          goto fini;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 306
        ypos ++;
      }
    }
#line 308
    if (ypos >= height) {
#line 309
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  fini: 
  {
#line 313
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 313
    tmp___0 = LZWReadByte(0, minCodeSize, stream);
    }
#line 313
    if (! (tmp___0 >= 0)) {
#line 313
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 318 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int DataBlockSize  =    0;
#line 320 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int GIFReadDataBlock(unsigned char *buffer___0 , FILE *stream ) 
{ 
  int count ;
  size_t tmp ;

  {
  {
#line 324
  count = _IO_getc(stream);
  }
#line 324
  if (count == -1) {
    {
#line 324
    ReadError();
    }
  }
#line 325
  DataBlockSize = count;
#line 326
  if (count > 0) {
    {
#line 328
    tmp = fread((void */* __restrict  */)buffer___0, (size_t )((unsigned int )count),
                (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 328
    if (tmp <= 0UL) {
      {
#line 328
      ReadError();
      }
    }
  }
#line 330
  return (count);
}
}
#line 333 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void GIFSkipDataBlocks(FILE *stream ) 
{ 
  int count ;
  unsigned char buffer___0[256] ;
  size_t tmp ;

  {
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    count = _IO_getc(stream);
    }
#line 340
    if (count == -1) {
      {
#line 340
      ReadError();
      }
    }
#line 341
    if (count > 0) {
      {
#line 343
      tmp = fread((void */* __restrict  */)(buffer___0), (size_t )((unsigned int )count),
                  (size_t )1, (FILE */* __restrict  */)stream);
      }
#line 343
      if (tmp <= 0UL) {
        {
#line 343
        ReadError();
        }
      }
    } else {
#line 346
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 352 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static unsigned char buffer[280]  ;
#line 353 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int curbit  ;
#line 353 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int lastbit  ;
#line 353 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int done  ;
#line 353 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int last_byte  ;
#line 350 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int LZWGetCode(int code_size___0 , int init_flag , FILE *stream ) 
{ 
  int count ;
  int i ;
  int j ;
  int ret ;

  {
#line 356
  if (init_flag) {
#line 358
    curbit = 0;
#line 359
    lastbit = 0;
#line 360
    last_byte = 2;
#line 361
    done = 0;
#line 362
    return (0);
  }
#line 365
  if (curbit + code_size___0 >= lastbit) {
#line 367
    if (done) {
#line 369
      if (curbit >= lastbit) {
        {
#line 370
        (*GIFError)("GIF/LZW error: ran off the end of my bits");
        }
      }
#line 371
      return (-1);
    }
    {
#line 373
    buffer[0] = buffer[last_byte - 2];
#line 374
    buffer[1] = buffer[last_byte - 1];
#line 376
    count = GIFReadDataBlock(& buffer[2], stream);
    }
#line 376
    if (count == 0) {
#line 377
      done = 1;
    }
#line 379
    last_byte = 2 + count;
#line 380
    curbit = (curbit - lastbit) + 16;
#line 381
    lastbit = (2 + count) * 8;
  }
#line 384
  ret = 0;
#line 385
  i = curbit;
#line 385
  j = 0;
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 385
    if (! (j < code_size___0)) {
#line 385
      goto while_break;
    }
#line 386
    ret |= (((int )buffer[i / 8] & (1 << i % 8)) != 0) << j;
#line 385
    i ++;
#line 385
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  curbit += code_size___0;
#line 389
  return (ret);
}
}
#line 394 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int fresh  =    0;
#line 396 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int code_size  ;
#line 396 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int set_code_size  ;
#line 397 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int max_code  ;
#line 397 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int max_code_size  ;
#line 398 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int firstcode  ;
#line 398 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int oldcode  ;
#line 399 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int clear_code  ;
#line 399 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int end_code  ;
#line 400 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int table[2][4096]  ;
#line 401 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int stack[8192]  ;
#line 401 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int *sp  ;
#line 392 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static int LZWReadByte(int init_flag , int input_code_size , FILE *stream ) 
{ 
  int code ;
  int incode ;
  int i ;
  int count ;
  unsigned char buffer___0[260] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 404
  if (init_flag) {
    {
#line 406
    set_code_size = input_code_size;
#line 407
    code_size = set_code_size + 1;
#line 408
    clear_code = 1 << set_code_size;
#line 409
    end_code = clear_code + 1;
#line 410
    max_code_size = 2 * clear_code;
#line 411
    max_code = clear_code + 2;
#line 413
    LZWGetCode(0, 1, stream);
#line 415
    fresh = 1;
#line 417
    i = 0;
    }
    {
#line 417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 417
      if (! (i < clear_code)) {
#line 417
        goto while_break;
      }
#line 419
      table[0][i] = 0;
#line 420
      table[1][i] = i;
#line 417
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 422
      if (! (i <= (1 << 12) - 1)) {
#line 422
        goto while_break___0;
      }
#line 424
      table[0][i] = 0;
#line 425
      table[1][i] = 0;
#line 422
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 428
    sp = stack;
#line 429
    return (0);
  } else
#line 431
  if (fresh) {
#line 433
    fresh = 0;
    {
#line 434
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 436
      oldcode = LZWGetCode(code_size, 0, stream);
#line 436
      firstcode = oldcode;
      }
#line 434
      if (! (firstcode == clear_code)) {
#line 434
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 439
    return (firstcode);
  }
#line 442
  if ((unsigned long )sp > (unsigned long )(stack)) {
#line 443
    sp --;
#line 443
    return (*sp);
  }
  {
#line 445
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 445
    code = LZWGetCode(code_size, 0, stream);
    }
#line 445
    if (! (code >= 0)) {
#line 445
      goto while_break___2;
    }
#line 447
    if (code == clear_code) {
#line 449
      i = 0;
      {
#line 449
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 449
        if (! (i < clear_code)) {
#line 449
          goto while_break___3;
        }
#line 451
        table[0][i] = 0;
#line 452
        table[1][i] = i;
#line 449
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 454
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 454
        if (! (i <= (1 << 12) - 1)) {
#line 454
          goto while_break___4;
        }
#line 456
        table[0][i] = 0;
#line 457
        table[1][i] = 0;
#line 454
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 460
      code_size = set_code_size + 1;
#line 461
      max_code_size = 2 * clear_code;
#line 462
      max_code = clear_code + 2;
#line 463
      sp = stack;
#line 464
      oldcode = LZWGetCode(code_size, 0, stream);
#line 464
      firstcode = oldcode;
      }
#line 466
      return (firstcode);
    } else
#line 468
    if (code == end_code) {
#line 473
      if (DataBlockSize == 0) {
#line 474
        return (-2);
      }
      {
#line 476
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 476
        count = GIFReadDataBlock(buffer___0, stream);
        }
#line 476
        if (! (count > 0)) {
#line 476
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 486
      return (-2);
    }
#line 489
    incode = code;
#line 491
    if (code >= max_code) {
#line 493
      tmp = sp;
#line 493
      sp ++;
#line 493
      *tmp = firstcode;
#line 494
      code = oldcode;
    }
    {
#line 497
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 497
      if (! (code >= clear_code)) {
#line 497
        goto while_break___6;
      }
#line 499
      tmp___0 = sp;
#line 499
      sp ++;
#line 499
      *tmp___0 = table[1][code];
#line 500
      if (code == table[0][code]) {
        {
#line 501
        (*GIFError)("GIF/LZW error: circular table entry");
        }
      }
#line 502
      code = table[0][code];
    }
    while_break___6: /* CIL Label */ ;
    }
#line 505
    tmp___1 = sp;
#line 505
    sp ++;
#line 505
    firstcode = table[1][code];
#line 505
    *tmp___1 = firstcode;
#line 507
    code = max_code;
#line 507
    if (code <= (1 << 12) - 1) {
#line 509
      table[0][code] = oldcode;
#line 510
      table[1][code] = firstcode;
#line 511
      max_code ++;
#line 512
      if (max_code >= max_code_size) {
#line 512
        if (max_code_size <= (1 << 12) - 1) {
#line 514
          max_code_size *= 2;
#line 515
          code_size ++;
        }
      }
    }
#line 519
    oldcode = incode;
#line 521
    if ((unsigned long )sp > (unsigned long )(stack)) {
#line 522
      sp --;
#line 522
      return (*sp);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 524
  return (code);
}
}
#line 536 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static unsigned char DefaultColorTable[24]  = 
#line 536
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)255,      (unsigned char)0,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)255,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)0};
#line 552 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void GIFGetColorTable(unsigned char **colors , unsigned int *numColors , struct GIFImage *image___0 ) 
{ 
  struct GIFScreen *screen ;

  {
#line 557
  if (image___0->LocalColorFlag) {
#line 560
    *colors = image___0->LocalColorTable;
#line 561
    *numColors = image___0->LocalNumColors;
#line 562
    return;
  }
#line 565
  screen = image___0->Screen;
#line 566
  if (screen->GlobalColorFlag) {
#line 569
    *colors = screen->GlobalColorTable;
#line 570
    *numColors = screen->GlobalNumColors;
#line 571
    return;
  }
#line 575
  *colors = DefaultColorTable;
#line 576
  *numColors = (unsigned int )(sizeof(DefaultColorTable) / 3UL);
#line 577
  return;
}
}
#line 582 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void GIFInitExtension(struct GIFExtension *ext , struct GIFScreen *screen , unsigned int initBufferSize ) 
{ 
  unsigned char *newBuffer ;
  void *tmp ;

  {
#line 587
  ext->Screen = screen;
#line 588
  if (initBufferSize > 0U) {
    {
#line 590
    tmp = malloc((size_t )initBufferSize);
#line 590
    newBuffer = (unsigned char *)tmp;
    }
#line 591
    if ((unsigned long )newBuffer == (unsigned long )((void *)0)) {
      {
#line 592
      MemoryError();
      }
    }
#line 593
    ext->Buffer = newBuffer;
#line 594
    ext->BufferSize = initBufferSize;
  } else {
#line 598
    ext->Buffer = (unsigned char *)((void *)0);
#line 599
    ext->BufferSize = 0U;
  }
#line 601
  return;
}
}
#line 606 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void GIFDestroyExtension(struct GIFExtension *ext ) 
{ 


  {
  {
#line 608
  free((void *)ext->Buffer);
  }
#line 609
  return;
}
}
#line 614 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void GIFReadNextExtension(struct GIFExtension *ext , FILE *stream ) 
{ 
  unsigned char *newBuffer ;
  unsigned int newBufferSize ;
  unsigned int offset ;
  unsigned int len ;
  int count ;
  int label ;
  void *tmp ;

  {
  {
#line 621
  label = _IO_getc(stream);
  }
#line 621
  if (label == -1) {
    {
#line 621
    ReadError();
    }
  }
#line 623
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
    {
#line 625
    GIFSkipDataBlocks(stream);
    }
#line 626
    return;
  }
#line 628
  ext->Label = (unsigned char )label;
#line 630
  offset = 0U;
#line 631
  len = ext->BufferSize;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    if (len < 255U) {
      {
#line 636
      newBufferSize = ext->BufferSize + 1024U;
#line 637
      tmp = realloc((void *)ext->Buffer, (size_t )newBufferSize);
#line 637
      newBuffer = (unsigned char *)tmp;
      }
#line 638
      if ((unsigned long )newBuffer == (unsigned long )((void *)0)) {
        {
#line 639
        MemoryError();
        }
      }
#line 640
      ext->BufferSize = newBufferSize;
#line 641
      ext->Buffer = newBuffer;
#line 642
      len += 1024U;
    }
    {
#line 644
    count = GIFReadDataBlock(ext->Buffer + offset, stream);
    }
#line 645
    if (count == 0) {
#line 646
      goto while_break;
    }
#line 647
    offset += (unsigned int )count;
#line 648
    len -= (unsigned int )count;
  }
  while_break: /* CIL Label */ ;
  }
#line 650
  return;
}
}
#line 656 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void GIFGetGraphicCtl(struct GIFGraphicCtlExt *graphicExt , struct GIFExtension *ext ) 
{ 
  unsigned char *buffer___0 ;

  {
#line 662
  if ((int )ext->Label != 249) {
    {
#line 664
    (*GIFWarning)("Not a graphic control extension");
    }
#line 665
    return;
  }
#line 667
  if (ext->BufferSize < 4U) {
    {
#line 669
    (*GIFWarning)("Broken graphic control extension");
    }
#line 670
    return;
  }
#line 673
  buffer___0 = ext->Buffer;
#line 674
  graphicExt->DisposalMethod = (unsigned int )(((int )*(buffer___0 + 0) >> 2) & 7);
#line 675
  graphicExt->InputFlag = (unsigned int )(((int )*(buffer___0 + 0) >> 1) & 1);
#line 676
  graphicExt->TransparentFlag = (unsigned int )((int )*(buffer___0 + 0) & 1);
#line 677
  graphicExt->DelayTime = (unsigned int )((int )*((buffer___0 + 1) + 0) + ((int )*((buffer___0 + 1) + 1) << 8));
#line 678
  graphicExt->Transparent = (unsigned int )*(buffer___0 + 3);
#line 679
  return;
}
}
#line 685 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void DefaultError(char const   *message ) 
{ 


  {
  {
#line 687
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
#line 688
  exit(1);
  }
}
}
#line 694 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void DefaultWarning(char const   *message ) 
{ 


  {
  {
#line 696
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 697
  return;
}
}
#line 702 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void MemoryError(void) 
{ 


  {
  {
#line 704
  (*GIFError)("Out of memory");
  }
#line 705
  return;
}
}
#line 710 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
static void ReadError(void) 
{ 


  {
  {
#line 712
  (*GIFError)("Error reading file or unexpected end of file");
  }
#line 713
  return;
}
}
#line 718 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void (*GIFError)(char const   *message )  =    & DefaultError;
#line 723 "/home/khheo/project/benchmark/optipng-0.7.6/src/gifread/gifread.c"
void (*GIFWarning)(char const   *message )  =    & DefaultWarning;
#line 234 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
char const   *zlibVersion(void) ;
#line 1125
uLong zlibCompileFlags(void) ;
#line 1764
char const   *zError(int err ) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 47 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.h"
char * const  z_errmsg[10] ;
#line 239
voidpf __attribute__((__visibility__("hidden")))  zcalloc(voidpf opaque , unsigned int items ,
                                                          unsigned int size ) ;
#line 241
void __attribute__((__visibility__("hidden")))  zcfree(voidpf opaque , voidpf ptr ) ;
#line 17 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.c"
char * const  z_errmsg[10]  = 
#line 17 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.c"
  {      (char */* const  */)"need dictionary",      (char */* const  */)"stream end",      (char */* const  */)"",      (char */* const  */)"file error", 
        (char */* const  */)"stream error",      (char */* const  */)"data error",      (char */* const  */)"insufficient memory",      (char */* const  */)"buffer error", 
        (char */* const  */)"incompatible version",      (char */* const  */)""};
#line 30 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.c"
char const   *zlibVersion(void) 
{ 


  {
#line 32
  return ("1.2.8-optipng");
}
}
#line 35 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.c"
uLong zlibCompileFlags(void) 
{ 
  uLong flags ;

  {
#line 39
  flags = (uLong )0;
  {
#line 41
  if ((int )sizeof(uInt ) == 2) {
#line 41
    goto case_2;
  }
#line 42
  if ((int )sizeof(uInt ) == 4) {
#line 42
    goto case_4;
  }
#line 43
  if ((int )sizeof(uInt ) == 8) {
#line 43
    goto case_8;
  }
#line 44
  goto switch_default;
  case_2: /* CIL Label */ 
#line 41
  goto switch_break;
  case_4: /* CIL Label */ 
#line 42
  flags ++;
#line 42
  goto switch_break;
  case_8: /* CIL Label */ 
#line 43
  flags += 2UL;
#line 43
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 44
  flags += 3UL;
  switch_break: /* CIL Label */ ;
  }
  {
#line 47
  if ((int )sizeof(uLong ) == 2) {
#line 47
    goto case_2___0;
  }
#line 48
  if ((int )sizeof(uLong ) == 4) {
#line 48
    goto case_4___0;
  }
#line 49
  if ((int )sizeof(uLong ) == 8) {
#line 49
    goto case_8___0;
  }
#line 50
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 47
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 48
  flags += (uLong )(1 << 2);
#line 48
  goto switch_break___0;
  case_8___0: /* CIL Label */ 
#line 49
  flags += (uLong )(2 << 2);
#line 49
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 50
  flags += (uLong )(3 << 2);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 53
  if ((int )sizeof(voidpf ) == 2) {
#line 53
    goto case_2___1;
  }
#line 54
  if ((int )sizeof(voidpf ) == 4) {
#line 54
    goto case_4___1;
  }
#line 55
  if ((int )sizeof(voidpf ) == 8) {
#line 55
    goto case_8___1;
  }
#line 56
  goto switch_default___1;
  case_2___1: /* CIL Label */ 
#line 53
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 54
  flags += (uLong )(1 << 4);
#line 54
  goto switch_break___1;
  case_8___1: /* CIL Label */ 
#line 55
  flags += (uLong )(2 << 4);
#line 55
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 56
  flags += (uLong )(3 << 4);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 59
  if ((int )sizeof(off_t ) == 2) {
#line 59
    goto case_2___2;
  }
#line 60
  if ((int )sizeof(off_t ) == 4) {
#line 60
    goto case_4___2;
  }
#line 61
  if ((int )sizeof(off_t ) == 8) {
#line 61
    goto case_8___2;
  }
#line 62
  goto switch_default___2;
  case_2___2: /* CIL Label */ 
#line 59
  goto switch_break___2;
  case_4___2: /* CIL Label */ 
#line 60
  flags += (uLong )(1 << 6);
#line 60
  goto switch_break___2;
  case_8___2: /* CIL Label */ 
#line 61
  flags += (uLong )(2 << 6);
#line 61
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 62
  flags += (uLong )(3 << 6);
  switch_break___2: /* CIL Label */ ;
  }
#line 80
  flags += (uLong )(1L << 16);
#line 83
  flags += (uLong )(1L << 17);
#line 115
  return (flags);
}
}
#line 136 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.c"
char const   *zError(int err ) 
{ 


  {
#line 139
  return ((char const   *)z_errmsg[2 - err]);
}
}
#line 304 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.c"
voidpf __attribute__((__visibility__("hidden")))  zcalloc(voidpf opaque , unsigned int items ,
                                                          unsigned int size ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  voidpf tmp___1 ;

  {
#line 309
  if (opaque) {
#line 309
    items += size - size;
  }
#line 310
  if (sizeof(uInt ) > 2UL) {
    {
#line 310
    tmp = malloc((size_t )(items * size));
#line 310
    tmp___1 = tmp;
    }
  } else {
    {
#line 310
    tmp___0 = calloc((size_t )items, (size_t )size);
#line 310
    tmp___1 = tmp___0;
    }
  }
#line 310
  return ((voidpf __attribute__((__visibility__("hidden")))  )tmp___1);
}
}
#line 314 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zutil.c"
void __attribute__((__visibility__("hidden")))  zcfree(voidpf opaque , voidpf ptr ) 
{ 


  {
  {
#line 318
  free(ptr);
  }
#line 319
  if (opaque) {
#line 319
    return;
  }
#line 320
  return;
}
}
#line 410 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
int inflate(z_streamp strm , int flush ) ;
#line 526
int inflateEnd(z_streamp strm ) ;
#line 1215
int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1653
int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/uncompr.c"
int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) 
{ 
  z_stream stream ;
  int err ;

  {
#line 33
  stream.next_in = (Bytef *)source;
#line 34
  stream.avail_in = (uInt )sourceLen;
#line 36
  if ((uLong )stream.avail_in != sourceLen) {
#line 36
    return (-5);
  }
#line 38
  stream.next_out = dest;
#line 39
  stream.avail_out = (uInt )*destLen;
#line 40
  if ((uLong )stream.avail_out != *destLen) {
#line 40
    return (-5);
  }
  {
#line 42
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 43
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 45
  err = inflateInit_(& stream, "1.2.8-optipng", (int )sizeof(z_stream ));
  }
#line 46
  if (err != 0) {
#line 46
    return (err);
  }
  {
#line 48
  err = inflate(& stream, 4);
  }
#line 49
  if (err != 1) {
    {
#line 50
    inflateEnd(& stream);
    }
#line 51
    if (err == 2) {
#line 52
      return (-3);
    } else
#line 51
    if (err == -5) {
#line 51
      if (stream.avail_in == 0U) {
#line 52
        return (-3);
      }
    }
#line 53
    return (err);
  }
  {
#line 55
  *destLen = stream.total_out;
#line 57
  err = inflateEnd(& stream);
  }
#line 58
  return (err);
}
}
#line 296 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.h"
void __attribute__((__visibility__("hidden")))  _tr_init(deflate_state *s ) ;
#line 297
int __attribute__((__visibility__("hidden")))  _tr_tally(deflate_state *s , unsigned int dist ,
                                                         unsigned int lc ) ;
#line 298
void __attribute__((__visibility__("hidden")))  _tr_flush_block(deflate_state *s ,
                                                                charf *buf , ulg stored_len ,
                                                                int last ) ;
#line 300
void __attribute__((__visibility__("hidden")))  _tr_flush_bits(deflate_state *s ) ;
#line 301
void __attribute__((__visibility__("hidden")))  _tr_align(deflate_state *s ) ;
#line 302
void __attribute__((__visibility__("hidden")))  _tr_stored_block(deflate_state *s ,
                                                                 charf *buf , ulg stored_len ,
                                                                 int last ) ;
#line 319
uch const __attribute__((__visibility__("hidden")))  _length_code[256] ;
#line 320
uch const __attribute__((__visibility__("hidden")))  _dist_code[512] ;
#line 62 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static int const   extra_lbits[29]  = 
#line 62 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )0};
#line 65 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static int const   extra_dbits[30]  = 
#line 65
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )6,      (int const   )6, 
        (int const   )7,      (int const   )7,      (int const   )8,      (int const   )8, 
        (int const   )9,      (int const   )9,      (int const   )10,      (int const   )10, 
        (int const   )11,      (int const   )11,      (int const   )12,      (int const   )12, 
        (int const   )13,      (int const   )13};
#line 68 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static int const   extra_blbits[19]  = 
#line 68
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )2,      (int const   )3,      (int const   )7};
#line 71 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static uch const   bl_order[19]  = 
#line 71
  {      (uch const   )16,      (uch const   )17,      (uch const   )18,      (uch const   )0, 
        (uch const   )8,      (uch const   )7,      (uch const   )9,      (uch const   )6, 
        (uch const   )10,      (uch const   )5,      (uch const   )11,      (uch const   )4, 
        (uch const   )12,      (uch const   )3,      (uch const   )13,      (uch const   )2, 
        (uch const   )14,      (uch const   )1,      (uch const   )15};
#line 3 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.h"
static ct_data const   static_ltree[288]  = 
#line 3 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.h"
  {      {{(ush )12}, {(ush )8}}, 
        {{(ush )140}, {(ush )8}}, 
        {{(ush )76}, {(ush )8}}, 
        {{(ush )204}, {(ush )8}}, 
        {{(ush )44}, {(ush )8}}, 
        {{(ush )172}, {(ush )8}}, 
        {{(ush )108}, {(ush )8}}, 
        {{(ush )236}, {(ush )8}}, 
        {{(ush )28}, {(ush )8}}, 
        {{(ush )156}, {(ush )8}}, 
        {{(ush )92}, {(ush )8}}, 
        {{(ush )220}, {(ush )8}}, 
        {{(ush )60}, {(ush )8}}, 
        {{(ush )188}, {(ush )8}}, 
        {{(ush )124}, {(ush )8}}, 
        {{(ush )252}, {(ush )8}}, 
        {{(ush )2}, {(ush )8}}, 
        {{(ush )130}, {(ush )8}}, 
        {{(ush )66}, {(ush )8}}, 
        {{(ush )194}, {(ush )8}}, 
        {{(ush )34}, {(ush )8}}, 
        {{(ush )162}, {(ush )8}}, 
        {{(ush )98}, {(ush )8}}, 
        {{(ush )226}, {(ush )8}}, 
        {{(ush )18}, {(ush )8}}, 
        {{(ush )146}, {(ush )8}}, 
        {{(ush )82}, {(ush )8}}, 
        {{(ush )210}, {(ush )8}}, 
        {{(ush )50}, {(ush )8}}, 
        {{(ush )178}, {(ush )8}}, 
        {{(ush )114}, {(ush )8}}, 
        {{(ush )242}, {(ush )8}}, 
        {{(ush )10}, {(ush )8}}, 
        {{(ush )138}, {(ush )8}}, 
        {{(ush )74}, {(ush )8}}, 
        {{(ush )202}, {(ush )8}}, 
        {{(ush )42}, {(ush )8}}, 
        {{(ush )170}, {(ush )8}}, 
        {{(ush )106}, {(ush )8}}, 
        {{(ush )234}, {(ush )8}}, 
        {{(ush )26}, {(ush )8}}, 
        {{(ush )154}, {(ush )8}}, 
        {{(ush )90}, {(ush )8}}, 
        {{(ush )218}, {(ush )8}}, 
        {{(ush )58}, {(ush )8}}, 
        {{(ush )186}, {(ush )8}}, 
        {{(ush )122}, {(ush )8}}, 
        {{(ush )250}, {(ush )8}}, 
        {{(ush )6}, {(ush )8}}, 
        {{(ush )134}, {(ush )8}}, 
        {{(ush )70}, {(ush )8}}, 
        {{(ush )198}, {(ush )8}}, 
        {{(ush )38}, {(ush )8}}, 
        {{(ush )166}, {(ush )8}}, 
        {{(ush )102}, {(ush )8}}, 
        {{(ush )230}, {(ush )8}}, 
        {{(ush )22}, {(ush )8}}, 
        {{(ush )150}, {(ush )8}}, 
        {{(ush )86}, {(ush )8}}, 
        {{(ush )214}, {(ush )8}}, 
        {{(ush )54}, {(ush )8}}, 
        {{(ush )182}, {(ush )8}}, 
        {{(ush )118}, {(ush )8}}, 
        {{(ush )246}, {(ush )8}}, 
        {{(ush )14}, {(ush )8}}, 
        {{(ush )142}, {(ush )8}}, 
        {{(ush )78}, {(ush )8}}, 
        {{(ush )206}, {(ush )8}}, 
        {{(ush )46}, {(ush )8}}, 
        {{(ush )174}, {(ush )8}}, 
        {{(ush )110}, {(ush )8}}, 
        {{(ush )238}, {(ush )8}}, 
        {{(ush )30}, {(ush )8}}, 
        {{(ush )158}, {(ush )8}}, 
        {{(ush )94}, {(ush )8}}, 
        {{(ush )222}, {(ush )8}}, 
        {{(ush )62}, {(ush )8}}, 
        {{(ush )190}, {(ush )8}}, 
        {{(ush )126}, {(ush )8}}, 
        {{(ush )254}, {(ush )8}}, 
        {{(ush )1}, {(ush )8}}, 
        {{(ush )129}, {(ush )8}}, 
        {{(ush )65}, {(ush )8}}, 
        {{(ush )193}, {(ush )8}}, 
        {{(ush )33}, {(ush )8}}, 
        {{(ush )161}, {(ush )8}}, 
        {{(ush )97}, {(ush )8}}, 
        {{(ush )225}, {(ush )8}}, 
        {{(ush )17}, {(ush )8}}, 
        {{(ush )145}, {(ush )8}}, 
        {{(ush )81}, {(ush )8}}, 
        {{(ush )209}, {(ush )8}}, 
        {{(ush )49}, {(ush )8}}, 
        {{(ush )177}, {(ush )8}}, 
        {{(ush )113}, {(ush )8}}, 
        {{(ush )241}, {(ush )8}}, 
        {{(ush )9}, {(ush )8}}, 
        {{(ush )137}, {(ush )8}}, 
        {{(ush )73}, {(ush )8}}, 
        {{(ush )201}, {(ush )8}}, 
        {{(ush )41}, {(ush )8}}, 
        {{(ush )169}, {(ush )8}}, 
        {{(ush )105}, {(ush )8}}, 
        {{(ush )233}, {(ush )8}}, 
        {{(ush )25}, {(ush )8}}, 
        {{(ush )153}, {(ush )8}}, 
        {{(ush )89}, {(ush )8}}, 
        {{(ush )217}, {(ush )8}}, 
        {{(ush )57}, {(ush )8}}, 
        {{(ush )185}, {(ush )8}}, 
        {{(ush )121}, {(ush )8}}, 
        {{(ush )249}, {(ush )8}}, 
        {{(ush )5}, {(ush )8}}, 
        {{(ush )133}, {(ush )8}}, 
        {{(ush )69}, {(ush )8}}, 
        {{(ush )197}, {(ush )8}}, 
        {{(ush )37}, {(ush )8}}, 
        {{(ush )165}, {(ush )8}}, 
        {{(ush )101}, {(ush )8}}, 
        {{(ush )229}, {(ush )8}}, 
        {{(ush )21}, {(ush )8}}, 
        {{(ush )149}, {(ush )8}}, 
        {{(ush )85}, {(ush )8}}, 
        {{(ush )213}, {(ush )8}}, 
        {{(ush )53}, {(ush )8}}, 
        {{(ush )181}, {(ush )8}}, 
        {{(ush )117}, {(ush )8}}, 
        {{(ush )245}, {(ush )8}}, 
        {{(ush )13}, {(ush )8}}, 
        {{(ush )141}, {(ush )8}}, 
        {{(ush )77}, {(ush )8}}, 
        {{(ush )205}, {(ush )8}}, 
        {{(ush )45}, {(ush )8}}, 
        {{(ush )173}, {(ush )8}}, 
        {{(ush )109}, {(ush )8}}, 
        {{(ush )237}, {(ush )8}}, 
        {{(ush )29}, {(ush )8}}, 
        {{(ush )157}, {(ush )8}}, 
        {{(ush )93}, {(ush )8}}, 
        {{(ush )221}, {(ush )8}}, 
        {{(ush )61}, {(ush )8}}, 
        {{(ush )189}, {(ush )8}}, 
        {{(ush )125}, {(ush )8}}, 
        {{(ush )253}, {(ush )8}}, 
        {{(ush )19}, {(ush )9}}, 
        {{(ush )275}, {(ush )9}}, 
        {{(ush )147}, {(ush )9}}, 
        {{(ush )403}, {(ush )9}}, 
        {{(ush )83}, {(ush )9}}, 
        {{(ush )339}, {(ush )9}}, 
        {{(ush )211}, {(ush )9}}, 
        {{(ush )467}, {(ush )9}}, 
        {{(ush )51}, {(ush )9}}, 
        {{(ush )307}, {(ush )9}}, 
        {{(ush )179}, {(ush )9}}, 
        {{(ush )435}, {(ush )9}}, 
        {{(ush )115}, {(ush )9}}, 
        {{(ush )371}, {(ush )9}}, 
        {{(ush )243}, {(ush )9}}, 
        {{(ush )499}, {(ush )9}}, 
        {{(ush )11}, {(ush )9}}, 
        {{(ush )267}, {(ush )9}}, 
        {{(ush )139}, {(ush )9}}, 
        {{(ush )395}, {(ush )9}}, 
        {{(ush )75}, {(ush )9}}, 
        {{(ush )331}, {(ush )9}}, 
        {{(ush )203}, {(ush )9}}, 
        {{(ush )459}, {(ush )9}}, 
        {{(ush )43}, {(ush )9}}, 
        {{(ush )299}, {(ush )9}}, 
        {{(ush )171}, {(ush )9}}, 
        {{(ush )427}, {(ush )9}}, 
        {{(ush )107}, {(ush )9}}, 
        {{(ush )363}, {(ush )9}}, 
        {{(ush )235}, {(ush )9}}, 
        {{(ush )491}, {(ush )9}}, 
        {{(ush )27}, {(ush )9}}, 
        {{(ush )283}, {(ush )9}}, 
        {{(ush )155}, {(ush )9}}, 
        {{(ush )411}, {(ush )9}}, 
        {{(ush )91}, {(ush )9}}, 
        {{(ush )347}, {(ush )9}}, 
        {{(ush )219}, {(ush )9}}, 
        {{(ush )475}, {(ush )9}}, 
        {{(ush )59}, {(ush )9}}, 
        {{(ush )315}, {(ush )9}}, 
        {{(ush )187}, {(ush )9}}, 
        {{(ush )443}, {(ush )9}}, 
        {{(ush )123}, {(ush )9}}, 
        {{(ush )379}, {(ush )9}}, 
        {{(ush )251}, {(ush )9}}, 
        {{(ush )507}, {(ush )9}}, 
        {{(ush )7}, {(ush )9}}, 
        {{(ush )263}, {(ush )9}}, 
        {{(ush )135}, {(ush )9}}, 
        {{(ush )391}, {(ush )9}}, 
        {{(ush )71}, {(ush )9}}, 
        {{(ush )327}, {(ush )9}}, 
        {{(ush )199}, {(ush )9}}, 
        {{(ush )455}, {(ush )9}}, 
        {{(ush )39}, {(ush )9}}, 
        {{(ush )295}, {(ush )9}}, 
        {{(ush )167}, {(ush )9}}, 
        {{(ush )423}, {(ush )9}}, 
        {{(ush )103}, {(ush )9}}, 
        {{(ush )359}, {(ush )9}}, 
        {{(ush )231}, {(ush )9}}, 
        {{(ush )487}, {(ush )9}}, 
        {{(ush )23}, {(ush )9}}, 
        {{(ush )279}, {(ush )9}}, 
        {{(ush )151}, {(ush )9}}, 
        {{(ush )407}, {(ush )9}}, 
        {{(ush )87}, {(ush )9}}, 
        {{(ush )343}, {(ush )9}}, 
        {{(ush )215}, {(ush )9}}, 
        {{(ush )471}, {(ush )9}}, 
        {{(ush )55}, {(ush )9}}, 
        {{(ush )311}, {(ush )9}}, 
        {{(ush )183}, {(ush )9}}, 
        {{(ush )439}, {(ush )9}}, 
        {{(ush )119}, {(ush )9}}, 
        {{(ush )375}, {(ush )9}}, 
        {{(ush )247}, {(ush )9}}, 
        {{(ush )503}, {(ush )9}}, 
        {{(ush )15}, {(ush )9}}, 
        {{(ush )271}, {(ush )9}}, 
        {{(ush )143}, {(ush )9}}, 
        {{(ush )399}, {(ush )9}}, 
        {{(ush )79}, {(ush )9}}, 
        {{(ush )335}, {(ush )9}}, 
        {{(ush )207}, {(ush )9}}, 
        {{(ush )463}, {(ush )9}}, 
        {{(ush )47}, {(ush )9}}, 
        {{(ush )303}, {(ush )9}}, 
        {{(ush )175}, {(ush )9}}, 
        {{(ush )431}, {(ush )9}}, 
        {{(ush )111}, {(ush )9}}, 
        {{(ush )367}, {(ush )9}}, 
        {{(ush )239}, {(ush )9}}, 
        {{(ush )495}, {(ush )9}}, 
        {{(ush )31}, {(ush )9}}, 
        {{(ush )287}, {(ush )9}}, 
        {{(ush )159}, {(ush )9}}, 
        {{(ush )415}, {(ush )9}}, 
        {{(ush )95}, {(ush )9}}, 
        {{(ush )351}, {(ush )9}}, 
        {{(ush )223}, {(ush )9}}, 
        {{(ush )479}, {(ush )9}}, 
        {{(ush )63}, {(ush )9}}, 
        {{(ush )319}, {(ush )9}}, 
        {{(ush )191}, {(ush )9}}, 
        {{(ush )447}, {(ush )9}}, 
        {{(ush )127}, {(ush )9}}, 
        {{(ush )383}, {(ush )9}}, 
        {{(ush )255}, {(ush )9}}, 
        {{(ush )511}, {(ush )9}}, 
        {{(ush )0}, {(ush )7}}, 
        {{(ush )64}, {(ush )7}}, 
        {{(ush )32}, {(ush )7}}, 
        {{(ush )96}, {(ush )7}}, 
        {{(ush )16}, {(ush )7}}, 
        {{(ush )80}, {(ush )7}}, 
        {{(ush )48}, {(ush )7}}, 
        {{(ush )112}, {(ush )7}}, 
        {{(ush )8}, {(ush )7}}, 
        {{(ush )72}, {(ush )7}}, 
        {{(ush )40}, {(ush )7}}, 
        {{(ush )104}, {(ush )7}}, 
        {{(ush )24}, {(ush )7}}, 
        {{(ush )88}, {(ush )7}}, 
        {{(ush )56}, {(ush )7}}, 
        {{(ush )120}, {(ush )7}}, 
        {{(ush )4}, {(ush )7}}, 
        {{(ush )68}, {(ush )7}}, 
        {{(ush )36}, {(ush )7}}, 
        {{(ush )100}, {(ush )7}}, 
        {{(ush )20}, {(ush )7}}, 
        {{(ush )84}, {(ush )7}}, 
        {{(ush )52}, {(ush )7}}, 
        {{(ush )116}, {(ush )7}}, 
        {{(ush )3}, {(ush )8}}, 
        {{(ush )131}, {(ush )8}}, 
        {{(ush )67}, {(ush )8}}, 
        {{(ush )195}, {(ush )8}}, 
        {{(ush )35}, {(ush )8}}, 
        {{(ush )163}, {(ush )8}}, 
        {{(ush )99}, {(ush )8}}, 
        {{(ush )227}, {(ush )8}}};
#line 64 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.h"
static ct_data const   static_dtree[30]  = 
#line 64
  {      {{(ush )0}, {(ush )5}}, 
        {{(ush )16}, {(ush )5}}, 
        {{(ush )8}, {(ush )5}}, 
        {{(ush )24}, {(ush )5}}, 
        {{(ush )4}, {(ush )5}}, 
        {{(ush )20}, {(ush )5}}, 
        {{(ush )12}, {(ush )5}}, 
        {{(ush )28}, {(ush )5}}, 
        {{(ush )2}, {(ush )5}}, 
        {{(ush )18}, {(ush )5}}, 
        {{(ush )10}, {(ush )5}}, 
        {{(ush )26}, {(ush )5}}, 
        {{(ush )6}, {(ush )5}}, 
        {{(ush )22}, {(ush )5}}, 
        {{(ush )14}, {(ush )5}}, 
        {{(ush )30}, {(ush )5}}, 
        {{(ush )1}, {(ush )5}}, 
        {{(ush )17}, {(ush )5}}, 
        {{(ush )9}, {(ush )5}}, 
        {{(ush )25}, {(ush )5}}, 
        {{(ush )5}, {(ush )5}}, 
        {{(ush )21}, {(ush )5}}, 
        {{(ush )13}, {(ush )5}}, 
        {{(ush )29}, {(ush )5}}, 
        {{(ush )3}, {(ush )5}}, 
        {{(ush )19}, {(ush )5}}, 
        {{(ush )11}, {(ush )5}}, 
        {{(ush )27}, {(ush )5}}, 
        {{(ush )7}, {(ush )5}}, 
        {{(ush )23}, {(ush )5}}};
#line 73 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.h"
uch const __attribute__((__visibility__("hidden")))  _dist_code[512]  = 
#line 73
  {      (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )1,      (uch const __attribute__((__visibility__("hidden")))  )2,      (uch const __attribute__((__visibility__("hidden")))  )3, 
        (uch const __attribute__((__visibility__("hidden")))  )4,      (uch const __attribute__((__visibility__("hidden")))  )4,      (uch const __attribute__((__visibility__("hidden")))  )5,      (uch const __attribute__((__visibility__("hidden")))  )5, 
        (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )6, 
        (uch const __attribute__((__visibility__("hidden")))  )7,      (uch const __attribute__((__visibility__("hidden")))  )7,      (uch const __attribute__((__visibility__("hidden")))  )7,      (uch const __attribute__((__visibility__("hidden")))  )7, 
        (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8, 
        (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8, 
        (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9, 
        (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )17, 
        (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29};
#line 102 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.h"
uch const __attribute__((__visibility__("hidden")))  _length_code[256]  = 
#line 102
  {      (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )1,      (uch const __attribute__((__visibility__("hidden")))  )2,      (uch const __attribute__((__visibility__("hidden")))  )3, 
        (uch const __attribute__((__visibility__("hidden")))  )4,      (uch const __attribute__((__visibility__("hidden")))  )5,      (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )7, 
        (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16, 
        (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16, 
        (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17, 
        (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17, 
        (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18, 
        (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18, 
        (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19, 
        (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )28};
#line 118 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.h"
static int const   base_length[29]  = 
#line 118
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )6,      (int const   )7, 
        (int const   )8,      (int const   )10,      (int const   )12,      (int const   )14, 
        (int const   )16,      (int const   )20,      (int const   )24,      (int const   )28, 
        (int const   )32,      (int const   )40,      (int const   )48,      (int const   )56, 
        (int const   )64,      (int const   )80,      (int const   )96,      (int const   )112, 
        (int const   )128,      (int const   )160,      (int const   )192,      (int const   )224, 
        (int const   )0};
#line 123 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.h"
static int const   base_dist[30]  = 
#line 123
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )6,      (int const   )8,      (int const   )12, 
        (int const   )16,      (int const   )24,      (int const   )32,      (int const   )48, 
        (int const   )64,      (int const   )96,      (int const   )128,      (int const   )192, 
        (int const   )256,      (int const   )384,      (int const   )512,      (int const   )768, 
        (int const   )1024,      (int const   )1536,      (int const   )2048,      (int const   )3072, 
        (int const   )4096,      (int const   )6144,      (int const   )8192,      (int const   )12288, 
        (int const   )16384,      (int const   )24576};
#line 125 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static static_tree_desc static_l_desc  =    {static_ltree, extra_lbits, 257, 286, 15};
#line 128 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static static_tree_desc static_d_desc  =    {static_dtree, extra_dbits, 0, 30, 15};
#line 131 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static static_tree_desc static_bl_desc  =    {(ct_data const   *)0, extra_blbits, 0, 19, 7};
#line 138
static void tr_static_init(void) ;
#line 139
static void init_block(deflate_state *s ) ;
#line 140
static void pqdownheap(deflate_state *s , ct_data *tree , int k ) ;
#line 141
static void gen_bitlen(deflate_state *s , tree_desc *desc ) ;
#line 142
static void gen_codes(ct_data *tree , int max_code___0 , ushf *bl_count ) ;
#line 143
static void build_tree(deflate_state *s , tree_desc *desc ) ;
#line 144
static void scan_tree(deflate_state *s , ct_data *tree , int max_code___0 ) ;
#line 145
static void send_tree(deflate_state *s , ct_data *tree , int max_code___0 ) ;
#line 146
static int build_bl_tree(deflate_state *s ) ;
#line 147
static void send_all_trees(deflate_state *s , int lcodes , int dcodes , int blcodes ) ;
#line 149
static void compress_block(deflate_state *s , ct_data const   *ltree , ct_data const   *dtree ) ;
#line 151
static int detect_data_type(deflate_state *s ) ;
#line 152
static unsigned int bi_reverse(unsigned int code , int len ) ;
#line 153
static void bi_windup(deflate_state *s ) ;
#line 154
static void bi_flush(deflate_state *s ) ;
#line 155
static void copy_block(deflate_state *s , charf *buf , unsigned int len , int header ) ;
#line 234 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void tr_static_init(void) 
{ 


  {
#line 314
  return;
}
}
#line 381 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_init(deflate_state *s ) 
{ 


  {
  {
#line 384
  tr_static_init();
#line 386
  s->l_desc.dyn_tree = s->dyn_ltree;
#line 387
  s->l_desc.stat_desc = & static_l_desc;
#line 389
  s->d_desc.dyn_tree = s->dyn_dtree;
#line 390
  s->d_desc.stat_desc = & static_d_desc;
#line 392
  s->bl_desc.dyn_tree = s->bl_tree;
#line 393
  s->bl_desc.stat_desc = & static_bl_desc;
#line 395
  s->bi_buf = (ush )0;
#line 396
  s->bi_valid = 0;
#line 403
  init_block(s);
  }
#line 404
  return;
}
}
#line 409 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void init_block(deflate_state *s ) 
{ 
  int n ;
  ulg tmp ;
  uInt tmp___0 ;

  {
#line 415
  n = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (n < 286)) {
#line 415
      goto while_break;
    }
#line 415
    s->dyn_ltree[n].fc.freq = (ush )0;
#line 415
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  n = 0;
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 416
    if (! (n < 30)) {
#line 416
      goto while_break___0;
    }
#line 416
    s->dyn_dtree[n].fc.freq = (ush )0;
#line 416
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 417
  n = 0;
  {
#line 417
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 417
    if (! (n < 19)) {
#line 417
      goto while_break___1;
    }
#line 417
    s->bl_tree[n].fc.freq = (ush )0;
#line 417
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 419
  s->dyn_ltree[256].fc.freq = (ush )1;
#line 420
  tmp = (ulg )0L;
#line 420
  s->static_len = tmp;
#line 420
  s->opt_len = tmp;
#line 421
  tmp___0 = (uInt )0;
#line 421
  s->matches = tmp___0;
#line 421
  s->last_lit = tmp___0;
#line 422
  return;
}
}
#line 453 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void pqdownheap(deflate_state *s , ct_data *tree , int k ) 
{ 
  int v ;
  int j ;

  {
#line 458
  v = s->heap[k];
#line 459
  j = k << 1;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (j <= s->heap_len)) {
#line 460
      goto while_break;
    }
#line 462
    if (j < s->heap_len) {
#line 462
      if ((int )(tree + s->heap[j + 1])->fc.freq < (int )(tree + s->heap[j])->fc.freq) {
#line 464
        j ++;
      } else
#line 462
      if ((int )(tree + s->heap[j + 1])->fc.freq == (int )(tree + s->heap[j])->fc.freq) {
#line 462
        if ((int )s->depth[s->heap[j + 1]] <= (int )s->depth[s->heap[j]]) {
#line 464
          j ++;
        }
      }
    }
#line 467
    if ((int )(tree + v)->fc.freq < (int )(tree + s->heap[j])->fc.freq) {
#line 467
      goto while_break;
    } else
#line 467
    if ((int )(tree + v)->fc.freq == (int )(tree + s->heap[j])->fc.freq) {
#line 467
      if ((int )s->depth[v] <= (int )s->depth[s->heap[j]]) {
#line 467
        goto while_break;
      }
    }
#line 470
    s->heap[k] = s->heap[j];
#line 470
    k = j;
#line 473
    j <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  s->heap[k] = v;
#line 476
  return;
}
}
#line 488 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void gen_bitlen(deflate_state *s , tree_desc *desc ) 
{ 
  ct_data *tree ;
  int max_code___0 ;
  ct_data const   *stree ;
  intf const   *extra ;
  int base ;
  int max_length ;
  int h ;
  int n ;
  int m ;
  int bits ;
  int xbits ;
  ush f ;
  int overflow ;

  {
#line 492
  tree = desc->dyn_tree;
#line 493
  max_code___0 = desc->max_code;
#line 494
  stree = (desc->stat_desc)->static_tree;
#line 495
  extra = (desc->stat_desc)->extra_bits;
#line 496
  base = (desc->stat_desc)->extra_base;
#line 497
  max_length = (desc->stat_desc)->max_length;
#line 503
  overflow = 0;
#line 505
  bits = 0;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (bits <= 15)) {
#line 505
      goto while_break;
    }
#line 505
    s->bl_count[bits] = (ush )0;
#line 505
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  (tree + s->heap[s->heap_max])->dl.len = (ush )0;
#line 512
  h = s->heap_max + 1;
  {
#line 512
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 512
    if (! (h < 573)) {
#line 512
      goto while_break___0;
    }
#line 513
    n = s->heap[h];
#line 514
    bits = (int )(tree + (tree + n)->dl.dad)->dl.len + 1;
#line 515
    if (bits > max_length) {
#line 515
      bits = max_length;
#line 515
      overflow ++;
    }
#line 516
    (tree + n)->dl.len = (ush )bits;
#line 519
    if (n > max_code___0) {
#line 519
      goto __Cont;
    }
#line 521
    s->bl_count[bits] = (ush )((int )s->bl_count[bits] + 1);
#line 522
    xbits = 0;
#line 523
    if (n >= base) {
#line 523
      xbits = (int )*(extra + (n - base));
    }
#line 524
    f = (tree + n)->fc.freq;
#line 525
    s->opt_len += (ulg )f * (ulg )(bits + xbits);
#line 526
    if (stree) {
#line 526
      s->static_len += (ulg )f * (ulg )((int const   )(stree + n)->dl.len + (int const   )xbits);
    }
    __Cont: /* CIL Label */ 
#line 512
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 528
  if (overflow == 0) {
#line 528
    return;
  }
  {
#line 534
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 535
    bits = max_length - 1;
    {
#line 536
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 536
      if (! ((int )s->bl_count[bits] == 0)) {
#line 536
        goto while_break___2;
      }
#line 536
      bits --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 537
    s->bl_count[bits] = (ush )((int )s->bl_count[bits] - 1);
#line 538
    s->bl_count[bits + 1] = (ush )((int )s->bl_count[bits + 1] + 2);
#line 539
    s->bl_count[max_length] = (ush )((int )s->bl_count[max_length] - 1);
#line 543
    overflow -= 2;
#line 534
    if (! (overflow > 0)) {
#line 534
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 551
  bits = max_length;
  {
#line 551
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 551
    if (! (bits != 0)) {
#line 551
      goto while_break___3;
    }
#line 552
    n = (int )s->bl_count[bits];
    {
#line 553
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 553
      if (! (n != 0)) {
#line 553
        goto while_break___4;
      }
#line 554
      h --;
#line 554
      m = s->heap[h];
#line 555
      if (m > max_code___0) {
#line 555
        goto while_continue___4;
      }
#line 556
      if ((unsigned int )(tree + m)->dl.len != (unsigned int )bits) {
#line 558
        s->opt_len += (ulg )(((long )bits - (long )(tree + m)->dl.len) * (long )(tree + m)->fc.freq);
#line 560
        (tree + m)->dl.len = (ush )bits;
      }
#line 562
      n --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 551
    bits --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 565
  return;
}
}
#line 575 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void gen_codes(ct_data *tree , int max_code___0 , ushf *bl_count ) 
{ 
  ush next_code[16] ;
  ush code ;
  int bits ;
  int n ;
  int len ;
  ush tmp ;
  unsigned int tmp___0 ;

  {
#line 581
  code = (ush )0;
#line 588
  bits = 1;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! (bits <= 15)) {
#line 588
      goto while_break;
    }
#line 589
    code = (ush )(((int )code + (int )*(bl_count + (bits - 1))) << 1);
#line 589
    next_code[bits] = code;
#line 588
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 598
  n = 0;
  {
#line 598
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 598
    if (! (n <= max_code___0)) {
#line 598
      goto while_break___0;
    }
#line 599
    len = (int )(tree + n)->dl.len;
#line 600
    if (len == 0) {
#line 600
      goto __Cont;
    }
    {
#line 602
    tmp = next_code[len];
#line 602
    next_code[len] = (ush )((int )next_code[len] + 1);
#line 602
    tmp___0 = bi_reverse((unsigned int )tmp, len);
#line 602
    (tree + n)->fc.code = (ush )tmp___0;
    }
    __Cont: /* CIL Label */ 
#line 598
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 607
  return;
}
}
#line 617 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void build_tree(deflate_state *s , tree_desc *desc ) 
{ 
  ct_data *tree ;
  ct_data const   *stree ;
  int elems ;
  int n ;
  int m ;
  int max_code___0 ;
  int node ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ush tmp___2 ;
  int tmp___3 ;

  {
#line 621
  tree = desc->dyn_tree;
#line 622
  stree = (desc->stat_desc)->static_tree;
#line 623
  elems = (desc->stat_desc)->elems;
#line 625
  max_code___0 = -1;
#line 632
  s->heap_len = 0;
#line 632
  s->heap_max = 573;
#line 634
  n = 0;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    if (! (n < elems)) {
#line 634
      goto while_break;
    }
#line 635
    if ((int )(tree + n)->fc.freq != 0) {
#line 636
      (s->heap_len) ++;
#line 636
      max_code___0 = n;
#line 636
      s->heap[s->heap_len] = max_code___0;
#line 637
      s->depth[n] = (uch )0;
    } else {
#line 639
      (tree + n)->dl.len = (ush )0;
    }
#line 634
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 648
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 648
    if (! (s->heap_len < 2)) {
#line 648
      goto while_break___0;
    }
#line 649
    (s->heap_len) ++;
#line 649
    if (max_code___0 < 2) {
#line 649
      max_code___0 ++;
#line 649
      tmp = max_code___0;
    } else {
#line 649
      tmp = 0;
    }
#line 649
    s->heap[s->heap_len] = tmp;
#line 649
    node = tmp;
#line 650
    (tree + node)->fc.freq = (ush )1;
#line 651
    s->depth[node] = (uch )0;
#line 652
    (s->opt_len) --;
#line 652
    if (stree) {
#line 652
      s->static_len -= (ulg )(stree + node)->dl.len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 655
  desc->max_code = max_code___0;
#line 660
  n = s->heap_len / 2;
  {
#line 660
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 660
    if (! (n >= 1)) {
#line 660
      goto while_break___1;
    }
    {
#line 660
    pqdownheap(s, tree, n);
#line 660
    n --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 665
  node = elems;
  {
#line 666
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 667
    n = s->heap[1];
#line 667
    tmp___0 = s->heap_len;
#line 667
    (s->heap_len) --;
#line 667
    s->heap[1] = s->heap[tmp___0];
#line 667
    pqdownheap(s, tree, 1);
#line 668
    m = s->heap[1];
#line 670
    (s->heap_max) --;
#line 670
    s->heap[s->heap_max] = n;
#line 671
    (s->heap_max) --;
#line 671
    s->heap[s->heap_max] = m;
#line 674
    (tree + node)->fc.freq = (ush )((int )(tree + n)->fc.freq + (int )(tree + m)->fc.freq);
    }
#line 675
    if ((int )s->depth[n] >= (int )s->depth[m]) {
#line 675
      tmp___1 = (int )s->depth[n];
    } else {
#line 675
      tmp___1 = (int )s->depth[m];
    }
    {
#line 675
    s->depth[node] = (uch )(tmp___1 + 1);
#line 677
    tmp___2 = (ush )node;
#line 677
    (tree + m)->dl.dad = tmp___2;
#line 677
    (tree + n)->dl.dad = tmp___2;
#line 685
    tmp___3 = node;
#line 685
    node ++;
#line 685
    s->heap[1] = tmp___3;
#line 686
    pqdownheap(s, tree, 1);
    }
#line 666
    if (! (s->heap_len >= 2)) {
#line 666
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 690
  (s->heap_max) --;
#line 690
  s->heap[s->heap_max] = s->heap[1];
#line 695
  gen_bitlen(s, desc);
#line 698
  gen_codes(tree, max_code___0, s->bl_count);
  }
#line 699
  return;
}
}
#line 705 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void scan_tree(deflate_state *s , ct_data *tree , int max_code___0 ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 711
  prevlen = -1;
#line 713
  nextlen = (int )(tree + 0)->dl.len;
#line 714
  count = 0;
#line 715
  max_count = 7;
#line 716
  min_count = 4;
#line 718
  if (nextlen == 0) {
#line 718
    max_count = 138;
#line 718
    min_count = 3;
  }
#line 719
  (tree + (max_code___0 + 1))->dl.len = (ush )65535;
#line 721
  n = 0;
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (! (n <= max_code___0)) {
#line 721
      goto while_break;
    }
#line 722
    curlen = nextlen;
#line 722
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 723
    count ++;
#line 723
    if (count < max_count) {
#line 723
      if (curlen == nextlen) {
#line 724
        goto __Cont;
      } else {
#line 723
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 725
    if (count < min_count) {
#line 726
      s->bl_tree[curlen].fc.freq = (ush )((int )s->bl_tree[curlen].fc.freq + count);
    } else
#line 727
    if (curlen != 0) {
#line 728
      if (curlen != prevlen) {
#line 728
        s->bl_tree[curlen].fc.freq = (ush )((int )s->bl_tree[curlen].fc.freq + 1);
      }
#line 729
      s->bl_tree[16].fc.freq = (ush )((int )s->bl_tree[16].fc.freq + 1);
    } else
#line 730
    if (count <= 10) {
#line 731
      s->bl_tree[17].fc.freq = (ush )((int )s->bl_tree[17].fc.freq + 1);
    } else {
#line 733
      s->bl_tree[18].fc.freq = (ush )((int )s->bl_tree[18].fc.freq + 1);
    }
#line 735
    count = 0;
#line 735
    prevlen = curlen;
#line 736
    if (nextlen == 0) {
#line 737
      max_count = 138;
#line 737
      min_count = 3;
    } else
#line 738
    if (curlen == nextlen) {
#line 739
      max_count = 6;
#line 739
      min_count = 3;
    } else {
#line 741
      max_count = 7;
#line 741
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 721
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 744
  return;
}
}
#line 750 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void send_tree(deflate_state *s , ct_data *tree , int max_code___0 ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;
  int len___1 ;
  int val___1 ;
  uInt tmp___3 ;
  uInt tmp___4 ;
  int len___2 ;
  int val___2 ;
  uInt tmp___5 ;
  uInt tmp___6 ;
  int len___3 ;
  int val___3 ;
  uInt tmp___7 ;
  uInt tmp___8 ;
  int len___4 ;
  int val___4 ;
  uInt tmp___9 ;
  uInt tmp___10 ;
  int len___5 ;
  int val___5 ;
  uInt tmp___11 ;
  uInt tmp___12 ;
  int len___6 ;
  int val___6 ;
  uInt tmp___13 ;
  uInt tmp___14 ;

  {
#line 756
  prevlen = -1;
#line 758
  nextlen = (int )(tree + 0)->dl.len;
#line 759
  count = 0;
#line 760
  max_count = 7;
#line 761
  min_count = 4;
#line 764
  if (nextlen == 0) {
#line 764
    max_count = 138;
#line 764
    min_count = 3;
  }
#line 766
  n = 0;
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (n <= max_code___0)) {
#line 766
      goto while_break;
    }
#line 767
    curlen = nextlen;
#line 767
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 768
    count ++;
#line 768
    if (count < max_count) {
#line 768
      if (curlen == nextlen) {
#line 769
        goto __Cont;
      } else {
#line 768
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 770
    if (count < min_count) {
      {
#line 771
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 771
        len = (int )s->bl_tree[curlen].dl.len;
#line 771
        if (s->bi_valid > 16 - len) {
#line 771
          val = (int )s->bl_tree[curlen].fc.code;
#line 771
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 771
          tmp = s->pending;
#line 771
          (s->pending) ++;
#line 771
          *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 771
          tmp___0 = s->pending;
#line 771
          (s->pending) ++;
#line 771
          *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 771
          s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 771
          s->bi_valid += len - 16;
        } else {
#line 771
          s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[curlen].fc.code << s->bi_valid));
#line 771
          s->bi_valid += len;
        }
#line 771
        count --;
#line 771
        if (! (count != 0)) {
#line 771
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 773
    if (curlen != 0) {
#line 774
      if (curlen != prevlen) {
#line 775
        len___0 = (int )s->bl_tree[curlen].dl.len;
#line 775
        if (s->bi_valid > 16 - len___0) {
#line 775
          val___0 = (int )s->bl_tree[curlen].fc.code;
#line 775
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 775
          tmp___1 = s->pending;
#line 775
          (s->pending) ++;
#line 775
          *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 775
          tmp___2 = s->pending;
#line 775
          (s->pending) ++;
#line 775
          *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 775
          s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 775
          s->bi_valid += len___0 - 16;
        } else {
#line 775
          s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[curlen].fc.code << s->bi_valid));
#line 775
          s->bi_valid += len___0;
        }
#line 775
        count --;
      }
#line 778
      len___1 = (int )s->bl_tree[16].dl.len;
#line 778
      if (s->bi_valid > 16 - len___1) {
#line 778
        val___1 = (int )s->bl_tree[16].fc.code;
#line 778
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___1) << s->bi_valid));
#line 778
        tmp___3 = s->pending;
#line 778
        (s->pending) ++;
#line 778
        *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf & 255);
#line 778
        tmp___4 = s->pending;
#line 778
        (s->pending) ++;
#line 778
        *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf >> 8);
#line 778
        s->bi_buf = (ush )((int )((ush )val___1) >> (16 - s->bi_valid));
#line 778
        s->bi_valid += len___1 - 16;
      } else {
#line 778
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[16].fc.code << s->bi_valid));
#line 778
        s->bi_valid += len___1;
      }
#line 778
      len___2 = 2;
#line 778
      if (s->bi_valid > 16 - len___2) {
#line 778
        val___2 = count - 3;
#line 778
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___2) << s->bi_valid));
#line 778
        tmp___5 = s->pending;
#line 778
        (s->pending) ++;
#line 778
        *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf & 255);
#line 778
        tmp___6 = s->pending;
#line 778
        (s->pending) ++;
#line 778
        *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf >> 8);
#line 778
        s->bi_buf = (ush )((int )((ush )val___2) >> (16 - s->bi_valid));
#line 778
        s->bi_valid += len___2 - 16;
      } else {
#line 778
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(count - 3)) << s->bi_valid));
#line 778
        s->bi_valid += len___2;
      }
    } else
#line 780
    if (count <= 10) {
#line 781
      len___3 = (int )s->bl_tree[17].dl.len;
#line 781
      if (s->bi_valid > 16 - len___3) {
#line 781
        val___3 = (int )s->bl_tree[17].fc.code;
#line 781
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___3) << s->bi_valid));
#line 781
        tmp___7 = s->pending;
#line 781
        (s->pending) ++;
#line 781
        *(s->pending_buf + tmp___7) = (uch )((int )s->bi_buf & 255);
#line 781
        tmp___8 = s->pending;
#line 781
        (s->pending) ++;
#line 781
        *(s->pending_buf + tmp___8) = (uch )((int )s->bi_buf >> 8);
#line 781
        s->bi_buf = (ush )((int )((ush )val___3) >> (16 - s->bi_valid));
#line 781
        s->bi_valid += len___3 - 16;
      } else {
#line 781
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[17].fc.code << s->bi_valid));
#line 781
        s->bi_valid += len___3;
      }
#line 781
      len___4 = 3;
#line 781
      if (s->bi_valid > 16 - len___4) {
#line 781
        val___4 = count - 3;
#line 781
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___4) << s->bi_valid));
#line 781
        tmp___9 = s->pending;
#line 781
        (s->pending) ++;
#line 781
        *(s->pending_buf + tmp___9) = (uch )((int )s->bi_buf & 255);
#line 781
        tmp___10 = s->pending;
#line 781
        (s->pending) ++;
#line 781
        *(s->pending_buf + tmp___10) = (uch )((int )s->bi_buf >> 8);
#line 781
        s->bi_buf = (ush )((int )((ush )val___4) >> (16 - s->bi_valid));
#line 781
        s->bi_valid += len___4 - 16;
      } else {
#line 781
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(count - 3)) << s->bi_valid));
#line 781
        s->bi_valid += len___4;
      }
    } else {
#line 784
      len___5 = (int )s->bl_tree[18].dl.len;
#line 784
      if (s->bi_valid > 16 - len___5) {
#line 784
        val___5 = (int )s->bl_tree[18].fc.code;
#line 784
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___5) << s->bi_valid));
#line 784
        tmp___11 = s->pending;
#line 784
        (s->pending) ++;
#line 784
        *(s->pending_buf + tmp___11) = (uch )((int )s->bi_buf & 255);
#line 784
        tmp___12 = s->pending;
#line 784
        (s->pending) ++;
#line 784
        *(s->pending_buf + tmp___12) = (uch )((int )s->bi_buf >> 8);
#line 784
        s->bi_buf = (ush )((int )((ush )val___5) >> (16 - s->bi_valid));
#line 784
        s->bi_valid += len___5 - 16;
      } else {
#line 784
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[18].fc.code << s->bi_valid));
#line 784
        s->bi_valid += len___5;
      }
#line 784
      len___6 = 7;
#line 784
      if (s->bi_valid > 16 - len___6) {
#line 784
        val___6 = count - 11;
#line 784
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___6) << s->bi_valid));
#line 784
        tmp___13 = s->pending;
#line 784
        (s->pending) ++;
#line 784
        *(s->pending_buf + tmp___13) = (uch )((int )s->bi_buf & 255);
#line 784
        tmp___14 = s->pending;
#line 784
        (s->pending) ++;
#line 784
        *(s->pending_buf + tmp___14) = (uch )((int )s->bi_buf >> 8);
#line 784
        s->bi_buf = (ush )((int )((ush )val___6) >> (16 - s->bi_valid));
#line 784
        s->bi_valid += len___6 - 16;
      } else {
#line 784
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(count - 11)) << s->bi_valid));
#line 784
        s->bi_valid += len___6;
      }
    }
#line 786
    count = 0;
#line 786
    prevlen = curlen;
#line 787
    if (nextlen == 0) {
#line 788
      max_count = 138;
#line 788
      min_count = 3;
    } else
#line 789
    if (curlen == nextlen) {
#line 790
      max_count = 6;
#line 790
      min_count = 3;
    } else {
#line 792
      max_count = 7;
#line 792
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 766
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  return;
}
}
#line 801 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static int build_bl_tree(deflate_state *s ) 
{ 
  int max_blindex ;

  {
  {
#line 807
  scan_tree(s, s->dyn_ltree, s->l_desc.max_code);
#line 808
  scan_tree(s, s->dyn_dtree, s->d_desc.max_code);
#line 811
  build_tree(s, & s->bl_desc);
#line 820
  max_blindex = 18;
  }
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (max_blindex >= 3)) {
#line 820
      goto while_break;
    }
#line 821
    if ((int )s->bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 821
      goto while_break;
    }
#line 820
    max_blindex --;
  }
  while_break: /* CIL Label */ ;
  }
#line 824
  s->opt_len += (ulg )(((3 * (max_blindex + 1) + 5) + 5) + 4);
#line 828
  return (max_blindex);
}
}
#line 836 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void send_all_trees(deflate_state *s , int lcodes , int dcodes , int blcodes ) 
{ 
  int rank ;
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;
  int len___1 ;
  int val___1 ;
  uInt tmp___3 ;
  uInt tmp___4 ;
  int len___2 ;
  int val___2 ;
  uInt tmp___5 ;
  uInt tmp___6 ;

  {
#line 846
  len = 5;
#line 846
  if (s->bi_valid > 16 - len) {
#line 846
    val = lcodes - 257;
#line 846
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 846
    tmp = s->pending;
#line 846
    (s->pending) ++;
#line 846
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 846
    tmp___0 = s->pending;
#line 846
    (s->pending) ++;
#line 846
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 846
    s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 846
    s->bi_valid += len - 16;
  } else {
#line 846
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(lcodes - 257)) << s->bi_valid));
#line 846
    s->bi_valid += len;
  }
#line 847
  len___0 = 5;
#line 847
  if (s->bi_valid > 16 - len___0) {
#line 847
    val___0 = dcodes - 1;
#line 847
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 847
    tmp___1 = s->pending;
#line 847
    (s->pending) ++;
#line 847
    *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 847
    tmp___2 = s->pending;
#line 847
    (s->pending) ++;
#line 847
    *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 847
    s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 847
    s->bi_valid += len___0 - 16;
  } else {
#line 847
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(dcodes - 1)) << s->bi_valid));
#line 847
    s->bi_valid += len___0;
  }
#line 848
  len___1 = 4;
#line 848
  if (s->bi_valid > 16 - len___1) {
#line 848
    val___1 = blcodes - 4;
#line 848
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___1) << s->bi_valid));
#line 848
    tmp___3 = s->pending;
#line 848
    (s->pending) ++;
#line 848
    *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf & 255);
#line 848
    tmp___4 = s->pending;
#line 848
    (s->pending) ++;
#line 848
    *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf >> 8);
#line 848
    s->bi_buf = (ush )((int )((ush )val___1) >> (16 - s->bi_valid));
#line 848
    s->bi_valid += len___1 - 16;
  } else {
#line 848
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(blcodes - 4)) << s->bi_valid));
#line 848
    s->bi_valid += len___1;
  }
#line 849
  rank = 0;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! (rank < blcodes)) {
#line 849
      goto while_break;
    }
#line 851
    len___2 = 3;
#line 851
    if (s->bi_valid > 16 - len___2) {
#line 851
      val___2 = (int )s->bl_tree[bl_order[rank]].dl.len;
#line 851
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___2) << s->bi_valid));
#line 851
      tmp___5 = s->pending;
#line 851
      (s->pending) ++;
#line 851
      *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf & 255);
#line 851
      tmp___6 = s->pending;
#line 851
      (s->pending) ++;
#line 851
      *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf >> 8);
#line 851
      s->bi_buf = (ush )((int )((ush )val___2) >> (16 - s->bi_valid));
#line 851
      s->bi_valid += len___2 - 16;
    } else {
#line 851
      s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[bl_order[rank]].dl.len << s->bi_valid));
#line 851
      s->bi_valid += len___2;
    }
#line 849
    rank ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 855
  send_tree(s, s->dyn_ltree, lcodes - 1);
#line 858
  send_tree(s, s->dyn_dtree, dcodes - 1);
  }
#line 860
  return;
}
}
#line 865 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_stored_block(deflate_state *s ,
                                                                 charf *buf , ulg stored_len ,
                                                                 int last ) 
{ 
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;

  {
#line 871
  len = 3;
#line 871
  if (s->bi_valid > 16 - len) {
#line 871
    val = last;
#line 871
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 871
    tmp = s->pending;
#line 871
    (s->pending) ++;
#line 871
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 871
    tmp___0 = s->pending;
#line 871
    (s->pending) ++;
#line 871
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 871
    s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 871
    s->bi_valid += len - 16;
  } else {
#line 871
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )last) << s->bi_valid));
#line 871
    s->bi_valid += len;
  }
  {
#line 876
  copy_block(s, buf, (unsigned int )stored_len, 1);
  }
#line 877
  return;
}
}
#line 882 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_flush_bits(deflate_state *s ) 
{ 


  {
  {
#line 885
  bi_flush(s);
  }
#line 886
  return;
}
}
#line 892 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_align(deflate_state *s ) 
{ 
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;

  {
#line 895
  len = 3;
#line 895
  if (s->bi_valid > 16 - len) {
#line 895
    val = 1 << 1;
#line 895
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 895
    tmp = s->pending;
#line 895
    (s->pending) ++;
#line 895
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 895
    tmp___0 = s->pending;
#line 895
    (s->pending) ++;
#line 895
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 895
    s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 895
    s->bi_valid += len - 16;
  } else {
#line 895
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(1 << 1)) << s->bi_valid));
#line 895
    s->bi_valid += len;
  }
#line 896
  len___0 = (int )static_ltree[256].dl.len;
#line 896
  if (s->bi_valid > 16 - len___0) {
#line 896
    val___0 = (int )static_ltree[256].fc.code;
#line 896
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 896
    tmp___1 = s->pending;
#line 896
    (s->pending) ++;
#line 896
    *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 896
    tmp___2 = s->pending;
#line 896
    (s->pending) ++;
#line 896
    *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 896
    s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 896
    s->bi_valid += len___0 - 16;
  } else {
#line 896
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )static_ltree[256].fc.code) << s->bi_valid));
#line 896
    s->bi_valid += len___0;
  }
  {
#line 900
  bi_flush(s);
  }
#line 901
  return;
}
}
#line 907 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_flush_block(deflate_state *s ,
                                                                charf *buf , ulg stored_len ,
                                                                int last ) 
{ 
  ulg opt_lenb ;
  ulg static_lenb ;
  int max_blindex ;
  int len ;
  int val ;
  uInt tmp ;
  uInt tmp___0 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;

  {
#line 914
  max_blindex = 0;
#line 917
  if (s->level > 0) {
#line 920
    if ((s->strm)->data_type == 2) {
      {
#line 921
      (s->strm)->data_type = detect_data_type(s);
      }
    }
    {
#line 924
    build_tree(s, & s->l_desc);
#line 928
    build_tree(s, & s->d_desc);
#line 938
    max_blindex = build_bl_tree(s);
#line 941
    opt_lenb = ((s->opt_len + 3UL) + 7UL) >> 3;
#line 942
    static_lenb = ((s->static_len + 3UL) + 7UL) >> 3;
    }
#line 948
    if (static_lenb <= opt_lenb) {
#line 948
      opt_lenb = static_lenb;
    }
  } else {
#line 952
    static_lenb = stored_len + 5UL;
#line 952
    opt_lenb = static_lenb;
  }
#line 958
  if (stored_len + 4UL <= opt_lenb) {
#line 958
    if ((unsigned long )buf != (unsigned long )((char *)0)) {
      {
#line 967
      _tr_stored_block(s, buf, stored_len, last);
      }
    } else {
#line 958
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 972
  if (s->strategy == 4) {
#line 972
    goto _L;
  } else
#line 972
  if (static_lenb == opt_lenb) {
    _L: /* CIL Label */ 
#line 974
    len = 3;
#line 974
    if (s->bi_valid > 16 - len) {
#line 974
      val = (1 << 1) + last;
#line 974
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 974
      tmp = s->pending;
#line 974
      (s->pending) ++;
#line 974
      *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 974
      tmp___0 = s->pending;
#line 974
      (s->pending) ++;
#line 974
      *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 974
      s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 974
      s->bi_valid += len - 16;
    } else {
#line 974
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )((1 << 1) + last)) << s->bi_valid));
#line 974
      s->bi_valid += len;
    }
    {
#line 975
    compress_block(s, static_ltree, static_dtree);
    }
  } else {
#line 981
    len___0 = 3;
#line 981
    if (s->bi_valid > 16 - len___0) {
#line 981
      val___0 = (2 << 1) + last;
#line 981
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 981
      tmp___1 = s->pending;
#line 981
      (s->pending) ++;
#line 981
      *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 981
      tmp___2 = s->pending;
#line 981
      (s->pending) ++;
#line 981
      *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 981
      s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 981
      s->bi_valid += len___0 - 16;
    } else {
#line 981
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )((2 << 1) + last)) << s->bi_valid));
#line 981
      s->bi_valid += len___0;
    }
    {
#line 982
    send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1, max_blindex + 1);
#line 984
    compress_block(s, (ct_data const   *)(s->dyn_ltree), (ct_data const   *)(s->dyn_dtree));
    }
  }
  {
#line 994
  init_block(s);
  }
#line 996
  if (last) {
    {
#line 997
    bi_windup(s);
    }
  }
#line 1004
  return;
}
}
#line 1010 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
int __attribute__((__visibility__("hidden")))  _tr_tally(deflate_state *s , unsigned int dist ,
                                                         unsigned int lc ) 
{ 
  uInt tmp ;
  int __attribute__((__visibility__("hidden")))  tmp___0 ;

  {
#line 1015
  *(s->d_buf + s->last_lit) = (ush )dist;
#line 1016
  tmp = s->last_lit;
#line 1016
  (s->last_lit) ++;
#line 1016
  *(s->l_buf + tmp) = (uch )lc;
#line 1017
  if (dist == 0U) {
#line 1019
    s->dyn_ltree[lc].fc.freq = (ush )((int )s->dyn_ltree[lc].fc.freq + 1);
  } else {
#line 1021
    (s->matches) ++;
#line 1023
    dist --;
#line 1028
    s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[lc] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[lc] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 1029
    if (dist < 256U) {
#line 1029
      tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
    } else {
#line 1029
      tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256U + (dist >> 7)];
    }
#line 1029
    s->dyn_dtree[tmp___0].fc.freq = (ush )((int )s->dyn_dtree[tmp___0].fc.freq + 1);
  }
#line 1050
  return ((int __attribute__((__visibility__("hidden")))  )(s->last_lit == s->lit_bufsize - 1U));
}
}
#line 1060 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void compress_block(deflate_state *s , ct_data const   *ltree , ct_data const   *dtree ) 
{ 
  unsigned int dist ;
  int lc ;
  unsigned int lx ;
  unsigned int code ;
  int extra ;
  unsigned int tmp ;
  int len ;
  int val ;
  uInt tmp___0 ;
  uInt tmp___1 ;
  int len___0 ;
  int val___0 ;
  uInt tmp___2 ;
  uInt tmp___3 ;
  int len___1 ;
  int val___1 ;
  uInt tmp___4 ;
  uInt tmp___5 ;
  int len___2 ;
  int val___2 ;
  uInt tmp___6 ;
  uInt tmp___7 ;
  int len___3 ;
  int val___3 ;
  uInt tmp___8 ;
  uInt tmp___9 ;
  int len___4 ;
  int val___4 ;
  uInt tmp___10 ;
  uInt tmp___11 ;

  {
#line 1067
  lx = 0U;
#line 1071
  if (s->last_lit != 0U) {
    {
#line 1071
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1072
      dist = (unsigned int )*(s->d_buf + lx);
#line 1073
      tmp = lx;
#line 1073
      lx ++;
#line 1073
      lc = (int )*(s->l_buf + tmp);
#line 1074
      if (dist == 0U) {
#line 1075
        len = (int )(ltree + lc)->dl.len;
#line 1075
        if (s->bi_valid > 16 - len) {
#line 1075
          val = (int )(ltree + lc)->fc.code;
#line 1075
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 1075
          tmp___0 = s->pending;
#line 1075
          (s->pending) ++;
#line 1075
          *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf & 255);
#line 1075
          tmp___1 = s->pending;
#line 1075
          (s->pending) ++;
#line 1075
          *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf >> 8);
#line 1075
          s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 1075
          s->bi_valid += len - 16;
        } else {
#line 1075
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(ltree + lc)->fc.code) << s->bi_valid));
#line 1075
          s->bi_valid += len;
        }
      } else {
#line 1079
        code = (unsigned int )_length_code[lc];
#line 1080
        len___0 = (int )(ltree + ((code + 256U) + 1U))->dl.len;
#line 1080
        if (s->bi_valid > 16 - len___0) {
#line 1080
          val___0 = (int )(ltree + ((code + 256U) + 1U))->fc.code;
#line 1080
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 1080
          tmp___2 = s->pending;
#line 1080
          (s->pending) ++;
#line 1080
          *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf & 255);
#line 1080
          tmp___3 = s->pending;
#line 1080
          (s->pending) ++;
#line 1080
          *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf >> 8);
#line 1080
          s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 1080
          s->bi_valid += len___0 - 16;
        } else {
#line 1080
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(ltree + ((code + 256U) + 1U))->fc.code) << s->bi_valid));
#line 1080
          s->bi_valid += len___0;
        }
#line 1081
        extra = (int )extra_lbits[code];
#line 1082
        if (extra != 0) {
#line 1083
          lc -= (int )base_length[code];
#line 1084
          len___1 = extra;
#line 1084
          if (s->bi_valid > 16 - len___1) {
#line 1084
            val___1 = lc;
#line 1084
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___1) << s->bi_valid));
#line 1084
            tmp___4 = s->pending;
#line 1084
            (s->pending) ++;
#line 1084
            *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf & 255);
#line 1084
            tmp___5 = s->pending;
#line 1084
            (s->pending) ++;
#line 1084
            *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf >> 8);
#line 1084
            s->bi_buf = (ush )((int )((ush )val___1) >> (16 - s->bi_valid));
#line 1084
            s->bi_valid += len___1 - 16;
          } else {
#line 1084
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )lc) << s->bi_valid));
#line 1084
            s->bi_valid += len___1;
          }
        }
#line 1086
        dist --;
#line 1087
        if (dist < 256U) {
#line 1087
          code = (unsigned int )_dist_code[dist];
        } else {
#line 1087
          code = (unsigned int )_dist_code[256U + (dist >> 7)];
        }
#line 1090
        len___2 = (int )(dtree + code)->dl.len;
#line 1090
        if (s->bi_valid > 16 - len___2) {
#line 1090
          val___2 = (int )(dtree + code)->fc.code;
#line 1090
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___2) << s->bi_valid));
#line 1090
          tmp___6 = s->pending;
#line 1090
          (s->pending) ++;
#line 1090
          *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf & 255);
#line 1090
          tmp___7 = s->pending;
#line 1090
          (s->pending) ++;
#line 1090
          *(s->pending_buf + tmp___7) = (uch )((int )s->bi_buf >> 8);
#line 1090
          s->bi_buf = (ush )((int )((ush )val___2) >> (16 - s->bi_valid));
#line 1090
          s->bi_valid += len___2 - 16;
        } else {
#line 1090
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(dtree + code)->fc.code) << s->bi_valid));
#line 1090
          s->bi_valid += len___2;
        }
#line 1091
        extra = (int )extra_dbits[code];
#line 1092
        if (extra != 0) {
#line 1093
          dist -= (unsigned int )base_dist[code];
#line 1094
          len___3 = extra;
#line 1094
          if (s->bi_valid > 16 - len___3) {
#line 1094
            val___3 = (int )dist;
#line 1094
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___3) << s->bi_valid));
#line 1094
            tmp___8 = s->pending;
#line 1094
            (s->pending) ++;
#line 1094
            *(s->pending_buf + tmp___8) = (uch )((int )s->bi_buf & 255);
#line 1094
            tmp___9 = s->pending;
#line 1094
            (s->pending) ++;
#line 1094
            *(s->pending_buf + tmp___9) = (uch )((int )s->bi_buf >> 8);
#line 1094
            s->bi_buf = (ush )((int )((ush )val___3) >> (16 - s->bi_valid));
#line 1094
            s->bi_valid += len___3 - 16;
          } else {
#line 1094
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )dist) << s->bi_valid));
#line 1094
            s->bi_valid += len___3;
          }
        }
      }
#line 1071
      if (! (lx < s->last_lit)) {
#line 1071
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1104
  len___4 = (int )(ltree + 256)->dl.len;
#line 1104
  if (s->bi_valid > 16 - len___4) {
#line 1104
    val___4 = (int )(ltree + 256)->fc.code;
#line 1104
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___4) << s->bi_valid));
#line 1104
    tmp___10 = s->pending;
#line 1104
    (s->pending) ++;
#line 1104
    *(s->pending_buf + tmp___10) = (uch )((int )s->bi_buf & 255);
#line 1104
    tmp___11 = s->pending;
#line 1104
    (s->pending) ++;
#line 1104
    *(s->pending_buf + tmp___11) = (uch )((int )s->bi_buf >> 8);
#line 1104
    s->bi_buf = (ush )((int )((ush )val___4) >> (16 - s->bi_valid));
#line 1104
    s->bi_valid += len___4 - 16;
  } else {
#line 1104
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(ltree + 256)->fc.code) << s->bi_valid));
#line 1104
    s->bi_valid += len___4;
  }
#line 1105
  return;
}
}
#line 1120 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static int detect_data_type(deflate_state *s ) 
{ 
  unsigned long black_mask ;
  int n ;

  {
#line 1127
  black_mask = 4093624447UL;
#line 1131
  n = 0;
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    if (! (n <= 31)) {
#line 1131
      goto while_break;
    }
#line 1132
    if (black_mask & 1UL) {
#line 1132
      if ((int )s->dyn_ltree[n].fc.freq != 0) {
#line 1133
        return (0);
      }
    }
#line 1131
    n ++;
#line 1131
    black_mask >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1136
  if ((int )s->dyn_ltree[9].fc.freq != 0) {
#line 1138
    return (1);
  } else
#line 1136
  if ((int )s->dyn_ltree[10].fc.freq != 0) {
#line 1138
    return (1);
  } else
#line 1136
  if ((int )s->dyn_ltree[13].fc.freq != 0) {
#line 1138
    return (1);
  }
#line 1139
  n = 32;
  {
#line 1139
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1139
    if (! (n < 256)) {
#line 1139
      goto while_break___0;
    }
#line 1140
    if ((int )s->dyn_ltree[n].fc.freq != 0) {
#line 1141
      return (1);
    }
#line 1139
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1146
  return (0);
}
}
#line 1154 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static unsigned int bi_reverse(unsigned int code , int len ) 
{ 
  register unsigned int res ;

  {
#line 1158
  res = 0U;
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1160
    res |= code & 1U;
#line 1161
    code >>= 1;
#line 1161
    res <<= 1;
#line 1159
    len --;
#line 1159
    if (! (len > 0)) {
#line 1159
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1163
  return (res >> 1);
}
}
#line 1169 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void bi_flush(deflate_state *s ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;
  uInt tmp___1 ;

  {
#line 1172
  if (s->bi_valid == 16) {
#line 1173
    tmp = s->pending;
#line 1173
    (s->pending) ++;
#line 1173
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 1173
    tmp___0 = s->pending;
#line 1173
    (s->pending) ++;
#line 1173
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 1174
    s->bi_buf = (ush )0;
#line 1175
    s->bi_valid = 0;
  } else
#line 1176
  if (s->bi_valid >= 8) {
#line 1177
    tmp___1 = s->pending;
#line 1177
    (s->pending) ++;
#line 1177
    *(s->pending_buf + tmp___1) = (Byte )s->bi_buf;
#line 1178
    s->bi_buf = (ush )((int )s->bi_buf >> 8);
#line 1179
    s->bi_valid -= 8;
  }
#line 1181
  return;
}
}
#line 1186 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void bi_windup(deflate_state *s ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;
  uInt tmp___1 ;

  {
#line 1189
  if (s->bi_valid > 8) {
#line 1190
    tmp = s->pending;
#line 1190
    (s->pending) ++;
#line 1190
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 1190
    tmp___0 = s->pending;
#line 1190
    (s->pending) ++;
#line 1190
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
  } else
#line 1191
  if (s->bi_valid > 0) {
#line 1192
    tmp___1 = s->pending;
#line 1192
    (s->pending) ++;
#line 1192
    *(s->pending_buf + tmp___1) = (Byte )s->bi_buf;
  }
#line 1194
  s->bi_buf = (ush )0;
#line 1195
  s->bi_valid = 0;
#line 1199
  return;
}
}
#line 1205 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/trees.c"
static void copy_block(deflate_state *s , charf *buf , unsigned int len , int header ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;
  uInt tmp___1 ;
  uInt tmp___2 ;
  uInt tmp___3 ;
  charf *tmp___4 ;
  unsigned int tmp___5 ;

  {
  {
#line 1211
  bi_windup(s);
  }
#line 1213
  if (header) {
#line 1214
    tmp = s->pending;
#line 1214
    (s->pending) ++;
#line 1214
    *(s->pending_buf + tmp) = (uch )((int )((ush )len) & 255);
#line 1214
    tmp___0 = s->pending;
#line 1214
    (s->pending) ++;
#line 1214
    *(s->pending_buf + tmp___0) = (uch )((int )((ush )len) >> 8);
#line 1215
    tmp___1 = s->pending;
#line 1215
    (s->pending) ++;
#line 1215
    *(s->pending_buf + tmp___1) = (uch )((int )((ush )(~ len)) & 255);
#line 1215
    tmp___2 = s->pending;
#line 1215
    (s->pending) ++;
#line 1215
    *(s->pending_buf + tmp___2) = (uch )((int )((ush )(~ len)) >> 8);
  }
  {
#line 1223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1223
    tmp___5 = len;
#line 1223
    len --;
#line 1223
    if (! tmp___5) {
#line 1223
      goto while_break;
    }
#line 1224
    tmp___3 = s->pending;
#line 1224
    (s->pending) ++;
#line 1224
    tmp___4 = buf;
#line 1224
    buf ++;
#line 1224
    *(s->pending_buf + tmp___3) = (Bytef )*tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 1226
  return;
}
}
#line 60 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.h"
int __attribute__((__visibility__("hidden")))  inflate_table(codetype type , unsigned short *lens ,
                                                             unsigned int codes ,
                                                             code **table___0 , unsigned int *bits ,
                                                             unsigned short *work ) ;
#line 11 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.c"
char const   inflate_copyright[47]  = 
#line 11 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.c"
  {      (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'8',      (char const   )' ',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'5',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'1',      (char const   )'3',      (char const   )' ',      (char const   )'M', 
        (char const   )'a',      (char const   )'r',      (char const   )'k',      (char const   )' ', 
        (char const   )'A',      (char const   )'d',      (char const   )'l',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'\000'};
#line 60 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.c"
static unsigned short const   lbase[31]  = 
#line 60
  {      (unsigned short const   )3,      (unsigned short const   )4,      (unsigned short const   )5,      (unsigned short const   )6, 
        (unsigned short const   )7,      (unsigned short const   )8,      (unsigned short const   )9,      (unsigned short const   )10, 
        (unsigned short const   )11,      (unsigned short const   )13,      (unsigned short const   )15,      (unsigned short const   )17, 
        (unsigned short const   )19,      (unsigned short const   )23,      (unsigned short const   )27,      (unsigned short const   )31, 
        (unsigned short const   )35,      (unsigned short const   )43,      (unsigned short const   )51,      (unsigned short const   )59, 
        (unsigned short const   )67,      (unsigned short const   )83,      (unsigned short const   )99,      (unsigned short const   )115, 
        (unsigned short const   )131,      (unsigned short const   )163,      (unsigned short const   )195,      (unsigned short const   )227, 
        (unsigned short const   )258,      (unsigned short const   )0,      (unsigned short const   )0};
#line 63 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.c"
static unsigned short const   lext[31]  = 
#line 63
  {      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )17, 
        (unsigned short const   )18,      (unsigned short const   )18,      (unsigned short const   )18,      (unsigned short const   )18, 
        (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )20,      (unsigned short const   )20,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )21, 
        (unsigned short const   )16,      (unsigned short const   )72,      (unsigned short const   )78};
#line 66 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.c"
static unsigned short const   dbase[32]  = 
#line 66
  {      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )3,      (unsigned short const   )4, 
        (unsigned short const   )5,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )13, 
        (unsigned short const   )17,      (unsigned short const   )25,      (unsigned short const   )33,      (unsigned short const   )49, 
        (unsigned short const   )65,      (unsigned short const   )97,      (unsigned short const   )129,      (unsigned short const   )193, 
        (unsigned short const   )257,      (unsigned short const   )385,      (unsigned short const   )513,      (unsigned short const   )769, 
        (unsigned short const   )1025,      (unsigned short const   )1537,      (unsigned short const   )2049,      (unsigned short const   )3073, 
        (unsigned short const   )4097,      (unsigned short const   )6145,      (unsigned short const   )8193,      (unsigned short const   )12289, 
        (unsigned short const   )16385,      (unsigned short const   )24577,      (unsigned short const   )0,      (unsigned short const   )0};
#line 70 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.c"
static unsigned short const   dext[32]  = 
#line 70
  {      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )18, 
        (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )20,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )22,      (unsigned short const   )22, 
        (unsigned short const   )23,      (unsigned short const   )23,      (unsigned short const   )24,      (unsigned short const   )24, 
        (unsigned short const   )25,      (unsigned short const   )25,      (unsigned short const   )26,      (unsigned short const   )26, 
        (unsigned short const   )27,      (unsigned short const   )27,      (unsigned short const   )28,      (unsigned short const   )28, 
        (unsigned short const   )29,      (unsigned short const   )29,      (unsigned short const   )64,      (unsigned short const   )64};
#line 32 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inftrees.c"
int __attribute__((__visibility__("hidden")))  inflate_table(codetype type , unsigned short *lens ,
                                                             unsigned int codes ,
                                                             code **table___0 , unsigned int *bits ,
                                                             unsigned short *work ) 
{ 
  unsigned int len ;
  unsigned int sym ;
  unsigned int min ;
  unsigned int max ;
  unsigned int root ;
  unsigned int curr ;
  unsigned int drop ;
  int left ;
  unsigned int used ;
  unsigned int huff ;
  unsigned int incr ;
  unsigned int fill ;
  unsigned int low ;
  unsigned int mask ;
  code here ;
  code *next ;
  unsigned short const   *base ;
  unsigned short const   *extra ;
  int end ;
  unsigned short count[16] ;
  unsigned short offs[16] ;
  code *tmp ;
  code *tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 107
  len = 0U;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (len <= 15U)) {
#line 107
      goto while_break;
    }
#line 108
    count[len] = (unsigned short)0;
#line 107
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  sym = 0U;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (sym < codes)) {
#line 109
      goto while_break___0;
    }
#line 110
    count[*(lens + sym)] = (unsigned short )((int )count[*(lens + sym)] + 1);
#line 109
    sym ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  root = *bits;
#line 114
  max = 15U;
  {
#line 114
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 114
    if (! (max >= 1U)) {
#line 114
      goto while_break___1;
    }
#line 115
    if ((int )count[max] != 0) {
#line 115
      goto while_break___1;
    }
#line 114
    max --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 116
  if (root > max) {
#line 116
    root = max;
  }
#line 117
  if (max == 0U) {
#line 118
    here.op = (unsigned char)64;
#line 119
    here.bits = (unsigned char)1;
#line 120
    here.val = (unsigned short)0;
#line 121
    tmp = *table___0;
#line 121
    (*table___0) ++;
#line 121
    *tmp = here;
#line 122
    tmp___0 = *table___0;
#line 122
    (*table___0) ++;
#line 122
    *tmp___0 = here;
#line 123
    *bits = 1U;
#line 124
    return ((int __attribute__((__visibility__("hidden")))  )0);
  }
#line 126
  min = 1U;
  {
#line 126
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 126
    if (! (min < max)) {
#line 126
      goto while_break___2;
    }
#line 127
    if ((int )count[min] != 0) {
#line 127
      goto while_break___2;
    }
#line 126
    min ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 128
  if (root < min) {
#line 128
    root = min;
  }
#line 131
  left = 1;
#line 132
  len = 1U;
  {
#line 132
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 132
    if (! (len <= 15U)) {
#line 132
      goto while_break___3;
    }
#line 133
    left <<= 1;
#line 134
    left -= (int )count[len];
#line 135
    if (left < 0) {
#line 135
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
#line 132
    len ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 137
  if (left > 0) {
#line 137
    if ((unsigned int )type == 0U) {
#line 138
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    } else
#line 137
    if (max != 1U) {
#line 138
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
  }
#line 141
  offs[1] = (unsigned short)0;
#line 142
  len = 1U;
  {
#line 142
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 142
    if (! (len < 15U)) {
#line 142
      goto while_break___4;
    }
#line 143
    offs[len + 1U] = (unsigned short )((int )offs[len] + (int )count[len]);
#line 142
    len ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 146
  sym = 0U;
  {
#line 146
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 146
    if (! (sym < codes)) {
#line 146
      goto while_break___5;
    }
#line 147
    if ((int )*(lens + sym) != 0) {
#line 147
      tmp___1 = offs[*(lens + sym)];
#line 147
      offs[*(lens + sym)] = (unsigned short )((int )offs[*(lens + sym)] + 1);
#line 147
      *(work + tmp___1) = (unsigned short )sym;
    }
#line 146
    sym ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 182
  if ((unsigned int )type == 0U) {
#line 182
    goto case_0;
  }
#line 186
  if ((unsigned int )type == 1U) {
#line 186
    goto case_1;
  }
#line 193
  goto switch_default;
  case_0: /* CIL Label */ 
#line 183
  extra = (unsigned short const   *)work;
#line 183
  base = extra;
#line 184
  end = 19;
#line 185
  goto switch_break;
  case_1: /* CIL Label */ 
#line 187
  base = lbase;
#line 188
  base -= 257;
#line 189
  extra = lext;
#line 190
  extra -= 257;
#line 191
  end = 256;
#line 192
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 194
  base = dbase;
#line 195
  extra = dext;
#line 196
  end = -1;
  switch_break: /* CIL Label */ ;
  }
#line 200
  huff = 0U;
#line 201
  sym = 0U;
#line 202
  len = min;
#line 203
  next = *table___0;
#line 204
  curr = root;
#line 205
  drop = 0U;
#line 206
  low = 4294967295U;
#line 207
  used = 1U << root;
#line 208
  mask = used - 1U;
#line 211
  if ((unsigned int )type == 1U) {
#line 211
    if (used > 852U) {
#line 213
      return ((int __attribute__((__visibility__("hidden")))  )1);
    } else {
#line 211
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 211
  if ((unsigned int )type == 2U) {
#line 211
    if (used > 592U) {
#line 213
      return ((int __attribute__((__visibility__("hidden")))  )1);
    }
  }
  {
#line 216
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 218
    here.bits = (unsigned char )(len - drop);
#line 219
    if ((int )*(work + sym) < end) {
#line 220
      here.op = (unsigned char)0;
#line 221
      here.val = *(work + sym);
    } else
#line 223
    if ((int )*(work + sym) > end) {
#line 224
      here.op = (unsigned char )*(extra + *(work + sym));
#line 225
      here.val = (unsigned short )*(base + *(work + sym));
    } else {
#line 228
      here.op = (unsigned char)96;
#line 229
      here.val = (unsigned short)0;
    }
#line 233
    incr = 1U << (len - drop);
#line 234
    fill = 1U << curr;
#line 235
    min = fill;
    {
#line 236
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 237
      fill -= incr;
#line 238
      *(next + ((huff >> drop) + fill)) = here;
#line 236
      if (! (fill != 0U)) {
#line 236
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 242
    incr = 1U << (len - 1U);
    {
#line 243
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 243
      if (! (huff & incr)) {
#line 243
        goto while_break___8;
      }
#line 244
      incr >>= 1;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 245
    if (incr != 0U) {
#line 246
      huff &= incr - 1U;
#line 247
      huff += incr;
    } else {
#line 250
      huff = 0U;
    }
#line 253
    sym ++;
#line 254
    count[len] = (unsigned short )((int )count[len] - 1);
#line 254
    if ((int )count[len] == 0) {
#line 255
      if (len == max) {
#line 255
        goto while_break___6;
      }
#line 256
      len = (unsigned int )*(lens + *(work + sym));
    }
#line 260
    if (len > root) {
#line 260
      if ((huff & mask) != low) {
#line 262
        if (drop == 0U) {
#line 263
          drop = root;
        }
#line 266
        next += min;
#line 269
        curr = len - drop;
#line 270
        left = 1 << curr;
        {
#line 271
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 271
          if (! (curr + drop < max)) {
#line 271
            goto while_break___9;
          }
#line 272
          left -= (int )count[curr + drop];
#line 273
          if (left <= 0) {
#line 273
            goto while_break___9;
          }
#line 274
          curr ++;
#line 275
          left <<= 1;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 279
        used += 1U << curr;
#line 280
        if ((unsigned int )type == 1U) {
#line 280
          if (used > 852U) {
#line 282
            return ((int __attribute__((__visibility__("hidden")))  )1);
          } else {
#line 280
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 280
        if ((unsigned int )type == 2U) {
#line 280
          if (used > 592U) {
#line 282
            return ((int __attribute__((__visibility__("hidden")))  )1);
          }
        }
#line 285
        low = huff & mask;
#line 286
        (*table___0 + low)->op = (unsigned char )curr;
#line 287
        (*table___0 + low)->bits = (unsigned char )root;
#line 288
        (*table___0 + low)->val = (unsigned short )(next - *table___0);
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 295
  if (huff != 0U) {
#line 296
    here.op = (unsigned char)64;
#line 297
    here.bits = (unsigned char )(len - drop);
#line 298
    here.val = (unsigned short)0;
#line 299
    *(next + huff) = here;
  }
#line 303
  *table___0 += used;
#line 304
  *bits = root;
#line 305
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 837 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
int inflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 860
int inflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 875
int inflateSync(z_streamp strm ) ;
#line 894
int inflateCopy(z_streamp dest , z_streamp source ) ;
#line 910
int inflateReset(z_streamp strm ) ;
#line 920
int inflateReset2(z_streamp strm , int windowBits ) ;
#line 932
int inflatePrime(z_streamp strm , int bits , int value ) ;
#line 953
long inflateMark(z_streamp strm ) ;
#line 981
int inflateGetHeader(z_streamp strm , gz_headerp head ) ;
#line 1587
uLong adler32(uLong adler , Bytef const   *buf , uInt len ) ;
#line 1659
int inflateInit2_(z_streamp strm , int windowBits , char const   *version , int stream_size ) ;
#line 1765
int inflateSyncPoint(z_streamp strm ) ;
#line 1767
int inflateUndermine(z_streamp strm , int subvert ) ;
#line 1768
int inflateResetKeep(z_streamp strm ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 11 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffast.h"
void __attribute__((__visibility__("hidden")))  inflate_fast(z_streamp strm , unsigned int start ) ;
#line 95 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
static void fixedtables(struct inflate_state *state ) ;
#line 96
static int updatewindow(z_streamp strm , unsigned char const   *end , unsigned int copy ) ;
#line 101
static unsigned int syncsearch(unsigned int *have , unsigned char const   *buf , unsigned int len ) ;
#line 104 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateResetKeep(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  uLong tmp ;
  unsigned long tmp___0 ;
  code const   *tmp___1 ;
  code *tmp___2 ;

  {
#line 109
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 109
    return (-2);
  } else
#line 109
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 109
    return (-2);
  }
#line 110
  state = (struct inflate_state *)strm->state;
#line 111
  tmp___0 = 0UL;
#line 111
  state->total = tmp___0;
#line 111
  tmp = tmp___0;
#line 111
  strm->total_out = tmp;
#line 111
  strm->total_in = tmp;
#line 112
  strm->msg = (char *)0;
#line 113
  if (state->wrap) {
#line 114
    strm->adler = (uLong )(state->wrap & 1);
  }
#line 115
  state->mode = (inflate_mode )0;
#line 116
  state->last = 0;
#line 117
  state->havedict = 0;
#line 118
  state->dmax = 32768U;
#line 119
  state->head = (gz_headerp )0;
#line 120
  state->hold = 0UL;
#line 121
  state->bits = 0U;
#line 122
  tmp___2 = state->codes;
#line 122
  state->next = tmp___2;
#line 122
  tmp___1 = (code const   *)tmp___2;
#line 122
  state->distcode = tmp___1;
#line 122
  state->lencode = tmp___1;
#line 123
  state->sane = 1;
#line 124
  state->back = -1;
#line 126
  return (0);
}
}
#line 129 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateReset(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
#line 134
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 134
    return (-2);
  } else
#line 134
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 134
    return (-2);
  }
  {
#line 135
  state = (struct inflate_state *)strm->state;
#line 136
  state->wsize = 0U;
#line 137
  state->whave = 0U;
#line 138
  state->wnext = 0U;
#line 139
  tmp = inflateResetKeep(strm);
  }
#line 139
  return (tmp);
}
}
#line 142 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateReset2(z_streamp strm , int windowBits ) 
{ 
  int wrap ;
  struct inflate_state *state ;
  int tmp ;

  {
#line 150
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 150
    return (-2);
  } else
#line 150
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 150
    return (-2);
  }
#line 151
  state = (struct inflate_state *)strm->state;
#line 154
  if (windowBits < 0) {
#line 155
    wrap = 0;
#line 156
    windowBits = - windowBits;
  } else {
#line 159
    wrap = (windowBits >> 4) + 1;
  }
#line 167
  if (windowBits) {
#line 167
    if (windowBits < 8) {
#line 168
      return (-2);
    } else
#line 167
    if (windowBits > 15) {
#line 168
      return (-2);
    }
  }
#line 169
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
#line 169
    if (state->wbits != (unsigned int )windowBits) {
      {
#line 170
      (*(strm->zfree))(strm->opaque, (voidpf )state->window);
#line 171
      state->window = (unsigned char *)0;
      }
    }
  }
  {
#line 175
  state->wrap = wrap;
#line 176
  state->wbits = (unsigned int )windowBits;
#line 177
  tmp = inflateReset(strm);
  }
#line 177
  return (tmp);
}
}
#line 180 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateInit2_(z_streamp strm , int windowBits , char const   *version , int stream_size ) 
{ 
  int ret ;
  struct inflate_state *state ;
  voidpf tmp ;

  {
#line 189
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 191
    return (-6);
  } else
#line 189
  if ((int const   )*(version + 0) != (int const   )*("1.2.8-optipng" + 0)) {
#line 191
    return (-6);
  } else
#line 189
  if (stream_size != (int )sizeof(z_stream )) {
#line 191
    return (-6);
  }
#line 192
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 192
    return (-2);
  }
#line 193
  strm->msg = (char *)0;
#line 194
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 198
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& zcalloc);
#line 199
    strm->opaque = (voidpf )0;
  }
#line 202
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 206
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))(& zcfree);
  }
  {
#line 208
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 208
  state = (struct inflate_state *)tmp;
  }
#line 210
  if ((unsigned long )state == (unsigned long )((struct inflate_state *)0)) {
#line 210
    return (-4);
  }
  {
#line 212
  strm->state = (struct internal_state *)state;
#line 213
  state->window = (unsigned char *)0;
#line 214
  ret = inflateReset2(strm, windowBits);
  }
#line 215
  if (ret != 0) {
    {
#line 216
    (*(strm->zfree))(strm->opaque, (voidpf )state);
#line 217
    strm->state = (struct internal_state *)0;
    }
  }
#line 219
  return (ret);
}
}
#line 222 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateInit_(z_streamp strm , char const   *version , int stream_size ) 
{ 
  int tmp ;

  {
  {
#line 227
  tmp = inflateInit2_(strm, 15, version, stream_size);
  }
#line 227
  return (tmp);
}
}
#line 230 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflatePrime(z_streamp strm , int bits , int value ) 
{ 
  struct inflate_state *state ;

  {
#line 237
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 237
    return (-2);
  } else
#line 237
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 237
    return (-2);
  }
#line 238
  state = (struct inflate_state *)strm->state;
#line 239
  if (bits < 0) {
#line 240
    state->hold = 0UL;
#line 241
    state->bits = 0U;
#line 242
    return (0);
  }
#line 244
  if (bits > 16) {
#line 244
    return (-2);
  } else
#line 244
  if (state->bits + (unsigned int )bits > 32U) {
#line 244
    return (-2);
  }
#line 245
  value = (int )((long )value & ((1L << bits) - 1L));
#line 246
  state->hold += (unsigned long )(value << state->bits);
#line 247
  state->bits += (unsigned int )bits;
#line 248
  return (0);
}
}
#line 10 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffixed.h"
static code const   lenfix[512]  = 
#line 10 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffixed.h"
  {      {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)192}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)160}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)224}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)144}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)208}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)176}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)240}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)200}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)168}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)232}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)152}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)216}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)184}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)248}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)196}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)164}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)228}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)148}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)212}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)180}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)244}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)204}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)172}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)236}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)156}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)220}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)188}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)252}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)194}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)162}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)226}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)146}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)210}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)178}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)242}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)202}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)170}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)234}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)154}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)218}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)186}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)250}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)198}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)166}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)230}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)150}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)214}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)182}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)246}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)206}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)174}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)238}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)158}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)222}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)190}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)254}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)193}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)161}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)225}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)145}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)209}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)177}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)241}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)201}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)169}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)233}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)153}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)217}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)185}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)249}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)197}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)165}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)229}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)149}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)213}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)181}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)245}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)205}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)173}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)237}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)157}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)221}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)189}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)253}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)195}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)163}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)227}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)147}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)211}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)179}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)243}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)203}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)171}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)235}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)155}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)219}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)187}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)251}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)199}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)167}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)231}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)151}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)215}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)183}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)247}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)207}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)175}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)239}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)159}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)223}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)191}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)255}};
#line 87 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffixed.h"
static code const   distfix[32]  = 
#line 87
  {      {(unsigned char)16, (unsigned char)5, (unsigned short)1}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)257}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)17}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)4097}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)5}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1025}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)65}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)16385}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)3}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)513}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)33}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)8193}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)9}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)2049}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)129}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)2}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)385}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)25}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)6145}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)7}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1537}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)97}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)24577}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)4}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)769}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)49}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)12289}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)13}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)3073}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)193}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}};
#line 261 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
static void fixedtables(struct inflate_state *state ) 
{ 


  {
#line 298
  state->lencode = lenfix;
#line 299
  state->lenbits = 9U;
#line 300
  state->distcode = distfix;
#line 301
  state->distbits = 5U;
#line 302
  return;
}
}
#line 379 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
static int updatewindow(z_streamp strm , unsigned char const   *end , unsigned int copy ) 
{ 
  struct inflate_state *state ;
  unsigned int dist ;
  voidpf tmp ;

  {
#line 387
  state = (struct inflate_state *)strm->state;
#line 390
  if ((unsigned long )state->window == (unsigned long )((unsigned char *)0)) {
    {
#line 391
    tmp = (*(strm->zalloc))(strm->opaque, 1U << state->wbits, (uInt )sizeof(unsigned char ));
#line 391
    state->window = (unsigned char *)tmp;
    }
#line 394
    if ((unsigned long )state->window == (unsigned long )((unsigned char *)0)) {
#line 394
      return (1);
    }
  }
#line 398
  if (state->wsize == 0U) {
#line 399
    state->wsize = 1U << state->wbits;
#line 400
    state->wnext = 0U;
#line 401
    state->whave = 0U;
  }
#line 405
  if (copy >= state->wsize) {
    {
#line 406
    memcpy((void */* __restrict  */)state->window, (void const   */* __restrict  */)(end - state->wsize),
           (size_t )state->wsize);
#line 407
    state->wnext = 0U;
#line 408
    state->whave = state->wsize;
    }
  } else {
#line 411
    dist = state->wsize - state->wnext;
#line 412
    if (dist > copy) {
#line 412
      dist = copy;
    }
    {
#line 413
    memcpy((void */* __restrict  */)(state->window + state->wnext), (void const   */* __restrict  */)(end - copy),
           (size_t )dist);
#line 414
    copy -= dist;
    }
#line 415
    if (copy) {
      {
#line 416
      memcpy((void */* __restrict  */)state->window, (void const   */* __restrict  */)(end - copy),
             (size_t )copy);
#line 417
      state->wnext = copy;
#line 418
      state->whave = state->wsize;
      }
    } else {
#line 421
      state->wnext += dist;
#line 422
      if (state->wnext == state->wsize) {
#line 422
        state->wnext = 0U;
      }
#line 423
      if (state->whave < state->wsize) {
#line 423
        state->whave += dist;
      }
    }
  }
#line 426
  return (0);
}
}
#line 625 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
static unsigned short const   order[19]  = 
#line 625
  {      (unsigned short const   )16,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )0, 
        (unsigned short const   )8,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )6, 
        (unsigned short const   )10,      (unsigned short const   )5,      (unsigned short const   )11,      (unsigned short const   )4, 
        (unsigned short const   )12,      (unsigned short const   )3,      (unsigned short const   )13,      (unsigned short const   )2, 
        (unsigned short const   )14,      (unsigned short const   )1,      (unsigned short const   )15};
#line 605 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflate(z_streamp strm , int flush ) 
{ 
  struct inflate_state *state ;
  unsigned char *next ;
  unsigned char *put ;
  unsigned int have ;
  unsigned int left ;
  unsigned long hold ;
  unsigned int bits ;
  unsigned int in ;
  unsigned int out ;
  unsigned int copy ;
  unsigned char *from ;
  code here ;
  code last ;
  unsigned int len ;
  int ret ;
  unsigned char *tmp ;
  unsigned long tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int __attribute__((__visibility__("hidden")))  tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned int tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  int __attribute__((__visibility__("hidden")))  tmp___18 ;
  int __attribute__((__visibility__("hidden")))  tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned long tmp___30 ;
  int tmp___31 ;
  unsigned long tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;

  {
#line 628
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 630
    return (-2);
  } else
#line 628
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 630
    return (-2);
  } else
#line 628
  if ((unsigned long )strm->next_out == (unsigned long )((Bytef *)0)) {
#line 630
    return (-2);
  } else
#line 628
  if ((unsigned long )strm->next_in == (unsigned long )((Bytef *)0)) {
#line 628
    if (strm->avail_in != 0U) {
#line 630
      return (-2);
    }
  }
#line 632
  state = (struct inflate_state *)strm->state;
#line 633
  if ((unsigned int )state->mode == 11U) {
#line 633
    state->mode = (inflate_mode )12;
  }
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    put = strm->next_out;
#line 634
    left = strm->avail_out;
#line 634
    next = strm->next_in;
#line 634
    have = strm->avail_in;
#line 634
    hold = state->hold;
#line 634
    bits = state->bits;
#line 634
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  in = have;
#line 636
  out = left;
#line 637
  ret = 0;
  {
#line 638
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 640
    if ((unsigned int )state->mode == 0U) {
#line 640
      goto case_0;
    }
#line 814
    if ((unsigned int )state->mode == 9U) {
#line 814
      goto case_9;
    }
#line 819
    if ((unsigned int )state->mode == 10U) {
#line 819
      goto case_10;
    }
#line 826
    if ((unsigned int )state->mode == 11U) {
#line 826
      goto case_11;
    }
#line 828
    if ((unsigned int )state->mode == 12U) {
#line 828
      goto case_12;
    }
#line 864
    if ((unsigned int )state->mode == 13U) {
#line 864
      goto case_13;
    }
#line 878
    if ((unsigned int )state->mode == 14U) {
#line 878
      goto case_14;
    }
#line 880
    if ((unsigned int )state->mode == 15U) {
#line 880
      goto case_15;
    }
#line 897
    if ((unsigned int )state->mode == 16U) {
#line 897
      goto case_16;
    }
#line 915
    if ((unsigned int )state->mode == 17U) {
#line 915
      goto case_17;
    }
#line 936
    if ((unsigned int )state->mode == 18U) {
#line 936
      goto case_18;
    }
#line 1019
    if ((unsigned int )state->mode == 19U) {
#line 1019
      goto case_19;
    }
#line 1021
    if ((unsigned int )state->mode == 20U) {
#line 1021
      goto case_20;
    }
#line 1070
    if ((unsigned int )state->mode == 21U) {
#line 1070
      goto case_21;
    }
#line 1080
    if ((unsigned int )state->mode == 22U) {
#line 1080
      goto case_22;
    }
#line 1107
    if ((unsigned int )state->mode == 23U) {
#line 1107
      goto case_23;
    }
#line 1123
    if ((unsigned int )state->mode == 24U) {
#line 1123
      goto case_24;
    }
#line 1168
    if ((unsigned int )state->mode == 25U) {
#line 1168
      goto case_25;
    }
#line 1174
    if ((unsigned int )state->mode == 26U) {
#line 1174
      goto case_26;
    }
#line 1211
    if ((unsigned int )state->mode == 28U) {
#line 1211
      goto case_28;
    }
#line 1214
    if ((unsigned int )state->mode == 29U) {
#line 1214
      goto case_29;
    }
#line 1217
    if ((unsigned int )state->mode == 30U) {
#line 1217
      goto case_30;
    }
#line 1220
    goto switch_default;
    case_0: /* CIL Label */ 
#line 641
    if (state->wrap == 0) {
#line 642
      state->mode = (inflate_mode )12;
#line 643
      goto switch_break;
    }
    {
#line 645
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 645
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 645
        if (! (bits < 16U)) {
#line 645
          goto while_break___2;
        }
        {
#line 645
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 645
          if (have == 0U) {
#line 645
            goto inf_leave;
          }
#line 645
          have --;
#line 645
          tmp = next;
#line 645
          next ++;
#line 645
          hold += (unsigned long )*tmp << bits;
#line 645
          bits += 8U;
#line 645
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 645
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 659
    if (((unsigned long )(((unsigned int )hold & ((1U << 8) - 1U)) << 8) + (hold >> 8)) % 31UL) {
#line 662
      strm->msg = (char *)"incorrect header check";
#line 663
      state->mode = (inflate_mode )29;
#line 664
      goto switch_break;
    }
#line 666
    if (((unsigned int )hold & ((1U << 4) - 1U)) != 8U) {
#line 667
      strm->msg = (char *)"unknown compression method";
#line 668
      state->mode = (inflate_mode )29;
#line 669
      goto switch_break;
    }
    {
#line 671
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 671
      hold >>= 4;
#line 671
      bits -= 4U;
#line 671
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 672
    len = ((unsigned int )hold & ((1U << 4) - 1U)) + 8U;
#line 673
    if (state->wbits == 0U) {
#line 674
      state->wbits = len;
    } else
#line 675
    if (len > state->wbits) {
#line 676
      strm->msg = (char *)"invalid window size";
#line 677
      state->mode = (inflate_mode )29;
#line 678
      goto switch_break;
    }
    {
#line 680
    state->dmax = 1U << len;
#line 682
    tmp___0 = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 682
    state->check = tmp___0;
#line 682
    strm->adler = tmp___0;
    }
#line 683
    if (hold & 512UL) {
#line 683
      state->mode = (inflate_mode )9;
    } else {
#line 683
      state->mode = (inflate_mode )11;
    }
    {
#line 684
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 684
      hold = 0UL;
#line 684
      bits = 0U;
#line 684
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 685
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 815
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 815
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 815
        if (! (bits < 32U)) {
#line 815
          goto while_break___7;
        }
        {
#line 815
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 815
          if (have == 0U) {
#line 815
            goto inf_leave;
          }
#line 815
          have --;
#line 815
          tmp___1 = next;
#line 815
          next ++;
#line 815
          hold += (unsigned long )*tmp___1 << bits;
#line 815
          bits += 8U;
#line 815
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 815
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 816
    tmp___2 = ((((hold >> 24) & 255UL) + ((hold >> 8) & 65280UL)) + ((hold & 65280UL) << 8)) + ((hold & 255UL) << 24);
#line 816
    state->check = tmp___2;
#line 816
    strm->adler = tmp___2;
    {
#line 817
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 817
      hold = 0UL;
#line 817
      bits = 0U;
#line 817
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 818
    state->mode = (inflate_mode )10;
    case_10: /* CIL Label */ 
#line 820
    if (state->havedict == 0) {
      {
#line 821
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 821
        strm->next_out = put;
#line 821
        strm->avail_out = left;
#line 821
        strm->next_in = next;
#line 821
        strm->avail_in = have;
#line 821
        state->hold = hold;
#line 821
        state->bits = bits;
#line 821
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 822
      return (2);
    }
    {
#line 824
    tmp___3 = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 824
    state->check = tmp___3;
#line 824
    strm->adler = tmp___3;
#line 825
    state->mode = (inflate_mode )11;
    }
    case_11: /* CIL Label */ 
#line 827
    if (flush == 5) {
#line 827
      goto inf_leave;
    } else
#line 827
    if (flush == 6) {
#line 827
      goto inf_leave;
    }
    case_12: /* CIL Label */ 
#line 829
    if (state->last) {
      {
#line 830
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 830
        hold >>= bits & 7U;
#line 830
        bits -= bits & 7U;
#line 830
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 831
      state->mode = (inflate_mode )26;
#line 832
      goto switch_break;
    }
    {
#line 834
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 834
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 834
        if (! (bits < 3U)) {
#line 834
          goto while_break___13;
        }
        {
#line 834
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 834
          if (have == 0U) {
#line 834
            goto inf_leave;
          }
#line 834
          have --;
#line 834
          tmp___4 = next;
#line 834
          next ++;
#line 834
          hold += (unsigned long )*tmp___4 << bits;
#line 834
          bits += 8U;
#line 834
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 834
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 835
    state->last = (int )((unsigned int )hold & ((1U << 1) - 1U));
    {
#line 836
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 836
      hold >>= 1;
#line 836
      bits --;
#line 836
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 838
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 0U) {
#line 838
      goto case_0___0;
    }
#line 843
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 1U) {
#line 843
      goto case_1;
    }
#line 853
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 2U) {
#line 853
      goto case_2;
    }
#line 858
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 3U) {
#line 858
      goto case_3;
    }
#line 837
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 841
    state->mode = (inflate_mode )13;
#line 842
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 844
    fixedtables(state);
#line 847
    state->mode = (inflate_mode )19;
    }
#line 848
    if (flush == 6) {
      {
#line 849
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 849
        hold >>= 2;
#line 849
        bits -= 2U;
#line 849
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 850
      goto inf_leave;
    }
#line 852
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 856
    state->mode = (inflate_mode )16;
#line 857
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 859
    strm->msg = (char *)"invalid block type";
#line 860
    state->mode = (inflate_mode )29;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 862
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 862
      hold >>= 2;
#line 862
      bits -= 2U;
#line 862
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 863
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 865
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 865
      hold >>= bits & 7U;
#line 865
      bits -= bits & 7U;
#line 865
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 866
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 866
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 866
        if (! (bits < 32U)) {
#line 866
          goto while_break___20;
        }
        {
#line 866
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 866
          if (have == 0U) {
#line 866
            goto inf_leave;
          }
#line 866
          have --;
#line 866
          tmp___5 = next;
#line 866
          next ++;
#line 866
          hold += (unsigned long )*tmp___5 << bits;
#line 866
          bits += 8U;
#line 866
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 866
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 867
    if ((hold & 65535UL) != ((hold >> 16) ^ 65535UL)) {
#line 868
      strm->msg = (char *)"invalid stored block lengths";
#line 869
      state->mode = (inflate_mode )29;
#line 870
      goto switch_break;
    }
#line 872
    state->length = (unsigned int )hold & 65535U;
    {
#line 875
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 875
      hold = 0UL;
#line 875
      bits = 0U;
#line 875
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 876
    state->mode = (inflate_mode )14;
#line 877
    if (flush == 6) {
#line 877
      goto inf_leave;
    }
    case_14: /* CIL Label */ 
#line 879
    state->mode = (inflate_mode )15;
    case_15: /* CIL Label */ 
#line 881
    copy = state->length;
#line 882
    if (copy) {
#line 883
      if (copy > have) {
#line 883
        copy = have;
      }
#line 884
      if (copy > left) {
#line 884
        copy = left;
      }
#line 885
      if (copy == 0U) {
#line 885
        goto inf_leave;
      }
      {
#line 886
      memcpy((void */* __restrict  */)put, (void const   */* __restrict  */)next,
             (size_t )copy);
#line 887
      have -= copy;
#line 888
      next += copy;
#line 889
      left -= copy;
#line 890
      put += copy;
#line 891
      state->length -= copy;
      }
#line 892
      goto switch_break;
    }
#line 895
    state->mode = (inflate_mode )11;
#line 896
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 898
    while (1) {
      while_continue___23: /* CIL Label */ ;
      {
#line 898
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 898
        if (! (bits < 14U)) {
#line 898
          goto while_break___24;
        }
        {
#line 898
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 898
          if (have == 0U) {
#line 898
            goto inf_leave;
          }
#line 898
          have --;
#line 898
          tmp___6 = next;
#line 898
          next ++;
#line 898
          hold += (unsigned long )*tmp___6 << bits;
#line 898
          bits += 8U;
#line 898
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
      }
      while_break___24: /* CIL Label */ ;
      }
#line 898
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 899
    state->nlen = ((unsigned int )hold & ((1U << 5) - 1U)) + 257U;
    {
#line 900
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 900
      hold >>= 5;
#line 900
      bits -= 5U;
#line 900
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 901
    state->ndist = ((unsigned int )hold & ((1U << 5) - 1U)) + 1U;
    {
#line 902
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 902
      hold >>= 5;
#line 902
      bits -= 5U;
#line 902
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 903
    state->ncode = ((unsigned int )hold & ((1U << 4) - 1U)) + 4U;
    {
#line 904
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 904
      hold >>= 4;
#line 904
      bits -= 4U;
#line 904
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 906
    if (state->nlen > 286U) {
#line 907
      strm->msg = (char *)"too many length or distance symbols";
#line 908
      state->mode = (inflate_mode )29;
#line 909
      goto switch_break;
    } else
#line 906
    if (state->ndist > 30U) {
#line 907
      strm->msg = (char *)"too many length or distance symbols";
#line 908
      state->mode = (inflate_mode )29;
#line 909
      goto switch_break;
    }
#line 913
    state->have = 0U;
#line 914
    state->mode = (inflate_mode )17;
    case_17: /* CIL Label */ 
    {
#line 916
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 916
      if (! (state->have < state->ncode)) {
#line 916
        goto while_break___29;
      }
      {
#line 917
      while (1) {
        while_continue___30: /* CIL Label */ ;
        {
#line 917
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 917
          if (! (bits < 3U)) {
#line 917
            goto while_break___31;
          }
          {
#line 917
          while (1) {
            while_continue___32: /* CIL Label */ ;
#line 917
            if (have == 0U) {
#line 917
              goto inf_leave;
            }
#line 917
            have --;
#line 917
            tmp___7 = next;
#line 917
            next ++;
#line 917
            hold += (unsigned long )*tmp___7 << bits;
#line 917
            bits += 8U;
#line 917
            goto while_break___32;
          }
          while_break___32: /* CIL Label */ ;
          }
        }
        while_break___31: /* CIL Label */ ;
        }
#line 917
        goto while_break___30;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 918
      tmp___8 = state->have;
#line 918
      (state->have) ++;
#line 918
      state->lens[order[tmp___8]] = (unsigned short )((unsigned int )hold & ((1U << 3) - 1U));
      {
#line 919
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 919
        hold >>= 3;
#line 919
        bits -= 3U;
#line 919
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 921
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 921
      if (! (state->have < 19U)) {
#line 921
        goto while_break___34;
      }
#line 922
      tmp___9 = state->have;
#line 922
      (state->have) ++;
#line 922
      state->lens[order[tmp___9]] = (unsigned short)0;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 923
    state->next = state->codes;
#line 924
    state->lencode = (code const   *)state->next;
#line 925
    state->lenbits = 7U;
#line 926
    tmp___10 = inflate_table((codetype )0, state->lens, 19U, & state->next, & state->lenbits,
                             state->work);
#line 926
    ret = (int )tmp___10;
    }
#line 928
    if (ret) {
#line 929
      strm->msg = (char *)"invalid code lengths set";
#line 930
      state->mode = (inflate_mode )29;
#line 931
      goto switch_break;
    }
#line 934
    state->have = 0U;
#line 935
    state->mode = (inflate_mode )18;
    case_18: /* CIL Label */ 
    {
#line 937
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 937
      if (! (state->have < state->nlen + state->ndist)) {
#line 937
        goto while_break___35;
      }
      {
#line 938
      while (1) {
        while_continue___36: /* CIL Label */ ;
#line 939
        here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 940
        if ((unsigned int )here.bits <= bits) {
#line 940
          goto while_break___36;
        }
        {
#line 941
        while (1) {
          while_continue___37: /* CIL Label */ ;
#line 941
          if (have == 0U) {
#line 941
            goto inf_leave;
          }
#line 941
          have --;
#line 941
          tmp___11 = next;
#line 941
          next ++;
#line 941
          hold += (unsigned long )*tmp___11 << bits;
#line 941
          bits += 8U;
#line 941
          goto while_break___37;
        }
        while_break___37: /* CIL Label */ ;
        }
      }
      while_break___36: /* CIL Label */ ;
      }
#line 943
      if ((int )here.val < 16) {
        {
#line 944
        while (1) {
          while_continue___38: /* CIL Label */ ;
#line 944
          hold >>= (int )here.bits;
#line 944
          bits -= (unsigned int )here.bits;
#line 944
          goto while_break___38;
        }
        while_break___38: /* CIL Label */ ;
        }
#line 945
        tmp___12 = state->have;
#line 945
        (state->have) ++;
#line 945
        state->lens[tmp___12] = here.val;
      } else {
#line 948
        if ((int )here.val == 16) {
          {
#line 949
          while (1) {
            while_continue___39: /* CIL Label */ ;
            {
#line 949
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 949
              if (! (bits < (unsigned int )((int )here.bits + 2))) {
#line 949
                goto while_break___40;
              }
              {
#line 949
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 949
                if (have == 0U) {
#line 949
                  goto inf_leave;
                }
#line 949
                have --;
#line 949
                tmp___13 = next;
#line 949
                next ++;
#line 949
                hold += (unsigned long )*tmp___13 << bits;
#line 949
                bits += 8U;
#line 949
                goto while_break___41;
              }
              while_break___41: /* CIL Label */ ;
              }
            }
            while_break___40: /* CIL Label */ ;
            }
#line 949
            goto while_break___39;
          }
          while_break___39: /* CIL Label */ ;
          }
          {
#line 950
          while (1) {
            while_continue___42: /* CIL Label */ ;
#line 950
            hold >>= (int )here.bits;
#line 950
            bits -= (unsigned int )here.bits;
#line 950
            goto while_break___42;
          }
          while_break___42: /* CIL Label */ ;
          }
#line 951
          if (state->have == 0U) {
#line 952
            strm->msg = (char *)"invalid bit length repeat";
#line 953
            state->mode = (inflate_mode )29;
#line 954
            goto while_break___35;
          }
#line 956
          len = (unsigned int )state->lens[state->have - 1U];
#line 957
          copy = 3U + ((unsigned int )hold & ((1U << 2) - 1U));
          {
#line 958
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 958
            hold >>= 2;
#line 958
            bits -= 2U;
#line 958
            goto while_break___43;
          }
          while_break___43: /* CIL Label */ ;
          }
        } else
#line 960
        if ((int )here.val == 17) {
          {
#line 961
          while (1) {
            while_continue___44: /* CIL Label */ ;
            {
#line 961
            while (1) {
              while_continue___45: /* CIL Label */ ;
#line 961
              if (! (bits < (unsigned int )((int )here.bits + 3))) {
#line 961
                goto while_break___45;
              }
              {
#line 961
              while (1) {
                while_continue___46: /* CIL Label */ ;
#line 961
                if (have == 0U) {
#line 961
                  goto inf_leave;
                }
#line 961
                have --;
#line 961
                tmp___14 = next;
#line 961
                next ++;
#line 961
                hold += (unsigned long )*tmp___14 << bits;
#line 961
                bits += 8U;
#line 961
                goto while_break___46;
              }
              while_break___46: /* CIL Label */ ;
              }
            }
            while_break___45: /* CIL Label */ ;
            }
#line 961
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
          {
#line 962
          while (1) {
            while_continue___47: /* CIL Label */ ;
#line 962
            hold >>= (int )here.bits;
#line 962
            bits -= (unsigned int )here.bits;
#line 962
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
#line 963
          len = 0U;
#line 964
          copy = 3U + ((unsigned int )hold & ((1U << 3) - 1U));
          {
#line 965
          while (1) {
            while_continue___48: /* CIL Label */ ;
#line 965
            hold >>= 3;
#line 965
            bits -= 3U;
#line 965
            goto while_break___48;
          }
          while_break___48: /* CIL Label */ ;
          }
        } else {
          {
#line 968
          while (1) {
            while_continue___49: /* CIL Label */ ;
            {
#line 968
            while (1) {
              while_continue___50: /* CIL Label */ ;
#line 968
              if (! (bits < (unsigned int )((int )here.bits + 7))) {
#line 968
                goto while_break___50;
              }
              {
#line 968
              while (1) {
                while_continue___51: /* CIL Label */ ;
#line 968
                if (have == 0U) {
#line 968
                  goto inf_leave;
                }
#line 968
                have --;
#line 968
                tmp___15 = next;
#line 968
                next ++;
#line 968
                hold += (unsigned long )*tmp___15 << bits;
#line 968
                bits += 8U;
#line 968
                goto while_break___51;
              }
              while_break___51: /* CIL Label */ ;
              }
            }
            while_break___50: /* CIL Label */ ;
            }
#line 968
            goto while_break___49;
          }
          while_break___49: /* CIL Label */ ;
          }
          {
#line 969
          while (1) {
            while_continue___52: /* CIL Label */ ;
#line 969
            hold >>= (int )here.bits;
#line 969
            bits -= (unsigned int )here.bits;
#line 969
            goto while_break___52;
          }
          while_break___52: /* CIL Label */ ;
          }
#line 970
          len = 0U;
#line 971
          copy = 11U + ((unsigned int )hold & ((1U << 7) - 1U));
          {
#line 972
          while (1) {
            while_continue___53: /* CIL Label */ ;
#line 972
            hold >>= 7;
#line 972
            bits -= 7U;
#line 972
            goto while_break___53;
          }
          while_break___53: /* CIL Label */ ;
          }
        }
#line 974
        if (state->have + copy > state->nlen + state->ndist) {
#line 975
          strm->msg = (char *)"invalid bit length repeat";
#line 976
          state->mode = (inflate_mode )29;
#line 977
          goto while_break___35;
        }
        {
#line 979
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 979
          tmp___17 = copy;
#line 979
          copy --;
#line 979
          if (! tmp___17) {
#line 979
            goto while_break___54;
          }
#line 980
          tmp___16 = state->have;
#line 980
          (state->have) ++;
#line 980
          state->lens[tmp___16] = (unsigned short )len;
        }
        while_break___54: /* CIL Label */ ;
        }
      }
    }
    while_break___35: /* CIL Label */ ;
    }
#line 985
    if ((unsigned int )state->mode == 29U) {
#line 985
      goto switch_break;
    }
#line 988
    if ((int )state->lens[256] == 0) {
#line 989
      strm->msg = (char *)"invalid code -- missing end-of-block";
#line 990
      state->mode = (inflate_mode )29;
#line 991
      goto switch_break;
    }
    {
#line 997
    state->next = state->codes;
#line 998
    state->lencode = (code const   *)state->next;
#line 999
    state->lenbits = 9U;
#line 1000
    tmp___18 = inflate_table((codetype )1, state->lens, state->nlen, & state->next,
                             & state->lenbits, state->work);
#line 1000
    ret = (int )tmp___18;
    }
#line 1002
    if (ret) {
#line 1003
      strm->msg = (char *)"invalid literal/lengths set";
#line 1004
      state->mode = (inflate_mode )29;
#line 1005
      goto switch_break;
    }
    {
#line 1007
    state->distcode = (code const   *)state->next;
#line 1008
    state->distbits = 6U;
#line 1009
    tmp___19 = inflate_table((codetype )2, state->lens + state->nlen, state->ndist,
                             & state->next, & state->distbits, state->work);
#line 1009
    ret = (int )tmp___19;
    }
#line 1011
    if (ret) {
#line 1012
      strm->msg = (char *)"invalid distances set";
#line 1013
      state->mode = (inflate_mode )29;
#line 1014
      goto switch_break;
    }
#line 1017
    state->mode = (inflate_mode )19;
#line 1018
    if (flush == 6) {
#line 1018
      goto inf_leave;
    }
    case_19: /* CIL Label */ 
#line 1020
    state->mode = (inflate_mode )20;
    case_20: /* CIL Label */ 
#line 1022
    if (have >= 6U) {
#line 1022
      if (left >= 258U) {
        {
#line 1023
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 1023
          strm->next_out = put;
#line 1023
          strm->avail_out = left;
#line 1023
          strm->next_in = next;
#line 1023
          strm->avail_in = have;
#line 1023
          state->hold = hold;
#line 1023
          state->bits = bits;
#line 1023
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
        {
#line 1024
        inflate_fast(strm, out);
        }
        {
#line 1025
        while (1) {
          while_continue___56: /* CIL Label */ ;
#line 1025
          put = strm->next_out;
#line 1025
          left = strm->avail_out;
#line 1025
          next = strm->next_in;
#line 1025
          have = strm->avail_in;
#line 1025
          hold = state->hold;
#line 1025
          bits = state->bits;
#line 1025
          goto while_break___56;
        }
        while_break___56: /* CIL Label */ ;
        }
#line 1026
        if ((unsigned int )state->mode == 11U) {
#line 1027
          state->back = -1;
        }
#line 1028
        goto switch_break;
      }
    }
#line 1030
    state->back = 0;
    {
#line 1031
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 1032
      here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 1033
      if ((unsigned int )here.bits <= bits) {
#line 1033
        goto while_break___57;
      }
      {
#line 1034
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 1034
        if (have == 0U) {
#line 1034
          goto inf_leave;
        }
#line 1034
        have --;
#line 1034
        tmp___20 = next;
#line 1034
        next ++;
#line 1034
        hold += (unsigned long )*tmp___20 << bits;
#line 1034
        bits += 8U;
#line 1034
        goto while_break___58;
      }
      while_break___58: /* CIL Label */ ;
      }
    }
    while_break___57: /* CIL Label */ ;
    }
#line 1036
    if (here.op) {
#line 1036
      if (((int )here.op & 240) == 0) {
#line 1037
        last = here;
        {
#line 1038
        while (1) {
          while_continue___59: /* CIL Label */ ;
#line 1039
          here = (code )*(state->lencode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 1041
          if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 1041
            goto while_break___59;
          }
          {
#line 1042
          while (1) {
            while_continue___60: /* CIL Label */ ;
#line 1042
            if (have == 0U) {
#line 1042
              goto inf_leave;
            }
#line 1042
            have --;
#line 1042
            tmp___21 = next;
#line 1042
            next ++;
#line 1042
            hold += (unsigned long )*tmp___21 << bits;
#line 1042
            bits += 8U;
#line 1042
            goto while_break___60;
          }
          while_break___60: /* CIL Label */ ;
          }
        }
        while_break___59: /* CIL Label */ ;
        }
        {
#line 1044
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 1044
          hold >>= (int )last.bits;
#line 1044
          bits -= (unsigned int )last.bits;
#line 1044
          goto while_break___61;
        }
        while_break___61: /* CIL Label */ ;
        }
#line 1045
        state->back += (int )last.bits;
      }
    }
    {
#line 1047
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 1047
      hold >>= (int )here.bits;
#line 1047
      bits -= (unsigned int )here.bits;
#line 1047
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
#line 1048
    state->back += (int )here.bits;
#line 1049
    state->length = (unsigned int )here.val;
#line 1050
    if ((int )here.op == 0) {
#line 1054
      state->mode = (inflate_mode )25;
#line 1055
      goto switch_break;
    }
#line 1057
    if ((int )here.op & 32) {
#line 1059
      state->back = -1;
#line 1060
      state->mode = (inflate_mode )11;
#line 1061
      goto switch_break;
    }
#line 1063
    if ((int )here.op & 64) {
#line 1064
      strm->msg = (char *)"invalid literal/length code";
#line 1065
      state->mode = (inflate_mode )29;
#line 1066
      goto switch_break;
    }
#line 1068
    state->extra = (unsigned int )here.op & 15U;
#line 1069
    state->mode = (inflate_mode )21;
    case_21: /* CIL Label */ 
#line 1071
    if (state->extra) {
      {
#line 1072
      while (1) {
        while_continue___63: /* CIL Label */ ;
        {
#line 1072
        while (1) {
          while_continue___64: /* CIL Label */ ;
#line 1072
          if (! (bits < state->extra)) {
#line 1072
            goto while_break___64;
          }
          {
#line 1072
          while (1) {
            while_continue___65: /* CIL Label */ ;
#line 1072
            if (have == 0U) {
#line 1072
              goto inf_leave;
            }
#line 1072
            have --;
#line 1072
            tmp___22 = next;
#line 1072
            next ++;
#line 1072
            hold += (unsigned long )*tmp___22 << bits;
#line 1072
            bits += 8U;
#line 1072
            goto while_break___65;
          }
          while_break___65: /* CIL Label */ ;
          }
        }
        while_break___64: /* CIL Label */ ;
        }
#line 1072
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
#line 1073
      state->length += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 1074
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 1074
        hold >>= state->extra;
#line 1074
        bits -= state->extra;
#line 1074
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
#line 1075
      state->back = (int )((unsigned int )state->back + state->extra);
    }
#line 1078
    state->was = state->length;
#line 1079
    state->mode = (inflate_mode )22;
    case_22: /* CIL Label */ 
    {
#line 1081
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 1082
      here = (code )*(state->distcode + ((unsigned int )hold & ((1U << state->distbits) - 1U)));
#line 1083
      if ((unsigned int )here.bits <= bits) {
#line 1083
        goto while_break___67;
      }
      {
#line 1084
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 1084
        if (have == 0U) {
#line 1084
          goto inf_leave;
        }
#line 1084
        have --;
#line 1084
        tmp___23 = next;
#line 1084
        next ++;
#line 1084
        hold += (unsigned long )*tmp___23 << bits;
#line 1084
        bits += 8U;
#line 1084
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
    }
    while_break___67: /* CIL Label */ ;
    }
#line 1086
    if (((int )here.op & 240) == 0) {
#line 1087
      last = here;
      {
#line 1088
      while (1) {
        while_continue___69: /* CIL Label */ ;
#line 1089
        here = (code )*(state->distcode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 1091
        if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 1091
          goto while_break___69;
        }
        {
#line 1092
        while (1) {
          while_continue___70: /* CIL Label */ ;
#line 1092
          if (have == 0U) {
#line 1092
            goto inf_leave;
          }
#line 1092
          have --;
#line 1092
          tmp___24 = next;
#line 1092
          next ++;
#line 1092
          hold += (unsigned long )*tmp___24 << bits;
#line 1092
          bits += 8U;
#line 1092
          goto while_break___70;
        }
        while_break___70: /* CIL Label */ ;
        }
      }
      while_break___69: /* CIL Label */ ;
      }
      {
#line 1094
      while (1) {
        while_continue___71: /* CIL Label */ ;
#line 1094
        hold >>= (int )last.bits;
#line 1094
        bits -= (unsigned int )last.bits;
#line 1094
        goto while_break___71;
      }
      while_break___71: /* CIL Label */ ;
      }
#line 1095
      state->back += (int )last.bits;
    }
    {
#line 1097
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 1097
      hold >>= (int )here.bits;
#line 1097
      bits -= (unsigned int )here.bits;
#line 1097
      goto while_break___72;
    }
    while_break___72: /* CIL Label */ ;
    }
#line 1098
    state->back += (int )here.bits;
#line 1099
    if ((int )here.op & 64) {
#line 1100
      strm->msg = (char *)"invalid distance code";
#line 1101
      state->mode = (inflate_mode )29;
#line 1102
      goto switch_break;
    }
#line 1104
    state->offset = (unsigned int )here.val;
#line 1105
    state->extra = (unsigned int )here.op & 15U;
#line 1106
    state->mode = (inflate_mode )23;
    case_23: /* CIL Label */ 
#line 1108
    if (state->extra) {
      {
#line 1109
      while (1) {
        while_continue___73: /* CIL Label */ ;
        {
#line 1109
        while (1) {
          while_continue___74: /* CIL Label */ ;
#line 1109
          if (! (bits < state->extra)) {
#line 1109
            goto while_break___74;
          }
          {
#line 1109
          while (1) {
            while_continue___75: /* CIL Label */ ;
#line 1109
            if (have == 0U) {
#line 1109
              goto inf_leave;
            }
#line 1109
            have --;
#line 1109
            tmp___25 = next;
#line 1109
            next ++;
#line 1109
            hold += (unsigned long )*tmp___25 << bits;
#line 1109
            bits += 8U;
#line 1109
            goto while_break___75;
          }
          while_break___75: /* CIL Label */ ;
          }
        }
        while_break___74: /* CIL Label */ ;
        }
#line 1109
        goto while_break___73;
      }
      while_break___73: /* CIL Label */ ;
      }
#line 1110
      state->offset += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 1111
      while (1) {
        while_continue___76: /* CIL Label */ ;
#line 1111
        hold >>= state->extra;
#line 1111
        bits -= state->extra;
#line 1111
        goto while_break___76;
      }
      while_break___76: /* CIL Label */ ;
      }
#line 1112
      state->back = (int )((unsigned int )state->back + state->extra);
    }
#line 1122
    state->mode = (inflate_mode )24;
    case_24: /* CIL Label */ 
#line 1124
    if (left == 0U) {
#line 1124
      goto inf_leave;
    }
#line 1125
    copy = out - left;
#line 1126
    if (state->offset > copy) {
#line 1127
      copy = state->offset - copy;
#line 1128
      if (copy > state->whave) {
#line 1129
        if (state->sane) {
#line 1130
          strm->msg = (char *)"invalid distance too far back";
#line 1131
          state->mode = (inflate_mode )29;
#line 1132
          goto switch_break;
        }
      }
#line 1148
      if (copy > state->wnext) {
#line 1149
        copy -= state->wnext;
#line 1150
        from = state->window + (state->wsize - copy);
      } else {
#line 1153
        from = state->window + (state->wnext - copy);
      }
#line 1154
      if (copy > state->length) {
#line 1154
        copy = state->length;
      }
    } else {
#line 1157
      from = put - state->offset;
#line 1158
      copy = state->length;
    }
#line 1160
    if (copy > left) {
#line 1160
      copy = left;
    }
#line 1161
    left -= copy;
#line 1162
    state->length -= copy;
    {
#line 1163
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 1164
      tmp___26 = put;
#line 1164
      put ++;
#line 1164
      tmp___27 = from;
#line 1164
      from ++;
#line 1164
      *tmp___26 = *tmp___27;
#line 1163
      copy --;
#line 1163
      if (! copy) {
#line 1163
        goto while_break___77;
      }
    }
    while_break___77: /* CIL Label */ ;
    }
#line 1166
    if (state->length == 0U) {
#line 1166
      state->mode = (inflate_mode )20;
    }
#line 1167
    goto switch_break;
    case_25: /* CIL Label */ 
#line 1169
    if (left == 0U) {
#line 1169
      goto inf_leave;
    }
#line 1170
    tmp___28 = put;
#line 1170
    put ++;
#line 1170
    *tmp___28 = (unsigned char )state->length;
#line 1171
    left --;
#line 1172
    state->mode = (inflate_mode )20;
#line 1173
    goto switch_break;
    case_26: /* CIL Label */ 
#line 1175
    if (state->wrap) {
      {
#line 1176
      while (1) {
        while_continue___78: /* CIL Label */ ;
        {
#line 1176
        while (1) {
          while_continue___79: /* CIL Label */ ;
#line 1176
          if (! (bits < 32U)) {
#line 1176
            goto while_break___79;
          }
          {
#line 1176
          while (1) {
            while_continue___80: /* CIL Label */ ;
#line 1176
            if (have == 0U) {
#line 1176
              goto inf_leave;
            }
#line 1176
            have --;
#line 1176
            tmp___29 = next;
#line 1176
            next ++;
#line 1176
            hold += (unsigned long )*tmp___29 << bits;
#line 1176
            bits += 8U;
#line 1176
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
        }
        while_break___79: /* CIL Label */ ;
        }
#line 1176
        goto while_break___78;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 1177
      out -= left;
#line 1178
      strm->total_out += (uLong )out;
#line 1179
      state->total += (unsigned long )out;
#line 1180
      if (out) {
        {
#line 1181
        tmp___30 = adler32(state->check, (Bytef const   *)(put - out), out);
#line 1181
        state->check = tmp___30;
#line 1181
        strm->adler = tmp___30;
        }
      }
#line 1183
      out = left;
#line 1184
      if (((((hold >> 24) & 255UL) + ((hold >> 8) & 65280UL)) + ((hold & 65280UL) << 8)) + ((hold & 255UL) << 24) != state->check) {
#line 1189
        strm->msg = (char *)"incorrect data check";
#line 1190
        state->mode = (inflate_mode )29;
#line 1191
        goto switch_break;
      }
      {
#line 1193
      while (1) {
        while_continue___81: /* CIL Label */ ;
#line 1193
        hold = 0UL;
#line 1193
        bits = 0U;
#line 1193
        goto while_break___81;
      }
      while_break___81: /* CIL Label */ ;
      }
    }
#line 1210
    state->mode = (inflate_mode )28;
    case_28: /* CIL Label */ 
#line 1212
    ret = 1;
#line 1213
    goto inf_leave;
    case_29: /* CIL Label */ 
#line 1215
    ret = -3;
#line 1216
    goto inf_leave;
    case_30: /* CIL Label */ 
#line 1218
    return (-4);
    switch_default: /* CIL Label */ 
#line 1221
    return (-2);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  inf_leave: 
  {
#line 1231
  while (1) {
    while_continue___82: /* CIL Label */ ;
#line 1231
    strm->next_out = put;
#line 1231
    strm->avail_out = left;
#line 1231
    strm->next_in = next;
#line 1231
    strm->avail_in = have;
#line 1231
    state->hold = hold;
#line 1231
    state->bits = bits;
#line 1231
    goto while_break___82;
  }
  while_break___82: /* CIL Label */ ;
  }
#line 1232
  if (state->wsize) {
#line 1232
    goto _L___0;
  } else
#line 1232
  if (out != strm->avail_out) {
#line 1232
    if ((unsigned int )state->mode < 29U) {
#line 1232
      if ((unsigned int )state->mode < 26U) {
#line 1232
        goto _L___0;
      } else
#line 1232
      if (flush != 4) {
        _L___0: /* CIL Label */ 
        {
#line 1234
        tmp___31 = updatewindow(strm, (unsigned char const   *)strm->next_out, out - strm->avail_out);
        }
#line 1234
        if (tmp___31) {
#line 1235
          state->mode = (inflate_mode )30;
#line 1236
          return (-4);
        }
      }
    }
  }
#line 1238
  in -= strm->avail_in;
#line 1239
  out -= strm->avail_out;
#line 1240
  strm->total_in += (uLong )in;
#line 1241
  strm->total_out += (uLong )out;
#line 1242
  state->total += (unsigned long )out;
#line 1243
  if (state->wrap) {
#line 1243
    if (out) {
      {
#line 1244
      tmp___32 = adler32(state->check, (Bytef const   *)(strm->next_out - out), out);
#line 1244
      state->check = tmp___32;
#line 1244
      strm->adler = tmp___32;
      }
    }
  }
#line 1246
  if (state->last) {
#line 1246
    tmp___33 = 64;
  } else {
#line 1246
    tmp___33 = 0;
  }
#line 1246
  if ((unsigned int )state->mode == 11U) {
#line 1246
    tmp___34 = 128;
  } else {
#line 1246
    tmp___34 = 0;
  }
#line 1246
  if ((unsigned int )state->mode == 19U) {
#line 1246
    tmp___35 = 256;
  } else
#line 1246
  if ((unsigned int )state->mode == 14U) {
#line 1246
    tmp___35 = 256;
  } else {
#line 1246
    tmp___35 = 0;
  }
#line 1246
  strm->data_type = (int )(((state->bits + (unsigned int )tmp___33) + (unsigned int )tmp___34) + (unsigned int )tmp___35);
#line 1249
  if (in == 0U) {
#line 1249
    if (out == 0U) {
#line 1249
      goto _L___1;
    } else {
#line 1249
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1249
  if (flush == 4) {
    _L___1: /* CIL Label */ 
#line 1249
    if (ret == 0) {
#line 1250
      ret = -5;
    }
  }
#line 1251
  return (ret);
}
}
#line 1254 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateEnd(z_streamp strm ) 
{ 
  struct inflate_state *state ;

  {
#line 1258
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1259
    return (-2);
  } else
#line 1258
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1259
    return (-2);
  } else
#line 1258
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 1259
    return (-2);
  }
#line 1260
  state = (struct inflate_state *)strm->state;
#line 1261
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
    {
#line 1261
    (*(strm->zfree))(strm->opaque, (voidpf )state->window);
    }
  }
  {
#line 1262
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 1263
  strm->state = (struct internal_state *)0;
  }
#line 1265
  return (0);
}
}
#line 1268 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) 
{ 
  struct inflate_state *state ;

  {
#line 1276
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1276
    return (-2);
  } else
#line 1276
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1276
    return (-2);
  }
#line 1277
  state = (struct inflate_state *)strm->state;
#line 1280
  if (state->whave) {
#line 1280
    if ((unsigned long )dictionary != (unsigned long )((Bytef *)0)) {
      {
#line 1281
      memcpy((void */* __restrict  */)dictionary, (void const   */* __restrict  */)(state->window + state->wnext),
             (size_t )(state->whave - state->wnext));
#line 1283
      memcpy((void */* __restrict  */)((dictionary + state->whave) - state->wnext),
             (void const   */* __restrict  */)state->window, (size_t )state->wnext);
      }
    }
  }
#line 1286
  if ((unsigned long )dictLength != (unsigned long )((uInt *)0)) {
#line 1287
    *dictLength = state->whave;
  }
#line 1288
  return (0);
}
}
#line 1291 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) 
{ 
  struct inflate_state *state ;
  unsigned long dictid ;
  int ret ;

  {
#line 1301
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1301
    return (-2);
  } else
#line 1301
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1301
    return (-2);
  }
#line 1302
  state = (struct inflate_state *)strm->state;
#line 1303
  if (state->wrap != 0) {
#line 1303
    if ((unsigned int )state->mode != 10U) {
#line 1304
      return (-2);
    }
  }
#line 1307
  if ((unsigned int )state->mode == 10U) {
    {
#line 1308
    dictid = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 1309
    dictid = adler32(dictid, dictionary, dictLength);
    }
#line 1310
    if (dictid != state->check) {
#line 1311
      return (-3);
    }
  }
  {
#line 1316
  ret = updatewindow(strm, dictionary + dictLength, dictLength);
  }
#line 1317
  if (ret) {
#line 1318
    state->mode = (inflate_mode )30;
#line 1319
    return (-4);
  }
#line 1321
  state->havedict = 1;
#line 1323
  return (0);
}
}
#line 1326 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateGetHeader(z_streamp strm , gz_headerp head ) 
{ 
  struct inflate_state *state ;

  {
#line 1333
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1333
    return (-2);
  } else
#line 1333
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1333
    return (-2);
  }
#line 1334
  state = (struct inflate_state *)strm->state;
#line 1335
  if ((state->wrap & 2) == 0) {
#line 1335
    return (-2);
  }
#line 1338
  state->head = head;
#line 1339
  head->done = 0;
#line 1340
  return (0);
}
}
#line 1354 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
static unsigned int syncsearch(unsigned int *have , unsigned char const   *buf , unsigned int len ) 
{ 
  unsigned int got ;
  unsigned int next ;
  int tmp ;

  {
#line 1362
  got = *have;
#line 1363
  next = 0U;
  {
#line 1364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1364
    if (next < len) {
#line 1364
      if (! (got < 4U)) {
#line 1364
        goto while_break;
      }
    } else {
#line 1364
      goto while_break;
    }
#line 1365
    if (got < 2U) {
#line 1365
      tmp = 0;
    } else {
#line 1365
      tmp = 255;
    }
#line 1365
    if ((int )*(buf + next) == tmp) {
#line 1366
      got ++;
    } else
#line 1367
    if (*(buf + next)) {
#line 1368
      got = 0U;
    } else {
#line 1370
      got = 4U - got;
    }
#line 1371
    next ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1373
  *have = got;
#line 1374
  return (next);
}
}
#line 1377 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateSync(z_streamp strm ) 
{ 
  unsigned int len ;
  unsigned long in ;
  unsigned long out ;
  unsigned char buf[4] ;
  struct inflate_state *state ;
  unsigned int tmp ;

  {
#line 1386
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1386
    return (-2);
  } else
#line 1386
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1386
    return (-2);
  }
#line 1387
  state = (struct inflate_state *)strm->state;
#line 1388
  if (strm->avail_in == 0U) {
#line 1388
    if (state->bits < 8U) {
#line 1388
      return (-5);
    }
  }
#line 1391
  if ((unsigned int )state->mode != 31U) {
#line 1392
    state->mode = (inflate_mode )31;
#line 1393
    state->hold <<= state->bits & 7U;
#line 1394
    state->bits -= state->bits & 7U;
#line 1395
    len = 0U;
    {
#line 1396
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1396
      if (! (state->bits >= 8U)) {
#line 1396
        goto while_break;
      }
#line 1397
      tmp = len;
#line 1397
      len ++;
#line 1397
      buf[tmp] = (unsigned char )state->hold;
#line 1398
      state->hold >>= 8;
#line 1399
      state->bits -= 8U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1401
    state->have = 0U;
#line 1402
    syncsearch(& state->have, (unsigned char const   *)(buf), len);
    }
  }
  {
#line 1406
  len = syncsearch(& state->have, (unsigned char const   *)strm->next_in, strm->avail_in);
#line 1407
  strm->avail_in -= len;
#line 1408
  strm->next_in += len;
#line 1409
  strm->total_in += (uLong )len;
  }
#line 1412
  if (state->have != 4U) {
#line 1412
    return (-3);
  }
  {
#line 1413
  in = strm->total_in;
#line 1413
  out = strm->total_out;
#line 1414
  inflateReset(strm);
#line 1415
  strm->total_in = in;
#line 1415
  strm->total_out = out;
#line 1416
  state->mode = (inflate_mode )11;
  }
#line 1417
  return (0);
}
}
#line 1428 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateSyncPoint(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
#line 1433
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1433
    return (-2);
  } else
#line 1433
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1433
    return (-2);
  }
#line 1434
  state = (struct inflate_state *)strm->state;
#line 1435
  if ((unsigned int )state->mode == 13U) {
#line 1435
    if (state->bits == 0U) {
#line 1435
      tmp = 1;
    } else {
#line 1435
      tmp = 0;
    }
  } else {
#line 1435
    tmp = 0;
  }
#line 1435
  return (tmp);
}
}
#line 1438 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateCopy(z_streamp dest , z_streamp source ) 
{ 
  struct inflate_state *state ;
  struct inflate_state *copy ;
  unsigned char *window ;
  unsigned int wsize ;
  voidpf tmp ;
  voidpf tmp___0 ;

  {
#line 1448
  if ((unsigned long )dest == (unsigned long )((z_streamp )0)) {
#line 1450
    return (-2);
  } else
#line 1448
  if ((unsigned long )source == (unsigned long )((z_streamp )0)) {
#line 1450
    return (-2);
  } else
#line 1448
  if ((unsigned long )source->state == (unsigned long )((struct internal_state *)0)) {
#line 1450
    return (-2);
  } else
#line 1448
  if ((unsigned long )source->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                     uInt items ,
                                                                     uInt size ))0)) {
#line 1450
    return (-2);
  } else
#line 1448
  if ((unsigned long )source->zfree == (unsigned long )((void (*)(voidpf opaque ,
                                                                  voidpf address ))0)) {
#line 1450
    return (-2);
  }
  {
#line 1451
  state = (struct inflate_state *)source->state;
#line 1454
  tmp = (*(source->zalloc))(source->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 1454
  copy = (struct inflate_state *)tmp;
  }
#line 1456
  if ((unsigned long )copy == (unsigned long )((struct inflate_state *)0)) {
#line 1456
    return (-4);
  }
#line 1457
  window = (unsigned char *)0;
#line 1458
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
    {
#line 1459
    tmp___0 = (*(source->zalloc))(source->opaque, 1U << state->wbits, (uInt )sizeof(unsigned char ));
#line 1459
    window = (unsigned char *)tmp___0;
    }
#line 1461
    if ((unsigned long )window == (unsigned long )((unsigned char *)0)) {
      {
#line 1462
      (*(source->zfree))(source->opaque, (voidpf )copy);
      }
#line 1463
      return (-4);
    }
  }
  {
#line 1468
  memcpy((void */* __restrict  */)((voidpf )dest), (void const   */* __restrict  */)((voidpf )source),
         sizeof(z_stream ));
#line 1469
  memcpy((void */* __restrict  */)((voidpf )copy), (void const   */* __restrict  */)((voidpf )state),
         sizeof(struct inflate_state ));
  }
#line 1470
  if ((unsigned long )state->lencode >= (unsigned long )(state->codes)) {
#line 1470
    if ((unsigned long )state->lencode <= (unsigned long )((state->codes + 1444) - 1)) {
#line 1472
      copy->lencode = (code const   *)(copy->codes + (state->lencode - (code const   *)(state->codes)));
#line 1473
      copy->distcode = (code const   *)(copy->codes + (state->distcode - (code const   *)(state->codes)));
    }
  }
#line 1475
  copy->next = copy->codes + (state->next - state->codes);
#line 1476
  if ((unsigned long )window != (unsigned long )((unsigned char *)0)) {
    {
#line 1477
    wsize = 1U << state->wbits;
#line 1478
    memcpy((void */* __restrict  */)window, (void const   */* __restrict  */)state->window,
           (size_t )wsize);
    }
  }
#line 1480
  copy->window = window;
#line 1481
  dest->state = (struct internal_state *)copy;
#line 1482
  return (0);
}
}
#line 1485 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
int inflateUndermine(z_streamp strm , int subvert ) 
{ 
  struct inflate_state *state ;

  {
#line 1491
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1491
    return (-2);
  } else
#line 1491
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1491
    return (-2);
  }
#line 1492
  state = (struct inflate_state *)strm->state;
#line 1493
  state->sane = ! subvert;
#line 1497
  state->sane = 1;
#line 1498
  return (-3);
}
}
#line 1502 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inflate.c"
long inflateMark(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 1507
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 1507
    return (-1L << 16);
  } else
#line 1507
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 1507
    return (-1L << 16);
  }
#line 1508
  state = (struct inflate_state *)strm->state;
#line 1509
  if ((unsigned int )state->mode == 15U) {
#line 1509
    tmp___0 = state->length;
  } else {
#line 1509
    if ((unsigned int )state->mode == 24U) {
#line 1509
      tmp = state->was - state->length;
    } else {
#line 1509
      tmp = 0U;
    }
#line 1509
    tmp___0 = tmp;
  }
#line 1509
  return (((long )state->back << 16) + (long )tmp___0);
}
}
#line 67 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffast.c"
void __attribute__((__visibility__("hidden")))  inflate_fast(z_streamp strm , unsigned int start ) 
{ 
  struct inflate_state *state ;
  unsigned char *in ;
  unsigned char *last ;
  unsigned char *out ;
  unsigned char *beg ;
  unsigned char *end ;
  unsigned int wsize ;
  unsigned int whave ;
  unsigned int wnext ;
  unsigned char *window ;
  unsigned long hold ;
  unsigned int bits ;
  code const   *lcode ;
  code const   *dcode ;
  unsigned int lmask ;
  unsigned int dmask ;
  code here ;
  unsigned int op ;
  unsigned int len ;
  unsigned int dist ;
  unsigned char *from ;
  long tmp ;
  long tmp___0 ;

  {
#line 98
  state = (struct inflate_state *)strm->state;
#line 99
  in = strm->next_in - 1;
#line 100
  last = in + (strm->avail_in - 5U);
#line 101
  out = strm->next_out - 1;
#line 102
  beg = out - (start - strm->avail_out);
#line 103
  end = out + (strm->avail_out - 257U);
#line 107
  wsize = state->wsize;
#line 108
  whave = state->whave;
#line 109
  wnext = state->wnext;
#line 110
  window = state->window;
#line 111
  hold = state->hold;
#line 112
  bits = state->bits;
#line 113
  lcode = state->lencode;
#line 114
  dcode = state->distcode;
#line 115
  lmask = (1U << state->lenbits) - 1U;
#line 116
  dmask = (1U << state->distbits) - 1U;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (bits < 15U) {
#line 122
      in ++;
#line 122
      hold += (unsigned long )*in << bits;
#line 123
      bits += 8U;
#line 124
      in ++;
#line 124
      hold += (unsigned long )*in << bits;
#line 125
      bits += 8U;
    }
#line 127
    here = (code )*(lcode + (hold & (unsigned long )lmask));
    dolen: 
#line 129
    op = (unsigned int )here.bits;
#line 130
    hold >>= op;
#line 131
    bits -= op;
#line 132
    op = (unsigned int )here.op;
#line 133
    if (op == 0U) {
#line 137
      out ++;
#line 137
      *out = (unsigned char )here.val;
    } else
#line 139
    if (op & 16U) {
#line 140
      len = (unsigned int )here.val;
#line 141
      op &= 15U;
#line 142
      if (op) {
#line 143
        if (bits < op) {
#line 144
          in ++;
#line 144
          hold += (unsigned long )*in << bits;
#line 145
          bits += 8U;
        }
#line 147
        len += (unsigned int )hold & ((1U << op) - 1U);
#line 148
        hold >>= op;
#line 149
        bits -= op;
      }
#line 152
      if (bits < 15U) {
#line 153
        in ++;
#line 153
        hold += (unsigned long )*in << bits;
#line 154
        bits += 8U;
#line 155
        in ++;
#line 155
        hold += (unsigned long )*in << bits;
#line 156
        bits += 8U;
      }
#line 158
      here = (code )*(dcode + (hold & (unsigned long )dmask));
      dodist: 
#line 160
      op = (unsigned int )here.bits;
#line 161
      hold >>= op;
#line 162
      bits -= op;
#line 163
      op = (unsigned int )here.op;
#line 164
      if (op & 16U) {
#line 165
        dist = (unsigned int )here.val;
#line 166
        op &= 15U;
#line 167
        if (bits < op) {
#line 168
          in ++;
#line 168
          hold += (unsigned long )*in << bits;
#line 169
          bits += 8U;
#line 170
          if (bits < op) {
#line 171
            in ++;
#line 171
            hold += (unsigned long )*in << bits;
#line 172
            bits += 8U;
          }
        }
#line 175
        dist += (unsigned int )hold & ((1U << op) - 1U);
#line 183
        hold >>= op;
#line 184
        bits -= op;
#line 186
        op = (unsigned int )(out - beg);
#line 187
        if (dist > op) {
#line 188
          op = dist - op;
#line 189
          if (op > whave) {
#line 190
            if (state->sane) {
#line 191
              strm->msg = (char *)"invalid distance too far back";
#line 193
              state->mode = (inflate_mode )29;
#line 194
              goto while_break;
            }
          }
#line 216
          from = window - 1;
#line 217
          if (wnext == 0U) {
#line 218
            from += wsize - op;
#line 219
            if (op < len) {
#line 220
              len -= op;
              {
#line 221
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 222
                out ++;
#line 222
                from ++;
#line 222
                *out = *from;
#line 221
                op --;
#line 221
                if (! op) {
#line 221
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 224
              from = out - dist;
            }
          } else
#line 227
          if (wnext < op) {
#line 228
            from += (wsize + wnext) - op;
#line 229
            op -= wnext;
#line 230
            if (op < len) {
#line 231
              len -= op;
              {
#line 232
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 233
                out ++;
#line 233
                from ++;
#line 233
                *out = *from;
#line 232
                op --;
#line 232
                if (! op) {
#line 232
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 235
              from = window - 1;
#line 236
              if (wnext < len) {
#line 237
                op = wnext;
#line 238
                len -= op;
                {
#line 239
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 240
                  out ++;
#line 240
                  from ++;
#line 240
                  *out = *from;
#line 239
                  op --;
#line 239
                  if (! op) {
#line 239
                    goto while_break___2;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
#line 242
                from = out - dist;
              }
            }
          } else {
#line 247
            from += wnext - op;
#line 248
            if (op < len) {
#line 249
              len -= op;
              {
#line 250
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 251
                out ++;
#line 251
                from ++;
#line 251
                *out = *from;
#line 250
                op --;
#line 250
                if (! op) {
#line 250
                  goto while_break___3;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 253
              from = out - dist;
            }
          }
          {
#line 256
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 256
            if (! (len > 2U)) {
#line 256
              goto while_break___4;
            }
#line 257
            out ++;
#line 257
            from ++;
#line 257
            *out = *from;
#line 258
            out ++;
#line 258
            from ++;
#line 258
            *out = *from;
#line 259
            out ++;
#line 259
            from ++;
#line 259
            *out = *from;
#line 260
            len -= 3U;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 262
          if (len) {
#line 263
            out ++;
#line 263
            from ++;
#line 263
            *out = *from;
#line 264
            if (len > 1U) {
#line 265
              out ++;
#line 265
              from ++;
#line 265
              *out = *from;
            }
          }
        } else {
#line 269
          from = out - dist;
          {
#line 270
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 271
            out ++;
#line 271
            from ++;
#line 271
            *out = *from;
#line 272
            out ++;
#line 272
            from ++;
#line 272
            *out = *from;
#line 273
            out ++;
#line 273
            from ++;
#line 273
            *out = *from;
#line 274
            len -= 3U;
#line 270
            if (! (len > 2U)) {
#line 270
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 276
          if (len) {
#line 277
            out ++;
#line 277
            from ++;
#line 277
            *out = *from;
#line 278
            if (len > 1U) {
#line 279
              out ++;
#line 279
              from ++;
#line 279
              *out = *from;
            }
          }
        }
      } else
#line 283
      if ((op & 64U) == 0U) {
#line 284
        here = (code )*(dcode + ((unsigned long )here.val + (hold & (unsigned long )((1U << op) - 1U))));
#line 285
        goto dodist;
      } else {
#line 288
        strm->msg = (char *)"invalid distance code";
#line 289
        state->mode = (inflate_mode )29;
#line 290
        goto while_break;
      }
    } else
#line 293
    if ((op & 64U) == 0U) {
#line 294
      here = (code )*(lcode + ((unsigned long )here.val + (hold & (unsigned long )((1U << op) - 1U))));
#line 295
      goto dolen;
    } else
#line 297
    if (op & 32U) {
#line 299
      state->mode = (inflate_mode )11;
#line 300
      goto while_break;
    } else {
#line 303
      strm->msg = (char *)"invalid literal/length code";
#line 304
      state->mode = (inflate_mode )29;
#line 305
      goto while_break;
    }
#line 120
    if ((unsigned long )in < (unsigned long )last) {
#line 120
      if (! ((unsigned long )out < (unsigned long )end)) {
#line 120
        goto while_break;
      }
    } else {
#line 120
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  len = bits >> 3;
#line 311
  in -= len;
#line 312
  bits -= len << 3;
#line 313
  hold &= (unsigned long )((1U << bits) - 1U);
#line 316
  strm->next_in = in + 1;
#line 317
  strm->next_out = out + 1;
#line 318
  if ((unsigned long )in < (unsigned long )last) {
#line 318
    tmp = 5L + (last - in);
  } else {
#line 318
    tmp = 5L - (in - last);
  }
#line 318
  strm->avail_in = (unsigned int )tmp;
#line 319
  if ((unsigned long )out < (unsigned long )end) {
#line 319
    tmp___0 = 257L + (end - out);
  } else {
#line 319
    tmp___0 = 257L - (out - end);
  }
#line 319
  strm->avail_out = (unsigned int )tmp___0;
#line 321
  state->hold = hold;
#line 322
  state->bits = bits;
#line 323
  return;
}
}
#line 1047 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                void *out_desc ) ;
#line 1117
int inflateBackEnd(z_streamp strm ) ;
#line 1661
int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window , char const   *version ,
                     int stream_size ) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/infback.c"
static void fixedtables___0(struct inflate_state *state ) ;
#line 28 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/infback.c"
int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window , char const   *version ,
                     int stream_size ) 
{ 
  struct inflate_state *state ;
  voidpf tmp ;

  {
#line 37
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 39
    return (-6);
  } else
#line 37
  if ((int const   )*(version + 0) != (int const   )*("1.2.8-optipng" + 0)) {
#line 39
    return (-6);
  } else
#line 37
  if (stream_size != (int )sizeof(z_stream )) {
#line 39
    return (-6);
  }
#line 40
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 42
    return (-2);
  } else
#line 40
  if ((unsigned long )window == (unsigned long )((unsigned char *)0)) {
#line 42
    return (-2);
  } else
#line 40
  if (windowBits < 8) {
#line 42
    return (-2);
  } else
#line 40
  if (windowBits > 15) {
#line 42
    return (-2);
  }
#line 43
  strm->msg = (char *)0;
#line 44
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 48
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& zcalloc);
#line 49
    strm->opaque = (voidpf )0;
  }
#line 52
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 56
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))(& zcfree);
  }
  {
#line 58
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 58
  state = (struct inflate_state *)tmp;
  }
#line 60
  if ((unsigned long )state == (unsigned long )((struct inflate_state *)0)) {
#line 60
    return (-4);
  }
#line 62
  strm->state = (struct internal_state *)state;
#line 63
  state->dmax = 32768U;
#line 64
  state->wbits = (unsigned int )windowBits;
#line 65
  state->wsize = 1U << windowBits;
#line 66
  state->window = window;
#line 67
  state->wnext = 0U;
#line 68
  state->whave = 0U;
#line 69
  return (0);
}
}
#line 10 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffixed.h"
static code const   lenfix___0[512]  = 
#line 10 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffixed.h"
  {      {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)192}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)160}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)224}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)144}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)208}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)176}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)240}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)200}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)168}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)232}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)152}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)216}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)184}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)248}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)196}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)164}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)228}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)148}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)212}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)180}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)244}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)204}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)172}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)236}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)156}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)220}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)188}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)252}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)194}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)162}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)226}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)146}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)210}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)178}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)242}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)202}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)170}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)234}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)154}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)218}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)186}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)250}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)198}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)166}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)230}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)150}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)214}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)182}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)246}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)206}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)174}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)238}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)158}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)222}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)190}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)254}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)193}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)161}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)225}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)145}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)209}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)177}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)241}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)201}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)169}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)233}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)153}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)217}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)185}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)249}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)197}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)165}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)229}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)149}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)213}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)181}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)245}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)205}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)173}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)237}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)157}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)221}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)189}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)253}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)195}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)163}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)227}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)147}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)211}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)179}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)243}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)203}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)171}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)235}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)155}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)219}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)187}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)251}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)199}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)167}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)231}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)151}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)215}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)183}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)247}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)207}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)175}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)239}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)159}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)223}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)191}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)255}};
#line 87 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/inffixed.h"
static code const   distfix___0[32]  = 
#line 87
  {      {(unsigned char)16, (unsigned char)5, (unsigned short)1}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)257}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)17}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)4097}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)5}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1025}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)65}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)16385}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)3}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)513}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)33}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)8193}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)9}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)2049}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)129}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)2}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)385}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)25}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)6145}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)7}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1537}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)97}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)24577}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)4}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)769}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)49}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)12289}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)13}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)3073}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)193}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}};
#line 82 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/infback.c"
static void fixedtables___0(struct inflate_state *state ) 
{ 


  {
#line 119
  state->lencode = lenfix___0;
#line 120
  state->lenbits = 9U;
#line 121
  state->distcode = distfix___0;
#line 122
  state->distbits = 5U;
#line 123
  return;
}
}
#line 269 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/infback.c"
static unsigned short const   order___0[19]  = 
#line 269
  {      (unsigned short const   )16,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )0, 
        (unsigned short const   )8,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )6, 
        (unsigned short const   )10,      (unsigned short const   )5,      (unsigned short const   )11,      (unsigned short const   )4, 
        (unsigned short const   )12,      (unsigned short const   )3,      (unsigned short const   )13,      (unsigned short const   )2, 
        (unsigned short const   )14,      (unsigned short const   )1,      (unsigned short const   )15};
#line 250 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/infback.c"
int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                void *out_desc ) 
{ 
  struct inflate_state *state ;
  unsigned char *next ;
  unsigned char *put ;
  unsigned int have ;
  unsigned int left ;
  unsigned long hold ;
  unsigned int bits ;
  unsigned int copy ;
  unsigned char *from ;
  code here ;
  code last ;
  unsigned int len ;
  int ret ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int __attribute__((__visibility__("hidden")))  tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned int tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  int __attribute__((__visibility__("hidden")))  tmp___14 ;
  int __attribute__((__visibility__("hidden")))  tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  int tmp___28 ;

  {
#line 273
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 274
    return (-2);
  } else
#line 273
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 274
    return (-2);
  }
#line 275
  state = (struct inflate_state *)strm->state;
#line 278
  strm->msg = (char *)0;
#line 279
  state->mode = (inflate_mode )11;
#line 280
  state->last = 0;
#line 281
  state->whave = 0U;
#line 282
  next = strm->next_in;
#line 283
  if ((unsigned long )next != (unsigned long )((unsigned char *)0)) {
#line 283
    have = strm->avail_in;
  } else {
#line 283
    have = 0U;
  }
#line 284
  hold = 0UL;
#line 285
  bits = 0U;
#line 286
  put = state->window;
#line 287
  left = state->wsize;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    if ((unsigned int )state->mode == 11U) {
#line 292
      goto case_11;
    }
#line 326
    if ((unsigned int )state->mode == 13U) {
#line 326
      goto case_13;
    }
#line 358
    if ((unsigned int )state->mode == 16U) {
#line 358
      goto case_16;
    }
#line 481
    if ((unsigned int )state->mode == 20U) {
#line 481
      goto case_20;
    }
#line 606
    if ((unsigned int )state->mode == 28U) {
#line 606
      goto case_28;
    }
#line 615
    if ((unsigned int )state->mode == 29U) {
#line 615
      goto case_29;
    }
#line 619
    goto switch_default;
    case_11: /* CIL Label */ 
#line 294
    if (state->last) {
      {
#line 295
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 295
        hold >>= bits & 7U;
#line 295
        bits -= bits & 7U;
#line 295
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 296
      state->mode = (inflate_mode )28;
#line 297
      goto switch_break;
    }
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 299
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 299
        if (! (bits < 3U)) {
#line 299
          goto while_break___2;
        }
        {
#line 299
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 299
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 299
            if (have == 0U) {
              {
#line 299
              have = (*in)(in_desc, & next);
              }
#line 299
              if (have == 0U) {
#line 299
                next = (unsigned char *)0;
#line 299
                ret = -5;
#line 299
                goto inf_leave;
              }
            }
#line 299
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 299
          have --;
#line 299
          tmp = next;
#line 299
          next ++;
#line 299
          hold += (unsigned long )*tmp << bits;
#line 299
          bits += 8U;
#line 299
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 299
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 300
    state->last = (int )((unsigned int )hold & ((1U << 1) - 1U));
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      hold >>= 1;
#line 301
      bits --;
#line 301
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 303
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 0U) {
#line 303
      goto case_0;
    }
#line 308
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 1U) {
#line 308
      goto case_1;
    }
#line 314
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 2U) {
#line 314
      goto case_2;
    }
#line 319
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 3U) {
#line 319
      goto case_3;
    }
#line 302
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 306
    state->mode = (inflate_mode )13;
#line 307
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 309
    fixedtables___0(state);
#line 312
    state->mode = (inflate_mode )20;
    }
#line 313
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 317
    state->mode = (inflate_mode )16;
#line 318
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 320
    strm->msg = (char *)"invalid block type";
#line 321
    state->mode = (inflate_mode )29;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 323
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 323
      hold >>= 2;
#line 323
      bits -= 2U;
#line 323
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 324
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 328
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 328
      hold >>= bits & 7U;
#line 328
      bits -= bits & 7U;
#line 328
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 329
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 329
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 329
        if (! (bits < 32U)) {
#line 329
          goto while_break___9;
        }
        {
#line 329
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 329
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 329
            if (have == 0U) {
              {
#line 329
              have = (*in)(in_desc, & next);
              }
#line 329
              if (have == 0U) {
#line 329
                next = (unsigned char *)0;
#line 329
                ret = -5;
#line 329
                goto inf_leave;
              }
            }
#line 329
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 329
          have --;
#line 329
          tmp___0 = next;
#line 329
          next ++;
#line 329
          hold += (unsigned long )*tmp___0 << bits;
#line 329
          bits += 8U;
#line 329
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 329
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 330
    if ((hold & 65535UL) != ((hold >> 16) ^ 65535UL)) {
#line 331
      strm->msg = (char *)"invalid stored block lengths";
#line 332
      state->mode = (inflate_mode )29;
#line 333
      goto switch_break;
    }
#line 335
    state->length = (unsigned int )hold & 65535U;
    {
#line 338
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 338
      hold = 0UL;
#line 338
      bits = 0U;
#line 338
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 341
      if (! (state->length != 0U)) {
#line 341
        goto while_break___13;
      }
#line 342
      copy = state->length;
      {
#line 343
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 343
        if (have == 0U) {
          {
#line 343
          have = (*in)(in_desc, & next);
          }
#line 343
          if (have == 0U) {
#line 343
            next = (unsigned char *)0;
#line 343
            ret = -5;
#line 343
            goto inf_leave;
          }
        }
#line 343
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 344
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 344
        if (left == 0U) {
          {
#line 344
          put = state->window;
#line 344
          left = state->wsize;
#line 344
          state->whave = left;
#line 344
          tmp___1 = (*out)(out_desc, put, left);
          }
#line 344
          if (tmp___1) {
#line 344
            ret = -5;
#line 344
            goto inf_leave;
          }
        }
#line 344
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 345
      if (copy > have) {
#line 345
        copy = have;
      }
#line 346
      if (copy > left) {
#line 346
        copy = left;
      }
      {
#line 347
      memcpy((void */* __restrict  */)put, (void const   */* __restrict  */)next,
             (size_t )copy);
#line 348
      have -= copy;
#line 349
      next += copy;
#line 350
      left -= copy;
#line 351
      put += copy;
#line 352
      state->length -= copy;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 355
    state->mode = (inflate_mode )11;
#line 356
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 360
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 360
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 360
        if (! (bits < 14U)) {
#line 360
          goto while_break___17;
        }
        {
#line 360
        while (1) {
          while_continue___18: /* CIL Label */ ;
          {
#line 360
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 360
            if (have == 0U) {
              {
#line 360
              have = (*in)(in_desc, & next);
              }
#line 360
              if (have == 0U) {
#line 360
                next = (unsigned char *)0;
#line 360
                ret = -5;
#line 360
                goto inf_leave;
              }
            }
#line 360
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 360
          have --;
#line 360
          tmp___2 = next;
#line 360
          next ++;
#line 360
          hold += (unsigned long )*tmp___2 << bits;
#line 360
          bits += 8U;
#line 360
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 360
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 361
    state->nlen = ((unsigned int )hold & ((1U << 5) - 1U)) + 257U;
    {
#line 362
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 362
      hold >>= 5;
#line 362
      bits -= 5U;
#line 362
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 363
    state->ndist = ((unsigned int )hold & ((1U << 5) - 1U)) + 1U;
    {
#line 364
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 364
      hold >>= 5;
#line 364
      bits -= 5U;
#line 364
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 365
    state->ncode = ((unsigned int )hold & ((1U << 4) - 1U)) + 4U;
    {
#line 366
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 366
      hold >>= 4;
#line 366
      bits -= 4U;
#line 366
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 368
    if (state->nlen > 286U) {
#line 369
      strm->msg = (char *)"too many length or distance symbols";
#line 370
      state->mode = (inflate_mode )29;
#line 371
      goto switch_break;
    } else
#line 368
    if (state->ndist > 30U) {
#line 369
      strm->msg = (char *)"too many length or distance symbols";
#line 370
      state->mode = (inflate_mode )29;
#line 371
      goto switch_break;
    }
#line 377
    state->have = 0U;
    {
#line 378
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 378
      if (! (state->have < state->ncode)) {
#line 378
        goto while_break___23;
      }
      {
#line 379
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 379
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 379
          if (! (bits < 3U)) {
#line 379
            goto while_break___25;
          }
          {
#line 379
          while (1) {
            while_continue___26: /* CIL Label */ ;
            {
#line 379
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 379
              if (have == 0U) {
                {
#line 379
                have = (*in)(in_desc, & next);
                }
#line 379
                if (have == 0U) {
#line 379
                  next = (unsigned char *)0;
#line 379
                  ret = -5;
#line 379
                  goto inf_leave;
                }
              }
#line 379
              goto while_break___27;
            }
            while_break___27: /* CIL Label */ ;
            }
#line 379
            have --;
#line 379
            tmp___3 = next;
#line 379
            next ++;
#line 379
            hold += (unsigned long )*tmp___3 << bits;
#line 379
            bits += 8U;
#line 379
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
#line 379
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 380
      tmp___4 = state->have;
#line 380
      (state->have) ++;
#line 380
      state->lens[order___0[tmp___4]] = (unsigned short )((unsigned int )hold & ((1U << 3) - 1U));
      {
#line 381
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 381
        hold >>= 3;
#line 381
        bits -= 3U;
#line 381
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 383
      if (! (state->have < 19U)) {
#line 383
        goto while_break___29;
      }
#line 384
      tmp___5 = state->have;
#line 384
      (state->have) ++;
#line 384
      state->lens[order___0[tmp___5]] = (unsigned short)0;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 385
    state->next = state->codes;
#line 386
    state->lencode = (code const   *)state->next;
#line 387
    state->lenbits = 7U;
#line 388
    tmp___6 = inflate_table((codetype )0, state->lens, 19U, & state->next, & state->lenbits,
                            state->work);
#line 388
    ret = (int )tmp___6;
    }
#line 390
    if (ret) {
#line 391
      strm->msg = (char *)"invalid code lengths set";
#line 392
      state->mode = (inflate_mode )29;
#line 393
      goto switch_break;
    }
#line 398
    state->have = 0U;
    {
#line 399
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 399
      if (! (state->have < state->nlen + state->ndist)) {
#line 399
        goto while_break___30;
      }
      {
#line 400
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 401
        here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 402
        if ((unsigned int )here.bits <= bits) {
#line 402
          goto while_break___31;
        }
        {
#line 403
        while (1) {
          while_continue___32: /* CIL Label */ ;
          {
#line 403
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 403
            if (have == 0U) {
              {
#line 403
              have = (*in)(in_desc, & next);
              }
#line 403
              if (have == 0U) {
#line 403
                next = (unsigned char *)0;
#line 403
                ret = -5;
#line 403
                goto inf_leave;
              }
            }
#line 403
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 403
          have --;
#line 403
          tmp___7 = next;
#line 403
          next ++;
#line 403
          hold += (unsigned long )*tmp___7 << bits;
#line 403
          bits += 8U;
#line 403
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
      }
      while_break___31: /* CIL Label */ ;
      }
#line 405
      if ((int )here.val < 16) {
        {
#line 406
        while (1) {
          while_continue___34: /* CIL Label */ ;
#line 406
          hold >>= (int )here.bits;
#line 406
          bits -= (unsigned int )here.bits;
#line 406
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
#line 407
        tmp___8 = state->have;
#line 407
        (state->have) ++;
#line 407
        state->lens[tmp___8] = here.val;
      } else {
#line 410
        if ((int )here.val == 16) {
          {
#line 411
          while (1) {
            while_continue___35: /* CIL Label */ ;
            {
#line 411
            while (1) {
              while_continue___36: /* CIL Label */ ;
#line 411
              if (! (bits < (unsigned int )((int )here.bits + 2))) {
#line 411
                goto while_break___36;
              }
              {
#line 411
              while (1) {
                while_continue___37: /* CIL Label */ ;
                {
#line 411
                while (1) {
                  while_continue___38: /* CIL Label */ ;
#line 411
                  if (have == 0U) {
                    {
#line 411
                    have = (*in)(in_desc, & next);
                    }
#line 411
                    if (have == 0U) {
#line 411
                      next = (unsigned char *)0;
#line 411
                      ret = -5;
#line 411
                      goto inf_leave;
                    }
                  }
#line 411
                  goto while_break___38;
                }
                while_break___38: /* CIL Label */ ;
                }
#line 411
                have --;
#line 411
                tmp___9 = next;
#line 411
                next ++;
#line 411
                hold += (unsigned long )*tmp___9 << bits;
#line 411
                bits += 8U;
#line 411
                goto while_break___37;
              }
              while_break___37: /* CIL Label */ ;
              }
            }
            while_break___36: /* CIL Label */ ;
            }
#line 411
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 412
          while (1) {
            while_continue___39: /* CIL Label */ ;
#line 412
            hold >>= (int )here.bits;
#line 412
            bits -= (unsigned int )here.bits;
#line 412
            goto while_break___39;
          }
          while_break___39: /* CIL Label */ ;
          }
#line 413
          if (state->have == 0U) {
#line 414
            strm->msg = (char *)"invalid bit length repeat";
#line 415
            state->mode = (inflate_mode )29;
#line 416
            goto while_break___30;
          }
#line 418
          len = (unsigned int )state->lens[state->have - 1U];
#line 419
          copy = 3U + ((unsigned int )hold & ((1U << 2) - 1U));
          {
#line 420
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 420
            hold >>= 2;
#line 420
            bits -= 2U;
#line 420
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
        } else
#line 422
        if ((int )here.val == 17) {
          {
#line 423
          while (1) {
            while_continue___41: /* CIL Label */ ;
            {
#line 423
            while (1) {
              while_continue___42: /* CIL Label */ ;
#line 423
              if (! (bits < (unsigned int )((int )here.bits + 3))) {
#line 423
                goto while_break___42;
              }
              {
#line 423
              while (1) {
                while_continue___43: /* CIL Label */ ;
                {
#line 423
                while (1) {
                  while_continue___44: /* CIL Label */ ;
#line 423
                  if (have == 0U) {
                    {
#line 423
                    have = (*in)(in_desc, & next);
                    }
#line 423
                    if (have == 0U) {
#line 423
                      next = (unsigned char *)0;
#line 423
                      ret = -5;
#line 423
                      goto inf_leave;
                    }
                  }
#line 423
                  goto while_break___44;
                }
                while_break___44: /* CIL Label */ ;
                }
#line 423
                have --;
#line 423
                tmp___10 = next;
#line 423
                next ++;
#line 423
                hold += (unsigned long )*tmp___10 << bits;
#line 423
                bits += 8U;
#line 423
                goto while_break___43;
              }
              while_break___43: /* CIL Label */ ;
              }
            }
            while_break___42: /* CIL Label */ ;
            }
#line 423
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
          {
#line 424
          while (1) {
            while_continue___45: /* CIL Label */ ;
#line 424
            hold >>= (int )here.bits;
#line 424
            bits -= (unsigned int )here.bits;
#line 424
            goto while_break___45;
          }
          while_break___45: /* CIL Label */ ;
          }
#line 425
          len = 0U;
#line 426
          copy = 3U + ((unsigned int )hold & ((1U << 3) - 1U));
          {
#line 427
          while (1) {
            while_continue___46: /* CIL Label */ ;
#line 427
            hold >>= 3;
#line 427
            bits -= 3U;
#line 427
            goto while_break___46;
          }
          while_break___46: /* CIL Label */ ;
          }
        } else {
          {
#line 430
          while (1) {
            while_continue___47: /* CIL Label */ ;
            {
#line 430
            while (1) {
              while_continue___48: /* CIL Label */ ;
#line 430
              if (! (bits < (unsigned int )((int )here.bits + 7))) {
#line 430
                goto while_break___48;
              }
              {
#line 430
              while (1) {
                while_continue___49: /* CIL Label */ ;
                {
#line 430
                while (1) {
                  while_continue___50: /* CIL Label */ ;
#line 430
                  if (have == 0U) {
                    {
#line 430
                    have = (*in)(in_desc, & next);
                    }
#line 430
                    if (have == 0U) {
#line 430
                      next = (unsigned char *)0;
#line 430
                      ret = -5;
#line 430
                      goto inf_leave;
                    }
                  }
#line 430
                  goto while_break___50;
                }
                while_break___50: /* CIL Label */ ;
                }
#line 430
                have --;
#line 430
                tmp___11 = next;
#line 430
                next ++;
#line 430
                hold += (unsigned long )*tmp___11 << bits;
#line 430
                bits += 8U;
#line 430
                goto while_break___49;
              }
              while_break___49: /* CIL Label */ ;
              }
            }
            while_break___48: /* CIL Label */ ;
            }
#line 430
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
          {
#line 431
          while (1) {
            while_continue___51: /* CIL Label */ ;
#line 431
            hold >>= (int )here.bits;
#line 431
            bits -= (unsigned int )here.bits;
#line 431
            goto while_break___51;
          }
          while_break___51: /* CIL Label */ ;
          }
#line 432
          len = 0U;
#line 433
          copy = 11U + ((unsigned int )hold & ((1U << 7) - 1U));
          {
#line 434
          while (1) {
            while_continue___52: /* CIL Label */ ;
#line 434
            hold >>= 7;
#line 434
            bits -= 7U;
#line 434
            goto while_break___52;
          }
          while_break___52: /* CIL Label */ ;
          }
        }
#line 436
        if (state->have + copy > state->nlen + state->ndist) {
#line 437
          strm->msg = (char *)"invalid bit length repeat";
#line 438
          state->mode = (inflate_mode )29;
#line 439
          goto while_break___30;
        }
        {
#line 441
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 441
          tmp___13 = copy;
#line 441
          copy --;
#line 441
          if (! tmp___13) {
#line 441
            goto while_break___53;
          }
#line 442
          tmp___12 = state->have;
#line 442
          (state->have) ++;
#line 442
          state->lens[tmp___12] = (unsigned short )len;
        }
        while_break___53: /* CIL Label */ ;
        }
      }
    }
    while_break___30: /* CIL Label */ ;
    }
#line 447
    if ((unsigned int )state->mode == 29U) {
#line 447
      goto switch_break;
    }
#line 450
    if ((int )state->lens[256] == 0) {
#line 451
      strm->msg = (char *)"invalid code -- missing end-of-block";
#line 452
      state->mode = (inflate_mode )29;
#line 453
      goto switch_break;
    }
    {
#line 459
    state->next = state->codes;
#line 460
    state->lencode = (code const   *)state->next;
#line 461
    state->lenbits = 9U;
#line 462
    tmp___14 = inflate_table((codetype )1, state->lens, state->nlen, & state->next,
                             & state->lenbits, state->work);
#line 462
    ret = (int )tmp___14;
    }
#line 464
    if (ret) {
#line 465
      strm->msg = (char *)"invalid literal/lengths set";
#line 466
      state->mode = (inflate_mode )29;
#line 467
      goto switch_break;
    }
    {
#line 469
    state->distcode = (code const   *)state->next;
#line 470
    state->distbits = 6U;
#line 471
    tmp___15 = inflate_table((codetype )2, state->lens + state->nlen, state->ndist,
                             & state->next, & state->distbits, state->work);
#line 471
    ret = (int )tmp___15;
    }
#line 473
    if (ret) {
#line 474
      strm->msg = (char *)"invalid distances set";
#line 475
      state->mode = (inflate_mode )29;
#line 476
      goto switch_break;
    }
#line 479
    state->mode = (inflate_mode )20;
    case_20: /* CIL Label */ 
#line 483
    if (have >= 6U) {
#line 483
      if (left >= 258U) {
        {
#line 484
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 484
          strm->next_out = put;
#line 484
          strm->avail_out = left;
#line 484
          strm->next_in = next;
#line 484
          strm->avail_in = have;
#line 484
          state->hold = hold;
#line 484
          state->bits = bits;
#line 484
          goto while_break___54;
        }
        while_break___54: /* CIL Label */ ;
        }
#line 485
        if (state->whave < state->wsize) {
#line 486
          state->whave = state->wsize - left;
        }
        {
#line 487
        inflate_fast(strm, state->wsize);
        }
        {
#line 488
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 488
          put = strm->next_out;
#line 488
          left = strm->avail_out;
#line 488
          next = strm->next_in;
#line 488
          have = strm->avail_in;
#line 488
          hold = state->hold;
#line 488
          bits = state->bits;
#line 488
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
#line 489
        goto switch_break;
      }
    }
    {
#line 493
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 494
      here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 495
      if ((unsigned int )here.bits <= bits) {
#line 495
        goto while_break___56;
      }
      {
#line 496
      while (1) {
        while_continue___57: /* CIL Label */ ;
        {
#line 496
        while (1) {
          while_continue___58: /* CIL Label */ ;
#line 496
          if (have == 0U) {
            {
#line 496
            have = (*in)(in_desc, & next);
            }
#line 496
            if (have == 0U) {
#line 496
              next = (unsigned char *)0;
#line 496
              ret = -5;
#line 496
              goto inf_leave;
            }
          }
#line 496
          goto while_break___58;
        }
        while_break___58: /* CIL Label */ ;
        }
#line 496
        have --;
#line 496
        tmp___16 = next;
#line 496
        next ++;
#line 496
        hold += (unsigned long )*tmp___16 << bits;
#line 496
        bits += 8U;
#line 496
        goto while_break___57;
      }
      while_break___57: /* CIL Label */ ;
      }
    }
    while_break___56: /* CIL Label */ ;
    }
#line 498
    if (here.op) {
#line 498
      if (((int )here.op & 240) == 0) {
#line 499
        last = here;
        {
#line 500
        while (1) {
          while_continue___59: /* CIL Label */ ;
#line 501
          here = (code )*(state->lencode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 503
          if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 503
            goto while_break___59;
          }
          {
#line 504
          while (1) {
            while_continue___60: /* CIL Label */ ;
            {
#line 504
            while (1) {
              while_continue___61: /* CIL Label */ ;
#line 504
              if (have == 0U) {
                {
#line 504
                have = (*in)(in_desc, & next);
                }
#line 504
                if (have == 0U) {
#line 504
                  next = (unsigned char *)0;
#line 504
                  ret = -5;
#line 504
                  goto inf_leave;
                }
              }
#line 504
              goto while_break___61;
            }
            while_break___61: /* CIL Label */ ;
            }
#line 504
            have --;
#line 504
            tmp___17 = next;
#line 504
            next ++;
#line 504
            hold += (unsigned long )*tmp___17 << bits;
#line 504
            bits += 8U;
#line 504
            goto while_break___60;
          }
          while_break___60: /* CIL Label */ ;
          }
        }
        while_break___59: /* CIL Label */ ;
        }
        {
#line 506
        while (1) {
          while_continue___62: /* CIL Label */ ;
#line 506
          hold >>= (int )last.bits;
#line 506
          bits -= (unsigned int )last.bits;
#line 506
          goto while_break___62;
        }
        while_break___62: /* CIL Label */ ;
        }
      }
    }
    {
#line 508
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 508
      hold >>= (int )here.bits;
#line 508
      bits -= (unsigned int )here.bits;
#line 508
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 509
    state->length = (unsigned int )here.val;
#line 512
    if ((int )here.op == 0) {
      {
#line 516
      while (1) {
        while_continue___64: /* CIL Label */ ;
#line 516
        if (left == 0U) {
          {
#line 516
          put = state->window;
#line 516
          left = state->wsize;
#line 516
          state->whave = left;
#line 516
          tmp___18 = (*out)(out_desc, put, left);
          }
#line 516
          if (tmp___18) {
#line 516
            ret = -5;
#line 516
            goto inf_leave;
          }
        }
#line 516
        goto while_break___64;
      }
      while_break___64: /* CIL Label */ ;
      }
#line 517
      tmp___19 = put;
#line 517
      put ++;
#line 517
      *tmp___19 = (unsigned char )state->length;
#line 518
      left --;
#line 519
      state->mode = (inflate_mode )20;
#line 520
      goto switch_break;
    }
#line 524
    if ((int )here.op & 32) {
#line 526
      state->mode = (inflate_mode )11;
#line 527
      goto switch_break;
    }
#line 531
    if ((int )here.op & 64) {
#line 532
      strm->msg = (char *)"invalid literal/length code";
#line 533
      state->mode = (inflate_mode )29;
#line 534
      goto switch_break;
    }
#line 538
    state->extra = (unsigned int )here.op & 15U;
#line 539
    if (state->extra != 0U) {
      {
#line 540
      while (1) {
        while_continue___65: /* CIL Label */ ;
        {
#line 540
        while (1) {
          while_continue___66: /* CIL Label */ ;
#line 540
          if (! (bits < state->extra)) {
#line 540
            goto while_break___66;
          }
          {
#line 540
          while (1) {
            while_continue___67: /* CIL Label */ ;
            {
#line 540
            while (1) {
              while_continue___68: /* CIL Label */ ;
#line 540
              if (have == 0U) {
                {
#line 540
                have = (*in)(in_desc, & next);
                }
#line 540
                if (have == 0U) {
#line 540
                  next = (unsigned char *)0;
#line 540
                  ret = -5;
#line 540
                  goto inf_leave;
                }
              }
#line 540
              goto while_break___68;
            }
            while_break___68: /* CIL Label */ ;
            }
#line 540
            have --;
#line 540
            tmp___20 = next;
#line 540
            next ++;
#line 540
            hold += (unsigned long )*tmp___20 << bits;
#line 540
            bits += 8U;
#line 540
            goto while_break___67;
          }
          while_break___67: /* CIL Label */ ;
          }
        }
        while_break___66: /* CIL Label */ ;
        }
#line 540
        goto while_break___65;
      }
      while_break___65: /* CIL Label */ ;
      }
#line 541
      state->length += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 542
      while (1) {
        while_continue___69: /* CIL Label */ ;
#line 542
        hold >>= state->extra;
#line 542
        bits -= state->extra;
#line 542
        goto while_break___69;
      }
      while_break___69: /* CIL Label */ ;
      }
    }
    {
#line 547
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 548
      here = (code )*(state->distcode + ((unsigned int )hold & ((1U << state->distbits) - 1U)));
#line 549
      if ((unsigned int )here.bits <= bits) {
#line 549
        goto while_break___70;
      }
      {
#line 550
      while (1) {
        while_continue___71: /* CIL Label */ ;
        {
#line 550
        while (1) {
          while_continue___72: /* CIL Label */ ;
#line 550
          if (have == 0U) {
            {
#line 550
            have = (*in)(in_desc, & next);
            }
#line 550
            if (have == 0U) {
#line 550
              next = (unsigned char *)0;
#line 550
              ret = -5;
#line 550
              goto inf_leave;
            }
          }
#line 550
          goto while_break___72;
        }
        while_break___72: /* CIL Label */ ;
        }
#line 550
        have --;
#line 550
        tmp___21 = next;
#line 550
        next ++;
#line 550
        hold += (unsigned long )*tmp___21 << bits;
#line 550
        bits += 8U;
#line 550
        goto while_break___71;
      }
      while_break___71: /* CIL Label */ ;
      }
    }
    while_break___70: /* CIL Label */ ;
    }
#line 552
    if (((int )here.op & 240) == 0) {
#line 553
      last = here;
      {
#line 554
      while (1) {
        while_continue___73: /* CIL Label */ ;
#line 555
        here = (code )*(state->distcode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 557
        if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 557
          goto while_break___73;
        }
        {
#line 558
        while (1) {
          while_continue___74: /* CIL Label */ ;
          {
#line 558
          while (1) {
            while_continue___75: /* CIL Label */ ;
#line 558
            if (have == 0U) {
              {
#line 558
              have = (*in)(in_desc, & next);
              }
#line 558
              if (have == 0U) {
#line 558
                next = (unsigned char *)0;
#line 558
                ret = -5;
#line 558
                goto inf_leave;
              }
            }
#line 558
            goto while_break___75;
          }
          while_break___75: /* CIL Label */ ;
          }
#line 558
          have --;
#line 558
          tmp___22 = next;
#line 558
          next ++;
#line 558
          hold += (unsigned long )*tmp___22 << bits;
#line 558
          bits += 8U;
#line 558
          goto while_break___74;
        }
        while_break___74: /* CIL Label */ ;
        }
      }
      while_break___73: /* CIL Label */ ;
      }
      {
#line 560
      while (1) {
        while_continue___76: /* CIL Label */ ;
#line 560
        hold >>= (int )last.bits;
#line 560
        bits -= (unsigned int )last.bits;
#line 560
        goto while_break___76;
      }
      while_break___76: /* CIL Label */ ;
      }
    }
    {
#line 562
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 562
      hold >>= (int )here.bits;
#line 562
      bits -= (unsigned int )here.bits;
#line 562
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
#line 563
    if ((int )here.op & 64) {
#line 564
      strm->msg = (char *)"invalid distance code";
#line 565
      state->mode = (inflate_mode )29;
#line 566
      goto switch_break;
    }
#line 568
    state->offset = (unsigned int )here.val;
#line 571
    state->extra = (unsigned int )here.op & 15U;
#line 572
    if (state->extra != 0U) {
      {
#line 573
      while (1) {
        while_continue___78: /* CIL Label */ ;
        {
#line 573
        while (1) {
          while_continue___79: /* CIL Label */ ;
#line 573
          if (! (bits < state->extra)) {
#line 573
            goto while_break___79;
          }
          {
#line 573
          while (1) {
            while_continue___80: /* CIL Label */ ;
            {
#line 573
            while (1) {
              while_continue___81: /* CIL Label */ ;
#line 573
              if (have == 0U) {
                {
#line 573
                have = (*in)(in_desc, & next);
                }
#line 573
                if (have == 0U) {
#line 573
                  next = (unsigned char *)0;
#line 573
                  ret = -5;
#line 573
                  goto inf_leave;
                }
              }
#line 573
              goto while_break___81;
            }
            while_break___81: /* CIL Label */ ;
            }
#line 573
            have --;
#line 573
            tmp___23 = next;
#line 573
            next ++;
#line 573
            hold += (unsigned long )*tmp___23 << bits;
#line 573
            bits += 8U;
#line 573
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
        }
        while_break___79: /* CIL Label */ ;
        }
#line 573
        goto while_break___78;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 574
      state->offset += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 575
      while (1) {
        while_continue___82: /* CIL Label */ ;
#line 575
        hold >>= state->extra;
#line 575
        bits -= state->extra;
#line 575
        goto while_break___82;
      }
      while_break___82: /* CIL Label */ ;
      }
    }
#line 577
    if (state->whave < state->wsize) {
#line 577
      tmp___24 = left;
    } else {
#line 577
      tmp___24 = 0U;
    }
#line 577
    if (state->offset > state->wsize - tmp___24) {
#line 579
      strm->msg = (char *)"invalid distance too far back";
#line 580
      state->mode = (inflate_mode )29;
#line 581
      goto switch_break;
    }
    {
#line 586
    while (1) {
      while_continue___83: /* CIL Label */ ;
      {
#line 587
      while (1) {
        while_continue___84: /* CIL Label */ ;
#line 587
        if (left == 0U) {
          {
#line 587
          put = state->window;
#line 587
          left = state->wsize;
#line 587
          state->whave = left;
#line 587
          tmp___25 = (*out)(out_desc, put, left);
          }
#line 587
          if (tmp___25) {
#line 587
            ret = -5;
#line 587
            goto inf_leave;
          }
        }
#line 587
        goto while_break___84;
      }
      while_break___84: /* CIL Label */ ;
      }
#line 588
      copy = state->wsize - state->offset;
#line 589
      if (copy < left) {
#line 590
        from = put + copy;
#line 591
        copy = left - copy;
      } else {
#line 594
        from = put - state->offset;
#line 595
        copy = left;
      }
#line 597
      if (copy > state->length) {
#line 597
        copy = state->length;
      }
#line 598
      state->length -= copy;
#line 599
      left -= copy;
      {
#line 600
      while (1) {
        while_continue___85: /* CIL Label */ ;
#line 601
        tmp___26 = put;
#line 601
        put ++;
#line 601
        tmp___27 = from;
#line 601
        from ++;
#line 601
        *tmp___26 = *tmp___27;
#line 600
        copy --;
#line 600
        if (! copy) {
#line 600
          goto while_break___85;
        }
      }
      while_break___85: /* CIL Label */ ;
      }
#line 586
      if (! (state->length != 0U)) {
#line 586
        goto while_break___83;
      }
    }
    while_break___83: /* CIL Label */ ;
    }
#line 604
    goto switch_break;
    case_28: /* CIL Label */ 
#line 608
    ret = 1;
#line 609
    if (left < state->wsize) {
      {
#line 610
      tmp___28 = (*out)(out_desc, state->window, state->wsize - left);
      }
#line 610
      if (tmp___28) {
#line 611
        ret = -5;
      }
    }
#line 613
    goto inf_leave;
    case_29: /* CIL Label */ 
#line 616
    ret = -3;
#line 617
    goto inf_leave;
    switch_default: /* CIL Label */ 
#line 620
    ret = -2;
#line 621
    goto inf_leave;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  inf_leave: 
#line 626
  strm->next_in = next;
#line 627
  strm->avail_in = have;
#line 628
  return (ret);
}
}
#line 631 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/infback.c"
int inflateBackEnd(z_streamp strm ) 
{ 


  {
#line 634
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 635
    return (-2);
  } else
#line 634
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 635
    return (-2);
  } else
#line 634
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 635
    return (-2);
  }
  {
#line 636
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 637
  strm->state = (struct internal_state *)0;
  }
#line 639
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 344 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 264 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 371
extern int deflateEnd(z_streamp strm ) ;
#line 667
extern int deflateReset(z_streamp strm ) ;
#line 678
extern int deflateParams(z_streamp strm , int level , int strategy ) ;
#line 1322
int gzsetparams(gzFile file , int level , int strategy ) ;
#line 1359
int gzwrite(gzFile file , voidpc buf , unsigned int len ) ;
#line 1367
int gzprintf(gzFile file , char const   *format  , ...) ;
#line 1382
int gzputs(gzFile file , char const   *str ) ;
#line 1403
int gzputc(gzFile file , int c ) ;
#line 1430
int gzflush(gzFile file , int flush ) ;
#line 1543
int gzclose_w(gzFile file ) ;
#line 1655
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 1776
int gzvprintf(gzFile file , char const   *format , va_list va ) ;
#line 384 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 196 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzguts.h"
void __attribute__((__visibility__("hidden")))  gz_error(gz_statep state , int err ,
                                                         char const   *msg___0 ) ;
#line 9 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
static int gz_init(gz_statep state ) ;
#line 10
static int gz_comp(gz_statep state , int flush ) ;
#line 11
static int gz_zero(gz_statep state , off64_t len ) ;
#line 15 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
static int gz_init(gz_statep state ) 
{ 
  int ret ;
  z_streamp strm ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 19
  strm = & state->strm;
#line 22
  tmp = malloc((size_t )state->want);
#line 22
  state->in = (unsigned char *)tmp;
  }
#line 23
  if ((unsigned long )state->in == (unsigned long )((void *)0)) {
    {
#line 24
    gz_error(state, -4, "out of memory");
    }
#line 25
    return (-1);
  }
#line 29
  if (! state->direct) {
    {
#line 31
    tmp___0 = malloc((size_t )state->want);
#line 31
    state->out = (unsigned char *)tmp___0;
    }
#line 32
    if ((unsigned long )state->out == (unsigned long )((void *)0)) {
      {
#line 33
      free((void *)state->in);
#line 34
      gz_error(state, -4, "out of memory");
      }
#line 35
      return (-1);
    }
    {
#line 39
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 40
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 41
    strm->opaque = (voidpf )0;
#line 42
    ret = deflateInit2_(strm, state->level, 8, 31, 8, state->strategy, "1.2.8-optipng",
                        (int )sizeof(z_stream ));
    }
#line 44
    if (ret != 0) {
      {
#line 45
      free((void *)state->out);
#line 46
      free((void *)state->in);
#line 47
      gz_error(state, -4, "out of memory");
      }
#line 48
      return (-1);
    }
  }
#line 53
  state->size = state->want;
#line 56
  if (! state->direct) {
#line 57
    strm->avail_out = state->size;
#line 58
    strm->next_out = state->out;
#line 59
    state->x.next = strm->next_out;
  }
#line 61
  return (0);
}
}
#line 70 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
static int gz_comp(gz_statep state , int flush ) 
{ 
  int ret ;
  int got ;
  unsigned int have ;
  z_streamp strm ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 76
  strm = & state->strm;
#line 79
  if (state->size == 0U) {
    {
#line 79
    tmp = gz_init(state);
    }
#line 79
    if (tmp == -1) {
#line 80
      return (-1);
    }
  }
#line 83
  if (state->direct) {
    {
#line 84
    tmp___0 = write(state->fd, (void const   *)strm->next_in, (size_t )strm->avail_in);
#line 84
    got = (int )tmp___0;
    }
#line 85
    if (got < 0) {
      {
#line 86
      tmp___1 = __errno_location();
#line 86
      tmp___2 = strerror(*tmp___1);
#line 86
      gz_error(state, -1, (char const   *)tmp___2);
      }
#line 87
      return (-1);
    } else
#line 85
    if ((unsigned int )got != strm->avail_in) {
      {
#line 86
      tmp___1 = __errno_location();
#line 86
      tmp___2 = strerror(*tmp___1);
#line 86
      gz_error(state, -1, (char const   *)tmp___2);
      }
#line 87
      return (-1);
    }
#line 89
    strm->avail_in = (uInt )0;
#line 90
    return (0);
  }
#line 94
  ret = 0;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (strm->avail_out == 0U) {
#line 98
      goto _L___0;
    } else
#line 98
    if (flush != 0) {
#line 98
      if (flush != 4) {
#line 98
        goto _L___0;
      } else
#line 98
      if (ret == 1) {
        _L___0: /* CIL Label */ 
#line 100
        have = (unsigned int )(strm->next_out - state->x.next);
#line 101
        if (have) {
          {
#line 101
          tmp___5 = write(state->fd, (void const   *)state->x.next, (size_t )have);
#line 101
          got = (int )tmp___5;
          }
#line 101
          if (got < 0) {
            {
#line 103
            tmp___3 = __errno_location();
#line 103
            tmp___4 = strerror(*tmp___3);
#line 103
            gz_error(state, -1, (char const   *)tmp___4);
            }
#line 104
            return (-1);
          } else
#line 101
          if ((unsigned int )got != have) {
            {
#line 103
            tmp___3 = __errno_location();
#line 103
            tmp___4 = strerror(*tmp___3);
#line 103
            gz_error(state, -1, (char const   *)tmp___4);
            }
#line 104
            return (-1);
          }
        }
#line 106
        if (strm->avail_out == 0U) {
#line 107
          strm->avail_out = state->size;
#line 108
          strm->next_out = state->out;
        }
#line 110
        state->x.next = strm->next_out;
      }
    }
    {
#line 114
    have = strm->avail_out;
#line 115
    ret = deflate(strm, flush);
    }
#line 116
    if (ret == -2) {
      {
#line 117
      gz_error(state, -2, "internal error: deflate stream corrupt");
      }
#line 119
      return (-1);
    }
#line 121
    have -= strm->avail_out;
#line 95
    if (! have) {
#line 95
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  if (flush == 4) {
    {
#line 126
    deflateReset(strm);
    }
  }
#line 129
  return (0);
}
}
#line 133 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
static int gz_zero(gz_statep state , off64_t len ) 
{ 
  int first ;
  unsigned int n ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;

  {
#line 139
  strm = & state->strm;
#line 142
  if (strm->avail_in) {
    {
#line 142
    tmp = gz_comp(state, 0);
    }
#line 142
    if (tmp == -1) {
#line 143
      return (-1);
    }
  }
#line 146
  first = 1;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! len) {
#line 147
      goto while_break;
    }
#line 148
    if (sizeof(int ) == sizeof(off64_t )) {
#line 148
      if (state->size > 2147483647U) {
#line 148
        n = (unsigned int )len;
      } else {
#line 148
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 148
    if ((off64_t )state->size > len) {
#line 148
      n = (unsigned int )len;
    } else {
#line 148
      n = state->size;
    }
#line 150
    if (first) {
      {
#line 151
      memset((void *)state->in, 0, (size_t )n);
#line 152
      first = 0;
      }
    }
    {
#line 154
    strm->avail_in = n;
#line 155
    strm->next_in = state->in;
#line 156
    state->x.pos += (off64_t )n;
#line 157
    tmp___0 = gz_comp(state, 0);
    }
#line 157
    if (tmp___0 == -1) {
#line 158
      return (-1);
    }
#line 159
    len -= (off64_t )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return (0);
}
}
#line 165 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzwrite(gzFile file , voidpc buf , unsigned int len ) 
{ 
  unsigned int put ;
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;
  unsigned int have ;
  unsigned int copy ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 170
  put = len;
#line 175
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 176
    return (0);
  }
#line 177
  state = (gz_statep )file;
#line 178
  strm = & state->strm;
#line 181
  if (state->mode != 31153) {
#line 182
    return (0);
  } else
#line 181
  if (state->err != 0) {
#line 182
    return (0);
  }
#line 186
  if ((int )len < 0) {
    {
#line 187
    gz_error(state, -3, "requested length does not fit in int");
    }
#line 188
    return (0);
  }
#line 192
  if (len == 0U) {
#line 193
    return (0);
  }
#line 196
  if (state->size == 0U) {
    {
#line 196
    tmp = gz_init(state);
    }
#line 196
    if (tmp == -1) {
#line 197
      return (0);
    }
  }
#line 200
  if (state->seek) {
    {
#line 201
    state->seek = 0;
#line 202
    tmp___0 = gz_zero(state, state->skip);
    }
#line 202
    if (tmp___0 == -1) {
#line 203
      return (0);
    }
  }
#line 207
  if (len < state->size) {
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 212
      if (strm->avail_in == 0U) {
#line 213
        strm->next_in = state->in;
      }
#line 214
      have = (unsigned int )((strm->next_in + strm->avail_in) - state->in);
#line 215
      copy = state->size - have;
#line 216
      if (copy > len) {
#line 217
        copy = len;
      }
      {
#line 218
      memcpy((void */* __restrict  */)(state->in + have), (void const   */* __restrict  */)buf,
             (size_t )copy);
#line 219
      strm->avail_in += copy;
#line 220
      state->x.pos += (off64_t )copy;
#line 221
      buf = (voidpc )((char const   *)buf + copy);
#line 222
      len -= copy;
      }
#line 223
      if (len) {
        {
#line 223
        tmp___1 = gz_comp(state, 0);
        }
#line 223
        if (tmp___1 == -1) {
#line 224
          return (0);
        }
      }
#line 209
      if (! len) {
#line 209
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 229
    if (strm->avail_in) {
      {
#line 229
      tmp___2 = gz_comp(state, 0);
      }
#line 229
      if (tmp___2 == -1) {
#line 230
        return (0);
      }
    }
    {
#line 233
    strm->avail_in = len;
#line 234
    strm->next_in = (Bytef *)buf;
#line 235
    state->x.pos += (off64_t )len;
#line 236
    tmp___3 = gz_comp(state, 0);
    }
#line 236
    if (tmp___3 == -1) {
#line 237
      return (0);
    }
  }
#line 241
  return ((int )put);
}
}
#line 245 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzputc(gzFile file , int c ) 
{ 
  unsigned int have ;
  unsigned char buf[1] ;
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;

  {
#line 255
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 256
    return (-1);
  }
#line 257
  state = (gz_statep )file;
#line 258
  strm = & state->strm;
#line 261
  if (state->mode != 31153) {
#line 262
    return (-1);
  } else
#line 261
  if (state->err != 0) {
#line 262
    return (-1);
  }
#line 265
  if (state->seek) {
    {
#line 266
    state->seek = 0;
#line 267
    tmp = gz_zero(state, state->skip);
    }
#line 267
    if (tmp == -1) {
#line 268
      return (-1);
    }
  }
#line 273
  if (state->size) {
#line 274
    if (strm->avail_in == 0U) {
#line 275
      strm->next_in = state->in;
    }
#line 276
    have = (unsigned int )((strm->next_in + strm->avail_in) - state->in);
#line 277
    if (have < state->size) {
#line 278
      *(state->in + have) = (unsigned char )c;
#line 279
      (strm->avail_in) ++;
#line 280
      (state->x.pos) ++;
#line 281
      return (c & 255);
    }
  }
  {
#line 286
  buf[0] = (unsigned char )c;
#line 287
  tmp___0 = gzwrite(file, (voidpc )(buf), 1U);
  }
#line 287
  if (tmp___0 != 1) {
#line 288
    return (-1);
  }
#line 289
  return (c & 255);
}
}
#line 293 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzputs(gzFile file , char const   *str ) 
{ 
  int ret ;
  unsigned int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 301
  tmp = strlen(str);
#line 301
  len = (unsigned int )tmp;
#line 302
  ret = gzwrite(file, (voidpc )str, len);
  }
#line 303
  if (ret == 0) {
#line 303
    if (len != 0U) {
#line 303
      tmp___0 = -1;
    } else {
#line 303
      tmp___0 = ret;
    }
  } else {
#line 303
    tmp___0 = ret;
  }
#line 303
  return (tmp___0);
}
}
#line 310 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzvprintf(gzFile file , char const   *format , va_list va ) 
{ 
  int size ;
  int len ;
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 317
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 318
    return (-1);
  }
#line 319
  state = (gz_statep )file;
#line 320
  strm = & state->strm;
#line 323
  if (state->mode != 31153) {
#line 324
    return (0);
  } else
#line 323
  if (state->err != 0) {
#line 324
    return (0);
  }
#line 327
  if (state->size == 0U) {
    {
#line 327
    tmp = gz_init(state);
    }
#line 327
    if (tmp == -1) {
#line 328
      return (0);
    }
  }
#line 331
  if (state->seek) {
    {
#line 332
    state->seek = 0;
#line 333
    tmp___0 = gz_zero(state, state->skip);
    }
#line 333
    if (tmp___0 == -1) {
#line 334
      return (0);
    }
  }
#line 338
  if (strm->avail_in) {
    {
#line 338
    tmp___1 = gz_comp(state, 0);
    }
#line 338
    if (tmp___1 == -1) {
#line 339
      return (0);
    }
  }
  {
#line 342
  size = (int )state->size;
#line 343
  *(state->in + (size - 1)) = (unsigned char)0;
#line 357
  len = vsnprintf((char */* __restrict  */)((char *)state->in), (size_t )size, (char const   */* __restrict  */)format,
                  va);
  }
#line 362
  if (len <= 0) {
#line 363
    return (0);
  } else
#line 362
  if (len >= size) {
#line 363
    return (0);
  } else
#line 362
  if ((int )*(state->in + (size - 1)) != 0) {
#line 363
    return (0);
  }
#line 366
  strm->avail_in = (unsigned int )len;
#line 367
  strm->next_in = state->in;
#line 368
  state->x.pos += (off64_t )len;
#line 369
  return (len);
}
}
#line 372 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzprintf(gzFile file , char const   *format  , ...) 
{ 
  va_list va ;
  int ret ;

  {
  {
#line 377
  __builtin_va_start(va, format);
#line 378
  ret = gzvprintf(file, format, va);
#line 379
  __builtin_va_end(va);
  }
#line 380
  return (ret);
}
}
#line 465 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzflush(gzFile file , int flush ) 
{ 
  gz_statep state ;
  int tmp ;

  {
#line 472
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 473
    return (-1);
  }
#line 474
  state = (gz_statep )file;
#line 477
  if (state->mode != 31153) {
#line 478
    return (-2);
  } else
#line 477
  if (state->err != 0) {
#line 478
    return (-2);
  }
#line 481
  if (flush < 0) {
#line 482
    return (-2);
  } else
#line 481
  if (flush > 4) {
#line 482
    return (-2);
  }
#line 485
  if (state->seek) {
    {
#line 486
    state->seek = 0;
#line 487
    tmp = gz_zero(state, state->skip);
    }
#line 487
    if (tmp == -1) {
#line 488
      return (-1);
    }
  }
  {
#line 492
  gz_comp(state, flush);
  }
#line 493
  return (state->err);
}
}
#line 497 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzsetparams(gzFile file , int level , int strategy ) 
{ 
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;

  {
#line 506
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 507
    return (-2);
  }
#line 508
  state = (gz_statep )file;
#line 509
  strm = & state->strm;
#line 512
  if (state->mode != 31153) {
#line 513
    return (-2);
  } else
#line 512
  if (state->err != 0) {
#line 513
    return (-2);
  }
#line 516
  if (level == state->level) {
#line 516
    if (strategy == state->strategy) {
#line 517
      return (0);
    }
  }
#line 520
  if (state->seek) {
    {
#line 521
    state->seek = 0;
#line 522
    tmp = gz_zero(state, state->skip);
    }
#line 522
    if (tmp == -1) {
#line 523
      return (-1);
    }
  }
#line 527
  if (state->size) {
#line 529
    if (strm->avail_in) {
      {
#line 529
      tmp___0 = gz_comp(state, 1);
      }
#line 529
      if (tmp___0 == -1) {
#line 530
        return (state->err);
      }
    }
    {
#line 531
    deflateParams(strm, level, strategy);
    }
  }
#line 533
  state->level = level;
#line 534
  state->strategy = strategy;
#line 535
  return (0);
}
}
#line 539 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzwrite.c"
int gzclose_w(gzFile file ) 
{ 
  int ret ;
  gz_statep state ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 542
  ret = 0;
#line 546
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 547
    return (-2);
  }
#line 548
  state = (gz_statep )file;
#line 551
  if (state->mode != 31153) {
#line 552
    return (-2);
  }
#line 555
  if (state->seek) {
    {
#line 556
    state->seek = 0;
#line 557
    tmp = gz_zero(state, state->skip);
    }
#line 557
    if (tmp == -1) {
#line 558
      ret = state->err;
    }
  }
  {
#line 562
  tmp___0 = gz_comp(state, 4);
  }
#line 562
  if (tmp___0 == -1) {
#line 563
    ret = state->err;
  }
#line 564
  if (state->size) {
#line 565
    if (! state->direct) {
      {
#line 566
      deflateEnd(& state->strm);
#line 567
      free((void *)state->out);
      }
    }
    {
#line 569
    free((void *)state->in);
    }
  }
  {
#line 571
  gz_error(state, 0, (char const   *)((void *)0));
#line 572
  free((void *)state->path);
#line 573
  tmp___1 = close(state->fd);
  }
#line 573
  if (tmp___1 == -1) {
#line 574
    ret = -1;
  }
  {
#line 575
  free((void *)state);
  }
#line 576
  return (ret);
}
}
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 1331 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1390
char *gzgets(gzFile file , char *buf , int len ) ;
#line 1409
int gzgetc(gzFile file ) ;
#line 1418
int gzungetc(int c , gzFile file ) ;
#line 1508
int gzdirect(gzFile file ) ;
#line 1542
int gzclose_r(gzFile file ) ;
#line 1693
int gzgetc_(gzFile file ) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 9 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
static int gz_load(gz_statep state , unsigned char *buf , unsigned int len , unsigned int *have ) ;
#line 10
static int gz_avail(gz_statep state ) ;
#line 11
static int gz_look(gz_statep state ) ;
#line 12
static int gz_decomp(gz_statep state ) ;
#line 13
static int gz_fetch(gz_statep state ) ;
#line 14
static int gz_skip(gz_statep state , off64_t len ) ;
#line 20 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
static int gz_load(gz_statep state , unsigned char *buf , unsigned int len , unsigned int *have ) 
{ 
  int ret ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 28
  *have = 0U;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 30
    tmp = read(state->fd, (void *)(buf + *have), (size_t )(len - *have));
#line 30
    ret = (int )tmp;
    }
#line 31
    if (ret <= 0) {
#line 32
      goto while_break;
    }
#line 33
    *have += (unsigned int )ret;
#line 29
    if (! (*have < len)) {
#line 29
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  if (ret < 0) {
    {
#line 36
    tmp___0 = __errno_location();
#line 36
    tmp___1 = strerror(*tmp___0);
#line 36
    gz_error(state, -1, (char const   *)tmp___1);
    }
#line 37
    return (-1);
  }
#line 39
  if (ret == 0) {
#line 40
    state->eof = 1;
  }
#line 41
  return (0);
}
}
#line 51 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
static int gz_avail(gz_statep state ) 
{ 
  unsigned int got ;
  z_streamp strm ;
  unsigned char *p ;
  unsigned char const   *q ;
  unsigned int n ;
  unsigned char *tmp ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 55
  strm = & state->strm;
#line 57
  if (state->err != 0) {
#line 57
    if (state->err != -5) {
#line 58
      return (-1);
    }
  }
#line 59
  if (state->eof == 0) {
#line 60
    if (strm->avail_in) {
#line 61
      p = state->in;
#line 62
      q = (unsigned char const   *)strm->next_in;
#line 63
      n = strm->avail_in;
      {
#line 64
      while (1) {
        while_continue: /* CIL Label */ ;
#line 65
        tmp = p;
#line 65
        p ++;
#line 65
        tmp___0 = q;
#line 65
        q ++;
#line 65
        *tmp = (unsigned char )*tmp___0;
#line 64
        n --;
#line 64
        if (! n) {
#line 64
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 68
    tmp___1 = gz_load(state, state->in + strm->avail_in, state->size - strm->avail_in,
                      & got);
    }
#line 68
    if (tmp___1 == -1) {
#line 70
      return (-1);
    }
#line 71
    strm->avail_in += got;
#line 72
    strm->next_in = state->in;
  }
#line 74
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
static int gz_look(gz_statep state ) 
{ 
  z_streamp strm ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 89
  strm = & state->strm;
#line 92
  if (state->size == 0U) {
    {
#line 94
    tmp = malloc((size_t )state->want);
#line 94
    state->in = (unsigned char *)tmp;
#line 95
    tmp___0 = malloc((size_t )(state->want << 1));
#line 95
    state->out = (unsigned char *)tmp___0;
    }
#line 96
    if ((unsigned long )state->in == (unsigned long )((void *)0)) {
#line 96
      goto _L;
    } else
#line 96
    if ((unsigned long )state->out == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 97
      if ((unsigned long )state->out != (unsigned long )((void *)0)) {
        {
#line 98
        free((void *)state->out);
        }
      }
#line 99
      if ((unsigned long )state->in != (unsigned long )((void *)0)) {
        {
#line 100
        free((void *)state->in);
        }
      }
      {
#line 101
      gz_error(state, -4, "out of memory");
      }
#line 102
      return (-1);
    }
    {
#line 104
    state->size = state->want;
#line 107
    state->strm.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 108
    state->strm.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 109
    state->strm.opaque = (voidpf )0;
#line 110
    state->strm.avail_in = (uInt )0;
#line 111
    state->strm.next_in = (Bytef *)0;
#line 112
    tmp___1 = inflateInit2_(& state->strm, 31, "1.2.8-optipng", (int )sizeof(z_stream ));
    }
#line 112
    if (tmp___1 != 0) {
      {
#line 113
      free((void *)state->out);
#line 114
      free((void *)state->in);
#line 115
      state->size = 0U;
#line 116
      gz_error(state, -4, "out of memory");
      }
#line 117
      return (-1);
    }
  }
#line 122
  if (strm->avail_in < 2U) {
    {
#line 123
    tmp___2 = gz_avail(state);
    }
#line 123
    if (tmp___2 == -1) {
#line 124
      return (-1);
    }
#line 125
    if (strm->avail_in == 0U) {
#line 126
      return (0);
    }
  }
#line 136
  if (strm->avail_in > 1U) {
#line 136
    if ((int )*(strm->next_in + 0) == 31) {
#line 136
      if ((int )*(strm->next_in + 1) == 139) {
        {
#line 138
        inflateReset(strm);
#line 139
        state->how = 2;
#line 140
        state->direct = 0;
        }
#line 141
        return (0);
      }
    }
  }
#line 146
  if (state->direct == 0) {
#line 147
    strm->avail_in = (uInt )0;
#line 148
    state->eof = 1;
#line 149
    state->x.have = 0U;
#line 150
    return (0);
  }
#line 156
  state->x.next = state->out;
#line 157
  if (strm->avail_in) {
    {
#line 158
    memcpy((void */* __restrict  */)state->x.next, (void const   */* __restrict  */)strm->next_in,
           (size_t )strm->avail_in);
#line 159
    state->x.have = strm->avail_in;
#line 160
    strm->avail_in = (uInt )0;
    }
  }
#line 162
  state->how = 1;
#line 163
  state->direct = 1;
#line 164
  return (0);
}
}
#line 172 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
static int gz_decomp(gz_statep state ) 
{ 
  int ret ;
  unsigned int had ;
  z_streamp strm ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 175
  ret = 0;
#line 177
  strm = & state->strm;
#line 180
  had = strm->avail_out;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (strm->avail_in == 0U) {
      {
#line 183
      tmp = gz_avail(state);
      }
#line 183
      if (tmp == -1) {
#line 184
        return (-1);
      }
    }
#line 185
    if (strm->avail_in == 0U) {
      {
#line 186
      gz_error(state, -5, "unexpected end of file");
      }
#line 187
      goto while_break;
    }
    {
#line 191
    ret = inflate(strm, 0);
    }
#line 192
    if (ret == -2) {
      {
#line 193
      gz_error(state, -2, "internal error: inflate stream corrupt");
      }
#line 195
      return (-1);
    } else
#line 192
    if (ret == 2) {
      {
#line 193
      gz_error(state, -2, "internal error: inflate stream corrupt");
      }
#line 195
      return (-1);
    }
#line 197
    if (ret == -4) {
      {
#line 198
      gz_error(state, -4, "out of memory");
      }
#line 199
      return (-1);
    }
#line 201
    if (ret == -3) {
#line 202
      if ((unsigned long )strm->msg == (unsigned long )((void *)0)) {
#line 202
        tmp___0 = "compressed data error";
      } else {
#line 202
        tmp___0 = (char const   *)strm->msg;
      }
      {
#line 202
      gz_error(state, -3, tmp___0);
      }
#line 204
      return (-1);
    }
#line 181
    if (strm->avail_out) {
#line 181
      if (! (ret != 1)) {
#line 181
        goto while_break;
      }
    } else {
#line 181
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  state->x.have = had - strm->avail_out;
#line 210
  state->x.next = strm->next_out - state->x.have;
#line 213
  if (ret == 1) {
#line 214
    state->how = 0;
  }
#line 217
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
static int gz_fetch(gz_statep state ) 
{ 
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 229
  strm = & state->strm;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    if (state->how == 0) {
#line 233
      goto case_0;
    }
#line 239
    if (state->how == 1) {
#line 239
      goto case_1;
    }
#line 245
    if (state->how == 2) {
#line 245
      goto case_2;
    }
#line 232
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 234
    tmp = gz_look(state);
    }
#line 234
    if (tmp == -1) {
#line 235
      return (-1);
    }
#line 236
    if (state->how == 0) {
#line 237
      return (0);
    }
#line 238
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 240
    tmp___0 = gz_load(state, state->out, state->size << 1, & state->x.have);
    }
#line 240
    if (tmp___0 == -1) {
#line 242
      return (-1);
    }
#line 243
    state->x.next = state->out;
#line 244
    return (0);
    case_2: /* CIL Label */ 
    {
#line 246
    strm->avail_out = state->size << 1;
#line 247
    strm->next_out = state->out;
#line 248
    tmp___1 = gz_decomp(state);
    }
#line 248
    if (tmp___1 == -1) {
#line 249
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 231
    if (state->x.have == 0U) {
#line 231
      if (! (! state->eof)) {
#line 231
        if (! strm->avail_in) {
#line 231
          goto while_break;
        }
      }
    } else {
#line 231
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return (0);
}
}
#line 256 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
static int gz_skip(gz_statep state , off64_t len ) 
{ 
  unsigned int n ;
  int tmp ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! len) {
#line 263
      goto while_break;
    }
#line 265
    if (state->x.have) {
#line 266
      if (sizeof(int ) == sizeof(off64_t )) {
#line 266
        if (state->x.have > 2147483647U) {
#line 266
          n = (unsigned int )len;
        } else {
#line 266
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 266
      if ((off64_t )state->x.have > len) {
#line 266
        n = (unsigned int )len;
      } else {
#line 266
        n = state->x.have;
      }
#line 268
      state->x.have -= n;
#line 269
      state->x.next += n;
#line 270
      state->x.pos += (off64_t )n;
#line 271
      len -= (off64_t )n;
    } else
#line 275
    if (state->eof) {
#line 275
      if (state->strm.avail_in == 0U) {
#line 276
        goto while_break;
      } else {
#line 275
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 281
      tmp = gz_fetch(state);
      }
#line 281
      if (tmp == -1) {
#line 282
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 284
  return (0);
}
}
#line 288 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
int gzread(gzFile file , voidp buf , unsigned int len ) 
{ 
  unsigned int got ;
  unsigned int n ;
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 298
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 299
    return (-1);
  }
#line 300
  state = (gz_statep )file;
#line 301
  strm = & state->strm;
#line 304
  if (state->mode != 7247) {
#line 306
    return (-1);
  } else
#line 304
  if (state->err != 0) {
#line 304
    if (state->err != -5) {
#line 306
      return (-1);
    }
  }
#line 310
  if ((int )len < 0) {
    {
#line 311
    gz_error(state, -3, "requested length does not fit in int");
    }
#line 312
    return (-1);
  }
#line 316
  if (len == 0U) {
#line 317
    return (0);
  }
#line 320
  if (state->seek) {
    {
#line 321
    state->seek = 0;
#line 322
    tmp = gz_skip(state, state->skip);
    }
#line 322
    if (tmp == -1) {
#line 323
      return (-1);
    }
  }
#line 327
  got = 0U;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (state->x.have) {
#line 331
      if (state->x.have > len) {
#line 331
        n = len;
      } else {
#line 331
        n = state->x.have;
      }
      {
#line 332
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)state->x.next,
             (size_t )n);
#line 333
      state->x.next += n;
#line 334
      state->x.have -= n;
      }
    } else
#line 338
    if (state->eof) {
#line 338
      if (strm->avail_in == 0U) {
#line 339
        state->past = 1;
#line 340
        goto while_break;
      } else {
#line 338
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 345
    if (state->how == 0) {
#line 345
      goto _L;
    } else
#line 345
    if (len < state->size << 1) {
      _L: /* CIL Label */ 
      {
#line 347
      tmp___0 = gz_fetch(state);
      }
#line 347
      if (tmp___0 == -1) {
#line 348
        return (-1);
      }
#line 349
      goto __Cont;
    } else
#line 355
    if (state->how == 1) {
      {
#line 356
      tmp___1 = gz_load(state, (unsigned char *)buf, len, & n);
      }
#line 356
      if (tmp___1 == -1) {
#line 357
        return (-1);
      }
    } else {
      {
#line 362
      strm->avail_out = len;
#line 363
      strm->next_out = (unsigned char *)buf;
#line 364
      tmp___2 = gz_decomp(state);
      }
#line 364
      if (tmp___2 == -1) {
#line 365
        return (-1);
      }
#line 366
      n = state->x.have;
#line 367
      state->x.have = 0U;
    }
#line 371
    len -= n;
#line 372
    buf = (voidp )((char *)buf + n);
#line 373
    got += n;
#line 374
    state->x.pos += (off64_t )n;
    __Cont: /* CIL Label */ 
#line 328
    if (! len) {
#line 328
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return ((int )got);
}
}
#line 387 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
int gzgetc(gzFile file ) 
{ 
  int ret ;
  unsigned char buf[1] ;
  gz_statep state ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 395
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 396
    return (-1);
  }
#line 397
  state = (gz_statep )file;
#line 400
  if (state->mode != 7247) {
#line 402
    return (-1);
  } else
#line 400
  if (state->err != 0) {
#line 400
    if (state->err != -5) {
#line 402
      return (-1);
    }
  }
#line 405
  if (state->x.have) {
#line 406
    (state->x.have) --;
#line 407
    (state->x.pos) ++;
#line 408
    tmp = state->x.next;
#line 408
    (state->x.next) ++;
#line 408
    return ((int )*tmp);
  }
  {
#line 412
  ret = gzread(file, (voidp )(buf), 1U);
  }
#line 413
  if (ret < 1) {
#line 413
    tmp___0 = -1;
  } else {
#line 413
    tmp___0 = (int )buf[0];
  }
#line 413
  return (tmp___0);
}
}
#line 416 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
int gzgetc_(gzFile file ) 
{ 
  int tmp ;

  {
  {
#line 419
  tmp = gzgetc(file);
  }
#line 419
  return (tmp);
}
}
#line 423 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
int gzungetc(int c , gzFile file ) 
{ 
  gz_statep state ;
  int tmp ;
  unsigned char *src ;
  unsigned char *dest ;

  {
#line 430
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 431
    return (-1);
  }
#line 432
  state = (gz_statep )file;
#line 435
  if (state->mode != 7247) {
#line 437
    return (-1);
  } else
#line 435
  if (state->err != 0) {
#line 435
    if (state->err != -5) {
#line 437
      return (-1);
    }
  }
#line 440
  if (state->seek) {
    {
#line 441
    state->seek = 0;
#line 442
    tmp = gz_skip(state, state->skip);
    }
#line 442
    if (tmp == -1) {
#line 443
      return (-1);
    }
  }
#line 447
  if (c < 0) {
#line 448
    return (-1);
  }
#line 451
  if (state->x.have == 0U) {
#line 452
    state->x.have = 1U;
#line 453
    state->x.next = (state->out + (state->size << 1)) - 1;
#line 454
    *(state->x.next + 0) = (unsigned char )c;
#line 455
    (state->x.pos) --;
#line 456
    state->past = 0;
#line 457
    return (c);
  }
#line 461
  if (state->x.have == state->size << 1) {
    {
#line 462
    gz_error(state, -3, "out of room to push characters");
    }
#line 463
    return (-1);
  }
#line 467
  if ((unsigned long )state->x.next == (unsigned long )state->out) {
#line 468
    src = state->out + state->x.have;
#line 469
    dest = state->out + (state->size << 1);
    {
#line 470
    while (1) {
      while_continue: /* CIL Label */ ;
#line 470
      if (! ((unsigned long )src > (unsigned long )state->out)) {
#line 470
        goto while_break;
      }
#line 471
      dest --;
#line 471
      src --;
#line 471
      *dest = *src;
    }
    while_break: /* CIL Label */ ;
    }
#line 472
    state->x.next = dest;
  }
#line 474
  (state->x.have) ++;
#line 475
  (state->x.next) --;
#line 476
  *(state->x.next + 0) = (unsigned char )c;
#line 477
  (state->x.pos) --;
#line 478
  state->past = 0;
#line 479
  return (c);
}
}
#line 483 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
char *gzgets(gzFile file , char *buf , int len ) 
{ 
  unsigned int left ;
  unsigned int n ;
  char *str ;
  unsigned char *eol ;
  gz_statep state ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 494
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 495
    return ((char *)((void *)0));
  } else
#line 494
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 495
    return ((char *)((void *)0));
  } else
#line 494
  if (len < 1) {
#line 495
    return ((char *)((void *)0));
  }
#line 496
  state = (gz_statep )file;
#line 499
  if (state->mode != 7247) {
#line 501
    return ((char *)((void *)0));
  } else
#line 499
  if (state->err != 0) {
#line 499
    if (state->err != -5) {
#line 501
      return ((char *)((void *)0));
    }
  }
#line 504
  if (state->seek) {
    {
#line 505
    state->seek = 0;
#line 506
    tmp = gz_skip(state, state->skip);
    }
#line 506
    if (tmp == -1) {
#line 507
      return ((char *)((void *)0));
    }
  }
#line 513
  str = buf;
#line 514
  left = (unsigned int )len - 1U;
#line 515
  if (left) {
    {
#line 515
    while (1) {
      while_continue: /* CIL Label */ ;
#line 517
      if (state->x.have == 0U) {
        {
#line 517
        tmp___0 = gz_fetch(state);
        }
#line 517
        if (tmp___0 == -1) {
#line 518
          return ((char *)((void *)0));
        }
      }
#line 519
      if (state->x.have == 0U) {
#line 520
        state->past = 1;
#line 521
        goto while_break;
      }
#line 525
      if (state->x.have > left) {
#line 525
        n = left;
      } else {
#line 525
        n = state->x.have;
      }
      {
#line 526
      tmp___1 = memchr((void const   *)state->x.next, '\n', (size_t )n);
#line 526
      eol = (unsigned char *)tmp___1;
      }
#line 527
      if ((unsigned long )eol != (unsigned long )((void *)0)) {
#line 528
        n = (unsigned int )(eol - state->x.next) + 1U;
      }
      {
#line 531
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)state->x.next,
             (size_t )n);
#line 532
      state->x.have -= n;
#line 533
      state->x.next += n;
#line 534
      state->x.pos += (off64_t )n;
#line 535
      left -= n;
#line 536
      buf += n;
      }
#line 515
      if (left) {
#line 515
        if (! ((unsigned long )eol == (unsigned long )((void *)0))) {
#line 515
          goto while_break;
        }
      } else {
#line 515
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 540
  if ((unsigned long )buf == (unsigned long )str) {
#line 541
    return ((char *)((void *)0));
  }
#line 542
  *(buf + 0) = (char)0;
#line 543
  return (str);
}
}
#line 547 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
int gzdirect(gzFile file ) 
{ 
  gz_statep state ;

  {
#line 553
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 554
    return (0);
  }
#line 555
  state = (gz_statep )file;
#line 559
  if (state->mode == 7247) {
#line 559
    if (state->how == 0) {
#line 559
      if (state->x.have == 0U) {
        {
#line 560
        gz_look(state);
        }
      }
    }
  }
#line 563
  return (state->direct);
}
}
#line 567 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzread.c"
int gzclose_r(gzFile file ) 
{ 
  int ret ;
  int err ;
  gz_statep state ;
  int tmp ;

  {
#line 574
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 575
    return (-2);
  }
#line 576
  state = (gz_statep )file;
#line 579
  if (state->mode != 7247) {
#line 580
    return (-2);
  }
#line 583
  if (state->size) {
    {
#line 584
    inflateEnd(& state->strm);
#line 585
    free((void *)state->out);
#line 586
    free((void *)state->in);
    }
  }
#line 588
  if (state->err == -5) {
#line 588
    err = -5;
  } else {
#line 588
    err = 0;
  }
  {
#line 589
  gz_error(state, 0, (char const   *)((void *)0));
#line 590
  free((void *)state->path);
#line 591
  ret = close(state->fd);
#line 592
  free((void *)state);
  }
#line 593
  if (ret) {
#line 593
    tmp = -1;
  } else {
#line 593
    tmp = err;
  }
#line 593
  return (tmp);
}
}
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 348 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek64)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    int __whence ) ;
#line 1282 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
gzFile gzdopen(int fd , char const   *mode ) ;
#line 1305
int gzbuffer(gzFile file , unsigned int size ) ;
#line 1465
int gzrewind(gzFile file ) ;
#line 1493
int gzeof(gzFile file ) ;
#line 1554
char const   *gzerror(gzFile file , int *errnum ) ;
#line 1570
void gzclearerr(gzFile file ) ;
#line 1710
gzFile gzopen64(char const   *path , char const   *mode ) ;
#line 1711
off64_t gzseek64(gzFile file , off64_t offset , int whence ) ;
#line 1712
off64_t gztell64(gzFile file ) ;
#line 1713
off64_t gzoffset64(gzFile file ) ;
#line 1743
gzFile gzopen(char const   *path , char const   *mode ) ;
#line 1744
off_t gzseek(gzFile file , off_t offset , int whence ) ;
#line 1745
off_t gztell(gzFile file ) ;
#line 1746
off_t gzoffset(gzFile file ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
static void gz_reset(gz_statep state ) ;
#line 20
static gzFile gz_open(void const   *path , int fd , char const   *mode ) ;
#line 75 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
static void gz_reset(gz_statep state ) 
{ 


  {
#line 78
  state->x.have = 0U;
#line 79
  if (state->mode == 7247) {
#line 80
    state->eof = 0;
#line 81
    state->past = 0;
#line 82
    state->how = 0;
  }
  {
#line 84
  state->seek = 0;
#line 85
  gz_error(state, 0, (char const   *)((void *)0));
#line 86
  state->x.pos = (off64_t )0;
#line 87
  state->strm.avail_in = (uInt )0;
  }
#line 88
  return;
}
}
#line 91 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
static gzFile gz_open(void const   *path , int fd , char const   *mode ) 
{ 
  gz_statep state ;
  size_t len ;
  int oflag ;
  int cloexec ;
  int exclusive ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 100
  cloexec = 0;
#line 103
  exclusive = 0;
#line 107
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 108
    return ((gzFile )((void *)0));
  }
  {
#line 111
  tmp = malloc(sizeof(gz_state ));
#line 111
  state = (gz_statep )tmp;
  }
#line 112
  if ((unsigned long )state == (unsigned long )((void *)0)) {
#line 113
    return ((gzFile )((void *)0));
  }
#line 114
  state->size = 0U;
#line 115
  state->want = 8192U;
#line 116
  state->msg = (char *)((void *)0);
#line 119
  state->mode = 0;
#line 120
  state->level = -1;
#line 121
  state->strategy = 0;
#line 122
  state->direct = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! *mode) {
#line 123
      goto while_break;
    }
#line 124
    if ((int const   )*mode >= 48) {
#line 124
      if ((int const   )*mode <= 57) {
#line 125
        state->level = (int )((int const   )*mode - 48);
      } else {
#line 124
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 128
      if ((int const   )*mode == 114) {
#line 128
        goto case_114;
      }
#line 139
      if ((int const   )*mode == 43) {
#line 139
        goto case_43;
      }
#line 142
      if ((int const   )*mode == 98) {
#line 142
        goto case_98;
      }
#line 145
      if ((int const   )*mode == 101) {
#line 145
        goto case_101;
      }
#line 150
      if ((int const   )*mode == 120) {
#line 150
        goto case_120;
      }
#line 154
      if ((int const   )*mode == 102) {
#line 154
        goto case_102;
      }
#line 157
      if ((int const   )*mode == 104) {
#line 157
        goto case_104;
      }
#line 160
      if ((int const   )*mode == 82) {
#line 160
        goto case_82;
      }
#line 163
      if ((int const   )*mode == 70) {
#line 163
        goto case_70;
      }
#line 166
      if ((int const   )*mode == 84) {
#line 166
        goto case_84;
      }
#line 169
      goto switch_default;
      case_114: /* CIL Label */ 
#line 129
      state->mode = 7247;
#line 130
      goto switch_break;
      case_43: /* CIL Label */ 
      {
#line 140
      free((void *)state);
      }
#line 141
      return ((gzFile )((void *)0));
      case_98: /* CIL Label */ 
#line 143
      goto switch_break;
      case_101: /* CIL Label */ 
#line 146
      cloexec = 1;
#line 147
      goto switch_break;
      case_120: /* CIL Label */ 
#line 151
      exclusive = 1;
#line 152
      goto switch_break;
      case_102: /* CIL Label */ 
#line 155
      state->strategy = 1;
#line 156
      goto switch_break;
      case_104: /* CIL Label */ 
#line 158
      state->strategy = 2;
#line 159
      goto switch_break;
      case_82: /* CIL Label */ 
#line 161
      state->strategy = 3;
#line 162
      goto switch_break;
      case_70: /* CIL Label */ 
#line 164
      state->strategy = 4;
#line 165
      goto switch_break;
      case_84: /* CIL Label */ 
#line 167
      state->direct = 1;
#line 168
      goto switch_break;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
    }
#line 172
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  if (state->mode == 0) {
    {
#line 177
    free((void *)state);
    }
#line 178
    return ((gzFile )((void *)0));
  }
#line 182
  if (state->mode == 7247) {
#line 183
    if (state->direct) {
      {
#line 184
      free((void *)state);
      }
#line 185
      return ((gzFile )((void *)0));
    }
#line 187
    state->direct = 1;
  }
  {
#line 199
  len = strlen((char const   *)path);
#line 200
  tmp___0 = malloc(len + 1UL);
#line 200
  state->path = (char *)tmp___0;
  }
#line 201
  if ((unsigned long )state->path == (unsigned long )((void *)0)) {
    {
#line 202
    free((void *)state);
    }
#line 203
    return ((gzFile )((void *)0));
  }
  {
#line 214
  snprintf((char */* __restrict  */)state->path, len + 1UL, (char const   */* __restrict  */)"%s",
           (char const   *)path);
  }
#line 220
  if (cloexec) {
#line 220
    tmp___1 = 524288;
  } else {
#line 220
    tmp___1 = 0;
  }
#line 220
  if (state->mode == 7247) {
#line 220
    tmp___4 = 0;
  } else {
#line 220
    if (exclusive) {
#line 220
      tmp___2 = 128;
    } else {
#line 220
      tmp___2 = 0;
    }
#line 220
    if (state->mode == 31153) {
#line 220
      tmp___3 = 512;
    } else {
#line 220
      tmp___3 = 1024;
    }
#line 220
    tmp___4 = (65 | tmp___2) | tmp___3;
  }
#line 220
  oflag = tmp___1 | tmp___4;
#line 241
  if (fd > -1) {
#line 241
    state->fd = fd;
  } else {
    {
#line 241
    tmp___5 = open((char const   *)path, oflag, 438);
#line 241
    state->fd = tmp___5;
    }
  }
#line 246
  if (state->fd == -1) {
    {
#line 247
    free((void *)state->path);
#line 248
    free((void *)state);
    }
#line 249
    return ((gzFile )((void *)0));
  }
#line 251
  if (state->mode == 1) {
#line 252
    state->mode = 31153;
  }
#line 255
  if (state->mode == 7247) {
    {
#line 256
    state->start = lseek64(state->fd, (__off64_t )0, 1);
    }
#line 257
    if (state->start == -1L) {
#line 257
      state->start = (off64_t )0;
    }
  }
  {
#line 261
  gz_reset(state);
  }
#line 264
  return ((gzFile )state);
}
}
#line 268 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
gzFile gzopen(char const   *path , char const   *mode ) 
{ 
  gzFile tmp ;

  {
  {
#line 272
  tmp = gz_open((void const   *)path, -1, mode);
  }
#line 272
  return (tmp);
}
}
#line 276 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
gzFile gzopen64(char const   *path , char const   *mode ) 
{ 
  gzFile tmp ;

  {
  {
#line 280
  tmp = gz_open((void const   *)path, -1, mode);
  }
#line 280
  return (tmp);
}
}
#line 284 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
gzFile gzdopen(int fd , char const   *mode ) 
{ 
  char *path ;
  gzFile gz ;
  void *tmp ;

  {
#line 291
  if (fd == -1) {
#line 292
    return ((gzFile )((void *)0));
  } else {
    {
#line 291
    tmp = malloc(7UL + 3UL * sizeof(int ));
#line 291
    path = (char *)tmp;
    }
#line 291
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 292
      return ((gzFile )((void *)0));
    }
  }
  {
#line 294
  snprintf((char */* __restrict  */)path, 7UL + 3UL * sizeof(int ), (char const   */* __restrict  */)"<fd:%d>",
           fd);
#line 298
  gz = gz_open((void const   *)path, fd, mode);
#line 299
  free((void *)path);
  }
#line 300
  return (gz);
}
}
#line 314 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
int gzbuffer(gzFile file , unsigned int size ) 
{ 
  gz_statep state ;

  {
#line 321
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 322
    return (-1);
  }
#line 323
  state = (gz_statep )file;
#line 324
  if (state->mode != 7247) {
#line 324
    if (state->mode != 31153) {
#line 325
      return (-1);
    }
  }
#line 328
  if (state->size != 0U) {
#line 329
    return (-1);
  }
#line 332
  if (size < 2U) {
#line 333
    size = 2U;
  }
#line 334
  state->want = size;
#line 335
  return (0);
}
}
#line 339 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
int gzrewind(gzFile file ) 
{ 
  gz_statep state ;
  __off64_t tmp ;

  {
#line 345
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 346
    return (-1);
  }
#line 347
  state = (gz_statep )file;
#line 350
  if (state->mode != 7247) {
#line 352
    return (-1);
  } else
#line 350
  if (state->err != 0) {
#line 350
    if (state->err != -5) {
#line 352
      return (-1);
    }
  }
  {
#line 355
  tmp = lseek64(state->fd, state->start, 0);
  }
#line 355
  if (tmp == -1L) {
#line 356
    return (-1);
  }
  {
#line 357
  gz_reset(state);
  }
#line 358
  return (0);
}
}
#line 362 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
off64_t gzseek64(gzFile file , off64_t offset , int whence ) 
{ 
  unsigned int n ;
  off64_t ret ;
  gz_statep state ;
  int tmp ;

  {
#line 372
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 373
    return ((off64_t )-1);
  }
#line 374
  state = (gz_statep )file;
#line 375
  if (state->mode != 7247) {
#line 375
    if (state->mode != 31153) {
#line 376
      return ((off64_t )-1);
    }
  }
#line 379
  if (state->err != 0) {
#line 379
    if (state->err != -5) {
#line 380
      return ((off64_t )-1);
    }
  }
#line 383
  if (whence != 0) {
#line 383
    if (whence != 1) {
#line 384
      return ((off64_t )-1);
    }
  }
#line 387
  if (whence == 0) {
#line 388
    offset -= state->x.pos;
  } else
#line 389
  if (state->seek) {
#line 390
    offset += state->skip;
  }
#line 391
  state->seek = 0;
#line 394
  if (state->mode == 7247) {
#line 394
    if (state->how == 1) {
#line 394
      if (state->x.pos + offset >= 0L) {
        {
#line 396
        ret = lseek64(state->fd, offset - (off64_t )state->x.have, 1);
        }
#line 397
        if (ret == -1L) {
#line 398
          return ((off64_t )-1);
        }
        {
#line 399
        state->x.have = 0U;
#line 400
        state->eof = 0;
#line 401
        state->past = 0;
#line 402
        state->seek = 0;
#line 403
        gz_error(state, 0, (char const   *)((void *)0));
#line 404
        state->strm.avail_in = (uInt )0;
#line 405
        state->x.pos += offset;
        }
#line 406
        return (state->x.pos);
      }
    }
  }
#line 410
  if (offset < 0L) {
#line 411
    if (state->mode != 7247) {
#line 412
      return ((off64_t )-1);
    }
#line 413
    offset += state->x.pos;
#line 414
    if (offset < 0L) {
#line 415
      return ((off64_t )-1);
    }
    {
#line 416
    tmp = gzrewind(file);
    }
#line 416
    if (tmp == -1) {
#line 417
      return ((off64_t )-1);
    }
  }
#line 421
  if (state->mode == 7247) {
#line 422
    if (sizeof(int ) == sizeof(off64_t )) {
#line 422
      if (state->x.have > 2147483647U) {
#line 422
        n = (unsigned int )offset;
      } else {
#line 422
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 422
    if ((off64_t )state->x.have > offset) {
#line 422
      n = (unsigned int )offset;
    } else {
#line 422
      n = state->x.have;
    }
#line 424
    state->x.have -= n;
#line 425
    state->x.next += n;
#line 426
    state->x.pos += (off64_t )n;
#line 427
    offset -= (off64_t )n;
  }
#line 431
  if (offset) {
#line 432
    state->seek = 1;
#line 433
    state->skip = offset;
  }
#line 435
  return (state->x.pos + offset);
}
}
#line 439 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
off_t gzseek(gzFile file , off_t offset , int whence ) 
{ 
  off64_t ret ;
  off_t tmp ;

  {
  {
#line 446
  ret = gzseek64(file, offset, whence);
  }
#line 447
  if (ret == ret) {
#line 447
    tmp = ret;
  } else {
#line 447
    tmp = (off_t )-1;
  }
#line 447
  return (tmp);
}
}
#line 451 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
off64_t gztell64(gzFile file ) 
{ 
  gz_statep state ;
  off64_t tmp ;

  {
#line 457
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 458
    return ((off64_t )-1);
  }
#line 459
  state = (gz_statep )file;
#line 460
  if (state->mode != 7247) {
#line 460
    if (state->mode != 31153) {
#line 461
      return ((off64_t )-1);
    }
  }
#line 464
  if (state->seek) {
#line 464
    tmp = state->skip;
  } else {
#line 464
    tmp = (off64_t )0;
  }
#line 464
  return (state->x.pos + tmp);
}
}
#line 468 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
off_t gztell(gzFile file ) 
{ 
  off64_t ret ;
  off_t tmp ;

  {
  {
#line 473
  ret = gztell64(file);
  }
#line 474
  if (ret == ret) {
#line 474
    tmp = ret;
  } else {
#line 474
    tmp = (off_t )-1;
  }
#line 474
  return (tmp);
}
}
#line 478 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
off64_t gzoffset64(gzFile file ) 
{ 
  off64_t offset ;
  gz_statep state ;

  {
#line 485
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 486
    return ((off64_t )-1);
  }
#line 487
  state = (gz_statep )file;
#line 488
  if (state->mode != 7247) {
#line 488
    if (state->mode != 31153) {
#line 489
      return ((off64_t )-1);
    }
  }
  {
#line 492
  offset = lseek64(state->fd, (__off64_t )0, 1);
  }
#line 493
  if (offset == -1L) {
#line 494
    return ((off64_t )-1);
  }
#line 495
  if (state->mode == 7247) {
#line 496
    offset -= (off64_t )state->strm.avail_in;
  }
#line 497
  return (offset);
}
}
#line 501 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
off_t gzoffset(gzFile file ) 
{ 
  off64_t ret ;
  off_t tmp ;

  {
  {
#line 506
  ret = gzoffset64(file);
  }
#line 507
  if (ret == ret) {
#line 507
    tmp = ret;
  } else {
#line 507
    tmp = (off_t )-1;
  }
#line 507
  return (tmp);
}
}
#line 511 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
int gzeof(gzFile file ) 
{ 
  gz_statep state ;
  int tmp ;

  {
#line 517
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 518
    return (0);
  }
#line 519
  state = (gz_statep )file;
#line 520
  if (state->mode != 7247) {
#line 520
    if (state->mode != 31153) {
#line 521
      return (0);
    }
  }
#line 524
  if (state->mode == 7247) {
#line 524
    tmp = state->past;
  } else {
#line 524
    tmp = 0;
  }
#line 524
  return (tmp);
}
}
#line 528 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
char const   *gzerror(gzFile file , int *errnum ) 
{ 
  gz_statep state ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 535
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 536
    return ((char const   *)((void *)0));
  }
#line 537
  state = (gz_statep )file;
#line 538
  if (state->mode != 7247) {
#line 538
    if (state->mode != 31153) {
#line 539
      return ((char const   *)((void *)0));
    }
  }
#line 542
  if ((unsigned long )errnum != (unsigned long )((void *)0)) {
#line 543
    *errnum = state->err;
  }
#line 544
  if (state->err == -4) {
#line 544
    tmp___0 = "out of memory";
  } else {
#line 544
    if ((unsigned long )state->msg == (unsigned long )((void *)0)) {
#line 544
      tmp = "";
    } else {
#line 544
      tmp = (char const   *)state->msg;
    }
#line 544
    tmp___0 = tmp;
  }
#line 544
  return (tmp___0);
}
}
#line 549 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
void gzclearerr(gzFile file ) 
{ 
  gz_statep state ;

  {
#line 555
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 556
    return;
  }
#line 557
  state = (gz_statep )file;
#line 558
  if (state->mode != 7247) {
#line 558
    if (state->mode != 31153) {
#line 559
      return;
    }
  }
#line 562
  if (state->mode == 7247) {
#line 563
    state->eof = 0;
#line 564
    state->past = 0;
  }
  {
#line 566
  gz_error(state, 0, (char const   *)((void *)0));
  }
#line 567
  return;
}
}
#line 575 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzlib.c"
void __attribute__((__visibility__("hidden")))  gz_error(gz_statep state , int err ,
                                                         char const   *msg___0 ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 581
  if ((unsigned long )state->msg != (unsigned long )((void *)0)) {
#line 582
    if (state->err != -4) {
      {
#line 583
      free((void *)state->msg);
      }
    }
#line 584
    state->msg = (char *)((void *)0);
  }
#line 588
  if (err != 0) {
#line 588
    if (err != -5) {
#line 589
      state->x.have = 0U;
    }
  }
#line 592
  state->err = err;
#line 593
  if ((unsigned long )msg___0 == (unsigned long )((void *)0)) {
#line 594
    return;
  }
#line 597
  if (err == -4) {
#line 598
    return;
  }
  {
#line 601
  tmp___0 = strlen((char const   *)state->path);
#line 601
  tmp___1 = strlen(msg___0);
#line 601
  tmp___2 = malloc((tmp___0 + tmp___1) + 3UL);
#line 601
  tmp = (char *)tmp___2;
#line 601
  state->msg = tmp;
  }
#line 601
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 603
    state->err = -4;
#line 604
    return;
  }
  {
#line 607
  tmp___3 = strlen((char const   *)state->path);
#line 607
  tmp___4 = strlen(msg___0);
#line 607
  snprintf((char */* __restrict  */)state->msg, (tmp___3 + tmp___4) + 3UL, (char const   */* __restrict  */)"%s%s%s",
           state->path, ": ", msg___0);
  }
#line 614
  return;
}
}
#line 1529 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
int gzclose(gzFile file ) ;
#line 11 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/gzclose.c"
int gzclose(gzFile file ) 
{ 
  int tmp ;

  {
  {
#line 23
  tmp = gzclose_r(file);
  }
#line 23
  return (tmp);
}
}
#line 605 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
int deflateSetDictionary(z_streamp___0 strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 649
int deflateCopy(z_streamp___0 dest , z_streamp___0 source ) ;
#line 699
int deflateTune(z_streamp___0 strm , int good_length , int max_lazy , int nice_length ,
                int max_chain ) ;
#line 716
uLong deflateBound(z_streamp___0 strm , uLong sourceLen ) ;
#line 731
int deflatePending(z_streamp___0 strm , unsigned int *pending , int *bits ) ;
#line 746
int deflatePrime(z_streamp___0 strm , int bits , int value ) ;
#line 763
int deflateSetHeader(z_streamp___0 strm , gz_headerp head ) ;
#line 1651
int deflateInit_(z_streamp___0 strm , int level , char const   *version , int stream_size ) ;
#line 1769
int deflateResetKeep(z_streamp___0 strm ) ;
#line 54 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
char const   deflate_copyright[68]  = 
#line 54 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
  {      (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'8',      (char const   )' ',      (char const   )'C', 
        (char const   )'o',      (char const   )'p',      (char const   )'y',      (char const   )'r', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'t', 
        (char const   )' ',      (char const   )'1',      (char const   )'9',      (char const   )'9', 
        (char const   )'5',      (char const   )'-',      (char const   )'2',      (char const   )'0', 
        (char const   )'1',      (char const   )'3',      (char const   )' ',      (char const   )'J', 
        (char const   )'e',      (char const   )'a',      (char const   )'n',      (char const   )'-', 
        (char const   )'l',      (char const   )'o',      (char const   )'u',      (char const   )'p', 
        (char const   )' ',      (char const   )'G',      (char const   )'a',      (char const   )'i', 
        (char const   )'l',      (char const   )'l',      (char const   )'y',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )' ', 
        (char const   )'M',      (char const   )'a',      (char const   )'r',      (char const   )'k', 
        (char const   )' ',      (char const   )'A',      (char const   )'d',      (char const   )'l', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'\000'};
#line 76
static void fill_window(deflate_state___0 *s ) ;
#line 77
static block_state deflate_stored(deflate_state___0 *s , int flush ) ;
#line 78
static block_state deflate_fast(deflate_state___0 *s , int flush ) ;
#line 80
static block_state deflate_slow(deflate_state___0 *s , int flush ) ;
#line 82
static block_state deflate_rle(deflate_state___0 *s , int flush ) ;
#line 83
static block_state deflate_huff(deflate_state___0 *s , int flush ) ;
#line 84
static void lm_init(deflate_state___0 *s ) ;
#line 85
static void putShortMSB(deflate_state___0 *s , uInt b ) ;
#line 86
static void flush_pending(z_streamp___0 strm ) ;
#line 87
static int read_buf(z_streamp___0 strm , Bytef *buf , unsigned int size ) ;
#line 92
static uInt longest_match(deflate_state___0 *s , IPos cur_match ) ;
#line 131 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static config const   configuration_table[10]  = 
#line 131
  {      {(ush )0, (ush )0, (ush )0, (ush )0, & deflate_stored}, 
        {(ush )4, (ush )4, (ush )8, (ush )4, & deflate_fast}, 
        {(ush )4, (ush )5, (ush )16, (ush )8, & deflate_fast}, 
        {(ush )4, (ush )6, (ush )32, (ush )32, & deflate_fast}, 
        {(ush )4, (ush )4, (ush )16, (ush )16, & deflate_slow}, 
        {(ush )8, (ush )16, (ush )32, (ush )32, & deflate_slow}, 
        {(ush )8, (ush )16, (ush )128, (ush )128, & deflate_slow}, 
        {(ush )8, (ush )32, (ush )128, (ush )256, & deflate_slow}, 
        {(ush )32, (ush )128, (ush )258, (ush )1024, & deflate_slow}, 
        {(ush )32, (ush )258, (ush )258, (ush )4096, & deflate_slow}};
#line 201 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateInit_(z_streamp___0 strm , int level , char const   *version , int stream_size ) 
{ 
  int tmp ;

  {
  {
#line 207
  tmp = deflateInit2_(strm, level, 8, 15, 8, 0, version, stream_size);
  }
#line 207
  return (tmp);
}
}
#line 226 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static char const   my_version[14]  = 
#line 226
  {      (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )'.', 
        (char const   )'8',      (char const   )'-',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'p',      (char const   )'n', 
        (char const   )'g',      (char const   )'\000'};
#line 213 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateInit2_(z_streamp___0 strm , int level , int method , int windowBits , int memLevel ,
                  int strategy , char const   *version , int stream_size ) 
{ 
  deflate_state___0 *s ;
  int wrap ;
  ushf *overlay ;
  voidpf tmp ;
  voidpf tmp___0 ;
  voidpf tmp___1 ;
  voidpf tmp___2 ;
  voidpf tmp___3 ;
  int tmp___4 ;

  {
#line 225
  wrap = 1;
#line 233
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 235
    return (-6);
  } else
#line 233
  if ((int const   )*(version + 0) != (int const   )my_version[0]) {
#line 235
    return (-6);
  } else
#line 233
  if ((unsigned long )stream_size != sizeof(z_stream___0 )) {
#line 235
    return (-6);
  }
#line 237
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 237
    return (-2);
  }
#line 239
  strm->msg = (char *)0;
#line 240
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 244
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& zcalloc);
#line 245
    strm->opaque = (voidpf )0;
  }
#line 248
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 252
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))(& zcfree);
  }
#line 258
  if (level == -1) {
#line 258
    level = 6;
  }
#line 261
  if (windowBits < 0) {
#line 262
    wrap = 0;
#line 263
    windowBits = - windowBits;
  }
#line 271
  if (memLevel < 1) {
#line 274
    return (-2);
  } else
#line 271
  if (memLevel > 9) {
#line 274
    return (-2);
  } else
#line 271
  if (method != 8) {
#line 274
    return (-2);
  } else
#line 271
  if (windowBits < 8) {
#line 274
    return (-2);
  } else
#line 271
  if (windowBits > 15) {
#line 274
    return (-2);
  } else
#line 271
  if (level < 0) {
#line 274
    return (-2);
  } else
#line 271
  if (level > 9) {
#line 274
    return (-2);
  } else
#line 271
  if (strategy < 0) {
#line 274
    return (-2);
  } else
#line 271
  if (strategy > 4) {
#line 274
    return (-2);
  }
#line 276
  if (windowBits == 8) {
#line 276
    windowBits = 9;
  }
  {
#line 277
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(deflate_state___0 ));
#line 277
  s = (deflate_state___0 *)tmp;
  }
#line 278
  if ((unsigned long )s == (unsigned long )((deflate_state___0 *)0)) {
#line 278
    return (-4);
  }
  {
#line 279
  strm->state = s;
#line 280
  s->strm = strm;
#line 282
  s->wrap = wrap;
#line 283
  s->gzhead = (gz_headerp )0;
#line 284
  s->w_bits = (uInt )windowBits;
#line 285
  s->w_size = (uInt )(1 << s->w_bits);
#line 286
  s->w_mask = s->w_size - 1U;
#line 288
  s->hash_bits = (uInt )(memLevel + 7);
#line 289
  s->hash_size = (uInt )(1 << s->hash_bits);
#line 290
  s->hash_mask = s->hash_size - 1U;
#line 291
  s->hash_shift = ((s->hash_bits + 3U) - 1U) / 3U;
#line 293
  tmp___0 = (*(strm->zalloc))(strm->opaque, s->w_size, (uInt )(2UL * sizeof(Byte )));
#line 293
  s->window = (Bytef *)tmp___0;
#line 294
  tmp___1 = (*(strm->zalloc))(strm->opaque, s->w_size, (uInt )sizeof(Pos ));
#line 294
  s->prev = (Posf *)tmp___1;
#line 295
  tmp___2 = (*(strm->zalloc))(strm->opaque, s->hash_size, (uInt )sizeof(Pos ));
#line 295
  s->head = (Posf *)tmp___2;
#line 297
  s->high_water = (ulg )0;
#line 299
  s->lit_bufsize = (uInt )(1 << (memLevel + 6));
#line 301
  tmp___3 = (*(strm->zalloc))(strm->opaque, s->lit_bufsize, (uInt )(sizeof(ush ) + 2UL));
#line 301
  overlay = (ushf *)tmp___3;
#line 302
  s->pending_buf = (uchf *)overlay;
#line 303
  s->pending_buf_size = (ulg )s->lit_bufsize * (sizeof(ush ) + 2UL);
  }
#line 305
  if ((unsigned long )s->window == (unsigned long )((Bytef *)0)) {
    {
#line 307
    s->status = 666;
#line 308
    strm->msg = (char *)z_errmsg[6];
#line 309
    deflateEnd(strm);
    }
#line 310
    return (-4);
  } else
#line 305
  if ((unsigned long )s->prev == (unsigned long )((Posf *)0)) {
    {
#line 307
    s->status = 666;
#line 308
    strm->msg = (char *)z_errmsg[6];
#line 309
    deflateEnd(strm);
    }
#line 310
    return (-4);
  } else
#line 305
  if ((unsigned long )s->head == (unsigned long )((Posf *)0)) {
    {
#line 307
    s->status = 666;
#line 308
    strm->msg = (char *)z_errmsg[6];
#line 309
    deflateEnd(strm);
    }
#line 310
    return (-4);
  } else
#line 305
  if ((unsigned long )s->pending_buf == (unsigned long )((Bytef *)0)) {
    {
#line 307
    s->status = 666;
#line 308
    strm->msg = (char *)z_errmsg[6];
#line 309
    deflateEnd(strm);
    }
#line 310
    return (-4);
  }
  {
#line 312
  s->d_buf = overlay + (unsigned long )s->lit_bufsize / sizeof(ush );
#line 313
  s->l_buf = s->pending_buf + (1UL + sizeof(ush )) * (unsigned long )s->lit_bufsize;
#line 315
  s->level = level;
#line 316
  s->strategy = strategy;
#line 317
  s->method = (Byte )method;
#line 319
  tmp___4 = deflateReset(strm);
  }
#line 319
  return (tmp___4);
}
}
#line 323 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateSetDictionary(z_streamp___0 strm , Bytef const   *dictionary , uInt dictLength ) 
{ 
  deflate_state___0 *s ;
  uInt str ;
  uInt n ;
  int wrap ;
  unsigned int avail ;
  unsigned char *next ;
  uInt tmp ;

  {
#line 334
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 335
    return (-2);
  } else
#line 334
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 335
    return (-2);
  } else
#line 334
  if ((unsigned long )dictionary == (unsigned long )((Bytef const   *)0)) {
#line 335
    return (-2);
  }
#line 336
  s = strm->state;
#line 337
  wrap = s->wrap;
#line 338
  if (wrap == 2) {
#line 339
    return (-2);
  } else
#line 338
  if (wrap == 1) {
#line 338
    if (s->status != 42) {
#line 339
      return (-2);
    } else {
#line 338
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 338
  if (s->lookahead) {
#line 339
    return (-2);
  }
#line 342
  if (wrap == 1) {
    {
#line 343
    strm->adler = adler32(strm->adler, dictionary, dictLength);
    }
  }
#line 344
  s->wrap = 0;
#line 347
  if (dictLength >= s->w_size) {
#line 348
    if (wrap == 0) {
      {
#line 349
      *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 349
      memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
#line 350
      s->strstart = (uInt )0;
#line 351
      s->block_start = 0L;
#line 352
      s->insert = (uInt )0;
      }
    }
#line 354
    dictionary += dictLength - s->w_size;
#line 355
    dictLength = s->w_size;
  }
  {
#line 359
  avail = strm->avail_in;
#line 360
  next = strm->next_in;
#line 361
  strm->avail_in = dictLength;
#line 362
  strm->next_in = (Bytef *)dictionary;
#line 363
  fill_window(s);
  }
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (s->lookahead >= 3U)) {
#line 364
      goto while_break;
    }
#line 365
    str = s->strstart;
#line 366
    n = s->lookahead - 2U;
    {
#line 367
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 368
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + ((str + 3U) - 1U))) & s->hash_mask;
#line 370
      *(s->prev + (str & s->w_mask)) = *(s->head + s->ins_h);
#line 372
      *(s->head + s->ins_h) = (Pos )str;
#line 373
      str ++;
#line 367
      n --;
#line 367
      if (! n) {
#line 367
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 375
    s->strstart = str;
#line 376
    s->lookahead = (uInt )2;
#line 377
    fill_window(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  s->strstart += s->lookahead;
#line 380
  s->block_start = (long )s->strstart;
#line 381
  s->insert = s->lookahead;
#line 382
  s->lookahead = (uInt )0;
#line 383
  tmp = (uInt )2;
#line 383
  s->prev_length = tmp;
#line 383
  s->match_length = tmp;
#line 384
  s->match_available = 0;
#line 385
  strm->next_in = next;
#line 386
  strm->avail_in = avail;
#line 387
  s->wrap = wrap;
#line 388
  return (0);
}
}
#line 392 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateResetKeep(z_streamp___0 strm ) 
{ 
  deflate_state___0 *s ;
  uLong tmp ;

  {
#line 397
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 399
    return (-2);
  } else
#line 397
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 399
    return (-2);
  } else
#line 397
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 399
    return (-2);
  } else
#line 397
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 399
    return (-2);
  }
#line 402
  tmp = (uLong )0;
#line 402
  strm->total_out = tmp;
#line 402
  strm->total_in = tmp;
#line 403
  strm->msg = (char *)0;
#line 404
  strm->data_type = 2;
#line 406
  s = strm->state;
#line 407
  s->pending = (uInt )0;
#line 408
  s->pending_out = s->pending_buf;
#line 410
  if (s->wrap < 0) {
#line 411
    s->wrap = - s->wrap;
  }
#line 413
  if (s->wrap) {
#line 413
    s->status = 42;
  } else {
#line 413
    s->status = 113;
  }
  {
#line 414
  strm->adler = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 419
  s->last_flush = 0;
#line 421
  _tr_init(s);
  }
#line 423
  return (0);
}
}
#line 427 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateReset(z_streamp___0 strm ) 
{ 
  int ret ;

  {
  {
#line 432
  ret = deflateResetKeep(strm);
  }
#line 433
  if (ret == 0) {
    {
#line 434
    lm_init(strm->state);
    }
  }
#line 435
  return (ret);
}
}
#line 439 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateSetHeader(z_streamp___0 strm , gz_headerp head ) 
{ 


  {
#line 443
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 443
    return (-2);
  } else
#line 443
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 443
    return (-2);
  }
#line 444
  if ((strm->state)->wrap != 2) {
#line 444
    return (-2);
  }
#line 445
  (strm->state)->gzhead = head;
#line 446
  return (0);
}
}
#line 450 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflatePending(z_streamp___0 strm , unsigned int *pending , int *bits ) 
{ 


  {
#line 455
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 455
    return (-2);
  } else
#line 455
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 455
    return (-2);
  }
#line 456
  if ((unsigned long )pending != (unsigned long )((unsigned int *)0)) {
#line 457
    *pending = (strm->state)->pending;
  }
#line 458
  if ((unsigned long )bits != (unsigned long )((int *)0)) {
#line 459
    *bits = (strm->state)->bi_valid;
  }
#line 460
  return (0);
}
}
#line 464 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflatePrime(z_streamp___0 strm , int bits , int value ) 
{ 
  deflate_state___0 *s ;
  int put ;

  {
#line 472
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 472
    return (-2);
  } else
#line 472
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 472
    return (-2);
  }
#line 473
  s = strm->state;
#line 474
  if ((unsigned long )((Bytef *)s->d_buf) < (unsigned long )(s->pending_out + (23 >> 3))) {
#line 475
    return (-5);
  }
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    put = 16 - s->bi_valid;
#line 478
    if (put > bits) {
#line 479
      put = bits;
    }
    {
#line 480
    s->bi_buf = (ush )((int )s->bi_buf | (int )((ush )((value & ((1 << put) - 1)) << s->bi_valid)));
#line 481
    s->bi_valid += put;
#line 482
    _tr_flush_bits(s);
#line 483
    value >>= put;
#line 484
    bits -= put;
    }
#line 476
    if (! bits) {
#line 476
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return (0);
}
}
#line 490 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateParams(z_streamp___0 strm , int level , int strategy ) 
{ 
  deflate_state___0 *s ;
  block_state (*func)(deflate_state___0 *s , int flush ) ;
  int err ;

  {
#line 497
  err = 0;
#line 499
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 499
    return (-2);
  } else
#line 499
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 499
    return (-2);
  }
#line 500
  s = strm->state;
#line 505
  if (level == -1) {
#line 505
    level = 6;
  }
#line 507
  if (level < 0) {
#line 508
    return (-2);
  } else
#line 507
  if (level > 9) {
#line 508
    return (-2);
  } else
#line 507
  if (strategy < 0) {
#line 508
    return (-2);
  } else
#line 507
  if (strategy > 4) {
#line 508
    return (-2);
  }
#line 510
  func = (block_state (*)(deflate_state___0 *s , int flush ))configuration_table[s->level].func;
#line 512
  if (strategy != s->strategy) {
#line 512
    goto _L;
  } else
#line 512
  if ((unsigned long )func != (unsigned long )configuration_table[level].func) {
    _L: /* CIL Label */ 
#line 512
    if (strm->total_in != 0UL) {
      {
#line 515
      err = deflate(strm, 5);
      }
#line 516
      if (err == -5) {
#line 516
        if (s->pending == 0U) {
#line 517
          err = 0;
        }
      }
    }
  }
#line 519
  if (s->level != level) {
#line 520
    s->level = level;
#line 521
    s->max_lazy_match = (uInt )configuration_table[level].max_lazy;
#line 522
    s->good_match = (uInt )configuration_table[level].good_length;
#line 523
    s->nice_match = (int )configuration_table[level].nice_length;
#line 524
    s->max_chain_length = (uInt )configuration_table[level].max_chain;
  }
#line 526
  s->strategy = strategy;
#line 527
  return (err);
}
}
#line 531 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateTune(z_streamp___0 strm , int good_length , int max_lazy , int nice_length ,
                int max_chain ) 
{ 
  deflate_state___0 *s ;

  {
#line 540
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 540
    return (-2);
  } else
#line 540
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 540
    return (-2);
  }
#line 541
  s = strm->state;
#line 542
  s->good_match = (uInt )good_length;
#line 543
  s->max_lazy_match = (uInt )max_lazy;
#line 544
  s->nice_match = nice_length;
#line 545
  s->max_chain_length = (uInt )max_chain;
#line 546
  return (0);
}
}
#line 566 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
uLong deflateBound(z_streamp___0 strm , uLong sourceLen ) 
{ 
  deflate_state___0 *s ;
  uLong complen ;
  uLong wraplen ;
  Bytef *str ;
  int tmp ;
  Bytef *tmp___0 ;
  Bytef *tmp___1 ;

  {
#line 575
  complen = ((sourceLen + ((sourceLen + 7UL) >> 3)) + ((sourceLen + 63UL) >> 6)) + 5UL;
#line 579
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 580
    return (complen + 6UL);
  } else
#line 579
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 580
    return (complen + 6UL);
  }
#line 583
  s = strm->state;
  {
#line 585
  if (s->wrap == 0) {
#line 585
    goto case_0;
  }
#line 588
  if (s->wrap == 1) {
#line 588
    goto case_1;
  }
#line 591
  if (s->wrap == 2) {
#line 591
    goto case_2;
  }
#line 610
  goto switch_default;
  case_0: /* CIL Label */ 
#line 586
  wraplen = (uLong )0;
#line 587
  goto switch_break;
  case_1: /* CIL Label */ 
#line 589
  if (s->strstart) {
#line 589
    tmp = 4;
  } else {
#line 589
    tmp = 0;
  }
#line 589
  wraplen = (uLong )(6 + tmp);
#line 590
  goto switch_break;
  case_2: /* CIL Label */ 
#line 592
  wraplen = (uLong )18;
#line 593
  if ((unsigned long )s->gzhead != (unsigned long )((gz_headerp )0)) {
#line 594
    if ((unsigned long )(s->gzhead)->extra != (unsigned long )((Bytef *)0)) {
#line 595
      wraplen += (uLong )(2U + (s->gzhead)->extra_len);
    }
#line 596
    str = (s->gzhead)->name;
#line 597
    if ((unsigned long )str != (unsigned long )((Bytef *)0)) {
      {
#line 598
      while (1) {
        while_continue: /* CIL Label */ ;
#line 599
        wraplen ++;
#line 598
        tmp___0 = str;
#line 598
        str ++;
#line 598
        if (! *tmp___0) {
#line 598
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 601
    str = (s->gzhead)->comment;
#line 602
    if ((unsigned long )str != (unsigned long )((Bytef *)0)) {
      {
#line 603
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 604
        wraplen ++;
#line 603
        tmp___1 = str;
#line 603
        str ++;
#line 603
        if (! *tmp___1) {
#line 603
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 606
    if ((s->gzhead)->hcrc) {
#line 607
      wraplen += 2UL;
    }
  }
#line 609
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 611
  wraplen = (uLong )6;
  switch_break: /* CIL Label */ ;
  }
#line 615
  if (s->w_bits != 15U) {
#line 616
    return (complen + wraplen);
  } else
#line 615
  if (s->hash_bits != 15U) {
#line 616
    return (complen + wraplen);
  }
#line 619
  return ((((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + 13UL) - 6UL) + wraplen);
}
}
#line 628 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static void putShortMSB(deflate_state___0 *s , uInt b ) 
{ 
  uInt tmp ;
  uInt tmp___0 ;

  {
#line 632
  tmp = s->pending;
#line 632
  (s->pending) ++;
#line 632
  *(s->pending_buf + tmp) = (Byte )(b >> 8);
#line 633
  tmp___0 = s->pending;
#line 633
  (s->pending) ++;
#line 633
  *(s->pending_buf + tmp___0) = (Byte )(b & 255U);
#line 634
  return;
}
}
#line 642 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static void flush_pending(z_streamp___0 strm ) 
{ 
  unsigned int len ;
  deflate_state___0 *s ;

  {
  {
#line 646
  s = strm->state;
#line 648
  _tr_flush_bits(s);
#line 649
  len = s->pending;
  }
#line 650
  if (len > strm->avail_out) {
#line 650
    len = strm->avail_out;
  }
#line 651
  if (len == 0U) {
#line 651
    return;
  }
  {
#line 653
  memcpy((void */* __restrict  */)strm->next_out, (void const   */* __restrict  */)s->pending_out,
         (size_t )len);
#line 654
  strm->next_out += len;
#line 655
  s->pending_out += len;
#line 656
  strm->total_out += (uLong )len;
#line 657
  strm->avail_out -= len;
#line 658
  s->pending -= len;
  }
#line 659
  if (s->pending == 0U) {
#line 660
    s->pending_out = s->pending_buf;
  }
#line 662
  return;
}
}
#line 665 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflate(z_streamp___0 strm , int flush ) 
{ 
  int old_flush ;
  deflate_state___0 *s ;
  uInt header ;
  uInt level_flags ;
  int tmp ;
  int tmp___0 ;
  block_state bstate ;
  block_state tmp___1 ;
  block_state tmp___2 ;
  block_state tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;

  {
#line 672
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 674
    return (-2);
  } else
#line 672
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 674
    return (-2);
  } else
#line 672
  if (flush > 5) {
#line 674
    return (-2);
  } else
#line 672
  if (flush < 0) {
#line 674
    return (-2);
  }
#line 676
  s = strm->state;
#line 678
  if ((unsigned long )strm->next_out == (unsigned long )((Bytef *)0)) {
#line 681
    strm->msg = (char *)z_errmsg[4];
#line 681
    return (-2);
  } else
#line 678
  if ((unsigned long )strm->next_in == (unsigned long )((Bytef *)0)) {
#line 678
    if (strm->avail_in != 0U) {
#line 681
      strm->msg = (char *)z_errmsg[4];
#line 681
      return (-2);
    } else {
#line 678
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 678
  if (s->status == 666) {
#line 678
    if (flush != 4) {
#line 681
      strm->msg = (char *)z_errmsg[4];
#line 681
      return (-2);
    }
  }
#line 683
  if (strm->avail_out == 0U) {
#line 683
    strm->msg = (char *)z_errmsg[7];
#line 683
    return (-5);
  }
#line 685
  s->strm = strm;
#line 686
  old_flush = s->last_flush;
#line 687
  s->last_flush = flush;
#line 690
  if (s->status == 42) {
#line 738
    header = (8U + ((s->w_bits - 8U) << 4)) << 8;
#line 741
    if (s->strategy >= 2) {
#line 742
      level_flags = (uInt )0;
    } else
#line 741
    if (s->level < 2) {
#line 742
      level_flags = (uInt )0;
    } else
#line 743
    if (s->level < 6) {
#line 744
      level_flags = (uInt )1;
    } else
#line 745
    if (s->level == 6) {
#line 746
      level_flags = (uInt )2;
    } else {
#line 748
      level_flags = (uInt )3;
    }
#line 749
    header |= level_flags << 6;
#line 750
    if (s->strstart != 0U) {
#line 750
      header |= 32U;
    }
    {
#line 751
    header += 31U - header % 31U;
#line 753
    s->status = 113;
#line 754
    putShortMSB(s, header);
    }
#line 757
    if (s->strstart != 0U) {
      {
#line 758
      putShortMSB(s, (uInt )(strm->adler >> 16));
#line 759
      putShortMSB(s, (uInt )(strm->adler & 65535UL));
      }
    }
    {
#line 761
    strm->adler = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
    }
  }
#line 870
  if (s->pending != 0U) {
    {
#line 871
    flush_pending(strm);
    }
#line 872
    if (strm->avail_out == 0U) {
#line 879
      s->last_flush = -1;
#line 880
      return (0);
    }
  } else
#line 887
  if (strm->avail_in == 0U) {
#line 887
    if (flush > 4) {
#line 887
      tmp = 9;
    } else {
#line 887
      tmp = 0;
    }
#line 887
    if (old_flush > 4) {
#line 887
      tmp___0 = 9;
    } else {
#line 887
      tmp___0 = 0;
    }
#line 887
    if ((flush << 1) - tmp <= (old_flush << 1) - tmp___0) {
#line 887
      if (flush != 4) {
#line 889
        strm->msg = (char *)z_errmsg[7];
#line 889
        return (-5);
      }
    }
  }
#line 893
  if (s->status == 666) {
#line 893
    if (strm->avail_in != 0U) {
#line 894
      strm->msg = (char *)z_errmsg[7];
#line 894
      return (-5);
    }
  }
#line 899
  if (strm->avail_in != 0U) {
#line 899
    goto _L___1;
  } else
#line 899
  if (s->lookahead != 0U) {
#line 899
    goto _L___1;
  } else
#line 899
  if (flush != 0) {
#line 899
    if (s->status != 666) {
      _L___1: /* CIL Label */ 
#line 903
      if (s->strategy == 2) {
        {
#line 903
        tmp___1 = deflate_huff(s, flush);
#line 903
        bstate = tmp___1;
        }
      } else {
#line 903
        if (s->strategy == 3) {
          {
#line 903
          tmp___2 = deflate_rle(s, flush);
#line 903
          tmp___4 = (unsigned int )tmp___2;
          }
        } else {
          {
#line 903
          tmp___3 = (*(configuration_table[s->level].func))(s, flush);
#line 903
          tmp___4 = (unsigned int )tmp___3;
          }
        }
#line 903
        bstate = (block_state )tmp___4;
      }
#line 907
      if ((unsigned int )bstate == 2U) {
#line 908
        s->status = 666;
      } else
#line 907
      if ((unsigned int )bstate == 3U) {
#line 908
        s->status = 666;
      }
#line 910
      if ((unsigned int )bstate == 0U) {
#line 910
        goto _L___0;
      } else
#line 910
      if ((unsigned int )bstate == 2U) {
        _L___0: /* CIL Label */ 
#line 911
        if (strm->avail_out == 0U) {
#line 912
          s->last_flush = -1;
        }
#line 914
        return (0);
      }
#line 923
      if ((unsigned int )bstate == 1U) {
#line 924
        if (flush == 1) {
          {
#line 925
          _tr_align(s);
          }
        } else
#line 926
        if (flush != 5) {
          {
#line 927
          _tr_stored_block(s, (char *)0, (ulg )0L, 0);
          }
#line 931
          if (flush == 3) {
            {
#line 932
            *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 932
            memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
            }
#line 933
            if (s->lookahead == 0U) {
#line 934
              s->strstart = (uInt )0;
#line 935
              s->block_start = 0L;
#line 936
              s->insert = (uInt )0;
            }
          }
        }
        {
#line 940
        flush_pending(strm);
        }
#line 941
        if (strm->avail_out == 0U) {
#line 942
          s->last_flush = -1;
#line 943
          return (0);
        }
      }
    }
  }
#line 949
  if (flush != 4) {
#line 949
    return (0);
  }
#line 950
  if (s->wrap <= 0) {
#line 950
    return (1);
  }
  {
#line 967
  putShortMSB(s, (uInt )(strm->adler >> 16));
#line 968
  putShortMSB(s, (uInt )(strm->adler & 65535UL));
#line 970
  flush_pending(strm);
  }
#line 974
  if (s->wrap > 0) {
#line 974
    s->wrap = - s->wrap;
  }
#line 975
  if (s->pending != 0U) {
#line 975
    tmp___5 = 0;
  } else {
#line 975
    tmp___5 = 1;
  }
#line 975
  return (tmp___5);
}
}
#line 979 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateEnd(z_streamp___0 strm ) 
{ 
  int status ;
  int tmp ;

  {
#line 984
  if ((unsigned long )strm == (unsigned long )((z_streamp___0 )0)) {
#line 984
    return (-2);
  } else
#line 984
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 984
    return (-2);
  }
#line 986
  status = (strm->state)->status;
#line 987
  if (status != 42) {
#line 987
    if (status != 69) {
#line 987
      if (status != 73) {
#line 987
        if (status != 91) {
#line 987
          if (status != 103) {
#line 987
            if (status != 113) {
#line 987
              if (status != 666) {
#line 994
                return (-2);
              }
            }
          }
        }
      }
    }
  }
#line 998
  if ((strm->state)->pending_buf) {
    {
#line 998
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->pending_buf);
    }
  }
#line 999
  if ((strm->state)->head) {
    {
#line 999
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->head);
    }
  }
#line 1000
  if ((strm->state)->prev) {
    {
#line 1000
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->prev);
    }
  }
#line 1001
  if ((strm->state)->window) {
    {
#line 1001
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->window);
    }
  }
  {
#line 1003
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 1004
  strm->state = (struct internal_state___1 *)0;
  }
#line 1006
  if (status == 113) {
#line 1006
    tmp = -3;
  } else {
#line 1006
    tmp = 0;
  }
#line 1006
  return (tmp);
}
}
#line 1014 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
int deflateCopy(z_streamp___0 dest , z_streamp___0 source ) 
{ 
  deflate_state___0 *ds ;
  deflate_state___0 *ss ;
  ushf *overlay ;
  voidpf tmp ;
  voidpf tmp___0 ;
  voidpf tmp___1 ;
  voidpf tmp___2 ;
  voidpf tmp___3 ;

  {
#line 1026
  if ((unsigned long )source == (unsigned long )((z_streamp___0 )0)) {
#line 1027
    return (-2);
  } else
#line 1026
  if ((unsigned long )dest == (unsigned long )((z_streamp___0 )0)) {
#line 1027
    return (-2);
  } else
#line 1026
  if ((unsigned long )source->state == (unsigned long )((struct internal_state___1 *)0)) {
#line 1027
    return (-2);
  }
  {
#line 1030
  ss = source->state;
#line 1032
  memcpy((void */* __restrict  */)((voidpf )dest), (void const   */* __restrict  */)((voidpf )source),
         sizeof(z_stream___0 ));
#line 1034
  tmp = (*(dest->zalloc))(dest->opaque, (uInt )1, (uInt )sizeof(deflate_state___0 ));
#line 1034
  ds = (deflate_state___0 *)tmp;
  }
#line 1035
  if ((unsigned long )ds == (unsigned long )((deflate_state___0 *)0)) {
#line 1035
    return (-4);
  }
  {
#line 1036
  dest->state = ds;
#line 1037
  memcpy((void */* __restrict  */)((voidpf )ds), (void const   */* __restrict  */)((voidpf )ss),
         sizeof(deflate_state___0 ));
#line 1038
  ds->strm = dest;
#line 1040
  tmp___0 = (*(dest->zalloc))(dest->opaque, ds->w_size, (uInt )(2UL * sizeof(Byte )));
#line 1040
  ds->window = (Bytef *)tmp___0;
#line 1041
  tmp___1 = (*(dest->zalloc))(dest->opaque, ds->w_size, (uInt )sizeof(Pos ));
#line 1041
  ds->prev = (Posf *)tmp___1;
#line 1042
  tmp___2 = (*(dest->zalloc))(dest->opaque, ds->hash_size, (uInt )sizeof(Pos ));
#line 1042
  ds->head = (Posf *)tmp___2;
#line 1043
  tmp___3 = (*(dest->zalloc))(dest->opaque, ds->lit_bufsize, (uInt )(sizeof(ush ) + 2UL));
#line 1043
  overlay = (ushf *)tmp___3;
#line 1044
  ds->pending_buf = (uchf *)overlay;
  }
#line 1046
  if ((unsigned long )ds->window == (unsigned long )((Bytef *)0)) {
    {
#line 1048
    deflateEnd(dest);
    }
#line 1049
    return (-4);
  } else
#line 1046
  if ((unsigned long )ds->prev == (unsigned long )((Posf *)0)) {
    {
#line 1048
    deflateEnd(dest);
    }
#line 1049
    return (-4);
  } else
#line 1046
  if ((unsigned long )ds->head == (unsigned long )((Posf *)0)) {
    {
#line 1048
    deflateEnd(dest);
    }
#line 1049
    return (-4);
  } else
#line 1046
  if ((unsigned long )ds->pending_buf == (unsigned long )((Bytef *)0)) {
    {
#line 1048
    deflateEnd(dest);
    }
#line 1049
    return (-4);
  }
  {
#line 1052
  memcpy((void */* __restrict  */)ds->window, (void const   */* __restrict  */)ss->window,
         (unsigned long )(ds->w_size * 2U) * sizeof(Byte ));
#line 1053
  memcpy((void */* __restrict  */)((voidpf )ds->prev), (void const   */* __restrict  */)((voidpf )ss->prev),
         (unsigned long )ds->w_size * sizeof(Pos ));
#line 1054
  memcpy((void */* __restrict  */)((voidpf )ds->head), (void const   */* __restrict  */)((voidpf )ss->head),
         (unsigned long )ds->hash_size * sizeof(Pos ));
#line 1055
  memcpy((void */* __restrict  */)ds->pending_buf, (void const   */* __restrict  */)ss->pending_buf,
         (size_t )((uInt )ds->pending_buf_size));
#line 1057
  ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
#line 1058
  ds->d_buf = overlay + (unsigned long )ds->lit_bufsize / sizeof(ush );
#line 1059
  ds->l_buf = ds->pending_buf + (1UL + sizeof(ush )) * (unsigned long )ds->lit_bufsize;
#line 1061
  ds->l_desc.dyn_tree = ds->dyn_ltree;
#line 1062
  ds->d_desc.dyn_tree = ds->dyn_dtree;
#line 1063
  ds->bl_desc.dyn_tree = ds->bl_tree;
  }
#line 1065
  return (0);
}
}
#line 1076 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static int read_buf(z_streamp___0 strm , Bytef *buf , unsigned int size ) 
{ 
  unsigned int len ;

  {
#line 1081
  len = strm->avail_in;
#line 1083
  if (len > size) {
#line 1083
    len = size;
  }
#line 1084
  if (len == 0U) {
#line 1084
    return (0);
  }
  {
#line 1086
  strm->avail_in -= len;
#line 1088
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)strm->next_in,
         (size_t )len);
  }
#line 1089
  if ((strm->state)->wrap == 1) {
    {
#line 1090
    strm->adler = adler32(strm->adler, (Bytef const   *)buf, len);
    }
  }
#line 1097
  strm->next_in += len;
#line 1098
  strm->total_in += (uLong )len;
#line 1100
  return ((int )len);
}
}
#line 1106 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static void lm_init(deflate_state___0 *s ) 
{ 
  uInt tmp ;

  {
  {
#line 1109
  s->window_size = 2UL * (ulg )s->w_size;
#line 1111
  *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 1111
  memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
#line 1115
  s->max_lazy_match = (uInt )configuration_table[s->level].max_lazy;
#line 1116
  s->good_match = (uInt )configuration_table[s->level].good_length;
#line 1117
  s->nice_match = (int )configuration_table[s->level].nice_length;
#line 1118
  s->max_chain_length = (uInt )configuration_table[s->level].max_chain;
#line 1120
  s->strstart = (uInt )0;
#line 1121
  s->block_start = 0L;
#line 1122
  s->lookahead = (uInt )0;
#line 1123
  s->insert = (uInt )0;
#line 1124
  tmp = (uInt )2;
#line 1124
  s->prev_length = tmp;
#line 1124
  s->match_length = tmp;
#line 1125
  s->match_available = 0;
#line 1126
  s->ins_h = (uInt )0;
  }
#line 1132
  return;
}
}
#line 1148 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static uInt longest_match(deflate_state___0 *s , IPos cur_match ) 
{ 
  unsigned int chain_length ;
  register Bytef *scan ;
  register Bytef *match ;
  register int len ;
  int best_len ;
  int nice_match ;
  IPos limit ;
  uInt tmp ;
  Posf *prev ;
  uInt wmask ;
  register Bytef *strend ;
  register Byte scan_end1 ;
  register Byte scan_end ;

  {
#line 1152
  chain_length = s->max_chain_length;
#line 1153
  scan = s->window + s->strstart;
#line 1156
  best_len = (int )s->prev_length;
#line 1157
  nice_match = s->nice_match;
#line 1158
  if (s->strstart > s->w_size - 262U) {
#line 1158
    tmp = s->strstart - (s->w_size - 262U);
  } else {
#line 1158
    tmp = (uInt )0;
  }
#line 1158
  limit = tmp;
#line 1163
  prev = s->prev;
#line 1164
  wmask = s->w_mask;
#line 1174
  strend = (s->window + s->strstart) + 258;
#line 1175
  scan_end1 = *(scan + (best_len - 1));
#line 1176
  scan_end = *(scan + best_len);
#line 1185
  if (s->prev_length >= s->good_match) {
#line 1186
    chain_length >>= 2;
  }
#line 1191
  if ((uInt )nice_match > s->lookahead) {
#line 1191
    nice_match = (int )s->lookahead;
  }
  {
#line 1195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1197
    match = s->window + cur_match;
#line 1242
    if ((int )*(match + best_len) != (int )scan_end) {
#line 1245
      goto __Cont;
    } else
#line 1242
    if ((int )*(match + (best_len - 1)) != (int )scan_end1) {
#line 1245
      goto __Cont;
    } else
#line 1242
    if ((int )*match != (int )*scan) {
#line 1245
      goto __Cont;
    } else {
#line 1242
      match ++;
#line 1242
      if ((int )*match != (int )*(scan + 1)) {
#line 1245
        goto __Cont;
      }
    }
#line 1253
    scan += 2;
#line 1253
    match ++;
    {
#line 1259
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1259
      scan ++;
#line 1259
      match ++;
#line 1259
      if ((int )*scan == (int )*match) {
#line 1259
        scan ++;
#line 1259
        match ++;
#line 1259
        if ((int )*scan == (int )*match) {
#line 1259
          scan ++;
#line 1259
          match ++;
#line 1259
          if ((int )*scan == (int )*match) {
#line 1259
            scan ++;
#line 1259
            match ++;
#line 1259
            if ((int )*scan == (int )*match) {
#line 1259
              scan ++;
#line 1259
              match ++;
#line 1259
              if ((int )*scan == (int )*match) {
#line 1259
                scan ++;
#line 1259
                match ++;
#line 1259
                if ((int )*scan == (int )*match) {
#line 1259
                  scan ++;
#line 1259
                  match ++;
#line 1259
                  if ((int )*scan == (int )*match) {
#line 1259
                    scan ++;
#line 1259
                    match ++;
#line 1259
                    if ((int )*scan == (int )*match) {
#line 1259
                      if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 1259
                        goto while_break___0;
                      }
                    } else {
#line 1259
                      goto while_break___0;
                    }
                  } else {
#line 1259
                    goto while_break___0;
                  }
                } else {
#line 1259
                  goto while_break___0;
                }
              } else {
#line 1259
                goto while_break___0;
              }
            } else {
#line 1259
              goto while_break___0;
            }
          } else {
#line 1259
            goto while_break___0;
          }
        } else {
#line 1259
          goto while_break___0;
        }
      } else {
#line 1259
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1268
    len = 258 - (int )(strend - scan);
#line 1269
    scan = strend - 258;
#line 1273
    if (len > best_len) {
#line 1274
      s->match_start = cur_match;
#line 1275
      best_len = len;
#line 1276
      if (len >= nice_match) {
#line 1276
        goto while_break;
      }
#line 1280
      scan_end1 = *(scan + (best_len - 1));
#line 1281
      scan_end = *(scan + best_len);
    }
    __Cont: /* CIL Label */ 
#line 1195
    cur_match = (IPos )*(prev + (cur_match & wmask));
#line 1195
    if (cur_match > limit) {
#line 1195
      chain_length --;
#line 1195
      if (! (chain_length != 0U)) {
#line 1195
        goto while_break;
      }
    } else {
#line 1195
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1287
  if ((uInt )best_len <= s->lookahead) {
#line 1287
    return ((uInt )best_len);
  }
#line 1288
  return (s->lookahead);
}
}
#line 1390 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static void fill_window(deflate_state___0 *s ) 
{ 
  register unsigned int n ;
  register unsigned int m ;
  register Posf *p ;
  unsigned int more ;
  uInt wsize ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  uInt str ;
  ulg curr ;
  ulg init ;

  {
#line 1396
  wsize = s->w_size;
  {
#line 1400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    more = (unsigned int )((s->window_size - (ulg )s->lookahead) - (ulg )s->strstart);
#line 1404
    if (sizeof(int ) <= 2UL) {
#line 1405
      if (more == 0U) {
#line 1405
        if (s->strstart == 0U) {
#line 1405
          if (s->lookahead == 0U) {
#line 1406
            more = wsize;
          } else {
#line 1405
            goto _L___0;
          }
        } else {
#line 1405
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1408
      if (more == 4294967295U) {
#line 1412
        more --;
      }
    }
#line 1419
    if (s->strstart >= wsize + (s->w_size - 262U)) {
      {
#line 1421
      memcpy((void */* __restrict  */)s->window, (void const   */* __restrict  */)(s->window + wsize),
             (size_t )wsize);
#line 1422
      s->match_start -= wsize;
#line 1423
      s->strstart -= wsize;
#line 1424
      s->block_start -= (long )wsize;
#line 1432
      n = s->hash_size;
#line 1433
      p = s->head + n;
      }
      {
#line 1434
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1435
        p --;
#line 1435
        m = (unsigned int )*p;
#line 1436
        if (m >= wsize) {
#line 1436
          tmp = m - wsize;
        } else {
#line 1436
          tmp = 0U;
        }
#line 1436
        *p = (Pos )tmp;
#line 1434
        n --;
#line 1434
        if (! n) {
#line 1434
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1439
      n = wsize;
#line 1441
      p = s->prev + n;
      {
#line 1442
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1443
        p --;
#line 1443
        m = (unsigned int )*p;
#line 1444
        if (m >= wsize) {
#line 1444
          tmp___0 = m - wsize;
        } else {
#line 1444
          tmp___0 = 0U;
        }
#line 1444
        *p = (Pos )tmp___0;
#line 1442
        n --;
#line 1442
        if (! n) {
#line 1442
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1450
      more += wsize;
    }
#line 1452
    if ((s->strm)->avail_in == 0U) {
#line 1452
      goto while_break;
    }
    {
#line 1467
    tmp___1 = read_buf(s->strm, (s->window + s->strstart) + s->lookahead, more);
#line 1467
    n = (unsigned int )tmp___1;
#line 1468
    s->lookahead += n;
    }
#line 1471
    if (s->lookahead + s->insert >= 3U) {
#line 1472
      str = s->strstart - s->insert;
#line 1473
      s->ins_h = (uInt )*(s->window + str);
#line 1474
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (str + 1U))) & s->hash_mask;
      {
#line 1478
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1478
        if (! s->insert) {
#line 1478
          goto while_break___2;
        }
#line 1479
        s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + ((str + 3U) - 1U))) & s->hash_mask;
#line 1481
        *(s->prev + (str & s->w_mask)) = *(s->head + s->ins_h);
#line 1483
        *(s->head + s->ins_h) = (Pos )str;
#line 1484
        str ++;
#line 1485
        (s->insert) --;
#line 1486
        if (s->lookahead + s->insert < 3U) {
#line 1487
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1400
    if (s->lookahead < 262U) {
#line 1400
      if (! ((s->strm)->avail_in != 0U)) {
#line 1400
        goto while_break;
      }
    } else {
#line 1400
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1503
  if (s->high_water < s->window_size) {
#line 1504
    curr = (ulg )s->strstart + (ulg )s->lookahead;
#line 1507
    if (s->high_water < curr) {
#line 1511
      init = s->window_size - curr;
#line 1512
      if (init > 258UL) {
#line 1513
        init = (ulg )258;
      }
      {
#line 1514
      memset((void *)(s->window + curr), 0, (size_t )((unsigned int )init));
#line 1515
      s->high_water = curr + init;
      }
    } else
#line 1517
    if (s->high_water < curr + 258UL) {
#line 1522
      init = (curr + 258UL) - s->high_water;
#line 1523
      if (init > s->window_size - s->high_water) {
#line 1524
        init = s->window_size - s->high_water;
      }
      {
#line 1525
      memset((void *)(s->window + s->high_water), 0, (size_t )((unsigned int )init));
#line 1526
      s->high_water += init;
      }
    }
  }
#line 1532
  return;
}
}
#line 1564 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static block_state deflate_stored(deflate_state___0 *s , int flush ) 
{ 
  ulg max_block_size ;
  ulg max_start ;
  charf *tmp ;
  charf *tmp___0 ;
  charf *tmp___1 ;
  charf *tmp___2 ;

  {
#line 1571
  max_block_size = (ulg )65535;
#line 1574
  if (max_block_size > s->pending_buf_size - 5UL) {
#line 1575
    max_block_size = s->pending_buf_size - 5UL;
  }
  {
#line 1579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1581
    if (s->lookahead <= 1U) {
      {
#line 1586
      fill_window(s);
      }
#line 1587
      if (s->lookahead == 0U) {
#line 1587
        if (flush == 0) {
#line 1587
          return ((block_state )0);
        }
      }
#line 1589
      if (s->lookahead == 0U) {
#line 1589
        goto while_break;
      }
    }
#line 1593
    s->strstart += s->lookahead;
#line 1594
    s->lookahead = (uInt )0;
#line 1597
    max_start = (ulg )s->block_start + max_block_size;
#line 1598
    if (s->strstart == 0U) {
#line 1598
      goto _L;
    } else
#line 1598
    if ((ulg )s->strstart >= max_start) {
      _L: /* CIL Label */ 
#line 1600
      s->lookahead = (uInt )((ulg )s->strstart - max_start);
#line 1601
      s->strstart = (uInt )max_start;
#line 1602
      if (s->block_start >= 0L) {
#line 1602
        tmp = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1602
        tmp = (charf *)0;
      }
      {
#line 1602
      _tr_flush_block(s, tmp, (ulg )((long )s->strstart - s->block_start), 0);
#line 1602
      s->block_start = (long )s->strstart;
#line 1602
      flush_pending(s->strm);
      }
#line 1602
      if ((s->strm)->avail_out == 0U) {
#line 1602
        return ((block_state )0);
      }
    }
#line 1607
    if (s->strstart - (uInt )s->block_start >= s->w_size - 262U) {
#line 1608
      if (s->block_start >= 0L) {
#line 1608
        tmp___0 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1608
        tmp___0 = (charf *)0;
      }
      {
#line 1608
      _tr_flush_block(s, tmp___0, (ulg )((long )s->strstart - s->block_start), 0);
#line 1608
      s->block_start = (long )s->strstart;
#line 1608
      flush_pending(s->strm);
      }
#line 1608
      if ((s->strm)->avail_out == 0U) {
#line 1608
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1611
  s->insert = (uInt )0;
#line 1612
  if (flush == 4) {
#line 1613
    if (s->block_start >= 0L) {
#line 1613
      tmp___1 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1613
      tmp___1 = (charf *)0;
    }
    {
#line 1613
    _tr_flush_block(s, tmp___1, (ulg )((long )s->strstart - s->block_start), 1);
#line 1613
    s->block_start = (long )s->strstart;
#line 1613
    flush_pending(s->strm);
    }
#line 1613
    if ((s->strm)->avail_out == 0U) {
#line 1613
      return ((block_state )2);
    }
#line 1614
    return ((block_state )3);
  }
#line 1616
  if ((long )s->strstart > s->block_start) {
#line 1617
    if (s->block_start >= 0L) {
#line 1617
      tmp___2 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1617
      tmp___2 = (charf *)0;
    }
    {
#line 1617
    _tr_flush_block(s, tmp___2, (ulg )((long )s->strstart - s->block_start), 0);
#line 1617
    s->block_start = (long )s->strstart;
#line 1617
    flush_pending(s->strm);
    }
#line 1617
    if ((s->strm)->avail_out == 0U) {
#line 1617
      return ((block_state )0);
    }
  }
#line 1618
  return ((block_state )1);
}
}
#line 1628 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static block_state deflate_fast(deflate_state___0 *s , int flush ) 
{ 
  IPos hash_head ;
  int bflush ;
  Posf tmp ;
  uch len ;
  ush dist ;
  uInt tmp___0 ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  Posf tmp___2 ;
  uch cc ;
  uInt tmp___3 ;
  charf *tmp___4 ;
  charf *tmp___5 ;
  charf *tmp___6 ;

  {
  {
#line 1635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1641
    if (s->lookahead < 262U) {
      {
#line 1642
      fill_window(s);
      }
#line 1643
      if (s->lookahead < 262U) {
#line 1643
        if (flush == 0) {
#line 1644
          return ((block_state )0);
        }
      }
#line 1646
      if (s->lookahead == 0U) {
#line 1646
        goto while_break;
      }
    }
#line 1652
    hash_head = (IPos )0;
#line 1653
    if (s->lookahead >= 3U) {
#line 1654
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1654
      tmp = *(s->head + s->ins_h);
#line 1654
      *(s->prev + (s->strstart & s->w_mask)) = tmp;
#line 1654
      hash_head = (IPos )tmp;
#line 1654
      *(s->head + s->ins_h) = (Pos )s->strstart;
    }
#line 1660
    if (hash_head != 0U) {
#line 1660
      if (s->strstart - hash_head <= s->w_size - 262U) {
        {
#line 1665
        s->match_length = longest_match(s, hash_head);
        }
      }
    }
#line 1668
    if (s->match_length >= 3U) {
#line 1671
      len = (uch )(s->match_length - 3U);
#line 1671
      dist = (ush )(s->strstart - s->match_start);
#line 1671
      *(s->d_buf + s->last_lit) = dist;
#line 1671
      tmp___0 = s->last_lit;
#line 1671
      (s->last_lit) ++;
#line 1671
      *(s->l_buf + tmp___0) = len;
#line 1671
      dist = (ush )((int )dist - 1);
#line 1671
      s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 1671
      if ((int )dist < 256) {
#line 1671
        tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
      } else {
#line 1671
        tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256 + ((int )dist >> 7)];
      }
#line 1671
      s->dyn_dtree[tmp___1].fc.freq = (ush )((int )s->dyn_dtree[tmp___1].fc.freq + 1);
#line 1671
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1674
      s->lookahead -= s->match_length;
#line 1680
      if (s->match_length <= s->max_lazy_match) {
#line 1680
        if (s->lookahead >= 3U) {
#line 1682
          (s->match_length) --;
          {
#line 1683
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1684
            (s->strstart) ++;
#line 1685
            s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1685
            tmp___2 = *(s->head + s->ins_h);
#line 1685
            *(s->prev + (s->strstart & s->w_mask)) = tmp___2;
#line 1685
            hash_head = (IPos )tmp___2;
#line 1685
            *(s->head + s->ins_h) = (Pos )s->strstart;
#line 1683
            (s->match_length) --;
#line 1683
            if (! (s->match_length != 0U)) {
#line 1683
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1690
          (s->strstart) ++;
        } else {
#line 1694
          s->strstart += s->match_length;
#line 1695
          s->match_length = (uInt )0;
#line 1696
          s->ins_h = (uInt )*(s->window + s->strstart);
#line 1697
          s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 1U))) & s->hash_mask;
        }
      } else {
#line 1694
        s->strstart += s->match_length;
#line 1695
        s->match_length = (uInt )0;
#line 1696
        s->ins_h = (uInt )*(s->window + s->strstart);
#line 1697
        s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 1U))) & s->hash_mask;
      }
    } else {
#line 1708
      cc = *(s->window + s->strstart);
#line 1708
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 1708
      tmp___3 = s->last_lit;
#line 1708
      (s->last_lit) ++;
#line 1708
      *(s->l_buf + tmp___3) = cc;
#line 1708
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 1708
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1709
      (s->lookahead) --;
#line 1710
      (s->strstart) ++;
    }
#line 1712
    if (bflush) {
#line 1712
      if (s->block_start >= 0L) {
#line 1712
        tmp___4 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1712
        tmp___4 = (charf *)0;
      }
      {
#line 1712
      _tr_flush_block(s, tmp___4, (ulg )((long )s->strstart - s->block_start), 0);
#line 1712
      s->block_start = (long )s->strstart;
#line 1712
      flush_pending(s->strm);
      }
#line 1712
      if ((s->strm)->avail_out == 0U) {
#line 1712
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1714
  if (s->strstart < 2U) {
#line 1714
    s->insert = s->strstart;
  } else {
#line 1714
    s->insert = (uInt )2;
  }
#line 1715
  if (flush == 4) {
#line 1716
    if (s->block_start >= 0L) {
#line 1716
      tmp___5 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1716
      tmp___5 = (charf *)0;
    }
    {
#line 1716
    _tr_flush_block(s, tmp___5, (ulg )((long )s->strstart - s->block_start), 1);
#line 1716
    s->block_start = (long )s->strstart;
#line 1716
    flush_pending(s->strm);
    }
#line 1716
    if ((s->strm)->avail_out == 0U) {
#line 1716
      return ((block_state )2);
    }
#line 1717
    return ((block_state )3);
  }
#line 1719
  if (s->last_lit) {
#line 1720
    if (s->block_start >= 0L) {
#line 1720
      tmp___6 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1720
      tmp___6 = (charf *)0;
    }
    {
#line 1720
    _tr_flush_block(s, tmp___6, (ulg )((long )s->strstart - s->block_start), 0);
#line 1720
    s->block_start = (long )s->strstart;
#line 1720
    flush_pending(s->strm);
    }
#line 1720
    if ((s->strm)->avail_out == 0U) {
#line 1720
      return ((block_state )0);
    }
  }
#line 1721
  return ((block_state )1);
}
}
#line 1730 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static block_state deflate_slow(deflate_state___0 *s , int flush ) 
{ 
  IPos hash_head ;
  int bflush ;
  Posf tmp ;
  uInt max_insert ;
  uch len ;
  ush dist ;
  uInt tmp___0 ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  Posf tmp___2 ;
  charf *tmp___3 ;
  uch cc ;
  uInt tmp___4 ;
  charf *tmp___5 ;
  uch cc___0 ;
  uInt tmp___6 ;
  charf *tmp___7 ;
  charf *tmp___8 ;

  {
  {
#line 1738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1744
    if (s->lookahead < 262U) {
      {
#line 1745
      fill_window(s);
      }
#line 1746
      if (s->lookahead < 262U) {
#line 1746
        if (flush == 0) {
#line 1747
          return ((block_state )0);
        }
      }
#line 1749
      if (s->lookahead == 0U) {
#line 1749
        goto while_break;
      }
    }
#line 1755
    hash_head = (IPos )0;
#line 1756
    if (s->lookahead >= 3U) {
#line 1757
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1757
      tmp = *(s->head + s->ins_h);
#line 1757
      *(s->prev + (s->strstart & s->w_mask)) = tmp;
#line 1757
      hash_head = (IPos )tmp;
#line 1757
      *(s->head + s->ins_h) = (Pos )s->strstart;
    }
#line 1762
    s->prev_length = s->match_length;
#line 1762
    s->prev_match = s->match_start;
#line 1763
    s->match_length = (uInt )2;
#line 1765
    if (hash_head != 0U) {
#line 1765
      if (s->prev_length < s->max_lazy_match) {
#line 1765
        if (s->strstart - hash_head <= s->w_size - 262U) {
          {
#line 1771
          s->match_length = longest_match(s, hash_head);
          }
#line 1774
          if (s->match_length <= 5U) {
#line 1774
            if (s->strategy == 1) {
#line 1784
              s->match_length = (uInt )2;
            }
          }
        }
      }
    }
#line 1790
    if (s->prev_length >= 3U) {
#line 1790
      if (s->match_length <= s->prev_length) {
#line 1791
        max_insert = (s->strstart + s->lookahead) - 3U;
#line 1796
        len = (uch )(s->prev_length - 3U);
#line 1796
        dist = (ush )((s->strstart - 1U) - s->prev_match);
#line 1796
        *(s->d_buf + s->last_lit) = dist;
#line 1796
        tmp___0 = s->last_lit;
#line 1796
        (s->last_lit) ++;
#line 1796
        *(s->l_buf + tmp___0) = len;
#line 1796
        dist = (ush )((int )dist - 1);
#line 1796
        s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 1796
        if ((int )dist < 256) {
#line 1796
          tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
        } else {
#line 1796
          tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256 + ((int )dist >> 7)];
        }
#line 1796
        s->dyn_dtree[tmp___1].fc.freq = (ush )((int )s->dyn_dtree[tmp___1].fc.freq + 1);
#line 1796
        bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1804
        s->lookahead -= s->prev_length - 1U;
#line 1805
        s->prev_length -= 2U;
        {
#line 1806
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1807
          (s->strstart) ++;
#line 1807
          if (s->strstart <= max_insert) {
#line 1808
            s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1808
            tmp___2 = *(s->head + s->ins_h);
#line 1808
            *(s->prev + (s->strstart & s->w_mask)) = tmp___2;
#line 1808
            hash_head = (IPos )tmp___2;
#line 1808
            *(s->head + s->ins_h) = (Pos )s->strstart;
          }
#line 1806
          (s->prev_length) --;
#line 1806
          if (! (s->prev_length != 0U)) {
#line 1806
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1811
        s->match_available = 0;
#line 1812
        s->match_length = (uInt )2;
#line 1813
        (s->strstart) ++;
#line 1815
        if (bflush) {
#line 1815
          if (s->block_start >= 0L) {
#line 1815
            tmp___3 = (charf *)(s->window + (unsigned int )s->block_start);
          } else {
#line 1815
            tmp___3 = (charf *)0;
          }
          {
#line 1815
          _tr_flush_block(s, tmp___3, (ulg )((long )s->strstart - s->block_start),
                          0);
#line 1815
          s->block_start = (long )s->strstart;
#line 1815
          flush_pending(s->strm);
          }
#line 1815
          if ((s->strm)->avail_out == 0U) {
#line 1815
            return ((block_state )0);
          }
        }
      } else {
#line 1790
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1817
    if (s->match_available) {
#line 1823
      cc = *(s->window + (s->strstart - 1U));
#line 1823
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 1823
      tmp___4 = s->last_lit;
#line 1823
      (s->last_lit) ++;
#line 1823
      *(s->l_buf + tmp___4) = cc;
#line 1823
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 1823
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1824
      if (bflush) {
#line 1825
        if (s->block_start >= 0L) {
#line 1825
          tmp___5 = (charf *)(s->window + (unsigned int )s->block_start);
        } else {
#line 1825
          tmp___5 = (charf *)0;
        }
        {
#line 1825
        _tr_flush_block(s, tmp___5, (ulg )((long )s->strstart - s->block_start), 0);
#line 1825
        s->block_start = (long )s->strstart;
#line 1825
        flush_pending(s->strm);
        }
      }
#line 1827
      (s->strstart) ++;
#line 1828
      (s->lookahead) --;
#line 1829
      if ((s->strm)->avail_out == 0U) {
#line 1829
        return ((block_state )0);
      }
    } else {
#line 1834
      s->match_available = 1;
#line 1835
      (s->strstart) ++;
#line 1836
      (s->lookahead) --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1840
  if (s->match_available) {
#line 1842
    cc___0 = *(s->window + (s->strstart - 1U));
#line 1842
    *(s->d_buf + s->last_lit) = (ushf )0;
#line 1842
    tmp___6 = s->last_lit;
#line 1842
    (s->last_lit) ++;
#line 1842
    *(s->l_buf + tmp___6) = cc___0;
#line 1842
    s->dyn_ltree[cc___0].fc.freq = (ush )((int )s->dyn_ltree[cc___0].fc.freq + 1);
#line 1842
    bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1843
    s->match_available = 0;
  }
#line 1845
  if (s->strstart < 2U) {
#line 1845
    s->insert = s->strstart;
  } else {
#line 1845
    s->insert = (uInt )2;
  }
#line 1846
  if (flush == 4) {
#line 1847
    if (s->block_start >= 0L) {
#line 1847
      tmp___7 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1847
      tmp___7 = (charf *)0;
    }
    {
#line 1847
    _tr_flush_block(s, tmp___7, (ulg )((long )s->strstart - s->block_start), 1);
#line 1847
    s->block_start = (long )s->strstart;
#line 1847
    flush_pending(s->strm);
    }
#line 1847
    if ((s->strm)->avail_out == 0U) {
#line 1847
      return ((block_state )2);
    }
#line 1848
    return ((block_state )3);
  }
#line 1850
  if (s->last_lit) {
#line 1851
    if (s->block_start >= 0L) {
#line 1851
      tmp___8 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1851
      tmp___8 = (charf *)0;
    }
    {
#line 1851
    _tr_flush_block(s, tmp___8, (ulg )((long )s->strstart - s->block_start), 0);
#line 1851
    s->block_start = (long )s->strstart;
#line 1851
    flush_pending(s->strm);
    }
#line 1851
    if ((s->strm)->avail_out == 0U) {
#line 1851
      return ((block_state )0);
    }
  }
#line 1852
  return ((block_state )1);
}
}
#line 1861 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static block_state deflate_rle(deflate_state___0 *s , int flush ) 
{ 
  int bflush ;
  uInt prev ;
  Bytef *scan ;
  Bytef *strend ;
  uch len ;
  ush dist ;
  uInt tmp ;
  int __attribute__((__visibility__("hidden")))  tmp___0 ;
  uch cc ;
  uInt tmp___1 ;
  charf *tmp___2 ;
  charf *tmp___3 ;
  charf *tmp___4 ;

  {
  {
#line 1869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1874
    if (s->lookahead <= 258U) {
      {
#line 1875
      fill_window(s);
      }
#line 1876
      if (s->lookahead <= 258U) {
#line 1876
        if (flush == 0) {
#line 1877
          return ((block_state )0);
        }
      }
#line 1879
      if (s->lookahead == 0U) {
#line 1879
        goto while_break;
      }
    }
#line 1883
    s->match_length = (uInt )0;
#line 1884
    if (s->lookahead >= 3U) {
#line 1884
      if (s->strstart > 0U) {
#line 1885
        scan = (s->window + s->strstart) - 1;
#line 1886
        prev = (uInt )*scan;
#line 1887
        scan ++;
#line 1887
        if (prev == (uInt )*scan) {
#line 1887
          scan ++;
#line 1887
          if (prev == (uInt )*scan) {
#line 1887
            scan ++;
#line 1887
            if (prev == (uInt )*scan) {
#line 1888
              strend = (s->window + s->strstart) + 258;
              {
#line 1889
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 1889
                scan ++;
#line 1889
                if (prev == (uInt )*scan) {
#line 1889
                  scan ++;
#line 1889
                  if (prev == (uInt )*scan) {
#line 1889
                    scan ++;
#line 1889
                    if (prev == (uInt )*scan) {
#line 1889
                      scan ++;
#line 1889
                      if (prev == (uInt )*scan) {
#line 1889
                        scan ++;
#line 1889
                        if (prev == (uInt )*scan) {
#line 1889
                          scan ++;
#line 1889
                          if (prev == (uInt )*scan) {
#line 1889
                            scan ++;
#line 1889
                            if (prev == (uInt )*scan) {
#line 1889
                              scan ++;
#line 1889
                              if (prev == (uInt )*scan) {
#line 1889
                                if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 1889
                                  goto while_break___0;
                                }
                              } else {
#line 1889
                                goto while_break___0;
                              }
                            } else {
#line 1889
                              goto while_break___0;
                            }
                          } else {
#line 1889
                            goto while_break___0;
                          }
                        } else {
#line 1889
                          goto while_break___0;
                        }
                      } else {
#line 1889
                        goto while_break___0;
                      }
                    } else {
#line 1889
                      goto while_break___0;
                    }
                  } else {
#line 1889
                    goto while_break___0;
                  }
                } else {
#line 1889
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 1895
              s->match_length = (uInt )(258 - (int )(strend - scan));
#line 1896
              if (s->match_length > s->lookahead) {
#line 1897
                s->match_length = s->lookahead;
              }
            }
          }
        }
      }
    }
#line 1903
    if (s->match_length >= 3U) {
#line 1906
      len = (uch )(s->match_length - 3U);
#line 1906
      dist = (ush )1;
#line 1906
      *(s->d_buf + s->last_lit) = dist;
#line 1906
      tmp = s->last_lit;
#line 1906
      (s->last_lit) ++;
#line 1906
      *(s->l_buf + tmp) = len;
#line 1906
      dist = (ush )((int )dist - 1);
#line 1906
      s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 1906
      if ((int )dist < 256) {
#line 1906
        tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
      } else {
#line 1906
        tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256 + ((int )dist >> 7)];
      }
#line 1906
      s->dyn_dtree[tmp___0].fc.freq = (ush )((int )s->dyn_dtree[tmp___0].fc.freq + 1);
#line 1906
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1908
      s->lookahead -= s->match_length;
#line 1909
      s->strstart += s->match_length;
#line 1910
      s->match_length = (uInt )0;
    } else {
#line 1914
      cc = *(s->window + s->strstart);
#line 1914
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 1914
      tmp___1 = s->last_lit;
#line 1914
      (s->last_lit) ++;
#line 1914
      *(s->l_buf + tmp___1) = cc;
#line 1914
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 1914
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1915
      (s->lookahead) --;
#line 1916
      (s->strstart) ++;
    }
#line 1918
    if (bflush) {
#line 1918
      if (s->block_start >= 0L) {
#line 1918
        tmp___2 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1918
        tmp___2 = (charf *)0;
      }
      {
#line 1918
      _tr_flush_block(s, tmp___2, (ulg )((long )s->strstart - s->block_start), 0);
#line 1918
      s->block_start = (long )s->strstart;
#line 1918
      flush_pending(s->strm);
      }
#line 1918
      if ((s->strm)->avail_out == 0U) {
#line 1918
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1920
  s->insert = (uInt )0;
#line 1921
  if (flush == 4) {
#line 1922
    if (s->block_start >= 0L) {
#line 1922
      tmp___3 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1922
      tmp___3 = (charf *)0;
    }
    {
#line 1922
    _tr_flush_block(s, tmp___3, (ulg )((long )s->strstart - s->block_start), 1);
#line 1922
    s->block_start = (long )s->strstart;
#line 1922
    flush_pending(s->strm);
    }
#line 1922
    if ((s->strm)->avail_out == 0U) {
#line 1922
      return ((block_state )2);
    }
#line 1923
    return ((block_state )3);
  }
#line 1925
  if (s->last_lit) {
#line 1926
    if (s->block_start >= 0L) {
#line 1926
      tmp___4 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1926
      tmp___4 = (charf *)0;
    }
    {
#line 1926
    _tr_flush_block(s, tmp___4, (ulg )((long )s->strstart - s->block_start), 0);
#line 1926
    s->block_start = (long )s->strstart;
#line 1926
    flush_pending(s->strm);
    }
#line 1926
    if ((s->strm)->avail_out == 0U) {
#line 1926
      return ((block_state )0);
    }
  }
#line 1927
  return ((block_state )1);
}
}
#line 1934 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/deflate.c"
static block_state deflate_huff(deflate_state___0 *s , int flush ) 
{ 
  int bflush ;
  uch cc ;
  uInt tmp ;
  charf *tmp___0 ;
  charf *tmp___1 ;
  charf *tmp___2 ;

  {
  {
#line 1940
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1942
    if (s->lookahead == 0U) {
      {
#line 1943
      fill_window(s);
      }
#line 1944
      if (s->lookahead == 0U) {
#line 1945
        if (flush == 0) {
#line 1946
          return ((block_state )0);
        }
#line 1947
        goto while_break;
      }
    }
#line 1952
    s->match_length = (uInt )0;
#line 1954
    cc = *(s->window + s->strstart);
#line 1954
    *(s->d_buf + s->last_lit) = (ushf )0;
#line 1954
    tmp = s->last_lit;
#line 1954
    (s->last_lit) ++;
#line 1954
    *(s->l_buf + tmp) = cc;
#line 1954
    s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 1954
    bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1955
    (s->lookahead) --;
#line 1956
    (s->strstart) ++;
#line 1957
    if (bflush) {
#line 1957
      if (s->block_start >= 0L) {
#line 1957
        tmp___0 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1957
        tmp___0 = (charf *)0;
      }
      {
#line 1957
      _tr_flush_block(s, tmp___0, (ulg )((long )s->strstart - s->block_start), 0);
#line 1957
      s->block_start = (long )s->strstart;
#line 1957
      flush_pending(s->strm);
      }
#line 1957
      if ((s->strm)->avail_out == 0U) {
#line 1957
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1959
  s->insert = (uInt )0;
#line 1960
  if (flush == 4) {
#line 1961
    if (s->block_start >= 0L) {
#line 1961
      tmp___1 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1961
      tmp___1 = (charf *)0;
    }
    {
#line 1961
    _tr_flush_block(s, tmp___1, (ulg )((long )s->strstart - s->block_start), 1);
#line 1961
    s->block_start = (long )s->strstart;
#line 1961
    flush_pending(s->strm);
    }
#line 1961
    if ((s->strm)->avail_out == 0U) {
#line 1961
      return ((block_state )2);
    }
#line 1962
    return ((block_state )3);
  }
#line 1964
  if (s->last_lit) {
#line 1965
    if (s->block_start >= 0L) {
#line 1965
      tmp___2 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1965
      tmp___2 = (charf *)0;
    }
    {
#line 1965
    _tr_flush_block(s, tmp___2, (ulg )((long )s->strstart - s->block_start), 0);
#line 1965
    s->block_start = (long )s->strstart;
#line 1965
    flush_pending(s->strm);
    }
#line 1965
    if ((s->strm)->avail_out == 0U) {
#line 1965
      return ((block_state )0);
    }
  }
#line 1966
  return ((block_state )1);
}
}
#line 1618 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
unsigned long crc32(unsigned long crc , unsigned char const   *buf , uInt len ) ;
#line 1715
uLong crc32_combine64(uLong crc1 , uLong crc2 , off64_t len2 ) ;
#line 1748
uLong crc32_combine(uLong crc1 , uLong crc2 , off_t len2 ) ;
#line 1766
z_crc_t const   *get_crc_table(void) ;
#line 40 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
static unsigned long crc32_little(unsigned long crc , unsigned char const   *buf ,
                                  unsigned int len ) ;
#line 42
static unsigned long crc32_big(unsigned long crc , unsigned char const   *buf , unsigned int len ) ;
#line 50
static unsigned long gf2_matrix_times(unsigned long *mat , unsigned long vec ) ;
#line 52
static void gf2_matrix_square(unsigned long *square , unsigned long *mat ) ;
#line 53
static uLong crc32_combine_(uLong crc1 , uLong crc2 , off64_t len2 ) ;
#line 5 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.h"
static z_crc_t const   crc_table[8][256]  = 
#line 5 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.h"
  { {        (z_crc_t const   )0UL,        (z_crc_t const   )1996959894UL,        (z_crc_t const   )3993919788UL,        (z_crc_t const   )2567524794UL, 
            (z_crc_t const   )124634137UL,        (z_crc_t const   )1886057615UL,        (z_crc_t const   )3915621685UL,        (z_crc_t const   )2657392035UL, 
            (z_crc_t const   )249268274UL,        (z_crc_t const   )2044508324UL,        (z_crc_t const   )3772115230UL,        (z_crc_t const   )2547177864UL, 
            (z_crc_t const   )162941995UL,        (z_crc_t const   )2125561021UL,        (z_crc_t const   )3887607047UL,        (z_crc_t const   )2428444049UL, 
            (z_crc_t const   )498536548UL,        (z_crc_t const   )1789927666UL,        (z_crc_t const   )4089016648UL,        (z_crc_t const   )2227061214UL, 
            (z_crc_t const   )450548861UL,        (z_crc_t const   )1843258603UL,        (z_crc_t const   )4107580753UL,        (z_crc_t const   )2211677639UL, 
            (z_crc_t const   )325883990UL,        (z_crc_t const   )1684777152UL,        (z_crc_t const   )4251122042UL,        (z_crc_t const   )2321926636UL, 
            (z_crc_t const   )335633487UL,        (z_crc_t const   )1661365465UL,        (z_crc_t const   )4195302755UL,        (z_crc_t const   )2366115317UL, 
            (z_crc_t const   )997073096UL,        (z_crc_t const   )1281953886UL,        (z_crc_t const   )3579855332UL,        (z_crc_t const   )2724688242UL, 
            (z_crc_t const   )1006888145UL,        (z_crc_t const   )1258607687UL,        (z_crc_t const   )3524101629UL,        (z_crc_t const   )2768942443UL, 
            (z_crc_t const   )901097722UL,        (z_crc_t const   )1119000684UL,        (z_crc_t const   )3686517206UL,        (z_crc_t const   )2898065728UL, 
            (z_crc_t const   )853044451UL,        (z_crc_t const   )1172266101UL,        (z_crc_t const   )3705015759UL,        (z_crc_t const   )2882616665UL, 
            (z_crc_t const   )651767980UL,        (z_crc_t const   )1373503546UL,        (z_crc_t const   )3369554304UL,        (z_crc_t const   )3218104598UL, 
            (z_crc_t const   )565507253UL,        (z_crc_t const   )1454621731UL,        (z_crc_t const   )3485111705UL,        (z_crc_t const   )3099436303UL, 
            (z_crc_t const   )671266974UL,        (z_crc_t const   )1594198024UL,        (z_crc_t const   )3322730930UL,        (z_crc_t const   )2970347812UL, 
            (z_crc_t const   )795835527UL,        (z_crc_t const   )1483230225UL,        (z_crc_t const   )3244367275UL,        (z_crc_t const   )3060149565UL, 
            (z_crc_t const   )1994146192UL,        (z_crc_t const   )31158534UL,        (z_crc_t const   )2563907772UL,        (z_crc_t const   )4023717930UL, 
            (z_crc_t const   )1907459465UL,        (z_crc_t const   )112637215UL,        (z_crc_t const   )2680153253UL,        (z_crc_t const   )3904427059UL, 
            (z_crc_t const   )2013776290UL,        (z_crc_t const   )251722036UL,        (z_crc_t const   )2517215374UL,        (z_crc_t const   )3775830040UL, 
            (z_crc_t const   )2137656763UL,        (z_crc_t const   )141376813UL,        (z_crc_t const   )2439277719UL,        (z_crc_t const   )3865271297UL, 
            (z_crc_t const   )1802195444UL,        (z_crc_t const   )476864866UL,        (z_crc_t const   )2238001368UL,        (z_crc_t const   )4066508878UL, 
            (z_crc_t const   )1812370925UL,        (z_crc_t const   )453092731UL,        (z_crc_t const   )2181625025UL,        (z_crc_t const   )4111451223UL, 
            (z_crc_t const   )1706088902UL,        (z_crc_t const   )314042704UL,        (z_crc_t const   )2344532202UL,        (z_crc_t const   )4240017532UL, 
            (z_crc_t const   )1658658271UL,        (z_crc_t const   )366619977UL,        (z_crc_t const   )2362670323UL,        (z_crc_t const   )4224994405UL, 
            (z_crc_t const   )1303535960UL,        (z_crc_t const   )984961486UL,        (z_crc_t const   )2747007092UL,        (z_crc_t const   )3569037538UL, 
            (z_crc_t const   )1256170817UL,        (z_crc_t const   )1037604311UL,        (z_crc_t const   )2765210733UL,        (z_crc_t const   )3554079995UL, 
            (z_crc_t const   )1131014506UL,        (z_crc_t const   )879679996UL,        (z_crc_t const   )2909243462UL,        (z_crc_t const   )3663771856UL, 
            (z_crc_t const   )1141124467UL,        (z_crc_t const   )855842277UL,        (z_crc_t const   )2852801631UL,        (z_crc_t const   )3708648649UL, 
            (z_crc_t const   )1342533948UL,        (z_crc_t const   )654459306UL,        (z_crc_t const   )3188396048UL,        (z_crc_t const   )3373015174UL, 
            (z_crc_t const   )1466479909UL,        (z_crc_t const   )544179635UL,        (z_crc_t const   )3110523913UL,        (z_crc_t const   )3462522015UL, 
            (z_crc_t const   )1591671054UL,        (z_crc_t const   )702138776UL,        (z_crc_t const   )2966460450UL,        (z_crc_t const   )3352799412UL, 
            (z_crc_t const   )1504918807UL,        (z_crc_t const   )783551873UL,        (z_crc_t const   )3082640443UL,        (z_crc_t const   )3233442989UL, 
            (z_crc_t const   )3988292384UL,        (z_crc_t const   )2596254646UL,        (z_crc_t const   )62317068UL,        (z_crc_t const   )1957810842UL, 
            (z_crc_t const   )3939845945UL,        (z_crc_t const   )2647816111UL,        (z_crc_t const   )81470997UL,        (z_crc_t const   )1943803523UL, 
            (z_crc_t const   )3814918930UL,        (z_crc_t const   )2489596804UL,        (z_crc_t const   )225274430UL,        (z_crc_t const   )2053790376UL, 
            (z_crc_t const   )3826175755UL,        (z_crc_t const   )2466906013UL,        (z_crc_t const   )167816743UL,        (z_crc_t const   )2097651377UL, 
            (z_crc_t const   )4027552580UL,        (z_crc_t const   )2265490386UL,        (z_crc_t const   )503444072UL,        (z_crc_t const   )1762050814UL, 
            (z_crc_t const   )4150417245UL,        (z_crc_t const   )2154129355UL,        (z_crc_t const   )426522225UL,        (z_crc_t const   )1852507879UL, 
            (z_crc_t const   )4275313526UL,        (z_crc_t const   )2312317920UL,        (z_crc_t const   )282753626UL,        (z_crc_t const   )1742555852UL, 
            (z_crc_t const   )4189708143UL,        (z_crc_t const   )2394877945UL,        (z_crc_t const   )397917763UL,        (z_crc_t const   )1622183637UL, 
            (z_crc_t const   )3604390888UL,        (z_crc_t const   )2714866558UL,        (z_crc_t const   )953729732UL,        (z_crc_t const   )1340076626UL, 
            (z_crc_t const   )3518719985UL,        (z_crc_t const   )2797360999UL,        (z_crc_t const   )1068828381UL,        (z_crc_t const   )1219638859UL, 
            (z_crc_t const   )3624741850UL,        (z_crc_t const   )2936675148UL,        (z_crc_t const   )906185462UL,        (z_crc_t const   )1090812512UL, 
            (z_crc_t const   )3747672003UL,        (z_crc_t const   )2825379669UL,        (z_crc_t const   )829329135UL,        (z_crc_t const   )1181335161UL, 
            (z_crc_t const   )3412177804UL,        (z_crc_t const   )3160834842UL,        (z_crc_t const   )628085408UL,        (z_crc_t const   )1382605366UL, 
            (z_crc_t const   )3423369109UL,        (z_crc_t const   )3138078467UL,        (z_crc_t const   )570562233UL,        (z_crc_t const   )1426400815UL, 
            (z_crc_t const   )3317316542UL,        (z_crc_t const   )2998733608UL,        (z_crc_t const   )733239954UL,        (z_crc_t const   )1555261956UL, 
            (z_crc_t const   )3268935591UL,        (z_crc_t const   )3050360625UL,        (z_crc_t const   )752459403UL,        (z_crc_t const   )1541320221UL, 
            (z_crc_t const   )2607071920UL,        (z_crc_t const   )3965973030UL,        (z_crc_t const   )1969922972UL,        (z_crc_t const   )40735498UL, 
            (z_crc_t const   )2617837225UL,        (z_crc_t const   )3943577151UL,        (z_crc_t const   )1913087877UL,        (z_crc_t const   )83908371UL, 
            (z_crc_t const   )2512341634UL,        (z_crc_t const   )3803740692UL,        (z_crc_t const   )2075208622UL,        (z_crc_t const   )213261112UL, 
            (z_crc_t const   )2463272603UL,        (z_crc_t const   )3855990285UL,        (z_crc_t const   )2094854071UL,        (z_crc_t const   )198958881UL, 
            (z_crc_t const   )2262029012UL,        (z_crc_t const   )4057260610UL,        (z_crc_t const   )1759359992UL,        (z_crc_t const   )534414190UL, 
            (z_crc_t const   )2176718541UL,        (z_crc_t const   )4139329115UL,        (z_crc_t const   )1873836001UL,        (z_crc_t const   )414664567UL, 
            (z_crc_t const   )2282248934UL,        (z_crc_t const   )4279200368UL,        (z_crc_t const   )1711684554UL,        (z_crc_t const   )285281116UL, 
            (z_crc_t const   )2405801727UL,        (z_crc_t const   )4167216745UL,        (z_crc_t const   )1634467795UL,        (z_crc_t const   )376229701UL, 
            (z_crc_t const   )2685067896UL,        (z_crc_t const   )3608007406UL,        (z_crc_t const   )1308918612UL,        (z_crc_t const   )956543938UL, 
            (z_crc_t const   )2808555105UL,        (z_crc_t const   )3495958263UL,        (z_crc_t const   )1231636301UL,        (z_crc_t const   )1047427035UL, 
            (z_crc_t const   )2932959818UL,        (z_crc_t const   )3654703836UL,        (z_crc_t const   )1088359270UL,        (z_crc_t const   )936918000UL, 
            (z_crc_t const   )2847714899UL,        (z_crc_t const   )3736837829UL,        (z_crc_t const   )1202900863UL,        (z_crc_t const   )817233897UL, 
            (z_crc_t const   )3183342108UL,        (z_crc_t const   )3401237130UL,        (z_crc_t const   )1404277552UL,        (z_crc_t const   )615818150UL, 
            (z_crc_t const   )3134207493UL,        (z_crc_t const   )3453421203UL,        (z_crc_t const   )1423857449UL,        (z_crc_t const   )601450431UL, 
            (z_crc_t const   )3009837614UL,        (z_crc_t const   )3294710456UL,        (z_crc_t const   )1567103746UL,        (z_crc_t const   )711928724UL, 
            (z_crc_t const   )3020668471UL,        (z_crc_t const   )3272380065UL,        (z_crc_t const   )1510334235UL,        (z_crc_t const   )755167117UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )421212481UL,        (z_crc_t const   )842424962UL,        (z_crc_t const   )724390851UL, 
            (z_crc_t const   )1684849924UL,        (z_crc_t const   )2105013317UL,        (z_crc_t const   )1448781702UL,        (z_crc_t const   )1329698503UL, 
            (z_crc_t const   )3369699848UL,        (z_crc_t const   )3519200073UL,        (z_crc_t const   )4210026634UL,        (z_crc_t const   )3824474571UL, 
            (z_crc_t const   )2897563404UL,        (z_crc_t const   )3048111693UL,        (z_crc_t const   )2659397006UL,        (z_crc_t const   )2274893007UL, 
            (z_crc_t const   )1254232657UL,        (z_crc_t const   )1406739216UL,        (z_crc_t const   )2029285587UL,        (z_crc_t const   )1643069842UL, 
            (z_crc_t const   )783210325UL,        (z_crc_t const   )934667796UL,        (z_crc_t const   )479770071UL,        (z_crc_t const   )92505238UL, 
            (z_crc_t const   )2182846553UL,        (z_crc_t const   )2600511768UL,        (z_crc_t const   )2955803355UL,        (z_crc_t const   )2838940570UL, 
            (z_crc_t const   )3866582365UL,        (z_crc_t const   )4285295644UL,        (z_crc_t const   )3561045983UL,        (z_crc_t const   )3445231262UL, 
            (z_crc_t const   )2508465314UL,        (z_crc_t const   )2359236067UL,        (z_crc_t const   )2813478432UL,        (z_crc_t const   )3198777185UL, 
            (z_crc_t const   )4058571174UL,        (z_crc_t const   )3908292839UL,        (z_crc_t const   )3286139684UL,        (z_crc_t const   )3670389349UL, 
            (z_crc_t const   )1566420650UL,        (z_crc_t const   )1145479147UL,        (z_crc_t const   )1869335592UL,        (z_crc_t const   )1987116393UL, 
            (z_crc_t const   )959540142UL,        (z_crc_t const   )539646703UL,        (z_crc_t const   )185010476UL,        (z_crc_t const   )303839341UL, 
            (z_crc_t const   )3745920755UL,        (z_crc_t const   )3327985586UL,        (z_crc_t const   )3983561841UL,        (z_crc_t const   )4100678960UL, 
            (z_crc_t const   )3140154359UL,        (z_crc_t const   )2721170102UL,        (z_crc_t const   )2300350837UL,        (z_crc_t const   )2416418868UL, 
            (z_crc_t const   )396344571UL,        (z_crc_t const   )243568058UL,        (z_crc_t const   )631889529UL,        (z_crc_t const   )1018359608UL, 
            (z_crc_t const   )1945336319UL,        (z_crc_t const   )1793607870UL,        (z_crc_t const   )1103436669UL,        (z_crc_t const   )1490954812UL, 
            (z_crc_t const   )4034481925UL,        (z_crc_t const   )3915546180UL,        (z_crc_t const   )3259968903UL,        (z_crc_t const   )3679722694UL, 
            (z_crc_t const   )2484439553UL,        (z_crc_t const   )2366552896UL,        (z_crc_t const   )2787371139UL,        (z_crc_t const   )3208174018UL, 
            (z_crc_t const   )950060301UL,        (z_crc_t const   )565965900UL,        (z_crc_t const   )177645455UL,        (z_crc_t const   )328046286UL, 
            (z_crc_t const   )1556873225UL,        (z_crc_t const   )1171730760UL,        (z_crc_t const   )1861902987UL,        (z_crc_t const   )2011255754UL, 
            (z_crc_t const   )3132841300UL,        (z_crc_t const   )2745199637UL,        (z_crc_t const   )2290958294UL,        (z_crc_t const   )2442530455UL, 
            (z_crc_t const   )3738671184UL,        (z_crc_t const   )3352078609UL,        (z_crc_t const   )3974232786UL,        (z_crc_t const   )4126854035UL, 
            (z_crc_t const   )1919080284UL,        (z_crc_t const   )1803150877UL,        (z_crc_t const   )1079293406UL,        (z_crc_t const   )1498383519UL, 
            (z_crc_t const   )370020952UL,        (z_crc_t const   )253043481UL,        (z_crc_t const   )607678682UL,        (z_crc_t const   )1025720731UL, 
            (z_crc_t const   )1711106983UL,        (z_crc_t const   )2095471334UL,        (z_crc_t const   )1472923941UL,        (z_crc_t const   )1322268772UL, 
            (z_crc_t const   )26324643UL,        (z_crc_t const   )411738082UL,        (z_crc_t const   )866634785UL,        (z_crc_t const   )717028704UL, 
            (z_crc_t const   )2904875439UL,        (z_crc_t const   )3024081134UL,        (z_crc_t const   )2668790573UL,        (z_crc_t const   )2248782444UL, 
            (z_crc_t const   )3376948395UL,        (z_crc_t const   )3495106026UL,        (z_crc_t const   )4219356713UL,        (z_crc_t const   )3798300520UL, 
            (z_crc_t const   )792689142UL,        (z_crc_t const   )908347575UL,        (z_crc_t const   )487136116UL,        (z_crc_t const   )68299317UL, 
            (z_crc_t const   )1263779058UL,        (z_crc_t const   )1380486579UL,        (z_crc_t const   )2036719216UL,        (z_crc_t const   )1618931505UL, 
            (z_crc_t const   )3890672638UL,        (z_crc_t const   )4278043327UL,        (z_crc_t const   )3587215740UL,        (z_crc_t const   )3435896893UL, 
            (z_crc_t const   )2206873338UL,        (z_crc_t const   )2593195963UL,        (z_crc_t const   )2981909624UL,        (z_crc_t const   )2829542713UL, 
            (z_crc_t const   )998479947UL,        (z_crc_t const   )580430090UL,        (z_crc_t const   )162921161UL,        (z_crc_t const   )279890824UL, 
            (z_crc_t const   )1609522511UL,        (z_crc_t const   )1190423566UL,        (z_crc_t const   )1842954189UL,        (z_crc_t const   )1958874764UL, 
            (z_crc_t const   )4082766403UL,        (z_crc_t const   )3930137346UL,        (z_crc_t const   )3245109441UL,        (z_crc_t const   )3631694208UL, 
            (z_crc_t const   )2536953671UL,        (z_crc_t const   )2385372678UL,        (z_crc_t const   )2768287173UL,        (z_crc_t const   )3155920004UL, 
            (z_crc_t const   )1900120602UL,        (z_crc_t const   )1750776667UL,        (z_crc_t const   )1131931800UL,        (z_crc_t const   )1517083097UL, 
            (z_crc_t const   )355290910UL,        (z_crc_t const   )204897887UL,        (z_crc_t const   )656092572UL,        (z_crc_t const   )1040194781UL, 
            (z_crc_t const   )3113746450UL,        (z_crc_t const   )2692952403UL,        (z_crc_t const   )2343461520UL,        (z_crc_t const   )2461357009UL, 
            (z_crc_t const   )3723805974UL,        (z_crc_t const   )3304059991UL,        (z_crc_t const   )4022511508UL,        (z_crc_t const   )4141455061UL, 
            (z_crc_t const   )2919742697UL,        (z_crc_t const   )3072101800UL,        (z_crc_t const   )2620513899UL,        (z_crc_t const   )2234183466UL, 
            (z_crc_t const   )3396041197UL,        (z_crc_t const   )3547351212UL,        (z_crc_t const   )4166851439UL,        (z_crc_t const   )3779471918UL, 
            (z_crc_t const   )1725839073UL,        (z_crc_t const   )2143618976UL,        (z_crc_t const   )1424512099UL,        (z_crc_t const   )1307796770UL, 
            (z_crc_t const   )45282277UL,        (z_crc_t const   )464110244UL,        (z_crc_t const   )813994343UL,        (z_crc_t const   )698327078UL, 
            (z_crc_t const   )3838160568UL,        (z_crc_t const   )4259225593UL,        (z_crc_t const   )3606301754UL,        (z_crc_t const   )3488152955UL, 
            (z_crc_t const   )2158586812UL,        (z_crc_t const   )2578602749UL,        (z_crc_t const   )2996767038UL,        (z_crc_t const   )2877569151UL, 
            (z_crc_t const   )740041904UL,        (z_crc_t const   )889656817UL,        (z_crc_t const   )506086962UL,        (z_crc_t const   )120682355UL, 
            (z_crc_t const   )1215357364UL,        (z_crc_t const   )1366020341UL,        (z_crc_t const   )2051441462UL,        (z_crc_t const   )1667084919UL, 
            (z_crc_t const   )3422213966UL,        (z_crc_t const   )3538019855UL,        (z_crc_t const   )4190942668UL,        (z_crc_t const   )3772220557UL, 
            (z_crc_t const   )2945847882UL,        (z_crc_t const   )3062702859UL,        (z_crc_t const   )2644537544UL,        (z_crc_t const   )2226864521UL, 
            (z_crc_t const   )52649286UL,        (z_crc_t const   )439905287UL,        (z_crc_t const   )823476164UL,        (z_crc_t const   )672009861UL, 
            (z_crc_t const   )1733269570UL,        (z_crc_t const   )2119477507UL,        (z_crc_t const   )1434057408UL,        (z_crc_t const   )1281543041UL, 
            (z_crc_t const   )2167981343UL,        (z_crc_t const   )2552493150UL,        (z_crc_t const   )3004082077UL,        (z_crc_t const   )2853541596UL, 
            (z_crc_t const   )3847487515UL,        (z_crc_t const   )4233048410UL,        (z_crc_t const   )3613549209UL,        (z_crc_t const   )3464057816UL, 
            (z_crc_t const   )1239502615UL,        (z_crc_t const   )1358593622UL,        (z_crc_t const   )2077699477UL,        (z_crc_t const   )1657543892UL, 
            (z_crc_t const   )764250643UL,        (z_crc_t const   )882293586UL,        (z_crc_t const   )532408465UL,        (z_crc_t const   )111204816UL, 
            (z_crc_t const   )1585378284UL,        (z_crc_t const   )1197851309UL,        (z_crc_t const   )1816695150UL,        (z_crc_t const   )1968414767UL, 
            (z_crc_t const   )974272232UL,        (z_crc_t const   )587794345UL,        (z_crc_t const   )136598634UL,        (z_crc_t const   )289367339UL, 
            (z_crc_t const   )2527558116UL,        (z_crc_t const   )2411481253UL,        (z_crc_t const   )2760973158UL,        (z_crc_t const   )3179948583UL, 
            (z_crc_t const   )4073438432UL,        (z_crc_t const   )3956313505UL,        (z_crc_t const   )3237863010UL,        (z_crc_t const   )3655790371UL, 
            (z_crc_t const   )347922877UL,        (z_crc_t const   )229101820UL,        (z_crc_t const   )646611775UL,        (z_crc_t const   )1066513022UL, 
            (z_crc_t const   )1892689081UL,        (z_crc_t const   )1774917112UL,        (z_crc_t const   )1122387515UL,        (z_crc_t const   )1543337850UL, 
            (z_crc_t const   )3697634229UL,        (z_crc_t const   )3313392372UL,        (z_crc_t const   )3998419255UL,        (z_crc_t const   )4148705398UL, 
            (z_crc_t const   )3087642289UL,        (z_crc_t const   )2702352368UL,        (z_crc_t const   )2319436851UL,        (z_crc_t const   )2468674930UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )29518391UL,        (z_crc_t const   )59036782UL,        (z_crc_t const   )38190681UL, 
            (z_crc_t const   )118073564UL,        (z_crc_t const   )114017003UL,        (z_crc_t const   )76381362UL,        (z_crc_t const   )89069189UL, 
            (z_crc_t const   )236147128UL,        (z_crc_t const   )265370511UL,        (z_crc_t const   )228034006UL,        (z_crc_t const   )206958561UL, 
            (z_crc_t const   )152762724UL,        (z_crc_t const   )148411219UL,        (z_crc_t const   )178138378UL,        (z_crc_t const   )190596925UL, 
            (z_crc_t const   )472294256UL,        (z_crc_t const   )501532999UL,        (z_crc_t const   )530741022UL,        (z_crc_t const   )509615401UL, 
            (z_crc_t const   )456068012UL,        (z_crc_t const   )451764635UL,        (z_crc_t const   )413917122UL,        (z_crc_t const   )426358261UL, 
            (z_crc_t const   )305525448UL,        (z_crc_t const   )334993663UL,        (z_crc_t const   )296822438UL,        (z_crc_t const   )275991697UL, 
            (z_crc_t const   )356276756UL,        (z_crc_t const   )352202787UL,        (z_crc_t const   )381193850UL,        (z_crc_t const   )393929805UL, 
            (z_crc_t const   )944588512UL,        (z_crc_t const   )965684439UL,        (z_crc_t const   )1003065998UL,        (z_crc_t const   )973863097UL, 
            (z_crc_t const   )1061482044UL,        (z_crc_t const   )1049003019UL,        (z_crc_t const   )1019230802UL,        (z_crc_t const   )1023561829UL, 
            (z_crc_t const   )912136024UL,        (z_crc_t const   )933002607UL,        (z_crc_t const   )903529270UL,        (z_crc_t const   )874031361UL, 
            (z_crc_t const   )827834244UL,        (z_crc_t const   )815125939UL,        (z_crc_t const   )852716522UL,        (z_crc_t const   )856752605UL, 
            (z_crc_t const   )611050896UL,        (z_crc_t const   )631869351UL,        (z_crc_t const   )669987326UL,        (z_crc_t const   )640506825UL, 
            (z_crc_t const   )593644876UL,        (z_crc_t const   )580921211UL,        (z_crc_t const   )551983394UL,        (z_crc_t const   )556069653UL, 
            (z_crc_t const   )712553512UL,        (z_crc_t const   )733666847UL,        (z_crc_t const   )704405574UL,        (z_crc_t const   )675154545UL, 
            (z_crc_t const   )762387700UL,        (z_crc_t const   )749958851UL,        (z_crc_t const   )787859610UL,        (z_crc_t const   )792175277UL, 
            (z_crc_t const   )1889177024UL,        (z_crc_t const   )1901651959UL,        (z_crc_t const   )1931368878UL,        (z_crc_t const   )1927033753UL, 
            (z_crc_t const   )2006131996UL,        (z_crc_t const   )1985040171UL,        (z_crc_t const   )1947726194UL,        (z_crc_t const   )1976933189UL, 
            (z_crc_t const   )2122964088UL,        (z_crc_t const   )2135668303UL,        (z_crc_t const   )2098006038UL,        (z_crc_t const   )2093965857UL, 
            (z_crc_t const   )2038461604UL,        (z_crc_t const   )2017599123UL,        (z_crc_t const   )2047123658UL,        (z_crc_t const   )2076625661UL, 
            (z_crc_t const   )1824272048UL,        (z_crc_t const   )1836991623UL,        (z_crc_t const   )1866005214UL,        (z_crc_t const   )1861914857UL, 
            (z_crc_t const   )1807058540UL,        (z_crc_t const   )1786244187UL,        (z_crc_t const   )1748062722UL,        (z_crc_t const   )1777547317UL, 
            (z_crc_t const   )1655668488UL,        (z_crc_t const   )1668093247UL,        (z_crc_t const   )1630251878UL,        (z_crc_t const   )1625932113UL, 
            (z_crc_t const   )1705433044UL,        (z_crc_t const   )1684323811UL,        (z_crc_t const   )1713505210UL,        (z_crc_t const   )1742760333UL, 
            (z_crc_t const   )1222101792UL,        (z_crc_t const   )1226154263UL,        (z_crc_t const   )1263738702UL,        (z_crc_t const   )1251046777UL, 
            (z_crc_t const   )1339974652UL,        (z_crc_t const   )1310460363UL,        (z_crc_t const   )1281013650UL,        (z_crc_t const   )1301863845UL, 
            (z_crc_t const   )1187289752UL,        (z_crc_t const   )1191637167UL,        (z_crc_t const   )1161842422UL,        (z_crc_t const   )1149379777UL, 
            (z_crc_t const   )1103966788UL,        (z_crc_t const   )1074747507UL,        (z_crc_t const   )1112139306UL,        (z_crc_t const   )1133218845UL, 
            (z_crc_t const   )1425107024UL,        (z_crc_t const   )1429406311UL,        (z_crc_t const   )1467333694UL,        (z_crc_t const   )1454888457UL, 
            (z_crc_t const   )1408811148UL,        (z_crc_t const   )1379576507UL,        (z_crc_t const   )1350309090UL,        (z_crc_t const   )1371438805UL, 
            (z_crc_t const   )1524775400UL,        (z_crc_t const   )1528845279UL,        (z_crc_t const   )1499917702UL,        (z_crc_t const   )1487177649UL, 
            (z_crc_t const   )1575719220UL,        (z_crc_t const   )1546255107UL,        (z_crc_t const   )1584350554UL,        (z_crc_t const   )1605185389UL, 
            (z_crc_t const   )3778354048UL,        (z_crc_t const   )3774312887UL,        (z_crc_t const   )3803303918UL,        (z_crc_t const   )3816007129UL, 
            (z_crc_t const   )3862737756UL,        (z_crc_t const   )3892238699UL,        (z_crc_t const   )3854067506UL,        (z_crc_t const   )3833203973UL, 
            (z_crc_t const   )4012263992UL,        (z_crc_t const   )4007927823UL,        (z_crc_t const   )3970080342UL,        (z_crc_t const   )3982554209UL, 
            (z_crc_t const   )3895452388UL,        (z_crc_t const   )3924658387UL,        (z_crc_t const   )3953866378UL,        (z_crc_t const   )3932773565UL, 
            (z_crc_t const   )4245928176UL,        (z_crc_t const   )4241609415UL,        (z_crc_t const   )4271336606UL,        (z_crc_t const   )4283762345UL, 
            (z_crc_t const   )4196012076UL,        (z_crc_t const   )4225268251UL,        (z_crc_t const   )4187931714UL,        (z_crc_t const   )4166823541UL, 
            (z_crc_t const   )4076923208UL,        (z_crc_t const   )4072833919UL,        (z_crc_t const   )4035198246UL,        (z_crc_t const   )4047918865UL, 
            (z_crc_t const   )4094247316UL,        (z_crc_t const   )4123732899UL,        (z_crc_t const   )4153251322UL,        (z_crc_t const   )4132437965UL, 
            (z_crc_t const   )3648544096UL,        (z_crc_t const   )3636082519UL,        (z_crc_t const   )3673983246UL,        (z_crc_t const   )3678331705UL, 
            (z_crc_t const   )3732010428UL,        (z_crc_t const   )3753090955UL,        (z_crc_t const   )3723829714UL,        (z_crc_t const   )3694611429UL, 
            (z_crc_t const   )3614117080UL,        (z_crc_t const   )3601426159UL,        (z_crc_t const   )3572488374UL,        (z_crc_t const   )3576541825UL, 
            (z_crc_t const   )3496125444UL,        (z_crc_t const   )3516976691UL,        (z_crc_t const   )3555094634UL,        (z_crc_t const   )3525581405UL, 
            (z_crc_t const   )3311336976UL,        (z_crc_t const   )3298595879UL,        (z_crc_t const   )3336186494UL,        (z_crc_t const   )3340255305UL, 
            (z_crc_t const   )3260503756UL,        (z_crc_t const   )3281337595UL,        (z_crc_t const   )3251864226UL,        (z_crc_t const   )3222399125UL, 
            (z_crc_t const   )3410866088UL,        (z_crc_t const   )3398419871UL,        (z_crc_t const   )3368647622UL,        (z_crc_t const   )3372945905UL, 
            (z_crc_t const   )3427010420UL,        (z_crc_t const   )3448139075UL,        (z_crc_t const   )3485520666UL,        (z_crc_t const   )3456284973UL, 
            (z_crc_t const   )2444203584UL,        (z_crc_t const   )2423127159UL,        (z_crc_t const   )2452308526UL,        (z_crc_t const   )2481530905UL, 
            (z_crc_t const   )2527477404UL,        (z_crc_t const   )2539934891UL,        (z_crc_t const   )2502093554UL,        (z_crc_t const   )2497740997UL, 
            (z_crc_t const   )2679949304UL,        (z_crc_t const   )2659102159UL,        (z_crc_t const   )2620920726UL,        (z_crc_t const   )2650438049UL, 
            (z_crc_t const   )2562027300UL,        (z_crc_t const   )2574714131UL,        (z_crc_t const   )2603727690UL,        (z_crc_t const   )2599670141UL, 
            (z_crc_t const   )2374579504UL,        (z_crc_t const   )2353749767UL,        (z_crc_t const   )2383274334UL,        (z_crc_t const   )2412743529UL, 
            (z_crc_t const   )2323684844UL,        (z_crc_t const   )2336421851UL,        (z_crc_t const   )2298759554UL,        (z_crc_t const   )2294686645UL, 
            (z_crc_t const   )2207933576UL,        (z_crc_t const   )2186809023UL,        (z_crc_t const   )2149495014UL,        (z_crc_t const   )2178734801UL, 
            (z_crc_t const   )2224278612UL,        (z_crc_t const   )2236720739UL,        (z_crc_t const   )2266437690UL,        (z_crc_t const   )2262135309UL, 
            (z_crc_t const   )2850214048UL,        (z_crc_t const   )2820717207UL,        (z_crc_t const   )2858812622UL,        (z_crc_t const   )2879680249UL, 
            (z_crc_t const   )2934667388UL,        (z_crc_t const   )2938704459UL,        (z_crc_t const   )2909776914UL,        (z_crc_t const   )2897069605UL, 
            (z_crc_t const   )2817622296UL,        (z_crc_t const   )2788420399UL,        (z_crc_t const   )2759153014UL,        (z_crc_t const   )2780249921UL, 
            (z_crc_t const   )2700618180UL,        (z_crc_t const   )2704950259UL,        (z_crc_t const   )2742877610UL,        (z_crc_t const   )2730399645UL, 
            (z_crc_t const   )3049550800UL,        (z_crc_t const   )3020298727UL,        (z_crc_t const   )3057690558UL,        (z_crc_t const   )3078802825UL, 
            (z_crc_t const   )2999835404UL,        (z_crc_t const   )3004150075UL,        (z_crc_t const   )2974355298UL,        (z_crc_t const   )2961925461UL, 
            (z_crc_t const   )3151438440UL,        (z_crc_t const   )3121956959UL,        (z_crc_t const   )3092510214UL,        (z_crc_t const   )3113327665UL, 
            (z_crc_t const   )3168701108UL,        (z_crc_t const   )3172786307UL,        (z_crc_t const   )3210370778UL,        (z_crc_t const   )3197646061UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )3099354981UL,        (z_crc_t const   )2852767883UL,        (z_crc_t const   )313896942UL, 
            (z_crc_t const   )2405603159UL,        (z_crc_t const   )937357362UL,        (z_crc_t const   )627793884UL,        (z_crc_t const   )2648127673UL, 
            (z_crc_t const   )3316918511UL,        (z_crc_t const   )2097696650UL,        (z_crc_t const   )1874714724UL,        (z_crc_t const   )3607201537UL, 
            (z_crc_t const   )1255587768UL,        (z_crc_t const   )4067088605UL,        (z_crc_t const   )3772741427UL,        (z_crc_t const   )1482887254UL, 
            (z_crc_t const   )1343838111UL,        (z_crc_t const   )3903140090UL,        (z_crc_t const   )4195393300UL,        (z_crc_t const   )1118632049UL, 
            (z_crc_t const   )3749429448UL,        (z_crc_t const   )1741137837UL,        (z_crc_t const   )1970407491UL,        (z_crc_t const   )3452858150UL, 
            (z_crc_t const   )2511175536UL,        (z_crc_t const   )756094997UL,        (z_crc_t const   )1067759611UL,        (z_crc_t const   )2266550430UL, 
            (z_crc_t const   )449832999UL,        (z_crc_t const   )2725482306UL,        (z_crc_t const   )2965774508UL,        (z_crc_t const   )142231497UL, 
            (z_crc_t const   )2687676222UL,        (z_crc_t const   )412010587UL,        (z_crc_t const   )171665333UL,        (z_crc_t const   )2995192016UL, 
            (z_crc_t const   )793786473UL,        (z_crc_t const   )2548850444UL,        (z_crc_t const   )2237264098UL,        (z_crc_t const   )1038456711UL, 
            (z_crc_t const   )1703315409UL,        (z_crc_t const   )3711623348UL,        (z_crc_t const   )3482275674UL,        (z_crc_t const   )1999841343UL, 
            (z_crc_t const   )3940814982UL,        (z_crc_t const   )1381529571UL,        (z_crc_t const   )1089329165UL,        (z_crc_t const   )4166106984UL, 
            (z_crc_t const   )4029413537UL,        (z_crc_t const   )1217896388UL,        (z_crc_t const   )1512189994UL,        (z_crc_t const   )3802027855UL, 
            (z_crc_t const   )2135519222UL,        (z_crc_t const   )3354724499UL,        (z_crc_t const   )3577784189UL,        (z_crc_t const   )1845280792UL, 
            (z_crc_t const   )899665998UL,        (z_crc_t const   )2367928107UL,        (z_crc_t const   )2677414085UL,        (z_crc_t const   )657096608UL, 
            (z_crc_t const   )3137160985UL,        (z_crc_t const   )37822588UL,        (z_crc_t const   )284462994UL,        (z_crc_t const   )2823350519UL, 
            (z_crc_t const   )2601801789UL,        (z_crc_t const   )598228824UL,        (z_crc_t const   )824021174UL,        (z_crc_t const   )2309093331UL, 
            (z_crc_t const   )343330666UL,        (z_crc_t const   )2898962447UL,        (z_crc_t const   )3195996129UL,        (z_crc_t const   )113467524UL, 
            (z_crc_t const   )1587572946UL,        (z_crc_t const   )3860600759UL,        (z_crc_t const   )4104763481UL,        (z_crc_t const   )1276501820UL, 
            (z_crc_t const   )3519211397UL,        (z_crc_t const   )1769898208UL,        (z_crc_t const   )2076913422UL,        (z_crc_t const   )3279374443UL, 
            (z_crc_t const   )3406630818UL,        (z_crc_t const   )1941006535UL,        (z_crc_t const   )1627703081UL,        (z_crc_t const   )3652755532UL, 
            (z_crc_t const   )1148164341UL,        (z_crc_t const   )4241751952UL,        (z_crc_t const   )3999682686UL,        (z_crc_t const   )1457141531UL, 
            (z_crc_t const   )247015245UL,        (z_crc_t const   )3053797416UL,        (z_crc_t const   )2763059142UL,        (z_crc_t const   )470583459UL, 
            (z_crc_t const   )2178658330UL,        (z_crc_t const   )963106687UL,        (z_crc_t const   )735213713UL,        (z_crc_t const   )2473467892UL, 
            (z_crc_t const   )992409347UL,        (z_crc_t const   )2207944806UL,        (z_crc_t const   )2435792776UL,        (z_crc_t const   )697522413UL, 
            (z_crc_t const   )3024379988UL,        (z_crc_t const   )217581361UL,        (z_crc_t const   )508405983UL,        (z_crc_t const   )2800865210UL, 
            (z_crc_t const   )4271038444UL,        (z_crc_t const   )1177467017UL,        (z_crc_t const   )1419450215UL,        (z_crc_t const   )3962007554UL, 
            (z_crc_t const   )1911572667UL,        (z_crc_t const   )3377213406UL,        (z_crc_t const   )3690561584UL,        (z_crc_t const   )1665525589UL, 
            (z_crc_t const   )1799331996UL,        (z_crc_t const   )3548628985UL,        (z_crc_t const   )3241568279UL,        (z_crc_t const   )2039091058UL, 
            (z_crc_t const   )3831314379UL,        (z_crc_t const   )1558270126UL,        (z_crc_t const   )1314193216UL,        (z_crc_t const   )4142438437UL, 
            (z_crc_t const   )2928380019UL,        (z_crc_t const   )372764438UL,        (z_crc_t const   )75645176UL,        (z_crc_t const   )3158189981UL, 
            (z_crc_t const   )568925988UL,        (z_crc_t const   )2572515393UL,        (z_crc_t const   )2346768303UL,        (z_crc_t const   )861712586UL, 
            (z_crc_t const   )3982079547UL,        (z_crc_t const   )1441124702UL,        (z_crc_t const   )1196457648UL,        (z_crc_t const   )4293663189UL, 
            (z_crc_t const   )1648042348UL,        (z_crc_t const   )3666298377UL,        (z_crc_t const   )3358779879UL,        (z_crc_t const   )1888390786UL, 
            (z_crc_t const   )686661332UL,        (z_crc_t const   )2421291441UL,        (z_crc_t const   )2196002399UL,        (z_crc_t const   )978858298UL, 
            (z_crc_t const   )2811169155UL,        (z_crc_t const   )523464422UL,        (z_crc_t const   )226935048UL,        (z_crc_t const   )3040519789UL, 
            (z_crc_t const   )3175145892UL,        (z_crc_t const   )100435649UL,        (z_crc_t const   )390670639UL,        (z_crc_t const   )2952089162UL, 
            (z_crc_t const   )841119475UL,        (z_crc_t const   )2325614998UL,        (z_crc_t const   )2553003640UL,        (z_crc_t const   )546822429UL, 
            (z_crc_t const   )2029308235UL,        (z_crc_t const   )3225988654UL,        (z_crc_t const   )3539796416UL,        (z_crc_t const   )1782671013UL, 
            (z_crc_t const   )4153826844UL,        (z_crc_t const   )1328167289UL,        (z_crc_t const   )1570739863UL,        (z_crc_t const   )3844338162UL, 
            (z_crc_t const   )1298864389UL,        (z_crc_t const   )4124540512UL,        (z_crc_t const   )3882013070UL,        (z_crc_t const   )1608431339UL, 
            (z_crc_t const   )3255406162UL,        (z_crc_t const   )2058742071UL,        (z_crc_t const   )1744848601UL,        (z_crc_t const   )3501990332UL, 
            (z_crc_t const   )2296328682UL,        (z_crc_t const   )811816591UL,        (z_crc_t const   )584513889UL,        (z_crc_t const   )2590678532UL, 
            (z_crc_t const   )129869501UL,        (z_crc_t const   )3204563416UL,        (z_crc_t const   )2914283062UL,        (z_crc_t const   )352848211UL, 
            (z_crc_t const   )494030490UL,        (z_crc_t const   )2781751807UL,        (z_crc_t const   )3078325777UL,        (z_crc_t const   )264757620UL, 
            (z_crc_t const   )2450577869UL,        (z_crc_t const   )715964072UL,        (z_crc_t const   )941166918UL,        (z_crc_t const   )2158327331UL, 
            (z_crc_t const   )3636881013UL,        (z_crc_t const   )1618608400UL,        (z_crc_t const   )1926213374UL,        (z_crc_t const   )3396585883UL, 
            (z_crc_t const   )1470427426UL,        (z_crc_t const   )4011365959UL,        (z_crc_t const   )4255988137UL,        (z_crc_t const   )1158766284UL, 
            (z_crc_t const   )1984818694UL,        (z_crc_t const   )3471935843UL,        (z_crc_t const   )3695453837UL,        (z_crc_t const   )1693991400UL, 
            (z_crc_t const   )4180638033UL,        (z_crc_t const   )1100160564UL,        (z_crc_t const   )1395044826UL,        (z_crc_t const   )3952793279UL, 
            (z_crc_t const   )3019491049UL,        (z_crc_t const   )189112716UL,        (z_crc_t const   )435162722UL,        (z_crc_t const   )2706139399UL, 
            (z_crc_t const   )1016811966UL,        (z_crc_t const   )2217162459UL,        (z_crc_t const   )2526189877UL,        (z_crc_t const   )774831696UL, 
            (z_crc_t const   )643086745UL,        (z_crc_t const   )2666061564UL,        (z_crc_t const   )2354934034UL,        (z_crc_t const   )887166583UL, 
            (z_crc_t const   )2838900430UL,        (z_crc_t const   )294275499UL,        (z_crc_t const   )54519365UL,        (z_crc_t const   )3145957664UL, 
            (z_crc_t const   )3823145334UL,        (z_crc_t const   )1532818963UL,        (z_crc_t const   )1240029693UL,        (z_crc_t const   )4048895640UL, 
            (z_crc_t const   )1820460577UL,        (z_crc_t const   )3560857924UL,        (z_crc_t const   )3331051178UL,        (z_crc_t const   )2117577167UL, 
            (z_crc_t const   )3598663992UL,        (z_crc_t const   )1858283101UL,        (z_crc_t const   )2088143283UL,        (z_crc_t const   )3301633750UL, 
            (z_crc_t const   )1495127663UL,        (z_crc_t const   )3785470218UL,        (z_crc_t const   )4078182116UL,        (z_crc_t const   )1269332353UL, 
            (z_crc_t const   )332098007UL,        (z_crc_t const   )2876706482UL,        (z_crc_t const   )3116540252UL,        (z_crc_t const   )25085497UL, 
            (z_crc_t const   )2628386432UL,        (z_crc_t const   )605395429UL,        (z_crc_t const   )916469259UL,        (z_crc_t const   )2384220526UL, 
            (z_crc_t const   )2254837415UL,        (z_crc_t const   )1054503362UL,        (z_crc_t const   )745528876UL,        (z_crc_t const   )2496903497UL, 
            (z_crc_t const   )151290352UL,        (z_crc_t const   )2981684885UL,        (z_crc_t const   )2735556987UL,        (z_crc_t const   )464596510UL, 
            (z_crc_t const   )1137851976UL,        (z_crc_t const   )4218313005UL,        (z_crc_t const   )3923506883UL,        (z_crc_t const   )1365741990UL, 
            (z_crc_t const   )3434129695UL,        (z_crc_t const   )1946996346UL,        (z_crc_t const   )1723425172UL,        (z_crc_t const   )3724871409UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )2519730039UL,        (z_crc_t const   )744558318UL,        (z_crc_t const   )3125873049UL, 
            (z_crc_t const   )432303367UL,        (z_crc_t const   )2415159920UL,        (z_crc_t const   )900031465UL,        (z_crc_t const   )2744476830UL, 
            (z_crc_t const   )847829774UL,        (z_crc_t const   )2763578489UL,        (z_crc_t const   )518641120UL,        (z_crc_t const   )2295976599UL, 
            (z_crc_t const   )726447625UL,        (z_crc_t const   )3179065726UL,        (z_crc_t const   )120436967UL,        (z_crc_t const   )2434645904UL, 
            (z_crc_t const   )1678817053UL,        (z_crc_t const   )4062228586UL,        (z_crc_t const   )1215412723UL,        (z_crc_t const   )3728850564UL, 
            (z_crc_t const   )2111101466UL,        (z_crc_t const   )3957644653UL,        (z_crc_t const   )1370871028UL,        (z_crc_t const   )3347436419UL, 
            (z_crc_t const   )1452829715UL,        (z_crc_t const   )3232263012UL,        (z_crc_t const   )2063164157UL,        (z_crc_t const   )3972621706UL, 
            (z_crc_t const   )1331429652UL,        (z_crc_t const   )3647735395UL,        (z_crc_t const   )1664946170UL,        (z_crc_t const   )4111272077UL, 
            (z_crc_t const   )3357568571UL,        (z_crc_t const   )1578133836UL,        (z_crc_t const   )3829489877UL,        (z_crc_t const   )1920034722UL, 
            (z_crc_t const   )3521381180UL,        (z_crc_t const   )1205077067UL,        (z_crc_t const   )4253355474UL,        (z_crc_t const   )1807026853UL, 
            (z_crc_t const   )4205360437UL,        (z_crc_t const   )1821946434UL,        (z_crc_t const   )3603545051UL,        (z_crc_t const   )1090108588UL, 
            (z_crc_t const   )3815561266UL,        (z_crc_t const   )1969020741UL,        (z_crc_t const   )3473790684UL,        (z_crc_t const   )1497223595UL, 
            (z_crc_t const   )2888882470UL,        (z_crc_t const   )973135441UL,        (z_crc_t const   )2152847304UL,        (z_crc_t const   )375509183UL, 
            (z_crc_t const   )3052712993UL,        (z_crc_t const   )600093526UL,        (z_crc_t const   )2576726735UL,        (z_crc_t const   )262520248UL, 
            (z_crc_t const   )2662859304UL,        (z_crc_t const   )143131999UL,        (z_crc_t const   )3000569030UL,        (z_crc_t const   )619252657UL, 
            (z_crc_t const   )2273079087UL,        (z_crc_t const   )290220120UL,        (z_crc_t const   )2870829505UL,        (z_crc_t const   )1026385590UL, 
            (z_crc_t const   )2420235382UL,        (z_crc_t const   )108124929UL,        (z_crc_t const   )3156267672UL,        (z_crc_t const   )705746415UL, 
            (z_crc_t const   )2307240305UL,        (z_crc_t const   )532002310UL,        (z_crc_t const   )2783231903UL,        (z_crc_t const   )869578984UL, 
            (z_crc_t const   )2731083640UL,        (z_crc_t const   )888733711UL,        (z_crc_t const   )2393377174UL,        (z_crc_t const   )412618465UL, 
            (z_crc_t const   )3138218623UL,        (z_crc_t const   )759000328UL,        (z_crc_t const   )2540463249UL,        (z_crc_t const   )22832102UL, 
            (z_crc_t const   )4098976619UL,        (z_crc_t const   )1650551836UL,        (z_crc_t const   )3627050373UL,        (z_crc_t const   )1308648178UL, 
            (z_crc_t const   )3985966700UL,        (z_crc_t const   )2074411291UL,        (z_crc_t const   )3253995650UL,        (z_crc_t const   )1472466933UL, 
            (z_crc_t const   )3336155237UL,        (z_crc_t const   )1357494034UL,        (z_crc_t const   )3937975947UL,        (z_crc_t const   )2089335292UL, 
            (z_crc_t const   )3743276386UL,        (z_crc_t const   )1227741717UL,        (z_crc_t const   )4085044108UL,        (z_crc_t const   )1699534075UL, 
            (z_crc_t const   )1482797645UL,        (z_crc_t const   )3461461306UL,        (z_crc_t const   )1946205347UL,        (z_crc_t const   )3794844628UL, 
            (z_crc_t const   )1101389642UL,        (z_crc_t const   )3616921661UL,        (z_crc_t const   )1841615268UL,        (z_crc_t const   )4227126995UL, 
            (z_crc_t const   )1793681731UL,        (z_crc_t const   )4242107956UL,        (z_crc_t const   )1183344557UL,        (z_crc_t const   )3501744346UL, 
            (z_crc_t const   )1932330052UL,        (z_crc_t const   )3843883827UL,        (z_crc_t const   )1598818986UL,        (z_crc_t const   )3380350429UL, 
            (z_crc_t const   )1014039888UL,        (z_crc_t const   )2856387111UL,        (z_crc_t const   )269487038UL,        (z_crc_t const   )2250247369UL, 
            (z_crc_t const   )632645719UL,        (z_crc_t const   )3011866400UL,        (z_crc_t const   )164914873UL,        (z_crc_t const   )2682544590UL, 
            (z_crc_t const   )251256414UL,        (z_crc_t const   )2563365161UL,        (z_crc_t const   )580440240UL,        (z_crc_t const   )3030964167UL, 
            (z_crc_t const   )389919577UL,        (z_crc_t const   )2165158958UL,        (z_crc_t const   )995933623UL,        (z_crc_t const   )2909584064UL, 
            (z_crc_t const   )545503469UL,        (z_crc_t const   )3065233306UL,        (z_crc_t const   )216184323UL,        (z_crc_t const   )2597499252UL, 
            (z_crc_t const   )961009130UL,        (z_crc_t const   )2943865501UL,        (z_crc_t const   )354867972UL,        (z_crc_t const   )2199313523UL, 
            (z_crc_t const   )302736355UL,        (z_crc_t const   )2218484884UL,        (z_crc_t const   )1047162125UL,        (z_crc_t const   )2824497786UL, 
            (z_crc_t const   )198119140UL,        (z_crc_t const   )2650737043UL,        (z_crc_t const   )665714698UL,        (z_crc_t const   )2979923837UL, 
            (z_crc_t const   )1150488560UL,        (z_crc_t const   )3533899911UL,        (z_crc_t const   )1760690462UL,        (z_crc_t const   )4274128489UL, 
            (z_crc_t const   )1566008055UL,        (z_crc_t const   )3412551040UL,        (z_crc_t const   )1899392025UL,        (z_crc_t const   )3875957614UL, 
            (z_crc_t const   )1981535486UL,        (z_crc_t const   )3760968585UL,        (z_crc_t const   )1518000656UL,        (z_crc_t const   )3427458407UL, 
            (z_crc_t const   )1876933113UL,        (z_crc_t const   )4193238670UL,        (z_crc_t const   )1136572183UL,        (z_crc_t const   )3582898272UL, 
            (z_crc_t const   )3903051478UL,        (z_crc_t const   )2123616673UL,        (z_crc_t const   )3301103672UL,        (z_crc_t const   )1391648591UL, 
            (z_crc_t const   )4050107345UL,        (z_crc_t const   )1733803174UL,        (z_crc_t const   )3708204351UL,        (z_crc_t const   )1261875784UL, 
            (z_crc_t const   )3660254680UL,        (z_crc_t const   )1276840623UL,        (z_crc_t const   )4132045622UL,        (z_crc_t const   )1618609217UL, 
            (z_crc_t const   )3287245023UL,        (z_crc_t const   )1440704424UL,        (z_crc_t const   )4019088945UL,        (z_crc_t const   )2042521926UL, 
            (z_crc_t const   )2360566219UL,        (z_crc_t const   )444819132UL,        (z_crc_t const   )2698145573UL,        (z_crc_t const   )920807506UL, 
            (z_crc_t const   )2507607244UL,        (z_crc_t const   )54987707UL,        (z_crc_t const   )3105227298UL,        (z_crc_t const   )791020885UL, 
            (z_crc_t const   )3191585477UL,        (z_crc_t const   )671858098UL,        (z_crc_t const   )2455417899UL,        (z_crc_t const   )74101596UL, 
            (z_crc_t const   )2818561986UL,        (z_crc_t const   )835702965UL,        (z_crc_t const   )2342443308UL,        (z_crc_t const   )497999451UL, 
            (z_crc_t const   )2965529755UL,        (z_crc_t const   )653419500UL,        (z_crc_t const   )2627955317UL,        (z_crc_t const   )177433858UL, 
            (z_crc_t const   )2835745180UL,        (z_crc_t const   )1060507371UL,        (z_crc_t const   )2238121842UL,        (z_crc_t const   )324468741UL, 
            (z_crc_t const   )2185936789UL,        (z_crc_t const   )343587042UL,        (z_crc_t const   )2922099067UL,        (z_crc_t const   )941340172UL, 
            (z_crc_t const   )2609828498UL,        (z_crc_t const   )230610405UL,        (z_crc_t const   )3085950076UL,        (z_crc_t const   )568318731UL, 
            (z_crc_t const   )3570586502UL,        (z_crc_t const   )1122161905UL,        (z_crc_t const   )4172537192UL,        (z_crc_t const   )1854134815UL, 
            (z_crc_t const   )3440819841UL,        (z_crc_t const   )1529264630UL,        (z_crc_t const   )3782717551UL,        (z_crc_t const   )2001188632UL, 
            (z_crc_t const   )3864660104UL,        (z_crc_t const   )1885999103UL,        (z_crc_t const   )3392865894UL,        (z_crc_t const   )1544225041UL, 
            (z_crc_t const   )4288570767UL,        (z_crc_t const   )1773036280UL,        (z_crc_t const   )3556731745UL,        (z_crc_t const   )1171221526UL, 
            (z_crc_t const   )2028079776UL,        (z_crc_t const   )4006743511UL,        (z_crc_t const   )1417872462UL,        (z_crc_t const   )3266511673UL, 
            (z_crc_t const   )1629906855UL,        (z_crc_t const   )4145438928UL,        (z_crc_t const   )1296525641UL,        (z_crc_t const   )3682037310UL, 
            (z_crc_t const   )1248514478UL,        (z_crc_t const   )3696940761UL,        (z_crc_t const   )1712054080UL,        (z_crc_t const   )4030453815UL, 
            (z_crc_t const   )1403960489UL,        (z_crc_t const   )3315514334UL,        (z_crc_t const   )2144318023UL,        (z_crc_t const   )3925849392UL, 
            (z_crc_t const   )485670333UL,        (z_crc_t const   )2328017610UL,        (z_crc_t const   )814986067UL,        (z_crc_t const   )2795746340UL, 
            (z_crc_t const   )87478458UL,        (z_crc_t const   )2466699213UL,        (z_crc_t const   )693624404UL,        (z_crc_t const   )3211254051UL, 
            (z_crc_t const   )779773619UL,        (z_crc_t const   )3091882436UL,        (z_crc_t const   )35350621UL,        (z_crc_t const   )2485874474UL, 
            (z_crc_t const   )935201716UL,        (z_crc_t const   )2710441155UL,        (z_crc_t const   )467600730UL,        (z_crc_t const   )2381251117UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )1093737241UL,        (z_crc_t const   )2187474482UL,        (z_crc_t const   )3277008171UL, 
            (z_crc_t const   )80047204UL,        (z_crc_t const   )1173649277UL,        (z_crc_t const   )2259114582UL,        (z_crc_t const   )3348513103UL, 
            (z_crc_t const   )143317448UL,        (z_crc_t const   )1237041873UL,        (z_crc_t const   )2330521594UL,        (z_crc_t const   )3420058851UL, 
            (z_crc_t const   )206550444UL,        (z_crc_t const   )1300147893UL,        (z_crc_t const   )2385347486UL,        (z_crc_t const   )3474757767UL, 
            (z_crc_t const   )1360183882UL,        (z_crc_t const   )270784851UL,        (z_crc_t const   )3547395192UL,        (z_crc_t const   )2453794657UL, 
            (z_crc_t const   )1440198190UL,        (z_crc_t const   )350663991UL,        (z_crc_t const   )3619002396UL,        (z_crc_t const   )2525266693UL, 
            (z_crc_t const   )1503140738UL,        (z_crc_t const   )413728923UL,        (z_crc_t const   )3690606000UL,        (z_crc_t const   )2597009065UL, 
            (z_crc_t const   )1566406630UL,        (z_crc_t const   )476867839UL,        (z_crc_t const   )3745464788UL,        (z_crc_t const   )2651740877UL, 
            (z_crc_t const   )2720302229UL,        (z_crc_t const   )3809845132UL,        (z_crc_t const   )541504167UL,        (z_crc_t const   )1635232190UL, 
            (z_crc_t const   )2799823089UL,        (z_crc_t const   )3889230824UL,        (z_crc_t const   )612622019UL,        (z_crc_t const   )1706214874UL, 
            (z_crc_t const   )2863553885UL,        (z_crc_t const   )3953083972UL,        (z_crc_t const   )684485487UL,        (z_crc_t const   )1778217078UL, 
            (z_crc_t const   )2926260537UL,        (z_crc_t const   )4015663648UL,        (z_crc_t const   )738789131UL,        (z_crc_t const   )1832393746UL, 
            (z_crc_t const   )4080420575UL,        (z_crc_t const   )2986827206UL,        (z_crc_t const   )1901359341UL,        (z_crc_t const   )811953140UL, 
            (z_crc_t const   )4159908539UL,        (z_crc_t const   )3066180002UL,        (z_crc_t const   )1972444297UL,        (z_crc_t const   )882902928UL, 
            (z_crc_t const   )4223442711UL,        (z_crc_t const   )3129836558UL,        (z_crc_t const   )2044635429UL,        (z_crc_t const   )955232828UL, 
            (z_crc_t const   )4286182259UL,        (z_crc_t const   )3192449130UL,        (z_crc_t const   )2098971969UL,        (z_crc_t const   )1009442392UL, 
            (z_crc_t const   )89094640UL,        (z_crc_t const   )1149133545UL,        (z_crc_t const   )2267893698UL,        (z_crc_t const   )3323745499UL, 
            (z_crc_t const   )25826708UL,        (z_crc_t const   )1086000781UL,        (z_crc_t const   )2213028774UL,        (z_crc_t const   )3269015743UL, 
            (z_crc_t const   )231055416UL,        (z_crc_t const   )1291107105UL,        (z_crc_t const   )2410124810UL,        (z_crc_t const   )3465973011UL, 
            (z_crc_t const   )151047260UL,        (z_crc_t const   )1211225925UL,        (z_crc_t const   )2338519662UL,        (z_crc_t const   )3394494839UL, 
            (z_crc_t const   )1415429050UL,        (z_crc_t const   )359440547UL,        (z_crc_t const   )3594489224UL,        (z_crc_t const   )2534315665UL, 
            (z_crc_t const   )1352194014UL,        (z_crc_t const   )296340679UL,        (z_crc_t const   )3539657196UL,        (z_crc_t const   )2479618805UL, 
            (z_crc_t const   )1557619314UL,        (z_crc_t const   )501643627UL,        (z_crc_t const   )3736425536UL,        (z_crc_t const   )2676248409UL, 
            (z_crc_t const   )1477578262UL,        (z_crc_t const   )421729551UL,        (z_crc_t const   )3664787492UL,        (z_crc_t const   )2604737341UL, 
            (z_crc_t const   )2808872293UL,        (z_crc_t const   )3864716924UL,        (z_crc_t const   )621398871UL,        (z_crc_t const   )1681444942UL, 
            (z_crc_t const   )2746126593UL,        (z_crc_t const   )3802106392UL,        (z_crc_t const   )567060275UL,        (z_crc_t const   )1627241514UL, 
            (z_crc_t const   )2950767789UL,        (z_crc_t const   )4006625204UL,        (z_crc_t const   )763564703UL,        (z_crc_t const   )1823607174UL, 
            (z_crc_t const   )2871281865UL,        (z_crc_t const   )3927266256UL,        (z_crc_t const   )692485883UL,        (z_crc_t const   )1752655330UL, 
            (z_crc_t const   )4135141167UL,        (z_crc_t const   )3074958390UL,        (z_crc_t const   )1947928861UL,        (z_crc_t const   )891949572UL, 
            (z_crc_t const   )4072428363UL,        (z_crc_t const   )3012380754UL,        (z_crc_t const   )1893623161UL,        (z_crc_t const   )837779040UL, 
            (z_crc_t const   )4277397223UL,        (z_crc_t const   )3217227262UL,        (z_crc_t const   )2089930965UL,        (z_crc_t const   )1033948108UL, 
            (z_crc_t const   )4197878403UL,        (z_crc_t const   )3137835418UL,        (z_crc_t const   )2018819249UL,        (z_crc_t const   )962963368UL, 
            (z_crc_t const   )1268286267UL,        (z_crc_t const   )178886690UL,        (z_crc_t const   )3388650761UL,        (z_crc_t const   )2295049744UL, 
            (z_crc_t const   )1331556191UL,        (z_crc_t const   )242021446UL,        (z_crc_t const   )3443513709UL,        (z_crc_t const   )2349777524UL, 
            (z_crc_t const   )1125276403UL,        (z_crc_t const   )35865066UL,        (z_crc_t const   )3245370561UL,        (z_crc_t const   )2151774168UL, 
            (z_crc_t const   )1205286551UL,        (z_crc_t const   )115748238UL,        (z_crc_t const   )3316973733UL,        (z_crc_t const   )2223250364UL, 
            (z_crc_t const   )445268337UL,        (z_crc_t const   )1539005032UL,        (z_crc_t const   )2565371715UL,        (z_crc_t const   )3654904922UL, 
            (z_crc_t const   )508505365UL,        (z_crc_t const   )1602106892UL,        (z_crc_t const   )2620201767UL,        (z_crc_t const   )3709599806UL, 
            (z_crc_t const   )302028985UL,        (z_crc_t const   )1395753888UL,        (z_crc_t const   )2422386315UL,        (z_crc_t const   )3511924114UL, 
            (z_crc_t const   )382072029UL,        (z_crc_t const   )1475669956UL,        (z_crc_t const   )2494022383UL,        (z_crc_t const   )3583433206UL, 
            (z_crc_t const   )3921414062UL,        (z_crc_t const   )2827820215UL,        (z_crc_t const   )1809723804UL,        (z_crc_t const   )720317061UL, 
            (z_crc_t const   )3984157642UL,        (z_crc_t const   )2890428627UL,        (z_crc_t const   )1864064504UL,        (z_crc_t const   )774522593UL, 
            (z_crc_t const   )3778469478UL,        (z_crc_t const   )2684863871UL,        (z_crc_t const   )1666508884UL,        (z_crc_t const   )577106765UL, 
            (z_crc_t const   )3857953282UL,        (z_crc_t const   )2764220699UL,        (z_crc_t const   )1737589808UL,        (z_crc_t const   )648060713UL, 
            (z_crc_t const   )3098461668UL,        (z_crc_t const   )4188004093UL,        (z_crc_t const   )986510294UL,        (z_crc_t const   )2080237775UL, 
            (z_crc_t const   )3161172352UL,        (z_crc_t const   )4250579609UL,        (z_crc_t const   )1040818098UL,        (z_crc_t const   )2134410411UL, 
            (z_crc_t const   )2955156524UL,        (z_crc_t const   )4044687157UL,        (z_crc_t const   )843459102UL,        (z_crc_t const   )1937191175UL, 
            (z_crc_t const   )3034673224UL,        (z_crc_t const   )4124076881UL,        (z_crc_t const   )914572922UL,        (z_crc_t const   )2008178019UL, 
            (z_crc_t const   )1322777291UL,        (z_crc_t const   )266789330UL,        (z_crc_t const   )3434466553UL,        (z_crc_t const   )2374293472UL, 
            (z_crc_t const   )1242732207UL,        (z_crc_t const   )186879414UL,        (z_crc_t const   )3362824349UL,        (z_crc_t const   )2302786436UL, 
            (z_crc_t const   )1180508931UL,        (z_crc_t const   )124532762UL,        (z_crc_t const   )3292468529UL,        (z_crc_t const   )2232290856UL, 
            (z_crc_t const   )1117278055UL,        (z_crc_t const   )61428862UL,        (z_crc_t const   )3237640533UL,        (z_crc_t const   )2177589836UL, 
            (z_crc_t const   )533018753UL,        (z_crc_t const   )1593058200UL,        (z_crc_t const   )2644971187UL,        (z_crc_t const   )3700823466UL, 
            (z_crc_t const   )453006565UL,        (z_crc_t const   )1513181180UL,        (z_crc_t const   )2573361879UL,        (z_crc_t const   )3629349326UL, 
            (z_crc_t const   )391110985UL,        (z_crc_t const   )1451162192UL,        (z_crc_t const   )2502809467UL,        (z_crc_t const   )3558657122UL, 
            (z_crc_t const   )327847213UL,        (z_crc_t const   )1388025396UL,        (z_crc_t const   )2447948575UL,        (z_crc_t const   )3503923206UL, 
            (z_crc_t const   )3975380574UL,        (z_crc_t const   )2915198279UL,        (z_crc_t const   )1855015020UL,        (z_crc_t const   )799036277UL, 
            (z_crc_t const   )3895857722UL,        (z_crc_t const   )2835810595UL,        (z_crc_t const   )1783899144UL,        (z_crc_t const   )728055569UL, 
            (z_crc_t const   )3833178006UL,        (z_crc_t const   )2773007503UL,        (z_crc_t const   )1713082788UL,        (z_crc_t const   )657099453UL, 
            (z_crc_t const   )3770469362UL,        (z_crc_t const   )2710425835UL,        (z_crc_t const   )1658781120UL,        (z_crc_t const   )602924761UL, 
            (z_crc_t const   )3185687572UL,        (z_crc_t const   )4241532685UL,        (z_crc_t const   )1065585190UL,        (z_crc_t const   )2125631807UL, 
            (z_crc_t const   )3106197616UL,        (z_crc_t const   )4162177897UL,        (z_crc_t const   )994502210UL,        (z_crc_t const   )2054683995UL, 
            (z_crc_t const   )3043714524UL,        (z_crc_t const   )4099571397UL,        (z_crc_t const   )923358190UL,        (z_crc_t const   )1983400183UL, 
            (z_crc_t const   )2980972984UL,        (z_crc_t const   )4036956833UL,        (z_crc_t const   )869023626UL,        (z_crc_t const   )1929192595UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )929743361UL,        (z_crc_t const   )1859421187UL,        (z_crc_t const   )1505641986UL, 
            (z_crc_t const   )3701999879UL,        (z_crc_t const   )3955411718UL,        (z_crc_t const   )2994507012UL,        (z_crc_t const   )2232831749UL, 
            (z_crc_t const   )3092321038UL,        (z_crc_t const   )2403062031UL,        (z_crc_t const   )3599079181UL,        (z_crc_t const   )3790558476UL, 
            (z_crc_t const   )1694046729UL,        (z_crc_t const   )1402198024UL,        (z_crc_t const   )170761738UL,        (z_crc_t const   )1028086795UL, 
            (z_crc_t const   )1889740316UL,        (z_crc_t const   )1204413469UL,        (z_crc_t const   )511156767UL,        (z_crc_t const   )689791006UL, 
            (z_crc_t const   )2886414107UL,        (z_crc_t const   )2606886170UL,        (z_crc_t const   )3269438232UL,        (z_crc_t const   )4122306841UL, 
            (z_crc_t const   )3371316498UL,        (z_crc_t const   )4288214803UL,        (z_crc_t const   )2787553553UL,        (z_crc_t const   )2437706512UL, 
            (z_crc_t const   )341457941UL,        (z_crc_t const   )590413332UL,        (z_crc_t const   )2056173590UL,        (z_crc_t const   )1306819095UL, 
            (z_crc_t const   )3762703672UL,        (z_crc_t const   )3610021689UL,        (z_crc_t const   )2391984443UL,        (z_crc_t const   )3120040762UL, 
            (z_crc_t const   )1022247999UL,        (z_crc_t const   )193234494UL,        (z_crc_t const   )1379582012UL,        (z_crc_t const   )1699742269UL, 
            (z_crc_t const   )1477926454UL,        (z_crc_t const   )1870502967UL,        (z_crc_t const   )918805045UL,        (z_crc_t const   )27858996UL, 
            (z_crc_t const   )2227132209UL,        (z_crc_t const   )3017119024UL,        (z_crc_t const   )3932934962UL,        (z_crc_t const   )3707834675UL, 
            (z_crc_t const   )2430954276UL,        (z_crc_t const   )2811210021UL,        (z_crc_t const   )4264685351UL,        (z_crc_t const   )3378195750UL, 
            (z_crc_t const   )1280139811UL,        (z_crc_t const   )2066194466UL,        (z_crc_t const   )580511264UL,        (z_crc_t const   )368256033UL, 
            (z_crc_t const   )682915882UL,        (z_crc_t const   )534690347UL,        (z_crc_t const   )1180761129UL,        (z_crc_t const   )1896496680UL, 
            (z_crc_t const   )4095504685UL,        (z_crc_t const   )3279336236UL,        (z_crc_t const   )2596861230UL,        (z_crc_t const   )2913089327UL, 
            (z_crc_t const   )3230505584UL,        (z_crc_t const   )4159133809UL,        (z_crc_t const   )2925076083UL,        (z_crc_t const   )2570312818UL, 
            (z_crc_t const   )472224631UL,        (z_crc_t const   )726618486UL,        (z_crc_t const   )1928402804UL,        (z_crc_t const   )1167840629UL, 
            (z_crc_t const   )2027719038UL,        (z_crc_t const   )1337346943UL,        (z_crc_t const   )369626493UL,        (z_crc_t const   )560123772UL, 
            (z_crc_t const   )2759098489UL,        (z_crc_t const   )2468233848UL,        (z_crc_t const   )3399484538UL,        (z_crc_t const   )4257924731UL, 
            (z_crc_t const   )2955852908UL,        (z_crc_t const   )2269412973UL,        (z_crc_t const   )3740940399UL,        (z_crc_t const   )3918592622UL, 
            (z_crc_t const   )1820767595UL,        (z_crc_t const   )1542223722UL,        (z_crc_t const   )38941032UL,        (z_crc_t const   )892924777UL, 
            (z_crc_t const   )142585698UL,        (z_crc_t const   )1058368867UL,        (z_crc_t const   )1722493793UL,        (z_crc_t const   )1371662688UL, 
            (z_crc_t const   )3570902629UL,        (z_crc_t const   )3820840036UL,        (z_crc_t const   )3120767590UL,        (z_crc_t const   )2372526183UL, 
            (z_crc_t const   )550229832UL,        (z_crc_t const   )396432713UL,        (z_crc_t const   )1310675787UL,        (z_crc_t const   )2037748042UL, 
            (z_crc_t const   )4234403407UL,        (z_crc_t const   )3406371918UL,        (z_crc_t const   )2461489740UL,        (z_crc_t const   )2782763085UL, 
            (z_crc_t const   )2560279622UL,        (z_crc_t const   )2951743047UL,        (z_crc_t const   )4132323397UL,        (z_crc_t const   )3240395332UL, 
            (z_crc_t const   )1144180033UL,        (z_crc_t const   )1935150912UL,        (z_crc_t const   )719735106UL,        (z_crc_t const   )495749955UL, 
            (z_crc_t const   )1349054804UL,        (z_crc_t const   )1728197461UL,        (z_crc_t const   )1052538199UL,        (z_crc_t const   )165066582UL, 
            (z_crc_t const   )2361456723UL,        (z_crc_t const   )3148495442UL,        (z_crc_t const   )3792993360UL,        (z_crc_t const   )3581853265UL, 
            (z_crc_t const   )3896107610UL,        (z_crc_t const   )3746766939UL,        (z_crc_t const   )2263705177UL,        (z_crc_t const   )2978456664UL, 
            (z_crc_t const   )881978205UL,        (z_crc_t const   )66791772UL,        (z_crc_t const   )1514499934UL,        (z_crc_t const   )1831841119UL, 
            (z_crc_t const   )2149266913UL,        (z_crc_t const   )3077699552UL,        (z_crc_t const   )4006588898UL,        (z_crc_t const   )3651498979UL, 
            (z_crc_t const   )1555250406UL,        (z_crc_t const   )1809448679UL,        (z_crc_t const   )845658341UL,        (z_crc_t const   )84769508UL, 
            (z_crc_t const   )944383727UL,        (z_crc_t const   )253813998UL,        (z_crc_t const   )1453236972UL,        (z_crc_t const   )1643405549UL, 
            (z_crc_t const   )3840028648UL,        (z_crc_t const   )3548966377UL,        (z_crc_t const   )2318838763UL,        (z_crc_t const   )3176950250UL, 
            (z_crc_t const   )4038595581UL,        (z_crc_t const   )3352482300UL,        (z_crc_t const   )2657916926UL,        (z_crc_t const   )2835764735UL, 
            (z_crc_t const   )739252986UL,        (z_crc_t const   )461035771UL,        (z_crc_t const   )1120182009UL,        (z_crc_t const   )1974361336UL, 
            (z_crc_t const   )1223229683UL,        (z_crc_t const   )2139341554UL,        (z_crc_t const   )641565936UL,        (z_crc_t const   )290932465UL, 
            (z_crc_t const   )2487290356UL,        (z_crc_t const   )2737556469UL,        (z_crc_t const   )4204105207UL,        (z_crc_t const   )3456061430UL, 
            (z_crc_t const   )1616738521UL,        (z_crc_t const   )1463270104UL,        (z_crc_t const   )243924186UL,        (z_crc_t const   )971194075UL, 
            (z_crc_t const   )3170202078UL,        (z_crc_t const   )2342499295UL,        (z_crc_t const   )3525440989UL,        (z_crc_t const   )3846911964UL, 
            (z_crc_t const   )3624692695UL,        (z_crc_t const   )4016482774UL,        (z_crc_t const   )3067670484UL,        (z_crc_t const   )2175938005UL, 
            (z_crc_t const   )77882064UL,        (z_crc_t const   )869179601UL,        (z_crc_t const   )1785784019UL,        (z_crc_t const   )1561994450UL, 
            (z_crc_t const   )285105861UL,        (z_crc_t const   )664050884UL,        (z_crc_t const   )2116737734UL,        (z_crc_t const   )1228937415UL, 
            (z_crc_t const   )3428210626UL,        (z_crc_t const   )4215051715UL,        (z_crc_t const   )2726482881UL,        (z_crc_t const   )2515014080UL, 
            (z_crc_t const   )2830061003UL,        (z_crc_t const   )2680524746UL,        (z_crc_t const   )3330001352UL,        (z_crc_t const   )4044426185UL, 
            (z_crc_t const   )1946633420UL,        (z_crc_t const   )1131251405UL,        (z_crc_t const   )450085071UL,        (z_crc_t const   )767099598UL, 
            (z_crc_t const   )1083617169UL,        (z_crc_t const   )2013031824UL,        (z_crc_t const   )776088466UL,        (z_crc_t const   )422111635UL, 
            (z_crc_t const   )2621351574UL,        (z_crc_t const   )2874434711UL,        (z_crc_t const   )4075430549UL,        (z_crc_t const   )3313557652UL, 
            (z_crc_t const   )4173839519UL,        (z_crc_t const   )3484253854UL,        (z_crc_t const   )2517842076UL,        (z_crc_t const   )2709125789UL, 
            (z_crc_t const   )611300760UL,        (z_crc_t const   )319125401UL,        (z_crc_t const   )1253781915UL,        (z_crc_t const   )2110911386UL, 
            (z_crc_t const   )808814989UL,        (z_crc_t const   )123685772UL,        (z_crc_t const   )1591807374UL,        (z_crc_t const   )1770770319UL, 
            (z_crc_t const   )3969745034UL,        (z_crc_t const   )3690414731UL,        (z_crc_t const   )2185823369UL,        (z_crc_t const   )3039020680UL, 
            (z_crc_t const   )2288294531UL,        (z_crc_t const   )3205388418UL,        (z_crc_t const   )3870301824UL,        (z_crc_t const   )3520781441UL, 
            (z_crc_t const   )1422693252UL,        (z_crc_t const   )1671844229UL,        (z_crc_t const   )974657415UL,        (z_crc_t const   )225629574UL, 
            (z_crc_t const   )2698044073UL,        (z_crc_t const   )2545557672UL,        (z_crc_t const   )3456394922UL,        (z_crc_t const   )4184777899UL, 
            (z_crc_t const   )2088299438UL,        (z_crc_t const   )1259481519UL,        (z_crc_t const   )313290669UL,        (z_crc_t const   )633777580UL, 
            (z_crc_t const   )411169191UL,        (z_crc_t const   )803943334UL,        (z_crc_t const   )1985312164UL,        (z_crc_t const   )1094694821UL, 
            (z_crc_t const   )3291084960UL,        (z_crc_t const   )4081269409UL,        (z_crc_t const   )2868739235UL,        (z_crc_t const   )2643967650UL, 
            (z_crc_t const   )3497247925UL,        (z_crc_t const   )3877177012UL,        (z_crc_t const   )3198632118UL,        (z_crc_t const   )2311946935UL, 
            (z_crc_t const   )215731634UL,        (z_crc_t const   )1001459635UL,        (z_crc_t const   )1645169073UL,        (z_crc_t const   )1432718256UL, 
            (z_crc_t const   )1747113915UL,        (z_crc_t const   )1598559674UL,        (z_crc_t const   )116806584UL,        (z_crc_t const   )832344505UL, 
            (z_crc_t const   )3028999868UL,        (z_crc_t const   )2212502717UL,        (z_crc_t const   )3663616703UL,        (z_crc_t const   )3979647166UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )1701297336UL,        (z_crc_t const   )2345142698UL,        (z_crc_t const   )4004492562UL, 
            (z_crc_t const   )1469538959UL,        (z_crc_t const   )854646327UL,        (z_crc_t const   )3697240869UL,        (z_crc_t const   )3107510173UL, 
            (z_crc_t const   )4012422341UL,        (z_crc_t const   )2320435325UL,        (z_crc_t const   )1692450159UL,        (z_crc_t const   )25625047UL, 
            (z_crc_t const   )3099579978UL,        (z_crc_t const   )3721947890UL,        (z_crc_t const   )863494112UL,        (z_crc_t const   )1443914584UL, 
            (z_crc_t const   )2673285456UL,        (z_crc_t const   )4197492200UL,        (z_crc_t const   )345968890UL,        (z_crc_t const   )1912122434UL, 
            (z_crc_t const   )3368057823UL,        (z_crc_t const   )2913453927UL,        (z_crc_t const   )1124627061UL,        (z_crc_t const   )644861645UL, 
            (z_crc_t const   )1887415701UL,        (z_crc_t const   )353898797UL,        (z_crc_t const   )4223116351UL,        (z_crc_t const   )2664437895UL, 
            (z_crc_t const   )669568794UL,        (z_crc_t const   )1116697506UL,        (z_crc_t const   )2887829168UL,        (z_crc_t const   )3376904712UL, 
            (z_crc_t const   )1051669152UL,        (z_crc_t const   )1539870232UL,        (z_crc_t const   )3043441418UL,        (z_crc_t const   )3489695666UL, 
            (z_crc_t const   )1765298223UL,        (z_crc_t const   )207613079UL,        (z_crc_t const   )3807402373UL,        (z_crc_t const   )2274878781UL, 
            (z_crc_t const   )3515319909UL,        (z_crc_t const   )3034594013UL,        (z_crc_t const   )1515163599UL,        (z_crc_t const   )1059599223UL, 
            (z_crc_t const   )2249254122UL,        (z_crc_t const   )3816249426UL,        (z_crc_t const   )232320320UL,        (z_crc_t const   )1757368824UL, 
            (z_crc_t const   )2717395952UL,        (z_crc_t const   )3298793288UL,        (z_crc_t const   )707797594UL,        (z_crc_t const   )1331142370UL, 
            (z_crc_t const   )4134488447UL,        (z_crc_t const   )2466837959UL,        (z_crc_t const   )2108113109UL,        (z_crc_t const   )415300717UL, 
            (z_crc_t const   )1322295093UL,        (z_crc_t const   )733422477UL,        (z_crc_t const   )3306722975UL,        (z_crc_t const   )2692688423UL, 
            (z_crc_t const   )424148410UL,        (z_crc_t const   )2082488578UL,        (z_crc_t const   )2458907664UL,        (z_crc_t const   )4159195304UL, 
            (z_crc_t const   )1029182619UL,        (z_crc_t const   )1480566819UL,        (z_crc_t const   )3062897969UL,        (z_crc_t const   )3556221321UL, 
            (z_crc_t const   )1791981076UL,        (z_crc_t const   )262720172UL,        (z_crc_t const   )3775365054UL,        (z_crc_t const   )2220933894UL, 
            (z_crc_t const   )3530596446UL,        (z_crc_t const   )3071745254UL,        (z_crc_t const   )1505274356UL,        (z_crc_t const   )1021252940UL, 
            (z_crc_t const   )2246558417UL,        (z_crc_t const   )3766517353UL,        (z_crc_t const   )238013307UL,        (z_crc_t const   )1799911363UL, 
            (z_crc_t const   )2718895563UL,        (z_crc_t const   )3345527155UL,        (z_crc_t const   )700908641UL,        (z_crc_t const   )1285601497UL, 
            (z_crc_t const   )4120407876UL,        (z_crc_t const   )2432685052UL,        (z_crc_t const   )2119198446UL,        (z_crc_t const   )456645206UL, 
            (z_crc_t const   )1294448910UL,        (z_crc_t const   )675284406UL,        (z_crc_t const   )3337597092UL,        (z_crc_t const   )2743602204UL, 
            (z_crc_t const   )447798145UL,        (z_crc_t const   )2144823097UL,        (z_crc_t const   )2440614443UL,        (z_crc_t const   )4095700627UL, 
            (z_crc_t const   )66528827UL,        (z_crc_t const   )1720752771UL,        (z_crc_t const   )2285842321UL,        (z_crc_t const   )3982005033UL, 
            (z_crc_t const   )1415595188UL,        (z_crc_t const   )822605836UL,        (z_crc_t const   )3752348958UL,        (z_crc_t const   )3134189990UL, 
            (z_crc_t const   )3974075134UL,        (z_crc_t const   )2310549062UL,        (z_crc_t const   )1729600340UL,        (z_crc_t const   )40904684UL, 
            (z_crc_t const   )3142119537UL,        (z_crc_t const   )3727641801UL,        (z_crc_t const   )813758939UL,        (z_crc_t const   )1441219939UL, 
            (z_crc_t const   )2627747691UL,        (z_crc_t const   )4190602195UL,        (z_crc_t const   )392705729UL,        (z_crc_t const   )1913621113UL, 
            (z_crc_t const   )3409403364UL,        (z_crc_t const   )2924536156UL,        (z_crc_t const   )1090475086UL,        (z_crc_t const   )630778102UL, 
            (z_crc_t const   )1938328494UL,        (z_crc_t const   )384775958UL,        (z_crc_t const   )4164977156UL,        (z_crc_t const   )2636594876UL, 
            (z_crc_t const   )606071073UL,        (z_crc_t const   )1098405273UL,        (z_crc_t const   )2950160523UL,        (z_crc_t const   )3400555571UL, 
            (z_crc_t const   )1001806317UL,        (z_crc_t const   )1590814037UL,        (z_crc_t const   )2961068103UL,        (z_crc_t const   )3575246079UL, 
            (z_crc_t const   )1814117218UL,        (z_crc_t const   )155617242UL,        (z_crc_t const   )3890819784UL,        (z_crc_t const   )2190380656UL, 
            (z_crc_t const   )3567185192UL,        (z_crc_t const   )2985906576UL,        (z_crc_t const   )1599530114UL,        (z_crc_t const   )976312378UL, 
            (z_crc_t const   )2198441895UL,        (z_crc_t const   )3865981727UL,        (z_crc_t const   )146900493UL,        (z_crc_t const   )1839610549UL, 
            (z_crc_t const   )2766225597UL,        (z_crc_t const   )3246849029UL,        (z_crc_t const   )791234839UL,        (z_crc_t const   )1246688687UL, 
            (z_crc_t const   )4084605490UL,        (z_crc_t const   )2517737098UL,        (z_crc_t const   )2025728920UL,        (z_crc_t const   )500799264UL, 
            (z_crc_t const   )1271526520UL,        (z_crc_t const   )783173824UL,        (z_crc_t const   )3221355986UL,        (z_crc_t const   )2774942058UL, 
            (z_crc_t const   )475961079UL,        (z_crc_t const   )2033789519UL,        (z_crc_t const   )2543230813UL,        (z_crc_t const   )4075889637UL, 
            (z_crc_t const   )85551949UL,        (z_crc_t const   )1618925557UL,        (z_crc_t const   )2396087015UL,        (z_crc_t const   )3954630239UL, 
            (z_crc_t const   )1385040322UL,        (z_crc_t const   )938063226UL,        (z_crc_t const   )3645243496UL,        (z_crc_t const   )3156327632UL, 
            (z_crc_t const   )3929137032UL,        (z_crc_t const   )2404803376UL,        (z_crc_t const   )1643763234UL,        (z_crc_t const   )77490842UL, 
            (z_crc_t const   )3181821191UL,        (z_crc_t const   )3636527551UL,        (z_crc_t const   )913224877UL,        (z_crc_t const   )1393100821UL, 
            (z_crc_t const   )2588832285UL,        (z_crc_t const   )4280929957UL,        (z_crc_t const   )294026167UL,        (z_crc_t const   )1960953615UL, 
            (z_crc_t const   )3453554834UL,        (z_crc_t const   )2831068202UL,        (z_crc_t const   )1175525688UL,        (z_crc_t const   )594978176UL, 
            (z_crc_t const   )1969669848UL,        (z_crc_t const   )268532320UL,        (z_crc_t const   )4272869234UL,        (z_crc_t const   )2613670858UL, 
            (z_crc_t const   )586261591UL,        (z_crc_t const   )1201019119UL,        (z_crc_t const   )2839129597UL,        (z_crc_t const   )3428716869UL, 
            (z_crc_t const   )116280694UL,        (z_crc_t const   )1669984718UL,        (z_crc_t const   )2368095452UL,        (z_crc_t const   )3896637540UL, 
            (z_crc_t const   )1366896633UL,        (z_crc_t const   )874419009UL,        (z_crc_t const   )3669042771UL,        (z_crc_t const   )3218512619UL, 
            (z_crc_t const   )3922131379UL,        (z_crc_t const   )2359379211UL,        (z_crc_t const   )1645146137UL,        (z_crc_t const   )124341409UL, 
            (z_crc_t const   )3193019196UL,        (z_crc_t const   )3677759364UL,        (z_crc_t const   )899256982UL,        (z_crc_t const   )1358835246UL, 
            (z_crc_t const   )2579059750UL,        (z_crc_t const   )4242466974UL,        (z_crc_t const   )309419404UL,        (z_crc_t const   )1997988148UL, 
            (z_crc_t const   )3459135145UL,        (z_crc_t const   )2873723409UL,        (z_crc_t const   )1172717315UL,        (z_crc_t const   )545358779UL, 
            (z_crc_t const   )1989271779UL,        (z_crc_t const   )334912603UL,        (z_crc_t const   )4250528073UL,        (z_crc_t const   )2554222065UL, 
            (z_crc_t const   )554074732UL,        (z_crc_t const   )1147223764UL,        (z_crc_t const   )2865662918UL,        (z_crc_t const   )3483973502UL, 
            (z_crc_t const   )943816662UL,        (z_crc_t const   )1562821486UL,        (z_crc_t const   )3012130428UL,        (z_crc_t const   )3605973700UL, 
            (z_crc_t const   )1876303193UL,        (z_crc_t const   )179413473UL,        (z_crc_t const   )3827176691UL,        (z_crc_t const   )2172233803UL, 
            (z_crc_t const   )3614034707UL,        (z_crc_t const   )2987292587UL,        (z_crc_t const   )1554105017UL,        (z_crc_t const   )969309697UL, 
            (z_crc_t const   )2164173212UL,        (z_crc_t const   )3852014884UL,        (z_crc_t const   )188129334UL,        (z_crc_t const   )1850809486UL, 
            (z_crc_t const   )2803263110UL,        (z_crc_t const   )3262241342UL,        (z_crc_t const   )752774956UL,        (z_crc_t const   )1236915092UL, 
            (z_crc_t const   )4034987017UL,        (z_crc_t const   )2514925745UL,        (z_crc_t const   )2068385187UL,        (z_crc_t const   )506376475UL, 
            (z_crc_t const   )1212076611UL,        (z_crc_t const   )760835835UL,        (z_crc_t const   )3287735273UL,        (z_crc_t const   )2794547025UL, 
            (z_crc_t const   )531214540UL,        (z_crc_t const   )2060323956UL,        (z_crc_t const   )2489432422UL,        (z_crc_t const   )4043703774UL}};
#line 190 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
z_crc_t const   *get_crc_table(void) 
{ 


  {
#line 196
  return ((z_crc_t const   *)(crc_table));
}
}
#line 204 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
unsigned long crc32(unsigned long crc , unsigned char const   *buf , uInt len ) 
{ 
  z_crc_t endian ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 209
  if ((unsigned long )buf == (unsigned long )((unsigned char const   *)0)) {
#line 209
    return (0UL);
  }
#line 217
  if (sizeof(void *) == sizeof(ptrdiff_t )) {
#line 220
    endian = (z_crc_t )1;
#line 221
    if (*((unsigned char *)(& endian))) {
      {
#line 222
      tmp = crc32_little(crc, buf, len);
      }
#line 222
      return (tmp);
    } else {
      {
#line 224
      tmp___0 = crc32_big(crc, buf, len);
      }
#line 224
      return (tmp___0);
    }
  }
#line 227
  crc ^= 4294967295UL;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (len >= 8U)) {
#line 228
      goto while_break;
    }
#line 229
    tmp___1 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___1) & 255] ^ (crc >> 8);
#line 229
    tmp___2 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___2) & 255] ^ (crc >> 8);
#line 229
    tmp___3 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___3) & 255] ^ (crc >> 8);
#line 229
    tmp___4 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___4) & 255] ^ (crc >> 8);
#line 229
    tmp___5 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___5) & 255] ^ (crc >> 8);
#line 229
    tmp___6 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___6) & 255] ^ (crc >> 8);
#line 229
    tmp___7 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___7) & 255] ^ (crc >> 8);
#line 229
    tmp___8 = buf;
#line 229
    buf ++;
#line 229
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___8) & 255] ^ (crc >> 8);
#line 230
    len -= 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  if (len) {
    {
#line 232
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 233
      tmp___9 = buf;
#line 233
      buf ++;
#line 233
      crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___9) & 255] ^ (crc >> 8);
#line 232
      len --;
#line 232
      if (! len) {
#line 232
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 235
  return (crc ^ 4294967295UL);
}
}
#line 247 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
static unsigned long crc32_little(unsigned long crc , unsigned char const   *buf ,
                                  unsigned int len ) 
{ 
  register z_crc_t c ;
  register z_crc_t const   *buf4 ;
  unsigned char const   *tmp ;
  z_crc_t const   *tmp___0 ;
  z_crc_t const   *tmp___1 ;
  z_crc_t const   *tmp___2 ;
  z_crc_t const   *tmp___3 ;
  z_crc_t const   *tmp___4 ;
  z_crc_t const   *tmp___5 ;
  z_crc_t const   *tmp___6 ;
  z_crc_t const   *tmp___7 ;
  z_crc_t const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 255
  c = (z_crc_t )crc;
#line 256
  c = ~ c;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (len) {
#line 257
      if (! ((ptrdiff_t )buf & 3L)) {
#line 257
        goto while_break;
      }
    } else {
#line 257
      goto while_break;
    }
#line 258
    tmp = buf;
#line 258
    buf ++;
#line 258
    c = (z_crc_t )(crc_table[0][(c ^ (unsigned int )*tmp) & 255U] ^ (unsigned int const   )(c >> 8));
#line 259
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  buf4 = (z_crc_t const   *)((void const   *)buf);
  {
#line 263
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 263
    if (! (len >= 32U)) {
#line 263
      goto while_break___0;
    }
#line 264
    tmp___0 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___0;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 264
    tmp___1 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___1;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 264
    tmp___2 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___2;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 264
    tmp___3 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___3;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 264
    tmp___4 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___4;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 264
    tmp___5 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___5;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 264
    tmp___6 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___6;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 264
    tmp___7 = buf4;
#line 264
    buf4 ++;
#line 264
    c ^= (unsigned int )*tmp___7;
#line 264
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 265
    len -= 32U;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 267
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 267
    if (! (len >= 4U)) {
#line 267
      goto while_break___1;
    }
#line 268
    tmp___8 = buf4;
#line 268
    buf4 ++;
#line 268
    c ^= (unsigned int )*tmp___8;
#line 268
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 269
    len -= 4U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 271
  buf = (unsigned char const   *)buf4;
#line 273
  if (len) {
    {
#line 273
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 274
      tmp___9 = buf;
#line 274
      buf ++;
#line 274
      c = (z_crc_t )(crc_table[0][(c ^ (unsigned int )*tmp___9) & 255U] ^ (unsigned int const   )(c >> 8));
#line 273
      len --;
#line 273
      if (! len) {
#line 273
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 276
  c = ~ c;
#line 277
  return ((unsigned long )c);
}
}
#line 287 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
static unsigned long crc32_big(unsigned long crc , unsigned char const   *buf , unsigned int len ) 
{ 
  register z_crc_t c ;
  register z_crc_t const   *buf4 ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;

  {
#line 295
  c = (((((z_crc_t )crc >> 24) & 255U) + (((z_crc_t )crc >> 8) & 65280U)) + (((z_crc_t )crc & 65280U) << 8)) + (((z_crc_t )crc & 255U) << 24);
#line 296
  c = ~ c;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (len) {
#line 297
      if (! ((ptrdiff_t )buf & 3L)) {
#line 297
        goto while_break;
      }
    } else {
#line 297
      goto while_break;
    }
#line 298
    tmp = buf;
#line 298
    buf ++;
#line 298
    c = (z_crc_t )(crc_table[4][(c >> 24) ^ (unsigned int )*tmp] ^ (unsigned int const   )(c << 8));
#line 299
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  buf4 = (z_crc_t const   *)((void const   *)buf);
#line 303
  buf4 --;
  {
#line 304
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 304
    if (! (len >= 32U)) {
#line 304
      goto while_break___0;
    }
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 305
    buf4 ++;
#line 305
    c ^= (unsigned int )*buf4;
#line 305
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 306
    len -= 32U;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 308
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 308
    if (! (len >= 4U)) {
#line 308
      goto while_break___1;
    }
#line 309
    buf4 ++;
#line 309
    c ^= (unsigned int )*buf4;
#line 309
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 310
    len -= 4U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 312
  buf4 ++;
#line 313
  buf = (unsigned char const   *)buf4;
#line 315
  if (len) {
    {
#line 315
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 316
      tmp___0 = buf;
#line 316
      buf ++;
#line 316
      c = (z_crc_t )(crc_table[4][(c >> 24) ^ (unsigned int )*tmp___0] ^ (unsigned int const   )(c << 8));
#line 315
      len --;
#line 315
      if (! len) {
#line 315
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 318
  c = ~ c;
#line 319
  return ((unsigned long )(((((c >> 24) & 255U) + ((c >> 8) & 65280U)) + ((c & 65280U) << 8)) + ((c & 255U) << 24)));
}
}
#line 327 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
static unsigned long gf2_matrix_times(unsigned long *mat , unsigned long vec ) 
{ 
  unsigned long sum ;

  {
#line 333
  sum = 0UL;
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 334
    if (! vec) {
#line 334
      goto while_break;
    }
#line 335
    if (vec & 1UL) {
#line 336
      sum ^= *mat;
    }
#line 337
    vec >>= 1;
#line 338
    mat ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return (sum);
}
}
#line 344 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
static void gf2_matrix_square(unsigned long *square , unsigned long *mat ) 
{ 
  int n ;

  {
#line 350
  n = 0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (n < 32)) {
#line 350
      goto while_break;
    }
    {
#line 351
    *(square + n) = gf2_matrix_times(mat, *(mat + n));
#line 350
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  return;
}
}
#line 355 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
static uLong crc32_combine_(uLong crc1 , uLong crc2 , off64_t len2 ) 
{ 
  int n ;
  unsigned long row ;
  unsigned long even[32] ;
  unsigned long odd[32] ;

  {
#line 366
  if (len2 <= 0L) {
#line 367
    return (crc1);
  }
#line 370
  odd[0] = 3988292384UL;
#line 371
  row = 1UL;
#line 372
  n = 1;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (n < 32)) {
#line 372
      goto while_break;
    }
#line 373
    odd[n] = row;
#line 374
    row <<= 1;
#line 372
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 378
  gf2_matrix_square(even, odd);
#line 381
  gf2_matrix_square(odd, even);
  }
  {
#line 385
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 387
    gf2_matrix_square(even, odd);
    }
#line 388
    if (len2 & 1L) {
      {
#line 389
      crc1 = gf2_matrix_times(even, crc1);
      }
    }
#line 390
    len2 >>= 1;
#line 393
    if (len2 == 0L) {
#line 394
      goto while_break___0;
    }
    {
#line 397
    gf2_matrix_square(odd, even);
    }
#line 398
    if (len2 & 1L) {
      {
#line 399
      crc1 = gf2_matrix_times(odd, crc1);
      }
    }
#line 400
    len2 >>= 1;
#line 385
    if (! (len2 != 0L)) {
#line 385
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 406
  crc1 ^= crc2;
#line 407
  return (crc1);
}
}
#line 411 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
uLong crc32_combine(uLong crc1 , uLong crc2 , off_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 416
  tmp = crc32_combine_(crc1, crc2, len2);
  }
#line 416
  return (tmp);
}
}
#line 419 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/crc32.c"
uLong crc32_combine64(uLong crc1 , uLong crc2 , off64_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 424
  tmp = crc32_combine_(crc1, crc2, len2);
  }
#line 424
  return (tmp);
}
}
#line 1178 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1192
int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
              int level ) ;
#line 1208
uLong compressBound(uLong sourceLen ) ;
#line 22 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/compress.c"
int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
              int level ) 
{ 
  z_stream stream ;
  int err ;
  int tmp ;

  {
#line 32
  stream.next_in = (Bytef *)source;
#line 33
  stream.avail_in = (uInt )sourceLen;
#line 38
  stream.next_out = dest;
#line 39
  stream.avail_out = (uInt )*destLen;
#line 40
  if ((uLong )stream.avail_out != *destLen) {
#line 40
    return (-5);
  }
  {
#line 42
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 43
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 44
  stream.opaque = (voidpf )0;
#line 46
  err = deflateInit_(& stream, level, "1.2.8-optipng", (int )sizeof(z_stream ));
  }
#line 47
  if (err != 0) {
#line 47
    return (err);
  }
  {
#line 49
  err = deflate(& stream, 4);
  }
#line 50
  if (err != 1) {
    {
#line 51
    deflateEnd(& stream);
    }
#line 52
    if (err == 0) {
#line 52
      tmp = -5;
    } else {
#line 52
      tmp = err;
    }
#line 52
    return (tmp);
  }
  {
#line 54
  *destLen = stream.total_out;
#line 56
  err = deflateEnd(& stream);
  }
#line 57
  return (err);
}
}
#line 62 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/compress.c"
int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) 
{ 
  int tmp ;

  {
  {
#line 68
  tmp = compress2(dest, destLen, source, sourceLen, -1);
  }
#line 68
  return (tmp);
}
}
#line 75 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/compress.c"
uLong compressBound(uLong sourceLen ) 
{ 


  {
#line 78
  return ((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + 13UL);
}
}
#line 1714 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/zlib.h"
uLong adler32_combine64(uLong adler1 , uLong adler2 , off64_t len2 ) ;
#line 1747
uLong adler32_combine(uLong adler1 , uLong adler2 , off_t len2 ) ;
#line 12 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/adler32.c"
static uLong adler32_combine_(uLong adler1 , uLong adler2 , off64_t len2 ) ;
#line 65 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/adler32.c"
uLong adler32(uLong adler , Bytef const   *buf , uInt len ) 
{ 
  unsigned long sum2 ;
  unsigned int n ;
  Bytef const   *tmp ;
  uInt tmp___0 ;
  Bytef const   *tmp___1 ;
  uInt tmp___2 ;

  {
#line 74
  sum2 = (adler >> 16) & 65535UL;
#line 75
  adler &= 65535UL;
#line 78
  if (len == 1U) {
#line 79
    adler += (uLong )*(buf + 0);
#line 80
    if (adler >= 65521UL) {
#line 81
      adler -= 65521UL;
    }
#line 82
    sum2 += adler;
#line 83
    if (sum2 >= 65521UL) {
#line 84
      sum2 -= 65521UL;
    }
#line 85
    return (adler | (sum2 << 16));
  }
#line 89
  if ((unsigned long )buf == (unsigned long )((Bytef const   *)0)) {
#line 90
    return ((uLong )1L);
  }
#line 93
  if (len < 16U) {
    {
#line 94
    while (1) {
      while_continue: /* CIL Label */ ;
#line 94
      tmp___0 = len;
#line 94
      len --;
#line 94
      if (! tmp___0) {
#line 94
        goto while_break;
      }
#line 95
      tmp = buf;
#line 95
      buf ++;
#line 95
      adler += (uLong )*tmp;
#line 96
      sum2 += adler;
    }
    while_break: /* CIL Label */ ;
    }
#line 98
    if (adler >= 65521UL) {
#line 99
      adler -= 65521UL;
    }
#line 100
    sum2 %= 65521UL;
#line 101
    return (adler | (sum2 << 16));
  }
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (! (len >= 5552U)) {
#line 105
      goto while_break___0;
    }
#line 106
    len -= 5552U;
#line 107
    n = 347U;
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 109
      adler += (uLong )*(buf + 0);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 1);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 2);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 3);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 4);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 5);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 6);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 7);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 8);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 9);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 10);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 11);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 12);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 13);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 14);
#line 109
      sum2 += adler;
#line 109
      adler += (uLong )*(buf + 15);
#line 109
      sum2 += adler;
#line 110
      buf += 16;
#line 108
      n --;
#line 108
      if (! n) {
#line 108
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 112
    adler %= 65521UL;
#line 113
    sum2 %= 65521UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 117
  if (len) {
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 118
      if (! (len >= 16U)) {
#line 118
        goto while_break___2;
      }
#line 119
      len -= 16U;
#line 120
      adler += (uLong )*(buf + 0);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 1);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 2);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 3);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 4);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 5);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 6);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 7);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 8);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 9);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 10);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 11);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 12);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 13);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 14);
#line 120
      sum2 += adler;
#line 120
      adler += (uLong )*(buf + 15);
#line 120
      sum2 += adler;
#line 121
      buf += 16;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 123
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 123
      tmp___2 = len;
#line 123
      len --;
#line 123
      if (! tmp___2) {
#line 123
        goto while_break___3;
      }
#line 124
      tmp___1 = buf;
#line 124
      buf ++;
#line 124
      adler += (uLong )*tmp___1;
#line 125
      sum2 += adler;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 127
    adler %= 65521UL;
#line 128
    sum2 %= 65521UL;
  }
#line 132
  return (adler | (sum2 << 16));
}
}
#line 136 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/adler32.c"
static uLong adler32_combine_(uLong adler1 , uLong adler2 , off64_t len2 ) 
{ 
  unsigned long sum1 ;
  unsigned long sum2 ;
  unsigned int rem ;

  {
#line 146
  if (len2 < 0L) {
#line 147
    return (4294967295UL);
  }
#line 150
  len2 %= 65521L;
#line 151
  rem = (unsigned int )len2;
#line 152
  sum1 = adler1 & 65535UL;
#line 153
  sum2 = (unsigned long )rem * sum1;
#line 154
  sum2 %= 65521UL;
#line 155
  sum1 += ((adler2 & 65535UL) + 65521UL) - 1UL;
#line 156
  sum2 += ((((adler1 >> 16) & 65535UL) + ((adler2 >> 16) & 65535UL)) + 65521UL) - (unsigned long )rem;
#line 157
  if (sum1 >= 65521UL) {
#line 157
    sum1 -= 65521UL;
  }
#line 158
  if (sum1 >= 65521UL) {
#line 158
    sum1 -= 65521UL;
  }
#line 159
  if (sum2 >= (unsigned long )(65521 << 1)) {
#line 159
    sum2 -= (unsigned long )(65521 << 1);
  }
#line 160
  if (sum2 >= 65521UL) {
#line 160
    sum2 -= 65521UL;
  }
#line 161
  return (sum1 | (sum2 << 16));
}
}
#line 165 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/adler32.c"
uLong adler32_combine(uLong adler1 , uLong adler2 , off_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 170
  tmp = adler32_combine_(adler1, adler2, len2);
  }
#line 170
  return (tmp);
}
}
#line 173 "/home/khheo/project/benchmark/optipng-0.7.6/src/zlib/adler32.c"
uLong adler32_combine64(uLong adler1 , uLong adler2 , off64_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 178
  tmp = adler32_combine_(adler1, adler2, len2);
  }
#line 178
  return (tmp);
}
}
#line 992 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
void png_write_sig(png_structrp png_ptr ) ;
#line 995
void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_string , png_const_bytep data ,
                     png_size_t length ) ;
#line 999
void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_string , png_uint_32 length ) ;
#line 1003
void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) ;
#line 1007
void png_write_chunk_end(png_structrp png_ptr ) ;
#line 1366
void png_write_flush(png_structrp png_ptr ) ;
#line 1722
png_voidp __attribute__((__malloc__))  png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1725
png_voidp __attribute__((__malloc__))  png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1733
void png_free(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1779
 __attribute__((__noreturn__)) void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1795
void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 2545
void png_save_uint_32(png_bytep buf , png_uint_32 i ) ;
#line 2556
void png_save_uint_16(png_bytep buf , unsigned int i ) ;
#line 855 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
void png_zstream_error(png_structrp png_ptr , int ret ) ;
#line 862
void png_free_buffer_list(png_structrp png_ptr , png_compression_bufferp *listp ) ;
#line 957
void png_reset_crc(png_structrp png_ptr ) ;
#line 960
void png_write_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) ;
#line 990
void png_calculate_crc(png_structrp png_ptr , png_const_bytep ptr , png_size_t length ) ;
#line 1002
void png_write_IHDR(png_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type ) ;
#line 1006
void png_write_PLTE(png_structrp png_ptr , png_const_colorp palette , png_uint_32 num_pal ) ;
#line 1009
void png_compress_IDAT(png_structrp png_ptr , png_const_bytep input , png_alloc_size_t input_len ,
                       int flush ) ;
#line 1013
void png_write_IEND(png_structrp png_ptr ) ;
#line 1021
void png_write_sBIT(png_structrp png_ptr , png_const_color_8p sbit , int color_type ) ;
#line 1051
void png_write_tRNS(png_structrp png_ptr , png_const_bytep trans_alpha , png_const_color_16p tran ,
                    int num_trans , int color_type ) ;
#line 1057
void png_write_bKGD(png_structrp png_ptr , png_const_color_16p back , int color_type ) ;
#line 1062
void png_write_hIST(png_structrp png_ptr , png_const_uint_16p hist , int num_hist ) ;
#line 1116
void png_write_finish_row(png_structrp png_ptr ) ;
#line 1120
void png_write_start_row(png_structrp png_ptr ) ;
#line 1167
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass ) ;
#line 1193
void png_write_find_filter(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1547
size_t png_safecat(png_charp buffer___0 , size_t bufsize , size_t pos , png_const_charp string ) ;
#line 1630
void png_app_warning(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 23 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_save_uint_32(png_bytep buf , png_uint_32 i ) 
{ 


  {
#line 26
  *(buf + 0) = (png_byte )(i >> 24);
#line 27
  *(buf + 1) = (png_byte )(i >> 16);
#line 28
  *(buf + 2) = (png_byte )(i >> 8);
#line 29
  *(buf + 3) = (png_byte )i;
#line 30
  return;
}
}
#line 36 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_save_uint_16(png_bytep buf , unsigned int i ) 
{ 


  {
#line 39
  *(buf + 0) = (png_byte )(i >> 8);
#line 40
  *(buf + 1) = (png_byte )i;
#line 41
  return;
}
}
#line 50 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_sig(png_structrp png_ptr ) 
{ 
  png_byte png_signature[8] ;

  {
  {
#line 53
  png_signature[0] = (png_byte )137;
#line 53
  png_signature[1] = (png_byte )80;
#line 53
  png_signature[2] = (png_byte )78;
#line 53
  png_signature[3] = (png_byte )71;
#line 53
  png_signature[4] = (png_byte )13;
#line 53
  png_signature[5] = (png_byte )10;
#line 53
  png_signature[6] = (png_byte )26;
#line 53
  png_signature[7] = (png_byte )10;
#line 57
  png_ptr->io_state = (png_uint_32 )18;
#line 61
  png_write_data(png_ptr, (png_const_bytep )(& png_signature[png_ptr->sig_bytes]),
                 (png_size_t )(8 - (int )png_ptr->sig_bytes));
  }
#line 64
  if ((int )png_ptr->sig_bytes < 3) {
#line 65
    png_ptr->mode |= 4096U;
  }
#line 66
  return;
}
}
#line 72 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static void png_write_chunk_header(png_structrp png_ptr , png_uint_32 chunk_name ,
                                   png_uint_32 length ) 
{ 
  png_byte buf[8] ;

  {
#line 83
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 84
    return;
  }
  {
#line 90
  png_ptr->io_state = (png_uint_32 )34;
#line 94
  png_save_uint_32(buf, length);
#line 95
  png_save_uint_32(buf + 4, chunk_name);
#line 96
  png_write_data(png_ptr, (png_const_bytep )(buf), (png_size_t )8);
#line 99
  png_ptr->chunk_name = chunk_name;
#line 102
  png_reset_crc(png_ptr);
#line 104
  png_calculate_crc(png_ptr, (png_const_bytep )(buf + 4), (png_size_t )4);
#line 110
  png_ptr->io_state = (png_uint_32 )66;
  }
#line 112
  return;
}
}
#line 114 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_string , png_uint_32 length ) 
{ 


  {
  {
#line 118
  png_write_chunk_header(png_ptr, ((((png_uint_32 )(255 & (int )*(chunk_string + 0)) << 24) | ((png_uint_32 )(255 & (int )*(chunk_string + 1)) << 16)) | ((png_uint_32 )(255 & (int )*(chunk_string + 2)) << 8)) | (png_uint_32 )(255 & (int )*(chunk_string + 3)),
                         length);
  }
#line 119
  return;
}
}
#line 126 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) 
{ 


  {
#line 131
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 132
    return;
  }
#line 134
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 134
    if (length > 0UL) {
      {
#line 136
      png_write_data(png_ptr, data, length);
#line 141
      png_calculate_crc(png_ptr, data, length);
      }
    }
  }
#line 143
  return;
}
}
#line 146 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_chunk_end(png_structrp png_ptr ) 
{ 
  png_byte buf[4] ;

  {
#line 151
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 151
    return;
  }
  {
#line 157
  png_ptr->io_state = (png_uint_32 )130;
#line 161
  png_save_uint_32(buf, png_ptr->crc);
#line 163
  png_write_data(png_ptr, (png_const_bytep )(buf), (png_size_t )4);
  }
#line 164
  return;
}
}
#line 175 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static void png_write_complete_chunk(png_structrp png_ptr , png_uint_32 chunk_name ,
                                     png_const_bytep data , png_size_t length ) 
{ 


  {
#line 179
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 180
    return;
  }
#line 183
  if (length > 2147483647UL) {
    {
#line 184
    png_error((png_const_structrp )png_ptr, "length exceeds PNG maximum");
    }
  }
  {
#line 186
  png_write_chunk_header(png_ptr, chunk_name, (png_uint_32 )length);
#line 187
  png_write_chunk_data(png_ptr, data, length);
#line 188
  png_write_chunk_end(png_ptr);
  }
#line 189
  return;
}
}
#line 192 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_string , png_const_bytep data ,
                     png_size_t length ) 
{ 


  {
  {
#line 196
  png_write_complete_chunk(png_ptr, ((((png_uint_32 )(255 & (int )*(chunk_string + 0)) << 24) | ((png_uint_32 )(255 & (int )*(chunk_string + 1)) << 16)) | ((png_uint_32 )(255 & (int )*(chunk_string + 2)) << 8)) | (png_uint_32 )(255 & (int )*(chunk_string + 3)),
                           data, length);
  }
#line 198
  return;
}
}
#line 204 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_alloc_size_t png_image_size(png_structrp png_ptr ) 
{ 
  png_uint_32 h ;
  png_uint_32 w ;
  unsigned int pd ;
  png_alloc_size_t cb_base ;
  int pass ;
  png_uint_32 pw ;
  int tmp ;
  int tmp___0 ;
  png_size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 210
  h = png_ptr->height;
#line 212
  if (png_ptr->rowbytes < 32768UL) {
#line 212
    if (h < 32768U) {
#line 214
      if ((int )png_ptr->interlaced != 0) {
#line 219
        w = png_ptr->width;
#line 220
        pd = (unsigned int )png_ptr->pixel_depth;
#line 224
        cb_base = (png_alloc_size_t )0;
#line 224
        pass = 0;
        {
#line 224
        while (1) {
          while_continue: /* CIL Label */ ;
#line 224
          if (! (pass <= 6)) {
#line 224
            goto while_break;
          }
#line 226
          if (pass > 1) {
#line 226
            tmp = (7 - pass) >> 1;
          } else {
#line 226
            tmp = 3;
          }
#line 226
          if (pass > 1) {
#line 226
            tmp___0 = (7 - pass) >> 1;
          } else {
#line 226
            tmp___0 = 3;
          }
#line 226
          pw = (w + (png_uint_32 )(((1 << tmp) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___0;
#line 228
          if (pw > 0U) {
#line 229
            if (pd >= 8U) {
#line 229
              tmp___1 = (png_size_t )pw * ((png_size_t )pd >> 3);
            } else {
#line 229
              tmp___1 = ((png_size_t )pw * (png_size_t )pd + 7UL) >> 3;
            }
#line 229
            if (pass > 2) {
#line 229
              tmp___2 = (8 - pass) >> 1;
            } else {
#line 229
              tmp___2 = 3;
            }
#line 229
            if (pass > 2) {
#line 229
              tmp___3 = (8 - pass) >> 1;
            } else {
#line 229
              tmp___3 = 3;
            }
#line 229
            cb_base += (tmp___1 + 1UL) * (png_size_t )((h + (png_uint_32 )(((1 << tmp___2) - 1) - (((1 & ~ pass) << (3 - (pass >> 1))) & 7))) >> tmp___3);
          }
#line 224
          pass ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 232
        return (cb_base);
      } else {
#line 236
        return ((png_ptr->rowbytes + 1UL) * (png_size_t )h);
      }
    } else {
#line 240
      return ((png_alloc_size_t )4294967295U);
    }
  } else {
#line 240
    return ((png_alloc_size_t )4294967295U);
  }
}
}
#line 250 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static void optimize_cmf(png_bytep data , png_alloc_size_t data_size ) 
{ 
  unsigned int z_cmf ;
  unsigned int z_cinfo ;
  unsigned int half_z_window_size ;
  unsigned int tmp ;

  {
#line 256
  if (data_size <= 16384UL) {
#line 258
    z_cmf = (unsigned int )*(data + 0);
#line 260
    if ((z_cmf & 15U) == 8U) {
#line 260
      if ((z_cmf & 240U) <= 112U) {
#line 265
        z_cinfo = z_cmf >> 4;
#line 266
        half_z_window_size = 1U << (z_cinfo + 7U);
#line 268
        if (data_size <= (png_alloc_size_t )half_z_window_size) {
          {
#line 272
          while (1) {
            while_continue: /* CIL Label */ ;
#line 274
            half_z_window_size >>= 1;
#line 275
            z_cinfo --;
#line 272
            if (z_cinfo > 0U) {
#line 272
              if (! (data_size <= (png_alloc_size_t )half_z_window_size)) {
#line 272
                goto while_break;
              }
            } else {
#line 272
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 279
          z_cmf = (z_cmf & 15U) | (z_cinfo << 4);
#line 281
          *(data + 0) = (png_byte )z_cmf;
#line 282
          tmp = (unsigned int )((int )*(data + 1) & 224);
#line 283
          tmp += 31U - ((z_cmf << 8) + tmp) % 31U;
#line 284
          *(data + 1) = (png_byte )tmp;
        }
      }
    }
  }
#line 288
  return;
}
}
#line 292 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static int png_deflate_claim(png_structrp png_ptr , png_uint_32 owner , png_alloc_size_t data_size ) 
{ 
  char msg___0[64] ;
  int level ;
  int method ;
  int windowBits ;
  int memLevel ;
  int strategy ;
  int ret ;
  unsigned int half_window_size ;
  int tmp ;

  {
#line 296
  if (png_ptr->zowner != 0U) {
    {
#line 301
    msg___0[0] = (char )((owner >> 24) & 255U);
#line 301
    msg___0[1] = (char )((owner >> 16) & 255U);
#line 301
    msg___0[2] = (char )((owner >> 8) & 255U);
#line 301
    msg___0[3] = (char )(owner & 255U);
#line 302
    msg___0[4] = (char )':';
#line 303
    msg___0[5] = (char )' ';
#line 304
    *((msg___0 + 6) + 0) = (char )((png_ptr->zowner >> 24) & 255U);
#line 304
    *((msg___0 + 6) + 1) = (char )((png_ptr->zowner >> 16) & 255U);
#line 304
    *((msg___0 + 6) + 2) = (char )((png_ptr->zowner >> 8) & 255U);
#line 304
    *((msg___0 + 6) + 3) = (char )(png_ptr->zowner & 255U);
#line 309
    png_safecat(msg___0, sizeof(msg___0), (size_t )10, " using zstream");
#line 312
    png_warning((png_const_structrp )png_ptr, (png_const_charp )(msg___0));
    }
#line 315
    if (png_ptr->zowner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 317
      png_ptr->zstream.msg = "in use by IDAT";
#line 318
      return (-2);
    }
#line 321
    png_ptr->zowner = (png_uint_32 )0;
  }
#line 328
  level = png_ptr->zlib_level;
#line 329
  method = png_ptr->zlib_method;
#line 330
  windowBits = png_ptr->zlib_window_bits;
#line 331
  memLevel = png_ptr->zlib_mem_level;
#line 335
  if (owner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 337
    if ((png_ptr->flags & 1U) != 0U) {
#line 338
      strategy = png_ptr->zlib_strategy;
    } else
#line 340
    if ((int )png_ptr->do_filter != 8) {
#line 341
      strategy = 1;
    } else {
#line 344
      strategy = 0;
    }
  } else {
#line 361
    strategy = 0;
  }
#line 372
  if (data_size <= 16384UL) {
#line 379
    half_window_size = 1U << (windowBits - 1);
    {
#line 381
    while (1) {
      while_continue: /* CIL Label */ ;
#line 381
      if (! (data_size + 262UL <= (png_alloc_size_t )half_window_size)) {
#line 381
        goto while_break;
      }
#line 383
      half_window_size >>= 1;
#line 384
      windowBits --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 389
  if ((png_ptr->flags & 2U) != 0U) {
#line 389
    if (png_ptr->zlib_set_level != level) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_method != method) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_window_bits != windowBits) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_mem_level != memLevel) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_strategy != strategy) {
      _L: /* CIL Label */ 
      {
#line 396
      tmp = deflateEnd(& png_ptr->zstream);
      }
#line 396
      if (tmp != 0) {
        {
#line 397
        png_warning((png_const_structrp )png_ptr, "deflateEnd failed (ignored)");
        }
      }
#line 399
      png_ptr->flags &= 4294967293U;
    }
  }
#line 405
  png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 406
  png_ptr->zstream.avail_in = (uInt )0;
#line 407
  png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 408
  png_ptr->zstream.avail_out = (uInt )0;
#line 413
  if ((png_ptr->flags & 2U) != 0U) {
    {
#line 414
    ret = deflateReset(& png_ptr->zstream);
    }
  } else {
    {
#line 418
    ret = deflateInit2_(& png_ptr->zstream, level, method, windowBits, memLevel, strategy,
                        "1.2.8-optipng", (int )sizeof(z_stream ));
    }
#line 421
    if (ret == 0) {
#line 422
      png_ptr->flags |= 2U;
    }
  }
#line 428
  if (ret == 0) {
#line 429
    png_ptr->zowner = owner;
  } else {
    {
#line 432
    png_zstream_error(png_ptr, ret);
    }
  }
#line 434
  return (ret);
}
}
#line 439 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_free_buffer_list(png_structrp png_ptr , png_compression_bufferp *listp ) 
{ 
  png_compression_bufferp list ;
  png_compression_bufferp next ;

  {
#line 442
  list = *listp;
#line 444
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 446
    *listp = (png_compression_bufferp )((void *)0);
    {
#line 448
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 450
      next = list->next;
#line 452
      png_free((png_const_structrp )png_ptr, (png_voidp )list);
#line 453
      list = next;
      }
#line 448
      if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 448
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 457
  return;
}
}
#line 672 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_IHDR(png_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type ) 
{ 
  png_byte buf[13] ;

  {
  {
#line 684
  if (color_type == 0) {
#line 684
    goto case_0;
  }
#line 702
  if (color_type == 2) {
#line 702
    goto case_2___0;
  }
#line 713
  if (color_type == 3) {
#line 713
    goto case_3;
  }
#line 728
  if (color_type == 4) {
#line 728
    goto case_4___1;
  }
#line 735
  if (color_type == 6) {
#line 735
    goto case_6;
  }
#line 746
  goto switch_default___1;
  case_0: /* CIL Label */ 
  {
#line 692
  if (bit_depth == 16) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 8) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 4) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 2) {
#line 692
    goto case_16;
  }
#line 692
  if (bit_depth == 1) {
#line 692
    goto case_16;
  }
#line 696
  goto switch_default;
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 694
  png_ptr->channels = (png_byte )1;
#line 694
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 697
  png_error((png_const_structrp )png_ptr, "Invalid bit depth for grayscale image");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 700
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 704
  if (bit_depth != 8) {
#line 704
    if (bit_depth != 16) {
      {
#line 708
      png_error((png_const_structrp )png_ptr, "Invalid bit depth for RGB image");
      }
    }
  }
#line 710
  png_ptr->channels = (png_byte )3;
#line 711
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 719
  if (bit_depth == 8) {
#line 719
    goto case_8___0;
  }
#line 719
  if (bit_depth == 4) {
#line 719
    goto case_8___0;
  }
#line 719
  if (bit_depth == 2) {
#line 719
    goto case_8___0;
  }
#line 719
  if (bit_depth == 1) {
#line 719
    goto case_8___0;
  }
#line 723
  goto switch_default___0;
  case_8___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 720
  png_ptr->channels = (png_byte )1;
#line 721
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 724
  png_error((png_const_structrp )png_ptr, "Invalid bit depth for paletted image");
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 726
  goto switch_break;
  case_4___1: /* CIL Label */ 
#line 729
  if (bit_depth != 8) {
#line 729
    if (bit_depth != 16) {
      {
#line 730
      png_error((png_const_structrp )png_ptr, "Invalid bit depth for grayscale+alpha image");
      }
    }
  }
#line 732
  png_ptr->channels = (png_byte )2;
#line 733
  goto switch_break;
  case_6: /* CIL Label */ 
#line 737
  if (bit_depth != 8) {
#line 737
    if (bit_depth != 16) {
      {
#line 741
      png_error((png_const_structrp )png_ptr, "Invalid bit depth for RGBA image");
      }
    }
  }
#line 743
  png_ptr->channels = (png_byte )4;
#line 744
  goto switch_break;
  switch_default___1: /* CIL Label */ 
  {
#line 747
  png_error((png_const_structrp )png_ptr, "Invalid image color type specified");
  }
  switch_break: /* CIL Label */ ;
  }
#line 750
  if (compression_type != 0) {
    {
#line 752
    png_warning((png_const_structrp )png_ptr, "Invalid compression type specified");
#line 753
    compression_type = 0;
    }
  }
#line 765
  if (filter_type != 0) {
    {
#line 775
    png_warning((png_const_structrp )png_ptr, "Invalid filter type specified");
#line 776
    filter_type = 0;
    }
  }
#line 780
  if (interlace_type != 0) {
#line 780
    if (interlace_type != 1) {
      {
#line 783
      png_warning((png_const_structrp )png_ptr, "Invalid interlace type specified");
#line 784
      interlace_type = 1;
      }
    }
  }
#line 791
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 792
  png_ptr->color_type = (png_byte )color_type;
#line 793
  png_ptr->interlaced = (png_byte )interlace_type;
#line 797
  png_ptr->compression_type = (png_byte )compression_type;
#line 798
  png_ptr->width = width;
#line 799
  png_ptr->height = height;
#line 801
  png_ptr->pixel_depth = (png_byte )(bit_depth * (int )png_ptr->channels);
#line 802
  if ((int )png_ptr->pixel_depth >= 8) {
#line 802
    png_ptr->rowbytes = (png_size_t )width * ((png_size_t )png_ptr->pixel_depth >> 3);
  } else {
#line 802
    png_ptr->rowbytes = ((png_size_t )width * (png_size_t )png_ptr->pixel_depth + 7UL) >> 3;
  }
  {
#line 804
  png_ptr->usr_width = png_ptr->width;
#line 805
  png_ptr->usr_bit_depth = png_ptr->bit_depth;
#line 806
  png_ptr->usr_channels = png_ptr->channels;
#line 809
  png_save_uint_32(buf, width);
#line 810
  png_save_uint_32(buf + 4, height);
#line 811
  buf[8] = (png_byte )bit_depth;
#line 812
  buf[9] = (png_byte )color_type;
#line 813
  buf[10] = (png_byte )compression_type;
#line 814
  buf[11] = (png_byte )filter_type;
#line 815
  buf[12] = (png_byte )interlace_type;
#line 818
  png_write_complete_chunk(png_ptr, (((73U << 24) | (72U << 16)) | (68U << 8)) | 82U,
                           (png_const_bytep )(buf), (png_size_t )13);
  }
#line 820
  if ((int )png_ptr->do_filter == 0) {
#line 822
    if ((int )png_ptr->color_type == 3) {
#line 824
      png_ptr->do_filter = (png_byte )8;
    } else
#line 822
    if ((int )png_ptr->bit_depth < 8) {
#line 824
      png_ptr->do_filter = (png_byte )8;
    } else {
#line 827
      png_ptr->do_filter = (png_byte )248;
    }
  }
#line 830
  png_ptr->mode = (png_uint_32 )1;
#line 831
  return;
}
}
#line 837 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_PLTE(png_structrp png_ptr , png_const_colorp palette , png_uint_32 num_pal ) 
{ 
  png_uint_32 max_palette_length ;
  png_uint_32 i ;
  png_const_colorp pal_ptr ;
  png_byte buf[3] ;

  {
#line 847
  if ((int )png_ptr->color_type == 3) {
#line 847
    max_palette_length = (png_uint_32 )(1 << (int )png_ptr->bit_depth);
  } else {
#line 847
    max_palette_length = (png_uint_32 )256;
  }
#line 850
  if (num_pal == 0U) {
#line 850
    goto _L;
  } else
#line 850
  if (num_pal > max_palette_length) {
    _L: /* CIL Label */ 
#line 856
    if ((int )png_ptr->color_type == 3) {
      {
#line 858
      png_error((png_const_structrp )png_ptr, "Invalid number of colors in palette");
      }
    } else {
      {
#line 863
      png_warning((png_const_structrp )png_ptr, "Invalid number of colors in palette");
      }
#line 864
      return;
    }
  }
#line 868
  if (((int )png_ptr->color_type & 2) == 0) {
    {
#line 870
    png_warning((png_const_structrp )png_ptr, "Ignoring request to write a PLTE chunk in grayscale PNG");
    }
#line 873
    return;
  }
  {
#line 876
  png_ptr->num_palette = (png_uint_16 )num_pal;
#line 879
  png_write_chunk_header(png_ptr, (((80U << 24) | (76U << 16)) | (84U << 8)) | 69U,
                         num_pal * 3U);
#line 882
  i = (png_uint_32 )0;
#line 882
  pal_ptr = palette;
  }
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! (i < num_pal)) {
#line 882
      goto while_break;
    }
    {
#line 884
    buf[0] = (png_byte )pal_ptr->red;
#line 885
    buf[1] = (png_byte )pal_ptr->green;
#line 886
    buf[2] = (png_byte )pal_ptr->blue;
#line 887
    png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (png_size_t )3);
#line 882
    i ++;
#line 882
    pal_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 905
  png_write_chunk_end(png_ptr);
#line 906
  png_ptr->mode |= 2U;
  }
#line 907
  return;
}
}
#line 926 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_compress_IDAT(png_structrp png_ptr , png_const_bytep input , png_alloc_size_t input_len ,
                       int flush ) 
{ 
  png_voidp __attribute__((__malloc__))  tmp ;
  png_alloc_size_t tmp___0 ;
  int tmp___1 ;
  int ret ;
  uInt avail ;
  int tmp___2 ;
  png_bytep data ;
  uInt size ;
  png_alloc_size_t tmp___3 ;
  png_bytep data___0 ;
  uInt size___0 ;
  png_alloc_size_t tmp___4 ;

  {
#line 930
  if (png_ptr->zowner != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 937
    if ((unsigned long )png_ptr->zbuffer_list == (unsigned long )((void *)0)) {
      {
#line 939
      tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )(& ((png_compression_buffer *)0)->output) + (unsigned long )png_ptr->zbuffer_size);
#line 939
      png_ptr->zbuffer_list = (png_compression_bufferp )tmp;
#line 941
      (png_ptr->zbuffer_list)->next = (struct png_compression_buffer *)((void *)0);
      }
    } else {
      {
#line 945
      png_free_buffer_list(png_ptr, & (png_ptr->zbuffer_list)->next);
      }
    }
    {
#line 948
    tmp___0 = png_image_size(png_ptr);
#line 948
    tmp___1 = png_deflate_claim(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                tmp___0);
    }
#line 948
    if (tmp___1 != 0) {
      {
#line 949
      png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
      }
    }
#line 954
    png_ptr->zstream.next_out = (png_ptr->zbuffer_list)->output;
#line 955
    png_ptr->zstream.avail_out = png_ptr->zbuffer_size;
  }
#line 962
  png_ptr->zstream.next_in = input;
#line 963
  png_ptr->zstream.avail_in = (uInt )0;
  {
#line 964
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    avail = (uInt )-1;
#line 971
    if ((png_alloc_size_t )avail > input_len) {
#line 972
      avail = (uInt )input_len;
    }
#line 974
    png_ptr->zstream.avail_in = avail;
#line 975
    input_len -= (png_alloc_size_t )avail;
#line 977
    if (input_len > 0UL) {
#line 977
      tmp___2 = 0;
    } else {
#line 977
      tmp___2 = flush;
    }
    {
#line 977
    ret = deflate(& png_ptr->zstream, tmp___2);
#line 980
    input_len += (png_alloc_size_t )png_ptr->zstream.avail_in;
#line 981
    png_ptr->zstream.avail_in = (uInt )0;
    }
#line 987
    if (png_ptr->zstream.avail_out == 0U) {
#line 989
      data = (png_ptr->zbuffer_list)->output;
#line 990
      size = png_ptr->zbuffer_size;
#line 996
      if ((png_ptr->mode & 4U) == 0U) {
#line 996
        if ((int )png_ptr->compression_type == 0) {
          {
#line 998
          tmp___3 = png_image_size(png_ptr);
#line 998
          optimize_cmf(data, tmp___3);
          }
        }
      }
      {
#line 1001
      png_write_complete_chunk(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                               (png_const_bytep )data, (png_size_t )size);
#line 1002
      png_ptr->mode |= 4U;
#line 1004
      png_ptr->zstream.next_out = data;
#line 1005
      png_ptr->zstream.avail_out = size;
      }
#line 1011
      if (ret == 0) {
#line 1011
        if (flush != 0) {
#line 1012
          goto __Cont;
        }
      }
    }
#line 1018
    if (ret == 0) {
#line 1024
      if (input_len == 0UL) {
#line 1026
        if (flush == 4) {
          {
#line 1027
          png_error((png_const_structrp )png_ptr, "Z_OK on Z_FINISH with output space");
          }
        }
#line 1029
        return;
      }
    } else
#line 1033
    if (ret == 1) {
#line 1033
      if (flush == 4) {
#line 1038
        data___0 = (png_ptr->zbuffer_list)->output;
#line 1039
        size___0 = png_ptr->zbuffer_size - png_ptr->zstream.avail_out;
#line 1042
        if ((png_ptr->mode & 4U) == 0U) {
#line 1042
          if ((int )png_ptr->compression_type == 0) {
            {
#line 1044
            tmp___4 = png_image_size(png_ptr);
#line 1044
            optimize_cmf(data___0, tmp___4);
            }
          }
        }
        {
#line 1047
        png_write_complete_chunk(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                 (png_const_bytep )data___0, (png_size_t )size___0);
#line 1048
        png_ptr->zstream.avail_out = (uInt )0;
#line 1049
        png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 1050
        png_ptr->mode |= 12U;
#line 1052
        png_ptr->zowner = (png_uint_32 )0;
        }
#line 1053
        return;
      } else {
        {
#line 1059
        png_zstream_error(png_ptr, ret);
#line 1060
        png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
        }
      }
    } else {
      {
#line 1059
      png_zstream_error(png_ptr, ret);
#line 1060
      png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1066 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_IEND(png_structrp png_ptr ) 
{ 


  {
  {
#line 1071
  png_write_complete_chunk(png_ptr, (((73U << 24) | (69U << 16)) | (78U << 8)) | 68U,
                           (png_const_bytep )((void *)0), (png_size_t )0);
#line 1072
  png_ptr->mode |= 16U;
  }
#line 1073
  return;
}
}
#line 1257 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_sBIT(png_structrp png_ptr , png_const_color_8p sbit , int color_type ) 
{ 
  png_byte buf[4] ;
  png_size_t size ;
  png_byte maxbits ;
  int tmp ;
  png_size_t tmp___0 ;

  {
#line 1266
  if ((color_type & 2) != 0) {
#line 1270
    if (color_type == 3) {
#line 1270
      tmp = 8;
    } else {
#line 1270
      tmp = (int )png_ptr->usr_bit_depth;
    }
#line 1270
    maxbits = (png_byte )tmp;
#line 1273
    if ((int const   )sbit->red == 0) {
      {
#line 1277
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1278
      return;
    } else
#line 1273
    if ((int const   )sbit->red > (int const   )maxbits) {
      {
#line 1277
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1278
      return;
    } else
#line 1273
    if ((int const   )sbit->green == 0) {
      {
#line 1277
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1278
      return;
    } else
#line 1273
    if ((int const   )sbit->green > (int const   )maxbits) {
      {
#line 1277
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1278
      return;
    } else
#line 1273
    if ((int const   )sbit->blue == 0) {
      {
#line 1277
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1278
      return;
    } else
#line 1273
    if ((int const   )sbit->blue > (int const   )maxbits) {
      {
#line 1277
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1278
      return;
    }
#line 1281
    buf[0] = (png_byte )sbit->red;
#line 1282
    buf[1] = (png_byte )sbit->green;
#line 1283
    buf[2] = (png_byte )sbit->blue;
#line 1284
    size = (png_size_t )3;
  } else {
#line 1289
    if ((int const   )sbit->gray == 0) {
      {
#line 1291
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1292
      return;
    } else
#line 1289
    if ((int const   )sbit->gray > (int const   )png_ptr->usr_bit_depth) {
      {
#line 1291
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1292
      return;
    }
#line 1295
    buf[0] = (png_byte )sbit->gray;
#line 1296
    size = (png_size_t )1;
  }
#line 1299
  if ((color_type & 4) != 0) {
#line 1301
    if ((int const   )sbit->alpha == 0) {
      {
#line 1303
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1304
      return;
    } else
#line 1301
    if ((int const   )sbit->alpha > (int const   )png_ptr->usr_bit_depth) {
      {
#line 1303
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1304
      return;
    }
#line 1307
    tmp___0 = size;
#line 1307
    size ++;
#line 1307
    buf[tmp___0] = (png_byte )sbit->alpha;
  }
  {
#line 1310
  png_write_complete_chunk(png_ptr, (((115U << 24) | (66U << 16)) | (73U << 8)) | 84U,
                           (png_const_bytep )(buf), size);
  }
#line 1311
  return;
}
}
#line 1342 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_tRNS(png_structrp png_ptr , png_const_bytep trans_alpha , png_const_color_16p tran ,
                    int num_trans , int color_type ) 
{ 
  png_byte buf[6] ;

  {
#line 1350
  if (color_type == 3) {
#line 1352
    if (num_trans <= 0) {
      {
#line 1354
      png_app_warning((png_const_structrp )png_ptr, "Invalid number of transparent colors specified");
      }
#line 1356
      return;
    } else
#line 1352
    if (num_trans > (int )png_ptr->num_palette) {
      {
#line 1354
      png_app_warning((png_const_structrp )png_ptr, "Invalid number of transparent colors specified");
      }
#line 1356
      return;
    }
    {
#line 1360
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             trans_alpha, (png_size_t )num_trans);
    }
  } else
#line 1364
  if (color_type == 0) {
#line 1367
    if ((int const   )tran->gray >= (int const   )(1 << (int )png_ptr->bit_depth)) {
      {
#line 1369
      png_app_warning((png_const_structrp )png_ptr, "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
      }
#line 1372
      return;
    }
    {
#line 1375
    png_save_uint_16(buf, (unsigned int )tran->gray);
#line 1376
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             (png_const_bytep )(buf), (png_size_t )2);
    }
  } else
#line 1379
  if (color_type == 2) {
    {
#line 1382
    png_save_uint_16(buf, (unsigned int )tran->red);
#line 1383
    png_save_uint_16(buf + 2, (unsigned int )tran->green);
#line 1384
    png_save_uint_16(buf + 4, (unsigned int )tran->blue);
    }
#line 1386
    if ((int )png_ptr->bit_depth == 8) {
#line 1386
      if ((((int )buf[0] | (int )buf[2]) | (int )buf[4]) != 0) {
        {
#line 1391
        png_app_warning((png_const_structrp )png_ptr, "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
        }
#line 1393
        return;
      }
    }
    {
#line 1396
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             (png_const_bytep )(buf), (png_size_t )6);
    }
  } else {
    {
#line 1401
    png_app_warning((png_const_structrp )png_ptr, "Can\'t write tRNS with an alpha channel");
    }
  }
#line 1403
  return;
}
}
#line 1408 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_bKGD(png_structrp png_ptr , png_const_color_16p back , int color_type ) 
{ 
  png_byte buf[6] ;

  {
#line 1415
  if (color_type == 3) {
#line 1417
    if ((int const   )back->index >= (int const   )png_ptr->num_palette) {
      {
#line 1424
      png_warning((png_const_structrp )png_ptr, "Invalid background palette index");
      }
#line 1425
      return;
    }
    {
#line 1428
    buf[0] = (png_byte )back->index;
#line 1429
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (png_size_t )1);
    }
  } else
#line 1432
  if ((color_type & 2) != 0) {
    {
#line 1434
    png_save_uint_16(buf, (unsigned int )back->red);
#line 1435
    png_save_uint_16(buf + 2, (unsigned int )back->green);
#line 1436
    png_save_uint_16(buf + 4, (unsigned int )back->blue);
    }
#line 1438
    if ((int )png_ptr->bit_depth == 8) {
#line 1438
      if ((((int )buf[0] | (int )buf[2]) | (int )buf[4]) != 0) {
        {
#line 1443
        png_warning((png_const_structrp )png_ptr, "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
        }
#line 1446
        return;
      }
    }
    {
#line 1449
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (png_size_t )6);
    }
  } else {
#line 1454
    if ((int const   )back->gray >= (int const   )(1 << (int )png_ptr->bit_depth)) {
      {
#line 1456
      png_warning((png_const_structrp )png_ptr, "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
      }
#line 1459
      return;
    }
    {
#line 1462
    png_save_uint_16(buf, (unsigned int )back->gray);
#line 1463
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (png_size_t )2);
    }
  }
#line 1465
  return;
}
}
#line 1470 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_hIST(png_structrp png_ptr , png_const_uint_16p hist , int num_hist ) 
{ 
  int i ;
  png_byte buf[3] ;

  {
#line 1478
  if (num_hist > (int )png_ptr->num_palette) {
    {
#line 1483
    png_warning((png_const_structrp )png_ptr, "Invalid number of histogram entries specified");
    }
#line 1484
    return;
  }
  {
#line 1487
  png_write_chunk_header(png_ptr, (((104U << 24) | (73U << 16)) | (83U << 8)) | 84U,
                         (png_uint_32 )(num_hist * 2));
#line 1489
  i = 0;
  }
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1489
    if (! (i < num_hist)) {
#line 1489
      goto while_break;
    }
    {
#line 1491
    png_save_uint_16(buf, (unsigned int )*(hist + i));
#line 1492
    png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (png_size_t )2);
#line 1489
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1495
  png_write_chunk_end(png_ptr);
  }
#line 1496
  return;
}
}
#line 1868 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_start[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 1871 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_inc[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 1874 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_ystart[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 1877 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_yinc[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 1861 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_start_row(png_structrp png_ptr ) 
{ 
  png_alloc_size_t buf_size ;
  int usr_pixel_depth ;
  png_byte filters ;
  png_size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  int num_filters ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  png_voidp __attribute__((__malloc__))  tmp___3 ;

  {
#line 1889
  usr_pixel_depth = (int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth;
#line 1890
  if (usr_pixel_depth >= 8) {
#line 1890
    tmp = (png_size_t )png_ptr->width * ((png_size_t )usr_pixel_depth >> 3);
  } else {
#line 1890
    tmp = ((png_size_t )png_ptr->width * (png_size_t )usr_pixel_depth + 7UL) >> 3;
  }
  {
#line 1890
  buf_size = tmp + 1UL;
#line 1893
  png_ptr->transformed_pixel_depth = png_ptr->pixel_depth;
#line 1894
  png_ptr->maximum_pixel_depth = (png_byte )usr_pixel_depth;
#line 1897
  tmp___0 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1897
  png_ptr->row_buf = (png_bytep )tmp___0;
#line 1899
  *(png_ptr->row_buf + 0) = (png_byte )0;
#line 1902
  filters = png_ptr->do_filter;
  }
#line 1904
  if (png_ptr->height == 1U) {
#line 1905
    filters = (png_byte )((int )filters & 31);
  }
#line 1907
  if (png_ptr->width == 1U) {
#line 1908
    filters = (png_byte )((int )filters & 47);
  }
#line 1910
  if ((int )filters == 0) {
#line 1911
    filters = (png_byte )8;
  }
#line 1913
  png_ptr->do_filter = filters;
#line 1915
  if (((int )filters & 240) != 0) {
#line 1915
    if ((unsigned long )png_ptr->try_row == (unsigned long )((void *)0)) {
      {
#line 1918
      num_filters = 0;
#line 1920
      tmp___1 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1920
      png_ptr->try_row = (png_bytep )tmp___1;
      }
#line 1922
      if ((int )filters & 16) {
#line 1923
        num_filters ++;
      }
#line 1925
      if ((int )filters & 32) {
#line 1926
        num_filters ++;
      }
#line 1928
      if ((int )filters & 64) {
#line 1929
        num_filters ++;
      }
#line 1931
      if ((int )filters & 128) {
#line 1932
        num_filters ++;
      }
#line 1934
      if (num_filters > 1) {
        {
#line 1935
        tmp___2 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1935
        png_ptr->tst_row = (png_bytep )tmp___2;
        }
      }
    }
  }
#line 1942
  if (((int )filters & 224) != 0) {
    {
#line 1943
    tmp___3 = png_calloc((png_const_structrp )png_ptr, buf_size);
#line 1943
    png_ptr->prev_row = (png_bytep )tmp___3;
    }
  }
#line 1949
  if ((int )png_ptr->interlaced != 0) {
#line 1951
    if ((png_ptr->transformations & 2U) == 0U) {
#line 1953
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc[0]) - 1U) - (png_uint_32 )png_pass_ystart[0]) / (png_uint_32 )png_pass_yinc[0];
#line 1956
      png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc[0]) - 1U) - (png_uint_32 )png_pass_start[0]) / (png_uint_32 )png_pass_inc[0];
    } else {
#line 1962
      png_ptr->num_rows = png_ptr->height;
#line 1963
      png_ptr->usr_width = png_ptr->width;
    }
  } else {
#line 1970
    png_ptr->num_rows = png_ptr->height;
#line 1971
    png_ptr->usr_width = png_ptr->width;
  }
#line 1973
  return;
}
}
#line 1983 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_start___0[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 1986 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_inc___0[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 1989 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_ystart___0[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 1992 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_yinc___0[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 1976 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_finish_row(png_structrp png_ptr ) 
{ 
  png_size_t tmp ;

  {
#line 1998
  (png_ptr->row_number) ++;
#line 2001
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 2002
    return;
  }
#line 2006
  if ((int )png_ptr->interlaced != 0) {
#line 2008
    png_ptr->row_number = (png_uint_32 )0;
#line 2009
    if ((png_ptr->transformations & 2U) != 0U) {
#line 2011
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
    } else {
      {
#line 2017
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2019
        png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 2021
        if ((int )png_ptr->pass >= 7) {
#line 2022
          goto while_break;
        }
#line 2024
        png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc___0[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___0[png_ptr->pass]) / (png_uint_32 )png_pass_inc___0[png_ptr->pass];
#line 2029
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___0[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_ystart___0[png_ptr->pass]) / (png_uint_32 )png_pass_yinc___0[png_ptr->pass];
#line 2034
        if ((png_ptr->transformations & 2U) != 0U) {
#line 2035
          goto while_break;
        }
#line 2017
        if (! (png_ptr->usr_width == 0U)) {
#line 2017
          if (! (png_ptr->num_rows == 0U)) {
#line 2017
            goto while_break;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 2042
    if ((int )png_ptr->pass < 7) {
#line 2044
      if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 2045
        if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 2045
          tmp = (png_size_t )png_ptr->width * ((png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
        } else {
#line 2045
          tmp = ((png_size_t )png_ptr->width * (png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
        }
        {
#line 2045
        memset((void *)png_ptr->prev_row, 0, tmp + 1UL);
        }
      }
#line 2049
      return;
    }
  }
  {
#line 2056
  png_compress_IDAT(png_ptr, (png_const_bytep )((void *)0), (png_alloc_size_t )0,
                    4);
  }
#line 2057
  return;
}
}
#line 2073 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_start___1[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 2076 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_byte const   png_pass_inc___1[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 2067 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass ) 
{ 
  png_bytep sp___0 ;
  png_bytep dp ;
  unsigned int shift ;
  int d ;
  int value ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep tmp ;
  png_bytep sp___1 ;
  png_bytep dp___0 ;
  unsigned int shift___0 ;
  int d___0 ;
  int value___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  png_bytep tmp___0 ;
  png_bytep sp___2 ;
  png_bytep dp___1 ;
  unsigned int shift___1 ;
  int d___1 ;
  int value___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  png_bytep tmp___1 ;
  png_bytep sp___3 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;
  png_uint_32 row_width___2 ;
  png_size_t pixel_bytes ;

  {
#line 2081
  if (pass < 6) {
    {
#line 2086
    if ((int )row_info->pixel_depth == 1) {
#line 2086
      goto case_1;
    }
#line 2124
    if ((int )row_info->pixel_depth == 2) {
#line 2124
      goto case_2;
    }
#line 2161
    if ((int )row_info->pixel_depth == 4) {
#line 2161
      goto case_4;
    }
#line 2197
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2094
    row_width = row_info->width;
#line 2096
    dp = row;
#line 2097
    d = 0;
#line 2098
    shift = 7U;
#line 2100
    i = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2100
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2100
      if (! (i < row_width)) {
#line 2100
        goto while_break;
      }
#line 2103
      sp___0 = row + (png_size_t )(i >> 3);
#line 2104
      value = ((int )*sp___0 >> (7 - (int )(i & 7U))) & 1;
#line 2105
      d |= value << shift;
#line 2107
      if (shift == 0U) {
#line 2109
        shift = 7U;
#line 2110
        tmp = dp;
#line 2110
        dp ++;
#line 2110
        *tmp = (png_byte )d;
#line 2111
        d = 0;
      } else {
#line 2115
        shift --;
      }
#line 2100
      i += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break: /* CIL Label */ ;
    }
#line 2118
    if (shift != 7U) {
#line 2119
      *dp = (png_byte )d;
    }
#line 2121
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2132
    row_width___0 = row_info->width;
#line 2134
    dp___0 = row;
#line 2135
    shift___0 = 6U;
#line 2136
    d___0 = 0;
#line 2138
    i___0 = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2138
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2138
      if (! (i___0 < row_width___0)) {
#line 2138
        goto while_break___0;
      }
#line 2141
      sp___1 = row + (png_size_t )(i___0 >> 2);
#line 2142
      value___0 = ((int )*sp___1 >> ((3 - (int )(i___0 & 3U)) << 1)) & 3;
#line 2143
      d___0 |= value___0 << shift___0;
#line 2145
      if (shift___0 == 0U) {
#line 2147
        shift___0 = 6U;
#line 2148
        tmp___0 = dp___0;
#line 2148
        dp___0 ++;
#line 2148
        *tmp___0 = (png_byte )d___0;
#line 2149
        d___0 = 0;
      } else {
#line 2153
        shift___0 -= 2U;
      }
#line 2138
      i___0 += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2155
    if (shift___0 != 6U) {
#line 2156
      *dp___0 = (png_byte )d___0;
    }
#line 2158
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2169
    row_width___1 = row_info->width;
#line 2171
    dp___1 = row;
#line 2172
    shift___1 = 4U;
#line 2173
    d___1 = 0;
#line 2174
    i___1 = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2174
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2174
      if (! (i___1 < row_width___1)) {
#line 2174
        goto while_break___1;
      }
#line 2177
      sp___2 = row + (png_size_t )(i___1 >> 1);
#line 2178
      value___1 = ((int )*sp___2 >> ((1 - (int )(i___1 & 1U)) << 2)) & 15;
#line 2179
      d___1 |= value___1 << shift___1;
#line 2181
      if (shift___1 == 0U) {
#line 2183
        shift___1 = 4U;
#line 2184
        tmp___1 = dp___1;
#line 2184
        dp___1 ++;
#line 2184
        *tmp___1 = (png_byte )d___1;
#line 2185
        d___1 = 0;
      } else {
#line 2189
        shift___1 -= 4U;
      }
#line 2174
      i___1 += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2191
    if (shift___1 != 4U) {
#line 2192
      *dp___1 = (png_byte )d___1;
    }
#line 2194
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2202
    row_width___2 = row_info->width;
#line 2206
    dp___2 = row;
#line 2209
    pixel_bytes = (png_size_t )((int )row_info->pixel_depth >> 3);
#line 2212
    i___2 = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2212
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2212
      if (! (i___2 < row_width___2)) {
#line 2212
        goto while_break___2;
      }
#line 2216
      sp___3 = row + (png_size_t )i___2 * pixel_bytes;
#line 2219
      if ((unsigned long )dp___2 != (unsigned long )sp___3) {
        {
#line 2220
        memcpy((void */* __restrict  */)dp___2, (void const   */* __restrict  */)sp___3,
               pixel_bytes);
        }
      }
#line 2223
      dp___2 += pixel_bytes;
#line 2212
      i___2 += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2225
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2229
    row_info->width = (((row_info->width + (png_uint_32 )png_pass_inc___1[pass]) - 1U) - (png_uint_32 )png_pass_start___1[pass]) / (png_uint_32 )png_pass_inc___1[pass];
#line 2234
    if ((int )row_info->pixel_depth >= 8) {
#line 2234
      row_info->rowbytes = (png_size_t )row_info->width * ((png_size_t )row_info->pixel_depth >> 3);
    } else {
#line 2234
      row_info->rowbytes = ((png_size_t )row_info->width * (png_size_t )row_info->pixel_depth + 7UL) >> 3;
    }
  }
#line 2237
  return;
}
}
#line 2245
static void png_write_filtered_row(png_structrp png_ptr , png_bytep filtered_row ,
                                   png_size_t full_row_length ) ;
#line 2250 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_size_t png_setup_sub_row(png_structrp png_ptr , png_uint_32 const   bpp ,
                                    png_size_t const   row_bytes , png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep lp ;
  png_size_t i ;
  png_size_t sum ;
  int v ;
  png_byte tmp ;
  int tmp___0 ;
  png_byte tmp___1 ;
  int tmp___2 ;

  {
#line 2256
  sum = (png_size_t )0;
#line 2259
  *(png_ptr->try_row + 0) = (png_byte )1;
#line 2261
  i = (png_size_t )0;
#line 2261
  rp = png_ptr->row_buf + 1;
#line 2261
  dp = png_ptr->try_row + 1;
  {
#line 2261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2261
    if (! (i < (png_size_t )bpp)) {
#line 2261
      goto while_break;
    }
#line 2264
    tmp = *rp;
#line 2264
    *dp = tmp;
#line 2264
    v = (int )tmp;
#line 2265
    if (v < 128) {
#line 2265
      tmp___0 = v;
    } else {
#line 2265
      tmp___0 = 256 - v;
    }
#line 2265
    sum += (png_size_t )tmp___0;
#line 2261
    i ++;
#line 2261
    rp ++;
#line 2261
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2268
  lp = png_ptr->row_buf + 1;
  {
#line 2268
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2268
    if (! (i < (png_size_t )row_bytes)) {
#line 2268
      goto while_break___0;
    }
#line 2271
    tmp___1 = (png_byte )(((int )*rp - (int )*lp) & 255);
#line 2271
    *dp = tmp___1;
#line 2271
    v = (int )tmp___1;
#line 2272
    if (v < 128) {
#line 2272
      tmp___2 = v;
    } else {
#line 2272
      tmp___2 = 256 - v;
    }
#line 2272
    sum += (png_size_t )tmp___2;
#line 2274
    if (sum > (png_size_t )lmins) {
#line 2275
      goto while_break___0;
    }
#line 2268
    i ++;
#line 2268
    rp ++;
#line 2268
    lp ++;
#line 2268
    dp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2278
  return (sum);
}
}
#line 2281 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_size_t png_setup_up_row(png_structrp png_ptr , png_size_t const   row_bytes ,
                                   png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_size_t i ;
  png_size_t sum ;
  int v ;
  png_byte tmp ;
  int tmp___0 ;

  {
#line 2287
  sum = (png_size_t )0;
#line 2290
  *(png_ptr->try_row + 0) = (png_byte )2;
#line 2292
  i = (png_size_t )0;
#line 2292
  rp = png_ptr->row_buf + 1;
#line 2292
  dp = png_ptr->try_row + 1;
#line 2292
  pp = png_ptr->prev_row + 1;
  {
#line 2292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2292
    if (! (i < (png_size_t )row_bytes)) {
#line 2292
      goto while_break;
    }
#line 2296
    tmp = (png_byte )(((int )*rp - (int )*pp) & 255);
#line 2296
    *dp = tmp;
#line 2296
    v = (int )tmp;
#line 2297
    if (v < 128) {
#line 2297
      tmp___0 = v;
    } else {
#line 2297
      tmp___0 = 256 - v;
    }
#line 2297
    sum += (png_size_t )tmp___0;
#line 2299
    if (sum > (png_size_t )lmins) {
#line 2300
      goto while_break;
    }
#line 2292
    i ++;
#line 2292
    rp ++;
#line 2292
    pp ++;
#line 2292
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2303
  return (sum);
}
}
#line 2306 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_size_t png_setup_avg_row(png_structrp png_ptr , png_uint_32 const   bpp ,
                                    png_size_t const   row_bytes , png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep lp ;
  png_uint_32 i ;
  png_size_t sum ;
  int v ;
  png_bytep tmp ;
  png_byte tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  int tmp___3 ;
  png_bytep tmp___4 ;
  png_byte tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  int tmp___9 ;

  {
#line 2312
  sum = (png_size_t )0;
#line 2315
  *(png_ptr->try_row + 0) = (png_byte )3;
#line 2317
  i = (png_uint_32 )0;
#line 2317
  rp = png_ptr->row_buf + 1;
#line 2317
  dp = png_ptr->try_row + 1;
#line 2317
  pp = png_ptr->prev_row + 1;
  {
#line 2317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2317
    if (! (i < (png_uint_32 )bpp)) {
#line 2317
      goto while_break;
    }
#line 2320
    tmp = dp;
#line 2320
    dp ++;
#line 2320
    tmp___1 = rp;
#line 2320
    rp ++;
#line 2320
    tmp___2 = pp;
#line 2320
    pp ++;
#line 2320
    tmp___0 = (png_byte )(((int )*tmp___1 - (int )*tmp___2 / 2) & 255);
#line 2320
    *tmp = tmp___0;
#line 2320
    v = (int )tmp___0;
#line 2322
    if (v < 128) {
#line 2322
      tmp___3 = v;
    } else {
#line 2322
      tmp___3 = 256 - v;
    }
#line 2322
    sum += (png_size_t )tmp___3;
#line 2317
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2325
  lp = png_ptr->row_buf + 1;
  {
#line 2325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2325
    if (! ((png_size_t const   )i < row_bytes)) {
#line 2325
      goto while_break___0;
    }
#line 2327
    tmp___4 = dp;
#line 2327
    dp ++;
#line 2327
    tmp___6 = rp;
#line 2327
    rp ++;
#line 2327
    tmp___7 = pp;
#line 2327
    pp ++;
#line 2327
    tmp___8 = lp;
#line 2327
    lp ++;
#line 2327
    tmp___5 = (png_byte )(((int )*tmp___6 - ((int )*tmp___7 + (int )*tmp___8) / 2) & 255);
#line 2327
    *tmp___4 = tmp___5;
#line 2327
    v = (int )tmp___5;
#line 2330
    if (v < 128) {
#line 2330
      tmp___9 = v;
    } else {
#line 2330
      tmp___9 = 256 - v;
    }
#line 2330
    sum += (png_size_t )tmp___9;
#line 2332
    if (sum > (png_size_t )lmins) {
#line 2333
      goto while_break___0;
    }
#line 2325
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2336
  return (sum);
}
}
#line 2339 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static png_size_t png_setup_paeth_row(png_structrp png_ptr , png_uint_32 const   bpp ,
                                      png_size_t const   row_bytes , png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep cp ;
  png_bytep lp ;
  png_size_t i ;
  png_size_t sum ;
  int v ;
  png_bytep tmp ;
  png_byte tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  int tmp___3 ;
  int a ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  int tmp___7 ;
  png_bytep tmp___8 ;
  png_byte tmp___9 ;
  png_bytep tmp___10 ;
  int tmp___11 ;

  {
#line 2345
  sum = (png_size_t )0;
#line 2348
  *(png_ptr->try_row + 0) = (png_byte )4;
#line 2350
  i = (png_size_t )0;
#line 2350
  rp = png_ptr->row_buf + 1;
#line 2350
  dp = png_ptr->try_row + 1;
#line 2350
  pp = png_ptr->prev_row + 1;
  {
#line 2350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2350
    if (! (i < (png_size_t )bpp)) {
#line 2350
      goto while_break;
    }
#line 2353
    tmp = dp;
#line 2353
    dp ++;
#line 2353
    tmp___1 = rp;
#line 2353
    rp ++;
#line 2353
    tmp___2 = pp;
#line 2353
    pp ++;
#line 2353
    tmp___0 = (png_byte )(((int )*tmp___1 - (int )*tmp___2) & 255);
#line 2353
    *tmp = tmp___0;
#line 2353
    v = (int )tmp___0;
#line 2355
    if (v < 128) {
#line 2355
      tmp___3 = v;
    } else {
#line 2355
      tmp___3 = 256 - v;
    }
#line 2355
    sum += (png_size_t )tmp___3;
#line 2350
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2358
  lp = png_ptr->row_buf + 1;
#line 2358
  cp = png_ptr->prev_row + 1;
  {
#line 2358
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2358
    if (! (i < (png_size_t )row_bytes)) {
#line 2358
      goto while_break___0;
    }
#line 2363
    tmp___4 = pp;
#line 2363
    pp ++;
#line 2363
    b = (int )*tmp___4;
#line 2364
    tmp___5 = cp;
#line 2364
    cp ++;
#line 2364
    c = (int )*tmp___5;
#line 2365
    tmp___6 = lp;
#line 2365
    lp ++;
#line 2365
    a = (int )*tmp___6;
#line 2367
    p = b - c;
#line 2368
    pc = a - c;
#line 2375
    if (p < 0) {
#line 2375
      pa = - p;
    } else {
#line 2375
      pa = p;
    }
#line 2376
    if (pc < 0) {
#line 2376
      pb = - pc;
    } else {
#line 2376
      pb = pc;
    }
#line 2377
    if (p + pc < 0) {
#line 2377
      pc = - (p + pc);
    } else {
#line 2377
      pc = p + pc;
    }
#line 2380
    if (pa <= pb) {
#line 2380
      if (pa <= pc) {
#line 2380
        p = a;
      } else {
#line 2380
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2380
      if (pb <= pc) {
#line 2380
        tmp___7 = b;
      } else {
#line 2380
        tmp___7 = c;
      }
#line 2380
      p = tmp___7;
    }
#line 2382
    tmp___8 = dp;
#line 2382
    dp ++;
#line 2382
    tmp___10 = rp;
#line 2382
    rp ++;
#line 2382
    tmp___9 = (png_byte )(((int )*tmp___10 - p) & 255);
#line 2382
    *tmp___8 = tmp___9;
#line 2382
    v = (int )tmp___9;
#line 2384
    if (v < 128) {
#line 2384
      tmp___11 = v;
    } else {
#line 2384
      tmp___11 = 256 - v;
    }
#line 2384
    sum += (png_size_t )tmp___11;
#line 2386
    if (sum > (png_size_t )lmins) {
#line 2387
      goto while_break___0;
    }
#line 2358
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2390
  return (sum);
}
}
#line 2394 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
void png_write_find_filter(png_structrp png_ptr , png_row_infop row_info ) 
{ 
  png_byte filter_to_do ;
  png_bytep row_buf ;
  png_bytep best_row ;
  png_uint_32 bpp ;
  png_size_t mins ;
  png_size_t row_bytes ;
  png_bytep rp ;
  png_size_t sum ;
  png_size_t i ;
  int v ;
  int tmp ;
  int tmp___0 ;
  png_size_t sum___0 ;
  png_size_t lmins ;
  png_size_t sum___1 ;
  png_size_t lmins___0 ;
  png_size_t sum___2 ;
  png_size_t lmins___1 ;
  png_size_t sum___3 ;
  png_size_t lmins___2 ;

  {
#line 2400
  filter_to_do = png_ptr->do_filter;
#line 2405
  row_bytes = row_info->rowbytes;
#line 2410
  bpp = (png_uint_32 )(((int )row_info->pixel_depth + 7) >> 3);
#line 2412
  row_buf = png_ptr->row_buf;
#line 2413
  mins = 0xfffffffffffffeffUL;
#line 2444
  best_row = png_ptr->row_buf;
#line 2447
  if (((int )filter_to_do & 8) != 0) {
#line 2447
    if ((int )filter_to_do != 8) {
#line 2450
      sum = (png_size_t )0;
#line 2454
      if (144115188075855871UL <= row_bytes) {
#line 2456
        i = (png_size_t )0;
#line 2456
        rp = row_buf + 1;
        {
#line 2456
        while (1) {
          while_continue: /* CIL Label */ ;
#line 2456
          if (! (i < row_bytes)) {
#line 2456
            goto while_break;
          }
#line 2459
          if (sum > 144115188075855615UL) {
#line 2460
            goto while_break;
          }
#line 2462
          v = (int )*rp;
#line 2463
          if (v < 128) {
#line 2463
            tmp = v;
          } else {
#line 2463
            tmp = 256 - v;
          }
#line 2463
          sum += (png_size_t )tmp;
#line 2456
          i ++;
#line 2456
          rp ++;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 2468
        i = (png_size_t )0;
#line 2468
        rp = row_buf + 1;
        {
#line 2468
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2468
          if (! (i < row_bytes)) {
#line 2468
            goto while_break___0;
          }
#line 2470
          v = (int )*rp;
#line 2471
          if (v < 128) {
#line 2471
            tmp___0 = v;
          } else {
#line 2471
            tmp___0 = 256 - v;
          }
#line 2471
          sum += (png_size_t )tmp___0;
#line 2468
          i ++;
#line 2468
          rp ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 2475
      mins = sum;
    }
  }
#line 2479
  if ((int )filter_to_do == 16) {
    {
#line 2482
    png_setup_sub_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                      (png_size_t const   )mins);
#line 2483
    best_row = png_ptr->try_row;
    }
  } else
#line 2486
  if (((int )filter_to_do & 16) != 0) {
    {
#line 2489
    lmins = mins;
#line 2491
    sum___0 = png_setup_sub_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                                (png_size_t const   )lmins);
    }
#line 2493
    if (sum___0 < mins) {
#line 2495
      mins = sum___0;
#line 2496
      best_row = png_ptr->try_row;
#line 2497
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2499
        png_ptr->try_row = png_ptr->tst_row;
#line 2500
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2506
  if ((int )filter_to_do == 32) {
    {
#line 2508
    png_setup_up_row(png_ptr, (png_size_t const   )row_bytes, (png_size_t const   )mins);
#line 2509
    best_row = png_ptr->try_row;
    }
  } else
#line 2512
  if (((int )filter_to_do & 32) != 0) {
    {
#line 2515
    lmins___0 = mins;
#line 2517
    sum___1 = png_setup_up_row(png_ptr, (png_size_t const   )row_bytes, (png_size_t const   )lmins___0);
    }
#line 2519
    if (sum___1 < mins) {
#line 2521
      mins = sum___1;
#line 2522
      best_row = png_ptr->try_row;
#line 2523
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2525
        png_ptr->try_row = png_ptr->tst_row;
#line 2526
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2532
  if ((int )filter_to_do == 64) {
    {
#line 2534
    png_setup_avg_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                      (png_size_t const   )mins);
#line 2535
    best_row = png_ptr->try_row;
    }
  } else
#line 2538
  if (((int )filter_to_do & 64) != 0) {
    {
#line 2541
    lmins___1 = mins;
#line 2543
    sum___2 = png_setup_avg_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                                (png_size_t const   )lmins___1);
    }
#line 2545
    if (sum___2 < mins) {
#line 2547
      mins = sum___2;
#line 2548
      best_row = png_ptr->try_row;
#line 2549
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2551
        png_ptr->try_row = png_ptr->tst_row;
#line 2552
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2558
  if (((int )filter_to_do == 128) != 0) {
    {
#line 2560
    png_setup_paeth_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                        (png_size_t const   )mins);
#line 2561
    best_row = png_ptr->try_row;
    }
  } else
#line 2564
  if (((int )filter_to_do & 128) != 0) {
    {
#line 2567
    lmins___2 = mins;
#line 2569
    sum___3 = png_setup_paeth_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                                  (png_size_t const   )lmins___2);
    }
#line 2571
    if (sum___3 < mins) {
#line 2573
      best_row = png_ptr->try_row;
#line 2574
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2576
        png_ptr->try_row = png_ptr->tst_row;
#line 2577
        png_ptr->tst_row = best_row;
      }
    }
  }
  {
#line 2583
  png_write_filtered_row(png_ptr, best_row, row_info->rowbytes + 1UL);
  }
#line 2586
  return;
}
}
#line 2590 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwutil.c"
static void png_write_filtered_row(png_structrp png_ptr , png_bytep filtered_row ,
                                   png_size_t full_row_length ) 
{ 
  png_bytep tptr ;

  {
  {
#line 2598
  png_compress_IDAT(png_ptr, (png_const_bytep )filtered_row, full_row_length, 0);
  }
#line 2602
  if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 2606
    tptr = png_ptr->prev_row;
#line 2607
    png_ptr->prev_row = png_ptr->row_buf;
#line 2608
    png_ptr->row_buf = tptr;
  }
  {
#line 2613
  png_write_finish_row(png_ptr);
#line 2616
  (png_ptr->flush_rows) ++;
  }
#line 2618
  if (png_ptr->flush_dist > 0U) {
#line 2618
    if (png_ptr->flush_rows >= png_ptr->flush_dist) {
      {
#line 2621
      png_write_flush(png_ptr);
      }
    }
  }
#line 2624
  return;
}
}
#line 934 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
png_structp __attribute__((__malloc__))  png_create_write_struct(png_const_charp user_png_ver ,
                                                                 png_voidp error_ptr ,
                                                                 void (*error_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                 void (*warn_fn)(png_structp  ,
                                                                                 png_const_charp  ) ) ;
#line 1021
void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1023
void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1291
int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1364
void png_set_flush(png_structrp png_ptr , int nrows ) ;
#line 1394
void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1402
void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) ;
#line 1406
void png_write_image(png_structrp png_ptr , png_bytepp image___0 ) ;
#line 1409
void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1418
void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) ;
#line 1426
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1461
void png_set_filter(png_structrp png_ptr , int method , int filters ) ;
#line 1514
void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1517
void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1520
void png_set_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1526
void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1529
void png_set_compression_method(png_structrp png_ptr , int method ) ;
#line 1593
void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      png_size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) ) ;
#line 1606
void png_set_write_status_fn(png_structrp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                         png_uint_32  ,
                                                                         int  ) ) ;
#line 1809
void png_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 2281
int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) ;
#line 2319
void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) ;
#line 914 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
png_structp __attribute__((__malloc__))  png_create_png_struct(png_const_charp user_png_ver ,
                                                               png_voidp error_ptr ,
                                                               void (*error_fn)(png_structp  ,
                                                                                png_const_charp  ) ,
                                                               void (*warn_fn)(png_structp  ,
                                                                               png_const_charp  ) ,
                                                               png_voidp mem_ptr ,
                                                               png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                                                               void (*free_fn)(png_structp  ,
                                                                               png_voidp  ) ) ;
#line 920
void png_destroy_png_struct(png_structrp png_ptr ) ;
#line 994
void png_flush(png_structrp png_ptr ) ;
#line 1534
void png_do_check_palette_indexes(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1636
void png_app_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 23 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
static void write_unknown_chunks(png_structrp png_ptr , png_const_inforp info_ptr ,
                                 unsigned int where ) 
{ 
  png_const_unknown_chunkp up ;
  int keep ;
  int tmp ;

  {
#line 27
  if (info_ptr->unknown_chunks_num != 0) {
#line 33
    up = (png_const_unknown_chunkp )info_ptr->unknown_chunks;
    {
#line 33
    while (1) {
      while_continue: /* CIL Label */ ;
#line 33
      if (! ((unsigned long )up < (unsigned long )(info_ptr->unknown_chunks + info_ptr->unknown_chunks_num))) {
#line 33
        goto while_break;
      }
#line 36
      if (((unsigned int )up->location & where) != 0U) {
        {
#line 42
        tmp = png_handle_as_unknown((png_const_structrp )png_ptr, (png_const_bytep )(up->name));
#line 42
        keep = tmp;
        }
#line 56
        if (keep != 1) {
#line 56
          if ((int )up->name[3] & 32) {
#line 56
            goto _L;
          } else
#line 56
          if (keep == 3) {
#line 56
            goto _L;
          } else
#line 56
          if (keep == 0) {
#line 56
            if (png_ptr->unknown_default == 3) {
              _L: /* CIL Label */ 
#line 64
              if (up->size == 0UL) {
                {
#line 65
                png_warning((png_const_structrp )png_ptr, "Writing zero-length unknown chunk");
                }
              }
              {
#line 67
              png_write_chunk(png_ptr, (png_const_bytep )(up->name), (png_const_bytep )up->data,
                              (png_size_t )up->size);
              }
            }
          }
        }
      }
#line 33
      up ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 71
  return;
}
}
#line 83 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 88
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 89
    return;
  } else
#line 88
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 89
    return;
  }
#line 91
  if ((png_ptr->mode & 1024U) == 0U) {
    {
#line 94
    png_write_sig(png_ptr);
#line 107
    png_write_IHDR(png_ptr, (png_uint_32 )info_ptr->width, (png_uint_32 )info_ptr->height,
                   (int )info_ptr->bit_depth, (int )info_ptr->color_type, (int )info_ptr->compression_type,
                   (int )info_ptr->filter_type, (int )info_ptr->interlace_type);
    }
#line 170
    if ((info_ptr->valid & 2U) != 0U) {
      {
#line 171
      png_write_sBIT(png_ptr, & info_ptr->sig_bit, (int )info_ptr->color_type);
      }
    }
    {
#line 184
    write_unknown_chunks(png_ptr, info_ptr, 1U);
#line 187
    png_ptr->mode |= 1024U;
    }
  }
#line 189
  return;
}
}
#line 191 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 200
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 201
    return;
  } else
#line 200
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 201
    return;
  }
  {
#line 203
  png_write_info_before_PLTE(png_ptr, info_ptr);
  }
#line 205
  if ((info_ptr->valid & 8U) != 0U) {
    {
#line 206
    png_write_PLTE(png_ptr, (png_const_colorp )info_ptr->palette, (png_uint_32 )info_ptr->num_palette);
    }
  } else
#line 209
  if ((int const   )info_ptr->color_type == 3) {
    {
#line 210
    png_error((png_const_structrp )png_ptr, "Valid palette required for paletted images");
    }
  }
#line 213
  if ((info_ptr->valid & 16U) != 0U) {
    {
#line 231
    png_write_tRNS(png_ptr, (png_const_bytep )info_ptr->trans_alpha, & info_ptr->trans_color,
                   (int )info_ptr->num_trans, (int )info_ptr->color_type);
    }
  }
#line 236
  if ((info_ptr->valid & 32U) != 0U) {
    {
#line 237
    png_write_bKGD(png_ptr, & info_ptr->background, (int )info_ptr->color_type);
    }
  }
#line 241
  if ((info_ptr->valid & 64U) != 0U) {
    {
#line 242
    png_write_hIST(png_ptr, (png_const_uint_16p )info_ptr->hist, (int )info_ptr->num_palette);
    }
  }
  {
#line 343
  write_unknown_chunks(png_ptr, info_ptr, 2U);
  }
#line 345
  return;
}
}
#line 352 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) 
{ 


  {
#line 357
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 358
    return;
  }
#line 360
  if ((png_ptr->mode & 4U) == 0U) {
    {
#line 361
    png_error((png_const_structrp )png_ptr, "No IDATs written into file");
    }
  }
#line 364
  if (png_ptr->num_palette_max > (int )png_ptr->num_palette) {
    {
#line 365
    png_benign_error((png_const_structrp )png_ptr, "Wrote palette index exceeding num_palette");
    }
  }
#line 369
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 436
    write_unknown_chunks(png_ptr, (png_const_inforp )info_ptr, 8U);
    }
  }
  {
#line 440
  png_ptr->mode |= 8U;
#line 443
  png_write_IEND(png_ptr);
  }
#line 457
  return;
}
}
#line 486 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
png_structp __attribute__((__malloc__))  png_create_write_struct(png_const_charp user_png_ver ,
                                                                 png_voidp error_ptr ,
                                                                 void (*error_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                 void (*warn_fn)(png_structp  ,
                                                                                 png_const_charp  ) ) 
{ 
  png_structrp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;

  {
  {
#line 491
  tmp = png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, (void *)0,
                              (png_voidp (*)(png_structp  , png_alloc_size_t  ))((void *)0),
                              (void (*)(png_structp  , png_voidp  ))((void *)0));
#line 491
  png_ptr = (png_structrp )tmp;
  }
#line 507
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 512
    png_ptr->zbuffer_size = (uInt )8192;
#line 518
    png_ptr->zlib_strategy = 1;
#line 519
    png_ptr->zlib_level = -1;
#line 520
    png_ptr->zlib_mem_level = 8;
#line 521
    png_ptr->zlib_window_bits = 15;
#line 522
    png_ptr->zlib_method = 8;
#line 548
    png_ptr->flags |= 2097152U;
#line 555
    png_set_write_fn(png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0),
                     (void (*)(png_structp  ))((void *)0));
    }
  }
#line 558
  return ((png_structp __attribute__((__malloc__))  )png_ptr);
}
}
#line 567 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) 
{ 
  png_uint_32 i ;
  png_bytepp rp ;

  {
#line 576
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 577
    return;
  }
#line 580
  i = (png_uint_32 )0;
#line 580
  rp = row;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (i < num_rows)) {
#line 580
      goto while_break;
    }
    {
#line 582
    png_write_row(png_ptr, (png_const_bytep )*rp);
#line 580
    i ++;
#line 580
    rp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 584
  return;
}
}
#line 589 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_image(png_structrp png_ptr , png_bytepp image___0 ) 
{ 
  png_uint_32 i ;
  int pass ;
  int num_pass ;
  png_bytepp rp ;

  {
#line 596
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 597
    return;
  }
  {
#line 605
  num_pass = png_set_interlace_handling(png_ptr);
#line 610
  pass = 0;
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! (pass < num_pass)) {
#line 610
      goto while_break;
    }
#line 613
    i = (png_uint_32 )0;
#line 613
    rp = image___0;
    {
#line 613
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 613
      if (! (i < png_ptr->height)) {
#line 613
        goto while_break___0;
      }
      {
#line 615
      png_write_row(png_ptr, (png_const_bytep )*rp);
#line 613
      i ++;
#line 613
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 610
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 618
  return;
}
}
#line 686 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_row(png_structrp png_ptr , png_const_bytep row ) 
{ 
  png_row_info row_info ;

  {
#line 692
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 693
    return;
  }
#line 699
  if (png_ptr->row_number == 0U) {
#line 699
    if ((int )png_ptr->pass == 0) {
#line 702
      if ((png_ptr->mode & 1024U) == 0U) {
        {
#line 703
        png_error((png_const_structrp )png_ptr, "png_write_info was never called before png_write_row");
        }
      }
      {
#line 743
      png_write_start_row(png_ptr);
      }
    }
  }
#line 748
  if ((int )png_ptr->interlaced != 0) {
#line 748
    if ((png_ptr->transformations & 2U) != 0U) {
      {
#line 753
      if ((int )png_ptr->pass == 0) {
#line 753
        goto case_0;
      }
#line 761
      if ((int )png_ptr->pass == 1) {
#line 761
        goto case_1;
      }
#line 769
      if ((int )png_ptr->pass == 2) {
#line 769
        goto case_2;
      }
#line 777
      if ((int )png_ptr->pass == 3) {
#line 777
        goto case_3;
      }
#line 785
      if ((int )png_ptr->pass == 4) {
#line 785
        goto case_4;
      }
#line 793
      if ((int )png_ptr->pass == 5) {
#line 793
        goto case_5;
      }
#line 801
      if ((int )png_ptr->pass == 6) {
#line 801
        goto case_6;
      }
#line 809
      goto switch_default;
      case_0: /* CIL Label */ 
#line 754
      if ((png_ptr->row_number & 7U) != 0U) {
        {
#line 756
        png_write_finish_row(png_ptr);
        }
#line 757
        return;
      }
#line 759
      goto switch_break;
      case_1: /* CIL Label */ 
#line 762
      if ((png_ptr->row_number & 7U) != 0U) {
        {
#line 764
        png_write_finish_row(png_ptr);
        }
#line 765
        return;
      } else
#line 762
      if (png_ptr->width < 5U) {
        {
#line 764
        png_write_finish_row(png_ptr);
        }
#line 765
        return;
      }
#line 767
      goto switch_break;
      case_2: /* CIL Label */ 
#line 770
      if ((png_ptr->row_number & 7U) != 4U) {
        {
#line 772
        png_write_finish_row(png_ptr);
        }
#line 773
        return;
      }
#line 775
      goto switch_break;
      case_3: /* CIL Label */ 
#line 778
      if ((png_ptr->row_number & 3U) != 0U) {
        {
#line 780
        png_write_finish_row(png_ptr);
        }
#line 781
        return;
      } else
#line 778
      if (png_ptr->width < 3U) {
        {
#line 780
        png_write_finish_row(png_ptr);
        }
#line 781
        return;
      }
#line 783
      goto switch_break;
      case_4: /* CIL Label */ 
#line 786
      if ((png_ptr->row_number & 3U) != 2U) {
        {
#line 788
        png_write_finish_row(png_ptr);
        }
#line 789
        return;
      }
#line 791
      goto switch_break;
      case_5: /* CIL Label */ 
#line 794
      if ((png_ptr->row_number & 1U) != 0U) {
        {
#line 796
        png_write_finish_row(png_ptr);
        }
#line 797
        return;
      } else
#line 794
      if (png_ptr->width < 2U) {
        {
#line 796
        png_write_finish_row(png_ptr);
        }
#line 797
        return;
      }
#line 799
      goto switch_break;
      case_6: /* CIL Label */ 
#line 802
      if ((png_ptr->row_number & 1U) == 0U) {
        {
#line 804
        png_write_finish_row(png_ptr);
        }
#line 805
        return;
      }
#line 807
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 810
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 816
  row_info.color_type = png_ptr->color_type;
#line 817
  row_info.width = png_ptr->usr_width;
#line 818
  row_info.channels = png_ptr->usr_channels;
#line 819
  row_info.bit_depth = png_ptr->usr_bit_depth;
#line 820
  row_info.pixel_depth = (png_byte )((int )row_info.bit_depth * (int )row_info.channels);
#line 821
  if ((int )row_info.pixel_depth >= 8) {
#line 821
    row_info.rowbytes = (png_size_t )row_info.width * ((png_size_t )row_info.pixel_depth >> 3);
  } else {
#line 821
    row_info.rowbytes = ((png_size_t )row_info.width * (png_size_t )row_info.pixel_depth + 7UL) >> 3;
  }
  {
#line 831
  memcpy((void */* __restrict  */)(png_ptr->row_buf + 1), (void const   */* __restrict  */)row,
         row_info.rowbytes);
  }
#line 835
  if (png_ptr->interlaced) {
#line 835
    if ((int )png_ptr->pass < 6) {
#line 835
      if ((png_ptr->transformations & 2U) != 0U) {
        {
#line 838
        png_do_write_interlace(& row_info, png_ptr->row_buf + 1, (int )png_ptr->pass);
        }
#line 840
        if (row_info.width == 0U) {
          {
#line 842
          png_write_finish_row(png_ptr);
          }
#line 843
          return;
        }
      }
    }
  }
#line 857
  if ((int )row_info.pixel_depth != (int )png_ptr->pixel_depth) {
    {
#line 859
    png_error((png_const_structrp )png_ptr, "internal write transform logic error");
    }
  } else
#line 857
  if ((int )row_info.pixel_depth != (int )png_ptr->transformed_pixel_depth) {
    {
#line 859
    png_error((png_const_structrp )png_ptr, "internal write transform logic error");
    }
  }
#line 882
  if ((int )row_info.color_type == 3) {
#line 882
    if (png_ptr->num_palette_max >= 0) {
      {
#line 884
      png_do_check_palette_indexes(png_ptr, & row_info);
      }
    }
  }
  {
#line 888
  png_write_find_filter(png_ptr, & row_info);
  }
#line 890
  if ((unsigned long )png_ptr->write_row_fn != (unsigned long )((void *)0)) {
    {
#line 891
    (*(png_ptr->write_row_fn))((png_structp )png_ptr, png_ptr->row_number, (int )png_ptr->pass);
    }
  }
#line 892
  return;
}
}
#line 896 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_flush(png_structrp png_ptr , int nrows ) 
{ 


  {
#line 901
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 902
    return;
  }
#line 904
  if (nrows < 0) {
#line 904
    png_ptr->flush_dist = (png_uint_32 )0;
  } else {
#line 904
    png_ptr->flush_dist = (png_uint_32 )nrows;
  }
#line 905
  return;
}
}
#line 908 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_flush(png_structrp png_ptr ) 
{ 


  {
#line 913
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 914
    return;
  }
#line 917
  if (png_ptr->row_number >= png_ptr->num_rows) {
#line 918
    return;
  }
  {
#line 920
  png_compress_IDAT(png_ptr, (png_const_bytep )((void *)0), (png_alloc_size_t )0,
                    2);
#line 921
  png_ptr->flush_rows = (png_uint_32 )0;
#line 922
  png_flush(png_ptr);
  }
#line 923
  return;
}
}
#line 927 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
static void png_write_destroy(png_structrp png_ptr ) 
{ 


  {
#line 933
  if ((png_ptr->flags & 2U) != 0U) {
    {
#line 934
    deflateEnd(& png_ptr->zstream);
    }
  }
  {
#line 937
  png_free_buffer_list(png_ptr, & png_ptr->zbuffer_list);
#line 938
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->row_buf);
#line 939
  png_ptr->row_buf = (png_bytep )((void *)0);
#line 941
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->prev_row);
#line 942
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->try_row);
#line 943
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->tst_row);
#line 944
  png_ptr->prev_row = (png_bytep )((void *)0);
#line 945
  png_ptr->try_row = (png_bytep )((void *)0);
#line 946
  png_ptr->tst_row = (png_bytep )((void *)0);
#line 950
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
#line 951
  png_ptr->chunk_list = (png_bytep )((void *)0);
  }
#line 958
  return;
}
}
#line 967 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) 
{ 
  png_structrp png_ptr ;

  {
#line 972
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 974
    png_ptr = (png_structrp )*png_ptr_ptr;
#line 976
    if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
      {
#line 978
      png_destroy_info_struct((png_const_structrp )png_ptr, info_ptr_ptr);
#line 980
      *png_ptr_ptr = (png_struct *)((void *)0);
#line 981
      png_write_destroy(png_ptr);
#line 982
      png_destroy_png_struct(png_ptr);
      }
    }
  }
#line 985
  return;
}
}
#line 988 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_filter(png_structrp png_ptr , int method , int filters ) 
{ 
  int num_filters ;
  png_alloc_size_t buf_size ;
  png_size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;

  {
#line 993
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 994
    return;
  }
#line 1002
  if (method == 0) {
    {
#line 1009
    if ((filters & 255) == 7) {
#line 1009
      goto case_7;
    }
#line 1009
    if ((filters & 255) == 6) {
#line 1009
      goto case_7;
    }
#line 1009
    if ((filters & 255) == 5) {
#line 1009
      goto case_7;
    }
#line 1012
    if ((filters & 255) == 0) {
#line 1012
      goto case_0;
    }
#line 1016
    if ((filters & 255) == 1) {
#line 1016
      goto case_1;
    }
#line 1019
    if ((filters & 255) == 2) {
#line 1019
      goto case_2;
    }
#line 1022
    if ((filters & 255) == 3) {
#line 1022
      goto case_3;
    }
#line 1025
    if ((filters & 255) == 4) {
#line 1025
      goto case_4;
    }
#line 1028
    goto switch_default;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 1009
    png_app_error((png_const_structrp )png_ptr, "Unknown row filter for method 0");
    }
    case_0: /* CIL Label */ 
#line 1013
    png_ptr->do_filter = (png_byte )8;
#line 1013
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1017
    png_ptr->do_filter = (png_byte )16;
#line 1017
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1020
    png_ptr->do_filter = (png_byte )32;
#line 1020
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1023
    png_ptr->do_filter = (png_byte )64;
#line 1023
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1026
    png_ptr->do_filter = (png_byte )128;
#line 1026
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1029
    png_ptr->do_filter = (png_byte )filters;
#line 1029
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1050
    if ((unsigned long )png_ptr->row_buf != (unsigned long )((void *)0)) {
#line 1059
      if (png_ptr->height == 1U) {
#line 1060
        filters &= -225;
      }
#line 1062
      if (png_ptr->width == 1U) {
#line 1063
        filters &= -209;
      }
#line 1065
      if ((filters & 224) != 0) {
#line 1065
        if ((unsigned long )png_ptr->prev_row == (unsigned long )((void *)0)) {
          {
#line 1071
          png_app_warning((png_const_structrp )png_ptr, "png_set_filter: UP/AVG/PAETH cannot be added after start");
#line 1073
          filters &= -225;
          }
        }
      }
#line 1076
      num_filters = 0;
#line 1078
      if (filters & 16) {
#line 1079
        num_filters ++;
      }
#line 1081
      if (filters & 32) {
#line 1082
        num_filters ++;
      }
#line 1084
      if (filters & 64) {
#line 1085
        num_filters ++;
      }
#line 1087
      if (filters & 128) {
#line 1088
        num_filters ++;
      }
#line 1093
      if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 1093
        tmp = (png_size_t )png_ptr->width * ((png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
      } else {
#line 1093
        tmp = ((png_size_t )png_ptr->width * (png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
      }
#line 1093
      buf_size = tmp + 1UL;
#line 1096
      if ((unsigned long )png_ptr->try_row == (unsigned long )((void *)0)) {
        {
#line 1097
        tmp___0 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1097
        png_ptr->try_row = (png_bytep )tmp___0;
        }
      }
#line 1100
      if (num_filters > 1) {
#line 1102
        if ((unsigned long )png_ptr->tst_row == (unsigned long )((void *)0)) {
          {
#line 1103
          tmp___1 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1103
          png_ptr->tst_row = (png_bytep )tmp___1;
          }
        }
      }
    }
#line 1107
    png_ptr->do_filter = (png_byte )filters;
  } else {
    {
#line 1111
    png_error((png_const_structrp )png_ptr, "Unknown custom filter method");
    }
  }
#line 1112
  return;
}
}
#line 1146 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_compression_level(png_structrp png_ptr , int level ) 
{ 


  {
#line 1151
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1152
    return;
  }
#line 1154
  png_ptr->zlib_level = level;
#line 1155
  return;
}
}
#line 1157 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) 
{ 


  {
#line 1162
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1163
    return;
  }
#line 1165
  png_ptr->zlib_mem_level = mem_level;
#line 1166
  return;
}
}
#line 1168 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_compression_strategy(png_structrp png_ptr , int strategy ) 
{ 


  {
#line 1173
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1174
    return;
  }
#line 1178
  png_ptr->flags |= 1U;
#line 1179
  png_ptr->zlib_strategy = strategy;
#line 1180
  return;
}
}
#line 1185 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) 
{ 


  {
#line 1188
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1189
    return;
  }
#line 1197
  if (window_bits > 15) {
    {
#line 1199
    png_warning((png_const_structrp )png_ptr, "Only compression windows <= 32k supported by PNG");
#line 1200
    window_bits = 15;
    }
  } else
#line 1203
  if (window_bits < 8) {
    {
#line 1205
    png_warning((png_const_structrp )png_ptr, "Only compression windows >= 256 supported by PNG");
#line 1206
    window_bits = 8;
    }
  }
#line 1209
  png_ptr->zlib_window_bits = window_bits;
#line 1210
  return;
}
}
#line 1212 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_compression_method(png_structrp png_ptr , int method ) 
{ 


  {
#line 1217
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1218
    return;
  }
#line 1223
  if (method != 8) {
    {
#line 1224
    png_warning((png_const_structrp )png_ptr, "Only compression method 8 is supported by PNG");
    }
  }
#line 1226
  png_ptr->zlib_method = method;
#line 1227
  return;
}
}
#line 1305 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_set_write_status_fn(png_structrp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                         png_uint_32  ,
                                                                         int  ) ) 
{ 


  {
#line 1308
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1309
    return;
  }
#line 1311
  png_ptr->write_row_fn = write_row_fn;
#line 1312
  return;
}
}
#line 1331 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwrite.c"
void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) 
{ 


  {
#line 1335
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1336
    return;
  } else
#line 1335
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1336
    return;
  }
#line 1338
  if ((info_ptr->valid & 32768U) == 0U) {
    {
#line 1340
    png_app_error((png_const_structrp )png_ptr, "no rows for png_write_image to write");
    }
#line 1341
    return;
  }
  {
#line 1345
  png_write_info(png_ptr, (png_const_inforp )info_ptr);
  }
#line 1350
  if ((transforms & 32) != 0) {
    {
#line 1354
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_MONO not supported");
    }
  }
#line 1360
  if ((transforms & 64) != 0) {
    {
#line 1365
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SHIFT not supported");
    }
  }
#line 1369
  if ((transforms & 4) != 0) {
    {
#line 1373
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKING not supported");
    }
  }
#line 1377
  if ((transforms & 256) != 0) {
    {
#line 1381
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ALPHA not supported");
    }
  }
#line 1388
  if ((transforms & 6144) != 0) {
    {
#line 1405
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_STRIP_FILLER not supported");
    }
  }
#line 1410
  if ((transforms & 128) != 0) {
    {
#line 1414
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_BGR not supported");
    }
  }
#line 1418
  if ((transforms & 512) != 0) {
    {
#line 1422
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ENDIAN not supported");
    }
  }
#line 1426
  if ((transforms & 8) != 0) {
    {
#line 1430
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKSWAP not supported");
    }
  }
#line 1434
  if ((transforms & 1024) != 0) {
    {
#line 1438
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_ALPHA not supported");
    }
  }
  {
#line 1444
  png_write_image(png_ptr, info_ptr->row_pointers);
#line 1447
  png_write_end(png_ptr, info_ptr);
  }
#line 1450
  return;
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 946 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
void png_default_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 951
void png_default_flush(png_structp png_ptr ) ;
#line 32 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwio.c"
void png_write_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) 
{ 


  {
#line 36
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
    {
#line 37
    (*(png_ptr->write_data_fn))((png_structp )png_ptr, (png_bytep )data, length);
    }
  } else {
    {
#line 41
    png_error((png_const_structrp )png_ptr, "Call to NULL write function");
    }
  }
#line 42
  return;
}
}
#line 50 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwio.c"
void png_default_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  png_size_t check ;

  {
#line 55
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 56
    return;
  }
  {
#line 58
  check = fwrite((void const   */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)((png_FILE_p )png_ptr->io_ptr));
  }
#line 60
  if (check != length) {
    {
#line 61
    png_error((png_const_structrp )png_ptr, "Write Error");
    }
  }
#line 62
  return;
}
}
#line 70 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwio.c"
void png_flush(png_structrp png_ptr ) 
{ 


  {
#line 73
  if ((unsigned long )png_ptr->output_flush_fn != (unsigned long )((void *)0)) {
    {
#line 74
    (*(png_ptr->output_flush_fn))((png_structp )png_ptr);
    }
  }
#line 75
  return;
}
}
#line 78 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwio.c"
void png_default_flush(png_structp png_ptr ) 
{ 
  png_FILE_p io_ptr ;

  {
#line 83
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 84
    return;
  }
  {
#line 86
  io_ptr = (png_FILE_p )png_ptr->io_ptr;
#line 87
  fflush(io_ptr);
  }
#line 88
  return;
}
}
#line 121 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngwio.c"
void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      png_size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) ) 
{ 


  {
#line 125
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 126
    return;
  }
#line 128
  png_ptr->io_ptr = io_ptr;
#line 131
  if ((unsigned long )write_data_fn != (unsigned long )((void *)0)) {
#line 132
    png_ptr->write_data_fn = write_data_fn;
  } else {
#line 135
    png_ptr->write_data_fn = & png_default_write_data;
  }
#line 143
  if ((unsigned long )output_flush_fn != (unsigned long )((void *)0)) {
#line 144
    png_ptr->output_flush_fn = output_flush_fn;
  } else {
#line 147
    png_ptr->output_flush_fn = & png_default_flush;
  }
#line 158
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
    {
#line 160
    png_ptr->read_data_fn = (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0);
#line 162
    png_warning((png_const_structrp )png_ptr, "Can\'t set both read_data_fn and write_data_fn in the same structure");
    }
  }
#line 167
  return;
}
}
#line 98 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngtrans.c"
int png_set_interlace_handling(png_structrp png_ptr ) 
{ 


  {
#line 103
  if ((unsigned long )png_ptr != (unsigned long )((png_structrp )0)) {
#line 103
    if ((int )png_ptr->interlaced != 0) {
#line 105
      png_ptr->transformations |= 2U;
#line 106
      return (7);
    }
  }
#line 109
  return (1);
}
}
#line 683 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngtrans.c"
void png_do_check_palette_indexes(png_structrp png_ptr , png_row_infop row_info ) 
{ 
  int padding ;
  png_bytep rp ;
  int i ;
  int i___0 ;

  {
#line 686
  if ((int )png_ptr->num_palette < 1 << (int )row_info->bit_depth) {
#line 686
    if ((int )png_ptr->num_palette > 0) {
#line 695
      padding = (int )((png_uint_32 )(- ((int )row_info->pixel_depth)) * row_info->width & 7U);
#line 696
      rp = png_ptr->row_buf + row_info->rowbytes;
      {
#line 700
      if ((int )row_info->bit_depth == 1) {
#line 700
        goto case_1;
      }
#line 715
      if ((int )row_info->bit_depth == 2) {
#line 715
        goto case_2;
      }
#line 745
      if ((int )row_info->bit_depth == 4) {
#line 745
        goto case_4;
      }
#line 765
      if ((int )row_info->bit_depth == 8) {
#line 765
        goto case_8;
      }
#line 776
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 705
          goto while_break;
        }
#line 707
        if ((int )*rp >> padding != 0) {
#line 708
          png_ptr->num_palette_max = 1;
        }
#line 709
        padding = 0;
#line 705
        rp --;
      }
      while_break: /* CIL Label */ ;
      }
#line 712
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 717
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 717
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 717
          goto while_break___0;
        }
#line 719
        i = ((int )*rp >> padding) & 3;
#line 721
        if (i > png_ptr->num_palette_max) {
#line 722
          png_ptr->num_palette_max = i;
        }
#line 724
        i = (((int )*rp >> padding) >> 2) & 3;
#line 726
        if (i > png_ptr->num_palette_max) {
#line 727
          png_ptr->num_palette_max = i;
        }
#line 729
        i = (((int )*rp >> padding) >> 4) & 3;
#line 731
        if (i > png_ptr->num_palette_max) {
#line 732
          png_ptr->num_palette_max = i;
        }
#line 734
        i = (((int )*rp >> padding) >> 6) & 3;
#line 736
        if (i > png_ptr->num_palette_max) {
#line 737
          png_ptr->num_palette_max = i;
        }
#line 739
        padding = 0;
#line 717
        rp --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 742
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 747
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 747
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 747
          goto while_break___1;
        }
#line 749
        i___0 = ((int )*rp >> padding) & 15;
#line 751
        if (i___0 > png_ptr->num_palette_max) {
#line 752
          png_ptr->num_palette_max = i___0;
        }
#line 754
        i___0 = (((int )*rp >> padding) >> 4) & 15;
#line 756
        if (i___0 > png_ptr->num_palette_max) {
#line 757
          png_ptr->num_palette_max = i___0;
        }
#line 759
        padding = 0;
#line 747
        rp --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 762
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 767
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 767
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 767
          goto while_break___2;
        }
#line 769
        if ((int )*rp > png_ptr->num_palette_max) {
#line 770
          png_ptr->num_palette_max = (int )*rp;
        }
#line 767
        rp --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 773
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 777
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 780
  return;
}
}
#line 942 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
void png_set_compression_buffer_size(png_structrp png_ptr , png_size_t size ) ;
#line 1729
png_voidp __attribute__((__malloc__))  png_malloc_warn(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) ;
#line 1736
void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 mask ,
                   int num ) ;
#line 1818
void png_set_benign_errors(png_structrp png_ptr , int allowed ) ;
#line 1860
void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) ;
#line 1935
void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) ;
#line 2007
void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) ;
#line 2016
void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                  png_uint_32 height , int bit_depth , int color_type , int interlace_type ,
                  int compression_type , int filter_type ) ;
#line 2060
void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                  int num_palette ) ;
#line 2069
void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2142
void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                  int num_trans , png_const_color_16p trans_color ) ;
#line 2274
void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                 int num_chunks_in ) ;
#line 2286
void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_const_unknown_chunkp unknowns ,
                            int num_unknowns ) ;
#line 2298
void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                    int chunk , int location ) ;
#line 2309
void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) ;
#line 2355
void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max , png_uint_32 user_height_max ) ;
#line 2362
void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) ;
#line 2367
void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_malloc_max ) ;
#line 2602
void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) ;
#line 888 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
png_voidp __attribute__((__malloc__))  png_malloc_base(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) ;
#line 903
png_voidp __attribute__((__malloc__))  png_realloc_array(png_const_structrp png_ptr ,
                                                         png_const_voidp old_array ,
                                                         int old_elements , int add_elements ,
                                                         size_t element_size ) ;
#line 1526
void png_check_IHDR(png_const_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int interlace_type , int compression_type ,
                    int filter_type ) ;
#line 1646
void png_chunk_report(png_const_structrp png_ptr , png_const_charp message , int error___0 ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) 
{ 


  {
#line 30
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 31
    return;
  } else
#line 30
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 31
    return;
  } else
#line 30
  if ((unsigned long )background == (unsigned long )((void *)0)) {
#line 31
    return;
  }
#line 33
  info_ptr->background = (png_color_16 )*background;
#line 34
  info_ptr->valid |= 32U;
#line 35
  return;
}
}
#line 162 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) 
{ 
  int i ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 170
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 171
    return;
  } else
#line 170
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 171
    return;
  }
#line 173
  if ((int )info_ptr->num_palette == 0) {
    {
#line 176
    png_warning(png_ptr, "Invalid palette size, hIST allocation skipped");
    }
#line 179
    return;
  } else
#line 173
  if ((int )info_ptr->num_palette > 256) {
    {
#line 176
    png_warning(png_ptr, "Invalid palette size, hIST allocation skipped");
    }
#line 179
    return;
  }
  {
#line 182
  png_free_data(png_ptr, info_ptr, (png_uint_32 )8, 0);
#line 187
  tmp = png_malloc_warn(png_ptr, 256UL * sizeof(png_uint_16 ));
#line 187
  info_ptr->hist = (png_uint_16p )tmp;
  }
#line 190
  if ((unsigned long )info_ptr->hist == (unsigned long )((void *)0)) {
    {
#line 192
    png_warning(png_ptr, "Insufficient memory for hIST chunk data");
    }
#line 194
    return;
  }
#line 197
  info_ptr->free_me |= 8U;
#line 199
  i = 0;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < (int )info_ptr->num_palette)) {
#line 199
      goto while_break;
    }
#line 200
    *(info_ptr->hist + i) = (png_uint_16 )*(hist + i);
#line 199
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  info_ptr->valid |= 64U;
#line 203
  return;
}
}
#line 206 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                  png_uint_32 height , int bit_depth , int color_type , int interlace_type ,
                  int compression_type , int filter_type ) 
{ 


  {
#line 214
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 215
    return;
  } else
#line 214
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 215
    return;
  }
  {
#line 217
  info_ptr->width = width;
#line 218
  info_ptr->height = height;
#line 219
  info_ptr->bit_depth = (png_byte )bit_depth;
#line 220
  info_ptr->color_type = (png_byte )color_type;
#line 221
  info_ptr->compression_type = (png_byte )compression_type;
#line 222
  info_ptr->filter_type = (png_byte )filter_type;
#line 223
  info_ptr->interlace_type = (png_byte )interlace_type;
#line 225
  png_check_IHDR(png_ptr, info_ptr->width, info_ptr->height, (int )info_ptr->bit_depth,
                 (int )info_ptr->color_type, (int )info_ptr->interlace_type, (int )info_ptr->compression_type,
                 (int )info_ptr->filter_type);
  }
#line 229
  if ((int )info_ptr->color_type == 3) {
#line 230
    info_ptr->channels = (png_byte )1;
  } else
#line 232
  if (((int )info_ptr->color_type & 2) != 0) {
#line 233
    info_ptr->channels = (png_byte )3;
  } else {
#line 236
    info_ptr->channels = (png_byte )1;
  }
#line 238
  if (((int )info_ptr->color_type & 4) != 0) {
#line 239
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 241
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 243
  if ((int )info_ptr->pixel_depth >= 8) {
#line 243
    info_ptr->rowbytes = (png_size_t )width * ((png_size_t )info_ptr->pixel_depth >> 3);
  } else {
#line 243
    info_ptr->rowbytes = ((png_size_t )width * (png_size_t )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 244
  return;
}
}
#line 511 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                  int num_palette ) 
{ 
  png_uint_32 max_palette_length ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_uint_16 tmp___0 ;

  {
#line 520
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 521
    return;
  } else
#line 520
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 521
    return;
  }
#line 523
  if ((int )info_ptr->color_type == 3) {
#line 523
    max_palette_length = (png_uint_32 )(1 << (int )info_ptr->bit_depth);
  } else {
#line 523
    max_palette_length = (png_uint_32 )256;
  }
#line 526
  if (num_palette < 0) {
#line 526
    goto _L;
  } else
#line 526
  if (num_palette > (int )max_palette_length) {
    _L: /* CIL Label */ 
#line 528
    if ((int )info_ptr->color_type == 3) {
      {
#line 529
      png_error((png_const_structrp )png_ptr, "Invalid palette length");
      }
    } else {
      {
#line 533
      png_warning((png_const_structrp )png_ptr, "Invalid palette length");
      }
#line 535
      return;
    }
  }
#line 539
  if (num_palette > 0) {
#line 539
    if ((unsigned long )palette == (unsigned long )((void *)0)) {
      {
#line 546
      png_error((png_const_structrp )png_ptr, "Invalid palette");
      }
    } else {
#line 539
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 539
  if (num_palette == 0) {
    {
#line 546
    png_error((png_const_structrp )png_ptr, "Invalid palette");
    }
  }
  {
#line 556
  png_free_data((png_const_structrp )png_ptr, info_ptr, (png_uint_32 )4096, 0);
#line 562
  tmp = png_calloc((png_const_structrp )png_ptr, 256UL * sizeof(png_color ));
#line 562
  png_ptr->palette = (png_colorp )tmp;
  }
#line 565
  if (num_palette > 0) {
    {
#line 566
    memcpy((void */* __restrict  */)png_ptr->palette, (void const   */* __restrict  */)palette,
           (unsigned long )num_palette * sizeof(png_color ));
    }
  }
#line 567
  info_ptr->palette = png_ptr->palette;
#line 568
  tmp___0 = (png_uint_16 )num_palette;
#line 568
  png_ptr->num_palette = tmp___0;
#line 568
  info_ptr->num_palette = tmp___0;
#line 570
  info_ptr->free_me |= 4096U;
#line 572
  info_ptr->valid |= 8U;
#line 573
  return;
}
}
#line 576 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) 
{ 


  {
#line 582
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 583
    return;
  } else
#line 582
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 583
    return;
  } else
#line 582
  if ((unsigned long )sig_bit == (unsigned long )((void *)0)) {
#line 583
    return;
  }
#line 585
  info_ptr->sig_bit = (png_color_8 )*sig_bit;
#line 586
  info_ptr->valid |= 2U;
#line 587
  return;
}
}
#line 932 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                  int num_trans , png_const_color_16p trans_color ) 
{ 
  png_bytep tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  int sample_max ;

  {
#line 938
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 940
    return;
  } else
#line 938
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 940
    return;
  }
#line 942
  if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
    {
#line 953
    png_free_data((png_const_structrp )png_ptr, info_ptr, (png_uint_32 )8192, 0);
#line 956
    tmp___0 = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )256);
#line 956
    tmp = (png_bytep )tmp___0;
#line 956
    info_ptr->trans_alpha = tmp;
#line 956
    png_ptr->trans_alpha = tmp;
    }
#line 959
    if (num_trans > 0) {
#line 959
      if (num_trans <= 256) {
        {
#line 960
        memcpy((void */* __restrict  */)info_ptr->trans_alpha, (void const   */* __restrict  */)trans_alpha,
               (png_size_t )num_trans);
        }
      }
    }
  }
#line 963
  if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 966
    if ((int )info_ptr->bit_depth < 16) {
#line 968
      sample_max = (1 << (int )info_ptr->bit_depth) - 1;
#line 970
      if ((int )info_ptr->color_type == 0) {
#line 970
        if ((int const   )trans_color->gray > (int const   )sample_max) {
          {
#line 976
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        } else {
#line 970
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 970
      if ((int )info_ptr->color_type == 2) {
#line 970
        if ((int const   )trans_color->red > (int const   )sample_max) {
          {
#line 976
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        } else
#line 970
        if ((int const   )trans_color->green > (int const   )sample_max) {
          {
#line 976
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        } else
#line 970
        if ((int const   )trans_color->blue > (int const   )sample_max) {
          {
#line 976
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        }
      }
    }
#line 981
    info_ptr->trans_color = (png_color_16 )*trans_color;
#line 983
    if (num_trans == 0) {
#line 984
      num_trans = 1;
    }
  }
#line 987
  info_ptr->num_trans = (png_uint_16 )num_trans;
#line 989
  if (num_trans != 0) {
#line 991
    info_ptr->valid |= 16U;
#line 992
    info_ptr->free_me |= 8192U;
  }
#line 994
  return;
}
}
#line 1098 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
static png_byte check_location(png_const_structrp png_ptr , int location ) 
{ 


  {
#line 1101
  location &= 11;
#line 1107
  if (location == 0) {
#line 1107
    if ((png_ptr->mode & 32768U) == 0U) {
      {
#line 1110
      png_app_warning(png_ptr, "png_set_unknown_chunks now expects a valid location");
#line 1113
      location = (int )((png_byte )(png_ptr->mode & 11U));
      }
    }
  }
#line 1120
  if (location == 0) {
    {
#line 1121
    png_error(png_ptr, "invalid location in png_set_unknown_chunks");
    }
  }
  {
#line 1126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1126
    if (! (location != (location & - location))) {
#line 1126
      goto while_break;
    }
#line 1127
    location &= ~ (location & - location);
  }
  while_break: /* CIL Label */ ;
  }
#line 1132
  return ((png_byte )location);
}
}
#line 1135 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_const_unknown_chunkp unknowns ,
                            int num_unknowns ) 
{ 
  png_unknown_chunkp np ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
#line 1141
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1143
    return;
  } else
#line 1141
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1143
    return;
  } else
#line 1141
  if (num_unknowns <= 0) {
#line 1143
    return;
  } else
#line 1141
  if ((unsigned long )unknowns == (unsigned long )((void *)0)) {
#line 1143
    return;
  }
  {
#line 1175
  tmp = png_realloc_array(png_ptr, (png_const_voidp )info_ptr->unknown_chunks, info_ptr->unknown_chunks_num,
                          num_unknowns, sizeof(*np));
#line 1175
  np = (png_unknown_chunkp )tmp;
  }
#line 1179
  if ((unsigned long )np == (unsigned long )((void *)0)) {
    {
#line 1181
    png_chunk_report(png_ptr, "too many unknown chunks", 1);
    }
#line 1184
    return;
  }
  {
#line 1187
  png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 1188
  info_ptr->unknown_chunks = np;
#line 1189
  info_ptr->free_me |= 512U;
#line 1191
  np += info_ptr->unknown_chunks_num;
  }
  {
#line 1196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1196
    if (! (num_unknowns > 0)) {
#line 1196
      goto while_break;
    }
    {
#line 1198
    memcpy((void */* __restrict  */)(np->name), (void const   */* __restrict  */)(unknowns->name),
           sizeof(np->name));
#line 1199
    np->name[sizeof(np->name) - 1UL] = (png_byte )'\000';
#line 1200
    np->location = check_location(png_ptr, (int )unknowns->location);
    }
#line 1202
    if (unknowns->size == 0UL) {
#line 1204
      np->data = (png_byte *)((void *)0);
#line 1205
      np->size = (png_size_t )0;
    } else {
      {
#line 1210
      tmp___0 = png_malloc_base(png_ptr, (png_alloc_size_t )unknowns->size);
#line 1210
      np->data = (png_byte *)tmp___0;
      }
#line 1213
      if ((unsigned long )np->data == (unsigned long )((void *)0)) {
        {
#line 1215
        png_chunk_report(png_ptr, "unknown chunk: out of memory", 1);
        }
#line 1218
        goto __Cont;
      }
      {
#line 1221
      memcpy((void */* __restrict  */)np->data, (void const   */* __restrict  */)unknowns->data,
             (size_t )unknowns->size);
#line 1222
      np->size = (png_size_t )unknowns->size;
      }
    }
#line 1229
    np ++;
#line 1230
    (info_ptr->unknown_chunks_num) ++;
    __Cont: /* CIL Label */ 
#line 1196
    num_unknowns --;
#line 1196
    unknowns ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1232
  return;
}
}
#line 1234 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                    int chunk , int location ) 
{ 


  {
#line 1243
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1243
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1243
      if (chunk >= 0) {
#line 1243
        if (chunk < info_ptr->unknown_chunks_num) {
#line 1246
          if ((location & 11) == 0) {
            {
#line 1248
            png_app_error(png_ptr, "invalid unknown chunk location");
            }
#line 1250
            if ((location & 4) != 0) {
#line 1251
              location = 8;
            } else {
#line 1254
              location = 1;
            }
          }
          {
#line 1257
          (info_ptr->unknown_chunks + chunk)->location = check_location(png_ptr, location);
          }
        }
      }
    }
  }
#line 1260
  return;
}
}
#line 1279 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
static unsigned int add_one_chunk(png_bytep list , unsigned int count , png_const_bytep add ,
                                  int keep ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 1287
  i = 0U;
  {
#line 1287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1287
    if (! (i < count)) {
#line 1287
      goto while_break;
    }
    {
#line 1289
    tmp = memcmp((void const   *)list, (void const   *)add, (size_t )4);
    }
#line 1289
    if (tmp == 0) {
#line 1291
      *(list + 4) = (png_byte )keep;
#line 1293
      return (count);
    }
#line 1287
    i ++;
#line 1287
    list += 5;
  }
  while_break: /* CIL Label */ ;
  }
#line 1297
  if (keep != 0) {
    {
#line 1299
    count ++;
#line 1300
    memcpy((void */* __restrict  */)list, (void const   */* __restrict  */)add, (size_t )4);
#line 1301
    *(list + 4) = (png_byte )keep;
    }
  }
#line 1304
  return (count);
}
}
#line 1338 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
static png_byte const   chunks_to_ignore[85]  = 
#line 1338
  {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68, 
        (png_byte const   )'\000',      (png_byte const   )99,      (png_byte const   )72,      (png_byte const   )82, 
        (png_byte const   )77,      (png_byte const   )'\000',      (png_byte const   )103,      (png_byte const   )65, 
        (png_byte const   )77,      (png_byte const   )65,      (png_byte const   )'\000',      (png_byte const   )104, 
        (png_byte const   )73,      (png_byte const   )83,      (png_byte const   )84,      (png_byte const   )'\000', 
        (png_byte const   )105,      (png_byte const   )67,      (png_byte const   )67,      (png_byte const   )80, 
        (png_byte const   )'\000',      (png_byte const   )105,      (png_byte const   )84,      (png_byte const   )88, 
        (png_byte const   )116,      (png_byte const   )'\000',      (png_byte const   )111,      (png_byte const   )70, 
        (png_byte const   )70,      (png_byte const   )115,      (png_byte const   )'\000',      (png_byte const   )112, 
        (png_byte const   )67,      (png_byte const   )65,      (png_byte const   )76,      (png_byte const   )'\000', 
        (png_byte const   )112,      (png_byte const   )72,      (png_byte const   )89,      (png_byte const   )115, 
        (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )66,      (png_byte const   )73, 
        (png_byte const   )84,      (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )67, 
        (png_byte const   )65,      (png_byte const   )76,      (png_byte const   )'\000',      (png_byte const   )115, 
        (png_byte const   )80,      (png_byte const   )76,      (png_byte const   )84,      (png_byte const   )'\000', 
        (png_byte const   )115,      (png_byte const   )84,      (png_byte const   )69,      (png_byte const   )82, 
        (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )82,      (png_byte const   )71, 
        (png_byte const   )66,      (png_byte const   )'\000',      (png_byte const   )116,      (png_byte const   )69, 
        (png_byte const   )88,      (png_byte const   )116,      (png_byte const   )'\000',      (png_byte const   )116, 
        (png_byte const   )73,      (png_byte const   )77,      (png_byte const   )69,      (png_byte const   )'\000', 
        (png_byte const   )122,      (png_byte const   )84,      (png_byte const   )88,      (png_byte const   )116, 
        (png_byte const   )'\000'};
#line 1307 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                 int num_chunks_in ) 
{ 
  png_bytep new_list ;
  unsigned int num_chunks ;
  unsigned int old_num_chunks ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_const_bytep inlist ;
  png_bytep outlist ;
  unsigned int i ;

  {
#line 1314
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1315
    return;
  }
#line 1317
  if (keep < 0) {
    {
#line 1319
    png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: invalid keep");
    }
#line 1321
    return;
  } else
#line 1317
  if (keep >= 4) {
    {
#line 1319
    png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: invalid keep");
    }
#line 1321
    return;
  }
#line 1324
  if (num_chunks_in <= 0) {
#line 1326
    png_ptr->unknown_default = keep;
#line 1329
    if (num_chunks_in == 0) {
#line 1330
      return;
    }
  }
#line 1333
  if (num_chunks_in < 0) {
#line 1358
    chunk_list = chunks_to_ignore;
#line 1359
    num_chunks = (unsigned int )sizeof(chunks_to_ignore) / 5U;
  } else {
#line 1364
    if ((unsigned long )chunk_list == (unsigned long )((void *)0)) {
      {
#line 1369
      png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: no chunk list");
      }
#line 1371
      return;
    }
#line 1374
    num_chunks = (unsigned int )num_chunks_in;
  }
#line 1377
  old_num_chunks = png_ptr->num_chunk_list;
#line 1378
  if ((unsigned long )png_ptr->chunk_list == (unsigned long )((void *)0)) {
#line 1379
    old_num_chunks = 0U;
  }
#line 1383
  if (num_chunks + old_num_chunks > 858993459U) {
    {
#line 1385
    png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: too many chunks");
    }
#line 1387
    return;
  }
#line 1394
  if (keep != 0) {
    {
#line 1396
    tmp = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )(5U * (num_chunks + old_num_chunks)));
#line 1396
    new_list = (png_bytep )tmp;
    }
#line 1399
    if (old_num_chunks > 0U) {
      {
#line 1400
      memcpy((void */* __restrict  */)new_list, (void const   */* __restrict  */)png_ptr->chunk_list,
             (size_t )(5U * old_num_chunks));
      }
    }
  } else
#line 1403
  if (old_num_chunks > 0U) {
#line 1404
    new_list = png_ptr->chunk_list;
  } else {
#line 1407
    new_list = (png_bytep )((void *)0);
  }
#line 1414
  if ((unsigned long )new_list != (unsigned long )((void *)0)) {
#line 1420
    i = 0U;
    {
#line 1420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1420
      if (! (i < num_chunks)) {
#line 1420
        goto while_break;
      }
      {
#line 1422
      old_num_chunks = add_one_chunk(new_list, old_num_chunks, chunk_list + 5U * i,
                                     keep);
#line 1420
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1427
    num_chunks = 0U;
#line 1428
    i = 0U;
#line 1428
    outlist = new_list;
#line 1428
    inlist = (png_const_bytep )outlist;
    {
#line 1428
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1428
      if (! (i < old_num_chunks)) {
#line 1428
        goto while_break___0;
      }
#line 1430
      if (*(inlist + 4)) {
#line 1432
        if ((unsigned long )outlist != (unsigned long )inlist) {
          {
#line 1433
          memcpy((void */* __restrict  */)outlist, (void const   */* __restrict  */)inlist,
                 (size_t )5);
          }
        }
#line 1434
        outlist += 5;
#line 1435
        num_chunks ++;
      }
#line 1428
      i ++;
#line 1428
      inlist += 5;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1440
    if (num_chunks == 0U) {
#line 1442
      if ((unsigned long )png_ptr->chunk_list != (unsigned long )new_list) {
        {
#line 1443
        png_free((png_const_structrp )png_ptr, (png_voidp )new_list);
        }
      }
#line 1445
      new_list = (png_bytep )((void *)0);
    }
  } else {
#line 1450
    num_chunks = 0U;
  }
#line 1452
  png_ptr->num_chunk_list = num_chunks;
#line 1454
  if ((unsigned long )png_ptr->chunk_list != (unsigned long )new_list) {
#line 1456
    if ((unsigned long )png_ptr->chunk_list != (unsigned long )((void *)0)) {
      {
#line 1457
      png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
      }
    }
#line 1459
    png_ptr->chunk_list = new_list;
  }
#line 1461
  return;
}
}
#line 1480 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) 
{ 


  {
#line 1486
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1487
    return;
  } else
#line 1486
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1487
    return;
  }
#line 1489
  if ((unsigned long )info_ptr->row_pointers != (unsigned long )((void *)0)) {
#line 1489
    if ((unsigned long )info_ptr->row_pointers != (unsigned long )row_pointers) {
      {
#line 1491
      png_free_data(png_ptr, info_ptr, (png_uint_32 )64, 0);
      }
    }
  }
#line 1493
  info_ptr->row_pointers = row_pointers;
#line 1495
  if ((unsigned long )row_pointers != (unsigned long )((void *)0)) {
#line 1496
    info_ptr->valid |= 32768U;
  }
#line 1497
  return;
}
}
#line 1500 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_compression_buffer_size(png_structrp png_ptr , png_size_t size ) 
{ 


  {
#line 1503
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1504
    return;
  }
#line 1506
  if (size == 0UL) {
    {
#line 1507
    png_error((png_const_structrp )png_ptr, "invalid compression buffer size");
    }
  } else
#line 1506
  if (size > 2147483647UL) {
    {
#line 1507
    png_error((png_const_structrp )png_ptr, "invalid compression buffer size");
    }
  }
#line 1510
  if ((png_ptr->mode & 32768U) != 0U) {
#line 1512
    png_ptr->IDAT_read_size = (png_uint_32 )size;
#line 1513
    return;
  }
#line 1518
  if ((png_ptr->mode & 32768U) == 0U) {
#line 1520
    if (png_ptr->zowner != 0U) {
      {
#line 1522
      png_warning((png_const_structrp )png_ptr, "Compression buffer size cannot be changed because it is in use");
      }
#line 1525
      return;
    }
#line 1532
    if (size > 4294967295UL) {
      {
#line 1534
      png_warning((png_const_structrp )png_ptr, "Compression buffer size limited to system maximum");
#line 1536
      size = (png_size_t )((uInt )-1);
      }
    }
#line 1540
    if (size < 6UL) {
      {
#line 1545
      png_warning((png_const_structrp )png_ptr, "Compression buffer size cannot be reduced below 6");
      }
#line 1548
      return;
    }
#line 1551
    if ((png_size_t )png_ptr->zbuffer_size != size) {
      {
#line 1553
      png_free_buffer_list(png_ptr, & png_ptr->zbuffer_list);
#line 1554
      png_ptr->zbuffer_size = (uInt )size;
      }
    }
  }
#line 1558
  return;
}
}
#line 1560 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) 
{ 


  {
#line 1563
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1563
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1564
      info_ptr->valid &= (unsigned int )(~ mask);
    }
  }
#line 1565
  return;
}
}
#line 1570 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max , png_uint_32 user_height_max ) 
{ 


  {
#line 1578
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1579
    return;
  }
#line 1581
  png_ptr->user_width_max = user_width_max;
#line 1582
  png_ptr->user_height_max = user_height_max;
#line 1583
  return;
}
}
#line 1586 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) 
{ 


  {
#line 1589
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1590
    png_ptr->user_chunk_cache_max = user_chunk_cache_max;
  }
#line 1591
  return;
}
}
#line 1594 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_malloc_max ) 
{ 


  {
#line 1598
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1599
    png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
  }
#line 1600
  return;
}
}
#line 1605 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_benign_errors(png_structrp png_ptr , int allowed ) 
{ 


  {
#line 1616
  if (allowed != 0) {
#line 1617
    png_ptr->flags |= 7340032U;
  } else {
#line 1621
    png_ptr->flags &= 4287627263U;
  }
#line 1623
  return;
}
}
#line 1635 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngset.c"
void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) 
{ 


  {
#line 1640
  if (allowed > 0) {
#line 1641
    png_ptr->num_palette_max = 0;
  } else {
#line 1644
    png_ptr->num_palette_max = -1;
  }
#line 1645
  return;
}
}
#line 919 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
int png_sig_cmp(png_const_bytep sig , png_size_t start , png_size_t num_to_check ) ;
#line 1783
 __attribute__((__noreturn__)) void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1799
void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1814
void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 2534
png_uint_32 png_get_uint_32(png_const_bytep buf ) ;
#line 2535
png_uint_16 png_get_uint_16(png_const_bytep buf ) ;
#line 2536
png_int_32 png_get_int_32(png_const_bytep buf ) ;
#line 2539
png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) ;
#line 964 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
void png_read_sig(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 968
png_uint_32 png_read_chunk_header(png_structrp png_ptr ) ;
#line 972
void png_read_data(png_structrp png_ptr , png_bytep data , png_size_t length ) ;
#line 976
void png_crc_read(png_structrp png_ptr , png_bytep buf , png_uint_32 length ) ;
#line 980
int png_crc_finish(png_structrp png_ptr , png_uint_32 skip ) ;
#line 984
int png_crc_error(png_structrp png_ptr ) ;
#line 1149
void png_combine_row(png_const_structrp png_ptr , png_bytep dp , int display ) ;
#line 1159
void png_do_read_interlace(png_row_infop row_info , png_bytep row , int pass , png_uint_32 transformations ) ;
#line 1174
void png_read_filter_row(png_structrp pp , png_row_infop row_info , png_bytep row ,
                         png_const_bytep prev_row , int filter ) ;
#line 1197
void png_read_IDAT_data(png_structrp png_ptr , png_bytep output , png_alloc_size_t avail_out ) ;
#line 1204
void png_read_finish_IDAT(png_structrp png_ptr ) ;
#line 1210
void png_read_finish_row(png_structrp png_ptr ) ;
#line 1216
void png_read_start_row(png_structrp png_ptr ) ;
#line 1267
void png_handle_IHDR(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1269
void png_handle_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1271
void png_handle_IEND(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1275
void png_handle_bKGD(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1290
void png_handle_hIST(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1320
void png_handle_sBIT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1350
void png_handle_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1359
void png_check_chunk_name(png_structrp png_ptr , png_uint_32 chunk_name ) ;
#line 1362
void png_handle_unknown(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ,
                        int keep ) ;
#line 1390
void png_init_read_transformations(png_structrp png_ptr ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) 
{ 
  png_uint_32 uval ;

  {
#line 24
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 26
  if (uval > 2147483647U) {
    {
#line 27
    png_error(png_ptr, "PNG unsigned integer out of range");
    }
  }
#line 29
  return (uval);
}
}
#line 67 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
png_uint_32 png_get_uint_32(png_const_bytep buf ) 
{ 
  png_uint_32 uval ;

  {
#line 70
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 76
  return (uval);
}
}
#line 84 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
png_int_32 png_get_int_32(png_const_bytep buf ) 
{ 
  png_uint_32 uval ;

  {
#line 87
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 88
  if ((uval & 2147483648U) == 0U) {
#line 89
    return ((png_int_32 )uval);
  }
#line 91
  uval = (uval ^ 4294967295U) + 1U;
#line 92
  if ((uval & 2147483648U) == 0U) {
#line 93
    return (- ((png_int_32 )uval));
  }
#line 98
  return (0);
}
}
#line 102 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
png_uint_16 png_get_uint_16(png_const_bytep buf ) 
{ 
  unsigned int val ;

  {
#line 110
  val = ((unsigned int )*buf << 8) + (unsigned int )*(buf + 1);
#line 114
  return ((png_uint_16 )val);
}
}
#line 120 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_read_sig(png_structrp png_ptr , png_inforp info_ptr ) 
{ 
  png_size_t num_checked ;
  png_size_t num_to_check ;
  int tmp ;
  int tmp___0 ;

  {
#line 126
  if ((int )png_ptr->sig_bytes >= 8) {
#line 127
    return;
  }
  {
#line 129
  num_checked = (png_size_t )png_ptr->sig_bytes;
#line 130
  num_to_check = 8UL - num_checked;
#line 133
  png_ptr->io_state = (png_uint_32 )17;
#line 137
  png_read_data(png_ptr, & info_ptr->signature[num_checked], num_to_check);
#line 138
  png_ptr->sig_bytes = (png_byte )8;
#line 140
  tmp___0 = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check);
  }
#line 140
  if (tmp___0 != 0) {
#line 142
    if (num_checked < 4UL) {
      {
#line 142
      tmp = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check - 4UL);
      }
#line 142
      if (tmp) {
        {
#line 144
        png_error((png_const_structrp )png_ptr, "Not a PNG file");
        }
      } else {
        {
#line 146
        png_error((png_const_structrp )png_ptr, "PNG file corrupted by ASCII conversion");
        }
      }
    } else {
      {
#line 146
      png_error((png_const_structrp )png_ptr, "PNG file corrupted by ASCII conversion");
      }
    }
  }
#line 148
  if (num_checked < 3UL) {
#line 149
    png_ptr->mode |= 4096U;
  }
#line 150
  return;
}
}
#line 155 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
png_uint_32 png_read_chunk_header(png_structrp png_ptr ) 
{ 
  png_byte buf[8] ;
  png_uint_32 length ;

  {
  {
#line 162
  png_ptr->io_state = (png_uint_32 )33;
#line 168
  png_read_data(png_ptr, buf, (png_size_t )8);
#line 169
  length = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf));
#line 172
  png_ptr->chunk_name = ((((png_uint_32 )(255 & (int )*((buf + 4) + 0)) << 24) | ((png_uint_32 )(255 & (int )*((buf + 4) + 1)) << 16)) | ((png_uint_32 )(255 & (int )*((buf + 4) + 2)) << 8)) | (png_uint_32 )(255 & (int )*((buf + 4) + 3));
#line 178
  png_reset_crc(png_ptr);
#line 179
  png_calculate_crc(png_ptr, (png_const_bytep )(buf + 4), (png_size_t )4);
#line 182
  png_check_chunk_name(png_ptr, png_ptr->chunk_name);
#line 185
  png_ptr->io_state = (png_uint_32 )65;
  }
#line 188
  return (length);
}
}
#line 192 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_crc_read(png_structrp png_ptr , png_bytep buf , png_uint_32 length ) 
{ 


  {
#line 195
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 196
    return;
  }
  {
#line 198
  png_read_data(png_ptr, buf, (png_size_t )length);
#line 199
  png_calculate_crc(png_ptr, (png_const_bytep )buf, (png_size_t )length);
  }
#line 200
  return;
}
}
#line 207 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
int png_crc_finish(png_structrp png_ptr , png_uint_32 skip ) 
{ 
  png_uint_32 len ;
  png_byte tmpbuf[1024] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (skip > 0U)) {
#line 213
      goto while_break;
    }
#line 218
    len = (png_uint_32 )sizeof(tmpbuf);
#line 219
    if (len > skip) {
#line 220
      len = skip;
    }
    {
#line 221
    skip -= len;
#line 223
    png_crc_read(png_ptr, tmpbuf, len);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  tmp___0 = png_crc_error(png_ptr);
  }
#line 226
  if (tmp___0 != 0) {
#line 228
    if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 228
      tmp = (png_ptr->flags & 512U) == 0U;
    } else {
#line 228
      tmp = (png_ptr->flags & 1024U) != 0U;
    }
#line 228
    if (tmp) {
      {
#line 232
      png_chunk_warning((png_const_structrp )png_ptr, "CRC error");
      }
    } else {
      {
#line 236
      png_chunk_error((png_const_structrp )png_ptr, "CRC error");
      }
    }
#line 238
    return (1);
  }
#line 241
  return (0);
}
}
#line 247 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
int png_crc_error(png_structrp png_ptr ) 
{ 
  png_byte crc_bytes[4] ;
  png_uint_32 crc ;
  int need_crc ;

  {
#line 252
  need_crc = 1;
#line 254
  if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 256
    if ((png_ptr->flags & 768U) == 768U) {
#line 258
      need_crc = 0;
    }
  } else
#line 263
  if ((png_ptr->flags & 2048U) != 0U) {
#line 264
    need_crc = 0;
  }
  {
#line 268
  png_ptr->io_state = (png_uint_32 )129;
#line 272
  png_read_data(png_ptr, crc_bytes, (png_size_t )4);
  }
#line 274
  if (need_crc != 0) {
#line 276
    crc = ((((png_uint_32 )crc_bytes[0] << 24) + ((png_uint_32 )*(crc_bytes + 1) << 16)) + ((png_uint_32 )*(crc_bytes + 2) << 8)) + (png_uint_32 )*(crc_bytes + 3);
#line 277
    return (crc != png_ptr->crc);
  } else {
#line 281
    return (0);
  }
}
}
#line 294 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_bytep png_read_buffer(png_structrp png_ptr , png_alloc_size_t new_size ,
                                 int warn ) 
{ 
  png_bytep buffer___0 ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 297
  buffer___0 = png_ptr->read_buffer;
#line 299
  if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 299
    if (new_size > png_ptr->read_buffer_size) {
      {
#line 301
      png_ptr->read_buffer = (png_bytep )((void *)0);
#line 302
      png_ptr->read_buffer = (png_bytep )((void *)0);
#line 303
      png_ptr->read_buffer_size = (png_alloc_size_t )0;
#line 304
      png_free((png_const_structrp )png_ptr, (png_voidp )buffer___0);
#line 305
      buffer___0 = (png_bytep )((void *)0);
      }
    }
  }
#line 308
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
    {
#line 310
    tmp = png_malloc_base((png_const_structrp )png_ptr, new_size);
#line 310
    buffer___0 = (png_bytep )tmp;
    }
#line 312
    if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 314
      png_ptr->read_buffer = buffer___0;
#line 315
      png_ptr->read_buffer_size = new_size;
    } else
#line 318
    if (warn < 2) {
#line 320
      if (warn != 0) {
        {
#line 321
        png_chunk_warning((png_const_structrp )png_ptr, "insufficient memory to read chunk");
        }
      } else {
        {
#line 324
        png_chunk_error((png_const_structrp )png_ptr, "insufficient memory to read chunk");
        }
      }
    }
  }
#line 328
  return (buffer___0);
}
}
#line 337 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static int png_inflate_claim(png_structrp png_ptr , png_uint_32 owner ) 
{ 
  char msg___0[64] ;
  int ret ;

  {
#line 340
  if (png_ptr->zowner != 0U) {
    {
#line 344
    msg___0[0] = (char )((png_ptr->zowner >> 24) & 255U);
#line 344
    msg___0[1] = (char )((png_ptr->zowner >> 16) & 255U);
#line 344
    msg___0[2] = (char )((png_ptr->zowner >> 8) & 255U);
#line 344
    msg___0[3] = (char )(png_ptr->zowner & 255U);
#line 349
    png_safecat(msg___0, sizeof(msg___0), (size_t )4, " using zstream");
#line 351
    png_chunk_warning((png_const_structrp )png_ptr, (png_const_charp )(msg___0));
#line 352
    png_ptr->zowner = (png_uint_32 )0;
    }
  }
#line 398
  png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 399
  png_ptr->zstream.avail_in = (uInt )0;
#line 400
  png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 401
  png_ptr->zstream.avail_out = (uInt )0;
#line 403
  if ((png_ptr->flags & 2U) != 0U) {
    {
#line 406
    ret = inflateReset(& png_ptr->zstream);
    }
  } else {
    {
#line 415
    ret = inflateInit_(& png_ptr->zstream, "1.2.8-optipng", (int )sizeof(z_stream ));
    }
#line 420
    if (ret == 0) {
#line 421
      png_ptr->flags |= 2U;
    }
  }
#line 424
  if (ret == 0) {
#line 425
    png_ptr->zowner = owner;
  } else {
    {
#line 428
    png_zstream_error(png_ptr, ret);
    }
  }
#line 430
  return (ret);
}
}
#line 828 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_IHDR(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  png_byte buf[13] ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int compression_type ;
  int filter_type ;
  int interlace_type ;

  {
#line 838
  if ((png_ptr->mode & 1U) != 0U) {
    {
#line 839
    png_chunk_error((png_const_structrp )png_ptr, "out of place");
    }
  }
#line 842
  if (length != 13U) {
    {
#line 843
    png_chunk_error((png_const_structrp )png_ptr, "invalid");
    }
  }
  {
#line 845
  png_ptr->mode |= 1U;
#line 847
  png_crc_read(png_ptr, buf, (png_uint_32 )13);
#line 848
  png_crc_finish(png_ptr, (png_uint_32 )0);
#line 850
  width = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf));
#line 851
  height = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf + 4));
#line 852
  bit_depth = (int )buf[8];
#line 853
  color_type = (int )buf[9];
#line 854
  compression_type = (int )buf[10];
#line 855
  filter_type = (int )buf[11];
#line 856
  interlace_type = (int )buf[12];
#line 859
  png_ptr->width = width;
#line 860
  png_ptr->height = height;
#line 861
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 862
  png_ptr->interlaced = (png_byte )interlace_type;
#line 863
  png_ptr->color_type = (png_byte )color_type;
#line 867
  png_ptr->compression_type = (png_byte )compression_type;
  }
  {
#line 878
  if ((int )png_ptr->color_type == 2) {
#line 878
    goto case_2;
  }
#line 882
  if ((int )png_ptr->color_type == 4) {
#line 882
    goto case_4;
  }
#line 886
  if ((int )png_ptr->color_type == 6) {
#line 886
    goto case_6;
  }
#line 872
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 875
  png_ptr->channels = (png_byte )1;
#line 876
  goto switch_break;
  case_2: /* CIL Label */ 
#line 879
  png_ptr->channels = (png_byte )3;
#line 880
  goto switch_break;
  case_4: /* CIL Label */ 
#line 883
  png_ptr->channels = (png_byte )2;
#line 884
  goto switch_break;
  case_6: /* CIL Label */ 
#line 887
  png_ptr->channels = (png_byte )4;
#line 888
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 892
  png_ptr->pixel_depth = (png_byte )((int )png_ptr->bit_depth * (int )png_ptr->channels);
#line 893
  if ((int )png_ptr->pixel_depth >= 8) {
#line 893
    png_ptr->rowbytes = (png_size_t )png_ptr->width * ((png_size_t )png_ptr->pixel_depth >> 3);
  } else {
#line 893
    png_ptr->rowbytes = ((png_size_t )png_ptr->width * (png_size_t )png_ptr->pixel_depth + 7UL) >> 3;
  }
  {
#line 897
  png_set_IHDR((png_const_structrp )png_ptr, info_ptr, width, height, bit_depth, color_type,
               interlace_type, compression_type, filter_type);
  }
#line 899
  return;
}
}
#line 902 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  png_color palette[256] ;
  int max_palette_length ;
  int num ;
  int i ;
  png_colorp pal_ptr ;
  png_byte buf[3] ;

  {
#line 913
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 914
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 921
  if ((png_ptr->mode & 2U) != 0U) {
    {
#line 922
    png_chunk_error((png_const_structrp )png_ptr, "duplicate");
    }
  } else
#line 924
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 929
    png_crc_finish(png_ptr, length);
#line 930
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 931
    return;
  }
#line 934
  png_ptr->mode |= 2U;
#line 936
  if (((int )png_ptr->color_type & 2) == 0) {
    {
#line 938
    png_crc_finish(png_ptr, length);
#line 939
    png_chunk_benign_error((png_const_structrp )png_ptr, "ignored in grayscale PNG");
    }
#line 940
    return;
  }
#line 951
  if (length > 768U) {
#line 951
    goto _L;
  } else
#line 951
  if (length % 3U) {
    _L: /* CIL Label */ 
    {
#line 953
    png_crc_finish(png_ptr, length);
    }
#line 955
    if ((int )png_ptr->color_type != 3) {
      {
#line 956
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
    } else {
      {
#line 959
      png_chunk_error((png_const_structrp )png_ptr, "invalid");
      }
    }
#line 961
    return;
  }
#line 965
  num = (int )length / 3;
#line 972
  if ((int )png_ptr->color_type == 3) {
#line 973
    max_palette_length = 1 << (int )png_ptr->bit_depth;
  } else {
#line 975
    max_palette_length = 256;
  }
#line 977
  if (num > max_palette_length) {
#line 978
    num = max_palette_length;
  }
#line 981
  i = 0;
#line 981
  pal_ptr = palette;
  {
#line 981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 981
    if (! (i < num)) {
#line 981
      goto while_break;
    }
    {
#line 985
    png_crc_read(png_ptr, buf, (png_uint_32 )3);
#line 986
    pal_ptr->red = buf[0];
#line 987
    pal_ptr->green = buf[1];
#line 988
    pal_ptr->blue = buf[2];
#line 981
    i ++;
#line 981
    pal_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1012
  png_crc_finish(png_ptr, (png_uint_32 )((int )length - num * 3));
#line 1050
  png_set_PLTE(png_ptr, info_ptr, (png_const_colorp )(palette), num);
  }
#line 1062
  if ((int )png_ptr->num_trans > 0) {
#line 1062
    goto _L___0;
  } else
#line 1062
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1062
    if ((info_ptr->valid & 16U) != 0U) {
      _L___0: /* CIL Label */ 
#line 1069
      png_ptr->num_trans = (png_uint_16 )0;
#line 1071
      if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1072
        info_ptr->num_trans = (png_uint_16 )0;
      }
      {
#line 1074
      png_chunk_benign_error((png_const_structrp )png_ptr, "tRNS must be after");
      }
    }
  }
#line 1079
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1079
    if ((info_ptr->valid & 64U) != 0U) {
      {
#line 1080
      png_chunk_benign_error((png_const_structrp )png_ptr, "hIST must be after");
      }
    }
  }
#line 1084
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1084
    if ((info_ptr->valid & 32U) != 0U) {
      {
#line 1085
      png_chunk_benign_error((png_const_structrp )png_ptr, "bKGD must be after");
      }
    }
  }
#line 1087
  return;
}
}
#line 1089 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_IEND(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 


  {
#line 1094
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1096
    png_chunk_error((png_const_structrp )png_ptr, "out of place");
    }
  } else
#line 1094
  if ((png_ptr->mode & 4U) == 0U) {
    {
#line 1096
    png_chunk_error((png_const_structrp )png_ptr, "out of place");
    }
  }
  {
#line 1098
  png_ptr->mode |= 24U;
#line 1100
  png_crc_finish(png_ptr, length);
  }
#line 1102
  if (length != 0U) {
    {
#line 1103
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
  }
#line 1106
  return;
}
}
#line 1147 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_sBIT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  unsigned int truelen ;
  unsigned int i ;
  png_byte sample_depth ;
  png_byte buf[4] ;
  int tmp ;

  {
#line 1156
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1157
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 1159
  if ((png_ptr->mode & 6U) != 0U) {
    {
#line 1161
    png_crc_finish(png_ptr, length);
#line 1162
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 1163
    return;
  }
#line 1166
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1166
    if ((info_ptr->valid & 2U) != 0U) {
      {
#line 1168
      png_crc_finish(png_ptr, length);
#line 1169
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 1170
      return;
    }
  }
#line 1173
  if ((int )png_ptr->color_type == 3) {
#line 1175
    truelen = 3U;
#line 1176
    sample_depth = (png_byte )8;
  } else {
#line 1181
    truelen = (unsigned int )png_ptr->channels;
#line 1182
    sample_depth = png_ptr->bit_depth;
  }
#line 1185
  if (length != truelen) {
    {
#line 1187
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
#line 1188
    png_crc_finish(png_ptr, length);
    }
#line 1189
    return;
  } else
#line 1185
  if (length > 4U) {
    {
#line 1187
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
#line 1188
    png_crc_finish(png_ptr, length);
    }
#line 1189
    return;
  }
  {
#line 1192
  buf[3] = sample_depth;
#line 1192
  buf[2] = buf[3];
#line 1192
  buf[1] = buf[2];
#line 1192
  buf[0] = buf[1];
#line 1193
  png_crc_read(png_ptr, buf, truelen);
#line 1195
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1195
  if (tmp != 0) {
#line 1196
    return;
  }
#line 1198
  i = 0U;
  {
#line 1198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1198
    if (! (i < truelen)) {
#line 1198
      goto while_break;
    }
#line 1200
    if ((int )buf[i] == 0) {
      {
#line 1202
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1203
      return;
    } else
#line 1200
    if ((int )buf[i] > (int )sample_depth) {
      {
#line 1202
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1203
      return;
    }
#line 1198
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1207
  if (((int )png_ptr->color_type & 2) != 0) {
#line 1209
    png_ptr->sig_bit.red = buf[0];
#line 1210
    png_ptr->sig_bit.green = buf[1];
#line 1211
    png_ptr->sig_bit.blue = buf[2];
#line 1212
    png_ptr->sig_bit.alpha = buf[3];
  } else {
#line 1217
    png_ptr->sig_bit.gray = buf[0];
#line 1218
    png_ptr->sig_bit.red = buf[0];
#line 1219
    png_ptr->sig_bit.green = buf[0];
#line 1220
    png_ptr->sig_bit.blue = buf[0];
#line 1221
    png_ptr->sig_bit.alpha = buf[1];
  }
  {
#line 1224
  png_set_sBIT((png_const_structrp )png_ptr, info_ptr, (png_const_color_8p )(& png_ptr->sig_bit));
  }
#line 1225
  return;
}
}
#line 1803 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  png_byte readbuf[256] ;
  png_byte buf[2] ;
  png_byte buf___0[6] ;
  int tmp ;

  {
#line 1810
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1811
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 1813
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 1815
    png_crc_finish(png_ptr, length);
#line 1816
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 1817
    return;
  } else
#line 1820
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1820
    if ((info_ptr->valid & 16U) != 0U) {
      {
#line 1822
      png_crc_finish(png_ptr, length);
#line 1823
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 1824
      return;
    }
  }
#line 1827
  if ((int )png_ptr->color_type == 0) {
#line 1831
    if (length != 2U) {
      {
#line 1833
      png_crc_finish(png_ptr, length);
#line 1834
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1835
      return;
    }
    {
#line 1838
    png_crc_read(png_ptr, buf, (png_uint_32 )2);
#line 1839
    png_ptr->num_trans = (png_uint_16 )1;
#line 1840
    png_ptr->trans_color.gray = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
    }
  } else
#line 1843
  if ((int )png_ptr->color_type == 2) {
#line 1847
    if (length != 6U) {
      {
#line 1849
      png_crc_finish(png_ptr, length);
#line 1850
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1851
      return;
    }
    {
#line 1854
    png_crc_read(png_ptr, buf___0, length);
#line 1855
    png_ptr->num_trans = (png_uint_16 )1;
#line 1856
    png_ptr->trans_color.red = (png_uint_16 )(((unsigned int )buf___0[0] << 8) + (unsigned int )*(buf___0 + 1));
#line 1857
    png_ptr->trans_color.green = (png_uint_16 )(((unsigned int )*(buf___0 + 2) << 8) + (unsigned int )*((buf___0 + 2) + 1));
#line 1858
    png_ptr->trans_color.blue = (png_uint_16 )(((unsigned int )*(buf___0 + 4) << 8) + (unsigned int )*((buf___0 + 4) + 1));
    }
  } else
#line 1861
  if ((int )png_ptr->color_type == 3) {
#line 1863
    if ((png_ptr->mode & 2U) == 0U) {
      {
#line 1866
      png_crc_finish(png_ptr, length);
#line 1867
      png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
      }
#line 1868
      return;
    }
#line 1871
    if (length > (unsigned int )png_ptr->num_palette) {
      {
#line 1875
      png_crc_finish(png_ptr, length);
#line 1876
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1877
      return;
    } else
#line 1871
    if (length > 256U) {
      {
#line 1875
      png_crc_finish(png_ptr, length);
#line 1876
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1877
      return;
    } else
#line 1871
    if (length == 0U) {
      {
#line 1875
      png_crc_finish(png_ptr, length);
#line 1876
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1877
      return;
    }
    {
#line 1880
    png_crc_read(png_ptr, readbuf, length);
#line 1881
    png_ptr->num_trans = (png_uint_16 )length;
    }
  } else {
    {
#line 1886
    png_crc_finish(png_ptr, length);
#line 1887
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid with alpha channel");
    }
#line 1888
    return;
  }
  {
#line 1891
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1891
  if (tmp != 0) {
#line 1893
    png_ptr->num_trans = (png_uint_16 )0;
#line 1894
    return;
  }
  {
#line 1901
  png_set_tRNS(png_ptr, info_ptr, (png_const_bytep )(readbuf), (int )png_ptr->num_trans,
               (png_const_color_16p )(& png_ptr->trans_color));
  }
#line 1903
  return;
}
}
#line 1907 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_bKGD(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  unsigned int truelen ;
  png_byte buf[6] ;
  png_color_16 background ;
  int tmp ;

  {
#line 1916
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1917
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 1919
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 1923
    png_crc_finish(png_ptr, length);
#line 1924
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 1925
    return;
  } else
#line 1919
  if ((int )png_ptr->color_type == 3) {
#line 1919
    if ((png_ptr->mode & 2U) == 0U) {
      {
#line 1923
      png_crc_finish(png_ptr, length);
#line 1924
      png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
      }
#line 1925
      return;
    } else {
#line 1919
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1928
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1928
    if ((info_ptr->valid & 32U) != 0U) {
      {
#line 1930
      png_crc_finish(png_ptr, length);
#line 1931
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 1932
      return;
    }
  }
#line 1935
  if ((int )png_ptr->color_type == 3) {
#line 1936
    truelen = 1U;
  } else
#line 1938
  if (((int )png_ptr->color_type & 2) != 0) {
#line 1939
    truelen = 6U;
  } else {
#line 1942
    truelen = 2U;
  }
#line 1944
  if (length != truelen) {
    {
#line 1946
    png_crc_finish(png_ptr, length);
#line 1947
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
#line 1948
    return;
  }
  {
#line 1951
  png_crc_read(png_ptr, buf, truelen);
#line 1953
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1953
  if (tmp != 0) {
#line 1954
    return;
  }
#line 1961
  if ((int )png_ptr->color_type == 3) {
#line 1963
    background.index = buf[0];
#line 1965
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1965
      if ((int )info_ptr->num_palette != 0) {
#line 1967
        if ((int )buf[0] >= (int )info_ptr->num_palette) {
          {
#line 1969
          png_chunk_benign_error((png_const_structrp )png_ptr, "invalid index");
          }
#line 1970
          return;
        }
#line 1973
        background.red = (png_uint_16 )(png_ptr->palette + buf[0])->red;
#line 1974
        background.green = (png_uint_16 )(png_ptr->palette + buf[0])->green;
#line 1975
        background.blue = (png_uint_16 )(png_ptr->palette + buf[0])->blue;
      } else {
#line 1979
        background.blue = (png_uint_16 )0;
#line 1979
        background.green = background.blue;
#line 1979
        background.red = background.green;
      }
    } else {
#line 1979
      background.blue = (png_uint_16 )0;
#line 1979
      background.green = background.blue;
#line 1979
      background.red = background.green;
    }
#line 1981
    background.gray = (png_uint_16 )0;
  } else
#line 1984
  if (((int )png_ptr->color_type & 2) == 0) {
#line 1986
    background.index = (png_byte )0;
#line 1987
    background.gray = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 1987
    background.blue = background.gray;
#line 1987
    background.green = background.blue;
#line 1987
    background.red = background.green;
  } else {
#line 1995
    background.index = (png_byte )0;
#line 1996
    background.red = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 1997
    background.green = (png_uint_16 )(((unsigned int )*(buf + 2) << 8) + (unsigned int )*((buf + 2) + 1));
#line 1998
    background.blue = (png_uint_16 )(((unsigned int )*(buf + 4) << 8) + (unsigned int )*((buf + 4) + 1));
#line 1999
    background.gray = (png_uint_16 )0;
  }
  {
#line 2002
  png_set_bKGD((png_const_structrp )png_ptr, info_ptr, (png_const_color_16p )(& background));
  }
#line 2003
  return;
}
}
#line 2007 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_hIST(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  unsigned int num ;
  unsigned int i ;
  png_uint_16 readbuf[256] ;
  png_byte buf[2] ;
  int tmp ;

  {
#line 2015
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 2016
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 2018
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 2021
    png_crc_finish(png_ptr, length);
#line 2022
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 2023
    return;
  } else
#line 2018
  if ((png_ptr->mode & 2U) == 0U) {
    {
#line 2021
    png_crc_finish(png_ptr, length);
#line 2022
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 2023
    return;
  } else
#line 2026
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2026
    if ((info_ptr->valid & 64U) != 0U) {
      {
#line 2028
      png_crc_finish(png_ptr, length);
#line 2029
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 2030
      return;
    }
  }
#line 2033
  num = length / 2U;
#line 2035
  if (num != (unsigned int )png_ptr->num_palette) {
    {
#line 2038
    png_crc_finish(png_ptr, length);
#line 2039
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
#line 2040
    return;
  } else
#line 2035
  if (num > 256U) {
    {
#line 2038
    png_crc_finish(png_ptr, length);
#line 2039
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
#line 2040
    return;
  }
#line 2043
  i = 0U;
  {
#line 2043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2043
    if (! (i < num)) {
#line 2043
      goto while_break;
    }
    {
#line 2047
    png_crc_read(png_ptr, buf, (png_uint_32 )2);
#line 2048
    readbuf[i] = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2043
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2051
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 2051
  if (tmp != 0) {
#line 2052
    return;
  }
  {
#line 2054
  png_set_hIST((png_const_structrp )png_ptr, info_ptr, (png_const_uint_16p )(readbuf));
  }
#line 2055
  return;
}
}
#line 2760 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static int png_cache_unknown_chunk(png_structrp png_ptr , png_uint_32 length ) 
{ 
  png_alloc_size_t limit ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 2763
  limit = (png_size_t )-1;
#line 2765
  if ((unsigned long )png_ptr->unknown_chunk.data != (unsigned long )((void *)0)) {
    {
#line 2767
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
#line 2768
    png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
    }
  }
#line 2772
  if (png_ptr->user_chunk_malloc_max > 0UL) {
#line 2772
    if (png_ptr->user_chunk_malloc_max < limit) {
#line 2774
      limit = png_ptr->user_chunk_malloc_max;
    }
  }
#line 2781
  if ((png_alloc_size_t )length <= limit) {
#line 2783
    *((char *)(png_ptr->unknown_chunk.name) + 0) = (char )((png_ptr->chunk_name >> 24) & 255U);
#line 2783
    *((char *)(png_ptr->unknown_chunk.name) + 1) = (char )((png_ptr->chunk_name >> 16) & 255U);
#line 2783
    *((char *)(png_ptr->unknown_chunk.name) + 2) = (char )((png_ptr->chunk_name >> 8) & 255U);
#line 2783
    *((char *)(png_ptr->unknown_chunk.name) + 3) = (char )(png_ptr->chunk_name & 255U);
#line 2783
    *((char *)(png_ptr->unknown_chunk.name) + 4) = (char)0;
#line 2785
    png_ptr->unknown_chunk.size = (png_size_t )length;
#line 2787
    png_ptr->unknown_chunk.location = (png_byte )png_ptr->mode;
#line 2789
    if (length == 0U) {
#line 2790
      png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
    } else {
      {
#line 2795
      tmp = png_malloc_warn((png_const_structrp )png_ptr, (png_alloc_size_t )length);
#line 2795
      png_ptr->unknown_chunk.data = (png_byte *)tmp;
      }
    }
  }
#line 2800
  if ((unsigned long )png_ptr->unknown_chunk.data == (unsigned long )((void *)0)) {
#line 2800
    if (length > 0U) {
      {
#line 2803
      png_crc_finish(png_ptr, length);
#line 2804
      png_chunk_benign_error((png_const_structrp )png_ptr, "unknown chunk exceeds memory limits");
      }
#line 2805
      return (0);
    } else {
#line 2800
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2810
    if (length > 0U) {
      {
#line 2811
      png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);
      }
    }
    {
#line 2812
    png_crc_finish(png_ptr, (png_uint_32 )0);
    }
#line 2813
    return (1);
  }
}
}
#line 2819 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_handle_unknown(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ,
                        int keep ) 
{ 
  int handled ;
  int tmp ;

  {
#line 2823
  handled = 0;
#line 2925
  if (keep == 0) {
#line 2926
    keep = png_ptr->unknown_default;
  }
#line 2928
  if (keep == 3) {
#line 2928
    goto _L;
  } else
#line 2928
  if (keep == 2) {
#line 2928
    if (1U & (png_ptr->chunk_name >> 29)) {
      _L: /* CIL Label */ 
      {
#line 2932
      tmp = png_cache_unknown_chunk(png_ptr, length);
      }
#line 2932
      if (tmp == 0) {
#line 2933
        keep = 1;
      }
    } else {
      {
#line 2937
      png_crc_finish(png_ptr, length);
      }
    }
  } else {
    {
#line 2937
    png_crc_finish(png_ptr, length);
    }
  }
#line 2962
  if (keep == 3) {
#line 2962
    goto _L___0;
  } else
#line 2962
  if (keep == 2) {
#line 2962
    if (1U & (png_ptr->chunk_name >> 29)) {
      _L___0: /* CIL Label */ 
      {
#line 2969
      if (png_ptr->user_chunk_cache_max == 2U) {
#line 2969
        goto case_2;
      }
#line 2973
      if (png_ptr->user_chunk_cache_max == 1U) {
#line 2973
        goto case_1;
      }
#line 2982
      if (png_ptr->user_chunk_cache_max == 0U) {
#line 2982
        goto case_0;
      }
#line 2979
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 2970
      png_ptr->user_chunk_cache_max = (png_uint_32 )1;
#line 2971
      png_chunk_benign_error((png_const_structrp )png_ptr, "no space in chunk cache");
      }
      case_1: /* CIL Label */ 
#line 2977
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2980
      (png_ptr->user_chunk_cache_max) --;
      case_0: /* CIL Label */ 
      {
#line 2987
      png_set_unknown_chunks((png_const_structrp )png_ptr, info_ptr, (png_const_unknown_chunkp )(& png_ptr->unknown_chunk),
                             1);
#line 2989
      handled = 1;
      }
#line 2991
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 3003
  if ((unsigned long )png_ptr->unknown_chunk.data != (unsigned long )((void *)0)) {
    {
#line 3004
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
    }
  }
#line 3005
  png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
#line 3015
  if (handled == 0) {
#line 3015
    if (! (1U & (png_ptr->chunk_name >> 29))) {
      {
#line 3016
      png_chunk_error((png_const_structrp )png_ptr, "unhandled critical chunk");
      }
    }
  }
#line 3017
  return;
}
}
#line 3031 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_check_chunk_name(png_structrp png_ptr , png_uint_32 chunk_name ) 
{ 
  int i ;
  int c ;

  {
#line 3038
  i = 1;
  {
#line 3038
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3038
    if (! (i <= 4)) {
#line 3038
      goto while_break;
    }
#line 3040
    c = (int )(chunk_name & 255U);
#line 3042
    if (c < 65) {
      {
#line 3043
      png_chunk_error((png_const_structrp )png_ptr, "invalid chunk type");
      }
    } else
#line 3042
    if (c > 122) {
      {
#line 3043
      png_chunk_error((png_const_structrp )png_ptr, "invalid chunk type");
      }
    } else
#line 3042
    if (c > 90) {
#line 3042
      if (c < 97) {
        {
#line 3043
        png_chunk_error((png_const_structrp )png_ptr, "invalid chunk type");
        }
      }
    }
#line 3045
    chunk_name >>= 8;
#line 3038
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3047
  return;
}
}
#line 3222 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_uint_32 const   row_mask[2][3][6]  = { { {          (png_uint_32 const   )(((1U << 1) - 1U) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) << 4) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) + (((1U << 1) - 1U) << 4)) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 2) + (((1U << 1) - 1U) << 6)) * 16843009U), 
                (png_uint_32 const   )((((((1U << 1) - 1U) + (((1U << 1) - 1U) << 2)) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 6)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 1) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 7)) * 16843009U)}, 
     {          (png_uint_32 const   )(((1U << 2) - 1U) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) << 8) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 4) + (((1U << 2) - 1U) << 12)) * 65537U), 
                (png_uint_32 const   )((((((1U << 2) - 1U) + (((1U << 2) - 1U) << 4)) + (((1U << 2) - 1U) << 8)) + (((1U << 2) - 1U) << 12)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 14)) * 65537U)}, 
     {          (png_uint_32 const   )((1U << 4) - 1U),          (png_uint_32 const   )(((1U << 4) - 1U) << 16),          (png_uint_32 const   )(((1U << 4) - 1U) + (((1U << 4) - 1U) << 16)),          (png_uint_32 const   )((((1U << 4) - 1U) << 8) + (((1U << 4) - 1U) << 24)), 
                (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28))}}, 
   { {          (png_uint_32 const   )((((1U << 1) - 1U) << 7) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) << 3) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 7) + (((1U << 1) - 1U) << 3)) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 5) + (((1U << 1) - 1U) << 1)) * 16843009U), 
                (png_uint_32 const   )(((((((1U << 1) - 1U) << 7) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 1)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 6) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 2)) + ((1U << 1) - 1U)) * 16843009U)}, 
     {          (png_uint_32 const   )((((1U << 2) - 1U) << 6) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) << 14) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 6) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 10)) * 65537U), 
                (png_uint_32 const   )(((((((1U << 2) - 1U) << 6) + (((1U << 2) - 1U) << 2)) + (((1U << 2) - 1U) << 14)) + (((1U << 2) - 1U) << 10)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 8)) * 65537U)}, 
     {          (png_uint_32 const   )(((1U << 4) - 1U) << 4),          (png_uint_32 const   )(((1U << 4) - 1U) << 20),          (png_uint_32 const   )((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 20)),          (png_uint_32 const   )((((1U << 4) - 1U) << 12) + (((1U << 4) - 1U) << 28)), 
                (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24))}}};
#line 3233 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_uint_32 const   display_mask[2][3][3]  = { { {          (png_uint_32 const   )(((((((1U << 1) - 1U) << 4) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 6)) + (((1U << 1) - 1U) << 7)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 2) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 6)) + (((1U << 1) - 1U) << 7)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 1) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 7)) * 16843009U)}, 
     {          (png_uint_32 const   )(((((((1U << 2) - 1U) << 8) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 14)) * 65537U)}, 
     {          (png_uint_32 const   )((((((1U << 4) - 1U) << 16) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 24)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 8) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 24)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28))}}, 
   { {          (png_uint_32 const   )(((((((1U << 1) - 1U) << 3) + (((1U << 1) - 1U) << 2)) + (((1U << 1) - 1U) << 1)) + ((1U << 1) - 1U)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 5) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 1)) + ((1U << 1) - 1U)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 6) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 2)) + ((1U << 1) - 1U)) * 16843009U)}, 
     {          (png_uint_32 const   )(((((((1U << 2) - 1U) << 14) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 8)) * 65537U)}, 
     {          (png_uint_32 const   )((((((1U << 4) - 1U) << 20) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 28)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 12) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 28)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24))}}};
#line 3056 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_combine_row(png_const_structrp png_ptr , png_bytep dp , int display ) 
{ 
  unsigned int pixel_depth ;
  png_const_bytep sp___0 ;
  png_alloc_size_t row_width ;
  unsigned int pass ;
  png_bytep end_ptr ;
  png_byte end_byte ;
  unsigned int end_mask ;
  png_size_t tmp ;
  png_size_t tmp___0 ;
  png_uint_32 pixels_per_byte ;
  png_uint_32 mask ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  png_uint_32 m ;
  unsigned int bytes_to_copy ;
  unsigned int bytes_to_jump ;
  unsigned int offset ;
  png_uint_32p dp32 ;
  png_const_uint_32p sp32 ;
  size_t skip ;
  size_t c ;
  png_uint_32p tmp___5 ;
  png_const_uint_32p tmp___6 ;
  png_bytep tmp___7 ;
  png_const_bytep tmp___8 ;
  png_uint_16p dp16 ;
  png_const_uint_16p sp16 ;
  size_t skip___0 ;
  size_t c___0 ;
  png_uint_16p tmp___9 ;
  png_const_uint_16p tmp___10 ;
  png_bytep tmp___11 ;
  png_const_bytep tmp___12 ;
  png_size_t tmp___13 ;

  {
#line 3059
  pixel_depth = (unsigned int )png_ptr->transformed_pixel_depth;
#line 3060
  sp___0 = (png_const_bytep )(png_ptr->row_buf + 1);
#line 3061
  row_width = (png_alloc_size_t )png_ptr->width;
#line 3062
  pass = (unsigned int )png_ptr->pass;
#line 3063
  end_ptr = (png_bytep )0;
#line 3064
  end_byte = (png_byte )0;
#line 3072
  if (pixel_depth == 0U) {
    {
#line 3073
    png_error(png_ptr, "internal row logic error");
    }
  }
#line 3079
  if (png_ptr->info_rowbytes != 0UL) {
#line 3079
    if (pixel_depth >= 8U) {
#line 3079
      tmp = row_width * ((png_size_t )pixel_depth >> 3);
    } else {
#line 3079
      tmp = (row_width * (png_size_t )pixel_depth + 7UL) >> 3;
    }
#line 3079
    if (png_ptr->info_rowbytes != (png_size_t const   )tmp) {
      {
#line 3081
      png_error(png_ptr, "internal row size calculation error");
      }
    }
  }
#line 3084
  if (row_width == 0UL) {
    {
#line 3085
    png_error(png_ptr, "internal row width error");
    }
  }
#line 3091
  end_mask = (unsigned int )((png_alloc_size_t )pixel_depth * row_width & 7UL);
#line 3092
  if (end_mask != 0U) {
#line 3095
    if (pixel_depth >= 8U) {
#line 3095
      tmp___0 = row_width * ((png_size_t )pixel_depth >> 3);
    } else {
#line 3095
      tmp___0 = (row_width * (png_size_t )pixel_depth + 7UL) >> 3;
    }
#line 3095
    end_ptr = (dp + tmp___0) - 1;
#line 3096
    end_byte = *end_ptr;
#line 3104
    end_mask = (unsigned int )(255 >> end_mask);
  }
#line 3115
  if ((int const   )png_ptr->interlaced != 0) {
#line 3115
    if ((png_ptr->transformations & 2U) != 0U) {
#line 3115
      if (pass < 6U) {
#line 3115
        if (display == 0) {
#line 3115
          goto _L___3;
        } else
#line 3115
        if (display == 1) {
#line 3115
          if ((pass & 1U) != 0U) {
            _L___3: /* CIL Label */ 
#line 3124
            if (row_width <= (png_alloc_size_t )(((1U & pass) << (3U - ((pass + 1U) >> 1))) & 7U)) {
#line 3125
              return;
            }
#line 3127
            if (pixel_depth < 8U) {
#line 3258
              pixels_per_byte = 8U / pixel_depth;
#line 3267
              if (display) {
#line 3267
                if (pixel_depth == 1U) {
#line 3267
                  tmp___2 = 0;
                } else {
#line 3267
                  if (pixel_depth == 2U) {
#line 3267
                    tmp___1 = 1;
                  } else {
#line 3267
                    tmp___1 = 2;
                  }
#line 3267
                  tmp___2 = tmp___1;
                }
#line 3267
                mask = (png_uint_32 )display_mask[1][tmp___2][pass >> 1];
              } else {
#line 3267
                if (pixel_depth == 1U) {
#line 3267
                  tmp___4 = 0;
                } else {
#line 3267
                  if (pixel_depth == 2U) {
#line 3267
                    tmp___3 = 1;
                  } else {
#line 3267
                    tmp___3 = 2;
                  }
#line 3267
                  tmp___4 = tmp___3;
                }
#line 3267
                mask = (png_uint_32 )row_mask[1][tmp___4][pass];
              }
              {
#line 3269
              while (1) {
                while_continue: /* CIL Label */ ;
#line 3277
                m = mask;
#line 3278
                mask = (m >> 8) | (m << 24);
#line 3279
                m &= 255U;
#line 3281
                if (m != 0U) {
#line 3283
                  if (m != 255U) {
#line 3284
                    *dp = (png_byte )(((unsigned int )*dp & ~ m) | ((unsigned int )*sp___0 & m));
                  } else {
#line 3286
                    *dp = (png_byte )*sp___0;
                  }
                }
#line 3293
                if (row_width <= (png_alloc_size_t )pixels_per_byte) {
#line 3294
                  goto while_break;
                }
#line 3296
                row_width -= (png_alloc_size_t )pixels_per_byte;
#line 3297
                dp ++;
#line 3298
                sp___0 ++;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 3307
              if (pixel_depth & 7U) {
                {
#line 3308
                png_error(png_ptr, "invalid user transform pixel depth");
                }
              }
#line 3310
              pixel_depth >>= 3;
#line 3311
              row_width *= (png_alloc_size_t )pixel_depth;
#line 3318
              offset = (((1U & pass) << (3U - ((pass + 1U) >> 1))) & 7U) * pixel_depth;
#line 3320
              row_width -= (png_alloc_size_t )offset;
#line 3321
              dp += offset;
#line 3322
              sp___0 += offset;
#line 3326
              if (display != 0) {
#line 3332
                bytes_to_copy = (unsigned int )(1 << ((6U - pass) >> 1)) * pixel_depth;
#line 3335
                if ((png_alloc_size_t )bytes_to_copy > row_width) {
#line 3336
                  bytes_to_copy = (unsigned int )row_width;
                }
              } else {
#line 3340
                bytes_to_copy = pixel_depth;
              }
#line 3343
              bytes_to_jump = (unsigned int )(1 << ((7U - pass) >> 1)) * pixel_depth;
              {
#line 3355
              if (bytes_to_copy == 1U) {
#line 3355
                goto case_1;
              }
#line 3368
              if (bytes_to_copy == 2U) {
#line 3368
                goto case_2;
              }
#line 3389
              if (bytes_to_copy == 3U) {
#line 3389
                goto case_3;
              }
#line 3405
              goto switch_default;
              case_1: /* CIL Label */ 
              {
#line 3356
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 3358
                *dp = (png_byte )*sp___0;
#line 3360
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3361
                  return;
                }
#line 3363
                dp += bytes_to_jump;
#line 3364
                sp___0 += bytes_to_jump;
#line 3365
                row_width -= (png_alloc_size_t )bytes_to_jump;
              }
              while_break___0: /* CIL Label */ ;
              }
              case_2: /* CIL Label */ 
              {
#line 3372
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3374
                *(dp + 0) = (png_byte )*(sp___0 + 0);
#line 3374
                *(dp + 1) = (png_byte )*(sp___0 + 1);
#line 3376
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3377
                  return;
                }
#line 3379
                sp___0 += bytes_to_jump;
#line 3380
                dp += bytes_to_jump;
#line 3381
                row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3372
                if (! (row_width > 1UL)) {
#line 3372
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3386
              *dp = (png_byte )*sp___0;
#line 3387
              return;
              case_3: /* CIL Label */ 
              {
#line 3393
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 3395
                *(dp + 0) = (png_byte )*(sp___0 + 0);
#line 3395
                *(dp + 1) = (png_byte )*(sp___0 + 1);
#line 3395
                *(dp + 2) = (png_byte )*(sp___0 + 2);
#line 3397
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3398
                  return;
                }
#line 3400
                sp___0 += bytes_to_jump;
#line 3401
                dp += bytes_to_jump;
#line 3402
                row_width -= (png_alloc_size_t )bytes_to_jump;
              }
              while_break___2: /* CIL Label */ ;
              }
              switch_default: /* CIL Label */ 
#line 3412
              if (bytes_to_copy < 16U) {
#line 3412
                if (((unsigned long )((char const   *)dp - (char const   *)0) & (sizeof(png_uint_16 ) - 1UL)) == 0UL) {
#line 3412
                  if (((unsigned long )((char const   *)sp___0 - (char const   *)0) & (sizeof(png_uint_16 ) - 1UL)) == 0UL) {
#line 3412
                    if ((unsigned long )bytes_to_copy % sizeof(png_uint_16 ) == 0UL) {
#line 3412
                      if ((unsigned long )bytes_to_jump % sizeof(png_uint_16 ) == 0UL) {
#line 3421
                        if ((((unsigned long )((char const   *)dp - (char const   *)0) & (sizeof(png_uint_32 ) - 1UL)) == 0UL) != 0) {
#line 3421
                          if ((((unsigned long )((char const   *)sp___0 - (char const   *)0) & (sizeof(png_uint_32 ) - 1UL)) == 0UL) != 0) {
#line 3421
                            if ((unsigned long )bytes_to_copy % sizeof(png_uint_32 ) == 0UL) {
#line 3421
                              if ((unsigned long )bytes_to_jump % sizeof(png_uint_32 ) == 0UL) {
#line 3426
                                dp32 = (png_uint_32p )((void *)dp);
#line 3427
                                sp32 = (png_const_uint_32p )((void const   *)sp___0);
#line 3429
                                skip = (unsigned long )(bytes_to_jump - bytes_to_copy) / sizeof(png_uint_32 );
                                {
#line 3432
                                while (1) {
                                  while_continue___3: /* CIL Label */ ;
#line 3434
                                  c = (size_t )bytes_to_copy;
                                  {
#line 3435
                                  while (1) {
                                    while_continue___4: /* CIL Label */ ;
#line 3437
                                    tmp___5 = dp32;
#line 3437
                                    dp32 ++;
#line 3437
                                    tmp___6 = sp32;
#line 3437
                                    sp32 ++;
#line 3437
                                    *tmp___5 = (png_uint_32 )*tmp___6;
#line 3438
                                    c -= sizeof(png_uint_32 );
#line 3435
                                    if (! (c > 0UL)) {
#line 3435
                                      goto while_break___4;
                                    }
                                  }
                                  while_break___4: /* CIL Label */ ;
                                  }
#line 3442
                                  if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3443
                                    return;
                                  }
#line 3445
                                  dp32 += skip;
#line 3446
                                  sp32 += skip;
#line 3447
                                  row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3432
                                  if (! ((png_alloc_size_t )bytes_to_copy <= row_width)) {
#line 3432
                                    goto while_break___3;
                                  }
                                }
                                while_break___3: /* CIL Label */ ;
                                }
#line 3455
                                dp = (png_bytep )dp32;
#line 3456
                                sp___0 = (png_const_bytep )sp32;
                                {
#line 3457
                                while (1) {
                                  while_continue___5: /* CIL Label */ ;
#line 3458
                                  tmp___7 = dp;
#line 3458
                                  dp ++;
#line 3458
                                  tmp___8 = sp___0;
#line 3458
                                  sp___0 ++;
#line 3458
                                  *tmp___7 = (png_byte )*tmp___8;
#line 3457
                                  row_width --;
#line 3457
                                  if (! (row_width > 0UL)) {
#line 3457
                                    goto while_break___5;
                                  }
                                }
                                while_break___5: /* CIL Label */ ;
                                }
#line 3460
                                return;
                              } else {
#line 3421
                                goto _L___1;
                              }
                            } else {
#line 3421
                              goto _L___1;
                            }
                          } else {
#line 3421
                            goto _L___1;
                          }
                        } else {
                          _L___1: /* CIL Label */ 
#line 3468
                          dp16 = (png_uint_16p )((void *)dp);
#line 3469
                          sp16 = (png_const_uint_16p )((void const   *)sp___0);
#line 3471
                          skip___0 = (unsigned long )(bytes_to_jump - bytes_to_copy) / sizeof(png_uint_16 );
                          {
#line 3474
                          while (1) {
                            while_continue___6: /* CIL Label */ ;
#line 3476
                            c___0 = (size_t )bytes_to_copy;
                            {
#line 3477
                            while (1) {
                              while_continue___7: /* CIL Label */ ;
#line 3479
                              tmp___9 = dp16;
#line 3479
                              dp16 ++;
#line 3479
                              tmp___10 = sp16;
#line 3479
                              sp16 ++;
#line 3479
                              *tmp___9 = (png_uint_16 )*tmp___10;
#line 3480
                              c___0 -= sizeof(png_uint_16 );
#line 3477
                              if (! (c___0 > 0UL)) {
#line 3477
                                goto while_break___7;
                              }
                            }
                            while_break___7: /* CIL Label */ ;
                            }
#line 3484
                            if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3485
                              return;
                            }
#line 3487
                            dp16 += skip___0;
#line 3488
                            sp16 += skip___0;
#line 3489
                            row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3474
                            if (! ((png_alloc_size_t )bytes_to_copy <= row_width)) {
#line 3474
                              goto while_break___6;
                            }
                          }
                          while_break___6: /* CIL Label */ ;
                          }
#line 3494
                          dp = (png_bytep )dp16;
#line 3495
                          sp___0 = (png_const_bytep )sp16;
                          {
#line 3496
                          while (1) {
                            while_continue___8: /* CIL Label */ ;
#line 3497
                            tmp___11 = dp;
#line 3497
                            dp ++;
#line 3497
                            tmp___12 = sp___0;
#line 3497
                            sp___0 ++;
#line 3497
                            *tmp___11 = (png_byte )*tmp___12;
#line 3496
                            row_width --;
#line 3496
                            if (! (row_width > 0UL)) {
#line 3496
                              goto while_break___8;
                            }
                          }
                          while_break___8: /* CIL Label */ ;
                          }
#line 3499
                          return;
                        }
                      }
                    }
                  }
                }
              }
              {
#line 3505
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 3507
                memcpy((void */* __restrict  */)dp, (void const   */* __restrict  */)sp___0,
                       (size_t )bytes_to_copy);
                }
#line 3509
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3510
                  return;
                }
#line 3512
                sp___0 += bytes_to_jump;
#line 3513
                dp += bytes_to_jump;
#line 3514
                row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3515
                if ((png_alloc_size_t )bytes_to_copy > row_width) {
#line 3516
                  bytes_to_copy = (unsigned int )row_width;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
              switch_break: /* CIL Label */ ;
              }
            }
          } else {
#line 3115
            goto _L___5;
          }
        } else {
#line 3115
          goto _L___5;
        }
      } else {
#line 3115
        goto _L___5;
      }
    } else {
#line 3115
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 3532
    if (pixel_depth >= 8U) {
#line 3532
      tmp___13 = row_width * ((png_size_t )pixel_depth >> 3);
    } else {
#line 3532
      tmp___13 = (row_width * (png_size_t )pixel_depth + 7UL) >> 3;
    }
    {
#line 3532
    memcpy((void */* __restrict  */)dp, (void const   */* __restrict  */)sp___0, tmp___13);
    }
  }
#line 3535
  if ((unsigned long )end_ptr != (unsigned long )((void *)0)) {
#line 3536
    *end_ptr = (png_byte )(((unsigned int )end_byte & end_mask) | ((unsigned int )*end_ptr & ~ end_mask));
  }
#line 3537
  return;
}
}
#line 3546 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static int const   png_pass_inc___2[7]  = {      (int const   )8,      (int const   )8,      (int const   )4,      (int const   )4, 
        (int const   )2,      (int const   )2,      (int const   )1};
#line 3540 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_do_read_interlace(png_row_infop row_info , png_bytep row , int pass , png_uint_32 transformations ) 
{ 
  png_uint_32 final_width ;
  png_bytep sp___0 ;
  png_bytep dp ;
  int sshift ;
  int dshift ;
  int s_start ;
  int s_end ;
  int s_inc ;
  int jstop ;
  png_byte v ;
  png_uint_32 i ;
  int j ;
  unsigned int tmp ;
  png_bytep sp___1 ;
  png_bytep dp___0 ;
  int sshift___0 ;
  int dshift___0 ;
  int s_start___0 ;
  int s_end___0 ;
  int s_inc___0 ;
  int jstop___0 ;
  png_uint_32 i___0 ;
  png_byte v___0 ;
  int j___0 ;
  unsigned int tmp___0 ;
  png_bytep sp___2 ;
  png_bytep dp___1 ;
  int sshift___1 ;
  int dshift___1 ;
  int s_start___1 ;
  int s_end___1 ;
  int s_inc___1 ;
  png_uint_32 i___1 ;
  int jstop___1 ;
  png_byte v___1 ;
  int j___1 ;
  unsigned int tmp___1 ;
  png_size_t pixel_bytes ;
  png_bytep sp___3 ;
  png_bytep dp___2 ;
  int jstop___2 ;
  png_uint_32 i___2 ;
  png_byte v___2[8] ;
  int j___2 ;

  {
#line 3549
  if ((unsigned long )row != (unsigned long )((void *)0)) {
#line 3549
    if ((unsigned long )row_info != (unsigned long )((void *)0)) {
#line 3553
      final_width = row_info->width * (png_uint_32 )png_pass_inc___2[pass];
      {
#line 3557
      if ((int )row_info->pixel_depth == 1) {
#line 3557
        goto case_1;
      }
#line 3619
      if ((int )row_info->pixel_depth == 2) {
#line 3619
        goto case_2;
      }
#line 3682
      if ((int )row_info->pixel_depth == 4) {
#line 3682
        goto case_4;
      }
#line 3744
      goto switch_default;
      case_1: /* CIL Label */ 
#line 3559
      sp___0 = row + (png_size_t )((row_info->width - 1U) >> 3);
#line 3560
      dp = row + (png_size_t )((final_width - 1U) >> 3);
#line 3563
      jstop = (int )png_pass_inc___2[pass];
#line 3581
      sshift = 7 - (int )((row_info->width + 7U) & 7U);
#line 3582
      dshift = 7 - (int )((final_width + 7U) & 7U);
#line 3583
      s_start = 0;
#line 3584
      s_end = 7;
#line 3585
      s_inc = 1;
#line 3588
      i = (png_uint_32 )0;
      {
#line 3588
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3588
        if (! (i < row_info->width)) {
#line 3588
          goto while_break;
        }
#line 3590
        v = (png_byte )(((int )*sp___0 >> sshift) & 1);
#line 3591
        j = 0;
        {
#line 3591
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3591
          if (! (j < jstop)) {
#line 3591
            goto while_break___0;
          }
#line 3593
          tmp = (unsigned int )((int )*dp & (32639 >> (7 - dshift)));
#line 3594
          tmp |= (unsigned int )((int )v << dshift);
#line 3595
          *dp = (png_byte )(tmp & 255U);
#line 3597
          if (dshift == s_end) {
#line 3599
            dshift = s_start;
#line 3600
            dp --;
          } else {
#line 3604
            dshift += s_inc;
          }
#line 3591
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3607
        if (sshift == s_end) {
#line 3609
          sshift = s_start;
#line 3610
          sp___0 --;
        } else {
#line 3614
          sshift += s_inc;
        }
#line 3588
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 3616
      goto switch_break;
      case_2: /* CIL Label */ 
#line 3621
      sp___1 = row + ((row_info->width - 1U) >> 2);
#line 3622
      dp___0 = row + ((final_width - 1U) >> 2);
#line 3625
      jstop___0 = (int )png_pass_inc___2[pass];
#line 3641
      sshift___0 = (int )((3U - ((row_info->width + 3U) & 3U)) << 1);
#line 3642
      dshift___0 = (int )((3U - ((final_width + 3U) & 3U)) << 1);
#line 3643
      s_start___0 = 0;
#line 3644
      s_end___0 = 6;
#line 3645
      s_inc___0 = 2;
#line 3648
      i___0 = (png_uint_32 )0;
      {
#line 3648
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3648
        if (! (i___0 < row_info->width)) {
#line 3648
          goto while_break___1;
        }
#line 3653
        v___0 = (png_byte )(((int )*sp___1 >> sshift___0) & 3);
#line 3654
        j___0 = 0;
        {
#line 3654
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3654
          if (! (j___0 < jstop___0)) {
#line 3654
            goto while_break___2;
          }
#line 3656
          tmp___0 = (unsigned int )((int )*dp___0 & (16191 >> (6 - dshift___0)));
#line 3657
          tmp___0 |= (unsigned int )((int )v___0 << dshift___0);
#line 3658
          *dp___0 = (png_byte )(tmp___0 & 255U);
#line 3660
          if (dshift___0 == s_end___0) {
#line 3662
            dshift___0 = s_start___0;
#line 3663
            dp___0 --;
          } else {
#line 3667
            dshift___0 += s_inc___0;
          }
#line 3654
          j___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3670
        if (sshift___0 == s_end___0) {
#line 3672
          sshift___0 = s_start___0;
#line 3673
          sp___1 --;
        } else {
#line 3677
          sshift___0 += s_inc___0;
        }
#line 3648
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3679
      goto switch_break;
      case_4: /* CIL Label */ 
#line 3684
      sp___2 = row + (png_size_t )((row_info->width - 1U) >> 1);
#line 3685
      dp___1 = row + (png_size_t )((final_width - 1U) >> 1);
#line 3689
      jstop___1 = (int )png_pass_inc___2[pass];
#line 3704
      sshift___1 = (int )((1U - ((row_info->width + 1U) & 1U)) << 2);
#line 3705
      dshift___1 = (int )((1U - ((final_width + 1U) & 1U)) << 2);
#line 3706
      s_start___1 = 0;
#line 3707
      s_end___1 = 4;
#line 3708
      s_inc___1 = 4;
#line 3711
      i___1 = (png_uint_32 )0;
      {
#line 3711
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3711
        if (! (i___1 < row_info->width)) {
#line 3711
          goto while_break___3;
        }
#line 3713
        v___1 = (png_byte )(((int )*sp___2 >> sshift___1) & 15);
#line 3716
        j___1 = 0;
        {
#line 3716
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3716
          if (! (j___1 < jstop___1)) {
#line 3716
            goto while_break___4;
          }
#line 3718
          tmp___1 = (unsigned int )((int )*dp___1 & (3855 >> (4 - dshift___1)));
#line 3719
          tmp___1 |= (unsigned int )((int )v___1 << dshift___1);
#line 3720
          *dp___1 = (png_byte )(tmp___1 & 255U);
#line 3722
          if (dshift___1 == s_end___1) {
#line 3724
            dshift___1 = s_start___1;
#line 3725
            dp___1 --;
          } else {
#line 3729
            dshift___1 += s_inc___1;
          }
#line 3716
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 3732
        if (sshift___1 == s_end___1) {
#line 3734
          sshift___1 = s_start___1;
#line 3735
          sp___2 --;
        } else {
#line 3739
          sshift___1 += s_inc___1;
        }
#line 3711
        i___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3741
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 3746
      pixel_bytes = (png_size_t )((int )row_info->pixel_depth >> 3);
#line 3748
      sp___3 = row + (png_size_t )(row_info->width - 1U) * pixel_bytes;
#line 3751
      dp___2 = row + (png_size_t )(final_width - 1U) * pixel_bytes;
#line 3753
      jstop___2 = (int )png_pass_inc___2[pass];
#line 3756
      i___2 = (png_uint_32 )0;
      {
#line 3756
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3756
        if (! (i___2 < row_info->width)) {
#line 3756
          goto while_break___5;
        }
        {
#line 3761
        memcpy((void */* __restrict  */)(v___2), (void const   */* __restrict  */)sp___3,
               pixel_bytes);
#line 3763
        j___2 = 0;
        }
        {
#line 3763
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3763
          if (! (j___2 < jstop___2)) {
#line 3763
            goto while_break___6;
          }
          {
#line 3765
          memcpy((void */* __restrict  */)dp___2, (void const   */* __restrict  */)(v___2),
                 pixel_bytes);
#line 3766
          dp___2 -= pixel_bytes;
#line 3763
          j___2 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 3769
        sp___3 -= pixel_bytes;
#line 3756
        i___2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3771
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 3775
      row_info->width = final_width;
#line 3776
      if ((int )row_info->pixel_depth >= 8) {
#line 3776
        row_info->rowbytes = (png_size_t )final_width * ((png_size_t )row_info->pixel_depth >> 3);
      } else {
#line 3776
        row_info->rowbytes = ((png_size_t )final_width * (png_size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 3781
  return;
}
}
#line 3784 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static void png_read_filter_row_sub(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) 
{ 
  png_size_t i ;
  png_size_t istop ;
  unsigned int bpp ;
  png_bytep rp ;

  {
#line 3789
  istop = row_info->rowbytes;
#line 3790
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 3791
  rp = row + bpp;
#line 3795
  i = (png_size_t )bpp;
  {
#line 3795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3795
    if (! (i < istop)) {
#line 3795
      goto while_break;
    }
#line 3797
    *rp = (png_byte )(((int )*rp + (int )*(rp - bpp)) & 255);
#line 3798
    rp ++;
#line 3795
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3800
  return;
}
}
#line 3802 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static void png_read_filter_row_up(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) 
{ 
  png_size_t i ;
  png_size_t istop ;
  png_bytep rp ;
  png_const_bytep pp ;
  png_const_bytep tmp ;

  {
#line 3807
  istop = row_info->rowbytes;
#line 3808
  rp = row;
#line 3809
  pp = prev_row;
#line 3811
  i = (png_size_t )0;
  {
#line 3811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3811
    if (! (i < istop)) {
#line 3811
      goto while_break;
    }
#line 3813
    tmp = pp;
#line 3813
    pp ++;
#line 3813
    *rp = (png_byte )(((int )*rp + (int )*tmp) & 255);
#line 3814
    rp ++;
#line 3811
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3816
  return;
}
}
#line 3818 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static void png_read_filter_row_avg(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) 
{ 
  png_size_t i ;
  png_bytep rp ;
  png_const_bytep pp ;
  unsigned int bpp ;
  png_size_t istop ;
  png_const_bytep tmp ;
  png_const_bytep tmp___0 ;

  {
#line 3823
  rp = row;
#line 3824
  pp = prev_row;
#line 3825
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 3826
  istop = row_info->rowbytes - (png_size_t )bpp;
#line 3828
  i = (png_size_t )0;
  {
#line 3828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3828
    if (! (i < (png_size_t )bpp)) {
#line 3828
      goto while_break;
    }
#line 3830
    tmp = pp;
#line 3830
    pp ++;
#line 3830
    *rp = (png_byte )(((int )*rp + (int )*tmp / 2) & 255);
#line 3833
    rp ++;
#line 3828
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3836
  i = (png_size_t )0;
  {
#line 3836
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3836
    if (! (i < istop)) {
#line 3836
      goto while_break___0;
    }
#line 3838
    tmp___0 = pp;
#line 3838
    pp ++;
#line 3838
    *rp = (png_byte )(((int )*rp + (int )((int const   )*tmp___0 + (int const   )*(rp - bpp)) / 2) & 255);
#line 3841
    rp ++;
#line 3836
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3843
  return;
}
}
#line 3845 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static void png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info , png_bytep row ,
                                                  png_const_bytep prev_row ) 
{ 
  png_bytep rp_end ;
  int a ;
  int c ;
  png_const_bytep tmp ;
  png_bytep tmp___0 ;
  int b ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_const_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 3849
  rp_end = row + row_info->rowbytes;
#line 3853
  tmp = prev_row;
#line 3853
  prev_row ++;
#line 3853
  c = (int )*tmp;
#line 3854
  a = (int )*row + c;
#line 3855
  tmp___0 = row;
#line 3855
  row ++;
#line 3855
  *tmp___0 = (png_byte )a;
  {
#line 3858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3858
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 3858
      goto while_break;
    }
#line 3862
    a &= 255;
#line 3863
    tmp___1 = prev_row;
#line 3863
    prev_row ++;
#line 3863
    b = (int )*tmp___1;
#line 3865
    p = b - c;
#line 3866
    pc = a - c;
#line 3873
    if (p < 0) {
#line 3873
      pa = - p;
    } else {
#line 3873
      pa = p;
    }
#line 3874
    if (pc < 0) {
#line 3874
      pb = - pc;
    } else {
#line 3874
      pb = pc;
    }
#line 3875
    if (p + pc < 0) {
#line 3875
      pc = - (p + pc);
    } else {
#line 3875
      pc = p + pc;
    }
#line 3881
    if (pb < pa) {
#line 3881
      pa = pb;
#line 3881
      a = b;
    }
#line 3882
    if (pc < pa) {
#line 3882
      a = c;
    }
#line 3887
    c = b;
#line 3888
    a += (int )*row;
#line 3889
    tmp___2 = row;
#line 3889
    row ++;
#line 3889
    *tmp___2 = (png_byte )a;
  }
  while_break: /* CIL Label */ ;
  }
#line 3891
  return;
}
}
#line 3893 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static void png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info , png_bytep row ,
                                                      png_const_bytep prev_row ) 
{ 
  int bpp ;
  png_bytep rp_end ;
  int a ;
  png_const_bytep tmp ;
  png_bytep tmp___0 ;
  int a___0 ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_const_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 3897
  bpp = ((int )row_info->pixel_depth + 7) >> 3;
#line 3898
  rp_end = row + bpp;
  {
#line 3903
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3903
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 3903
      goto while_break;
    }
#line 3905
    tmp = prev_row;
#line 3905
    prev_row ++;
#line 3905
    a = (int )*row + (int )*tmp;
#line 3906
    tmp___0 = row;
#line 3906
    row ++;
#line 3906
    *tmp___0 = (png_byte )a;
  }
  while_break: /* CIL Label */ ;
  }
#line 3910
  rp_end += row_info->rowbytes - (png_size_t )bpp;
  {
#line 3912
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3912
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 3912
      goto while_break___0;
    }
#line 3916
    c = (int )*(prev_row - bpp);
#line 3917
    a___0 = (int )*(row - bpp);
#line 3918
    tmp___1 = prev_row;
#line 3918
    prev_row ++;
#line 3918
    b = (int )*tmp___1;
#line 3920
    p = b - c;
#line 3921
    pc = a___0 - c;
#line 3928
    if (p < 0) {
#line 3928
      pa = - p;
    } else {
#line 3928
      pa = p;
    }
#line 3929
    if (pc < 0) {
#line 3929
      pb = - pc;
    } else {
#line 3929
      pb = pc;
    }
#line 3930
    if (p + pc < 0) {
#line 3930
      pc = - (p + pc);
    } else {
#line 3930
      pc = p + pc;
    }
#line 3933
    if (pb < pa) {
#line 3933
      pa = pb;
#line 3933
      a___0 = b;
    }
#line 3934
    if (pc < pa) {
#line 3934
      a___0 = c;
    }
#line 3936
    a___0 += (int )*row;
#line 3937
    tmp___2 = row;
#line 3937
    row ++;
#line 3937
    *tmp___2 = (png_byte )a___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3939
  return;
}
}
#line 3941 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static void png_init_filter_functions(png_structrp pp ) 
{ 
  unsigned int bpp ;

  {
#line 3953
  bpp = (unsigned int )(((int )pp->pixel_depth + 7) >> 3);
#line 3955
  pp->read_filter[0] = & png_read_filter_row_sub;
#line 3956
  pp->read_filter[1] = & png_read_filter_row_up;
#line 3957
  pp->read_filter[2] = & png_read_filter_row_avg;
#line 3958
  if (bpp == 1U) {
#line 3959
    pp->read_filter[3] = & png_read_filter_row_paeth_1byte_pixel;
  } else {
#line 3962
    pp->read_filter[3] = & png_read_filter_row_paeth_multibyte_pixel;
  }
#line 3976
  return;
}
}
#line 3978 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_read_filter_row(png_structrp pp , png_row_infop row_info , png_bytep row ,
                         png_const_bytep prev_row , int filter ) 
{ 


  {
#line 3986
  if (filter > 0) {
#line 3986
    if (filter < 5) {
#line 3988
      if ((unsigned long )pp->read_filter[0] == (unsigned long )((void *)0)) {
        {
#line 3989
        png_init_filter_functions(pp);
        }
      }
      {
#line 3991
      (*(pp->read_filter[filter - 1]))(row_info, row, prev_row);
      }
    }
  }
#line 3993
  return;
}
}
#line 3996 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_read_IDAT_data(png_structrp png_ptr , png_bytep output , png_alloc_size_t avail_out ) 
{ 
  int ret ;
  png_byte tmpbuf[1024] ;
  uInt avail_in ;
  png_bytep buffer___0 ;
  uInt out ;

  {
#line 4001
  png_ptr->zstream.next_out = output;
#line 4002
  png_ptr->zstream.avail_out = (uInt )0;
#line 4004
  if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 4005
    avail_out = (png_alloc_size_t )0;
  }
  {
#line 4007
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4012
    if (png_ptr->zstream.avail_in == 0U) {
      {
#line 4017
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4017
        if (! (png_ptr->idat_size == 0U)) {
#line 4017
          goto while_break___0;
        }
        {
#line 4019
        png_crc_finish(png_ptr, (png_uint_32 )0);
#line 4021
        png_ptr->idat_size = png_read_chunk_header(png_ptr);
        }
#line 4025
        if (png_ptr->chunk_name != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
          {
#line 4026
          png_error((png_const_structrp )png_ptr, "Not enough image data");
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4029
      avail_in = png_ptr->IDAT_read_size;
#line 4031
      if (avail_in > png_ptr->idat_size) {
#line 4032
        avail_in = png_ptr->idat_size;
      }
      {
#line 4039
      buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )avail_in, 0);
#line 4041
      png_crc_read(png_ptr, buffer___0, avail_in);
#line 4042
      png_ptr->idat_size -= avail_in;
#line 4044
      png_ptr->zstream.next_in = (Bytef const   *)buffer___0;
#line 4045
      png_ptr->zstream.avail_in = avail_in;
      }
    }
#line 4049
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4051
      out = (uInt )-1;
#line 4053
      if ((png_alloc_size_t )out > avail_out) {
#line 4054
        out = (uInt )avail_out;
      }
#line 4056
      avail_out -= (png_alloc_size_t )out;
#line 4057
      png_ptr->zstream.avail_out = out;
    } else {
#line 4062
      png_ptr->zstream.next_out = tmpbuf;
#line 4063
      png_ptr->zstream.avail_out = (uInt )sizeof(tmpbuf);
    }
    {
#line 4073
    ret = inflate(& png_ptr->zstream, 0);
    }
#line 4076
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4077
      avail_out += (png_alloc_size_t )png_ptr->zstream.avail_out;
    } else {
#line 4080
      avail_out += sizeof(tmpbuf) - (unsigned long )png_ptr->zstream.avail_out;
    }
#line 4082
    png_ptr->zstream.avail_out = (uInt )0;
#line 4084
    if (ret == 1) {
#line 4087
      png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 4089
      png_ptr->mode |= 8U;
#line 4090
      png_ptr->flags |= 8U;
#line 4092
      if (png_ptr->zstream.avail_in > 0U) {
        {
#line 4093
        png_chunk_benign_error((png_const_structrp )png_ptr, "Extra compressed data");
        }
      } else
#line 4092
      if (png_ptr->idat_size > 0U) {
        {
#line 4093
        png_chunk_benign_error((png_const_structrp )png_ptr, "Extra compressed data");
        }
      }
#line 4094
      goto while_break;
    }
#line 4097
    if (ret != 0) {
      {
#line 4099
      png_zstream_error(png_ptr, ret);
      }
#line 4101
      if ((unsigned long )output != (unsigned long )((void *)0)) {
        {
#line 4102
        png_chunk_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
        }
      } else {
        {
#line 4106
        png_chunk_benign_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
        }
#line 4107
        return;
      }
    }
#line 4007
    if (! (avail_out > 0UL)) {
#line 4007
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4112
  if (avail_out > 0UL) {
#line 4117
    if ((unsigned long )output != (unsigned long )((void *)0)) {
      {
#line 4118
      png_error((png_const_structrp )png_ptr, "Not enough image data");
      }
    } else {
      {
#line 4121
      png_chunk_benign_error((png_const_structrp )png_ptr, "Too much image data");
      }
    }
  }
#line 4123
  return;
}
}
#line 4125 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_read_finish_IDAT(png_structrp png_ptr ) 
{ 


  {
#line 4133
  if ((png_ptr->flags & 8U) == 0U) {
    {
#line 4139
    png_read_IDAT_data(png_ptr, (png_bytep )((void *)0), (png_alloc_size_t )0);
#line 4140
    png_ptr->zstream.next_out = (Bytef *)((void *)0);
    }
#line 4145
    if ((png_ptr->flags & 8U) == 0U) {
#line 4147
      png_ptr->mode |= 8U;
#line 4148
      png_ptr->flags |= 8U;
    }
  }
#line 4155
  if (png_ptr->zowner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
    {
#line 4158
    png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 4159
    png_ptr->zstream.avail_in = (uInt )0;
#line 4162
    png_ptr->zowner = (png_uint_32 )0;
#line 4169
    png_crc_finish(png_ptr, png_ptr->idat_size);
    }
  }
#line 4171
  return;
}
}
#line 4179 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_start___2[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 4182 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_inc___3[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 4185 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_ystart___1[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 4188 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_yinc___1[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 4173 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_read_finish_row(png_structrp png_ptr ) 
{ 


  {
#line 4191
  (png_ptr->row_number) ++;
#line 4192
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 4193
    return;
  }
#line 4195
  if ((int )png_ptr->interlaced != 0) {
    {
#line 4197
    png_ptr->row_number = (png_uint_32 )0;
#line 4202
    memset((void *)png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
    }
    {
#line 4204
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4206
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 4208
      if ((int )png_ptr->pass >= 7) {
#line 4209
        goto while_break;
      }
#line 4211
      png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc___3[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___2[png_ptr->pass]) / (png_uint_32 )png_pass_inc___3[png_ptr->pass];
#line 4216
      if ((png_ptr->transformations & 2U) == 0U) {
#line 4218
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___1[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_ystart___1[png_ptr->pass]) / (png_uint_32 )png_pass_yinc___1[png_ptr->pass];
      } else {
#line 4225
        goto while_break;
      }
#line 4204
      if (! (png_ptr->num_rows == 0U)) {
#line 4204
        if (! (png_ptr->iwidth == 0U)) {
#line 4204
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4229
    if ((int )png_ptr->pass < 7) {
#line 4230
      return;
    }
  }
  {
#line 4234
  png_read_finish_IDAT(png_ptr);
  }
#line 4235
  return;
}
}
#line 4244 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_start___3[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 4247 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_inc___4[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 4250 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_ystart___2[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 4253 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
static png_byte const   png_pass_yinc___2[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 4238 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrutil.c"
void png_read_start_row(png_structrp png_ptr ) 
{ 
  int max_pixel_depth ;
  png_size_t row_bytes ;
  png_size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  png_bytep temp ;
  int extra ;
  png_bytep buffer___0 ;
  int tmp___3 ;

  {
  {
#line 4261
  png_init_read_transformations(png_ptr);
  }
#line 4263
  if ((int )png_ptr->interlaced != 0) {
#line 4265
    if ((png_ptr->transformations & 2U) == 0U) {
#line 4266
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___2[0]) - 1U) - (png_uint_32 )png_pass_ystart___2[0]) / (png_uint_32 )png_pass_yinc___2[0];
    } else {
#line 4270
      png_ptr->num_rows = png_ptr->height;
    }
#line 4272
    png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc___4[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___3[png_ptr->pass]) / (png_uint_32 )png_pass_inc___4[png_ptr->pass];
  } else {
#line 4280
    png_ptr->num_rows = png_ptr->height;
#line 4281
    png_ptr->iwidth = png_ptr->width;
  }
#line 4284
  max_pixel_depth = (int )png_ptr->pixel_depth;
#line 4430
  png_ptr->maximum_pixel_depth = (png_byte )max_pixel_depth;
#line 4431
  png_ptr->transformed_pixel_depth = (png_byte )0;
#line 4436
  row_bytes = (png_size_t )((png_ptr->width + 7U) & 4294967288U);
#line 4440
  if (max_pixel_depth >= 8) {
#line 4440
    tmp = row_bytes * ((png_size_t )max_pixel_depth >> 3);
  } else {
#line 4440
    tmp = (row_bytes * (png_size_t )max_pixel_depth + 7UL) >> 3;
  }
#line 4440
  row_bytes = (tmp + 1UL) + (png_size_t )((max_pixel_depth + 7) >> 3);
#line 4448
  if (row_bytes + 48UL > png_ptr->old_big_row_buf_size) {
    {
#line 4450
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_row_buf);
#line 4451
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_prev_row);
    }
#line 4453
    if ((int )png_ptr->interlaced != 0) {
      {
#line 4454
      tmp___0 = png_calloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4454
      png_ptr->big_row_buf = (png_bytep )tmp___0;
      }
    } else {
      {
#line 4458
      tmp___1 = png_malloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4458
      png_ptr->big_row_buf = (png_bytep )tmp___1;
      }
    }
    {
#line 4460
    tmp___2 = png_malloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4460
    png_ptr->big_prev_row = (png_bytep )tmp___2;
#line 4471
    temp = png_ptr->big_row_buf + 32;
#line 4472
    extra = (int )((temp - (png_bytep )0) & 15L);
#line 4473
    png_ptr->row_buf = (temp - extra) - 1;
#line 4475
    temp = png_ptr->big_prev_row + 32;
#line 4476
    extra = (int )((temp - (png_bytep )0) & 15L);
#line 4477
    png_ptr->prev_row = (temp - extra) - 1;
#line 4485
    png_ptr->old_big_row_buf_size = row_bytes + 48UL;
    }
  }
#line 4493
  if (png_ptr->rowbytes > 0xfffffffffffffffeUL) {
    {
#line 4494
    png_error((png_const_structrp )png_ptr, "Row has too many bytes to allocate in memory");
    }
  }
  {
#line 4496
  memset((void *)png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
  }
#line 4510
  if ((unsigned long )png_ptr->read_buffer != (unsigned long )((png_bytep )0)) {
    {
#line 4512
    buffer___0 = png_ptr->read_buffer;
#line 4514
    png_ptr->read_buffer_size = (png_alloc_size_t )0;
#line 4515
    png_ptr->read_buffer = (png_bytep )((void *)0);
#line 4516
    png_free((png_const_structrp )png_ptr, (png_voidp )buffer___0);
    }
  }
  {
#line 4524
  tmp___3 = png_inflate_claim(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U);
  }
#line 4524
  if (tmp___3 != 0) {
    {
#line 4525
    png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
    }
  }
#line 4527
  png_ptr->flags |= 64U;
#line 4528
  return;
}
}
#line 1430 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) ;
#line 1228 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
void png_read_transform_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1381
void png_do_read_transformations(png_structrp png_ptr , png_row_infop row_info ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrtran.c"
void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) 
{ 


  {
#line 29
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 30
    return;
  }
  {
#line 35
  if (crit_action == 5) {
#line 35
    goto case_5;
  }
#line 38
  if (crit_action == 3) {
#line 38
    goto case_3;
  }
#line 43
  if (crit_action == 4) {
#line 43
    goto case_4;
  }
#line 49
  if (crit_action == 2) {
#line 49
    goto case_2;
  }
#line 55
  goto switch_default;
  case_5: /* CIL Label */ 
#line 36
  goto switch_break;
  case_3: /* CIL Label */ 
#line 39
  png_ptr->flags &= 4294964223U;
#line 40
  png_ptr->flags |= 1024U;
#line 41
  goto switch_break;
  case_4: /* CIL Label */ 
#line 44
  png_ptr->flags &= 4294964223U;
#line 45
  png_ptr->flags |= 3072U;
#line 47
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 50
  png_warning((png_const_structrp )png_ptr, "Can\'t discard critical data on CRC error");
  }
  switch_default: /* CIL Label */ 
#line 56
  png_ptr->flags &= 4294964223U;
#line 57
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 63
  if (ancil_action == 5) {
#line 63
    goto case_5___0;
  }
#line 66
  if (ancil_action == 3) {
#line 66
    goto case_3___0;
  }
#line 71
  if (ancil_action == 4) {
#line 71
    goto case_4___0;
  }
#line 77
  if (ancil_action == 1) {
#line 77
    goto case_1;
  }
#line 85
  goto switch_default___0;
  case_5___0: /* CIL Label */ 
#line 64
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 67
  png_ptr->flags &= 4294966527U;
#line 68
  png_ptr->flags |= 256U;
#line 69
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 72
  png_ptr->flags &= 4294966527U;
#line 73
  png_ptr->flags |= 768U;
#line 75
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 78
  png_ptr->flags &= 4294966527U;
#line 79
  png_ptr->flags |= 512U;
#line 80
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 86
  png_ptr->flags &= 4294966527U;
#line 87
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 1099 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrtran.c"
static void png_init_palette_transformations(png_structrp png_ptr ) 
{ 
  int input_has_alpha ;
  int input_has_transparency ;
  int i ;

  {
#line 1110
  input_has_alpha = 0;
#line 1111
  input_has_transparency = 0;
#line 1113
  if ((int )png_ptr->num_trans > 0) {
#line 1118
    i = 0;
    {
#line 1118
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1118
      if (! (i < (int )png_ptr->num_trans)) {
#line 1118
        goto while_break;
      }
#line 1120
      if (! ((int )*(png_ptr->trans_alpha + i) == 255)) {
#line 1122
        if ((int )*(png_ptr->trans_alpha + i) == 0) {
#line 1123
          input_has_transparency = 1;
        } else {
#line 1126
          input_has_transparency = 1;
#line 1127
          input_has_alpha = 1;
#line 1128
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 1118
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1134
  if (input_has_alpha == 0) {
#line 1140
    png_ptr->transformations &= 4286578687U;
#line 1141
    png_ptr->flags &= 4294959103U;
#line 1143
    if (input_has_transparency == 0) {
#line 1144
      png_ptr->transformations &= 4294966911U;
    }
  }
#line 1186
  return;
}
}
#line 1188 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrtran.c"
static void png_init_rgb_transformations(png_structrp png_ptr ) 
{ 
  int input_has_alpha ;
  int input_has_transparency ;

  {
#line 1195
  input_has_alpha = ((int )png_ptr->color_type & 4) != 0;
#line 1196
  input_has_transparency = (int )png_ptr->num_trans > 0;
#line 1199
  if (input_has_alpha == 0) {
#line 1210
    if (input_has_transparency == 0) {
#line 1211
      png_ptr->transformations &= 4294966911U;
    }
  }
#line 1271
  return;
}
}
#line 1273 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrtran.c"
void png_init_read_transformations(png_structrp png_ptr ) 
{ 


  {
#line 1476
  if ((int )png_ptr->color_type == 3) {
    {
#line 1477
    png_init_palette_transformations(png_ptr);
    }
  } else {
    {
#line 1480
    png_init_rgb_transformations(png_ptr);
    }
  }
#line 1916
  return;
}
}
#line 1922 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrtran.c"
void png_read_transform_info(png_structrp png_ptr , png_inforp info_ptr ) 
{ 


  {
#line 2062
  if ((int )info_ptr->color_type == 3) {
#line 2063
    info_ptr->channels = (png_byte )1;
  } else
#line 2065
  if (((int )info_ptr->color_type & 2) != 0) {
#line 2066
    info_ptr->channels = (png_byte )3;
  } else {
#line 2069
    info_ptr->channels = (png_byte )1;
  }
#line 2080
  if (((int )info_ptr->color_type & 4) != 0) {
#line 2081
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 2108
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 2111
  if ((int )info_ptr->pixel_depth >= 8) {
#line 2111
    info_ptr->rowbytes = (png_size_t )info_ptr->width * ((png_size_t )info_ptr->pixel_depth >> 3);
  } else {
#line 2111
    info_ptr->rowbytes = ((png_size_t )info_ptr->width * (png_size_t )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 2119
  png_ptr->info_rowbytes = info_ptr->rowbytes;
#line 2122
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 2123
    return;
  }
#line 2125
  return;
}
}
#line 4703 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrtran.c"
void png_do_read_transformations(png_structrp png_ptr , png_row_infop row_info ) 
{ 


  {
#line 4708
  if ((unsigned long )png_ptr->row_buf == (unsigned long )((void *)0)) {
    {
#line 4714
    png_error((png_const_structrp )png_ptr, "NULL row buffer");
    }
  }
#line 4723
  if ((png_ptr->flags & 16384U) != 0U) {
#line 4723
    if ((png_ptr->flags & 64U) == 0U) {
      {
#line 4730
      png_error((png_const_structrp )png_ptr, "Uninitialized row");
      }
    }
  }
#line 4934
  if ((int )row_info->color_type == 3) {
#line 4934
    if (png_ptr->num_palette_max >= 0) {
      {
#line 4936
      png_do_check_palette_indexes(png_ptr, row_info);
      }
    }
  }
#line 4994
  return;
}
}
#line 1597 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    png_size_t  ) ) ;
#line 938 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
void png_default_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 31 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrio.c"
void png_read_data(png_structrp png_ptr , png_bytep data , png_size_t length ) 
{ 


  {
#line 36
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
    {
#line 37
    (*(png_ptr->read_data_fn))((png_structp )png_ptr, data, length);
    }
  } else {
    {
#line 40
    png_error((png_const_structrp )png_ptr, "Call to NULL read function");
    }
  }
#line 41
  return;
}
}
#line 49 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrio.c"
void png_default_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  png_size_t check ;

  {
#line 54
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 55
    return;
  }
  {
#line 60
  check = fread((void */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)png_ptr->io_ptr);
  }
#line 62
  if (check != length) {
    {
#line 63
    png_error((png_const_structrp )png_ptr, "Read Error");
    }
  }
#line 64
  return;
}
}
#line 86 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngrio.c"
void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    png_size_t  ) ) 
{ 


  {
#line 90
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 91
    return;
  }
#line 93
  png_ptr->io_ptr = io_ptr;
#line 96
  if ((unsigned long )read_data_fn != (unsigned long )((void *)0)) {
#line 97
    png_ptr->read_data_fn = read_data_fn;
  } else {
#line 100
    png_ptr->read_data_fn = & png_default_read_data;
  }
#line 107
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
    {
#line 109
    png_ptr->write_data_fn = (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0);
#line 110
    png_warning((png_const_structrp )png_ptr, "Can\'t set both read_data_fn and write_data_fn in the same structure");
    }
  }
#line 117
  png_ptr->output_flush_fn = (void (*)(png_structp  ))((void *)0);
#line 119
  return;
}
}
#line 928 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
png_structp __attribute__((__malloc__))  png_create_read_struct(png_const_charp user_png_ver ,
                                                                png_voidp error_ptr ,
                                                                void (*error_fn)(png_structp  ,
                                                                                 png_const_charp  ) ,
                                                                void (*warn_fn)(png_structp  ,
                                                                                png_const_charp  ) ) ;
#line 1028
void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1370
void png_start_read_image(png_structrp png_ptr ) ;
#line 1373
void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1378
void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows ) ;
#line 1384
void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep dsp_row ) ;
#line 1390
void png_read_image(png_structrp png_ptr , png_bytepp image___0 ) ;
#line 1414
void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1422
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr ) ;
#line 1603
void png_set_read_status_fn(png_structrp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                       png_uint_32  ,
                                                                       int  ) ) ;
#line 2315
void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) ;
#line 931 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
void png_zfree(voidpf png_ptr , voidpf ptr ) ;
#line 1372
int png_chunk_unknown_handling(png_const_structrp png_ptr , png_uint_32 chunk_name ) ;
#line 25 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
png_structp __attribute__((__malloc__))  png_create_read_struct(png_const_charp user_png_ver ,
                                                                png_voidp error_ptr ,
                                                                void (*error_fn)(png_structp  ,
                                                                                 png_const_charp  ) ,
                                                                void (*warn_fn)(png_structp  ,
                                                                                png_const_charp  ) ) 
{ 
  png_structp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;

  {
  {
#line 30
  tmp = png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, (void *)0,
                              (png_voidp (*)(png_structp  , png_alloc_size_t  ))((void *)0),
                              (void (*)(png_structp  , png_voidp  ))((void *)0));
#line 30
  png_ptr = (png_structp )tmp;
  }
#line 49
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 51
    png_ptr->mode = (png_uint_32 )32768;
#line 57
    png_ptr->IDAT_read_size = (uInt )8192;
#line 61
    png_ptr->flags |= 1048576U;
#line 67
    png_ptr->flags |= 2097152U;
#line 75
    png_set_read_fn((png_structrp )png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  ,
                                                                 png_size_t  ))((void *)0));
    }
  }
#line 78
  return ((png_structp __attribute__((__malloc__))  )png_ptr);
}
}
#line 91 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) 
{ 
  int keep ;
  png_uint_32 length ;
  png_uint_32 tmp ;
  png_uint_32 chunk_name ;

  {
#line 100
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 101
    return;
  } else
#line 100
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 101
    return;
  }
  {
#line 104
  png_read_sig(png_ptr, info_ptr);
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp = png_read_chunk_header(png_ptr);
#line 108
    length = tmp;
#line 109
    chunk_name = png_ptr->chunk_name;
    }
#line 114
    if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 116
      if ((png_ptr->mode & 1U) == 0U) {
        {
#line 117
        png_chunk_error((png_const_structrp )png_ptr, "Missing IHDR before IDAT");
        }
      } else
#line 119
      if ((int )png_ptr->color_type == 3) {
#line 119
        if ((png_ptr->mode & 2U) == 0U) {
          {
#line 121
          png_chunk_error((png_const_structrp )png_ptr, "Missing PLTE before IDAT");
          }
        } else {
#line 119
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 123
      if ((png_ptr->mode & 8U) != 0U) {
        {
#line 124
        png_chunk_benign_error((png_const_structrp )png_ptr, "Too many IDATs found");
        }
      }
#line 126
      png_ptr->mode |= 4U;
    } else
#line 129
    if ((png_ptr->mode & 4U) != 0U) {
#line 130
      png_ptr->mode |= 8U;
    }
#line 135
    if (chunk_name == ((((73U << 24) | (72U << 16)) | (68U << 8)) | 82U)) {
      {
#line 136
      png_handle_IHDR(png_ptr, info_ptr, length);
      }
    } else
#line 138
    if (chunk_name == ((((73U << 24) | (69U << 16)) | (78U << 8)) | 68U)) {
      {
#line 139
      png_handle_IEND(png_ptr, info_ptr, length);
      }
    } else {
      {
#line 142
      keep = png_chunk_unknown_handling((png_const_structrp )png_ptr, chunk_name);
      }
#line 142
      if (keep != 0) {
        {
#line 144
        png_handle_unknown(png_ptr, info_ptr, length, keep);
        }
#line 146
        if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 147
          png_ptr->mode |= 2U;
        } else
#line 149
        if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 151
          png_ptr->idat_size = (png_uint_32 )0;
#line 152
          goto while_break;
        }
      } else
#line 156
      if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
        {
#line 157
        png_handle_PLTE(png_ptr, info_ptr, length);
        }
      } else
#line 159
      if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 161
        png_ptr->idat_size = length;
#line 162
        goto while_break;
      } else
#line 166
      if (chunk_name == ((((98U << 24) | (75U << 16)) | (71U << 8)) | 68U)) {
        {
#line 167
        png_handle_bKGD(png_ptr, info_ptr, length);
        }
      } else
#line 181
      if (chunk_name == ((((104U << 24) | (73U << 16)) | (83U << 8)) | 84U)) {
        {
#line 182
        png_handle_hIST(png_ptr, info_ptr, length);
        }
      } else
#line 206
      if (chunk_name == ((((115U << 24) | (66U << 16)) | (73U << 8)) | 84U)) {
        {
#line 207
        png_handle_sBIT(png_ptr, info_ptr, length);
        }
      } else
#line 236
      if (chunk_name == ((((116U << 24) | (82U << 16)) | (78U << 8)) | 83U)) {
        {
#line 237
        png_handle_tRNS(png_ptr, info_ptr, length);
        }
      } else {
        {
#line 251
        png_handle_unknown(png_ptr, info_ptr, length, 0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 258 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) 
{ 


  {
#line 263
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 265
    if ((png_ptr->flags & 64U) == 0U) {
      {
#line 267
      png_read_start_row(png_ptr);
#line 270
      png_read_transform_info(png_ptr, info_ptr);
      }
    } else {
      {
#line 278
      png_app_error((png_const_structrp )png_ptr, "png_read_update_info/png_start_read_image: duplicate call");
      }
    }
  }
#line 281
  return;
}
}
#line 289 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_start_read_image(png_structrp png_ptr ) 
{ 


  {
#line 294
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 296
    if ((png_ptr->flags & 64U) == 0U) {
      {
#line 297
      png_read_start_row(png_ptr);
      }
    } else {
      {
#line 301
      png_app_error((png_const_structrp )png_ptr, "png_start_read_image/png_read_update_info: duplicate call");
      }
    }
  }
#line 304
  return;
}
}
#line 374 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep dsp_row ) 
{ 
  png_row_info row_info ;
  int tmp ;

  {
#line 379
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 380
    return;
  }
#line 388
  if ((png_ptr->flags & 64U) == 0U) {
    {
#line 389
    png_read_start_row(png_ptr);
    }
  }
#line 392
  row_info.width = png_ptr->iwidth;
#line 393
  row_info.color_type = png_ptr->color_type;
#line 394
  row_info.bit_depth = png_ptr->bit_depth;
#line 395
  row_info.channels = png_ptr->channels;
#line 396
  row_info.pixel_depth = png_ptr->pixel_depth;
#line 397
  if ((int )row_info.pixel_depth >= 8) {
#line 397
    row_info.rowbytes = (png_size_t )row_info.width * ((png_size_t )row_info.pixel_depth >> 3);
  } else {
#line 397
    row_info.rowbytes = ((png_size_t )row_info.width * (png_size_t )row_info.pixel_depth + 7UL) >> 3;
  }
#line 400
  if (png_ptr->row_number == 0U) {
#line 400
    if ((int )png_ptr->pass == 0) {
#line 400
      tmp = 1;
    } else {
#line 400
      tmp = 0;
    }
  } else {
#line 400
    tmp = 0;
  }
#line 448
  if ((int )png_ptr->interlaced != 0) {
#line 448
    if ((png_ptr->transformations & 2U) != 0U) {
      {
#line 453
      if ((int )png_ptr->pass == 0) {
#line 453
        goto case_0;
      }
#line 463
      if ((int )png_ptr->pass == 1) {
#line 463
        goto case_1;
      }
#line 474
      if ((int )png_ptr->pass == 2) {
#line 474
        goto case_2;
      }
#line 485
      if ((int )png_ptr->pass == 3) {
#line 485
        goto case_3;
      }
#line 496
      if ((int )png_ptr->pass == 4) {
#line 496
        goto case_4;
      }
#line 507
      if ((int )png_ptr->pass == 5) {
#line 507
        goto case_5;
      }
#line 518
      goto switch_default;
      case_0: /* CIL Label */ 
#line 454
      if (png_ptr->row_number & 7U) {
#line 456
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 457
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 458
        png_read_finish_row(png_ptr);
        }
#line 459
        return;
      }
#line 461
      goto switch_break;
      case_1: /* CIL Label */ 
#line 464
      if (png_ptr->row_number & 7U) {
#line 464
        goto _L;
      } else
#line 464
      if (png_ptr->width < 5U) {
        _L: /* CIL Label */ 
#line 466
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 467
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 469
        png_read_finish_row(png_ptr);
        }
#line 470
        return;
      }
#line 472
      goto switch_break;
      case_2: /* CIL Label */ 
#line 475
      if ((png_ptr->row_number & 7U) != 4U) {
#line 477
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 477
          if (png_ptr->row_number & 4U) {
            {
#line 478
            png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
            }
          }
        }
        {
#line 480
        png_read_finish_row(png_ptr);
        }
#line 481
        return;
      }
#line 483
      goto switch_break;
      case_3: /* CIL Label */ 
#line 486
      if (png_ptr->row_number & 3U) {
#line 486
        goto _L___0;
      } else
#line 486
      if (png_ptr->width < 3U) {
        _L___0: /* CIL Label */ 
#line 488
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 489
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 491
        png_read_finish_row(png_ptr);
        }
#line 492
        return;
      }
#line 494
      goto switch_break;
      case_4: /* CIL Label */ 
#line 497
      if ((png_ptr->row_number & 3U) != 2U) {
#line 499
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 499
          if (png_ptr->row_number & 2U) {
            {
#line 500
            png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
            }
          }
        }
        {
#line 502
        png_read_finish_row(png_ptr);
        }
#line 503
        return;
      }
#line 505
      goto switch_break;
      case_5: /* CIL Label */ 
#line 508
      if (png_ptr->row_number & 1U) {
#line 508
        goto _L___1;
      } else
#line 508
      if (png_ptr->width < 2U) {
        _L___1: /* CIL Label */ 
#line 510
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 511
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 513
        png_read_finish_row(png_ptr);
        }
#line 514
        return;
      }
#line 516
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 520
      if ((png_ptr->row_number & 1U) == 0U) {
        {
#line 522
        png_read_finish_row(png_ptr);
        }
#line 523
        return;
      }
#line 525
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 530
  if ((png_ptr->mode & 4U) == 0U) {
    {
#line 531
    png_error((png_const_structrp )png_ptr, "Invalid attempt to read row data");
    }
  }
  {
#line 534
  png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1UL);
  }
#line 536
  if ((int )*(png_ptr->row_buf + 0) > 0) {
#line 538
    if ((int )*(png_ptr->row_buf + 0) < 5) {
      {
#line 539
      png_read_filter_row(png_ptr, & row_info, png_ptr->row_buf + 1, (png_const_bytep )(png_ptr->prev_row + 1),
                          (int )*(png_ptr->row_buf + 0));
      }
    } else {
      {
#line 542
      png_error((png_const_structrp )png_ptr, "bad adaptive filter value");
      }
    }
  }
  {
#line 550
  memcpy((void */* __restrict  */)png_ptr->prev_row, (void const   */* __restrict  */)png_ptr->row_buf,
         row_info.rowbytes + 1UL);
  }
#line 562
  if (png_ptr->transformations) {
    {
#line 563
    png_do_read_transformations(png_ptr, & row_info);
    }
  }
#line 567
  if ((int )png_ptr->transformed_pixel_depth == 0) {
#line 569
    png_ptr->transformed_pixel_depth = row_info.pixel_depth;
#line 570
    if ((int )row_info.pixel_depth > (int )png_ptr->maximum_pixel_depth) {
      {
#line 571
      png_error((png_const_structrp )png_ptr, "sequential row overflow");
      }
    }
  } else
#line 574
  if ((int )png_ptr->transformed_pixel_depth != (int )row_info.pixel_depth) {
    {
#line 575
    png_error((png_const_structrp )png_ptr, "internal sequential row size calculation error");
    }
  }
#line 579
  if ((int )png_ptr->interlaced != 0) {
#line 579
    if ((png_ptr->transformations & 2U) != 0U) {
#line 582
      if ((int )png_ptr->pass < 6) {
        {
#line 583
        png_do_read_interlace(& row_info, png_ptr->row_buf + 1, (int )png_ptr->pass,
                              png_ptr->transformations);
        }
      }
#line 586
      if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
        {
#line 587
        png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
        }
      }
#line 589
      if ((unsigned long )row != (unsigned long )((void *)0)) {
        {
#line 590
        png_combine_row((png_const_structrp )png_ptr, row, 0);
        }
      }
    } else {
#line 579
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 596
    if ((unsigned long )row != (unsigned long )((void *)0)) {
      {
#line 597
      png_combine_row((png_const_structrp )png_ptr, row, -1);
      }
    }
#line 599
    if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
      {
#line 600
      png_combine_row((png_const_structrp )png_ptr, dsp_row, -1);
      }
    }
  }
  {
#line 602
  png_read_finish_row(png_ptr);
  }
#line 604
  if ((unsigned long )png_ptr->read_row_fn != (unsigned long )((void *)0)) {
    {
#line 605
    (*(png_ptr->read_row_fn))((png_structp )png_ptr, png_ptr->row_number, (int )png_ptr->pass);
    }
  }
#line 607
  return;
}
}
#line 635 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows ) 
{ 
  png_uint_32 i ;
  png_bytepp rp ;
  png_bytepp dp ;
  png_bytep rptr ;
  png_bytepp tmp ;
  png_bytep dptr ;
  png_bytepp tmp___0 ;
  png_bytep rptr___0 ;
  png_bytep dptr___0 ;

  {
#line 645
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 646
    return;
  }
#line 648
  rp = row;
#line 649
  dp = display_row;
#line 650
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 650
    if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 651
      i = (png_uint_32 )0;
      {
#line 651
      while (1) {
        while_continue: /* CIL Label */ ;
#line 651
        if (! (i < num_rows)) {
#line 651
          goto while_break;
        }
        {
#line 653
        tmp = rp;
#line 653
        rp ++;
#line 653
        rptr = *tmp;
#line 654
        tmp___0 = dp;
#line 654
        dp ++;
#line 654
        dptr = *tmp___0;
#line 656
        png_read_row(png_ptr, rptr, dptr);
#line 651
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 650
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 659
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 660
    i = (png_uint_32 )0;
    {
#line 660
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 660
      if (! (i < num_rows)) {
#line 660
        goto while_break___0;
      }
      {
#line 662
      rptr___0 = *rp;
#line 663
      png_read_row(png_ptr, rptr___0, (png_bytep )((void *)0));
#line 664
      rp ++;
#line 660
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 667
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 668
    i = (png_uint_32 )0;
    {
#line 668
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 668
      if (! (i < num_rows)) {
#line 668
        goto while_break___1;
      }
      {
#line 670
      dptr___0 = *dp;
#line 671
      png_read_row(png_ptr, (png_bytep )((void *)0), dptr___0);
#line 672
      dp ++;
#line 668
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 674
  return;
}
}
#line 690 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_read_image(png_structrp png_ptr , png_bytepp image___0 ) 
{ 
  png_uint_32 i ;
  png_uint_32 image_height ;
  int pass ;
  int j ;
  png_bytepp rp ;

  {
#line 699
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 700
    return;
  }
#line 703
  if ((png_ptr->flags & 64U) == 0U) {
    {
#line 705
    pass = png_set_interlace_handling(png_ptr);
#line 707
    png_start_read_image(png_ptr);
    }
  } else {
#line 711
    if ((int )png_ptr->interlaced != 0) {
#line 711
      if ((png_ptr->transformations & 2U) == 0U) {
        {
#line 718
        png_warning((png_const_structrp )png_ptr, "Interlace handling should be turned on when using png_read_image");
#line 721
        png_ptr->num_rows = png_ptr->height;
        }
      }
    }
    {
#line 727
    pass = png_set_interlace_handling(png_ptr);
    }
  }
#line 737
  image_height = png_ptr->height;
#line 739
  j = 0;
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 739
    if (! (j < pass)) {
#line 739
      goto while_break;
    }
#line 741
    rp = image___0;
#line 742
    i = (png_uint_32 )0;
    {
#line 742
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 742
      if (! (i < image_height)) {
#line 742
        goto while_break___0;
      }
      {
#line 744
      png_read_row(png_ptr, *rp, (png_bytep )((void *)0));
#line 745
      rp ++;
#line 742
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 739
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  return;
}
}
#line 756 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) 
{ 
  int keep ;
  int tmp ;
  png_uint_32 length ;
  png_uint_32 tmp___0 ;
  png_uint_32 chunk_name ;

  {
#line 765
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 766
    return;
  }
  {
#line 772
  tmp = png_chunk_unknown_handling((png_const_structrp )png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U);
  }
#line 772
  if (tmp == 0) {
    {
#line 774
    png_read_finish_IDAT(png_ptr);
    }
  }
#line 778
  if ((int )png_ptr->color_type == 3) {
#line 778
    if (png_ptr->num_palette_max > (int )png_ptr->num_palette) {
      {
#line 780
      png_benign_error((png_const_structrp )png_ptr, "Read palette index exceeding num_palette");
      }
    }
  }
  {
#line 783
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 785
    tmp___0 = png_read_chunk_header(png_ptr);
#line 785
    length = tmp___0;
#line 786
    chunk_name = png_ptr->chunk_name;
    }
#line 788
    if (chunk_name == ((((73U << 24) | (69U << 16)) | (78U << 8)) | 68U)) {
      {
#line 789
      png_handle_IEND(png_ptr, info_ptr, length);
      }
    } else
#line 791
    if (chunk_name == ((((73U << 24) | (72U << 16)) | (68U << 8)) | 82U)) {
      {
#line 792
      png_handle_IHDR(png_ptr, info_ptr, length);
      }
    } else
#line 794
    if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
      {
#line 795
      png_crc_finish(png_ptr, length);
      }
    } else {
      {
#line 798
      keep = png_chunk_unknown_handling((png_const_structrp )png_ptr, chunk_name);
      }
#line 798
      if (keep != 0) {
#line 800
        if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 802
          if (length > 0U) {
            {
#line 804
            png_benign_error((png_const_structrp )png_ptr, "Too many IDATs found");
            }
          } else
#line 802
          if ((png_ptr->mode & 8192U) != 0U) {
            {
#line 804
            png_benign_error((png_const_structrp )png_ptr, "Too many IDATs found");
            }
          }
        }
        {
#line 806
        png_handle_unknown(png_ptr, info_ptr, length, keep);
        }
#line 807
        if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 808
          png_ptr->mode |= 2U;
        }
      } else
#line 812
      if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 817
        if (length > 0U) {
          {
#line 818
          png_benign_error((png_const_structrp )png_ptr, "Too many IDATs found");
          }
        } else
#line 817
        if ((png_ptr->mode & 8192U) != 0U) {
          {
#line 818
          png_benign_error((png_const_structrp )png_ptr, "Too many IDATs found");
          }
        }
        {
#line 820
        png_crc_finish(png_ptr, length);
        }
      } else
#line 822
      if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
        {
#line 823
        png_handle_PLTE(png_ptr, info_ptr, length);
        }
      } else
#line 826
      if (chunk_name == ((((98U << 24) | (75U << 16)) | (71U << 8)) | 68U)) {
        {
#line 827
        png_handle_bKGD(png_ptr, info_ptr, length);
        }
      } else
#line 841
      if (chunk_name == ((((104U << 24) | (73U << 16)) | (83U << 8)) | 84U)) {
        {
#line 842
        png_handle_hIST(png_ptr, info_ptr, length);
        }
      } else
#line 866
      if (chunk_name == ((((115U << 24) | (66U << 16)) | (73U << 8)) | 84U)) {
        {
#line 867
        png_handle_sBIT(png_ptr, info_ptr, length);
        }
      } else
#line 896
      if (chunk_name == ((((116U << 24) | (82U << 16)) | (78U << 8)) | 83U)) {
        {
#line 897
        png_handle_tRNS(png_ptr, info_ptr, length);
        }
      } else {
        {
#line 911
        png_handle_unknown(png_ptr, info_ptr, length, 0);
        }
      }
    }
#line 783
    if (! ((png_ptr->mode & 16U) == 0U)) {
#line 783
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 914
  return;
}
}
#line 918 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
static void png_read_destroy(png_structrp png_ptr ) 
{ 


  {
  {
#line 927
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_row_buf);
#line 928
  png_ptr->big_row_buf = (png_bytep )((void *)0);
#line 929
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_prev_row);
#line 930
  png_ptr->big_prev_row = (png_bytep )((void *)0);
#line 931
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->read_buffer);
#line 932
  png_ptr->read_buffer = (png_bytep )((void *)0);
  }
#line 941
  if ((png_ptr->free_me & 4096U) != 0U) {
    {
#line 943
    png_zfree((voidpf )png_ptr, (voidpf )png_ptr->palette);
#line 944
    png_ptr->palette = (png_colorp )((void *)0);
    }
  }
#line 946
  png_ptr->free_me &= 4294963199U;
#line 950
  if ((png_ptr->free_me & 8192U) != 0U) {
    {
#line 952
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->trans_alpha);
#line 953
    png_ptr->trans_alpha = (png_bytep )((void *)0);
    }
  }
  {
#line 955
  png_ptr->free_me &= 4294959103U;
#line 958
  inflateEnd(& png_ptr->zstream);
#line 967
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
#line 968
  png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
#line 972
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
#line 973
  png_ptr->chunk_list = (png_bytep )((void *)0);
  }
#line 980
  return;
}
}
#line 983 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr ) 
{ 
  png_structrp png_ptr ;

  {
#line 987
  png_ptr = (png_structrp )((void *)0);
#line 991
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 992
    png_ptr = (png_structrp )*png_ptr_ptr;
  }
#line 994
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 995
    return;
  }
  {
#line 1001
  png_destroy_info_struct((png_const_structrp )png_ptr, end_info_ptr_ptr);
#line 1002
  png_destroy_info_struct((png_const_structrp )png_ptr, info_ptr_ptr);
#line 1004
  *png_ptr_ptr = (png_struct *)((void *)0);
#line 1005
  png_read_destroy(png_ptr);
#line 1006
  png_destroy_png_struct(png_ptr);
  }
#line 1007
  return;
}
}
#line 1009 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_set_read_status_fn(png_structrp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                       png_uint_32  ,
                                                                       int  ) ) 
{ 


  {
#line 1012
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1013
    return;
  }
#line 1015
  png_ptr->read_row_fn = read_row_fn;
#line 1016
  return;
}
}
#line 1021 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngread.c"
void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) 
{ 
  png_uint_32 iptr ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
#line 1026
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1027
    return;
  } else
#line 1026
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1027
    return;
  }
  {
#line 1032
  png_read_info(png_ptr, info_ptr);
  }
#line 1033
  if ((unsigned long )info_ptr->height > 4294967295UL / sizeof(png_bytep )) {
    {
#line 1034
    png_error((png_const_structrp )png_ptr, "Image is too high to process with png_read_png()");
    }
  }
#line 1045
  if ((transforms & 32768) != 0) {
    {
#line 1052
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SCALE_16 not supported");
    }
  }
#line 1059
  if ((transforms & 1) != 0) {
    {
#line 1063
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_STRIP_16 not supported");
    }
  }
#line 1069
  if ((transforms & 2) != 0) {
    {
#line 1073
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_STRIP_ALPHA not supported");
    }
  }
#line 1079
  if ((transforms & 4) != 0) {
    {
#line 1083
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKING not supported");
    }
  }
#line 1089
  if ((transforms & 8) != 0) {
    {
#line 1093
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKSWAP not supported");
    }
  }
#line 1101
  if ((transforms & 16) != 0) {
    {
#line 1105
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_EXPAND not supported");
    }
  }
#line 1113
  if ((transforms & 32) != 0) {
    {
#line 1117
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_MONO not supported");
    }
  }
#line 1124
  if ((transforms & 64) != 0) {
    {
#line 1129
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SHIFT not supported");
    }
  }
#line 1133
  if ((transforms & 128) != 0) {
    {
#line 1137
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_BGR not supported");
    }
  }
#line 1141
  if ((transforms & 256) != 0) {
    {
#line 1145
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ALPHA not supported");
    }
  }
#line 1149
  if ((transforms & 512) != 0) {
    {
#line 1153
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ENDIAN not supported");
    }
  }
#line 1158
  if ((transforms & 1024) != 0) {
    {
#line 1162
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_ALPHA not supported");
    }
  }
#line 1167
  if ((transforms & 8192) != 0) {
    {
#line 1171
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_GRAY_TO_RGB not supported");
    }
  }
#line 1175
  if ((transforms & 16384) != 0) {
    {
#line 1179
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_EXPAND_16 not supported");
    }
  }
  {
#line 1187
  png_set_interlace_handling(png_ptr);
#line 1193
  png_read_update_info(png_ptr, info_ptr);
#line 1197
  png_free_data((png_const_structrp )png_ptr, info_ptr, (png_uint_32 )64, 0);
  }
#line 1198
  if ((unsigned long )info_ptr->row_pointers == (unsigned long )((void *)0)) {
    {
#line 1202
    tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )info_ptr->height * sizeof(png_bytep ));
#line 1202
    info_ptr->row_pointers = (png_bytepp )tmp;
#line 1205
    iptr = (png_uint_32 )0;
    }
    {
#line 1205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1205
      if (! (iptr < info_ptr->height)) {
#line 1205
        goto while_break;
      }
#line 1206
      *(info_ptr->row_pointers + iptr) = (png_byte *)((void *)0);
#line 1205
      iptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1208
    info_ptr->free_me |= 64U;
#line 1210
    iptr = (png_uint_32 )0;
    {
#line 1210
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1210
      if (! (iptr < info_ptr->height)) {
#line 1210
        goto while_break___0;
      }
      {
#line 1211
      tmp___0 = png_malloc((png_const_structrp )png_ptr, info_ptr->rowbytes);
#line 1211
      *(info_ptr->row_pointers + iptr) = (png_byte *)tmp___0;
#line 1210
      iptr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1215
  png_read_image(png_ptr, info_ptr->row_pointers);
#line 1216
  info_ptr->valid |= 32768U;
#line 1219
  png_read_end(png_ptr, info_ptr);
  }
#line 1222
  return;
}
}
#line 907 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
png_uint_32 png_access_version_number(void) ;
#line 912
void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 974
int png_reset_zstream(png_structrp png_ptr ) ;
#line 1010
png_infop __attribute__((__malloc__))  png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1017
void png_info_init_3(png_infopp ptr_ptr , png_size_t png_info_struct_size ) ;
#line 1566
void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1577
void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) ) ;
#line 1601
png_voidp png_get_io_ptr(png_const_structrp png_ptr ) ;
#line 1746
void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                    png_uint_32 mask ) ;
#line 2324
png_const_charp png_get_copyright(png_const_structrp png_ptr ) ;
#line 2326
png_const_charp png_get_header_ver(png_const_structrp png_ptr ) ;
#line 2328
png_const_charp png_get_header_version(png_const_structrp png_ptr ) ;
#line 2330
png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) ;
#line 2548
void png_save_int_32(png_bytep buf , png_int_32 i ) ;
#line 881 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
int png_user_version_check(png_structrp png_ptr , png_const_charp user_png_ver ) ;
#line 927
voidpf __attribute__((__malloc__))  png_zalloc(voidpf png_ptr , uInt items , uInt size ) ;
#line 26 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) 
{ 
  unsigned int nb ;

  {
#line 29
  nb = (unsigned int )num_bytes;
#line 33
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 34
    return;
  }
#line 36
  if (num_bytes < 0) {
#line 37
    nb = 0U;
  }
#line 39
  if (nb > 8U) {
    {
#line 40
    png_error((png_const_structrp )png_ptr, "Too many bytes for PNG signature");
    }
  }
#line 42
  png_ptr->sig_bytes = (png_byte )nb;
#line 43
  return;
}
}
#line 53 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
int png_sig_cmp(png_const_bytep sig , png_size_t start , png_size_t num_to_check ) 
{ 
  png_byte png_signature[8] ;
  int tmp ;

  {
#line 56
  png_signature[0] = (png_byte )137;
#line 56
  png_signature[1] = (png_byte )80;
#line 56
  png_signature[2] = (png_byte )78;
#line 56
  png_signature[3] = (png_byte )71;
#line 56
  png_signature[4] = (png_byte )13;
#line 56
  png_signature[5] = (png_byte )10;
#line 56
  png_signature[6] = (png_byte )26;
#line 56
  png_signature[7] = (png_byte )10;
#line 58
  if (num_to_check > 8UL) {
#line 59
    num_to_check = (png_size_t )8;
  } else
#line 61
  if (num_to_check < 1UL) {
#line 62
    return (-1);
  }
#line 64
  if (start > 7UL) {
#line 65
    return (-1);
  }
#line 67
  if (start + num_to_check > 8UL) {
#line 68
    num_to_check = 8UL - start;
  }
  {
#line 70
  tmp = memcmp((void const   *)(sig + start), (void const   *)(& png_signature[start]),
               num_to_check);
  }
#line 70
  return (tmp);
}
}
#line 77 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
voidpf __attribute__((__malloc__))  png_zalloc(voidpf png_ptr , uInt items , uInt size ) 
{ 
  png_alloc_size_t num_bytes ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 80
  num_bytes = (png_alloc_size_t )size;
#line 82
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 83
    return ((voidpf __attribute__((__malloc__))  )((void *)0));
  }
#line 85
  if ((png_alloc_size_t )items >= 0xffffffffffffffffUL / (png_alloc_size_t )size) {
    {
#line 87
    png_warning((png_const_structrp )png_ptr, "Potential overflow in png_zalloc()");
    }
#line 89
    return ((voidpf __attribute__((__malloc__))  )((void *)0));
  }
  {
#line 92
  num_bytes *= (png_alloc_size_t )items;
#line 93
  tmp = png_malloc_warn((png_const_structrp )png_ptr, num_bytes);
  }
#line 93
  return (tmp);
}
}
#line 97 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_zfree(voidpf png_ptr , voidpf ptr ) 
{ 


  {
  {
#line 100
  png_free((png_const_structrp )png_ptr, ptr);
  }
#line 101
  return;
}
}
#line 106 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_reset_crc(png_structrp png_ptr ) 
{ 
  uLong tmp ;

  {
  {
#line 110
  tmp = crc32((uLong )0, (Bytef const   *)0, (uInt )0);
#line 110
  png_ptr->crc = (png_uint_32 )tmp;
  }
#line 111
  return;
}
}
#line 118 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_calculate_crc(png_structrp png_ptr , png_const_bytep ptr , png_size_t length ) 
{ 
  int need_crc ;
  uLong crc ;
  uInt safe_length ;

  {
#line 121
  need_crc = 1;
#line 123
  if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 125
    if ((png_ptr->flags & 768U) == 768U) {
#line 127
      need_crc = 0;
    }
  } else
#line 132
  if ((png_ptr->flags & 2048U) != 0U) {
#line 133
    need_crc = 0;
  }
#line 141
  if (need_crc != 0) {
#line 141
    if (length > 0UL) {
#line 143
      crc = (uLong )png_ptr->crc;
      {
#line 145
      while (1) {
        while_continue: /* CIL Label */ ;
#line 147
        safe_length = (uInt )length;
#line 149
        if (safe_length == 0U) {
#line 150
          safe_length = (uInt )-1;
        }
        {
#line 153
        crc = crc32(crc, ptr, safe_length);
#line 159
        ptr += safe_length;
#line 160
        length -= (png_size_t )safe_length;
        }
#line 145
        if (! (length > 0UL)) {
#line 145
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 165
      png_ptr->crc = (png_uint_32 )crc;
    }
  }
#line 167
  return;
}
}
#line 172 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
int png_user_version_check(png_structrp png_ptr , png_const_charp user_png_ver ) 
{ 
  int i ;
  int found_dots ;
  size_t pos ;
  char m[128] ;

  {
#line 180
  if ((unsigned long )user_png_ver != (unsigned long )((void *)0)) {
#line 182
    i = -1;
#line 183
    found_dots = 0;
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
#line 187
      i ++;
#line 188
      if ((int const   )*(user_png_ver + i) != (int const   )*("1.6.21" + i)) {
#line 189
        png_ptr->flags |= 131072U;
      }
#line 190
      if ((int const   )*(user_png_ver + i) == 46) {
#line 191
        found_dots ++;
      }
#line 185
      if (found_dots < 2) {
#line 185
        if ((int const   )*(user_png_ver + i) != 0) {
#line 185
          if (! ((int const   )*("1.6.21" + i) != 0)) {
#line 185
            goto while_break;
          }
        } else {
#line 185
          goto while_break;
        }
      } else {
#line 185
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 197
    png_ptr->flags |= 131072U;
  }
#line 199
  if ((png_ptr->flags & 131072U) != 0U) {
    {
#line 202
    pos = (size_t )0;
#line 205
    pos = png_safecat(m, sizeof(m), pos, "Application built with libpng-");
#line 207
    pos = png_safecat(m, sizeof(m), pos, user_png_ver);
#line 208
    pos = png_safecat(m, sizeof(m), pos, " but running with ");
#line 209
    pos = png_safecat(m, sizeof(m), pos, "1.6.21");
#line 212
    png_warning((png_const_structrp )png_ptr, (png_const_charp )(m));
    }
#line 219
    return (0);
  }
#line 223
  return (1);
}
}
#line 229 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_structp __attribute__((__malloc__))  png_create_png_struct(png_const_charp user_png_ver ,
                                                               png_voidp error_ptr ,
                                                               void (*error_fn)(png_structp  ,
                                                                                png_const_charp  ) ,
                                                               void (*warn_fn)(png_structp  ,
                                                                               png_const_charp  ) ,
                                                               png_voidp mem_ptr ,
                                                               png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                                                               void (*free_fn)(png_structp  ,
                                                                               png_voidp  ) ) 
{ 
  png_struct create_struct ;
  png_structrp png_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;
  int tmp___0 ;

  {
  {
#line 243
  memset((void *)(& create_struct), 0, sizeof(create_struct));
#line 247
  create_struct.user_width_max = (png_uint_32 )1000000;
#line 248
  create_struct.user_height_max = (png_uint_32 )1000000;
#line 252
  create_struct.user_chunk_cache_max = (png_uint_32 )1000;
#line 259
  create_struct.user_chunk_malloc_max = (png_alloc_size_t )8000000;
#line 279
  png_set_error_fn((png_structrp )(& create_struct), error_ptr, error_fn, warn_fn);
#line 297
  tmp___0 = png_user_version_check((png_structrp )(& create_struct), user_png_ver);
  }
#line 297
  if (tmp___0 != 0) {
    {
#line 299
    tmp = png_malloc_warn((png_const_structrp )(& create_struct), sizeof(*png_ptr));
#line 299
    png_ptr = (png_structrp )tmp;
    }
#line 302
    if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 307
      create_struct.zstream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& png_zalloc);
#line 308
      create_struct.zstream.zfree = & png_zfree;
#line 309
      create_struct.zstream.opaque = (voidpf )png_ptr;
#line 318
      *png_ptr = create_struct;
#line 321
      return ((png_structp __attribute__((__malloc__))  )png_ptr);
    }
  }
#line 329
  return ((png_structp __attribute__((__malloc__))  )((void *)0));
}
}
#line 333 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_infop __attribute__((__malloc__))  png_create_info_struct(png_const_structrp png_ptr ) 
{ 
  png_inforp info_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 340
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 341
    return ((png_infop __attribute__((__malloc__))  )((void *)0));
  }
  {
#line 348
  tmp = png_malloc_base(png_ptr, sizeof(*info_ptr));
#line 348
  info_ptr = (png_inforp )tmp;
  }
#line 351
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 352
    memset((void *)info_ptr, 0, sizeof(*info_ptr));
    }
  }
#line 354
  return ((png_infop __attribute__((__malloc__))  )info_ptr);
}
}
#line 365 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) 
{ 
  png_inforp info_ptr ;

  {
#line 368
  info_ptr = (png_inforp )((void *)0);
#line 372
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 373
    return;
  }
#line 375
  if ((unsigned long )info_ptr_ptr != (unsigned long )((void *)0)) {
#line 376
    info_ptr = (png_inforp )*info_ptr_ptr;
  }
#line 378
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 386
    *info_ptr_ptr = (png_info *)((void *)0);
#line 388
    png_free_data(png_ptr, info_ptr, (png_uint_32 )32767, -1);
#line 389
    memset((void *)info_ptr, 0, sizeof(*info_ptr));
#line 390
    png_free(png_ptr, (png_voidp )info_ptr);
    }
  }
#line 392
  return;
}
}
#line 403 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_info_init_3(png_infopp ptr_ptr , png_size_t png_info_struct_size ) 
{ 
  png_inforp info_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 407
  info_ptr = (png_inforp )*ptr_ptr;
#line 411
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 412
    return;
  }
#line 414
  if (sizeof(png_info ) > png_info_struct_size) {
    {
#line 416
    *ptr_ptr = (png_info *)((void *)0);
#line 418
    free((void *)info_ptr);
#line 419
    tmp = png_malloc_base((png_const_structrp )((void *)0), sizeof(*info_ptr));
#line 419
    info_ptr = (png_inforp )tmp;
    }
#line 421
    if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 422
      return;
    }
#line 423
    *ptr_ptr = (png_info *)info_ptr;
  }
  {
#line 427
  memset((void *)info_ptr, 0, sizeof(*info_ptr));
  }
#line 428
  return;
}
}
#line 431 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                    png_uint_32 mask ) 
{ 


  {
#line 437
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 438
    return;
  } else
#line 437
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 438
    return;
  }
#line 440
  if (freer == 1) {
#line 441
    info_ptr->free_me |= mask;
  } else
#line 443
  if (freer == 2) {
#line 444
    info_ptr->free_me &= ~ mask;
  } else {
    {
#line 447
    png_error(png_ptr, "Unknown freer parameter in png_data_freer");
    }
  }
#line 448
  return;
}
}
#line 450 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 mask ,
                   int num ) 
{ 
  int i ;
  png_uint_32 row ;

  {
#line 456
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 457
    return;
  } else
#line 456
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 457
    return;
  }
#line 486
  if (((mask & 8192U) & info_ptr->free_me) != 0U) {
    {
#line 488
    info_ptr->valid &= 4294967279U;
#line 489
    png_free(png_ptr, (png_voidp )info_ptr->trans_alpha);
#line 490
    info_ptr->trans_alpha = (png_bytep )((void *)0);
#line 491
    info_ptr->num_trans = (png_uint_16 )0;
    }
  }
#line 574
  if ((unsigned long )info_ptr->unknown_chunks != (unsigned long )((png_unknown_chunkp )0)) {
#line 574
    if (((mask & 512U) & info_ptr->free_me) != 0U) {
#line 577
      if (num != -1) {
        {
#line 579
        png_free(png_ptr, (png_voidp )(info_ptr->unknown_chunks + num)->data);
#line 580
        (info_ptr->unknown_chunks + num)->data = (png_byte *)((void *)0);
        }
      } else {
#line 587
        i = 0;
        {
#line 587
        while (1) {
          while_continue: /* CIL Label */ ;
#line 587
          if (! (i < info_ptr->unknown_chunks_num)) {
#line 587
            goto while_break;
          }
          {
#line 588
          png_free(png_ptr, (png_voidp )(info_ptr->unknown_chunks + i)->data);
#line 587
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 590
        png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 591
        info_ptr->unknown_chunks = (png_unknown_chunkp )((void *)0);
#line 592
        info_ptr->unknown_chunks_num = 0;
        }
      }
    }
  }
#line 599
  if (((mask & 8U) & info_ptr->free_me) != 0U) {
    {
#line 601
    png_free(png_ptr, (png_voidp )info_ptr->hist);
#line 602
    info_ptr->hist = (png_uint_16p )((void *)0);
#line 603
    info_ptr->valid &= 4294967231U;
    }
  }
#line 608
  if (((mask & 4096U) & info_ptr->free_me) != 0U) {
    {
#line 610
    png_free(png_ptr, (png_voidp )info_ptr->palette);
#line 611
    info_ptr->palette = (png_colorp )((void *)0);
#line 612
    info_ptr->valid &= 4294967287U;
#line 613
    info_ptr->num_palette = (png_uint_16 )0;
    }
  }
#line 618
  if (((mask & 64U) & info_ptr->free_me) != 0U) {
#line 620
    if ((unsigned long )info_ptr->row_pointers != (unsigned long )((png_bytepp )0)) {
#line 623
      row = (png_uint_32 )0;
      {
#line 623
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 623
        if (! (row < info_ptr->height)) {
#line 623
          goto while_break___0;
        }
        {
#line 624
        png_free(png_ptr, (png_voidp )*(info_ptr->row_pointers + row));
#line 623
        row ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 626
      png_free(png_ptr, (png_voidp )info_ptr->row_pointers);
#line 627
      info_ptr->row_pointers = (png_bytepp )((void *)0);
      }
    }
#line 629
    info_ptr->valid &= 4294934527U;
  }
#line 633
  if (num != -1) {
#line 634
    mask &= 4294950367U;
  }
#line 636
  info_ptr->free_me &= ~ mask;
#line 637
  return;
}
}
#line 644 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_voidp png_get_io_ptr(png_const_structrp png_ptr ) 
{ 


  {
#line 647
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 648
    return ((void *)0);
  }
#line 650
  return ((png_voidp )png_ptr->io_ptr);
}
}
#line 661 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_init_io(png_structrp png_ptr , png_FILE_p fp ) 
{ 


  {
#line 666
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 667
    return;
  }
#line 669
  png_ptr->io_ptr = (png_voidp )fp;
#line 670
  return;
}
}
#line 684 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_save_int_32(png_bytep buf , png_int_32 i ) 
{ 


  {
  {
#line 687
  png_save_uint_32(buf, (png_uint_32 )i);
  }
#line 688
  return;
}
}
#line 769 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_const_charp png_get_copyright(png_const_structrp png_ptr ) 
{ 


  {
#line 777
  return ("\nlibpng version 1.6.21 - January 15, 2016\nCopyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson\nCopyright (c) 1996-1997 Andreas Dilger\nCopyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
}
}
#line 801 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) 
{ 
  png_const_charp tmp ;

  {
  {
#line 805
  tmp = png_get_header_ver(png_ptr);
  }
#line 805
  return (tmp);
}
}
#line 808 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_const_charp png_get_header_ver(png_const_structrp png_ptr ) 
{ 


  {
#line 813
  return ("1.6.21");
}
}
#line 816 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_const_charp png_get_header_version(png_const_structrp png_ptr ) 
{ 


  {
#line 822
  return (" libpng version 1.6.21 - January 15, 2016\n\n");
}
}
#line 890 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) 
{ 
  png_const_bytep p ;
  png_const_bytep p_end ;
  int tmp ;

  {
#line 896
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 897
    return (0);
  } else
#line 896
  if ((unsigned long )chunk_name == (unsigned long )((void *)0)) {
#line 897
    return (0);
  } else
#line 896
  if (png_ptr->num_chunk_list == 0U) {
#line 897
    return (0);
  }
#line 899
  p_end = (png_const_bytep )png_ptr->chunk_list;
#line 900
  p = p_end + png_ptr->num_chunk_list * 5U;
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 908
    p -= 5;
#line 910
    tmp = memcmp((void const   *)chunk_name, (void const   *)p, (size_t )4);
    }
#line 910
    if (tmp == 0) {
#line 911
      return ((int )*(p + 4));
    }
#line 906
    if (! ((unsigned long )p > (unsigned long )p_end)) {
#line 906
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return (0);
}
}
#line 925 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
int png_chunk_unknown_handling(png_const_structrp png_ptr , png_uint_32 chunk_name ) 
{ 
  png_byte chunk_string[5] ;
  int tmp ;

  {
  {
#line 930
  *((char *)(chunk_string) + 0) = (char )((chunk_name >> 24) & 255U);
#line 930
  *((char *)(chunk_string) + 1) = (char )((chunk_name >> 16) & 255U);
#line 930
  *((char *)(chunk_string) + 2) = (char )((chunk_name >> 8) & 255U);
#line 930
  *((char *)(chunk_string) + 3) = (char )(chunk_name & 255U);
#line 930
  *((char *)(chunk_string) + 4) = (char)0;
#line 931
  tmp = png_handle_as_unknown(png_ptr, (png_const_bytep )(chunk_string));
  }
#line 931
  return (tmp);
}
}
#line 938 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
int png_reset_zstream(png_structrp png_ptr ) 
{ 
  int tmp ;

  {
#line 941
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 942
    return (-2);
  }
  {
#line 945
  tmp = inflateReset(& png_ptr->zstream);
  }
#line 945
  return (tmp);
}
}
#line 950 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
png_uint_32 png_access_version_number(void) 
{ 


  {
#line 954
  return ((png_uint_32 )10621);
}
}
#line 962 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_zstream_error(png_structrp png_ptr , int ret ) 
{ 


  {
#line 969
  if ((unsigned long )png_ptr->zstream.msg == (unsigned long )((void *)0)) {
    {
#line 976
    if (ret == 1) {
#line 976
      goto case_1;
    }
#line 981
    if (ret == 2) {
#line 981
      goto case_2;
    }
#line 988
    if (ret == -1) {
#line 988
      goto case_neg_1;
    }
#line 993
    if (ret == -2) {
#line 993
      goto case_neg_2;
    }
#line 998
    if (ret == -3) {
#line 998
      goto case_neg_3;
    }
#line 1002
    if (ret == -4) {
#line 1002
      goto case_neg_4;
    }
#line 1006
    if (ret == -5) {
#line 1006
      goto case_neg_5;
    }
#line 1013
    if (ret == -6) {
#line 1013
      goto case_neg_6;
    }
#line 1017
    if (ret == -7) {
#line 1017
      goto case_neg_7;
    }
#line 971
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 973
    png_ptr->zstream.msg = "unexpected zlib return code";
#line 974
    goto switch_break;
    case_1: /* CIL Label */ 
#line 978
    png_ptr->zstream.msg = "unexpected end of LZ stream";
#line 979
    goto switch_break;
    case_2: /* CIL Label */ 
#line 985
    png_ptr->zstream.msg = "missing LZ dictionary";
#line 986
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 990
    png_ptr->zstream.msg = "zlib IO error";
#line 991
    goto switch_break;
    case_neg_2: /* CIL Label */ 
#line 995
    png_ptr->zstream.msg = "bad parameters to zlib";
#line 996
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 999
    png_ptr->zstream.msg = "damaged LZ stream";
#line 1000
    goto switch_break;
    case_neg_4: /* CIL Label */ 
#line 1003
    png_ptr->zstream.msg = "insufficient memory";
#line 1004
    goto switch_break;
    case_neg_5: /* CIL Label */ 
#line 1010
    png_ptr->zstream.msg = "truncated";
#line 1011
    goto switch_break;
    case_neg_6: /* CIL Label */ 
#line 1014
    png_ptr->zstream.msg = "unsupported zlib version";
#line 1015
    goto switch_break;
    case_neg_7: /* CIL Label */ 
#line 1023
    png_ptr->zstream.msg = "unexpected zlib return";
#line 1024
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1026
  return;
}
}
#line 2470 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
static int png_gt(size_t a , size_t b ) 
{ 


  {
#line 2473
  return (a > b);
}
}
#line 2479 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.c"
void png_check_IHDR(png_const_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int interlace_type , int compression_type ,
                    int filter_type ) 
{ 
  int error___0 ;
  int tmp ;

  {
#line 2485
  error___0 = 0;
#line 2488
  if (width == 0U) {
    {
#line 2490
    png_warning(png_ptr, "Image width is zero in IHDR");
#line 2491
    error___0 = 1;
    }
  }
#line 2494
  if (width > 2147483647U) {
    {
#line 2496
    png_warning(png_ptr, "Invalid image width in IHDR");
#line 2497
    error___0 = 1;
    }
  }
  {
#line 2500
  tmp = png_gt((size_t )((width + 7U) & 4294967288U), 2305843009213693944UL);
  }
#line 2500
  if (tmp) {
    {
#line 2518
    png_warning(png_ptr, "Image width is too large for this architecture");
#line 2519
    error___0 = 1;
    }
  }
#line 2523
  if (width > (png_uint_32 )png_ptr->user_width_max) {
    {
#line 2528
    png_warning(png_ptr, "Image width exceeds user limit in IHDR");
#line 2529
    error___0 = 1;
    }
  }
#line 2532
  if (height == 0U) {
    {
#line 2534
    png_warning(png_ptr, "Image height is zero in IHDR");
#line 2535
    error___0 = 1;
    }
  }
#line 2538
  if (height > 2147483647U) {
    {
#line 2540
    png_warning(png_ptr, "Invalid image height in IHDR");
#line 2541
    error___0 = 1;
    }
  }
#line 2545
  if (height > (png_uint_32 )png_ptr->user_height_max) {
    {
#line 2550
    png_warning(png_ptr, "Image height exceeds user limit in IHDR");
#line 2551
    error___0 = 1;
    }
  }
#line 2555
  if (bit_depth != 1) {
#line 2555
    if (bit_depth != 2) {
#line 2555
      if (bit_depth != 4) {
#line 2555
        if (bit_depth != 8) {
#line 2555
          if (bit_depth != 16) {
            {
#line 2558
            png_warning(png_ptr, "Invalid bit depth in IHDR");
#line 2559
            error___0 = 1;
            }
          }
        }
      }
    }
  }
#line 2562
  if (color_type < 0) {
    {
#line 2565
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2566
    error___0 = 1;
    }
  } else
#line 2562
  if (color_type == 1) {
    {
#line 2565
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2566
    error___0 = 1;
    }
  } else
#line 2562
  if (color_type == 5) {
    {
#line 2565
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2566
    error___0 = 1;
    }
  } else
#line 2562
  if (color_type > 6) {
    {
#line 2565
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2566
    error___0 = 1;
    }
  }
#line 2569
  if (color_type == 3) {
#line 2569
    if (bit_depth > 8) {
      {
#line 2574
      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
#line 2575
      error___0 = 1;
      }
    } else {
#line 2569
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2569
  if (color_type == 2) {
#line 2569
    goto _L;
  } else
#line 2569
  if (color_type == 4) {
#line 2569
    goto _L;
  } else
#line 2569
  if (color_type == 6) {
    _L: /* CIL Label */ 
#line 2569
    if (bit_depth < 8) {
      {
#line 2574
      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
#line 2575
      error___0 = 1;
      }
    }
  }
#line 2578
  if (interlace_type >= 2) {
    {
#line 2580
    png_warning(png_ptr, "Unknown interlace method in IHDR");
#line 2581
    error___0 = 1;
    }
  }
#line 2584
  if (compression_type != 0) {
    {
#line 2586
    png_warning(png_ptr, "Unknown compression method in IHDR");
#line 2587
    error___0 = 1;
    }
  }
#line 2624
  if (filter_type != 0) {
    {
#line 2626
    png_warning(png_ptr, "Unknown filter method in IHDR");
#line 2627
    error___0 = 1;
    }
  }
#line 2631
  if (error___0 == 1) {
    {
#line 2632
    png_error(png_ptr, "Invalid IHDR data");
    }
  }
#line 2633
  return;
}
}
#line 896 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
png_voidp __attribute__((__malloc__))  png_malloc_array(png_const_structrp png_ptr ,
                                                        int nelements , size_t element_size ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
void png_destroy_png_struct(png_structrp png_ptr ) 
{ 
  png_struct dummy_struct ;

  {
#line 27
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 32
    dummy_struct = *png_ptr;
#line 33
    memset((void *)png_ptr, 0, sizeof(*png_ptr));
#line 34
    png_free((png_const_structrp )(& dummy_struct), (png_voidp )png_ptr);
    }
  }
#line 41
  return;
}
}
#line 49 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) 
{ 
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
  {
#line 54
  tmp = png_malloc(png_ptr, size);
#line 54
  ret = (png_voidp )tmp;
  }
#line 56
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
#line 57
    memset(ret, 0, size);
    }
  }
#line 59
  return ((png_voidp __attribute__((__malloc__))  )ret);
}
}
#line 67 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_base(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) 
{ 
  void *tmp ;

  {
#line 83
  if (size > 0UL) {
#line 83
    if (size <= 0xffffffffffffffffUL) {
      {
#line 95
      tmp = malloc(size);
      }
#line 95
      return ((png_voidp __attribute__((__malloc__))  )tmp);
    } else {
#line 99
      return ((png_voidp __attribute__((__malloc__))  )((void *)0));
    }
  } else {
#line 99
    return ((png_voidp __attribute__((__malloc__))  )((void *)0));
  }
}
}
#line 108 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
static png_voidp png_malloc_array_checked(png_const_structrp png_ptr , int nelements ,
                                          size_t element_size ) 
{ 
  png_alloc_size_t req ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 112
  req = (png_alloc_size_t )nelements;
#line 114
  if (req <= 0xffffffffffffffffUL / element_size) {
    {
#line 115
    tmp = png_malloc_base(png_ptr, req * element_size);
    }
#line 115
    return ((png_voidp )tmp);
  }
#line 118
  return ((void *)0);
}
}
#line 121 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_array(png_const_structrp png_ptr ,
                                                        int nelements , size_t element_size ) 
{ 
  png_voidp tmp ;

  {
#line 125
  if (nelements <= 0) {
    {
#line 126
    png_error(png_ptr, "internal error: array alloc");
    }
  } else
#line 125
  if (element_size == 0UL) {
    {
#line 126
    png_error(png_ptr, "internal error: array alloc");
    }
  }
  {
#line 128
  tmp = png_malloc_array_checked(png_ptr, nelements, element_size);
  }
#line 128
  return ((png_voidp __attribute__((__malloc__))  )tmp);
}
}
#line 131 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_realloc_array(png_const_structrp png_ptr ,
                                                         png_const_voidp old_array ,
                                                         int old_elements , int add_elements ,
                                                         size_t element_size ) 
{ 
  png_voidp new_array ;
  png_voidp tmp ;

  {
#line 136
  if (add_elements <= 0) {
    {
#line 138
    png_error(png_ptr, "internal error: array realloc");
    }
  } else
#line 136
  if (element_size == 0UL) {
    {
#line 138
    png_error(png_ptr, "internal error: array realloc");
    }
  } else
#line 136
  if (old_elements < 0) {
    {
#line 138
    png_error(png_ptr, "internal error: array realloc");
    }
  } else
#line 136
  if ((unsigned long )old_array == (unsigned long )((void *)0)) {
#line 136
    if (old_elements > 0) {
      {
#line 138
      png_error(png_ptr, "internal error: array realloc");
      }
    }
  }
#line 143
  if (add_elements <= 2147483647 - old_elements) {
    {
#line 145
    tmp = png_malloc_array_checked(png_ptr, old_elements + add_elements, element_size);
#line 145
    new_array = tmp;
    }
#line 148
    if ((unsigned long )new_array != (unsigned long )((void *)0)) {
#line 153
      if (old_elements > 0) {
        {
#line 154
        memcpy((void */* __restrict  */)new_array, (void const   */* __restrict  */)old_array,
               element_size * (size_t )((unsigned int )old_elements));
        }
      }
      {
#line 156
      memset((void *)((char *)new_array + element_size * (size_t )((unsigned int )old_elements)),
             0, element_size * (size_t )((unsigned int )add_elements));
      }
#line 159
      return ((png_voidp __attribute__((__malloc__))  )new_array);
    }
  }
#line 163
  return ((png_voidp __attribute__((__malloc__))  )((void *)0));
}
}
#line 171 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) 
{ 
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 176
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 177
    return ((png_voidp __attribute__((__malloc__))  )((void *)0));
  }
  {
#line 179
  tmp = png_malloc_base(png_ptr, size);
#line 179
  ret = (png_voidp )tmp;
  }
#line 181
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 182
    png_error(png_ptr, "Out of memory");
    }
  }
#line 184
  return ((png_voidp __attribute__((__malloc__))  )ret);
}
}
#line 211 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_warn(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) 
{ 
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 215
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 217
    tmp = png_malloc_base(png_ptr, size);
#line 217
    ret = (png_voidp )tmp;
    }
#line 219
    if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 220
      return ((png_voidp __attribute__((__malloc__))  )ret);
    }
    {
#line 222
    png_warning(png_ptr, "Out of memory");
    }
  }
#line 225
  return ((png_voidp __attribute__((__malloc__))  )((void *)0));
}
}
#line 231 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngmem.c"
void png_free(png_const_structrp png_ptr , png_voidp ptr ) 
{ 


  {
#line 234
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 235
    return;
  } else
#line 234
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 235
    return;
  }
  {
#line 252
  free(ptr);
  }
#line 253
  return;
}
}
#line 939 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
png_size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) ;
#line 1843
png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                          png_uint_32 flag ) ;
#line 1847
png_size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1854
png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1865
png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1870
png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1874
png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1878
png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1882
png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1886
png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1890
png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1894
png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1898
png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1902
png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1908
png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1912
png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1914
png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1916
png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1918
png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1925
png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1930
png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_color_16p *background ) ;
#line 2002
png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_16p *hist ) ;
#line 2011
png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                         int *color_type , int *interlace_type , int *compression_type ,
                         int *filter_type ) ;
#line 2057
png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr , png_colorp *palette ,
                         int *num_palette ) ;
#line 2064
png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_color_8p *sig_bit ) ;
#line 2136
png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *trans_alpha ,
                         int *num_trans , png_color_16p *trans_color ) ;
#line 2301
int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_unknown_chunkpp unknowns ) ;
#line 2357
png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) ;
#line 2359
png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) ;
#line 2364
png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) ;
#line 2369
png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) ;
#line 2406
png_uint_32 png_get_io_state(png_const_structrp png_ptr ) ;
#line 2412
png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) ;
#line 2605
int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                          png_uint_32 flag ) 
{ 


  {
#line 23
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 23
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 24
      return ((png_uint_32 )(info_ptr->valid & (unsigned int const   )flag));
    }
  }
#line 26
  return ((png_uint_32 )0);
}
}
#line 29 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 32
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 32
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 33
      return ((png_size_t )info_ptr->rowbytes);
    }
  }
#line 35
  return ((png_size_t )0);
}
}
#line 39 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 42
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 42
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 43
      return ((png_bytepp )info_ptr->row_pointers);
    }
  }
#line 45
  return ((png_bytepp )0);
}
}
#line 51 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 54
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 54
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 55
      return ((png_uint_32 )info_ptr->width);
    }
  }
#line 57
  return ((png_uint_32 )0);
}
}
#line 60 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 63
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 63
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 64
      return ((png_uint_32 )info_ptr->height);
    }
  }
#line 66
  return ((png_uint_32 )0);
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 72
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 72
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 73
      return ((png_byte )info_ptr->bit_depth);
    }
  }
#line 75
  return ((png_byte )0);
}
}
#line 78 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 81
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 81
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 82
      return ((png_byte )info_ptr->color_type);
    }
  }
#line 84
  return ((png_byte )0);
}
}
#line 87 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 90
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 90
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 91
      return ((png_byte )info_ptr->filter_type);
    }
  }
#line 93
  return ((png_byte )0);
}
}
#line 96 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 99
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 99
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 100
      return ((png_byte )info_ptr->interlace_type);
    }
  }
#line 102
  return ((png_byte )0);
}
}
#line 105 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 108
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 108
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 109
      return ((png_byte )info_ptr->compression_type);
    }
  }
#line 111
  return ((png_byte )0);
}
}
#line 114 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 133
  return ((png_uint_32 )0);
}
}
#line 136 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 155
  return ((png_uint_32 )0);
}
}
#line 158 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 176
  return ((png_uint_32 )0);
}
}
#line 204 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 231
  return (0);
}
}
#line 235 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 252
  return (0);
}
}
#line 255 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 272
  return (0);
}
}
#line 275 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 292
  return (0);
}
}
#line 295 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 312
  return (0);
}
}
#line 466 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 469
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 469
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 470
      return ((png_byte )info_ptr->channels);
    }
  }
#line 472
  return ((png_byte )0);
}
}
#line 476 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 479
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 479
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 480
      return ((png_const_bytep )(info_ptr->signature));
    }
  }
#line 482
  return ((png_const_bytep )((void *)0));
}
}
#line 487 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_color_16p *background ) 
{ 


  {
#line 491
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 491
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 491
      if ((info_ptr->valid & 32U) != 0U) {
#line 491
        if ((unsigned long )background != (unsigned long )((void *)0)) {
#line 497
          *background = & info_ptr->background;
#line 498
          return ((png_uint_32 )32);
        }
      }
    }
  }
#line 501
  return ((png_uint_32 )0);
}
}
#line 777 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_16p *hist ) 
{ 


  {
#line 783
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 783
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 783
      if ((info_ptr->valid & 64U) != 0U) {
#line 783
        if ((unsigned long )hist != (unsigned long )((void *)0)) {
#line 786
          *hist = info_ptr->hist;
#line 787
          return ((png_uint_32 )64);
        }
      }
    }
  }
#line 790
  return ((png_uint_32 )0);
}
}
#line 794 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                         int *color_type , int *interlace_type , int *compression_type ,
                         int *filter_type ) 
{ 


  {
#line 802
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 803
    return ((png_uint_32 )0);
  } else
#line 802
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 803
    return ((png_uint_32 )0);
  }
#line 805
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 806
    *width = (png_uint_32 )info_ptr->width;
  }
#line 808
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 809
    *height = (png_uint_32 )info_ptr->height;
  }
#line 811
  if ((unsigned long )bit_depth != (unsigned long )((void *)0)) {
#line 812
    *bit_depth = (int )info_ptr->bit_depth;
  }
#line 814
  if ((unsigned long )color_type != (unsigned long )((void *)0)) {
#line 815
    *color_type = (int )info_ptr->color_type;
  }
#line 817
  if ((unsigned long )compression_type != (unsigned long )((void *)0)) {
#line 818
    *compression_type = (int )info_ptr->compression_type;
  }
#line 820
  if ((unsigned long )filter_type != (unsigned long )((void *)0)) {
#line 821
    *filter_type = (int )info_ptr->filter_type;
  }
#line 823
  if ((unsigned long )interlace_type != (unsigned long )((void *)0)) {
#line 824
    *interlace_type = (int )info_ptr->interlace_type;
  }
  {
#line 831
  png_check_IHDR(png_ptr, (png_uint_32 )info_ptr->width, (png_uint_32 )info_ptr->height,
                 (int )info_ptr->bit_depth, (int )info_ptr->color_type, (int )info_ptr->interlace_type,
                 (int )info_ptr->compression_type, (int )info_ptr->filter_type);
  }
#line 835
  return ((png_uint_32 )1);
}
}
#line 981 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr , png_colorp *palette ,
                         int *num_palette ) 
{ 


  {
#line 987
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 987
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 987
      if ((info_ptr->valid & 8U) != 0U) {
#line 987
        if ((unsigned long )palette != (unsigned long )((void *)0)) {
#line 990
          *palette = info_ptr->palette;
#line 991
          *num_palette = (int )info_ptr->num_palette;
#line 993
          return ((png_uint_32 )8);
        }
      }
    }
  }
#line 996
  return ((png_uint_32 )0);
}
}
#line 1000 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_color_8p *sig_bit ) 
{ 


  {
#line 1006
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1006
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1006
      if ((info_ptr->valid & 2U) != 0U) {
#line 1006
        if ((unsigned long )sig_bit != (unsigned long )((void *)0)) {
#line 1009
          *sig_bit = & info_ptr->sig_bit;
#line 1010
          return ((png_uint_32 )2);
        }
      }
    }
  }
#line 1013
  return ((png_uint_32 )0);
}
}
#line 1062 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *trans_alpha ,
                         int *num_trans , png_color_16p *trans_color ) 
{ 
  png_uint_32 retval ;

  {
#line 1066
  retval = (png_uint_32 )0;
#line 1067
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1067
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1067
      if ((info_ptr->valid & 16U) != 0U) {
#line 1072
        if ((int )info_ptr->color_type == 3) {
#line 1074
          if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1076
            *trans_alpha = info_ptr->trans_alpha;
#line 1077
            retval |= 16U;
          }
#line 1080
          if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1081
            *trans_color = & info_ptr->trans_color;
          }
        } else {
#line 1086
          if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1088
            *trans_color = & info_ptr->trans_color;
#line 1089
            retval |= 16U;
          }
#line 1092
          if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1093
            *trans_alpha = (png_bytep )((void *)0);
          }
        }
#line 1096
        if ((unsigned long )num_trans != (unsigned long )((void *)0)) {
#line 1098
          *num_trans = (int )info_ptr->num_trans;
#line 1099
          retval |= 16U;
        }
      }
    }
  }
#line 1103
  return (retval);
}
}
#line 1108 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_unknown_chunkpp unknowns ) 
{ 


  {
#line 1112
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1112
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1112
      if ((unsigned long )unknowns != (unsigned long )((void *)0)) {
#line 1114
        *unknowns = info_ptr->unknown_chunks;
#line 1115
        return (info_ptr->unknown_chunks_num);
      }
    }
  }
#line 1118
  return (0);
}
}
#line 1138 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) 
{ 


  {
#line 1141
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1142
    return ((png_size_t )0);
  }
#line 1145
  if ((png_ptr->mode & 32768U) != 0U) {
#line 1149
    return ((png_size_t )png_ptr->IDAT_read_size);
  } else {
#line 1157
    return ((png_size_t )png_ptr->zbuffer_size);
  }
}
}
#line 1164 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) 
{ 
  png_uint_32 tmp ;

  {
#line 1167
  if (png_ptr) {
#line 1167
    tmp = png_ptr->user_width_max;
  } else {
#line 1167
    tmp = (png_uint_32 const   )0;
  }
#line 1167
  return ((png_uint_32 )tmp);
}
}
#line 1170 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) 
{ 
  png_uint_32 tmp ;

  {
#line 1173
  if (png_ptr) {
#line 1173
    tmp = png_ptr->user_height_max;
  } else {
#line 1173
    tmp = (png_uint_32 const   )0;
  }
#line 1173
  return ((png_uint_32 )tmp);
}
}
#line 1177 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) 
{ 
  png_uint_32 tmp ;

  {
#line 1180
  if (png_ptr) {
#line 1180
    tmp = png_ptr->user_chunk_cache_max;
  } else {
#line 1180
    tmp = (png_uint_32 const   )0;
  }
#line 1180
  return ((png_uint_32 )tmp);
}
}
#line 1184 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) 
{ 
  png_alloc_size_t tmp ;

  {
#line 1187
  if (png_ptr) {
#line 1187
    tmp = png_ptr->user_chunk_malloc_max;
  } else {
#line 1187
    tmp = (png_alloc_size_t const   )0;
  }
#line 1187
  return ((png_alloc_size_t )tmp);
}
}
#line 1193 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_io_state(png_const_structrp png_ptr ) 
{ 


  {
#line 1196
  return ((png_uint_32 )png_ptr->io_state);
}
}
#line 1199 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) 
{ 


  {
#line 1202
  return ((png_uint_32 )png_ptr->chunk_name);
}
}
#line 1208 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngget.c"
int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) 
{ 


  {
#line 1211
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1211
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1212
      return ((int )png_ptr->num_palette_max);
    }
  }
#line 1214
  return (-1);
}
}
#line 969 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/png.h"
 __attribute__((__noreturn__)) void png_longjmp(png_const_structrp png_ptr , int val ) ;
#line 1581
png_voidp png_get_error_ptr(png_const_structrp png_ptr ) ;
#line 1559 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngpriv.h"
png_charp png_format_number(png_const_charp start , png_charp end , int format , png_alloc_size_t number ) ;
#line 1592
void png_warning_parameter(char (*p)[32] , int number , png_const_charp string ) ;
#line 1597
void png_warning_parameter_unsigned(char (*p)[32] , int number , int format , png_alloc_size_t value ) ;
#line 1603
void png_warning_parameter_signed(char (*p)[32] , int number , int format , png_int_32 value ) ;
#line 1607
void png_formatted_warning(png_const_structrp png_ptr , char (*p)[32] , png_const_charp message ) ;
#line 23 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
static  __attribute__((__noreturn__)) void png_default_error(png_const_structrp png_ptr ,
                                                             png_const_charp error_message ) ;
#line 27
static void png_default_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 38
 __attribute__((__noreturn__)) void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 38 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 82
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 82
    if ((unsigned long )png_ptr->error_fn != (unsigned long )((void *)0)) {
      {
#line 83
      (*(png_ptr->error_fn))((png_structp )((png_structrp )png_ptr), error_message);
      }
    }
  }
  {
#line 88
  png_default_error(png_ptr, error_message);
  }
}
}
#line 111 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
size_t png_safecat(png_charp buffer___0 , size_t bufsize , size_t pos , png_const_charp string ) 
{ 
  size_t tmp ;
  png_const_charp tmp___0 ;

  {
#line 115
  if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 115
    if (pos < bufsize) {
#line 117
      if ((unsigned long )string != (unsigned long )((void *)0)) {
        {
#line 118
        while (1) {
          while_continue: /* CIL Label */ ;
#line 118
          if ((int const   )*string != 0) {
#line 118
            if (! (pos < bufsize - 1UL)) {
#line 118
              goto while_break;
            }
          } else {
#line 118
            goto while_break;
          }
#line 119
          tmp = pos;
#line 119
          pos ++;
#line 119
          tmp___0 = string;
#line 119
          string ++;
#line 119
          *(buffer___0 + tmp) = (char )*tmp___0;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 121
      *(buffer___0 + pos) = (char )'\000';
    }
  }
#line 124
  return (pos);
}
}
#line 148 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
static char const   digits[17]  = 
#line 148
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
#line 132 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
png_charp png_format_number(png_const_charp start , png_charp end , int format , png_alloc_size_t number ) 
{ 
  int count ;
  int mincount ;
  int output ;

  {
#line 136
  count = 0;
#line 137
  mincount = 1;
#line 138
  output = 0;
#line 140
  end --;
#line 140
  *end = (char )'\000';
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if ((unsigned long )end > (unsigned long )start) {
#line 145
      if (! (number != 0UL)) {
#line 145
        if (! (count < mincount)) {
#line 145
          goto while_break;
        }
      }
    } else {
#line 145
      goto while_break;
    }
    {
#line 152
    if (format == 5) {
#line 152
      goto case_5;
    }
#line 163
    if (format == 2) {
#line 163
      goto case_2;
    }
#line 168
    if (format == 1) {
#line 168
      goto case_1;
    }
#line 173
    if (format == 4) {
#line 173
      goto case_4;
    }
#line 178
    if (format == 3) {
#line 178
      goto case_3;
    }
#line 183
    goto switch_default;
    case_5: /* CIL Label */ 
#line 154
    mincount = 5;
#line 155
    if (output != 0) {
#line 157
      end --;
#line 157
      *end = (char )digits[number % 10UL];
#line 158
      output = 1;
    } else
#line 155
    if (number % 10UL != 0UL) {
#line 157
      end --;
#line 157
      *end = (char )digits[number % 10UL];
#line 158
      output = 1;
    }
#line 160
    number /= 10UL;
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
#line 165
    mincount = 2;
    case_1: /* CIL Label */ 
#line 169
    end --;
#line 169
    *end = (char )digits[number % 10UL];
#line 170
    number /= 10UL;
#line 171
    goto switch_break;
    case_4: /* CIL Label */ 
#line 175
    mincount = 2;
    case_3: /* CIL Label */ 
#line 179
    end --;
#line 179
    *end = (char )digits[number & 15UL];
#line 180
    number >>= 4;
#line 181
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    number = (png_alloc_size_t )0;
#line 185
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 189
    count ++;
#line 192
    if (format == 5) {
#line 192
      if (count == 5) {
#line 192
        if ((unsigned long )end > (unsigned long )start) {
#line 198
          if (output != 0) {
#line 199
            end --;
#line 199
            *end = (char )'.';
          } else
#line 200
          if (number == 0UL) {
#line 201
            end --;
#line 201
            *end = (char )'0';
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (end);
}
}
#line 215 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) 
{ 
  int offset ;

  {
#line 218
  offset = 0;
#line 219
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 226
    if ((int const   )*warning_message == 35) {
#line 228
      offset = 1;
      {
#line 228
      while (1) {
        while_continue: /* CIL Label */ ;
#line 228
        if (! (offset < 15)) {
#line 228
          goto while_break;
        }
#line 229
        if ((int const   )*(warning_message + offset) == 32) {
#line 230
          goto while_break;
        }
#line 228
        offset ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 234
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 234
    if ((unsigned long )png_ptr->warning_fn != (unsigned long )((void *)0)) {
      {
#line 235
      (*(png_ptr->warning_fn))((png_structp )((png_structrp )png_ptr), warning_message + offset);
      }
    } else {
      {
#line 238
      png_default_warning(png_ptr, warning_message + offset);
      }
    }
  } else {
    {
#line 238
    png_default_warning(png_ptr, warning_message + offset);
    }
  }
#line 239
  return;
}
}
#line 246 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_warning_parameter(char (*p)[32] , int number , png_const_charp string ) 
{ 


  {
#line 250
  if (number > 0) {
#line 250
    if (number <= 8) {
      {
#line 251
      png_safecat(*(p + (number - 1)), sizeof(*(p + (number - 1))), (size_t )0, string);
      }
    }
  }
#line 252
  return;
}
}
#line 254 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_warning_parameter_unsigned(char (*p)[32] , int number , int format , png_alloc_size_t value ) 
{ 
  char buffer___0[24] ;
  png_charp tmp ;

  {
  {
#line 259
  tmp = png_format_number((png_const_charp )(buffer___0), buffer___0 + sizeof(buffer___0),
                          format, value);
#line 259
  png_warning_parameter(p, number, (png_const_charp )tmp);
  }
#line 260
  return;
}
}
#line 262 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_warning_parameter_signed(char (*p)[32] , int number , int format , png_int_32 value ) 
{ 
  png_alloc_size_t u ;
  png_charp str ;
  char buffer___0[24] ;

  {
#line 271
  u = (png_alloc_size_t )value;
#line 272
  if (value < 0) {
#line 273
    u = ~ u + 1UL;
  }
  {
#line 275
  str = png_format_number((png_const_charp )(buffer___0), buffer___0 + sizeof(buffer___0),
                          format, u);
  }
#line 277
  if (value < 0) {
#line 277
    if ((unsigned long )str > (unsigned long )(buffer___0)) {
#line 278
      str --;
#line 278
      *str = (char )'-';
    }
  }
  {
#line 280
  png_warning_parameter(p, number, (png_const_charp )str);
  }
#line 281
  return;
}
}
#line 309 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
static char const   valid_parameters[10]  = 
#line 309
  {      (char const   )'1',      (char const   )'2',      (char const   )'3',      (char const   )'4', 
        (char const   )'5',      (char const   )'6',      (char const   )'7',      (char const   )'8', 
        (char const   )'9',      (char const   )'\000'};
#line 283 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_formatted_warning(png_const_structrp png_ptr , char (*p)[32] , png_const_charp message ) 
{ 
  size_t i ;
  char msg___0[192] ;
  int parameter_char ;
  int parameter ;
  png_const_charp parm ;
  png_const_charp pend ;
  size_t tmp ;
  png_const_charp tmp___0 ;
  size_t tmp___1 ;
  png_const_charp tmp___2 ;

  {
#line 292
  i = (size_t )0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (i < sizeof(msg___0) - 1UL) {
#line 301
      if (! ((int const   )*message != 0)) {
#line 301
        goto while_break;
      }
    } else {
#line 301
      goto while_break;
    }
#line 306
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 306
      if ((int const   )*message == 64) {
#line 306
        if ((int const   )*(message + 1) != 0) {
#line 308
          message ++;
#line 308
          parameter_char = (int )*message;
#line 310
          parameter = 0;
          {
#line 315
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 315
            if ((int const   )valid_parameters[parameter] != (int const   )parameter_char) {
#line 315
              if (! ((int const   )valid_parameters[parameter] != 0)) {
#line 315
                goto while_break___0;
              }
            } else {
#line 315
              goto while_break___0;
            }
#line 317
            parameter ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 320
          if (parameter < 8) {
#line 323
            parm = (png_const_charp )(*(p + parameter));
#line 324
            pend = (png_const_charp )(*(p + parameter) + sizeof(*(p + parameter)));
            {
#line 330
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 330
              if (i < sizeof(msg___0) - 1UL) {
#line 330
                if ((int const   )*parm != 0) {
#line 330
                  if (! ((unsigned long )parm < (unsigned long )pend)) {
#line 330
                    goto while_break___1;
                  }
                } else {
#line 330
                  goto while_break___1;
                }
              } else {
#line 330
                goto while_break___1;
              }
#line 331
              tmp = i;
#line 331
              i ++;
#line 331
              tmp___0 = parm;
#line 331
              parm ++;
#line 331
              msg___0[tmp] = (char )*tmp___0;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 334
            message ++;
#line 335
            goto while_continue;
          }
        }
      }
    }
#line 346
    tmp___1 = i;
#line 346
    i ++;
#line 346
    tmp___2 = message;
#line 346
    message ++;
#line 346
    msg___0[tmp___1] = (char )*tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  msg___0[i] = (char )'\000';
#line 356
  png_warning(png_ptr, (png_const_charp )(msg___0));
  }
#line 357
  return;
}
}
#line 361 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 364
  if ((png_ptr->flags & 1048576U) != 0U) {
#line 367
    if ((png_ptr->mode & 32768U) != 0U) {
#line 367
      if (png_ptr->chunk_name != 0U) {
        {
#line 369
        png_chunk_warning(png_ptr, error_message);
        }
      } else {
        {
#line 372
        png_warning(png_ptr, error_message);
        }
      }
    } else {
      {
#line 372
      png_warning(png_ptr, error_message);
      }
    }
  } else
#line 378
  if ((png_ptr->mode & 32768U) != 0U) {
#line 378
    if (png_ptr->chunk_name != 0U) {
      {
#line 380
      png_chunk_error(png_ptr, error_message);
      }
    } else {
      {
#line 383
      png_error(png_ptr, error_message);
      }
    }
  } else {
    {
#line 383
    png_error(png_ptr, error_message);
    }
  }
#line 389
  return;
}
}
#line 391 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_app_warning(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 394
  if ((png_ptr->flags & 2097152U) != 0U) {
    {
#line 395
    png_warning(png_ptr, error_message);
    }
  } else {
    {
#line 397
    png_error(png_ptr, error_message);
    }
  }
#line 402
  return;
}
}
#line 404 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_app_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 407
  if ((png_ptr->flags & 4194304U) != 0U) {
    {
#line 408
    png_warning(png_ptr, error_message);
    }
  } else {
    {
#line 410
    png_error(png_ptr, error_message);
    }
  }
#line 415
  return;
}
}
#line 428 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
static char const   png_digit[16]  = 
#line 428
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F'};
#line 433 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
static void png_format_buffer(png_const_structrp png_ptr , png_charp buffer___0 ,
                              png_const_charp error_message ) 
{ 
  png_uint_32 chunk_name ;
  int iout ;
  int ishift ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int iin ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 437
  chunk_name = (png_uint_32 )png_ptr->chunk_name;
#line 438
  iout = 0;
#line 438
  ishift = 24;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (ishift >= 0)) {
#line 440
      goto while_break;
    }
#line 442
    c = (int )(chunk_name >> ishift) & 255;
#line 444
    ishift -= 8;
#line 445
    if (c < 65) {
#line 445
      tmp___4 = 1;
    } else
#line 445
    if (c > 122) {
#line 445
      tmp___4 = 1;
    } else
#line 445
    if (c > 90) {
#line 445
      if (c < 97) {
#line 445
        tmp___4 = 1;
      } else {
#line 445
        tmp___4 = 0;
      }
    } else {
#line 445
      tmp___4 = 0;
    }
#line 445
    if (tmp___4 != 0) {
#line 447
      tmp = iout;
#line 447
      iout ++;
#line 447
      *(buffer___0 + tmp) = (char)91;
#line 448
      tmp___0 = iout;
#line 448
      iout ++;
#line 448
      *(buffer___0 + tmp___0) = (char )png_digit[(c & 240) >> 4];
#line 449
      tmp___1 = iout;
#line 449
      iout ++;
#line 449
      *(buffer___0 + tmp___1) = (char )png_digit[c & 15];
#line 450
      tmp___2 = iout;
#line 450
      iout ++;
#line 450
      *(buffer___0 + tmp___2) = (char)93;
    } else {
#line 455
      tmp___3 = iout;
#line 455
      iout ++;
#line 455
      *(buffer___0 + tmp___3) = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  if ((unsigned long )error_message == (unsigned long )((void *)0)) {
#line 460
    *(buffer___0 + iout) = (char )'\000';
  } else {
#line 464
    iin = 0;
#line 466
    tmp___5 = iout;
#line 466
    iout ++;
#line 466
    *(buffer___0 + tmp___5) = (char )':';
#line 467
    tmp___6 = iout;
#line 467
    iout ++;
#line 467
    *(buffer___0 + tmp___6) = (char )' ';
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 469
      if (iin < 195) {
#line 469
        if (! ((int const   )*(error_message + iin) != 0)) {
#line 469
          goto while_break___0;
        }
      } else {
#line 469
        goto while_break___0;
      }
#line 470
      tmp___7 = iout;
#line 470
      iout ++;
#line 470
      tmp___8 = iin;
#line 470
      iin ++;
#line 470
      *(buffer___0 + tmp___7) = (char )*(error_message + tmp___8);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 473
    *(buffer___0 + iout) = (char )'\000';
  }
#line 475
  return;
}
}
#line 479
 __attribute__((__noreturn__)) void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 479 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 
  char msg___0[214] ;

  {
#line 484
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
    {
#line 485
    png_error(png_ptr, error_message);
    }
  } else {
    {
#line 489
    png_format_buffer(png_ptr, msg___0, error_message);
#line 490
    png_error(png_ptr, (png_const_charp )(msg___0));
    }
  }
}
}
#line 496 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) 
{ 
  char msg___0[214] ;

  {
#line 500
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
    {
#line 501
    png_warning(png_ptr, warning_message);
    }
  } else {
    {
#line 505
    png_format_buffer(png_ptr, msg___0, warning_message);
#line 506
    png_warning(png_ptr, (png_const_charp )(msg___0));
    }
  }
#line 508
  return;
}
}
#line 513 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 517
  if ((png_ptr->flags & 1048576U) != 0U) {
    {
#line 518
    png_chunk_warning(png_ptr, error_message);
    }
  } else {
    {
#line 521
    png_chunk_error(png_ptr, error_message);
    }
  }
#line 526
  return;
}
}
#line 530 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_chunk_report(png_const_structrp png_ptr , png_const_charp message , int error___0 ) 
{ 


  {
#line 541
  if ((png_ptr->mode & 32768U) != 0U) {
#line 546
    if (error___0 < 2) {
      {
#line 547
      png_chunk_warning(png_ptr, message);
      }
    } else {
      {
#line 550
      png_chunk_benign_error(png_ptr, message);
      }
    }
  } else
#line 555
  if ((png_ptr->mode & 32768U) == 0U) {
#line 560
    if (error___0 < 1) {
      {
#line 561
      png_app_warning(png_ptr, message);
      }
    } else {
      {
#line 564
      png_app_error(png_ptr, message);
      }
    }
  }
#line 567
  return;
}
}
#line 710
static  __attribute__((__noreturn__)) void png_default_error(png_const_structrp png_ptr ,
                                                             png_const_charp error_message ) ;
#line 710 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
static void png_default_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 
  png_const_charp tmp ;

  {
#line 747
  if (error_message) {
#line 747
    tmp = error_message;
  } else {
#line 747
    tmp = "undefined";
  }
  {
#line 747
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libpng error: %s",
          tmp);
#line 749
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 754
  png_longjmp(png_ptr, 1);
  }
}
}
#line 757
 __attribute__((__noreturn__)) void png_longjmp(png_const_structrp png_ptr , int val ) ;
#line 757 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_longjmp(png_const_structrp png_ptr , int val ) 
{ 


  {
  {
#line 775
  abort();
  }
}
}
#line 784 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
static void png_default_warning(png_const_structrp png_ptr , png_const_charp warning_message ) 
{ 


  {
  {
#line 819
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libpng warning: %s",
          warning_message);
#line 820
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 826
  return;
}
}
#line 834 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) ) 
{ 


  {
#line 838
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 839
    return;
  }
#line 841
  png_ptr->error_ptr = error_ptr;
#line 842
  png_ptr->error_fn = error_fn;
#line 844
  png_ptr->warning_fn = warning_fn;
#line 848
  return;
}
}
#line 855 "/home/khheo/project/benchmark/optipng-0.7.6/src/libpng/pngerror.c"
png_voidp png_get_error_ptr(png_const_structrp png_ptr ) 
{ 


  {
#line 858
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 859
    return ((void *)0);
  }
#line 861
  return ((png_voidp )png_ptr->error_ptr);
}
}
#line 21 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxutil.h"
void pngx_set_compression_type(png_structp png_ptr , png_infop info_ptr , int compression_type ) ;
#line 23
void pngx_set_filter_type(png_structp png_ptr , png_infop info_ptr , int filter_type ) ;
#line 25
void pngx_set_interlace_type(png_structp png_ptr , png_infop info_ptr , int interlace_type ) ;
#line 22 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxset.c"
void pngx_set_compression_type(png_structp png_ptr , png_infop info_ptr , int compression_type ) 
{ 
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int interlace_type ;
  int filter_type ;
  int old_compression_type ;
  png_uint_32 tmp ;

  {
  {
#line 30
  tmp = png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
                     & height, & bit_depth, & color_type, & interlace_type, & old_compression_type,
                     & filter_type);
  }
#line 30
  if (! tmp) {
#line 32
    return;
  }
#line 33
  if (compression_type == old_compression_type) {
#line 34
    return;
  }
  {
#line 35
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 37
  return;
}
}
#line 39 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxset.c"
void pngx_set_filter_type(png_structp png_ptr , png_infop info_ptr , int filter_type ) 
{ 
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int old_filter_type ;
  png_uint_32 tmp ;

  {
  {
#line 47
  tmp = png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
                     & height, & bit_depth, & color_type, & interlace_type, & compression_type,
                     & old_filter_type);
  }
#line 47
  if (! tmp) {
#line 49
    return;
  }
#line 50
  if (filter_type == old_filter_type) {
#line 51
    return;
  }
  {
#line 52
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 54
  return;
}
}
#line 56 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxset.c"
void pngx_set_interlace_type(png_structp png_ptr , png_infop info_ptr , int interlace_type ) 
{ 
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int compression_type ;
  int filter_type ;
  int old_interlace_type ;
  png_uint_32 tmp ;

  {
  {
#line 64
  tmp = png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
                     & height, & bit_depth, & color_type, & old_interlace_type, & compression_type,
                     & filter_type);
  }
#line 64
  if (! tmp) {
#line 66
    return;
  }
#line 67
  if (interlace_type == old_interlace_type) {
#line 68
    return;
  }
  {
#line 69
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 71
  return;
}
}
#line 43 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxutil.h"
png_bytepp pngx_malloc_rows(png_structp png_ptr , png_infop info_ptr , int filler ) ;
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 56 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxpriv.h"
int pngx_sig_is_tiff(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) ;
#line 59
int pngx_read_tiff(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
static char const   tiff_fmt_name[5]  = {      (char const   )'T',      (char const   )'I',      (char const   )'F',      (char const   )'F', 
        (char const   )'\000'};
#line 20 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
static char const   tiff_fmt_long_name[25]  = 
#line 20
  {      (char const   )'T',      (char const   )'a',      (char const   )'g',      (char const   )'g', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'I', 
        (char const   )'m',      (char const   )'a',      (char const   )'g',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'\000'};
#line 23 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
int pngx_sig_is_tiff(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 29
  if (sig_size < 8UL) {
#line 30
    return (-1);
  }
  {
#line 31
  tmp = memcmp((void const   *)sig, (void const   *)(minitiff_sig_m), (size_t )4);
  }
#line 31
  if (tmp != 0) {
    {
#line 31
    tmp___0 = memcmp((void const   *)sig, (void const   *)(minitiff_sig_i), (size_t )4);
    }
#line 31
    if (tmp___0 != 0) {
#line 33
      return (0);
    }
  }
#line 36
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 37
    *fmt_name_ptr = tiff_fmt_name;
  }
#line 38
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 39
    *fmt_long_name_ptr = tiff_fmt_long_name;
  }
#line 40
  return (1);
}
}
#line 45 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
static png_structp err_png_ptr  =    (png_structp )((void *)0);
#line 46 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
static unsigned int num_extra_images  ;
#line 48 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
static void pngx_tiff_error(char const   *msg___0 ) 
{ 


  {
  {
#line 50
  png_error((png_const_structrp )err_png_ptr, msg___0);
  }
}
}
#line 53 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
static void pngx_tiff_warning(char const   *msg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 59
  tmp = strstr(msg___0, "multi-image");
  }
#line 59
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 60
    num_extra_images ++;
  }
#line 66
  return;
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrtif.c"
int pngx_read_tiff(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  struct minitiff_info tiff_info ;
  unsigned int width ;
  unsigned int height ;
  unsigned int pixel_size ;
  unsigned int sample_depth ;
  unsigned int sample_max ;
  int color_type ;
  int sample_overflow ;
  png_bytepp row_pointers ;
  png_bytep row ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  int tmp ;
  unsigned int b ;
  png_byte b___0 ;
  unsigned int b___1 ;

  {
  {
#line 80
  err_png_ptr = png_ptr;
#line 81
  num_extra_images = 0U;
#line 82
  minitiff_init_info(& tiff_info);
#line 83
  tiff_info.error_handler = & pngx_tiff_error;
#line 84
  tiff_info.warning_handler = & pngx_tiff_warning;
#line 85
  minitiff_read_info(& tiff_info, stream);
#line 86
  minitiff_validate_info(& tiff_info);
#line 88
  width = (unsigned int )tiff_info.width;
#line 89
  height = (unsigned int )tiff_info.height;
#line 90
  pixel_size = tiff_info.samples_per_pixel;
#line 91
  sample_depth = tiff_info.bits_per_sample;
  }
  {
#line 94
  if (pixel_size == 1U) {
#line 94
    goto case_1;
  }
#line 97
  if (pixel_size == 2U) {
#line 97
    goto case_2;
  }
#line 100
  if (pixel_size == 3U) {
#line 100
    goto case_3;
  }
#line 103
  if (pixel_size == 4U) {
#line 103
    goto case_4;
  }
#line 106
  goto switch_default;
  case_1: /* CIL Label */ 
#line 95
  color_type = 0;
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  color_type = 4;
#line 99
  goto switch_break;
  case_3: /* CIL Label */ 
#line 101
  color_type = 2;
#line 102
  goto switch_break;
  case_4: /* CIL Label */ 
#line 104
  color_type = 6;
#line 105
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 107
  png_error((png_const_structrp )png_ptr, "Unsupported TIFF color space");
  }
#line 109
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 111
  if (sample_depth > 16U) {
    {
#line 112
    png_error((png_const_structrp )png_ptr, "Unsupported TIFF sample depth");
    }
  }
#line 113
  sample_max = (unsigned int )((1 << sample_depth) - 1);
#line 114
  sample_overflow = 0;
#line 116
  if (sample_depth <= 8U) {
#line 116
    tmp = 8;
  } else {
#line 116
    tmp = 16;
  }
  {
#line 116
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               tmp, color_type, 0, 0, 0);
#line 120
  row_pointers = pngx_malloc_rows(png_ptr, info_ptr, 0);
  }
#line 122
  if (sample_depth <= 8U) {
#line 124
    i = 0U;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! (i < height)) {
#line 124
        goto while_break;
      }
      {
#line 126
      row = *(row_pointers + i);
#line 127
      minitiff_read_row(& tiff_info, row, (size_t )i, stream);
      }
#line 128
      if (sample_depth < 8U) {
#line 130
        j = 0U;
        {
#line 130
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 130
          if (! (j < pixel_size * width)) {
#line 130
            goto while_break___0;
          }
#line 132
          b = (unsigned int )*(row + j);
#line 133
          if (b > sample_max) {
#line 135
            b = sample_max;
#line 136
            sample_overflow = 1;
          }
#line 138
          *(row + j) = (png_byte )((b * 255U + sample_max / 2U) / sample_max);
#line 130
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 141
      if (tiff_info.photometric == 0U) {
#line 143
        j = 0U;
        {
#line 143
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 143
          if (! (j < pixel_size * width)) {
#line 143
            goto while_break___1;
          }
#line 144
          *(row + j) = (png_byte )(255 - (int )*(row + j));
#line 143
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 124
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 150
    i = 0U;
    {
#line 150
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 150
      if (! (i < height)) {
#line 150
        goto while_break___2;
      }
      {
#line 152
      row = *(row_pointers + i);
#line 153
      minitiff_read_row(& tiff_info, row, (size_t )i, stream);
      }
#line 154
      if (tiff_info.byte_order == 73) {
#line 157
        k = 0U;
#line 157
        j = k;
        {
#line 157
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 157
          if (! (j < pixel_size * width)) {
#line 157
            goto while_break___3;
          }
#line 159
          b___0 = *(row + k);
#line 160
          *(row + k) = *(row + (k + 1U));
#line 161
          *(row + (k + 1U)) = b___0;
#line 157
          j ++;
#line 157
          k += 2U;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 164
      if (sample_depth < 16U) {
#line 166
        k = 0U;
#line 166
        j = k;
        {
#line 166
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 166
          if (! (k < pixel_size * width)) {
#line 166
            goto while_break___4;
          }
#line 168
          b___1 = (unsigned int )(((int )*(row + k) << 8) + (int )*(row + (k + 1U)));
#line 169
          if (b___1 > sample_max) {
#line 171
            b___1 = sample_max;
#line 172
            sample_overflow = 1;
          }
#line 174
          b___1 = (b___1 * 65535U + sample_max / 2U) / sample_max;
#line 175
          *(row + k) = (png_byte )(b___1 >> 8);
#line 176
          *(row + (k + 1U)) = (png_byte )(b___1 & 255U);
#line 166
          j ++;
#line 166
          k += 2U;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 150
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 182
  if (sample_overflow) {
    {
#line 183
    png_warning((png_const_structrp )png_ptr, "Overflow in TIFF samples");
    }
  }
  {
#line 185
  minitiff_destroy_info(& tiff_info);
  }
#line 186
  return ((int )(1U + num_extra_images));
}
}
#line 50 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxpriv.h"
int pngx_sig_is_pnm(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 53
int pngx_read_pnm(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   pbm_fmt_name[4]  = {      (char const   )'P',      (char const   )'B',      (char const   )'M',      (char const   )'\000'};
#line 25 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   pgm_fmt_name[4]  = {      (char const   )'P',      (char const   )'G',      (char const   )'M',      (char const   )'\000'};
#line 26 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   ppm_fmt_name[4]  = {      (char const   )'P',      (char const   )'P',      (char const   )'M',      (char const   )'\000'};
#line 27 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   pam_fmt_name[4]  = {      (char const   )'P',      (char const   )'A',      (char const   )'M',      (char const   )'\000'};
#line 28 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   pbm_fmt_long_name[16]  = 
#line 28
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'B',      (char const   )'i',      (char const   )'t', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 29 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   pgm_fmt_long_name[17]  = 
#line 29
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'G',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )'m',      (char const   )'a',      (char const   )'p', 
        (char const   )'\000'};
#line 30 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   ppm_fmt_long_name[16]  = 
#line 30
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'P',      (char const   )'i',      (char const   )'x', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 31 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   pam_fmt_long_name[16]  = 
#line 31
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'A',      (char const   )'n',      (char const   )'y', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 39 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   *fmt_names[7]  = {      pbm_fmt_name,      pgm_fmt_name,      ppm_fmt_name,      pbm_fmt_name, 
        pgm_fmt_name,      ppm_fmt_name,      pam_fmt_name};
#line 45 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static char const   *fmt_long_names[7]  = {      pbm_fmt_long_name,      pgm_fmt_long_name,      ppm_fmt_long_name,      pbm_fmt_long_name, 
        pgm_fmt_long_name,      ppm_fmt_long_name,      pam_fmt_long_name};
#line 34 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
int pngx_sig_is_pnm(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 


  {
#line 53
  if (sig_size < 4UL) {
#line 54
    return (-1);
  }
#line 55
  if ((int )*(sig + 0) != 80) {
#line 56
    return (0);
  } else
#line 55
  if ((int )*(sig + 1) < 49) {
#line 56
    return (0);
  } else
#line 55
  if ((int )*(sig + 1) > 55) {
#line 56
    return (0);
  }
#line 57
  if ((int )*(sig + 2) != 32) {
#line 57
    if ((int )*(sig + 2) != 9) {
#line 57
      if ((int )*(sig + 2) != 10) {
#line 57
        if ((int )*(sig + 2) != 13) {
#line 57
          if ((int )*(sig + 2) != 35) {
#line 59
            return (0);
          }
        }
      }
    }
  }
#line 62
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 63
    *fmt_name_ptr = fmt_names[(int )*(sig + 1) - 49];
  }
#line 64
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 65
    *fmt_long_name_ptr = fmt_long_names[(int )*(sig + 1) - 49];
  }
#line 66
  return (1);
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
static int pnm_fpeek_eof(pnm_struct *pnm_ptr , FILE *stream ) 
{ 
  int ch ;

  {
#line 74
  if (pnm_ptr->format >= 1U) {
#line 74
    if (pnm_ptr->format <= 3U) {
      {
#line 76
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 78
        ch = _IO_getc(stream);
        }
#line 79
        if (ch == 35) {
          {
#line 81
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 82
            ch = _IO_getc(stream);
            }
#line 81
            if (ch != -1) {
#line 81
              if (ch != 10) {
#line 81
                if (! (ch != 13)) {
#line 81
                  goto while_break___0;
                }
              } else {
#line 81
                goto while_break___0;
              }
            } else {
#line 81
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 85
        if (ch == -1) {
#line 86
          return (1);
        }
#line 76
        if (! (ch == 32)) {
#line 76
          if (! (ch == 9)) {
#line 76
            if (! (ch == 10)) {
#line 76
              if (! (ch == 13)) {
#line 76
                goto while_break;
              }
            }
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 74
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 91
    ch = _IO_getc(stream);
    }
#line 92
    if (ch == -1) {
#line 93
      return (1);
    }
  }
  {
#line 96
  ungetc(ch, stream);
  }
#line 97
  return (0);
}
}
#line 100 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrpnm.c"
int pngx_read_pnm(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  pnm_struct pnminfo ;
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int height ;
  unsigned int maxval ;
  unsigned int max_width ;
  unsigned int num_samples ;
  unsigned int sample_size ;
  unsigned int *pnmrow ;
  size_t row_size ;
  png_bytepp row_pointers ;
  png_color_8 sig_bit ;
  unsigned int i ;
  unsigned int j ;
  int failed ;
  int overflow ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  int tmp___3 ;
  unsigned int val ;
  png_uint_32 val___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 114
  tmp = pnm_fget_header(& pnminfo, stream);
  }
#line 114
  if (tmp != 1) {
#line 115
    return (0);
  }
#line 116
  format = pnminfo.format;
#line 117
  depth = pnminfo.depth;
#line 118
  width = pnminfo.width;
#line 119
  height = pnminfo.height;
#line 120
  maxval = pnminfo.maxval;
#line 121
  if (format > 6U) {
    {
#line 122
    png_error((png_const_structrp )png_ptr, "Can\'t handle PNM formats newer than PPM (\"P6\")");
    }
  }
#line 123
  if (sizeof(size_t ) <= sizeof(unsigned int )) {
#line 123
    max_width = (unsigned int )((4294967295UL / sizeof(unsigned int )) / (unsigned long )depth);
  } else {
#line 123
    max_width = 4294967295U;
  }
#line 127
  if (max_width > 2147483647U) {
#line 128
    max_width = 2147483647U;
  }
#line 130
  if (width > max_width) {
    {
#line 131
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large PNM dimensions");
    }
  }
#line 132
  sample_size = 1U;
#line 133
  num_samples = depth * width;
#line 133
  row_size = (size_t )num_samples;
#line 134
  if (maxval > 65535U) {
    {
#line 135
    png_error((png_const_structrp )png_ptr, "Can\'t handle PNM samples larger than 16 bits");
    }
  } else
#line 136
  if (maxval > 255U) {
#line 138
    sample_size = 2U;
#line 139
    row_size *= 2UL;
  }
#line 143
  if (depth == 1U) {
#line 143
    tmp___0 = 0;
  } else {
#line 143
    tmp___0 = 2;
  }
#line 143
  if (maxval <= 255U) {
#line 143
    tmp___1 = 8;
  } else {
#line 143
    tmp___1 = 16;
  }
  {
#line 143
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               tmp___1, tmp___0, 0, 0, 0);
#line 148
  i = 1U;
#line 148
  j = 2U;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (j - 1U < maxval)) {
#line 148
      goto while_break;
    }
#line 148
    i ++;
#line 148
    j <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (j - 1U != maxval) {
    {
#line 150
    png_warning((png_const_structrp )png_ptr, "Possibly inexact sample conversion from PNM to PNG");
    }
  } else
#line 152
  if (i % 8U != 0U) {
#line 152
    if (depth > 1U) {
#line 152
      goto _L;
    } else
#line 152
    if (8U % i != 0U) {
      _L: /* CIL Label */ 
      {
#line 154
      sig_bit.gray = (png_byte )i;
#line 154
      sig_bit.blue = sig_bit.gray;
#line 154
      sig_bit.green = sig_bit.blue;
#line 154
      sig_bit.red = sig_bit.green;
#line 155
      sig_bit.alpha = (png_byte )0;
#line 156
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    }
  }
  {
#line 160
  row_pointers = pngx_malloc_rows(png_ptr, info_ptr, -1);
  }
#line 161
  if (format >= 4U) {
#line 161
    if (maxval == 255U) {
#line 162
      pnmrow = (unsigned int *)((void *)0);
    } else
#line 161
    if (maxval == 65535U) {
#line 162
      pnmrow = (unsigned int *)((void *)0);
    } else {
      {
#line 164
      tmp___2 = png_malloc((png_const_structrp )png_ptr, (unsigned long )num_samples * sizeof(unsigned int ));
#line 164
      pnmrow = (unsigned int *)tmp___2;
      }
    }
  } else {
    {
#line 164
    tmp___2 = png_malloc((png_const_structrp )png_ptr, (unsigned long )num_samples * sizeof(unsigned int ));
#line 164
    pnmrow = (unsigned int *)tmp___2;
    }
  }
#line 168
  failed = 0;
#line 169
  overflow = 0;
#line 170
  if ((unsigned long )pnmrow != (unsigned long )((void *)0)) {
#line 172
    i = 0U;
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 172
      if (! (i < height)) {
#line 172
        goto while_break___0;
      }
      {
#line 174
      tmp___3 = pnm_fget_values((pnm_struct const   *)(& pnminfo), pnmrow, 1U, stream);
      }
#line 174
      if (tmp___3 <= 0) {
#line 175
        failed = 1;
      }
#line 177
      if (maxval <= 255U) {
#line 179
        j = 0U;
        {
#line 179
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 179
          if (! (j < num_samples)) {
#line 179
            goto while_break___1;
          }
#line 181
          val = *(pnmrow + j);
#line 182
          if (val > maxval) {
#line 184
            val = 255U;
#line 185
            overflow = 1;
          } else
#line 187
          if (maxval != 255U) {
#line 188
            val = (val * 255U + maxval / 2U) / maxval;
          }
#line 189
          *(*(row_pointers + i) + j) = (png_byte )val;
#line 179
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 194
        j = 0U;
        {
#line 194
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 194
          if (! (j < num_samples)) {
#line 194
            goto while_break___2;
          }
#line 196
          val___0 = *(pnmrow + j);
#line 197
          if (val___0 > maxval) {
#line 199
            val___0 = (png_uint_32 )65535;
#line 200
            overflow = 1;
          } else
#line 202
          if (maxval != 65535U) {
#line 203
            val___0 = (val___0 * 65535U + maxval / 2U) / maxval;
          }
#line 204
          *(*(row_pointers + i) + 2U * j) = (png_byte )(val___0 >> 8);
#line 205
          *(*(row_pointers + i) + (2U * j + 1U)) = (png_byte )(val___0 & 255U);
#line 194
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 208
      if (failed) {
#line 209
        goto while_break___0;
      }
#line 172
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 214
    i = 0U;
    {
#line 214
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 214
      if (! (i < height)) {
#line 214
        goto while_break___3;
      }
      {
#line 216
      tmp___4 = pnm_fget_bytes((pnm_struct const   *)(& pnminfo), *(row_pointers + i),
                               (size_t )sample_size, 1U, stream);
      }
#line 216
      if (tmp___4 <= 0) {
#line 219
        failed = 1;
#line 220
        goto while_break___3;
      }
#line 214
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 226
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 226
    if (! (i < height)) {
#line 226
      goto while_break___4;
    }
    {
#line 227
    memset((void *)*(row_pointers + i), 0, row_size);
#line 226
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 230
  if ((unsigned long )pnmrow != (unsigned long )((void *)0)) {
    {
#line 231
    png_free((png_const_structrp )png_ptr, (png_voidp )pnmrow);
    }
  }
#line 234
  if (overflow) {
    {
#line 235
    png_warning((png_const_structrp )png_ptr, "Overflow in PNM samples");
    }
  }
#line 236
  if (failed) {
    {
#line 237
    png_error((png_const_structrp )png_ptr, "Error in PNM image file");
    }
  } else {
    {
#line 238
    tmp___5 = pnm_fpeek_eof(& pnminfo, stream);
    }
#line 238
    if (! tmp___5) {
      {
#line 239
      png_warning((png_const_structrp )png_ptr, "Extraneous data found after PNM image");
      }
    }
  }
#line 242
  return (1);
}
}
#line 44 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxpriv.h"
int pngx_sig_is_jpeg(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) ;
#line 47
int pngx_read_jpeg(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 37 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jp2[12]  = 
#line 37 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrjpg.c"
  {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )12, 
        (png_byte const   )106,      (png_byte const   )80,      (png_byte const   )32,      (png_byte const   )32, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )135,      (png_byte const   )10};
#line 39 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jpc[4]  = {      (png_byte const   )255,      (png_byte const   )79,      (png_byte const   )255,      (png_byte const   )81};
#line 41 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jng[8]  = 
#line 41
  {      (png_byte const   )139,      (png_byte const   )74,      (png_byte const   )78,      (png_byte const   )71, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )26,      (png_byte const   )10};
#line 43 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jng_jhdr[8]  = 
#line 43
  {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )26, 
        (png_byte const   )74,      (png_byte const   )72,      (png_byte const   )68,      (png_byte const   )82};
#line 47 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrjpg.c"
int pngx_sig_is_jpeg(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) 
{ 
  char const   *fmt ;
  unsigned int marker ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  if (sig_size < 12UL) {
#line 57
    return (-1);
  }
#line 58
  if ((int )*(sig + 0) == 255) {
#line 58
    if ((int )*(sig + 1) == 216) {
#line 58
      if ((int )*(sig + 2) == 255) {
#line 60
        marker = 65280U | (unsigned int )*(sig + 3);
#line 61
        if (marker >= 65472U) {
#line 61
          if (marker <= 65487U) {
#line 64
            fmt = "JPEG";
#line 65
            result = 1;
          } else {
#line 61
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 61
        if (marker >= 65498U) {
#line 61
          if (marker <= 65534U) {
#line 64
            fmt = "JPEG";
#line 65
            result = 1;
          } else {
#line 68
            return (0);
          }
        } else {
#line 68
          return (0);
        }
      } else {
#line 58
        goto _L___1;
      }
    } else {
#line 58
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 70
    tmp___1 = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jp2), (size_t )12);
    }
#line 70
    if (tmp___1 == 0) {
#line 73
      fmt = "JPEG-2000";
#line 74
      result = 2;
    } else {
      {
#line 70
      tmp___2 = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jpc), (size_t )4);
      }
#line 70
      if (tmp___2 == 0) {
#line 73
        fmt = "JPEG-2000";
#line 74
        result = 2;
      } else {
        {
#line 76
        tmp = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jng), (size_t )8);
        }
#line 76
        if (tmp == 0) {
#line 79
          fmt = "JNG";
#line 80
          result = 3;
        } else {
          {
#line 76
          tmp___0 = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jng_jhdr),
                           (size_t )8);
          }
#line 76
          if (tmp___0 == 0) {
#line 79
            fmt = "JNG";
#line 80
            result = 3;
          } else {
#line 83
            return (0);
          }
        }
      }
    }
  }
#line 86
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 87
    *fmt_name_ptr = fmt;
  }
#line 88
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 89
    *fmt_long_name_ptr = fmt;
  }
#line 90
  return (result);
}
}
#line 93 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrjpg.c"
int pngx_read_jpeg(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  png_byte buf[12] ;
  int sig_code ;
  size_t tmp ;

  {
  {
#line 99
  tmp = fread((void */* __restrict  */)(buf), (size_t )12, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 99
  if (tmp != 1UL) {
#line 100
    return (0);
  }
  {
#line 101
  sig_code = pngx_sig_is_jpeg(buf, (size_t )12, (png_const_charpp )((void *)0), (png_const_charpp )((void *)0));
  }
  {
#line 105
  if (sig_code == 1) {
#line 105
    goto case_1;
  }
#line 109
  if (sig_code == 2) {
#line 109
    goto case_2;
  }
#line 113
  if (sig_code == 3) {
#line 113
    goto case_3;
  }
#line 103
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 106
  png_error((png_const_structrp )png_ptr, "JPEG decoding is not supported");
  }
#line 108
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 110
  png_error((png_const_structrp )png_ptr, "JPEG-2000 decoding is not supported");
  }
#line 112
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 114
  png_error((png_const_structrp )png_ptr, "JNG (JPEG) decoding is not supported");
  }
#line 116
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 118
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 119
    return (0);
  }
#line 120
  return (0);
}
}
#line 38 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxpriv.h"
int pngx_sig_is_gif(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 41
int pngx_read_gif(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 17 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static char const   gif_fmt_name[4]  = {      (char const   )'G',      (char const   )'I',      (char const   )'F',      (char const   )'\000'};
#line 18 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static char const   gif_fmt_long_name[28]  = 
#line 18
  {      (char const   )'G',      (char const   )'r',      (char const   )'a',      (char const   )'p', 
        (char const   )'h',      (char const   )'i',      (char const   )'c',      (char const   )'s', 
        (char const   )' ',      (char const   )'I',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'n',      (char const   )'g',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'o',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'\000'};
#line 20 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static png_byte const   gif_sig_gif87a[6]  = {      (png_byte const   )71,      (png_byte const   )73,      (png_byte const   )70,      (png_byte const   )56, 
        (png_byte const   )55,      (png_byte const   )97};
#line 22 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static png_byte const   gif_sig_gif89a[6]  = {      (png_byte const   )71,      (png_byte const   )73,      (png_byte const   )70,      (png_byte const   )56, 
        (png_byte const   )57,      (png_byte const   )97};
#line 26 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
int pngx_sig_is_gif(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 32
  if (sig_size < 13UL) {
#line 33
    return (-1);
  }
  {
#line 34
  tmp = memcmp((void const   *)sig, (void const   *)(gif_sig_gif87a), (size_t )6);
  }
#line 34
  if (tmp != 0) {
    {
#line 34
    tmp___0 = memcmp((void const   *)sig, (void const   *)(gif_sig_gif89a), (size_t )6);
    }
#line 34
    if (tmp___0 != 0) {
#line 36
      return (0);
    }
  }
#line 39
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 40
    *fmt_name_ptr = gif_fmt_name;
  }
#line 41
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 42
    *fmt_long_name_ptr = gif_fmt_long_name;
  }
#line 43
  return (1);
}
}
#line 48 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static png_structp err_png_ptr___0  ;
#line 49 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static struct GIFImage *err_gif_image_ptr  ;
#line 50 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static struct GIFExtension *err_gif_ext_ptr  ;
#line 52 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static void pngx_gif_error(char const   *msg___0 ) 
{ 


  {
#line 55
  if ((unsigned long )err_gif_image_ptr != (unsigned long )((void *)0)) {
    {
#line 56
    GIFDestroyImage(err_gif_image_ptr);
    }
  }
#line 57
  if ((unsigned long )err_gif_ext_ptr != (unsigned long )((void *)0)) {
    {
#line 58
    GIFDestroyExtension(err_gif_ext_ptr);
    }
  }
  {
#line 59
  png_error((png_const_structrp )err_png_ptr___0, msg___0);
  }
}
}
#line 62 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static void pngx_gif_warning(char const   *msg___0 ) 
{ 


  {
  {
#line 65
  png_warning((png_const_structrp )err_png_ptr___0, msg___0);
  }
#line 66
  return;
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static void pngx_set_gif_palette(png_structp png_ptr , png_infop info_ptr , unsigned char *color_table ,
                                 unsigned int num_colors ) 
{ 
  png_color palette[256] ;
  unsigned int i ;

  {
#line 79
  i = 0U;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < num_colors)) {
#line 79
      goto while_break;
    }
#line 81
    palette[i].red = *(color_table + 3U * i);
#line 82
    palette[i].green = *(color_table + (3U * i + 1U));
#line 83
    palette[i].blue = *(color_table + (3U * i + 2U));
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(palette),
               (int )num_colors);
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
static void pngx_set_gif_transparent(png_structp png_ptr , png_infop info_ptr , unsigned int transparent ) 
{ 
  png_byte trans[256] ;
  unsigned int i ;

  {
#line 97
  i = 0U;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < transparent)) {
#line 97
      goto while_break;
    }
#line 98
    trans[i] = (png_byte )255;
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  trans[transparent] = (png_byte )0;
#line 100
  png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )(trans),
               (int )transparent + 1, (png_const_color_16p )((void *)0));
  }
#line 101
  return;
}
}
#line 103 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrgif.c"
int pngx_read_gif(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  struct GIFScreen screen ;
  struct GIFImage image___0 ;
  struct GIFExtension ext ;
  struct GIFGraphicCtlExt graphicExt ;
  int blockCode ;
  unsigned char *colorTable ;
  unsigned int numColors ;
  unsigned int transparent ;
  unsigned int numImages ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_bytepp row_pointers ;

  {
  {
#line 121
  GIFError = & pngx_gif_error;
#line 122
  GIFWarning = & pngx_gif_warning;
#line 123
  err_png_ptr___0 = png_ptr;
#line 124
  err_gif_image_ptr = (struct GIFImage *)((void *)0);
#line 125
  err_gif_ext_ptr = (struct GIFExtension *)((void *)0);
#line 128
  GIFReadScreen(& screen, stream);
#line 129
  width = screen.Width;
#line 130
  height = screen.Height;
#line 133
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               8, 3, 0, 0, 0);
#line 138
  row_pointers = pngx_malloc_rows(png_ptr, info_ptr, (int )screen.Background);
#line 141
  GIFInitImage(& image___0, & screen, row_pointers);
#line 142
  err_gif_image_ptr = & image___0;
#line 143
  GIFInitExtension(& ext, & screen, 256U);
#line 144
  err_gif_ext_ptr = & ext;
#line 145
  numImages = 0U;
#line 146
  transparent = 4294967295U;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    blockCode = GIFReadNextBlock(& image___0, & ext, stream);
    }
#line 152
    if (blockCode == 44) {
#line 154
      if ((unsigned long )image___0.Rows != (unsigned long )((void *)0)) {
#line 157
        if (image___0.InterlaceFlag) {
          {
#line 158
          pngx_set_interlace_type(png_ptr, info_ptr, 1);
          }
        }
        {
#line 160
        GIFGetColorTable(& colorTable, & numColors, & image___0);
#line 161
        pngx_set_gif_palette(png_ptr, info_ptr, colorTable, numColors);
        }
#line 162
        if (transparent < 256U) {
          {
#line 163
          pngx_set_gif_transparent(png_ptr, info_ptr, transparent);
          }
        }
#line 166
        image___0.Rows = (unsigned char **)((void *)0);
      }
#line 168
      numImages ++;
    } else
#line 170
    if (blockCode == 33) {
#line 172
      if ((int )ext.Label == 249) {
        {
#line 174
        GIFGetGraphicCtl(& graphicExt, & ext);
        }
#line 175
        if ((unsigned long )image___0.Rows != (unsigned long )((void *)0)) {
#line 175
          if (graphicExt.TransparentFlag) {
#line 177
            if (transparent >= 256U) {
#line 178
              transparent = graphicExt.Transparent;
            }
          }
        }
      }
    } else
#line 182
    if (blockCode == 59) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if ((unsigned long )image___0.Rows != (unsigned long )((void *)0)) {
    {
#line 187
    png_error((png_const_structrp )png_ptr, "No image in GIF file");
    }
  }
  {
#line 189
  GIFDestroyImage(& image___0);
#line 190
  GIFDestroyExtension(& ext);
  }
#line 191
  return ((int )numImages);
}
}
#line 731 "/usr/include/stdio.h"
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
#line 47 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxtern.h"
int pngx_read_image(png_structp png_ptr , png_infop info_ptr , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 32 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxpriv.h"
int pngx_sig_is_bmp(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 35
int pngx_read_bmp(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 27 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static int pngx_sig_is_png(png_structp png_ptr , png_bytep sig , size_t sig_size ,
                           png_const_charpp fmt_name_ptr , png_const_charpp fmt_long_name_ptr ) ;
#line 27 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static char const   pngx_png_standalone_fmt_name[4]  = {      (char const   )'P',      (char const   )'N',      (char const   )'G',      (char const   )'\000'};
#line 29 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static char const   pngx_png_datastream_fmt_name[15]  = 
#line 29
  {      (char const   )'P',      (char const   )'N',      (char const   )'G',      (char const   )' ', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'a', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'m',      (char const   )'\000'};
#line 31 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static char const   pngx_png_standalone_fmt_long_name[26]  = 
#line 31
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'N',      (char const   )'e',      (char const   )'t', 
        (char const   )'w',      (char const   )'o',      (char const   )'r',      (char const   )'k', 
        (char const   )' ',      (char const   )'G',      (char const   )'r',      (char const   )'a', 
        (char const   )'p',      (char const   )'h',      (char const   )'i',      (char const   )'c', 
        (char const   )'s',      (char const   )'\000'};
#line 33 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static char const   pngx_png_datastream_fmt_long_name[46]  = 
#line 33
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'N',      (char const   )'e',      (char const   )'t', 
        (char const   )'w',      (char const   )'o',      (char const   )'r',      (char const   )'k', 
        (char const   )' ',      (char const   )'G',      (char const   )'r',      (char const   )'a', 
        (char const   )'p',      (char const   )'h',      (char const   )'i',      (char const   )'c', 
        (char const   )'s',      (char const   )' ',      (char const   )'e',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'d',      (char const   )'d', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'d', 
        (char const   )'a',      (char const   )'t',      (char const   )'a',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'m',      (char const   )'\000'};
#line 36 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static png_byte const   png_file_sig[8]  = 
#line 36
  {      (png_byte const   )137,      (png_byte const   )80,      (png_byte const   )78,      (png_byte const   )71, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )26,      (png_byte const   )10};
#line 37 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static png_byte const   mng_file_sig[8]  = 
#line 37
  {      (png_byte const   )138,      (png_byte const   )77,      (png_byte const   )78,      (png_byte const   )71, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )26,      (png_byte const   )10};
#line 38 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static png_byte const   png_ihdr_sig[8]  = 
#line 38
  {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )13, 
        (png_byte const   )73,      (png_byte const   )72,      (png_byte const   )68,      (png_byte const   )82};
#line 16 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
static int pngx_sig_is_png(png_structp png_ptr , png_bytep sig , size_t sig_size ,
                           png_const_charpp fmt_name_ptr , png_const_charpp fmt_long_name_ptr ) 
{ 
  int has_png_sig ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 46
  if (sig_size <= 43UL) {
#line 47
    return (-1);
  }
  {
#line 48
  tmp = memcmp((void const   *)sig, (void const   *)(png_file_sig), (size_t )8);
#line 48
  has_png_sig = tmp == 0;
  }
#line 49
  if (has_png_sig) {
#line 49
    tmp___2 = 8;
  } else {
#line 49
    tmp___2 = 0;
  }
  {
#line 49
  tmp___3 = memcmp((void const   *)(sig + tmp___2), (void const   *)(png_ihdr_sig),
                   (size_t )8);
  }
#line 49
  if (tmp___3 != 0) {
    {
#line 52
    tmp___1 = memcmp((void const   *)sig, (void const   *)(png_file_sig), (size_t )4);
    }
#line 52
    if (tmp___1 == 0) {
#line 52
      if ((int )*(sig + 4) == 10) {
        {
#line 53
        png_error((png_const_structrp )png_ptr, "PNG file appears to be corrupted by text file conversions");
        }
      } else
#line 52
      if ((int )*(sig + 4) == 13) {
        {
#line 53
        png_error((png_const_structrp )png_ptr, "PNG file appears to be corrupted by text file conversions");
        }
      } else {
#line 52
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 55
      tmp___0 = memcmp((void const   *)sig, (void const   *)(mng_file_sig), (size_t )8);
      }
#line 55
      if (tmp___0 == 0) {
        {
#line 56
        png_error((png_const_structrp )png_ptr, "MNG decoding is not supported");
        }
      }
    }
#line 58
    return (0);
  }
#line 62
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 64
    if (has_png_sig) {
#line 64
      *fmt_name_ptr = pngx_png_standalone_fmt_name;
    } else {
#line 64
      *fmt_name_ptr = pngx_png_datastream_fmt_name;
    }
  }
#line 68
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 70
    if (has_png_sig) {
#line 70
      *fmt_long_name_ptr = pngx_png_standalone_fmt_long_name;
    } else {
#line 70
      *fmt_long_name_ptr = pngx_png_datastream_fmt_long_name;
    }
  }
#line 74
  return (1);
}
}
#line 77 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxread.c"
int pngx_read_image(png_structp png_ptr , png_infop info_ptr , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 
  png_byte sig[128] ;
  size_t num ;
  int (*read_fn)(png_structp  , png_infop  , FILE * ) ;
  FILE *stream ;
  fpos_t fpos ;
  int result ;
  png_voidp tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 96
  tmp = png_get_io_ptr((png_const_structrp )png_ptr);
#line 96
  stream = (FILE *)tmp;
#line 97
  tmp___0 = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& fpos));
  }
#line 97
  if (tmp___0 != 0) {
    {
#line 98
    png_error((png_const_structrp )png_ptr, "Can\'t ftell in input file stream");
    }
  }
  {
#line 99
  num = fread((void */* __restrict  */)(sig), (size_t )1, sizeof(sig), (FILE */* __restrict  */)stream);
#line 100
  tmp___1 = fsetpos(stream, (fpos_t const   *)(& fpos));
  }
#line 100
  if (tmp___1 != 0) {
    {
#line 101
    png_error((png_const_structrp )png_ptr, "Can\'t fseek in input file stream");
    }
  }
  {
#line 104
  tmp___3 = pngx_sig_is_png(png_ptr, sig, num, fmt_name_ptr, fmt_long_name_ptr);
  }
#line 104
  if (tmp___3 > 0) {
    {
#line 106
    png_read_png((png_structrp )png_ptr, (png_inforp )info_ptr, 0, (void *)0);
#line 107
    tmp___2 = _IO_getc(stream);
    }
#line 107
    if (tmp___2 != -1) {
      {
#line 109
      png_warning((png_const_structrp )png_ptr, "Extraneous data found after IEND");
#line 110
      fseek(stream, 0L, 2);
      }
    }
#line 112
    return (1);
  }
  {
#line 116
  tmp___8 = pngx_sig_is_bmp(sig, num, fmt_name_ptr, fmt_long_name_ptr);
  }
#line 116
  if (tmp___8 > 0) {
#line 117
    read_fn = & pngx_read_bmp;
  } else {
    {
#line 118
    tmp___7 = pngx_sig_is_gif(sig, num, fmt_name_ptr, fmt_long_name_ptr);
    }
#line 118
    if (tmp___7 > 0) {
#line 119
      read_fn = & pngx_read_gif;
    } else {
      {
#line 120
      tmp___6 = pngx_sig_is_jpeg(sig, num, fmt_name_ptr, fmt_long_name_ptr);
      }
#line 120
      if (tmp___6 > 0) {
#line 121
        read_fn = & pngx_read_jpeg;
      } else {
        {
#line 122
        tmp___5 = pngx_sig_is_pnm(sig, num, fmt_name_ptr, fmt_long_name_ptr);
        }
#line 122
        if (tmp___5 > 0) {
#line 123
          read_fn = & pngx_read_pnm;
        } else {
          {
#line 124
          tmp___4 = pngx_sig_is_tiff(sig, num, fmt_name_ptr, fmt_long_name_ptr);
          }
#line 124
          if (tmp___4 > 0) {
#line 125
            read_fn = & pngx_read_tiff;
          } else {
#line 127
            return (0);
          }
        }
      }
    }
  }
  {
#line 130
  result = (*read_fn)(png_ptr, info_ptr, stream);
  }
#line 132
  if (result <= 0) {
    {
#line 133
    tmp___9 = fsetpos(stream, (fpos_t const   *)(& fpos));
    }
#line 133
    if (tmp___9 != 0) {
      {
#line 134
      png_error((png_const_structrp )png_ptr, "Can\'t fseek in input file stream");
      }
    }
  }
#line 135
  return (result);
}
}
#line 45 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxutil.h"
png_bytepp pngx_malloc_rows_extended(png_structp png_ptr , png_infop info_ptr , pngx_alloc_size_t min_row_size ,
                                     int filler ) ;
#line 96 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static unsigned int bmp_get_word(png_bytep ptr ) 
{ 


  {
#line 99
  return ((unsigned int )*(ptr + 0) + ((unsigned int )*(ptr + 1) << 8));
}
}
#line 102 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static png_uint_32 bmp_get_dword(png_bytep ptr ) 
{ 


  {
#line 105
  return ((((png_uint_32 )*(ptr + 0) + ((png_uint_32 )*(ptr + 1) << 8)) + ((png_uint_32 )*(ptr + 2) << 16)) + ((png_uint_32 )*(ptr + 3) << 24));
}
}
#line 114 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static void bmp_memset_bytes(png_bytep ptr , size_t offset , int ch , size_t len ) 
{ 


  {
  {
#line 117
  memset((void *)(ptr + offset), ch, len);
  }
#line 118
  return;
}
}
#line 120 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static void bmp_memset_halfbytes(png_bytep ptr , size_t offset , int ch , size_t len ) 
{ 


  {
#line 123
  if (len == 0UL) {
#line 124
    return;
  }
#line 125
  ptr += offset / 2UL;
#line 126
  if (offset & 1UL) {
#line 128
    *ptr = (png_byte )(((int )*ptr & 240) | (ch & 15));
#line 129
    ch = ((ch & 240) >> 4) | ((ch & 15) << 4);
#line 130
    ptr ++;
#line 131
    len --;
  }
  {
#line 133
  memset((void *)ptr, ch, len / 2UL);
  }
#line 134
  if (len & 1UL) {
#line 135
    *(ptr + len / 2UL) = (png_byte )(ch & 240);
  }
#line 136
  return;
}
}
#line 138 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static size_t bmp_fread_bytes(png_bytep ptr , size_t offset , size_t len , FILE *stream ) 
{ 
  size_t result ;

  {
  {
#line 143
  result = fread((void */* __restrict  */)(ptr + offset), (size_t )1, len, (FILE */* __restrict  */)stream);
  }
#line 144
  if (len & 1UL) {
    {
#line 145
    _IO_getc(stream);
    }
  }
#line 146
  return (result);
}
}
#line 149 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static size_t bmp_fread_halfbytes(png_bytep ptr , size_t offset , size_t len , FILE *stream ) 
{ 
  size_t result ;
  int ch ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 155
  if (len == 0UL) {
#line 156
    return ((size_t )0);
  }
#line 157
  ptr += offset / 2UL;
#line 158
  if (offset & 1UL) {
#line 160
    result = (size_t )0;
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      if (! (result < len - 1UL)) {
#line 160
        goto while_break;
      }
      {
#line 162
      ch = _IO_getc(stream);
      }
#line 163
      if (ch == -1) {
#line 164
        goto while_break;
      }
#line 165
      *ptr = (png_byte )(((int )*ptr & 240) | ((ch & 240) >> 4));
#line 166
      ptr ++;
#line 167
      *ptr = (png_byte )((ch & 15) << 4);
#line 160
      result += 2UL;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 172
    tmp = fread((void */* __restrict  */)ptr, (size_t )1, (len + 1UL) / 2UL, (FILE */* __restrict  */)stream);
#line 172
    result = tmp * 2UL;
    }
  }
#line 174
  if (len & 2UL) {
    {
#line 175
    _IO_getc(stream);
    }
  }
#line 176
  if (result <= len) {
#line 176
    tmp___0 = result;
  } else {
#line 176
    tmp___0 = len;
  }
#line 176
  return (tmp___0);
}
}
#line 184 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static void bmp_process_mask(png_uint_32 bmp_mask , png_bytep sig_bit , png_bytep shift_bit ) 
{ 
  png_byte tmp ;

  {
#line 187
  tmp = (png_byte )0;
#line 187
  *shift_bit = tmp;
#line 187
  *sig_bit = tmp;
#line 188
  if (bmp_mask == 0U) {
#line 189
    return;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((bmp_mask & 1U) == 0U)) {
#line 190
      goto while_break;
    }
#line 192
    bmp_mask >>= 1;
#line 193
    *shift_bit = (png_byte )((int )*shift_bit + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (bmp_mask != 0U)) {
#line 195
      goto while_break___0;
    }
#line 197
    if ((bmp_mask & 1U) == 0U) {
#line 199
      *sig_bit = (png_byte )0;
#line 200
      return;
    } else
#line 197
    if ((int )*sig_bit >= 8) {
#line 199
      *sig_bit = (png_byte )0;
#line 200
      return;
    }
#line 202
    bmp_mask >>= 1;
#line 203
    *sig_bit = (png_byte )((int )*sig_bit + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 212 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static size_t bmp_read_rows(png_bytepp begin_row , png_bytepp end_row , size_t row_size ,
                            unsigned int compression , FILE *stream ) 
{ 
  size_t result ;
  png_bytepp crt_row ;
  int inc ;
  size_t crtn ;
  size_t dcrtn ;
  size_t endn ;
  unsigned int len ;
  unsigned int b1 ;
  unsigned int b2 ;
  int ch ;
  void (*bmp_memset_fn)(png_bytep  , size_t  , int  , size_t  ) ;
  size_t (*bmp_fread_fn)(png_bytep  , size_t  , size_t  , FILE * ) ;
  size_t tmp ;

  {
#line 225
  if (row_size == 0UL) {
#line 226
    return ((size_t )0);
  }
#line 228
  if ((unsigned long )begin_row <= (unsigned long )end_row) {
#line 228
    inc = 1;
  } else {
#line 228
    inc = -1;
  }
#line 229
  crtn = (size_t )0;
#line 230
  result = (size_t )0;
#line 231
  if (compression == 2U) {
#line 233
    endn = row_size * 2UL;
#line 234
    if (endn <= row_size) {
#line 235
      return ((size_t )0);
    }
#line 236
    bmp_memset_fn = & bmp_memset_halfbytes;
#line 237
    bmp_fread_fn = & bmp_fread_halfbytes;
  } else {
#line 241
    endn = row_size;
#line 242
    bmp_memset_fn = & bmp_memset_bytes;
#line 243
    bmp_fread_fn = & bmp_fread_bytes;
  }
#line 246
  if (compression == 0U) {
#line 246
    goto _L___0;
  } else
#line 246
  if (compression == 3U) {
    _L___0: /* CIL Label */ 
#line 249
    crt_row = begin_row;
    {
#line 249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 249
      if (! ((unsigned long )crt_row != (unsigned long )end_row)) {
#line 249
        goto while_break;
      }
      {
#line 251
      crtn = (*bmp_fread_fn)(*crt_row, (size_t )0, endn, stream);
      }
#line 252
      if (crtn != endn) {
#line 253
        goto while_break;
      }
#line 254
      result ++;
#line 249
      crt_row += inc;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 257
  if (compression == 1U) {
#line 257
    goto _L;
  } else
#line 257
  if (compression == 2U) {
    _L: /* CIL Label */ 
#line 260
    if (compression == 1U) {
#line 262
      endn = row_size;
    } else {
#line 266
      endn = row_size * 2UL;
#line 267
      if (endn <= row_size) {
#line 268
        return ((size_t )0);
      }
    }
#line 270
    crt_row = begin_row;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      if (! ((unsigned long )crt_row != (unsigned long )end_row)) {
#line 270
        goto while_break___0;
      }
      {
#line 272
      ch = _IO_getc(stream);
#line 272
      b1 = (unsigned int )ch;
#line 273
      ch = _IO_getc(stream);
#line 273
      b2 = (unsigned int )ch;
      }
#line 274
      if (ch == -1) {
#line 275
        goto while_break___0;
      }
#line 276
      if (b1 == 0U) {
#line 278
        if (b2 == 0U) {
          {
#line 280
          (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 281
          crt_row += inc;
#line 282
          crtn = (size_t )0;
#line 283
          result ++;
          }
#line 284
          if ((unsigned long )crt_row == (unsigned long )end_row) {
            {
#line 286
            ch = _IO_getc(stream);
            }
#line 287
            if (ch != -1) {
#line 287
              if (ch != 0) {
                {
#line 289
                ungetc(ch, stream);
                }
#line 290
                goto while_break___0;
              }
            }
            {
#line 292
            _IO_getc(stream);
            }
#line 293
            goto while_break___0;
          }
        } else
#line 296
        if (b2 == 1U) {
          {
#line 298
          (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 299
          crt_row += inc;
#line 300
          crtn = (size_t )0;
          }
#line 301
          if ((unsigned long )begin_row <= (unsigned long )end_row) {
#line 301
            result = (size_t )(end_row - begin_row);
          } else {
#line 301
            result = (size_t )(begin_row - end_row);
          }
#line 303
          goto while_break___0;
        } else
#line 305
        if (b2 == 2U) {
          {
#line 307
          ch = _IO_getc(stream);
#line 307
          b1 = (unsigned int )ch;
#line 308
          ch = _IO_getc(stream);
#line 308
          b2 = (unsigned int )ch;
          }
#line 309
          if (ch == -1) {
#line 310
            goto while_break___0;
          }
#line 311
          if ((size_t )b1 < endn - crtn) {
#line 311
            dcrtn = crtn + (size_t )b1;
          } else {
#line 311
            dcrtn = endn;
          }
          {
#line 312
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 312
            if (! (b2 > 0U)) {
#line 312
              goto while_break___1;
            }
            {
#line 314
            (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 315
            crt_row += inc;
#line 316
            crtn = (size_t )0;
#line 317
            result ++;
            }
#line 318
            if ((unsigned long )crt_row == (unsigned long )end_row) {
#line 319
              goto while_break___1;
            }
#line 312
            b2 --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 321
          if ((unsigned long )crt_row != (unsigned long )end_row) {
            {
#line 322
            (*bmp_memset_fn)(*crt_row, crtn, 0, dcrtn - crtn);
            }
          }
        } else {
#line 326
          if ((size_t )b2 <= endn - crtn) {
#line 326
            len = b2;
          } else {
#line 326
            len = (unsigned int )(endn - crtn);
          }
          {
#line 327
          tmp = (*bmp_fread_fn)(*crt_row, crtn, (size_t )len, stream);
          }
#line 327
          if (tmp != (size_t )len) {
#line 328
            goto while_break___0;
          }
#line 329
          crtn += (size_t )len;
        }
      } else {
#line 334
        if ((size_t )b1 <= endn - crtn) {
#line 334
          len = b1;
        } else {
#line 334
          len = (unsigned int )(endn - crtn);
        }
        {
#line 335
        (*bmp_memset_fn)(*crt_row, crtn, (int )b2, (size_t )len);
#line 336
        crtn += (size_t )len;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 341
    return ((size_t )0);
  }
  {
#line 344
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )crt_row != (unsigned long )end_row)) {
#line 344
      goto while_break___2;
    }
    {
#line 346
    (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 347
    crtn = (size_t )0;
#line 344
    crt_row += inc;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 350
  return (result);
}
}
#line 358 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static void bmp_to_png_rows(png_bytepp row_pointers , png_uint_32 width , png_uint_32 height ,
                            unsigned int pixdepth , png_bytep rgba_sig , png_bytep rgba_shift ) 
{ 
  png_bytep src_ptr ;
  png_bytep dest_ptr ;
  unsigned int rgba_mask[4] ;
  unsigned int num_samples ;
  unsigned int sample ;
  unsigned int mask ;
  unsigned int wpix ;
  png_uint_32 dwpix ;
  png_uint_32 x ;
  png_uint_32 y ;
  unsigned int i ;
  png_byte tmp ;

  {
#line 371
  if (pixdepth == 24U) {
#line 373
    y = (png_uint_32 )0;
    {
#line 373
    while (1) {
      while_continue: /* CIL Label */ ;
#line 373
      if (! (y < height)) {
#line 373
        goto while_break;
      }
#line 375
      src_ptr = *(row_pointers + y);
#line 376
      x = (png_uint_32 )0;
      {
#line 376
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 376
        if (! (x < width)) {
#line 376
          goto while_break___0;
        }
#line 378
        tmp = *(src_ptr + 0);
#line 379
        *(src_ptr + 0) = *(src_ptr + 2);
#line 380
        *(src_ptr + 2) = tmp;
#line 376
        x ++;
#line 376
        src_ptr += 3;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 373
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 383
    return;
  }
#line 386
  if ((int )*(rgba_sig + 3) != 0) {
#line 386
    num_samples = 4U;
  } else {
#line 386
    num_samples = 3U;
  }
#line 387
  i = 0U;
  {
#line 387
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 387
    if (! (i < num_samples)) {
#line 387
      goto while_break___1;
    }
#line 388
    rgba_mask[i] = (1U << (int )*(rgba_sig + i)) - 1U;
#line 387
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 390
  if (pixdepth == 16U) {
#line 392
    y = (png_uint_32 )0;
    {
#line 392
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 392
      if (! (y < height)) {
#line 392
        goto while_break___2;
      }
#line 394
      src_ptr = *(row_pointers + y) + (width - 1U) * 2U;
#line 395
      dest_ptr = *(row_pointers + y) + (width - 1U) * num_samples;
#line 396
      x = (png_uint_32 )0;
      {
#line 396
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 396
        if (! (x < width)) {
#line 396
          goto while_break___3;
        }
#line 399
        wpix = (unsigned int )*(src_ptr + 0) + ((unsigned int )*(src_ptr + 1) << 8);
#line 400
        i = 0U;
        {
#line 400
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 400
          if (! (i < num_samples)) {
#line 400
            goto while_break___4;
          }
#line 402
          mask = rgba_mask[i];
#line 403
          sample = (wpix >> (int )*(rgba_shift + i)) & mask;
#line 404
          *(dest_ptr + i) = (png_byte )((sample * 255U + mask / 2U) / mask);
#line 400
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 396
        x ++;
#line 396
        src_ptr -= 2;
#line 396
        dest_ptr -= num_samples;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 392
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 409
  if (pixdepth == 32U) {
#line 411
    y = (png_uint_32 )0;
    {
#line 411
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 411
      if (! (y < height)) {
#line 411
        goto while_break___5;
      }
#line 413
      dest_ptr = *(row_pointers + y);
#line 413
      src_ptr = dest_ptr;
#line 414
      x = (png_uint_32 )0;
      {
#line 414
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 414
        if (! (x < width)) {
#line 414
          goto while_break___6;
        }
#line 417
        dwpix = (((png_uint_32 )*(src_ptr + 0) + ((png_uint_32 )*(src_ptr + 1) << 8)) + ((png_uint_32 )*(src_ptr + 2) << 16)) + ((png_uint_32 )*(src_ptr + 3) << 24);
#line 419
        i = 0U;
        {
#line 419
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 419
          if (! (i < num_samples)) {
#line 419
            goto while_break___7;
          }
#line 421
          mask = rgba_mask[i];
#line 422
          sample = (dwpix >> (int )*(rgba_shift + i)) & mask;
#line 423
          *(dest_ptr + i) = (png_byte )((sample * 255U + mask / 2U) / mask);
#line 419
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 414
        x ++;
#line 414
        src_ptr += 4;
#line 414
        dest_ptr += num_samples;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 411
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 429
  return;
}
}
#line 441 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static char const   bmp_fmt_name[4]  = {      (char const   )'B',      (char const   )'M',      (char const   )'P',      (char const   )'\000'};
#line 442 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static char const   os2bmp_fmt_long_name[12]  = 
#line 442
  {      (char const   )'O',      (char const   )'S',      (char const   )'/',      (char const   )'2', 
        (char const   )' ',      (char const   )'B',      (char const   )'i',      (char const   )'t', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 443 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
static char const   winbmp_fmt_long_name[15]  = 
#line 443
  {      (char const   )'W',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'o',      (char const   )'w',      (char const   )'s',      (char const   )' ', 
        (char const   )'B',      (char const   )'i',      (char const   )'t',      (char const   )'m', 
        (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 436 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
int pngx_sig_is_bmp(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 
  png_uint_32 bihsize ;
  unsigned int tmp ;

  {
#line 447
  if (sig_size < 18UL) {
#line 448
    return (-1);
  }
  {
#line 449
  tmp = bmp_get_word(sig);
  }
#line 449
  if (tmp != 19778U) {
#line 450
    return (0);
  }
  {
#line 452
  bihsize = bmp_get_dword(sig + 14);
  }
#line 453
  if (bihsize > 2147483647U) {
#line 455
    return (0);
  } else
#line 453
  if (bihsize != 12U) {
#line 453
    if (bihsize < 40U) {
#line 455
      return (0);
    }
  }
#line 458
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 459
    *fmt_name_ptr = bmp_fmt_name;
  }
#line 460
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 462
    if (bihsize == 12U) {
#line 463
      *fmt_long_name_ptr = os2bmp_fmt_long_name;
    } else {
#line 465
      *fmt_long_name_ptr = winbmp_fmt_long_name;
    }
  }
#line 467
  return (1);
}
}
#line 470 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxrbmp.c"
int pngx_read_bmp(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  png_byte bfh[138] ;
  png_bytep bih ;
  png_byte rgbq[4] ;
  png_uint_32 offbits ;
  png_uint_32 bihsize ;
  png_uint_32 skip ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 rowsize ;
  int topdown ;
  unsigned int pixdepth ;
  png_uint_32 compression ;
  unsigned int palsize ;
  unsigned int palnum ;
  png_uint_32 rgba_mask[4] ;
  png_byte rgba_sig[4] ;
  png_byte rgba_shift[4] ;
  int bit_depth ;
  int color_type ;
  png_color palette[256] ;
  png_color_8 sig_bit ;
  png_bytepp row_pointers ;
  png_bytepp begin_row ;
  png_bytepp end_row ;
  unsigned int i ;
  size_t y ;
  unsigned int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 474
  bih = bfh + 14;
#line 492
  i = 0U;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 494
    tmp___0 = fread((void */* __restrict  */)(bfh), (size_t )18, (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 494
    if (tmp___0 != 1UL) {
#line 495
      i ++;
    } else {
      {
#line 496
      tmp = bmp_get_word(bfh + 0);
      }
#line 496
      if (tmp == 19778U) {
#line 497
        goto while_break;
      }
    }
    {
#line 498
    tmp___1 = fread((void */* __restrict  */)(bfh), (size_t )110, (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 498
    if (tmp___1 != 1UL) {
#line 499
      i ++;
    }
#line 500
    if (i > 0U) {
#line 501
      return (0);
    }
#line 492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 505
  offbits = bmp_get_dword(bfh + 10);
#line 506
  bihsize = bmp_get_dword(bfh + 14);
  }
#line 507
  if (offbits > 2147483647U) {
#line 510
    return (0);
  } else
#line 507
  if (bihsize > 2147483647U) {
#line 510
    return (0);
  } else
#line 507
  if (offbits < bihsize + 14U) {
#line 510
    return (0);
  } else
#line 507
  if (bihsize != 12U) {
#line 507
    if (bihsize < 40U) {
#line 510
      return (0);
    }
  }
#line 511
  if (bihsize > 124U) {
#line 513
    skip = bihsize - 124U;
#line 514
    bihsize = (png_uint_32 )124;
  } else {
#line 517
    skip = (png_uint_32 )0;
  }
  {
#line 518
  tmp___2 = fread((void */* __restrict  */)(bih + 4), (size_t )(bihsize - 4U), (size_t )1,
                  (FILE */* __restrict  */)stream);
  }
#line 518
  if (tmp___2 != 1UL) {
#line 519
    return (0);
  }
#line 520
  if (skip > 0U) {
    {
#line 521
    tmp___3 = fseek(stream, (long )skip, 1);
    }
#line 521
    if (tmp___3 != 0) {
#line 522
      return (0);
    }
  }
#line 523
  skip = (offbits - bihsize) - 14U;
#line 524
  topdown = 0;
#line 525
  if (bihsize < 40U) {
    {
#line 527
    width = bmp_get_word(bih + 4);
#line 528
    height = bmp_get_word(bih + 6);
#line 529
    pixdepth = bmp_get_word(bih + 10);
#line 530
    compression = (png_uint_32 )0;
#line 531
    palsize = 3U;
    }
  } else {
    {
#line 535
    width = bmp_get_dword(bih + 4);
#line 536
    height = bmp_get_dword(bih + 8);
#line 537
    pixdepth = bmp_get_word(bih + 14);
#line 538
    compression = bmp_get_dword(bih + 16);
#line 539
    palsize = 4U;
    }
#line 540
    if (height > 2147483647U) {
#line 542
      height = (4294967295U - height) + 1U;
#line 543
      topdown = 1;
    }
#line 545
    if (bihsize == 40U) {
#line 545
      if (compression == 3U) {
#line 548
        if (skip <= 16U) {
#line 548
          i = skip;
        } else {
#line 548
          i = 16U;
        }
        {
#line 549
        tmp___4 = fread((void */* __restrict  */)(bih + 40), (size_t )i, (size_t )1,
                        (FILE */* __restrict  */)stream);
        }
#line 549
        if (tmp___4 != 1UL) {
#line 550
          return (0);
        }
#line 551
        bihsize += i;
#line 552
        skip -= i;
      }
    }
  }
  {
#line 556
  memset((void *)(rgba_mask), 0, sizeof(rgba_mask));
  }
#line 557
  if (pixdepth > 8U) {
#line 559
    if (compression == 0U) {
#line 561
      if (pixdepth == 16U) {
#line 563
        compression = (png_uint_32 )3;
#line 564
        rgba_mask[0] = (png_uint_32 )31744;
#line 565
        rgba_mask[1] = (png_uint_32 )992;
#line 566
        rgba_mask[2] = (png_uint_32 )31;
      } else {
#line 570
        rgba_mask[0] = (png_uint_32 )16711680L;
#line 571
        rgba_mask[1] = (png_uint_32 )65280L;
#line 572
        rgba_mask[2] = (png_uint_32 )255L;
      }
    } else
#line 575
    if (compression == 3U) {
#line 577
      if (bihsize >= 52U) {
        {
#line 579
        rgba_mask[0] = bmp_get_dword(bih + 40);
#line 580
        rgba_mask[1] = bmp_get_dword(bih + 44);
#line 581
        rgba_mask[2] = bmp_get_dword(bih + 48);
        }
      } else {
        {
#line 584
        png_error((png_const_structrp )png_ptr, "Missing color mask in BMP file");
        }
      }
    }
#line 586
    if (bihsize >= 56U) {
      {
#line 587
      rgba_mask[3] = bmp_get_dword(bih + 52);
      }
    }
  }
  {
#line 592
  if (compression == 0U) {
#line 592
    goto case_0;
  }
#line 600
  if (compression == 1U) {
#line 600
    goto case_1;
  }
#line 604
  if (compression == 2U) {
#line 604
    goto case_2;
  }
#line 608
  if (compression == 3U) {
#line 608
    goto case_3;
  }
#line 612
  if (compression == 4U) {
#line 612
    goto case_4;
  }
#line 616
  if (compression == 5U) {
#line 616
    goto case_5;
  }
#line 623
  goto switch_default;
  case_0: /* CIL Label */ 
#line 597
  if (pixdepth > 0U) {
#line 597
    if (32U % pixdepth != 0U) {
#line 597
      if (pixdepth != 24U) {
#line 598
        pixdepth = 0U;
      }
    }
  }
#line 599
  goto switch_break;
  case_1: /* CIL Label */ 
#line 601
  if (pixdepth != 8U) {
#line 602
    pixdepth = 0U;
  }
#line 603
  goto switch_break;
  case_2: /* CIL Label */ 
#line 605
  if (pixdepth != 4U) {
#line 606
    pixdepth = 0U;
  }
#line 607
  goto switch_break;
  case_3: /* CIL Label */ 
#line 609
  if (pixdepth != 16U) {
#line 609
    if (pixdepth != 32U) {
#line 610
      pixdepth = 0U;
    }
  }
#line 611
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 613
  png_error((png_const_structrp )png_ptr, "JPEG-compressed BMP files are not supported");
  }
#line 615
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 617
  tmp___5 = _IO_getc(stream);
#line 617
  tmp___6 = ungetc(tmp___5, stream);
  }
#line 617
  if (tmp___6 == 0) {
    {
#line 618
    png_set_sig_bytes((png_structrp )png_ptr, 8);
    }
  }
  {
#line 619
  png_set_read_fn((png_structrp )png_ptr, (png_voidp )stream, (void (*)(png_structp  ,
                                                                        png_bytep  ,
                                                                        png_size_t  ))((void *)0));
#line 620
  png_read_png((png_structrp )png_ptr, (png_inforp )info_ptr, 0, (void *)0);
  }
#line 622
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 624
  png_error((png_const_structrp )png_ptr, "Unsupported compression method in BMP file");
  }
  switch_break: /* CIL Label */ ;
  }
#line 628
  if (width == 0U) {
    {
#line 629
    png_error((png_const_structrp )png_ptr, "Invalid image dimensions in BMP file");
    }
  } else
#line 628
  if (width > 2147483647U) {
    {
#line 629
    png_error((png_const_structrp )png_ptr, "Invalid image dimensions in BMP file");
    }
  } else
#line 628
  if (height == 0U) {
    {
#line 629
    png_error((png_const_structrp )png_ptr, "Invalid image dimensions in BMP file");
    }
  }
#line 630
  if (pixdepth == 0U) {
    {
#line 631
    png_error((png_const_structrp )png_ptr, "Invalid pixel depth in BMP file");
    }
  }
#line 634
  if (pixdepth <= 8U) {
#line 636
    palnum = skip / palsize;
#line 637
    if (palnum > 256U) {
#line 638
      palnum = 256U;
    }
#line 639
    skip -= palsize * palnum;
#line 640
    rowsize = (((width + 32U / pixdepth) - 1U) / (32U / pixdepth)) * 4U;
#line 642
    bit_depth = (int )pixdepth;
#line 643
    if (palnum > 0U) {
#line 643
      color_type = 3;
    } else {
#line 643
      color_type = 0;
    }
  } else {
#line 647
    palnum = 0U;
#line 648
    bit_depth = 8;
    {
#line 651
    if (pixdepth == 16U) {
#line 651
      goto case_16;
    }
#line 654
    if (pixdepth == 24U) {
#line 654
      goto case_24;
    }
#line 657
    if (pixdepth == 32U) {
#line 657
      goto case_32;
    }
#line 660
    goto switch_default___0;
    case_16: /* CIL Label */ 
#line 652
    rowsize = (width * 2U + 3U) & 4294967292U;
#line 653
    goto switch_break___0;
    case_24: /* CIL Label */ 
#line 655
    rowsize = (width * 3U + 3U) & 4294967292U;
#line 656
    goto switch_break___0;
    case_32: /* CIL Label */ 
#line 658
    rowsize = width * 4U;
#line 659
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 661
    bit_depth = 0;
#line 662
    rowsize = (png_uint_32 )0;
    switch_break___0: /* CIL Label */ ;
    }
#line 664
    if (rowsize / width < pixdepth / 8U) {
#line 665
      rowsize = (png_uint_32 )0;
    }
#line 666
    if (rgba_mask[3] != 0U) {
#line 666
      color_type = 6;
    } else {
#line 666
      color_type = 2;
    }
  }
#line 669
  if (rowsize == 0U) {
    {
#line 670
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large BMP dimensions");
    }
  }
  {
#line 673
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, 0, 0, 0);
  }
#line 676
  if (pixdepth > 8U) {
#line 678
    i = 0U;
    {
#line 678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 678
      if (! (i < 4U)) {
#line 678
        goto while_break___0;
      }
      {
#line 679
      bmp_process_mask(rgba_mask[i], & rgba_sig[i], & rgba_shift[i]);
#line 678
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 680
    if ((int )rgba_sig[0] == 0) {
      {
#line 681
      png_error((png_const_structrp )png_ptr, "Invalid color mask in BMP file");
      }
    } else
#line 680
    if ((int )rgba_sig[1] == 0) {
      {
#line 681
      png_error((png_const_structrp )png_ptr, "Invalid color mask in BMP file");
      }
    } else
#line 680
    if ((int )rgba_sig[2] == 0) {
      {
#line 681
      png_error((png_const_structrp )png_ptr, "Invalid color mask in BMP file");
      }
    }
#line 682
    if ((int )rgba_sig[0] != 8) {
      {
#line 685
      sig_bit.red = rgba_sig[0];
#line 686
      sig_bit.green = rgba_sig[1];
#line 687
      sig_bit.blue = rgba_sig[2];
#line 688
      sig_bit.alpha = rgba_sig[3];
#line 689
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    } else
#line 682
    if ((int )rgba_sig[1] != 8) {
      {
#line 685
      sig_bit.red = rgba_sig[0];
#line 686
      sig_bit.green = rgba_sig[1];
#line 687
      sig_bit.blue = rgba_sig[2];
#line 688
      sig_bit.alpha = rgba_sig[3];
#line 689
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    } else
#line 682
    if ((int )rgba_sig[2] != 8) {
      {
#line 685
      sig_bit.red = rgba_sig[0];
#line 686
      sig_bit.green = rgba_sig[1];
#line 687
      sig_bit.blue = rgba_sig[2];
#line 688
      sig_bit.alpha = rgba_sig[3];
#line 689
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    } else
#line 682
    if ((int )rgba_sig[3] != 0) {
#line 682
      if ((int )rgba_sig[3] != 8) {
        {
#line 685
        sig_bit.red = rgba_sig[0];
#line 686
        sig_bit.green = rgba_sig[1];
#line 687
        sig_bit.blue = rgba_sig[2];
#line 688
        sig_bit.alpha = rgba_sig[3];
#line 689
        png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
        }
      }
    }
  }
#line 694
  if (palnum > 0U) {
#line 696
    i = 0U;
    {
#line 696
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 696
      if (! (i < palnum)) {
#line 696
        goto while_break___1;
      }
      {
#line 698
      tmp___7 = fread((void */* __restrict  */)(rgbq), (size_t )palsize, (size_t )1,
                      (FILE */* __restrict  */)stream);
      }
#line 698
      if (tmp___7 != 1UL) {
#line 699
        goto while_break___1;
      }
#line 700
      palette[i].red = rgbq[2];
#line 701
      palette[i].green = rgbq[1];
#line 702
      palette[i].blue = rgbq[0];
#line 696
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 704
    png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(palette),
                 (int )i);
    }
#line 705
    if (i != palnum) {
      {
#line 706
      png_error((png_const_structrp )png_ptr, "Error reading color palette in BMP file");
      }
    }
  }
  {
#line 710
  row_pointers = pngx_malloc_rows_extended(png_ptr, info_ptr, (pngx_alloc_size_t )rowsize,
                                           -1);
  }
#line 711
  if (topdown) {
#line 713
    begin_row = row_pointers;
#line 714
    end_row = row_pointers + height;
  } else {
#line 718
    begin_row = (row_pointers + height) - 1;
#line 719
    end_row = row_pointers - 1;
  }
#line 721
  if (skip > 0U) {
    {
#line 722
    fseek(stream, (long )skip, 1);
    }
  }
  {
#line 723
  y = bmp_read_rows(begin_row, end_row, (size_t )rowsize, compression, stream);
  }
#line 726
  if (pixdepth > 8U) {
    {
#line 727
    bmp_to_png_rows(row_pointers, width, height, pixdepth, rgba_sig, rgba_shift);
    }
  }
#line 731
  if (y != (size_t )height) {
    {
#line 732
    png_error((png_const_structrp )png_ptr, "Error reading BMP file");
    }
  }
#line 734
  return (1);
}
}
#line 16 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxmem.c"
png_bytepp pngx_malloc_rows(png_structp png_ptr , png_infop info_ptr , int filler ) 
{ 
  png_bytepp tmp ;

  {
  {
#line 19
  tmp = pngx_malloc_rows_extended(png_ptr, info_ptr, (pngx_alloc_size_t )0, filler);
  }
#line 19
  return (tmp);
}
}
#line 22 "/home/khheo/project/benchmark/optipng-0.7.6/src/pngxtern/pngxmem.c"
png_bytepp pngx_malloc_rows_extended(png_structp png_ptr , png_infop info_ptr , pngx_alloc_size_t min_row_size ,
                                     int filler ) 
{ 
  pngx_alloc_size_t row_size ;
  png_bytep row ;
  png_bytepp rows ;
  png_uint_32 height ;
  png_uint_32 i ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
  {
#line 32
  height = png_get_image_height((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 33
  if (height == 0U) {
    {
#line 34
    png_error((png_const_structrp )png_ptr, "Missing IHDR");
    }
  }
  {
#line 35
  row_size = png_get_rowbytes((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 37
  if (row_size == 0UL) {
    {
#line 38
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large image dimensions");
    }
  } else
#line 37
  if ((pngx_alloc_size_t )height > 0xffffffffffffffffUL / sizeof(png_bytep )) {
    {
#line 38
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large image dimensions");
    }
  }
#line 39
  if (row_size < min_row_size) {
#line 40
    row_size = min_row_size;
  }
  {
#line 43
  png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )64,
                0);
#line 46
  tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )height * sizeof(png_bytep ));
#line 46
  rows = (png_bytepp )tmp;
  }
#line 48
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
#line 49
    return ((png_bytepp )((void *)0));
  }
#line 52
  i = (png_uint_32 )0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < height)) {
#line 52
      goto while_break;
    }
    {
#line 54
    tmp___0 = png_malloc((png_const_structrp )png_ptr, row_size);
#line 54
    row = (png_bytep )tmp___0;
    }
#line 55
    if ((unsigned long )row == (unsigned long )((void *)0)) {
      {
#line 58
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 58
        if (! (i > 0U)) {
#line 58
          goto while_break___0;
        }
        {
#line 59
        i --;
#line 59
        png_free((png_const_structrp )png_ptr, (png_voidp )*(rows + i));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 60
      png_free((png_const_structrp )png_ptr, (png_voidp )rows);
      }
#line 61
      return ((png_bytepp )((void *)0));
    }
#line 63
    if (filler >= 0) {
      {
#line 64
      memset((void *)row, filler, row_size);
      }
    }
#line 65
    *(rows + i) = row;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  png_set_rows((png_const_structrp )png_ptr, (png_inforp )info_ptr, rows);
  }
#line 70
  return (rows);
}
}
#line 28 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.h"
int opng_validate_image(png_structp png_ptr , png_infop info_ptr ) ;
#line 55
png_uint_32 opng_reduce_image(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 46 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
int opng_validate_image(png_structp png_ptr , png_infop info_ptr ) 
{ 
  png_byte tmp ;
  png_uint_32 tmp___0 ;
  png_byte tmp___1 ;
  png_uint_32 tmp___2 ;

  {
  {
#line 52
  tmp = png_get_bit_depth((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 52
  if ((int )tmp == 0) {
#line 53
    return (0);
  }
  {
#line 56
  tmp___1 = png_get_color_type((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 56
  if ((int )tmp___1 & 1) {
    {
#line 58
    tmp___0 = png_get_valid((png_const_structrp )png_ptr, (png_const_inforp )info_ptr,
                            (png_uint_32 )8);
    }
#line 58
    if (! tmp___0) {
#line 59
      return (0);
    }
  }
  {
#line 63
  tmp___2 = png_get_valid((png_const_structrp )png_ptr, (png_const_inforp )info_ptr,
                          (png_uint_32 )32768);
  }
#line 63
  if (! tmp___2) {
#line 64
    return (0);
  }
#line 66
  return (1);
}
}
#line 100 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static int opng_insert_palette_entry(png_colorp palette , int *num_palette , png_bytep trans_alpha ,
                                     int *num_trans , int max_tuples , unsigned int red ,
                                     unsigned int green , unsigned int blue , unsigned int alpha ,
                                     int *index___0 ) 
{ 
  int low ;
  int high ;
  int mid ;
  int cmp ;
  int i ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 109
  if (*num_palette >= 0) {
#line 109
    if (! (*num_palette <= max_tuples)) {
      {
#line 109
      __assert_fail("*num_palette >= 0 && *num_palette <= max_tuples", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    109U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 109
    __assert_fail("*num_palette >= 0 && *num_palette <= max_tuples", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  109U, "opng_insert_palette_entry");
    }
  }
#line 110
  if (*num_trans >= 0) {
#line 110
    if (! (*num_trans <= *num_palette)) {
      {
#line 110
      __assert_fail("*num_trans >= 0 && *num_trans <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    110U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 110
    __assert_fail("*num_trans >= 0 && *num_trans <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  110U, "opng_insert_palette_entry");
    }
  }
#line 112
  if (alpha < 255U) {
#line 115
    low = 0;
#line 116
    high = *num_trans - 1;
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! (low <= high)) {
#line 117
        goto while_break;
      }
#line 119
      mid = (low + high) / 2;
#line 120
      if ((int )alpha != (int )*(trans_alpha + mid)) {
#line 120
        cmp = (int )alpha - (int )*(trans_alpha + mid);
      } else {
#line 120
        if ((int )red != (int )(palette + mid)->red) {
#line 120
          tmp___2 = (int )red - (int )(palette + mid)->red;
        } else {
#line 120
          if ((int )green != (int )(palette + mid)->green) {
#line 120
            tmp___1 = (int )green - (int )(palette + mid)->green;
          } else {
#line 120
            tmp___1 = (int )blue - (int )(palette + mid)->blue;
          }
#line 120
          tmp___2 = tmp___1;
        }
#line 120
        cmp = tmp___2;
      }
#line 123
      if (cmp < 0) {
#line 124
        high = mid - 1;
      } else
#line 125
      if (cmp > 0) {
#line 126
        low = mid + 1;
      } else {
#line 129
        *index___0 = mid;
#line 130
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 137
    low = *num_trans;
#line 138
    high = *num_palette - 1;
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 139
      if (! (low <= high)) {
#line 139
        goto while_break___0;
      }
#line 141
      mid = (low + high) / 2;
#line 142
      if ((int )red != (int )(palette + mid)->red) {
#line 142
        cmp = (int )red - (int )(palette + mid)->red;
      } else {
#line 142
        if ((int )green != (int )(palette + mid)->green) {
#line 142
          tmp___3 = (int )green - (int )(palette + mid)->green;
        } else {
#line 142
          tmp___3 = (int )blue - (int )(palette + mid)->blue;
        }
#line 142
        cmp = tmp___3;
      }
#line 144
      if (cmp < 0) {
#line 145
        high = mid - 1;
      } else
#line 146
      if (cmp > 0) {
#line 147
        low = mid + 1;
      } else {
#line 150
        *index___0 = mid;
#line 151
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 155
  if (alpha > 255U) {
#line 159
    i = 0;
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (i < *num_trans)) {
#line 159
        goto while_break___1;
      }
#line 161
      if ((int )red != (int )(palette + i)->red) {
#line 161
        cmp = (int )red - (int )(palette + i)->red;
      } else {
#line 161
        if ((int )green != (int )(palette + i)->green) {
#line 161
          tmp___4 = (int )green - (int )(palette + i)->green;
        } else {
#line 161
          tmp___4 = (int )blue - (int )(palette + i)->blue;
        }
#line 161
        cmp = tmp___4;
      }
#line 163
      if (cmp == 0) {
#line 165
        *index___0 = i;
#line 166
        return (0);
      }
#line 159
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 172
  if (*num_palette >= max_tuples) {
#line 174
    tmp___6 = -1;
#line 174
    *index___0 = tmp___6;
#line 174
    tmp___5 = tmp___6;
#line 174
    *num_trans = tmp___5;
#line 174
    *num_palette = tmp___5;
#line 175
    return (-1);
  }
#line 179
  if (low >= 0) {
#line 179
    if (! (low <= *num_palette)) {
      {
#line 179
      __assert_fail("low >= 0 && low <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    179U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 179
    __assert_fail("low >= 0 && low <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  179U, "opng_insert_palette_entry");
    }
  }
#line 180
  i = *num_palette;
  {
#line 180
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 180
    if (! (i > low)) {
#line 180
      goto while_break___2;
    }
#line 181
    *(palette + i) = *(palette + (i - 1));
#line 180
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 182
  (palette + low)->red = (png_byte )red;
#line 183
  (palette + low)->green = (png_byte )green;
#line 184
  (palette + low)->blue = (png_byte )blue;
#line 185
  (*num_palette) ++;
#line 186
  if (alpha < 255U) {
#line 188
    if (! (low <= *num_trans)) {
      {
#line 188
      __assert_fail("low <= *num_trans", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    188U, "opng_insert_palette_entry");
      }
    }
#line 189
    i = *num_trans;
    {
#line 189
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 189
      if (! (i > low)) {
#line 189
        goto while_break___3;
      }
#line 190
      *(trans_alpha + i) = *(trans_alpha + (i - 1));
#line 189
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 191
    *(trans_alpha + low) = (png_byte )alpha;
#line 192
    (*num_trans) ++;
  }
#line 194
  *index___0 = low;
#line 195
  return (1);
}
}
#line 203 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static void opng_realloc_PLTE(png_structp png_ptr , png_infop info_ptr , int num_palette ) 
{ 
  png_color buffer___0[256] ;
  png_colorp palette ;
  int src_num_palette ;

  {
#line 212
  if (! (num_palette > 0)) {
    {
#line 212
    __assert_fail("num_palette > 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  212U, "opng_realloc_PLTE");
    }
  }
  {
#line 213
  src_num_palette = 0;
#line 214
  png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette, & src_num_palette);
  }
#line 215
  if (num_palette == src_num_palette) {
#line 216
    return;
  }
  {
#line 217
  memcpy((void */* __restrict  */)(buffer___0), (void const   */* __restrict  */)palette,
         (unsigned long )num_palette * sizeof(png_color ));
  }
#line 218
  if (num_palette > src_num_palette) {
    {
#line 219
    memset((void *)(buffer___0 + src_num_palette), 0, (unsigned long )(num_palette - src_num_palette) * sizeof(png_color ));
    }
  }
  {
#line 221
  png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(buffer___0),
               num_palette);
  }
#line 222
  return;
}
}
#line 229 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static void opng_realloc_tRNS(png_structp png_ptr , png_infop info_ptr , int num_trans ) 
{ 
  png_byte buffer___0[256] ;
  png_bytep trans_alpha ;
  int src_num_trans ;

  {
#line 238
  if (! (num_trans > 0)) {
    {
#line 238
    __assert_fail("num_trans > 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  238U, "opng_realloc_tRNS");
    }
  }
  {
#line 239
  src_num_trans = 0;
#line 240
  png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & trans_alpha,
               & src_num_trans, (png_color_16p *)((void *)0));
  }
#line 241
  if (num_trans == src_num_trans) {
#line 242
    return;
  }
  {
#line 243
  memcpy((void */* __restrict  */)(buffer___0), (void const   */* __restrict  */)trans_alpha,
         (size_t )num_trans);
  }
#line 244
  if (num_trans > src_num_trans) {
    {
#line 245
    memset((void *)(buffer___0 + src_num_trans), 0, (size_t )(num_trans - src_num_trans));
    }
  }
  {
#line 246
  png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )(buffer___0),
               num_trans, (png_const_color_16p )((void *)0));
  }
#line 247
  return;
}
}
#line 252 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static void opng_get_alpha_row(png_row_infop row_info_ptr , png_color_16p trans_color ,
                               png_bytep row , png_bytep alpha_row ) 
{ 
  png_bytep sample_ptr ;
  png_uint_32 width ;
  int color_type ;
  int bit_depth ;
  int channels ;
  png_byte trans_red ;
  png_byte trans_green ;
  png_byte trans_blue ;
  png_byte trans_gray ;
  png_uint_32 i ;
  int tmp___2 ;
  int tmp___5 ;

  {
#line 262
  width = row_info_ptr->width;
#line 263
  color_type = (int )row_info_ptr->color_type;
#line 264
  bit_depth = (int )row_info_ptr->bit_depth;
#line 265
  channels = (int )row_info_ptr->channels;
#line 267
  if (! (! (color_type & 1))) {
    {
#line 267
    __assert_fail("!(color_type & 1)", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  267U, "opng_get_alpha_row");
    }
  }
#line 268
  if (! (bit_depth == 8)) {
    {
#line 268
    __assert_fail("bit_depth == 8", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  268U, "opng_get_alpha_row");
    }
  }
#line 270
  if (! (color_type & 4)) {
#line 272
    if ((unsigned long )trans_color == (unsigned long )((void *)0)) {
      {
#line 275
      memset((void *)alpha_row, 255, (size_t )width);
      }
#line 276
      return;
    }
#line 278
    if (color_type == 2) {
#line 280
      if (! (channels == 3)) {
        {
#line 280
        __assert_fail("channels == 3", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                      280U, "opng_get_alpha_row");
        }
      }
#line 281
      trans_red = (png_byte )trans_color->red;
#line 282
      trans_green = (png_byte )trans_color->green;
#line 283
      trans_blue = (png_byte )trans_color->blue;
#line 284
      sample_ptr = row;
#line 285
      i = (png_uint_32 )0;
      {
#line 285
      while (1) {
        while_continue: /* CIL Label */ ;
#line 285
        if (! (i < width)) {
#line 285
          goto while_break;
        }
#line 286
        if ((int )*(sample_ptr + 0) == (int )trans_red) {
#line 286
          if ((int )*(sample_ptr + 1) == (int )trans_green) {
#line 286
            if ((int )*(sample_ptr + 2) == (int )trans_blue) {
#line 286
              tmp___2 = 0;
            } else {
#line 286
              tmp___2 = 255;
            }
          } else {
#line 286
            tmp___2 = 255;
          }
        } else {
#line 286
          tmp___2 = 255;
        }
#line 286
        *(alpha_row + i) = (png_byte )tmp___2;
#line 285
        i ++;
#line 285
        sample_ptr += 3;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 293
      if (! (color_type == 0)) {
        {
#line 293
        __assert_fail("color_type == 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                      293U, "opng_get_alpha_row");
        }
      }
#line 294
      if (! (channels == 1)) {
        {
#line 294
        __assert_fail("channels == 1", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                      294U, "opng_get_alpha_row");
        }
      }
#line 295
      trans_gray = (png_byte )trans_color->gray;
#line 296
      i = (png_uint_32 )0;
      {
#line 296
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 296
        if (! (i < width)) {
#line 296
          goto while_break___0;
        }
#line 297
        if ((int )*(row + i) == (int )trans_gray) {
#line 297
          tmp___5 = 0;
        } else {
#line 297
          tmp___5 = 255;
        }
#line 297
        *(alpha_row + i) = (png_byte )tmp___5;
#line 296
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 299
    return;
  }
#line 303
  if (! (channels > 1)) {
    {
#line 303
    __assert_fail("channels > 1", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  303U, "opng_get_alpha_row");
    }
  }
#line 304
  sample_ptr = row + (channels - 1);
#line 305
  i = (png_uint_32 )0;
  {
#line 305
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 305
    if (! (i < width)) {
#line 305
      goto while_break___1;
    }
#line 306
    *alpha_row = *sample_ptr;
#line 305
    i ++;
#line 305
    sample_ptr += channels;
#line 305
    alpha_row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 314 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static png_uint_32 opng_analyze_bits(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep component_ptr ;
  png_uint_32 height ;
  png_uint_32 width ;
  int bit_depth ;
  int color_type ;
  int byte_depth ;
  int channels ;
  int sample_size ;
  int offset_alpha ;
  png_color_16p background ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_byte tmp ;
  png_uint_32 tmp___0 ;

  {
  {
#line 329
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & bit_depth, & color_type, (int *)((void *)0), (int *)((void *)0),
               (int *)((void *)0));
  }
#line 331
  if (bit_depth < 8) {
#line 332
    return ((png_uint_32 )0);
  }
#line 333
  if (color_type & 1) {
#line 334
    return ((png_uint_32 )0);
  }
  {
#line 336
  byte_depth = bit_depth / 8;
#line 337
  tmp = png_get_channels((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 337
  channels = (int )tmp;
#line 338
  sample_size = channels * byte_depth;
#line 339
  offset_alpha = (channels - 1) * byte_depth;
#line 342
  reductions &= 13U;
  }
#line 344
  if (bit_depth <= 8) {
#line 345
    reductions &= 4294967294U;
  }
#line 346
  if (! (color_type & 2)) {
#line 347
    reductions &= 4294967291U;
  }
#line 348
  if (! (color_type & 4)) {
#line 349
    reductions &= 4294967287U;
  }
  {
#line 353
  tmp___0 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 353
  if (tmp___0) {
#line 355
    if (reductions & 1U) {
#line 357
      if ((int )background->red % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      } else
#line 357
      if ((int )background->green % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      } else
#line 357
      if ((int )background->blue % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      } else
#line 357
      if ((int )background->gray % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      }
    }
#line 363
    if (reductions & 4U) {
#line 365
      if ((int )background->red != (int )background->green) {
#line 367
        reductions &= 4294967291U;
      } else
#line 365
      if ((int )background->red != (int )background->blue) {
#line 367
        reductions &= 4294967291U;
      }
    }
  }
  {
#line 373
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 374
  i = (png_uint_32 )0;
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < height)) {
#line 374
      goto while_break;
    }
#line 376
    if (reductions == 0U) {
#line 377
      return ((png_uint_32 )0);
    }
#line 380
    if (reductions & 1U) {
#line 382
      component_ptr = *row_ptr;
#line 383
      j = (png_uint_32 )0;
      {
#line 383
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 383
        if (! (j < (png_uint_32 )channels * width)) {
#line 383
          goto while_break___0;
        }
#line 385
        if ((int )*(component_ptr + 0) != (int )*(component_ptr + 1)) {
#line 387
          reductions &= 4294967294U;
#line 388
          goto while_break___0;
        }
#line 383
        j ++;
#line 383
        component_ptr += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 393
    if (bit_depth == 8) {
#line 396
      if (reductions & 4U) {
#line 398
        component_ptr = *row_ptr;
#line 399
        j = (png_uint_32 )0;
        {
#line 399
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 399
          if (! (j < width)) {
#line 399
            goto while_break___1;
          }
#line 401
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 1)) {
#line 404
            reductions &= 4294967291U;
#line 405
            goto while_break___1;
          } else
#line 401
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 2)) {
#line 404
            reductions &= 4294967291U;
#line 405
            goto while_break___1;
          }
#line 399
          j ++;
#line 399
          component_ptr += sample_size;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 411
      if (reductions & 8U) {
#line 413
        component_ptr = *row_ptr + offset_alpha;
#line 414
        j = (png_uint_32 )0;
        {
#line 414
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 414
          if (! (j < width)) {
#line 414
            goto while_break___2;
          }
#line 416
          if ((int )*(component_ptr + 0) != 255) {
#line 418
            reductions &= 4294967287U;
#line 419
            goto while_break___2;
          }
#line 414
          j ++;
#line 414
          component_ptr += sample_size;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 427
      if (reductions & 4U) {
#line 429
        component_ptr = *row_ptr;
#line 430
        j = (png_uint_32 )0;
        {
#line 430
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 430
          if (! (j < width)) {
#line 430
            goto while_break___3;
          }
#line 432
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 2)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          } else
#line 432
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 4)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          } else
#line 432
          if ((int )*(component_ptr + 1) != (int )*(component_ptr + 3)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          } else
#line 432
          if ((int )*(component_ptr + 1) != (int )*(component_ptr + 5)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          }
#line 430
          j ++;
#line 430
          component_ptr += sample_size;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 444
      if (reductions & 8U) {
#line 446
        component_ptr = *row_ptr + offset_alpha;
#line 447
        j = (png_uint_32 )0;
        {
#line 447
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 447
          if (! (j < width)) {
#line 447
            goto while_break___4;
          }
#line 449
          if ((int )*(component_ptr + 0) != 255) {
#line 451
            reductions &= 4294967287U;
#line 452
            goto while_break___4;
          } else
#line 449
          if ((int )*(component_ptr + 1) != 255) {
#line 451
            reductions &= 4294967287U;
#line 452
            goto while_break___4;
          }
#line 447
          j ++;
#line 447
          component_ptr += sample_size;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 374
    i ++;
#line 374
    row_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  return (reductions);
}
}
#line 470 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_bits(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep src_ptr ;
  png_bytep dest_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int src_bit_depth ;
  int dest_bit_depth ;
  int src_byte_depth ;
  int dest_byte_depth ;
  int src_color_type ;
  int dest_color_type ;
  int src_channels ;
  int dest_channels ;
  int src_sample_size ;
  int dest_sample_size ;
  int tran_tbl[8] ;
  png_color_16p trans_color ;
  png_color_16p background ;
  png_color_8p sig_bits ;
  png_uint_32 i ;
  png_uint_32 j ;
  int k ;
  png_byte tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  png_uint_32 tmp___7 ;
  png_uint_32 tmp___8 ;
  png_byte max_sig_bits ;
  png_uint_32 tmp___9 ;

  {
  {
#line 497
  reductions = opng_analyze_bits(png_ptr, info_ptr, reductions);
  }
#line 498
  if (reductions == 0U) {
#line 499
    return ((png_uint_32 )0);
  }
  {
#line 501
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & src_bit_depth, & src_color_type, & interlace_type, & compression_type,
               & filter_type);
  }
#line 506
  if (! (src_bit_depth >= 8)) {
    {
#line 506
    __assert_fail("src_bit_depth >= 8", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  506U, "opng_reduce_bits");
    }
  }
#line 507
  if (reductions & 1U) {
#line 509
    if (! (src_bit_depth == 16)) {
      {
#line 509
      __assert_fail("src_bit_depth == 16", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    509U, "opng_reduce_bits");
      }
    }
#line 510
    dest_bit_depth = 8;
  } else {
#line 513
    dest_bit_depth = src_bit_depth;
  }
#line 515
  src_byte_depth = src_bit_depth / 8;
#line 516
  dest_byte_depth = dest_bit_depth / 8;
#line 518
  dest_color_type = src_color_type;
#line 519
  if (reductions & 4U) {
#line 521
    if (! (src_color_type & 2)) {
      {
#line 521
      __assert_fail("src_color_type & 2", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    521U, "opng_reduce_bits");
      }
    }
#line 522
    dest_color_type &= -3;
  }
#line 524
  if (reductions & 8U) {
#line 526
    if (! (src_color_type & 4)) {
      {
#line 526
      __assert_fail("src_color_type & 4", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    526U, "opng_reduce_bits");
      }
    }
#line 527
    dest_color_type &= -5;
  }
  {
#line 530
  tmp___3 = png_get_channels((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 530
  src_channels = (int )tmp___3;
  }
#line 531
  if (dest_color_type & 2) {
#line 531
    tmp___4 = 3;
  } else {
#line 531
    tmp___4 = 1;
  }
#line 531
  if (dest_color_type & 4) {
#line 531
    tmp___5 = 1;
  } else {
#line 531
    tmp___5 = 0;
  }
#line 531
  dest_channels = tmp___4 + tmp___5;
#line 535
  src_sample_size = src_channels * src_byte_depth;
#line 536
  dest_sample_size = dest_channels * dest_byte_depth;
#line 539
  k = 0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (k < 4 * dest_byte_depth)) {
#line 539
      goto while_break;
    }
#line 540
    tran_tbl[k] = (k * src_bit_depth) / dest_bit_depth;
#line 539
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  if (reductions & 4U) {
#line 542
    if (dest_color_type & 4) {
#line 545
      tran_tbl[dest_byte_depth] = tran_tbl[3 * dest_byte_depth];
#line 546
      if (dest_byte_depth == 2) {
#line 547
        tran_tbl[dest_byte_depth + 1] = tran_tbl[3 * dest_byte_depth + 1];
      }
    }
  }
#line 551
  if (! (src_sample_size > dest_sample_size)) {
    {
#line 551
    __assert_fail("src_sample_size > dest_sample_size", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  551U, "opng_reduce_bits");
    }
  }
  {
#line 552
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 553
  i = (png_uint_32 )0;
  }
  {
#line 553
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 553
    if (! (i < height)) {
#line 553
      goto while_break___0;
    }
#line 555
    dest_ptr = *row_ptr;
#line 555
    src_ptr = dest_ptr;
#line 556
    j = (png_uint_32 )0;
    {
#line 556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 556
      if (! (j < width)) {
#line 556
        goto while_break___1;
      }
#line 558
      k = 0;
      {
#line 558
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 558
        if (! (k < dest_sample_size)) {
#line 558
          goto while_break___2;
        }
#line 559
        *(dest_ptr + k) = *(src_ptr + tran_tbl[k]);
#line 558
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 560
      src_ptr += src_sample_size;
#line 561
      dest_ptr += dest_sample_size;
#line 556
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 553
    i ++;
#line 553
    row_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 566
  tmp___7 = png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_bytep *)((void *)0),
                         (int *)((void *)0), & trans_color);
  }
#line 566
  if (tmp___7) {
#line 568
    if (reductions & 1U) {
#line 570
      if ((int )trans_color->red % 257 == 0) {
#line 570
        if ((int )trans_color->green % 257 == 0) {
#line 570
          if ((int )trans_color->blue % 257 == 0) {
#line 570
            if ((int )trans_color->gray % 257 == 0) {
#line 575
              trans_color->red = (png_uint_16 )((int )trans_color->red & 255);
#line 576
              trans_color->green = (png_uint_16 )((int )trans_color->green & 255);
#line 577
              trans_color->blue = (png_uint_16 )((int )trans_color->blue & 255);
#line 578
              trans_color->gray = (png_uint_16 )((int )trans_color->gray & 255);
            } else {
              {
#line 583
              png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )8192,
                            -1);
#line 584
              png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr,
                              16);
              }
            }
          } else {
            {
#line 583
            png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )8192,
                          -1);
#line 584
            png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
            }
          }
        } else {
          {
#line 583
          png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )8192,
                        -1);
#line 584
          png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
          }
        }
      } else {
        {
#line 583
        png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )8192,
                      -1);
#line 584
        png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
        }
      }
    }
#line 587
    if (reductions & 4U) {
#line 589
      if ((int )trans_color->red == (int )trans_color->green) {
#line 591
        trans_color->gray = trans_color->red;
      } else
#line 589
      if ((int )trans_color->red == (int )trans_color->blue) {
#line 591
        trans_color->gray = trans_color->red;
      } else {
        {
#line 595
        png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )8192,
                      -1);
#line 596
        png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
        }
      }
    }
  }
  {
#line 601
  tmp___8 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 601
  if (tmp___8) {
#line 603
    if (reductions & 1U) {
#line 605
      background->red = (png_uint_16 )((int )background->red & 255);
#line 606
      background->green = (png_uint_16 )((int )background->green & 255);
#line 607
      background->blue = (png_uint_16 )((int )background->blue & 255);
#line 608
      background->gray = (png_uint_16 )((int )background->gray & 255);
    }
#line 610
    if (reductions & 4U) {
#line 611
      background->gray = background->red;
    }
  }
  {
#line 615
  tmp___9 = png_get_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, & sig_bits);
  }
#line 615
  if (tmp___9) {
#line 617
    if (reductions & 1U) {
#line 619
      if ((int )sig_bits->red > 8) {
#line 620
        sig_bits->red = (png_byte )8;
      }
#line 621
      if ((int )sig_bits->green > 8) {
#line 622
        sig_bits->green = (png_byte )8;
      }
#line 623
      if ((int )sig_bits->blue > 8) {
#line 624
        sig_bits->blue = (png_byte )8;
      }
#line 625
      if ((int )sig_bits->gray > 8) {
#line 626
        sig_bits->gray = (png_byte )8;
      }
#line 627
      if ((int )sig_bits->alpha > 8) {
#line 628
        sig_bits->alpha = (png_byte )8;
      }
    }
#line 630
    if (reductions & 4U) {
#line 632
      max_sig_bits = sig_bits->red;
#line 633
      if ((int )max_sig_bits < (int )sig_bits->green) {
#line 634
        max_sig_bits = sig_bits->green;
      }
#line 635
      if ((int )max_sig_bits < (int )sig_bits->blue) {
#line 636
        max_sig_bits = sig_bits->blue;
      }
#line 637
      sig_bits->gray = max_sig_bits;
    }
  }
  {
#line 643
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               dest_bit_depth, dest_color_type, interlace_type, compression_type,
               filter_type);
  }
#line 647
  return (reductions);
}
}
#line 655 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_palette_bits(png_structp png_ptr , png_infop info_ptr ,
                                            png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep src_sample_ptr ;
  png_bytep dest_sample_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int src_bit_depth ;
  int dest_bit_depth ;
  unsigned int src_mask_init ;
  unsigned int src_mask ;
  unsigned int src_shift ;
  unsigned int dest_shift ;
  unsigned int sample ;
  unsigned int dest_buf ;
  png_colorp palette ;
  int num_palette ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_uint_32 tmp ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;

  {
#line 673
  if (! (reductions & 2U)) {
#line 674
    return ((png_uint_32 )0);
  }
  {
#line 675
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & src_bit_depth, & color_type, & interlace_type, & compression_type,
               & filter_type);
  }
#line 677
  if (color_type != 3) {
#line 678
    return ((png_uint_32 )0);
  }
  {
#line 679
  tmp = png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette,
                     & num_palette);
  }
#line 679
  if (! tmp) {
#line 680
    num_palette = 0;
  }
#line 683
  if (num_palette > 16) {
#line 684
    return ((png_uint_32 )0);
  } else
#line 685
  if (num_palette > 4) {
#line 686
    dest_bit_depth = 4;
  } else
#line 687
  if (num_palette > 2) {
#line 688
    dest_bit_depth = 2;
  } else {
#line 691
    if (! (num_palette > 0)) {
      {
#line 691
      __assert_fail("num_palette > 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    691U, "opng_reduce_palette_bits");
      }
    }
#line 692
    dest_bit_depth = 1;
  }
#line 695
  if (src_bit_depth <= dest_bit_depth) {
#line 697
    if (! (src_bit_depth == dest_bit_depth)) {
      {
#line 697
      __assert_fail("src_bit_depth == dest_bit_depth", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    697U, "opng_reduce_palette_bits");
      }
    }
#line 698
    return ((png_uint_32 )0);
  }
  {
#line 702
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 703
  if (src_bit_depth == 8) {
#line 705
    i = (png_uint_32 )0;
    {
#line 705
    while (1) {
      while_continue: /* CIL Label */ ;
#line 705
      if (! (i < height)) {
#line 705
        goto while_break;
      }
#line 707
      dest_sample_ptr = *row_ptr;
#line 707
      src_sample_ptr = dest_sample_ptr;
#line 708
      dest_shift = 8U;
#line 709
      dest_buf = 0U;
#line 710
      j = (png_uint_32 )0;
      {
#line 710
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 710
        if (! (j < width)) {
#line 710
          goto while_break___0;
        }
#line 712
        dest_shift -= (unsigned int )dest_bit_depth;
#line 713
        if (dest_shift > 0U) {
#line 714
          dest_buf |= (unsigned int )((int )*src_sample_ptr << dest_shift);
        } else {
#line 717
          tmp___2 = dest_sample_ptr;
#line 717
          dest_sample_ptr ++;
#line 717
          *tmp___2 = (png_byte )(dest_buf | (unsigned int )*src_sample_ptr);
#line 718
          dest_shift = 8U;
#line 719
          dest_buf = 0U;
        }
#line 721
        src_sample_ptr ++;
#line 710
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 723
      if (dest_shift != 0U) {
#line 724
        *dest_sample_ptr = (png_byte )dest_buf;
      }
#line 705
      i ++;
#line 705
      row_ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 729
    src_mask_init = (unsigned int )((1 << (8 + src_bit_depth)) - (1 << 8));
#line 730
    i = (png_uint_32 )0;
    {
#line 730
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 730
      if (! (i < height)) {
#line 730
        goto while_break___1;
      }
#line 732
      dest_sample_ptr = *row_ptr;
#line 732
      src_sample_ptr = dest_sample_ptr;
#line 733
      dest_shift = 8U;
#line 733
      src_shift = dest_shift;
#line 734
      src_mask = src_mask_init;
#line 735
      dest_buf = 0U;
#line 736
      j = (png_uint_32 )0;
      {
#line 736
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 736
        if (! (j < width)) {
#line 736
          goto while_break___2;
        }
#line 738
        src_shift -= (unsigned int )src_bit_depth;
#line 739
        src_mask >>= src_bit_depth;
#line 740
        sample = ((unsigned int )*src_sample_ptr & src_mask) >> src_shift;
#line 741
        dest_shift -= (unsigned int )dest_bit_depth;
#line 742
        if (dest_shift > 0U) {
#line 743
          dest_buf |= sample << dest_shift;
        } else {
#line 746
          tmp___3 = dest_sample_ptr;
#line 746
          dest_sample_ptr ++;
#line 746
          *tmp___3 = (png_byte )(dest_buf | sample);
#line 747
          dest_shift = 8U;
#line 748
          dest_buf = 0U;
        }
#line 750
        if (src_shift == 0U) {
#line 752
          src_shift = 8U;
#line 753
          src_mask = src_mask_init;
#line 754
          src_sample_ptr ++;
        }
#line 736
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 757
      if (dest_shift != 0U) {
#line 758
        *dest_sample_ptr = (png_byte )dest_buf;
      }
#line 730
      i ++;
#line 730
      row_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 763
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               dest_bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 765
  return ((png_uint_32 )2);
}
}
#line 774 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_to_palette(png_structp png_ptr , png_infop info_ptr ,
                                          png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  png_row_info row_info ;
  png_bytepp row_ptr ;
  png_bytep sample_ptr ;
  png_bytep alpha_row ;
  png_uint_32 height ;
  png_uint_32 width ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int src_bit_depth ;
  int dest_bit_depth ;
  int channels ;
  png_color palette[256] ;
  png_byte trans_alpha[256] ;
  png_color_16p trans_color ;
  int num_palette ;
  int num_trans ;
  int index___0 ;
  unsigned int gray ;
  unsigned int red ;
  unsigned int green ;
  unsigned int blue ;
  unsigned int alpha ;
  unsigned int prev_gray ;
  unsigned int prev_red ;
  unsigned int prev_green ;
  unsigned int prev_blue ;
  unsigned int prev_alpha ;
  png_color_16p background ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_byte tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  png_uint_32 tmp___6 ;
  int tmp___9 ;
  int tmp___11 ;
  png_uint_32 tmp___13 ;

  {
  {
#line 798
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & src_bit_depth, & color_type, & interlace_type, & compression_type,
               & filter_type);
  }
#line 800
  if (src_bit_depth != 8) {
#line 801
    return ((png_uint_32 )0);
  }
#line 802
  if (! (! (color_type & 1))) {
    {
#line 802
    __assert_fail("!(color_type & 1)", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  802U, "opng_reduce_to_palette");
    }
  }
  {
#line 804
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 805
  tmp___0 = png_get_channels((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 805
  channels = (int )tmp___0;
#line 806
  tmp___1 = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )width);
#line 806
  alpha_row = (png_bytep )tmp___1;
#line 808
  row_info.width = width;
#line 809
  row_info.rowbytes = (png_size_t )0;
#line 810
  row_info.color_type = (png_byte )color_type;
#line 811
  row_info.bit_depth = (png_byte )src_bit_depth;
#line 812
  row_info.channels = (png_byte )channels;
#line 813
  row_info.pixel_depth = (png_byte )0;
#line 816
  num_trans = 0;
#line 816
  num_palette = num_trans;
#line 817
  trans_color = (png_color_16p )((void *)0);
#line 818
  png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_bytep *)((void *)0),
               (int *)((void *)0), & trans_color);
#line 819
  prev_alpha = 256U;
#line 819
  prev_blue = prev_alpha;
#line 819
  prev_green = prev_blue;
#line 819
  prev_red = prev_green;
#line 819
  prev_gray = prev_red;
#line 820
  i = (png_uint_32 )0;
  }
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (i < height)) {
#line 820
      goto while_break;
    }
    {
#line 822
    sample_ptr = *row_ptr;
#line 823
    opng_get_alpha_row(& row_info, trans_color, *row_ptr, alpha_row);
    }
#line 824
    if (color_type & 2) {
#line 826
      j = (png_uint_32 )0;
      {
#line 826
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 826
        if (! (j < width)) {
#line 826
          goto while_break___0;
        }
#line 828
        red = (unsigned int )*(sample_ptr + 0);
#line 829
        green = (unsigned int )*(sample_ptr + 1);
#line 830
        blue = (unsigned int )*(sample_ptr + 2);
#line 831
        alpha = (unsigned int )*(alpha_row + j);
#line 833
        if (red != prev_red) {
#line 833
          goto _L;
        } else
#line 833
        if (green != prev_green) {
#line 833
          goto _L;
        } else
#line 833
        if (blue != prev_blue) {
#line 833
          goto _L;
        } else
#line 833
        if (alpha != prev_alpha) {
          _L: /* CIL Label */ 
          {
#line 836
          prev_red = red;
#line 837
          prev_green = green;
#line 838
          prev_blue = blue;
#line 839
          prev_alpha = alpha;
#line 840
          tmp___3 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                              & num_trans, 256, red, green, blue,
                                              alpha, & index___0);
          }
#line 840
          if (tmp___3 < 0) {
#line 844
            if (! (num_palette < 0)) {
              {
#line 844
              __assert_fail("num_palette < 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                            844U, "opng_reduce_to_palette");
              }
            }
#line 845
            i = height;
#line 846
            goto while_break___0;
          }
        }
#line 826
        j ++;
#line 826
        sample_ptr += channels;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 853
      j = (png_uint_32 )0;
      {
#line 853
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 853
        if (! (j < width)) {
#line 853
          goto while_break___1;
        }
#line 855
        gray = (unsigned int )*(sample_ptr + 0);
#line 856
        alpha = (unsigned int )*(alpha_row + j);
#line 858
        if (gray != prev_gray) {
#line 858
          goto _L___0;
        } else
#line 858
        if (alpha != prev_alpha) {
          _L___0: /* CIL Label */ 
          {
#line 860
          prev_gray = gray;
#line 861
          prev_alpha = alpha;
#line 862
          tmp___5 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                              & num_trans, 256, gray, gray, gray,
                                              alpha, & index___0);
          }
#line 862
          if (tmp___5 < 0) {
#line 866
            if (! (num_palette < 0)) {
              {
#line 866
              __assert_fail("num_palette < 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                            866U, "opng_reduce_to_palette");
              }
            }
#line 867
            i = height;
#line 868
            goto while_break___1;
          }
        }
#line 853
        j ++;
#line 853
        sample_ptr += channels;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 820
    i ++;
#line 820
    row_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  if (num_palette >= 0) {
    {
#line 875
    tmp___6 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
    }
#line 875
    if (tmp___6) {
#line 878
      if (color_type & 2) {
#line 880
        red = (unsigned int )background->red;
#line 881
        green = (unsigned int )background->green;
#line 882
        blue = (unsigned int )background->blue;
      } else {
#line 885
        blue = (unsigned int )background->gray;
#line 885
        green = blue;
#line 885
        red = green;
      }
      {
#line 886
      opng_insert_palette_entry(palette, & num_palette, trans_alpha, & num_trans,
                                256, red, green, blue, 256U, & index___0);
      }
#line 889
      if (index___0 >= 0) {
#line 890
        background->index = (png_byte )index___0;
      }
    }
  }
#line 903
  if (num_palette >= 0) {
#line 905
    if (num_palette > 0) {
#line 905
      if (! (num_palette <= 256)) {
        {
#line 905
        __assert_fail("num_palette > 0 && num_palette <= 256", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                      905U, "opng_reduce_to_palette");
        }
      }
    } else {
      {
#line 905
      __assert_fail("num_palette > 0 && num_palette <= 256", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    905U, "opng_reduce_to_palette");
      }
    }
#line 906
    if (num_trans >= 0) {
#line 906
      if (! (num_trans <= num_palette)) {
        {
#line 906
        __assert_fail("num_trans >= 0 && num_trans <= num_palette", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                      906U, "opng_reduce_to_palette");
        }
      }
    } else {
      {
#line 906
      __assert_fail("num_trans >= 0 && num_trans <= num_palette", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    906U, "opng_reduce_to_palette");
      }
    }
#line 907
    if (num_palette <= 2) {
#line 908
      dest_bit_depth = 1;
    } else
#line 909
    if (num_palette <= 4) {
#line 910
      dest_bit_depth = 2;
    } else
#line 911
    if (num_palette <= 16) {
#line 912
      dest_bit_depth = 4;
    } else {
#line 914
      dest_bit_depth = 8;
    }
#line 916
    if (channels * 8 == dest_bit_depth) {
#line 919
      num_palette = -1;
    } else
#line 916
    if (((png_uint_32 )(((3 * num_palette + num_trans) * 8) / (channels * 8 - dest_bit_depth)) / width) / height >= 1U) {
#line 919
      num_palette = -1;
    }
  }
#line 922
  if (num_palette < 0) {
    {
#line 924
    png_free((png_const_structrp )png_ptr, (png_voidp )alpha_row);
    }
#line 925
    return ((png_uint_32 )0);
  }
  {
#line 929
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 930
  index___0 = -1;
#line 931
  prev_alpha = 4294967295U;
#line 931
  prev_blue = prev_alpha;
#line 931
  prev_green = prev_blue;
#line 931
  prev_red = prev_green;
#line 932
  i = (png_uint_32 )0;
  }
  {
#line 932
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 932
    if (! (i < height)) {
#line 932
      goto while_break___2;
    }
    {
#line 934
    sample_ptr = *row_ptr;
#line 935
    opng_get_alpha_row(& row_info, trans_color, *row_ptr, alpha_row);
    }
#line 936
    if (color_type & 2) {
#line 938
      j = (png_uint_32 )0;
      {
#line 938
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 938
        if (! (j < width)) {
#line 938
          goto while_break___3;
        }
#line 940
        red = (unsigned int )*(sample_ptr + 0);
#line 941
        green = (unsigned int )*(sample_ptr + 1);
#line 942
        blue = (unsigned int )*(sample_ptr + 2);
#line 943
        alpha = (unsigned int )*(alpha_row + j);
#line 945
        if (red != prev_red) {
#line 945
          goto _L___1;
        } else
#line 945
        if (green != prev_green) {
#line 945
          goto _L___1;
        } else
#line 945
        if (blue != prev_blue) {
#line 945
          goto _L___1;
        } else
#line 945
        if (alpha != prev_alpha) {
          _L___1: /* CIL Label */ 
          {
#line 948
          prev_red = red;
#line 949
          prev_green = green;
#line 950
          prev_blue = blue;
#line 951
          prev_alpha = alpha;
#line 952
          tmp___9 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                              & num_trans, 256, red, green, blue,
                                              alpha, & index___0);
          }
#line 952
          if (tmp___9 != 0) {
#line 955
            index___0 = -1;
          }
        }
#line 957
        if (! (index___0 >= 0)) {
          {
#line 957
          __assert_fail("index >= 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                        957U, "opng_reduce_to_palette");
          }
        }
#line 958
        *(*row_ptr + j) = (png_byte )index___0;
#line 938
        j ++;
#line 938
        sample_ptr += channels;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 963
      j = (png_uint_32 )0;
      {
#line 963
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 963
        if (! (j < width)) {
#line 963
          goto while_break___4;
        }
#line 965
        gray = (unsigned int )*(sample_ptr + 0);
#line 966
        alpha = (unsigned int )*(alpha_row + j);
#line 968
        if (gray != prev_gray) {
#line 968
          goto _L___2;
        } else
#line 968
        if (alpha != prev_alpha) {
          _L___2: /* CIL Label */ 
          {
#line 970
          prev_gray = gray;
#line 971
          prev_alpha = alpha;
#line 972
          tmp___11 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                               & num_trans, 256, gray, gray, gray,
                                               alpha, & index___0);
          }
#line 972
          if (tmp___11 != 0) {
#line 975
            index___0 = -1;
          }
        }
#line 977
        if (! (index___0 >= 0)) {
          {
#line 977
          __assert_fail("index >= 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                        977U, "opng_reduce_to_palette");
          }
        }
#line 978
        *(*row_ptr + j) = (png_byte )index___0;
#line 963
        j ++;
#line 963
        sample_ptr += channels;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 932
    i ++;
#line 932
    row_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 984
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               8, 3, interlace_type, compression_type, filter_type);
#line 986
  png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(palette),
               num_palette);
  }
#line 987
  if (num_trans > 0) {
    {
#line 988
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )(trans_alpha),
                 num_trans, (png_const_color_16p )((void *)0));
    }
  }
  {
#line 991
  png_free((png_const_structrp )png_ptr, (png_voidp )alpha_row);
#line 993
  result = (png_uint_32 )16;
  }
#line 994
  if (reductions & 2U) {
    {
#line 995
    tmp___13 = opng_reduce_palette_bits(png_ptr, info_ptr, reductions);
#line 995
    result |= tmp___13;
    }
  }
#line 996
  return (result);
}
}
#line 1005 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static void opng_analyze_sample_usage(png_structp png_ptr , png_infop info_ptr , png_bytep usage_map ) 
{ 
  png_bytepp row_ptr ;
  png_bytep sample_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int init_shift ;
  int init_mask ;
  int shift ;
  int mask ;
  png_color_16p background ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_byte tmp ;
  png_uint_32 tmp___1 ;

  {
  {
#line 1020
  height = png_get_image_height((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1021
  width = png_get_image_width((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1022
  tmp = png_get_bit_depth((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1022
  bit_depth = (int )tmp;
#line 1023
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1026
  memset((void *)usage_map, 0, (size_t )256);
  }
#line 1029
  if (bit_depth == 8) {
#line 1031
    i = (png_uint_32 )0;
    {
#line 1031
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1031
      if (! (i < height)) {
#line 1031
        goto while_break;
      }
#line 1033
      j = (png_uint_32 )0;
#line 1033
      sample_ptr = *row_ptr;
      {
#line 1033
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1033
        if (! (j < width)) {
#line 1033
          goto while_break___0;
        }
#line 1034
        *(usage_map + *sample_ptr) = (png_byte )1;
#line 1033
        j ++;
#line 1033
        sample_ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1031
      i ++;
#line 1031
      row_ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1039
    if (! (bit_depth < 8)) {
      {
#line 1039
      __assert_fail("bit_depth < 8", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    1039U, "opng_analyze_sample_usage");
      }
    }
#line 1040
    init_shift = 8 - bit_depth;
#line 1041
    init_mask = (1 << 8) - (1 << init_shift);
#line 1042
    i = (png_uint_32 )0;
    {
#line 1042
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1042
      if (! (i < height)) {
#line 1042
        goto while_break___1;
      }
#line 1044
      j = (png_uint_32 )0;
#line 1044
      sample_ptr = *row_ptr;
      {
#line 1044
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1044
        if (! (j < width)) {
#line 1044
          goto while_break___2;
        }
#line 1046
        mask = init_mask;
#line 1047
        shift = init_shift;
        {
#line 1048
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1050
          *(usage_map + (((int )*sample_ptr & mask) >> shift)) = (png_byte )1;
#line 1051
          mask >>= bit_depth;
#line 1052
          shift -= bit_depth;
#line 1053
          j ++;
#line 1048
          if (mask > 0) {
#line 1048
            if (! (j < width)) {
#line 1048
              goto while_break___3;
            }
          } else {
#line 1048
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1044
        sample_ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1042
      i ++;
#line 1042
      row_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1061
  tmp___1 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 1061
  if (tmp___1) {
#line 1062
    *(usage_map + background->index) = (png_byte )1;
  }
#line 1064
  return;
}
}
#line 1071 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_palette(png_structp png_ptr , png_infop info_ptr ,
                                       png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  png_colorp palette ;
  png_bytep trans_alpha ;
  png_bytepp row_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int num_palette ;
  int num_trans ;
  int last_color_index ;
  int last_trans_index ;
  png_byte crt_trans_value ;
  png_byte last_trans_value ;
  png_byte is_used[256] ;
  png_color_16 gray_trans ;
  int is_gray ;
  png_color_16p background ;
  png_uint_16p hist ;
  png_color_8p sig_bits ;
  png_uint_32 i ;
  png_uint_32 j ;
  int k ;
  png_uint_32 tmp ;
  png_uint_32 tmp___1 ;
  int tmp___2 ;
  png_uint_32 tmp___8 ;
  png_byte tmp___9 ;
  png_uint_32 tmp___10 ;
  png_uint_32 tmp___11 ;
  png_byte max_sig_bits ;
  png_uint_32 tmp___12 ;

  {
  {
#line 1101
  result = (png_uint_32 )0;
#line 1103
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & bit_depth, & color_type, & interlace_type, & compression_type,
               & filter_type);
#line 1105
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1106
  tmp = png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette,
                     & num_palette);
  }
#line 1106
  if (! tmp) {
#line 1108
    palette = (png_colorp )((void *)0);
#line 1109
    num_palette = 0;
  }
  {
#line 1111
  tmp___1 = png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & trans_alpha,
                         & num_trans, (png_color_16p *)((void *)0));
  }
#line 1111
  if (tmp___1) {
#line 1117
    if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1117
      if (! (num_trans > 0)) {
        {
#line 1117
        __assert_fail("trans_alpha != ((void *)0) && num_trans > 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                      1117U, "opng_reduce_palette");
        }
      }
    } else {
      {
#line 1117
      __assert_fail("trans_alpha != ((void *)0) && num_trans > 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    1117U, "opng_reduce_palette");
      }
    }
  } else {
#line 1113
    trans_alpha = (png_bytep )((void *)0);
#line 1114
    num_trans = 0;
  }
  {
#line 1119
  opng_analyze_sample_usage(png_ptr, info_ptr, is_used);
  }
#line 1121
  if (reductions & 128U) {
#line 1121
    if (bit_depth == 8) {
#line 1121
      tmp___2 = 1;
    } else {
#line 1121
      tmp___2 = 0;
    }
  } else {
#line 1121
    tmp___2 = 0;
  }
#line 1121
  is_gray = tmp___2;
#line 1122
  last_trans_index = -1;
#line 1122
  last_color_index = last_trans_index;
#line 1123
  k = 0;
  {
#line 1123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1123
    if (! (k < 256)) {
#line 1123
      goto while_break;
    }
#line 1125
    if (! is_used[k]) {
#line 1126
      goto __Cont;
    }
#line 1127
    last_color_index = k;
#line 1128
    if (k < num_trans) {
#line 1128
      if ((int )*(trans_alpha + k) < 255) {
#line 1129
        last_trans_index = k;
      }
    }
#line 1130
    if (is_gray) {
#line 1131
      if ((int )(palette + k)->red != (int )(palette + k)->green) {
#line 1133
        is_gray = 0;
      } else
#line 1131
      if ((int )(palette + k)->red != (int )(palette + k)->blue) {
#line 1133
        is_gray = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1123
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  if (! (last_color_index >= 0)) {
    {
#line 1135
    __assert_fail("last_color_index >= 0", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  1135U, "opng_reduce_palette");
    }
  }
#line 1136
  if (! (last_color_index >= last_trans_index)) {
    {
#line 1136
    __assert_fail("last_color_index >= last_trans_index", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                  1136U, "opng_reduce_palette");
    }
  }
#line 1139
  if (last_color_index >= num_palette) {
    {
#line 1141
    png_warning((png_const_structrp )png_ptr, "Too few colors in PLTE");
#line 1143
    opng_realloc_PLTE(png_ptr, info_ptr, last_color_index + 1);
#line 1144
    png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette, & num_palette);
    }
#line 1145
    if (! (num_palette == last_color_index + 1)) {
      {
#line 1145
      __assert_fail("num_palette == last_color_index + 1", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                    1145U, "opng_reduce_palette");
      }
    }
#line 1146
    result |= 8192U;
  }
#line 1148
  if (num_trans > num_palette) {
    {
#line 1150
    png_warning((png_const_structrp )png_ptr, "Too many alpha values in tRNS");
#line 1152
    result |= 8192U;
    }
  }
#line 1156
  if (is_gray) {
#line 1156
    if (last_trans_index >= 0) {
#line 1158
      gray_trans.gray = (png_uint_16 )(palette + last_trans_index)->red;
#line 1159
      last_trans_value = *(trans_alpha + last_trans_index);
#line 1160
      k = 0;
      {
#line 1160
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1160
        if (! (k <= last_color_index)) {
#line 1160
          goto while_break___0;
        }
#line 1162
        if (! is_used[k]) {
#line 1163
          goto __Cont___0;
        }
#line 1164
        if (k <= last_trans_index) {
#line 1166
          crt_trans_value = *(trans_alpha + k);
#line 1168
          if ((int )crt_trans_value < 255) {
#line 1168
            if ((int )(palette + k)->red != (int )gray_trans.gray) {
#line 1170
              is_gray = 0;
#line 1171
              goto while_break___0;
            }
          }
        } else {
#line 1175
          crt_trans_value = (png_byte )255;
        }
#line 1177
        if ((int )(palette + k)->red == (int )gray_trans.gray) {
#line 1177
          if ((int )crt_trans_value != (int )last_trans_value) {
#line 1180
            is_gray = 0;
#line 1181
            goto while_break___0;
          }
        }
        __Cont___0: /* CIL Label */ 
#line 1160
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1187
  if (num_trans > 0) {
#line 1187
    if (last_trans_index < 0) {
      {
#line 1189
      num_trans = 0;
#line 1190
      png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )8192,
                    -1);
#line 1191
      png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
#line 1192
      result |= 512U;
      }
    }
  }
#line 1195
  if (reductions & 512U) {
#line 1197
    if (num_palette != last_color_index + 1) {
      {
#line 1201
      opng_realloc_PLTE(png_ptr, info_ptr, last_color_index + 1);
#line 1202
      png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette,
                   & num_palette);
      }
#line 1203
      if (! (num_palette == last_color_index + 1)) {
        {
#line 1203
        __assert_fail("num_palette == last_color_index + 1", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                      1203U, "opng_reduce_palette");
        }
      }
#line 1204
      result |= 512U;
    }
#line 1207
    if (num_trans > 0) {
#line 1207
      if (num_trans != last_trans_index + 1) {
        {
#line 1210
        opng_realloc_tRNS(png_ptr, info_ptr, last_trans_index + 1);
#line 1211
        png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & trans_alpha,
                     & num_trans, (png_color_16p *)((void *)0));
        }
#line 1212
        if (! (num_trans == last_trans_index + 1)) {
          {
#line 1212
          __assert_fail("num_trans == last_trans_index + 1", "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c",
                        1212U, "opng_reduce_palette");
          }
        }
#line 1213
        result |= 512U;
      }
    }
  }
#line 1217
  if (reductions & 2U) {
    {
#line 1219
    tmp___8 = opng_reduce_palette_bits(png_ptr, info_ptr, reductions);
#line 1219
    result |= tmp___8;
#line 1221
    tmp___9 = png_get_bit_depth((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1221
    bit_depth = (int )tmp___9;
    }
  }
#line 1223
  if (bit_depth < 8) {
#line 1224
    return (result);
  } else
#line 1223
  if (! is_gray) {
#line 1224
    return (result);
  }
#line 1227
  i = (png_uint_32 )0;
  {
#line 1227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1227
    if (! (i < height)) {
#line 1227
      goto while_break___1;
    }
#line 1229
    j = (png_uint_32 )0;
    {
#line 1229
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1229
      if (! (j < width)) {
#line 1229
        goto while_break___2;
      }
#line 1230
      *(*(row_ptr + i) + j) = (palette + *(*(row_ptr + i) + j))->red;
#line 1229
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1227
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1234
  if (num_trans > 0) {
    {
#line 1235
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )((void *)0),
                 0, (png_const_color_16p )(& gray_trans));
    }
  }
  {
#line 1237
  tmp___10 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 1237
  if (tmp___10) {
#line 1238
    background->gray = (png_uint_16 )(palette + background->index)->red;
  }
  {
#line 1241
  tmp___11 = png_get_hIST((png_const_structrp )png_ptr, (png_inforp )info_ptr, & hist);
  }
#line 1241
  if (tmp___11) {
    {
#line 1243
    png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )8,
                  -1);
#line 1244
    png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 64);
    }
  }
  {
#line 1248
  tmp___12 = png_get_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, & sig_bits);
  }
#line 1248
  if (tmp___12) {
#line 1250
    max_sig_bits = sig_bits->red;
#line 1251
    if ((int )max_sig_bits < (int )sig_bits->green) {
#line 1252
      max_sig_bits = sig_bits->green;
    }
#line 1253
    if ((int )max_sig_bits < (int )sig_bits->blue) {
#line 1254
      max_sig_bits = sig_bits->blue;
    }
#line 1255
    sig_bits->gray = max_sig_bits;
  }
  {
#line 1260
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, 0, interlace_type, compression_type, filter_type);
#line 1262
  png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_uint_32 )4096,
                -1);
#line 1263
  png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8);
  }
#line 1264
  return ((png_uint_32 )128);
}
}
#line 1275 "/home/khheo/project/benchmark/optipng-0.7.6/src/opngreduc/opngreduc.c"
png_uint_32 opng_reduce_image(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  int color_type ;
  int tmp ;
  png_byte tmp___0 ;
  png_uint_32 tmp___1 ;
  png_uint_32 tmp___2 ;

  {
  {
#line 1284
  tmp = opng_validate_image(png_ptr, info_ptr);
  }
#line 1284
  if (! tmp) {
    {
#line 1286
    png_warning((png_const_structrp )png_ptr, "Image reduction requires the presence of all critical information");
    }
#line 1288
    return ((png_uint_32 )0);
  }
  {
#line 1291
  tmp___0 = png_get_color_type((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1291
  color_type = (int )tmp___0;
#line 1296
  result = opng_reduce_bits(png_ptr, info_ptr, reductions);
  }
#line 1299
  if (color_type == 3) {
#line 1299
    if (reductions & 642U) {
      {
#line 1304
      tmp___1 = opng_reduce_palette(png_ptr, info_ptr, reductions);
#line 1304
      result |= tmp___1;
      }
    }
  }
#line 1307
  if ((color_type & -5) == 0) {
#line 1307
    if (reductions & 64U) {
#line 1307
      goto _L;
    } else {
#line 1307
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1307
  if ((color_type & -5) == 2) {
#line 1307
    if (reductions & 16U) {
      _L: /* CIL Label */ 
#line 1312
      if (! (result & 128U)) {
        {
#line 1313
        tmp___2 = opng_reduce_to_palette(png_ptr, info_ptr, reductions);
#line 1313
        result |= tmp___2;
        }
      }
    }
  }
#line 1316
  return (result);
}
}
#line 144 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 146
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 116 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.h"
char *osys_path_chdir(char *buffer___0 , size_t bufsize , char const   *old_path ,
                      char const   *new_dirname ) ;
#line 129
char *osys_path_chext(char *buffer___0 , size_t bufsize , char const   *old_path ,
                      char const   *new_extname ) ;
#line 138
char *osys_path_mkbak(char *buffer___0 , size_t bufsize , char const   *path ) ;
#line 145
osys_foffset_t osys_ftello(FILE *stream ) ;
#line 152
int osys_fseeko(FILE *stream , osys_foffset_t offset , int whence ) ;
#line 160
int osys_fgetsize(FILE *stream , osys_fsize_t *size ) ;
#line 170
size_t osys_fread_at(FILE *stream , osys_foffset_t offset , int whence , void *block ,
                     size_t blocksize ) ;
#line 181
size_t osys_fwrite_at(FILE *stream , osys_foffset_t offset , int whence , void const   *block ,
                      size_t blocksize ) ;
#line 190
int osys_rename(char const   *src_path , char const   *dest_path , int clobber ) ;
#line 199
int osys_copy_attr(char const   *src_path , char const   *dest_path ) ;
#line 208
int osys_create_dir(char const   *dirname ) ;
#line 225
int osys_test(char const   *path , char const   *mode ) ;
#line 236
int osys_test_eq(char const   *path1 , char const   *path2 ) ;
#line 244
int osys_unlink(char const   *path ) ;
#line 253
void osys_terminate(void) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 302
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 476
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 317
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd ,
                                                                                                char const   *__path ,
                                                                                                struct timespec  const  *__times ,
                                                                                                int __flags ) ;
#line 177 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
char *osys_path_chdir(char *buffer___0 , size_t bufsize , char const   *old_path ,
                      char const   *new_dirname ) 
{ 
  char const   *path ;
  char const   *ptr ;
  size_t dirlen ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 185
  path = old_path;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 192
    tmp = strpbrk(path, "/");
#line 192
    ptr = (char const   *)tmp;
    }
#line 193
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 194
      goto while_break;
    }
#line 195
    path = ptr + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 199
  dirlen = strlen(new_dirname);
#line 200
  tmp___0 = strlen(path);
  }
#line 200
  if ((dirlen + tmp___0) + 2UL >= bufsize) {
#line 201
    return ((char *)((void *)0));
  }
#line 204
  if (dirlen > 0UL) {
    {
#line 206
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)new_dirname);
#line 216
    tmp___2 = strchr("/", (int )*(buffer___0 + (dirlen - 1UL)));
    }
#line 216
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 217
      tmp___1 = dirlen;
#line 217
      dirlen ++;
#line 217
      *(buffer___0 + tmp___1) = (char )'/';
    }
  }
  {
#line 222
  strcpy((char */* __restrict  */)(buffer___0 + dirlen), (char const   */* __restrict  */)path);
  }
#line 223
  return (buffer___0);
}
}
#line 230 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
char *osys_path_chext(char *buffer___0 , size_t bufsize , char const   *old_path ,
                      char const   *new_extname ) 
{ 
  size_t i ;
  size_t pos ;
  char tmp ;
  char tmp___0 ;

  {
#line 236
  if ((int const   )*(new_extname + 0) != 46) {
#line 237
    return ((char *)((void *)0));
  }
#line 238
  i = (size_t )0;
#line 238
  pos = (size_t )-1;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! ((int const   )*(old_path + i) != 0)) {
#line 238
      goto while_break;
    }
#line 240
    if (i >= bufsize) {
#line 241
      return ((char *)((void *)0));
    }
#line 242
    tmp = (char )*(old_path + i);
#line 242
    *(buffer___0 + i) = tmp;
#line 242
    if ((int )tmp == 46) {
#line 243
      pos = i;
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if (i > pos) {
#line 246
    i = pos;
  }
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 249
    if (i >= bufsize) {
#line 250
      return ((char *)((void *)0));
    }
#line 251
    tmp___0 = (char )*new_extname;
#line 251
    *(buffer___0 + i) = tmp___0;
#line 251
    if ((int )tmp___0 == 0) {
#line 252
      return (buffer___0);
    }
#line 247
    i ++;
#line 247
    new_extname ++;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 262 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
static char const   bak_extname[5]  = {      (char const   )'.',      (char const   )'b',      (char const   )'a',      (char const   )'k', 
        (char const   )'\000'};
#line 259 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
char *osys_path_mkbak(char *buffer___0 , size_t bufsize , char const   *path ) 
{ 
  size_t tmp ;

  {
  {
#line 264
  tmp = strlen(path);
  }
#line 264
  if (tmp + sizeof(bak_extname) > bufsize) {
#line 265
    return ((char *)((void *)0));
  }
  {
#line 273
  strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)path);
#line 274
  strcat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)(bak_extname));
  }
#line 275
  return (buffer___0);
}
}
#line 283 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
osys_foffset_t osys_ftello(FILE *stream ) 
{ 
  long tmp ;

  {
  {
#line 300
  tmp = ftell(stream);
  }
#line 300
  return (tmp);
}
}
#line 308 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_fseeko(FILE *stream , osys_foffset_t offset , int whence ) 
{ 
  int tmp ;

  {
  {
#line 324
  tmp = fseek(stream, offset, whence);
  }
#line 324
  return (tmp);
}
}
#line 337 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_fgetsize(FILE *stream , osys_fsize_t *size ) 
{ 
  osys_foffset_t offset ;
  int tmp ;

  {
  {
#line 356
  tmp = osys_fseeko(stream, (osys_foffset_t )0, 2);
  }
#line 356
  if (tmp != 0) {
#line 357
    return (-1);
  }
  {
#line 358
  offset = osys_ftello(stream);
  }
#line 359
  if (offset < 0L) {
#line 360
    return (-1);
  }
#line 361
  *size = (osys_fsize_t )offset;
#line 362
  return (0);
}
}
#line 370 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
size_t osys_fread_at(FILE *stream , osys_foffset_t offset , int whence , void *block ,
                     size_t blocksize ) 
{ 
  fpos_t pos ;
  size_t result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 377
  tmp = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& pos));
  }
#line 377
  if (tmp != 0) {
#line 378
    return ((size_t )0);
  }
  {
#line 379
  tmp___0 = osys_fseeko(stream, offset, whence);
  }
#line 379
  if (tmp___0 == 0) {
    {
#line 380
    result = fread((void */* __restrict  */)block, (size_t )1, blocksize, (FILE */* __restrict  */)stream);
    }
  } else {
#line 382
    result = (size_t )0;
  }
  {
#line 383
  tmp___1 = fsetpos(stream, (fpos_t const   *)(& pos));
  }
#line 383
  if (tmp___1 != 0) {
#line 384
    result = (size_t )0;
  }
#line 385
  return (result);
}
}
#line 391 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
size_t osys_fwrite_at(FILE *stream , osys_foffset_t offset , int whence , void const   *block ,
                      size_t blocksize ) 
{ 
  fpos_t pos ;
  size_t result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 398
  tmp = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& pos));
  }
#line 398
  if (tmp != 0) {
#line 399
    return ((size_t )0);
  } else {
    {
#line 398
    tmp___0 = fflush(stream);
    }
#line 398
    if (tmp___0 != 0) {
#line 399
      return ((size_t )0);
    }
  }
  {
#line 400
  tmp___1 = osys_fseeko(stream, offset, whence);
  }
#line 400
  if (tmp___1 == 0) {
    {
#line 401
    result = fwrite((void const   */* __restrict  */)block, (size_t )1, blocksize,
                    (FILE */* __restrict  */)stream);
    }
  } else {
#line 403
    result = (size_t )0;
  }
  {
#line 404
  tmp___2 = fflush(stream);
  }
#line 404
  if (tmp___2 != 0) {
#line 405
    result = (size_t )0;
  }
  {
#line 406
  tmp___3 = fsetpos(stream, (fpos_t const   *)(& pos));
  }
#line 406
  if (tmp___3 != 0) {
#line 407
    result = (size_t )0;
  }
#line 408
  return (result);
}
}
#line 414 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_rename(char const   *src_path , char const   *dest_path , int clobber ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 439
  if (! clobber) {
    {
#line 441
    tmp = access(dest_path, 0);
    }
#line 441
    if (tmp >= 0) {
#line 442
      return (-1);
    }
  }
  {
#line 444
  tmp___0 = rename(src_path, dest_path);
  }
#line 444
  return (tmp___0);
}
}
#line 463 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_copy_attr(char const   *src_path , char const   *dest_path ) 
{ 
  struct stat sbuf ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct timespec times[2] ;
  int tmp___2 ;

  {
  {
#line 498
  tmp = stat((char const   */* __restrict  */)src_path, (struct stat */* __restrict  */)(& sbuf));
  }
#line 498
  if (tmp != 0) {
#line 499
    return (-1);
  }
  {
#line 501
  result = 0;
#line 503
  tmp___0 = chown(dest_path, sbuf.st_uid, sbuf.st_gid);
#line 508
  tmp___1 = chmod(dest_path, sbuf.st_mode);
  }
#line 508
  if (tmp___1 != 0) {
#line 509
    result = -1;
  }
  {
#line 515
  times[0] = sbuf.st_atim;
#line 516
  times[1] = sbuf.st_mtim;
#line 517
  tmp___2 = utimensat(-100, dest_path, (struct timespec  const  *)(times), 0);
  }
#line 517
  if (tmp___2 != 0) {
#line 518
    result = -1;
  }
#line 531
  return (result);
}
}
#line 547 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_create_dir(char const   *dirname ) 
{ 
  size_t len ;
  struct stat sbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 552
  len = strlen(dirname);
  }
#line 553
  if (len == 0UL) {
#line 554
    return (0);
  }
  {
#line 596
  tmp___0 = stat((char const   */* __restrict  */)dirname, (struct stat */* __restrict  */)(& sbuf));
  }
#line 596
  if (tmp___0 == 0) {
#line 597
    if (sbuf.st_mode & 16384U) {
#line 597
      tmp = 0;
    } else {
#line 597
      tmp = -1;
    }
#line 597
    return (tmp);
  }
  {
#line 601
  tmp___1 = mkdir(dirname, (__mode_t )511);
  }
#line 601
  return (tmp___1);
}
}
#line 621 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_test(char const   *path , char const   *mode ) 
{ 
  int faccess ;
  int freg ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat sbuf ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 626
  freg = 0;
#line 626
  faccess = freg;
#line 627
  tmp = strchr(mode, 'f');
  }
#line 627
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 628
    freg = 1;
  }
  {
#line 629
  tmp___0 = strchr(mode, 'r');
  }
#line 629
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 630
    faccess |= 4;
  }
  {
#line 631
  tmp___1 = strchr(mode, 'w');
  }
#line 631
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 632
    faccess |= 2;
  }
  {
#line 633
  tmp___2 = strchr(mode, 'x');
  }
#line 633
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 634
    faccess |= 1;
  }
#line 635
  if (faccess == 0) {
#line 635
    if (freg == 0) {
      {
#line 637
      tmp___3 = strchr(mode, 'e');
      }
#line 637
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 638
        return (0);
      }
    }
  }
  {
#line 661
  tmp___4 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sbuf));
  }
#line 661
  if (tmp___4 != 0) {
#line 662
    return (-1);
  }
#line 663
  if (freg) {
#line 663
    if (! (sbuf.st_mode & 32768U)) {
#line 664
      return (-1);
    }
  }
#line 665
  if (faccess == 0) {
#line 666
    return (0);
  }
  {
#line 667
  tmp___5 = access(path, faccess);
  }
#line 667
  return (tmp___5);
}
}
#line 692 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_test_eq(char const   *path1 , char const   *path2 ) 
{ 
  struct stat sbuf1 ;
  struct stat sbuf2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 737
  tmp = stat((char const   */* __restrict  */)path1, (struct stat */* __restrict  */)(& sbuf1));
  }
#line 737
  if (tmp != 0) {
#line 740
    return (-1);
  } else {
    {
#line 737
    tmp___0 = stat((char const   */* __restrict  */)path2, (struct stat */* __restrict  */)(& sbuf2));
    }
#line 737
    if (tmp___0 != 0) {
#line 740
      return (-1);
    }
  }
#line 742
  if (sbuf1.st_dev == sbuf2.st_dev) {
#line 742
    if (sbuf1.st_ino == sbuf2.st_ino) {
#line 746
      if (sbuf1.st_ino != 0UL) {
#line 746
        tmp___1 = 1;
      } else {
#line 746
        tmp___1 = -1;
      }
#line 746
      return (tmp___1);
    } else {
#line 751
      return (0);
    }
  } else {
#line 751
    return (0);
  }
}
}
#line 768 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
int osys_unlink(char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 781
  tmp = remove(path);
  }
#line 781
  return (tmp);
}
}
#line 793 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
static char const   *msg  =    "The execution of this program has been terminated abnormally.\n";
#line 790 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/osys.c"
void osys_terminate(void) 
{ 


  {
  {
#line 795
  fputs((char const   */* __restrict  */)msg, (FILE */* __restrict  */)stderr);
#line 796
  exit(70);
  }
}
}
#line 124 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.h"
int opng_ulratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) ;
#line 140
int opng_ulratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) ;
#line 150
int opng_ullratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) ;
#line 158
int opng_ullratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) ;
#line 39 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.c"
static int opng_snprintf_impl(char *buffer___0 , size_t buffer_size , char const   *format 
                              , ...) 
{ 
  va_list arg_ptr ;
  int result ;

  {
  {
#line 52
  __builtin_va_start(arg_ptr, format);
#line 53
  result = vsnprintf((char */* __restrict  */)buffer___0, buffer_size, (char const   */* __restrict  */)format,
                     arg_ptr);
#line 54
  __builtin_va_end(arg_ptr);
  }
#line 56
  if (result < 0) {
#line 56
    goto _L;
  } else
#line 56
  if ((size_t )result >= buffer_size) {
    _L: /* CIL Label */ 
#line 59
    if (buffer_size > 0UL) {
#line 60
      *(buffer___0 + (buffer_size - 1UL)) = (char )'\000';
    }
#line 61
    return (-1);
  }
#line 63
  return (result);
}
}
#line 74 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.c"
static int opng_sprint_uratio_impl(char *buffer___0 , size_t buffer_size , opng_ulongest_impl_t num ,
                                   opng_ulongest_impl_t denom , int always_percent ) 
{ 
  opng_ulongest_impl_t integer_part ;
  opng_ulongest_impl_t remainder ;
  unsigned int fractional_part ;
  unsigned int scale ;
  double scaled_ratio ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 95
  if (denom == 0ULL) {
#line 96
    if (num == 0ULL) {
#line 96
      tmp = "??%%";
    } else {
#line 96
      tmp = "INFTY%%";
    }
    {
#line 96
    tmp___0 = opng_snprintf_impl(buffer___0, buffer_size, tmp);
    }
#line 96
    return (tmp___0);
  }
#line 101
  if (num < denom) {
#line 101
    if (denom / (denom - num) < 20000ULL) {
#line 103
      scale = 10000U;
#line 104
      scaled_ratio = ((double )num * (double )scale) / (double )denom;
#line 105
      fractional_part = (unsigned int )(scaled_ratio + 0.5);
#line 108
      if (fractional_part >= scale) {
#line 109
        fractional_part = scale - 1U;
      }
      {
#line 110
      tmp___1 = opng_snprintf_impl(buffer___0, buffer_size, "%u.%02u%%", fractional_part / 100U,
                                   fractional_part % 100U);
      }
#line 110
      return (tmp___1);
    }
  }
#line 117
  integer_part = num / denom;
#line 118
  remainder = num % denom;
#line 119
  scale = 100U;
#line 120
  scaled_ratio = ((double )remainder * (double )scale) / (double )denom;
#line 121
  fractional_part = (unsigned int )(scaled_ratio + 0.5);
#line 122
  if (fractional_part >= scale) {
#line 124
    fractional_part = 0U;
#line 125
    integer_part ++;
  }
#line 129
  if (always_percent) {
    {
#line 130
    tmp___2 = opng_snprintf_impl(buffer___0, buffer_size, "%llu%02u%%", integer_part,
                                 fractional_part);
    }
#line 130
    return (tmp___2);
  }
#line 135
  if (integer_part < 100ULL) {
    {
#line 136
    tmp___3 = opng_snprintf_impl(buffer___0, buffer_size, "%llu.%02ux", integer_part,
                                 fractional_part);
    }
#line 136
    return (tmp___3);
  }
#line 143
  integer_part = num / denom;
#line 144
  if (remainder > (denom - 1ULL) / 2ULL) {
#line 145
    integer_part ++;
  }
  {
#line 146
  tmp___4 = opng_snprintf_impl(buffer___0, buffer_size, "%llux", integer_part);
  }
#line 146
  return (tmp___4);
}
}
#line 154 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.c"
int opng_ulratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) 
{ 
  opng_ulongest_impl_t num ;
  opng_ulongest_impl_t denom ;
  int tmp ;

  {
  {
#line 158
  num = (opng_ulongest_impl_t )ratio->num;
#line 159
  denom = (opng_ulongest_impl_t )ratio->denom;
#line 160
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 0);
  }
#line 160
  return (tmp);
}
}
#line 166 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.c"
int opng_ulratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) 
{ 
  opng_ulongest_impl_t num ;
  opng_ulongest_impl_t denom ;
  int tmp ;

  {
  {
#line 170
  num = (opng_ulongest_impl_t )ratio->num;
#line 171
  denom = (opng_ulongest_impl_t )ratio->denom;
#line 172
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 1);
  }
#line 172
  return (tmp);
}
}
#line 180 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.c"
int opng_ullratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) 
{ 
  opng_ulongest_impl_t num ;
  opng_ulongest_impl_t denom ;
  int tmp ;

  {
  {
#line 184
  num = (opng_ulongest_impl_t )ratio->num;
#line 185
  denom = (opng_ulongest_impl_t )ratio->denom;
#line 186
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 0);
  }
#line 186
  return (tmp);
}
}
#line 192 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/ratio.c"
int opng_ullratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) 
{ 
  opng_ulongest_impl_t num ;
  opng_ulongest_impl_t denom ;
  int tmp ;

  {
  {
#line 196
  num = (opng_ulongest_impl_t )ratio->num;
#line 197
  denom = (opng_ulongest_impl_t )ratio->denom;
#line 198
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 1);
  }
#line 198
  return (tmp);
}
}
#line 165 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.h"
unsigned int opng_bitset_count(opng_bitset_t set ) ;
#line 174
int opng_bitset_find_first(opng_bitset_t set ) ;
#line 183
int opng_bitset_find_next(opng_bitset_t set , int elt ) ;
#line 192
int opng_bitset_find_last(opng_bitset_t set ) ;
#line 201
int opng_bitset_find_prev(opng_bitset_t set , int elt ) ;
#line 230
opng_bitset_t opng_rangeset_string_to_bitset(char const   *str , size_t *end_idx ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 40 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.c"
unsigned int opng_bitset_count(opng_bitset_t set ) 
{ 
  unsigned int result ;

  {
#line 46
  result = 0U;
  {
#line 47
  while (1) {
    while_continue: /* CIL Label */ ;
#line 47
    if (! (set != 0U)) {
#line 47
      goto while_break;
    }
#line 49
    set &= set - 1U;
#line 50
    result ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (result);
}
}
#line 58 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.c"
int opng_bitset_find_first(opng_bitset_t set ) 
{ 
  int i ;

  {
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i <= 31)) {
#line 63
      goto while_break;
    }
#line 65
    if ((set & (1U << i)) != 0U) {
#line 66
      return (i);
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  return (-1);
}
}
#line 74 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.c"
int opng_bitset_find_next(opng_bitset_t set , int elt ) 
{ 
  int i ;
  int tmp ;

  {
#line 79
  if (elt > -1) {
#line 79
    tmp = elt;
  } else {
#line 79
    tmp = -1;
  }
#line 79
  i = tmp + 1;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i <= 31)) {
#line 79
      goto while_break;
    }
#line 81
    if ((set & (1U << i)) != 0U) {
#line 82
      return (i);
    }
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (-1);
}
}
#line 90 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.c"
int opng_bitset_find_last(opng_bitset_t set ) 
{ 
  int i ;

  {
#line 95
  i = 31;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i >= 0)) {
#line 95
      goto while_break;
    }
#line 97
    if ((set & (1U << i)) != 0U) {
#line 98
      return (i);
    }
#line 95
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (-1);
}
}
#line 106 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.c"
int opng_bitset_find_prev(opng_bitset_t set , int elt ) 
{ 
  int i ;
  int tmp ;

  {
#line 111
  if (elt < 32) {
#line 111
    tmp = elt;
  } else {
#line 111
    tmp = 32;
  }
#line 111
  i = tmp - 1;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i >= 0)) {
#line 111
      goto while_break;
    }
#line 113
    if ((set & (1U << i)) != 0U) {
#line 114
      return (i);
    }
#line 111
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return (-1);
}
}
#line 122 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/bitset.c"
opng_bitset_t opng_rangeset_string_to_bitset(char const   *str , size_t *end_idx ) 
{ 
  opng_bitset_t result ;
  char const   *ptr ;
  int state ;
  int num ;
  int num1 ;
  int num2 ;
  int out_of_range ;
  unsigned short const   **tmp ;
  unsigned int tmp___0 ;
  int *tmp___1 ;

  {
#line 131
  result = (opng_bitset_t )0;
#line 132
  ptr = str;
#line 133
  state = 0;
#line 134
  out_of_range = 0;
#line 135
  num2 = -1;
#line 135
  num1 = num2;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 139
      tmp = __ctype_b_loc();
      }
#line 139
      if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
#line 139
        goto while_break___0;
      }
#line 139
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 143
    if (state == 2) {
#line 143
      goto case_2;
    }
#line 143
    if (state == 0) {
#line 143
      goto case_2;
    }
#line 165
    if (state == 1) {
#line 165
      goto case_1;
    }
#line 140
    goto switch_break;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 145
    if ((int const   )*ptr >= 48) {
#line 145
      if ((int const   )*ptr <= 57) {
#line 147
        num = 0;
        {
#line 148
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 150
          num = 10 * num + (int )((int const   )*ptr - 48);
#line 151
          if (num > 31) {
#line 153
            out_of_range = 1;
#line 154
            num = 31;
          }
#line 156
          ptr ++;
#line 148
          if ((int const   )*ptr >= 48) {
#line 148
            if (! ((int const   )*ptr <= 57)) {
#line 148
              goto while_break___1;
            }
          } else {
#line 148
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 158
        if (state == 0) {
#line 159
          num1 = num;
        }
#line 160
        num2 = num;
#line 161
        state ++;
#line 162
        goto __Cont;
      }
    }
#line 164
    goto switch_break;
    case_1: /* CIL Label */ 
#line 167
    if ((int const   )*ptr == 45) {
#line 169
      ptr ++;
#line 170
      num2 = 31;
#line 171
      state ++;
#line 172
      goto __Cont;
    }
#line 174
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 177
    if (state > 0) {
#line 180
      state = 0;
#line 181
      if (num2 > 31) {
#line 183
        out_of_range = 1;
#line 184
        num2 = 31;
      }
#line 186
      if (num1 <= num2) {
#line 187
        if (num1 <= num2) {
#line 187
          tmp___0 = (((1U << (num2 - num1)) << 1) - 1U) << num1;
        } else {
#line 187
          tmp___0 = 0U;
        }
#line 187
        result |= tmp___0;
      } else {
#line 189
        out_of_range = 1;
      }
    }
#line 192
    if ((int const   )*ptr == 44) {
#line 195
      ptr ++;
#line 196
      goto __Cont;
    } else
#line 192
    if ((int const   )*ptr == 59) {
#line 195
      ptr ++;
#line 196
      goto __Cont;
    } else {
#line 201
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  if (num1 == -1) {
#line 208
    if ((unsigned long )end_idx != (unsigned long )((void *)0)) {
#line 209
      *end_idx = (size_t )0;
    }
#line 211
    return ((opng_bitset_t )0);
  }
#line 213
  if ((unsigned long )end_idx != (unsigned long )((void *)0)) {
#line 214
    *end_idx = (size_t )(ptr - str);
  }
#line 216
  if (out_of_range) {
    {
#line 217
    tmp___1 = __errno_location();
#line 217
    *tmp___1 = 34;
    }
  }
#line 219
  return (result);
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 73 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.h"
int opng_initialize(struct opng_options  const  *init_options , struct opng_ui  const  *init_ui ) ;
#line 79
int opng_optimize(char const   *infile_name ) ;
#line 84
int opng_finalize(void) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 35 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
struct exception_context the_exception_context[1]  ;
#line 41 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static struct opng_preset  const  presets[8]  = 
#line 41
  {      {"", "", "", ""}, 
        {"", "", "", ""}, 
        {"9", "8", "0-", "0,5"}, 
        {"9", "8-9", "0-", "0,5"}, 
        {"9", "8", "0-", "0-"}, 
        {"9", "8-9", "0-", "0-"}, 
        {"1-9", "8", "0-", "0-"}, 
        {"1-9", "8-9", "0-", "0-"}};
#line 63 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int const   filter_table[6]  = {      (int const   )8,      (int const   )16,      (int const   )32,      (int const   )64, 
        (int const   )128,      (int const   )248};
#line 95 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_PLTE[4]  = {      (png_byte const   )80,      (png_byte const   )76,      (png_byte const   )84,      (png_byte const   )69};
#line 96 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_tRNS[4]  = {      (png_byte const   )116,      (png_byte const   )82,      (png_byte const   )78,      (png_byte const   )83};
#line 97 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_IDAT[4]  = {      (png_byte const   )73,      (png_byte const   )68,      (png_byte const   )65,      (png_byte const   )84};
#line 98 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_IEND[4]  = {      (png_byte const   )73,      (png_byte const   )69,      (png_byte const   )78,      (png_byte const   )68};
#line 99 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_bKGD[4]  = {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68};
#line 100 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_hIST[4]  = {      (png_byte const   )104,      (png_byte const   )73,      (png_byte const   )83,      (png_byte const   )84};
#line 101 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_sBIT[4]  = {      (png_byte const   )115,      (png_byte const   )66,      (png_byte const   )73,      (png_byte const   )84};
#line 102 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_dSIG[4]  = {      (png_byte const   )100,      (png_byte const   )83,      (png_byte const   )73,      (png_byte const   )71};
#line 103 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_acTL[4]  = {      (png_byte const   )97,      (png_byte const   )99,      (png_byte const   )84,      (png_byte const   )76};
#line 104 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_fcTL[4]  = {      (png_byte const   )102,      (png_byte const   )99,      (png_byte const   )84,      (png_byte const   )76};
#line 105 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_byte const   sig_fdAT[4]  = {      (png_byte const   )102,      (png_byte const   )100,      (png_byte const   )65,      (png_byte const   )84};
#line 111 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static struct opng_engine_struct engine  ;
#line 119 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static struct opng_process_struct process  ;
#line 136 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static unsigned long const   idat_size_max  =    (osys_fsize_t const   )((png_uint_32 )2147483647L);
#line 137 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static char const   *idat_size_max_string  =    "2GB";
#line 142 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static struct opng_summary_struct summary  ;
#line 153 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static struct opng_image_struct image  ;
#line 181 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static struct opng_options options  ;
#line 187 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void (*usr_printf)(char const   *fmt  , ...)  ;
#line 188 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void (*usr_print_cntrl)(int cntrl_code )  ;
#line 189 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void (*usr_progress)(unsigned long num , unsigned long denom )  ;
#line 190 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void (*usr_panic)(char const   *msg )  ;
#line 196 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_structp read_ptr  ;
#line 197 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_infop read_info_ptr  ;
#line 198 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_structp write_ptr  ;
#line 199 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_infop write_info_ptr  ;
#line 212 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_print_fsize_ratio(osys_fsize_t num , osys_fsize_t denom ) 
{ 
  char buffer___0[32] ;
  struct opng_ulratio ratio ;
  int result ;
  char const   *tmp ;

  {
  {
#line 227
  ratio.num = num;
#line 228
  ratio.denom = denom;
#line 229
  result = opng_ulratio_to_factor_string(buffer___0, sizeof(buffer___0), (struct opng_ulratio  const  *)(& ratio));
  }
#line 230
  if (result > 0) {
#line 230
    tmp = "";
  } else {
#line 230
    tmp = "...";
  }
  {
#line 230
  (*usr_printf)("%s%s", buffer___0, tmp);
  }
#line 234
  return;
}
}
#line 239 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_print_fsize_difference(osys_fsize_t init_size , osys_fsize_t final_size ,
                                        int show_ratio ) 
{ 
  osys_fsize_t difference ;
  int sign ;
  char const   *tmp ;

  {
#line 246
  if (init_size <= final_size) {
#line 248
    sign = 0;
#line 249
    difference = final_size - init_size;
  } else {
#line 253
    sign = 1;
#line 254
    difference = init_size - final_size;
  }
#line 257
  if (difference == 0UL) {
    {
#line 259
    (*usr_printf)("no change");
    }
#line 260
    return;
  }
#line 262
  if (difference == 1UL) {
    {
#line 263
    (*usr_printf)("1 byte");
    }
  } else {
    {
#line 265
    (*usr_printf)("%lu bytes", difference);
    }
  }
#line 266
  if (show_ratio) {
#line 266
    if (init_size > 0UL) {
      {
#line 268
      (*usr_printf)(" = ");
#line 269
      opng_print_fsize_ratio(difference, init_size);
      }
    }
  }
#line 271
  if (sign == 0) {
#line 271
    tmp = " increase";
  } else {
#line 271
    tmp = " decrease";
  }
  {
#line 271
  (*usr_printf)(tmp);
  }
#line 272
  return;
}
}
#line 281
static void opng_print_image_info(int show_dim , int show_depth , int show_type ,
                                  int show_interlaced ) ;
#line 281 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int const   type_channels[8]  = 
#line 281
  {      (int const   )1,      (int const   )0,      (int const   )3,      (int const   )1, 
        (int const   )2,      (int const   )0,      (int const   )4,      (int const   )0};
#line 277 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_print_image_info(int show_dim , int show_depth , int show_type ,
                                  int show_interlaced ) 
{ 
  int channels ;
  int printed ;
  char const   *tmp ;

  {
#line 284
  printed = 0;
#line 285
  if (show_dim) {
    {
#line 287
    printed = 1;
#line 288
    (*usr_printf)("%lux%lu pixels", (unsigned long )image.width, (unsigned long )image.height);
    }
  }
#line 291
  if (show_depth) {
#line 293
    if (printed) {
      {
#line 294
      (*usr_printf)(", ");
      }
    }
#line 295
    printed = 1;
#line 296
    channels = (int )type_channels[image.color_type & 7];
#line 297
    if (channels != 1) {
      {
#line 298
      (*usr_printf)("%dx%d bits/pixel", channels, image.bit_depth);
      }
    } else
#line 299
    if (image.bit_depth != 1) {
      {
#line 300
      (*usr_printf)("%d bits/pixel", image.bit_depth);
      }
    } else {
      {
#line 302
      (*usr_printf)("1 bit/pixel");
      }
    }
  }
#line 304
  if (show_type) {
#line 306
    if (printed) {
      {
#line 307
      (*usr_printf)(", ");
      }
    }
#line 308
    printed = 1;
#line 309
    if (image.color_type & 1) {
#line 311
      if (image.num_palette == 1) {
        {
#line 312
        (*usr_printf)("1 color");
        }
      } else {
        {
#line 314
        (*usr_printf)("%d colors", image.num_palette);
        }
      }
#line 315
      if (image.num_trans > 0) {
        {
#line 316
        (*usr_printf)(" (%d transparent)", image.num_trans);
        }
      }
      {
#line 317
      (*usr_printf)(" in palette");
      }
    } else {
#line 321
      if (image.color_type & 2) {
#line 321
        tmp = "RGB";
      } else {
#line 321
        tmp = "grayscale";
      }
      {
#line 321
      (*usr_printf)(tmp);
      }
#line 323
      if (image.color_type & 4) {
        {
#line 324
        (*usr_printf)("+alpha");
        }
      } else
#line 325
      if ((unsigned long )image.trans_color_ptr != (unsigned long )((void *)0)) {
        {
#line 326
        (*usr_printf)("+transparency");
        }
      }
    }
  }
#line 329
  if (show_interlaced) {
#line 331
    if (image.interlace_type != 0) {
#line 333
      if (printed) {
        {
#line 334
        (*usr_printf)(", ");
        }
      }
      {
#line 335
      (*usr_printf)("interlaced");
      }
    }
  }
#line 338
  return;
}
}
#line 343 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_print_warning(char const   *msg___0 ) 
{ 


  {
  {
#line 346
  (*usr_print_cntrl)('\v');
#line 347
  (*usr_printf)("Warning: %s\n", msg___0);
  }
#line 348
  return;
}
}
#line 353 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_print_error(char const   *msg___0 ) 
{ 


  {
  {
#line 356
  (*usr_print_cntrl)('\v');
#line 357
  (*usr_printf)("Error: %s\n", msg___0);
  }
#line 358
  return;
}
}
#line 363 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_warning(png_structp png_ptr , png_const_charp msg___0 ) 
{ 


  {
#line 368
  if ((unsigned long )png_ptr == (unsigned long )read_ptr) {
#line 369
    process.status |= 8448U;
  }
  {
#line 370
  opng_print_warning(msg___0);
  }
#line 371
  return;
}
}
#line 376 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_error(png_structp png_ptr , png_const_charp msg___0 ) 
{ 


  {
#line 381
  if ((unsigned long )png_ptr == (unsigned long )read_ptr) {
#line 382
    process.status |= 8448U;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    the_exception_context[0].v.etmp = (char const   */* volatile  */)msg___0;
#line 383
    longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 389 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_free(void *ptr ) 
{ 


  {
  {
#line 396
  free(ptr);
  }
#line 397
  return;
}
}
#line 402 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_check_idat_size(osys_fsize_t size ) 
{ 


  {
#line 405
  if (size > (osys_fsize_t )idat_size_max) {
    {
#line 406
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 406
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"IDAT sizes larger than the maximum chunk size are currently unsupported";
#line 406
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 408
  return;
}
}
#line 413 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_set_keep_unknown_chunk(png_structp png_ptr , int keep , png_bytep chunk_type ) 
{ 
  png_byte chunk_name[5] ;
  int tmp ;

  {
  {
#line 420
  memcpy((void */* __restrict  */)(chunk_name), (void const   */* __restrict  */)chunk_type,
         (size_t )4);
#line 421
  chunk_name[4] = (png_byte )0;
#line 422
  tmp = png_handle_as_unknown((png_const_structrp )png_ptr, (png_const_bytep )(chunk_name));
  }
#line 422
  if (! tmp) {
    {
#line 423
    png_set_keep_unknown_chunks((png_structrp )png_ptr, keep, (png_const_bytep )(chunk_name),
                                1);
    }
  }
#line 424
  return;
}
}
#line 429 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int opng_is_image_chunk(png_bytep chunk_type ) 
{ 
  int tmp ;

  {
#line 432
  if (((int )*(chunk_type + 0) & 32) == 0) {
#line 433
    return (1);
  }
  {
#line 439
  tmp = memcmp((void const   *)chunk_type, (void const   *)(sig_tRNS), (size_t )4);
  }
#line 439
  if (tmp == 0) {
#line 440
    return (1);
  }
#line 441
  return (0);
}
}
#line 447 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int opng_is_apng_chunk(png_bytep chunk_type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 450
  tmp = memcmp((void const   *)chunk_type, (void const   *)(sig_acTL), (size_t )4);
  }
#line 450
  if (tmp == 0) {
#line 453
    return (1);
  } else {
    {
#line 450
    tmp___0 = memcmp((void const   *)chunk_type, (void const   *)(sig_fcTL), (size_t )4);
    }
#line 450
    if (tmp___0 == 0) {
#line 453
      return (1);
    } else {
      {
#line 450
      tmp___1 = memcmp((void const   *)chunk_type, (void const   *)(sig_fdAT), (size_t )4);
      }
#line 450
      if (tmp___1 == 0) {
#line 453
        return (1);
      }
    }
  }
#line 454
  return (0);
}
}
#line 460 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int opng_allow_chunk(png_bytep chunk_type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 464
  tmp = opng_is_image_chunk(chunk_type);
  }
#line 464
  if (tmp) {
#line 465
    return (1);
  }
#line 467
  if (options.strip_all) {
#line 468
    return (0);
  }
  {
#line 470
  tmp___0 = memcmp((void const   *)chunk_type, (void const   *)(sig_dSIG), (size_t )4);
  }
#line 470
  if (tmp___0 == 0) {
#line 471
    return (0);
  }
#line 473
  if (options.snip) {
    {
#line 473
    tmp___1 = opng_is_apng_chunk(chunk_type);
    }
#line 473
    if (tmp___1) {
#line 474
      return (0);
    }
  }
#line 476
  return (1);
}
}
#line 482 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_handle_chunk(png_structp png_ptr , png_bytep chunk_type ) 
{ 
  int keep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 487
  tmp = opng_is_image_chunk(chunk_type);
  }
#line 487
  if (tmp) {
#line 488
    return;
  }
#line 490
  if (options.strip_all) {
    {
#line 492
    process.status |= 192U;
#line 493
    opng_set_keep_unknown_chunk(png_ptr, 1, chunk_type);
    }
#line 495
    return;
  }
  {
#line 499
  tmp___0 = memcmp((void const   *)chunk_type, (void const   *)(sig_bKGD), (size_t )4);
  }
#line 499
  if (tmp___0 == 0) {
#line 502
    return;
  } else {
    {
#line 499
    tmp___1 = memcmp((void const   *)chunk_type, (void const   *)(sig_hIST), (size_t )4);
    }
#line 499
    if (tmp___1 == 0) {
#line 502
      return;
    } else {
      {
#line 499
      tmp___2 = memcmp((void const   *)chunk_type, (void const   *)(sig_sBIT), (size_t )4);
      }
#line 499
      if (tmp___2 == 0) {
#line 502
        return;
      }
    }
  }
  {
#line 505
  keep = 3;
#line 506
  tmp___5 = memcmp((void const   *)chunk_type, (void const   *)(sig_dSIG), (size_t )4);
  }
#line 506
  if (tmp___5 == 0) {
#line 507
    process.status |= 8U;
  } else {
    {
#line 508
    tmp___4 = opng_is_apng_chunk(chunk_type);
    }
#line 508
    if (tmp___4) {
      {
#line 510
      process.status |= 32U;
#line 511
      tmp___3 = memcmp((void const   *)chunk_type, (void const   *)(sig_fdAT), (size_t )4);
      }
#line 511
      if (tmp___3 == 0) {
#line 512
        process.status |= 16U;
      }
#line 513
      if (options.snip) {
#line 515
        process.status |= 128U;
#line 516
        keep = 1;
      }
    }
  }
  {
#line 519
  opng_set_keep_unknown_chunk(png_ptr, keep, chunk_type);
  }
#line 520
  return;
}
}
#line 525 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_init_read_data(void) 
{ 


  {
#line 531
  return;
}
}
#line 536 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_init_write_data(void) 
{ 


  {
#line 539
  process.out_file_size = (osys_fsize_t )0;
#line 540
  process.out_plte_trns_size = (png_uint_32 )0;
#line 541
  process.out_idat_size = (osys_fsize_t )0;
#line 542
  return;
}
}
#line 547 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_read_data(png_structp png_ptr , png_bytep data , size_t length ) 
{ 
  FILE *stream ;
  png_voidp tmp ;
  int io_state ;
  png_uint_32 tmp___0 ;
  int io_state_loc ;
  png_bytep chunk_sig ;
  size_t tmp___1 ;
  osys_foffset_t tmp___2 ;
  png_uint_32 tmp___3 ;
  png_bytepp tmp___4 ;
  png_bytepp tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 550
  tmp = png_get_io_ptr((png_const_structrp )png_ptr);
#line 550
  stream = (FILE *)tmp;
#line 551
  tmp___0 = png_get_io_state((png_const_structrp )png_ptr);
#line 551
  io_state = (int )tmp___0;
#line 552
  io_state_loc = io_state & 240;
#line 556
  tmp___1 = fread((void */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)stream);
  }
#line 556
  if (tmp___1 != length) {
    {
#line 557
    png_error((png_const_structrp )png_ptr, "Can\'t read the input file or unexpected end of file");
    }
  }
#line 560
  if (process.in_file_size == 0UL) {
#line 562
    if (! (length == 8UL)) {
      {
#line 562
      (*usr_panic)("PNG I/O must start with the first 8 bytes");
      }
    }
    {
#line 563
    tmp___2 = osys_ftello(stream);
#line 563
    process.in_datastream_offset = tmp___2 - 8L;
#line 564
    process.status |= 2U;
    }
#line 565
    if (io_state_loc == 16) {
#line 566
      process.status |= 4U;
    }
#line 567
    if (process.in_datastream_offset == 0L) {
#line 568
      process.status |= 1U;
    } else
#line 569
    if (process.in_datastream_offset < 0L) {
      {
#line 570
      png_error((png_const_structrp )png_ptr, "Can\'t get the file-position indicator in input file");
      }
    }
#line 572
    process.in_file_size = (osys_fsize_t )process.in_datastream_offset;
  }
#line 574
  process.in_file_size += length;
#line 577
  if (io_state & 1) {
#line 577
    if (! (io_state_loc != 0)) {
      {
#line 577
      (*usr_panic)("Incorrect info in png_ptr->io_state");
      }
    }
  } else {
    {
#line 577
    (*usr_panic)("Incorrect info in png_ptr->io_state");
    }
  }
#line 579
  if (io_state_loc == 32) {
#line 585
    if (! (length == 8UL)) {
      {
#line 585
      (*usr_panic)("Reading chunk header, expecting 8 bytes");
      }
    }
    {
#line 586
    chunk_sig = data + 4;
#line 588
    tmp___8 = memcmp((void const   *)chunk_sig, (void const   *)(sig_IDAT), (size_t )4);
    }
#line 588
    if (tmp___8 == 0) {
#line 590
      if (! ((unsigned long )png_ptr == (unsigned long )read_ptr)) {
        {
#line 590
        (*usr_panic)("Incorrect I/O handler setup");
        }
      }
      {
#line 591
      tmp___5 = png_get_rows((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr);
      }
#line 591
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 593
        if (! (process.in_idat_size == 0UL)) {
          {
#line 593
          (*usr_panic)("Found IDAT with no rows");
          }
        }
        {
#line 599
        tmp___3 = png_get_image_height((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr);
        }
#line 599
        if (tmp___3 == 0U) {
#line 600
          return;
        }
        {
#line 601
        tmp___4 = pngx_malloc_rows(read_ptr, read_info_ptr, 0);
        }
#line 601
        if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
          {
#line 601
          (*usr_panic)("Failed allocation of image rows; unsafe libpng allocator");
          }
        }
        {
#line 605
        png_data_freer((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                       2, (png_uint_32 )64);
        }
      } else {
#line 611
        process.status |= 128U;
      }
#line 613
      process.in_idat_size += (osys_fsize_t )(((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3));
    } else {
      {
#line 615
      tmp___6 = memcmp((void const   *)chunk_sig, (void const   *)(sig_PLTE), (size_t )4);
      }
#line 615
      if (tmp___6 == 0) {
#line 619
        process.in_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
      } else {
        {
#line 615
        tmp___7 = memcmp((void const   *)chunk_sig, (void const   *)(sig_tRNS), (size_t )4);
        }
#line 615
        if (tmp___7 == 0) {
#line 619
          process.in_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
        } else {
          {
#line 622
          opng_handle_chunk(png_ptr, chunk_sig);
          }
        }
      }
    }
  } else
#line 624
  if (io_state_loc == 128) {
#line 626
    if (! (length == 4UL)) {
      {
#line 626
      (*usr_panic)("Reading chunk CRC, expecting 4 bytes");
      }
    }
  }
#line 628
  return;
}
}
#line 636 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int allow_crt_chunk  ;
#line 637 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int crt_chunk_is_idat  ;
#line 638 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static osys_foffset_t crt_idat_offset  ;
#line 639 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static osys_fsize_t crt_idat_size  ;
#line 640 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static png_uint_32 crt_idat_crc  ;
#line 633 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_write_data(png_structp png_ptr , png_bytep data , size_t length ) 
{ 
  FILE *stream ;
  png_voidp tmp ;
  int io_state ;
  png_uint_32 tmp___0 ;
  int io_state_loc ;
  png_bytep chunk_sig ;
  png_byte buf[4] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uLong tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  uLong tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 641
  tmp = png_get_io_ptr((png_const_structrp )png_ptr);
#line 641
  stream = (FILE *)tmp;
#line 642
  tmp___0 = png_get_io_state((png_const_structrp )png_ptr);
#line 642
  io_state = (int )tmp___0;
#line 643
  io_state_loc = io_state & 240;
  }
#line 647
  if (io_state & 2) {
#line 647
    if (! (io_state_loc != 0)) {
      {
#line 647
      (*usr_panic)("Incorrect info in png_ptr->io_state");
      }
    }
  } else {
    {
#line 647
    (*usr_panic)("Incorrect info in png_ptr->io_state");
    }
  }
#line 651
  if (io_state_loc == 32) {
#line 653
    if (! (length == 8UL)) {
      {
#line 653
      (*usr_panic)("Writing chunk header, expecting 8 bytes");
      }
    }
    {
#line 654
    chunk_sig = data + 4;
#line 655
    allow_crt_chunk = opng_allow_chunk(chunk_sig);
#line 656
    tmp___3 = memcmp((void const   *)chunk_sig, (void const   *)(sig_IDAT), (size_t )4);
    }
#line 656
    if (tmp___3 == 0) {
#line 658
      crt_chunk_is_idat = 1;
#line 659
      process.out_idat_size += (osys_fsize_t )(((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3));
#line 661
      if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 663
        if (process.out_idat_size > process.max_idat_size) {
          {
#line 664
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 664
            the_exception_context[0].v.etmp = (char const   */* volatile  */)((void *)0);
#line 664
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    } else {
      {
#line 669
      crt_chunk_is_idat = 0;
#line 670
      tmp___1 = memcmp((void const   *)chunk_sig, (void const   *)(sig_PLTE), (size_t )4);
      }
#line 670
      if (tmp___1 == 0) {
#line 674
        process.out_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
      } else {
        {
#line 670
        tmp___2 = memcmp((void const   *)chunk_sig, (void const   *)(sig_tRNS), (size_t )4);
        }
#line 670
        if (tmp___2 == 0) {
#line 674
          process.out_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
        }
      }
    }
  } else
#line 678
  if (io_state_loc == 128) {
#line 680
    if (! (length == 4UL)) {
      {
#line 680
      (*usr_panic)("Writing chunk CRC, expecting 4 bytes");
      }
    }
  }
#line 684
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 685
    return;
  }
#line 688
  if (io_state_loc != 16) {
#line 688
    if (! allow_crt_chunk) {
#line 689
      return;
    }
  }
  {
#line 697
  if (io_state_loc == 32) {
#line 697
    goto case_32;
  }
#line 760
  if (io_state_loc == 64) {
#line 760
    goto case_64;
  }
#line 766
  if (io_state_loc == 128) {
#line 766
    goto case_128;
  }
#line 695
  goto switch_break;
  case_32: /* CIL Label */ 
#line 699
  if (crt_chunk_is_idat) {
#line 701
    if (crt_idat_offset == 0L) {
      {
#line 704
      crt_idat_offset = osys_ftello(stream);
      }
#line 706
      if (process.best_idat_size > 0UL) {
#line 709
        crt_idat_size = process.best_idat_size;
      } else {
#line 716
        crt_idat_size = length;
      }
      {
#line 718
      png_save_uint_32(data, (png_uint_32 )crt_idat_size);
#line 720
      tmp___4 = crc32((uLong )0, sig_IDAT, (uInt )4);
#line 720
      crt_idat_crc = (png_uint_32 )tmp___4;
      }
    } else {
#line 725
      return;
    }
  } else
#line 730
  if (crt_idat_offset != 0L) {
    {
#line 735
    png_save_uint_32(buf, crt_idat_crc);
#line 736
    tmp___5 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                     (FILE */* __restrict  */)stream);
    }
#line 736
    if (tmp___5 != 4UL) {
#line 737
      io_state = 0;
    }
#line 738
    process.out_file_size += 4UL;
#line 739
    if (process.out_idat_size != crt_idat_size) {
#line 744
      if (! (process.best_idat_size == 0UL)) {
        {
#line 744
        (*usr_panic)("Wrong guess of the output IDAT size");
        }
      }
      {
#line 746
      opng_check_idat_size(process.out_idat_size);
#line 747
      png_save_uint_32(buf, (png_uint_32 )process.out_idat_size);
#line 749
      tmp___6 = osys_fwrite_at(stream, crt_idat_offset, 0, (void const   *)(buf),
                               (size_t )4);
      }
#line 749
      if (tmp___6 != 4UL) {
#line 751
        io_state = 0;
      }
    }
#line 753
    if (io_state == 0) {
      {
#line 754
      png_error((png_const_structrp )png_ptr, "Can\'t finalize IDAT");
      }
    }
#line 755
    crt_idat_offset = (osys_foffset_t )0;
  }
#line 758
  goto switch_break;
  case_64: /* CIL Label */ 
#line 762
  if (crt_chunk_is_idat) {
    {
#line 763
    tmp___7 = crc32((uLong )crt_idat_crc, (Bytef const   *)data, (uInt )length);
#line 763
    crt_idat_crc = (png_uint_32 )tmp___7;
    }
  }
#line 764
  goto switch_break;
  case_128: /* CIL Label */ 
#line 768
  if (crt_chunk_is_idat) {
#line 769
    return;
  }
#line 770
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 775
  tmp___8 = fwrite((void const   */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)stream);
  }
#line 775
  if (tmp___8 != length) {
    {
#line 776
    png_error((png_const_structrp )png_ptr, "Can\'t write the output file");
    }
  }
#line 777
  process.out_file_size += length;
#line 778
  return;
}
}
#line 783 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_clear_image_info(void) 
{ 


  {
  {
#line 786
  memset((void *)(& image), 0, sizeof(image));
  }
#line 787
  return;
}
}
#line 792 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_load_image_info(png_structp png_ptr , png_infop info_ptr , int load_meta ) 
{ 
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;
  png_uint_32 tmp___1 ;

  {
  {
#line 795
  memset((void *)(& image), 0, sizeof(image));
#line 797
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & image.width,
               & image.height, & image.bit_depth, & image.color_type, & image.interlace_type,
               & image.compression_type, & image.filter_type);
#line 800
  image.row_pointers = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 801
  png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.palette,
               & image.num_palette);
#line 805
  tmp = png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.trans_alpha,
                     & image.num_trans, & image.trans_color_ptr);
  }
#line 805
  if (tmp) {
#line 811
    if ((unsigned long )image.trans_color_ptr != (unsigned long )((void *)0)) {
#line 813
      image.trans_color = *(image.trans_color_ptr);
#line 814
      image.trans_color_ptr = & image.trans_color;
    }
  }
#line 818
  if (! load_meta) {
#line 819
    return;
  }
  {
#line 821
  tmp___0 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.background_ptr);
  }
#line 821
  if (tmp___0) {
#line 824
    image.background = *(image.background_ptr);
#line 825
    image.background_ptr = & image.background;
  }
  {
#line 827
  png_get_hIST((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.hist);
#line 828
  tmp___1 = png_get_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.sig_bit_ptr);
  }
#line 828
  if (tmp___1) {
#line 831
    image.sig_bit = *(image.sig_bit_ptr);
#line 832
    image.sig_bit_ptr = & image.sig_bit;
  }
  {
#line 834
  image.num_unknowns = png_get_unknown_chunks((png_const_structrp )png_ptr, (png_inforp )info_ptr,
                                              & image.unknowns);
  }
#line 836
  return;
}
}
#line 841 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_store_image_info(png_structp png_ptr , png_infop info_ptr , int store_meta ) 
{ 
  int i ;

  {
#line 844
  if (! ((unsigned long )image.row_pointers != (unsigned long )((void *)0))) {
    {
#line 844
    (*usr_panic)("No info in image");
    }
  }
  {
#line 846
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, image.width, image.height,
               image.bit_depth, image.color_type, image.interlace_type, image.compression_type,
               image.filter_type);
#line 849
  png_set_rows((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, image.row_pointers);
  }
#line 850
  if ((unsigned long )image.palette != (unsigned long )((void *)0)) {
    {
#line 851
    png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )image.palette,
                 image.num_palette);
    }
  }
#line 855
  if ((unsigned long )image.trans_alpha != (unsigned long )((void *)0)) {
    {
#line 856
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )image.trans_alpha,
                 image.num_trans, (png_const_color_16p )image.trans_color_ptr);
    }
  } else
#line 855
  if ((unsigned long )image.trans_color_ptr != (unsigned long )((void *)0)) {
    {
#line 856
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )image.trans_alpha,
                 image.num_trans, (png_const_color_16p )image.trans_color_ptr);
    }
  }
#line 859
  if (! store_meta) {
#line 860
    return;
  }
#line 862
  if ((unsigned long )image.background_ptr != (unsigned long )((void *)0)) {
    {
#line 863
    png_set_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_16p )image.background_ptr);
    }
  }
#line 864
  if ((unsigned long )image.hist != (unsigned long )((void *)0)) {
    {
#line 865
    png_set_hIST((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_uint_16p )image.hist);
    }
  }
#line 866
  if ((unsigned long )image.sig_bit_ptr != (unsigned long )((void *)0)) {
    {
#line 867
    png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )image.sig_bit_ptr);
    }
  }
#line 868
  if (image.num_unknowns != 0) {
    {
#line 871
    png_set_unknown_chunks((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_unknown_chunkp )image.unknowns,
                           image.num_unknowns);
#line 874
    i = 0;
    }
    {
#line 874
    while (1) {
      while_continue: /* CIL Label */ ;
#line 874
      if (! (i < image.num_unknowns)) {
#line 874
        goto while_break;
      }
      {
#line 875
      png_set_unknown_chunk_location((png_const_structrp )png_ptr, (png_inforp )info_ptr,
                                     i, (int )(image.unknowns + i)->location);
#line 874
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 878
  return;
}
}
#line 883 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_destroy_image_info(void) 
{ 
  png_uint_32 i ;
  int j ;

  {
#line 889
  if ((unsigned long )image.row_pointers == (unsigned long )((void *)0)) {
#line 890
    return;
  }
#line 892
  i = (png_uint_32 )0;
  {
#line 892
  while (1) {
    while_continue: /* CIL Label */ ;
#line 892
    if (! (i < image.height)) {
#line 892
      goto while_break;
    }
    {
#line 893
    opng_free((void *)*(image.row_pointers + i));
#line 892
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 894
  opng_free((void *)image.row_pointers);
#line 895
  opng_free((void *)image.palette);
#line 896
  opng_free((void *)image.trans_alpha);
#line 897
  opng_free((void *)image.hist);
#line 898
  j = 0;
  }
  {
#line 898
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 898
    if (! (j < image.num_unknowns)) {
#line 898
      goto while_break___0;
    }
    {
#line 899
    opng_free((void *)(image.unknowns + j)->data);
#line 898
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 900
  opng_free((void *)image.unknowns);
#line 908
  memset((void *)(& image), 0, sizeof(image));
  }
#line 909
  return;
}
}
#line 914 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_read_file(FILE *infile___0 ) 
{ 
  char const   *fmt_name ;
  int num_img ;
  png_uint_32 reductions ;
  char const   * volatile  err_msg ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  jmp_buf * volatile  exception__prev___0 ;
  jmp_buf exception__env___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 922
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 922
  the_exception_context[0].penv = & exception__env;
#line 922
  tmp___2 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 922
  if (tmp___2 == 0) {
    {
#line 922
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 924
      tmp = png_create_read_struct("1.6.21", (void *)0, & opng_error, & opng_warning);
#line 924
      read_ptr = (png_structp )tmp;
#line 926
      tmp___0 = png_create_info_struct((png_const_structrp )read_ptr);
#line 926
      read_info_ptr = (png_infop )tmp___0;
      }
#line 927
      if ((unsigned long )read_info_ptr == (unsigned long )((void *)0)) {
        {
#line 928
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 928
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 928
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 931
      png_set_keep_unknown_chunks((png_structrp )read_ptr, 3, (png_const_bytep )((void *)0),
                                  0);
#line 933
      png_set_user_limits((png_structrp )read_ptr, (png_uint_32 )2147483647L, (png_uint_32 )2147483647L);
#line 936
      opng_init_read_data();
#line 937
      png_set_read_fn((png_structrp )read_ptr, (png_voidp )infile___0, & opng_read_data);
#line 938
      fmt_name = (char const   *)((void *)0);
#line 939
      num_img = pngx_read_image(read_ptr, read_info_ptr, & fmt_name, (png_const_charpp )((void *)0));
      }
#line 940
      if (num_img <= 0) {
        {
#line 941
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 941
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Unrecognized image file format";
#line 941
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 942
      if (num_img > 1) {
#line 943
        process.status |= 16U;
      }
#line 944
      if (process.status & 1U) {
#line 944
        if (process.status & 16U) {
#line 948
          if (process.status & 4U) {
#line 948
            fmt_name = "APNG";
          } else {
#line 948
            fmt_name = "APNG datastream";
          }
        }
      }
#line 951
      if (! ((unsigned long )fmt_name != (unsigned long )((void *)0))) {
        {
#line 951
        (*usr_panic)("No format name from pngxtern");
        }
      }
#line 953
      if (process.in_file_size == 0UL) {
        {
#line 955
        tmp___1 = osys_fgetsize(infile___0, & process.in_file_size);
        }
#line 955
        if (tmp___1 < 0) {
          {
#line 957
          opng_print_warning("Can\'t get the correct file size");
#line 958
          process.in_file_size = (osys_fsize_t )0;
          }
        }
      }
#line 962
      err_msg = (char const   */* volatile  */)((void *)0);
#line 922
      the_exception_context[0].caught = 0;
#line 922
      if (! the_exception_context[0].caught) {
#line 922
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 964
    the_exception_context[0].caught = 1;
  }
#line 964
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 964
  if (! (! the_exception_context[0].caught)) {
    {
#line 964
    err_msg = the_exception_context[0].v.etmp;
#line 969
    tmp___3 = opng_validate_image(read_ptr, read_info_ptr);
    }
#line 969
    if (tmp___3) {
      {
#line 971
      png_warning((png_const_structrp )read_ptr, (png_const_charp )err_msg);
#line 972
      err_msg = (char const   */* volatile  */)((void *)0);
      }
    }
  }
  {
#line 976
  exception__prev___0 = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 976
  the_exception_context[0].penv = & exception__env___0;
#line 976
  tmp___5 = _setjmp((struct __jmp_buf_tag *)(exception__env___0));
  }
#line 976
  if (tmp___5 == 0) {
    {
#line 976
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 978
      if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
        {
#line 979
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 979
          the_exception_context[0].v.etmp = err_msg;
#line 979
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 982
      tmp___4 = strcmp(fmt_name, "PNG");
      }
#line 982
      if (tmp___4 != 0) {
        {
#line 984
        (*usr_printf)("Importing %s", fmt_name);
        }
#line 985
        if (process.status & 16U) {
#line 987
          if (! (process.status & 1U)) {
            {
#line 988
            (*usr_printf)(" (multi-image or animation)");
            }
          }
#line 989
          if (options.snip) {
            {
#line 990
            (*usr_printf)("; snipping...");
            }
          }
        }
        {
#line 992
        (*usr_printf)("\n");
        }
      }
      {
#line 994
      opng_load_image_info(read_ptr, read_info_ptr, 1);
#line 995
      opng_print_image_info(1, 1, 1, 1);
#line 996
      (*usr_printf)("\n");
#line 999
      reductions = (png_uint_32 )1023;
      }
#line 1000
      if (options.nb) {
#line 1001
        reductions &= 4294967292U;
      }
#line 1002
      if (options.nc) {
#line 1003
        reductions &= 4294967043U;
      }
#line 1004
      if (options.np) {
#line 1005
        reductions &= 4294966527U;
      }
#line 1006
      if (options.nz) {
#line 1006
        if (process.status & 2U) {
#line 1009
          reductions = (png_uint_32 )0;
        }
      }
#line 1011
      if (process.status & 8U) {
#line 1014
        reductions = (png_uint_32 )0;
      }
#line 1016
      if (process.status & 1U) {
#line 1016
        if (process.status & 16U) {
#line 1016
          if (reductions != 0U) {
#line 1016
            if (! options.snip) {
              {
#line 1020
              (*usr_printf)("Can\'t reliably reduce APNG file; disabling reductions.\n(Did you want to -snip and optimize the first frame?)\n");
#line 1023
              reductions = (png_uint_32 )0;
              }
            }
          }
        }
      }
      {
#line 1027
      process.reductions = opng_reduce_image(read_ptr, read_info_ptr, reductions);
      }
#line 1031
      if (process.reductions != 0U) {
        {
#line 1033
        opng_load_image_info(read_ptr, read_info_ptr, 1);
#line 1034
        (*usr_printf)("Reducing image to ");
#line 1035
        opng_print_image_info(0, 1, 1, 0);
#line 1036
        (*usr_printf)("\n");
        }
      }
#line 1040
      if (options.interlace >= 0) {
#line 1040
        if (image.interlace_type != options.interlace) {
#line 1043
          image.interlace_type = options.interlace;
#line 1045
          process.status |= 8192U;
        }
      }
#line 976
      the_exception_context[0].caught = 0;
#line 976
      if (! the_exception_context[0].caught) {
#line 976
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1048
    the_exception_context[0].caught = 1;
  }
#line 1048
  the_exception_context[0].penv = (jmp_buf *)exception__prev___0;
#line 1048
  if (! (! the_exception_context[0].caught)) {
    {
#line 1048
    err_msg = the_exception_context[0].v.etmp;
#line 1051
    png_data_freer((png_const_structrp )read_ptr, (png_inforp )read_info_ptr, 1, (png_uint_32 )32767);
#line 1053
    png_destroy_read_struct(& read_ptr, & read_info_ptr, (png_infopp )((void *)0));
    }
    {
#line 1054
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1054
      the_exception_context[0].v.etmp = err_msg;
#line 1054
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1060
  png_data_freer((png_const_structrp )read_ptr, (png_inforp )read_info_ptr, 2, (png_uint_32 )32767);
#line 1062
  png_destroy_read_struct(& read_ptr, & read_info_ptr, (png_infopp )((void *)0));
  }
#line 1063
  return;
}
}
#line 1071 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_write_file(FILE *outfile___0 , int compression_level , int memory_level ,
                            int compression_strategy , int filter ) 
{ 
  char const   * volatile  err_msg ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  int tmp___1 ;

  {
#line 1078
  if (compression_level >= 1) {
#line 1078
    if (compression_level <= 9) {
#line 1078
      if (memory_level >= 1) {
#line 1078
        if (memory_level <= 9) {
#line 1078
          if (compression_strategy >= 0) {
#line 1078
            if (compression_strategy <= 3) {
#line 1078
              if (filter >= 0) {
#line 1078
                if (! (filter <= 5)) {
                  {
#line 1078
                  (*usr_panic)("Invalid encoding parameters");
                  }
                }
              } else {
                {
#line 1078
                (*usr_panic)("Invalid encoding parameters");
                }
              }
            } else {
              {
#line 1078
              (*usr_panic)("Invalid encoding parameters");
              }
            }
          } else {
            {
#line 1078
            (*usr_panic)("Invalid encoding parameters");
            }
          }
        } else {
          {
#line 1078
          (*usr_panic)("Invalid encoding parameters");
          }
        }
      } else {
        {
#line 1078
        (*usr_panic)("Invalid encoding parameters");
        }
      }
    } else {
      {
#line 1078
      (*usr_panic)("Invalid encoding parameters");
      }
    }
  } else {
    {
#line 1078
    (*usr_panic)("Invalid encoding parameters");
    }
  }
  {
#line 1089
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1089
  the_exception_context[0].penv = & exception__env;
#line 1089
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1089
  if (tmp___1 == 0) {
    {
#line 1089
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1091
      tmp = png_create_write_struct("1.6.21", (void *)0, & opng_error, & opng_warning);
#line 1091
      write_ptr = (png_structp )tmp;
#line 1093
      tmp___0 = png_create_info_struct((png_const_structrp )write_ptr);
#line 1093
      write_info_ptr = (png_infop )tmp___0;
      }
#line 1094
      if ((unsigned long )write_info_ptr == (unsigned long )((void *)0)) {
        {
#line 1095
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1095
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 1095
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 1097
      png_set_compression_level((png_structrp )write_ptr, compression_level);
#line 1098
      png_set_compression_mem_level((png_structrp )write_ptr, memory_level);
#line 1099
      png_set_compression_strategy((png_structrp )write_ptr, compression_strategy);
#line 1100
      png_set_filter((png_structrp )write_ptr, 0, (int )filter_table[filter]);
      }
#line 1101
      if (compression_strategy != 2) {
#line 1101
        if (compression_strategy != 3) {
#line 1104
          if (options.window_bits > 0) {
            {
#line 1105
            png_set_compression_window_bits((png_structrp )write_ptr, options.window_bits);
            }
          }
        } else {
          {
#line 1113
          png_set_compression_window_bits((png_structrp )write_ptr, 9);
          }
        }
      } else {
        {
#line 1113
        png_set_compression_window_bits((png_structrp )write_ptr, 9);
        }
      }
      {
#line 1118
      png_set_keep_unknown_chunks((png_structrp )write_ptr, 3, (png_const_bytep )((void *)0),
                                  0);
#line 1120
      png_set_user_limits((png_structrp )write_ptr, (png_uint_32 )2147483647L, (png_uint_32 )2147483647L);
#line 1123
      opng_store_image_info(write_ptr, write_info_ptr, (unsigned long )outfile___0 != (unsigned long )((void *)0));
#line 1124
      opng_init_write_data();
#line 1125
      png_set_write_fn((png_structrp )write_ptr, (png_voidp )outfile___0, & opng_write_data,
                       (void (*)(png_structp  ))((void *)0));
#line 1126
      png_write_png((png_structrp )write_ptr, (png_inforp )write_info_ptr, 0, (void *)0);
#line 1128
      err_msg = (char const   */* volatile  */)((void *)0);
#line 1089
      the_exception_context[0].caught = 0;
      }
#line 1089
      if (! the_exception_context[0].caught) {
#line 1089
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1130
    the_exception_context[0].caught = 1;
  }
#line 1130
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1130
  if (! (! the_exception_context[0].caught)) {
#line 1130
    err_msg = the_exception_context[0].v.etmp;
#line 1133
    process.out_idat_size = (osys_fsize_t )(idat_size_max + 1UL);
  }
  {
#line 1137
  png_destroy_write_struct(& write_ptr, & write_info_ptr);
  }
#line 1139
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1140
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1140
      the_exception_context[0].v.etmp = err_msg;
#line 1140
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1141
  return;
}
}
#line 1146 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_copy_file(FILE *infile___0 , FILE *outfile___0 ) 
{ 
  png_bytep volatile   buf ;
  png_uint_32 buf_size_incr ;
  png_uint_32 buf_size ;
  png_uint_32 length ;
  png_byte chunk_hdr[8] ;
  char const   * volatile  err_msg ;
  png_structp __attribute__((__malloc__))  tmp ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  size_t tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1150
  buf_size_incr = (png_uint_32 )4096;
#line 1155
  tmp = png_create_write_struct("1.6.21", (void *)0, & opng_error, & opng_warning);
#line 1155
  write_ptr = (png_structp )tmp;
  }
#line 1157
  if ((unsigned long )write_ptr == (unsigned long )((void *)0)) {
    {
#line 1158
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1158
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 1158
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1159
  opng_init_write_data();
#line 1160
  png_set_write_fn((png_structrp )write_ptr, (png_voidp )outfile___0, & opng_write_data,
                   (void (*)(png_structp  ))((void *)0));
#line 1162
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1162
  the_exception_context[0].penv = & exception__env;
#line 1162
  tmp___4 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1162
  if (tmp___4 == 0) {
    {
#line 1162
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1164
      buf = (png_bytep volatile   )((void *)0);
#line 1165
      buf_size = (png_uint_32 )0;
#line 1168
      png_write_sig((png_structrp )write_ptr);
      }
      {
#line 1172
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1174
        tmp___0 = fread((void */* __restrict  */)(chunk_hdr), (size_t )8, (size_t )1,
                        (FILE */* __restrict  */)infile___0);
        }
#line 1174
        if (tmp___0 != 1UL) {
          {
#line 1175
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1175
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Read error";
#line 1175
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 1176
        length = ((((png_uint_32 )chunk_hdr[0] << 24) + ((png_uint_32 )*(chunk_hdr + 1) << 16)) + ((png_uint_32 )*(chunk_hdr + 2) << 8)) + (png_uint_32 )*(chunk_hdr + 3);
#line 1177
        if (length > 2147483647U) {
#line 1179
          if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1179
            if ((unsigned long )length == 2303741511UL) {
#line 1180
              goto __Cont;
            }
          }
          {
#line 1181
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 1181
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Data error";
#line 1181
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 1183
        if (length + 4U > buf_size) {
          {
#line 1185
          png_free((png_const_structrp )write_ptr, (png_voidp )buf);
#line 1186
          buf_size = (((length + 4U) + (buf_size_incr - 1U)) / buf_size_incr) * buf_size_incr;
#line 1188
          tmp___1 = png_malloc((png_const_structrp )write_ptr, (png_alloc_size_t )buf_size);
#line 1188
          buf = (png_bytep volatile   )((png_bytep )tmp___1);
          }
        }
        {
#line 1191
        tmp___2 = fread((void */* __restrict  */)buf, (size_t )(length + 4U), (size_t )1,
                        (FILE */* __restrict  */)infile___0);
        }
#line 1191
        if (tmp___2 != 1UL) {
          {
#line 1192
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 1192
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Read error";
#line 1192
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 1193
        png_write_chunk((png_structrp )write_ptr, (png_const_bytep )(chunk_hdr + 4),
                        (png_const_bytep )buf, (png_size_t )length);
        }
        __Cont: /* CIL Label */ 
        {
#line 1172
        tmp___3 = memcmp((void const   *)(chunk_hdr + 4), (void const   *)(sig_IEND),
                         (size_t )4);
        }
#line 1172
        if (! (tmp___3 != 0)) {
#line 1172
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1196
      err_msg = (char const   */* volatile  */)((void *)0);
#line 1162
      the_exception_context[0].caught = 0;
#line 1162
      if (! the_exception_context[0].caught) {
#line 1162
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1198
    the_exception_context[0].caught = 1;
  }
#line 1198
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1198
  if (! the_exception_context[0].caught) {
#line 1198
    tmp___5 = 1;
  } else {
#line 1198
    err_msg = the_exception_context[0].v.etmp;
#line 1198
    tmp___5 = 0;
  }
  {
#line 1202
  png_free((png_const_structrp )write_ptr, (png_voidp )buf);
#line 1203
  png_destroy_write_struct(& write_ptr, (png_infopp )((void *)0));
  }
#line 1205
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1206
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1206
      the_exception_context[0].v.etmp = err_msg;
#line 1206
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1207
  return;
}
}
#line 1212 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_init_iteration(opng_bitset_t cmdline_set , opng_bitset_t mask_set ,
                                char const   *preset , opng_bitset_t *output_set ) 
{ 
  opng_bitset_t preset_set ;

  {
#line 1218
  *output_set = cmdline_set & mask_set;
#line 1219
  if (*output_set == 0U) {
#line 1219
    if (cmdline_set != 0U) {
      {
#line 1220
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1220
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Iteration parameter(s) out of range";
#line 1220
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1221
  if (*output_set == 0U) {
    {
#line 1223
    preset_set = opng_rangeset_string_to_bitset(preset, (size_t *)((void *)0));
#line 1224
    *output_set |= preset_set & mask_set;
    }
  } else
#line 1221
  if (options.optim_level >= 0) {
    {
#line 1223
    preset_set = opng_rangeset_string_to_bitset(preset, (size_t *)((void *)0));
#line 1224
    *output_set |= preset_set & mask_set;
    }
  }
#line 1226
  return;
}
}
#line 1231 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_init_iterations(void) 
{ 
  opng_bitset_t compr_level_set ;
  opng_bitset_t mem_level_set ;
  opng_bitset_t strategy_set ;
  opng_bitset_t filter_set ;
  opng_bitset_t strategy_singles_set ;
  int preset_index ;
  int t1 ;
  int t2 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1243
  if (process.status & 8192U) {
#line 1244
    process.max_idat_size = (osys_fsize_t )idat_size_max;
  } else
#line 1243
  if (options.full) {
#line 1244
    process.max_idat_size = (osys_fsize_t )idat_size_max;
  } else {
#line 1247
    if (! (process.in_idat_size > 0UL)) {
      {
#line 1247
      (*usr_panic)("No IDAT in input");
      }
    }
#line 1254
    process.max_idat_size = process.in_idat_size + (osys_fsize_t )process.in_plte_trns_size;
  }
#line 1262
  preset_index = options.optim_level;
#line 1263
  if (preset_index < 0) {
#line 1264
    preset_index = 2;
  } else
#line 1265
  if (preset_index > 7) {
#line 1266
    preset_index = 7;
  }
  {
#line 1271
  opng_init_iteration(options.compr_level_set, (opng_bitset_t )((1 << 10) - (1 << 1)),
                      (char const   *)presets[preset_index].compr_level, & compr_level_set);
#line 1273
  opng_init_iteration(options.mem_level_set, (opng_bitset_t )((1 << 10) - (1 << 1)),
                      (char const   *)presets[preset_index].mem_level, & mem_level_set);
#line 1275
  opng_init_iteration(options.strategy_set, (opng_bitset_t )((1 << 4) - 1), (char const   *)presets[preset_index].strategy,
                      & strategy_set);
#line 1277
  opng_init_iteration(options.filter_set, (opng_bitset_t )((1 << 6) - 1), (char const   *)presets[preset_index].filter,
                      & filter_set);
  }
#line 1281
  if (compr_level_set == 0U) {
#line 1282
    compr_level_set |= 1U << 9;
  }
#line 1283
  if (mem_level_set == 0U) {
#line 1284
    mem_level_set |= 1U << 8;
  }
#line 1285
  if (image.bit_depth < 8) {
#line 1285
    goto _L;
  } else
#line 1285
  if ((unsigned long )image.palette != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1287
    if (strategy_set == 0U) {
#line 1288
      strategy_set |= 1U;
    }
#line 1289
    if (filter_set == 0U) {
#line 1290
      filter_set |= 1U;
    }
  } else {
#line 1294
    if (strategy_set == 0U) {
#line 1295
      strategy_set |= 1U << 1;
    }
#line 1296
    if (filter_set == 0U) {
#line 1297
      filter_set |= 1U << 5;
    }
  }
  {
#line 1301
  process.compr_level_set = compr_level_set;
#line 1302
  process.mem_level_set = mem_level_set;
#line 1303
  process.strategy_set = strategy_set;
#line 1304
  process.filter_set = filter_set;
#line 1305
  strategy_singles_set = (opng_bitset_t )((1 << 2) | (1 << 3));
#line 1306
  tmp = opng_bitset_count(compr_level_set);
#line 1306
  tmp___0 = opng_bitset_count(strategy_set & ~ strategy_singles_set);
#line 1306
  t1 = (int )(tmp * tmp___0);
#line 1308
  tmp___1 = opng_bitset_count(strategy_set & strategy_singles_set);
#line 1308
  t2 = (int )tmp___1;
#line 1309
  tmp___2 = opng_bitset_count(mem_level_set);
#line 1309
  tmp___3 = opng_bitset_count(filter_set);
#line 1309
  process.num_iterations = (int )(((unsigned int )(t1 + t2) * tmp___2) * tmp___3);
  }
#line 1312
  if (! (process.num_iterations > 0)) {
    {
#line 1312
    (*usr_panic)("Invalid iteration parameters");
    }
  }
#line 1313
  return;
}
}
#line 1318 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_iterate(void) 
{ 
  opng_bitset_t compr_level_set ;
  opng_bitset_t mem_level_set ;
  opng_bitset_t strategy_set ;
  opng_bitset_t filter_set ;
  opng_bitset_t saved_compr_level_set ;
  int compr_level ;
  int mem_level ;
  int strategy ;
  int filter ;
  int counter ;
  int line_reused ;

  {
#line 1327
  if (! (process.num_iterations > 0)) {
    {
#line 1327
    (*usr_panic)("Iterations not initialized");
    }
  }
#line 1328
  if (process.num_iterations == 1) {
#line 1328
    if (process.status & 8192U) {
      {
#line 1334
      process.best_idat_size = (osys_fsize_t )0;
#line 1335
      process.best_compr_level = opng_bitset_find_first(process.compr_level_set);
#line 1336
      process.best_mem_level = opng_bitset_find_first(process.mem_level_set);
#line 1337
      process.best_strategy = opng_bitset_find_first(process.strategy_set);
#line 1338
      process.best_filter = opng_bitset_find_first(process.filter_set);
      }
#line 1339
      return;
    }
  }
  {
#line 1343
  compr_level_set = process.compr_level_set;
#line 1344
  mem_level_set = process.mem_level_set;
#line 1345
  strategy_set = process.strategy_set;
#line 1346
  filter_set = process.filter_set;
#line 1347
  process.best_idat_size = (osys_fsize_t )(idat_size_max + 1UL);
#line 1348
  process.best_compr_level = -1;
#line 1349
  process.best_mem_level = -1;
#line 1350
  process.best_strategy = -1;
#line 1351
  process.best_filter = -1;
#line 1354
  (*usr_printf)("\nTrying:\n");
#line 1355
  line_reused = 0;
#line 1356
  counter = 0;
#line 1357
  filter = 0;
  }
  {
#line 1357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1357
    if (! (filter <= 5)) {
#line 1357
      goto while_break;
    }
#line 1360
    if ((filter_set & (1U << filter)) != 0U) {
#line 1362
      strategy = 0;
      {
#line 1362
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1362
        if (! (strategy <= 3)) {
#line 1362
          goto while_break___0;
        }
#line 1365
        if ((strategy_set & (1U << strategy)) != 0U) {
#line 1370
          saved_compr_level_set = compr_level_set;
#line 1371
          if (strategy == 2) {
#line 1373
            compr_level_set = (opng_bitset_t )0;
#line 1374
            compr_level_set |= 1U << 1;
          } else
#line 1376
          if (strategy == 3) {
#line 1378
            compr_level_set = (opng_bitset_t )0;
#line 1379
            compr_level_set |= 1U << 9;
          }
#line 1381
          compr_level = 9;
          {
#line 1381
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1381
            if (! (compr_level >= 1)) {
#line 1381
              goto while_break___1;
            }
#line 1384
            if ((compr_level_set & (1U << compr_level)) != 0U) {
#line 1386
              mem_level = 9;
              {
#line 1386
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 1386
                if (! (mem_level >= 1)) {
#line 1386
                  goto while_break___2;
                }
#line 1389
                if ((mem_level_set & (1U << mem_level)) != 0U) {
                  {
#line 1391
                  (*usr_printf)("  zc = %d  zm = %d  zs = %d  f = %d", compr_level,
                                mem_level, strategy, filter);
#line 1394
                  (*usr_progress)((unsigned long )counter, (unsigned long )process.num_iterations);
#line 1395
                  counter ++;
#line 1396
                  opng_write_file((FILE *)((void *)0), compr_level, mem_level, strategy,
                                  filter);
                  }
#line 1398
                  if (process.out_idat_size > (osys_fsize_t )idat_size_max) {
#line 1400
                    if (options.verbose) {
                      {
#line 1402
                      (*usr_printf)("\t\tIDAT too big\n");
#line 1403
                      line_reused = 0;
                      }
                    } else {
                      {
#line 1407
                      (*usr_print_cntrl)('\r');
#line 1408
                      line_reused = 1;
                      }
                    }
#line 1410
                    goto __Cont;
                  }
                  {
#line 1412
                  (*usr_printf)("\t\tIDAT size = %lu\n", process.out_idat_size);
#line 1415
                  line_reused = 0;
                  }
#line 1416
                  if (process.best_idat_size < process.out_idat_size) {
#line 1417
                    goto __Cont;
                  }
#line 1418
                  if (process.best_idat_size == process.out_idat_size) {
#line 1418
                    if (process.best_strategy >= 2) {
#line 1420
                      goto __Cont;
                    }
                  }
#line 1421
                  process.best_compr_level = compr_level;
#line 1422
                  process.best_mem_level = mem_level;
#line 1423
                  process.best_strategy = strategy;
#line 1424
                  process.best_filter = filter;
#line 1425
                  process.best_idat_size = process.out_idat_size;
#line 1426
                  if (! options.full) {
#line 1427
                    process.max_idat_size = process.out_idat_size;
                  }
                }
                __Cont: /* CIL Label */ 
#line 1386
                mem_level --;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 1381
            compr_level --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1432
          compr_level_set = saved_compr_level_set;
        }
#line 1362
        strategy ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1357
    filter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1437
  if (line_reused) {
    {
#line 1438
    (*usr_print_cntrl)(-31);
    }
  }
#line 1440
  if (! (counter == process.num_iterations)) {
    {
#line 1440
    (*usr_panic)("Inconsistent iteration counter");
    }
  }
  {
#line 1442
  (*usr_progress)((unsigned long )counter, (unsigned long )process.num_iterations);
  }
#line 1443
  return;
}
}
#line 1448 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_finish_iterations(void) 
{ 


  {
#line 1451
  if (process.best_idat_size + (osys_fsize_t )process.out_plte_trns_size < process.in_idat_size + (osys_fsize_t )process.in_plte_trns_size) {
#line 1453
    process.status |= 8192U;
  }
#line 1454
  if (process.status & 8192U) {
#line 1456
    if (process.best_idat_size <= (osys_fsize_t )idat_size_max) {
      {
#line 1458
      (*usr_printf)("\nSelecting parameters:\n");
#line 1459
      (*usr_printf)("  zc = %d  zm = %d  zs = %d  f = %d", process.best_compr_level,
                    process.best_mem_level, process.best_strategy, process.best_filter);
      }
#line 1462
      if (process.best_idat_size > 0UL) {
        {
#line 1465
        (*usr_printf)("\t\tIDAT size = %lu", process.best_idat_size);
        }
      }
      {
#line 1468
      (*usr_printf)("\n");
      }
    } else {
      {
#line 1473
      (*usr_printf)("  zc = *  zm = *  zs = *  f = *\t\tIDAT size > %s\n", idat_size_max_string);
      }
    }
  }
#line 1477
  return;
}
}
#line 1485 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static FILE *infile  ;
#line 1485 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static FILE *outfile  ;
#line 1486 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static char const   *infile_name_local  ;
#line 1487 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static char const   *outfile_name  ;
#line 1487 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static char const   *bakfile_name  ;
#line 1488 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int new_outfile  ;
#line 1488 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static int has_backup  ;
#line 1482 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
static void opng_optimize_impl(char const   *infile_name ) 
{ 
  char name_buf[4096] ;
  char tmp_buf[4096] ;
  char const   * volatile  err_msg ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp_name ;
  char *tmp___1 ;
  int test_eq ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  jmp_buf * volatile  exception__prev___0 ;
  jmp_buf exception__env___0 ;
  char const   *tmp___12 ;
  jmp_buf * volatile  exception__prev___1 ;
  jmp_buf exception__env___1 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 1492
  memset((void *)(& process), 0, sizeof(process));
  }
#line 1493
  if (options.force) {
#line 1494
    process.status |= 8192U;
  }
  {
#line 1496
  err_msg = (char const   */* volatile  */)((void *)0);
#line 1498
  infile_name_local = infile_name;
#line 1499
  infile = fopen((char const   */* __restrict  */)infile_name_local, (char const   */* __restrict  */)"rb");
  }
#line 1499
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 1500
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1500
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open the input file";
#line 1500
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1501
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1501
  the_exception_context[0].penv = & exception__env;
#line 1501
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1501
  if (tmp == 0) {
    {
#line 1501
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1503
      opng_read_file(infile);
#line 1501
      the_exception_context[0].caught = 0;
      }
#line 1501
      if (! the_exception_context[0].caught) {
#line 1501
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1505
    the_exception_context[0].caught = 1;
  }
#line 1505
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1505
  if (! (! the_exception_context[0].caught)) {
#line 1505
    err_msg = the_exception_context[0].v.etmp;
#line 1507
    if (! ((unsigned long )err_msg != (unsigned long )((void *)0))) {
      {
#line 1507
      (*usr_panic)("Mysterious error in opng_read_file");
      }
    }
  }
  {
#line 1509
  fclose(infile);
  }
#line 1510
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1511
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1511
      the_exception_context[0].v.etmp = err_msg;
#line 1511
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1514
  if (process.status & 256U) {
    {
#line 1516
    (*usr_printf)("Recoverable errors found in input.");
    }
#line 1517
    if (options.fix) {
      {
#line 1519
      (*usr_printf)(" Fixing...\n");
#line 1520
      process.status |= 4096U;
      }
    } else {
      {
#line 1524
      (*usr_printf)(" Rerun OptiPNG with -fix enabled.\n");
      }
      {
#line 1525
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1525
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Previous error(s) not fixed";
#line 1525
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1530
  if (process.status & 128U) {
#line 1531
    process.status |= 4096U;
  }
#line 1534
  if (! (process.status & 4U)) {
#line 1535
    process.status |= 4096U;
  }
#line 1536
  if (process.status & 2U) {
#line 1538
    if (options.nz) {
#line 1538
      if (process.status & 8192U) {
        {
#line 1540
        (*usr_printf)("IDAT recoding is necessary, but is disabled by the user.\n");
        }
        {
#line 1542
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1542
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t continue";
#line 1542
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 1546
    process.status |= 8192U;
  }
#line 1549
  if (process.status & 8U) {
    {
#line 1551
    (*usr_printf)("Digital signature found in input.");
    }
#line 1552
    if (options.force) {
      {
#line 1554
      (*usr_printf)(" Erasing...\n");
#line 1555
      process.status |= 4096U;
      }
    } else {
      {
#line 1559
      (*usr_printf)(" Rerun OptiPNG with -force enabled.\n");
      }
      {
#line 1560
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1560
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t optimize digitally-signed files";
#line 1560
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1565
  if (process.status & 16U) {
#line 1567
    if (! options.snip) {
#line 1567
      if (! (process.status & 1U)) {
        {
#line 1569
        (*usr_printf)("Conversion to PNG requires snipping. Rerun OptiPNG with -snip enabled.\n");
        }
        {
#line 1571
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1571
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Incompatible input format";
#line 1571
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
  }
#line 1574
  if (process.status & 32U) {
#line 1574
    if (options.snip) {
#line 1575
      process.status |= 4096U;
    }
  }
#line 1578
  if (process.status & 64U) {
    {
#line 1579
    (*usr_printf)("Stripping metadata...\n");
    }
  }
#line 1582
  outfile_name = (char const   *)((void *)0);
#line 1583
  if (! (process.status & 1U)) {
    {
#line 1585
    tmp___0 = osys_path_chext(name_buf, sizeof(name_buf), infile_name_local, ".png");
    }
#line 1585
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 1587
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1587
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create the output file (name too long)";
#line 1587
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1588
    outfile_name = (char const   *)(name_buf);
  }
#line 1590
  if ((unsigned long )options.out_name != (unsigned long )((void *)0)) {
#line 1591
    outfile_name = options.out_name;
  }
#line 1592
  if ((unsigned long )options.dir_name != (unsigned long )((void *)0)) {
#line 1595
    if ((unsigned long )outfile_name != (unsigned long )((void *)0)) {
      {
#line 1597
      strcpy((char */* __restrict  */)(tmp_buf), (char const   */* __restrict  */)outfile_name);
#line 1598
      tmp_name = (char const   *)(tmp_buf);
      }
    } else {
#line 1601
      tmp_name = infile_name_local;
    }
    {
#line 1602
    tmp___1 = osys_path_chdir(name_buf, sizeof(name_buf), tmp_name, options.dir_name);
    }
#line 1602
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 1604
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1604
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create the output file (name too long)";
#line 1604
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 1605
    outfile_name = (char const   *)(name_buf);
  }
#line 1607
  if ((unsigned long )outfile_name == (unsigned long )((void *)0)) {
#line 1609
    outfile_name = infile_name_local;
#line 1610
    new_outfile = 0;
  } else {
    {
#line 1614
    tmp___2 = osys_test_eq(infile_name_local, outfile_name);
#line 1614
    test_eq = tmp___2;
    }
#line 1615
    if (test_eq >= 0) {
#line 1616
      new_outfile = test_eq == 0;
    } else {
      {
#line 1622
      tmp___3 = strcmp(infile_name_local, outfile_name);
#line 1622
      new_outfile = tmp___3 != 0;
      }
    }
  }
#line 1627
  bakfile_name = (char const   *)(tmp_buf);
#line 1628
  if (new_outfile) {
    {
#line 1630
    tmp___4 = osys_path_mkbak(tmp_buf, sizeof(tmp_buf), outfile_name);
    }
#line 1630
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 1632
      bakfile_name = (char const   *)((void *)0);
    }
  } else {
    {
#line 1636
    tmp___5 = osys_path_mkbak(tmp_buf, sizeof(tmp_buf), infile_name_local);
    }
#line 1636
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 1638
      bakfile_name = (char const   *)((void *)0);
    }
  }
#line 1641
  if ((unsigned long )bakfile_name == (unsigned long )((void *)0)) {
    {
#line 1642
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 1642
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create backup file (name too long)";
#line 1642
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 1644
  if (! options.simulate) {
    {
#line 1644
    tmp___8 = osys_test(outfile_name, "e");
    }
#line 1644
    if (tmp___8 == 0) {
#line 1646
      if (new_outfile) {
#line 1646
        if (! options.backup) {
#line 1646
          if (! options.clobber) {
            {
#line 1648
            (*usr_printf)("The output file exists. Rerun OptiPNG with -backup enabled.\n");
            }
            {
#line 1650
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 1650
              the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t overwrite the output file";
#line 1650
              longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                      1);
              }
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 1652
      tmp___6 = osys_test(outfile_name, "fw");
      }
#line 1652
      if (tmp___6 != 0) {
#line 1652
        goto _L;
      } else
#line 1652
      if (! options.clobber) {
        {
#line 1652
        tmp___7 = osys_test(bakfile_name, "e");
        }
#line 1652
        if (tmp___7 == 0) {
          _L: /* CIL Label */ 
          {
#line 1654
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 1654
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the existing output file";
#line 1654
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___10: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 1658
  if (process.status & 2U) {
    {
#line 1659
    (*usr_printf)("Input IDAT size = %lu bytes\n", process.in_idat_size);
    }
  }
  {
#line 1661
  (*usr_printf)("Input file size = %lu bytes\n", process.in_file_size);
  }
#line 1665
  if (! options.nz) {
    {
#line 1667
    opng_init_iterations();
#line 1668
    opng_iterate();
#line 1669
    opng_finish_iterations();
    }
  } else
#line 1665
  if (process.status & 8192U) {
    {
#line 1667
    opng_init_iterations();
#line 1668
    opng_iterate();
#line 1669
    opng_finish_iterations();
    }
  }
#line 1671
  if (process.status & 8192U) {
    {
#line 1673
    process.status |= 4096U;
#line 1674
    opng_check_idat_size(process.best_idat_size);
    }
  }
#line 1678
  if (! (process.status & 4096U)) {
    {
#line 1680
    (*usr_printf)("\n%s is already optimized.\n", infile_name_local);
    }
#line 1681
    if (! new_outfile) {
#line 1682
      return;
    }
  }
#line 1684
  if (options.simulate) {
    {
#line 1686
    (*usr_printf)("\nNo output: simulation mode.\n");
    }
#line 1687
    return;
  }
#line 1691
  if (new_outfile) {
    {
#line 1693
    (*usr_printf)("\nOutput file: %s\n", outfile_name);
    }
#line 1694
    if ((unsigned long )options.dir_name != (unsigned long )((void *)0)) {
      {
#line 1695
      osys_create_dir(options.dir_name);
      }
    }
    {
#line 1696
    has_backup = 0;
#line 1697
    tmp___10 = osys_test(outfile_name, "e");
    }
#line 1697
    if (tmp___10 == 0) {
      {
#line 1699
      tmp___9 = osys_rename(outfile_name, bakfile_name, options.clobber);
      }
#line 1699
      if (tmp___9 != 0) {
        {
#line 1700
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 1700
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the output file";
#line 1700
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 1701
      has_backup = 1;
    }
  } else {
    {
#line 1706
    tmp___11 = osys_rename(infile_name_local, bakfile_name, options.clobber);
    }
#line 1706
    if (tmp___11 != 0) {
      {
#line 1707
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1707
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the input file";
#line 1707
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1708
    has_backup = 1;
  }
  {
#line 1711
  outfile = fopen((char const   */* __restrict  */)outfile_name, (char const   */* __restrict  */)"wb");
#line 1712
  exception__prev___0 = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1712
  the_exception_context[0].penv = & exception__env___0;
#line 1712
  tmp___15 = _setjmp((struct __jmp_buf_tag *)(exception__env___0));
  }
#line 1712
  if (tmp___15 == 0) {
    {
#line 1712
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1714
      if ((unsigned long )outfile == (unsigned long )((void *)0)) {
        {
#line 1715
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 1715
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open the output file";
#line 1715
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 1716
      if (process.status & 8192U) {
        {
#line 1719
        opng_write_file(outfile, process.best_compr_level, process.best_mem_level,
                        process.best_strategy, process.best_filter);
        }
      } else {
#line 1726
        if (new_outfile) {
#line 1726
          tmp___12 = infile_name_local;
        } else {
#line 1726
          tmp___12 = bakfile_name;
        }
        {
#line 1726
        infile = fopen((char const   */* __restrict  */)tmp___12, (char const   */* __restrict  */)"rb");
        }
#line 1728
        if ((unsigned long )infile == (unsigned long )((void *)0)) {
          {
#line 1729
          while (1) {
            while_continue___15: /* CIL Label */ ;
            {
#line 1729
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t reopen the input file";
#line 1729
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___15: /* CIL Label */ ;
          }
        }
        {
#line 1730
        exception__prev___1 = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1730
        the_exception_context[0].penv = & exception__env___1;
#line 1730
        tmp___14 = _setjmp((struct __jmp_buf_tag *)(exception__env___1));
        }
#line 1730
        if (tmp___14 == 0) {
          {
#line 1730
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 1732
            if (process.in_datastream_offset > 0L) {
              {
#line 1732
              tmp___13 = osys_fseeko(infile, process.in_datastream_offset, 0);
              }
#line 1732
              if (tmp___13 != 0) {
                {
#line 1735
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  {
#line 1735
                  the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t reposition the input file";
#line 1735
                  longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                          1);
                  }
                }
                while_break___17: /* CIL Label */ ;
                }
              }
            }
            {
#line 1736
            process.best_idat_size = process.in_idat_size;
#line 1737
            opng_copy_file(infile, outfile);
#line 1730
            the_exception_context[0].caught = 0;
            }
#line 1730
            if (! the_exception_context[0].caught) {
#line 1730
              goto while_break___16;
            }
          }
          while_break___16: /* CIL Label */ ;
          }
        } else {
#line 1739
          the_exception_context[0].caught = 1;
        }
#line 1739
        the_exception_context[0].penv = (jmp_buf *)exception__prev___1;
#line 1739
        if (! (! the_exception_context[0].caught)) {
#line 1739
          err_msg = the_exception_context[0].v.etmp;
#line 1741
          if (! ((unsigned long )err_msg != (unsigned long )((void *)0))) {
            {
#line 1741
            (*usr_panic)("Mysterious error in opng_copy_file");
            }
          }
        }
        {
#line 1744
        fclose(infile);
        }
#line 1745
        if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
          {
#line 1746
          while (1) {
            while_continue___18: /* CIL Label */ ;
            {
#line 1746
            the_exception_context[0].v.etmp = err_msg;
#line 1746
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___18: /* CIL Label */ ;
          }
        }
      }
#line 1712
      the_exception_context[0].caught = 0;
#line 1712
      if (! the_exception_context[0].caught) {
#line 1712
        goto while_break___13;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
  } else {
#line 1749
    the_exception_context[0].caught = 1;
  }
#line 1749
  the_exception_context[0].penv = (jmp_buf *)exception__prev___0;
#line 1749
  if (! (! the_exception_context[0].caught)) {
#line 1749
    err_msg = the_exception_context[0].v.etmp;
#line 1751
    if ((unsigned long )outfile != (unsigned long )((void *)0)) {
      {
#line 1752
      fclose(outfile);
      }
    }
#line 1754
    if (has_backup) {
#line 1756
      if (new_outfile) {
#line 1756
        tmp___16 = outfile_name;
      } else {
#line 1756
        tmp___16 = infile_name_local;
      }
      {
#line 1756
      tmp___17 = osys_rename(bakfile_name, tmp___16, 1);
      }
#line 1756
      if (tmp___17 != 0) {
        {
#line 1759
        opng_print_warning("Can\'t recover the original file from backup");
        }
      }
    } else {
#line 1764
      if (! new_outfile) {
        {
#line 1764
        (*usr_panic)("Overwrote input with no temporary backup");
        }
      }
      {
#line 1766
      tmp___18 = osys_unlink(outfile_name);
      }
#line 1766
      if (tmp___18 != 0) {
        {
#line 1767
        opng_print_warning("Can\'t remove the broken output file");
        }
      }
    }
    {
#line 1769
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 1769
      the_exception_context[0].v.etmp = err_msg;
#line 1769
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___19: /* CIL Label */ ;
    }
  }
  {
#line 1772
  fclose(outfile);
  }
#line 1777
  if (options.preserve) {
#line 1778
    if (new_outfile) {
#line 1778
      tmp___19 = infile_name_local;
    } else {
#line 1778
      tmp___19 = bakfile_name;
    }
    {
#line 1778
    osys_copy_attr(tmp___19, outfile_name);
    }
  }
#line 1782
  if (! new_outfile) {
#line 1782
    if (! options.backup) {
      {
#line 1784
      tmp___20 = osys_unlink(bakfile_name);
      }
#line 1784
      if (tmp___20 != 0) {
        {
#line 1785
        opng_print_warning("Can\'t remove the backup file");
        }
      }
    }
  }
  {
#line 1789
  (*usr_printf)("\nOutput IDAT size = %lu bytes", process.out_idat_size);
  }
#line 1791
  if (process.status & 2U) {
    {
#line 1793
    (*usr_printf)(" (");
#line 1794
    opng_print_fsize_difference(process.in_idat_size, process.out_idat_size, 0);
#line 1796
    (*usr_printf)(")");
    }
  }
  {
#line 1798
  (*usr_printf)("\nOutput file size = %lu bytes (", process.out_file_size);
#line 1800
  opng_print_fsize_difference(process.in_file_size, process.out_file_size, 1);
#line 1802
  (*usr_printf)(")\n");
  }
#line 1803
  return;
}
}
#line 1808 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
int opng_initialize(struct opng_options  const  *init_options , struct opng_ui  const  *init_ui ) 
{ 


  {
#line 1813
  usr_printf = (void (*)(char const   *fmt  , ...))init_ui->printf_fn;
#line 1814
  usr_print_cntrl = (void (*)(int cntrl_code ))init_ui->print_cntrl_fn;
#line 1815
  usr_progress = (void (*)(unsigned long num , unsigned long denom ))init_ui->progress_fn;
#line 1816
  usr_panic = (void (*)(char const   *msg ))init_ui->panic_fn;
#line 1817
  if ((unsigned long )usr_printf == (unsigned long )((void *)0)) {
#line 1821
    return (-1);
  } else
#line 1817
  if ((unsigned long )usr_print_cntrl == (unsigned long )((void *)0)) {
#line 1821
    return (-1);
  } else
#line 1817
  if ((unsigned long )usr_progress == (unsigned long )((void *)0)) {
#line 1821
    return (-1);
  } else
#line 1817
  if ((unsigned long )usr_panic == (unsigned long )((void *)0)) {
#line 1821
    return (-1);
  }
#line 1824
  options = (struct opng_options )*init_options;
#line 1825
  if (options.optim_level == 0) {
#line 1827
    options.np = 1;
#line 1827
    options.nc = options.np;
#line 1827
    options.nb = options.nc;
#line 1828
    options.nz = 1;
  }
  {
#line 1832
  memset((void *)(& summary), 0, sizeof(summary));
#line 1833
  engine.started = 1;
  }
#line 1834
  return (0);
}
}
#line 1840 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
int opng_optimize(char const   *infile_name ) 
{ 
  char const   *err_msg ;
  int volatile   result ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  int tmp ;

  {
#line 1846
  if (! engine.started) {
    {
#line 1846
    (*usr_panic)("The OptiPNG engine is not running");
    }
  }
  {
#line 1848
  (*usr_printf)("** Processing: %s\n", infile_name);
#line 1849
  (summary.file_count) ++;
#line 1850
  opng_clear_image_info();
#line 1851
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1851
  the_exception_context[0].penv = & exception__env;
#line 1851
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1851
  if (tmp == 0) {
    {
#line 1851
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1853
      opng_optimize_impl(infile_name);
      }
#line 1854
      if (process.status & 256U) {
#line 1856
        (summary.err_count) ++;
#line 1857
        (summary.fix_count) ++;
      }
#line 1859
      if (process.status & 16U) {
#line 1861
        if (options.snip) {
#line 1862
          (summary.snip_count) ++;
        }
      }
#line 1864
      result = (int volatile   )0;
#line 1851
      the_exception_context[0].caught = 0;
#line 1851
      if (! the_exception_context[0].caught) {
#line 1851
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1866
    the_exception_context[0].caught = 1;
  }
#line 1866
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1866
  if (! (! the_exception_context[0].caught)) {
    {
#line 1866
    err_msg = (char const   *)the_exception_context[0].v.etmp;
#line 1868
    (summary.err_count) ++;
#line 1869
    opng_print_error(err_msg);
#line 1870
    result = (int volatile   )-1;
    }
  }
  {
#line 1872
  opng_destroy_image_info();
#line 1873
  (*usr_printf)("\n");
  }
#line 1874
  return ((int )result);
}
}
#line 1880 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optim.c"
int opng_finalize(void) 
{ 


  {
#line 1884
  if (options.verbose) {
#line 1884
    goto _L;
  } else
#line 1884
  if (summary.snip_count > 0U) {
#line 1884
    goto _L;
  } else
#line 1884
  if (summary.err_count > 0U) {
    _L: /* CIL Label */ 
    {
#line 1886
    (*usr_printf)("** Status report\n");
#line 1887
    (*usr_printf)("%u file(s) have been processed.\n", summary.file_count);
    }
#line 1888
    if (summary.snip_count > 0U) {
      {
#line 1890
      (*usr_printf)("%u multi-image file(s) have been snipped.\n", summary.snip_count);
      }
    }
#line 1893
    if (summary.err_count > 0U) {
      {
#line 1895
      (*usr_printf)("%u error(s) have been encountered.\n", summary.err_count);
      }
#line 1897
      if (summary.fix_count > 0U) {
        {
#line 1898
        (*usr_printf)("%u erroneous file(s) have been fixed.\n", summary.fix_count);
        }
      }
    }
  }
#line 1904
  engine.started = 0;
#line 1905
  return (0);
}
}
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 294
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 517
extern int fputc(int __c , FILE *__stream ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char const   *msg_intro  =    "OptiPNG version 0.7.6\nCopyright (C) 2001-2016 Cosmin Truta and the Contributing Authors.\n";
#line 42 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char const   *msg_license  =    "This program is open-source software. See LICENSE for more details.\n\nPortions of this software are based in part on the work of:\n  Jean-loup Gailly and Mark Adler (zlib)\n  Glenn Randers-Pehrson and the PNG Development Group (libpng)\n  Miyasaka Masaru (BMP support)\n  David Koblas (GIF support)\n";
#line 51 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char const   *msg_help_synopsis  =    "Synopsis:\n    optipng [options] files ...\nFiles:\n    Image files of type: PNG, BMP, GIF, PNM or TIFF\n";
#line 57 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char const   *msg_help_basic_options  =    "Basic options:\n    -?, -h, -help\tshow the extended help\n    -o <level>\t\toptimization level (0-7)\t\t[default: 2]\n    -v\t\t\trun in verbose mode / show copyright and version info\n";
#line 63 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char const   *msg_help_options  =    "Basic options:\n    -?, -h, -help\tshow this help\n    -o <level>\t\toptimization level (0-7)\t\t[default: 2]\n    -v\t\t\trun in verbose mode / show copyright and version info\nGeneral options:\n    -backup, -keep\tkeep a backup of the modified files\n    -clobber\t\toverwrite existing files\n    -fix\t\tenable error recovery\n    -force\t\tenforce writing of a new output file\n    -preserve\t\tpreserve file attributes if possible\n    -quiet, -silent\trun in quiet mode\n    -simulate\t\trun in simulation mode\n    -out <file>\t\twrite output file to <file>\n    -dir <directory>\twrite output file(s) to <directory>\n    -log <file>\t\tlog messages to <file>\n    --\t\t\tstop option switch parsing\nOptimization options:\n    -f <filters>\tPNG delta filters (0-5)\t\t\t[default: 0,5]\n    -i <type>\t\tPNG interlace type (0-1)\n    -zc <levels>\tzlib compression levels (1-9)\t\t[default: 9]\n    -zm <levels>\tzlib memory levels (1-9)\t\t[default: 8]\n    -zs <strategies>\tzlib compression strategies (0-3)\t[default: 0-3]\n    -zw <size>\t\tzlib window size (256,512,1k,2k,4k,8k,16k,32k)\n    -full\t\tproduce a full report on IDAT (might reduce speed)\n    -nb\t\t\tno bit depth reduction\n    -nc\t\t\tno color type reduction\n    -np\t\t\tno palette reduction\n    -nx\t\t\tno reductions\n    -nz\t\t\tno IDAT recoding\nEditing options:\n    -snip\t\tcut one image out of multi-image or animation files\n    -strip <objects>\tstrip metadata objects (e.g. \"all\")\nOptimization levels:\n    -o0\t\t<=>\t-o1 -nx -nz\t\t\t\t(0 or 1 trials)\n    -o1\t\t<=>\t-zc9 -zm8 -zs0 -f0\t\t\t(1 trial)\n    \t\t(or...)\t-zc9 -zm8 -zs1 -f5\t\t\t(1 trial)\n    -o2\t\t<=>\t-zc9 -zm8 -zs0-3 -f0,5\t\t\t(8 trials)\n    -o3\t\t<=>\t-zc9 -zm8-9 -zs0-3 -f0,5\t\t(16 trials)\n    -o4\t\t<=>\t-zc9 -zm8 -zs0-3 -f0-5\t\t\t(24 trials)\n    -o5\t\t<=>\t-zc9 -zm8-9 -zs0-3 -f0-5\t\t(48 trials)\n    -o6\t\t<=>\t-zc1-9 -zm8 -zs0-3 -f0-5\t\t(120 trials)\n    -o7\t\t<=>\t-zc1-9 -zm8-9 -zs0-3 -f0-5\t\t(240 trials)\n    -o7 -zm1-9\t<=>\t-zc1-9 -zm1-9 -zs0-3 -f0-5\t\t(1080 trials)\nNotes:\n    The combination for -o1 is chosen heuristically.\n    Exhaustive combinations such as \"-o7 -zm1-9\" are not generally recommended.\n";
#line 114 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char const   *msg_help_examples  =    "Examples:\n    optipng file.png\t\t\t\t\t\t(default speed)\n    optipng -o5 file.png\t\t\t\t\t(slow)\n    optipng -o7 file.png\t\t\t\t\t(very slow)\n";
#line 120 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char const   *msg_help_more  =    "Type \"optipng -h\" for extended help.\n";
#line 124 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static enum __anonenum_operation_981116399 operation  ;
#line 131 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static struct __anonstruct_local_options_1002814925 local_options  ;
#line 137 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static struct opng_options options___0  ;
#line 139 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static FILE *con_file  ;
#line 140 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static FILE *log_file  ;
#line 142 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int start_of_line  ;
#line 148 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void error(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;

  {
  {
#line 154
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Error: ");
#line 155
  __builtin_va_start(arg_ptr, fmt);
#line 156
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
#line 157
  __builtin_va_end(arg_ptr);
#line 158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 159
  exit(1);
  }
}
}
#line 165 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void panic(char const   *msg___0 ) 
{ 


  {
  {
#line 169
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n** INTERNAL ERROR: %s\n",
          msg___0);
#line 170
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please submit a defect report.\nhttp://optipng.sourceforge.net/\n\n");
#line 171
  fflush(stderr);
  }
#line 172
  if (options___0.debug) {
    {
#line 175
    abort();
    }
  } else {
    {
#line 180
    osys_terminate();
    }
  }
#line 182
  return;
}
}
#line 187 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int opng_strcasecmp(char const   *str1 , char const   *str2 ) 
{ 
  int ch1 ;
  int ch2 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    tmp = str1;
#line 195
    str1 ++;
#line 195
    ch1 = tolower((int )*tmp);
#line 196
    tmp___0 = str2;
#line 196
    str2 ++;
#line 196
    ch2 = tolower((int )*tmp___0);
    }
#line 197
    if (ch1 != ch2) {
#line 198
      return (ch1 - ch2);
    }
#line 199
    if (ch1 == 0) {
#line 200
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 208 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char *opng_strltrim(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    tmp = __ctype_b_loc();
    }
#line 212
    if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 212
      goto while_break;
    }
#line 213
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((char *)str);
}
}
#line 220 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char *opng_strtail(char const   *str , size_t num ) 
{ 
  size_t len ;

  {
  {
#line 226
  len = strlen(str);
  }
#line 227
  if (len <= num) {
#line 228
    return ((char *)str);
  }
#line 229
  return (((char *)str + len) - num);
}
}
#line 235 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static char *opng_strpbrk_digit(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if ((int const   )*str == 0) {
#line 241
      return ((char *)((void *)0));
    }
    {
#line 242
    tmp = __ctype_b_loc();
    }
#line 242
    if ((int const   )*(*tmp + (int )*str) & 2048) {
#line 243
      return ((char *)str);
    }
#line 244
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 251 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int opng_str2ulong(unsigned long *out_val , char const   *in_str , int allow_multiplier ) 
{ 
  char const   *begin_ptr ;
  char *end_ptr ;
  unsigned long multiplier ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 261
  end_ptr = opng_strltrim(in_str);
#line 261
  begin_ptr = (char const   *)end_ptr;
  }
#line 262
  if ((int const   )*begin_ptr >= 48) {
#line 262
    if ((int const   )*begin_ptr <= 57) {
      {
#line 263
      *out_val = strtoul((char const   */* __restrict  */)begin_ptr, (char **/* __restrict  */)(& end_ptr),
                         10);
      }
    }
  }
#line 264
  if ((unsigned long )begin_ptr == (unsigned long )end_ptr) {
    {
#line 266
    tmp = __errno_location();
#line 266
    *tmp = 22;
#line 267
    *out_val = 0UL;
    }
#line 268
    return (-1);
  }
#line 271
  if (allow_multiplier) {
#line 278
    if ((int )*end_ptr == 107) {
#line 280
      end_ptr ++;
#line 281
      multiplier = 1024UL;
    } else
#line 278
    if ((int )*end_ptr == 75) {
#line 280
      end_ptr ++;
#line 281
      multiplier = 1024UL;
    } else
#line 283
    if ((int )*end_ptr == 77) {
#line 285
      end_ptr ++;
#line 286
      multiplier = 1048576UL;
    } else
#line 288
    if ((int )*end_ptr == 71) {
#line 290
      end_ptr ++;
#line 291
      multiplier = 1073741824UL;
    } else {
#line 294
      multiplier = 1UL;
    }
#line 295
    if (multiplier > 1UL) {
#line 297
      if (*out_val > 0xffffffffffffffffUL / multiplier) {
        {
#line 299
        tmp___0 = __errno_location();
#line 299
        *tmp___0 = 34;
#line 300
        *out_val = 0xffffffffffffffffUL;
        }
      } else {
#line 303
        *out_val *= multiplier;
      }
    }
  }
  {
#line 308
  tmp___2 = opng_strltrim((char const   *)end_ptr);
  }
#line 308
  if ((int )*tmp___2 != 0) {
    {
#line 310
    tmp___1 = __errno_location();
#line 310
    *tmp___1 = 22;
    }
#line 311
    return (-1);
  }
#line 313
  return (0);
}
}
#line 319 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int opng_rangeset2bitset(opng_bitset_t *out_val , char const   *in_str ) 
{ 
  size_t end_idx ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 325
  *out_val = opng_rangeset_string_to_bitset(in_str, & end_idx);
  }
#line 326
  if (end_idx == 0UL) {
    {
#line 328
    tmp = __errno_location();
#line 328
    *tmp = 22;
    }
#line 329
    return (-1);
  } else {
    {
#line 326
    tmp___0 = opng_strltrim(in_str + end_idx);
    }
#line 326
    if ((int )*tmp___0 != 0) {
      {
#line 328
      tmp = __errno_location();
#line 328
      *tmp = 22;
      }
#line 329
      return (-1);
    }
  }
#line 331
  return (0);
}
}
#line 337 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void err_option_arg(char const   *opt , char const   *opt_arg ) 
{ 
  char *tmp ;

  {
#line 341
  if ((unsigned long )opt_arg == (unsigned long )((void *)0)) {
    {
#line 342
    error("Missing argument for option %s", opt);
    }
  } else {
    {
#line 341
    tmp = opng_strltrim(opt_arg);
    }
#line 341
    if ((int )*tmp == 0) {
      {
#line 342
      error("Missing argument for option %s", opt);
      }
    } else {
      {
#line 344
      error("Invalid argument for option %s: %s", opt, opt_arg);
      }
    }
  }
#line 345
  return;
}
}
#line 350 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int check_num_option(char const   *opt , char const   *opt_arg , int lowest ,
                            int highest ) 
{ 
  unsigned long value ;
  int tmp ;

  {
  {
#line 357
  tmp = opng_str2ulong(& value, opt_arg, 0);
  }
#line 357
  if (tmp != 0) {
    {
#line 359
    err_option_arg(opt, opt_arg);
    }
  } else
#line 357
  if (value > 2147483647UL) {
    {
#line 359
    err_option_arg(opt, opt_arg);
    }
  } else
#line 357
  if ((int )value < lowest) {
    {
#line 359
    err_option_arg(opt, opt_arg);
    }
  } else
#line 357
  if ((int )value > highest) {
    {
#line 359
    err_option_arg(opt, opt_arg);
    }
  }
#line 360
  return ((int )value);
}
}
#line 366 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int check_power2_option(char const   *opt , char const   *opt_arg , int lowest ,
                               int highest ) 
{ 
  unsigned long value ;
  int result ;
  int tmp ;

  {
  {
#line 375
  tmp = opng_str2ulong(& value, opt_arg, 1);
  }
#line 375
  if (tmp == 0) {
#line 377
    if (lowest < 0) {
#line 378
      lowest = 0;
    }
#line 379
    if (highest > (int )(8UL * sizeof(long ) - 2UL)) {
#line 380
      highest = (int )(8UL * sizeof(long ) - 2UL);
    }
#line 381
    result = lowest;
    {
#line 381
    while (1) {
      while_continue: /* CIL Label */ ;
#line 381
      if (! (result <= highest)) {
#line 381
        goto while_break;
      }
#line 383
      if (1UL << result == value) {
#line 384
        return (result);
      }
#line 381
      result ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 387
  err_option_arg(opt, opt_arg);
  }
#line 388
  return (-1);
}
}
#line 394 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static opng_bitset_t check_rangeset_option(char const   *opt , char const   *opt_arg ,
                                           opng_bitset_t result_mask ) 
{ 
  opng_bitset_t result ;
  int tmp ;

  {
  {
#line 401
  tmp = opng_rangeset2bitset(& result, opt_arg);
  }
#line 401
  if (tmp == 0) {
#line 402
    result &= result_mask;
  } else {
#line 404
    result = (opng_bitset_t )0;
  }
#line 405
  if (result == 0U) {
    {
#line 406
    err_option_arg(opt, opt_arg);
    }
  }
#line 407
  return (result);
}
}
#line 413 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void check_obj_option(char const   *opt , char const   *opt_arg ) 
{ 
  unsigned int i ;
  int tmp ;

  {
  {
#line 418
  tmp = strcmp("all", opt_arg);
  }
#line 418
  if (tmp == 0) {
#line 419
    return;
  }
#line 423
  i = 0U;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i < 4U)) {
#line 423
      goto while_break;
    }
#line 426
    if ((int const   )*(opt_arg + i) >= 65) {
#line 426
      if (! ((int const   )*(opt_arg + i) <= 90)) {
#line 426
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 426
    if ((int const   )*(opt_arg + i) >= 97) {
#line 426
      if (! ((int const   )*(opt_arg + i) <= 122)) {
#line 428
        goto while_break;
      }
    } else {
#line 428
      goto while_break;
    }
#line 423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  if (i == 4U) {
#line 430
    if ((int const   )*(opt_arg + i) == 0) {
      {
#line 431
      error("Manipulation of individual chunks is not implemented");
      }
    } else {
      {
#line 433
      err_option_arg(opt, opt_arg);
      }
    }
  } else {
    {
#line 433
    err_option_arg(opt, opt_arg);
    }
  }
#line 434
  return;
}
}
#line 439 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int scan_option(char const   *str , char *opt_buf , size_t opt_buf_size , char const   **opt_arg_ptr ) 
{ 
  char const   *ptr ;
  unsigned int opt_len ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 447
  if ((int const   )*(str + 0) != 45) {
#line 448
    return (0);
  } else
#line 447
  if ((int const   )*(str + 1) == 0) {
#line 448
    return (0);
  }
#line 451
  opt_len = 0U;
#line 452
  ptr = str + 1;
  {
#line 453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 453
    if (! ((int const   )*ptr == 45)) {
#line 453
      goto while_break;
    }
#line 454
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 455
  if ((int const   )*ptr == 0) {
#line 456
    ptr --;
  }
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 459
    if ((size_t )opt_len < opt_buf_size) {
      {
#line 460
      tmp = tolower((int )*ptr);
#line 460
      *(opt_buf + opt_len) = (char )tmp;
      }
    }
#line 461
    opt_len ++;
#line 462
    ptr ++;
#line 463
    if ((int const   )*ptr == 0) {
#line 463
      goto _L;
    } else {
      {
#line 463
      tmp___1 = __ctype_b_loc();
      }
#line 463
      if ((int const   )*(*tmp___1 + (int )*ptr) & 8192) {
        _L: /* CIL Label */ 
        {
#line 465
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 465
          tmp___0 = __ctype_b_loc();
          }
#line 465
          if (! ((int const   )*(*tmp___0 + (int )*ptr) & 8192)) {
#line 465
            goto while_break___1;
          }
#line 466
          ptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 467
        if ((int const   )*ptr != 0) {
#line 467
          *opt_arg_ptr = ptr;
        } else {
#line 467
          *opt_arg_ptr = (char const   *)((void *)0);
        }
#line 468
        goto while_break___0;
      }
    }
#line 470
    if ((int const   )*ptr == 61) {
#line 472
      ptr ++;
#line 473
      *opt_arg_ptr = ptr;
#line 474
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 479
  if (opt_buf_size > 0UL) {
#line 481
    if ((size_t )opt_len < opt_buf_size) {
#line 482
      *(opt_buf + opt_len) = (char )'\000';
    } else {
#line 484
      *(opt_buf + (opt_buf_size - 1UL)) = (char )'\000';
    }
  }
#line 486
  return (1);
}
}
#line 492 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void parse_args(int argc , char **argv ) 
{ 
  char *arg ;
  char opt[16] ;
  size_t opt_len ;
  char const   *xopt ;
  int simple_opt ;
  int stop_switch ;
  opng_bitset_t set ;
  int val ;
  unsigned int file_count ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
  {
#line 506
  memset((void *)(& options___0), 0, sizeof(options___0));
#line 507
  options___0.optim_level = -1;
#line 508
  options___0.interlace = -1;
#line 509
  file_count = 0U;
#line 512
  stop_switch = 0;
#line 513
  i = 1;
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! (i < argc)) {
#line 513
      goto while_break;
    }
#line 515
    arg = *(argv + i);
#line 516
    if (stop_switch) {
#line 518
      file_count ++;
#line 519
      goto __Cont;
    } else {
      {
#line 516
      tmp = scan_option((char const   *)arg, opt, sizeof(opt), & xopt);
      }
#line 516
      if (tmp < 1) {
#line 518
        file_count ++;
#line 519
        goto __Cont;
      }
    }
    {
#line 521
    opt_len = strlen((char const   *)(opt));
#line 524
    *(argv + i) = (char *)((void *)0);
#line 527
    tmp___2 = strchr("fio", (int )opt[0]);
    }
#line 527
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 527
      tmp___3 = __ctype_b_loc();
      }
#line 527
      if ((int const   )*(*tmp___3 + (int )opt[1]) & 2048) {
        {
#line 533
        tmp___0 = opng_strpbrk_digit((char const   *)(opt));
#line 533
        opt_len = (size_t )(tmp___0 - opt);
#line 534
        opt[opt_len] = (char )'\000';
#line 535
        tmp___1 = opng_strpbrk_digit((char const   *)arg);
#line 535
        xopt = (char const   *)tmp___1;
        }
      } else {
#line 527
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 527
    if ((int )opt[0] == 122) {
      {
#line 527
      tmp___4 = __ctype_b_loc();
      }
#line 527
      if ((int const   )*(*tmp___4 + (int )opt[1]) & 1024) {
        {
#line 527
        tmp___5 = __ctype_b_loc();
        }
#line 527
        if ((int const   )*(*tmp___5 + (int )opt[2]) & 2048) {
          {
#line 533
          tmp___0 = opng_strpbrk_digit((char const   *)(opt));
#line 533
          opt_len = (size_t )(tmp___0 - opt);
#line 534
          opt[opt_len] = (char )'\000';
#line 535
          tmp___1 = opng_strpbrk_digit((char const   *)arg);
#line 535
          xopt = (char const   *)tmp___1;
          }
        }
      }
    }
    {
#line 539
    simple_opt = 1;
#line 540
    tmp___28 = strcmp("-", (char const   *)(opt));
    }
#line 540
    if (tmp___28 == 0) {
#line 543
      stop_switch = 1;
    } else {
      {
#line 545
      tmp___26 = strcmp("?", (char const   *)(opt));
      }
#line 545
      if (tmp___26 == 0) {
#line 549
        local_options.help = 1;
      } else {
        {
#line 545
        tmp___27 = strncmp("help", (char const   *)(opt), opt_len);
        }
#line 545
        if (tmp___27 == 0) {
#line 549
          local_options.help = 1;
        } else {
          {
#line 551
          tmp___24 = strncmp("backup", (char const   *)(opt), opt_len);
          }
#line 551
          if (tmp___24 == 0) {
#line 555
            options___0.backup = 1;
          } else {
            {
#line 551
            tmp___25 = strncmp("keep", (char const   *)(opt), opt_len);
            }
#line 551
            if (tmp___25 == 0) {
#line 555
              options___0.backup = 1;
            } else {
              {
#line 557
              tmp___23 = strncmp("clobber", (char const   *)(opt), opt_len);
              }
#line 557
              if (tmp___23 == 0) {
#line 560
                options___0.clobber = 1;
              } else {
                {
#line 562
                tmp___22 = strcmp("debug", (char const   *)(opt));
                }
#line 562
                if (tmp___22 == 0) {
#line 566
                  options___0.debug = 1;
                } else {
                  {
#line 568
                  tmp___21 = strncmp("fix", (char const   *)(opt), opt_len);
                  }
#line 568
                  if (tmp___21 == 0) {
#line 568
                    if (opt_len >= 2UL) {
#line 571
                      options___0.fix = 1;
                    } else {
#line 568
                      goto _L___7;
                    }
                  } else {
                    _L___7: /* CIL Label */ 
                    {
#line 573
                    tmp___20 = strncmp("force", (char const   *)(opt), opt_len);
                    }
#line 573
                    if (tmp___20 == 0) {
#line 573
                      if (opt_len >= 2UL) {
#line 576
                        options___0.force = 1;
                      } else {
#line 573
                        goto _L___6;
                      }
                    } else {
                      _L___6: /* CIL Label */ 
                      {
#line 578
                      tmp___19 = strncmp("full", (char const   *)(opt), opt_len);
                      }
#line 578
                      if (tmp___19 == 0) {
#line 578
                        if (opt_len >= 2UL) {
#line 581
                          options___0.full = 1;
                        } else {
#line 578
                          goto _L___5;
                        }
                      } else {
                        _L___5: /* CIL Label */ 
                        {
#line 583
                        tmp___18 = strcmp("nb", (char const   *)(opt));
                        }
#line 583
                        if (tmp___18 == 0) {
#line 586
                          options___0.nb = 1;
                        } else {
                          {
#line 588
                          tmp___17 = strcmp("nc", (char const   *)(opt));
                          }
#line 588
                          if (tmp___17 == 0) {
#line 591
                            options___0.nc = 1;
                          } else {
                            {
#line 593
                            tmp___16 = strcmp("np", (char const   *)(opt));
                            }
#line 593
                            if (tmp___16 == 0) {
#line 596
                              options___0.np = 1;
                            } else {
                              {
#line 598
                              tmp___15 = strcmp("nx", (char const   *)(opt));
                              }
#line 598
                              if (tmp___15 == 0) {
#line 601
                                options___0.np = 1;
#line 601
                                options___0.nc = options___0.np;
#line 601
                                options___0.nb = options___0.nc;
                              } else {
                                {
#line 604
                                tmp___14 = strcmp("nz", (char const   *)(opt));
                                }
#line 604
                                if (tmp___14 == 0) {
#line 607
                                  options___0.nz = 1;
                                } else {
                                  {
#line 609
                                  tmp___13 = strncmp("preserve", (char const   *)(opt),
                                                     opt_len);
                                  }
#line 609
                                  if (tmp___13 == 0) {
#line 612
                                    options___0.preserve = 1;
                                  } else {
                                    {
#line 614
                                    tmp___11 = strncmp("quiet", (char const   *)(opt),
                                                       opt_len);
                                    }
#line 614
                                    if (tmp___11 == 0) {
#line 618
                                      options___0.quiet = 1;
                                    } else {
                                      {
#line 614
                                      tmp___12 = strncmp("silent", (char const   *)(opt),
                                                         opt_len);
                                      }
#line 614
                                      if (tmp___12 == 0) {
#line 614
                                        if (opt_len >= 3UL) {
#line 618
                                          options___0.quiet = 1;
                                        } else {
#line 614
                                          goto _L___4;
                                        }
                                      } else {
                                        _L___4: /* CIL Label */ 
                                        {
#line 620
                                        tmp___10 = strncmp("simulate", (char const   *)(opt),
                                                           opt_len);
                                        }
#line 620
                                        if (tmp___10 == 0) {
#line 620
                                          if (opt_len >= 3UL) {
#line 623
                                            options___0.simulate = 1;
                                          } else {
#line 620
                                            goto _L___3;
                                          }
                                        } else {
                                          _L___3: /* CIL Label */ 
                                          {
#line 625
                                          tmp___9 = strncmp("snip", (char const   *)(opt),
                                                            opt_len);
                                          }
#line 625
                                          if (tmp___9 == 0) {
#line 625
                                            if (opt_len >= 2UL) {
#line 628
                                              options___0.snip = 1;
                                            } else {
#line 625
                                              goto _L___2;
                                            }
                                          } else {
                                            _L___2: /* CIL Label */ 
                                            {
#line 630
                                            tmp___8 = strcmp("v", (char const   *)(opt));
                                            }
#line 630
                                            if (tmp___8 == 0) {
#line 633
                                              options___0.verbose = 1;
#line 634
                                              local_options.version = 1;
                                            } else {
                                              {
#line 636
                                              tmp___7 = strncmp("verbose", (char const   *)(opt),
                                                                opt_len);
                                              }
#line 636
                                              if (tmp___7 == 0) {
#line 636
                                                if (opt_len >= 4UL) {
#line 639
                                                  options___0.verbose = 1;
                                                } else {
#line 636
                                                  goto _L___1;
                                                }
                                              } else {
                                                _L___1: /* CIL Label */ 
                                                {
#line 641
                                                tmp___6 = strncmp("version", (char const   *)(opt),
                                                                  opt_len);
                                                }
#line 641
                                                if (tmp___6 == 0) {
#line 641
                                                  if (opt_len >= 4UL) {
#line 644
                                                    local_options.version = 1;
                                                  } else {
#line 641
                                                    goto _L___0;
                                                  }
                                                } else {
                                                  _L___0: /* CIL Label */ 
#line 648
                                                  simple_opt = 0;
#line 649
                                                  if ((unsigned long )xopt == (unsigned long )((void *)0)) {
#line 651
                                                    i ++;
#line 651
                                                    if (i < argc) {
#line 653
                                                      xopt = (char const   *)*(argv + i);
#line 655
                                                      *(argv + i) = (char *)((void *)0);
                                                    } else {
#line 660
                                                      xopt = "";
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 666
    if (simple_opt) {
#line 668
      if ((unsigned long )xopt != (unsigned long )((void *)0)) {
        {
#line 669
        error("No argument allowed for option: %s", arg);
        }
      }
    } else {
      {
#line 671
      tmp___39 = strcmp("o", (char const   *)(opt));
      }
#line 671
      if (tmp___39 == 0) {
        {
#line 674
        val = check_num_option("-o", xopt, 0, 2147483647);
        }
#line 675
        if (options___0.optim_level < 0) {
#line 676
          options___0.optim_level = val;
        } else
#line 677
        if (options___0.optim_level != val) {
          {
#line 678
          error("Multiple optimization levels are not permitted");
          }
        }
      } else {
        {
#line 680
        tmp___38 = strcmp("i", (char const   *)(opt));
        }
#line 680
        if (tmp___38 == 0) {
          {
#line 683
          val = check_num_option("-i", xopt, 0, 1);
          }
#line 684
          if (options___0.interlace < 0) {
#line 685
            options___0.interlace = val;
          } else
#line 686
          if (options___0.interlace != val) {
            {
#line 687
            error("Multiple interlace types are not permitted");
            }
          }
        } else {
          {
#line 689
          tmp___37 = strcmp("f", (char const   *)(opt));
          }
#line 689
          if (tmp___37 == 0) {
            {
#line 692
            set = check_rangeset_option("-f", xopt, (opng_bitset_t )((1 << 6) - 1));
#line 693
            options___0.filter_set |= set;
            }
          } else {
            {
#line 695
            tmp___36 = strcmp("zc", (char const   *)(opt));
            }
#line 695
            if (tmp___36 == 0) {
              {
#line 698
              set = check_rangeset_option("-zc", xopt, (opng_bitset_t )((1 << 10) - (1 << 1)));
#line 699
              options___0.compr_level_set |= set;
              }
            } else {
              {
#line 701
              tmp___35 = strcmp("zm", (char const   *)(opt));
              }
#line 701
              if (tmp___35 == 0) {
                {
#line 704
                set = check_rangeset_option("-zm", xopt, (opng_bitset_t )((1 << 10) - (1 << 1)));
#line 705
                options___0.mem_level_set |= set;
                }
              } else {
                {
#line 707
                tmp___34 = strcmp("zs", (char const   *)(opt));
                }
#line 707
                if (tmp___34 == 0) {
                  {
#line 710
                  set = check_rangeset_option("-zs", xopt, (opng_bitset_t )((1 << 4) - 1));
#line 711
                  options___0.strategy_set |= set;
                  }
                } else {
                  {
#line 713
                  tmp___33 = strcmp("zw", (char const   *)(opt));
                  }
#line 713
                  if (tmp___33 == 0) {
                    {
#line 716
                    val = check_power2_option("-zw", xopt, 8, 15);
                    }
#line 717
                    if (options___0.window_bits == 0) {
#line 718
                      options___0.window_bits = val;
                    } else
#line 719
                    if (options___0.window_bits != val) {
                      {
#line 720
                      error("Multiple window sizes are not permitted");
                      }
                    }
                  } else {
                    {
#line 722
                    tmp___32 = strncmp("strip", (char const   *)(opt), opt_len);
                    }
#line 722
                    if (tmp___32 == 0) {
#line 722
                      if (opt_len >= 2UL) {
                        {
#line 725
                        check_obj_option("-strip", xopt);
#line 726
                        options___0.strip_all = 1;
                        }
                      } else {
#line 722
                        goto _L___9;
                      }
                    } else {
                      _L___9: /* CIL Label */ 
                      {
#line 728
                      tmp___31 = strncmp("out", (char const   *)(opt), opt_len);
                      }
#line 728
                      if (tmp___31 == 0) {
#line 728
                        if (opt_len >= 2UL) {
#line 731
                          if ((unsigned long )options___0.out_name != (unsigned long )((void *)0)) {
                            {
#line 732
                            error("Multiple output file names are not permitted");
                            }
                          }
#line 733
                          if ((int const   )*(xopt + 0) == 0) {
                            {
#line 734
                            err_option_arg("-out", (char const   *)((void *)0));
                            }
                          }
#line 735
                          options___0.out_name = xopt;
                        } else {
#line 728
                          goto _L___8;
                        }
                      } else {
                        _L___8: /* CIL Label */ 
                        {
#line 737
                        tmp___30 = strncmp("dir", (char const   *)(opt), opt_len);
                        }
#line 737
                        if (tmp___30 == 0) {
#line 740
                          if ((unsigned long )options___0.dir_name != (unsigned long )((void *)0)) {
                            {
#line 741
                            error("Multiple output dir names are not permitted");
                            }
                          }
#line 742
                          if ((int const   )*(xopt + 0) == 0) {
                            {
#line 743
                            err_option_arg("-dir", (char const   *)((void *)0));
                            }
                          }
#line 744
                          options___0.dir_name = xopt;
                        } else {
                          {
#line 746
                          tmp___29 = strncmp("log", (char const   *)(opt), opt_len);
                          }
#line 746
                          if (tmp___29 == 0) {
#line 749
                            if ((unsigned long )options___0.log_name != (unsigned long )((void *)0)) {
                              {
#line 750
                              error("Multiple log file names are not permitted");
                              }
                            }
#line 751
                            if ((int const   )*(xopt + 0) == 0) {
                              {
#line 752
                              err_option_arg("-log", (char const   *)((void *)0));
                              }
                            }
#line 753
                            options___0.log_name = xopt;
                          } else {
                            {
#line 757
                            error("Unrecognized option: %s", arg);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 513
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 762
  if ((unsigned long )options___0.out_name != (unsigned long )((void *)0)) {
#line 764
    if (file_count > 1U) {
      {
#line 765
      error("The option -out requires one input file");
      }
    }
#line 766
    if ((unsigned long )options___0.dir_name != (unsigned long )((void *)0)) {
      {
#line 767
      error("The options -out and -dir are mutually exclusive");
      }
    }
  }
#line 769
  if ((unsigned long )options___0.log_name != (unsigned long )((void *)0)) {
    {
#line 771
    tmp___40 = opng_strtail(options___0.log_name, (size_t )4);
#line 771
    tmp___41 = opng_strcasecmp(".log", (char const   *)tmp___40);
    }
#line 771
    if (tmp___41 != 0) {
      {
#line 772
      error("To prevent accidental data corruption, the log file name must end with \".log\"");
      }
    }
  }
#line 775
  if (local_options.help) {
#line 776
    operation = (enum __anonenum_operation_981116399 )1;
  } else
#line 777
  if (file_count != 0U) {
#line 778
    operation = (enum __anonenum_operation_981116399 )0;
  } else
#line 779
  if (local_options.version) {
#line 780
    operation = (enum __anonenum_operation_981116399 )2;
  } else {
#line 782
    operation = (enum __anonenum_operation_981116399 )1;
  }
#line 783
  return;
}
}
#line 788 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void app_printf(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  size_t tmp___0 ;

  {
#line 793
  if ((int const   )*(fmt + 0) == 0) {
#line 794
    return;
  }
  {
#line 795
  tmp___0 = strlen(fmt);
  }
#line 795
  if ((int const   )*(fmt + (tmp___0 - 1UL)) == 10) {
#line 795
    start_of_line = 1;
  } else {
#line 795
    start_of_line = 0;
  }
#line 797
  if ((unsigned long )con_file != (unsigned long )((void *)0)) {
    {
#line 799
    __builtin_va_start(arg_ptr, fmt);
#line 800
    vfprintf((FILE */* __restrict  */)con_file, (char const   */* __restrict  */)fmt,
             arg_ptr);
#line 801
    __builtin_va_end(arg_ptr);
    }
  }
#line 803
  if ((unsigned long )log_file != (unsigned long )((void *)0)) {
    {
#line 805
    __builtin_va_start(arg_ptr, fmt);
#line 806
    vfprintf((FILE */* __restrict  */)log_file, (char const   */* __restrict  */)fmt,
             arg_ptr);
#line 807
    __builtin_va_end(arg_ptr);
    }
  }
#line 809
  return;
}
}
#line 814 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void app_print_cntrl(int cntrl_code ) 
{ 
  char const   *con_str ;
  char const   *log_str ;
  int i ;

  {
#line 820
  if (cntrl_code == 13) {
#line 823
    con_str = "\r";
#line 824
    log_str = "\n";
#line 825
    start_of_line = 1;
  } else
#line 827
  if (cntrl_code == 11) {
#line 830
    if (! start_of_line) {
#line 832
      log_str = "\n";
#line 832
      con_str = log_str;
#line 833
      start_of_line = 1;
    } else {
#line 836
      log_str = "";
#line 836
      con_str = log_str;
    }
  } else
#line 838
  if (cntrl_code < 0) {
#line 838
    if (cntrl_code > -80) {
#line 838
      if (start_of_line) {
#line 841
        if ((unsigned long )con_file != (unsigned long )((void *)0)) {
#line 843
          i = 0;
          {
#line 843
          while (1) {
            while_continue: /* CIL Label */ ;
#line 843
            if (! (i > cntrl_code)) {
#line 843
              goto while_break;
            }
            {
#line 844
            fputc(' ', con_file);
#line 843
            i --;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 846
        con_str = "\r";
#line 847
        log_str = "";
      } else {
#line 852
        log_str = "<?>";
#line 852
        con_str = log_str;
      }
    } else {
#line 852
      log_str = "<?>";
#line 852
      con_str = log_str;
    }
  } else {
#line 852
    log_str = "<?>";
#line 852
    con_str = log_str;
  }
#line 855
  if ((unsigned long )con_file != (unsigned long )((void *)0)) {
    {
#line 856
    fputs((char const   */* __restrict  */)con_str, (FILE */* __restrict  */)con_file);
    }
  }
#line 857
  if ((unsigned long )log_file != (unsigned long )((void *)0)) {
    {
#line 858
    fputs((char const   */* __restrict  */)log_str, (FILE */* __restrict  */)log_file);
    }
  }
#line 859
  return;
}
}
#line 864 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void app_progress(unsigned long current_step , unsigned long total_steps ) 
{ 


  {
#line 868
  if ((unsigned long )con_file != (unsigned long )((void *)0)) {
    {
#line 869
    fflush(con_file);
    }
  }
#line 874
  if (current_step) {
#line 874
    if (total_steps) {
#line 875
      return;
    }
  }
#line 876
  return;
}
}
#line 881 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void app_init(void) 
{ 


  {
#line 884
  start_of_line = 1;
#line 886
  if ((unsigned int )operation == 1U) {
#line 887
    con_file = stdout;
  } else
#line 886
  if ((unsigned int )operation == 2U) {
#line 887
    con_file = stdout;
  } else
#line 888
  if (! options___0.quiet) {
#line 889
    con_file = stderr;
  } else {
#line 891
    con_file = (FILE *)((void *)0);
  }
#line 893
  if ((unsigned long )options___0.log_name != (unsigned long )((void *)0)) {
    {
#line 896
    log_file = fopen((char const   */* __restrict  */)options___0.log_name, (char const   */* __restrict  */)"a");
    }
#line 896
    if ((unsigned long )log_file == (unsigned long )((void *)0)) {
      {
#line 897
      error("Can\'t open log file: %s\n", options___0.log_name);
      }
    }
    {
#line 898
    setvbuf((FILE */* __restrict  */)log_file, (char */* __restrict  */)((void *)0),
            1, (size_t )8192);
#line 899
    app_printf("** Warning: %s\n\n", "The option -log is deprecated; use shell redirection");
    }
  }
#line 902
  return;
}
}
#line 907 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static void app_finish(void) 
{ 


  {
#line 910
  if ((unsigned long )log_file != (unsigned long )((void *)0)) {
    {
#line 913
    fclose(log_file);
    }
  }
#line 915
  return;
}
}
#line 920 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
static int process_files(int argc , char **argv ) 
{ 
  int result ;
  struct opng_ui ui ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 928
  ui.printf_fn = & app_printf;
#line 929
  ui.print_cntrl_fn = & app_print_cntrl;
#line 930
  ui.progress_fn = & app_progress;
#line 931
  ui.panic_fn = & panic;
#line 932
  tmp = opng_initialize((struct opng_options  const  *)(& options___0), (struct opng_ui  const  *)(& ui));
  }
#line 932
  if (tmp != 0) {
    {
#line 933
    panic("Can\'t initialize optimization engine");
    }
  }
#line 936
  result = 0;
#line 937
  i = 1;
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 937
    if (! (i < argc)) {
#line 937
      goto while_break;
    }
#line 939
    if ((unsigned long )*(argv + i) == (unsigned long )((void *)0)) {
#line 940
      goto __Cont;
    } else
#line 939
    if ((int )*(*(argv + i) + 0) == 0) {
#line 940
      goto __Cont;
    }
    {
#line 941
    tmp___0 = opng_optimize((char const   *)*(argv + i));
    }
#line 941
    if (tmp___0 != 0) {
#line 942
      result = 1;
    }
    __Cont: /* CIL Label */ 
#line 937
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 946
  tmp___1 = opng_finalize();
  }
#line 946
  if (tmp___1 != 0) {
    {
#line 947
    panic("Can\'t finalize optimization engine");
    }
  }
#line 949
  return (result);
}
}
#line 955 "/home/khheo/project/benchmark/optipng-0.7.6/src/optipng/optipng.c"
int main(int argc , char **argv ) 
{ 
  int result ;
  char const   *tmp ;
  png_const_charp tmp___0 ;

  {
  {
#line 961
  parse_args(argc, argv);
#line 962
  app_init();
#line 963
  result = 0;
  }
#line 965
  if (local_options.version) {
    {
#line 968
    app_printf("%s\n", msg_intro);
    }
  }
  {
#line 973
  if ((unsigned int )operation == 0U) {
#line 973
    goto case_0;
  }
#line 977
  if ((unsigned int )operation == 1U) {
#line 977
    goto case_1;
  }
#line 996
  if ((unsigned int )operation == 2U) {
#line 996
    goto case_2;
  }
#line 1002
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 975
  result = process_files(argc, argv);
  }
#line 976
  goto switch_break;
  case_1: /* CIL Label */ 
#line 978
  if (local_options.help) {
    {
#line 981
    app_printf("%s%s%s", msg_help_synopsis, msg_help_options, msg_help_examples);
    }
  } else {
    {
#line 989
    app_printf("%s%s%s%s", msg_help_synopsis, msg_help_basic_options, msg_help_examples,
               msg_help_more);
    }
  }
#line 995
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 998
  app_printf("%s\n", msg_license);
#line 999
  tmp = zlibVersion();
#line 999
  tmp___0 = png_get_libpng_ver((png_const_structrp )((void *)0));
#line 999
  app_printf("Using libpng version %s and zlib version %s\n", tmp___0, tmp);
  }
#line 1001
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1003
  result = -1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1007
  app_finish();
  }
#line 1008
  return (result);
}
}
