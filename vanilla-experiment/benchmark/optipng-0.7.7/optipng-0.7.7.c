/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 40 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/minitiff.h"
struct minitiff_info {
   void (*error_handler)(char const   *msg ) ;
   void (*warning_handler)(char const   *msg ) ;
   int byte_order ;
   size_t width ;
   size_t height ;
   unsigned int bits_per_sample ;
   unsigned int compression ;
   unsigned int photometric ;
   size_t strip_offsets_count ;
   unsigned long *strip_offsets ;
   unsigned int orientation ;
   unsigned int samples_per_pixel ;
   size_t rows_per_strip ;
};
#line 46 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
struct minitiff_getter {
   unsigned int (*get_ushort)(unsigned char const   *buf_ptr ) ;
   unsigned long (*get_ulong)(unsigned char const   *buf_ptr ) ;
};
#line 57 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmio.h"
struct pnm_struct {
   unsigned int format ;
   unsigned int depth ;
   unsigned int width ;
   unsigned int height ;
   unsigned int maxval ;
};
#line 57 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmio.h"
typedef struct pnm_struct pnm_struct;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 54 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.h"
struct GIFScreen {
   unsigned int Width ;
   unsigned int Height ;
   unsigned int GlobalColorFlag ;
   unsigned int ColorResolution ;
   unsigned int SortFlag ;
   unsigned int GlobalNumColors ;
   unsigned int Background ;
   unsigned int PixelAspectRatio ;
   unsigned char GlobalColorTable[768] ;
};
#line 70 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.h"
struct GIFImage {
   struct GIFScreen *Screen ;
   unsigned int LeftPos ;
   unsigned int TopPos ;
   unsigned int Width ;
   unsigned int Height ;
   unsigned int LocalColorFlag ;
   unsigned int InterlaceFlag ;
   unsigned int SortFlag ;
   unsigned int LocalNumColors ;
   unsigned char LocalColorTable[768] ;
   unsigned char **Rows ;
};
#line 88 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.h"
struct GIFExtension {
   struct GIFScreen *Screen ;
   unsigned char *Buffer ;
   unsigned int BufferSize ;
   unsigned char Label ;
};
#line 99 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.h"
struct GIFGraphicCtlExt {
   unsigned int DisposalMethod ;
   unsigned int InputFlag ;
   unsigned int TransparentFlag ;
   unsigned int DelayTime ;
   unsigned int Transparent ;
};
#line 393 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef unsigned int uInt;
#line 394 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef unsigned long uLong;
#line 409 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef void *voidpf;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 391 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef unsigned char Byte;
#line 400 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef Byte Bytef;
#line 405 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef uLong uLongf;
#line 102 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
struct internal_state ;
#line 104 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
struct z_stream_s {
   Bytef const   *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char const   *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 104 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
typedef struct z_stream_s z_stream;
#line 126 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
typedef z_stream *z_streamp;
#line 402 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef char charf;
#line 403 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef int intf;
#line 132 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
struct gz_header_s {
   int text ;
   uLong time ;
   int xflags ;
   int os ;
   Bytef *extra ;
   uInt extra_len ;
   uInt extra_max ;
   Bytef *name ;
   uInt name_max ;
   Bytef *comment ;
   uInt comm_max ;
   int hcrc ;
   int done ;
};
#line 132 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
typedef struct gz_header_s gz_header;
#line 149 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
typedef gz_header *gz_headerp;
#line 43 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.h"
typedef unsigned char uch;
#line 44 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.h"
typedef uch uchf;
#line 45 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.h"
typedef unsigned short ush;
#line 46 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.h"
typedef ush ushf;
#line 47 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.h"
typedef unsigned long ulg;
#line 68 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
union __anonunion_fc_152553610 {
   ush freq ;
   ush code ;
};
#line 68 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
union __anonunion_dl_152553611 {
   ush dad ;
   ush len ;
};
#line 68 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
struct ct_data_s {
   union __anonunion_fc_152553610 fc ;
   union __anonunion_dl_152553611 dl ;
};
#line 68 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
typedef struct ct_data_s ct_data;
#line 84
struct static_tree_desc_s ;
#line 84 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
typedef struct static_tree_desc_s static_tree_desc;
#line 86 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
struct tree_desc_s {
   ct_data *dyn_tree ;
   int max_code ;
   static_tree_desc const   *stat_desc ;
};
#line 86 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
typedef struct tree_desc_s tree_desc;
#line 92 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
typedef ush Pos;
#line 93 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
typedef Pos Posf;
#line 94 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
typedef unsigned int IPos;
#line 100 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
struct internal_state {
   z_streamp strm ;
   int status ;
   Bytef *pending_buf ;
   ulg pending_buf_size ;
   Bytef *pending_out ;
   ulg pending ;
   int wrap ;
   gz_headerp gzhead ;
   ulg gzindex ;
   Byte method ;
   int last_flush ;
   uInt w_size ;
   uInt w_bits ;
   uInt w_mask ;
   Bytef *window ;
   ulg window_size ;
   Posf *prev ;
   Posf *head ;
   uInt ins_h ;
   uInt hash_size ;
   uInt hash_bits ;
   uInt hash_mask ;
   uInt hash_shift ;
   long block_start ;
   uInt match_length ;
   IPos prev_match ;
   int match_available ;
   uInt strstart ;
   uInt match_start ;
   uInt lookahead ;
   uInt prev_length ;
   uInt max_chain_length ;
   uInt max_lazy_match ;
   int level ;
   int strategy ;
   uInt good_match ;
   int nice_match ;
   struct ct_data_s dyn_ltree[573] ;
   struct ct_data_s dyn_dtree[61] ;
   struct ct_data_s bl_tree[39] ;
   struct tree_desc_s l_desc ;
   struct tree_desc_s d_desc ;
   struct tree_desc_s bl_desc ;
   ush bl_count[16] ;
   int heap[573] ;
   int heap_len ;
   int heap_max ;
   uch depth[573] ;
   uchf *l_buf ;
   uInt lit_bufsize ;
   uInt last_lit ;
   ushf *d_buf ;
   ulg opt_len ;
   ulg static_len ;
   uInt matches ;
   uInt insert ;
   ush bi_buf ;
   int bi_valid ;
   ulg high_water ;
};
#line 100 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
typedef struct internal_state deflate_state;
#line 117 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
struct static_tree_desc_s {
   ct_data const   *static_tree ;
   intf const   *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
};
#line 24 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.h"
struct __anonstruct_code_1002866527 {
   unsigned char op ;
   unsigned char bits ;
   unsigned short val ;
};
#line 24 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.h"
typedef struct __anonstruct_code_1002866527 code;
#line 54
enum __anonenum_codetype_576538390 {
    CODES = 0,
    LENS = 1,
    DISTS = 2
} ;
#line 54 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.h"
typedef enum __anonenum_codetype_576538390 codetype;
#line 20 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.h"
enum __anonenum_inflate_mode_1063025839 {
    HEAD = 16180,
    FLAGS = 16181,
    TIME = 16182,
    OS = 16183,
    EXLEN = 16184,
    EXTRA = 16185,
    NAME = 16186,
    COMMENT = 16187,
    HCRC = 16188,
    DICTID = 16189,
    DICT = 16190,
    TYPE = 16191,
    TYPEDO = 16192,
    STORED = 16193,
    COPY_ = 16194,
    COPY = 16195,
    TABLE = 16196,
    LENLENS = 16197,
    CODELENS = 16198,
    LEN_ = 16199,
    LEN = 16200,
    LENEXT = 16201,
    DIST = 16202,
    DISTEXT = 16203,
    MATCH = 16204,
    LIT = 16205,
    CHECK = 16206,
    LENGTH = 16207,
    DONE = 16208,
    BAD = 16209,
    MEM = 16210,
    SYNC = 16211
} ;
#line 20 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.h"
typedef enum __anonenum_inflate_mode_1063025839 inflate_mode;
#line 82 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.h"
struct inflate_state {
   z_streamp strm ;
   inflate_mode mode ;
   int last ;
   int wrap ;
   int havedict ;
   int flags ;
   unsigned int dmax ;
   unsigned long check ;
   unsigned long total ;
   gz_headerp head ;
   unsigned int wbits ;
   unsigned int wsize ;
   unsigned int whave ;
   unsigned int wnext ;
   unsigned char *window ;
   unsigned long hold ;
   unsigned int bits ;
   unsigned int length ;
   unsigned int offset ;
   unsigned int extra ;
   code const   *lencode ;
   code const   *distcode ;
   unsigned int lenbits ;
   unsigned int distbits ;
   unsigned int ncode ;
   unsigned int nlen ;
   unsigned int ndist ;
   unsigned int have ;
   code *next ;
   unsigned short lens[320] ;
   unsigned short work[288] ;
   code codes[1444] ;
   int sane ;
   int back ;
   unsigned int was ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 64 "/usr/include/stdio.h"
typedef __off64_t off64_t;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 248 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef size_t z_size_t;
#line 408 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef void const   *voidpc;
#line 1318 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
struct gzFile_s ;
#line 1318 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1835 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off64_t pos ;
};
#line 170 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzguts.h"
struct __anonstruct_gz_state_943293388 {
   struct gzFile_s x ;
   int mode ;
   int fd ;
   char *path ;
   unsigned int size ;
   unsigned int want ;
   unsigned char *in ;
   unsigned char *out ;
   int direct ;
   int how ;
   off64_t start ;
   int eof ;
   int past ;
   int level ;
   int strategy ;
   off64_t skip ;
   int seek ;
   int err ;
   char *msg ;
   z_stream strm ;
};
#line 170 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzguts.h"
typedef struct __anonstruct_gz_state_943293388 gz_state;
#line 202 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzguts.h"
typedef gz_state *gz_statep;
#line 410 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef void *voidp;
#line 66 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
enum __anonenum_block_state_307922230 {
    need_more = 0,
    block_done = 1,
    finish_started = 2,
    finish_done = 3
} ;
#line 66 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
typedef enum __anonenum_block_state_307922230 block_state;
#line 120 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
struct config_s {
   ush good_length ;
   ush max_lazy ;
   ush nice_length ;
   ush max_chain ;
   block_state (*func)(deflate_state *s , int flush ) ;
};
#line 120 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
typedef struct config_s config;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 429 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zconf.h"
typedef unsigned int z_crc_t;
#line 481 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef unsigned char png_byte;
#line 497 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef unsigned short png_uint_16;
#line 503 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef int png_int_32;
#line 511 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef unsigned int png_uint_32;
#line 521 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef size_t png_size_t;
#line 556 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_size_t png_alloc_size_t;
#line 573 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_int_32 png_fixed_point;
#line 576 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef void *png_voidp;
#line 578 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_byte *png_bytep;
#line 579 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_byte const   *png_const_bytep;
#line 585 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_uint_16 const   *png_const_uint_16p;
#line 588 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef char *png_charp;
#line 589 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef char const   *png_const_charp;
#line 470 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
struct png_struct_def ;
#line 470 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef struct png_struct_def png_struct;
#line 472 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_struct *png_structp;
#line 500 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_struct * __restrict  png_structrp;
#line 501 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_struct const   * __restrict  png_const_structrp;
#line 509 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
struct png_color_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
};
#line 509 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef struct png_color_struct png_color;
#line 515 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_color *png_colorp;
#line 516 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_color const   *png_const_colorp;
#line 519 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
struct png_color_16_struct {
   png_byte index ;
   png_uint_16 red ;
   png_uint_16 green ;
   png_uint_16 blue ;
   png_uint_16 gray ;
};
#line 519 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef struct png_color_16_struct png_color_16;
#line 528 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_color_16 const   *png_const_color_16p;
#line 531 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
struct png_color_8_struct {
   png_byte red ;
   png_byte green ;
   png_byte blue ;
   png_byte gray ;
   png_byte alpha ;
};
#line 531 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef struct png_color_8_struct png_color_8;
#line 540 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_color_8 const   *png_const_color_8p;
#line 653 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
struct png_unknown_chunk_t {
   png_byte name[5] ;
   png_byte *data ;
   png_size_t size ;
   png_byte location ;
};
#line 653 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef struct png_unknown_chunk_t png_unknown_chunk;
#line 785 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
struct png_row_info_struct {
   png_uint_32 width ;
   png_size_t rowbytes ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte channels ;
   png_byte pixel_depth ;
};
#line 785 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef struct png_row_info_struct png_row_info;
#line 795 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_row_info *png_row_infop;
#line 61 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngstruct.h"
struct png_compression_buffer {
   struct png_compression_buffer *next ;
   png_byte output[1] ;
};
#line 61 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngstruct.h"
typedef struct png_compression_buffer png_compression_buffer;
#line 61 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngstruct.h"
typedef struct png_compression_buffer *png_compression_bufferp;
#line 143 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngstruct.h"
struct png_struct_def {
   void (*error_fn)(png_structp  , png_const_charp  ) ;
   void (*warning_fn)(png_structp  , png_const_charp  ) ;
   png_voidp error_ptr ;
   void (*write_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   void (*read_data_fn)(png_structp  , png_bytep  , png_size_t  ) ;
   png_voidp io_ptr ;
   png_uint_32 mode ;
   png_uint_32 flags ;
   png_uint_32 transformations ;
   png_uint_32 zowner ;
   z_stream zstream ;
   png_compression_bufferp zbuffer_list ;
   uInt zbuffer_size ;
   int zlib_level ;
   int zlib_method ;
   int zlib_window_bits ;
   int zlib_mem_level ;
   int zlib_strategy ;
   int zlib_set_level ;
   int zlib_set_method ;
   int zlib_set_window_bits ;
   int zlib_set_mem_level ;
   int zlib_set_strategy ;
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 num_rows ;
   png_uint_32 usr_width ;
   png_size_t rowbytes ;
   png_uint_32 iwidth ;
   png_uint_32 row_number ;
   png_uint_32 chunk_name ;
   png_bytep prev_row ;
   png_bytep row_buf ;
   png_bytep try_row ;
   png_bytep tst_row ;
   png_size_t info_rowbytes ;
   png_uint_32 idat_size ;
   png_uint_32 crc ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   int num_palette_max ;
   png_uint_16 num_trans ;
   png_byte compression ;
   png_byte filter ;
   png_byte interlaced ;
   png_byte pass ;
   png_byte do_filter ;
   png_byte color_type ;
   png_byte bit_depth ;
   png_byte usr_bit_depth ;
   png_byte pixel_depth ;
   png_byte channels ;
   png_byte usr_channels ;
   png_byte sig_bytes ;
   png_byte maximum_pixel_depth ;
   png_byte transformed_pixel_depth ;
   png_byte zstream_start ;
   png_byte background_gamma_type ;
   png_fixed_point background_gamma ;
   png_color_16 background ;
   void (*output_flush_fn)(png_structp  ) ;
   png_uint_32 flush_dist ;
   png_uint_32 flush_rows ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   void (*read_row_fn)(png_structp  , png_uint_32  , int  ) ;
   void (*write_row_fn)(png_structp  , png_uint_32  , int  ) ;
   png_uint_32 free_me ;
   int unknown_default ;
   unsigned int num_chunk_list ;
   png_bytep chunk_list ;
   png_bytep big_row_buf ;
   png_byte compression_type ;
   png_uint_32 user_width_max ;
   png_uint_32 user_height_max ;
   png_uint_32 user_chunk_cache_max ;
   png_alloc_size_t user_chunk_malloc_max ;
   png_unknown_chunk unknown_chunk ;
   png_size_t old_big_row_buf_size ;
   png_bytep read_buffer ;
   png_alloc_size_t read_buffer_size ;
   uInt IDAT_read_size ;
   png_uint_32 io_state ;
   png_bytep big_prev_row ;
   void (*read_filter[4])(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) ;
};
#line 584 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_uint_16 *png_uint_16p;
#line 605 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_byte **png_bytepp;
#line 473 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_struct **png_structpp;
#line 484
struct png_info_def ;
#line 484 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef struct png_info_def png_info;
#line 487 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_info **png_infopp;
#line 502 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_info * __restrict  png_inforp;
#line 503 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_info const   * __restrict  png_const_inforp;
#line 669 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_unknown_chunk *png_unknown_chunkp;
#line 670 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_unknown_chunk const   *png_const_unknown_chunkp;
#line 55 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pnginfo.h"
struct png_info_def {
   png_uint_32 width ;
   png_uint_32 height ;
   png_uint_32 valid ;
   png_size_t rowbytes ;
   png_colorp palette ;
   png_uint_16 num_palette ;
   png_uint_16 num_trans ;
   png_byte bit_depth ;
   png_byte color_type ;
   png_byte compression_type ;
   png_byte filter_type ;
   png_byte interlace_type ;
   png_byte channels ;
   png_byte pixel_depth ;
   png_byte spare_byte ;
   png_byte signature[8] ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   png_color_16 trans_color ;
   png_color_16 background ;
   png_uint_16p hist ;
   png_uint_32 free_me ;
   png_unknown_chunkp unknown_chunks ;
   int unknown_chunks_num ;
   png_bytepp row_pointers ;
};
#line 596 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef FILE *png_FILE_p;
#line 493 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
typedef unsigned long png_ptruint;
#line 577 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef void const   *png_const_voidp;
#line 580 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_uint_32 *png_uint_32p;
#line 581 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngconf.h"
typedef png_uint_32 const   *png_const_uint_32p;
#line 485 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_info *png_infop;
#line 471 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_struct const   *png_const_structp;
#line 486 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_info const   *png_const_infop;
#line 527 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_color_16 *png_color_16p;
#line 539 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_color_8 *png_color_8p;
#line 671 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
typedef png_unknown_chunk **png_unknown_chunkpp;
#line 610 "../libpng/pngconf.h"
typedef char const   **png_const_charpp;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_971511552 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_971511552 __mbstate_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/_G_config.h"
struct __anonstruct__G_fpos_t_800156284 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/_G_config.h"
typedef struct __anonstruct__G_fpos_t_800156284 _G_fpos_t;
#line 78 "/usr/include/stdio.h"
typedef _G_fpos_t fpos_t;
#line 30 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxutil.h"
typedef png_alloc_size_t pngx_alloc_size_t;
#line 28 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.h"
typedef unsigned long long opng_ullong_t;
#line 78 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.h"
struct opng_ulratio {
   unsigned long num ;
   unsigned long denom ;
};
#line 98 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.h"
struct opng_ullratio {
   opng_ullong_t num ;
   opng_ullong_t denom ;
};
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.c"
typedef opng_ullong_t opng_uxlong_impl_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 40 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.h"
typedef long opng_foffset_t;
#line 49 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.h"
typedef unsigned long opng_fsize_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 26 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.h"
typedef unsigned int opng_bitset_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 25 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.h"
struct opng_options {
   int backup ;
   int clobber ;
   int debug ;
   int fix ;
   int force ;
   int full ;
   int preserve ;
   int quiet ;
   int simulate ;
   int verbose ;
   char const   *out_name ;
   char const   *dir_name ;
   char const   *log_name ;
   int interlace ;
   int nb ;
   int nc ;
   int np ;
   int nz ;
   int optim_level ;
   opng_bitset_t compr_level_set ;
   opng_bitset_t mem_level_set ;
   opng_bitset_t strategy_set ;
   opng_bitset_t filter_set ;
   int window_bits ;
   int snip ;
   int strip_all ;
};
#line 61 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.h"
struct opng_ui {
   void (*printf_fn)(char const   *fmt  , ...) ;
   void (*print_cntrl_fn)(int cntrl_code ) ;
   void (*progress_fn)(unsigned long current_step , unsigned long total_steps ) ;
   void (*panic_fn)(char const   *msg ) ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 33 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 45 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 34 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct __anonstruct_v_1022237947 {
   char const   *etmp ;
};
#line 34 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct exception_context {
   jmp_buf *penv ;
   int caught ;
   struct __anonstruct_v_1022237947  volatile  v ;
};
#line 41 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct opng_preset {
   char const   *compr_level ;
   char const   *mem_level ;
   char const   *strategy ;
   char const   *filter ;
};
#line 111 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct opng_engine_struct {
   int started ;
};
#line 119 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct opng_process_struct {
   unsigned int status ;
   int num_iterations ;
   opng_foffset_t in_datastream_offset ;
   opng_fsize_t in_file_size ;
   opng_fsize_t out_file_size ;
   opng_fsize_t in_idat_size ;
   opng_fsize_t out_idat_size ;
   opng_fsize_t best_idat_size ;
   opng_fsize_t max_idat_size ;
   png_uint_32 in_plte_trns_size ;
   png_uint_32 out_plte_trns_size ;
   png_uint_32 reductions ;
   opng_bitset_t compr_level_set ;
   opng_bitset_t mem_level_set ;
   opng_bitset_t strategy_set ;
   opng_bitset_t filter_set ;
   int best_compr_level ;
   int best_mem_level ;
   int best_strategy ;
   int best_filter ;
};
#line 142 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct opng_summary_struct {
   unsigned int file_count ;
   unsigned int err_count ;
   unsigned int fix_count ;
   unsigned int snip_count ;
};
#line 153 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct opng_image_struct {
   png_uint_32 width ;
   png_uint_32 height ;
   int bit_depth ;
   int color_type ;
   int compression_type ;
   int filter_type ;
   int interlace_type ;
   png_bytepp row_pointers ;
   png_colorp palette ;
   int num_palette ;
   png_color_16p background_ptr ;
   png_color_16 background ;
   png_uint_16p hist ;
   png_color_8p sig_bit_ptr ;
   png_color_8 sig_bit ;
   png_bytep trans_alpha ;
   int num_trans ;
   png_color_16p trans_color_ptr ;
   png_color_16 trans_color ;
   png_unknown_chunkp unknowns ;
   int num_unknowns ;
};
#line 123 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
enum __anonenum_operation_981116399 {
    OP_RUN = 0,
    OP_SHOW_HELP = 1,
    OP_SHOW_VERSION = 2
} ;
#line 130 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
struct __anonstruct_local_options_1029054173 {
   int help ;
   int version ;
};
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 61 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/minitiff.h"
void minitiff_init_info(struct minitiff_info *info_ptr ) ;
#line 62
void minitiff_validate_info(struct minitiff_info  const  *info_ptr ) ;
#line 63
void minitiff_destroy_info(struct minitiff_info *info_ptr ) ;
#line 84
void minitiff_error(struct minitiff_info  const  *info_ptr , char const   *msg ) ;
#line 85
void minitiff_warning(struct minitiff_info  const  *info_ptr , char const   *msg ) ;
#line 246
char const   minitiff_sig_m[4] ;
#line 247
char const   minitiff_sig_i[4] ;
#line 248
char const   minitiff_sig_bigm[4] ;
#line 249
char const   minitiff_sig_bigi[4] ;
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 588
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
void minitiff_init_info(struct minitiff_info *info_ptr ) 
{ 


  {
  {
#line 23
  memset((void *)info_ptr, 0, sizeof(*info_ptr));
#line 24
  info_ptr->photometric = 4294967295U;
  }
#line 25
  return;
}
}
#line 30 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
void minitiff_validate_info(struct minitiff_info  const  *info_ptr ) 
{ 


  {
#line 32
  if (info_ptr->width == 0UL) {
    {
#line 33
    minitiff_error(info_ptr, "Invalid image dimensions in TIFF file");
    }
  } else
#line 32
  if (info_ptr->height == 0UL) {
    {
#line 33
    minitiff_error(info_ptr, "Invalid image dimensions in TIFF file");
    }
  }
#line 34
  if (info_ptr->bits_per_sample == 0U) {
    {
#line 35
    minitiff_error(info_ptr, "Invalid pixel info in TIFF file");
    }
  } else
#line 34
  if (info_ptr->samples_per_pixel == 0U) {
    {
#line 35
    minitiff_error(info_ptr, "Invalid pixel info in TIFF file");
    }
  }
#line 36
  if ((unsigned long )info_ptr->strip_offsets == (unsigned long )((void *)0)) {
    {
#line 37
    minitiff_error(info_ptr, "Invalid strip info in TIFF file");
    }
  } else
#line 36
  if (info_ptr->rows_per_strip == 0UL) {
    {
#line 37
    minitiff_error(info_ptr, "Invalid strip info in TIFF file");
    }
  }
#line 38
  if (info_ptr->compression != 1U) {
    {
#line 39
    minitiff_error(info_ptr, "Unsupported compression method in TIFF file");
    }
  }
#line 41
  if (info_ptr->photometric >= 3U) {
    {
#line 42
    minitiff_error(info_ptr, "Unsupported photometric interpretation in TIFF file");
    }
  }
#line 44
  return;
}
}
#line 49 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
void minitiff_destroy_info(struct minitiff_info *info_ptr ) 
{ 


  {
#line 51
  if ((unsigned long )info_ptr->strip_offsets != (unsigned long )((void *)0)) {
    {
#line 52
    free((void *)info_ptr->strip_offsets);
    }
  }
#line 53
  return;
}
}
#line 58 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
static void default_error_handler(char const   *msg ) 
{ 


  {
  {
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"minitiff: error: %s\n",
          msg);
#line 61
  exit(1);
  }
}
}
#line 67 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
void minitiff_error(struct minitiff_info  const  *info_ptr , char const   *msg ) 
{ 


  {
#line 69
  if ((unsigned long )info_ptr->error_handler != (unsigned long )((void *)0)) {
    {
#line 70
    (*(info_ptr->error_handler))(msg);
    }
  } else {
    {
#line 72
    default_error_handler(msg);
    }
  }
  {
#line 73
  abort();
  }
}
}
#line 79 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
static void default_warning_handler(char const   *msg ) 
{ 


  {
  {
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"minitiff: warning: %s\n",
          msg);
  }
#line 82
  return;
}
}
#line 87 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
void minitiff_warning(struct minitiff_info  const  *info_ptr , char const   *msg ) 
{ 


  {
#line 89
  if ((unsigned long )info_ptr->warning_handler != (unsigned long )((void *)0)) {
    {
#line 90
    (*(info_ptr->warning_handler))(msg);
    }
  } else {
    {
#line 92
    default_warning_handler(msg);
    }
  }
#line 93
  return;
}
}
#line 98 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
char const   minitiff_sig_m[4]  = {      (char const   )77,      (char const   )77,      (char const   )0,      (char const   )42};
#line 99 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
char const   minitiff_sig_i[4]  = {      (char const   )73,      (char const   )73,      (char const   )42,      (char const   )0};
#line 104 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
char const   minitiff_sig_bigm[4]  = {      (char const   )77,      (char const   )77,      (char const   )0,      (char const   )43};
#line 105 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffutil.c"
char const   minitiff_sig_bigi[4]  = {      (char const   )73,      (char const   )73,      (char const   )43,      (char const   )0};
#line 646 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 68 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/minitiff.h"
void minitiff_read_info(struct minitiff_info *info_ptr , FILE *stream ) ;
#line 69
void minitiff_read_row(struct minitiff_info *info_ptr , unsigned char *row_ptr , size_t row_index ,
                       FILE *stream ) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_alloc  =    "Error allocating memory for TIFF file";
#line 23 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_read  =    "Error reading TIFF file";
#line 25 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_seek  =    "Error repositioning TIFF file";
#line 27 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_notiff  =    "Not a TIFF file";
#line 29 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_bigtiff  =    "Unsupported BigTIFF file";
#line 31 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_invalid  =    "Invalid TIFF file";
#line 33 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_range  =    "Value out of the supported range in TIFF file";
#line 35 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_err_unsupported  =    "Unsupported data in TIFF file";
#line 37 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_warn_metadata  =    "Unrecognized metadata in TIFF file";
#line 39 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static char const   *msg_warn_multiple  =    "Selected first image from multi-image TIFF file";
#line 55 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static unsigned int get_ushort_m(unsigned char const   *buf_ptr ) 
{ 


  {
#line 57
  return (((unsigned int )*(buf_ptr + 0) << 8) + (unsigned int )*(buf_ptr + 1));
}
}
#line 64 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static unsigned int get_ushort_i(unsigned char const   *buf_ptr ) 
{ 


  {
#line 66
  return ((unsigned int )*(buf_ptr + 0) + ((unsigned int )*(buf_ptr + 1) << 8));
}
}
#line 73 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static unsigned long get_ulong_m(unsigned char const   *buf_ptr ) 
{ 


  {
#line 75
  return (((((unsigned long )*(buf_ptr + 0) << 24) + ((unsigned long )*(buf_ptr + 1) << 16)) + ((unsigned long )*(buf_ptr + 2) << 8)) + (unsigned long )*(buf_ptr + 3));
}
}
#line 84 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static unsigned long get_ulong_i(unsigned char const   *buf_ptr ) 
{ 


  {
#line 86
  return ((((unsigned long )*(buf_ptr + 0) + ((unsigned long )*(buf_ptr + 1) << 8)) + ((unsigned long )*(buf_ptr + 2) << 16)) + ((unsigned long )*(buf_ptr + 3) << 24));
}
}
#line 95 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static unsigned long get_ulong_value(struct minitiff_getter  const  *getter_ptr ,
                                     int tag_type , unsigned char const   *buf_ptr ) 
{ 
  unsigned int tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 101
  if (tag_type == 1) {
#line 101
    goto case_1;
  }
#line 103
  if (tag_type == 3) {
#line 103
    goto case_3;
  }
#line 105
  if (tag_type == 4) {
#line 105
    goto case_4;
  }
#line 107
  goto switch_default;
  case_1: /* CIL Label */ 
#line 102
  return ((unsigned long )*(buf_ptr + 0));
  case_3: /* CIL Label */ 
  {
#line 104
  tmp = (*(getter_ptr->get_ushort))(buf_ptr);
  }
#line 104
  return ((unsigned long )tmp);
  case_4: /* CIL Label */ 
  {
#line 106
  tmp___0 = (*(getter_ptr->get_ulong))(buf_ptr);
  }
#line 106
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 108
  return (0xffffffffffffffffUL);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 115 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static unsigned long *alloc_ulong_array(struct minitiff_info *info_ptr , size_t count ) 
{ 
  unsigned long *result ;
  void *tmp ;

  {
#line 119
  if (count > 0xffffffffffffffffUL / sizeof(unsigned long )) {
    {
#line 120
    minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_range);
    }
  }
  {
#line 121
  tmp = malloc(count * sizeof(unsigned long ));
#line 121
  result = (unsigned long *)tmp;
  }
#line 122
  if ((unsigned long )result == (unsigned long )((void *)0)) {
    {
#line 123
    minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_alloc);
    }
  }
#line 124
  return (result);
}
}
#line 134 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static unsigned int cast_ulong_to_uint(struct minitiff_info *info_ptr , unsigned long value ) 
{ 
  unsigned int result ;

  {
#line 137
  result = (unsigned int )value;
#line 138
  if ((unsigned long )result != value) {
    {
#line 139
    minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_range);
    }
  }
#line 140
  return (result);
}
}
#line 149 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static size_t read_ulong_values(struct minitiff_getter  const  *getter_ptr , int tag_type ,
                                unsigned long *values , size_t count , FILE *stream ) 
{ 
  unsigned char buf[4] ;
  size_t value_size ;
  size_t i ;
  size_t tmp ;

  {
  {
#line 160
  if (tag_type == 1) {
#line 160
    goto case_1;
  }
#line 163
  if (tag_type == 3) {
#line 163
    goto case_3;
  }
#line 166
  if (tag_type == 4) {
#line 166
    goto case_4;
  }
#line 169
  goto switch_default;
  case_1: /* CIL Label */ 
#line 161
  value_size = (size_t )1;
#line 162
  goto switch_break;
  case_3: /* CIL Label */ 
#line 164
  value_size = (size_t )2;
#line 165
  goto switch_break;
  case_4: /* CIL Label */ 
#line 167
  value_size = (size_t )4;
#line 168
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 170
  return ((size_t )0);
  switch_break: /* CIL Label */ ;
  }
#line 173
  i = (size_t )0;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (! (i < count)) {
#line 173
      goto while_break;
    }
    {
#line 175
    tmp = fread((void */* __restrict  */)(buf), value_size, (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 175
    if (tmp != 1UL) {
#line 176
      goto while_break;
    }
    {
#line 177
    *(values + i) = get_ulong_value(getter_ptr, tag_type, (unsigned char const   *)(buf));
#line 173
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return (i);
}
}
#line 185 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
static void seek_to_offset(struct minitiff_info *info_ptr , long offset , FILE *stream ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
#line 188
  if (offset < 0L) {
    {
#line 189
    minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_range);
    }
  }
  {
#line 190
  tmp = ftell(stream);
  }
#line 190
  if (tmp == offset) {
#line 191
    return;
  }
  {
#line 192
  tmp___0 = fseek(stream, offset, 0);
  }
#line 192
  if (tmp___0 != 0) {
    {
#line 193
    minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_seek);
    }
  }
#line 194
  return;
}
}
#line 199 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
void minitiff_read_info(struct minitiff_info *info_ptr , FILE *stream ) 
{ 
  struct minitiff_getter getter ;
  unsigned char buf[12] ;
  unsigned char *vbuf ;
  unsigned long ulvals[4] ;
  unsigned long ulval ;
  long dir_offset ;
  unsigned int dir_size ;
  unsigned int i ;
  unsigned int tag_id ;
  unsigned int tag_type ;
  size_t count ;
  size_t bits_per_sample_count ;
  unsigned int bits_per_sample_tag_type ;
  unsigned int strip_offsets_tag_type ;
  long bits_per_sample_offset ;
  long strip_offsets_offset ;
  int unknown_metadata_found ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  unsigned long tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned int tmp___13 ;
  unsigned long tmp___14 ;
  size_t tmp___15 ;
  unsigned long tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;

  {
  {
#line 203
  vbuf = buf + 8;
#line 215
  tmp = fread((void */* __restrict  */)(buf), (size_t )8, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 215
  if (tmp != 1UL) {
#line 216
    goto err_read;
  }
  {
#line 217
  tmp___3 = memcmp((void const   *)(buf), (void const   *)(minitiff_sig_m), (size_t )4);
  }
#line 217
  if (tmp___3 == 0) {
#line 219
    info_ptr->byte_order = 'M';
#line 220
    getter.get_ushort = & get_ushort_m;
#line 221
    getter.get_ulong = & get_ulong_m;
  } else {
    {
#line 223
    tmp___2 = memcmp((void const   *)(buf), (void const   *)(minitiff_sig_i), (size_t )4);
    }
#line 223
    if (tmp___2 == 0) {
#line 225
      info_ptr->byte_order = 'I';
#line 226
      getter.get_ushort = & get_ushort_i;
#line 227
      getter.get_ulong = & get_ulong_i;
    } else {
      {
#line 229
      tmp___0 = memcmp((void const   *)(buf), (void const   *)(minitiff_sig_bigm),
                       (size_t )4);
      }
#line 229
      if (tmp___0 == 0) {
        {
#line 232
        minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_bigtiff);
        }
#line 233
        return;
      } else {
        {
#line 229
        tmp___1 = memcmp((void const   *)(buf), (void const   *)(minitiff_sig_bigi),
                         (size_t )4);
        }
#line 229
        if (tmp___1 == 0) {
          {
#line 232
          minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_bigtiff);
          }
#line 233
          return;
        } else {
          {
#line 237
          minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_notiff);
          }
#line 238
          return;
        }
      }
    }
  }
  {
#line 240
  bits_per_sample_count = (size_t )0;
#line 241
  strip_offsets_tag_type = 0U;
#line 241
  bits_per_sample_tag_type = strip_offsets_tag_type;
#line 242
  strip_offsets_offset = 0L;
#line 242
  bits_per_sample_offset = strip_offsets_offset;
#line 243
  tmp___4 = (*(getter.get_ulong))((unsigned char const   *)(buf + 4));
#line 243
  dir_offset = (long )tmp___4;
  }
#line 244
  if (dir_offset >= 0L) {
#line 244
    if (dir_offset < 8L) {
#line 245
      goto err_invalid;
    }
  }
  {
#line 246
  seek_to_offset(info_ptr, dir_offset, stream);
#line 249
  tmp___5 = fread((void */* __restrict  */)(buf), (size_t )2, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 249
  if (tmp___5 != 1UL) {
#line 250
    goto err_read;
  }
  {
#line 251
  dir_size = (*(getter.get_ushort))((unsigned char const   *)(buf));
#line 252
  unknown_metadata_found = 0;
#line 253
  i = 0U;
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < dir_size)) {
#line 253
      goto while_break;
    }
    {
#line 255
    tmp___6 = fread((void */* __restrict  */)(buf), (size_t )12, (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 255
    if (tmp___6 != 1UL) {
#line 256
      goto err_read;
    }
    {
#line 257
    tag_id = (*(getter.get_ushort))((unsigned char const   *)(buf));
#line 258
    tag_type = (*(getter.get_ushort))((unsigned char const   *)(buf + 2));
#line 259
    tmp___7 = (*(getter.get_ulong))((unsigned char const   *)(buf + 4));
#line 259
    tmp___8 = cast_ulong_to_uint(info_ptr, tmp___7);
#line 259
    count = (size_t )tmp___8;
    }
#line 260
    if (count == 0UL) {
#line 261
      goto err_unsupported;
    }
    {
#line 264
    if (tag_id == 254U) {
#line 264
      goto case_254;
    }
#line 271
    if (tag_id == 256U) {
#line 271
      goto case_256;
    }
#line 277
    if (tag_id == 257U) {
#line 277
      goto case_257;
    }
#line 283
    if (tag_id == 258U) {
#line 283
      goto case_258;
    }
#line 297
    if (tag_id == 259U) {
#line 297
      goto case_259;
    }
#line 303
    if (tag_id == 262U) {
#line 303
      goto case_262;
    }
#line 309
    if (tag_id == 273U) {
#line 309
      goto case_273;
    }
#line 325
    if (tag_id == 274U) {
#line 325
      goto case_274;
    }
#line 331
    if (tag_id == 277U) {
#line 331
      goto case_277;
    }
#line 337
    if (tag_id == 278U) {
#line 337
      goto case_278;
    }
#line 343
    if (tag_id == 279U) {
#line 343
      goto case_279;
    }
#line 347
    if (tag_id == 317U) {
#line 347
      goto case_317;
    }
#line 347
    if (tag_id == 284U) {
#line 347
      goto case_317;
    }
#line 357
    if (tag_id == 50341U) {
#line 357
      goto case_50341;
    }
#line 357
    if (tag_id == 40965U) {
#line 357
      goto case_50341;
    }
#line 357
    if (tag_id == 34853U) {
#line 357
      goto case_50341;
    }
#line 357
    if (tag_id == 34675U) {
#line 357
      goto case_50341;
    }
#line 357
    if (tag_id == 34665U) {
#line 357
      goto case_50341;
    }
#line 357
    if (tag_id == 33723U) {
#line 357
      goto case_50341;
    }
#line 357
    if (tag_id == 700U) {
#line 357
      goto case_50341;
    }
#line 262
    goto switch_break;
    case_254: /* CIL Label */ 
#line 265
    if (count != 1UL) {
#line 266
      goto err_unsupported;
    }
    {
#line 267
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
    }
#line 268
    if (ulval != 0UL) {
#line 268
      if (ulval != 1UL) {
#line 269
        goto err_unsupported;
      }
    }
#line 270
    goto switch_break;
    case_256: /* CIL Label */ 
#line 272
    if (count != 1UL) {
#line 273
      goto err_unsupported;
    }
    {
#line 274
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
#line 275
    tmp___9 = cast_ulong_to_uint(info_ptr, ulval);
#line 275
    info_ptr->width = (size_t )tmp___9;
    }
#line 276
    goto switch_break;
    case_257: /* CIL Label */ 
#line 278
    if (count != 1UL) {
#line 279
      goto err_unsupported;
    }
    {
#line 280
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
#line 281
    tmp___10 = cast_ulong_to_uint(info_ptr, ulval);
#line 281
    info_ptr->height = (size_t )tmp___10;
    }
#line 282
    goto switch_break;
    case_258: /* CIL Label */ 
#line 284
    if (count == 1UL) {
      {
#line 286
      ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                              (unsigned char const   *)vbuf);
#line 287
      info_ptr->bits_per_sample = cast_ulong_to_uint(info_ptr, ulval);
      }
    } else {
      {
#line 292
      bits_per_sample_count = count;
#line 293
      bits_per_sample_tag_type = tag_type;
#line 294
      tmp___11 = (*(getter.get_ulong))((unsigned char const   *)vbuf);
#line 294
      bits_per_sample_offset = (long )tmp___11;
      }
    }
#line 296
    goto switch_break;
    case_259: /* CIL Label */ 
#line 298
    if (count != 1UL) {
#line 299
      goto err_unsupported;
    }
    {
#line 300
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
#line 301
    info_ptr->compression = cast_ulong_to_uint(info_ptr, ulval);
    }
#line 302
    goto switch_break;
    case_262: /* CIL Label */ 
#line 304
    if (count != 1UL) {
#line 305
      goto err_unsupported;
    }
    {
#line 306
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
#line 307
    info_ptr->photometric = cast_ulong_to_uint(info_ptr, ulval);
    }
#line 308
    goto switch_break;
    case_273: /* CIL Label */ 
#line 310
    info_ptr->strip_offsets_count = count;
#line 311
    if (count == 1UL) {
#line 313
      if ((unsigned long )info_ptr->strip_offsets != (unsigned long )((void *)0)) {
#line 314
        goto err_invalid;
      }
      {
#line 315
      info_ptr->strip_offsets = alloc_ulong_array(info_ptr, (size_t )1);
#line 316
      *(info_ptr->strip_offsets + 0) = get_ulong_value((struct minitiff_getter  const  *)(& getter),
                                                       (int )tag_type, (unsigned char const   *)vbuf);
      }
    } else {
      {
#line 321
      strip_offsets_tag_type = tag_type;
#line 322
      tmp___12 = (*(getter.get_ulong))((unsigned char const   *)vbuf);
#line 322
      strip_offsets_offset = (long )tmp___12;
      }
    }
#line 324
    goto switch_break;
    case_274: /* CIL Label */ 
#line 326
    if (count != 1UL) {
#line 327
      goto err_unsupported;
    }
    {
#line 328
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
#line 329
    info_ptr->orientation = cast_ulong_to_uint(info_ptr, ulval);
    }
#line 330
    goto switch_break;
    case_277: /* CIL Label */ 
#line 332
    if (count != 1UL) {
#line 333
      goto err_unsupported;
    }
    {
#line 334
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
#line 335
    info_ptr->samples_per_pixel = cast_ulong_to_uint(info_ptr, ulval);
    }
#line 336
    goto switch_break;
    case_278: /* CIL Label */ 
#line 338
    if (count != 1UL) {
#line 339
      goto err_unsupported;
    }
    {
#line 340
    ulval = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                            (unsigned char const   *)vbuf);
#line 341
    tmp___13 = cast_ulong_to_uint(info_ptr, ulval);
#line 341
    info_ptr->rows_per_strip = (size_t )tmp___13;
    }
#line 342
    goto switch_break;
    case_279: /* CIL Label */ 
#line 345
    goto switch_break;
    case_317: /* CIL Label */ 
    case_284: /* CIL Label */ 
#line 348
    if (count != 1UL) {
#line 349
      goto err_unsupported;
    } else {
      {
#line 348
      tmp___14 = get_ulong_value((struct minitiff_getter  const  *)(& getter), (int )tag_type,
                                 (unsigned char const   *)vbuf);
      }
#line 348
      if (tmp___14 != 1UL) {
#line 349
        goto err_unsupported;
      }
    }
#line 350
    goto switch_break;
    case_50341: /* CIL Label */ 
    case_40965: /* CIL Label */ 
    case_34853: /* CIL Label */ 
    case_34675: /* CIL Label */ 
    case_34665: /* CIL Label */ 
    case_33723: /* CIL Label */ 
    case_700: /* CIL Label */ 
#line 358
    if (! unknown_metadata_found) {
      {
#line 360
      unknown_metadata_found = 1;
#line 361
      minitiff_warning((struct minitiff_info  const  *)info_ptr, msg_warn_metadata);
      }
    }
#line 363
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 253
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 368
  tmp___15 = fread((void */* __restrict  */)(buf), (size_t )4, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 368
  if (tmp___15 != 1UL) {
#line 369
    goto err_read;
  }
  {
#line 370
  tmp___16 = (*(getter.get_ulong))((unsigned char const   *)(buf));
  }
#line 370
  if (tmp___16 != 0UL) {
    {
#line 371
    minitiff_warning((struct minitiff_info  const  *)info_ptr, msg_warn_multiple);
    }
  }
#line 374
  if (bits_per_sample_offset != 0L) {
#line 376
    count = bits_per_sample_count;
#line 377
    if (count != (size_t )info_ptr->samples_per_pixel) {
#line 378
      goto err_invalid;
    }
#line 379
    if (count > 4UL) {
#line 380
      goto err_unsupported;
    }
    {
#line 381
    seek_to_offset(info_ptr, bits_per_sample_offset, stream);
#line 382
    tmp___17 = read_ulong_values((struct minitiff_getter  const  *)(& getter), (int )bits_per_sample_tag_type,
                                 ulvals, count, stream);
    }
#line 382
    if (tmp___17 != count) {
#line 384
      goto err_read;
    }
    {
#line 385
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 385
      count --;
#line 385
      if (! (count > 0UL)) {
#line 385
        goto while_break___0;
      }
#line 386
      if (ulvals[0] != ulvals[count]) {
#line 387
        goto err_unsupported;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 388
    info_ptr->bits_per_sample = cast_ulong_to_uint(info_ptr, ulvals[0]);
    }
  }
#line 390
  if (strip_offsets_offset != 0L) {
#line 392
    count = info_ptr->strip_offsets_count;
#line 393
    if (count == 0UL) {
#line 394
      goto err_invalid;
    } else
#line 393
    if (count > info_ptr->height) {
#line 394
      goto err_invalid;
    }
#line 395
    if ((unsigned long )info_ptr->strip_offsets != (unsigned long )((void *)0)) {
#line 396
      goto err_invalid;
    }
    {
#line 397
    info_ptr->strip_offsets = alloc_ulong_array(info_ptr, count);
#line 398
    seek_to_offset(info_ptr, strip_offsets_offset, stream);
#line 399
    tmp___18 = read_ulong_values((struct minitiff_getter  const  *)(& getter), (int )strip_offsets_tag_type,
                                 info_ptr->strip_offsets, count, stream);
    }
#line 399
    if (tmp___18 != count) {
#line 402
      goto err_read;
    }
  }
#line 406
  return;
  err_read: 
  {
#line 410
  minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_read);
  }
  err_invalid: 
  {
#line 412
  minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_invalid);
  }
  err_unsupported: 
  {
#line 414
  minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_unsupported);
  }
#line 415
  return;
}
}
#line 420 "/home/khheo/project/benchmark/optipng-0.7.7/src/minitiff/tiffread.c"
void minitiff_read_row(struct minitiff_info *info_ptr , unsigned char *row_ptr , size_t row_index ,
                       FILE *stream ) 
{ 
  size_t row_size ;
  size_t strip_index ;
  unsigned int bytes_per_sample ;
  unsigned int sample_max ;
  long offset ;
  size_t i ;
  size_t tmp ;

  {
#line 431
  bytes_per_sample = (info_ptr->bits_per_sample + 7U) / 8U;
#line 432
  row_size = (info_ptr->width * (size_t )info_ptr->samples_per_pixel) * (size_t )bytes_per_sample;
#line 438
  strip_index = row_index / info_ptr->rows_per_strip;
#line 439
  if (strip_index >= info_ptr->strip_offsets_count) {
#line 440
    goto err_invalid;
  }
#line 441
  if ((long )*(info_ptr->strip_offsets + strip_index) < 0L) {
#line 442
    goto err_range;
  }
  {
#line 443
  offset = (long )(*(info_ptr->strip_offsets + strip_index) + row_size * (row_index % info_ptr->rows_per_strip));
#line 445
  seek_to_offset(info_ptr, offset, stream);
#line 448
  tmp = fread((void */* __restrict  */)row_ptr, row_size, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 448
  if (tmp != 1UL) {
#line 449
    goto err_read;
  }
#line 450
  if (info_ptr->photometric == 0U) {
#line 453
    if (bytes_per_sample > 1U) {
#line 454
      goto err_unsupported;
    }
#line 455
    sample_max = (unsigned int )((1 << info_ptr->bits_per_sample) - 1);
#line 456
    i = (size_t )0;
    {
#line 456
    while (1) {
      while_continue: /* CIL Label */ ;
#line 456
      if (! (i < row_size)) {
#line 456
        goto while_break;
      }
#line 457
      *(row_ptr + i) = (unsigned char )(sample_max - (unsigned int )*(row_ptr + i));
#line 456
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 461
  return;
  err_read: 
  {
#line 465
  minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_read);
  }
  err_invalid: 
  {
#line 467
  minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_invalid);
  }
  err_range: 
  {
#line 469
  minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_range);
  }
  err_unsupported: 
  {
#line 471
  minitiff_error((struct minitiff_info  const  *)info_ptr, msg_err_unsupported);
  }
#line 472
  return;
}
}
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 102 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmio.h"
int pnm_is_valid(pnm_struct const   *pnm_ptr ) ;
#line 103
size_t pnm_raw_sample_size(pnm_struct const   *pnm_ptr ) ;
#line 104
size_t pnm_mem_size(pnm_struct const   *pnm_ptr , size_t sample_size , unsigned int num_rows ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmutil.c"
int pnm_is_valid(pnm_struct const   *pnm_ptr ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int height ;
  unsigned int maxval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 23
  format = (unsigned int )pnm_ptr->format;
#line 24
  depth = (unsigned int )pnm_ptr->depth;
#line 25
  width = (unsigned int )pnm_ptr->width;
#line 26
  height = (unsigned int )pnm_ptr->height;
#line 27
  maxval = (unsigned int )pnm_ptr->maxval;
#line 29
  if (depth == 0U) {
#line 30
    return (0);
  } else
#line 29
  if (width == 0U) {
#line 30
    return (0);
  } else
#line 29
  if (height == 0U) {
#line 30
    return (0);
  } else
#line 29
  if (maxval == 0U) {
#line 30
    return (0);
  }
  {
#line 40
  if (format == 4U) {
#line 40
    goto case_4;
  }
#line 40
  if (format == 1U) {
#line 40
    goto case_4;
  }
#line 44
  if (format == 5U) {
#line 44
    goto case_5;
  }
#line 44
  if (format == 2U) {
#line 44
    goto case_5;
  }
#line 48
  if (format == 6U) {
#line 48
    goto case_6;
  }
#line 48
  if (format == 3U) {
#line 48
    goto case_6;
  }
#line 51
  if (format == 7U) {
#line 51
    goto case_7;
  }
#line 54
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 42
  if (depth == 1U) {
#line 42
    if (maxval == 1U) {
#line 42
      tmp = 1;
    } else {
#line 42
      tmp = 0;
    }
  } else {
#line 42
    tmp = 0;
  }
#line 42
  return (tmp);
  case_5: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 46
  if (depth == 1U) {
#line 46
    tmp___0 = 1;
  } else {
#line 46
    tmp___0 = 0;
  }
#line 46
  return (tmp___0);
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 50
  if (depth == 3U) {
#line 50
    tmp___1 = 1;
  } else {
#line 50
    tmp___1 = 0;
  }
#line 50
  return (tmp___1);
  case_7: /* CIL Label */ 
#line 53
  return (1);
  switch_default: /* CIL Label */ 
#line 55
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 66 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmutil.c"
size_t pnm_raw_sample_size(pnm_struct const   *pnm_ptr ) 
{ 
  unsigned int maxval ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 68
  maxval = (unsigned int )pnm_ptr->maxval;
#line 70
  if (maxval == 0U) {
    {
#line 71
    tmp = __errno_location();
#line 71
    *tmp = 22;
    }
  }
#line 73
  if (maxval <= 255U) {
#line 74
    return ((size_t )1);
  } else
#line 75
  if (maxval <= 65535U) {
#line 76
    return ((size_t )2);
  } else
#line 78
  if (maxval <= 16777215U) {
#line 79
    return ((size_t )3);
  } else
#line 80
  if (maxval <= 4294967295U) {
#line 81
    return ((size_t )4);
  } else {
    {
#line 85
    tmp___0 = __errno_location();
#line 85
    *tmp___0 = 22;
    }
#line 86
    return ((size_t )0);
  }
}
}
#line 97 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmutil.c"
size_t pnm_mem_size(pnm_struct const   *pnm_ptr , size_t sample_size , unsigned int num_rows ) 
{ 
  unsigned int depth ;
  unsigned int width ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 100
  depth = (unsigned int )pnm_ptr->depth;
#line 101
  width = (unsigned int )pnm_ptr->width;
#line 103
  if (sample_size == 0UL) {
    {
#line 105
    tmp = __errno_location();
#line 105
    *tmp = 22;
    }
#line 106
    return ((size_t )0);
  } else
#line 103
  if (depth == 0U) {
    {
#line 105
    tmp = __errno_location();
#line 105
    *tmp = 22;
    }
#line 106
    return ((size_t )0);
  } else
#line 103
  if (width == 0U) {
    {
#line 105
    tmp = __errno_location();
#line 105
    *tmp = 22;
    }
#line 106
    return ((size_t )0);
  }
#line 109
  if ((size_t )num_rows > ((0xffffffffffffffffUL / sample_size) / (size_t )depth) / (size_t )width) {
    {
#line 111
    tmp___0 = __errno_location();
#line 111
    *tmp___0 = 34;
    }
#line 112
    return ((size_t )0);
  }
#line 115
  return (((sample_size * (size_t )depth) * (size_t )width) * (size_t )num_rows);
}
}
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 652 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 86 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmio.h"
int pnm_fput_header(pnm_struct const   *pnm_ptr , FILE *stream ) ;
#line 88
int pnm_fput_values(pnm_struct const   *pnm_ptr , unsigned int const   *sample_values ,
                    unsigned int num_rows , FILE *stream ) ;
#line 92
int pnm_fput_bytes(pnm_struct const   *pnm_ptr , unsigned char const   *sample_bytes ,
                   size_t sample_size , unsigned int num_rows , FILE *stream ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmout.c"
int pnm_fput_header(pnm_struct const   *pnm_ptr , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int height ;
  unsigned int maxval ;
  int result ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 23
  format = (unsigned int )pnm_ptr->format;
#line 24
  depth = (unsigned int )pnm_ptr->depth;
#line 25
  width = (unsigned int )pnm_ptr->width;
#line 26
  height = (unsigned int )pnm_ptr->height;
#line 27
  maxval = (unsigned int )pnm_ptr->maxval;
#line 31
  tmp = pnm_is_valid(pnm_ptr);
  }
#line 31
  if (! tmp) {
#line 32
    return (0);
  }
  {
#line 38
  if (format == 4U) {
#line 38
    goto case_4;
  }
#line 38
  if (format == 1U) {
#line 38
    goto case_4;
  }
#line 45
  if (format == 6U) {
#line 45
    goto case_6;
  }
#line 45
  if (format == 5U) {
#line 45
    goto case_6;
  }
#line 45
  if (format == 3U) {
#line 45
    goto case_6;
  }
#line 45
  if (format == 2U) {
#line 45
    goto case_6;
  }
#line 49
  if (format == 7U) {
#line 49
    goto case_7;
  }
#line 54
  goto switch_default;
  case_4: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 39
  result = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"P%c\n%u %u\n",
                   format + 48U, width, height);
  }
#line 41
  goto switch_break;
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 46
  result = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"P%c\n%u %u\n%u\n",
                   format + 48U, width, height, maxval);
  }
#line 48
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 50
  result = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"P7\nDEPTH %u\nWIDTH %u\nHEIGHT %u\nMAXVAL %u\nENDHDR\n",
                   depth, width, height, maxval);
  }
#line 53
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 55
  tmp___0 = __errno_location();
#line 55
  *tmp___0 = 22;
  }
#line 56
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 60
  if (result > 0) {
#line 60
    tmp___1 = 1;
  } else {
#line 60
    tmp___1 = -1;
  }
#line 60
  return (tmp___1);
}
}
#line 71 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmout.c"
int pnm_fput_values(pnm_struct const   *pnm_ptr , unsigned int const   *sample_values ,
                    unsigned int num_rows , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  int ch ;
  int mask ;
  size_t i ;
  size_t j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;

  {
#line 76
  format = (unsigned int )pnm_ptr->format;
#line 77
  depth = (unsigned int )pnm_ptr->depth;
#line 78
  width = (unsigned int )pnm_ptr->width;
#line 79
  maxval = (unsigned int )pnm_ptr->maxval;
#line 80
  row_length = (size_t )depth * (size_t )width;
#line 81
  num_samples = (size_t )num_rows * row_length;
  {
#line 88
  if (format == 1U) {
#line 88
    goto case_1;
  }
#line 102
  if (format == 3U) {
#line 102
    goto case_3;
  }
#line 102
  if (format == 2U) {
#line 102
    goto case_3;
  }
#line 112
  if (format == 4U) {
#line 112
    goto case_4;
  }
#line 132
  if (format == 7U) {
#line 132
    goto case_7;
  }
#line 132
  if (format == 6U) {
#line 132
    goto case_7;
  }
#line 132
  if (format == 5U) {
#line 132
    goto case_7;
  }
#line 171
  goto switch_default;
  case_1: /* CIL Label */ 
#line 89
  j = (size_t )0;
#line 89
  i = j;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < num_samples)) {
#line 89
      goto while_break;
    }
#line 91
    if (*(sample_values + i) != 0U) {
#line 91
      tmp = '0';
    } else {
#line 91
      tmp = '1';
    }
    {
#line 91
    tmp___0 = _IO_putc(tmp, stream);
    }
#line 91
    if (tmp___0 == -1) {
#line 92
      goto while_break;
    }
#line 93
    j ++;
#line 93
    if (j == row_length) {
      {
#line 95
      j = (size_t )0;
#line 96
      tmp___1 = _IO_putc('\n', stream);
      }
#line 96
      if (tmp___1 == -1) {
#line 97
        goto while_break;
      }
    }
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 103
  j = (size_t )0;
#line 103
  i = j;
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (i < num_samples)) {
#line 103
      goto while_break___0;
    }
#line 105
    j ++;
#line 105
    if (j == row_length) {
#line 106
      j = (size_t )0;
    }
#line 107
    if (j == 0UL) {
#line 107
      tmp___2 = "%u\n";
    } else {
#line 107
      tmp___2 = "%u ";
    }
    {
#line 107
    tmp___3 = fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
                      *(sample_values + i));
    }
#line 107
    if (tmp___3 <= 0) {
#line 109
      goto while_break___0;
    }
#line 103
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 111
  goto switch_break;
  case_4: /* CIL Label */ 
#line 113
  j = (size_t )0;
#line 113
  i = j;
  {
#line 113
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 113
    if (! (i < num_samples)) {
#line 113
      goto while_break___1;
    }
#line 115
    ch = 0;
#line 116
    mask = 128;
    {
#line 116
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 116
      if (! (mask != 0)) {
#line 116
        goto while_break___2;
      }
#line 118
      tmp___4 = i;
#line 118
      i ++;
#line 118
      if (*(sample_values + tmp___4) == 0U) {
#line 119
        ch |= mask;
      }
#line 120
      j ++;
#line 120
      if (j == row_length) {
#line 122
        j = (size_t )0;
#line 123
        goto while_break___2;
      }
#line 116
      mask >>= 1;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 126
    tmp___5 = _IO_putc(ch, stream);
    }
#line 126
    if (tmp___5 == -1) {
#line 127
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 129
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 133
  if (maxval <= 255U) {
#line 135
    i = (size_t )0;
    {
#line 135
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 135
      if (! (i < num_samples)) {
#line 135
        goto while_break___3;
      }
      {
#line 137
      tmp___6 = _IO_putc((int )(*(sample_values + i) & 255U), stream);
      }
#line 137
      if (tmp___6 == -1) {
#line 138
        goto while_break___3;
      }
#line 135
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 141
  if (maxval <= 65535U) {
#line 143
    i = (size_t )0;
    {
#line 143
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 143
      if (! (i < num_samples)) {
#line 143
        goto while_break___4;
      }
      {
#line 145
      tmp___7 = _IO_putc((int )((*(sample_values + i) >> 8) & 255U), stream);
      }
#line 145
      if (tmp___7 == -1) {
#line 147
        goto while_break___4;
      } else {
        {
#line 145
        tmp___8 = _IO_putc((int )(*(sample_values + i) & 255U), stream);
        }
#line 145
        if (tmp___8 == -1) {
#line 147
          goto while_break___4;
        }
      }
#line 143
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 151
  if (maxval <= 4294967295U) {
#line 153
    i = (size_t )0;
    {
#line 153
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 153
      if (! (i < num_samples)) {
#line 153
        goto while_break___5;
      }
#line 155
      if (maxval > 16777215U) {
        {
#line 156
        tmp___9 = _IO_putc((int )((*(sample_values + i) >> 24) & 255U), stream);
        }
#line 156
        if (tmp___9 == -1) {
#line 157
          goto while_break___5;
        }
      }
      {
#line 158
      tmp___10 = _IO_putc((int )((*(sample_values + i) >> 16) & 255U), stream);
      }
#line 158
      if (tmp___10 == -1) {
#line 161
        goto while_break___5;
      } else {
        {
#line 158
        tmp___11 = _IO_putc((int )((*(sample_values + i) >> 8) & 255U), stream);
        }
#line 158
        if (tmp___11 == -1) {
#line 161
          goto while_break___5;
        } else {
          {
#line 158
          tmp___12 = _IO_putc((int )(*(sample_values + i) & 255U), stream);
          }
#line 158
          if (tmp___12 == -1) {
#line 161
            goto while_break___5;
          }
        }
      }
#line 153
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
    {
#line 167
    tmp___13 = __errno_location();
#line 167
    *tmp___13 = 22;
    }
#line 168
    return (0);
  }
#line 170
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 172
  tmp___14 = __errno_location();
#line 172
  *tmp___14 = 22;
  }
#line 173
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 177
  if (i == num_samples) {
#line 177
    tmp___15 = 1;
  } else {
#line 177
    tmp___15 = -1;
  }
#line 177
  return (tmp___15);
}
}
#line 188 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmout.c"
int pnm_fput_bytes(pnm_struct const   *pnm_ptr , unsigned char const   *sample_bytes ,
                   size_t sample_size , unsigned int num_rows , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  size_t raw_sample_size ;
  int ch ;
  int mask ;
  size_t i ;
  size_t j ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 194
  format = (unsigned int )pnm_ptr->format;
#line 195
  depth = (unsigned int )pnm_ptr->depth;
#line 196
  width = (unsigned int )pnm_ptr->width;
#line 197
  maxval = (unsigned int )pnm_ptr->maxval;
#line 198
  row_length = (size_t )depth * (size_t )width;
#line 199
  num_samples = (size_t )num_rows * row_length;
#line 205
  if (maxval <= 255U) {
#line 206
    raw_sample_size = (size_t )1;
  } else
#line 207
  if (maxval <= 65535U) {
#line 208
    raw_sample_size = (size_t )2;
  } else
#line 210
  if (maxval <= 16777215U) {
#line 211
    raw_sample_size = (size_t )3;
  } else
#line 212
  if (maxval <= 4294967295U) {
#line 213
    raw_sample_size = (size_t )4;
  } else {
#line 216
    raw_sample_size = (size_t )(! sample_size);
  }
#line 217
  if (raw_sample_size != sample_size) {
    {
#line 219
    tmp = __errno_location();
#line 219
    *tmp = 22;
    }
#line 220
    return (0);
  }
  {
#line 226
  if (format == 4U) {
#line 226
    goto case_4;
  }
#line 246
  if (format == 7U) {
#line 246
    goto case_7;
  }
#line 246
  if (format == 6U) {
#line 246
    goto case_7;
  }
#line 246
  if (format == 5U) {
#line 246
    goto case_7;
  }
#line 249
  goto switch_default;
  case_4: /* CIL Label */ 
#line 227
  j = (size_t )0;
#line 227
  i = j;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (i < num_samples)) {
#line 227
      goto while_break;
    }
#line 229
    ch = 0;
#line 230
    mask = 128;
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 230
      if (! (mask != 0)) {
#line 230
        goto while_break___0;
      }
#line 232
      tmp___0 = i;
#line 232
      i ++;
#line 232
      if ((int const   )*(sample_bytes + tmp___0) == 0) {
#line 233
        ch |= mask;
      }
#line 234
      j ++;
#line 234
      if (j == row_length) {
#line 236
        j = (size_t )0;
#line 237
        goto while_break___0;
      }
#line 230
      mask >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 240
    tmp___1 = _IO_putc(ch, stream);
    }
#line 240
    if (tmp___1 == -1) {
#line 241
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 247
  i = fwrite((void const   */* __restrict  */)sample_bytes, sample_size, num_samples,
             (FILE */* __restrict  */)stream);
  }
#line 248
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 250
  tmp___2 = __errno_location();
#line 250
  *tmp___2 = 22;
  }
#line 251
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 255
  if (i == num_samples) {
#line 255
    tmp___3 = 1;
  } else {
#line 255
    tmp___3 = -1;
  }
#line 255
  return (tmp___3);
}
}
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 639 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 70 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmio.h"
int pnm_fget_header(pnm_struct *pnm_ptr , FILE *stream ) ;
#line 72
int pnm_fget_values(pnm_struct const   *pnm_ptr , unsigned int *sample_values , unsigned int num_rows ,
                    FILE *stream ) ;
#line 76
int pnm_fget_bytes(pnm_struct const   *pnm_ptr , unsigned char *sample_bytes , size_t sample_size ,
                   unsigned int num_rows , FILE *stream ) ;
#line 39 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmin.c"
static int pnm_fget_char(FILE *stream ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 41
  tmp = _IO_getc(stream);
#line 41
  ch = tmp;
  }
#line 44
  if (ch == 35) {
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 48
      ch = _IO_getc(stream);
      }
#line 46
      if (ch != -1) {
#line 46
        if (ch != 10) {
#line 46
          if (! (ch != 13)) {
#line 46
            goto while_break;
          }
        } else {
#line 46
          goto while_break;
        }
      } else {
#line 46
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 53
  if (ch == 13) {
    {
#line 55
    ch = _IO_getc(stream);
    }
#line 56
    if (ch != 10) {
      {
#line 58
      ungetc(ch, stream);
#line 59
      ch = '\n';
      }
    }
  }
#line 63
  return (ch);
}
}
#line 71 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmin.c"
static int pnm_fscan_uint(FILE *stream , unsigned int *value ) 
{ 
  int ch ;
  unsigned int tmp ;
  int *tmp___0 ;

  {
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    ch = pnm_fget_char(stream);
    }
#line 77
    if (! (ch == 32)) {
#line 77
      if (! (ch == 9)) {
#line 77
        if (! (ch == 10)) {
#line 77
          if (! (ch == 13)) {
#line 77
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (ch == -1) {
#line 82
    return (-1);
  }
#line 83
  if (ch >= 48) {
#line 83
    if (! (ch <= 57)) {
      {
#line 85
      ungetc(ch, stream);
      }
#line 86
      return (0);
    }
  } else {
    {
#line 85
    ungetc(ch, stream);
    }
#line 86
    return (0);
  }
#line 90
  *value = 0U;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    tmp = *value * 10U + (unsigned int )(ch - 48);
#line 94
    if (tmp >= *value) {
#line 95
      *value = tmp;
    } else {
      {
#line 98
      *value = 4294967295U;
#line 99
      tmp___0 = __errno_location();
#line 99
      *tmp___0 = 34;
      }
    }
    {
#line 101
    ch = _IO_getc(stream);
    }
#line 91
    if (ch >= 48) {
#line 91
      if (! (ch <= 57)) {
#line 91
        goto while_break___0;
      }
    } else {
#line 91
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 105
  if (! (ch == 32)) {
#line 105
    if (! (ch == 9)) {
#line 105
      if (! (ch == 10)) {
#line 105
        if (! (ch == 13)) {
          {
#line 106
          ungetc(ch, stream);
          }
        }
      }
    }
  }
#line 108
  return (1);
}
}
#line 118 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmin.c"
int pnm_fget_header(pnm_struct *pnm_ptr , FILE *stream ) 
{ 
  unsigned int format ;
  int ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 124
  memset((void *)pnm_ptr, 0, sizeof(pnm_struct ));
#line 127
  ch = _IO_getc(stream);
  }
#line 128
  if (ch == -1) {
#line 129
    return (-1);
  }
#line 131
  if (ch != 80) {
#line 132
    return (-1);
  }
  {
#line 133
  ch = _IO_getc(stream);
  }
#line 134
  if (ch < 49) {
#line 135
    return (-1);
  } else
#line 134
  if (ch > 57) {
#line 135
    return (-1);
  }
  {
#line 136
  format = (unsigned int )(ch - 48);
#line 137
  ch = pnm_fget_char(stream);
  }
#line 138
  if (! (ch == 32)) {
#line 138
    if (! (ch == 9)) {
#line 138
      if (! (ch == 10)) {
#line 138
        if (! (ch == 13)) {
#line 139
          return (-1);
        }
      }
    }
  }
#line 142
  pnm_ptr->format = format;
#line 143
  if (format >= 1U) {
#line 143
    if (format <= 6U) {
#line 145
      if (format == 3U) {
#line 145
        pnm_ptr->depth = 3U;
      } else
#line 145
      if (format == 6U) {
#line 145
        pnm_ptr->depth = 3U;
      } else {
#line 145
        pnm_ptr->depth = 1U;
      }
      {
#line 146
      tmp = pnm_fscan_uint(stream, & pnm_ptr->width);
      }
#line 146
      if (tmp != 1) {
#line 148
        return (-1);
      } else {
        {
#line 146
        tmp___0 = pnm_fscan_uint(stream, & pnm_ptr->height);
        }
#line 146
        if (tmp___0 != 1) {
#line 148
          return (-1);
        }
      }
#line 149
      if (format == 1U) {
#line 150
        pnm_ptr->maxval = 1U;
      } else
#line 149
      if (format == 4U) {
#line 150
        pnm_ptr->maxval = 1U;
      } else {
        {
#line 153
        tmp___1 = pnm_fscan_uint(stream, & pnm_ptr->maxval);
        }
#line 153
        if (tmp___1 != 1) {
#line 154
          return (-1);
        }
      }
      {
#line 156
      tmp___4 = pnm_is_valid((pnm_struct const   *)pnm_ptr);
      }
#line 156
      if (tmp___4) {
#line 156
        tmp___3 = 1;
      } else {
#line 156
        tmp___3 = 0;
      }
#line 156
      return (tmp___3);
    } else {
#line 159
      return (-1);
    }
  } else {
#line 159
    return (-1);
  }
}
}
#line 172 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmin.c"
int pnm_fget_values(pnm_struct const   *pnm_ptr , unsigned int *sample_values , unsigned int num_rows ,
                    FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  int ch ;
  int ch8 ;
  int ch16 ;
  int ch24 ;
  int mask ;
  size_t i ;
  size_t j ;
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 177
  format = (unsigned int )pnm_ptr->format;
#line 178
  depth = (unsigned int )pnm_ptr->depth;
#line 179
  width = (unsigned int )pnm_ptr->width;
#line 180
  maxval = (unsigned int )pnm_ptr->maxval;
#line 181
  row_length = (size_t )depth * (size_t )width;
#line 182
  num_samples = (size_t )num_rows * row_length;
  {
#line 193
  if (format == 1U) {
#line 193
    goto case_1;
  }
#line 209
  if (format == 3U) {
#line 209
    goto case_3;
  }
#line 209
  if (format == 2U) {
#line 209
    goto case_3;
  }
#line 216
  if (format == 4U) {
#line 216
    goto case_4;
  }
#line 235
  if (format == 7U) {
#line 235
    goto case_7;
  }
#line 235
  if (format == 6U) {
#line 235
    goto case_7;
  }
#line 235
  if (format == 5U) {
#line 235
    goto case_7;
  }
#line 282
  goto switch_default;
  case_1: /* CIL Label */ 
#line 194
  i = (size_t )0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < num_samples)) {
#line 194
      goto while_break;
    }
    {
#line 196
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 198
      ch = pnm_fget_char(stream);
      }
#line 196
      if (! (ch == 32)) {
#line 196
        if (! (ch == 9)) {
#line 196
          if (! (ch == 10)) {
#line 196
            if (! (ch == 13)) {
#line 196
              goto while_break___0;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    if (ch != 48) {
#line 200
      if (ch != 49) {
        {
#line 202
        ungetc(ch, stream);
        }
#line 203
        goto while_break;
      }
    }
#line 205
    if (ch == 48) {
#line 205
      *(sample_values + i) = 1U;
    } else {
#line 205
      *(sample_values + i) = 0U;
    }
#line 194
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 210
  i = (size_t )0;
  {
#line 210
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 210
    if (! (i < num_samples)) {
#line 210
      goto while_break___1;
    }
    {
#line 212
    tmp = pnm_fscan_uint(stream, sample_values + i);
    }
#line 212
    if (tmp != 1) {
#line 213
      goto while_break___1;
    }
#line 210
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 215
  goto switch_break;
  case_4: /* CIL Label */ 
#line 217
  j = (size_t )0;
#line 217
  i = j;
  {
#line 217
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 217
    if (! (i < num_samples)) {
#line 217
      goto while_break___2;
    }
    {
#line 219
    ch = _IO_getc(stream);
    }
#line 220
    if (ch == -1) {
#line 221
      goto while_break___2;
    }
#line 222
    mask = 128;
    {
#line 222
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 222
      if (! (mask != 0)) {
#line 222
        goto while_break___3;
      }
#line 224
      tmp___0 = i;
#line 224
      i ++;
#line 224
      if (ch & mask) {
#line 224
        *(sample_values + tmp___0) = 0U;
      } else {
#line 224
        *(sample_values + tmp___0) = 1U;
      }
#line 225
      j ++;
#line 225
      if (j == row_length) {
#line 227
        j = (size_t )0;
#line 228
        goto while_break___3;
      }
#line 222
      mask >>= 1;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 232
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 236
  if (maxval <= 255U) {
#line 238
    i = (size_t )0;
    {
#line 238
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 238
      if (! (i < num_samples)) {
#line 238
        goto while_break___4;
      }
      {
#line 240
      ch = _IO_getc(stream);
      }
#line 241
      if (ch == -1) {
#line 242
        goto while_break___4;
      }
#line 243
      *(sample_values + i) = (unsigned int )ch;
#line 238
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 246
  if (maxval <= 65535U) {
#line 248
    i = (size_t )0;
    {
#line 248
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 248
      if (! (i < num_samples)) {
#line 248
        goto while_break___5;
      }
      {
#line 250
      ch8 = _IO_getc(stream);
#line 251
      ch = _IO_getc(stream);
      }
#line 252
      if (ch == -1) {
#line 253
        goto while_break___5;
      }
#line 254
      *(sample_values + i) = ((unsigned int )ch8 << 8) + (unsigned int )ch;
#line 248
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else
#line 258
  if (maxval <= 4294967295U) {
#line 260
    ch24 = 0;
#line 261
    i = (size_t )0;
    {
#line 261
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 261
      if (! (i < num_samples)) {
#line 261
        goto while_break___6;
      }
#line 263
      if (maxval > 16777215U) {
        {
#line 264
        ch24 = _IO_getc(stream);
        }
      }
      {
#line 265
      ch16 = _IO_getc(stream);
#line 266
      ch8 = _IO_getc(stream);
#line 267
      ch = _IO_getc(stream);
      }
#line 268
      if (ch == -1) {
#line 269
        goto while_break___6;
      }
#line 270
      *(sample_values + i) = ((((unsigned int )ch24 << 24) + ((unsigned int )ch16 << 16)) + ((unsigned int )ch8 << 8)) + (unsigned int )ch;
#line 261
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
    {
#line 278
    tmp___1 = __errno_location();
#line 278
    *tmp___1 = 22;
    }
#line 279
    return (0);
  }
#line 281
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 283
  tmp___2 = __errno_location();
#line 283
  *tmp___2 = 22;
  }
#line 284
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 288
  if (i < num_samples) {
    {
#line 290
    memset((void *)(sample_values + i), 0, (num_samples - i) * sizeof(unsigned int ));
    }
#line 291
    return (-1);
  }
#line 293
  return (1);
}
}
#line 305 "/home/khheo/project/benchmark/optipng-0.7.7/src/pnmio/pnmin.c"
int pnm_fget_bytes(pnm_struct const   *pnm_ptr , unsigned char *sample_bytes , size_t sample_size ,
                   unsigned int num_rows , FILE *stream ) 
{ 
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int maxval ;
  size_t row_length ;
  size_t num_samples ;
  size_t raw_sample_size ;
  int ch ;
  int mask ;
  size_t i ;
  size_t j ;
  int *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
#line 311
  format = (unsigned int )pnm_ptr->format;
#line 312
  depth = (unsigned int )pnm_ptr->depth;
#line 313
  width = (unsigned int )pnm_ptr->width;
#line 314
  maxval = (unsigned int )pnm_ptr->maxval;
#line 315
  row_length = (size_t )depth * (size_t )width;
#line 316
  num_samples = (size_t )num_rows * row_length;
#line 322
  if (maxval <= 255U) {
#line 323
    raw_sample_size = (size_t )1;
  } else
#line 324
  if (maxval <= 65535U) {
#line 325
    raw_sample_size = (size_t )2;
  } else
#line 327
  if (maxval <= 16777215U) {
#line 328
    raw_sample_size = (size_t )3;
  } else
#line 329
  if (maxval <= 4294967295U) {
#line 330
    raw_sample_size = (size_t )4;
  } else {
#line 333
    raw_sample_size = (size_t )(! sample_size);
  }
#line 334
  if (raw_sample_size != sample_size) {
    {
#line 336
    tmp = __errno_location();
#line 336
    *tmp = 22;
    }
#line 337
    return (0);
  }
  {
#line 343
  if (format == 4U) {
#line 343
    goto case_4;
  }
#line 362
  if (format == 7U) {
#line 362
    goto case_7;
  }
#line 362
  if (format == 6U) {
#line 362
    goto case_7;
  }
#line 362
  if (format == 5U) {
#line 362
    goto case_7;
  }
#line 365
  goto switch_default;
  case_4: /* CIL Label */ 
#line 344
  j = (size_t )0;
#line 344
  i = j;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (i < num_samples)) {
#line 344
      goto while_break;
    }
    {
#line 346
    ch = _IO_getc(stream);
    }
#line 347
    if (ch == -1) {
#line 348
      goto while_break;
    }
#line 349
    mask = 128;
    {
#line 349
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 349
      if (! (mask != 0)) {
#line 349
        goto while_break___0;
      }
#line 351
      tmp___0 = i;
#line 351
      i ++;
#line 351
      if (ch & mask) {
#line 351
        tmp___1 = 0;
      } else {
#line 351
        tmp___1 = 1;
      }
#line 351
      *(sample_bytes + tmp___0) = (unsigned char )tmp___1;
#line 352
      j ++;
#line 352
      if (j == row_length) {
#line 354
        j = (size_t )0;
#line 355
        goto while_break___0;
      }
#line 349
      mask >>= 1;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  goto switch_break;
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 363
  i = fread((void */* __restrict  */)sample_bytes, sample_size, num_samples, (FILE */* __restrict  */)stream);
  }
#line 364
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 366
  tmp___2 = __errno_location();
#line 366
  *tmp___2 = 22;
  }
#line 367
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 371
  if (i < num_samples) {
    {
#line 373
    memset((void *)(sample_bytes + i), 0, sample_size * num_samples - i);
    }
#line 374
    return (-1);
  }
#line 376
  return (1);
}
}
#line 761 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 114 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.h"
void GIFReadScreen(struct GIFScreen *screen , FILE *stream ) ;
#line 122
void GIFInitImage(struct GIFImage *image___0 , struct GIFScreen *screen , unsigned char **rows ) ;
#line 129
void GIFDestroyImage(struct GIFImage *image___0 ) ;
#line 138
int GIFReadNextBlock(struct GIFImage *image___0 , struct GIFExtension *ext , FILE *stream ) ;
#line 148
void GIFGetColorTable(unsigned char **colors , unsigned int *numColors , struct GIFImage *image___0 ) ;
#line 157
void GIFInitExtension(struct GIFExtension *ext , struct GIFScreen *screen , unsigned int initBufferSize ) ;
#line 164
void GIFDestroyExtension(struct GIFExtension *ext ) ;
#line 172
void GIFGetGraphicCtl(struct GIFGraphicCtlExt *graphicExt , struct GIFExtension *ext ) ;
#line 180
void (*GIFError)(char const   *message ) ;
#line 186
void (*GIFWarning)(char const   *message ) ;
#line 549 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 47 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void GIFReadNextImage(struct GIFImage *image___0 , FILE *stream ) ;
#line 48
static void GIFReadImageData(struct GIFImage *image___0 , FILE *stream ) ;
#line 49
static int GIFReadDataBlock(unsigned char *buffer___0 , FILE *stream ) ;
#line 50
static void GIFSkipDataBlocks(FILE *stream ) ;
#line 51
static int LZWGetCode(int code_size___0 , int init_flag , FILE *stream ) ;
#line 52
static int LZWDecodeByte(int init_flag , int input_code_size , FILE *stream ) ;
#line 53
static void GIFReadNextExtension(struct GIFExtension *ext , FILE *stream ) ;
#line 55
static int GetByte(FILE *stream ) ;
#line 56
static void ReadBytes(unsigned char *buffer___0 , unsigned int count , FILE *stream ) ;
#line 58
static void ErrorAlloc(void) ;
#line 59
static void ErrorRead(FILE *stream ) ;
#line 60
static void DefaultError(char const   *message ) ;
#line 61
static void DefaultWarning(char const   *message ) ;
#line 67 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void GIFReadScreen(struct GIFScreen *screen , FILE *stream ) 
{ 
  unsigned char buffer___0[7] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 72
  ReadBytes(buffer___0, 6U, stream);
#line 73
  tmp = memcmp((void const   *)(buffer___0), (void const   *)"GIF", (size_t )3);
  }
#line 73
  if (tmp != 0) {
    {
#line 74
    (*GIFError)("Not a GIF file");
    }
  }
  {
#line 75
  tmp___0 = memcmp((void const   *)(buffer___0 + 3), (void const   *)"87a", (size_t )3);
  }
#line 75
  if (tmp___0 != 0) {
    {
#line 75
    tmp___1 = memcmp((void const   *)(buffer___0 + 3), (void const   *)"89a", (size_t )3);
    }
#line 75
    if (tmp___1 != 0) {
      {
#line 77
      (*GIFWarning)("Invalid GIF version number, not \"87a\" or \"89a\"");
      }
    }
  }
  {
#line 80
  ReadBytes(buffer___0, 7U, stream);
#line 81
  screen->Width = (unsigned int )((int )*((buffer___0 + 0) + 0) + ((int )*((buffer___0 + 0) + 1) << 8));
#line 82
  screen->Height = (unsigned int )((int )*((buffer___0 + 2) + 0) + ((int )*((buffer___0 + 2) + 1) << 8));
  }
#line 83
  if ((int )buffer___0[4] & 128) {
#line 83
    screen->GlobalColorFlag = 1U;
  } else {
#line 83
    screen->GlobalColorFlag = 0U;
  }
#line 84
  screen->ColorResolution = (unsigned int )((((int )buffer___0[4] & 112) >> 3) + 1);
#line 85
  if ((int )buffer___0[4] & 8) {
#line 85
    screen->SortFlag = 1U;
  } else {
#line 85
    screen->SortFlag = 0U;
  }
#line 86
  screen->GlobalNumColors = (unsigned int )(2 << ((int )buffer___0[4] & 7));
#line 87
  screen->Background = (unsigned int )buffer___0[5];
#line 88
  screen->PixelAspectRatio = (unsigned int )buffer___0[6];
#line 90
  if (screen->GlobalColorFlag) {
    {
#line 93
    ReadBytes(screen->GlobalColorTable, 3U * screen->GlobalNumColors, stream);
    }
  }
#line 98
  if (screen->Width == 0U) {
    {
#line 99
    (*GIFError)("Invalid dimensions in GIF image");
    }
  } else
#line 98
  if (screen->Height == 0U) {
    {
#line 99
    (*GIFError)("Invalid dimensions in GIF image");
    }
  }
#line 100
  if (screen->Background > 0U) {
#line 102
    if (screen->GlobalColorFlag) {
#line 102
      if (screen->Background >= screen->GlobalNumColors) {
#line 109
        screen->Background = 0U;
      } else {
#line 102
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 102
    if (! screen->GlobalColorFlag) {
#line 109
      screen->Background = 0U;
    }
  }
#line 112
  return;
}
}
#line 117 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void GIFInitImage(struct GIFImage *image___0 , struct GIFScreen *screen , unsigned char **rows ) 
{ 


  {
#line 120
  image___0->Screen = screen;
#line 121
  image___0->Rows = rows;
#line 122
  return;
}
}
#line 127 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void GIFDestroyImage(struct GIFImage *image___0 ) 
{ 


  {
#line 130
  return;
}
}
#line 135 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
int GIFReadNextBlock(struct GIFImage *image___0 , struct GIFExtension *ext , FILE *stream ) 
{ 
  int ch ;
  int foundBogus ;

  {
#line 141
  foundBogus = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 144
    ch = GetByte(stream);
    }
    {
#line 147
    if (ch == 44) {
#line 147
      goto case_44;
    }
#line 150
    if (ch == 33) {
#line 150
      goto case_33;
    }
#line 153
    if (ch == 59) {
#line 153
      goto case_59;
    }
#line 155
    goto switch_default;
    case_44: /* CIL Label */ 
    {
#line 148
    GIFReadNextImage(image___0, stream);
    }
#line 149
    return (ch);
    case_33: /* CIL Label */ 
    {
#line 151
    GIFReadNextExtension(ext, stream);
    }
#line 152
    return (ch);
    case_59: /* CIL Label */ 
#line 154
    return (ch);
    switch_default: /* CIL Label */ 
#line 156
    if (! foundBogus) {
      {
#line 157
      (*GIFWarning)("Bogus data in GIF file");
      }
    }
#line 158
    foundBogus = 1;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 166 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void GIFReadNextImage(struct GIFImage *image___0 , FILE *stream ) 
{ 
  struct GIFScreen *screen ;
  unsigned char buffer___0[9] ;

  {
  {
#line 172
  ReadBytes(buffer___0, 9U, stream);
  }
#line 173
  if ((unsigned long )image___0 == (unsigned long )((void *)0)) {
    {
#line 175
    GIFSkipDataBlocks(stream);
    }
#line 176
    return;
  }
#line 179
  image___0->LeftPos = (unsigned int )((int )*((buffer___0 + 0) + 0) + ((int )*((buffer___0 + 0) + 1) << 8));
#line 180
  image___0->TopPos = (unsigned int )((int )*((buffer___0 + 2) + 0) + ((int )*((buffer___0 + 2) + 1) << 8));
#line 181
  image___0->Width = (unsigned int )((int )*((buffer___0 + 4) + 0) + ((int )*((buffer___0 + 4) + 1) << 8));
#line 182
  image___0->Height = (unsigned int )((int )*((buffer___0 + 6) + 0) + ((int )*((buffer___0 + 6) + 1) << 8));
#line 183
  if ((int )buffer___0[8] & 128) {
#line 183
    image___0->LocalColorFlag = 1U;
  } else {
#line 183
    image___0->LocalColorFlag = 0U;
  }
#line 184
  if ((int )buffer___0[8] & 64) {
#line 184
    image___0->InterlaceFlag = 1U;
  } else {
#line 184
    image___0->InterlaceFlag = 0U;
  }
#line 185
  if ((int )buffer___0[8] & 32) {
#line 185
    image___0->SortFlag = 1U;
  } else {
#line 185
    image___0->SortFlag = 0U;
  }
#line 186
  if (image___0->LocalColorFlag) {
#line 186
    image___0->LocalNumColors = (unsigned int )(2 << ((int )buffer___0[8] & 7));
  } else {
#line 186
    image___0->LocalNumColors = 0U;
  }
#line 189
  if (image___0->LocalColorFlag) {
    {
#line 192
    ReadBytes(image___0->LocalColorTable, 3U * image___0->LocalNumColors, stream);
    }
  }
#line 196
  screen = image___0->Screen;
#line 198
  if (image___0->Width == 0U) {
    {
#line 201
    (*GIFError)("Invalid dimensions in GIF image");
    }
  } else
#line 198
  if (image___0->Height == 0U) {
    {
#line 201
    (*GIFError)("Invalid dimensions in GIF image");
    }
  } else
#line 198
  if (image___0->LeftPos + image___0->Width > screen->Width) {
    {
#line 201
    (*GIFError)("Invalid dimensions in GIF image");
    }
  } else
#line 198
  if (image___0->TopPos + image___0->Height > screen->Height) {
    {
#line 201
    (*GIFError)("Invalid dimensions in GIF image");
    }
  }
  {
#line 203
  GIFReadImageData(image___0, stream);
  }
#line 204
  return;
}
}
#line 206 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void GIFReadImageData(struct GIFImage *image___0 , FILE *stream ) 
{ 
  int minCodeSize ;
  unsigned char **rows ;
  unsigned int width ;
  unsigned int height ;
  unsigned int interlaced ;
  unsigned char *colors ;
  unsigned int numColors ;
  unsigned int xpos ;
  unsigned int ypos ;
  int pass ;
  int val ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 219
  minCodeSize = GetByte(stream);
  }
#line 220
  if (minCodeSize >= 12) {
    {
#line 221
    (*GIFError)("Invalid LZW code size");
    }
  }
  {
#line 223
  tmp = LZWDecodeByte(1, minCodeSize, stream);
  }
#line 223
  if (tmp < 0) {
    {
#line 224
    (*GIFError)("Error decoding GIF image");
    }
  }
#line 227
  rows = image___0->Rows;
#line 228
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
    {
#line 236
    GIFSkipDataBlocks(stream);
    }
#line 238
    return;
  }
  {
#line 241
  width = image___0->Width;
#line 242
  height = image___0->Height;
#line 243
  interlaced = image___0->InterlaceFlag;
#line 244
  GIFGetColorTable(& colors, & numColors, image___0);
#line 245
  ypos = 0U;
#line 245
  xpos = ypos;
#line 246
  pass = 0;
  }
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 247
    val = LZWDecodeByte(0, minCodeSize, stream);
    }
#line 247
    if (! (val >= 0)) {
#line 247
      goto while_break;
    }
#line 249
    if ((unsigned int )val >= numColors) {
      {
#line 251
      (*GIFWarning)("Pixel value out of range in GIF image");
#line 252
      val = (int )(numColors - 1U);
      }
    }
#line 254
    *(*(rows + ypos) + xpos) = (unsigned char )val;
#line 255
    xpos ++;
#line 255
    if (xpos == width) {
#line 257
      xpos = 0U;
#line 258
      if (interlaced) {
        {
#line 263
        if (pass == 1) {
#line 263
          goto case_1;
        }
#line 263
        if (pass == 0) {
#line 263
          goto case_1;
        }
#line 266
        if (pass == 2) {
#line 266
          goto case_2;
        }
#line 269
        if (pass == 3) {
#line 269
          goto case_3;
        }
#line 260
        goto switch_break;
        case_1: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 264
        ypos += 8U;
#line 265
        goto switch_break;
        case_2: /* CIL Label */ 
#line 267
        ypos += 4U;
#line 268
        goto switch_break;
        case_3: /* CIL Label */ 
#line 270
        ypos += 2U;
#line 271
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 273
        if (ypos >= height) {
#line 275
          pass ++;
          {
#line 277
          if (pass == 1) {
#line 277
            goto case_1___0;
          }
#line 280
          if (pass == 2) {
#line 280
            goto case_2___0;
          }
#line 283
          if (pass == 3) {
#line 283
            goto case_3___0;
          }
#line 286
          goto switch_default;
          case_1___0: /* CIL Label */ 
#line 278
          ypos = 4U;
#line 279
          goto switch_break___0;
          case_2___0: /* CIL Label */ 
#line 281
          ypos = 2U;
#line 282
          goto switch_break___0;
          case_3___0: /* CIL Label */ 
#line 284
          ypos = 1U;
#line 285
          goto switch_break___0;
          switch_default: /* CIL Label */ 
#line 287
          goto fini;
          switch_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 292
        ypos ++;
      }
    }
#line 294
    if (ypos >= height) {
#line 295
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  fini: 
  {
#line 299
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 299
    tmp___0 = LZWDecodeByte(0, minCodeSize, stream);
    }
#line 299
    if (! (tmp___0 >= 0)) {
#line 299
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 302
  return;
}
}
#line 304 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int DataBlockSize  =    0;
#line 306 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int GIFReadDataBlock(unsigned char *buffer___0 , FILE *stream ) 
{ 
  int count ;

  {
  {
#line 310
  count = GetByte(stream);
#line 311
  DataBlockSize = count;
  }
#line 312
  if (count > 0) {
    {
#line 313
    ReadBytes(buffer___0, (unsigned int )count, stream);
    }
  }
#line 314
  return (count);
}
}
#line 317 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void GIFSkipDataBlocks(FILE *stream ) 
{ 
  int count ;
  unsigned char buffer___0[256] ;

  {
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 324
    count = GetByte(stream);
    }
#line 325
    if (count > 0) {
      {
#line 326
      ReadBytes(buffer___0, (unsigned int )count, stream);
      }
    } else {
#line 328
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 334 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static unsigned char buffer[280]  ;
#line 335 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int curbit  ;
#line 335 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int lastbit  ;
#line 335 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int done  ;
#line 335 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int last_byte  ;
#line 332 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int LZWGetCode(int code_size___0 , int init_flag , FILE *stream ) 
{ 
  int count ;
  int i ;
  int j ;
  int ret ;

  {
#line 338
  if (init_flag) {
#line 340
    curbit = 0;
#line 341
    lastbit = 0;
#line 342
    last_byte = 2;
#line 343
    done = 0;
#line 344
    return (0);
  }
#line 347
  if (curbit + code_size___0 >= lastbit) {
#line 349
    if (done) {
#line 351
      if (curbit >= lastbit) {
        {
#line 352
        (*GIFError)("Ran off the end of input bits in LZW decoding");
        }
      }
#line 353
      return (-1);
    }
    {
#line 355
    buffer[0] = buffer[last_byte - 2];
#line 356
    buffer[1] = buffer[last_byte - 1];
#line 358
    count = GIFReadDataBlock(& buffer[2], stream);
    }
#line 358
    if (count == 0) {
#line 359
      done = 1;
    }
#line 361
    last_byte = 2 + count;
#line 362
    curbit = (curbit - lastbit) + 16;
#line 363
    lastbit = (2 + count) * 8;
  }
#line 366
  ret = 0;
#line 367
  i = curbit;
#line 367
  j = 0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (j < code_size___0)) {
#line 367
      goto while_break;
    }
#line 368
    ret |= (((int )buffer[i / 8] & (1 << i % 8)) != 0) << j;
#line 367
    i ++;
#line 367
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  curbit += code_size___0;
#line 371
  return (ret);
}
}
#line 376 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int fresh  =    0;
#line 377 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int code_size  ;
#line 377 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int set_code_size  ;
#line 378 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int max_code  ;
#line 378 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int max_code_size  ;
#line 379 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int firstcode  ;
#line 379 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int oldcode  ;
#line 380 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int clear_code  ;
#line 380 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int end_code  ;
#line 381 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int table[2][4096]  ;
#line 382 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int stack[8192]  ;
#line 382 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int *sp  ;
#line 374 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int LZWDecodeByte(int init_flag , int input_code_size , FILE *stream ) 
{ 
  int code ;
  int incode ;
  int i ;
  int count ;
  unsigned char buffer___0[260] ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 386
  if (init_flag) {
    {
#line 388
    fresh = 1;
#line 389
    set_code_size = input_code_size;
#line 390
    code_size = set_code_size + 1;
#line 391
    clear_code = 1 << set_code_size;
#line 392
    end_code = clear_code + 1;
#line 393
    max_code_size = 2 * clear_code;
#line 394
    max_code = clear_code + 2;
#line 396
    LZWGetCode(0, 1, stream);
#line 398
    i = 0;
    }
    {
#line 398
    while (1) {
      while_continue: /* CIL Label */ ;
#line 398
      if (! (i < clear_code)) {
#line 398
        goto while_break;
      }
#line 400
      table[0][i] = 0;
#line 401
      table[1][i] = i;
#line 398
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 403
      if (! (i <= (1 << 12) - 1)) {
#line 403
        goto while_break___0;
      }
#line 405
      table[0][i] = 0;
#line 406
      table[1][i] = 0;
#line 403
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 409
    sp = stack;
#line 410
    return (0);
  } else
#line 412
  if (fresh) {
#line 414
    fresh = 0;
    {
#line 415
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 417
      oldcode = LZWGetCode(code_size, 0, stream);
#line 417
      firstcode = oldcode;
      }
#line 415
      if (! (firstcode == clear_code)) {
#line 415
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 419
    return (firstcode);
  }
#line 422
  if ((unsigned long )sp > (unsigned long )(stack)) {
#line 423
    sp --;
#line 423
    return (*sp);
  }
  {
#line 425
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 425
    code = LZWGetCode(code_size, 0, stream);
    }
#line 425
    if (! (code >= 0)) {
#line 425
      goto while_break___2;
    }
#line 427
    if (code == clear_code) {
#line 429
      i = 0;
      {
#line 429
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 429
        if (! (i < clear_code)) {
#line 429
          goto while_break___3;
        }
#line 431
        table[0][i] = 0;
#line 432
        table[1][i] = i;
#line 429
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 434
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 434
        if (! (i <= (1 << 12) - 1)) {
#line 434
          goto while_break___4;
        }
#line 436
        table[0][i] = 0;
#line 437
        table[1][i] = 0;
#line 434
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 440
      code_size = set_code_size + 1;
#line 441
      max_code_size = 2 * clear_code;
#line 442
      max_code = clear_code + 2;
#line 443
      sp = stack;
#line 444
      oldcode = LZWGetCode(code_size, 0, stream);
#line 444
      firstcode = oldcode;
      }
#line 445
      return (firstcode);
    } else
#line 447
    if (code == end_code) {
#line 452
      if (DataBlockSize == 0) {
#line 453
        return (-2);
      }
      {
#line 455
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 455
        count = GIFReadDataBlock(buffer___0, stream);
        }
#line 455
        if (! (count > 0)) {
#line 455
          goto while_break___5;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 465
      return (-2);
    }
#line 468
    incode = code;
#line 470
    if (code >= max_code) {
#line 472
      tmp = sp;
#line 472
      sp ++;
#line 472
      *tmp = firstcode;
#line 473
      code = oldcode;
    }
    {
#line 476
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 476
      if (! (code >= clear_code)) {
#line 476
        goto while_break___6;
      }
#line 478
      tmp___0 = sp;
#line 478
      sp ++;
#line 478
      *tmp___0 = table[1][code];
#line 479
      if (code == table[0][code]) {
        {
#line 481
        (*GIFError)("Circular dependency found in LZW table");
        }
      } else
#line 479
      if ((size_t )(sp - stack) >= sizeof(stack) / sizeof(stack[0])) {
        {
#line 481
        (*GIFError)("Circular dependency found in LZW table");
        }
      }
#line 482
      code = table[0][code];
    }
    while_break___6: /* CIL Label */ ;
    }
#line 485
    tmp___1 = sp;
#line 485
    sp ++;
#line 485
    firstcode = table[1][code];
#line 485
    *tmp___1 = firstcode;
#line 487
    code = max_code;
#line 487
    if (code <= (1 << 12) - 1) {
#line 489
      table[0][code] = oldcode;
#line 490
      table[1][code] = firstcode;
#line 491
      max_code ++;
#line 492
      if (max_code >= max_code_size) {
#line 492
        if (max_code_size <= (1 << 12) - 1) {
#line 494
          max_code_size *= 2;
#line 495
          code_size ++;
        }
      }
    }
#line 499
    oldcode = incode;
#line 501
    if ((unsigned long )sp > (unsigned long )(stack)) {
#line 502
      sp --;
#line 502
      return (*sp);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 504
  return (code);
}
}
#line 516 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static unsigned char DefaultColorTable[24]  = 
#line 516
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)255, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)255,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)255,      (unsigned char)0,      (unsigned char)255, 
        (unsigned char)0,      (unsigned char)255,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)255,      (unsigned char)255,      (unsigned char)0};
#line 532 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void GIFGetColorTable(unsigned char **colors , unsigned int *numColors , struct GIFImage *image___0 ) 
{ 
  struct GIFScreen *screen ;

  {
#line 537
  if (image___0->LocalColorFlag) {
#line 540
    *colors = image___0->LocalColorTable;
#line 541
    *numColors = image___0->LocalNumColors;
#line 542
    return;
  }
#line 545
  screen = image___0->Screen;
#line 546
  if (screen->GlobalColorFlag) {
#line 549
    *colors = screen->GlobalColorTable;
#line 550
    *numColors = screen->GlobalNumColors;
#line 551
    return;
  }
#line 555
  *colors = DefaultColorTable;
#line 556
  *numColors = (unsigned int )(sizeof(DefaultColorTable) / 3UL);
#line 557
  return;
}
}
#line 562 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void GIFInitExtension(struct GIFExtension *ext , struct GIFScreen *screen , unsigned int initBufferSize ) 
{ 
  unsigned char *newBuffer ;
  void *tmp ;

  {
#line 567
  ext->Screen = screen;
#line 568
  if (initBufferSize > 0U) {
    {
#line 570
    tmp = malloc((size_t )initBufferSize);
#line 570
    newBuffer = (unsigned char *)tmp;
    }
#line 571
    if ((unsigned long )newBuffer == (unsigned long )((void *)0)) {
      {
#line 572
      ErrorAlloc();
      }
    }
#line 573
    ext->Buffer = newBuffer;
#line 574
    ext->BufferSize = initBufferSize;
  } else {
#line 578
    ext->Buffer = (unsigned char *)((void *)0);
#line 579
    ext->BufferSize = 0U;
  }
#line 581
  return;
}
}
#line 586 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void GIFDestroyExtension(struct GIFExtension *ext ) 
{ 


  {
  {
#line 588
  free((void *)ext->Buffer);
  }
#line 589
  return;
}
}
#line 594 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void GIFReadNextExtension(struct GIFExtension *ext , FILE *stream ) 
{ 
  unsigned char *newBuffer ;
  unsigned int newBufferSize ;
  unsigned int offset ;
  unsigned int len ;
  int count ;
  int label ;
  void *tmp ;

  {
  {
#line 601
  label = GetByte(stream);
  }
#line 603
  if ((unsigned long )ext == (unsigned long )((void *)0)) {
    {
#line 605
    GIFSkipDataBlocks(stream);
    }
#line 606
    return;
  }
#line 608
  ext->Label = (unsigned char )label;
#line 610
  offset = 0U;
#line 611
  len = ext->BufferSize;
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 614
    if (len < 255U) {
      {
#line 616
      newBufferSize = ext->BufferSize + 1024U;
#line 617
      tmp = realloc((void *)ext->Buffer, (size_t )newBufferSize);
#line 617
      newBuffer = (unsigned char *)tmp;
      }
#line 618
      if ((unsigned long )newBuffer == (unsigned long )((void *)0)) {
        {
#line 619
        ErrorAlloc();
        }
      }
#line 620
      ext->BufferSize = newBufferSize;
#line 621
      ext->Buffer = newBuffer;
#line 622
      len += 1024U;
    }
    {
#line 624
    count = GIFReadDataBlock(ext->Buffer + offset, stream);
    }
#line 625
    if (count == 0) {
#line 626
      goto while_break;
    }
#line 627
    offset += (unsigned int )count;
#line 628
    len -= (unsigned int )count;
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  return;
}
}
#line 636 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void GIFGetGraphicCtl(struct GIFGraphicCtlExt *graphicExt , struct GIFExtension *ext ) 
{ 
  unsigned char *buffer___0 ;

  {
#line 642
  if ((int )ext->Label != 249) {
    {
#line 644
    (*GIFWarning)("Not a graphic control extension in GIF file");
    }
#line 645
    return;
  }
#line 647
  if (ext->BufferSize < 4U) {
    {
#line 649
    (*GIFWarning)("Broken graphic control extension in GIF file");
    }
#line 650
    return;
  }
#line 653
  buffer___0 = ext->Buffer;
#line 654
  graphicExt->DisposalMethod = (unsigned int )(((int )*(buffer___0 + 0) >> 2) & 7);
#line 655
  graphicExt->InputFlag = (unsigned int )(((int )*(buffer___0 + 0) >> 1) & 1);
#line 656
  graphicExt->TransparentFlag = (unsigned int )((int )*(buffer___0 + 0) & 1);
#line 657
  graphicExt->DelayTime = (unsigned int )((int )*((buffer___0 + 1) + 0) + ((int )*((buffer___0 + 1) + 1) << 8));
#line 658
  graphicExt->Transparent = (unsigned int )*(buffer___0 + 3);
#line 659
  return;
}
}
#line 664 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static int GetByte(FILE *stream ) 
{ 
  int ch ;

  {
  {
#line 668
  ch = _IO_getc(stream);
  }
#line 668
  if (ch == -1) {
    {
#line 669
    ErrorRead(stream);
    }
  }
#line 670
  return (ch);
}
}
#line 676 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void ReadBytes(unsigned char *buffer___0 , unsigned int count , FILE *stream ) 
{ 
  size_t tmp ;

  {
  {
#line 678
  tmp = fread((void */* __restrict  */)buffer___0, (size_t )count, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 678
  if (tmp != 1UL) {
    {
#line 679
    ErrorRead(stream);
    }
  }
#line 680
  return;
}
}
#line 685 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void ErrorAlloc(void) 
{ 


  {
  {
#line 687
  (*GIFError)("Out of memory in GIF decoder");
  }
#line 688
  return;
}
}
#line 693 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void ErrorRead(FILE *stream ) 
{ 
  int tmp ;

  {
  {
#line 695
  tmp = ferror(stream);
  }
#line 695
  if (tmp) {
    {
#line 696
    (*GIFError)("Error reading GIF file");
    }
  } else {
    {
#line 698
    (*GIFError)("Unexpected end of GIF file");
    }
  }
#line 699
  return;
}
}
#line 704 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void DefaultError(char const   *message ) 
{ 


  {
  {
#line 706
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
#line 707
  exit(1);
  }
}
}
#line 713 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
static void DefaultWarning(char const   *message ) 
{ 


  {
  {
#line 715
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          message);
  }
#line 716
  return;
}
}
#line 721 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void (*GIFError)(char const   *message )  =    & DefaultError;
#line 726 "/home/khheo/project/benchmark/optipng-0.7.7/src/gifread/gifread.c"
void (*GIFWarning)(char const   *message )  =    & DefaultWarning;
#line 238 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
char const   *zlibVersion(void) ;
#line 1192
uLong zlibCompileFlags(void) ;
#line 1906
char const   *zError(int err ) ;
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 49 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.h"
char * const  z_errmsg[10] ;
#line 257
voidpf __attribute__((__visibility__("hidden")))  zcalloc(voidpf opaque , unsigned int items ,
                                                          unsigned int size ) ;
#line 259
void __attribute__((__visibility__("hidden")))  zcfree(voidpf opaque , voidpf ptr ) ;
#line 13 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.c"
char * const  z_errmsg[10]  = 
#line 13 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.c"
  {      (char */* const  */)((char *)"need dictionary"),      (char */* const  */)((char *)"stream end"),      (char */* const  */)((char *)""),      (char */* const  */)((char *)"file error"), 
        (char */* const  */)((char *)"stream error"),      (char */* const  */)((char *)"data error"),      (char */* const  */)((char *)"insufficient memory"),      (char */* const  */)((char *)"buffer error"), 
        (char */* const  */)((char *)"incompatible version"),      (char */* const  */)((char *)"")};
#line 27 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.c"
char const   *zlibVersion(void) 
{ 


  {
#line 29
  return ("1.2.11-optipng");
}
}
#line 32 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.c"
uLong zlibCompileFlags(void) 
{ 
  uLong flags ;

  {
#line 36
  flags = (uLong )0;
  {
#line 38
  if ((int )sizeof(uInt ) == 2) {
#line 38
    goto case_2;
  }
#line 39
  if ((int )sizeof(uInt ) == 4) {
#line 39
    goto case_4;
  }
#line 40
  if ((int )sizeof(uInt ) == 8) {
#line 40
    goto case_8;
  }
#line 41
  goto switch_default;
  case_2: /* CIL Label */ 
#line 38
  goto switch_break;
  case_4: /* CIL Label */ 
#line 39
  flags ++;
#line 39
  goto switch_break;
  case_8: /* CIL Label */ 
#line 40
  flags += 2UL;
#line 40
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 41
  flags += 3UL;
  switch_break: /* CIL Label */ ;
  }
  {
#line 44
  if ((int )sizeof(uLong ) == 2) {
#line 44
    goto case_2___0;
  }
#line 45
  if ((int )sizeof(uLong ) == 4) {
#line 45
    goto case_4___0;
  }
#line 46
  if ((int )sizeof(uLong ) == 8) {
#line 46
    goto case_8___0;
  }
#line 47
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
#line 44
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 45
  flags += (uLong )(1 << 2);
#line 45
  goto switch_break___0;
  case_8___0: /* CIL Label */ 
#line 46
  flags += (uLong )(2 << 2);
#line 46
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 47
  flags += (uLong )(3 << 2);
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 50
  if ((int )sizeof(voidpf ) == 2) {
#line 50
    goto case_2___1;
  }
#line 51
  if ((int )sizeof(voidpf ) == 4) {
#line 51
    goto case_4___1;
  }
#line 52
  if ((int )sizeof(voidpf ) == 8) {
#line 52
    goto case_8___1;
  }
#line 53
  goto switch_default___1;
  case_2___1: /* CIL Label */ 
#line 50
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 51
  flags += (uLong )(1 << 4);
#line 51
  goto switch_break___1;
  case_8___1: /* CIL Label */ 
#line 52
  flags += (uLong )(2 << 4);
#line 52
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 53
  flags += (uLong )(3 << 4);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 56
  if ((int )sizeof(off_t ) == 2) {
#line 56
    goto case_2___2;
  }
#line 57
  if ((int )sizeof(off_t ) == 4) {
#line 57
    goto case_4___2;
  }
#line 58
  if ((int )sizeof(off_t ) == 8) {
#line 58
    goto case_8___2;
  }
#line 59
  goto switch_default___2;
  case_2___2: /* CIL Label */ 
#line 56
  goto switch_break___2;
  case_4___2: /* CIL Label */ 
#line 57
  flags += (uLong )(1 << 6);
#line 57
  goto switch_break___2;
  case_8___2: /* CIL Label */ 
#line 58
  flags += (uLong )(2 << 6);
#line 58
  goto switch_break___2;
  switch_default___2: /* CIL Label */ 
#line 59
  flags += (uLong )(3 << 6);
  switch_break___2: /* CIL Label */ ;
  }
#line 77
  flags += (uLong )(1L << 16);
#line 80
  flags += (uLong )(1L << 17);
#line 112
  return (flags);
}
}
#line 133 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.c"
char const   *zError(int err ) 
{ 


  {
#line 136
  return ((char const   *)z_errmsg[2 - err]);
}
}
#line 305 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.c"
voidpf __attribute__((__visibility__("hidden")))  zcalloc(voidpf opaque , unsigned int items ,
                                                          unsigned int size ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  voidpf tmp___1 ;

  {
#line 311
  if (sizeof(uInt ) > 2UL) {
    {
#line 311
    tmp = malloc((size_t )(items * size));
#line 311
    tmp___1 = tmp;
    }
  } else {
    {
#line 311
    tmp___0 = calloc((size_t )items, (size_t )size);
#line 311
    tmp___1 = tmp___0;
    }
  }
#line 311
  return ((voidpf __attribute__((__visibility__("hidden")))  )tmp___1);
}
}
#line 315 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zutil.c"
void __attribute__((__visibility__("hidden")))  zcfree(voidpf opaque , voidpf ptr ) 
{ 


  {
  {
#line 320
  free(ptr);
  }
#line 321
  return;
}
}
#line 418 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int inflate(z_streamp strm , int flush ) ;
#line 538
int inflateEnd(z_streamp strm ) ;
#line 1283
int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1301
int uncompress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong *sourceLen ) ;
#line 1784
int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 27 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/uncompr.c"
int uncompress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong *sourceLen ) 
{ 
  z_stream stream ;
  int err ;
  uInt max ;
  uLong len ;
  uLong left ;
  Byte buf[1] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 35
  max = (uInt )-1;
#line 39
  len = *sourceLen;
#line 40
  if (*destLen) {
#line 41
    left = *destLen;
#line 42
    *destLen = (uLongf )0;
  } else {
#line 45
    left = (uLong )1;
#line 46
    dest = buf;
  }
  {
#line 49
  stream.next_in = (Bytef *)source;
#line 50
  stream.avail_in = (uInt )0;
#line 51
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 52
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 53
  stream.opaque = (voidpf )0;
#line 55
  err = inflateInit_(& stream, "1.2.11-optipng", (int )sizeof(z_stream ));
  }
#line 56
  if (err != 0) {
#line 56
    return (err);
  }
#line 58
  stream.next_out = dest;
#line 59
  stream.avail_out = (uInt )0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (stream.avail_out == 0U) {
#line 63
      if (left > (uLong )max) {
#line 63
        stream.avail_out = max;
      } else {
#line 63
        stream.avail_out = (uInt )left;
      }
#line 64
      left -= (uLong )stream.avail_out;
    }
#line 66
    if (stream.avail_in == 0U) {
#line 67
      if (len > (uLong )max) {
#line 67
        stream.avail_in = max;
      } else {
#line 67
        stream.avail_in = (uInt )len;
      }
#line 68
      len -= (uLong )stream.avail_in;
    }
    {
#line 70
    err = inflate(& stream, 0);
    }
#line 61
    if (! (err == 0)) {
#line 61
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  *sourceLen -= len + (uLong )stream.avail_in;
#line 74
  if ((unsigned long )dest != (unsigned long )(buf)) {
#line 75
    *destLen = stream.total_out;
  } else
#line 76
  if (stream.total_out) {
#line 76
    if (err == -5) {
#line 77
      left = (uLong )1;
    }
  }
  {
#line 79
  inflateEnd(& stream);
  }
#line 80
  if (err == 1) {
#line 80
    tmp___1 = 0;
  } else {
#line 80
    if (err == 2) {
#line 80
      tmp___0 = -3;
    } else {
#line 80
      if (err == -5) {
#line 80
        if (left + (uLong )stream.avail_out) {
#line 80
          tmp = -3;
        } else {
#line 80
          tmp = err;
        }
      } else {
#line 80
        tmp = err;
      }
#line 80
      tmp___0 = tmp;
    }
#line 80
    tmp___1 = tmp___0;
  }
#line 80
  return (tmp___1);
}
}
#line 86 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/uncompr.c"
int uncompress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) 
{ 
  int tmp ;

  {
  {
#line 92
  tmp = uncompress2(dest, destLen, source, & sourceLen);
  }
#line 92
  return (tmp);
}
}
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 299 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.h"
void __attribute__((__visibility__("hidden")))  _tr_init(deflate_state *s ) ;
#line 300
int __attribute__((__visibility__("hidden")))  _tr_tally(deflate_state *s , unsigned int dist ,
                                                         unsigned int lc ) ;
#line 301
void __attribute__((__visibility__("hidden")))  _tr_flush_block(deflate_state *s ,
                                                                charf *buf , ulg stored_len ,
                                                                int last ) ;
#line 303
void __attribute__((__visibility__("hidden")))  _tr_flush_bits(deflate_state *s ) ;
#line 304
void __attribute__((__visibility__("hidden")))  _tr_align(deflate_state *s ) ;
#line 305
void __attribute__((__visibility__("hidden")))  _tr_stored_block(deflate_state *s ,
                                                                 charf *buf , ulg stored_len ,
                                                                 int last ) ;
#line 322
uch const __attribute__((__visibility__("hidden")))  _length_code[256] ;
#line 323
uch const __attribute__((__visibility__("hidden")))  _dist_code[512] ;
#line 62 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static int const   extra_lbits[29]  = 
#line 62 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )1,      (int const   )1, 
        (int const   )2,      (int const   )2,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )3,      (int const   )3, 
        (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )5,      (int const   )5, 
        (int const   )0};
#line 65 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static int const   extra_dbits[30]  = 
#line 65
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )1,      (int const   )1,      (int const   )2,      (int const   )2, 
        (int const   )3,      (int const   )3,      (int const   )4,      (int const   )4, 
        (int const   )5,      (int const   )5,      (int const   )6,      (int const   )6, 
        (int const   )7,      (int const   )7,      (int const   )8,      (int const   )8, 
        (int const   )9,      (int const   )9,      (int const   )10,      (int const   )10, 
        (int const   )11,      (int const   )11,      (int const   )12,      (int const   )12, 
        (int const   )13,      (int const   )13};
#line 68 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static int const   extra_blbits[19]  = 
#line 68
  {      (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )0,      (int const   )0,      (int const   )0,      (int const   )0, 
        (int const   )2,      (int const   )3,      (int const   )7};
#line 71 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static uch const   bl_order[19]  = 
#line 71
  {      (uch const   )16,      (uch const   )17,      (uch const   )18,      (uch const   )0, 
        (uch const   )8,      (uch const   )7,      (uch const   )9,      (uch const   )6, 
        (uch const   )10,      (uch const   )5,      (uch const   )11,      (uch const   )4, 
        (uch const   )12,      (uch const   )3,      (uch const   )13,      (uch const   )2, 
        (uch const   )14,      (uch const   )1,      (uch const   )15};
#line 3 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.h"
static ct_data const   static_ltree[288]  = 
#line 3 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.h"
  {      {{(ush )12}, {(ush )8}}, 
        {{(ush )140}, {(ush )8}}, 
        {{(ush )76}, {(ush )8}}, 
        {{(ush )204}, {(ush )8}}, 
        {{(ush )44}, {(ush )8}}, 
        {{(ush )172}, {(ush )8}}, 
        {{(ush )108}, {(ush )8}}, 
        {{(ush )236}, {(ush )8}}, 
        {{(ush )28}, {(ush )8}}, 
        {{(ush )156}, {(ush )8}}, 
        {{(ush )92}, {(ush )8}}, 
        {{(ush )220}, {(ush )8}}, 
        {{(ush )60}, {(ush )8}}, 
        {{(ush )188}, {(ush )8}}, 
        {{(ush )124}, {(ush )8}}, 
        {{(ush )252}, {(ush )8}}, 
        {{(ush )2}, {(ush )8}}, 
        {{(ush )130}, {(ush )8}}, 
        {{(ush )66}, {(ush )8}}, 
        {{(ush )194}, {(ush )8}}, 
        {{(ush )34}, {(ush )8}}, 
        {{(ush )162}, {(ush )8}}, 
        {{(ush )98}, {(ush )8}}, 
        {{(ush )226}, {(ush )8}}, 
        {{(ush )18}, {(ush )8}}, 
        {{(ush )146}, {(ush )8}}, 
        {{(ush )82}, {(ush )8}}, 
        {{(ush )210}, {(ush )8}}, 
        {{(ush )50}, {(ush )8}}, 
        {{(ush )178}, {(ush )8}}, 
        {{(ush )114}, {(ush )8}}, 
        {{(ush )242}, {(ush )8}}, 
        {{(ush )10}, {(ush )8}}, 
        {{(ush )138}, {(ush )8}}, 
        {{(ush )74}, {(ush )8}}, 
        {{(ush )202}, {(ush )8}}, 
        {{(ush )42}, {(ush )8}}, 
        {{(ush )170}, {(ush )8}}, 
        {{(ush )106}, {(ush )8}}, 
        {{(ush )234}, {(ush )8}}, 
        {{(ush )26}, {(ush )8}}, 
        {{(ush )154}, {(ush )8}}, 
        {{(ush )90}, {(ush )8}}, 
        {{(ush )218}, {(ush )8}}, 
        {{(ush )58}, {(ush )8}}, 
        {{(ush )186}, {(ush )8}}, 
        {{(ush )122}, {(ush )8}}, 
        {{(ush )250}, {(ush )8}}, 
        {{(ush )6}, {(ush )8}}, 
        {{(ush )134}, {(ush )8}}, 
        {{(ush )70}, {(ush )8}}, 
        {{(ush )198}, {(ush )8}}, 
        {{(ush )38}, {(ush )8}}, 
        {{(ush )166}, {(ush )8}}, 
        {{(ush )102}, {(ush )8}}, 
        {{(ush )230}, {(ush )8}}, 
        {{(ush )22}, {(ush )8}}, 
        {{(ush )150}, {(ush )8}}, 
        {{(ush )86}, {(ush )8}}, 
        {{(ush )214}, {(ush )8}}, 
        {{(ush )54}, {(ush )8}}, 
        {{(ush )182}, {(ush )8}}, 
        {{(ush )118}, {(ush )8}}, 
        {{(ush )246}, {(ush )8}}, 
        {{(ush )14}, {(ush )8}}, 
        {{(ush )142}, {(ush )8}}, 
        {{(ush )78}, {(ush )8}}, 
        {{(ush )206}, {(ush )8}}, 
        {{(ush )46}, {(ush )8}}, 
        {{(ush )174}, {(ush )8}}, 
        {{(ush )110}, {(ush )8}}, 
        {{(ush )238}, {(ush )8}}, 
        {{(ush )30}, {(ush )8}}, 
        {{(ush )158}, {(ush )8}}, 
        {{(ush )94}, {(ush )8}}, 
        {{(ush )222}, {(ush )8}}, 
        {{(ush )62}, {(ush )8}}, 
        {{(ush )190}, {(ush )8}}, 
        {{(ush )126}, {(ush )8}}, 
        {{(ush )254}, {(ush )8}}, 
        {{(ush )1}, {(ush )8}}, 
        {{(ush )129}, {(ush )8}}, 
        {{(ush )65}, {(ush )8}}, 
        {{(ush )193}, {(ush )8}}, 
        {{(ush )33}, {(ush )8}}, 
        {{(ush )161}, {(ush )8}}, 
        {{(ush )97}, {(ush )8}}, 
        {{(ush )225}, {(ush )8}}, 
        {{(ush )17}, {(ush )8}}, 
        {{(ush )145}, {(ush )8}}, 
        {{(ush )81}, {(ush )8}}, 
        {{(ush )209}, {(ush )8}}, 
        {{(ush )49}, {(ush )8}}, 
        {{(ush )177}, {(ush )8}}, 
        {{(ush )113}, {(ush )8}}, 
        {{(ush )241}, {(ush )8}}, 
        {{(ush )9}, {(ush )8}}, 
        {{(ush )137}, {(ush )8}}, 
        {{(ush )73}, {(ush )8}}, 
        {{(ush )201}, {(ush )8}}, 
        {{(ush )41}, {(ush )8}}, 
        {{(ush )169}, {(ush )8}}, 
        {{(ush )105}, {(ush )8}}, 
        {{(ush )233}, {(ush )8}}, 
        {{(ush )25}, {(ush )8}}, 
        {{(ush )153}, {(ush )8}}, 
        {{(ush )89}, {(ush )8}}, 
        {{(ush )217}, {(ush )8}}, 
        {{(ush )57}, {(ush )8}}, 
        {{(ush )185}, {(ush )8}}, 
        {{(ush )121}, {(ush )8}}, 
        {{(ush )249}, {(ush )8}}, 
        {{(ush )5}, {(ush )8}}, 
        {{(ush )133}, {(ush )8}}, 
        {{(ush )69}, {(ush )8}}, 
        {{(ush )197}, {(ush )8}}, 
        {{(ush )37}, {(ush )8}}, 
        {{(ush )165}, {(ush )8}}, 
        {{(ush )101}, {(ush )8}}, 
        {{(ush )229}, {(ush )8}}, 
        {{(ush )21}, {(ush )8}}, 
        {{(ush )149}, {(ush )8}}, 
        {{(ush )85}, {(ush )8}}, 
        {{(ush )213}, {(ush )8}}, 
        {{(ush )53}, {(ush )8}}, 
        {{(ush )181}, {(ush )8}}, 
        {{(ush )117}, {(ush )8}}, 
        {{(ush )245}, {(ush )8}}, 
        {{(ush )13}, {(ush )8}}, 
        {{(ush )141}, {(ush )8}}, 
        {{(ush )77}, {(ush )8}}, 
        {{(ush )205}, {(ush )8}}, 
        {{(ush )45}, {(ush )8}}, 
        {{(ush )173}, {(ush )8}}, 
        {{(ush )109}, {(ush )8}}, 
        {{(ush )237}, {(ush )8}}, 
        {{(ush )29}, {(ush )8}}, 
        {{(ush )157}, {(ush )8}}, 
        {{(ush )93}, {(ush )8}}, 
        {{(ush )221}, {(ush )8}}, 
        {{(ush )61}, {(ush )8}}, 
        {{(ush )189}, {(ush )8}}, 
        {{(ush )125}, {(ush )8}}, 
        {{(ush )253}, {(ush )8}}, 
        {{(ush )19}, {(ush )9}}, 
        {{(ush )275}, {(ush )9}}, 
        {{(ush )147}, {(ush )9}}, 
        {{(ush )403}, {(ush )9}}, 
        {{(ush )83}, {(ush )9}}, 
        {{(ush )339}, {(ush )9}}, 
        {{(ush )211}, {(ush )9}}, 
        {{(ush )467}, {(ush )9}}, 
        {{(ush )51}, {(ush )9}}, 
        {{(ush )307}, {(ush )9}}, 
        {{(ush )179}, {(ush )9}}, 
        {{(ush )435}, {(ush )9}}, 
        {{(ush )115}, {(ush )9}}, 
        {{(ush )371}, {(ush )9}}, 
        {{(ush )243}, {(ush )9}}, 
        {{(ush )499}, {(ush )9}}, 
        {{(ush )11}, {(ush )9}}, 
        {{(ush )267}, {(ush )9}}, 
        {{(ush )139}, {(ush )9}}, 
        {{(ush )395}, {(ush )9}}, 
        {{(ush )75}, {(ush )9}}, 
        {{(ush )331}, {(ush )9}}, 
        {{(ush )203}, {(ush )9}}, 
        {{(ush )459}, {(ush )9}}, 
        {{(ush )43}, {(ush )9}}, 
        {{(ush )299}, {(ush )9}}, 
        {{(ush )171}, {(ush )9}}, 
        {{(ush )427}, {(ush )9}}, 
        {{(ush )107}, {(ush )9}}, 
        {{(ush )363}, {(ush )9}}, 
        {{(ush )235}, {(ush )9}}, 
        {{(ush )491}, {(ush )9}}, 
        {{(ush )27}, {(ush )9}}, 
        {{(ush )283}, {(ush )9}}, 
        {{(ush )155}, {(ush )9}}, 
        {{(ush )411}, {(ush )9}}, 
        {{(ush )91}, {(ush )9}}, 
        {{(ush )347}, {(ush )9}}, 
        {{(ush )219}, {(ush )9}}, 
        {{(ush )475}, {(ush )9}}, 
        {{(ush )59}, {(ush )9}}, 
        {{(ush )315}, {(ush )9}}, 
        {{(ush )187}, {(ush )9}}, 
        {{(ush )443}, {(ush )9}}, 
        {{(ush )123}, {(ush )9}}, 
        {{(ush )379}, {(ush )9}}, 
        {{(ush )251}, {(ush )9}}, 
        {{(ush )507}, {(ush )9}}, 
        {{(ush )7}, {(ush )9}}, 
        {{(ush )263}, {(ush )9}}, 
        {{(ush )135}, {(ush )9}}, 
        {{(ush )391}, {(ush )9}}, 
        {{(ush )71}, {(ush )9}}, 
        {{(ush )327}, {(ush )9}}, 
        {{(ush )199}, {(ush )9}}, 
        {{(ush )455}, {(ush )9}}, 
        {{(ush )39}, {(ush )9}}, 
        {{(ush )295}, {(ush )9}}, 
        {{(ush )167}, {(ush )9}}, 
        {{(ush )423}, {(ush )9}}, 
        {{(ush )103}, {(ush )9}}, 
        {{(ush )359}, {(ush )9}}, 
        {{(ush )231}, {(ush )9}}, 
        {{(ush )487}, {(ush )9}}, 
        {{(ush )23}, {(ush )9}}, 
        {{(ush )279}, {(ush )9}}, 
        {{(ush )151}, {(ush )9}}, 
        {{(ush )407}, {(ush )9}}, 
        {{(ush )87}, {(ush )9}}, 
        {{(ush )343}, {(ush )9}}, 
        {{(ush )215}, {(ush )9}}, 
        {{(ush )471}, {(ush )9}}, 
        {{(ush )55}, {(ush )9}}, 
        {{(ush )311}, {(ush )9}}, 
        {{(ush )183}, {(ush )9}}, 
        {{(ush )439}, {(ush )9}}, 
        {{(ush )119}, {(ush )9}}, 
        {{(ush )375}, {(ush )9}}, 
        {{(ush )247}, {(ush )9}}, 
        {{(ush )503}, {(ush )9}}, 
        {{(ush )15}, {(ush )9}}, 
        {{(ush )271}, {(ush )9}}, 
        {{(ush )143}, {(ush )9}}, 
        {{(ush )399}, {(ush )9}}, 
        {{(ush )79}, {(ush )9}}, 
        {{(ush )335}, {(ush )9}}, 
        {{(ush )207}, {(ush )9}}, 
        {{(ush )463}, {(ush )9}}, 
        {{(ush )47}, {(ush )9}}, 
        {{(ush )303}, {(ush )9}}, 
        {{(ush )175}, {(ush )9}}, 
        {{(ush )431}, {(ush )9}}, 
        {{(ush )111}, {(ush )9}}, 
        {{(ush )367}, {(ush )9}}, 
        {{(ush )239}, {(ush )9}}, 
        {{(ush )495}, {(ush )9}}, 
        {{(ush )31}, {(ush )9}}, 
        {{(ush )287}, {(ush )9}}, 
        {{(ush )159}, {(ush )9}}, 
        {{(ush )415}, {(ush )9}}, 
        {{(ush )95}, {(ush )9}}, 
        {{(ush )351}, {(ush )9}}, 
        {{(ush )223}, {(ush )9}}, 
        {{(ush )479}, {(ush )9}}, 
        {{(ush )63}, {(ush )9}}, 
        {{(ush )319}, {(ush )9}}, 
        {{(ush )191}, {(ush )9}}, 
        {{(ush )447}, {(ush )9}}, 
        {{(ush )127}, {(ush )9}}, 
        {{(ush )383}, {(ush )9}}, 
        {{(ush )255}, {(ush )9}}, 
        {{(ush )511}, {(ush )9}}, 
        {{(ush )0}, {(ush )7}}, 
        {{(ush )64}, {(ush )7}}, 
        {{(ush )32}, {(ush )7}}, 
        {{(ush )96}, {(ush )7}}, 
        {{(ush )16}, {(ush )7}}, 
        {{(ush )80}, {(ush )7}}, 
        {{(ush )48}, {(ush )7}}, 
        {{(ush )112}, {(ush )7}}, 
        {{(ush )8}, {(ush )7}}, 
        {{(ush )72}, {(ush )7}}, 
        {{(ush )40}, {(ush )7}}, 
        {{(ush )104}, {(ush )7}}, 
        {{(ush )24}, {(ush )7}}, 
        {{(ush )88}, {(ush )7}}, 
        {{(ush )56}, {(ush )7}}, 
        {{(ush )120}, {(ush )7}}, 
        {{(ush )4}, {(ush )7}}, 
        {{(ush )68}, {(ush )7}}, 
        {{(ush )36}, {(ush )7}}, 
        {{(ush )100}, {(ush )7}}, 
        {{(ush )20}, {(ush )7}}, 
        {{(ush )84}, {(ush )7}}, 
        {{(ush )52}, {(ush )7}}, 
        {{(ush )116}, {(ush )7}}, 
        {{(ush )3}, {(ush )8}}, 
        {{(ush )131}, {(ush )8}}, 
        {{(ush )67}, {(ush )8}}, 
        {{(ush )195}, {(ush )8}}, 
        {{(ush )35}, {(ush )8}}, 
        {{(ush )163}, {(ush )8}}, 
        {{(ush )99}, {(ush )8}}, 
        {{(ush )227}, {(ush )8}}};
#line 64 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.h"
static ct_data const   static_dtree[30]  = 
#line 64
  {      {{(ush )0}, {(ush )5}}, 
        {{(ush )16}, {(ush )5}}, 
        {{(ush )8}, {(ush )5}}, 
        {{(ush )24}, {(ush )5}}, 
        {{(ush )4}, {(ush )5}}, 
        {{(ush )20}, {(ush )5}}, 
        {{(ush )12}, {(ush )5}}, 
        {{(ush )28}, {(ush )5}}, 
        {{(ush )2}, {(ush )5}}, 
        {{(ush )18}, {(ush )5}}, 
        {{(ush )10}, {(ush )5}}, 
        {{(ush )26}, {(ush )5}}, 
        {{(ush )6}, {(ush )5}}, 
        {{(ush )22}, {(ush )5}}, 
        {{(ush )14}, {(ush )5}}, 
        {{(ush )30}, {(ush )5}}, 
        {{(ush )1}, {(ush )5}}, 
        {{(ush )17}, {(ush )5}}, 
        {{(ush )9}, {(ush )5}}, 
        {{(ush )25}, {(ush )5}}, 
        {{(ush )5}, {(ush )5}}, 
        {{(ush )21}, {(ush )5}}, 
        {{(ush )13}, {(ush )5}}, 
        {{(ush )29}, {(ush )5}}, 
        {{(ush )3}, {(ush )5}}, 
        {{(ush )19}, {(ush )5}}, 
        {{(ush )11}, {(ush )5}}, 
        {{(ush )27}, {(ush )5}}, 
        {{(ush )7}, {(ush )5}}, 
        {{(ush )23}, {(ush )5}}};
#line 73 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.h"
uch const __attribute__((__visibility__("hidden")))  _dist_code[512]  = 
#line 73
  {      (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )1,      (uch const __attribute__((__visibility__("hidden")))  )2,      (uch const __attribute__((__visibility__("hidden")))  )3, 
        (uch const __attribute__((__visibility__("hidden")))  )4,      (uch const __attribute__((__visibility__("hidden")))  )4,      (uch const __attribute__((__visibility__("hidden")))  )5,      (uch const __attribute__((__visibility__("hidden")))  )5, 
        (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )6, 
        (uch const __attribute__((__visibility__("hidden")))  )7,      (uch const __attribute__((__visibility__("hidden")))  )7,      (uch const __attribute__((__visibility__("hidden")))  )7,      (uch const __attribute__((__visibility__("hidden")))  )7, 
        (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8, 
        (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8, 
        (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9, 
        (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )17, 
        (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28,      (uch const __attribute__((__visibility__("hidden")))  )28, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29, 
        (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29,      (uch const __attribute__((__visibility__("hidden")))  )29};
#line 102 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.h"
uch const __attribute__((__visibility__("hidden")))  _length_code[256]  = 
#line 102
  {      (uch const __attribute__((__visibility__("hidden")))  )0,      (uch const __attribute__((__visibility__("hidden")))  )1,      (uch const __attribute__((__visibility__("hidden")))  )2,      (uch const __attribute__((__visibility__("hidden")))  )3, 
        (uch const __attribute__((__visibility__("hidden")))  )4,      (uch const __attribute__((__visibility__("hidden")))  )5,      (uch const __attribute__((__visibility__("hidden")))  )6,      (uch const __attribute__((__visibility__("hidden")))  )7, 
        (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )8,      (uch const __attribute__((__visibility__("hidden")))  )9,      (uch const __attribute__((__visibility__("hidden")))  )9, 
        (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )10,      (uch const __attribute__((__visibility__("hidden")))  )11,      (uch const __attribute__((__visibility__("hidden")))  )11, 
        (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12,      (uch const __attribute__((__visibility__("hidden")))  )12, 
        (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13,      (uch const __attribute__((__visibility__("hidden")))  )13, 
        (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14,      (uch const __attribute__((__visibility__("hidden")))  )14, 
        (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15,      (uch const __attribute__((__visibility__("hidden")))  )15, 
        (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16, 
        (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16,      (uch const __attribute__((__visibility__("hidden")))  )16, 
        (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17, 
        (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17,      (uch const __attribute__((__visibility__("hidden")))  )17, 
        (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18, 
        (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18,      (uch const __attribute__((__visibility__("hidden")))  )18, 
        (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19, 
        (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19,      (uch const __attribute__((__visibility__("hidden")))  )19, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20,      (uch const __attribute__((__visibility__("hidden")))  )20, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21,      (uch const __attribute__((__visibility__("hidden")))  )21, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22,      (uch const __attribute__((__visibility__("hidden")))  )22, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23,      (uch const __attribute__((__visibility__("hidden")))  )23, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24,      (uch const __attribute__((__visibility__("hidden")))  )24, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25,      (uch const __attribute__((__visibility__("hidden")))  )25, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26,      (uch const __attribute__((__visibility__("hidden")))  )26, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27, 
        (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )27,      (uch const __attribute__((__visibility__("hidden")))  )28};
#line 118 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.h"
static int const   base_length[29]  = 
#line 118
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )5,      (int const   )6,      (int const   )7, 
        (int const   )8,      (int const   )10,      (int const   )12,      (int const   )14, 
        (int const   )16,      (int const   )20,      (int const   )24,      (int const   )28, 
        (int const   )32,      (int const   )40,      (int const   )48,      (int const   )56, 
        (int const   )64,      (int const   )80,      (int const   )96,      (int const   )112, 
        (int const   )128,      (int const   )160,      (int const   )192,      (int const   )224, 
        (int const   )0};
#line 123 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.h"
static int const   base_dist[30]  = 
#line 123
  {      (int const   )0,      (int const   )1,      (int const   )2,      (int const   )3, 
        (int const   )4,      (int const   )6,      (int const   )8,      (int const   )12, 
        (int const   )16,      (int const   )24,      (int const   )32,      (int const   )48, 
        (int const   )64,      (int const   )96,      (int const   )128,      (int const   )192, 
        (int const   )256,      (int const   )384,      (int const   )512,      (int const   )768, 
        (int const   )1024,      (int const   )1536,      (int const   )2048,      (int const   )3072, 
        (int const   )4096,      (int const   )6144,      (int const   )8192,      (int const   )12288, 
        (int const   )16384,      (int const   )24576};
#line 125 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static struct static_tree_desc_s  const  static_l_desc  =    {static_ltree, extra_lbits, 257, 286, 15};
#line 128 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static struct static_tree_desc_s  const  static_d_desc  =    {static_dtree, extra_dbits, 0, 30, 15};
#line 131 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static struct static_tree_desc_s  const  static_bl_desc  =    {(ct_data const   *)0, extra_blbits, 0, 19, 7};
#line 138
static void tr_static_init(void) ;
#line 139
static void init_block(deflate_state *s ) ;
#line 140
static void pqdownheap(deflate_state *s , ct_data *tree , int k ) ;
#line 141
static void gen_bitlen(deflate_state *s , tree_desc *desc ) ;
#line 142
static void gen_codes(ct_data *tree , int max_code___0 , ushf *bl_count ) ;
#line 143
static void build_tree(deflate_state *s , tree_desc *desc ) ;
#line 144
static void scan_tree(deflate_state *s , ct_data *tree , int max_code___0 ) ;
#line 145
static void send_tree(deflate_state *s , ct_data *tree , int max_code___0 ) ;
#line 146
static int build_bl_tree(deflate_state *s ) ;
#line 147
static void send_all_trees(deflate_state *s , int lcodes , int dcodes , int blcodes ) ;
#line 149
static void compress_block(deflate_state *s , ct_data const   *ltree , ct_data const   *dtree ) ;
#line 151
static int detect_data_type(deflate_state *s ) ;
#line 152
static unsigned int bi_reverse(unsigned int code , int len ) ;
#line 153
static void bi_windup(deflate_state *s ) ;
#line 154
static void bi_flush(deflate_state *s ) ;
#line 232 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void tr_static_init(void) 
{ 


  {
#line 312
  return;
}
}
#line 379 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_init(deflate_state *s ) 
{ 


  {
  {
#line 382
  tr_static_init();
#line 384
  s->l_desc.dyn_tree = s->dyn_ltree;
#line 385
  s->l_desc.stat_desc = & static_l_desc;
#line 387
  s->d_desc.dyn_tree = s->dyn_dtree;
#line 388
  s->d_desc.stat_desc = & static_d_desc;
#line 390
  s->bl_desc.dyn_tree = s->bl_tree;
#line 391
  s->bl_desc.stat_desc = & static_bl_desc;
#line 393
  s->bi_buf = (ush )0;
#line 394
  s->bi_valid = 0;
#line 401
  init_block(s);
  }
#line 402
  return;
}
}
#line 407 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void init_block(deflate_state *s ) 
{ 
  int n ;
  ulg tmp ;
  uInt tmp___0 ;

  {
#line 413
  n = 0;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! (n < 286)) {
#line 413
      goto while_break;
    }
#line 413
    s->dyn_ltree[n].fc.freq = (ush )0;
#line 413
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  n = 0;
  {
#line 414
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 414
    if (! (n < 30)) {
#line 414
      goto while_break___0;
    }
#line 414
    s->dyn_dtree[n].fc.freq = (ush )0;
#line 414
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 415
  n = 0;
  {
#line 415
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 415
    if (! (n < 19)) {
#line 415
      goto while_break___1;
    }
#line 415
    s->bl_tree[n].fc.freq = (ush )0;
#line 415
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 417
  s->dyn_ltree[256].fc.freq = (ush )1;
#line 418
  tmp = (ulg )0L;
#line 418
  s->static_len = tmp;
#line 418
  s->opt_len = tmp;
#line 419
  tmp___0 = (uInt )0;
#line 419
  s->matches = tmp___0;
#line 419
  s->last_lit = tmp___0;
#line 420
  return;
}
}
#line 451 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void pqdownheap(deflate_state *s , ct_data *tree , int k ) 
{ 
  int v ;
  int j ;

  {
#line 456
  v = s->heap[k];
#line 457
  j = k << 1;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! (j <= s->heap_len)) {
#line 458
      goto while_break;
    }
#line 460
    if (j < s->heap_len) {
#line 460
      if ((int )(tree + s->heap[j + 1])->fc.freq < (int )(tree + s->heap[j])->fc.freq) {
#line 462
        j ++;
      } else
#line 460
      if ((int )(tree + s->heap[j + 1])->fc.freq == (int )(tree + s->heap[j])->fc.freq) {
#line 460
        if ((int )s->depth[s->heap[j + 1]] <= (int )s->depth[s->heap[j]]) {
#line 462
          j ++;
        }
      }
    }
#line 465
    if ((int )(tree + v)->fc.freq < (int )(tree + s->heap[j])->fc.freq) {
#line 465
      goto while_break;
    } else
#line 465
    if ((int )(tree + v)->fc.freq == (int )(tree + s->heap[j])->fc.freq) {
#line 465
      if ((int )s->depth[v] <= (int )s->depth[s->heap[j]]) {
#line 465
        goto while_break;
      }
    }
#line 468
    s->heap[k] = s->heap[j];
#line 468
    k = j;
#line 471
    j <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 473
  s->heap[k] = v;
#line 474
  return;
}
}
#line 486 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void gen_bitlen(deflate_state *s , tree_desc *desc ) 
{ 
  ct_data *tree ;
  int max_code___0 ;
  ct_data const   *stree ;
  intf const   *extra ;
  int base ;
  int max_length ;
  int h ;
  int n ;
  int m ;
  int bits ;
  int xbits ;
  ush f ;
  int overflow ;

  {
#line 490
  tree = desc->dyn_tree;
#line 491
  max_code___0 = desc->max_code;
#line 492
  stree = (ct_data const   *)(desc->stat_desc)->static_tree;
#line 493
  extra = (intf const   *)(desc->stat_desc)->extra_bits;
#line 494
  base = (int )(desc->stat_desc)->extra_base;
#line 495
  max_length = (int )(desc->stat_desc)->max_length;
#line 501
  overflow = 0;
#line 503
  bits = 0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (bits <= 15)) {
#line 503
      goto while_break;
    }
#line 503
    s->bl_count[bits] = (ush )0;
#line 503
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  (tree + s->heap[s->heap_max])->dl.len = (ush )0;
#line 510
  h = s->heap_max + 1;
  {
#line 510
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 510
    if (! (h < 573)) {
#line 510
      goto while_break___0;
    }
#line 511
    n = s->heap[h];
#line 512
    bits = (int )(tree + (tree + n)->dl.dad)->dl.len + 1;
#line 513
    if (bits > max_length) {
#line 513
      bits = max_length;
#line 513
      overflow ++;
    }
#line 514
    (tree + n)->dl.len = (ush )bits;
#line 517
    if (n > max_code___0) {
#line 517
      goto __Cont;
    }
#line 519
    s->bl_count[bits] = (ush )((int )s->bl_count[bits] + 1);
#line 520
    xbits = 0;
#line 521
    if (n >= base) {
#line 521
      xbits = (int )*(extra + (n - base));
    }
#line 522
    f = (tree + n)->fc.freq;
#line 523
    s->opt_len += (ulg )f * (ulg )((unsigned int )(bits + xbits));
#line 524
    if (stree) {
#line 524
      s->static_len += (ulg )f * (ulg )((unsigned int )((int const   )(stree + n)->dl.len + (int const   )xbits));
    }
    __Cont: /* CIL Label */ 
#line 510
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 526
  if (overflow == 0) {
#line 526
    return;
  }
  {
#line 532
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 533
    bits = max_length - 1;
    {
#line 534
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 534
      if (! ((int )s->bl_count[bits] == 0)) {
#line 534
        goto while_break___2;
      }
#line 534
      bits --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 535
    s->bl_count[bits] = (ush )((int )s->bl_count[bits] - 1);
#line 536
    s->bl_count[bits + 1] = (ush )((int )s->bl_count[bits + 1] + 2);
#line 537
    s->bl_count[max_length] = (ush )((int )s->bl_count[max_length] - 1);
#line 541
    overflow -= 2;
#line 532
    if (! (overflow > 0)) {
#line 532
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 549
  bits = max_length;
  {
#line 549
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 549
    if (! (bits != 0)) {
#line 549
      goto while_break___3;
    }
#line 550
    n = (int )s->bl_count[bits];
    {
#line 551
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 551
      if (! (n != 0)) {
#line 551
        goto while_break___4;
      }
#line 552
      h --;
#line 552
      m = s->heap[h];
#line 553
      if (m > max_code___0) {
#line 553
        goto while_continue___4;
      }
#line 554
      if ((unsigned int )(tree + m)->dl.len != (unsigned int )bits) {
#line 556
        s->opt_len += ((ulg )bits - (ulg )(tree + m)->dl.len) * (ulg )(tree + m)->fc.freq;
#line 557
        (tree + m)->dl.len = (ush )bits;
      }
#line 559
      n --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 549
    bits --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 562
  return;
}
}
#line 572 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void gen_codes(ct_data *tree , int max_code___0 , ushf *bl_count ) 
{ 
  ush next_code[16] ;
  unsigned int code ;
  int bits ;
  int n ;
  int len ;
  ush tmp ;
  unsigned int tmp___0 ;

  {
#line 578
  code = 0U;
#line 585
  bits = 1;
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (! (bits <= 15)) {
#line 585
      goto while_break;
    }
#line 586
    code = (code + (unsigned int )*(bl_count + (bits - 1))) << 1;
#line 587
    next_code[bits] = (ush )code;
#line 585
    bits ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  n = 0;
  {
#line 596
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 596
    if (! (n <= max_code___0)) {
#line 596
      goto while_break___0;
    }
#line 597
    len = (int )(tree + n)->dl.len;
#line 598
    if (len == 0) {
#line 598
      goto __Cont;
    }
    {
#line 600
    tmp = next_code[len];
#line 600
    next_code[len] = (ush )((int )next_code[len] + 1);
#line 600
    tmp___0 = bi_reverse((unsigned int )tmp, len);
#line 600
    (tree + n)->fc.code = (ush )tmp___0;
    }
    __Cont: /* CIL Label */ 
#line 596
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 605
  return;
}
}
#line 615 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void build_tree(deflate_state *s , tree_desc *desc ) 
{ 
  ct_data *tree ;
  ct_data const   *stree ;
  int elems ;
  int n ;
  int m ;
  int max_code___0 ;
  int node ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ush tmp___2 ;
  int tmp___3 ;

  {
#line 619
  tree = desc->dyn_tree;
#line 620
  stree = (ct_data const   *)(desc->stat_desc)->static_tree;
#line 621
  elems = (int )(desc->stat_desc)->elems;
#line 623
  max_code___0 = -1;
#line 630
  s->heap_len = 0;
#line 630
  s->heap_max = 573;
#line 632
  n = 0;
  {
#line 632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 632
    if (! (n < elems)) {
#line 632
      goto while_break;
    }
#line 633
    if ((int )(tree + n)->fc.freq != 0) {
#line 634
      (s->heap_len) ++;
#line 634
      max_code___0 = n;
#line 634
      s->heap[s->heap_len] = max_code___0;
#line 635
      s->depth[n] = (uch )0;
    } else {
#line 637
      (tree + n)->dl.len = (ush )0;
    }
#line 632
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 646
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 646
    if (! (s->heap_len < 2)) {
#line 646
      goto while_break___0;
    }
#line 647
    (s->heap_len) ++;
#line 647
    if (max_code___0 < 2) {
#line 647
      max_code___0 ++;
#line 647
      tmp = max_code___0;
    } else {
#line 647
      tmp = 0;
    }
#line 647
    s->heap[s->heap_len] = tmp;
#line 647
    node = tmp;
#line 648
    (tree + node)->fc.freq = (ush )1;
#line 649
    s->depth[node] = (uch )0;
#line 650
    (s->opt_len) --;
#line 650
    if (stree) {
#line 650
      s->static_len -= (ulg )(stree + node)->dl.len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 653
  desc->max_code = max_code___0;
#line 658
  n = s->heap_len / 2;
  {
#line 658
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 658
    if (! (n >= 1)) {
#line 658
      goto while_break___1;
    }
    {
#line 658
    pqdownheap(s, tree, n);
#line 658
    n --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 663
  node = elems;
  {
#line 664
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 665
    n = s->heap[1];
#line 665
    tmp___0 = s->heap_len;
#line 665
    (s->heap_len) --;
#line 665
    s->heap[1] = s->heap[tmp___0];
#line 665
    pqdownheap(s, tree, 1);
#line 666
    m = s->heap[1];
#line 668
    (s->heap_max) --;
#line 668
    s->heap[s->heap_max] = n;
#line 669
    (s->heap_max) --;
#line 669
    s->heap[s->heap_max] = m;
#line 672
    (tree + node)->fc.freq = (ush )((int )(tree + n)->fc.freq + (int )(tree + m)->fc.freq);
    }
#line 673
    if ((int )s->depth[n] >= (int )s->depth[m]) {
#line 673
      tmp___1 = (int )s->depth[n];
    } else {
#line 673
      tmp___1 = (int )s->depth[m];
    }
    {
#line 673
    s->depth[node] = (uch )(tmp___1 + 1);
#line 675
    tmp___2 = (ush )node;
#line 675
    (tree + m)->dl.dad = tmp___2;
#line 675
    (tree + n)->dl.dad = tmp___2;
#line 683
    tmp___3 = node;
#line 683
    node ++;
#line 683
    s->heap[1] = tmp___3;
#line 684
    pqdownheap(s, tree, 1);
    }
#line 664
    if (! (s->heap_len >= 2)) {
#line 664
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 688
  (s->heap_max) --;
#line 688
  s->heap[s->heap_max] = s->heap[1];
#line 693
  gen_bitlen(s, desc);
#line 696
  gen_codes(tree, max_code___0, s->bl_count);
  }
#line 697
  return;
}
}
#line 703 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void scan_tree(deflate_state *s , ct_data *tree , int max_code___0 ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 709
  prevlen = -1;
#line 711
  nextlen = (int )(tree + 0)->dl.len;
#line 712
  count = 0;
#line 713
  max_count = 7;
#line 714
  min_count = 4;
#line 716
  if (nextlen == 0) {
#line 716
    max_count = 138;
#line 716
    min_count = 3;
  }
#line 717
  (tree + (max_code___0 + 1))->dl.len = (ush )65535;
#line 719
  n = 0;
  {
#line 719
  while (1) {
    while_continue: /* CIL Label */ ;
#line 719
    if (! (n <= max_code___0)) {
#line 719
      goto while_break;
    }
#line 720
    curlen = nextlen;
#line 720
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 721
    count ++;
#line 721
    if (count < max_count) {
#line 721
      if (curlen == nextlen) {
#line 722
        goto __Cont;
      } else {
#line 721
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 723
    if (count < min_count) {
#line 724
      s->bl_tree[curlen].fc.freq = (ush )((int )s->bl_tree[curlen].fc.freq + count);
    } else
#line 725
    if (curlen != 0) {
#line 726
      if (curlen != prevlen) {
#line 726
        s->bl_tree[curlen].fc.freq = (ush )((int )s->bl_tree[curlen].fc.freq + 1);
      }
#line 727
      s->bl_tree[16].fc.freq = (ush )((int )s->bl_tree[16].fc.freq + 1);
    } else
#line 728
    if (count <= 10) {
#line 729
      s->bl_tree[17].fc.freq = (ush )((int )s->bl_tree[17].fc.freq + 1);
    } else {
#line 731
      s->bl_tree[18].fc.freq = (ush )((int )s->bl_tree[18].fc.freq + 1);
    }
#line 733
    count = 0;
#line 733
    prevlen = curlen;
#line 734
    if (nextlen == 0) {
#line 735
      max_count = 138;
#line 735
      min_count = 3;
    } else
#line 736
    if (curlen == nextlen) {
#line 737
      max_count = 6;
#line 737
      min_count = 3;
    } else {
#line 739
      max_count = 7;
#line 739
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 719
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  return;
}
}
#line 748 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void send_tree(deflate_state *s , ct_data *tree , int max_code___0 ) 
{ 
  int n ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;
  int len ;
  int val ;
  ulg tmp ;
  ulg tmp___0 ;
  int len___0 ;
  int val___0 ;
  ulg tmp___1 ;
  ulg tmp___2 ;
  int len___1 ;
  int val___1 ;
  ulg tmp___3 ;
  ulg tmp___4 ;
  int len___2 ;
  int val___2 ;
  ulg tmp___5 ;
  ulg tmp___6 ;
  int len___3 ;
  int val___3 ;
  ulg tmp___7 ;
  ulg tmp___8 ;
  int len___4 ;
  int val___4 ;
  ulg tmp___9 ;
  ulg tmp___10 ;
  int len___5 ;
  int val___5 ;
  ulg tmp___11 ;
  ulg tmp___12 ;
  int len___6 ;
  int val___6 ;
  ulg tmp___13 ;
  ulg tmp___14 ;

  {
#line 754
  prevlen = -1;
#line 756
  nextlen = (int )(tree + 0)->dl.len;
#line 757
  count = 0;
#line 758
  max_count = 7;
#line 759
  min_count = 4;
#line 762
  if (nextlen == 0) {
#line 762
    max_count = 138;
#line 762
    min_count = 3;
  }
#line 764
  n = 0;
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if (! (n <= max_code___0)) {
#line 764
      goto while_break;
    }
#line 765
    curlen = nextlen;
#line 765
    nextlen = (int )(tree + (n + 1))->dl.len;
#line 766
    count ++;
#line 766
    if (count < max_count) {
#line 766
      if (curlen == nextlen) {
#line 767
        goto __Cont;
      } else {
#line 766
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 768
    if (count < min_count) {
      {
#line 769
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 769
        len = (int )s->bl_tree[curlen].dl.len;
#line 769
        if (s->bi_valid > 16 - len) {
#line 769
          val = (int )s->bl_tree[curlen].fc.code;
#line 769
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 769
          tmp = s->pending;
#line 769
          (s->pending) ++;
#line 769
          *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 769
          tmp___0 = s->pending;
#line 769
          (s->pending) ++;
#line 769
          *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 769
          s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 769
          s->bi_valid += len - 16;
        } else {
#line 769
          s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[curlen].fc.code << s->bi_valid));
#line 769
          s->bi_valid += len;
        }
#line 769
        count --;
#line 769
        if (! (count != 0)) {
#line 769
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 771
    if (curlen != 0) {
#line 772
      if (curlen != prevlen) {
#line 773
        len___0 = (int )s->bl_tree[curlen].dl.len;
#line 773
        if (s->bi_valid > 16 - len___0) {
#line 773
          val___0 = (int )s->bl_tree[curlen].fc.code;
#line 773
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 773
          tmp___1 = s->pending;
#line 773
          (s->pending) ++;
#line 773
          *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 773
          tmp___2 = s->pending;
#line 773
          (s->pending) ++;
#line 773
          *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 773
          s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 773
          s->bi_valid += len___0 - 16;
        } else {
#line 773
          s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[curlen].fc.code << s->bi_valid));
#line 773
          s->bi_valid += len___0;
        }
#line 773
        count --;
      }
#line 776
      len___1 = (int )s->bl_tree[16].dl.len;
#line 776
      if (s->bi_valid > 16 - len___1) {
#line 776
        val___1 = (int )s->bl_tree[16].fc.code;
#line 776
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___1) << s->bi_valid));
#line 776
        tmp___3 = s->pending;
#line 776
        (s->pending) ++;
#line 776
        *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf & 255);
#line 776
        tmp___4 = s->pending;
#line 776
        (s->pending) ++;
#line 776
        *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf >> 8);
#line 776
        s->bi_buf = (ush )((int )((ush )val___1) >> (16 - s->bi_valid));
#line 776
        s->bi_valid += len___1 - 16;
      } else {
#line 776
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[16].fc.code << s->bi_valid));
#line 776
        s->bi_valid += len___1;
      }
#line 776
      len___2 = 2;
#line 776
      if (s->bi_valid > 16 - len___2) {
#line 776
        val___2 = count - 3;
#line 776
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___2) << s->bi_valid));
#line 776
        tmp___5 = s->pending;
#line 776
        (s->pending) ++;
#line 776
        *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf & 255);
#line 776
        tmp___6 = s->pending;
#line 776
        (s->pending) ++;
#line 776
        *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf >> 8);
#line 776
        s->bi_buf = (ush )((int )((ush )val___2) >> (16 - s->bi_valid));
#line 776
        s->bi_valid += len___2 - 16;
      } else {
#line 776
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(count - 3)) << s->bi_valid));
#line 776
        s->bi_valid += len___2;
      }
    } else
#line 778
    if (count <= 10) {
#line 779
      len___3 = (int )s->bl_tree[17].dl.len;
#line 779
      if (s->bi_valid > 16 - len___3) {
#line 779
        val___3 = (int )s->bl_tree[17].fc.code;
#line 779
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___3) << s->bi_valid));
#line 779
        tmp___7 = s->pending;
#line 779
        (s->pending) ++;
#line 779
        *(s->pending_buf + tmp___7) = (uch )((int )s->bi_buf & 255);
#line 779
        tmp___8 = s->pending;
#line 779
        (s->pending) ++;
#line 779
        *(s->pending_buf + tmp___8) = (uch )((int )s->bi_buf >> 8);
#line 779
        s->bi_buf = (ush )((int )((ush )val___3) >> (16 - s->bi_valid));
#line 779
        s->bi_valid += len___3 - 16;
      } else {
#line 779
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[17].fc.code << s->bi_valid));
#line 779
        s->bi_valid += len___3;
      }
#line 779
      len___4 = 3;
#line 779
      if (s->bi_valid > 16 - len___4) {
#line 779
        val___4 = count - 3;
#line 779
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___4) << s->bi_valid));
#line 779
        tmp___9 = s->pending;
#line 779
        (s->pending) ++;
#line 779
        *(s->pending_buf + tmp___9) = (uch )((int )s->bi_buf & 255);
#line 779
        tmp___10 = s->pending;
#line 779
        (s->pending) ++;
#line 779
        *(s->pending_buf + tmp___10) = (uch )((int )s->bi_buf >> 8);
#line 779
        s->bi_buf = (ush )((int )((ush )val___4) >> (16 - s->bi_valid));
#line 779
        s->bi_valid += len___4 - 16;
      } else {
#line 779
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(count - 3)) << s->bi_valid));
#line 779
        s->bi_valid += len___4;
      }
    } else {
#line 782
      len___5 = (int )s->bl_tree[18].dl.len;
#line 782
      if (s->bi_valid > 16 - len___5) {
#line 782
        val___5 = (int )s->bl_tree[18].fc.code;
#line 782
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___5) << s->bi_valid));
#line 782
        tmp___11 = s->pending;
#line 782
        (s->pending) ++;
#line 782
        *(s->pending_buf + tmp___11) = (uch )((int )s->bi_buf & 255);
#line 782
        tmp___12 = s->pending;
#line 782
        (s->pending) ++;
#line 782
        *(s->pending_buf + tmp___12) = (uch )((int )s->bi_buf >> 8);
#line 782
        s->bi_buf = (ush )((int )((ush )val___5) >> (16 - s->bi_valid));
#line 782
        s->bi_valid += len___5 - 16;
      } else {
#line 782
        s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[18].fc.code << s->bi_valid));
#line 782
        s->bi_valid += len___5;
      }
#line 782
      len___6 = 7;
#line 782
      if (s->bi_valid > 16 - len___6) {
#line 782
        val___6 = count - 11;
#line 782
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___6) << s->bi_valid));
#line 782
        tmp___13 = s->pending;
#line 782
        (s->pending) ++;
#line 782
        *(s->pending_buf + tmp___13) = (uch )((int )s->bi_buf & 255);
#line 782
        tmp___14 = s->pending;
#line 782
        (s->pending) ++;
#line 782
        *(s->pending_buf + tmp___14) = (uch )((int )s->bi_buf >> 8);
#line 782
        s->bi_buf = (ush )((int )((ush )val___6) >> (16 - s->bi_valid));
#line 782
        s->bi_valid += len___6 - 16;
      } else {
#line 782
        s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(count - 11)) << s->bi_valid));
#line 782
        s->bi_valid += len___6;
      }
    }
#line 784
    count = 0;
#line 784
    prevlen = curlen;
#line 785
    if (nextlen == 0) {
#line 786
      max_count = 138;
#line 786
      min_count = 3;
    } else
#line 787
    if (curlen == nextlen) {
#line 788
      max_count = 6;
#line 788
      min_count = 3;
    } else {
#line 790
      max_count = 7;
#line 790
      min_count = 4;
    }
    __Cont: /* CIL Label */ 
#line 764
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 793
  return;
}
}
#line 799 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static int build_bl_tree(deflate_state *s ) 
{ 
  int max_blindex ;

  {
  {
#line 805
  scan_tree(s, s->dyn_ltree, s->l_desc.max_code);
#line 806
  scan_tree(s, s->dyn_dtree, s->d_desc.max_code);
#line 809
  build_tree(s, & s->bl_desc);
#line 818
  max_blindex = 18;
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    if (! (max_blindex >= 3)) {
#line 818
      goto while_break;
    }
#line 819
    if ((int )s->bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 819
      goto while_break;
    }
#line 818
    max_blindex --;
  }
  while_break: /* CIL Label */ ;
  }
#line 822
  s->opt_len += ((3UL * ((ulg )max_blindex + 1UL) + 5UL) + 5UL) + 4UL;
#line 826
  return (max_blindex);
}
}
#line 834 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void send_all_trees(deflate_state *s , int lcodes , int dcodes , int blcodes ) 
{ 
  int rank ;
  int len ;
  int val ;
  ulg tmp ;
  ulg tmp___0 ;
  int len___0 ;
  int val___0 ;
  ulg tmp___1 ;
  ulg tmp___2 ;
  int len___1 ;
  int val___1 ;
  ulg tmp___3 ;
  ulg tmp___4 ;
  int len___2 ;
  int val___2 ;
  ulg tmp___5 ;
  ulg tmp___6 ;

  {
#line 844
  len = 5;
#line 844
  if (s->bi_valid > 16 - len) {
#line 844
    val = lcodes - 257;
#line 844
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 844
    tmp = s->pending;
#line 844
    (s->pending) ++;
#line 844
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 844
    tmp___0 = s->pending;
#line 844
    (s->pending) ++;
#line 844
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 844
    s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 844
    s->bi_valid += len - 16;
  } else {
#line 844
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(lcodes - 257)) << s->bi_valid));
#line 844
    s->bi_valid += len;
  }
#line 845
  len___0 = 5;
#line 845
  if (s->bi_valid > 16 - len___0) {
#line 845
    val___0 = dcodes - 1;
#line 845
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 845
    tmp___1 = s->pending;
#line 845
    (s->pending) ++;
#line 845
    *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 845
    tmp___2 = s->pending;
#line 845
    (s->pending) ++;
#line 845
    *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 845
    s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 845
    s->bi_valid += len___0 - 16;
  } else {
#line 845
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(dcodes - 1)) << s->bi_valid));
#line 845
    s->bi_valid += len___0;
  }
#line 846
  len___1 = 4;
#line 846
  if (s->bi_valid > 16 - len___1) {
#line 846
    val___1 = blcodes - 4;
#line 846
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___1) << s->bi_valid));
#line 846
    tmp___3 = s->pending;
#line 846
    (s->pending) ++;
#line 846
    *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf & 255);
#line 846
    tmp___4 = s->pending;
#line 846
    (s->pending) ++;
#line 846
    *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf >> 8);
#line 846
    s->bi_buf = (ush )((int )((ush )val___1) >> (16 - s->bi_valid));
#line 846
    s->bi_valid += len___1 - 16;
  } else {
#line 846
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(blcodes - 4)) << s->bi_valid));
#line 846
    s->bi_valid += len___1;
  }
#line 847
  rank = 0;
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    if (! (rank < blcodes)) {
#line 847
      goto while_break;
    }
#line 849
    len___2 = 3;
#line 849
    if (s->bi_valid > 16 - len___2) {
#line 849
      val___2 = (int )s->bl_tree[bl_order[rank]].dl.len;
#line 849
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___2) << s->bi_valid));
#line 849
      tmp___5 = s->pending;
#line 849
      (s->pending) ++;
#line 849
      *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf & 255);
#line 849
      tmp___6 = s->pending;
#line 849
      (s->pending) ++;
#line 849
      *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf >> 8);
#line 849
      s->bi_buf = (ush )((int )((ush )val___2) >> (16 - s->bi_valid));
#line 849
      s->bi_valid += len___2 - 16;
    } else {
#line 849
      s->bi_buf = (ush )((int )s->bi_buf | ((int )s->bl_tree[bl_order[rank]].dl.len << s->bi_valid));
#line 849
      s->bi_valid += len___2;
    }
#line 847
    rank ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 853
  send_tree(s, s->dyn_ltree, lcodes - 1);
#line 856
  send_tree(s, s->dyn_dtree, dcodes - 1);
  }
#line 858
  return;
}
}
#line 863 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_stored_block(deflate_state *s ,
                                                                 charf *buf , ulg stored_len ,
                                                                 int last ) 
{ 
  int len ;
  int val ;
  ulg tmp ;
  ulg tmp___0 ;
  ulg tmp___1 ;
  ulg tmp___2 ;
  ulg tmp___3 ;
  ulg tmp___4 ;

  {
#line 869
  len = 3;
#line 869
  if (s->bi_valid > 16 - len) {
#line 869
    val = last;
#line 869
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 869
    tmp = s->pending;
#line 869
    (s->pending) ++;
#line 869
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 869
    tmp___0 = s->pending;
#line 869
    (s->pending) ++;
#line 869
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 869
    s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 869
    s->bi_valid += len - 16;
  } else {
#line 869
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )last) << s->bi_valid));
#line 869
    s->bi_valid += len;
  }
  {
#line 870
  bi_windup(s);
#line 871
  tmp___1 = s->pending;
#line 871
  (s->pending) ++;
#line 871
  *(s->pending_buf + tmp___1) = (uch )((int )((ush )stored_len) & 255);
#line 871
  tmp___2 = s->pending;
#line 871
  (s->pending) ++;
#line 871
  *(s->pending_buf + tmp___2) = (uch )((int )((ush )stored_len) >> 8);
#line 872
  tmp___3 = s->pending;
#line 872
  (s->pending) ++;
#line 872
  *(s->pending_buf + tmp___3) = (uch )((int )((ush )(~ stored_len)) & 255);
#line 872
  tmp___4 = s->pending;
#line 872
  (s->pending) ++;
#line 872
  *(s->pending_buf + tmp___4) = (uch )((int )((ush )(~ stored_len)) >> 8);
#line 873
  memcpy((void */* __restrict  */)(s->pending_buf + s->pending), (void const   */* __restrict  */)((Bytef *)buf),
         stored_len);
#line 874
  s->pending += stored_len;
  }
#line 881
  return;
}
}
#line 886 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_flush_bits(deflate_state *s ) 
{ 


  {
  {
#line 889
  bi_flush(s);
  }
#line 890
  return;
}
}
#line 896 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_align(deflate_state *s ) 
{ 
  int len ;
  int val ;
  ulg tmp ;
  ulg tmp___0 ;
  int len___0 ;
  int val___0 ;
  ulg tmp___1 ;
  ulg tmp___2 ;

  {
#line 899
  len = 3;
#line 899
  if (s->bi_valid > 16 - len) {
#line 899
    val = 1 << 1;
#line 899
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 899
    tmp = s->pending;
#line 899
    (s->pending) ++;
#line 899
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 899
    tmp___0 = s->pending;
#line 899
    (s->pending) ++;
#line 899
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 899
    s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 899
    s->bi_valid += len - 16;
  } else {
#line 899
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(1 << 1)) << s->bi_valid));
#line 899
    s->bi_valid += len;
  }
#line 900
  len___0 = (int )static_ltree[256].dl.len;
#line 900
  if (s->bi_valid > 16 - len___0) {
#line 900
    val___0 = (int )static_ltree[256].fc.code;
#line 900
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 900
    tmp___1 = s->pending;
#line 900
    (s->pending) ++;
#line 900
    *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 900
    tmp___2 = s->pending;
#line 900
    (s->pending) ++;
#line 900
    *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 900
    s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 900
    s->bi_valid += len___0 - 16;
  } else {
#line 900
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )static_ltree[256].fc.code) << s->bi_valid));
#line 900
    s->bi_valid += len___0;
  }
  {
#line 904
  bi_flush(s);
  }
#line 905
  return;
}
}
#line 911 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
void __attribute__((__visibility__("hidden")))  _tr_flush_block(deflate_state *s ,
                                                                charf *buf , ulg stored_len ,
                                                                int last ) 
{ 
  ulg opt_lenb ;
  ulg static_lenb ;
  int max_blindex ;
  int len ;
  int val ;
  ulg tmp ;
  ulg tmp___0 ;
  int len___0 ;
  int val___0 ;
  ulg tmp___1 ;
  ulg tmp___2 ;

  {
#line 918
  max_blindex = 0;
#line 921
  if (s->level > 0) {
#line 924
    if ((s->strm)->data_type == 2) {
      {
#line 925
      (s->strm)->data_type = detect_data_type(s);
      }
    }
    {
#line 928
    build_tree(s, & s->l_desc);
#line 932
    build_tree(s, & s->d_desc);
#line 942
    max_blindex = build_bl_tree(s);
#line 945
    opt_lenb = ((s->opt_len + 3UL) + 7UL) >> 3;
#line 946
    static_lenb = ((s->static_len + 3UL) + 7UL) >> 3;
    }
#line 952
    if (static_lenb <= opt_lenb) {
#line 952
      opt_lenb = static_lenb;
    }
  } else {
#line 956
    static_lenb = stored_len + 5UL;
#line 956
    opt_lenb = static_lenb;
  }
#line 962
  if (stored_len + 4UL <= opt_lenb) {
#line 962
    if ((unsigned long )buf != (unsigned long )((char *)0)) {
      {
#line 971
      _tr_stored_block(s, buf, stored_len, last);
      }
    } else {
#line 962
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 976
  if (s->strategy == 4) {
#line 976
    goto _L;
  } else
#line 976
  if (static_lenb == opt_lenb) {
    _L: /* CIL Label */ 
#line 978
    len = 3;
#line 978
    if (s->bi_valid > 16 - len) {
#line 978
      val = (1 << 1) + last;
#line 978
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 978
      tmp = s->pending;
#line 978
      (s->pending) ++;
#line 978
      *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 978
      tmp___0 = s->pending;
#line 978
      (s->pending) ++;
#line 978
      *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 978
      s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 978
      s->bi_valid += len - 16;
    } else {
#line 978
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )((1 << 1) + last)) << s->bi_valid));
#line 978
      s->bi_valid += len;
    }
    {
#line 979
    compress_block(s, static_ltree, static_dtree);
    }
  } else {
#line 985
    len___0 = 3;
#line 985
    if (s->bi_valid > 16 - len___0) {
#line 985
      val___0 = (2 << 1) + last;
#line 985
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 985
      tmp___1 = s->pending;
#line 985
      (s->pending) ++;
#line 985
      *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf & 255);
#line 985
      tmp___2 = s->pending;
#line 985
      (s->pending) ++;
#line 985
      *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf >> 8);
#line 985
      s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 985
      s->bi_valid += len___0 - 16;
    } else {
#line 985
      s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )((2 << 1) + last)) << s->bi_valid));
#line 985
      s->bi_valid += len___0;
    }
    {
#line 986
    send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1, max_blindex + 1);
#line 988
    compress_block(s, (ct_data const   *)(s->dyn_ltree), (ct_data const   *)(s->dyn_dtree));
    }
  }
  {
#line 998
  init_block(s);
  }
#line 1000
  if (last) {
    {
#line 1001
    bi_windup(s);
    }
  }
#line 1008
  return;
}
}
#line 1014 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
int __attribute__((__visibility__("hidden")))  _tr_tally(deflate_state *s , unsigned int dist ,
                                                         unsigned int lc ) 
{ 
  uInt tmp ;
  int __attribute__((__visibility__("hidden")))  tmp___0 ;

  {
#line 1019
  *(s->d_buf + s->last_lit) = (ush )dist;
#line 1020
  tmp = s->last_lit;
#line 1020
  (s->last_lit) ++;
#line 1020
  *(s->l_buf + tmp) = (uch )lc;
#line 1021
  if (dist == 0U) {
#line 1023
    s->dyn_ltree[lc].fc.freq = (ush )((int )s->dyn_ltree[lc].fc.freq + 1);
  } else {
#line 1025
    (s->matches) ++;
#line 1027
    dist --;
#line 1032
    s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[lc] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[lc] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 1033
    if (dist < 256U) {
#line 1033
      tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
    } else {
#line 1033
      tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256U + (dist >> 7)];
    }
#line 1033
    s->dyn_dtree[tmp___0].fc.freq = (ush )((int )s->dyn_dtree[tmp___0].fc.freq + 1);
  }
#line 1054
  return ((int __attribute__((__visibility__("hidden")))  )(s->last_lit == s->lit_bufsize - 1U));
}
}
#line 1064 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void compress_block(deflate_state *s , ct_data const   *ltree , ct_data const   *dtree ) 
{ 
  unsigned int dist ;
  int lc ;
  unsigned int lx ;
  unsigned int code ;
  int extra ;
  unsigned int tmp ;
  int len ;
  int val ;
  ulg tmp___0 ;
  ulg tmp___1 ;
  int len___0 ;
  int val___0 ;
  ulg tmp___2 ;
  ulg tmp___3 ;
  int len___1 ;
  int val___1 ;
  ulg tmp___4 ;
  ulg tmp___5 ;
  int len___2 ;
  int val___2 ;
  ulg tmp___6 ;
  ulg tmp___7 ;
  int len___3 ;
  int val___3 ;
  ulg tmp___8 ;
  ulg tmp___9 ;
  int len___4 ;
  int val___4 ;
  ulg tmp___10 ;
  ulg tmp___11 ;

  {
#line 1071
  lx = 0U;
#line 1075
  if (s->last_lit != 0U) {
    {
#line 1075
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1076
      dist = (unsigned int )*(s->d_buf + lx);
#line 1077
      tmp = lx;
#line 1077
      lx ++;
#line 1077
      lc = (int )*(s->l_buf + tmp);
#line 1078
      if (dist == 0U) {
#line 1079
        len = (int )(ltree + lc)->dl.len;
#line 1079
        if (s->bi_valid > 16 - len) {
#line 1079
          val = (int )(ltree + lc)->fc.code;
#line 1079
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val) << s->bi_valid));
#line 1079
          tmp___0 = s->pending;
#line 1079
          (s->pending) ++;
#line 1079
          *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf & 255);
#line 1079
          tmp___1 = s->pending;
#line 1079
          (s->pending) ++;
#line 1079
          *(s->pending_buf + tmp___1) = (uch )((int )s->bi_buf >> 8);
#line 1079
          s->bi_buf = (ush )((int )((ush )val) >> (16 - s->bi_valid));
#line 1079
          s->bi_valid += len - 16;
        } else {
#line 1079
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(ltree + lc)->fc.code) << s->bi_valid));
#line 1079
          s->bi_valid += len;
        }
      } else {
#line 1083
        code = (unsigned int )_length_code[lc];
#line 1084
        len___0 = (int )(ltree + ((code + 256U) + 1U))->dl.len;
#line 1084
        if (s->bi_valid > 16 - len___0) {
#line 1084
          val___0 = (int )(ltree + ((code + 256U) + 1U))->fc.code;
#line 1084
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___0) << s->bi_valid));
#line 1084
          tmp___2 = s->pending;
#line 1084
          (s->pending) ++;
#line 1084
          *(s->pending_buf + tmp___2) = (uch )((int )s->bi_buf & 255);
#line 1084
          tmp___3 = s->pending;
#line 1084
          (s->pending) ++;
#line 1084
          *(s->pending_buf + tmp___3) = (uch )((int )s->bi_buf >> 8);
#line 1084
          s->bi_buf = (ush )((int )((ush )val___0) >> (16 - s->bi_valid));
#line 1084
          s->bi_valid += len___0 - 16;
        } else {
#line 1084
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(ltree + ((code + 256U) + 1U))->fc.code) << s->bi_valid));
#line 1084
          s->bi_valid += len___0;
        }
#line 1085
        extra = (int )extra_lbits[code];
#line 1086
        if (extra != 0) {
#line 1087
          lc -= (int )base_length[code];
#line 1088
          len___1 = extra;
#line 1088
          if (s->bi_valid > 16 - len___1) {
#line 1088
            val___1 = lc;
#line 1088
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___1) << s->bi_valid));
#line 1088
            tmp___4 = s->pending;
#line 1088
            (s->pending) ++;
#line 1088
            *(s->pending_buf + tmp___4) = (uch )((int )s->bi_buf & 255);
#line 1088
            tmp___5 = s->pending;
#line 1088
            (s->pending) ++;
#line 1088
            *(s->pending_buf + tmp___5) = (uch )((int )s->bi_buf >> 8);
#line 1088
            s->bi_buf = (ush )((int )((ush )val___1) >> (16 - s->bi_valid));
#line 1088
            s->bi_valid += len___1 - 16;
          } else {
#line 1088
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )lc) << s->bi_valid));
#line 1088
            s->bi_valid += len___1;
          }
        }
#line 1090
        dist --;
#line 1091
        if (dist < 256U) {
#line 1091
          code = (unsigned int )_dist_code[dist];
        } else {
#line 1091
          code = (unsigned int )_dist_code[256U + (dist >> 7)];
        }
#line 1094
        len___2 = (int )(dtree + code)->dl.len;
#line 1094
        if (s->bi_valid > 16 - len___2) {
#line 1094
          val___2 = (int )(dtree + code)->fc.code;
#line 1094
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___2) << s->bi_valid));
#line 1094
          tmp___6 = s->pending;
#line 1094
          (s->pending) ++;
#line 1094
          *(s->pending_buf + tmp___6) = (uch )((int )s->bi_buf & 255);
#line 1094
          tmp___7 = s->pending;
#line 1094
          (s->pending) ++;
#line 1094
          *(s->pending_buf + tmp___7) = (uch )((int )s->bi_buf >> 8);
#line 1094
          s->bi_buf = (ush )((int )((ush )val___2) >> (16 - s->bi_valid));
#line 1094
          s->bi_valid += len___2 - 16;
        } else {
#line 1094
          s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(dtree + code)->fc.code) << s->bi_valid));
#line 1094
          s->bi_valid += len___2;
        }
#line 1095
        extra = (int )extra_dbits[code];
#line 1096
        if (extra != 0) {
#line 1097
          dist -= (unsigned int )base_dist[code];
#line 1098
          len___3 = extra;
#line 1098
          if (s->bi_valid > 16 - len___3) {
#line 1098
            val___3 = (int )dist;
#line 1098
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___3) << s->bi_valid));
#line 1098
            tmp___8 = s->pending;
#line 1098
            (s->pending) ++;
#line 1098
            *(s->pending_buf + tmp___8) = (uch )((int )s->bi_buf & 255);
#line 1098
            tmp___9 = s->pending;
#line 1098
            (s->pending) ++;
#line 1098
            *(s->pending_buf + tmp___9) = (uch )((int )s->bi_buf >> 8);
#line 1098
            s->bi_buf = (ush )((int )((ush )val___3) >> (16 - s->bi_valid));
#line 1098
            s->bi_valid += len___3 - 16;
          } else {
#line 1098
            s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )dist) << s->bi_valid));
#line 1098
            s->bi_valid += len___3;
          }
        }
      }
#line 1075
      if (! (lx < s->last_lit)) {
#line 1075
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1108
  len___4 = (int )(ltree + 256)->dl.len;
#line 1108
  if (s->bi_valid > 16 - len___4) {
#line 1108
    val___4 = (int )(ltree + 256)->fc.code;
#line 1108
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )val___4) << s->bi_valid));
#line 1108
    tmp___10 = s->pending;
#line 1108
    (s->pending) ++;
#line 1108
    *(s->pending_buf + tmp___10) = (uch )((int )s->bi_buf & 255);
#line 1108
    tmp___11 = s->pending;
#line 1108
    (s->pending) ++;
#line 1108
    *(s->pending_buf + tmp___11) = (uch )((int )s->bi_buf >> 8);
#line 1108
    s->bi_buf = (ush )((int )((ush )val___4) >> (16 - s->bi_valid));
#line 1108
    s->bi_valid += len___4 - 16;
  } else {
#line 1108
    s->bi_buf = (ush )((int )s->bi_buf | ((int )((ush )(ltree + 256)->fc.code) << s->bi_valid));
#line 1108
    s->bi_valid += len___4;
  }
#line 1109
  return;
}
}
#line 1124 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static int detect_data_type(deflate_state *s ) 
{ 
  unsigned long black_mask ;
  int n ;

  {
#line 1131
  black_mask = 4093624447UL;
#line 1135
  n = 0;
  {
#line 1135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1135
    if (! (n <= 31)) {
#line 1135
      goto while_break;
    }
#line 1136
    if (black_mask & 1UL) {
#line 1136
      if ((int )s->dyn_ltree[n].fc.freq != 0) {
#line 1137
        return (0);
      }
    }
#line 1135
    n ++;
#line 1135
    black_mask >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  if ((int )s->dyn_ltree[9].fc.freq != 0) {
#line 1142
    return (1);
  } else
#line 1140
  if ((int )s->dyn_ltree[10].fc.freq != 0) {
#line 1142
    return (1);
  } else
#line 1140
  if ((int )s->dyn_ltree[13].fc.freq != 0) {
#line 1142
    return (1);
  }
#line 1143
  n = 32;
  {
#line 1143
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1143
    if (! (n < 256)) {
#line 1143
      goto while_break___0;
    }
#line 1144
    if ((int )s->dyn_ltree[n].fc.freq != 0) {
#line 1145
      return (1);
    }
#line 1143
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1150
  return (0);
}
}
#line 1158 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static unsigned int bi_reverse(unsigned int code , int len ) 
{ 
  register unsigned int res ;

  {
#line 1162
  res = 0U;
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    res |= code & 1U;
#line 1165
    code >>= 1;
#line 1165
    res <<= 1;
#line 1163
    len --;
#line 1163
    if (! (len > 0)) {
#line 1163
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1167
  return (res >> 1);
}
}
#line 1173 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void bi_flush(deflate_state *s ) 
{ 
  ulg tmp ;
  ulg tmp___0 ;
  ulg tmp___1 ;

  {
#line 1176
  if (s->bi_valid == 16) {
#line 1177
    tmp = s->pending;
#line 1177
    (s->pending) ++;
#line 1177
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 1177
    tmp___0 = s->pending;
#line 1177
    (s->pending) ++;
#line 1177
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
#line 1178
    s->bi_buf = (ush )0;
#line 1179
    s->bi_valid = 0;
  } else
#line 1180
  if (s->bi_valid >= 8) {
#line 1181
    tmp___1 = s->pending;
#line 1181
    (s->pending) ++;
#line 1181
    *(s->pending_buf + tmp___1) = (Byte )s->bi_buf;
#line 1182
    s->bi_buf = (ush )((int )s->bi_buf >> 8);
#line 1183
    s->bi_valid -= 8;
  }
#line 1185
  return;
}
}
#line 1190 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/trees.c"
static void bi_windup(deflate_state *s ) 
{ 
  ulg tmp ;
  ulg tmp___0 ;
  ulg tmp___1 ;

  {
#line 1193
  if (s->bi_valid > 8) {
#line 1194
    tmp = s->pending;
#line 1194
    (s->pending) ++;
#line 1194
    *(s->pending_buf + tmp) = (uch )((int )s->bi_buf & 255);
#line 1194
    tmp___0 = s->pending;
#line 1194
    (s->pending) ++;
#line 1194
    *(s->pending_buf + tmp___0) = (uch )((int )s->bi_buf >> 8);
  } else
#line 1195
  if (s->bi_valid > 0) {
#line 1196
    tmp___1 = s->pending;
#line 1196
    (s->pending) ++;
#line 1196
    *(s->pending_buf + tmp___1) = (Byte )s->bi_buf;
  }
#line 1198
  s->bi_buf = (ush )0;
#line 1199
  s->bi_valid = 0;
#line 1203
  return;
}
}
#line 60 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.h"
int __attribute__((__visibility__("hidden")))  inflate_table(codetype type , unsigned short *lens ,
                                                             unsigned int codes ,
                                                             code **table___0 , unsigned int *bits ,
                                                             unsigned short *work ) ;
#line 11 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.c"
char const   inflate_copyright[48]  = 
#line 11 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.c"
  {      (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'f', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'1',      (char const   )'1',      (char const   )' ', 
        (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'5',      (char const   )'-',      (char const   )'2', 
        (char const   )'0',      (char const   )'1',      (char const   )'7',      (char const   )' ', 
        (char const   )'M',      (char const   )'a',      (char const   )'r',      (char const   )'k', 
        (char const   )' ',      (char const   )'A',      (char const   )'d',      (char const   )'l', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'\000'};
#line 60 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.c"
static unsigned short const   lbase[31]  = 
#line 60
  {      (unsigned short const   )3,      (unsigned short const   )4,      (unsigned short const   )5,      (unsigned short const   )6, 
        (unsigned short const   )7,      (unsigned short const   )8,      (unsigned short const   )9,      (unsigned short const   )10, 
        (unsigned short const   )11,      (unsigned short const   )13,      (unsigned short const   )15,      (unsigned short const   )17, 
        (unsigned short const   )19,      (unsigned short const   )23,      (unsigned short const   )27,      (unsigned short const   )31, 
        (unsigned short const   )35,      (unsigned short const   )43,      (unsigned short const   )51,      (unsigned short const   )59, 
        (unsigned short const   )67,      (unsigned short const   )83,      (unsigned short const   )99,      (unsigned short const   )115, 
        (unsigned short const   )131,      (unsigned short const   )163,      (unsigned short const   )195,      (unsigned short const   )227, 
        (unsigned short const   )258,      (unsigned short const   )0,      (unsigned short const   )0};
#line 63 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.c"
static unsigned short const   lext[31]  = 
#line 63
  {      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )17, 
        (unsigned short const   )18,      (unsigned short const   )18,      (unsigned short const   )18,      (unsigned short const   )18, 
        (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )19, 
        (unsigned short const   )20,      (unsigned short const   )20,      (unsigned short const   )20,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )21, 
        (unsigned short const   )16,      (unsigned short const   )77,      (unsigned short const   )202};
#line 66 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.c"
static unsigned short const   dbase[32]  = 
#line 66
  {      (unsigned short const   )1,      (unsigned short const   )2,      (unsigned short const   )3,      (unsigned short const   )4, 
        (unsigned short const   )5,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )13, 
        (unsigned short const   )17,      (unsigned short const   )25,      (unsigned short const   )33,      (unsigned short const   )49, 
        (unsigned short const   )65,      (unsigned short const   )97,      (unsigned short const   )129,      (unsigned short const   )193, 
        (unsigned short const   )257,      (unsigned short const   )385,      (unsigned short const   )513,      (unsigned short const   )769, 
        (unsigned short const   )1025,      (unsigned short const   )1537,      (unsigned short const   )2049,      (unsigned short const   )3073, 
        (unsigned short const   )4097,      (unsigned short const   )6145,      (unsigned short const   )8193,      (unsigned short const   )12289, 
        (unsigned short const   )16385,      (unsigned short const   )24577,      (unsigned short const   )0,      (unsigned short const   )0};
#line 70 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.c"
static unsigned short const   dext[32]  = 
#line 70
  {      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16,      (unsigned short const   )16, 
        (unsigned short const   )17,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )18, 
        (unsigned short const   )19,      (unsigned short const   )19,      (unsigned short const   )20,      (unsigned short const   )20, 
        (unsigned short const   )21,      (unsigned short const   )21,      (unsigned short const   )22,      (unsigned short const   )22, 
        (unsigned short const   )23,      (unsigned short const   )23,      (unsigned short const   )24,      (unsigned short const   )24, 
        (unsigned short const   )25,      (unsigned short const   )25,      (unsigned short const   )26,      (unsigned short const   )26, 
        (unsigned short const   )27,      (unsigned short const   )27,      (unsigned short const   )28,      (unsigned short const   )28, 
        (unsigned short const   )29,      (unsigned short const   )29,      (unsigned short const   )64,      (unsigned short const   )64};
#line 32 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inftrees.c"
int __attribute__((__visibility__("hidden")))  inflate_table(codetype type , unsigned short *lens ,
                                                             unsigned int codes ,
                                                             code **table___0 , unsigned int *bits ,
                                                             unsigned short *work ) 
{ 
  unsigned int len ;
  unsigned int sym ;
  unsigned int min ;
  unsigned int max ;
  unsigned int root ;
  unsigned int curr ;
  unsigned int drop ;
  int left ;
  unsigned int used ;
  unsigned int huff ;
  unsigned int incr ;
  unsigned int fill ;
  unsigned int low ;
  unsigned int mask ;
  code here ;
  code *next ;
  unsigned short const   *base ;
  unsigned short const   *extra ;
  unsigned int match ;
  unsigned short count[16] ;
  unsigned short offs[16] ;
  code *tmp ;
  code *tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 107
  len = 0U;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (len <= 15U)) {
#line 107
      goto while_break;
    }
#line 108
    count[len] = (unsigned short)0;
#line 107
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  sym = 0U;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (! (sym < codes)) {
#line 109
      goto while_break___0;
    }
#line 110
    count[*(lens + sym)] = (unsigned short )((int )count[*(lens + sym)] + 1);
#line 109
    sym ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  root = *bits;
#line 114
  max = 15U;
  {
#line 114
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 114
    if (! (max >= 1U)) {
#line 114
      goto while_break___1;
    }
#line 115
    if ((int )count[max] != 0) {
#line 115
      goto while_break___1;
    }
#line 114
    max --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 116
  if (root > max) {
#line 116
    root = max;
  }
#line 117
  if (max == 0U) {
#line 118
    here.op = (unsigned char)64;
#line 119
    here.bits = (unsigned char)1;
#line 120
    here.val = (unsigned short)0;
#line 121
    tmp = *table___0;
#line 121
    (*table___0) ++;
#line 121
    *tmp = here;
#line 122
    tmp___0 = *table___0;
#line 122
    (*table___0) ++;
#line 122
    *tmp___0 = here;
#line 123
    *bits = 1U;
#line 124
    return ((int __attribute__((__visibility__("hidden")))  )0);
  }
#line 126
  min = 1U;
  {
#line 126
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 126
    if (! (min < max)) {
#line 126
      goto while_break___2;
    }
#line 127
    if ((int )count[min] != 0) {
#line 127
      goto while_break___2;
    }
#line 126
    min ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 128
  if (root < min) {
#line 128
    root = min;
  }
#line 131
  left = 1;
#line 132
  len = 1U;
  {
#line 132
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 132
    if (! (len <= 15U)) {
#line 132
      goto while_break___3;
    }
#line 133
    left <<= 1;
#line 134
    left -= (int )count[len];
#line 135
    if (left < 0) {
#line 135
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
#line 132
    len ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 137
  if (left > 0) {
#line 137
    if ((unsigned int )type == 0U) {
#line 138
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    } else
#line 137
    if (max != 1U) {
#line 138
      return ((int __attribute__((__visibility__("hidden")))  )-1);
    }
  }
#line 141
  offs[1] = (unsigned short)0;
#line 142
  len = 1U;
  {
#line 142
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 142
    if (! (len < 15U)) {
#line 142
      goto while_break___4;
    }
#line 143
    offs[len + 1U] = (unsigned short )((int )offs[len] + (int )count[len]);
#line 142
    len ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 146
  sym = 0U;
  {
#line 146
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 146
    if (! (sym < codes)) {
#line 146
      goto while_break___5;
    }
#line 147
    if ((int )*(lens + sym) != 0) {
#line 147
      tmp___1 = offs[*(lens + sym)];
#line 147
      offs[*(lens + sym)] = (unsigned short )((int )offs[*(lens + sym)] + 1);
#line 147
      *(work + tmp___1) = (unsigned short )sym;
    }
#line 146
    sym ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 182
  if ((unsigned int )type == 0U) {
#line 182
    goto case_0;
  }
#line 186
  if ((unsigned int )type == 1U) {
#line 186
    goto case_1;
  }
#line 191
  goto switch_default;
  case_0: /* CIL Label */ 
#line 183
  extra = (unsigned short const   *)work;
#line 183
  base = extra;
#line 184
  match = 20U;
#line 185
  goto switch_break;
  case_1: /* CIL Label */ 
#line 187
  base = lbase;
#line 188
  extra = lext;
#line 189
  match = 257U;
#line 190
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 192
  base = dbase;
#line 193
  extra = dext;
#line 194
  match = 0U;
  switch_break: /* CIL Label */ ;
  }
#line 198
  huff = 0U;
#line 199
  sym = 0U;
#line 200
  len = min;
#line 201
  next = *table___0;
#line 202
  curr = root;
#line 203
  drop = 0U;
#line 204
  low = 4294967295U;
#line 205
  used = 1U << root;
#line 206
  mask = used - 1U;
#line 209
  if ((unsigned int )type == 1U) {
#line 209
    if (used > 852U) {
#line 211
      return ((int __attribute__((__visibility__("hidden")))  )1);
    } else {
#line 209
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 209
  if ((unsigned int )type == 2U) {
#line 209
    if (used > 592U) {
#line 211
      return ((int __attribute__((__visibility__("hidden")))  )1);
    }
  }
  {
#line 214
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 216
    here.bits = (unsigned char )(len - drop);
#line 217
    if ((unsigned int )*(work + sym) + 1U < match) {
#line 218
      here.op = (unsigned char)0;
#line 219
      here.val = *(work + sym);
    } else
#line 221
    if ((unsigned int )*(work + sym) >= match) {
#line 222
      here.op = (unsigned char )*(extra + ((unsigned int )*(work + sym) - match));
#line 223
      here.val = (unsigned short )*(base + ((unsigned int )*(work + sym) - match));
    } else {
#line 226
      here.op = (unsigned char)96;
#line 227
      here.val = (unsigned short)0;
    }
#line 231
    incr = 1U << (len - drop);
#line 232
    fill = 1U << curr;
#line 233
    min = fill;
    {
#line 234
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 235
      fill -= incr;
#line 236
      *(next + ((huff >> drop) + fill)) = here;
#line 234
      if (! (fill != 0U)) {
#line 234
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 240
    incr = 1U << (len - 1U);
    {
#line 241
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 241
      if (! (huff & incr)) {
#line 241
        goto while_break___8;
      }
#line 242
      incr >>= 1;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 243
    if (incr != 0U) {
#line 244
      huff &= incr - 1U;
#line 245
      huff += incr;
    } else {
#line 248
      huff = 0U;
    }
#line 251
    sym ++;
#line 252
    count[len] = (unsigned short )((int )count[len] - 1);
#line 252
    if ((int )count[len] == 0) {
#line 253
      if (len == max) {
#line 253
        goto while_break___6;
      }
#line 254
      len = (unsigned int )*(lens + *(work + sym));
    }
#line 258
    if (len > root) {
#line 258
      if ((huff & mask) != low) {
#line 260
        if (drop == 0U) {
#line 261
          drop = root;
        }
#line 264
        next += min;
#line 267
        curr = len - drop;
#line 268
        left = 1 << curr;
        {
#line 269
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 269
          if (! (curr + drop < max)) {
#line 269
            goto while_break___9;
          }
#line 270
          left -= (int )count[curr + drop];
#line 271
          if (left <= 0) {
#line 271
            goto while_break___9;
          }
#line 272
          curr ++;
#line 273
          left <<= 1;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 277
        used += 1U << curr;
#line 278
        if ((unsigned int )type == 1U) {
#line 278
          if (used > 852U) {
#line 280
            return ((int __attribute__((__visibility__("hidden")))  )1);
          } else {
#line 278
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 278
        if ((unsigned int )type == 2U) {
#line 278
          if (used > 592U) {
#line 280
            return ((int __attribute__((__visibility__("hidden")))  )1);
          }
        }
#line 283
        low = huff & mask;
#line 284
        (*table___0 + low)->op = (unsigned char )curr;
#line 285
        (*table___0 + low)->bits = (unsigned char )root;
#line 286
        (*table___0 + low)->val = (unsigned short )(next - *table___0);
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 293
  if (huff != 0U) {
#line 294
    here.op = (unsigned char)64;
#line 295
    here.bits = (unsigned char )(len - drop);
#line 296
    here.val = (unsigned short)0;
#line 297
    *(next + huff) = here;
  }
#line 301
  *table___0 += used;
#line 302
  *bits = root;
#line 303
  return ((int __attribute__((__visibility__("hidden")))  )0);
}
}
#line 902 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int inflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 925
int inflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 940
int inflateSync(z_streamp strm ) ;
#line 959
int inflateCopy(z_streamp dest , z_streamp source ) ;
#line 975
int inflateReset(z_streamp strm ) ;
#line 985
int inflateReset2(z_streamp strm , int windowBits ) ;
#line 999
int inflatePrime(z_streamp strm , int bits , int value ) ;
#line 1020
long inflateMark(z_streamp strm ) ;
#line 1048
int inflateGetHeader(z_streamp strm , gz_headerp head ) ;
#line 1706
uLong adler32(uLong adler , Bytef const   *buf , uInt len ) ;
#line 1790
int inflateInit2_(z_streamp strm , int windowBits , char const   *version , int stream_size ) ;
#line 1907
int inflateSyncPoint(z_streamp strm ) ;
#line 1909
int inflateUndermine(z_streamp strm , int subvert ) ;
#line 1910
int inflateValidate(z_streamp strm , int check ) ;
#line 1911
unsigned long inflateCodesUsed(z_streamp strm ) ;
#line 1912
int inflateResetKeep(z_streamp strm ) ;
#line 11 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffast.h"
void __attribute__((__visibility__("hidden")))  inflate_fast(z_streamp strm , unsigned int start ) ;
#line 95 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
static int inflateStateCheck(z_streamp strm ) ;
#line 96
static void fixedtables(struct inflate_state *state ) ;
#line 97
static int updatewindow(z_streamp strm , unsigned char const   *end , unsigned int copy ) ;
#line 102
static unsigned int syncsearch(unsigned int *have , unsigned char const   *buf , unsigned int len ) ;
#line 105 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
static int inflateStateCheck(z_streamp strm ) 
{ 
  struct inflate_state *state ;

  {
#line 109
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 111
    return (1);
  } else
#line 109
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 111
    return (1);
  } else
#line 109
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 111
    return (1);
  }
#line 112
  state = (struct inflate_state *)strm->state;
#line 113
  if ((unsigned long )state == (unsigned long )((struct inflate_state *)0)) {
#line 115
    return (1);
  } else
#line 113
  if ((unsigned long )state->strm != (unsigned long )strm) {
#line 115
    return (1);
  } else
#line 113
  if ((unsigned int )state->mode < 16180U) {
#line 115
    return (1);
  } else
#line 113
  if ((unsigned int )state->mode > 16211U) {
#line 115
    return (1);
  }
#line 116
  return (0);
}
}
#line 119 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateResetKeep(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;
  uLong tmp___0 ;
  unsigned long tmp___1 ;
  code const   *tmp___2 ;
  code *tmp___3 ;

  {
  {
#line 124
  tmp = inflateStateCheck(strm);
  }
#line 124
  if (tmp) {
#line 124
    return (-2);
  }
#line 125
  state = (struct inflate_state *)strm->state;
#line 126
  tmp___1 = 0UL;
#line 126
  state->total = tmp___1;
#line 126
  tmp___0 = tmp___1;
#line 126
  strm->total_out = tmp___0;
#line 126
  strm->total_in = tmp___0;
#line 127
  strm->msg = (char *)0;
#line 128
  if (state->wrap) {
#line 129
    strm->adler = (uLong )(state->wrap & 1);
  }
#line 130
  state->mode = (inflate_mode )16180;
#line 131
  state->last = 0;
#line 132
  state->havedict = 0;
#line 133
  state->dmax = 32768U;
#line 134
  state->head = (gz_headerp )0;
#line 135
  state->hold = 0UL;
#line 136
  state->bits = 0U;
#line 137
  tmp___3 = state->codes;
#line 137
  state->next = tmp___3;
#line 137
  tmp___2 = (code const   *)tmp___3;
#line 137
  state->distcode = tmp___2;
#line 137
  state->lencode = tmp___2;
#line 138
  state->sane = 1;
#line 139
  state->back = -1;
#line 141
  return (0);
}
}
#line 144 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateReset(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 149
  tmp = inflateStateCheck(strm);
  }
#line 149
  if (tmp) {
#line 149
    return (-2);
  }
  {
#line 150
  state = (struct inflate_state *)strm->state;
#line 151
  state->wsize = 0U;
#line 152
  state->whave = 0U;
#line 153
  state->wnext = 0U;
#line 154
  tmp___0 = inflateResetKeep(strm);
  }
#line 154
  return (tmp___0);
}
}
#line 157 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateReset2(z_streamp strm , int windowBits ) 
{ 
  int wrap ;
  struct inflate_state *state ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  tmp = inflateStateCheck(strm);
  }
#line 165
  if (tmp) {
#line 165
    return (-2);
  }
#line 166
  state = (struct inflate_state *)strm->state;
#line 169
  if (windowBits < 0) {
#line 170
    wrap = 0;
#line 171
    windowBits = - windowBits;
  } else {
#line 174
    wrap = (windowBits >> 4) + 5;
  }
#line 182
  if (windowBits) {
#line 182
    if (windowBits < 8) {
#line 183
      return (-2);
    } else
#line 182
    if (windowBits > 15) {
#line 183
      return (-2);
    }
  }
#line 184
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
#line 184
    if (state->wbits != (unsigned int )windowBits) {
      {
#line 185
      (*(strm->zfree))(strm->opaque, (voidpf )state->window);
#line 186
      state->window = (unsigned char *)0;
      }
    }
  }
  {
#line 190
  state->wrap = wrap;
#line 191
  state->wbits = (unsigned int )windowBits;
#line 192
  tmp___0 = inflateReset(strm);
  }
#line 192
  return (tmp___0);
}
}
#line 195 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateInit2_(z_streamp strm , int windowBits , char const   *version , int stream_size ) 
{ 
  int ret ;
  struct inflate_state *state ;
  voidpf tmp ;

  {
#line 204
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 206
    return (-6);
  } else
#line 204
  if ((int const   )*(version + 0) != (int const   )*("1.2.11-optipng" + 0)) {
#line 206
    return (-6);
  } else
#line 204
  if (stream_size != (int )sizeof(z_stream )) {
#line 206
    return (-6);
  }
#line 207
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 207
    return (-2);
  }
#line 208
  strm->msg = (char *)0;
#line 209
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 213
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& zcalloc);
#line 214
    strm->opaque = (voidpf )0;
  }
#line 217
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 221
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))(& zcfree);
  }
  {
#line 223
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 223
  state = (struct inflate_state *)tmp;
  }
#line 225
  if ((unsigned long )state == (unsigned long )((struct inflate_state *)0)) {
#line 225
    return (-4);
  }
  {
#line 227
  strm->state = (struct internal_state *)state;
#line 228
  state->strm = strm;
#line 229
  state->window = (unsigned char *)0;
#line 230
  state->mode = (inflate_mode )16180;
#line 231
  ret = inflateReset2(strm, windowBits);
  }
#line 232
  if (ret != 0) {
    {
#line 233
    (*(strm->zfree))(strm->opaque, (voidpf )state);
#line 234
    strm->state = (struct internal_state *)0;
    }
  }
#line 236
  return (ret);
}
}
#line 239 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateInit_(z_streamp strm , char const   *version , int stream_size ) 
{ 
  int tmp ;

  {
  {
#line 244
  tmp = inflateInit2_(strm, 15, version, stream_size);
  }
#line 244
  return (tmp);
}
}
#line 247 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflatePrime(z_streamp strm , int bits , int value ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
  {
#line 254
  tmp = inflateStateCheck(strm);
  }
#line 254
  if (tmp) {
#line 254
    return (-2);
  }
#line 255
  state = (struct inflate_state *)strm->state;
#line 256
  if (bits < 0) {
#line 257
    state->hold = 0UL;
#line 258
    state->bits = 0U;
#line 259
    return (0);
  }
#line 261
  if (bits > 16) {
#line 261
    return (-2);
  } else
#line 261
  if (state->bits + (uInt )bits > 32U) {
#line 261
    return (-2);
  }
#line 262
  value = (int )((long )value & ((1L << bits) - 1L));
#line 263
  state->hold += (unsigned long )((unsigned int )value << state->bits);
#line 264
  state->bits += (uInt )bits;
#line 265
  return (0);
}
}
#line 10 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffixed.h"
static code const   lenfix[512]  = 
#line 10 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffixed.h"
  {      {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)192}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)160}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)224}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)144}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)208}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)176}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)240}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)200}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)168}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)232}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)152}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)216}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)184}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)248}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)196}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)164}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)228}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)148}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)212}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)180}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)244}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)204}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)172}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)236}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)156}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)220}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)188}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)252}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)194}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)162}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)226}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)146}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)210}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)178}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)242}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)202}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)170}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)234}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)154}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)218}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)186}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)250}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)198}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)166}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)230}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)150}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)214}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)182}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)246}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)206}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)174}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)238}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)158}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)222}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)190}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)254}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)193}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)161}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)225}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)145}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)209}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)177}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)241}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)201}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)169}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)233}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)153}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)217}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)185}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)249}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)197}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)165}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)229}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)149}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)213}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)181}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)245}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)205}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)173}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)237}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)157}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)221}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)189}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)253}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)195}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)163}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)227}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)147}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)211}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)179}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)243}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)203}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)171}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)235}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)155}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)219}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)187}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)251}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)199}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)167}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)231}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)151}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)215}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)183}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)247}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)207}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)175}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)239}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)159}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)223}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)191}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)255}};
#line 87 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffixed.h"
static code const   distfix[32]  = 
#line 87
  {      {(unsigned char)16, (unsigned char)5, (unsigned short)1}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)257}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)17}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)4097}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)5}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1025}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)65}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)16385}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)3}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)513}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)33}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)8193}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)9}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)2049}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)129}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)2}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)385}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)25}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)6145}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)7}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1537}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)97}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)24577}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)4}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)769}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)49}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)12289}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)13}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)3073}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)193}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}};
#line 278 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
static void fixedtables(struct inflate_state *state ) 
{ 


  {
#line 315
  state->lencode = lenfix;
#line 316
  state->lenbits = 9U;
#line 317
  state->distcode = distfix;
#line 318
  state->distbits = 5U;
#line 319
  return;
}
}
#line 396 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
static int updatewindow(z_streamp strm , unsigned char const   *end , unsigned int copy ) 
{ 
  struct inflate_state *state ;
  unsigned int dist ;
  voidpf tmp ;

  {
#line 404
  state = (struct inflate_state *)strm->state;
#line 407
  if ((unsigned long )state->window == (unsigned long )((unsigned char *)0)) {
    {
#line 408
    tmp = (*(strm->zalloc))(strm->opaque, 1U << state->wbits, (uInt )sizeof(unsigned char ));
#line 408
    state->window = (unsigned char *)tmp;
    }
#line 411
    if ((unsigned long )state->window == (unsigned long )((unsigned char *)0)) {
#line 411
      return (1);
    }
  }
#line 415
  if (state->wsize == 0U) {
#line 416
    state->wsize = 1U << state->wbits;
#line 417
    state->wnext = 0U;
#line 418
    state->whave = 0U;
  }
#line 422
  if (copy >= state->wsize) {
    {
#line 423
    memcpy((void */* __restrict  */)state->window, (void const   */* __restrict  */)(end - state->wsize),
           (size_t )state->wsize);
#line 424
    state->wnext = 0U;
#line 425
    state->whave = state->wsize;
    }
  } else {
#line 428
    dist = state->wsize - state->wnext;
#line 429
    if (dist > copy) {
#line 429
      dist = copy;
    }
    {
#line 430
    memcpy((void */* __restrict  */)(state->window + state->wnext), (void const   */* __restrict  */)(end - copy),
           (size_t )dist);
#line 431
    copy -= dist;
    }
#line 432
    if (copy) {
      {
#line 433
      memcpy((void */* __restrict  */)state->window, (void const   */* __restrict  */)(end - copy),
             (size_t )copy);
#line 434
      state->wnext = copy;
#line 435
      state->whave = state->wsize;
      }
    } else {
#line 438
      state->wnext += dist;
#line 439
      if (state->wnext == state->wsize) {
#line 439
        state->wnext = 0U;
      }
#line 440
      if (state->whave < state->wsize) {
#line 440
        state->whave += dist;
      }
    }
  }
#line 443
  return (0);
}
}
#line 642 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
static unsigned short const   order[19]  = 
#line 642
  {      (unsigned short const   )16,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )0, 
        (unsigned short const   )8,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )6, 
        (unsigned short const   )10,      (unsigned short const   )5,      (unsigned short const   )11,      (unsigned short const   )4, 
        (unsigned short const   )12,      (unsigned short const   )3,      (unsigned short const   )13,      (unsigned short const   )2, 
        (unsigned short const   )14,      (unsigned short const   )1,      (unsigned short const   )15};
#line 622 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflate(z_streamp strm , int flush ) 
{ 
  struct inflate_state *state ;
  unsigned char *next ;
  unsigned char *put ;
  unsigned int have ;
  unsigned int left ;
  unsigned long hold ;
  unsigned int bits ;
  unsigned int in ;
  unsigned int out ;
  unsigned int copy ;
  unsigned char *from ;
  code here ;
  code last ;
  unsigned int len ;
  int ret ;
  int tmp ;
  unsigned char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  int __attribute__((__visibility__("hidden")))  tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned int tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  int __attribute__((__visibility__("hidden")))  tmp___19 ;
  int __attribute__((__visibility__("hidden")))  tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned long tmp___31 ;
  int tmp___32 ;
  unsigned long tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
  {
#line 645
  tmp = inflateStateCheck(strm);
  }
#line 645
  if (tmp) {
#line 647
    return (-2);
  } else
#line 645
  if ((unsigned long )strm->next_out == (unsigned long )((Bytef *)0)) {
#line 647
    return (-2);
  } else
#line 645
  if ((unsigned long )strm->next_in == (unsigned long )((Bytef *)0)) {
#line 645
    if (strm->avail_in != 0U) {
#line 647
      return (-2);
    }
  }
#line 649
  state = (struct inflate_state *)strm->state;
#line 650
  if ((unsigned int )state->mode == 16191U) {
#line 650
    state->mode = (inflate_mode )16192;
  }
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    put = strm->next_out;
#line 651
    left = strm->avail_out;
#line 651
    next = strm->next_in;
#line 651
    have = strm->avail_in;
#line 651
    hold = state->hold;
#line 651
    bits = state->bits;
#line 651
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  in = have;
#line 653
  out = left;
#line 654
  ret = 0;
  {
#line 655
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 657
    if ((unsigned int )state->mode == 16180U) {
#line 657
      goto case_16180;
    }
#line 837
    if ((unsigned int )state->mode == 16189U) {
#line 837
      goto case_16189;
    }
#line 842
    if ((unsigned int )state->mode == 16190U) {
#line 842
      goto case_16190;
    }
#line 849
    if ((unsigned int )state->mode == 16191U) {
#line 849
      goto case_16191;
    }
#line 851
    if ((unsigned int )state->mode == 16192U) {
#line 851
      goto case_16192;
    }
#line 887
    if ((unsigned int )state->mode == 16193U) {
#line 887
      goto case_16193;
    }
#line 901
    if ((unsigned int )state->mode == 16194U) {
#line 901
      goto case_16194;
    }
#line 903
    if ((unsigned int )state->mode == 16195U) {
#line 903
      goto case_16195;
    }
#line 920
    if ((unsigned int )state->mode == 16196U) {
#line 920
      goto case_16196;
    }
#line 938
    if ((unsigned int )state->mode == 16197U) {
#line 938
      goto case_16197;
    }
#line 959
    if ((unsigned int )state->mode == 16198U) {
#line 959
      goto case_16198;
    }
#line 1042
    if ((unsigned int )state->mode == 16199U) {
#line 1042
      goto case_16199;
    }
#line 1044
    if ((unsigned int )state->mode == 16200U) {
#line 1044
      goto case_16200;
    }
#line 1093
    if ((unsigned int )state->mode == 16201U) {
#line 1093
      goto case_16201;
    }
#line 1103
    if ((unsigned int )state->mode == 16202U) {
#line 1103
      goto case_16202;
    }
#line 1130
    if ((unsigned int )state->mode == 16203U) {
#line 1130
      goto case_16203;
    }
#line 1146
    if ((unsigned int )state->mode == 16204U) {
#line 1146
      goto case_16204;
    }
#line 1191
    if ((unsigned int )state->mode == 16205U) {
#line 1191
      goto case_16205;
    }
#line 1197
    if ((unsigned int )state->mode == 16206U) {
#line 1197
      goto case_16206;
    }
#line 1234
    if ((unsigned int )state->mode == 16208U) {
#line 1234
      goto case_16208;
    }
#line 1237
    if ((unsigned int )state->mode == 16209U) {
#line 1237
      goto case_16209;
    }
#line 1240
    if ((unsigned int )state->mode == 16210U) {
#line 1240
      goto case_16210;
    }
#line 1243
    goto switch_default;
    case_16180: /* CIL Label */ 
#line 658
    if (state->wrap == 0) {
#line 659
      state->mode = (inflate_mode )16192;
#line 660
      goto switch_break;
    }
    {
#line 662
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 662
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 662
        if (! (bits < 16U)) {
#line 662
          goto while_break___2;
        }
        {
#line 662
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 662
          if (have == 0U) {
#line 662
            goto inf_leave;
          }
#line 662
          have --;
#line 662
          tmp___0 = next;
#line 662
          next ++;
#line 662
          hold += (unsigned long )*tmp___0 << bits;
#line 662
          bits += 8U;
#line 662
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 662
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 678
    if (((unsigned long )(((unsigned int )hold & ((1U << 8) - 1U)) << 8) + (hold >> 8)) % 31UL) {
#line 681
      strm->msg = (char *)"incorrect header check";
#line 682
      state->mode = (inflate_mode )16209;
#line 683
      goto switch_break;
    }
#line 685
    if (((unsigned int )hold & ((1U << 4) - 1U)) != 8U) {
#line 686
      strm->msg = (char *)"unknown compression method";
#line 687
      state->mode = (inflate_mode )16209;
#line 688
      goto switch_break;
    }
    {
#line 690
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 690
      hold >>= 4;
#line 690
      bits -= 4U;
#line 690
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 691
    len = ((unsigned int )hold & ((1U << 4) - 1U)) + 8U;
#line 692
    if (state->wbits == 0U) {
#line 693
      state->wbits = len;
    }
#line 694
    if (len > 15U) {
#line 695
      strm->msg = (char *)"invalid window size";
#line 696
      state->mode = (inflate_mode )16209;
#line 697
      goto switch_break;
    } else
#line 694
    if (len > state->wbits) {
#line 695
      strm->msg = (char *)"invalid window size";
#line 696
      state->mode = (inflate_mode )16209;
#line 697
      goto switch_break;
    }
    {
#line 699
    state->dmax = 1U << len;
#line 701
    tmp___1 = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 701
    state->check = tmp___1;
#line 701
    strm->adler = tmp___1;
    }
#line 702
    if (hold & 512UL) {
#line 702
      state->mode = (inflate_mode )16189;
    } else {
#line 702
      state->mode = (inflate_mode )16191;
    }
    {
#line 703
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 703
      hold = 0UL;
#line 703
      bits = 0U;
#line 703
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 704
    goto switch_break;
    case_16189: /* CIL Label */ 
    {
#line 838
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 838
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 838
        if (! (bits < 32U)) {
#line 838
          goto while_break___7;
        }
        {
#line 838
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 838
          if (have == 0U) {
#line 838
            goto inf_leave;
          }
#line 838
          have --;
#line 838
          tmp___2 = next;
#line 838
          next ++;
#line 838
          hold += (unsigned long )*tmp___2 << bits;
#line 838
          bits += 8U;
#line 838
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 838
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 839
    tmp___3 = ((((hold >> 24) & 255UL) + ((hold >> 8) & 65280UL)) + ((hold & 65280UL) << 8)) + ((hold & 255UL) << 24);
#line 839
    state->check = tmp___3;
#line 839
    strm->adler = tmp___3;
    {
#line 840
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 840
      hold = 0UL;
#line 840
      bits = 0U;
#line 840
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 841
    state->mode = (inflate_mode )16190;
    case_16190: /* CIL Label */ 
#line 843
    if (state->havedict == 0) {
      {
#line 844
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 844
        strm->next_out = put;
#line 844
        strm->avail_out = left;
#line 844
        strm->next_in = next;
#line 844
        strm->avail_in = have;
#line 844
        state->hold = hold;
#line 844
        state->bits = bits;
#line 844
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 845
      return (2);
    }
    {
#line 847
    tmp___4 = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 847
    state->check = tmp___4;
#line 847
    strm->adler = tmp___4;
#line 848
    state->mode = (inflate_mode )16191;
    }
    case_16191: /* CIL Label */ 
#line 850
    if (flush == 5) {
#line 850
      goto inf_leave;
    } else
#line 850
    if (flush == 6) {
#line 850
      goto inf_leave;
    }
    case_16192: /* CIL Label */ 
#line 852
    if (state->last) {
      {
#line 853
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 853
        hold >>= bits & 7U;
#line 853
        bits -= bits & 7U;
#line 853
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 854
      state->mode = (inflate_mode )16206;
#line 855
      goto switch_break;
    }
    {
#line 857
    while (1) {
      while_continue___12: /* CIL Label */ ;
      {
#line 857
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 857
        if (! (bits < 3U)) {
#line 857
          goto while_break___13;
        }
        {
#line 857
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 857
          if (have == 0U) {
#line 857
            goto inf_leave;
          }
#line 857
          have --;
#line 857
          tmp___5 = next;
#line 857
          next ++;
#line 857
          hold += (unsigned long )*tmp___5 << bits;
#line 857
          bits += 8U;
#line 857
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
#line 857
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 858
    state->last = (int )((unsigned int )hold & ((1U << 1) - 1U));
    {
#line 859
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 859
      hold >>= 1;
#line 859
      bits --;
#line 859
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 861
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 0U) {
#line 861
      goto case_0;
    }
#line 866
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 1U) {
#line 866
      goto case_1;
    }
#line 876
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 2U) {
#line 876
      goto case_2;
    }
#line 881
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 3U) {
#line 881
      goto case_3;
    }
#line 860
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 864
    state->mode = (inflate_mode )16193;
#line 865
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 867
    fixedtables(state);
#line 870
    state->mode = (inflate_mode )16199;
    }
#line 871
    if (flush == 6) {
      {
#line 872
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 872
        hold >>= 2;
#line 872
        bits -= 2U;
#line 872
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 873
      goto inf_leave;
    }
#line 875
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 879
    state->mode = (inflate_mode )16196;
#line 880
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 882
    strm->msg = (char *)"invalid block type";
#line 883
    state->mode = (inflate_mode )16209;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 885
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 885
      hold >>= 2;
#line 885
      bits -= 2U;
#line 885
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 886
    goto switch_break;
    case_16193: /* CIL Label */ 
    {
#line 888
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 888
      hold >>= bits & 7U;
#line 888
      bits -= bits & 7U;
#line 888
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 889
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 889
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 889
        if (! (bits < 32U)) {
#line 889
          goto while_break___20;
        }
        {
#line 889
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 889
          if (have == 0U) {
#line 889
            goto inf_leave;
          }
#line 889
          have --;
#line 889
          tmp___6 = next;
#line 889
          next ++;
#line 889
          hold += (unsigned long )*tmp___6 << bits;
#line 889
          bits += 8U;
#line 889
          goto while_break___21;
        }
        while_break___21: /* CIL Label */ ;
        }
      }
      while_break___20: /* CIL Label */ ;
      }
#line 889
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 890
    if ((hold & 65535UL) != ((hold >> 16) ^ 65535UL)) {
#line 891
      strm->msg = (char *)"invalid stored block lengths";
#line 892
      state->mode = (inflate_mode )16209;
#line 893
      goto switch_break;
    }
#line 895
    state->length = (unsigned int )hold & 65535U;
    {
#line 898
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 898
      hold = 0UL;
#line 898
      bits = 0U;
#line 898
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 899
    state->mode = (inflate_mode )16194;
#line 900
    if (flush == 6) {
#line 900
      goto inf_leave;
    }
    case_16194: /* CIL Label */ 
#line 902
    state->mode = (inflate_mode )16195;
    case_16195: /* CIL Label */ 
#line 904
    copy = state->length;
#line 905
    if (copy) {
#line 906
      if (copy > have) {
#line 906
        copy = have;
      }
#line 907
      if (copy > left) {
#line 907
        copy = left;
      }
#line 908
      if (copy == 0U) {
#line 908
        goto inf_leave;
      }
      {
#line 909
      memcpy((void */* __restrict  */)put, (void const   */* __restrict  */)next,
             (size_t )copy);
#line 910
      have -= copy;
#line 911
      next += copy;
#line 912
      left -= copy;
#line 913
      put += copy;
#line 914
      state->length -= copy;
      }
#line 915
      goto switch_break;
    }
#line 918
    state->mode = (inflate_mode )16191;
#line 919
    goto switch_break;
    case_16196: /* CIL Label */ 
    {
#line 921
    while (1) {
      while_continue___23: /* CIL Label */ ;
      {
#line 921
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 921
        if (! (bits < 14U)) {
#line 921
          goto while_break___24;
        }
        {
#line 921
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 921
          if (have == 0U) {
#line 921
            goto inf_leave;
          }
#line 921
          have --;
#line 921
          tmp___7 = next;
#line 921
          next ++;
#line 921
          hold += (unsigned long )*tmp___7 << bits;
#line 921
          bits += 8U;
#line 921
          goto while_break___25;
        }
        while_break___25: /* CIL Label */ ;
        }
      }
      while_break___24: /* CIL Label */ ;
      }
#line 921
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 922
    state->nlen = ((unsigned int )hold & ((1U << 5) - 1U)) + 257U;
    {
#line 923
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 923
      hold >>= 5;
#line 923
      bits -= 5U;
#line 923
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 924
    state->ndist = ((unsigned int )hold & ((1U << 5) - 1U)) + 1U;
    {
#line 925
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 925
      hold >>= 5;
#line 925
      bits -= 5U;
#line 925
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 926
    state->ncode = ((unsigned int )hold & ((1U << 4) - 1U)) + 4U;
    {
#line 927
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 927
      hold >>= 4;
#line 927
      bits -= 4U;
#line 927
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 929
    if (state->nlen > 286U) {
#line 930
      strm->msg = (char *)"too many length or distance symbols";
#line 931
      state->mode = (inflate_mode )16209;
#line 932
      goto switch_break;
    } else
#line 929
    if (state->ndist > 30U) {
#line 930
      strm->msg = (char *)"too many length or distance symbols";
#line 931
      state->mode = (inflate_mode )16209;
#line 932
      goto switch_break;
    }
#line 936
    state->have = 0U;
#line 937
    state->mode = (inflate_mode )16197;
    case_16197: /* CIL Label */ 
    {
#line 939
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 939
      if (! (state->have < state->ncode)) {
#line 939
        goto while_break___29;
      }
      {
#line 940
      while (1) {
        while_continue___30: /* CIL Label */ ;
        {
#line 940
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 940
          if (! (bits < 3U)) {
#line 940
            goto while_break___31;
          }
          {
#line 940
          while (1) {
            while_continue___32: /* CIL Label */ ;
#line 940
            if (have == 0U) {
#line 940
              goto inf_leave;
            }
#line 940
            have --;
#line 940
            tmp___8 = next;
#line 940
            next ++;
#line 940
            hold += (unsigned long )*tmp___8 << bits;
#line 940
            bits += 8U;
#line 940
            goto while_break___32;
          }
          while_break___32: /* CIL Label */ ;
          }
        }
        while_break___31: /* CIL Label */ ;
        }
#line 940
        goto while_break___30;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 941
      tmp___9 = state->have;
#line 941
      (state->have) ++;
#line 941
      state->lens[order[tmp___9]] = (unsigned short )((unsigned int )hold & ((1U << 3) - 1U));
      {
#line 942
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 942
        hold >>= 3;
#line 942
        bits -= 3U;
#line 942
        goto while_break___33;
      }
      while_break___33: /* CIL Label */ ;
      }
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 944
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 944
      if (! (state->have < 19U)) {
#line 944
        goto while_break___34;
      }
#line 945
      tmp___10 = state->have;
#line 945
      (state->have) ++;
#line 945
      state->lens[order[tmp___10]] = (unsigned short)0;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 946
    state->next = state->codes;
#line 947
    state->lencode = (code const   *)state->next;
#line 948
    state->lenbits = 7U;
#line 949
    tmp___11 = inflate_table((codetype )0, state->lens, 19U, & state->next, & state->lenbits,
                             state->work);
#line 949
    ret = (int )tmp___11;
    }
#line 951
    if (ret) {
#line 952
      strm->msg = (char *)"invalid code lengths set";
#line 953
      state->mode = (inflate_mode )16209;
#line 954
      goto switch_break;
    }
#line 957
    state->have = 0U;
#line 958
    state->mode = (inflate_mode )16198;
    case_16198: /* CIL Label */ 
    {
#line 960
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 960
      if (! (state->have < state->nlen + state->ndist)) {
#line 960
        goto while_break___35;
      }
      {
#line 961
      while (1) {
        while_continue___36: /* CIL Label */ ;
#line 962
        here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 963
        if ((unsigned int )here.bits <= bits) {
#line 963
          goto while_break___36;
        }
        {
#line 964
        while (1) {
          while_continue___37: /* CIL Label */ ;
#line 964
          if (have == 0U) {
#line 964
            goto inf_leave;
          }
#line 964
          have --;
#line 964
          tmp___12 = next;
#line 964
          next ++;
#line 964
          hold += (unsigned long )*tmp___12 << bits;
#line 964
          bits += 8U;
#line 964
          goto while_break___37;
        }
        while_break___37: /* CIL Label */ ;
        }
      }
      while_break___36: /* CIL Label */ ;
      }
#line 966
      if ((int )here.val < 16) {
        {
#line 967
        while (1) {
          while_continue___38: /* CIL Label */ ;
#line 967
          hold >>= (int )here.bits;
#line 967
          bits -= (unsigned int )here.bits;
#line 967
          goto while_break___38;
        }
        while_break___38: /* CIL Label */ ;
        }
#line 968
        tmp___13 = state->have;
#line 968
        (state->have) ++;
#line 968
        state->lens[tmp___13] = here.val;
      } else {
#line 971
        if ((int )here.val == 16) {
          {
#line 972
          while (1) {
            while_continue___39: /* CIL Label */ ;
            {
#line 972
            while (1) {
              while_continue___40: /* CIL Label */ ;
#line 972
              if (! (bits < (unsigned int )((int )here.bits + 2))) {
#line 972
                goto while_break___40;
              }
              {
#line 972
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 972
                if (have == 0U) {
#line 972
                  goto inf_leave;
                }
#line 972
                have --;
#line 972
                tmp___14 = next;
#line 972
                next ++;
#line 972
                hold += (unsigned long )*tmp___14 << bits;
#line 972
                bits += 8U;
#line 972
                goto while_break___41;
              }
              while_break___41: /* CIL Label */ ;
              }
            }
            while_break___40: /* CIL Label */ ;
            }
#line 972
            goto while_break___39;
          }
          while_break___39: /* CIL Label */ ;
          }
          {
#line 973
          while (1) {
            while_continue___42: /* CIL Label */ ;
#line 973
            hold >>= (int )here.bits;
#line 973
            bits -= (unsigned int )here.bits;
#line 973
            goto while_break___42;
          }
          while_break___42: /* CIL Label */ ;
          }
#line 974
          if (state->have == 0U) {
#line 975
            strm->msg = (char *)"invalid bit length repeat";
#line 976
            state->mode = (inflate_mode )16209;
#line 977
            goto while_break___35;
          }
#line 979
          len = (unsigned int )state->lens[state->have - 1U];
#line 980
          copy = 3U + ((unsigned int )hold & ((1U << 2) - 1U));
          {
#line 981
          while (1) {
            while_continue___43: /* CIL Label */ ;
#line 981
            hold >>= 2;
#line 981
            bits -= 2U;
#line 981
            goto while_break___43;
          }
          while_break___43: /* CIL Label */ ;
          }
        } else
#line 983
        if ((int )here.val == 17) {
          {
#line 984
          while (1) {
            while_continue___44: /* CIL Label */ ;
            {
#line 984
            while (1) {
              while_continue___45: /* CIL Label */ ;
#line 984
              if (! (bits < (unsigned int )((int )here.bits + 3))) {
#line 984
                goto while_break___45;
              }
              {
#line 984
              while (1) {
                while_continue___46: /* CIL Label */ ;
#line 984
                if (have == 0U) {
#line 984
                  goto inf_leave;
                }
#line 984
                have --;
#line 984
                tmp___15 = next;
#line 984
                next ++;
#line 984
                hold += (unsigned long )*tmp___15 << bits;
#line 984
                bits += 8U;
#line 984
                goto while_break___46;
              }
              while_break___46: /* CIL Label */ ;
              }
            }
            while_break___45: /* CIL Label */ ;
            }
#line 984
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
          {
#line 985
          while (1) {
            while_continue___47: /* CIL Label */ ;
#line 985
            hold >>= (int )here.bits;
#line 985
            bits -= (unsigned int )here.bits;
#line 985
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
#line 986
          len = 0U;
#line 987
          copy = 3U + ((unsigned int )hold & ((1U << 3) - 1U));
          {
#line 988
          while (1) {
            while_continue___48: /* CIL Label */ ;
#line 988
            hold >>= 3;
#line 988
            bits -= 3U;
#line 988
            goto while_break___48;
          }
          while_break___48: /* CIL Label */ ;
          }
        } else {
          {
#line 991
          while (1) {
            while_continue___49: /* CIL Label */ ;
            {
#line 991
            while (1) {
              while_continue___50: /* CIL Label */ ;
#line 991
              if (! (bits < (unsigned int )((int )here.bits + 7))) {
#line 991
                goto while_break___50;
              }
              {
#line 991
              while (1) {
                while_continue___51: /* CIL Label */ ;
#line 991
                if (have == 0U) {
#line 991
                  goto inf_leave;
                }
#line 991
                have --;
#line 991
                tmp___16 = next;
#line 991
                next ++;
#line 991
                hold += (unsigned long )*tmp___16 << bits;
#line 991
                bits += 8U;
#line 991
                goto while_break___51;
              }
              while_break___51: /* CIL Label */ ;
              }
            }
            while_break___50: /* CIL Label */ ;
            }
#line 991
            goto while_break___49;
          }
          while_break___49: /* CIL Label */ ;
          }
          {
#line 992
          while (1) {
            while_continue___52: /* CIL Label */ ;
#line 992
            hold >>= (int )here.bits;
#line 992
            bits -= (unsigned int )here.bits;
#line 992
            goto while_break___52;
          }
          while_break___52: /* CIL Label */ ;
          }
#line 993
          len = 0U;
#line 994
          copy = 11U + ((unsigned int )hold & ((1U << 7) - 1U));
          {
#line 995
          while (1) {
            while_continue___53: /* CIL Label */ ;
#line 995
            hold >>= 7;
#line 995
            bits -= 7U;
#line 995
            goto while_break___53;
          }
          while_break___53: /* CIL Label */ ;
          }
        }
#line 997
        if (state->have + copy > state->nlen + state->ndist) {
#line 998
          strm->msg = (char *)"invalid bit length repeat";
#line 999
          state->mode = (inflate_mode )16209;
#line 1000
          goto while_break___35;
        }
        {
#line 1002
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 1002
          tmp___18 = copy;
#line 1002
          copy --;
#line 1002
          if (! tmp___18) {
#line 1002
            goto while_break___54;
          }
#line 1003
          tmp___17 = state->have;
#line 1003
          (state->have) ++;
#line 1003
          state->lens[tmp___17] = (unsigned short )len;
        }
        while_break___54: /* CIL Label */ ;
        }
      }
    }
    while_break___35: /* CIL Label */ ;
    }
#line 1008
    if ((unsigned int )state->mode == 16209U) {
#line 1008
      goto switch_break;
    }
#line 1011
    if ((int )state->lens[256] == 0) {
#line 1012
      strm->msg = (char *)"invalid code -- missing end-of-block";
#line 1013
      state->mode = (inflate_mode )16209;
#line 1014
      goto switch_break;
    }
    {
#line 1020
    state->next = state->codes;
#line 1021
    state->lencode = (code const   *)state->next;
#line 1022
    state->lenbits = 9U;
#line 1023
    tmp___19 = inflate_table((codetype )1, state->lens, state->nlen, & state->next,
                             & state->lenbits, state->work);
#line 1023
    ret = (int )tmp___19;
    }
#line 1025
    if (ret) {
#line 1026
      strm->msg = (char *)"invalid literal/lengths set";
#line 1027
      state->mode = (inflate_mode )16209;
#line 1028
      goto switch_break;
    }
    {
#line 1030
    state->distcode = (code const   *)state->next;
#line 1031
    state->distbits = 6U;
#line 1032
    tmp___20 = inflate_table((codetype )2, state->lens + state->nlen, state->ndist,
                             & state->next, & state->distbits, state->work);
#line 1032
    ret = (int )tmp___20;
    }
#line 1034
    if (ret) {
#line 1035
      strm->msg = (char *)"invalid distances set";
#line 1036
      state->mode = (inflate_mode )16209;
#line 1037
      goto switch_break;
    }
#line 1040
    state->mode = (inflate_mode )16199;
#line 1041
    if (flush == 6) {
#line 1041
      goto inf_leave;
    }
    case_16199: /* CIL Label */ 
#line 1043
    state->mode = (inflate_mode )16200;
    case_16200: /* CIL Label */ 
#line 1045
    if (have >= 6U) {
#line 1045
      if (left >= 258U) {
        {
#line 1046
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 1046
          strm->next_out = put;
#line 1046
          strm->avail_out = left;
#line 1046
          strm->next_in = next;
#line 1046
          strm->avail_in = have;
#line 1046
          state->hold = hold;
#line 1046
          state->bits = bits;
#line 1046
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
        {
#line 1047
        inflate_fast(strm, out);
        }
        {
#line 1048
        while (1) {
          while_continue___56: /* CIL Label */ ;
#line 1048
          put = strm->next_out;
#line 1048
          left = strm->avail_out;
#line 1048
          next = strm->next_in;
#line 1048
          have = strm->avail_in;
#line 1048
          hold = state->hold;
#line 1048
          bits = state->bits;
#line 1048
          goto while_break___56;
        }
        while_break___56: /* CIL Label */ ;
        }
#line 1049
        if ((unsigned int )state->mode == 16191U) {
#line 1050
          state->back = -1;
        }
#line 1051
        goto switch_break;
      }
    }
#line 1053
    state->back = 0;
    {
#line 1054
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 1055
      here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 1056
      if ((unsigned int )here.bits <= bits) {
#line 1056
        goto while_break___57;
      }
      {
#line 1057
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 1057
        if (have == 0U) {
#line 1057
          goto inf_leave;
        }
#line 1057
        have --;
#line 1057
        tmp___21 = next;
#line 1057
        next ++;
#line 1057
        hold += (unsigned long )*tmp___21 << bits;
#line 1057
        bits += 8U;
#line 1057
        goto while_break___58;
      }
      while_break___58: /* CIL Label */ ;
      }
    }
    while_break___57: /* CIL Label */ ;
    }
#line 1059
    if (here.op) {
#line 1059
      if (((int )here.op & 240) == 0) {
#line 1060
        last = here;
        {
#line 1061
        while (1) {
          while_continue___59: /* CIL Label */ ;
#line 1062
          here = (code )*(state->lencode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 1064
          if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 1064
            goto while_break___59;
          }
          {
#line 1065
          while (1) {
            while_continue___60: /* CIL Label */ ;
#line 1065
            if (have == 0U) {
#line 1065
              goto inf_leave;
            }
#line 1065
            have --;
#line 1065
            tmp___22 = next;
#line 1065
            next ++;
#line 1065
            hold += (unsigned long )*tmp___22 << bits;
#line 1065
            bits += 8U;
#line 1065
            goto while_break___60;
          }
          while_break___60: /* CIL Label */ ;
          }
        }
        while_break___59: /* CIL Label */ ;
        }
        {
#line 1067
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 1067
          hold >>= (int )last.bits;
#line 1067
          bits -= (unsigned int )last.bits;
#line 1067
          goto while_break___61;
        }
        while_break___61: /* CIL Label */ ;
        }
#line 1068
        state->back += (int )last.bits;
      }
    }
    {
#line 1070
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 1070
      hold >>= (int )here.bits;
#line 1070
      bits -= (unsigned int )here.bits;
#line 1070
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
#line 1071
    state->back += (int )here.bits;
#line 1072
    state->length = (unsigned int )here.val;
#line 1073
    if ((int )here.op == 0) {
#line 1077
      state->mode = (inflate_mode )16205;
#line 1078
      goto switch_break;
    }
#line 1080
    if ((int )here.op & 32) {
#line 1082
      state->back = -1;
#line 1083
      state->mode = (inflate_mode )16191;
#line 1084
      goto switch_break;
    }
#line 1086
    if ((int )here.op & 64) {
#line 1087
      strm->msg = (char *)"invalid literal/length code";
#line 1088
      state->mode = (inflate_mode )16209;
#line 1089
      goto switch_break;
    }
#line 1091
    state->extra = (unsigned int )here.op & 15U;
#line 1092
    state->mode = (inflate_mode )16201;
    case_16201: /* CIL Label */ 
#line 1094
    if (state->extra) {
      {
#line 1095
      while (1) {
        while_continue___63: /* CIL Label */ ;
        {
#line 1095
        while (1) {
          while_continue___64: /* CIL Label */ ;
#line 1095
          if (! (bits < state->extra)) {
#line 1095
            goto while_break___64;
          }
          {
#line 1095
          while (1) {
            while_continue___65: /* CIL Label */ ;
#line 1095
            if (have == 0U) {
#line 1095
              goto inf_leave;
            }
#line 1095
            have --;
#line 1095
            tmp___23 = next;
#line 1095
            next ++;
#line 1095
            hold += (unsigned long )*tmp___23 << bits;
#line 1095
            bits += 8U;
#line 1095
            goto while_break___65;
          }
          while_break___65: /* CIL Label */ ;
          }
        }
        while_break___64: /* CIL Label */ ;
        }
#line 1095
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
#line 1096
      state->length += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 1097
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 1097
        hold >>= state->extra;
#line 1097
        bits -= state->extra;
#line 1097
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
#line 1098
      state->back = (int )((unsigned int )state->back + state->extra);
    }
#line 1101
    state->was = state->length;
#line 1102
    state->mode = (inflate_mode )16202;
    case_16202: /* CIL Label */ 
    {
#line 1104
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 1105
      here = (code )*(state->distcode + ((unsigned int )hold & ((1U << state->distbits) - 1U)));
#line 1106
      if ((unsigned int )here.bits <= bits) {
#line 1106
        goto while_break___67;
      }
      {
#line 1107
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 1107
        if (have == 0U) {
#line 1107
          goto inf_leave;
        }
#line 1107
        have --;
#line 1107
        tmp___24 = next;
#line 1107
        next ++;
#line 1107
        hold += (unsigned long )*tmp___24 << bits;
#line 1107
        bits += 8U;
#line 1107
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
    }
    while_break___67: /* CIL Label */ ;
    }
#line 1109
    if (((int )here.op & 240) == 0) {
#line 1110
      last = here;
      {
#line 1111
      while (1) {
        while_continue___69: /* CIL Label */ ;
#line 1112
        here = (code )*(state->distcode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 1114
        if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 1114
          goto while_break___69;
        }
        {
#line 1115
        while (1) {
          while_continue___70: /* CIL Label */ ;
#line 1115
          if (have == 0U) {
#line 1115
            goto inf_leave;
          }
#line 1115
          have --;
#line 1115
          tmp___25 = next;
#line 1115
          next ++;
#line 1115
          hold += (unsigned long )*tmp___25 << bits;
#line 1115
          bits += 8U;
#line 1115
          goto while_break___70;
        }
        while_break___70: /* CIL Label */ ;
        }
      }
      while_break___69: /* CIL Label */ ;
      }
      {
#line 1117
      while (1) {
        while_continue___71: /* CIL Label */ ;
#line 1117
        hold >>= (int )last.bits;
#line 1117
        bits -= (unsigned int )last.bits;
#line 1117
        goto while_break___71;
      }
      while_break___71: /* CIL Label */ ;
      }
#line 1118
      state->back += (int )last.bits;
    }
    {
#line 1120
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 1120
      hold >>= (int )here.bits;
#line 1120
      bits -= (unsigned int )here.bits;
#line 1120
      goto while_break___72;
    }
    while_break___72: /* CIL Label */ ;
    }
#line 1121
    state->back += (int )here.bits;
#line 1122
    if ((int )here.op & 64) {
#line 1123
      strm->msg = (char *)"invalid distance code";
#line 1124
      state->mode = (inflate_mode )16209;
#line 1125
      goto switch_break;
    }
#line 1127
    state->offset = (unsigned int )here.val;
#line 1128
    state->extra = (unsigned int )here.op & 15U;
#line 1129
    state->mode = (inflate_mode )16203;
    case_16203: /* CIL Label */ 
#line 1131
    if (state->extra) {
      {
#line 1132
      while (1) {
        while_continue___73: /* CIL Label */ ;
        {
#line 1132
        while (1) {
          while_continue___74: /* CIL Label */ ;
#line 1132
          if (! (bits < state->extra)) {
#line 1132
            goto while_break___74;
          }
          {
#line 1132
          while (1) {
            while_continue___75: /* CIL Label */ ;
#line 1132
            if (have == 0U) {
#line 1132
              goto inf_leave;
            }
#line 1132
            have --;
#line 1132
            tmp___26 = next;
#line 1132
            next ++;
#line 1132
            hold += (unsigned long )*tmp___26 << bits;
#line 1132
            bits += 8U;
#line 1132
            goto while_break___75;
          }
          while_break___75: /* CIL Label */ ;
          }
        }
        while_break___74: /* CIL Label */ ;
        }
#line 1132
        goto while_break___73;
      }
      while_break___73: /* CIL Label */ ;
      }
#line 1133
      state->offset += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 1134
      while (1) {
        while_continue___76: /* CIL Label */ ;
#line 1134
        hold >>= state->extra;
#line 1134
        bits -= state->extra;
#line 1134
        goto while_break___76;
      }
      while_break___76: /* CIL Label */ ;
      }
#line 1135
      state->back = (int )((unsigned int )state->back + state->extra);
    }
#line 1145
    state->mode = (inflate_mode )16204;
    case_16204: /* CIL Label */ 
#line 1147
    if (left == 0U) {
#line 1147
      goto inf_leave;
    }
#line 1148
    copy = out - left;
#line 1149
    if (state->offset > copy) {
#line 1150
      copy = state->offset - copy;
#line 1151
      if (copy > state->whave) {
#line 1152
        if (state->sane) {
#line 1153
          strm->msg = (char *)"invalid distance too far back";
#line 1154
          state->mode = (inflate_mode )16209;
#line 1155
          goto switch_break;
        }
      }
#line 1171
      if (copy > state->wnext) {
#line 1172
        copy -= state->wnext;
#line 1173
        from = state->window + (state->wsize - copy);
      } else {
#line 1176
        from = state->window + (state->wnext - copy);
      }
#line 1177
      if (copy > state->length) {
#line 1177
        copy = state->length;
      }
    } else {
#line 1180
      from = put - state->offset;
#line 1181
      copy = state->length;
    }
#line 1183
    if (copy > left) {
#line 1183
      copy = left;
    }
#line 1184
    left -= copy;
#line 1185
    state->length -= copy;
    {
#line 1186
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 1187
      tmp___27 = put;
#line 1187
      put ++;
#line 1187
      tmp___28 = from;
#line 1187
      from ++;
#line 1187
      *tmp___27 = *tmp___28;
#line 1186
      copy --;
#line 1186
      if (! copy) {
#line 1186
        goto while_break___77;
      }
    }
    while_break___77: /* CIL Label */ ;
    }
#line 1189
    if (state->length == 0U) {
#line 1189
      state->mode = (inflate_mode )16200;
    }
#line 1190
    goto switch_break;
    case_16205: /* CIL Label */ 
#line 1192
    if (left == 0U) {
#line 1192
      goto inf_leave;
    }
#line 1193
    tmp___29 = put;
#line 1193
    put ++;
#line 1193
    *tmp___29 = (unsigned char )state->length;
#line 1194
    left --;
#line 1195
    state->mode = (inflate_mode )16200;
#line 1196
    goto switch_break;
    case_16206: /* CIL Label */ 
#line 1198
    if (state->wrap) {
      {
#line 1199
      while (1) {
        while_continue___78: /* CIL Label */ ;
        {
#line 1199
        while (1) {
          while_continue___79: /* CIL Label */ ;
#line 1199
          if (! (bits < 32U)) {
#line 1199
            goto while_break___79;
          }
          {
#line 1199
          while (1) {
            while_continue___80: /* CIL Label */ ;
#line 1199
            if (have == 0U) {
#line 1199
              goto inf_leave;
            }
#line 1199
            have --;
#line 1199
            tmp___30 = next;
#line 1199
            next ++;
#line 1199
            hold += (unsigned long )*tmp___30 << bits;
#line 1199
            bits += 8U;
#line 1199
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
        }
        while_break___79: /* CIL Label */ ;
        }
#line 1199
        goto while_break___78;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 1200
      out -= left;
#line 1201
      strm->total_out += (uLong )out;
#line 1202
      state->total += (unsigned long )out;
#line 1203
      if (state->wrap & 4) {
#line 1203
        if (out) {
          {
#line 1204
          tmp___31 = adler32(state->check, (Bytef const   *)(put - out), out);
#line 1204
          state->check = tmp___31;
#line 1204
          strm->adler = tmp___31;
          }
        }
      }
#line 1206
      out = left;
#line 1207
      if (state->wrap & 4) {
#line 1207
        if (((((hold >> 24) & 255UL) + ((hold >> 8) & 65280UL)) + ((hold & 65280UL) << 8)) + ((hold & 255UL) << 24) != state->check) {
#line 1212
          strm->msg = (char *)"incorrect data check";
#line 1213
          state->mode = (inflate_mode )16209;
#line 1214
          goto switch_break;
        }
      }
      {
#line 1216
      while (1) {
        while_continue___81: /* CIL Label */ ;
#line 1216
        hold = 0UL;
#line 1216
        bits = 0U;
#line 1216
        goto while_break___81;
      }
      while_break___81: /* CIL Label */ ;
      }
    }
#line 1233
    state->mode = (inflate_mode )16208;
    case_16208: /* CIL Label */ 
#line 1235
    ret = 1;
#line 1236
    goto inf_leave;
    case_16209: /* CIL Label */ 
#line 1238
    ret = -3;
#line 1239
    goto inf_leave;
    case_16210: /* CIL Label */ 
#line 1241
    return (-4);
    switch_default: /* CIL Label */ 
#line 1244
    return (-2);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  inf_leave: 
  {
#line 1254
  while (1) {
    while_continue___82: /* CIL Label */ ;
#line 1254
    strm->next_out = put;
#line 1254
    strm->avail_out = left;
#line 1254
    strm->next_in = next;
#line 1254
    strm->avail_in = have;
#line 1254
    state->hold = hold;
#line 1254
    state->bits = bits;
#line 1254
    goto while_break___82;
  }
  while_break___82: /* CIL Label */ ;
  }
#line 1255
  if (state->wsize) {
#line 1255
    goto _L___0;
  } else
#line 1255
  if (out != strm->avail_out) {
#line 1255
    if ((unsigned int )state->mode < 16209U) {
#line 1255
      if ((unsigned int )state->mode < 16206U) {
#line 1255
        goto _L___0;
      } else
#line 1255
      if (flush != 4) {
        _L___0: /* CIL Label */ 
        {
#line 1257
        tmp___32 = updatewindow(strm, (unsigned char const   *)strm->next_out, out - strm->avail_out);
        }
#line 1257
        if (tmp___32) {
#line 1258
          state->mode = (inflate_mode )16210;
#line 1259
          return (-4);
        }
      }
    }
  }
#line 1261
  in -= strm->avail_in;
#line 1262
  out -= strm->avail_out;
#line 1263
  strm->total_in += (uLong )in;
#line 1264
  strm->total_out += (uLong )out;
#line 1265
  state->total += (unsigned long )out;
#line 1266
  if (state->wrap & 4) {
#line 1266
    if (out) {
      {
#line 1267
      tmp___33 = adler32(state->check, (Bytef const   *)(strm->next_out - out), out);
#line 1267
      state->check = tmp___33;
#line 1267
      strm->adler = tmp___33;
      }
    }
  }
#line 1269
  if (state->last) {
#line 1269
    tmp___34 = 64;
  } else {
#line 1269
    tmp___34 = 0;
  }
#line 1269
  if ((unsigned int )state->mode == 16191U) {
#line 1269
    tmp___35 = 128;
  } else {
#line 1269
    tmp___35 = 0;
  }
#line 1269
  if ((unsigned int )state->mode == 16199U) {
#line 1269
    tmp___36 = 256;
  } else
#line 1269
  if ((unsigned int )state->mode == 16194U) {
#line 1269
    tmp___36 = 256;
  } else {
#line 1269
    tmp___36 = 0;
  }
#line 1269
  strm->data_type = (((int )state->bits + tmp___34) + tmp___35) + tmp___36;
#line 1272
  if (in == 0U) {
#line 1272
    if (out == 0U) {
#line 1272
      goto _L___1;
    } else {
#line 1272
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1272
  if (flush == 4) {
    _L___1: /* CIL Label */ 
#line 1272
    if (ret == 0) {
#line 1273
      ret = -5;
    }
  }
#line 1274
  return (ret);
}
}
#line 1277 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateEnd(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
  {
#line 1281
  tmp = inflateStateCheck(strm);
  }
#line 1281
  if (tmp) {
#line 1282
    return (-2);
  }
#line 1283
  state = (struct inflate_state *)strm->state;
#line 1284
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
    {
#line 1284
    (*(strm->zfree))(strm->opaque, (voidpf )state->window);
    }
  }
  {
#line 1285
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 1286
  strm->state = (struct internal_state *)0;
  }
#line 1288
  return (0);
}
}
#line 1291 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
  {
#line 1299
  tmp = inflateStateCheck(strm);
  }
#line 1299
  if (tmp) {
#line 1299
    return (-2);
  }
#line 1300
  state = (struct inflate_state *)strm->state;
#line 1303
  if (state->whave) {
#line 1303
    if ((unsigned long )dictionary != (unsigned long )((Bytef *)0)) {
      {
#line 1304
      memcpy((void */* __restrict  */)dictionary, (void const   */* __restrict  */)(state->window + state->wnext),
             (size_t )(state->whave - state->wnext));
#line 1306
      memcpy((void */* __restrict  */)((dictionary + state->whave) - state->wnext),
             (void const   */* __restrict  */)state->window, (size_t )state->wnext);
      }
    }
  }
#line 1309
  if ((unsigned long )dictLength != (unsigned long )((uInt *)0)) {
#line 1310
    *dictLength = state->whave;
  }
#line 1311
  return (0);
}
}
#line 1314 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) 
{ 
  struct inflate_state *state ;
  unsigned long dictid ;
  int ret ;
  int tmp ;

  {
  {
#line 1324
  tmp = inflateStateCheck(strm);
  }
#line 1324
  if (tmp) {
#line 1324
    return (-2);
  }
#line 1325
  state = (struct inflate_state *)strm->state;
#line 1326
  if (state->wrap != 0) {
#line 1326
    if ((unsigned int )state->mode != 16190U) {
#line 1327
      return (-2);
    }
  }
#line 1330
  if ((unsigned int )state->mode == 16190U) {
    {
#line 1331
    dictid = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 1332
    dictid = adler32(dictid, dictionary, dictLength);
    }
#line 1333
    if (dictid != state->check) {
#line 1334
      return (-3);
    }
  }
  {
#line 1339
  ret = updatewindow(strm, dictionary + dictLength, dictLength);
  }
#line 1340
  if (ret) {
#line 1341
    state->mode = (inflate_mode )16210;
#line 1342
    return (-4);
  }
#line 1344
  state->havedict = 1;
#line 1346
  return (0);
}
}
#line 1349 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateGetHeader(z_streamp strm , gz_headerp head ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
  {
#line 1356
  tmp = inflateStateCheck(strm);
  }
#line 1356
  if (tmp) {
#line 1356
    return (-2);
  }
#line 1357
  state = (struct inflate_state *)strm->state;
#line 1358
  if ((state->wrap & 2) == 0) {
#line 1358
    return (-2);
  }
#line 1361
  state->head = head;
#line 1362
  head->done = 0;
#line 1363
  return (0);
}
}
#line 1377 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
static unsigned int syncsearch(unsigned int *have , unsigned char const   *buf , unsigned int len ) 
{ 
  unsigned int got ;
  unsigned int next ;
  int tmp ;

  {
#line 1385
  got = *have;
#line 1386
  next = 0U;
  {
#line 1387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    if (next < len) {
#line 1387
      if (! (got < 4U)) {
#line 1387
        goto while_break;
      }
    } else {
#line 1387
      goto while_break;
    }
#line 1388
    if (got < 2U) {
#line 1388
      tmp = 0;
    } else {
#line 1388
      tmp = 255;
    }
#line 1388
    if ((int )*(buf + next) == tmp) {
#line 1389
      got ++;
    } else
#line 1390
    if (*(buf + next)) {
#line 1391
      got = 0U;
    } else {
#line 1393
      got = 4U - got;
    }
#line 1394
    next ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1396
  *have = got;
#line 1397
  return (next);
}
}
#line 1400 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateSync(z_streamp strm ) 
{ 
  unsigned int len ;
  unsigned long in ;
  unsigned long out ;
  unsigned char buf[4] ;
  struct inflate_state *state ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 1409
  tmp = inflateStateCheck(strm);
  }
#line 1409
  if (tmp) {
#line 1409
    return (-2);
  }
#line 1410
  state = (struct inflate_state *)strm->state;
#line 1411
  if (strm->avail_in == 0U) {
#line 1411
    if (state->bits < 8U) {
#line 1411
      return (-5);
    }
  }
#line 1414
  if ((unsigned int )state->mode != 16211U) {
#line 1415
    state->mode = (inflate_mode )16211;
#line 1416
    state->hold <<= state->bits & 7U;
#line 1417
    state->bits -= state->bits & 7U;
#line 1418
    len = 0U;
    {
#line 1419
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1419
      if (! (state->bits >= 8U)) {
#line 1419
        goto while_break;
      }
#line 1420
      tmp___0 = len;
#line 1420
      len ++;
#line 1420
      buf[tmp___0] = (unsigned char )state->hold;
#line 1421
      state->hold >>= 8;
#line 1422
      state->bits -= 8U;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1424
    state->have = 0U;
#line 1425
    syncsearch(& state->have, (unsigned char const   *)(buf), len);
    }
  }
  {
#line 1429
  len = syncsearch(& state->have, (unsigned char const   *)strm->next_in, strm->avail_in);
#line 1430
  strm->avail_in -= len;
#line 1431
  strm->next_in += len;
#line 1432
  strm->total_in += (uLong )len;
  }
#line 1435
  if (state->have != 4U) {
#line 1435
    return (-3);
  }
  {
#line 1436
  in = strm->total_in;
#line 1436
  out = strm->total_out;
#line 1437
  inflateReset(strm);
#line 1438
  strm->total_in = in;
#line 1438
  strm->total_out = out;
#line 1439
  state->mode = (inflate_mode )16191;
  }
#line 1440
  return (0);
}
}
#line 1451 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateSyncPoint(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1456
  tmp = inflateStateCheck(strm);
  }
#line 1456
  if (tmp) {
#line 1456
    return (-2);
  }
#line 1457
  state = (struct inflate_state *)strm->state;
#line 1458
  if ((unsigned int )state->mode == 16193U) {
#line 1458
    if (state->bits == 0U) {
#line 1458
      tmp___0 = 1;
    } else {
#line 1458
      tmp___0 = 0;
    }
  } else {
#line 1458
    tmp___0 = 0;
  }
#line 1458
  return (tmp___0);
}
}
#line 1461 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateCopy(z_streamp dest , z_streamp source ) 
{ 
  struct inflate_state *state ;
  struct inflate_state *copy ;
  unsigned char *window ;
  unsigned int wsize ;
  int tmp ;
  voidpf tmp___0 ;
  voidpf tmp___1 ;

  {
  {
#line 1471
  tmp = inflateStateCheck(source);
  }
#line 1471
  if (tmp) {
#line 1472
    return (-2);
  } else
#line 1471
  if ((unsigned long )dest == (unsigned long )((z_streamp )0)) {
#line 1472
    return (-2);
  }
  {
#line 1473
  state = (struct inflate_state *)source->state;
#line 1476
  tmp___0 = (*(source->zalloc))(source->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 1476
  copy = (struct inflate_state *)tmp___0;
  }
#line 1478
  if ((unsigned long )copy == (unsigned long )((struct inflate_state *)0)) {
#line 1478
    return (-4);
  }
#line 1479
  window = (unsigned char *)0;
#line 1480
  if ((unsigned long )state->window != (unsigned long )((unsigned char *)0)) {
    {
#line 1481
    tmp___1 = (*(source->zalloc))(source->opaque, 1U << state->wbits, (uInt )sizeof(unsigned char ));
#line 1481
    window = (unsigned char *)tmp___1;
    }
#line 1483
    if ((unsigned long )window == (unsigned long )((unsigned char *)0)) {
      {
#line 1484
      (*(source->zfree))(source->opaque, (voidpf )copy);
      }
#line 1485
      return (-4);
    }
  }
  {
#line 1490
  memcpy((void */* __restrict  */)((voidpf )dest), (void const   */* __restrict  */)((voidpf )source),
         sizeof(z_stream ));
#line 1491
  memcpy((void */* __restrict  */)((voidpf )copy), (void const   */* __restrict  */)((voidpf )state),
         sizeof(struct inflate_state ));
#line 1492
  copy->strm = dest;
  }
#line 1493
  if ((unsigned long )state->lencode >= (unsigned long )(state->codes)) {
#line 1493
    if ((unsigned long )state->lencode <= (unsigned long )((state->codes + 1444) - 1)) {
#line 1495
      copy->lencode = (code const   *)(copy->codes + (state->lencode - (code const   *)(state->codes)));
#line 1496
      copy->distcode = (code const   *)(copy->codes + (state->distcode - (code const   *)(state->codes)));
    }
  }
#line 1498
  copy->next = copy->codes + (state->next - state->codes);
#line 1499
  if ((unsigned long )window != (unsigned long )((unsigned char *)0)) {
    {
#line 1500
    wsize = 1U << state->wbits;
#line 1501
    memcpy((void */* __restrict  */)window, (void const   */* __restrict  */)state->window,
           (size_t )wsize);
    }
  }
#line 1503
  copy->window = window;
#line 1504
  dest->state = (struct internal_state *)copy;
#line 1505
  return (0);
}
}
#line 1508 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateUndermine(z_streamp strm , int subvert ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
  {
#line 1514
  tmp = inflateStateCheck(strm);
  }
#line 1514
  if (tmp) {
#line 1514
    return (-2);
  }
#line 1515
  state = (struct inflate_state *)strm->state;
#line 1521
  state->sane = 1;
#line 1522
  return (-3);
}
}
#line 1526 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
int inflateValidate(z_streamp strm , int check ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
  {
#line 1532
  tmp = inflateStateCheck(strm);
  }
#line 1532
  if (tmp) {
#line 1532
    return (-2);
  }
#line 1533
  state = (struct inflate_state *)strm->state;
#line 1534
  if (check) {
#line 1535
    state->wrap |= 4;
  } else {
#line 1537
    state->wrap &= -5;
  }
#line 1538
  return (0);
}
}
#line 1541 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
long inflateMark(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 1546
  tmp = inflateStateCheck(strm);
  }
#line 1546
  if (tmp) {
#line 1547
    return (- (1L << 16));
  }
#line 1548
  state = (struct inflate_state *)strm->state;
#line 1549
  if ((unsigned int )state->mode == 16195U) {
#line 1549
    tmp___1 = state->length;
  } else {
#line 1549
    if ((unsigned int )state->mode == 16204U) {
#line 1549
      tmp___0 = state->was - state->length;
    } else {
#line 1549
      tmp___0 = 0U;
    }
#line 1549
    tmp___1 = tmp___0;
  }
#line 1549
  return ((long )((unsigned long )((long )state->back) << 16) + (long )tmp___1);
}
}
#line 1554 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inflate.c"
unsigned long inflateCodesUsed(z_streamp strm ) 
{ 
  struct inflate_state *state ;
  int tmp ;

  {
  {
#line 1558
  tmp = inflateStateCheck(strm);
  }
#line 1558
  if (tmp) {
#line 1558
    return (0xffffffffffffffffUL);
  }
#line 1559
  state = (struct inflate_state *)strm->state;
#line 1560
  return ((unsigned long )(state->next - state->codes));
}
}
#line 50 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffast.c"
void __attribute__((__visibility__("hidden")))  inflate_fast(z_streamp strm , unsigned int start ) 
{ 
  struct inflate_state *state ;
  unsigned char *in ;
  unsigned char *last ;
  unsigned char *out ;
  unsigned char *beg ;
  unsigned char *end ;
  unsigned int wsize ;
  unsigned int whave ;
  unsigned int wnext ;
  unsigned char *window ;
  unsigned long hold ;
  unsigned int bits ;
  code const   *lcode ;
  code const   *dcode ;
  unsigned int lmask ;
  unsigned int dmask ;
  code here ;
  unsigned int op ;
  unsigned int len ;
  unsigned int dist ;
  unsigned char *from ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  unsigned char *tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  long tmp___35 ;
  long tmp___36 ;

  {
#line 81
  state = (struct inflate_state *)strm->state;
#line 82
  in = strm->next_in;
#line 83
  last = in + (strm->avail_in - 5U);
#line 84
  out = strm->next_out;
#line 85
  beg = out - (start - strm->avail_out);
#line 86
  end = out + (strm->avail_out - 257U);
#line 90
  wsize = state->wsize;
#line 91
  whave = state->whave;
#line 92
  wnext = state->wnext;
#line 93
  window = state->window;
#line 94
  hold = state->hold;
#line 95
  bits = state->bits;
#line 96
  lcode = state->lencode;
#line 97
  dcode = state->distcode;
#line 98
  lmask = (1U << state->lenbits) - 1U;
#line 99
  dmask = (1U << state->distbits) - 1U;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (bits < 15U) {
#line 105
      tmp = in;
#line 105
      in ++;
#line 105
      hold += (unsigned long )*tmp << bits;
#line 106
      bits += 8U;
#line 107
      tmp___0 = in;
#line 107
      in ++;
#line 107
      hold += (unsigned long )*tmp___0 << bits;
#line 108
      bits += 8U;
    }
#line 110
    here = (code )*(lcode + (hold & (unsigned long )lmask));
    dolen: 
#line 112
    op = (unsigned int )here.bits;
#line 113
    hold >>= op;
#line 114
    bits -= op;
#line 115
    op = (unsigned int )here.op;
#line 116
    if (op == 0U) {
#line 120
      tmp___1 = out;
#line 120
      out ++;
#line 120
      *tmp___1 = (unsigned char )here.val;
    } else
#line 122
    if (op & 16U) {
#line 123
      len = (unsigned int )here.val;
#line 124
      op &= 15U;
#line 125
      if (op) {
#line 126
        if (bits < op) {
#line 127
          tmp___2 = in;
#line 127
          in ++;
#line 127
          hold += (unsigned long )*tmp___2 << bits;
#line 128
          bits += 8U;
        }
#line 130
        len += (unsigned int )hold & ((1U << op) - 1U);
#line 131
        hold >>= op;
#line 132
        bits -= op;
      }
#line 135
      if (bits < 15U) {
#line 136
        tmp___3 = in;
#line 136
        in ++;
#line 136
        hold += (unsigned long )*tmp___3 << bits;
#line 137
        bits += 8U;
#line 138
        tmp___4 = in;
#line 138
        in ++;
#line 138
        hold += (unsigned long )*tmp___4 << bits;
#line 139
        bits += 8U;
      }
#line 141
      here = (code )*(dcode + (hold & (unsigned long )dmask));
      dodist: 
#line 143
      op = (unsigned int )here.bits;
#line 144
      hold >>= op;
#line 145
      bits -= op;
#line 146
      op = (unsigned int )here.op;
#line 147
      if (op & 16U) {
#line 148
        dist = (unsigned int )here.val;
#line 149
        op &= 15U;
#line 150
        if (bits < op) {
#line 151
          tmp___5 = in;
#line 151
          in ++;
#line 151
          hold += (unsigned long )*tmp___5 << bits;
#line 152
          bits += 8U;
#line 153
          if (bits < op) {
#line 154
            tmp___6 = in;
#line 154
            in ++;
#line 154
            hold += (unsigned long )*tmp___6 << bits;
#line 155
            bits += 8U;
          }
        }
#line 158
        dist += (unsigned int )hold & ((1U << op) - 1U);
#line 166
        hold >>= op;
#line 167
        bits -= op;
#line 169
        op = (unsigned int )(out - beg);
#line 170
        if (dist > op) {
#line 171
          op = dist - op;
#line 172
          if (op > whave) {
#line 173
            if (state->sane) {
#line 174
              strm->msg = (char *)"invalid distance too far back";
#line 176
              state->mode = (inflate_mode )16209;
#line 177
              goto while_break;
            }
          }
#line 199
          from = window;
#line 200
          if (wnext == 0U) {
#line 201
            from += wsize - op;
#line 202
            if (op < len) {
#line 203
              len -= op;
              {
#line 204
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 205
                tmp___7 = out;
#line 205
                out ++;
#line 205
                tmp___8 = from;
#line 205
                from ++;
#line 205
                *tmp___7 = *tmp___8;
#line 204
                op --;
#line 204
                if (! op) {
#line 204
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 207
              from = out - dist;
            }
          } else
#line 210
          if (wnext < op) {
#line 211
            from += (wsize + wnext) - op;
#line 212
            op -= wnext;
#line 213
            if (op < len) {
#line 214
              len -= op;
              {
#line 215
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 216
                tmp___9 = out;
#line 216
                out ++;
#line 216
                tmp___10 = from;
#line 216
                from ++;
#line 216
                *tmp___9 = *tmp___10;
#line 215
                op --;
#line 215
                if (! op) {
#line 215
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 218
              from = window;
#line 219
              if (wnext < len) {
#line 220
                op = wnext;
#line 221
                len -= op;
                {
#line 222
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 223
                  tmp___11 = out;
#line 223
                  out ++;
#line 223
                  tmp___12 = from;
#line 223
                  from ++;
#line 223
                  *tmp___11 = *tmp___12;
#line 222
                  op --;
#line 222
                  if (! op) {
#line 222
                    goto while_break___2;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
#line 225
                from = out - dist;
              }
            }
          } else {
#line 230
            from += wnext - op;
#line 231
            if (op < len) {
#line 232
              len -= op;
              {
#line 233
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 234
                tmp___13 = out;
#line 234
                out ++;
#line 234
                tmp___14 = from;
#line 234
                from ++;
#line 234
                *tmp___13 = *tmp___14;
#line 233
                op --;
#line 233
                if (! op) {
#line 233
                  goto while_break___3;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 236
              from = out - dist;
            }
          }
          {
#line 239
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 239
            if (! (len > 2U)) {
#line 239
              goto while_break___4;
            }
#line 240
            tmp___15 = out;
#line 240
            out ++;
#line 240
            tmp___16 = from;
#line 240
            from ++;
#line 240
            *tmp___15 = *tmp___16;
#line 241
            tmp___17 = out;
#line 241
            out ++;
#line 241
            tmp___18 = from;
#line 241
            from ++;
#line 241
            *tmp___17 = *tmp___18;
#line 242
            tmp___19 = out;
#line 242
            out ++;
#line 242
            tmp___20 = from;
#line 242
            from ++;
#line 242
            *tmp___19 = *tmp___20;
#line 243
            len -= 3U;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 245
          if (len) {
#line 246
            tmp___21 = out;
#line 246
            out ++;
#line 246
            tmp___22 = from;
#line 246
            from ++;
#line 246
            *tmp___21 = *tmp___22;
#line 247
            if (len > 1U) {
#line 248
              tmp___23 = out;
#line 248
              out ++;
#line 248
              tmp___24 = from;
#line 248
              from ++;
#line 248
              *tmp___23 = *tmp___24;
            }
          }
        } else {
#line 252
          from = out - dist;
          {
#line 253
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 254
            tmp___25 = out;
#line 254
            out ++;
#line 254
            tmp___26 = from;
#line 254
            from ++;
#line 254
            *tmp___25 = *tmp___26;
#line 255
            tmp___27 = out;
#line 255
            out ++;
#line 255
            tmp___28 = from;
#line 255
            from ++;
#line 255
            *tmp___27 = *tmp___28;
#line 256
            tmp___29 = out;
#line 256
            out ++;
#line 256
            tmp___30 = from;
#line 256
            from ++;
#line 256
            *tmp___29 = *tmp___30;
#line 257
            len -= 3U;
#line 253
            if (! (len > 2U)) {
#line 253
              goto while_break___5;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 259
          if (len) {
#line 260
            tmp___31 = out;
#line 260
            out ++;
#line 260
            tmp___32 = from;
#line 260
            from ++;
#line 260
            *tmp___31 = *tmp___32;
#line 261
            if (len > 1U) {
#line 262
              tmp___33 = out;
#line 262
              out ++;
#line 262
              tmp___34 = from;
#line 262
              from ++;
#line 262
              *tmp___33 = *tmp___34;
            }
          }
        }
      } else
#line 266
      if ((op & 64U) == 0U) {
#line 267
        here = (code )*(dcode + ((unsigned long )here.val + (hold & (unsigned long )((1U << op) - 1U))));
#line 268
        goto dodist;
      } else {
#line 271
        strm->msg = (char *)"invalid distance code";
#line 272
        state->mode = (inflate_mode )16209;
#line 273
        goto while_break;
      }
    } else
#line 276
    if ((op & 64U) == 0U) {
#line 277
      here = (code )*(lcode + ((unsigned long )here.val + (hold & (unsigned long )((1U << op) - 1U))));
#line 278
      goto dolen;
    } else
#line 280
    if (op & 32U) {
#line 282
      state->mode = (inflate_mode )16191;
#line 283
      goto while_break;
    } else {
#line 286
      strm->msg = (char *)"invalid literal/length code";
#line 287
      state->mode = (inflate_mode )16209;
#line 288
      goto while_break;
    }
#line 103
    if ((unsigned long )in < (unsigned long )last) {
#line 103
      if (! ((unsigned long )out < (unsigned long )end)) {
#line 103
        goto while_break;
      }
    } else {
#line 103
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  len = bits >> 3;
#line 294
  in -= len;
#line 295
  bits -= len << 3;
#line 296
  hold &= (unsigned long )((1U << bits) - 1U);
#line 299
  strm->next_in = in;
#line 300
  strm->next_out = out;
#line 301
  if ((unsigned long )in < (unsigned long )last) {
#line 301
    tmp___35 = 5L + (last - in);
  } else {
#line 301
    tmp___35 = 5L - (in - last);
  }
#line 301
  strm->avail_in = (unsigned int )tmp___35;
#line 302
  if ((unsigned long )out < (unsigned long )end) {
#line 302
    tmp___36 = 257L + (end - out);
  } else {
#line 302
    tmp___36 = 257L - (out - end);
  }
#line 302
  strm->avail_out = (unsigned int )tmp___36;
#line 304
  state->hold = hold;
#line 305
  state->bits = bits;
#line 306
  return;
}
}
#line 1114 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                void *out_desc ) ;
#line 1184
int inflateBackEnd(z_streamp strm ) ;
#line 1792
int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window , char const   *version ,
                     int stream_size ) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/infback.c"
static void fixedtables___0(struct inflate_state *state ) ;
#line 28 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/infback.c"
int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window , char const   *version ,
                     int stream_size ) 
{ 
  struct inflate_state *state ;
  voidpf tmp ;

  {
#line 37
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 39
    return (-6);
  } else
#line 37
  if ((int const   )*(version + 0) != (int const   )*("1.2.11-optipng" + 0)) {
#line 39
    return (-6);
  } else
#line 37
  if (stream_size != (int )sizeof(z_stream )) {
#line 39
    return (-6);
  }
#line 40
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 42
    return (-2);
  } else
#line 40
  if ((unsigned long )window == (unsigned long )((unsigned char *)0)) {
#line 42
    return (-2);
  } else
#line 40
  if (windowBits < 8) {
#line 42
    return (-2);
  } else
#line 40
  if (windowBits > 15) {
#line 42
    return (-2);
  }
#line 43
  strm->msg = (char *)0;
#line 44
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 48
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& zcalloc);
#line 49
    strm->opaque = (voidpf )0;
  }
#line 52
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 56
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))(& zcfree);
  }
  {
#line 58
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(struct inflate_state ));
#line 58
  state = (struct inflate_state *)tmp;
  }
#line 60
  if ((unsigned long )state == (unsigned long )((struct inflate_state *)0)) {
#line 60
    return (-4);
  }
#line 62
  strm->state = (struct internal_state *)state;
#line 63
  state->dmax = 32768U;
#line 64
  state->wbits = (uInt )windowBits;
#line 65
  state->wsize = 1U << windowBits;
#line 66
  state->window = window;
#line 67
  state->wnext = 0U;
#line 68
  state->whave = 0U;
#line 69
  return (0);
}
}
#line 10 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffixed.h"
static code const   lenfix___0[512]  = 
#line 10 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffixed.h"
  {      {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)192}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)160}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)224}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)144}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)208}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)176}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)240}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)200}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)168}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)232}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)152}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)216}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)184}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)248}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)196}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)164}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)228}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)148}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)212}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)180}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)244}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)204}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)172}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)236}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)156}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)220}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)188}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)252}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)194}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)162}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)226}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)146}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)210}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)178}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)242}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)202}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)170}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)234}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)154}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)218}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)186}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)250}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)198}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)166}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)230}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)150}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)214}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)182}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)246}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)206}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)174}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)238}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)158}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)222}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)190}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)254}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)80}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)16}, 
        {(unsigned char)20, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)112}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)48}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)193}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)96}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)32}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)161}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)128}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)64}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)225}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)88}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)24}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)145}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)120}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)56}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)209}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)104}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)40}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)177}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)136}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)72}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)241}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)84}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)20}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)227}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)116}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)52}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)201}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)100}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)36}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)169}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)132}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)68}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)233}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)92}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)28}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)153}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)124}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)60}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)217}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)108}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)44}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)185}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)12}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)140}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)76}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)249}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)82}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)18}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)163}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)114}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)50}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)197}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)98}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)34}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)165}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)2}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)130}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)66}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)229}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)90}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)26}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)149}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)122}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)58}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)213}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)106}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)42}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)181}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)138}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)74}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)245}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)86}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)22}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)118}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)54}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)205}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)102}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)38}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)173}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)134}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)70}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)237}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)94}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)30}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)157}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)126}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)62}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)221}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)110}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)46}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)189}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)14}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)142}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)78}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)253}, 
        {(unsigned char)96, (unsigned char)7, (unsigned short)0}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)81}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)17}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)113}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)49}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)195}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)10}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)97}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)33}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)163}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)1}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)129}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)65}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)227}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)6}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)89}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)25}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)147}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)121}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)57}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)211}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)17}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)105}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)41}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)179}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)137}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)73}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)243}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)4}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)85}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)21}, 
        {(unsigned char)16, (unsigned char)8, (unsigned short)258}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)117}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)53}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)203}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)101}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)37}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)171}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)133}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)69}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)235}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)8}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)93}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)29}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)155}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)125}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)61}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)219}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)23}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)109}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)45}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)187}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)13}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)141}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)77}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)251}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)83}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)19}, 
        {(unsigned char)21, (unsigned char)8, (unsigned short)195}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)115}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)199}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)35}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)167}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)3}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)131}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)231}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)91}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)151}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)67}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)123}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)59}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)215}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)19}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)107}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)43}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)183}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)11}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)139}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)75}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)247}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)5}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)87}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)23}, 
        {(unsigned char)64, (unsigned char)8, (unsigned short)0}, 
        {(unsigned char)19, (unsigned char)7, (unsigned short)51}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)119}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)55}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)207}, 
        {(unsigned char)17, (unsigned char)7, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)103}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)39}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)175}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)7}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)135}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)71}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)239}, 
        {(unsigned char)16, (unsigned char)7, (unsigned short)9}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)95}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)31}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)159}, 
        {(unsigned char)20, (unsigned char)7, (unsigned short)99}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)127}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)63}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)223}, 
        {(unsigned char)18, (unsigned char)7, (unsigned short)27}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)111}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)47}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)191}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)15}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)143}, 
        {(unsigned char)0, (unsigned char)8, (unsigned short)79}, 
        {(unsigned char)0, (unsigned char)9, (unsigned short)255}};
#line 87 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/inffixed.h"
static code const   distfix___0[32]  = 
#line 87
  {      {(unsigned char)16, (unsigned char)5, (unsigned short)1}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)257}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)17}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)4097}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)5}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1025}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)65}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)16385}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)3}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)513}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)33}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)8193}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)9}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)2049}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)129}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)2}, 
        {(unsigned char)23, (unsigned char)5, (unsigned short)385}, 
        {(unsigned char)19, (unsigned char)5, (unsigned short)25}, 
        {(unsigned char)27, (unsigned char)5, (unsigned short)6145}, 
        {(unsigned char)17, (unsigned char)5, (unsigned short)7}, 
        {(unsigned char)25, (unsigned char)5, (unsigned short)1537}, 
        {(unsigned char)21, (unsigned char)5, (unsigned short)97}, 
        {(unsigned char)29, (unsigned char)5, (unsigned short)24577}, 
        {(unsigned char)16, (unsigned char)5, (unsigned short)4}, 
        {(unsigned char)24, (unsigned char)5, (unsigned short)769}, 
        {(unsigned char)20, (unsigned char)5, (unsigned short)49}, 
        {(unsigned char)28, (unsigned char)5, (unsigned short)12289}, 
        {(unsigned char)18, (unsigned char)5, (unsigned short)13}, 
        {(unsigned char)26, (unsigned char)5, (unsigned short)3073}, 
        {(unsigned char)22, (unsigned char)5, (unsigned short)193}, 
        {(unsigned char)64, (unsigned char)5, (unsigned short)0}};
#line 82 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/infback.c"
static void fixedtables___0(struct inflate_state *state ) 
{ 


  {
#line 119
  state->lencode = lenfix___0;
#line 120
  state->lenbits = 9U;
#line 121
  state->distcode = distfix___0;
#line 122
  state->distbits = 5U;
#line 123
  return;
}
}
#line 269 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/infback.c"
static unsigned short const   order___0[19]  = 
#line 269
  {      (unsigned short const   )16,      (unsigned short const   )17,      (unsigned short const   )18,      (unsigned short const   )0, 
        (unsigned short const   )8,      (unsigned short const   )7,      (unsigned short const   )9,      (unsigned short const   )6, 
        (unsigned short const   )10,      (unsigned short const   )5,      (unsigned short const   )11,      (unsigned short const   )4, 
        (unsigned short const   )12,      (unsigned short const   )3,      (unsigned short const   )13,      (unsigned short const   )2, 
        (unsigned short const   )14,      (unsigned short const   )1,      (unsigned short const   )15};
#line 250 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/infback.c"
int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                void *out_desc ) 
{ 
  struct inflate_state *state ;
  unsigned char *next ;
  unsigned char *put ;
  unsigned int have ;
  unsigned int left ;
  unsigned long hold ;
  unsigned int bits ;
  unsigned int copy ;
  unsigned char *from ;
  code here ;
  code last ;
  unsigned int len ;
  int ret ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int __attribute__((__visibility__("hidden")))  tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned int tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  int __attribute__((__visibility__("hidden")))  tmp___14 ;
  int __attribute__((__visibility__("hidden")))  tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  unsigned char *tmp___26 ;
  unsigned char *tmp___27 ;
  int tmp___28 ;

  {
#line 273
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 274
    return (-2);
  } else
#line 273
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 274
    return (-2);
  }
#line 275
  state = (struct inflate_state *)strm->state;
#line 278
  strm->msg = (char *)0;
#line 279
  state->mode = (inflate_mode )16191;
#line 280
  state->last = 0;
#line 281
  state->whave = 0U;
#line 282
  next = strm->next_in;
#line 283
  if ((unsigned long )next != (unsigned long )((unsigned char *)0)) {
#line 283
    have = strm->avail_in;
  } else {
#line 283
    have = 0U;
  }
#line 284
  hold = 0UL;
#line 285
  bits = 0U;
#line 286
  put = state->window;
#line 287
  left = state->wsize;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 292
    if ((unsigned int )state->mode == 16191U) {
#line 292
      goto case_16191;
    }
#line 326
    if ((unsigned int )state->mode == 16193U) {
#line 326
      goto case_16193;
    }
#line 358
    if ((unsigned int )state->mode == 16196U) {
#line 358
      goto case_16196;
    }
#line 481
    if ((unsigned int )state->mode == 16200U) {
#line 481
      goto case_16200;
    }
#line 606
    if ((unsigned int )state->mode == 16208U) {
#line 606
      goto case_16208;
    }
#line 615
    if ((unsigned int )state->mode == 16209U) {
#line 615
      goto case_16209;
    }
#line 619
    goto switch_default;
    case_16191: /* CIL Label */ 
#line 294
    if (state->last) {
      {
#line 295
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 295
        hold >>= bits & 7U;
#line 295
        bits -= bits & 7U;
#line 295
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 296
      state->mode = (inflate_mode )16208;
#line 297
      goto switch_break;
    }
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 299
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 299
        if (! (bits < 3U)) {
#line 299
          goto while_break___2;
        }
        {
#line 299
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 299
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 299
            if (have == 0U) {
              {
#line 299
              have = (*in)(in_desc, & next);
              }
#line 299
              if (have == 0U) {
#line 299
                next = (unsigned char *)0;
#line 299
                ret = -5;
#line 299
                goto inf_leave;
              }
            }
#line 299
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 299
          have --;
#line 299
          tmp = next;
#line 299
          next ++;
#line 299
          hold += (unsigned long )*tmp << bits;
#line 299
          bits += 8U;
#line 299
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 299
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 300
    state->last = (int )((unsigned int )hold & ((1U << 1) - 1U));
    {
#line 301
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 301
      hold >>= 1;
#line 301
      bits --;
#line 301
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 303
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 0U) {
#line 303
      goto case_0;
    }
#line 308
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 1U) {
#line 308
      goto case_1;
    }
#line 314
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 2U) {
#line 314
      goto case_2;
    }
#line 319
    if (((unsigned int )hold & ((1U << 2) - 1U)) == 3U) {
#line 319
      goto case_3;
    }
#line 302
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 306
    state->mode = (inflate_mode )16193;
#line 307
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 309
    fixedtables___0(state);
#line 312
    state->mode = (inflate_mode )16200;
    }
#line 313
    goto switch_break___0;
    case_2: /* CIL Label */ 
#line 317
    state->mode = (inflate_mode )16196;
#line 318
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 320
    strm->msg = (char *)"invalid block type";
#line 321
    state->mode = (inflate_mode )16209;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 323
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 323
      hold >>= 2;
#line 323
      bits -= 2U;
#line 323
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 324
    goto switch_break;
    case_16193: /* CIL Label */ 
    {
#line 328
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 328
      hold >>= bits & 7U;
#line 328
      bits -= bits & 7U;
#line 328
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 329
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 329
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 329
        if (! (bits < 32U)) {
#line 329
          goto while_break___9;
        }
        {
#line 329
        while (1) {
          while_continue___10: /* CIL Label */ ;
          {
#line 329
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 329
            if (have == 0U) {
              {
#line 329
              have = (*in)(in_desc, & next);
              }
#line 329
              if (have == 0U) {
#line 329
                next = (unsigned char *)0;
#line 329
                ret = -5;
#line 329
                goto inf_leave;
              }
            }
#line 329
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 329
          have --;
#line 329
          tmp___0 = next;
#line 329
          next ++;
#line 329
          hold += (unsigned long )*tmp___0 << bits;
#line 329
          bits += 8U;
#line 329
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 329
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 330
    if ((hold & 65535UL) != ((hold >> 16) ^ 65535UL)) {
#line 331
      strm->msg = (char *)"invalid stored block lengths";
#line 332
      state->mode = (inflate_mode )16209;
#line 333
      goto switch_break;
    }
#line 335
    state->length = (unsigned int )hold & 65535U;
    {
#line 338
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 338
      hold = 0UL;
#line 338
      bits = 0U;
#line 338
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 341
      if (! (state->length != 0U)) {
#line 341
        goto while_break___13;
      }
#line 342
      copy = state->length;
      {
#line 343
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 343
        if (have == 0U) {
          {
#line 343
          have = (*in)(in_desc, & next);
          }
#line 343
          if (have == 0U) {
#line 343
            next = (unsigned char *)0;
#line 343
            ret = -5;
#line 343
            goto inf_leave;
          }
        }
#line 343
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 344
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 344
        if (left == 0U) {
          {
#line 344
          put = state->window;
#line 344
          left = state->wsize;
#line 344
          state->whave = left;
#line 344
          tmp___1 = (*out)(out_desc, put, left);
          }
#line 344
          if (tmp___1) {
#line 344
            ret = -5;
#line 344
            goto inf_leave;
          }
        }
#line 344
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
#line 345
      if (copy > have) {
#line 345
        copy = have;
      }
#line 346
      if (copy > left) {
#line 346
        copy = left;
      }
      {
#line 347
      memcpy((void */* __restrict  */)put, (void const   */* __restrict  */)next,
             (size_t )copy);
#line 348
      have -= copy;
#line 349
      next += copy;
#line 350
      left -= copy;
#line 351
      put += copy;
#line 352
      state->length -= copy;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 355
    state->mode = (inflate_mode )16191;
#line 356
    goto switch_break;
    case_16196: /* CIL Label */ 
    {
#line 360
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 360
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 360
        if (! (bits < 14U)) {
#line 360
          goto while_break___17;
        }
        {
#line 360
        while (1) {
          while_continue___18: /* CIL Label */ ;
          {
#line 360
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 360
            if (have == 0U) {
              {
#line 360
              have = (*in)(in_desc, & next);
              }
#line 360
              if (have == 0U) {
#line 360
                next = (unsigned char *)0;
#line 360
                ret = -5;
#line 360
                goto inf_leave;
              }
            }
#line 360
            goto while_break___19;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 360
          have --;
#line 360
          tmp___2 = next;
#line 360
          next ++;
#line 360
          hold += (unsigned long )*tmp___2 << bits;
#line 360
          bits += 8U;
#line 360
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 360
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 361
    state->nlen = ((unsigned int )hold & ((1U << 5) - 1U)) + 257U;
    {
#line 362
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 362
      hold >>= 5;
#line 362
      bits -= 5U;
#line 362
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 363
    state->ndist = ((unsigned int )hold & ((1U << 5) - 1U)) + 1U;
    {
#line 364
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 364
      hold >>= 5;
#line 364
      bits -= 5U;
#line 364
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 365
    state->ncode = ((unsigned int )hold & ((1U << 4) - 1U)) + 4U;
    {
#line 366
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 366
      hold >>= 4;
#line 366
      bits -= 4U;
#line 366
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 368
    if (state->nlen > 286U) {
#line 369
      strm->msg = (char *)"too many length or distance symbols";
#line 370
      state->mode = (inflate_mode )16209;
#line 371
      goto switch_break;
    } else
#line 368
    if (state->ndist > 30U) {
#line 369
      strm->msg = (char *)"too many length or distance symbols";
#line 370
      state->mode = (inflate_mode )16209;
#line 371
      goto switch_break;
    }
#line 377
    state->have = 0U;
    {
#line 378
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 378
      if (! (state->have < state->ncode)) {
#line 378
        goto while_break___23;
      }
      {
#line 379
      while (1) {
        while_continue___24: /* CIL Label */ ;
        {
#line 379
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 379
          if (! (bits < 3U)) {
#line 379
            goto while_break___25;
          }
          {
#line 379
          while (1) {
            while_continue___26: /* CIL Label */ ;
            {
#line 379
            while (1) {
              while_continue___27: /* CIL Label */ ;
#line 379
              if (have == 0U) {
                {
#line 379
                have = (*in)(in_desc, & next);
                }
#line 379
                if (have == 0U) {
#line 379
                  next = (unsigned char *)0;
#line 379
                  ret = -5;
#line 379
                  goto inf_leave;
                }
              }
#line 379
              goto while_break___27;
            }
            while_break___27: /* CIL Label */ ;
            }
#line 379
            have --;
#line 379
            tmp___3 = next;
#line 379
            next ++;
#line 379
            hold += (unsigned long )*tmp___3 << bits;
#line 379
            bits += 8U;
#line 379
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
#line 379
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 380
      tmp___4 = state->have;
#line 380
      (state->have) ++;
#line 380
      state->lens[order___0[tmp___4]] = (unsigned short )((unsigned int )hold & ((1U << 3) - 1U));
      {
#line 381
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 381
        hold >>= 3;
#line 381
        bits -= 3U;
#line 381
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 383
      if (! (state->have < 19U)) {
#line 383
        goto while_break___29;
      }
#line 384
      tmp___5 = state->have;
#line 384
      (state->have) ++;
#line 384
      state->lens[order___0[tmp___5]] = (unsigned short)0;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 385
    state->next = state->codes;
#line 386
    state->lencode = (code const   *)state->next;
#line 387
    state->lenbits = 7U;
#line 388
    tmp___6 = inflate_table((codetype )0, state->lens, 19U, & state->next, & state->lenbits,
                            state->work);
#line 388
    ret = (int )tmp___6;
    }
#line 390
    if (ret) {
#line 391
      strm->msg = (char *)"invalid code lengths set";
#line 392
      state->mode = (inflate_mode )16209;
#line 393
      goto switch_break;
    }
#line 398
    state->have = 0U;
    {
#line 399
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 399
      if (! (state->have < state->nlen + state->ndist)) {
#line 399
        goto while_break___30;
      }
      {
#line 400
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 401
        here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 402
        if ((unsigned int )here.bits <= bits) {
#line 402
          goto while_break___31;
        }
        {
#line 403
        while (1) {
          while_continue___32: /* CIL Label */ ;
          {
#line 403
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 403
            if (have == 0U) {
              {
#line 403
              have = (*in)(in_desc, & next);
              }
#line 403
              if (have == 0U) {
#line 403
                next = (unsigned char *)0;
#line 403
                ret = -5;
#line 403
                goto inf_leave;
              }
            }
#line 403
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 403
          have --;
#line 403
          tmp___7 = next;
#line 403
          next ++;
#line 403
          hold += (unsigned long )*tmp___7 << bits;
#line 403
          bits += 8U;
#line 403
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
      }
      while_break___31: /* CIL Label */ ;
      }
#line 405
      if ((int )here.val < 16) {
        {
#line 406
        while (1) {
          while_continue___34: /* CIL Label */ ;
#line 406
          hold >>= (int )here.bits;
#line 406
          bits -= (unsigned int )here.bits;
#line 406
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
#line 407
        tmp___8 = state->have;
#line 407
        (state->have) ++;
#line 407
        state->lens[tmp___8] = here.val;
      } else {
#line 410
        if ((int )here.val == 16) {
          {
#line 411
          while (1) {
            while_continue___35: /* CIL Label */ ;
            {
#line 411
            while (1) {
              while_continue___36: /* CIL Label */ ;
#line 411
              if (! (bits < (unsigned int )((int )here.bits + 2))) {
#line 411
                goto while_break___36;
              }
              {
#line 411
              while (1) {
                while_continue___37: /* CIL Label */ ;
                {
#line 411
                while (1) {
                  while_continue___38: /* CIL Label */ ;
#line 411
                  if (have == 0U) {
                    {
#line 411
                    have = (*in)(in_desc, & next);
                    }
#line 411
                    if (have == 0U) {
#line 411
                      next = (unsigned char *)0;
#line 411
                      ret = -5;
#line 411
                      goto inf_leave;
                    }
                  }
#line 411
                  goto while_break___38;
                }
                while_break___38: /* CIL Label */ ;
                }
#line 411
                have --;
#line 411
                tmp___9 = next;
#line 411
                next ++;
#line 411
                hold += (unsigned long )*tmp___9 << bits;
#line 411
                bits += 8U;
#line 411
                goto while_break___37;
              }
              while_break___37: /* CIL Label */ ;
              }
            }
            while_break___36: /* CIL Label */ ;
            }
#line 411
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 412
          while (1) {
            while_continue___39: /* CIL Label */ ;
#line 412
            hold >>= (int )here.bits;
#line 412
            bits -= (unsigned int )here.bits;
#line 412
            goto while_break___39;
          }
          while_break___39: /* CIL Label */ ;
          }
#line 413
          if (state->have == 0U) {
#line 414
            strm->msg = (char *)"invalid bit length repeat";
#line 415
            state->mode = (inflate_mode )16209;
#line 416
            goto while_break___30;
          }
#line 418
          len = (unsigned int )state->lens[state->have - 1U];
#line 419
          copy = 3U + ((unsigned int )hold & ((1U << 2) - 1U));
          {
#line 420
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 420
            hold >>= 2;
#line 420
            bits -= 2U;
#line 420
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
        } else
#line 422
        if ((int )here.val == 17) {
          {
#line 423
          while (1) {
            while_continue___41: /* CIL Label */ ;
            {
#line 423
            while (1) {
              while_continue___42: /* CIL Label */ ;
#line 423
              if (! (bits < (unsigned int )((int )here.bits + 3))) {
#line 423
                goto while_break___42;
              }
              {
#line 423
              while (1) {
                while_continue___43: /* CIL Label */ ;
                {
#line 423
                while (1) {
                  while_continue___44: /* CIL Label */ ;
#line 423
                  if (have == 0U) {
                    {
#line 423
                    have = (*in)(in_desc, & next);
                    }
#line 423
                    if (have == 0U) {
#line 423
                      next = (unsigned char *)0;
#line 423
                      ret = -5;
#line 423
                      goto inf_leave;
                    }
                  }
#line 423
                  goto while_break___44;
                }
                while_break___44: /* CIL Label */ ;
                }
#line 423
                have --;
#line 423
                tmp___10 = next;
#line 423
                next ++;
#line 423
                hold += (unsigned long )*tmp___10 << bits;
#line 423
                bits += 8U;
#line 423
                goto while_break___43;
              }
              while_break___43: /* CIL Label */ ;
              }
            }
            while_break___42: /* CIL Label */ ;
            }
#line 423
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
          {
#line 424
          while (1) {
            while_continue___45: /* CIL Label */ ;
#line 424
            hold >>= (int )here.bits;
#line 424
            bits -= (unsigned int )here.bits;
#line 424
            goto while_break___45;
          }
          while_break___45: /* CIL Label */ ;
          }
#line 425
          len = 0U;
#line 426
          copy = 3U + ((unsigned int )hold & ((1U << 3) - 1U));
          {
#line 427
          while (1) {
            while_continue___46: /* CIL Label */ ;
#line 427
            hold >>= 3;
#line 427
            bits -= 3U;
#line 427
            goto while_break___46;
          }
          while_break___46: /* CIL Label */ ;
          }
        } else {
          {
#line 430
          while (1) {
            while_continue___47: /* CIL Label */ ;
            {
#line 430
            while (1) {
              while_continue___48: /* CIL Label */ ;
#line 430
              if (! (bits < (unsigned int )((int )here.bits + 7))) {
#line 430
                goto while_break___48;
              }
              {
#line 430
              while (1) {
                while_continue___49: /* CIL Label */ ;
                {
#line 430
                while (1) {
                  while_continue___50: /* CIL Label */ ;
#line 430
                  if (have == 0U) {
                    {
#line 430
                    have = (*in)(in_desc, & next);
                    }
#line 430
                    if (have == 0U) {
#line 430
                      next = (unsigned char *)0;
#line 430
                      ret = -5;
#line 430
                      goto inf_leave;
                    }
                  }
#line 430
                  goto while_break___50;
                }
                while_break___50: /* CIL Label */ ;
                }
#line 430
                have --;
#line 430
                tmp___11 = next;
#line 430
                next ++;
#line 430
                hold += (unsigned long )*tmp___11 << bits;
#line 430
                bits += 8U;
#line 430
                goto while_break___49;
              }
              while_break___49: /* CIL Label */ ;
              }
            }
            while_break___48: /* CIL Label */ ;
            }
#line 430
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
          {
#line 431
          while (1) {
            while_continue___51: /* CIL Label */ ;
#line 431
            hold >>= (int )here.bits;
#line 431
            bits -= (unsigned int )here.bits;
#line 431
            goto while_break___51;
          }
          while_break___51: /* CIL Label */ ;
          }
#line 432
          len = 0U;
#line 433
          copy = 11U + ((unsigned int )hold & ((1U << 7) - 1U));
          {
#line 434
          while (1) {
            while_continue___52: /* CIL Label */ ;
#line 434
            hold >>= 7;
#line 434
            bits -= 7U;
#line 434
            goto while_break___52;
          }
          while_break___52: /* CIL Label */ ;
          }
        }
#line 436
        if (state->have + copy > state->nlen + state->ndist) {
#line 437
          strm->msg = (char *)"invalid bit length repeat";
#line 438
          state->mode = (inflate_mode )16209;
#line 439
          goto while_break___30;
        }
        {
#line 441
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 441
          tmp___13 = copy;
#line 441
          copy --;
#line 441
          if (! tmp___13) {
#line 441
            goto while_break___53;
          }
#line 442
          tmp___12 = state->have;
#line 442
          (state->have) ++;
#line 442
          state->lens[tmp___12] = (unsigned short )len;
        }
        while_break___53: /* CIL Label */ ;
        }
      }
    }
    while_break___30: /* CIL Label */ ;
    }
#line 447
    if ((unsigned int )state->mode == 16209U) {
#line 447
      goto switch_break;
    }
#line 450
    if ((int )state->lens[256] == 0) {
#line 451
      strm->msg = (char *)"invalid code -- missing end-of-block";
#line 452
      state->mode = (inflate_mode )16209;
#line 453
      goto switch_break;
    }
    {
#line 459
    state->next = state->codes;
#line 460
    state->lencode = (code const   *)state->next;
#line 461
    state->lenbits = 9U;
#line 462
    tmp___14 = inflate_table((codetype )1, state->lens, state->nlen, & state->next,
                             & state->lenbits, state->work);
#line 462
    ret = (int )tmp___14;
    }
#line 464
    if (ret) {
#line 465
      strm->msg = (char *)"invalid literal/lengths set";
#line 466
      state->mode = (inflate_mode )16209;
#line 467
      goto switch_break;
    }
    {
#line 469
    state->distcode = (code const   *)state->next;
#line 470
    state->distbits = 6U;
#line 471
    tmp___15 = inflate_table((codetype )2, state->lens + state->nlen, state->ndist,
                             & state->next, & state->distbits, state->work);
#line 471
    ret = (int )tmp___15;
    }
#line 473
    if (ret) {
#line 474
      strm->msg = (char *)"invalid distances set";
#line 475
      state->mode = (inflate_mode )16209;
#line 476
      goto switch_break;
    }
#line 479
    state->mode = (inflate_mode )16200;
    case_16200: /* CIL Label */ 
#line 483
    if (have >= 6U) {
#line 483
      if (left >= 258U) {
        {
#line 484
        while (1) {
          while_continue___54: /* CIL Label */ ;
#line 484
          strm->next_out = put;
#line 484
          strm->avail_out = left;
#line 484
          strm->next_in = next;
#line 484
          strm->avail_in = have;
#line 484
          state->hold = hold;
#line 484
          state->bits = bits;
#line 484
          goto while_break___54;
        }
        while_break___54: /* CIL Label */ ;
        }
#line 485
        if (state->whave < state->wsize) {
#line 486
          state->whave = state->wsize - left;
        }
        {
#line 487
        inflate_fast(strm, state->wsize);
        }
        {
#line 488
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 488
          put = strm->next_out;
#line 488
          left = strm->avail_out;
#line 488
          next = strm->next_in;
#line 488
          have = strm->avail_in;
#line 488
          hold = state->hold;
#line 488
          bits = state->bits;
#line 488
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
#line 489
        goto switch_break;
      }
    }
    {
#line 493
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 494
      here = (code )*(state->lencode + ((unsigned int )hold & ((1U << state->lenbits) - 1U)));
#line 495
      if ((unsigned int )here.bits <= bits) {
#line 495
        goto while_break___56;
      }
      {
#line 496
      while (1) {
        while_continue___57: /* CIL Label */ ;
        {
#line 496
        while (1) {
          while_continue___58: /* CIL Label */ ;
#line 496
          if (have == 0U) {
            {
#line 496
            have = (*in)(in_desc, & next);
            }
#line 496
            if (have == 0U) {
#line 496
              next = (unsigned char *)0;
#line 496
              ret = -5;
#line 496
              goto inf_leave;
            }
          }
#line 496
          goto while_break___58;
        }
        while_break___58: /* CIL Label */ ;
        }
#line 496
        have --;
#line 496
        tmp___16 = next;
#line 496
        next ++;
#line 496
        hold += (unsigned long )*tmp___16 << bits;
#line 496
        bits += 8U;
#line 496
        goto while_break___57;
      }
      while_break___57: /* CIL Label */ ;
      }
    }
    while_break___56: /* CIL Label */ ;
    }
#line 498
    if (here.op) {
#line 498
      if (((int )here.op & 240) == 0) {
#line 499
        last = here;
        {
#line 500
        while (1) {
          while_continue___59: /* CIL Label */ ;
#line 501
          here = (code )*(state->lencode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 503
          if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 503
            goto while_break___59;
          }
          {
#line 504
          while (1) {
            while_continue___60: /* CIL Label */ ;
            {
#line 504
            while (1) {
              while_continue___61: /* CIL Label */ ;
#line 504
              if (have == 0U) {
                {
#line 504
                have = (*in)(in_desc, & next);
                }
#line 504
                if (have == 0U) {
#line 504
                  next = (unsigned char *)0;
#line 504
                  ret = -5;
#line 504
                  goto inf_leave;
                }
              }
#line 504
              goto while_break___61;
            }
            while_break___61: /* CIL Label */ ;
            }
#line 504
            have --;
#line 504
            tmp___17 = next;
#line 504
            next ++;
#line 504
            hold += (unsigned long )*tmp___17 << bits;
#line 504
            bits += 8U;
#line 504
            goto while_break___60;
          }
          while_break___60: /* CIL Label */ ;
          }
        }
        while_break___59: /* CIL Label */ ;
        }
        {
#line 506
        while (1) {
          while_continue___62: /* CIL Label */ ;
#line 506
          hold >>= (int )last.bits;
#line 506
          bits -= (unsigned int )last.bits;
#line 506
          goto while_break___62;
        }
        while_break___62: /* CIL Label */ ;
        }
      }
    }
    {
#line 508
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 508
      hold >>= (int )here.bits;
#line 508
      bits -= (unsigned int )here.bits;
#line 508
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 509
    state->length = (unsigned int )here.val;
#line 512
    if ((int )here.op == 0) {
      {
#line 516
      while (1) {
        while_continue___64: /* CIL Label */ ;
#line 516
        if (left == 0U) {
          {
#line 516
          put = state->window;
#line 516
          left = state->wsize;
#line 516
          state->whave = left;
#line 516
          tmp___18 = (*out)(out_desc, put, left);
          }
#line 516
          if (tmp___18) {
#line 516
            ret = -5;
#line 516
            goto inf_leave;
          }
        }
#line 516
        goto while_break___64;
      }
      while_break___64: /* CIL Label */ ;
      }
#line 517
      tmp___19 = put;
#line 517
      put ++;
#line 517
      *tmp___19 = (unsigned char )state->length;
#line 518
      left --;
#line 519
      state->mode = (inflate_mode )16200;
#line 520
      goto switch_break;
    }
#line 524
    if ((int )here.op & 32) {
#line 526
      state->mode = (inflate_mode )16191;
#line 527
      goto switch_break;
    }
#line 531
    if ((int )here.op & 64) {
#line 532
      strm->msg = (char *)"invalid literal/length code";
#line 533
      state->mode = (inflate_mode )16209;
#line 534
      goto switch_break;
    }
#line 538
    state->extra = (unsigned int )here.op & 15U;
#line 539
    if (state->extra != 0U) {
      {
#line 540
      while (1) {
        while_continue___65: /* CIL Label */ ;
        {
#line 540
        while (1) {
          while_continue___66: /* CIL Label */ ;
#line 540
          if (! (bits < state->extra)) {
#line 540
            goto while_break___66;
          }
          {
#line 540
          while (1) {
            while_continue___67: /* CIL Label */ ;
            {
#line 540
            while (1) {
              while_continue___68: /* CIL Label */ ;
#line 540
              if (have == 0U) {
                {
#line 540
                have = (*in)(in_desc, & next);
                }
#line 540
                if (have == 0U) {
#line 540
                  next = (unsigned char *)0;
#line 540
                  ret = -5;
#line 540
                  goto inf_leave;
                }
              }
#line 540
              goto while_break___68;
            }
            while_break___68: /* CIL Label */ ;
            }
#line 540
            have --;
#line 540
            tmp___20 = next;
#line 540
            next ++;
#line 540
            hold += (unsigned long )*tmp___20 << bits;
#line 540
            bits += 8U;
#line 540
            goto while_break___67;
          }
          while_break___67: /* CIL Label */ ;
          }
        }
        while_break___66: /* CIL Label */ ;
        }
#line 540
        goto while_break___65;
      }
      while_break___65: /* CIL Label */ ;
      }
#line 541
      state->length += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 542
      while (1) {
        while_continue___69: /* CIL Label */ ;
#line 542
        hold >>= state->extra;
#line 542
        bits -= state->extra;
#line 542
        goto while_break___69;
      }
      while_break___69: /* CIL Label */ ;
      }
    }
    {
#line 547
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 548
      here = (code )*(state->distcode + ((unsigned int )hold & ((1U << state->distbits) - 1U)));
#line 549
      if ((unsigned int )here.bits <= bits) {
#line 549
        goto while_break___70;
      }
      {
#line 550
      while (1) {
        while_continue___71: /* CIL Label */ ;
        {
#line 550
        while (1) {
          while_continue___72: /* CIL Label */ ;
#line 550
          if (have == 0U) {
            {
#line 550
            have = (*in)(in_desc, & next);
            }
#line 550
            if (have == 0U) {
#line 550
              next = (unsigned char *)0;
#line 550
              ret = -5;
#line 550
              goto inf_leave;
            }
          }
#line 550
          goto while_break___72;
        }
        while_break___72: /* CIL Label */ ;
        }
#line 550
        have --;
#line 550
        tmp___21 = next;
#line 550
        next ++;
#line 550
        hold += (unsigned long )*tmp___21 << bits;
#line 550
        bits += 8U;
#line 550
        goto while_break___71;
      }
      while_break___71: /* CIL Label */ ;
      }
    }
    while_break___70: /* CIL Label */ ;
    }
#line 552
    if (((int )here.op & 240) == 0) {
#line 553
      last = here;
      {
#line 554
      while (1) {
        while_continue___73: /* CIL Label */ ;
#line 555
        here = (code )*(state->distcode + ((unsigned int )last.val + (((unsigned int )hold & ((1U << ((int )last.bits + (int )last.op)) - 1U)) >> (int )last.bits)));
#line 557
        if ((unsigned int )((int )last.bits + (int )here.bits) <= bits) {
#line 557
          goto while_break___73;
        }
        {
#line 558
        while (1) {
          while_continue___74: /* CIL Label */ ;
          {
#line 558
          while (1) {
            while_continue___75: /* CIL Label */ ;
#line 558
            if (have == 0U) {
              {
#line 558
              have = (*in)(in_desc, & next);
              }
#line 558
              if (have == 0U) {
#line 558
                next = (unsigned char *)0;
#line 558
                ret = -5;
#line 558
                goto inf_leave;
              }
            }
#line 558
            goto while_break___75;
          }
          while_break___75: /* CIL Label */ ;
          }
#line 558
          have --;
#line 558
          tmp___22 = next;
#line 558
          next ++;
#line 558
          hold += (unsigned long )*tmp___22 << bits;
#line 558
          bits += 8U;
#line 558
          goto while_break___74;
        }
        while_break___74: /* CIL Label */ ;
        }
      }
      while_break___73: /* CIL Label */ ;
      }
      {
#line 560
      while (1) {
        while_continue___76: /* CIL Label */ ;
#line 560
        hold >>= (int )last.bits;
#line 560
        bits -= (unsigned int )last.bits;
#line 560
        goto while_break___76;
      }
      while_break___76: /* CIL Label */ ;
      }
    }
    {
#line 562
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 562
      hold >>= (int )here.bits;
#line 562
      bits -= (unsigned int )here.bits;
#line 562
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
#line 563
    if ((int )here.op & 64) {
#line 564
      strm->msg = (char *)"invalid distance code";
#line 565
      state->mode = (inflate_mode )16209;
#line 566
      goto switch_break;
    }
#line 568
    state->offset = (unsigned int )here.val;
#line 571
    state->extra = (unsigned int )here.op & 15U;
#line 572
    if (state->extra != 0U) {
      {
#line 573
      while (1) {
        while_continue___78: /* CIL Label */ ;
        {
#line 573
        while (1) {
          while_continue___79: /* CIL Label */ ;
#line 573
          if (! (bits < state->extra)) {
#line 573
            goto while_break___79;
          }
          {
#line 573
          while (1) {
            while_continue___80: /* CIL Label */ ;
            {
#line 573
            while (1) {
              while_continue___81: /* CIL Label */ ;
#line 573
              if (have == 0U) {
                {
#line 573
                have = (*in)(in_desc, & next);
                }
#line 573
                if (have == 0U) {
#line 573
                  next = (unsigned char *)0;
#line 573
                  ret = -5;
#line 573
                  goto inf_leave;
                }
              }
#line 573
              goto while_break___81;
            }
            while_break___81: /* CIL Label */ ;
            }
#line 573
            have --;
#line 573
            tmp___23 = next;
#line 573
            next ++;
#line 573
            hold += (unsigned long )*tmp___23 << bits;
#line 573
            bits += 8U;
#line 573
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
        }
        while_break___79: /* CIL Label */ ;
        }
#line 573
        goto while_break___78;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 574
      state->offset += (unsigned int )hold & ((1U << state->extra) - 1U);
      {
#line 575
      while (1) {
        while_continue___82: /* CIL Label */ ;
#line 575
        hold >>= state->extra;
#line 575
        bits -= state->extra;
#line 575
        goto while_break___82;
      }
      while_break___82: /* CIL Label */ ;
      }
    }
#line 577
    if (state->whave < state->wsize) {
#line 577
      tmp___24 = left;
    } else {
#line 577
      tmp___24 = 0U;
    }
#line 577
    if (state->offset > state->wsize - tmp___24) {
#line 579
      strm->msg = (char *)"invalid distance too far back";
#line 580
      state->mode = (inflate_mode )16209;
#line 581
      goto switch_break;
    }
    {
#line 586
    while (1) {
      while_continue___83: /* CIL Label */ ;
      {
#line 587
      while (1) {
        while_continue___84: /* CIL Label */ ;
#line 587
        if (left == 0U) {
          {
#line 587
          put = state->window;
#line 587
          left = state->wsize;
#line 587
          state->whave = left;
#line 587
          tmp___25 = (*out)(out_desc, put, left);
          }
#line 587
          if (tmp___25) {
#line 587
            ret = -5;
#line 587
            goto inf_leave;
          }
        }
#line 587
        goto while_break___84;
      }
      while_break___84: /* CIL Label */ ;
      }
#line 588
      copy = state->wsize - state->offset;
#line 589
      if (copy < left) {
#line 590
        from = put + copy;
#line 591
        copy = left - copy;
      } else {
#line 594
        from = put - state->offset;
#line 595
        copy = left;
      }
#line 597
      if (copy > state->length) {
#line 597
        copy = state->length;
      }
#line 598
      state->length -= copy;
#line 599
      left -= copy;
      {
#line 600
      while (1) {
        while_continue___85: /* CIL Label */ ;
#line 601
        tmp___26 = put;
#line 601
        put ++;
#line 601
        tmp___27 = from;
#line 601
        from ++;
#line 601
        *tmp___26 = *tmp___27;
#line 600
        copy --;
#line 600
        if (! copy) {
#line 600
          goto while_break___85;
        }
      }
      while_break___85: /* CIL Label */ ;
      }
#line 586
      if (! (state->length != 0U)) {
#line 586
        goto while_break___83;
      }
    }
    while_break___83: /* CIL Label */ ;
    }
#line 604
    goto switch_break;
    case_16208: /* CIL Label */ 
#line 608
    ret = 1;
#line 609
    if (left < state->wsize) {
      {
#line 610
      tmp___28 = (*out)(out_desc, state->window, state->wsize - left);
      }
#line 610
      if (tmp___28) {
#line 611
        ret = -5;
      }
    }
#line 613
    goto inf_leave;
    case_16209: /* CIL Label */ 
#line 616
    ret = -3;
#line 617
    goto inf_leave;
    switch_default: /* CIL Label */ 
#line 620
    ret = -2;
#line 621
    goto inf_leave;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  inf_leave: 
#line 626
  strm->next_in = next;
#line 627
  strm->avail_in = have;
#line 628
  return (ret);
}
}
#line 631 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/infback.c"
int inflateBackEnd(z_streamp strm ) 
{ 


  {
#line 634
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 635
    return (-2);
  } else
#line 634
  if ((unsigned long )strm->state == (unsigned long )((struct internal_state *)0)) {
#line 635
    return (-2);
  } else
#line 634
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 635
    return (-2);
  }
  {
#line 636
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 637
  strm->state = (struct internal_state *)0;
  }
#line 639
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 344 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 268 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int deflate(z_streamp strm , int flush ) ;
#line 381
int deflateEnd(z_streamp strm ) ;
#line 713
int deflateReset(z_streamp strm ) ;
#line 724
int deflateParams(z_streamp strm , int level , int strategy ) ;
#line 1397
int gzsetparams(gzFile file , int level , int strategy ) ;
#line 1464
int gzwrite(gzFile file , voidpc buf , unsigned int len ) ;
#line 1472
z_size_t gzfwrite(voidpc buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1486
int gzprintf(gzFile file , char const   *format  , ...) ;
#line 1501
int gzputs(gzFile file , char const   *str ) ;
#line 1522
int gzputc(gzFile file , int c ) ;
#line 1549
int gzflush(gzFile file , int flush ) ;
#line 1662
int gzclose_w(gzFile file ) ;
#line 1786
int deflateInit2_(z_streamp strm , int level , int method , int windowBits , int memLevel ,
                  int strategy , char const   *version , int stream_size ) ;
#line 1920
int gzvprintf(gzFile file , char const   *format , va_list va ) ;
#line 384 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 205 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzguts.h"
void __attribute__((__visibility__("hidden")))  gz_error(gz_statep state , int err ,
                                                         char const   *msg ) ;
#line 9 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
static int gz_init(gz_statep state ) ;
#line 10
static int gz_comp(gz_statep state , int flush ) ;
#line 11
static int gz_zero(gz_statep state , off64_t len ) ;
#line 12
static z_size_t gz_write(gz_statep state , voidpc buf , z_size_t len ) ;
#line 17 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
static int gz_init(gz_statep state ) 
{ 
  int ret ;
  z_streamp strm ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 21
  strm = & state->strm;
#line 24
  tmp = malloc((size_t )(state->want << 1));
#line 24
  state->in = (unsigned char *)tmp;
  }
#line 25
  if ((unsigned long )state->in == (unsigned long )((void *)0)) {
    {
#line 26
    gz_error(state, -4, "out of memory");
    }
#line 27
    return (-1);
  }
#line 31
  if (! state->direct) {
    {
#line 33
    tmp___0 = malloc((size_t )state->want);
#line 33
    state->out = (unsigned char *)tmp___0;
    }
#line 34
    if ((unsigned long )state->out == (unsigned long )((void *)0)) {
      {
#line 35
      free((void *)state->in);
#line 36
      gz_error(state, -4, "out of memory");
      }
#line 37
      return (-1);
    }
    {
#line 41
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 42
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 43
    strm->opaque = (voidpf )0;
#line 44
    ret = deflateInit2_(strm, state->level, 8, 31, 8, state->strategy, "1.2.11-optipng",
                        (int )sizeof(z_stream ));
    }
#line 46
    if (ret != 0) {
      {
#line 47
      free((void *)state->out);
#line 48
      free((void *)state->in);
#line 49
      gz_error(state, -4, "out of memory");
      }
#line 50
      return (-1);
    }
#line 52
    strm->next_in = (Bytef *)((void *)0);
  }
#line 56
  state->size = state->want;
#line 59
  if (! state->direct) {
#line 60
    strm->avail_out = state->size;
#line 61
    strm->next_out = state->out;
#line 62
    state->x.next = strm->next_out;
  }
#line 64
  return (0);
}
}
#line 73 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
static int gz_comp(gz_statep state , int flush ) 
{ 
  int ret ;
  int writ ;
  unsigned int have ;
  unsigned int put ;
  unsigned int max ;
  z_streamp strm ;
  int tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 78
  max = (4294967295U >> 2) + 1U;
#line 79
  strm = & state->strm;
#line 82
  if (state->size == 0U) {
    {
#line 82
    tmp = gz_init(state);
    }
#line 82
    if (tmp == -1) {
#line 83
      return (-1);
    }
  }
#line 86
  if (state->direct) {
    {
#line 87
    while (1) {
      while_continue: /* CIL Label */ ;
#line 87
      if (! strm->avail_in) {
#line 87
        goto while_break;
      }
#line 88
      if (strm->avail_in > max) {
#line 88
        put = max;
      } else {
#line 88
        put = strm->avail_in;
      }
      {
#line 89
      tmp___0 = write(state->fd, (void const   *)strm->next_in, (size_t )put);
#line 89
      writ = (int )tmp___0;
      }
#line 90
      if (writ < 0) {
        {
#line 91
        tmp___1 = __errno_location();
#line 91
        tmp___2 = strerror(*tmp___1);
#line 91
        gz_error(state, -1, (char const   *)tmp___2);
        }
#line 92
        return (-1);
      }
#line 94
      strm->avail_in -= (unsigned int )writ;
#line 95
      strm->next_in += writ;
    }
    while_break: /* CIL Label */ ;
    }
#line 97
    return (0);
  }
#line 101
  ret = 0;
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 105
    if (strm->avail_out == 0U) {
#line 105
      goto _L___0;
    } else
#line 105
    if (flush != 0) {
#line 105
      if (flush != 4) {
#line 105
        goto _L___0;
      } else
#line 105
      if (ret == 1) {
        _L___0: /* CIL Label */ 
        {
#line 107
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 107
          if (! ((unsigned long )strm->next_out > (unsigned long )state->x.next)) {
#line 107
            goto while_break___1;
          }
#line 108
          if (strm->next_out - state->x.next > (long )((int )max)) {
#line 108
            put = max;
          } else {
#line 108
            put = (unsigned int )(strm->next_out - state->x.next);
          }
          {
#line 110
          tmp___3 = write(state->fd, (void const   *)state->x.next, (size_t )put);
#line 110
          writ = (int )tmp___3;
          }
#line 111
          if (writ < 0) {
            {
#line 112
            tmp___4 = __errno_location();
#line 112
            tmp___5 = strerror(*tmp___4);
#line 112
            gz_error(state, -1, (char const   *)tmp___5);
            }
#line 113
            return (-1);
          }
#line 115
          state->x.next += writ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 117
        if (strm->avail_out == 0U) {
#line 118
          strm->avail_out = state->size;
#line 119
          strm->next_out = state->out;
#line 120
          state->x.next = state->out;
        }
      }
    }
    {
#line 125
    have = strm->avail_out;
#line 126
    ret = deflate(strm, flush);
    }
#line 127
    if (ret == -2) {
      {
#line 128
      gz_error(state, -2, "internal error: deflate stream corrupt");
      }
#line 130
      return (-1);
    }
#line 132
    have -= strm->avail_out;
#line 102
    if (! have) {
#line 102
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 136
  if (flush == 4) {
    {
#line 137
    deflateReset(strm);
    }
  }
#line 140
  return (0);
}
}
#line 145 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
static int gz_zero(gz_statep state , off64_t len ) 
{ 
  int first ;
  unsigned int n ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;

  {
#line 151
  strm = & state->strm;
#line 154
  if (strm->avail_in) {
    {
#line 154
    tmp = gz_comp(state, 0);
    }
#line 154
    if (tmp == -1) {
#line 155
      return (-1);
    }
  }
#line 158
  first = 1;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! len) {
#line 159
      goto while_break;
    }
#line 160
    if (sizeof(int ) == sizeof(off64_t )) {
#line 160
      if (state->size > 2147483647U) {
#line 160
        n = (unsigned int )len;
      } else {
#line 160
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 160
    if ((off64_t )state->size > len) {
#line 160
      n = (unsigned int )len;
    } else {
#line 160
      n = state->size;
    }
#line 162
    if (first) {
      {
#line 163
      memset((void *)state->in, 0, (size_t )n);
#line 164
      first = 0;
      }
    }
    {
#line 166
    strm->avail_in = n;
#line 167
    strm->next_in = state->in;
#line 168
    state->x.pos += (off64_t )n;
#line 169
    tmp___0 = gz_comp(state, 0);
    }
#line 169
    if (tmp___0 == -1) {
#line 170
      return (-1);
    }
#line 171
    len -= (off64_t )n;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (0);
}
}
#line 178 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
static z_size_t gz_write(gz_statep state , voidpc buf , z_size_t len ) 
{ 
  z_size_t put ;
  int tmp ;
  int tmp___0 ;
  unsigned int have ;
  unsigned int copy ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int n ;
  int tmp___3 ;

  {
#line 183
  put = len;
#line 186
  if (len == 0UL) {
#line 187
    return ((z_size_t )0);
  }
#line 190
  if (state->size == 0U) {
    {
#line 190
    tmp = gz_init(state);
    }
#line 190
    if (tmp == -1) {
#line 191
      return ((z_size_t )0);
    }
  }
#line 194
  if (state->seek) {
    {
#line 195
    state->seek = 0;
#line 196
    tmp___0 = gz_zero(state, state->skip);
    }
#line 196
    if (tmp___0 == -1) {
#line 197
      return ((z_size_t )0);
    }
  }
#line 201
  if (len < (z_size_t )state->size) {
    {
#line 203
    while (1) {
      while_continue: /* CIL Label */ ;
#line 206
      if (state->strm.avail_in == 0U) {
#line 207
        state->strm.next_in = state->in;
      }
#line 208
      have = (unsigned int )((state->strm.next_in + state->strm.avail_in) - state->in);
#line 210
      copy = state->size - have;
#line 211
      if ((z_size_t )copy > len) {
#line 212
        copy = (unsigned int )len;
      }
      {
#line 213
      memcpy((void */* __restrict  */)(state->in + have), (void const   */* __restrict  */)buf,
             (size_t )copy);
#line 214
      state->strm.avail_in += copy;
#line 215
      state->x.pos += (off64_t )copy;
#line 216
      buf = (voidpc )((char const   *)buf + copy);
#line 217
      len -= (z_size_t )copy;
      }
#line 218
      if (len) {
        {
#line 218
        tmp___1 = gz_comp(state, 0);
        }
#line 218
        if (tmp___1 == -1) {
#line 219
          return ((z_size_t )0);
        }
      }
#line 203
      if (! len) {
#line 203
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 224
    if (state->strm.avail_in) {
      {
#line 224
      tmp___2 = gz_comp(state, 0);
      }
#line 224
      if (tmp___2 == -1) {
#line 225
        return ((z_size_t )0);
      }
    }
#line 228
    state->strm.next_in = (Bytef *)buf;
    {
#line 229
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 230
      n = 4294967295U;
#line 231
      if ((z_size_t )n > len) {
#line 232
        n = (unsigned int )len;
      }
      {
#line 233
      state->strm.avail_in = n;
#line 234
      state->x.pos += (off64_t )n;
#line 235
      tmp___3 = gz_comp(state, 0);
      }
#line 235
      if (tmp___3 == -1) {
#line 236
        return ((z_size_t )0);
      }
#line 237
      len -= (z_size_t )n;
#line 229
      if (! len) {
#line 229
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 242
  return (put);
}
}
#line 246 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzwrite(gzFile file , voidpc buf , unsigned int len ) 
{ 
  gz_statep state ;
  z_size_t tmp ;

  {
#line 254
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 255
    return (0);
  }
#line 256
  state = (gz_statep )file;
#line 259
  if (state->mode != 31153) {
#line 260
    return (0);
  } else
#line 259
  if (state->err != 0) {
#line 260
    return (0);
  }
#line 264
  if ((int )len < 0) {
    {
#line 265
    gz_error(state, -3, "requested length does not fit in int");
    }
#line 266
    return (0);
  }
  {
#line 270
  tmp = gz_write(state, buf, (z_size_t )len);
  }
#line 270
  return ((int )tmp);
}
}
#line 274 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
z_size_t gzfwrite(voidpc buf , z_size_t size , z_size_t nitems , gzFile file ) 
{ 
  z_size_t len ;
  gz_statep state ;
  z_size_t tmp ;
  z_size_t tmp___0 ;

  {
#line 284
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 285
    return ((z_size_t )0);
  }
#line 286
  state = (gz_statep )file;
#line 289
  if (state->mode != 31153) {
#line 290
    return ((z_size_t )0);
  } else
#line 289
  if (state->err != 0) {
#line 290
    return ((z_size_t )0);
  }
#line 293
  len = nitems * size;
#line 294
  if (size) {
#line 294
    if (len / size != nitems) {
      {
#line 295
      gz_error(state, -2, "request does not fit in a size_t");
      }
#line 296
      return ((z_size_t )0);
    }
  }
#line 300
  if (len) {
    {
#line 300
    tmp = gz_write(state, buf, len);
#line 300
    tmp___0 = tmp / size;
    }
  } else {
#line 300
    tmp___0 = (z_size_t )0;
  }
#line 300
  return (tmp___0);
}
}
#line 304 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzputc(gzFile file , int c ) 
{ 
  unsigned int have ;
  unsigned char buf[1] ;
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  z_size_t tmp___0 ;

  {
#line 314
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 315
    return (-1);
  }
#line 316
  state = (gz_statep )file;
#line 317
  strm = & state->strm;
#line 320
  if (state->mode != 31153) {
#line 321
    return (-1);
  } else
#line 320
  if (state->err != 0) {
#line 321
    return (-1);
  }
#line 324
  if (state->seek) {
    {
#line 325
    state->seek = 0;
#line 326
    tmp = gz_zero(state, state->skip);
    }
#line 326
    if (tmp == -1) {
#line 327
      return (-1);
    }
  }
#line 332
  if (state->size) {
#line 333
    if (strm->avail_in == 0U) {
#line 334
      strm->next_in = state->in;
    }
#line 335
    have = (unsigned int )((strm->next_in + strm->avail_in) - state->in);
#line 336
    if (have < state->size) {
#line 337
      *(state->in + have) = (unsigned char )c;
#line 338
      (strm->avail_in) ++;
#line 339
      (state->x.pos) ++;
#line 340
      return (c & 255);
    }
  }
  {
#line 345
  buf[0] = (unsigned char )c;
#line 346
  tmp___0 = gz_write(state, (voidpc )(buf), (z_size_t )1);
  }
#line 346
  if (tmp___0 != 1UL) {
#line 347
    return (-1);
  }
#line 348
  return (c & 255);
}
}
#line 352 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzputs(gzFile file , char const   *str ) 
{ 
  int ret ;
  z_size_t len ;
  gz_statep state ;
  z_size_t tmp ;
  int tmp___0 ;

  {
#line 361
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 362
    return (-1);
  }
#line 363
  state = (gz_statep )file;
#line 366
  if (state->mode != 31153) {
#line 367
    return (-1);
  } else
#line 366
  if (state->err != 0) {
#line 367
    return (-1);
  }
  {
#line 370
  len = strlen(str);
#line 371
  tmp = gz_write(state, (voidpc )str, len);
#line 371
  ret = (int )tmp;
  }
#line 372
  if (ret == 0) {
#line 372
    if (len != 0UL) {
#line 372
      tmp___0 = -1;
    } else {
#line 372
      tmp___0 = ret;
    }
  } else {
#line 372
    tmp___0 = ret;
  }
#line 372
  return (tmp___0);
}
}
#line 379 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzvprintf(gzFile file , char const   *format , va_list va ) 
{ 
  int len ;
  unsigned int left ;
  char *next ;
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 388
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 389
    return (-2);
  }
#line 390
  state = (gz_statep )file;
#line 391
  strm = & state->strm;
#line 394
  if (state->mode != 31153) {
#line 395
    return (-2);
  } else
#line 394
  if (state->err != 0) {
#line 395
    return (-2);
  }
#line 398
  if (state->size == 0U) {
    {
#line 398
    tmp = gz_init(state);
    }
#line 398
    if (tmp == -1) {
#line 399
      return (state->err);
    }
  }
#line 402
  if (state->seek) {
    {
#line 403
    state->seek = 0;
#line 404
    tmp___0 = gz_zero(state, state->skip);
    }
#line 404
    if (tmp___0 == -1) {
#line 405
      return (state->err);
    }
  }
#line 411
  if (strm->avail_in == 0U) {
#line 412
    strm->next_in = state->in;
  }
  {
#line 413
  next = (char *)((state->in + (strm->next_in - state->in)) + strm->avail_in);
#line 414
  *(next + (state->size - 1U)) = (char)0;
#line 428
  len = vsnprintf((char */* __restrict  */)next, (size_t )state->size, (char const   */* __restrict  */)format,
                  va);
  }
#line 433
  if (len == 0) {
#line 434
    return (0);
  } else
#line 433
  if ((unsigned int )len >= state->size) {
#line 434
    return (0);
  } else
#line 433
  if ((int )*(next + (state->size - 1U)) != 0) {
#line 434
    return (0);
  }
#line 437
  strm->avail_in += (unsigned int )len;
#line 438
  state->x.pos += (off64_t )len;
#line 439
  if (strm->avail_in >= state->size) {
    {
#line 440
    left = strm->avail_in - state->size;
#line 441
    strm->avail_in = state->size;
#line 442
    tmp___1 = gz_comp(state, 0);
    }
#line 442
    if (tmp___1 == -1) {
#line 443
      return (state->err);
    }
    {
#line 444
    memcpy((void */* __restrict  */)state->in, (void const   */* __restrict  */)(state->in + state->size),
           (size_t )left);
#line 445
    strm->next_in = state->in;
#line 446
    strm->avail_in = left;
    }
  }
#line 448
  return (len);
}
}
#line 451 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzprintf(gzFile file , char const   *format  , ...) 
{ 
  va_list va ;
  int ret ;

  {
  {
#line 456
  __builtin_va_start(va, format);
#line 457
  ret = gzvprintf(file, format, va);
#line 458
  __builtin_va_end(va);
  }
#line 459
  return (ret);
}
}
#line 553 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzflush(gzFile file , int flush ) 
{ 
  gz_statep state ;
  int tmp ;

  {
#line 560
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 561
    return (-2);
  }
#line 562
  state = (gz_statep )file;
#line 565
  if (state->mode != 31153) {
#line 566
    return (-2);
  } else
#line 565
  if (state->err != 0) {
#line 566
    return (-2);
  }
#line 569
  if (flush < 0) {
#line 570
    return (-2);
  } else
#line 569
  if (flush > 4) {
#line 570
    return (-2);
  }
#line 573
  if (state->seek) {
    {
#line 574
    state->seek = 0;
#line 575
    tmp = gz_zero(state, state->skip);
    }
#line 575
    if (tmp == -1) {
#line 576
      return (state->err);
    }
  }
  {
#line 580
  gz_comp(state, flush);
  }
#line 581
  return (state->err);
}
}
#line 585 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzsetparams(gzFile file , int level , int strategy ) 
{ 
  gz_statep state ;
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;

  {
#line 594
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 595
    return (-2);
  }
#line 596
  state = (gz_statep )file;
#line 597
  strm = & state->strm;
#line 600
  if (state->mode != 31153) {
#line 601
    return (-2);
  } else
#line 600
  if (state->err != 0) {
#line 601
    return (-2);
  }
#line 604
  if (level == state->level) {
#line 604
    if (strategy == state->strategy) {
#line 605
      return (0);
    }
  }
#line 608
  if (state->seek) {
    {
#line 609
    state->seek = 0;
#line 610
    tmp = gz_zero(state, state->skip);
    }
#line 610
    if (tmp == -1) {
#line 611
      return (state->err);
    }
  }
#line 615
  if (state->size) {
#line 617
    if (strm->avail_in) {
      {
#line 617
      tmp___0 = gz_comp(state, 5);
      }
#line 617
      if (tmp___0 == -1) {
#line 618
        return (state->err);
      }
    }
    {
#line 619
    deflateParams(strm, level, strategy);
    }
  }
#line 621
  state->level = level;
#line 622
  state->strategy = strategy;
#line 623
  return (0);
}
}
#line 627 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzwrite.c"
int gzclose_w(gzFile file ) 
{ 
  int ret ;
  gz_statep state ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 630
  ret = 0;
#line 634
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 635
    return (-2);
  }
#line 636
  state = (gz_statep )file;
#line 639
  if (state->mode != 31153) {
#line 640
    return (-2);
  }
#line 643
  if (state->seek) {
    {
#line 644
    state->seek = 0;
#line 645
    tmp = gz_zero(state, state->skip);
    }
#line 645
    if (tmp == -1) {
#line 646
      ret = state->err;
    }
  }
  {
#line 650
  tmp___0 = gz_comp(state, 4);
  }
#line 650
  if (tmp___0 == -1) {
#line 651
    ret = state->err;
  }
#line 652
  if (state->size) {
#line 653
    if (! state->direct) {
      {
#line 654
      deflateEnd(& state->strm);
#line 655
      free((void *)state->out);
      }
    }
    {
#line 657
    free((void *)state->in);
    }
  }
  {
#line 659
  gz_error(state, 0, (char const   *)((void *)0));
#line 660
  free((void *)state->path);
#line 661
  tmp___1 = close(state->fd);
  }
#line 661
  if (tmp___1 == -1) {
#line 662
    ret = -1;
  }
  {
#line 663
  free((void *)state);
  }
#line 664
  return (ret);
}
}
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 1408 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1438
z_size_t gzfread(voidp buf , z_size_t size , z_size_t nitems , gzFile file ) ;
#line 1509
char *gzgets(gzFile file , char *buf , int len ) ;
#line 1528
int gzgetc(gzFile file ) ;
#line 1537
int gzungetc(int c , gzFile file ) ;
#line 1627
int gzdirect(gzFile file ) ;
#line 1661
int gzclose_r(gzFile file ) ;
#line 1840
int gzgetc_(gzFile file ) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 9 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static int gz_load(gz_statep state , unsigned char *buf , unsigned int len , unsigned int *have ) ;
#line 10
static int gz_avail(gz_statep state ) ;
#line 11
static int gz_look(gz_statep state ) ;
#line 12
static int gz_decomp(gz_statep state ) ;
#line 13
static int gz_fetch(gz_statep state ) ;
#line 14
static int gz_skip(gz_statep state , off64_t len ) ;
#line 15
static z_size_t gz_read(gz_statep state , voidp buf , z_size_t len ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static int gz_load(gz_statep state , unsigned char *buf , unsigned int len , unsigned int *have ) 
{ 
  int ret ;
  unsigned int get ;
  unsigned int max ;
  ssize_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 28
  max = (4294967295U >> 2) + 1U;
#line 30
  *have = 0U;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    get = len - *have;
#line 33
    if (get > max) {
#line 34
      get = max;
    }
    {
#line 35
    tmp = read(state->fd, (void *)(buf + *have), (size_t )get);
#line 35
    ret = (int )tmp;
    }
#line 36
    if (ret <= 0) {
#line 37
      goto while_break;
    }
#line 38
    *have += (unsigned int )ret;
#line 31
    if (! (*have < len)) {
#line 31
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  if (ret < 0) {
    {
#line 41
    tmp___0 = __errno_location();
#line 41
    tmp___1 = strerror(*tmp___0);
#line 41
    gz_error(state, -1, (char const   *)tmp___1);
    }
#line 42
    return (-1);
  }
#line 44
  if (ret == 0) {
#line 45
    state->eof = 1;
  }
#line 46
  return (0);
}
}
#line 56 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static int gz_avail(gz_statep state ) 
{ 
  unsigned int got ;
  z_streamp strm ;
  unsigned char *p ;
  unsigned char const   *q ;
  unsigned int n ;
  unsigned char *tmp ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 60
  strm = & state->strm;
#line 62
  if (state->err != 0) {
#line 62
    if (state->err != -5) {
#line 63
      return (-1);
    }
  }
#line 64
  if (state->eof == 0) {
#line 65
    if (strm->avail_in) {
#line 66
      p = state->in;
#line 67
      q = (unsigned char const   *)strm->next_in;
#line 68
      n = strm->avail_in;
      {
#line 69
      while (1) {
        while_continue: /* CIL Label */ ;
#line 70
        tmp = p;
#line 70
        p ++;
#line 70
        tmp___0 = q;
#line 70
        q ++;
#line 70
        *tmp = (unsigned char )*tmp___0;
#line 69
        n --;
#line 69
        if (! n) {
#line 69
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 73
    tmp___1 = gz_load(state, state->in + strm->avail_in, state->size - strm->avail_in,
                      & got);
    }
#line 73
    if (tmp___1 == -1) {
#line 75
      return (-1);
    }
#line 76
    strm->avail_in += got;
#line 77
    strm->next_in = state->in;
  }
#line 79
  return (0);
}
}
#line 91 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static int gz_look(gz_statep state ) 
{ 
  z_streamp strm ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 94
  strm = & state->strm;
#line 97
  if (state->size == 0U) {
    {
#line 99
    tmp = malloc((size_t )state->want);
#line 99
    state->in = (unsigned char *)tmp;
#line 100
    tmp___0 = malloc((size_t )(state->want << 1));
#line 100
    state->out = (unsigned char *)tmp___0;
    }
#line 101
    if ((unsigned long )state->in == (unsigned long )((void *)0)) {
      {
#line 102
      free((void *)state->out);
#line 103
      free((void *)state->in);
#line 104
      gz_error(state, -4, "out of memory");
      }
#line 105
      return (-1);
    } else
#line 101
    if ((unsigned long )state->out == (unsigned long )((void *)0)) {
      {
#line 102
      free((void *)state->out);
#line 103
      free((void *)state->in);
#line 104
      gz_error(state, -4, "out of memory");
      }
#line 105
      return (-1);
    }
    {
#line 107
    state->size = state->want;
#line 110
    state->strm.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 111
    state->strm.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 112
    state->strm.opaque = (voidpf )0;
#line 113
    state->strm.avail_in = (uInt )0;
#line 114
    state->strm.next_in = (Bytef *)0;
#line 115
    tmp___1 = inflateInit2_(& state->strm, 31, "1.2.11-optipng", (int )sizeof(z_stream ));
    }
#line 115
    if (tmp___1 != 0) {
      {
#line 116
      free((void *)state->out);
#line 117
      free((void *)state->in);
#line 118
      state->size = 0U;
#line 119
      gz_error(state, -4, "out of memory");
      }
#line 120
      return (-1);
    }
  }
#line 125
  if (strm->avail_in < 2U) {
    {
#line 126
    tmp___2 = gz_avail(state);
    }
#line 126
    if (tmp___2 == -1) {
#line 127
      return (-1);
    }
#line 128
    if (strm->avail_in == 0U) {
#line 129
      return (0);
    }
  }
#line 139
  if (strm->avail_in > 1U) {
#line 139
    if ((int )*(strm->next_in + 0) == 31) {
#line 139
      if ((int )*(strm->next_in + 1) == 139) {
        {
#line 141
        inflateReset(strm);
#line 142
        state->how = 2;
#line 143
        state->direct = 0;
        }
#line 144
        return (0);
      }
    }
  }
#line 149
  if (state->direct == 0) {
#line 150
    strm->avail_in = (uInt )0;
#line 151
    state->eof = 1;
#line 152
    state->x.have = 0U;
#line 153
    return (0);
  }
#line 159
  state->x.next = state->out;
#line 160
  if (strm->avail_in) {
    {
#line 161
    memcpy((void */* __restrict  */)state->x.next, (void const   */* __restrict  */)strm->next_in,
           (size_t )strm->avail_in);
#line 162
    state->x.have = strm->avail_in;
#line 163
    strm->avail_in = (uInt )0;
    }
  }
#line 165
  state->how = 1;
#line 166
  state->direct = 1;
#line 167
  return (0);
}
}
#line 175 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static int gz_decomp(gz_statep state ) 
{ 
  int ret ;
  unsigned int had ;
  z_streamp strm ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 178
  ret = 0;
#line 180
  strm = & state->strm;
#line 183
  had = strm->avail_out;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (strm->avail_in == 0U) {
      {
#line 186
      tmp = gz_avail(state);
      }
#line 186
      if (tmp == -1) {
#line 187
        return (-1);
      }
    }
#line 188
    if (strm->avail_in == 0U) {
      {
#line 189
      gz_error(state, -5, "unexpected end of file");
      }
#line 190
      goto while_break;
    }
    {
#line 194
    ret = inflate(strm, 0);
    }
#line 195
    if (ret == -2) {
      {
#line 196
      gz_error(state, -2, "internal error: inflate stream corrupt");
      }
#line 198
      return (-1);
    } else
#line 195
    if (ret == 2) {
      {
#line 196
      gz_error(state, -2, "internal error: inflate stream corrupt");
      }
#line 198
      return (-1);
    }
#line 200
    if (ret == -4) {
      {
#line 201
      gz_error(state, -4, "out of memory");
      }
#line 202
      return (-1);
    }
#line 204
    if (ret == -3) {
#line 205
      if ((unsigned long )strm->msg == (unsigned long )((void *)0)) {
#line 205
        tmp___0 = "compressed data error";
      } else {
#line 205
        tmp___0 = (char const   *)strm->msg;
      }
      {
#line 205
      gz_error(state, -3, tmp___0);
      }
#line 207
      return (-1);
    }
#line 184
    if (strm->avail_out) {
#line 184
      if (! (ret != 1)) {
#line 184
        goto while_break;
      }
    } else {
#line 184
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  state->x.have = had - strm->avail_out;
#line 213
  state->x.next = strm->next_out - state->x.have;
#line 216
  if (ret == 1) {
#line 217
    state->how = 0;
  }
#line 220
  return (0);
}
}
#line 229 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static int gz_fetch(gz_statep state ) 
{ 
  z_streamp strm ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 232
  strm = & state->strm;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    if (state->how == 0) {
#line 236
      goto case_0;
    }
#line 242
    if (state->how == 1) {
#line 242
      goto case_1;
    }
#line 248
    if (state->how == 2) {
#line 248
      goto case_2;
    }
#line 235
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 237
    tmp = gz_look(state);
    }
#line 237
    if (tmp == -1) {
#line 238
      return (-1);
    }
#line 239
    if (state->how == 0) {
#line 240
      return (0);
    }
#line 241
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 243
    tmp___0 = gz_load(state, state->out, state->size << 1, & state->x.have);
    }
#line 243
    if (tmp___0 == -1) {
#line 245
      return (-1);
    }
#line 246
    state->x.next = state->out;
#line 247
    return (0);
    case_2: /* CIL Label */ 
    {
#line 249
    strm->avail_out = state->size << 1;
#line 250
    strm->next_out = state->out;
#line 251
    tmp___1 = gz_decomp(state);
    }
#line 251
    if (tmp___1 == -1) {
#line 252
      return (-1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 234
    if (state->x.have == 0U) {
#line 234
      if (! (! state->eof)) {
#line 234
        if (! strm->avail_in) {
#line 234
          goto while_break;
        }
      }
    } else {
#line 234
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return (0);
}
}
#line 259 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static int gz_skip(gz_statep state , off64_t len ) 
{ 
  unsigned int n ;
  int tmp ;

  {
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! len) {
#line 266
      goto while_break;
    }
#line 268
    if (state->x.have) {
#line 269
      if (sizeof(int ) == sizeof(off64_t )) {
#line 269
        if (state->x.have > 2147483647U) {
#line 269
          n = (unsigned int )len;
        } else {
#line 269
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 269
      if ((off64_t )state->x.have > len) {
#line 269
        n = (unsigned int )len;
      } else {
#line 269
        n = state->x.have;
      }
#line 271
      state->x.have -= n;
#line 272
      state->x.next += n;
#line 273
      state->x.pos += (off64_t )n;
#line 274
      len -= (off64_t )n;
    } else
#line 278
    if (state->eof) {
#line 278
      if (state->strm.avail_in == 0U) {
#line 279
        goto while_break;
      } else {
#line 278
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 284
      tmp = gz_fetch(state);
      }
#line 284
      if (tmp == -1) {
#line 285
        return (-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (0);
}
}
#line 294 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
static z_size_t gz_read(gz_statep state , voidp buf , z_size_t len ) 
{ 
  z_size_t got ;
  unsigned int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 303
  if (len == 0UL) {
#line 304
    return ((z_size_t )0);
  }
#line 307
  if (state->seek) {
    {
#line 308
    state->seek = 0;
#line 309
    tmp = gz_skip(state, state->skip);
    }
#line 309
    if (tmp == -1) {
#line 310
      return ((z_size_t )0);
    }
  }
#line 314
  got = (z_size_t )0;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    n = 4294967295U;
#line 318
    if ((z_size_t )n > len) {
#line 319
      n = (unsigned int )len;
    }
#line 322
    if (state->x.have) {
#line 323
      if (state->x.have < n) {
#line 324
        n = state->x.have;
      }
      {
#line 325
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)state->x.next,
             (size_t )n);
#line 326
      state->x.next += n;
#line 327
      state->x.have -= n;
      }
    } else
#line 331
    if (state->eof) {
#line 331
      if (state->strm.avail_in == 0U) {
#line 332
        state->past = 1;
#line 333
        goto while_break;
      } else {
#line 331
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 338
    if (state->how == 0) {
#line 338
      goto _L;
    } else
#line 338
    if (n < state->size << 1) {
      _L: /* CIL Label */ 
      {
#line 340
      tmp___0 = gz_fetch(state);
      }
#line 340
      if (tmp___0 == -1) {
#line 341
        return ((z_size_t )0);
      }
#line 342
      goto __Cont;
    } else
#line 348
    if (state->how == 1) {
      {
#line 349
      tmp___1 = gz_load(state, (unsigned char *)buf, n, & n);
      }
#line 349
      if (tmp___1 == -1) {
#line 350
        return ((z_size_t )0);
      }
    } else {
      {
#line 355
      state->strm.avail_out = n;
#line 356
      state->strm.next_out = (unsigned char *)buf;
#line 357
      tmp___2 = gz_decomp(state);
      }
#line 357
      if (tmp___2 == -1) {
#line 358
        return ((z_size_t )0);
      }
#line 359
      n = state->x.have;
#line 360
      state->x.have = 0U;
    }
#line 364
    len -= (z_size_t )n;
#line 365
    buf = (voidp )((char *)buf + n);
#line 366
    got += (z_size_t )n;
#line 367
    state->x.pos += (off64_t )n;
    __Cont: /* CIL Label */ 
#line 315
    if (! len) {
#line 315
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return (got);
}
}
#line 375 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
int gzread(gzFile file , voidp buf , unsigned int len ) 
{ 
  gz_statep state ;
  z_size_t tmp ;

  {
#line 383
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 384
    return (-1);
  }
#line 385
  state = (gz_statep )file;
#line 388
  if (state->mode != 7247) {
#line 390
    return (-1);
  } else
#line 388
  if (state->err != 0) {
#line 388
    if (state->err != -5) {
#line 390
      return (-1);
    }
  }
#line 394
  if ((int )len < 0) {
    {
#line 395
    gz_error(state, -2, "request does not fit in an int");
    }
#line 396
    return (-1);
  }
  {
#line 400
  tmp = gz_read(state, buf, (z_size_t )len);
#line 400
  len = (unsigned int )tmp;
  }
#line 403
  if (len == 0U) {
#line 403
    if (state->err != 0) {
#line 403
      if (state->err != -5) {
#line 404
        return (-1);
      }
    }
  }
#line 407
  return ((int )len);
}
}
#line 411 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
z_size_t gzfread(voidp buf , z_size_t size , z_size_t nitems , gzFile file ) 
{ 
  z_size_t len ;
  gz_statep state ;
  z_size_t tmp ;
  z_size_t tmp___0 ;

  {
#line 421
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 422
    return ((z_size_t )0);
  }
#line 423
  state = (gz_statep )file;
#line 426
  if (state->mode != 7247) {
#line 428
    return ((z_size_t )0);
  } else
#line 426
  if (state->err != 0) {
#line 426
    if (state->err != -5) {
#line 428
      return ((z_size_t )0);
    }
  }
#line 431
  len = nitems * size;
#line 432
  if (size) {
#line 432
    if (len / size != nitems) {
      {
#line 433
      gz_error(state, -2, "request does not fit in a size_t");
      }
#line 434
      return ((z_size_t )0);
    }
  }
#line 438
  if (len) {
    {
#line 438
    tmp = gz_read(state, buf, len);
#line 438
    tmp___0 = tmp / size;
    }
  } else {
#line 438
    tmp___0 = (z_size_t )0;
  }
#line 438
  return (tmp___0);
}
}
#line 447 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
int gzgetc(gzFile file ) 
{ 
  int ret ;
  unsigned char buf[1] ;
  gz_statep state ;
  unsigned char *tmp ;
  z_size_t tmp___0 ;
  int tmp___1 ;

  {
#line 455
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 456
    return (-1);
  }
#line 457
  state = (gz_statep )file;
#line 460
  if (state->mode != 7247) {
#line 462
    return (-1);
  } else
#line 460
  if (state->err != 0) {
#line 460
    if (state->err != -5) {
#line 462
      return (-1);
    }
  }
#line 465
  if (state->x.have) {
#line 466
    (state->x.have) --;
#line 467
    (state->x.pos) ++;
#line 468
    tmp = state->x.next;
#line 468
    (state->x.next) ++;
#line 468
    return ((int )*tmp);
  }
  {
#line 472
  tmp___0 = gz_read(state, (voidp )(buf), (z_size_t )1);
#line 472
  ret = (int )tmp___0;
  }
#line 473
  if (ret < 1) {
#line 473
    tmp___1 = -1;
  } else {
#line 473
    tmp___1 = (int )buf[0];
  }
#line 473
  return (tmp___1);
}
}
#line 476 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
int gzgetc_(gzFile file ) 
{ 
  int tmp ;

  {
  {
#line 479
  tmp = gzgetc(file);
  }
#line 479
  return (tmp);
}
}
#line 483 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
int gzungetc(int c , gzFile file ) 
{ 
  gz_statep state ;
  int tmp ;
  unsigned char *src ;
  unsigned char *dest ;

  {
#line 490
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 491
    return (-1);
  }
#line 492
  state = (gz_statep )file;
#line 495
  if (state->mode != 7247) {
#line 497
    return (-1);
  } else
#line 495
  if (state->err != 0) {
#line 495
    if (state->err != -5) {
#line 497
      return (-1);
    }
  }
#line 500
  if (state->seek) {
    {
#line 501
    state->seek = 0;
#line 502
    tmp = gz_skip(state, state->skip);
    }
#line 502
    if (tmp == -1) {
#line 503
      return (-1);
    }
  }
#line 507
  if (c < 0) {
#line 508
    return (-1);
  }
#line 511
  if (state->x.have == 0U) {
#line 512
    state->x.have = 1U;
#line 513
    state->x.next = (state->out + (state->size << 1)) - 1;
#line 514
    *(state->x.next + 0) = (unsigned char )c;
#line 515
    (state->x.pos) --;
#line 516
    state->past = 0;
#line 517
    return (c);
  }
#line 521
  if (state->x.have == state->size << 1) {
    {
#line 522
    gz_error(state, -3, "out of room to push characters");
    }
#line 523
    return (-1);
  }
#line 527
  if ((unsigned long )state->x.next == (unsigned long )state->out) {
#line 528
    src = state->out + state->x.have;
#line 529
    dest = state->out + (state->size << 1);
    {
#line 530
    while (1) {
      while_continue: /* CIL Label */ ;
#line 530
      if (! ((unsigned long )src > (unsigned long )state->out)) {
#line 530
        goto while_break;
      }
#line 531
      dest --;
#line 531
      src --;
#line 531
      *dest = *src;
    }
    while_break: /* CIL Label */ ;
    }
#line 532
    state->x.next = dest;
  }
#line 534
  (state->x.have) ++;
#line 535
  (state->x.next) --;
#line 536
  *(state->x.next + 0) = (unsigned char )c;
#line 537
  (state->x.pos) --;
#line 538
  state->past = 0;
#line 539
  return (c);
}
}
#line 543 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
char *gzgets(gzFile file , char *buf , int len ) 
{ 
  unsigned int left ;
  unsigned int n ;
  char *str ;
  unsigned char *eol ;
  gz_statep state ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 554
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 555
    return ((char *)((void *)0));
  } else
#line 554
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 555
    return ((char *)((void *)0));
  } else
#line 554
  if (len < 1) {
#line 555
    return ((char *)((void *)0));
  }
#line 556
  state = (gz_statep )file;
#line 559
  if (state->mode != 7247) {
#line 561
    return ((char *)((void *)0));
  } else
#line 559
  if (state->err != 0) {
#line 559
    if (state->err != -5) {
#line 561
      return ((char *)((void *)0));
    }
  }
#line 564
  if (state->seek) {
    {
#line 565
    state->seek = 0;
#line 566
    tmp = gz_skip(state, state->skip);
    }
#line 566
    if (tmp == -1) {
#line 567
      return ((char *)((void *)0));
    }
  }
#line 573
  str = buf;
#line 574
  left = (unsigned int )len - 1U;
#line 575
  if (left) {
    {
#line 575
    while (1) {
      while_continue: /* CIL Label */ ;
#line 577
      if (state->x.have == 0U) {
        {
#line 577
        tmp___0 = gz_fetch(state);
        }
#line 577
        if (tmp___0 == -1) {
#line 578
          return ((char *)((void *)0));
        }
      }
#line 579
      if (state->x.have == 0U) {
#line 580
        state->past = 1;
#line 581
        goto while_break;
      }
#line 585
      if (state->x.have > left) {
#line 585
        n = left;
      } else {
#line 585
        n = state->x.have;
      }
      {
#line 586
      tmp___1 = memchr((void const   *)state->x.next, '\n', (size_t )n);
#line 586
      eol = (unsigned char *)tmp___1;
      }
#line 587
      if ((unsigned long )eol != (unsigned long )((void *)0)) {
#line 588
        n = (unsigned int )(eol - state->x.next) + 1U;
      }
      {
#line 591
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)state->x.next,
             (size_t )n);
#line 592
      state->x.have -= n;
#line 593
      state->x.next += n;
#line 594
      state->x.pos += (off64_t )n;
#line 595
      left -= n;
#line 596
      buf += n;
      }
#line 575
      if (left) {
#line 575
        if (! ((unsigned long )eol == (unsigned long )((void *)0))) {
#line 575
          goto while_break;
        }
      } else {
#line 575
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 600
  if ((unsigned long )buf == (unsigned long )str) {
#line 601
    return ((char *)((void *)0));
  }
#line 602
  *(buf + 0) = (char)0;
#line 603
  return (str);
}
}
#line 607 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
int gzdirect(gzFile file ) 
{ 
  gz_statep state ;

  {
#line 613
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 614
    return (0);
  }
#line 615
  state = (gz_statep )file;
#line 619
  if (state->mode == 7247) {
#line 619
    if (state->how == 0) {
#line 619
      if (state->x.have == 0U) {
        {
#line 620
        gz_look(state);
        }
      }
    }
  }
#line 623
  return (state->direct);
}
}
#line 627 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzread.c"
int gzclose_r(gzFile file ) 
{ 
  int ret ;
  int err ;
  gz_statep state ;
  int tmp ;

  {
#line 634
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 635
    return (-2);
  }
#line 636
  state = (gz_statep )file;
#line 639
  if (state->mode != 7247) {
#line 640
    return (-2);
  }
#line 643
  if (state->size) {
    {
#line 644
    inflateEnd(& state->strm);
#line 645
    free((void *)state->out);
#line 646
    free((void *)state->in);
    }
  }
#line 648
  if (state->err == -5) {
#line 648
    err = -5;
  } else {
#line 648
    err = 0;
  }
  {
#line 649
  gz_error(state, 0, (char const   *)((void *)0));
#line 650
  free((void *)state->path);
#line 651
  ret = close(state->fd);
#line 652
  free((void *)state);
  }
#line 653
  if (ret) {
#line 653
    tmp = -1;
  } else {
#line 653
    tmp = err;
  }
#line 653
  return (tmp);
}
}
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 348 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek64)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    int __whence ) ;
#line 1358 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
gzFile gzdopen(int fd , char const   *mode ) ;
#line 1381
int gzbuffer(gzFile file , unsigned int size ) ;
#line 1584
int gzrewind(gzFile file ) ;
#line 1612
int gzeof(gzFile file ) ;
#line 1673
char const   *gzerror(gzFile file , int *errnum ) ;
#line 1689
void gzclearerr(gzFile file ) ;
#line 1857
gzFile gzopen64(char const   *path , char const   *mode ) ;
#line 1858
off64_t gzseek64(gzFile file , off64_t offset , int whence ) ;
#line 1859
off64_t gztell64(gzFile file ) ;
#line 1860
off64_t gzoffset64(gzFile file ) ;
#line 1890
gzFile gzopen(char const   *path , char const   *mode ) ;
#line 1891
off_t gzseek(gzFile file , off_t offset , int whence ) ;
#line 1892
off_t gztell(gzFile file ) ;
#line 1893
off_t gzoffset(gzFile file ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
static void gz_reset(gz_statep state ) ;
#line 20
static gzFile gz_open(void const   *path , int fd , char const   *mode ) ;
#line 75 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
static void gz_reset(gz_statep state ) 
{ 


  {
#line 78
  state->x.have = 0U;
#line 79
  if (state->mode == 7247) {
#line 80
    state->eof = 0;
#line 81
    state->past = 0;
#line 82
    state->how = 0;
  }
  {
#line 84
  state->seek = 0;
#line 85
  gz_error(state, 0, (char const   *)((void *)0));
#line 86
  state->x.pos = (off64_t )0;
#line 87
  state->strm.avail_in = (uInt )0;
  }
#line 88
  return;
}
}
#line 91 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
static gzFile gz_open(void const   *path , int fd , char const   *mode ) 
{ 
  gz_statep state ;
  z_size_t len ;
  int oflag ;
  int cloexec ;
  int exclusive ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 100
  cloexec = 0;
#line 103
  exclusive = 0;
#line 107
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 108
    return ((gzFile )((void *)0));
  }
  {
#line 111
  tmp = malloc(sizeof(gz_state ));
#line 111
  state = (gz_statep )tmp;
  }
#line 112
  if ((unsigned long )state == (unsigned long )((void *)0)) {
#line 113
    return ((gzFile )((void *)0));
  }
#line 114
  state->size = 0U;
#line 115
  state->want = 8192U;
#line 116
  state->msg = (char *)((void *)0);
#line 119
  state->mode = 0;
#line 120
  state->level = -1;
#line 121
  state->strategy = 0;
#line 122
  state->direct = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! *mode) {
#line 123
      goto while_break;
    }
#line 124
    if ((int const   )*mode >= 48) {
#line 124
      if ((int const   )*mode <= 57) {
#line 125
        state->level = (int )((int const   )*mode - 48);
      } else {
#line 124
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 128
      if ((int const   )*mode == 114) {
#line 128
        goto case_114;
      }
#line 139
      if ((int const   )*mode == 43) {
#line 139
        goto case_43;
      }
#line 142
      if ((int const   )*mode == 98) {
#line 142
        goto case_98;
      }
#line 145
      if ((int const   )*mode == 101) {
#line 145
        goto case_101;
      }
#line 150
      if ((int const   )*mode == 120) {
#line 150
        goto case_120;
      }
#line 154
      if ((int const   )*mode == 102) {
#line 154
        goto case_102;
      }
#line 157
      if ((int const   )*mode == 104) {
#line 157
        goto case_104;
      }
#line 160
      if ((int const   )*mode == 82) {
#line 160
        goto case_82;
      }
#line 163
      if ((int const   )*mode == 70) {
#line 163
        goto case_70;
      }
#line 166
      if ((int const   )*mode == 84) {
#line 166
        goto case_84;
      }
#line 169
      goto switch_default;
      case_114: /* CIL Label */ 
#line 129
      state->mode = 7247;
#line 130
      goto switch_break;
      case_43: /* CIL Label */ 
      {
#line 140
      free((void *)state);
      }
#line 141
      return ((gzFile )((void *)0));
      case_98: /* CIL Label */ 
#line 143
      goto switch_break;
      case_101: /* CIL Label */ 
#line 146
      cloexec = 1;
#line 147
      goto switch_break;
      case_120: /* CIL Label */ 
#line 151
      exclusive = 1;
#line 152
      goto switch_break;
      case_102: /* CIL Label */ 
#line 155
      state->strategy = 1;
#line 156
      goto switch_break;
      case_104: /* CIL Label */ 
#line 158
      state->strategy = 2;
#line 159
      goto switch_break;
      case_82: /* CIL Label */ 
#line 161
      state->strategy = 3;
#line 162
      goto switch_break;
      case_70: /* CIL Label */ 
#line 164
      state->strategy = 4;
#line 165
      goto switch_break;
      case_84: /* CIL Label */ 
#line 167
      state->direct = 1;
#line 168
      goto switch_break;
      switch_default: /* CIL Label */ ;
      switch_break: /* CIL Label */ ;
      }
    }
#line 172
    mode ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  if (state->mode == 0) {
    {
#line 177
    free((void *)state);
    }
#line 178
    return ((gzFile )((void *)0));
  }
#line 182
  if (state->mode == 7247) {
#line 183
    if (state->direct) {
      {
#line 184
      free((void *)state);
      }
#line 185
      return ((gzFile )((void *)0));
    }
#line 187
    state->direct = 1;
  }
  {
#line 199
  len = strlen((char const   *)path);
#line 200
  tmp___0 = malloc(len + 1UL);
#line 200
  state->path = (char *)tmp___0;
  }
#line 201
  if ((unsigned long )state->path == (unsigned long )((void *)0)) {
    {
#line 202
    free((void *)state);
    }
#line 203
    return ((gzFile )((void *)0));
  }
  {
#line 214
  snprintf((char */* __restrict  */)state->path, len + 1UL, (char const   */* __restrict  */)"%s",
           (char const   *)path);
  }
#line 220
  if (cloexec) {
#line 220
    tmp___1 = 524288;
  } else {
#line 220
    tmp___1 = 0;
  }
#line 220
  if (state->mode == 7247) {
#line 220
    tmp___4 = 0;
  } else {
#line 220
    if (exclusive) {
#line 220
      tmp___2 = 128;
    } else {
#line 220
      tmp___2 = 0;
    }
#line 220
    if (state->mode == 31153) {
#line 220
      tmp___3 = 512;
    } else {
#line 220
      tmp___3 = 1024;
    }
#line 220
    tmp___4 = (65 | tmp___2) | tmp___3;
  }
#line 220
  oflag = tmp___1 | tmp___4;
#line 241
  if (fd > -1) {
#line 241
    state->fd = fd;
  } else {
    {
#line 241
    tmp___5 = open((char const   *)path, oflag, 438);
#line 241
    state->fd = tmp___5;
    }
  }
#line 246
  if (state->fd == -1) {
    {
#line 247
    free((void *)state->path);
#line 248
    free((void *)state);
    }
#line 249
    return ((gzFile )((void *)0));
  }
#line 251
  if (state->mode == 1) {
    {
#line 252
    lseek64(state->fd, (__off64_t )0, 2);
#line 253
    state->mode = 31153;
    }
  }
#line 257
  if (state->mode == 7247) {
    {
#line 258
    state->start = lseek64(state->fd, (__off64_t )0, 1);
    }
#line 259
    if (state->start == -1L) {
#line 259
      state->start = (off64_t )0;
    }
  }
  {
#line 263
  gz_reset(state);
  }
#line 266
  return ((gzFile )state);
}
}
#line 270 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
gzFile gzopen(char const   *path , char const   *mode ) 
{ 
  gzFile tmp ;

  {
  {
#line 274
  tmp = gz_open((void const   *)path, -1, mode);
  }
#line 274
  return (tmp);
}
}
#line 278 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
gzFile gzopen64(char const   *path , char const   *mode ) 
{ 
  gzFile tmp ;

  {
  {
#line 282
  tmp = gz_open((void const   *)path, -1, mode);
  }
#line 282
  return (tmp);
}
}
#line 286 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
gzFile gzdopen(int fd , char const   *mode ) 
{ 
  char *path ;
  gzFile gz ;
  void *tmp ;

  {
#line 293
  if (fd == -1) {
#line 294
    return ((gzFile )((void *)0));
  } else {
    {
#line 293
    tmp = malloc(7UL + 3UL * sizeof(int ));
#line 293
    path = (char *)tmp;
    }
#line 293
    if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 294
      return ((gzFile )((void *)0));
    }
  }
  {
#line 296
  snprintf((char */* __restrict  */)path, 7UL + 3UL * sizeof(int ), (char const   */* __restrict  */)"<fd:%d>",
           fd);
#line 300
  gz = gz_open((void const   *)path, fd, mode);
#line 301
  free((void *)path);
  }
#line 302
  return (gz);
}
}
#line 316 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
int gzbuffer(gzFile file , unsigned int size ) 
{ 
  gz_statep state ;

  {
#line 323
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 324
    return (-1);
  }
#line 325
  state = (gz_statep )file;
#line 326
  if (state->mode != 7247) {
#line 326
    if (state->mode != 31153) {
#line 327
      return (-1);
    }
  }
#line 330
  if (state->size != 0U) {
#line 331
    return (-1);
  }
#line 334
  if (size << 1 < size) {
#line 335
    return (-1);
  }
#line 336
  if (size < 2U) {
#line 337
    size = 2U;
  }
#line 338
  state->want = size;
#line 339
  return (0);
}
}
#line 343 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
int gzrewind(gzFile file ) 
{ 
  gz_statep state ;
  __off64_t tmp ;

  {
#line 349
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 350
    return (-1);
  }
#line 351
  state = (gz_statep )file;
#line 354
  if (state->mode != 7247) {
#line 356
    return (-1);
  } else
#line 354
  if (state->err != 0) {
#line 354
    if (state->err != -5) {
#line 356
      return (-1);
    }
  }
  {
#line 359
  tmp = lseek64(state->fd, state->start, 0);
  }
#line 359
  if (tmp == -1L) {
#line 360
    return (-1);
  }
  {
#line 361
  gz_reset(state);
  }
#line 362
  return (0);
}
}
#line 366 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
off64_t gzseek64(gzFile file , off64_t offset , int whence ) 
{ 
  unsigned int n ;
  off64_t ret ;
  gz_statep state ;
  int tmp ;

  {
#line 376
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 377
    return ((off64_t )-1);
  }
#line 378
  state = (gz_statep )file;
#line 379
  if (state->mode != 7247) {
#line 379
    if (state->mode != 31153) {
#line 380
      return ((off64_t )-1);
    }
  }
#line 383
  if (state->err != 0) {
#line 383
    if (state->err != -5) {
#line 384
      return ((off64_t )-1);
    }
  }
#line 387
  if (whence != 0) {
#line 387
    if (whence != 1) {
#line 388
      return ((off64_t )-1);
    }
  }
#line 391
  if (whence == 0) {
#line 392
    offset -= state->x.pos;
  } else
#line 393
  if (state->seek) {
#line 394
    offset += state->skip;
  }
#line 395
  state->seek = 0;
#line 398
  if (state->mode == 7247) {
#line 398
    if (state->how == 1) {
#line 398
      if (state->x.pos + offset >= 0L) {
        {
#line 400
        ret = lseek64(state->fd, offset - (off64_t )state->x.have, 1);
        }
#line 401
        if (ret == -1L) {
#line 402
          return ((off64_t )-1);
        }
        {
#line 403
        state->x.have = 0U;
#line 404
        state->eof = 0;
#line 405
        state->past = 0;
#line 406
        state->seek = 0;
#line 407
        gz_error(state, 0, (char const   *)((void *)0));
#line 408
        state->strm.avail_in = (uInt )0;
#line 409
        state->x.pos += offset;
        }
#line 410
        return (state->x.pos);
      }
    }
  }
#line 414
  if (offset < 0L) {
#line 415
    if (state->mode != 7247) {
#line 416
      return ((off64_t )-1);
    }
#line 417
    offset += state->x.pos;
#line 418
    if (offset < 0L) {
#line 419
      return ((off64_t )-1);
    }
    {
#line 420
    tmp = gzrewind(file);
    }
#line 420
    if (tmp == -1) {
#line 421
      return ((off64_t )-1);
    }
  }
#line 425
  if (state->mode == 7247) {
#line 426
    if (sizeof(int ) == sizeof(off64_t )) {
#line 426
      if (state->x.have > 2147483647U) {
#line 426
        n = (unsigned int )offset;
      } else {
#line 426
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 426
    if ((off64_t )state->x.have > offset) {
#line 426
      n = (unsigned int )offset;
    } else {
#line 426
      n = state->x.have;
    }
#line 428
    state->x.have -= n;
#line 429
    state->x.next += n;
#line 430
    state->x.pos += (off64_t )n;
#line 431
    offset -= (off64_t )n;
  }
#line 435
  if (offset) {
#line 436
    state->seek = 1;
#line 437
    state->skip = offset;
  }
#line 439
  return (state->x.pos + offset);
}
}
#line 443 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
off_t gzseek(gzFile file , off_t offset , int whence ) 
{ 
  off64_t ret ;
  off_t tmp ;

  {
  {
#line 450
  ret = gzseek64(file, offset, whence);
  }
#line 451
  if (ret == ret) {
#line 451
    tmp = ret;
  } else {
#line 451
    tmp = (off_t )-1;
  }
#line 451
  return (tmp);
}
}
#line 455 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
off64_t gztell64(gzFile file ) 
{ 
  gz_statep state ;
  off64_t tmp ;

  {
#line 461
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 462
    return ((off64_t )-1);
  }
#line 463
  state = (gz_statep )file;
#line 464
  if (state->mode != 7247) {
#line 464
    if (state->mode != 31153) {
#line 465
      return ((off64_t )-1);
    }
  }
#line 468
  if (state->seek) {
#line 468
    tmp = state->skip;
  } else {
#line 468
    tmp = (off64_t )0;
  }
#line 468
  return (state->x.pos + tmp);
}
}
#line 472 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
off_t gztell(gzFile file ) 
{ 
  off64_t ret ;
  off_t tmp ;

  {
  {
#line 477
  ret = gztell64(file);
  }
#line 478
  if (ret == ret) {
#line 478
    tmp = ret;
  } else {
#line 478
    tmp = (off_t )-1;
  }
#line 478
  return (tmp);
}
}
#line 482 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
off64_t gzoffset64(gzFile file ) 
{ 
  off64_t offset ;
  gz_statep state ;

  {
#line 489
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 490
    return ((off64_t )-1);
  }
#line 491
  state = (gz_statep )file;
#line 492
  if (state->mode != 7247) {
#line 492
    if (state->mode != 31153) {
#line 493
      return ((off64_t )-1);
    }
  }
  {
#line 496
  offset = lseek64(state->fd, (__off64_t )0, 1);
  }
#line 497
  if (offset == -1L) {
#line 498
    return ((off64_t )-1);
  }
#line 499
  if (state->mode == 7247) {
#line 500
    offset -= (off64_t )state->strm.avail_in;
  }
#line 501
  return (offset);
}
}
#line 505 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
off_t gzoffset(gzFile file ) 
{ 
  off64_t ret ;
  off_t tmp ;

  {
  {
#line 510
  ret = gzoffset64(file);
  }
#line 511
  if (ret == ret) {
#line 511
    tmp = ret;
  } else {
#line 511
    tmp = (off_t )-1;
  }
#line 511
  return (tmp);
}
}
#line 515 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
int gzeof(gzFile file ) 
{ 
  gz_statep state ;
  int tmp ;

  {
#line 521
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 522
    return (0);
  }
#line 523
  state = (gz_statep )file;
#line 524
  if (state->mode != 7247) {
#line 524
    if (state->mode != 31153) {
#line 525
      return (0);
    }
  }
#line 528
  if (state->mode == 7247) {
#line 528
    tmp = state->past;
  } else {
#line 528
    tmp = 0;
  }
#line 528
  return (tmp);
}
}
#line 532 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
char const   *gzerror(gzFile file , int *errnum ) 
{ 
  gz_statep state ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 539
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 540
    return ((char const   *)((void *)0));
  }
#line 541
  state = (gz_statep )file;
#line 542
  if (state->mode != 7247) {
#line 542
    if (state->mode != 31153) {
#line 543
      return ((char const   *)((void *)0));
    }
  }
#line 546
  if ((unsigned long )errnum != (unsigned long )((void *)0)) {
#line 547
    *errnum = state->err;
  }
#line 548
  if (state->err == -4) {
#line 548
    tmp___0 = "out of memory";
  } else {
#line 548
    if ((unsigned long )state->msg == (unsigned long )((void *)0)) {
#line 548
      tmp = "";
    } else {
#line 548
      tmp = (char const   *)state->msg;
    }
#line 548
    tmp___0 = tmp;
  }
#line 548
  return (tmp___0);
}
}
#line 553 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
void gzclearerr(gzFile file ) 
{ 
  gz_statep state ;

  {
#line 559
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 560
    return;
  }
#line 561
  state = (gz_statep )file;
#line 562
  if (state->mode != 7247) {
#line 562
    if (state->mode != 31153) {
#line 563
      return;
    }
  }
#line 566
  if (state->mode == 7247) {
#line 567
    state->eof = 0;
#line 568
    state->past = 0;
  }
  {
#line 570
  gz_error(state, 0, (char const   *)((void *)0));
  }
#line 571
  return;
}
}
#line 579 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzlib.c"
void __attribute__((__visibility__("hidden")))  gz_error(gz_statep state , int err ,
                                                         char const   *msg ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 585
  if ((unsigned long )state->msg != (unsigned long )((void *)0)) {
#line 586
    if (state->err != -4) {
      {
#line 587
      free((void *)state->msg);
      }
    }
#line 588
    state->msg = (char *)((void *)0);
  }
#line 592
  if (err != 0) {
#line 592
    if (err != -5) {
#line 593
      state->x.have = 0U;
    }
  }
#line 596
  state->err = err;
#line 597
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 598
    return;
  }
#line 601
  if (err == -4) {
#line 602
    return;
  }
  {
#line 605
  tmp___0 = strlen((char const   *)state->path);
#line 605
  tmp___1 = strlen(msg);
#line 605
  tmp___2 = malloc((tmp___0 + tmp___1) + 3UL);
#line 605
  tmp = (char *)tmp___2;
#line 605
  state->msg = tmp;
  }
#line 605
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 607
    state->err = -4;
#line 608
    return;
  }
  {
#line 611
  tmp___3 = strlen((char const   *)state->path);
#line 611
  tmp___4 = strlen(msg);
#line 611
  snprintf((char */* __restrict  */)state->msg, (tmp___3 + tmp___4) + 3UL, (char const   */* __restrict  */)"%s%s%s",
           state->path, ": ", msg);
  }
#line 618
  return;
}
}
#line 1648 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int gzclose(gzFile file ) ;
#line 11 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/gzclose.c"
int gzclose(gzFile file ) 
{ 
  int tmp ;

  {
  {
#line 23
  tmp = gzclose_r(file);
  }
#line 23
  return (tmp);
}
}
#line 629 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int deflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
#line 673
int deflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) ;
#line 695
int deflateCopy(z_streamp dest , z_streamp source ) ;
#line 761
int deflateTune(z_streamp strm , int good_length , int max_lazy , int nice_length ,
                int max_chain ) ;
#line 778
uLong deflateBound(z_streamp strm , uLong sourceLen ) ;
#line 793
int deflatePending(z_streamp strm , unsigned int *pending , int *bits ) ;
#line 808
int deflatePrime(z_streamp strm , int bits , int value ) ;
#line 825
int deflateSetHeader(z_streamp strm , gz_headerp head ) ;
#line 1782
int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) ;
#line 1913
int deflateResetKeep(z_streamp strm ) ;
#line 54 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
char const   deflate_copyright[69]  = 
#line 54 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
  {      (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'l',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'1',      (char const   )'.',      (char const   )'2', 
        (char const   )'.',      (char const   )'1',      (char const   )'1',      (char const   )' ', 
        (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'1',      (char const   )'9', 
        (char const   )'9',      (char const   )'5',      (char const   )'-',      (char const   )'2', 
        (char const   )'0',      (char const   )'1',      (char const   )'7',      (char const   )' ', 
        (char const   )'J',      (char const   )'e',      (char const   )'a',      (char const   )'n', 
        (char const   )'-',      (char const   )'l',      (char const   )'o',      (char const   )'u', 
        (char const   )'p',      (char const   )' ',      (char const   )'G',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'l',      (char const   )'y', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'M',      (char const   )'a',      (char const   )'r', 
        (char const   )'k',      (char const   )' ',      (char const   )'A',      (char const   )'d', 
        (char const   )'l',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'\000'};
#line 76
static int deflateStateCheck(z_streamp strm ) ;
#line 77
static void slide_hash(deflate_state *s ) ;
#line 78
static void fill_window(deflate_state *s ) ;
#line 79
static block_state deflate_stored(deflate_state *s , int flush ) ;
#line 80
static block_state deflate_fast(deflate_state *s , int flush ) ;
#line 82
static block_state deflate_slow(deflate_state *s , int flush ) ;
#line 84
static block_state deflate_rle(deflate_state *s , int flush ) ;
#line 85
static block_state deflate_huff(deflate_state *s , int flush ) ;
#line 86
static void lm_init(deflate_state *s ) ;
#line 87
static void putShortMSB(deflate_state *s , uInt b ) ;
#line 88
static void flush_pending(z_streamp strm ) ;
#line 89
static unsigned int read_buf(z_streamp strm , Bytef *buf , unsigned int size ) ;
#line 95
static uInt longest_match(deflate_state *s , IPos cur_match ) ;
#line 134 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static config const   configuration_table[10]  = 
#line 134
  {      {(ush )0, (ush )0, (ush )0, (ush )0, & deflate_stored}, 
        {(ush )4, (ush )4, (ush )8, (ush )4, & deflate_fast}, 
        {(ush )4, (ush )5, (ush )16, (ush )8, & deflate_fast}, 
        {(ush )4, (ush )6, (ush )32, (ush )32, & deflate_fast}, 
        {(ush )4, (ush )4, (ush )16, (ush )16, & deflate_slow}, 
        {(ush )8, (ush )16, (ush )32, (ush )32, & deflate_slow}, 
        {(ush )8, (ush )16, (ush )128, (ush )128, & deflate_slow}, 
        {(ush )8, (ush )32, (ush )128, (ush )256, & deflate_slow}, 
        {(ush )32, (ush )128, (ush )258, (ush )1024, & deflate_slow}, 
        {(ush )32, (ush )258, (ush )258, (ush )4096, & deflate_slow}};
#line 201 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static void slide_hash(deflate_state *s ) 
{ 
  unsigned int n ;
  unsigned int m ;
  Posf *p ;
  uInt wsize ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 206
  wsize = s->w_size;
#line 208
  n = s->hash_size;
#line 209
  p = s->head + n;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    p --;
#line 211
    m = (unsigned int )*p;
#line 212
    if (m >= wsize) {
#line 212
      tmp = m - wsize;
    } else {
#line 212
      tmp = 0U;
    }
#line 212
    *p = (Pos )tmp;
#line 210
    n --;
#line 210
    if (! n) {
#line 210
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  n = wsize;
#line 216
  p = s->prev + n;
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    p --;
#line 218
    m = (unsigned int )*p;
#line 219
    if (m >= wsize) {
#line 219
      tmp___0 = m - wsize;
    } else {
#line 219
      tmp___0 = 0U;
    }
#line 219
    *p = (Pos )tmp___0;
#line 217
    n --;
#line 217
    if (! n) {
#line 217
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 228 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateInit_(z_streamp strm , int level , char const   *version , int stream_size ) 
{ 
  int tmp ;

  {
  {
#line 234
  tmp = deflateInit2_(strm, level, 8, 15, 8, 0, version, stream_size);
  }
#line 234
  return (tmp);
}
}
#line 253 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static char const   my_version[15]  = 
#line 253
  {      (char const   )'1',      (char const   )'.',      (char const   )'2',      (char const   )'.', 
        (char const   )'1',      (char const   )'1',      (char const   )'-',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'n',      (char const   )'g',      (char const   )'\000'};
#line 240 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateInit2_(z_streamp strm , int level , int method , int windowBits , int memLevel ,
                  int strategy , char const   *version , int stream_size ) 
{ 
  deflate_state *s ;
  int wrap ;
  ushf *overlay ;
  voidpf tmp ;
  voidpf tmp___0 ;
  voidpf tmp___1 ;
  voidpf tmp___2 ;
  voidpf tmp___3 ;
  int tmp___4 ;

  {
#line 252
  wrap = 1;
#line 260
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 262
    return (-6);
  } else
#line 260
  if ((int const   )*(version + 0) != (int const   )my_version[0]) {
#line 262
    return (-6);
  } else
#line 260
  if ((unsigned long )stream_size != sizeof(z_stream )) {
#line 262
    return (-6);
  }
#line 264
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 264
    return (-2);
  }
#line 266
  strm->msg = (char *)0;
#line 267
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 271
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& zcalloc);
#line 272
    strm->opaque = (voidpf )0;
  }
#line 275
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 279
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))(& zcfree);
  }
#line 285
  if (level == -1) {
#line 285
    level = 6;
  }
#line 288
  if (windowBits < 0) {
#line 289
    wrap = 0;
#line 290
    windowBits = - windowBits;
  }
#line 298
  if (memLevel < 1) {
#line 301
    return (-2);
  } else
#line 298
  if (memLevel > 9) {
#line 301
    return (-2);
  } else
#line 298
  if (method != 8) {
#line 301
    return (-2);
  } else
#line 298
  if (windowBits < 8) {
#line 301
    return (-2);
  } else
#line 298
  if (windowBits > 15) {
#line 301
    return (-2);
  } else
#line 298
  if (level < 0) {
#line 301
    return (-2);
  } else
#line 298
  if (level > 9) {
#line 301
    return (-2);
  } else
#line 298
  if (strategy < 0) {
#line 301
    return (-2);
  } else
#line 298
  if (strategy > 4) {
#line 301
    return (-2);
  } else
#line 298
  if (windowBits == 8) {
#line 298
    if (wrap != 1) {
#line 301
      return (-2);
    }
  }
#line 303
  if (windowBits == 8) {
#line 303
    windowBits = 9;
  }
  {
#line 304
  tmp = (*(strm->zalloc))(strm->opaque, (uInt )1, (uInt )sizeof(deflate_state ));
#line 304
  s = (deflate_state *)tmp;
  }
#line 305
  if ((unsigned long )s == (unsigned long )((deflate_state *)0)) {
#line 305
    return (-4);
  }
  {
#line 306
  strm->state = s;
#line 307
  s->strm = strm;
#line 308
  s->status = 42;
#line 310
  s->wrap = wrap;
#line 311
  s->gzhead = (gz_headerp )0;
#line 312
  s->w_bits = (uInt )windowBits;
#line 313
  s->w_size = (uInt )(1 << s->w_bits);
#line 314
  s->w_mask = s->w_size - 1U;
#line 316
  s->hash_bits = (uInt )memLevel + 7U;
#line 317
  s->hash_size = (uInt )(1 << s->hash_bits);
#line 318
  s->hash_mask = s->hash_size - 1U;
#line 319
  s->hash_shift = ((s->hash_bits + 3U) - 1U) / 3U;
#line 321
  tmp___0 = (*(strm->zalloc))(strm->opaque, s->w_size, (uInt )(2UL * sizeof(Byte )));
#line 321
  s->window = (Bytef *)tmp___0;
#line 322
  tmp___1 = (*(strm->zalloc))(strm->opaque, s->w_size, (uInt )sizeof(Pos ));
#line 322
  s->prev = (Posf *)tmp___1;
#line 323
  tmp___2 = (*(strm->zalloc))(strm->opaque, s->hash_size, (uInt )sizeof(Pos ));
#line 323
  s->head = (Posf *)tmp___2;
#line 325
  s->high_water = (ulg )0;
#line 327
  s->lit_bufsize = (uInt )(1 << (memLevel + 6));
#line 329
  tmp___3 = (*(strm->zalloc))(strm->opaque, s->lit_bufsize, (uInt )(sizeof(ush ) + 2UL));
#line 329
  overlay = (ushf *)tmp___3;
#line 330
  s->pending_buf = (uchf *)overlay;
#line 331
  s->pending_buf_size = (ulg )s->lit_bufsize * (sizeof(ush ) + 2UL);
  }
#line 333
  if ((unsigned long )s->window == (unsigned long )((Bytef *)0)) {
    {
#line 335
    s->status = 666;
#line 336
    strm->msg = (char *)z_errmsg[6];
#line 337
    deflateEnd(strm);
    }
#line 338
    return (-4);
  } else
#line 333
  if ((unsigned long )s->prev == (unsigned long )((Posf *)0)) {
    {
#line 335
    s->status = 666;
#line 336
    strm->msg = (char *)z_errmsg[6];
#line 337
    deflateEnd(strm);
    }
#line 338
    return (-4);
  } else
#line 333
  if ((unsigned long )s->head == (unsigned long )((Posf *)0)) {
    {
#line 335
    s->status = 666;
#line 336
    strm->msg = (char *)z_errmsg[6];
#line 337
    deflateEnd(strm);
    }
#line 338
    return (-4);
  } else
#line 333
  if ((unsigned long )s->pending_buf == (unsigned long )((Bytef *)0)) {
    {
#line 335
    s->status = 666;
#line 336
    strm->msg = (char *)z_errmsg[6];
#line 337
    deflateEnd(strm);
    }
#line 338
    return (-4);
  }
  {
#line 340
  s->d_buf = overlay + (unsigned long )s->lit_bufsize / sizeof(ush );
#line 341
  s->l_buf = s->pending_buf + (1UL + sizeof(ush )) * (unsigned long )s->lit_bufsize;
#line 343
  s->level = level;
#line 344
  s->strategy = strategy;
#line 345
  s->method = (Byte )method;
#line 347
  tmp___4 = deflateReset(strm);
  }
#line 347
  return (tmp___4);
}
}
#line 353 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static int deflateStateCheck(z_streamp strm ) 
{ 
  deflate_state *s ;

  {
#line 357
  if ((unsigned long )strm == (unsigned long )((z_streamp )0)) {
#line 359
    return (1);
  } else
#line 357
  if ((unsigned long )strm->zalloc == (unsigned long )((voidpf (*)(voidpf opaque ,
                                                                   uInt items , uInt size ))0)) {
#line 359
    return (1);
  } else
#line 357
  if ((unsigned long )strm->zfree == (unsigned long )((void (*)(voidpf opaque , voidpf address ))0)) {
#line 359
    return (1);
  }
#line 360
  s = strm->state;
#line 361
  if ((unsigned long )s == (unsigned long )((deflate_state *)0)) {
#line 371
    return (1);
  } else
#line 361
  if ((unsigned long )s->strm != (unsigned long )strm) {
#line 371
    return (1);
  } else
#line 361
  if (s->status != 42) {
#line 361
    if (s->status != 69) {
#line 361
      if (s->status != 73) {
#line 361
        if (s->status != 91) {
#line 361
          if (s->status != 103) {
#line 361
            if (s->status != 113) {
#line 361
              if (s->status != 666) {
#line 371
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 372
  return (0);
}
}
#line 376 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) 
{ 
  deflate_state *s ;
  uInt str ;
  uInt n ;
  int wrap ;
  unsigned int avail ;
  unsigned char *next ;
  int tmp ;
  uInt tmp___0 ;

  {
  {
#line 387
  tmp = deflateStateCheck(strm);
  }
#line 387
  if (tmp) {
#line 388
    return (-2);
  } else
#line 387
  if ((unsigned long )dictionary == (unsigned long )((Bytef const   *)0)) {
#line 388
    return (-2);
  }
#line 389
  s = strm->state;
#line 390
  wrap = s->wrap;
#line 391
  if (wrap == 2) {
#line 392
    return (-2);
  } else
#line 391
  if (wrap == 1) {
#line 391
    if (s->status != 42) {
#line 392
      return (-2);
    } else {
#line 391
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 391
  if (s->lookahead) {
#line 392
    return (-2);
  }
#line 395
  if (wrap == 1) {
    {
#line 396
    strm->adler = adler32(strm->adler, dictionary, dictLength);
    }
  }
#line 397
  s->wrap = 0;
#line 400
  if (dictLength >= s->w_size) {
#line 401
    if (wrap == 0) {
      {
#line 402
      *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 402
      memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
#line 403
      s->strstart = (uInt )0;
#line 404
      s->block_start = 0L;
#line 405
      s->insert = (uInt )0;
      }
    }
#line 407
    dictionary += dictLength - s->w_size;
#line 408
    dictLength = s->w_size;
  }
  {
#line 412
  avail = strm->avail_in;
#line 413
  next = strm->next_in;
#line 414
  strm->avail_in = dictLength;
#line 415
  strm->next_in = (Bytef *)dictionary;
#line 416
  fill_window(s);
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (s->lookahead >= 3U)) {
#line 417
      goto while_break;
    }
#line 418
    str = s->strstart;
#line 419
    n = s->lookahead - 2U;
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 421
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + ((str + 3U) - 1U))) & s->hash_mask;
#line 423
      *(s->prev + (str & s->w_mask)) = *(s->head + s->ins_h);
#line 425
      *(s->head + s->ins_h) = (Pos )str;
#line 426
      str ++;
#line 420
      n --;
#line 420
      if (! n) {
#line 420
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 428
    s->strstart = str;
#line 429
    s->lookahead = (uInt )2;
#line 430
    fill_window(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  s->strstart += s->lookahead;
#line 433
  s->block_start = (long )s->strstart;
#line 434
  s->insert = s->lookahead;
#line 435
  s->lookahead = (uInt )0;
#line 436
  tmp___0 = (uInt )2;
#line 436
  s->prev_length = tmp___0;
#line 436
  s->match_length = tmp___0;
#line 437
  s->match_available = 0;
#line 438
  strm->next_in = next;
#line 439
  strm->avail_in = avail;
#line 440
  s->wrap = wrap;
#line 441
  return (0);
}
}
#line 445 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateGetDictionary(z_streamp strm , Bytef *dictionary , uInt *dictLength ) 
{ 
  deflate_state *s ;
  uInt len ;
  int tmp ;

  {
  {
#line 453
  tmp = deflateStateCheck(strm);
  }
#line 453
  if (tmp) {
#line 454
    return (-2);
  }
#line 455
  s = strm->state;
#line 456
  len = s->strstart + s->lookahead;
#line 457
  if (len > s->w_size) {
#line 458
    len = s->w_size;
  }
#line 459
  if ((unsigned long )dictionary != (unsigned long )((Bytef *)0)) {
#line 459
    if (len) {
      {
#line 460
      memcpy((void */* __restrict  */)dictionary, (void const   */* __restrict  */)(((s->window + s->strstart) + s->lookahead) - len),
             (size_t )len);
      }
    }
  }
#line 461
  if ((unsigned long )dictLength != (unsigned long )((uInt *)0)) {
#line 462
    *dictLength = len;
  }
#line 463
  return (0);
}
}
#line 467 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateResetKeep(z_streamp strm ) 
{ 
  deflate_state *s ;
  int tmp ;
  uLong tmp___0 ;

  {
  {
#line 472
  tmp = deflateStateCheck(strm);
  }
#line 472
  if (tmp) {
#line 473
    return (-2);
  }
#line 476
  tmp___0 = (uLong )0;
#line 476
  strm->total_out = tmp___0;
#line 476
  strm->total_in = tmp___0;
#line 477
  strm->msg = (char *)0;
#line 478
  strm->data_type = 2;
#line 480
  s = strm->state;
#line 481
  s->pending = (ulg )0;
#line 482
  s->pending_out = s->pending_buf;
#line 484
  if (s->wrap < 0) {
#line 485
    s->wrap = - s->wrap;
  }
#line 487
  if (s->wrap) {
#line 487
    s->status = 42;
  } else {
#line 487
    s->status = 113;
  }
  {
#line 492
  strm->adler = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 497
  s->last_flush = 0;
#line 499
  _tr_init(s);
  }
#line 501
  return (0);
}
}
#line 505 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateReset(z_streamp strm ) 
{ 
  int ret ;

  {
  {
#line 510
  ret = deflateResetKeep(strm);
  }
#line 511
  if (ret == 0) {
    {
#line 512
    lm_init(strm->state);
    }
  }
#line 513
  return (ret);
}
}
#line 517 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateSetHeader(z_streamp strm , gz_headerp head ) 
{ 
  int tmp ;

  {
  {
#line 521
  tmp = deflateStateCheck(strm);
  }
#line 521
  if (tmp) {
#line 522
    return (-2);
  } else
#line 521
  if ((strm->state)->wrap != 2) {
#line 522
    return (-2);
  }
#line 523
  (strm->state)->gzhead = head;
#line 524
  return (0);
}
}
#line 528 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflatePending(z_streamp strm , unsigned int *pending , int *bits ) 
{ 
  int tmp ;

  {
  {
#line 533
  tmp = deflateStateCheck(strm);
  }
#line 533
  if (tmp) {
#line 533
    return (-2);
  }
#line 534
  if ((unsigned long )pending != (unsigned long )((unsigned int *)0)) {
#line 535
    *pending = (unsigned int )(strm->state)->pending;
  }
#line 536
  if ((unsigned long )bits != (unsigned long )((int *)0)) {
#line 537
    *bits = (strm->state)->bi_valid;
  }
#line 538
  return (0);
}
}
#line 542 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflatePrime(z_streamp strm , int bits , int value ) 
{ 
  deflate_state *s ;
  int put ;
  int tmp ;

  {
  {
#line 550
  tmp = deflateStateCheck(strm);
  }
#line 550
  if (tmp) {
#line 550
    return (-2);
  }
#line 551
  s = strm->state;
#line 552
  if ((unsigned long )((Bytef *)s->d_buf) < (unsigned long )(s->pending_out + (23 >> 3))) {
#line 553
    return (-5);
  }
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    put = 16 - s->bi_valid;
#line 556
    if (put > bits) {
#line 557
      put = bits;
    }
    {
#line 558
    s->bi_buf = (ush )((int )s->bi_buf | (int )((ush )((value & ((1 << put) - 1)) << s->bi_valid)));
#line 559
    s->bi_valid += put;
#line 560
    _tr_flush_bits(s);
#line 561
    value >>= put;
#line 562
    bits -= put;
    }
#line 554
    if (! bits) {
#line 554
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return (0);
}
}
#line 568 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateParams(z_streamp strm , int level , int strategy ) 
{ 
  deflate_state *s ;
  block_state (*func)(deflate_state *s , int flush ) ;
  int tmp ;
  int err ;
  int tmp___0 ;

  {
  {
#line 576
  tmp = deflateStateCheck(strm);
  }
#line 576
  if (tmp) {
#line 576
    return (-2);
  }
#line 577
  s = strm->state;
#line 582
  if (level == -1) {
#line 582
    level = 6;
  }
#line 584
  if (level < 0) {
#line 585
    return (-2);
  } else
#line 584
  if (level > 9) {
#line 585
    return (-2);
  } else
#line 584
  if (strategy < 0) {
#line 585
    return (-2);
  } else
#line 584
  if (strategy > 4) {
#line 585
    return (-2);
  }
#line 587
  func = (block_state (*)(deflate_state *s , int flush ))configuration_table[s->level].func;
#line 589
  if (strategy != s->strategy) {
#line 589
    goto _L;
  } else
#line 589
  if ((unsigned long )func != (unsigned long )configuration_table[level].func) {
    _L: /* CIL Label */ 
#line 589
    if (s->high_water) {
      {
#line 592
      tmp___0 = deflate(strm, 5);
#line 592
      err = tmp___0;
      }
#line 593
      if (err == -2) {
#line 594
        return (err);
      }
#line 595
      if (strm->avail_out == 0U) {
#line 596
        return (-5);
      }
    }
  }
#line 598
  if (s->level != level) {
#line 599
    if (s->level == 0) {
#line 599
      if (s->matches != 0U) {
#line 600
        if (s->matches == 1U) {
          {
#line 601
          slide_hash(s);
          }
        } else {
#line 603
          *(s->head + (s->hash_size - 1U)) = (Posf )0;
        }
        {
#line 603
        memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
#line 604
        s->matches = (uInt )0;
        }
      }
    }
#line 606
    s->level = level;
#line 607
    s->max_lazy_match = (uInt )configuration_table[level].max_lazy;
#line 608
    s->good_match = (uInt )configuration_table[level].good_length;
#line 609
    s->nice_match = (int )configuration_table[level].nice_length;
#line 610
    s->max_chain_length = (uInt )configuration_table[level].max_chain;
  }
#line 612
  s->strategy = strategy;
#line 613
  return (0);
}
}
#line 617 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateTune(z_streamp strm , int good_length , int max_lazy , int nice_length ,
                int max_chain ) 
{ 
  deflate_state *s ;
  int tmp ;

  {
  {
#line 626
  tmp = deflateStateCheck(strm);
  }
#line 626
  if (tmp) {
#line 626
    return (-2);
  }
#line 627
  s = strm->state;
#line 628
  s->good_match = (uInt )good_length;
#line 629
  s->max_lazy_match = (uInt )max_lazy;
#line 630
  s->nice_match = nice_length;
#line 631
  s->max_chain_length = (uInt )max_chain;
#line 632
  return (0);
}
}
#line 652 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
uLong deflateBound(z_streamp strm , uLong sourceLen ) 
{ 
  deflate_state *s ;
  uLong complen ;
  uLong wraplen ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 660
  complen = ((sourceLen + ((sourceLen + 7UL) >> 3)) + ((sourceLen + 63UL) >> 6)) + 5UL;
#line 664
  tmp = deflateStateCheck(strm);
  }
#line 664
  if (tmp) {
#line 665
    return (complen + 6UL);
  }
#line 668
  s = strm->state;
  {
#line 670
  if (s->wrap == 0) {
#line 670
    goto case_0;
  }
#line 673
  if (s->wrap == 1) {
#line 673
    goto case_1;
  }
#line 698
  goto switch_default;
  case_0: /* CIL Label */ 
#line 671
  wraplen = (uLong )0;
#line 672
  goto switch_break;
  case_1: /* CIL Label */ 
#line 674
  if (s->strstart) {
#line 674
    tmp___0 = 4;
  } else {
#line 674
    tmp___0 = 0;
  }
#line 674
  wraplen = (uLong )(6 + tmp___0);
#line 675
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 699
  wraplen = (uLong )6;
  switch_break: /* CIL Label */ ;
  }
#line 703
  if (s->w_bits != 15U) {
#line 704
    return (complen + wraplen);
  } else
#line 703
  if (s->hash_bits != 15U) {
#line 704
    return (complen + wraplen);
  }
#line 707
  return ((((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + 13UL) - 6UL) + wraplen);
}
}
#line 716 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static void putShortMSB(deflate_state *s , uInt b ) 
{ 
  ulg tmp ;
  ulg tmp___0 ;

  {
#line 720
  tmp = s->pending;
#line 720
  (s->pending) ++;
#line 720
  *(s->pending_buf + tmp) = (Byte )(b >> 8);
#line 721
  tmp___0 = s->pending;
#line 721
  (s->pending) ++;
#line 721
  *(s->pending_buf + tmp___0) = (Byte )(b & 255U);
#line 722
  return;
}
}
#line 730 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static void flush_pending(z_streamp strm ) 
{ 
  unsigned int len ;
  deflate_state *s ;

  {
  {
#line 734
  s = strm->state;
#line 736
  _tr_flush_bits(s);
#line 737
  len = (unsigned int )s->pending;
  }
#line 738
  if (len > strm->avail_out) {
#line 738
    len = strm->avail_out;
  }
#line 739
  if (len == 0U) {
#line 739
    return;
  }
  {
#line 741
  memcpy((void */* __restrict  */)strm->next_out, (void const   */* __restrict  */)s->pending_out,
         (size_t )len);
#line 742
  strm->next_out += len;
#line 743
  s->pending_out += len;
#line 744
  strm->total_out += (uLong )len;
#line 745
  strm->avail_out -= len;
#line 746
  s->pending -= (ulg )len;
  }
#line 747
  if (s->pending == 0UL) {
#line 748
    s->pending_out = s->pending_buf;
  }
#line 750
  return;
}
}
#line 763 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflate(z_streamp strm , int flush ) 
{ 
  int old_flush ;
  deflate_state *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uInt header ;
  uInt level_flags ;
  block_state bstate ;
  block_state tmp___2 ;
  block_state tmp___3 ;
  block_state tmp___4 ;
  block_state tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 770
  tmp = deflateStateCheck(strm);
  }
#line 770
  if (tmp) {
#line 771
    return (-2);
  } else
#line 770
  if (flush > 5) {
#line 771
    return (-2);
  } else
#line 770
  if (flush < 0) {
#line 771
    return (-2);
  }
#line 773
  s = strm->state;
#line 775
  if ((unsigned long )strm->next_out == (unsigned long )((Bytef *)0)) {
#line 778
    strm->msg = (char *)z_errmsg[4];
#line 778
    return (-2);
  } else
#line 775
  if (strm->avail_in != 0U) {
#line 775
    if ((unsigned long )strm->next_in == (unsigned long )((Bytef *)0)) {
#line 778
      strm->msg = (char *)z_errmsg[4];
#line 778
      return (-2);
    } else {
#line 775
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 775
  if (s->status == 666) {
#line 775
    if (flush != 4) {
#line 778
      strm->msg = (char *)z_errmsg[4];
#line 778
      return (-2);
    }
  }
#line 780
  if (strm->avail_out == 0U) {
#line 780
    strm->msg = (char *)z_errmsg[7];
#line 780
    return (-5);
  }
#line 782
  old_flush = s->last_flush;
#line 783
  s->last_flush = flush;
#line 786
  if (s->pending != 0UL) {
    {
#line 787
    flush_pending(strm);
    }
#line 788
    if (strm->avail_out == 0U) {
#line 795
      s->last_flush = -1;
#line 796
      return (0);
    }
  } else
#line 803
  if (strm->avail_in == 0U) {
#line 803
    if (flush > 4) {
#line 803
      tmp___0 = 9;
    } else {
#line 803
      tmp___0 = 0;
    }
#line 803
    if (old_flush > 4) {
#line 803
      tmp___1 = 9;
    } else {
#line 803
      tmp___1 = 0;
    }
#line 803
    if (flush * 2 - tmp___0 <= old_flush * 2 - tmp___1) {
#line 803
      if (flush != 4) {
#line 805
        strm->msg = (char *)z_errmsg[7];
#line 805
        return (-5);
      }
    }
  }
#line 809
  if (s->status == 666) {
#line 809
    if (strm->avail_in != 0U) {
#line 810
      strm->msg = (char *)z_errmsg[7];
#line 810
      return (-5);
    }
  }
#line 814
  if (s->status == 42) {
#line 816
    header = (8U + ((s->w_bits - 8U) << 4)) << 8;
#line 819
    if (s->strategy >= 2) {
#line 820
      level_flags = (uInt )0;
    } else
#line 819
    if (s->level < 2) {
#line 820
      level_flags = (uInt )0;
    } else
#line 821
    if (s->level < 6) {
#line 822
      level_flags = (uInt )1;
    } else
#line 823
    if (s->level == 6) {
#line 824
      level_flags = (uInt )2;
    } else {
#line 826
      level_flags = (uInt )3;
    }
#line 827
    header |= level_flags << 6;
#line 828
    if (s->strstart != 0U) {
#line 828
      header |= 32U;
    }
    {
#line 829
    header += 31U - header % 31U;
#line 831
    putShortMSB(s, header);
    }
#line 834
    if (s->strstart != 0U) {
      {
#line 835
      putShortMSB(s, (uInt )(strm->adler >> 16));
#line 836
      putShortMSB(s, (uInt )(strm->adler & 65535UL));
      }
    }
    {
#line 838
    strm->adler = adler32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 839
    s->status = 113;
#line 842
    flush_pending(strm);
    }
#line 843
    if (s->pending != 0UL) {
#line 844
      s->last_flush = -1;
#line 845
      return (0);
    }
  }
#line 996
  if (strm->avail_in != 0U) {
#line 996
    goto _L___1;
  } else
#line 996
  if (s->lookahead != 0U) {
#line 996
    goto _L___1;
  } else
#line 996
  if (flush != 0) {
#line 996
    if (s->status != 666) {
      _L___1: /* CIL Label */ 
#line 1000
      if (s->level == 0) {
        {
#line 1000
        tmp___2 = deflate_stored(s, flush);
#line 1000
        bstate = tmp___2;
        }
      } else {
#line 1000
        if (s->strategy == 2) {
          {
#line 1000
          tmp___3 = deflate_huff(s, flush);
#line 1000
          tmp___7 = (unsigned int )tmp___3;
          }
        } else {
#line 1000
          if (s->strategy == 3) {
            {
#line 1000
            tmp___4 = deflate_rle(s, flush);
#line 1000
            tmp___6 = (unsigned int )tmp___4;
            }
          } else {
            {
#line 1000
            tmp___5 = (*(configuration_table[s->level].func))(s, flush);
#line 1000
            tmp___6 = (unsigned int )tmp___5;
            }
          }
#line 1000
          tmp___7 = tmp___6;
        }
#line 1000
        bstate = (block_state )tmp___7;
      }
#line 1005
      if ((unsigned int )bstate == 2U) {
#line 1006
        s->status = 666;
      } else
#line 1005
      if ((unsigned int )bstate == 3U) {
#line 1006
        s->status = 666;
      }
#line 1008
      if ((unsigned int )bstate == 0U) {
#line 1008
        goto _L___0;
      } else
#line 1008
      if ((unsigned int )bstate == 2U) {
        _L___0: /* CIL Label */ 
#line 1009
        if (strm->avail_out == 0U) {
#line 1010
          s->last_flush = -1;
        }
#line 1012
        return (0);
      }
#line 1021
      if ((unsigned int )bstate == 1U) {
#line 1022
        if (flush == 1) {
          {
#line 1023
          _tr_align(s);
          }
        } else
#line 1024
        if (flush != 5) {
          {
#line 1025
          _tr_stored_block(s, (char *)0, (ulg )0L, 0);
          }
#line 1029
          if (flush == 3) {
            {
#line 1030
            *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 1030
            memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
            }
#line 1031
            if (s->lookahead == 0U) {
#line 1032
              s->strstart = (uInt )0;
#line 1033
              s->block_start = 0L;
#line 1034
              s->insert = (uInt )0;
            }
          }
        }
        {
#line 1038
        flush_pending(strm);
        }
#line 1039
        if (strm->avail_out == 0U) {
#line 1040
          s->last_flush = -1;
#line 1041
          return (0);
        }
      }
    }
  }
#line 1046
  if (flush != 4) {
#line 1046
    return (0);
  }
#line 1047
  if (s->wrap <= 0) {
#line 1047
    return (1);
  }
  {
#line 1064
  putShortMSB(s, (uInt )(strm->adler >> 16));
#line 1065
  putShortMSB(s, (uInt )(strm->adler & 65535UL));
#line 1067
  flush_pending(strm);
  }
#line 1071
  if (s->wrap > 0) {
#line 1071
    s->wrap = - s->wrap;
  }
#line 1072
  if (s->pending != 0UL) {
#line 1072
    tmp___8 = 0;
  } else {
#line 1072
    tmp___8 = 1;
  }
#line 1072
  return (tmp___8);
}
}
#line 1076 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateEnd(z_streamp strm ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1081
  tmp = deflateStateCheck(strm);
  }
#line 1081
  if (tmp) {
#line 1081
    return (-2);
  }
#line 1083
  status = (strm->state)->status;
#line 1086
  if ((strm->state)->pending_buf) {
    {
#line 1086
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->pending_buf);
    }
  }
#line 1087
  if ((strm->state)->head) {
    {
#line 1087
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->head);
    }
  }
#line 1088
  if ((strm->state)->prev) {
    {
#line 1088
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->prev);
    }
  }
#line 1089
  if ((strm->state)->window) {
    {
#line 1089
    (*(strm->zfree))(strm->opaque, (voidpf )(strm->state)->window);
    }
  }
  {
#line 1091
  (*(strm->zfree))(strm->opaque, (voidpf )strm->state);
#line 1092
  strm->state = (struct internal_state *)0;
  }
#line 1094
  if (status == 113) {
#line 1094
    tmp___0 = -3;
  } else {
#line 1094
    tmp___0 = 0;
  }
#line 1094
  return (tmp___0);
}
}
#line 1102 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
int deflateCopy(z_streamp dest , z_streamp source ) 
{ 
  deflate_state *ds ;
  deflate_state *ss ;
  ushf *overlay ;
  int tmp ;
  voidpf tmp___0 ;
  voidpf tmp___1 ;
  voidpf tmp___2 ;
  voidpf tmp___3 ;
  voidpf tmp___4 ;

  {
  {
#line 1114
  tmp = deflateStateCheck(source);
  }
#line 1114
  if (tmp) {
#line 1115
    return (-2);
  } else
#line 1114
  if ((unsigned long )dest == (unsigned long )((z_streamp )0)) {
#line 1115
    return (-2);
  }
  {
#line 1118
  ss = source->state;
#line 1120
  memcpy((void */* __restrict  */)((voidpf )dest), (void const   */* __restrict  */)((voidpf )source),
         sizeof(z_stream ));
#line 1122
  tmp___0 = (*(dest->zalloc))(dest->opaque, (uInt )1, (uInt )sizeof(deflate_state ));
#line 1122
  ds = (deflate_state *)tmp___0;
  }
#line 1123
  if ((unsigned long )ds == (unsigned long )((deflate_state *)0)) {
#line 1123
    return (-4);
  }
  {
#line 1124
  dest->state = ds;
#line 1125
  memcpy((void */* __restrict  */)((voidpf )ds), (void const   */* __restrict  */)((voidpf )ss),
         sizeof(deflate_state ));
#line 1126
  ds->strm = dest;
#line 1128
  tmp___1 = (*(dest->zalloc))(dest->opaque, ds->w_size, (uInt )(2UL * sizeof(Byte )));
#line 1128
  ds->window = (Bytef *)tmp___1;
#line 1129
  tmp___2 = (*(dest->zalloc))(dest->opaque, ds->w_size, (uInt )sizeof(Pos ));
#line 1129
  ds->prev = (Posf *)tmp___2;
#line 1130
  tmp___3 = (*(dest->zalloc))(dest->opaque, ds->hash_size, (uInt )sizeof(Pos ));
#line 1130
  ds->head = (Posf *)tmp___3;
#line 1131
  tmp___4 = (*(dest->zalloc))(dest->opaque, ds->lit_bufsize, (uInt )(sizeof(ush ) + 2UL));
#line 1131
  overlay = (ushf *)tmp___4;
#line 1132
  ds->pending_buf = (uchf *)overlay;
  }
#line 1134
  if ((unsigned long )ds->window == (unsigned long )((Bytef *)0)) {
    {
#line 1136
    deflateEnd(dest);
    }
#line 1137
    return (-4);
  } else
#line 1134
  if ((unsigned long )ds->prev == (unsigned long )((Posf *)0)) {
    {
#line 1136
    deflateEnd(dest);
    }
#line 1137
    return (-4);
  } else
#line 1134
  if ((unsigned long )ds->head == (unsigned long )((Posf *)0)) {
    {
#line 1136
    deflateEnd(dest);
    }
#line 1137
    return (-4);
  } else
#line 1134
  if ((unsigned long )ds->pending_buf == (unsigned long )((Bytef *)0)) {
    {
#line 1136
    deflateEnd(dest);
    }
#line 1137
    return (-4);
  }
  {
#line 1140
  memcpy((void */* __restrict  */)ds->window, (void const   */* __restrict  */)ss->window,
         (unsigned long )(ds->w_size * 2U) * sizeof(Byte ));
#line 1141
  memcpy((void */* __restrict  */)((voidpf )ds->prev), (void const   */* __restrict  */)((voidpf )ss->prev),
         (unsigned long )ds->w_size * sizeof(Pos ));
#line 1142
  memcpy((void */* __restrict  */)((voidpf )ds->head), (void const   */* __restrict  */)((voidpf )ss->head),
         (unsigned long )ds->hash_size * sizeof(Pos ));
#line 1143
  memcpy((void */* __restrict  */)ds->pending_buf, (void const   */* __restrict  */)ss->pending_buf,
         (size_t )((uInt )ds->pending_buf_size));
#line 1145
  ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
#line 1146
  ds->d_buf = overlay + (unsigned long )ds->lit_bufsize / sizeof(ush );
#line 1147
  ds->l_buf = ds->pending_buf + (1UL + sizeof(ush )) * (unsigned long )ds->lit_bufsize;
#line 1149
  ds->l_desc.dyn_tree = ds->dyn_ltree;
#line 1150
  ds->d_desc.dyn_tree = ds->dyn_dtree;
#line 1151
  ds->bl_desc.dyn_tree = ds->bl_tree;
  }
#line 1153
  return (0);
}
}
#line 1164 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static unsigned int read_buf(z_streamp strm , Bytef *buf , unsigned int size ) 
{ 
  unsigned int len ;

  {
#line 1169
  len = strm->avail_in;
#line 1171
  if (len > size) {
#line 1171
    len = size;
  }
#line 1172
  if (len == 0U) {
#line 1172
    return (0U);
  }
  {
#line 1174
  strm->avail_in -= len;
#line 1176
  memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)strm->next_in,
         (size_t )len);
  }
#line 1177
  if ((strm->state)->wrap == 1) {
    {
#line 1178
    strm->adler = adler32(strm->adler, (Bytef const   *)buf, len);
    }
  }
#line 1185
  strm->next_in += len;
#line 1186
  strm->total_in += (uLong )len;
#line 1188
  return (len);
}
}
#line 1194 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static void lm_init(deflate_state *s ) 
{ 
  uInt tmp ;

  {
  {
#line 1197
  s->window_size = 2UL * (ulg )s->w_size;
#line 1199
  *(s->head + (s->hash_size - 1U)) = (Posf )0;
#line 1199
  memset((void *)((Bytef *)s->head), 0, (unsigned long )(s->hash_size - 1U) * sizeof(*(s->head)));
#line 1203
  s->max_lazy_match = (uInt )configuration_table[s->level].max_lazy;
#line 1204
  s->good_match = (uInt )configuration_table[s->level].good_length;
#line 1205
  s->nice_match = (int )configuration_table[s->level].nice_length;
#line 1206
  s->max_chain_length = (uInt )configuration_table[s->level].max_chain;
#line 1208
  s->strstart = (uInt )0;
#line 1209
  s->block_start = 0L;
#line 1210
  s->lookahead = (uInt )0;
#line 1211
  s->insert = (uInt )0;
#line 1212
  tmp = (uInt )2;
#line 1212
  s->prev_length = tmp;
#line 1212
  s->match_length = tmp;
#line 1213
  s->match_available = 0;
#line 1214
  s->ins_h = (uInt )0;
  }
#line 1220
  return;
}
}
#line 1236 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static uInt longest_match(deflate_state *s , IPos cur_match ) 
{ 
  unsigned int chain_length ;
  register Bytef *scan ;
  register Bytef *match ;
  register int len ;
  int best_len ;
  int nice_match ;
  IPos limit ;
  uInt tmp ;
  Posf *prev ;
  uInt wmask ;
  register Bytef *strend ;
  register Byte scan_end1 ;
  register Byte scan_end ;

  {
#line 1240
  chain_length = s->max_chain_length;
#line 1241
  scan = s->window + s->strstart;
#line 1244
  best_len = (int )s->prev_length;
#line 1245
  nice_match = s->nice_match;
#line 1246
  if (s->strstart > s->w_size - 262U) {
#line 1246
    tmp = s->strstart - (s->w_size - 262U);
  } else {
#line 1246
    tmp = (uInt )0;
  }
#line 1246
  limit = tmp;
#line 1251
  prev = s->prev;
#line 1252
  wmask = s->w_mask;
#line 1262
  strend = (s->window + s->strstart) + 258;
#line 1263
  scan_end1 = *(scan + (best_len - 1));
#line 1264
  scan_end = *(scan + best_len);
#line 1273
  if (s->prev_length >= s->good_match) {
#line 1274
    chain_length >>= 2;
  }
#line 1279
  if ((uInt )nice_match > s->lookahead) {
#line 1279
    nice_match = (int )s->lookahead;
  }
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1285
    match = s->window + cur_match;
#line 1330
    if ((int )*(match + best_len) != (int )scan_end) {
#line 1333
      goto __Cont;
    } else
#line 1330
    if ((int )*(match + (best_len - 1)) != (int )scan_end1) {
#line 1333
      goto __Cont;
    } else
#line 1330
    if ((int )*match != (int )*scan) {
#line 1333
      goto __Cont;
    } else {
#line 1330
      match ++;
#line 1330
      if ((int )*match != (int )*(scan + 1)) {
#line 1333
        goto __Cont;
      }
    }
#line 1341
    scan += 2;
#line 1341
    match ++;
    {
#line 1347
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1347
      scan ++;
#line 1347
      match ++;
#line 1347
      if ((int )*scan == (int )*match) {
#line 1347
        scan ++;
#line 1347
        match ++;
#line 1347
        if ((int )*scan == (int )*match) {
#line 1347
          scan ++;
#line 1347
          match ++;
#line 1347
          if ((int )*scan == (int )*match) {
#line 1347
            scan ++;
#line 1347
            match ++;
#line 1347
            if ((int )*scan == (int )*match) {
#line 1347
              scan ++;
#line 1347
              match ++;
#line 1347
              if ((int )*scan == (int )*match) {
#line 1347
                scan ++;
#line 1347
                match ++;
#line 1347
                if ((int )*scan == (int )*match) {
#line 1347
                  scan ++;
#line 1347
                  match ++;
#line 1347
                  if ((int )*scan == (int )*match) {
#line 1347
                    scan ++;
#line 1347
                    match ++;
#line 1347
                    if ((int )*scan == (int )*match) {
#line 1347
                      if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 1347
                        goto while_break___0;
                      }
                    } else {
#line 1347
                      goto while_break___0;
                    }
                  } else {
#line 1347
                    goto while_break___0;
                  }
                } else {
#line 1347
                  goto while_break___0;
                }
              } else {
#line 1347
                goto while_break___0;
              }
            } else {
#line 1347
              goto while_break___0;
            }
          } else {
#line 1347
            goto while_break___0;
          }
        } else {
#line 1347
          goto while_break___0;
        }
      } else {
#line 1347
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1356
    len = 258 - (int )(strend - scan);
#line 1357
    scan = strend - 258;
#line 1361
    if (len > best_len) {
#line 1362
      s->match_start = cur_match;
#line 1363
      best_len = len;
#line 1364
      if (len >= nice_match) {
#line 1364
        goto while_break;
      }
#line 1368
      scan_end1 = *(scan + (best_len - 1));
#line 1369
      scan_end = *(scan + best_len);
    }
    __Cont: /* CIL Label */ 
#line 1283
    cur_match = (IPos )*(prev + (cur_match & wmask));
#line 1283
    if (cur_match > limit) {
#line 1283
      chain_length --;
#line 1283
      if (! (chain_length != 0U)) {
#line 1283
        goto while_break;
      }
    } else {
#line 1283
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1375
  if ((uInt )best_len <= s->lookahead) {
#line 1375
    return ((uInt )best_len);
  }
#line 1376
  return (s->lookahead);
}
}
#line 1482 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static void fill_window(deflate_state *s ) 
{ 
  unsigned int n ;
  unsigned int more ;
  uInt wsize ;
  uInt str ;
  ulg curr ;
  ulg init ;

  {
#line 1487
  wsize = s->w_size;
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1492
    more = (unsigned int )((s->window_size - (ulg )s->lookahead) - (ulg )s->strstart);
#line 1495
    if (sizeof(int ) <= 2UL) {
#line 1496
      if (more == 0U) {
#line 1496
        if (s->strstart == 0U) {
#line 1496
          if (s->lookahead == 0U) {
#line 1497
            more = wsize;
          } else {
#line 1496
            goto _L___0;
          }
        } else {
#line 1496
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1499
      if (more == 4294967295U) {
#line 1503
        more --;
      }
    }
#line 1510
    if (s->strstart >= wsize + (s->w_size - 262U)) {
      {
#line 1512
      memcpy((void */* __restrict  */)s->window, (void const   */* __restrict  */)(s->window + wsize),
             (size_t )(wsize - more));
#line 1513
      s->match_start -= wsize;
#line 1514
      s->strstart -= wsize;
#line 1515
      s->block_start -= (long )wsize;
#line 1516
      slide_hash(s);
#line 1517
      more += wsize;
      }
    }
#line 1519
    if ((s->strm)->avail_in == 0U) {
#line 1519
      goto while_break;
    }
    {
#line 1534
    n = read_buf(s->strm, (s->window + s->strstart) + s->lookahead, more);
#line 1535
    s->lookahead += n;
    }
#line 1538
    if (s->lookahead + s->insert >= 3U) {
#line 1539
      str = s->strstart - s->insert;
#line 1540
      s->ins_h = (uInt )*(s->window + str);
#line 1541
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (str + 1U))) & s->hash_mask;
      {
#line 1545
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1545
        if (! s->insert) {
#line 1545
          goto while_break___0;
        }
#line 1546
        s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + ((str + 3U) - 1U))) & s->hash_mask;
#line 1548
        *(s->prev + (str & s->w_mask)) = *(s->head + s->ins_h);
#line 1550
        *(s->head + s->ins_h) = (Pos )str;
#line 1551
        str ++;
#line 1552
        (s->insert) --;
#line 1553
        if (s->lookahead + s->insert < 3U) {
#line 1554
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1491
    if (s->lookahead < 262U) {
#line 1491
      if (! ((s->strm)->avail_in != 0U)) {
#line 1491
        goto while_break;
      }
    } else {
#line 1491
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1570
  if (s->high_water < s->window_size) {
#line 1571
    curr = (ulg )s->strstart + (ulg )s->lookahead;
#line 1574
    if (s->high_water < curr) {
#line 1578
      init = s->window_size - curr;
#line 1579
      if (init > 258UL) {
#line 1580
        init = (ulg )258;
      }
      {
#line 1581
      memset((void *)(s->window + curr), 0, (size_t )((unsigned int )init));
#line 1582
      s->high_water = curr + init;
      }
    } else
#line 1584
    if (s->high_water < curr + 258UL) {
#line 1589
      init = (curr + 258UL) - s->high_water;
#line 1590
      if (init > s->window_size - s->high_water) {
#line 1591
        init = s->window_size - s->high_water;
      }
      {
#line 1592
      memset((void *)(s->window + s->high_water), 0, (size_t )((unsigned int )init));
#line 1593
      s->high_water += init;
      }
    }
  }
#line 1599
  return;
}
}
#line 1643 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static block_state deflate_stored(deflate_state *s , int flush ) 
{ 
  unsigned int min_block ;
  ulg tmp ;
  unsigned int len ;
  unsigned int left ;
  unsigned int have ;
  unsigned int last ;
  unsigned int used ;
  uInt tmp___0 ;
  int tmp___1 ;

  {
#line 1651
  if (s->pending_buf_size - 5UL > (ulg )s->w_size) {
#line 1651
    tmp = (ulg )s->w_size;
  } else {
#line 1651
    tmp = s->pending_buf_size - 5UL;
  }
#line 1651
  min_block = (unsigned int )tmp;
#line 1657
  last = 0U;
#line 1658
  used = (s->strm)->avail_in;
  {
#line 1659
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1664
    len = 65535U;
#line 1665
    have = (unsigned int )((s->bi_valid + 42) >> 3);
#line 1666
    if ((s->strm)->avail_out < have) {
#line 1667
      goto while_break;
    }
#line 1669
    have = (s->strm)->avail_out - have;
#line 1670
    left = (unsigned int )((long )s->strstart - s->block_start);
#line 1671
    if ((ulg )len > (ulg )left + (ulg )(s->strm)->avail_in) {
#line 1672
      len = left + (s->strm)->avail_in;
    }
#line 1673
    if (len > have) {
#line 1674
      len = have;
    }
#line 1681
    if (len < min_block) {
#line 1681
      if (len == 0U) {
#line 1681
        if (flush != 4) {
#line 1684
          goto while_break;
        } else {
#line 1681
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1681
      if (flush == 0) {
#line 1684
        goto while_break;
      } else
#line 1681
      if (len != left + (s->strm)->avail_in) {
#line 1684
        goto while_break;
      }
    }
#line 1689
    if (flush == 4) {
#line 1689
      if (len == left + (s->strm)->avail_in) {
#line 1689
        last = 1U;
      } else {
#line 1689
        last = 0U;
      }
    } else {
#line 1689
      last = 0U;
    }
    {
#line 1690
    _tr_stored_block(s, (char *)0, (ulg )0L, (int )last);
#line 1693
    *(s->pending_buf + (s->pending - 4UL)) = (Bytef )len;
#line 1694
    *(s->pending_buf + (s->pending - 3UL)) = (Bytef )(len >> 8);
#line 1695
    *(s->pending_buf + (s->pending - 2UL)) = (Bytef )(~ len);
#line 1696
    *(s->pending_buf + (s->pending - 1UL)) = (Bytef )(~ len >> 8);
#line 1699
    flush_pending(s->strm);
    }
#line 1708
    if (left) {
#line 1709
      if (left > len) {
#line 1710
        left = len;
      }
      {
#line 1711
      memcpy((void */* __restrict  */)(s->strm)->next_out, (void const   */* __restrict  */)(s->window + s->block_start),
             (size_t )left);
#line 1712
      (s->strm)->next_out += left;
#line 1713
      (s->strm)->avail_out -= left;
#line 1714
      (s->strm)->total_out += (uLong )left;
#line 1715
      s->block_start += (long )left;
#line 1716
      len -= left;
      }
    }
#line 1722
    if (len) {
      {
#line 1723
      read_buf(s->strm, (s->strm)->next_out, len);
#line 1724
      (s->strm)->next_out += len;
#line 1725
      (s->strm)->avail_out -= len;
#line 1726
      (s->strm)->total_out += (uLong )len;
      }
    }
#line 1659
    if (! (last == 0U)) {
#line 1659
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1736
  used -= (s->strm)->avail_in;
#line 1737
  if (used) {
#line 1741
    if (used >= s->w_size) {
      {
#line 1742
      s->matches = (uInt )2;
#line 1743
      memcpy((void */* __restrict  */)s->window, (void const   */* __restrict  */)((s->strm)->next_in - s->w_size),
             (size_t )s->w_size);
#line 1744
      s->strstart = s->w_size;
      }
    } else {
#line 1747
      if (s->window_size - (ulg )s->strstart <= (ulg )used) {
        {
#line 1749
        s->strstart -= s->w_size;
#line 1750
        memcpy((void */* __restrict  */)s->window, (void const   */* __restrict  */)(s->window + s->w_size),
               (size_t )s->strstart);
        }
#line 1751
        if (s->matches < 2U) {
#line 1752
          (s->matches) ++;
        }
      }
      {
#line 1754
      memcpy((void */* __restrict  */)(s->window + s->strstart), (void const   */* __restrict  */)((s->strm)->next_in - used),
             (size_t )used);
#line 1755
      s->strstart += used;
      }
    }
#line 1757
    s->block_start = (long )s->strstart;
#line 1758
    if (used > s->w_size - s->insert) {
#line 1758
      tmp___0 = s->w_size - s->insert;
    } else {
#line 1758
      tmp___0 = used;
    }
#line 1758
    s->insert += tmp___0;
  }
#line 1760
  if (s->high_water < (ulg )s->strstart) {
#line 1761
    s->high_water = (ulg )s->strstart;
  }
#line 1764
  if (last) {
#line 1765
    return ((block_state )3);
  }
#line 1768
  if (flush != 0) {
#line 1768
    if (flush != 4) {
#line 1768
      if ((s->strm)->avail_in == 0U) {
#line 1768
        if ((long )s->strstart == s->block_start) {
#line 1770
          return ((block_state )1);
        }
      }
    }
  }
#line 1773
  have = (unsigned int )((s->window_size - (ulg )s->strstart) - 1UL);
#line 1774
  if ((s->strm)->avail_in > have) {
#line 1774
    if (s->block_start >= (long )s->w_size) {
      {
#line 1776
      s->block_start -= (long )s->w_size;
#line 1777
      s->strstart -= s->w_size;
#line 1778
      memcpy((void */* __restrict  */)s->window, (void const   */* __restrict  */)(s->window + s->w_size),
             (size_t )s->strstart);
      }
#line 1779
      if (s->matches < 2U) {
#line 1780
        (s->matches) ++;
      }
#line 1781
      have += s->w_size;
    }
  }
#line 1783
  if (have > (s->strm)->avail_in) {
#line 1784
    have = (s->strm)->avail_in;
  }
#line 1785
  if (have) {
    {
#line 1786
    read_buf(s->strm, s->window + s->strstart, have);
#line 1787
    s->strstart += have;
    }
  }
#line 1789
  if (s->high_water < (ulg )s->strstart) {
#line 1790
    s->high_water = (ulg )s->strstart;
  }
#line 1797
  have = (unsigned int )((s->bi_valid + 42) >> 3);
#line 1799
  if (s->pending_buf_size - (ulg )have > 65535UL) {
#line 1799
    have = 65535U;
  } else {
#line 1799
    have = (unsigned int )(s->pending_buf_size - (ulg )have);
  }
#line 1800
  if (have > s->w_size) {
#line 1800
    min_block = s->w_size;
  } else {
#line 1800
    min_block = have;
  }
#line 1801
  left = (unsigned int )((long )s->strstart - s->block_start);
#line 1802
  if (left >= min_block) {
#line 1802
    goto _L___0;
  } else
#line 1802
  if (left) {
#line 1802
    goto _L___1;
  } else
#line 1802
  if (flush == 4) {
    _L___1: /* CIL Label */ 
#line 1802
    if (flush != 0) {
#line 1802
      if ((s->strm)->avail_in == 0U) {
#line 1802
        if (left <= have) {
          _L___0: /* CIL Label */ 
#line 1805
          if (left > have) {
#line 1805
            len = have;
          } else {
#line 1805
            len = left;
          }
#line 1806
          if (flush == 4) {
#line 1806
            if ((s->strm)->avail_in == 0U) {
#line 1806
              if (len == left) {
#line 1806
                last = 1U;
              } else {
#line 1806
                last = 0U;
              }
            } else {
#line 1806
              last = 0U;
            }
          } else {
#line 1806
            last = 0U;
          }
          {
#line 1808
          _tr_stored_block(s, (charf *)s->window + s->block_start, (ulg )len, (int )last);
#line 1809
          s->block_start += (long )len;
#line 1810
          flush_pending(s->strm);
          }
        }
      }
    }
  }
#line 1814
  if (last) {
#line 1814
    tmp___1 = 2;
  } else {
#line 1814
    tmp___1 = 0;
  }
#line 1814
  return ((block_state )tmp___1);
}
}
#line 1824 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static block_state deflate_fast(deflate_state *s , int flush ) 
{ 
  IPos hash_head ;
  int bflush ;
  Posf tmp ;
  uch len ;
  ush dist ;
  uInt tmp___0 ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  Posf tmp___2 ;
  uch cc ;
  uInt tmp___3 ;
  charf *tmp___4 ;
  charf *tmp___5 ;
  charf *tmp___6 ;

  {
  {
#line 1831
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1837
    if (s->lookahead < 262U) {
      {
#line 1838
      fill_window(s);
      }
#line 1839
      if (s->lookahead < 262U) {
#line 1839
        if (flush == 0) {
#line 1840
          return ((block_state )0);
        }
      }
#line 1842
      if (s->lookahead == 0U) {
#line 1842
        goto while_break;
      }
    }
#line 1848
    hash_head = (IPos )0;
#line 1849
    if (s->lookahead >= 3U) {
#line 1850
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1850
      tmp = *(s->head + s->ins_h);
#line 1850
      *(s->prev + (s->strstart & s->w_mask)) = tmp;
#line 1850
      hash_head = (IPos )tmp;
#line 1850
      *(s->head + s->ins_h) = (Pos )s->strstart;
    }
#line 1856
    if (hash_head != 0U) {
#line 1856
      if (s->strstart - hash_head <= s->w_size - 262U) {
        {
#line 1861
        s->match_length = longest_match(s, hash_head);
        }
      }
    }
#line 1864
    if (s->match_length >= 3U) {
#line 1867
      len = (uch )(s->match_length - 3U);
#line 1867
      dist = (ush )(s->strstart - s->match_start);
#line 1867
      *(s->d_buf + s->last_lit) = dist;
#line 1867
      tmp___0 = s->last_lit;
#line 1867
      (s->last_lit) ++;
#line 1867
      *(s->l_buf + tmp___0) = len;
#line 1867
      dist = (ush )((int )dist - 1);
#line 1867
      s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 1867
      if ((int )dist < 256) {
#line 1867
        tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
      } else {
#line 1867
        tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256 + ((int )dist >> 7)];
      }
#line 1867
      s->dyn_dtree[tmp___1].fc.freq = (ush )((int )s->dyn_dtree[tmp___1].fc.freq + 1);
#line 1867
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1870
      s->lookahead -= s->match_length;
#line 1876
      if (s->match_length <= s->max_lazy_match) {
#line 1876
        if (s->lookahead >= 3U) {
#line 1878
          (s->match_length) --;
          {
#line 1879
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1880
            (s->strstart) ++;
#line 1881
            s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1881
            tmp___2 = *(s->head + s->ins_h);
#line 1881
            *(s->prev + (s->strstart & s->w_mask)) = tmp___2;
#line 1881
            hash_head = (IPos )tmp___2;
#line 1881
            *(s->head + s->ins_h) = (Pos )s->strstart;
#line 1879
            (s->match_length) --;
#line 1879
            if (! (s->match_length != 0U)) {
#line 1879
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1886
          (s->strstart) ++;
        } else {
#line 1890
          s->strstart += s->match_length;
#line 1891
          s->match_length = (uInt )0;
#line 1892
          s->ins_h = (uInt )*(s->window + s->strstart);
#line 1893
          s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 1U))) & s->hash_mask;
        }
      } else {
#line 1890
        s->strstart += s->match_length;
#line 1891
        s->match_length = (uInt )0;
#line 1892
        s->ins_h = (uInt )*(s->window + s->strstart);
#line 1893
        s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 1U))) & s->hash_mask;
      }
    } else {
#line 1904
      cc = *(s->window + s->strstart);
#line 1904
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 1904
      tmp___3 = s->last_lit;
#line 1904
      (s->last_lit) ++;
#line 1904
      *(s->l_buf + tmp___3) = cc;
#line 1904
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 1904
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 1905
      (s->lookahead) --;
#line 1906
      (s->strstart) ++;
    }
#line 1908
    if (bflush) {
#line 1908
      if (s->block_start >= 0L) {
#line 1908
        tmp___4 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 1908
        tmp___4 = (charf *)0;
      }
      {
#line 1908
      _tr_flush_block(s, tmp___4, (ulg )((long )s->strstart - s->block_start), 0);
#line 1908
      s->block_start = (long )s->strstart;
#line 1908
      flush_pending(s->strm);
      }
#line 1908
      if ((s->strm)->avail_out == 0U) {
#line 1908
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1910
  if (s->strstart < 2U) {
#line 1910
    s->insert = s->strstart;
  } else {
#line 1910
    s->insert = (uInt )2;
  }
#line 1911
  if (flush == 4) {
#line 1912
    if (s->block_start >= 0L) {
#line 1912
      tmp___5 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1912
      tmp___5 = (charf *)0;
    }
    {
#line 1912
    _tr_flush_block(s, tmp___5, (ulg )((long )s->strstart - s->block_start), 1);
#line 1912
    s->block_start = (long )s->strstart;
#line 1912
    flush_pending(s->strm);
    }
#line 1912
    if ((s->strm)->avail_out == 0U) {
#line 1912
      return ((block_state )2);
    }
#line 1913
    return ((block_state )3);
  }
#line 1915
  if (s->last_lit) {
#line 1916
    if (s->block_start >= 0L) {
#line 1916
      tmp___6 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 1916
      tmp___6 = (charf *)0;
    }
    {
#line 1916
    _tr_flush_block(s, tmp___6, (ulg )((long )s->strstart - s->block_start), 0);
#line 1916
    s->block_start = (long )s->strstart;
#line 1916
    flush_pending(s->strm);
    }
#line 1916
    if ((s->strm)->avail_out == 0U) {
#line 1916
      return ((block_state )0);
    }
  }
#line 1917
  return ((block_state )1);
}
}
#line 1926 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static block_state deflate_slow(deflate_state *s , int flush ) 
{ 
  IPos hash_head ;
  int bflush ;
  Posf tmp ;
  uInt max_insert ;
  uch len ;
  ush dist ;
  uInt tmp___0 ;
  int __attribute__((__visibility__("hidden")))  tmp___1 ;
  Posf tmp___2 ;
  charf *tmp___3 ;
  uch cc ;
  uInt tmp___4 ;
  charf *tmp___5 ;
  uch cc___0 ;
  uInt tmp___6 ;
  charf *tmp___7 ;
  charf *tmp___8 ;

  {
  {
#line 1934
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1940
    if (s->lookahead < 262U) {
      {
#line 1941
      fill_window(s);
      }
#line 1942
      if (s->lookahead < 262U) {
#line 1942
        if (flush == 0) {
#line 1943
          return ((block_state )0);
        }
      }
#line 1945
      if (s->lookahead == 0U) {
#line 1945
        goto while_break;
      }
    }
#line 1951
    hash_head = (IPos )0;
#line 1952
    if (s->lookahead >= 3U) {
#line 1953
      s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 1953
      tmp = *(s->head + s->ins_h);
#line 1953
      *(s->prev + (s->strstart & s->w_mask)) = tmp;
#line 1953
      hash_head = (IPos )tmp;
#line 1953
      *(s->head + s->ins_h) = (Pos )s->strstart;
    }
#line 1958
    s->prev_length = s->match_length;
#line 1958
    s->prev_match = s->match_start;
#line 1959
    s->match_length = (uInt )2;
#line 1961
    if (hash_head != 0U) {
#line 1961
      if (s->prev_length < s->max_lazy_match) {
#line 1961
        if (s->strstart - hash_head <= s->w_size - 262U) {
          {
#line 1967
          s->match_length = longest_match(s, hash_head);
          }
#line 1970
          if (s->match_length <= 5U) {
#line 1970
            if (s->strategy == 1) {
#line 1980
              s->match_length = (uInt )2;
            }
          }
        }
      }
    }
#line 1986
    if (s->prev_length >= 3U) {
#line 1986
      if (s->match_length <= s->prev_length) {
#line 1987
        max_insert = (s->strstart + s->lookahead) - 3U;
#line 1992
        len = (uch )(s->prev_length - 3U);
#line 1992
        dist = (ush )((s->strstart - 1U) - s->prev_match);
#line 1992
        *(s->d_buf + s->last_lit) = dist;
#line 1992
        tmp___0 = s->last_lit;
#line 1992
        (s->last_lit) ++;
#line 1992
        *(s->l_buf + tmp___0) = len;
#line 1992
        dist = (ush )((int )dist - 1);
#line 1992
        s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 1992
        if ((int )dist < 256) {
#line 1992
          tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
        } else {
#line 1992
          tmp___1 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256 + ((int )dist >> 7)];
        }
#line 1992
        s->dyn_dtree[tmp___1].fc.freq = (ush )((int )s->dyn_dtree[tmp___1].fc.freq + 1);
#line 1992
        bflush = s->last_lit == s->lit_bufsize - 1U;
#line 2000
        s->lookahead -= s->prev_length - 1U;
#line 2001
        s->prev_length -= 2U;
        {
#line 2002
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2003
          (s->strstart) ++;
#line 2003
          if (s->strstart <= max_insert) {
#line 2004
            s->ins_h = ((s->ins_h << s->hash_shift) ^ (unsigned int )*(s->window + (s->strstart + 2U))) & s->hash_mask;
#line 2004
            tmp___2 = *(s->head + s->ins_h);
#line 2004
            *(s->prev + (s->strstart & s->w_mask)) = tmp___2;
#line 2004
            hash_head = (IPos )tmp___2;
#line 2004
            *(s->head + s->ins_h) = (Pos )s->strstart;
          }
#line 2002
          (s->prev_length) --;
#line 2002
          if (! (s->prev_length != 0U)) {
#line 2002
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2007
        s->match_available = 0;
#line 2008
        s->match_length = (uInt )2;
#line 2009
        (s->strstart) ++;
#line 2011
        if (bflush) {
#line 2011
          if (s->block_start >= 0L) {
#line 2011
            tmp___3 = (charf *)(s->window + (unsigned int )s->block_start);
          } else {
#line 2011
            tmp___3 = (charf *)0;
          }
          {
#line 2011
          _tr_flush_block(s, tmp___3, (ulg )((long )s->strstart - s->block_start),
                          0);
#line 2011
          s->block_start = (long )s->strstart;
#line 2011
          flush_pending(s->strm);
          }
#line 2011
          if ((s->strm)->avail_out == 0U) {
#line 2011
            return ((block_state )0);
          }
        }
      } else {
#line 1986
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2013
    if (s->match_available) {
#line 2019
      cc = *(s->window + (s->strstart - 1U));
#line 2019
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 2019
      tmp___4 = s->last_lit;
#line 2019
      (s->last_lit) ++;
#line 2019
      *(s->l_buf + tmp___4) = cc;
#line 2019
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 2019
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 2020
      if (bflush) {
#line 2021
        if (s->block_start >= 0L) {
#line 2021
          tmp___5 = (charf *)(s->window + (unsigned int )s->block_start);
        } else {
#line 2021
          tmp___5 = (charf *)0;
        }
        {
#line 2021
        _tr_flush_block(s, tmp___5, (ulg )((long )s->strstart - s->block_start), 0);
#line 2021
        s->block_start = (long )s->strstart;
#line 2021
        flush_pending(s->strm);
        }
      }
#line 2023
      (s->strstart) ++;
#line 2024
      (s->lookahead) --;
#line 2025
      if ((s->strm)->avail_out == 0U) {
#line 2025
        return ((block_state )0);
      }
    } else {
#line 2030
      s->match_available = 1;
#line 2031
      (s->strstart) ++;
#line 2032
      (s->lookahead) --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2036
  if (s->match_available) {
#line 2038
    cc___0 = *(s->window + (s->strstart - 1U));
#line 2038
    *(s->d_buf + s->last_lit) = (ushf )0;
#line 2038
    tmp___6 = s->last_lit;
#line 2038
    (s->last_lit) ++;
#line 2038
    *(s->l_buf + tmp___6) = cc___0;
#line 2038
    s->dyn_ltree[cc___0].fc.freq = (ush )((int )s->dyn_ltree[cc___0].fc.freq + 1);
#line 2038
    bflush = s->last_lit == s->lit_bufsize - 1U;
#line 2039
    s->match_available = 0;
  }
#line 2041
  if (s->strstart < 2U) {
#line 2041
    s->insert = s->strstart;
  } else {
#line 2041
    s->insert = (uInt )2;
  }
#line 2042
  if (flush == 4) {
#line 2043
    if (s->block_start >= 0L) {
#line 2043
      tmp___7 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 2043
      tmp___7 = (charf *)0;
    }
    {
#line 2043
    _tr_flush_block(s, tmp___7, (ulg )((long )s->strstart - s->block_start), 1);
#line 2043
    s->block_start = (long )s->strstart;
#line 2043
    flush_pending(s->strm);
    }
#line 2043
    if ((s->strm)->avail_out == 0U) {
#line 2043
      return ((block_state )2);
    }
#line 2044
    return ((block_state )3);
  }
#line 2046
  if (s->last_lit) {
#line 2047
    if (s->block_start >= 0L) {
#line 2047
      tmp___8 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 2047
      tmp___8 = (charf *)0;
    }
    {
#line 2047
    _tr_flush_block(s, tmp___8, (ulg )((long )s->strstart - s->block_start), 0);
#line 2047
    s->block_start = (long )s->strstart;
#line 2047
    flush_pending(s->strm);
    }
#line 2047
    if ((s->strm)->avail_out == 0U) {
#line 2047
      return ((block_state )0);
    }
  }
#line 2048
  return ((block_state )1);
}
}
#line 2057 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static block_state deflate_rle(deflate_state *s , int flush ) 
{ 
  int bflush ;
  uInt prev ;
  Bytef *scan ;
  Bytef *strend ;
  uch len ;
  ush dist ;
  uInt tmp ;
  int __attribute__((__visibility__("hidden")))  tmp___0 ;
  uch cc ;
  uInt tmp___1 ;
  charf *tmp___2 ;
  charf *tmp___3 ;
  charf *tmp___4 ;

  {
  {
#line 2065
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2070
    if (s->lookahead <= 258U) {
      {
#line 2071
      fill_window(s);
      }
#line 2072
      if (s->lookahead <= 258U) {
#line 2072
        if (flush == 0) {
#line 2073
          return ((block_state )0);
        }
      }
#line 2075
      if (s->lookahead == 0U) {
#line 2075
        goto while_break;
      }
    }
#line 2079
    s->match_length = (uInt )0;
#line 2080
    if (s->lookahead >= 3U) {
#line 2080
      if (s->strstart > 0U) {
#line 2081
        scan = (s->window + s->strstart) - 1;
#line 2082
        prev = (uInt )*scan;
#line 2083
        scan ++;
#line 2083
        if (prev == (uInt )*scan) {
#line 2083
          scan ++;
#line 2083
          if (prev == (uInt )*scan) {
#line 2083
            scan ++;
#line 2083
            if (prev == (uInt )*scan) {
#line 2084
              strend = (s->window + s->strstart) + 258;
              {
#line 2085
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 2085
                scan ++;
#line 2085
                if (prev == (uInt )*scan) {
#line 2085
                  scan ++;
#line 2085
                  if (prev == (uInt )*scan) {
#line 2085
                    scan ++;
#line 2085
                    if (prev == (uInt )*scan) {
#line 2085
                      scan ++;
#line 2085
                      if (prev == (uInt )*scan) {
#line 2085
                        scan ++;
#line 2085
                        if (prev == (uInt )*scan) {
#line 2085
                          scan ++;
#line 2085
                          if (prev == (uInt )*scan) {
#line 2085
                            scan ++;
#line 2085
                            if (prev == (uInt )*scan) {
#line 2085
                              scan ++;
#line 2085
                              if (prev == (uInt )*scan) {
#line 2085
                                if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 2085
                                  goto while_break___0;
                                }
                              } else {
#line 2085
                                goto while_break___0;
                              }
                            } else {
#line 2085
                              goto while_break___0;
                            }
                          } else {
#line 2085
                            goto while_break___0;
                          }
                        } else {
#line 2085
                          goto while_break___0;
                        }
                      } else {
#line 2085
                        goto while_break___0;
                      }
                    } else {
#line 2085
                      goto while_break___0;
                    }
                  } else {
#line 2085
                    goto while_break___0;
                  }
                } else {
#line 2085
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 2091
              s->match_length = 258U - (uInt )(strend - scan);
#line 2092
              if (s->match_length > s->lookahead) {
#line 2093
                s->match_length = s->lookahead;
              }
            }
          }
        }
      }
    }
#line 2099
    if (s->match_length >= 3U) {
#line 2102
      len = (uch )(s->match_length - 3U);
#line 2102
      dist = (ush )1;
#line 2102
      *(s->d_buf + s->last_lit) = dist;
#line 2102
      tmp = s->last_lit;
#line 2102
      (s->last_lit) ++;
#line 2102
      *(s->l_buf + tmp) = len;
#line 2102
      dist = (ush )((int )dist - 1);
#line 2102
      s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq = (ush )((int )s->dyn_ltree[((int const __attribute__((__visibility__("hidden")))  )_length_code[len] + (int const __attribute__((__visibility__("hidden")))  )256) + (int const __attribute__((__visibility__("hidden")))  )1].fc.freq + 1);
#line 2102
      if ((int )dist < 256) {
#line 2102
        tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[dist];
      } else {
#line 2102
        tmp___0 = (int const __attribute__((__visibility__("hidden")))  )_dist_code[256 + ((int )dist >> 7)];
      }
#line 2102
      s->dyn_dtree[tmp___0].fc.freq = (ush )((int )s->dyn_dtree[tmp___0].fc.freq + 1);
#line 2102
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 2104
      s->lookahead -= s->match_length;
#line 2105
      s->strstart += s->match_length;
#line 2106
      s->match_length = (uInt )0;
    } else {
#line 2110
      cc = *(s->window + s->strstart);
#line 2110
      *(s->d_buf + s->last_lit) = (ushf )0;
#line 2110
      tmp___1 = s->last_lit;
#line 2110
      (s->last_lit) ++;
#line 2110
      *(s->l_buf + tmp___1) = cc;
#line 2110
      s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 2110
      bflush = s->last_lit == s->lit_bufsize - 1U;
#line 2111
      (s->lookahead) --;
#line 2112
      (s->strstart) ++;
    }
#line 2114
    if (bflush) {
#line 2114
      if (s->block_start >= 0L) {
#line 2114
        tmp___2 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 2114
        tmp___2 = (charf *)0;
      }
      {
#line 2114
      _tr_flush_block(s, tmp___2, (ulg )((long )s->strstart - s->block_start), 0);
#line 2114
      s->block_start = (long )s->strstart;
#line 2114
      flush_pending(s->strm);
      }
#line 2114
      if ((s->strm)->avail_out == 0U) {
#line 2114
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2116
  s->insert = (uInt )0;
#line 2117
  if (flush == 4) {
#line 2118
    if (s->block_start >= 0L) {
#line 2118
      tmp___3 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 2118
      tmp___3 = (charf *)0;
    }
    {
#line 2118
    _tr_flush_block(s, tmp___3, (ulg )((long )s->strstart - s->block_start), 1);
#line 2118
    s->block_start = (long )s->strstart;
#line 2118
    flush_pending(s->strm);
    }
#line 2118
    if ((s->strm)->avail_out == 0U) {
#line 2118
      return ((block_state )2);
    }
#line 2119
    return ((block_state )3);
  }
#line 2121
  if (s->last_lit) {
#line 2122
    if (s->block_start >= 0L) {
#line 2122
      tmp___4 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 2122
      tmp___4 = (charf *)0;
    }
    {
#line 2122
    _tr_flush_block(s, tmp___4, (ulg )((long )s->strstart - s->block_start), 0);
#line 2122
    s->block_start = (long )s->strstart;
#line 2122
    flush_pending(s->strm);
    }
#line 2122
    if ((s->strm)->avail_out == 0U) {
#line 2122
      return ((block_state )0);
    }
  }
#line 2123
  return ((block_state )1);
}
}
#line 2130 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/deflate.c"
static block_state deflate_huff(deflate_state *s , int flush ) 
{ 
  int bflush ;
  uch cc ;
  uInt tmp ;
  charf *tmp___0 ;
  charf *tmp___1 ;
  charf *tmp___2 ;

  {
  {
#line 2136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2138
    if (s->lookahead == 0U) {
      {
#line 2139
      fill_window(s);
      }
#line 2140
      if (s->lookahead == 0U) {
#line 2141
        if (flush == 0) {
#line 2142
          return ((block_state )0);
        }
#line 2143
        goto while_break;
      }
    }
#line 2148
    s->match_length = (uInt )0;
#line 2150
    cc = *(s->window + s->strstart);
#line 2150
    *(s->d_buf + s->last_lit) = (ushf )0;
#line 2150
    tmp = s->last_lit;
#line 2150
    (s->last_lit) ++;
#line 2150
    *(s->l_buf + tmp) = cc;
#line 2150
    s->dyn_ltree[cc].fc.freq = (ush )((int )s->dyn_ltree[cc].fc.freq + 1);
#line 2150
    bflush = s->last_lit == s->lit_bufsize - 1U;
#line 2151
    (s->lookahead) --;
#line 2152
    (s->strstart) ++;
#line 2153
    if (bflush) {
#line 2153
      if (s->block_start >= 0L) {
#line 2153
        tmp___0 = (charf *)(s->window + (unsigned int )s->block_start);
      } else {
#line 2153
        tmp___0 = (charf *)0;
      }
      {
#line 2153
      _tr_flush_block(s, tmp___0, (ulg )((long )s->strstart - s->block_start), 0);
#line 2153
      s->block_start = (long )s->strstart;
#line 2153
      flush_pending(s->strm);
      }
#line 2153
      if ((s->strm)->avail_out == 0U) {
#line 2153
        return ((block_state )0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2155
  s->insert = (uInt )0;
#line 2156
  if (flush == 4) {
#line 2157
    if (s->block_start >= 0L) {
#line 2157
      tmp___1 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 2157
      tmp___1 = (charf *)0;
    }
    {
#line 2157
    _tr_flush_block(s, tmp___1, (ulg )((long )s->strstart - s->block_start), 1);
#line 2157
    s->block_start = (long )s->strstart;
#line 2157
    flush_pending(s->strm);
    }
#line 2157
    if ((s->strm)->avail_out == 0U) {
#line 2157
      return ((block_state )2);
    }
#line 2158
    return ((block_state )3);
  }
#line 2160
  if (s->last_lit) {
#line 2161
    if (s->block_start >= 0L) {
#line 2161
      tmp___2 = (charf *)(s->window + (unsigned int )s->block_start);
    } else {
#line 2161
      tmp___2 = (charf *)0;
    }
    {
#line 2161
    _tr_flush_block(s, tmp___2, (ulg )((long )s->strstart - s->block_start), 0);
#line 2161
    s->block_start = (long )s->strstart;
#line 2161
    flush_pending(s->strm);
    }
#line 2161
    if ((s->strm)->avail_out == 0U) {
#line 2161
      return ((block_state )0);
    }
  }
#line 2162
  return ((block_state )1);
}
}
#line 1743 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
unsigned long crc32(unsigned long crc , unsigned char const   *buf , uInt len ) ;
#line 1760
unsigned long crc32_z(unsigned long crc , unsigned char const   *buf , z_size_t len ) ;
#line 1862
uLong crc32_combine64(uLong crc1 , uLong crc2 , off64_t len2 ) ;
#line 1895
uLong crc32_combine(uLong crc1 , uLong crc2 , off_t len2 ) ;
#line 1908
z_crc_t const   *get_crc_table(void) ;
#line 38 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
static unsigned long crc32_little(unsigned long crc , unsigned char const   *buf ,
                                  z_size_t len ) ;
#line 40
static unsigned long crc32_big(unsigned long crc , unsigned char const   *buf , z_size_t len ) ;
#line 48
static unsigned long gf2_matrix_times(unsigned long *mat , unsigned long vec ) ;
#line 50
static void gf2_matrix_square(unsigned long *square , unsigned long *mat ) ;
#line 51
static uLong crc32_combine_(uLong crc1 , uLong crc2 , off64_t len2 ) ;
#line 5 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.h"
static z_crc_t const   crc_table[8][256]  = 
#line 5 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.h"
  { {        (z_crc_t const   )0UL,        (z_crc_t const   )1996959894UL,        (z_crc_t const   )3993919788UL,        (z_crc_t const   )2567524794UL, 
            (z_crc_t const   )124634137UL,        (z_crc_t const   )1886057615UL,        (z_crc_t const   )3915621685UL,        (z_crc_t const   )2657392035UL, 
            (z_crc_t const   )249268274UL,        (z_crc_t const   )2044508324UL,        (z_crc_t const   )3772115230UL,        (z_crc_t const   )2547177864UL, 
            (z_crc_t const   )162941995UL,        (z_crc_t const   )2125561021UL,        (z_crc_t const   )3887607047UL,        (z_crc_t const   )2428444049UL, 
            (z_crc_t const   )498536548UL,        (z_crc_t const   )1789927666UL,        (z_crc_t const   )4089016648UL,        (z_crc_t const   )2227061214UL, 
            (z_crc_t const   )450548861UL,        (z_crc_t const   )1843258603UL,        (z_crc_t const   )4107580753UL,        (z_crc_t const   )2211677639UL, 
            (z_crc_t const   )325883990UL,        (z_crc_t const   )1684777152UL,        (z_crc_t const   )4251122042UL,        (z_crc_t const   )2321926636UL, 
            (z_crc_t const   )335633487UL,        (z_crc_t const   )1661365465UL,        (z_crc_t const   )4195302755UL,        (z_crc_t const   )2366115317UL, 
            (z_crc_t const   )997073096UL,        (z_crc_t const   )1281953886UL,        (z_crc_t const   )3579855332UL,        (z_crc_t const   )2724688242UL, 
            (z_crc_t const   )1006888145UL,        (z_crc_t const   )1258607687UL,        (z_crc_t const   )3524101629UL,        (z_crc_t const   )2768942443UL, 
            (z_crc_t const   )901097722UL,        (z_crc_t const   )1119000684UL,        (z_crc_t const   )3686517206UL,        (z_crc_t const   )2898065728UL, 
            (z_crc_t const   )853044451UL,        (z_crc_t const   )1172266101UL,        (z_crc_t const   )3705015759UL,        (z_crc_t const   )2882616665UL, 
            (z_crc_t const   )651767980UL,        (z_crc_t const   )1373503546UL,        (z_crc_t const   )3369554304UL,        (z_crc_t const   )3218104598UL, 
            (z_crc_t const   )565507253UL,        (z_crc_t const   )1454621731UL,        (z_crc_t const   )3485111705UL,        (z_crc_t const   )3099436303UL, 
            (z_crc_t const   )671266974UL,        (z_crc_t const   )1594198024UL,        (z_crc_t const   )3322730930UL,        (z_crc_t const   )2970347812UL, 
            (z_crc_t const   )795835527UL,        (z_crc_t const   )1483230225UL,        (z_crc_t const   )3244367275UL,        (z_crc_t const   )3060149565UL, 
            (z_crc_t const   )1994146192UL,        (z_crc_t const   )31158534UL,        (z_crc_t const   )2563907772UL,        (z_crc_t const   )4023717930UL, 
            (z_crc_t const   )1907459465UL,        (z_crc_t const   )112637215UL,        (z_crc_t const   )2680153253UL,        (z_crc_t const   )3904427059UL, 
            (z_crc_t const   )2013776290UL,        (z_crc_t const   )251722036UL,        (z_crc_t const   )2517215374UL,        (z_crc_t const   )3775830040UL, 
            (z_crc_t const   )2137656763UL,        (z_crc_t const   )141376813UL,        (z_crc_t const   )2439277719UL,        (z_crc_t const   )3865271297UL, 
            (z_crc_t const   )1802195444UL,        (z_crc_t const   )476864866UL,        (z_crc_t const   )2238001368UL,        (z_crc_t const   )4066508878UL, 
            (z_crc_t const   )1812370925UL,        (z_crc_t const   )453092731UL,        (z_crc_t const   )2181625025UL,        (z_crc_t const   )4111451223UL, 
            (z_crc_t const   )1706088902UL,        (z_crc_t const   )314042704UL,        (z_crc_t const   )2344532202UL,        (z_crc_t const   )4240017532UL, 
            (z_crc_t const   )1658658271UL,        (z_crc_t const   )366619977UL,        (z_crc_t const   )2362670323UL,        (z_crc_t const   )4224994405UL, 
            (z_crc_t const   )1303535960UL,        (z_crc_t const   )984961486UL,        (z_crc_t const   )2747007092UL,        (z_crc_t const   )3569037538UL, 
            (z_crc_t const   )1256170817UL,        (z_crc_t const   )1037604311UL,        (z_crc_t const   )2765210733UL,        (z_crc_t const   )3554079995UL, 
            (z_crc_t const   )1131014506UL,        (z_crc_t const   )879679996UL,        (z_crc_t const   )2909243462UL,        (z_crc_t const   )3663771856UL, 
            (z_crc_t const   )1141124467UL,        (z_crc_t const   )855842277UL,        (z_crc_t const   )2852801631UL,        (z_crc_t const   )3708648649UL, 
            (z_crc_t const   )1342533948UL,        (z_crc_t const   )654459306UL,        (z_crc_t const   )3188396048UL,        (z_crc_t const   )3373015174UL, 
            (z_crc_t const   )1466479909UL,        (z_crc_t const   )544179635UL,        (z_crc_t const   )3110523913UL,        (z_crc_t const   )3462522015UL, 
            (z_crc_t const   )1591671054UL,        (z_crc_t const   )702138776UL,        (z_crc_t const   )2966460450UL,        (z_crc_t const   )3352799412UL, 
            (z_crc_t const   )1504918807UL,        (z_crc_t const   )783551873UL,        (z_crc_t const   )3082640443UL,        (z_crc_t const   )3233442989UL, 
            (z_crc_t const   )3988292384UL,        (z_crc_t const   )2596254646UL,        (z_crc_t const   )62317068UL,        (z_crc_t const   )1957810842UL, 
            (z_crc_t const   )3939845945UL,        (z_crc_t const   )2647816111UL,        (z_crc_t const   )81470997UL,        (z_crc_t const   )1943803523UL, 
            (z_crc_t const   )3814918930UL,        (z_crc_t const   )2489596804UL,        (z_crc_t const   )225274430UL,        (z_crc_t const   )2053790376UL, 
            (z_crc_t const   )3826175755UL,        (z_crc_t const   )2466906013UL,        (z_crc_t const   )167816743UL,        (z_crc_t const   )2097651377UL, 
            (z_crc_t const   )4027552580UL,        (z_crc_t const   )2265490386UL,        (z_crc_t const   )503444072UL,        (z_crc_t const   )1762050814UL, 
            (z_crc_t const   )4150417245UL,        (z_crc_t const   )2154129355UL,        (z_crc_t const   )426522225UL,        (z_crc_t const   )1852507879UL, 
            (z_crc_t const   )4275313526UL,        (z_crc_t const   )2312317920UL,        (z_crc_t const   )282753626UL,        (z_crc_t const   )1742555852UL, 
            (z_crc_t const   )4189708143UL,        (z_crc_t const   )2394877945UL,        (z_crc_t const   )397917763UL,        (z_crc_t const   )1622183637UL, 
            (z_crc_t const   )3604390888UL,        (z_crc_t const   )2714866558UL,        (z_crc_t const   )953729732UL,        (z_crc_t const   )1340076626UL, 
            (z_crc_t const   )3518719985UL,        (z_crc_t const   )2797360999UL,        (z_crc_t const   )1068828381UL,        (z_crc_t const   )1219638859UL, 
            (z_crc_t const   )3624741850UL,        (z_crc_t const   )2936675148UL,        (z_crc_t const   )906185462UL,        (z_crc_t const   )1090812512UL, 
            (z_crc_t const   )3747672003UL,        (z_crc_t const   )2825379669UL,        (z_crc_t const   )829329135UL,        (z_crc_t const   )1181335161UL, 
            (z_crc_t const   )3412177804UL,        (z_crc_t const   )3160834842UL,        (z_crc_t const   )628085408UL,        (z_crc_t const   )1382605366UL, 
            (z_crc_t const   )3423369109UL,        (z_crc_t const   )3138078467UL,        (z_crc_t const   )570562233UL,        (z_crc_t const   )1426400815UL, 
            (z_crc_t const   )3317316542UL,        (z_crc_t const   )2998733608UL,        (z_crc_t const   )733239954UL,        (z_crc_t const   )1555261956UL, 
            (z_crc_t const   )3268935591UL,        (z_crc_t const   )3050360625UL,        (z_crc_t const   )752459403UL,        (z_crc_t const   )1541320221UL, 
            (z_crc_t const   )2607071920UL,        (z_crc_t const   )3965973030UL,        (z_crc_t const   )1969922972UL,        (z_crc_t const   )40735498UL, 
            (z_crc_t const   )2617837225UL,        (z_crc_t const   )3943577151UL,        (z_crc_t const   )1913087877UL,        (z_crc_t const   )83908371UL, 
            (z_crc_t const   )2512341634UL,        (z_crc_t const   )3803740692UL,        (z_crc_t const   )2075208622UL,        (z_crc_t const   )213261112UL, 
            (z_crc_t const   )2463272603UL,        (z_crc_t const   )3855990285UL,        (z_crc_t const   )2094854071UL,        (z_crc_t const   )198958881UL, 
            (z_crc_t const   )2262029012UL,        (z_crc_t const   )4057260610UL,        (z_crc_t const   )1759359992UL,        (z_crc_t const   )534414190UL, 
            (z_crc_t const   )2176718541UL,        (z_crc_t const   )4139329115UL,        (z_crc_t const   )1873836001UL,        (z_crc_t const   )414664567UL, 
            (z_crc_t const   )2282248934UL,        (z_crc_t const   )4279200368UL,        (z_crc_t const   )1711684554UL,        (z_crc_t const   )285281116UL, 
            (z_crc_t const   )2405801727UL,        (z_crc_t const   )4167216745UL,        (z_crc_t const   )1634467795UL,        (z_crc_t const   )376229701UL, 
            (z_crc_t const   )2685067896UL,        (z_crc_t const   )3608007406UL,        (z_crc_t const   )1308918612UL,        (z_crc_t const   )956543938UL, 
            (z_crc_t const   )2808555105UL,        (z_crc_t const   )3495958263UL,        (z_crc_t const   )1231636301UL,        (z_crc_t const   )1047427035UL, 
            (z_crc_t const   )2932959818UL,        (z_crc_t const   )3654703836UL,        (z_crc_t const   )1088359270UL,        (z_crc_t const   )936918000UL, 
            (z_crc_t const   )2847714899UL,        (z_crc_t const   )3736837829UL,        (z_crc_t const   )1202900863UL,        (z_crc_t const   )817233897UL, 
            (z_crc_t const   )3183342108UL,        (z_crc_t const   )3401237130UL,        (z_crc_t const   )1404277552UL,        (z_crc_t const   )615818150UL, 
            (z_crc_t const   )3134207493UL,        (z_crc_t const   )3453421203UL,        (z_crc_t const   )1423857449UL,        (z_crc_t const   )601450431UL, 
            (z_crc_t const   )3009837614UL,        (z_crc_t const   )3294710456UL,        (z_crc_t const   )1567103746UL,        (z_crc_t const   )711928724UL, 
            (z_crc_t const   )3020668471UL,        (z_crc_t const   )3272380065UL,        (z_crc_t const   )1510334235UL,        (z_crc_t const   )755167117UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )421212481UL,        (z_crc_t const   )842424962UL,        (z_crc_t const   )724390851UL, 
            (z_crc_t const   )1684849924UL,        (z_crc_t const   )2105013317UL,        (z_crc_t const   )1448781702UL,        (z_crc_t const   )1329698503UL, 
            (z_crc_t const   )3369699848UL,        (z_crc_t const   )3519200073UL,        (z_crc_t const   )4210026634UL,        (z_crc_t const   )3824474571UL, 
            (z_crc_t const   )2897563404UL,        (z_crc_t const   )3048111693UL,        (z_crc_t const   )2659397006UL,        (z_crc_t const   )2274893007UL, 
            (z_crc_t const   )1254232657UL,        (z_crc_t const   )1406739216UL,        (z_crc_t const   )2029285587UL,        (z_crc_t const   )1643069842UL, 
            (z_crc_t const   )783210325UL,        (z_crc_t const   )934667796UL,        (z_crc_t const   )479770071UL,        (z_crc_t const   )92505238UL, 
            (z_crc_t const   )2182846553UL,        (z_crc_t const   )2600511768UL,        (z_crc_t const   )2955803355UL,        (z_crc_t const   )2838940570UL, 
            (z_crc_t const   )3866582365UL,        (z_crc_t const   )4285295644UL,        (z_crc_t const   )3561045983UL,        (z_crc_t const   )3445231262UL, 
            (z_crc_t const   )2508465314UL,        (z_crc_t const   )2359236067UL,        (z_crc_t const   )2813478432UL,        (z_crc_t const   )3198777185UL, 
            (z_crc_t const   )4058571174UL,        (z_crc_t const   )3908292839UL,        (z_crc_t const   )3286139684UL,        (z_crc_t const   )3670389349UL, 
            (z_crc_t const   )1566420650UL,        (z_crc_t const   )1145479147UL,        (z_crc_t const   )1869335592UL,        (z_crc_t const   )1987116393UL, 
            (z_crc_t const   )959540142UL,        (z_crc_t const   )539646703UL,        (z_crc_t const   )185010476UL,        (z_crc_t const   )303839341UL, 
            (z_crc_t const   )3745920755UL,        (z_crc_t const   )3327985586UL,        (z_crc_t const   )3983561841UL,        (z_crc_t const   )4100678960UL, 
            (z_crc_t const   )3140154359UL,        (z_crc_t const   )2721170102UL,        (z_crc_t const   )2300350837UL,        (z_crc_t const   )2416418868UL, 
            (z_crc_t const   )396344571UL,        (z_crc_t const   )243568058UL,        (z_crc_t const   )631889529UL,        (z_crc_t const   )1018359608UL, 
            (z_crc_t const   )1945336319UL,        (z_crc_t const   )1793607870UL,        (z_crc_t const   )1103436669UL,        (z_crc_t const   )1490954812UL, 
            (z_crc_t const   )4034481925UL,        (z_crc_t const   )3915546180UL,        (z_crc_t const   )3259968903UL,        (z_crc_t const   )3679722694UL, 
            (z_crc_t const   )2484439553UL,        (z_crc_t const   )2366552896UL,        (z_crc_t const   )2787371139UL,        (z_crc_t const   )3208174018UL, 
            (z_crc_t const   )950060301UL,        (z_crc_t const   )565965900UL,        (z_crc_t const   )177645455UL,        (z_crc_t const   )328046286UL, 
            (z_crc_t const   )1556873225UL,        (z_crc_t const   )1171730760UL,        (z_crc_t const   )1861902987UL,        (z_crc_t const   )2011255754UL, 
            (z_crc_t const   )3132841300UL,        (z_crc_t const   )2745199637UL,        (z_crc_t const   )2290958294UL,        (z_crc_t const   )2442530455UL, 
            (z_crc_t const   )3738671184UL,        (z_crc_t const   )3352078609UL,        (z_crc_t const   )3974232786UL,        (z_crc_t const   )4126854035UL, 
            (z_crc_t const   )1919080284UL,        (z_crc_t const   )1803150877UL,        (z_crc_t const   )1079293406UL,        (z_crc_t const   )1498383519UL, 
            (z_crc_t const   )370020952UL,        (z_crc_t const   )253043481UL,        (z_crc_t const   )607678682UL,        (z_crc_t const   )1025720731UL, 
            (z_crc_t const   )1711106983UL,        (z_crc_t const   )2095471334UL,        (z_crc_t const   )1472923941UL,        (z_crc_t const   )1322268772UL, 
            (z_crc_t const   )26324643UL,        (z_crc_t const   )411738082UL,        (z_crc_t const   )866634785UL,        (z_crc_t const   )717028704UL, 
            (z_crc_t const   )2904875439UL,        (z_crc_t const   )3024081134UL,        (z_crc_t const   )2668790573UL,        (z_crc_t const   )2248782444UL, 
            (z_crc_t const   )3376948395UL,        (z_crc_t const   )3495106026UL,        (z_crc_t const   )4219356713UL,        (z_crc_t const   )3798300520UL, 
            (z_crc_t const   )792689142UL,        (z_crc_t const   )908347575UL,        (z_crc_t const   )487136116UL,        (z_crc_t const   )68299317UL, 
            (z_crc_t const   )1263779058UL,        (z_crc_t const   )1380486579UL,        (z_crc_t const   )2036719216UL,        (z_crc_t const   )1618931505UL, 
            (z_crc_t const   )3890672638UL,        (z_crc_t const   )4278043327UL,        (z_crc_t const   )3587215740UL,        (z_crc_t const   )3435896893UL, 
            (z_crc_t const   )2206873338UL,        (z_crc_t const   )2593195963UL,        (z_crc_t const   )2981909624UL,        (z_crc_t const   )2829542713UL, 
            (z_crc_t const   )998479947UL,        (z_crc_t const   )580430090UL,        (z_crc_t const   )162921161UL,        (z_crc_t const   )279890824UL, 
            (z_crc_t const   )1609522511UL,        (z_crc_t const   )1190423566UL,        (z_crc_t const   )1842954189UL,        (z_crc_t const   )1958874764UL, 
            (z_crc_t const   )4082766403UL,        (z_crc_t const   )3930137346UL,        (z_crc_t const   )3245109441UL,        (z_crc_t const   )3631694208UL, 
            (z_crc_t const   )2536953671UL,        (z_crc_t const   )2385372678UL,        (z_crc_t const   )2768287173UL,        (z_crc_t const   )3155920004UL, 
            (z_crc_t const   )1900120602UL,        (z_crc_t const   )1750776667UL,        (z_crc_t const   )1131931800UL,        (z_crc_t const   )1517083097UL, 
            (z_crc_t const   )355290910UL,        (z_crc_t const   )204897887UL,        (z_crc_t const   )656092572UL,        (z_crc_t const   )1040194781UL, 
            (z_crc_t const   )3113746450UL,        (z_crc_t const   )2692952403UL,        (z_crc_t const   )2343461520UL,        (z_crc_t const   )2461357009UL, 
            (z_crc_t const   )3723805974UL,        (z_crc_t const   )3304059991UL,        (z_crc_t const   )4022511508UL,        (z_crc_t const   )4141455061UL, 
            (z_crc_t const   )2919742697UL,        (z_crc_t const   )3072101800UL,        (z_crc_t const   )2620513899UL,        (z_crc_t const   )2234183466UL, 
            (z_crc_t const   )3396041197UL,        (z_crc_t const   )3547351212UL,        (z_crc_t const   )4166851439UL,        (z_crc_t const   )3779471918UL, 
            (z_crc_t const   )1725839073UL,        (z_crc_t const   )2143618976UL,        (z_crc_t const   )1424512099UL,        (z_crc_t const   )1307796770UL, 
            (z_crc_t const   )45282277UL,        (z_crc_t const   )464110244UL,        (z_crc_t const   )813994343UL,        (z_crc_t const   )698327078UL, 
            (z_crc_t const   )3838160568UL,        (z_crc_t const   )4259225593UL,        (z_crc_t const   )3606301754UL,        (z_crc_t const   )3488152955UL, 
            (z_crc_t const   )2158586812UL,        (z_crc_t const   )2578602749UL,        (z_crc_t const   )2996767038UL,        (z_crc_t const   )2877569151UL, 
            (z_crc_t const   )740041904UL,        (z_crc_t const   )889656817UL,        (z_crc_t const   )506086962UL,        (z_crc_t const   )120682355UL, 
            (z_crc_t const   )1215357364UL,        (z_crc_t const   )1366020341UL,        (z_crc_t const   )2051441462UL,        (z_crc_t const   )1667084919UL, 
            (z_crc_t const   )3422213966UL,        (z_crc_t const   )3538019855UL,        (z_crc_t const   )4190942668UL,        (z_crc_t const   )3772220557UL, 
            (z_crc_t const   )2945847882UL,        (z_crc_t const   )3062702859UL,        (z_crc_t const   )2644537544UL,        (z_crc_t const   )2226864521UL, 
            (z_crc_t const   )52649286UL,        (z_crc_t const   )439905287UL,        (z_crc_t const   )823476164UL,        (z_crc_t const   )672009861UL, 
            (z_crc_t const   )1733269570UL,        (z_crc_t const   )2119477507UL,        (z_crc_t const   )1434057408UL,        (z_crc_t const   )1281543041UL, 
            (z_crc_t const   )2167981343UL,        (z_crc_t const   )2552493150UL,        (z_crc_t const   )3004082077UL,        (z_crc_t const   )2853541596UL, 
            (z_crc_t const   )3847487515UL,        (z_crc_t const   )4233048410UL,        (z_crc_t const   )3613549209UL,        (z_crc_t const   )3464057816UL, 
            (z_crc_t const   )1239502615UL,        (z_crc_t const   )1358593622UL,        (z_crc_t const   )2077699477UL,        (z_crc_t const   )1657543892UL, 
            (z_crc_t const   )764250643UL,        (z_crc_t const   )882293586UL,        (z_crc_t const   )532408465UL,        (z_crc_t const   )111204816UL, 
            (z_crc_t const   )1585378284UL,        (z_crc_t const   )1197851309UL,        (z_crc_t const   )1816695150UL,        (z_crc_t const   )1968414767UL, 
            (z_crc_t const   )974272232UL,        (z_crc_t const   )587794345UL,        (z_crc_t const   )136598634UL,        (z_crc_t const   )289367339UL, 
            (z_crc_t const   )2527558116UL,        (z_crc_t const   )2411481253UL,        (z_crc_t const   )2760973158UL,        (z_crc_t const   )3179948583UL, 
            (z_crc_t const   )4073438432UL,        (z_crc_t const   )3956313505UL,        (z_crc_t const   )3237863010UL,        (z_crc_t const   )3655790371UL, 
            (z_crc_t const   )347922877UL,        (z_crc_t const   )229101820UL,        (z_crc_t const   )646611775UL,        (z_crc_t const   )1066513022UL, 
            (z_crc_t const   )1892689081UL,        (z_crc_t const   )1774917112UL,        (z_crc_t const   )1122387515UL,        (z_crc_t const   )1543337850UL, 
            (z_crc_t const   )3697634229UL,        (z_crc_t const   )3313392372UL,        (z_crc_t const   )3998419255UL,        (z_crc_t const   )4148705398UL, 
            (z_crc_t const   )3087642289UL,        (z_crc_t const   )2702352368UL,        (z_crc_t const   )2319436851UL,        (z_crc_t const   )2468674930UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )29518391UL,        (z_crc_t const   )59036782UL,        (z_crc_t const   )38190681UL, 
            (z_crc_t const   )118073564UL,        (z_crc_t const   )114017003UL,        (z_crc_t const   )76381362UL,        (z_crc_t const   )89069189UL, 
            (z_crc_t const   )236147128UL,        (z_crc_t const   )265370511UL,        (z_crc_t const   )228034006UL,        (z_crc_t const   )206958561UL, 
            (z_crc_t const   )152762724UL,        (z_crc_t const   )148411219UL,        (z_crc_t const   )178138378UL,        (z_crc_t const   )190596925UL, 
            (z_crc_t const   )472294256UL,        (z_crc_t const   )501532999UL,        (z_crc_t const   )530741022UL,        (z_crc_t const   )509615401UL, 
            (z_crc_t const   )456068012UL,        (z_crc_t const   )451764635UL,        (z_crc_t const   )413917122UL,        (z_crc_t const   )426358261UL, 
            (z_crc_t const   )305525448UL,        (z_crc_t const   )334993663UL,        (z_crc_t const   )296822438UL,        (z_crc_t const   )275991697UL, 
            (z_crc_t const   )356276756UL,        (z_crc_t const   )352202787UL,        (z_crc_t const   )381193850UL,        (z_crc_t const   )393929805UL, 
            (z_crc_t const   )944588512UL,        (z_crc_t const   )965684439UL,        (z_crc_t const   )1003065998UL,        (z_crc_t const   )973863097UL, 
            (z_crc_t const   )1061482044UL,        (z_crc_t const   )1049003019UL,        (z_crc_t const   )1019230802UL,        (z_crc_t const   )1023561829UL, 
            (z_crc_t const   )912136024UL,        (z_crc_t const   )933002607UL,        (z_crc_t const   )903529270UL,        (z_crc_t const   )874031361UL, 
            (z_crc_t const   )827834244UL,        (z_crc_t const   )815125939UL,        (z_crc_t const   )852716522UL,        (z_crc_t const   )856752605UL, 
            (z_crc_t const   )611050896UL,        (z_crc_t const   )631869351UL,        (z_crc_t const   )669987326UL,        (z_crc_t const   )640506825UL, 
            (z_crc_t const   )593644876UL,        (z_crc_t const   )580921211UL,        (z_crc_t const   )551983394UL,        (z_crc_t const   )556069653UL, 
            (z_crc_t const   )712553512UL,        (z_crc_t const   )733666847UL,        (z_crc_t const   )704405574UL,        (z_crc_t const   )675154545UL, 
            (z_crc_t const   )762387700UL,        (z_crc_t const   )749958851UL,        (z_crc_t const   )787859610UL,        (z_crc_t const   )792175277UL, 
            (z_crc_t const   )1889177024UL,        (z_crc_t const   )1901651959UL,        (z_crc_t const   )1931368878UL,        (z_crc_t const   )1927033753UL, 
            (z_crc_t const   )2006131996UL,        (z_crc_t const   )1985040171UL,        (z_crc_t const   )1947726194UL,        (z_crc_t const   )1976933189UL, 
            (z_crc_t const   )2122964088UL,        (z_crc_t const   )2135668303UL,        (z_crc_t const   )2098006038UL,        (z_crc_t const   )2093965857UL, 
            (z_crc_t const   )2038461604UL,        (z_crc_t const   )2017599123UL,        (z_crc_t const   )2047123658UL,        (z_crc_t const   )2076625661UL, 
            (z_crc_t const   )1824272048UL,        (z_crc_t const   )1836991623UL,        (z_crc_t const   )1866005214UL,        (z_crc_t const   )1861914857UL, 
            (z_crc_t const   )1807058540UL,        (z_crc_t const   )1786244187UL,        (z_crc_t const   )1748062722UL,        (z_crc_t const   )1777547317UL, 
            (z_crc_t const   )1655668488UL,        (z_crc_t const   )1668093247UL,        (z_crc_t const   )1630251878UL,        (z_crc_t const   )1625932113UL, 
            (z_crc_t const   )1705433044UL,        (z_crc_t const   )1684323811UL,        (z_crc_t const   )1713505210UL,        (z_crc_t const   )1742760333UL, 
            (z_crc_t const   )1222101792UL,        (z_crc_t const   )1226154263UL,        (z_crc_t const   )1263738702UL,        (z_crc_t const   )1251046777UL, 
            (z_crc_t const   )1339974652UL,        (z_crc_t const   )1310460363UL,        (z_crc_t const   )1281013650UL,        (z_crc_t const   )1301863845UL, 
            (z_crc_t const   )1187289752UL,        (z_crc_t const   )1191637167UL,        (z_crc_t const   )1161842422UL,        (z_crc_t const   )1149379777UL, 
            (z_crc_t const   )1103966788UL,        (z_crc_t const   )1074747507UL,        (z_crc_t const   )1112139306UL,        (z_crc_t const   )1133218845UL, 
            (z_crc_t const   )1425107024UL,        (z_crc_t const   )1429406311UL,        (z_crc_t const   )1467333694UL,        (z_crc_t const   )1454888457UL, 
            (z_crc_t const   )1408811148UL,        (z_crc_t const   )1379576507UL,        (z_crc_t const   )1350309090UL,        (z_crc_t const   )1371438805UL, 
            (z_crc_t const   )1524775400UL,        (z_crc_t const   )1528845279UL,        (z_crc_t const   )1499917702UL,        (z_crc_t const   )1487177649UL, 
            (z_crc_t const   )1575719220UL,        (z_crc_t const   )1546255107UL,        (z_crc_t const   )1584350554UL,        (z_crc_t const   )1605185389UL, 
            (z_crc_t const   )3778354048UL,        (z_crc_t const   )3774312887UL,        (z_crc_t const   )3803303918UL,        (z_crc_t const   )3816007129UL, 
            (z_crc_t const   )3862737756UL,        (z_crc_t const   )3892238699UL,        (z_crc_t const   )3854067506UL,        (z_crc_t const   )3833203973UL, 
            (z_crc_t const   )4012263992UL,        (z_crc_t const   )4007927823UL,        (z_crc_t const   )3970080342UL,        (z_crc_t const   )3982554209UL, 
            (z_crc_t const   )3895452388UL,        (z_crc_t const   )3924658387UL,        (z_crc_t const   )3953866378UL,        (z_crc_t const   )3932773565UL, 
            (z_crc_t const   )4245928176UL,        (z_crc_t const   )4241609415UL,        (z_crc_t const   )4271336606UL,        (z_crc_t const   )4283762345UL, 
            (z_crc_t const   )4196012076UL,        (z_crc_t const   )4225268251UL,        (z_crc_t const   )4187931714UL,        (z_crc_t const   )4166823541UL, 
            (z_crc_t const   )4076923208UL,        (z_crc_t const   )4072833919UL,        (z_crc_t const   )4035198246UL,        (z_crc_t const   )4047918865UL, 
            (z_crc_t const   )4094247316UL,        (z_crc_t const   )4123732899UL,        (z_crc_t const   )4153251322UL,        (z_crc_t const   )4132437965UL, 
            (z_crc_t const   )3648544096UL,        (z_crc_t const   )3636082519UL,        (z_crc_t const   )3673983246UL,        (z_crc_t const   )3678331705UL, 
            (z_crc_t const   )3732010428UL,        (z_crc_t const   )3753090955UL,        (z_crc_t const   )3723829714UL,        (z_crc_t const   )3694611429UL, 
            (z_crc_t const   )3614117080UL,        (z_crc_t const   )3601426159UL,        (z_crc_t const   )3572488374UL,        (z_crc_t const   )3576541825UL, 
            (z_crc_t const   )3496125444UL,        (z_crc_t const   )3516976691UL,        (z_crc_t const   )3555094634UL,        (z_crc_t const   )3525581405UL, 
            (z_crc_t const   )3311336976UL,        (z_crc_t const   )3298595879UL,        (z_crc_t const   )3336186494UL,        (z_crc_t const   )3340255305UL, 
            (z_crc_t const   )3260503756UL,        (z_crc_t const   )3281337595UL,        (z_crc_t const   )3251864226UL,        (z_crc_t const   )3222399125UL, 
            (z_crc_t const   )3410866088UL,        (z_crc_t const   )3398419871UL,        (z_crc_t const   )3368647622UL,        (z_crc_t const   )3372945905UL, 
            (z_crc_t const   )3427010420UL,        (z_crc_t const   )3448139075UL,        (z_crc_t const   )3485520666UL,        (z_crc_t const   )3456284973UL, 
            (z_crc_t const   )2444203584UL,        (z_crc_t const   )2423127159UL,        (z_crc_t const   )2452308526UL,        (z_crc_t const   )2481530905UL, 
            (z_crc_t const   )2527477404UL,        (z_crc_t const   )2539934891UL,        (z_crc_t const   )2502093554UL,        (z_crc_t const   )2497740997UL, 
            (z_crc_t const   )2679949304UL,        (z_crc_t const   )2659102159UL,        (z_crc_t const   )2620920726UL,        (z_crc_t const   )2650438049UL, 
            (z_crc_t const   )2562027300UL,        (z_crc_t const   )2574714131UL,        (z_crc_t const   )2603727690UL,        (z_crc_t const   )2599670141UL, 
            (z_crc_t const   )2374579504UL,        (z_crc_t const   )2353749767UL,        (z_crc_t const   )2383274334UL,        (z_crc_t const   )2412743529UL, 
            (z_crc_t const   )2323684844UL,        (z_crc_t const   )2336421851UL,        (z_crc_t const   )2298759554UL,        (z_crc_t const   )2294686645UL, 
            (z_crc_t const   )2207933576UL,        (z_crc_t const   )2186809023UL,        (z_crc_t const   )2149495014UL,        (z_crc_t const   )2178734801UL, 
            (z_crc_t const   )2224278612UL,        (z_crc_t const   )2236720739UL,        (z_crc_t const   )2266437690UL,        (z_crc_t const   )2262135309UL, 
            (z_crc_t const   )2850214048UL,        (z_crc_t const   )2820717207UL,        (z_crc_t const   )2858812622UL,        (z_crc_t const   )2879680249UL, 
            (z_crc_t const   )2934667388UL,        (z_crc_t const   )2938704459UL,        (z_crc_t const   )2909776914UL,        (z_crc_t const   )2897069605UL, 
            (z_crc_t const   )2817622296UL,        (z_crc_t const   )2788420399UL,        (z_crc_t const   )2759153014UL,        (z_crc_t const   )2780249921UL, 
            (z_crc_t const   )2700618180UL,        (z_crc_t const   )2704950259UL,        (z_crc_t const   )2742877610UL,        (z_crc_t const   )2730399645UL, 
            (z_crc_t const   )3049550800UL,        (z_crc_t const   )3020298727UL,        (z_crc_t const   )3057690558UL,        (z_crc_t const   )3078802825UL, 
            (z_crc_t const   )2999835404UL,        (z_crc_t const   )3004150075UL,        (z_crc_t const   )2974355298UL,        (z_crc_t const   )2961925461UL, 
            (z_crc_t const   )3151438440UL,        (z_crc_t const   )3121956959UL,        (z_crc_t const   )3092510214UL,        (z_crc_t const   )3113327665UL, 
            (z_crc_t const   )3168701108UL,        (z_crc_t const   )3172786307UL,        (z_crc_t const   )3210370778UL,        (z_crc_t const   )3197646061UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )3099354981UL,        (z_crc_t const   )2852767883UL,        (z_crc_t const   )313896942UL, 
            (z_crc_t const   )2405603159UL,        (z_crc_t const   )937357362UL,        (z_crc_t const   )627793884UL,        (z_crc_t const   )2648127673UL, 
            (z_crc_t const   )3316918511UL,        (z_crc_t const   )2097696650UL,        (z_crc_t const   )1874714724UL,        (z_crc_t const   )3607201537UL, 
            (z_crc_t const   )1255587768UL,        (z_crc_t const   )4067088605UL,        (z_crc_t const   )3772741427UL,        (z_crc_t const   )1482887254UL, 
            (z_crc_t const   )1343838111UL,        (z_crc_t const   )3903140090UL,        (z_crc_t const   )4195393300UL,        (z_crc_t const   )1118632049UL, 
            (z_crc_t const   )3749429448UL,        (z_crc_t const   )1741137837UL,        (z_crc_t const   )1970407491UL,        (z_crc_t const   )3452858150UL, 
            (z_crc_t const   )2511175536UL,        (z_crc_t const   )756094997UL,        (z_crc_t const   )1067759611UL,        (z_crc_t const   )2266550430UL, 
            (z_crc_t const   )449832999UL,        (z_crc_t const   )2725482306UL,        (z_crc_t const   )2965774508UL,        (z_crc_t const   )142231497UL, 
            (z_crc_t const   )2687676222UL,        (z_crc_t const   )412010587UL,        (z_crc_t const   )171665333UL,        (z_crc_t const   )2995192016UL, 
            (z_crc_t const   )793786473UL,        (z_crc_t const   )2548850444UL,        (z_crc_t const   )2237264098UL,        (z_crc_t const   )1038456711UL, 
            (z_crc_t const   )1703315409UL,        (z_crc_t const   )3711623348UL,        (z_crc_t const   )3482275674UL,        (z_crc_t const   )1999841343UL, 
            (z_crc_t const   )3940814982UL,        (z_crc_t const   )1381529571UL,        (z_crc_t const   )1089329165UL,        (z_crc_t const   )4166106984UL, 
            (z_crc_t const   )4029413537UL,        (z_crc_t const   )1217896388UL,        (z_crc_t const   )1512189994UL,        (z_crc_t const   )3802027855UL, 
            (z_crc_t const   )2135519222UL,        (z_crc_t const   )3354724499UL,        (z_crc_t const   )3577784189UL,        (z_crc_t const   )1845280792UL, 
            (z_crc_t const   )899665998UL,        (z_crc_t const   )2367928107UL,        (z_crc_t const   )2677414085UL,        (z_crc_t const   )657096608UL, 
            (z_crc_t const   )3137160985UL,        (z_crc_t const   )37822588UL,        (z_crc_t const   )284462994UL,        (z_crc_t const   )2823350519UL, 
            (z_crc_t const   )2601801789UL,        (z_crc_t const   )598228824UL,        (z_crc_t const   )824021174UL,        (z_crc_t const   )2309093331UL, 
            (z_crc_t const   )343330666UL,        (z_crc_t const   )2898962447UL,        (z_crc_t const   )3195996129UL,        (z_crc_t const   )113467524UL, 
            (z_crc_t const   )1587572946UL,        (z_crc_t const   )3860600759UL,        (z_crc_t const   )4104763481UL,        (z_crc_t const   )1276501820UL, 
            (z_crc_t const   )3519211397UL,        (z_crc_t const   )1769898208UL,        (z_crc_t const   )2076913422UL,        (z_crc_t const   )3279374443UL, 
            (z_crc_t const   )3406630818UL,        (z_crc_t const   )1941006535UL,        (z_crc_t const   )1627703081UL,        (z_crc_t const   )3652755532UL, 
            (z_crc_t const   )1148164341UL,        (z_crc_t const   )4241751952UL,        (z_crc_t const   )3999682686UL,        (z_crc_t const   )1457141531UL, 
            (z_crc_t const   )247015245UL,        (z_crc_t const   )3053797416UL,        (z_crc_t const   )2763059142UL,        (z_crc_t const   )470583459UL, 
            (z_crc_t const   )2178658330UL,        (z_crc_t const   )963106687UL,        (z_crc_t const   )735213713UL,        (z_crc_t const   )2473467892UL, 
            (z_crc_t const   )992409347UL,        (z_crc_t const   )2207944806UL,        (z_crc_t const   )2435792776UL,        (z_crc_t const   )697522413UL, 
            (z_crc_t const   )3024379988UL,        (z_crc_t const   )217581361UL,        (z_crc_t const   )508405983UL,        (z_crc_t const   )2800865210UL, 
            (z_crc_t const   )4271038444UL,        (z_crc_t const   )1177467017UL,        (z_crc_t const   )1419450215UL,        (z_crc_t const   )3962007554UL, 
            (z_crc_t const   )1911572667UL,        (z_crc_t const   )3377213406UL,        (z_crc_t const   )3690561584UL,        (z_crc_t const   )1665525589UL, 
            (z_crc_t const   )1799331996UL,        (z_crc_t const   )3548628985UL,        (z_crc_t const   )3241568279UL,        (z_crc_t const   )2039091058UL, 
            (z_crc_t const   )3831314379UL,        (z_crc_t const   )1558270126UL,        (z_crc_t const   )1314193216UL,        (z_crc_t const   )4142438437UL, 
            (z_crc_t const   )2928380019UL,        (z_crc_t const   )372764438UL,        (z_crc_t const   )75645176UL,        (z_crc_t const   )3158189981UL, 
            (z_crc_t const   )568925988UL,        (z_crc_t const   )2572515393UL,        (z_crc_t const   )2346768303UL,        (z_crc_t const   )861712586UL, 
            (z_crc_t const   )3982079547UL,        (z_crc_t const   )1441124702UL,        (z_crc_t const   )1196457648UL,        (z_crc_t const   )4293663189UL, 
            (z_crc_t const   )1648042348UL,        (z_crc_t const   )3666298377UL,        (z_crc_t const   )3358779879UL,        (z_crc_t const   )1888390786UL, 
            (z_crc_t const   )686661332UL,        (z_crc_t const   )2421291441UL,        (z_crc_t const   )2196002399UL,        (z_crc_t const   )978858298UL, 
            (z_crc_t const   )2811169155UL,        (z_crc_t const   )523464422UL,        (z_crc_t const   )226935048UL,        (z_crc_t const   )3040519789UL, 
            (z_crc_t const   )3175145892UL,        (z_crc_t const   )100435649UL,        (z_crc_t const   )390670639UL,        (z_crc_t const   )2952089162UL, 
            (z_crc_t const   )841119475UL,        (z_crc_t const   )2325614998UL,        (z_crc_t const   )2553003640UL,        (z_crc_t const   )546822429UL, 
            (z_crc_t const   )2029308235UL,        (z_crc_t const   )3225988654UL,        (z_crc_t const   )3539796416UL,        (z_crc_t const   )1782671013UL, 
            (z_crc_t const   )4153826844UL,        (z_crc_t const   )1328167289UL,        (z_crc_t const   )1570739863UL,        (z_crc_t const   )3844338162UL, 
            (z_crc_t const   )1298864389UL,        (z_crc_t const   )4124540512UL,        (z_crc_t const   )3882013070UL,        (z_crc_t const   )1608431339UL, 
            (z_crc_t const   )3255406162UL,        (z_crc_t const   )2058742071UL,        (z_crc_t const   )1744848601UL,        (z_crc_t const   )3501990332UL, 
            (z_crc_t const   )2296328682UL,        (z_crc_t const   )811816591UL,        (z_crc_t const   )584513889UL,        (z_crc_t const   )2590678532UL, 
            (z_crc_t const   )129869501UL,        (z_crc_t const   )3204563416UL,        (z_crc_t const   )2914283062UL,        (z_crc_t const   )352848211UL, 
            (z_crc_t const   )494030490UL,        (z_crc_t const   )2781751807UL,        (z_crc_t const   )3078325777UL,        (z_crc_t const   )264757620UL, 
            (z_crc_t const   )2450577869UL,        (z_crc_t const   )715964072UL,        (z_crc_t const   )941166918UL,        (z_crc_t const   )2158327331UL, 
            (z_crc_t const   )3636881013UL,        (z_crc_t const   )1618608400UL,        (z_crc_t const   )1926213374UL,        (z_crc_t const   )3396585883UL, 
            (z_crc_t const   )1470427426UL,        (z_crc_t const   )4011365959UL,        (z_crc_t const   )4255988137UL,        (z_crc_t const   )1158766284UL, 
            (z_crc_t const   )1984818694UL,        (z_crc_t const   )3471935843UL,        (z_crc_t const   )3695453837UL,        (z_crc_t const   )1693991400UL, 
            (z_crc_t const   )4180638033UL,        (z_crc_t const   )1100160564UL,        (z_crc_t const   )1395044826UL,        (z_crc_t const   )3952793279UL, 
            (z_crc_t const   )3019491049UL,        (z_crc_t const   )189112716UL,        (z_crc_t const   )435162722UL,        (z_crc_t const   )2706139399UL, 
            (z_crc_t const   )1016811966UL,        (z_crc_t const   )2217162459UL,        (z_crc_t const   )2526189877UL,        (z_crc_t const   )774831696UL, 
            (z_crc_t const   )643086745UL,        (z_crc_t const   )2666061564UL,        (z_crc_t const   )2354934034UL,        (z_crc_t const   )887166583UL, 
            (z_crc_t const   )2838900430UL,        (z_crc_t const   )294275499UL,        (z_crc_t const   )54519365UL,        (z_crc_t const   )3145957664UL, 
            (z_crc_t const   )3823145334UL,        (z_crc_t const   )1532818963UL,        (z_crc_t const   )1240029693UL,        (z_crc_t const   )4048895640UL, 
            (z_crc_t const   )1820460577UL,        (z_crc_t const   )3560857924UL,        (z_crc_t const   )3331051178UL,        (z_crc_t const   )2117577167UL, 
            (z_crc_t const   )3598663992UL,        (z_crc_t const   )1858283101UL,        (z_crc_t const   )2088143283UL,        (z_crc_t const   )3301633750UL, 
            (z_crc_t const   )1495127663UL,        (z_crc_t const   )3785470218UL,        (z_crc_t const   )4078182116UL,        (z_crc_t const   )1269332353UL, 
            (z_crc_t const   )332098007UL,        (z_crc_t const   )2876706482UL,        (z_crc_t const   )3116540252UL,        (z_crc_t const   )25085497UL, 
            (z_crc_t const   )2628386432UL,        (z_crc_t const   )605395429UL,        (z_crc_t const   )916469259UL,        (z_crc_t const   )2384220526UL, 
            (z_crc_t const   )2254837415UL,        (z_crc_t const   )1054503362UL,        (z_crc_t const   )745528876UL,        (z_crc_t const   )2496903497UL, 
            (z_crc_t const   )151290352UL,        (z_crc_t const   )2981684885UL,        (z_crc_t const   )2735556987UL,        (z_crc_t const   )464596510UL, 
            (z_crc_t const   )1137851976UL,        (z_crc_t const   )4218313005UL,        (z_crc_t const   )3923506883UL,        (z_crc_t const   )1365741990UL, 
            (z_crc_t const   )3434129695UL,        (z_crc_t const   )1946996346UL,        (z_crc_t const   )1723425172UL,        (z_crc_t const   )3724871409UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )2519730039UL,        (z_crc_t const   )744558318UL,        (z_crc_t const   )3125873049UL, 
            (z_crc_t const   )432303367UL,        (z_crc_t const   )2415159920UL,        (z_crc_t const   )900031465UL,        (z_crc_t const   )2744476830UL, 
            (z_crc_t const   )847829774UL,        (z_crc_t const   )2763578489UL,        (z_crc_t const   )518641120UL,        (z_crc_t const   )2295976599UL, 
            (z_crc_t const   )726447625UL,        (z_crc_t const   )3179065726UL,        (z_crc_t const   )120436967UL,        (z_crc_t const   )2434645904UL, 
            (z_crc_t const   )1678817053UL,        (z_crc_t const   )4062228586UL,        (z_crc_t const   )1215412723UL,        (z_crc_t const   )3728850564UL, 
            (z_crc_t const   )2111101466UL,        (z_crc_t const   )3957644653UL,        (z_crc_t const   )1370871028UL,        (z_crc_t const   )3347436419UL, 
            (z_crc_t const   )1452829715UL,        (z_crc_t const   )3232263012UL,        (z_crc_t const   )2063164157UL,        (z_crc_t const   )3972621706UL, 
            (z_crc_t const   )1331429652UL,        (z_crc_t const   )3647735395UL,        (z_crc_t const   )1664946170UL,        (z_crc_t const   )4111272077UL, 
            (z_crc_t const   )3357568571UL,        (z_crc_t const   )1578133836UL,        (z_crc_t const   )3829489877UL,        (z_crc_t const   )1920034722UL, 
            (z_crc_t const   )3521381180UL,        (z_crc_t const   )1205077067UL,        (z_crc_t const   )4253355474UL,        (z_crc_t const   )1807026853UL, 
            (z_crc_t const   )4205360437UL,        (z_crc_t const   )1821946434UL,        (z_crc_t const   )3603545051UL,        (z_crc_t const   )1090108588UL, 
            (z_crc_t const   )3815561266UL,        (z_crc_t const   )1969020741UL,        (z_crc_t const   )3473790684UL,        (z_crc_t const   )1497223595UL, 
            (z_crc_t const   )2888882470UL,        (z_crc_t const   )973135441UL,        (z_crc_t const   )2152847304UL,        (z_crc_t const   )375509183UL, 
            (z_crc_t const   )3052712993UL,        (z_crc_t const   )600093526UL,        (z_crc_t const   )2576726735UL,        (z_crc_t const   )262520248UL, 
            (z_crc_t const   )2662859304UL,        (z_crc_t const   )143131999UL,        (z_crc_t const   )3000569030UL,        (z_crc_t const   )619252657UL, 
            (z_crc_t const   )2273079087UL,        (z_crc_t const   )290220120UL,        (z_crc_t const   )2870829505UL,        (z_crc_t const   )1026385590UL, 
            (z_crc_t const   )2420235382UL,        (z_crc_t const   )108124929UL,        (z_crc_t const   )3156267672UL,        (z_crc_t const   )705746415UL, 
            (z_crc_t const   )2307240305UL,        (z_crc_t const   )532002310UL,        (z_crc_t const   )2783231903UL,        (z_crc_t const   )869578984UL, 
            (z_crc_t const   )2731083640UL,        (z_crc_t const   )888733711UL,        (z_crc_t const   )2393377174UL,        (z_crc_t const   )412618465UL, 
            (z_crc_t const   )3138218623UL,        (z_crc_t const   )759000328UL,        (z_crc_t const   )2540463249UL,        (z_crc_t const   )22832102UL, 
            (z_crc_t const   )4098976619UL,        (z_crc_t const   )1650551836UL,        (z_crc_t const   )3627050373UL,        (z_crc_t const   )1308648178UL, 
            (z_crc_t const   )3985966700UL,        (z_crc_t const   )2074411291UL,        (z_crc_t const   )3253995650UL,        (z_crc_t const   )1472466933UL, 
            (z_crc_t const   )3336155237UL,        (z_crc_t const   )1357494034UL,        (z_crc_t const   )3937975947UL,        (z_crc_t const   )2089335292UL, 
            (z_crc_t const   )3743276386UL,        (z_crc_t const   )1227741717UL,        (z_crc_t const   )4085044108UL,        (z_crc_t const   )1699534075UL, 
            (z_crc_t const   )1482797645UL,        (z_crc_t const   )3461461306UL,        (z_crc_t const   )1946205347UL,        (z_crc_t const   )3794844628UL, 
            (z_crc_t const   )1101389642UL,        (z_crc_t const   )3616921661UL,        (z_crc_t const   )1841615268UL,        (z_crc_t const   )4227126995UL, 
            (z_crc_t const   )1793681731UL,        (z_crc_t const   )4242107956UL,        (z_crc_t const   )1183344557UL,        (z_crc_t const   )3501744346UL, 
            (z_crc_t const   )1932330052UL,        (z_crc_t const   )3843883827UL,        (z_crc_t const   )1598818986UL,        (z_crc_t const   )3380350429UL, 
            (z_crc_t const   )1014039888UL,        (z_crc_t const   )2856387111UL,        (z_crc_t const   )269487038UL,        (z_crc_t const   )2250247369UL, 
            (z_crc_t const   )632645719UL,        (z_crc_t const   )3011866400UL,        (z_crc_t const   )164914873UL,        (z_crc_t const   )2682544590UL, 
            (z_crc_t const   )251256414UL,        (z_crc_t const   )2563365161UL,        (z_crc_t const   )580440240UL,        (z_crc_t const   )3030964167UL, 
            (z_crc_t const   )389919577UL,        (z_crc_t const   )2165158958UL,        (z_crc_t const   )995933623UL,        (z_crc_t const   )2909584064UL, 
            (z_crc_t const   )545503469UL,        (z_crc_t const   )3065233306UL,        (z_crc_t const   )216184323UL,        (z_crc_t const   )2597499252UL, 
            (z_crc_t const   )961009130UL,        (z_crc_t const   )2943865501UL,        (z_crc_t const   )354867972UL,        (z_crc_t const   )2199313523UL, 
            (z_crc_t const   )302736355UL,        (z_crc_t const   )2218484884UL,        (z_crc_t const   )1047162125UL,        (z_crc_t const   )2824497786UL, 
            (z_crc_t const   )198119140UL,        (z_crc_t const   )2650737043UL,        (z_crc_t const   )665714698UL,        (z_crc_t const   )2979923837UL, 
            (z_crc_t const   )1150488560UL,        (z_crc_t const   )3533899911UL,        (z_crc_t const   )1760690462UL,        (z_crc_t const   )4274128489UL, 
            (z_crc_t const   )1566008055UL,        (z_crc_t const   )3412551040UL,        (z_crc_t const   )1899392025UL,        (z_crc_t const   )3875957614UL, 
            (z_crc_t const   )1981535486UL,        (z_crc_t const   )3760968585UL,        (z_crc_t const   )1518000656UL,        (z_crc_t const   )3427458407UL, 
            (z_crc_t const   )1876933113UL,        (z_crc_t const   )4193238670UL,        (z_crc_t const   )1136572183UL,        (z_crc_t const   )3582898272UL, 
            (z_crc_t const   )3903051478UL,        (z_crc_t const   )2123616673UL,        (z_crc_t const   )3301103672UL,        (z_crc_t const   )1391648591UL, 
            (z_crc_t const   )4050107345UL,        (z_crc_t const   )1733803174UL,        (z_crc_t const   )3708204351UL,        (z_crc_t const   )1261875784UL, 
            (z_crc_t const   )3660254680UL,        (z_crc_t const   )1276840623UL,        (z_crc_t const   )4132045622UL,        (z_crc_t const   )1618609217UL, 
            (z_crc_t const   )3287245023UL,        (z_crc_t const   )1440704424UL,        (z_crc_t const   )4019088945UL,        (z_crc_t const   )2042521926UL, 
            (z_crc_t const   )2360566219UL,        (z_crc_t const   )444819132UL,        (z_crc_t const   )2698145573UL,        (z_crc_t const   )920807506UL, 
            (z_crc_t const   )2507607244UL,        (z_crc_t const   )54987707UL,        (z_crc_t const   )3105227298UL,        (z_crc_t const   )791020885UL, 
            (z_crc_t const   )3191585477UL,        (z_crc_t const   )671858098UL,        (z_crc_t const   )2455417899UL,        (z_crc_t const   )74101596UL, 
            (z_crc_t const   )2818561986UL,        (z_crc_t const   )835702965UL,        (z_crc_t const   )2342443308UL,        (z_crc_t const   )497999451UL, 
            (z_crc_t const   )2965529755UL,        (z_crc_t const   )653419500UL,        (z_crc_t const   )2627955317UL,        (z_crc_t const   )177433858UL, 
            (z_crc_t const   )2835745180UL,        (z_crc_t const   )1060507371UL,        (z_crc_t const   )2238121842UL,        (z_crc_t const   )324468741UL, 
            (z_crc_t const   )2185936789UL,        (z_crc_t const   )343587042UL,        (z_crc_t const   )2922099067UL,        (z_crc_t const   )941340172UL, 
            (z_crc_t const   )2609828498UL,        (z_crc_t const   )230610405UL,        (z_crc_t const   )3085950076UL,        (z_crc_t const   )568318731UL, 
            (z_crc_t const   )3570586502UL,        (z_crc_t const   )1122161905UL,        (z_crc_t const   )4172537192UL,        (z_crc_t const   )1854134815UL, 
            (z_crc_t const   )3440819841UL,        (z_crc_t const   )1529264630UL,        (z_crc_t const   )3782717551UL,        (z_crc_t const   )2001188632UL, 
            (z_crc_t const   )3864660104UL,        (z_crc_t const   )1885999103UL,        (z_crc_t const   )3392865894UL,        (z_crc_t const   )1544225041UL, 
            (z_crc_t const   )4288570767UL,        (z_crc_t const   )1773036280UL,        (z_crc_t const   )3556731745UL,        (z_crc_t const   )1171221526UL, 
            (z_crc_t const   )2028079776UL,        (z_crc_t const   )4006743511UL,        (z_crc_t const   )1417872462UL,        (z_crc_t const   )3266511673UL, 
            (z_crc_t const   )1629906855UL,        (z_crc_t const   )4145438928UL,        (z_crc_t const   )1296525641UL,        (z_crc_t const   )3682037310UL, 
            (z_crc_t const   )1248514478UL,        (z_crc_t const   )3696940761UL,        (z_crc_t const   )1712054080UL,        (z_crc_t const   )4030453815UL, 
            (z_crc_t const   )1403960489UL,        (z_crc_t const   )3315514334UL,        (z_crc_t const   )2144318023UL,        (z_crc_t const   )3925849392UL, 
            (z_crc_t const   )485670333UL,        (z_crc_t const   )2328017610UL,        (z_crc_t const   )814986067UL,        (z_crc_t const   )2795746340UL, 
            (z_crc_t const   )87478458UL,        (z_crc_t const   )2466699213UL,        (z_crc_t const   )693624404UL,        (z_crc_t const   )3211254051UL, 
            (z_crc_t const   )779773619UL,        (z_crc_t const   )3091882436UL,        (z_crc_t const   )35350621UL,        (z_crc_t const   )2485874474UL, 
            (z_crc_t const   )935201716UL,        (z_crc_t const   )2710441155UL,        (z_crc_t const   )467600730UL,        (z_crc_t const   )2381251117UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )1093737241UL,        (z_crc_t const   )2187474482UL,        (z_crc_t const   )3277008171UL, 
            (z_crc_t const   )80047204UL,        (z_crc_t const   )1173649277UL,        (z_crc_t const   )2259114582UL,        (z_crc_t const   )3348513103UL, 
            (z_crc_t const   )143317448UL,        (z_crc_t const   )1237041873UL,        (z_crc_t const   )2330521594UL,        (z_crc_t const   )3420058851UL, 
            (z_crc_t const   )206550444UL,        (z_crc_t const   )1300147893UL,        (z_crc_t const   )2385347486UL,        (z_crc_t const   )3474757767UL, 
            (z_crc_t const   )1360183882UL,        (z_crc_t const   )270784851UL,        (z_crc_t const   )3547395192UL,        (z_crc_t const   )2453794657UL, 
            (z_crc_t const   )1440198190UL,        (z_crc_t const   )350663991UL,        (z_crc_t const   )3619002396UL,        (z_crc_t const   )2525266693UL, 
            (z_crc_t const   )1503140738UL,        (z_crc_t const   )413728923UL,        (z_crc_t const   )3690606000UL,        (z_crc_t const   )2597009065UL, 
            (z_crc_t const   )1566406630UL,        (z_crc_t const   )476867839UL,        (z_crc_t const   )3745464788UL,        (z_crc_t const   )2651740877UL, 
            (z_crc_t const   )2720302229UL,        (z_crc_t const   )3809845132UL,        (z_crc_t const   )541504167UL,        (z_crc_t const   )1635232190UL, 
            (z_crc_t const   )2799823089UL,        (z_crc_t const   )3889230824UL,        (z_crc_t const   )612622019UL,        (z_crc_t const   )1706214874UL, 
            (z_crc_t const   )2863553885UL,        (z_crc_t const   )3953083972UL,        (z_crc_t const   )684485487UL,        (z_crc_t const   )1778217078UL, 
            (z_crc_t const   )2926260537UL,        (z_crc_t const   )4015663648UL,        (z_crc_t const   )738789131UL,        (z_crc_t const   )1832393746UL, 
            (z_crc_t const   )4080420575UL,        (z_crc_t const   )2986827206UL,        (z_crc_t const   )1901359341UL,        (z_crc_t const   )811953140UL, 
            (z_crc_t const   )4159908539UL,        (z_crc_t const   )3066180002UL,        (z_crc_t const   )1972444297UL,        (z_crc_t const   )882902928UL, 
            (z_crc_t const   )4223442711UL,        (z_crc_t const   )3129836558UL,        (z_crc_t const   )2044635429UL,        (z_crc_t const   )955232828UL, 
            (z_crc_t const   )4286182259UL,        (z_crc_t const   )3192449130UL,        (z_crc_t const   )2098971969UL,        (z_crc_t const   )1009442392UL, 
            (z_crc_t const   )89094640UL,        (z_crc_t const   )1149133545UL,        (z_crc_t const   )2267893698UL,        (z_crc_t const   )3323745499UL, 
            (z_crc_t const   )25826708UL,        (z_crc_t const   )1086000781UL,        (z_crc_t const   )2213028774UL,        (z_crc_t const   )3269015743UL, 
            (z_crc_t const   )231055416UL,        (z_crc_t const   )1291107105UL,        (z_crc_t const   )2410124810UL,        (z_crc_t const   )3465973011UL, 
            (z_crc_t const   )151047260UL,        (z_crc_t const   )1211225925UL,        (z_crc_t const   )2338519662UL,        (z_crc_t const   )3394494839UL, 
            (z_crc_t const   )1415429050UL,        (z_crc_t const   )359440547UL,        (z_crc_t const   )3594489224UL,        (z_crc_t const   )2534315665UL, 
            (z_crc_t const   )1352194014UL,        (z_crc_t const   )296340679UL,        (z_crc_t const   )3539657196UL,        (z_crc_t const   )2479618805UL, 
            (z_crc_t const   )1557619314UL,        (z_crc_t const   )501643627UL,        (z_crc_t const   )3736425536UL,        (z_crc_t const   )2676248409UL, 
            (z_crc_t const   )1477578262UL,        (z_crc_t const   )421729551UL,        (z_crc_t const   )3664787492UL,        (z_crc_t const   )2604737341UL, 
            (z_crc_t const   )2808872293UL,        (z_crc_t const   )3864716924UL,        (z_crc_t const   )621398871UL,        (z_crc_t const   )1681444942UL, 
            (z_crc_t const   )2746126593UL,        (z_crc_t const   )3802106392UL,        (z_crc_t const   )567060275UL,        (z_crc_t const   )1627241514UL, 
            (z_crc_t const   )2950767789UL,        (z_crc_t const   )4006625204UL,        (z_crc_t const   )763564703UL,        (z_crc_t const   )1823607174UL, 
            (z_crc_t const   )2871281865UL,        (z_crc_t const   )3927266256UL,        (z_crc_t const   )692485883UL,        (z_crc_t const   )1752655330UL, 
            (z_crc_t const   )4135141167UL,        (z_crc_t const   )3074958390UL,        (z_crc_t const   )1947928861UL,        (z_crc_t const   )891949572UL, 
            (z_crc_t const   )4072428363UL,        (z_crc_t const   )3012380754UL,        (z_crc_t const   )1893623161UL,        (z_crc_t const   )837779040UL, 
            (z_crc_t const   )4277397223UL,        (z_crc_t const   )3217227262UL,        (z_crc_t const   )2089930965UL,        (z_crc_t const   )1033948108UL, 
            (z_crc_t const   )4197878403UL,        (z_crc_t const   )3137835418UL,        (z_crc_t const   )2018819249UL,        (z_crc_t const   )962963368UL, 
            (z_crc_t const   )1268286267UL,        (z_crc_t const   )178886690UL,        (z_crc_t const   )3388650761UL,        (z_crc_t const   )2295049744UL, 
            (z_crc_t const   )1331556191UL,        (z_crc_t const   )242021446UL,        (z_crc_t const   )3443513709UL,        (z_crc_t const   )2349777524UL, 
            (z_crc_t const   )1125276403UL,        (z_crc_t const   )35865066UL,        (z_crc_t const   )3245370561UL,        (z_crc_t const   )2151774168UL, 
            (z_crc_t const   )1205286551UL,        (z_crc_t const   )115748238UL,        (z_crc_t const   )3316973733UL,        (z_crc_t const   )2223250364UL, 
            (z_crc_t const   )445268337UL,        (z_crc_t const   )1539005032UL,        (z_crc_t const   )2565371715UL,        (z_crc_t const   )3654904922UL, 
            (z_crc_t const   )508505365UL,        (z_crc_t const   )1602106892UL,        (z_crc_t const   )2620201767UL,        (z_crc_t const   )3709599806UL, 
            (z_crc_t const   )302028985UL,        (z_crc_t const   )1395753888UL,        (z_crc_t const   )2422386315UL,        (z_crc_t const   )3511924114UL, 
            (z_crc_t const   )382072029UL,        (z_crc_t const   )1475669956UL,        (z_crc_t const   )2494022383UL,        (z_crc_t const   )3583433206UL, 
            (z_crc_t const   )3921414062UL,        (z_crc_t const   )2827820215UL,        (z_crc_t const   )1809723804UL,        (z_crc_t const   )720317061UL, 
            (z_crc_t const   )3984157642UL,        (z_crc_t const   )2890428627UL,        (z_crc_t const   )1864064504UL,        (z_crc_t const   )774522593UL, 
            (z_crc_t const   )3778469478UL,        (z_crc_t const   )2684863871UL,        (z_crc_t const   )1666508884UL,        (z_crc_t const   )577106765UL, 
            (z_crc_t const   )3857953282UL,        (z_crc_t const   )2764220699UL,        (z_crc_t const   )1737589808UL,        (z_crc_t const   )648060713UL, 
            (z_crc_t const   )3098461668UL,        (z_crc_t const   )4188004093UL,        (z_crc_t const   )986510294UL,        (z_crc_t const   )2080237775UL, 
            (z_crc_t const   )3161172352UL,        (z_crc_t const   )4250579609UL,        (z_crc_t const   )1040818098UL,        (z_crc_t const   )2134410411UL, 
            (z_crc_t const   )2955156524UL,        (z_crc_t const   )4044687157UL,        (z_crc_t const   )843459102UL,        (z_crc_t const   )1937191175UL, 
            (z_crc_t const   )3034673224UL,        (z_crc_t const   )4124076881UL,        (z_crc_t const   )914572922UL,        (z_crc_t const   )2008178019UL, 
            (z_crc_t const   )1322777291UL,        (z_crc_t const   )266789330UL,        (z_crc_t const   )3434466553UL,        (z_crc_t const   )2374293472UL, 
            (z_crc_t const   )1242732207UL,        (z_crc_t const   )186879414UL,        (z_crc_t const   )3362824349UL,        (z_crc_t const   )2302786436UL, 
            (z_crc_t const   )1180508931UL,        (z_crc_t const   )124532762UL,        (z_crc_t const   )3292468529UL,        (z_crc_t const   )2232290856UL, 
            (z_crc_t const   )1117278055UL,        (z_crc_t const   )61428862UL,        (z_crc_t const   )3237640533UL,        (z_crc_t const   )2177589836UL, 
            (z_crc_t const   )533018753UL,        (z_crc_t const   )1593058200UL,        (z_crc_t const   )2644971187UL,        (z_crc_t const   )3700823466UL, 
            (z_crc_t const   )453006565UL,        (z_crc_t const   )1513181180UL,        (z_crc_t const   )2573361879UL,        (z_crc_t const   )3629349326UL, 
            (z_crc_t const   )391110985UL,        (z_crc_t const   )1451162192UL,        (z_crc_t const   )2502809467UL,        (z_crc_t const   )3558657122UL, 
            (z_crc_t const   )327847213UL,        (z_crc_t const   )1388025396UL,        (z_crc_t const   )2447948575UL,        (z_crc_t const   )3503923206UL, 
            (z_crc_t const   )3975380574UL,        (z_crc_t const   )2915198279UL,        (z_crc_t const   )1855015020UL,        (z_crc_t const   )799036277UL, 
            (z_crc_t const   )3895857722UL,        (z_crc_t const   )2835810595UL,        (z_crc_t const   )1783899144UL,        (z_crc_t const   )728055569UL, 
            (z_crc_t const   )3833178006UL,        (z_crc_t const   )2773007503UL,        (z_crc_t const   )1713082788UL,        (z_crc_t const   )657099453UL, 
            (z_crc_t const   )3770469362UL,        (z_crc_t const   )2710425835UL,        (z_crc_t const   )1658781120UL,        (z_crc_t const   )602924761UL, 
            (z_crc_t const   )3185687572UL,        (z_crc_t const   )4241532685UL,        (z_crc_t const   )1065585190UL,        (z_crc_t const   )2125631807UL, 
            (z_crc_t const   )3106197616UL,        (z_crc_t const   )4162177897UL,        (z_crc_t const   )994502210UL,        (z_crc_t const   )2054683995UL, 
            (z_crc_t const   )3043714524UL,        (z_crc_t const   )4099571397UL,        (z_crc_t const   )923358190UL,        (z_crc_t const   )1983400183UL, 
            (z_crc_t const   )2980972984UL,        (z_crc_t const   )4036956833UL,        (z_crc_t const   )869023626UL,        (z_crc_t const   )1929192595UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )929743361UL,        (z_crc_t const   )1859421187UL,        (z_crc_t const   )1505641986UL, 
            (z_crc_t const   )3701999879UL,        (z_crc_t const   )3955411718UL,        (z_crc_t const   )2994507012UL,        (z_crc_t const   )2232831749UL, 
            (z_crc_t const   )3092321038UL,        (z_crc_t const   )2403062031UL,        (z_crc_t const   )3599079181UL,        (z_crc_t const   )3790558476UL, 
            (z_crc_t const   )1694046729UL,        (z_crc_t const   )1402198024UL,        (z_crc_t const   )170761738UL,        (z_crc_t const   )1028086795UL, 
            (z_crc_t const   )1889740316UL,        (z_crc_t const   )1204413469UL,        (z_crc_t const   )511156767UL,        (z_crc_t const   )689791006UL, 
            (z_crc_t const   )2886414107UL,        (z_crc_t const   )2606886170UL,        (z_crc_t const   )3269438232UL,        (z_crc_t const   )4122306841UL, 
            (z_crc_t const   )3371316498UL,        (z_crc_t const   )4288214803UL,        (z_crc_t const   )2787553553UL,        (z_crc_t const   )2437706512UL, 
            (z_crc_t const   )341457941UL,        (z_crc_t const   )590413332UL,        (z_crc_t const   )2056173590UL,        (z_crc_t const   )1306819095UL, 
            (z_crc_t const   )3762703672UL,        (z_crc_t const   )3610021689UL,        (z_crc_t const   )2391984443UL,        (z_crc_t const   )3120040762UL, 
            (z_crc_t const   )1022247999UL,        (z_crc_t const   )193234494UL,        (z_crc_t const   )1379582012UL,        (z_crc_t const   )1699742269UL, 
            (z_crc_t const   )1477926454UL,        (z_crc_t const   )1870502967UL,        (z_crc_t const   )918805045UL,        (z_crc_t const   )27858996UL, 
            (z_crc_t const   )2227132209UL,        (z_crc_t const   )3017119024UL,        (z_crc_t const   )3932934962UL,        (z_crc_t const   )3707834675UL, 
            (z_crc_t const   )2430954276UL,        (z_crc_t const   )2811210021UL,        (z_crc_t const   )4264685351UL,        (z_crc_t const   )3378195750UL, 
            (z_crc_t const   )1280139811UL,        (z_crc_t const   )2066194466UL,        (z_crc_t const   )580511264UL,        (z_crc_t const   )368256033UL, 
            (z_crc_t const   )682915882UL,        (z_crc_t const   )534690347UL,        (z_crc_t const   )1180761129UL,        (z_crc_t const   )1896496680UL, 
            (z_crc_t const   )4095504685UL,        (z_crc_t const   )3279336236UL,        (z_crc_t const   )2596861230UL,        (z_crc_t const   )2913089327UL, 
            (z_crc_t const   )3230505584UL,        (z_crc_t const   )4159133809UL,        (z_crc_t const   )2925076083UL,        (z_crc_t const   )2570312818UL, 
            (z_crc_t const   )472224631UL,        (z_crc_t const   )726618486UL,        (z_crc_t const   )1928402804UL,        (z_crc_t const   )1167840629UL, 
            (z_crc_t const   )2027719038UL,        (z_crc_t const   )1337346943UL,        (z_crc_t const   )369626493UL,        (z_crc_t const   )560123772UL, 
            (z_crc_t const   )2759098489UL,        (z_crc_t const   )2468233848UL,        (z_crc_t const   )3399484538UL,        (z_crc_t const   )4257924731UL, 
            (z_crc_t const   )2955852908UL,        (z_crc_t const   )2269412973UL,        (z_crc_t const   )3740940399UL,        (z_crc_t const   )3918592622UL, 
            (z_crc_t const   )1820767595UL,        (z_crc_t const   )1542223722UL,        (z_crc_t const   )38941032UL,        (z_crc_t const   )892924777UL, 
            (z_crc_t const   )142585698UL,        (z_crc_t const   )1058368867UL,        (z_crc_t const   )1722493793UL,        (z_crc_t const   )1371662688UL, 
            (z_crc_t const   )3570902629UL,        (z_crc_t const   )3820840036UL,        (z_crc_t const   )3120767590UL,        (z_crc_t const   )2372526183UL, 
            (z_crc_t const   )550229832UL,        (z_crc_t const   )396432713UL,        (z_crc_t const   )1310675787UL,        (z_crc_t const   )2037748042UL, 
            (z_crc_t const   )4234403407UL,        (z_crc_t const   )3406371918UL,        (z_crc_t const   )2461489740UL,        (z_crc_t const   )2782763085UL, 
            (z_crc_t const   )2560279622UL,        (z_crc_t const   )2951743047UL,        (z_crc_t const   )4132323397UL,        (z_crc_t const   )3240395332UL, 
            (z_crc_t const   )1144180033UL,        (z_crc_t const   )1935150912UL,        (z_crc_t const   )719735106UL,        (z_crc_t const   )495749955UL, 
            (z_crc_t const   )1349054804UL,        (z_crc_t const   )1728197461UL,        (z_crc_t const   )1052538199UL,        (z_crc_t const   )165066582UL, 
            (z_crc_t const   )2361456723UL,        (z_crc_t const   )3148495442UL,        (z_crc_t const   )3792993360UL,        (z_crc_t const   )3581853265UL, 
            (z_crc_t const   )3896107610UL,        (z_crc_t const   )3746766939UL,        (z_crc_t const   )2263705177UL,        (z_crc_t const   )2978456664UL, 
            (z_crc_t const   )881978205UL,        (z_crc_t const   )66791772UL,        (z_crc_t const   )1514499934UL,        (z_crc_t const   )1831841119UL, 
            (z_crc_t const   )2149266913UL,        (z_crc_t const   )3077699552UL,        (z_crc_t const   )4006588898UL,        (z_crc_t const   )3651498979UL, 
            (z_crc_t const   )1555250406UL,        (z_crc_t const   )1809448679UL,        (z_crc_t const   )845658341UL,        (z_crc_t const   )84769508UL, 
            (z_crc_t const   )944383727UL,        (z_crc_t const   )253813998UL,        (z_crc_t const   )1453236972UL,        (z_crc_t const   )1643405549UL, 
            (z_crc_t const   )3840028648UL,        (z_crc_t const   )3548966377UL,        (z_crc_t const   )2318838763UL,        (z_crc_t const   )3176950250UL, 
            (z_crc_t const   )4038595581UL,        (z_crc_t const   )3352482300UL,        (z_crc_t const   )2657916926UL,        (z_crc_t const   )2835764735UL, 
            (z_crc_t const   )739252986UL,        (z_crc_t const   )461035771UL,        (z_crc_t const   )1120182009UL,        (z_crc_t const   )1974361336UL, 
            (z_crc_t const   )1223229683UL,        (z_crc_t const   )2139341554UL,        (z_crc_t const   )641565936UL,        (z_crc_t const   )290932465UL, 
            (z_crc_t const   )2487290356UL,        (z_crc_t const   )2737556469UL,        (z_crc_t const   )4204105207UL,        (z_crc_t const   )3456061430UL, 
            (z_crc_t const   )1616738521UL,        (z_crc_t const   )1463270104UL,        (z_crc_t const   )243924186UL,        (z_crc_t const   )971194075UL, 
            (z_crc_t const   )3170202078UL,        (z_crc_t const   )2342499295UL,        (z_crc_t const   )3525440989UL,        (z_crc_t const   )3846911964UL, 
            (z_crc_t const   )3624692695UL,        (z_crc_t const   )4016482774UL,        (z_crc_t const   )3067670484UL,        (z_crc_t const   )2175938005UL, 
            (z_crc_t const   )77882064UL,        (z_crc_t const   )869179601UL,        (z_crc_t const   )1785784019UL,        (z_crc_t const   )1561994450UL, 
            (z_crc_t const   )285105861UL,        (z_crc_t const   )664050884UL,        (z_crc_t const   )2116737734UL,        (z_crc_t const   )1228937415UL, 
            (z_crc_t const   )3428210626UL,        (z_crc_t const   )4215051715UL,        (z_crc_t const   )2726482881UL,        (z_crc_t const   )2515014080UL, 
            (z_crc_t const   )2830061003UL,        (z_crc_t const   )2680524746UL,        (z_crc_t const   )3330001352UL,        (z_crc_t const   )4044426185UL, 
            (z_crc_t const   )1946633420UL,        (z_crc_t const   )1131251405UL,        (z_crc_t const   )450085071UL,        (z_crc_t const   )767099598UL, 
            (z_crc_t const   )1083617169UL,        (z_crc_t const   )2013031824UL,        (z_crc_t const   )776088466UL,        (z_crc_t const   )422111635UL, 
            (z_crc_t const   )2621351574UL,        (z_crc_t const   )2874434711UL,        (z_crc_t const   )4075430549UL,        (z_crc_t const   )3313557652UL, 
            (z_crc_t const   )4173839519UL,        (z_crc_t const   )3484253854UL,        (z_crc_t const   )2517842076UL,        (z_crc_t const   )2709125789UL, 
            (z_crc_t const   )611300760UL,        (z_crc_t const   )319125401UL,        (z_crc_t const   )1253781915UL,        (z_crc_t const   )2110911386UL, 
            (z_crc_t const   )808814989UL,        (z_crc_t const   )123685772UL,        (z_crc_t const   )1591807374UL,        (z_crc_t const   )1770770319UL, 
            (z_crc_t const   )3969745034UL,        (z_crc_t const   )3690414731UL,        (z_crc_t const   )2185823369UL,        (z_crc_t const   )3039020680UL, 
            (z_crc_t const   )2288294531UL,        (z_crc_t const   )3205388418UL,        (z_crc_t const   )3870301824UL,        (z_crc_t const   )3520781441UL, 
            (z_crc_t const   )1422693252UL,        (z_crc_t const   )1671844229UL,        (z_crc_t const   )974657415UL,        (z_crc_t const   )225629574UL, 
            (z_crc_t const   )2698044073UL,        (z_crc_t const   )2545557672UL,        (z_crc_t const   )3456394922UL,        (z_crc_t const   )4184777899UL, 
            (z_crc_t const   )2088299438UL,        (z_crc_t const   )1259481519UL,        (z_crc_t const   )313290669UL,        (z_crc_t const   )633777580UL, 
            (z_crc_t const   )411169191UL,        (z_crc_t const   )803943334UL,        (z_crc_t const   )1985312164UL,        (z_crc_t const   )1094694821UL, 
            (z_crc_t const   )3291084960UL,        (z_crc_t const   )4081269409UL,        (z_crc_t const   )2868739235UL,        (z_crc_t const   )2643967650UL, 
            (z_crc_t const   )3497247925UL,        (z_crc_t const   )3877177012UL,        (z_crc_t const   )3198632118UL,        (z_crc_t const   )2311946935UL, 
            (z_crc_t const   )215731634UL,        (z_crc_t const   )1001459635UL,        (z_crc_t const   )1645169073UL,        (z_crc_t const   )1432718256UL, 
            (z_crc_t const   )1747113915UL,        (z_crc_t const   )1598559674UL,        (z_crc_t const   )116806584UL,        (z_crc_t const   )832344505UL, 
            (z_crc_t const   )3028999868UL,        (z_crc_t const   )2212502717UL,        (z_crc_t const   )3663616703UL,        (z_crc_t const   )3979647166UL}, 
   {        (z_crc_t const   )0UL,        (z_crc_t const   )1701297336UL,        (z_crc_t const   )2345142698UL,        (z_crc_t const   )4004492562UL, 
            (z_crc_t const   )1469538959UL,        (z_crc_t const   )854646327UL,        (z_crc_t const   )3697240869UL,        (z_crc_t const   )3107510173UL, 
            (z_crc_t const   )4012422341UL,        (z_crc_t const   )2320435325UL,        (z_crc_t const   )1692450159UL,        (z_crc_t const   )25625047UL, 
            (z_crc_t const   )3099579978UL,        (z_crc_t const   )3721947890UL,        (z_crc_t const   )863494112UL,        (z_crc_t const   )1443914584UL, 
            (z_crc_t const   )2673285456UL,        (z_crc_t const   )4197492200UL,        (z_crc_t const   )345968890UL,        (z_crc_t const   )1912122434UL, 
            (z_crc_t const   )3368057823UL,        (z_crc_t const   )2913453927UL,        (z_crc_t const   )1124627061UL,        (z_crc_t const   )644861645UL, 
            (z_crc_t const   )1887415701UL,        (z_crc_t const   )353898797UL,        (z_crc_t const   )4223116351UL,        (z_crc_t const   )2664437895UL, 
            (z_crc_t const   )669568794UL,        (z_crc_t const   )1116697506UL,        (z_crc_t const   )2887829168UL,        (z_crc_t const   )3376904712UL, 
            (z_crc_t const   )1051669152UL,        (z_crc_t const   )1539870232UL,        (z_crc_t const   )3043441418UL,        (z_crc_t const   )3489695666UL, 
            (z_crc_t const   )1765298223UL,        (z_crc_t const   )207613079UL,        (z_crc_t const   )3807402373UL,        (z_crc_t const   )2274878781UL, 
            (z_crc_t const   )3515319909UL,        (z_crc_t const   )3034594013UL,        (z_crc_t const   )1515163599UL,        (z_crc_t const   )1059599223UL, 
            (z_crc_t const   )2249254122UL,        (z_crc_t const   )3816249426UL,        (z_crc_t const   )232320320UL,        (z_crc_t const   )1757368824UL, 
            (z_crc_t const   )2717395952UL,        (z_crc_t const   )3298793288UL,        (z_crc_t const   )707797594UL,        (z_crc_t const   )1331142370UL, 
            (z_crc_t const   )4134488447UL,        (z_crc_t const   )2466837959UL,        (z_crc_t const   )2108113109UL,        (z_crc_t const   )415300717UL, 
            (z_crc_t const   )1322295093UL,        (z_crc_t const   )733422477UL,        (z_crc_t const   )3306722975UL,        (z_crc_t const   )2692688423UL, 
            (z_crc_t const   )424148410UL,        (z_crc_t const   )2082488578UL,        (z_crc_t const   )2458907664UL,        (z_crc_t const   )4159195304UL, 
            (z_crc_t const   )1029182619UL,        (z_crc_t const   )1480566819UL,        (z_crc_t const   )3062897969UL,        (z_crc_t const   )3556221321UL, 
            (z_crc_t const   )1791981076UL,        (z_crc_t const   )262720172UL,        (z_crc_t const   )3775365054UL,        (z_crc_t const   )2220933894UL, 
            (z_crc_t const   )3530596446UL,        (z_crc_t const   )3071745254UL,        (z_crc_t const   )1505274356UL,        (z_crc_t const   )1021252940UL, 
            (z_crc_t const   )2246558417UL,        (z_crc_t const   )3766517353UL,        (z_crc_t const   )238013307UL,        (z_crc_t const   )1799911363UL, 
            (z_crc_t const   )2718895563UL,        (z_crc_t const   )3345527155UL,        (z_crc_t const   )700908641UL,        (z_crc_t const   )1285601497UL, 
            (z_crc_t const   )4120407876UL,        (z_crc_t const   )2432685052UL,        (z_crc_t const   )2119198446UL,        (z_crc_t const   )456645206UL, 
            (z_crc_t const   )1294448910UL,        (z_crc_t const   )675284406UL,        (z_crc_t const   )3337597092UL,        (z_crc_t const   )2743602204UL, 
            (z_crc_t const   )447798145UL,        (z_crc_t const   )2144823097UL,        (z_crc_t const   )2440614443UL,        (z_crc_t const   )4095700627UL, 
            (z_crc_t const   )66528827UL,        (z_crc_t const   )1720752771UL,        (z_crc_t const   )2285842321UL,        (z_crc_t const   )3982005033UL, 
            (z_crc_t const   )1415595188UL,        (z_crc_t const   )822605836UL,        (z_crc_t const   )3752348958UL,        (z_crc_t const   )3134189990UL, 
            (z_crc_t const   )3974075134UL,        (z_crc_t const   )2310549062UL,        (z_crc_t const   )1729600340UL,        (z_crc_t const   )40904684UL, 
            (z_crc_t const   )3142119537UL,        (z_crc_t const   )3727641801UL,        (z_crc_t const   )813758939UL,        (z_crc_t const   )1441219939UL, 
            (z_crc_t const   )2627747691UL,        (z_crc_t const   )4190602195UL,        (z_crc_t const   )392705729UL,        (z_crc_t const   )1913621113UL, 
            (z_crc_t const   )3409403364UL,        (z_crc_t const   )2924536156UL,        (z_crc_t const   )1090475086UL,        (z_crc_t const   )630778102UL, 
            (z_crc_t const   )1938328494UL,        (z_crc_t const   )384775958UL,        (z_crc_t const   )4164977156UL,        (z_crc_t const   )2636594876UL, 
            (z_crc_t const   )606071073UL,        (z_crc_t const   )1098405273UL,        (z_crc_t const   )2950160523UL,        (z_crc_t const   )3400555571UL, 
            (z_crc_t const   )1001806317UL,        (z_crc_t const   )1590814037UL,        (z_crc_t const   )2961068103UL,        (z_crc_t const   )3575246079UL, 
            (z_crc_t const   )1814117218UL,        (z_crc_t const   )155617242UL,        (z_crc_t const   )3890819784UL,        (z_crc_t const   )2190380656UL, 
            (z_crc_t const   )3567185192UL,        (z_crc_t const   )2985906576UL,        (z_crc_t const   )1599530114UL,        (z_crc_t const   )976312378UL, 
            (z_crc_t const   )2198441895UL,        (z_crc_t const   )3865981727UL,        (z_crc_t const   )146900493UL,        (z_crc_t const   )1839610549UL, 
            (z_crc_t const   )2766225597UL,        (z_crc_t const   )3246849029UL,        (z_crc_t const   )791234839UL,        (z_crc_t const   )1246688687UL, 
            (z_crc_t const   )4084605490UL,        (z_crc_t const   )2517737098UL,        (z_crc_t const   )2025728920UL,        (z_crc_t const   )500799264UL, 
            (z_crc_t const   )1271526520UL,        (z_crc_t const   )783173824UL,        (z_crc_t const   )3221355986UL,        (z_crc_t const   )2774942058UL, 
            (z_crc_t const   )475961079UL,        (z_crc_t const   )2033789519UL,        (z_crc_t const   )2543230813UL,        (z_crc_t const   )4075889637UL, 
            (z_crc_t const   )85551949UL,        (z_crc_t const   )1618925557UL,        (z_crc_t const   )2396087015UL,        (z_crc_t const   )3954630239UL, 
            (z_crc_t const   )1385040322UL,        (z_crc_t const   )938063226UL,        (z_crc_t const   )3645243496UL,        (z_crc_t const   )3156327632UL, 
            (z_crc_t const   )3929137032UL,        (z_crc_t const   )2404803376UL,        (z_crc_t const   )1643763234UL,        (z_crc_t const   )77490842UL, 
            (z_crc_t const   )3181821191UL,        (z_crc_t const   )3636527551UL,        (z_crc_t const   )913224877UL,        (z_crc_t const   )1393100821UL, 
            (z_crc_t const   )2588832285UL,        (z_crc_t const   )4280929957UL,        (z_crc_t const   )294026167UL,        (z_crc_t const   )1960953615UL, 
            (z_crc_t const   )3453554834UL,        (z_crc_t const   )2831068202UL,        (z_crc_t const   )1175525688UL,        (z_crc_t const   )594978176UL, 
            (z_crc_t const   )1969669848UL,        (z_crc_t const   )268532320UL,        (z_crc_t const   )4272869234UL,        (z_crc_t const   )2613670858UL, 
            (z_crc_t const   )586261591UL,        (z_crc_t const   )1201019119UL,        (z_crc_t const   )2839129597UL,        (z_crc_t const   )3428716869UL, 
            (z_crc_t const   )116280694UL,        (z_crc_t const   )1669984718UL,        (z_crc_t const   )2368095452UL,        (z_crc_t const   )3896637540UL, 
            (z_crc_t const   )1366896633UL,        (z_crc_t const   )874419009UL,        (z_crc_t const   )3669042771UL,        (z_crc_t const   )3218512619UL, 
            (z_crc_t const   )3922131379UL,        (z_crc_t const   )2359379211UL,        (z_crc_t const   )1645146137UL,        (z_crc_t const   )124341409UL, 
            (z_crc_t const   )3193019196UL,        (z_crc_t const   )3677759364UL,        (z_crc_t const   )899256982UL,        (z_crc_t const   )1358835246UL, 
            (z_crc_t const   )2579059750UL,        (z_crc_t const   )4242466974UL,        (z_crc_t const   )309419404UL,        (z_crc_t const   )1997988148UL, 
            (z_crc_t const   )3459135145UL,        (z_crc_t const   )2873723409UL,        (z_crc_t const   )1172717315UL,        (z_crc_t const   )545358779UL, 
            (z_crc_t const   )1989271779UL,        (z_crc_t const   )334912603UL,        (z_crc_t const   )4250528073UL,        (z_crc_t const   )2554222065UL, 
            (z_crc_t const   )554074732UL,        (z_crc_t const   )1147223764UL,        (z_crc_t const   )2865662918UL,        (z_crc_t const   )3483973502UL, 
            (z_crc_t const   )943816662UL,        (z_crc_t const   )1562821486UL,        (z_crc_t const   )3012130428UL,        (z_crc_t const   )3605973700UL, 
            (z_crc_t const   )1876303193UL,        (z_crc_t const   )179413473UL,        (z_crc_t const   )3827176691UL,        (z_crc_t const   )2172233803UL, 
            (z_crc_t const   )3614034707UL,        (z_crc_t const   )2987292587UL,        (z_crc_t const   )1554105017UL,        (z_crc_t const   )969309697UL, 
            (z_crc_t const   )2164173212UL,        (z_crc_t const   )3852014884UL,        (z_crc_t const   )188129334UL,        (z_crc_t const   )1850809486UL, 
            (z_crc_t const   )2803263110UL,        (z_crc_t const   )3262241342UL,        (z_crc_t const   )752774956UL,        (z_crc_t const   )1236915092UL, 
            (z_crc_t const   )4034987017UL,        (z_crc_t const   )2514925745UL,        (z_crc_t const   )2068385187UL,        (z_crc_t const   )506376475UL, 
            (z_crc_t const   )1212076611UL,        (z_crc_t const   )760835835UL,        (z_crc_t const   )3287735273UL,        (z_crc_t const   )2794547025UL, 
            (z_crc_t const   )531214540UL,        (z_crc_t const   )2060323956UL,        (z_crc_t const   )2489432422UL,        (z_crc_t const   )4043703774UL}};
#line 188 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
z_crc_t const   *get_crc_table(void) 
{ 


  {
#line 194
  return ((z_crc_t const   *)(crc_table));
}
}
#line 202 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
unsigned long crc32_z(unsigned long crc , unsigned char const   *buf , z_size_t len ) 
{ 
  z_crc_t endian ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 207
  if ((unsigned long )buf == (unsigned long )((unsigned char const   *)0)) {
#line 207
    return (0UL);
  }
#line 215
  if (sizeof(void *) == sizeof(ptrdiff_t )) {
#line 218
    endian = (z_crc_t )1;
#line 219
    if (*((unsigned char *)(& endian))) {
      {
#line 220
      tmp = crc32_little(crc, buf, len);
      }
#line 220
      return (tmp);
    } else {
      {
#line 222
      tmp___0 = crc32_big(crc, buf, len);
      }
#line 222
      return (tmp___0);
    }
  }
#line 225
  crc ^= 4294967295UL;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (len >= 8UL)) {
#line 226
      goto while_break;
    }
#line 227
    tmp___1 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___1) & 255] ^ (crc >> 8);
#line 227
    tmp___2 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___2) & 255] ^ (crc >> 8);
#line 227
    tmp___3 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___3) & 255] ^ (crc >> 8);
#line 227
    tmp___4 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___4) & 255] ^ (crc >> 8);
#line 227
    tmp___5 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___5) & 255] ^ (crc >> 8);
#line 227
    tmp___6 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___6) & 255] ^ (crc >> 8);
#line 227
    tmp___7 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___7) & 255] ^ (crc >> 8);
#line 227
    tmp___8 = buf;
#line 227
    buf ++;
#line 227
    crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___8) & 255] ^ (crc >> 8);
#line 228
    len -= 8UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if (len) {
    {
#line 230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 231
      tmp___9 = buf;
#line 231
      buf ++;
#line 231
      crc = (unsigned long )crc_table[0][((int )crc ^ (int )*tmp___9) & 255] ^ (crc >> 8);
#line 230
      len --;
#line 230
      if (! len) {
#line 230
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 233
  return (crc ^ 4294967295UL);
}
}
#line 237 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
unsigned long crc32(unsigned long crc , unsigned char const   *buf , uInt len ) 
{ 
  unsigned long tmp ;

  {
  {
#line 242
  tmp = crc32_z(crc, buf, (z_size_t )len);
  }
#line 242
  return (tmp);
}
}
#line 266 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
static unsigned long crc32_little(unsigned long crc , unsigned char const   *buf ,
                                  z_size_t len ) 
{ 
  register z_crc_t c ;
  register z_crc_t const   *buf4 ;
  unsigned char const   *tmp ;
  z_crc_t const   *tmp___0 ;
  z_crc_t const   *tmp___1 ;
  z_crc_t const   *tmp___2 ;
  z_crc_t const   *tmp___3 ;
  z_crc_t const   *tmp___4 ;
  z_crc_t const   *tmp___5 ;
  z_crc_t const   *tmp___6 ;
  z_crc_t const   *tmp___7 ;
  z_crc_t const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 274
  c = (z_crc_t )crc;
#line 275
  c = ~ c;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (len) {
#line 276
      if (! ((ptrdiff_t )buf & 3L)) {
#line 276
        goto while_break;
      }
    } else {
#line 276
      goto while_break;
    }
#line 277
    tmp = buf;
#line 277
    buf ++;
#line 277
    c = (z_crc_t )(crc_table[0][(c ^ (unsigned int )*tmp) & 255U] ^ (unsigned int const   )(c >> 8));
#line 278
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  buf4 = (z_crc_t const   *)((void const   *)buf);
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (len >= 32UL)) {
#line 282
      goto while_break___0;
    }
#line 283
    tmp___0 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___0;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 283
    tmp___1 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___1;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 283
    tmp___2 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___2;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 283
    tmp___3 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___3;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 283
    tmp___4 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___4;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 283
    tmp___5 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___5;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 283
    tmp___6 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___6;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 283
    tmp___7 = buf4;
#line 283
    buf4 ++;
#line 283
    c ^= (unsigned int )*tmp___7;
#line 283
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 284
    len -= 32UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 286
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 286
    if (! (len >= 4UL)) {
#line 286
      goto while_break___1;
    }
#line 287
    tmp___8 = buf4;
#line 287
    buf4 ++;
#line 287
    c ^= (unsigned int )*tmp___8;
#line 287
    c = (z_crc_t )(((crc_table[3][c & 255U] ^ crc_table[2][(c >> 8) & 255U]) ^ crc_table[1][(c >> 16) & 255U]) ^ crc_table[0][c >> 24]);
#line 288
    len -= 4UL;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 290
  buf = (unsigned char const   *)buf4;
#line 292
  if (len) {
    {
#line 292
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 293
      tmp___9 = buf;
#line 293
      buf ++;
#line 293
      c = (z_crc_t )(crc_table[0][(c ^ (unsigned int )*tmp___9) & 255U] ^ (unsigned int const   )(c >> 8));
#line 292
      len --;
#line 292
      if (! len) {
#line 292
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 295
  c = ~ c;
#line 296
  return ((unsigned long )c);
}
}
#line 306 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
static unsigned long crc32_big(unsigned long crc , unsigned char const   *buf , z_size_t len ) 
{ 
  register z_crc_t c ;
  register z_crc_t const   *buf4 ;
  unsigned char const   *tmp ;
  z_crc_t const   *tmp___0 ;
  z_crc_t const   *tmp___1 ;
  z_crc_t const   *tmp___2 ;
  z_crc_t const   *tmp___3 ;
  z_crc_t const   *tmp___4 ;
  z_crc_t const   *tmp___5 ;
  z_crc_t const   *tmp___6 ;
  z_crc_t const   *tmp___7 ;
  z_crc_t const   *tmp___8 ;
  unsigned char const   *tmp___9 ;

  {
#line 314
  c = (((((z_crc_t )crc >> 24) & 255U) + (((z_crc_t )crc >> 8) & 65280U)) + (((z_crc_t )crc & 65280U) << 8)) + (((z_crc_t )crc & 255U) << 24);
#line 315
  c = ~ c;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (len) {
#line 316
      if (! ((ptrdiff_t )buf & 3L)) {
#line 316
        goto while_break;
      }
    } else {
#line 316
      goto while_break;
    }
#line 317
    tmp = buf;
#line 317
    buf ++;
#line 317
    c = (z_crc_t )(crc_table[4][(c >> 24) ^ (unsigned int )*tmp] ^ (unsigned int const   )(c << 8));
#line 318
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  buf4 = (z_crc_t const   *)((void const   *)buf);
  {
#line 322
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 322
    if (! (len >= 32UL)) {
#line 322
      goto while_break___0;
    }
#line 323
    tmp___0 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___0;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 323
    tmp___1 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___1;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 323
    tmp___2 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___2;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 323
    tmp___3 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___3;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 323
    tmp___4 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___4;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 323
    tmp___5 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___5;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 323
    tmp___6 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___6;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 323
    tmp___7 = buf4;
#line 323
    buf4 ++;
#line 323
    c ^= (unsigned int )*tmp___7;
#line 323
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 324
    len -= 32UL;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 326
    if (! (len >= 4UL)) {
#line 326
      goto while_break___1;
    }
#line 327
    tmp___8 = buf4;
#line 327
    buf4 ++;
#line 327
    c ^= (unsigned int )*tmp___8;
#line 327
    c = (z_crc_t )(((crc_table[4][c & 255U] ^ crc_table[5][(c >> 8) & 255U]) ^ crc_table[6][(c >> 16) & 255U]) ^ crc_table[7][c >> 24]);
#line 328
    len -= 4UL;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  buf = (unsigned char const   *)buf4;
#line 332
  if (len) {
    {
#line 332
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 333
      tmp___9 = buf;
#line 333
      buf ++;
#line 333
      c = (z_crc_t )(crc_table[4][(c >> 24) ^ (unsigned int )*tmp___9] ^ (unsigned int const   )(c << 8));
#line 332
      len --;
#line 332
      if (! len) {
#line 332
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 335
  c = ~ c;
#line 336
  return ((unsigned long )(((((c >> 24) & 255U) + ((c >> 8) & 65280U)) + ((c & 65280U) << 8)) + ((c & 255U) << 24)));
}
}
#line 344 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
static unsigned long gf2_matrix_times(unsigned long *mat , unsigned long vec ) 
{ 
  unsigned long sum ;

  {
#line 350
  sum = 0UL;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! vec) {
#line 351
      goto while_break;
    }
#line 352
    if (vec & 1UL) {
#line 353
      sum ^= *mat;
    }
#line 354
    vec >>= 1;
#line 355
    mat ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return (sum);
}
}
#line 361 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
static void gf2_matrix_square(unsigned long *square , unsigned long *mat ) 
{ 
  int n ;

  {
#line 367
  n = 0;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (n < 32)) {
#line 367
      goto while_break;
    }
    {
#line 368
    *(square + n) = gf2_matrix_times(mat, *(mat + n));
#line 367
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  return;
}
}
#line 372 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
static uLong crc32_combine_(uLong crc1 , uLong crc2 , off64_t len2 ) 
{ 
  int n ;
  unsigned long row ;
  unsigned long even[32] ;
  unsigned long odd[32] ;

  {
#line 383
  if (len2 <= 0L) {
#line 384
    return (crc1);
  }
#line 387
  odd[0] = 3988292384UL;
#line 388
  row = 1UL;
#line 389
  n = 1;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (n < 32)) {
#line 389
      goto while_break;
    }
#line 390
    odd[n] = row;
#line 391
    row <<= 1;
#line 389
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 395
  gf2_matrix_square(even, odd);
#line 398
  gf2_matrix_square(odd, even);
  }
  {
#line 402
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 404
    gf2_matrix_square(even, odd);
    }
#line 405
    if (len2 & 1L) {
      {
#line 406
      crc1 = gf2_matrix_times(even, crc1);
      }
    }
#line 407
    len2 >>= 1;
#line 410
    if (len2 == 0L) {
#line 411
      goto while_break___0;
    }
    {
#line 414
    gf2_matrix_square(odd, even);
    }
#line 415
    if (len2 & 1L) {
      {
#line 416
      crc1 = gf2_matrix_times(odd, crc1);
      }
    }
#line 417
    len2 >>= 1;
#line 402
    if (! (len2 != 0L)) {
#line 402
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 423
  crc1 ^= crc2;
#line 424
  return (crc1);
}
}
#line 428 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
uLong crc32_combine(uLong crc1 , uLong crc2 , off_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 433
  tmp = crc32_combine_(crc1, crc2, len2);
  }
#line 433
  return (tmp);
}
}
#line 436 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/crc32.c"
uLong crc32_combine64(uLong crc1 , uLong crc2 , off64_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 441
  tmp = crc32_combine_(crc1, crc2, len2);
  }
#line 441
  return (tmp);
}
}
#line 1245 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) ;
#line 1260
int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
              int level ) ;
#line 1276
uLong compressBound(uLong sourceLen ) ;
#line 22 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/compress.c"
int compress2(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ,
              int level ) 
{ 
  z_stream stream ;
  int err ;
  uInt max ;
  uLong left ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 31
  max = (uInt )-1;
#line 34
  left = *destLen;
#line 35
  *destLen = (uLongf )0;
#line 37
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
#line 38
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
#line 39
  stream.opaque = (voidpf )0;
#line 41
  err = deflateInit_(& stream, level, "1.2.11-optipng", (int )sizeof(z_stream ));
  }
#line 42
  if (err != 0) {
#line 42
    return (err);
  }
#line 44
  stream.next_out = dest;
#line 45
  stream.avail_out = (uInt )0;
#line 46
  stream.next_in = (Bytef *)source;
#line 47
  stream.avail_in = (uInt )0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (stream.avail_out == 0U) {
#line 51
      if (left > (uLong )max) {
#line 51
        stream.avail_out = max;
      } else {
#line 51
        stream.avail_out = (uInt )left;
      }
#line 52
      left -= (uLong )stream.avail_out;
    }
#line 54
    if (stream.avail_in == 0U) {
#line 55
      if (sourceLen > (uLong )max) {
#line 55
        stream.avail_in = max;
      } else {
#line 55
        stream.avail_in = (uInt )sourceLen;
      }
#line 56
      sourceLen -= (uLong )stream.avail_in;
    }
#line 58
    if (sourceLen) {
#line 58
      tmp = 0;
    } else {
#line 58
      tmp = 4;
    }
    {
#line 58
    err = deflate(& stream, tmp);
    }
#line 49
    if (! (err == 0)) {
#line 49
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 61
  *destLen = stream.total_out;
#line 62
  deflateEnd(& stream);
  }
#line 63
  if (err == 1) {
#line 63
    tmp___0 = 0;
  } else {
#line 63
    tmp___0 = err;
  }
#line 63
  return (tmp___0);
}
}
#line 68 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/compress.c"
int compress(Bytef *dest , uLongf *destLen , Bytef const   *source , uLong sourceLen ) 
{ 
  int tmp ;

  {
  {
#line 74
  tmp = compress2(dest, destLen, source, sourceLen, -1);
  }
#line 74
  return (tmp);
}
}
#line 81 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/compress.c"
uLong compressBound(uLong sourceLen ) 
{ 


  {
#line 84
  return ((((sourceLen + (sourceLen >> 12)) + (sourceLen >> 14)) + (sourceLen >> 25)) + 13UL);
}
}
#line 1725 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/zlib.h"
uLong adler32_z(uLong adler , Bytef const   *buf , z_size_t len ) ;
#line 1861
uLong adler32_combine64(uLong adler1 , uLong adler2 , off64_t len2 ) ;
#line 1894
uLong adler32_combine(uLong adler1 , uLong adler2 , off_t len2 ) ;
#line 10 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/adler32.c"
static uLong adler32_combine_(uLong adler1 , uLong adler2 , off64_t len2 ) ;
#line 63 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/adler32.c"
uLong adler32_z(uLong adler , Bytef const   *buf , z_size_t len ) 
{ 
  unsigned long sum2 ;
  unsigned int n ;
  Bytef const   *tmp ;
  z_size_t tmp___0 ;
  Bytef const   *tmp___1 ;
  z_size_t tmp___2 ;

  {
#line 72
  sum2 = (adler >> 16) & 65535UL;
#line 73
  adler &= 65535UL;
#line 76
  if (len == 1UL) {
#line 77
    adler += (uLong )*(buf + 0);
#line 78
    if (adler >= 65521UL) {
#line 79
      adler -= 65521UL;
    }
#line 80
    sum2 += adler;
#line 81
    if (sum2 >= 65521UL) {
#line 82
      sum2 -= 65521UL;
    }
#line 83
    return (adler | (sum2 << 16));
  }
#line 87
  if ((unsigned long )buf == (unsigned long )((Bytef const   *)0)) {
#line 88
    return ((uLong )1L);
  }
#line 91
  if (len < 16UL) {
    {
#line 92
    while (1) {
      while_continue: /* CIL Label */ ;
#line 92
      tmp___0 = len;
#line 92
      len --;
#line 92
      if (! tmp___0) {
#line 92
        goto while_break;
      }
#line 93
      tmp = buf;
#line 93
      buf ++;
#line 93
      adler += (uLong )*tmp;
#line 94
      sum2 += adler;
    }
    while_break: /* CIL Label */ ;
    }
#line 96
    if (adler >= 65521UL) {
#line 97
      adler -= 65521UL;
    }
#line 98
    sum2 %= 65521UL;
#line 99
    return (adler | (sum2 << 16));
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (len >= 5552UL)) {
#line 103
      goto while_break___0;
    }
#line 104
    len -= 5552UL;
#line 105
    n = 347U;
    {
#line 106
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 107
      adler += (uLong )*(buf + 0);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 1);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 2);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 3);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 4);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 5);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 6);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 7);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 8);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 9);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 10);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 11);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 12);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 13);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 14);
#line 107
      sum2 += adler;
#line 107
      adler += (uLong )*(buf + 15);
#line 107
      sum2 += adler;
#line 108
      buf += 16;
#line 106
      n --;
#line 106
      if (! n) {
#line 106
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 110
    adler %= 65521UL;
#line 111
    sum2 %= 65521UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  if (len) {
    {
#line 116
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 116
      if (! (len >= 16UL)) {
#line 116
        goto while_break___2;
      }
#line 117
      len -= 16UL;
#line 118
      adler += (uLong )*(buf + 0);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 1);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 2);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 3);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 4);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 5);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 6);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 7);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 8);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 9);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 10);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 11);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 12);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 13);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 14);
#line 118
      sum2 += adler;
#line 118
      adler += (uLong )*(buf + 15);
#line 118
      sum2 += adler;
#line 119
      buf += 16;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 121
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 121
      tmp___2 = len;
#line 121
      len --;
#line 121
      if (! tmp___2) {
#line 121
        goto while_break___3;
      }
#line 122
      tmp___1 = buf;
#line 122
      buf ++;
#line 122
      adler += (uLong )*tmp___1;
#line 123
      sum2 += adler;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 125
    adler %= 65521UL;
#line 126
    sum2 %= 65521UL;
  }
#line 130
  return (adler | (sum2 << 16));
}
}
#line 134 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/adler32.c"
uLong adler32(uLong adler , Bytef const   *buf , uInt len ) 
{ 
  uLong tmp ;

  {
  {
#line 139
  tmp = adler32_z(adler, buf, (z_size_t )len);
  }
#line 139
  return (tmp);
}
}
#line 143 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/adler32.c"
static uLong adler32_combine_(uLong adler1 , uLong adler2 , off64_t len2 ) 
{ 
  unsigned long sum1 ;
  unsigned long sum2 ;
  unsigned int rem ;

  {
#line 153
  if (len2 < 0L) {
#line 154
    return (4294967295UL);
  }
#line 157
  len2 %= 65521L;
#line 158
  rem = (unsigned int )len2;
#line 159
  sum1 = adler1 & 65535UL;
#line 160
  sum2 = (unsigned long )rem * sum1;
#line 161
  sum2 %= 65521UL;
#line 162
  sum1 += ((adler2 & 65535UL) + 65521UL) - 1UL;
#line 163
  sum2 += ((((adler1 >> 16) & 65535UL) + ((adler2 >> 16) & 65535UL)) + 65521UL) - (unsigned long )rem;
#line 164
  if (sum1 >= 65521UL) {
#line 164
    sum1 -= 65521UL;
  }
#line 165
  if (sum1 >= 65521UL) {
#line 165
    sum1 -= 65521UL;
  }
#line 166
  if (sum2 >= 65521UL << 1) {
#line 166
    sum2 -= 65521UL << 1;
  }
#line 167
  if (sum2 >= 65521UL) {
#line 167
    sum2 -= 65521UL;
  }
#line 168
  return (sum1 | (sum2 << 16));
}
}
#line 172 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/adler32.c"
uLong adler32_combine(uLong adler1 , uLong adler2 , off_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 177
  tmp = adler32_combine_(adler1, adler2, len2);
  }
#line 177
  return (tmp);
}
}
#line 180 "/home/khheo/project/benchmark/optipng-0.7.7/src/zlib/adler32.c"
uLong adler32_combine64(uLong adler1 , uLong adler2 , off64_t len2 ) 
{ 
  uLong tmp ;

  {
  {
#line 185
  tmp = adler32_combine_(adler1, adler2, len2);
  }
#line 185
  return (tmp);
}
}
#line 1017 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
void png_write_sig(png_structrp png_ptr ) ;
#line 1020
void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_string , png_const_bytep data ,
                     png_size_t length ) ;
#line 1024
void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_string , png_uint_32 length ) ;
#line 1028
void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) ;
#line 1032
void png_write_chunk_end(png_structrp png_ptr ) ;
#line 1391
void png_write_flush(png_structrp png_ptr ) ;
#line 1747
png_voidp __attribute__((__malloc__))  png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1750
png_voidp __attribute__((__malloc__))  png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) ;
#line 1758
void png_free(png_const_structrp png_ptr , png_voidp ptr ) ;
#line 1805
 __attribute__((__noreturn__)) void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1821
void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 2586
void png_save_uint_32(png_bytep buf , png_uint_32 i ) ;
#line 2597
void png_save_uint_16(png_bytep buf , unsigned int i ) ;
#line 965 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
void png_zstream_error(png_structrp png_ptr , int ret ) ;
#line 972
void png_free_buffer_list(png_structrp png_ptr , png_compression_bufferp *listp ) ;
#line 1067
void png_reset_crc(png_structrp png_ptr ) ;
#line 1070
void png_write_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) ;
#line 1100
void png_calculate_crc(png_structrp png_ptr , png_const_bytep ptr , png_size_t length ) ;
#line 1112
void png_write_IHDR(png_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type ) ;
#line 1116
void png_write_PLTE(png_structrp png_ptr , png_const_colorp palette , png_uint_32 num_pal ) ;
#line 1119
void png_compress_IDAT(png_structrp png_ptr , png_const_bytep input , png_alloc_size_t input_len ,
                       int flush ) ;
#line 1123
void png_write_IEND(png_structrp png_ptr ) ;
#line 1131
void png_write_sBIT(png_structrp png_ptr , png_const_color_8p sbit , int color_type ) ;
#line 1166
void png_write_tRNS(png_structrp png_ptr , png_const_bytep trans_alpha , png_const_color_16p tran ,
                    int num_trans , int color_type ) ;
#line 1172
void png_write_bKGD(png_structrp png_ptr , png_const_color_16p back , int color_type ) ;
#line 1177
void png_write_hIST(png_structrp png_ptr , png_const_uint_16p hist , int num_hist ) ;
#line 1231
void png_write_finish_row(png_structrp png_ptr ) ;
#line 1235
void png_write_start_row(png_structrp png_ptr ) ;
#line 1282
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass ) ;
#line 1359
void png_write_find_filter(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1723
size_t png_safecat(png_charp buffer___0 , size_t bufsize , size_t pos , png_const_charp string ) ;
#line 1806
void png_app_warning(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 23 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_save_uint_32(png_bytep buf , png_uint_32 i ) 
{ 


  {
#line 26
  *(buf + 0) = (png_byte )((i >> 24) & 255U);
#line 27
  *(buf + 1) = (png_byte )((i >> 16) & 255U);
#line 28
  *(buf + 2) = (png_byte )((i >> 8) & 255U);
#line 29
  *(buf + 3) = (png_byte )(i & 255U);
#line 30
  return;
}
}
#line 36 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_save_uint_16(png_bytep buf , unsigned int i ) 
{ 


  {
#line 39
  *(buf + 0) = (png_byte )((i >> 8) & 255U);
#line 40
  *(buf + 1) = (png_byte )(i & 255U);
#line 41
  return;
}
}
#line 50 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_sig(png_structrp png_ptr ) 
{ 
  png_byte png_signature[8] ;

  {
  {
#line 53
  png_signature[0] = (png_byte )137;
#line 53
  png_signature[1] = (png_byte )80;
#line 53
  png_signature[2] = (png_byte )78;
#line 53
  png_signature[3] = (png_byte )71;
#line 53
  png_signature[4] = (png_byte )13;
#line 53
  png_signature[5] = (png_byte )10;
#line 53
  png_signature[6] = (png_byte )26;
#line 53
  png_signature[7] = (png_byte )10;
#line 57
  png_ptr->io_state = (png_uint_32 )18;
#line 61
  png_write_data(png_ptr, (png_const_bytep )(& png_signature[png_ptr->sig_bytes]),
                 (png_size_t )(8 - (int )png_ptr->sig_bytes));
  }
#line 64
  if ((int )png_ptr->sig_bytes < 3) {
#line 65
    png_ptr->mode |= 4096U;
  }
#line 66
  return;
}
}
#line 72 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void png_write_chunk_header(png_structrp png_ptr , png_uint_32 chunk_name ,
                                   png_uint_32 length ) 
{ 
  png_byte buf[8] ;

  {
#line 83
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 84
    return;
  }
  {
#line 90
  png_ptr->io_state = (png_uint_32 )34;
#line 94
  png_save_uint_32(buf, length);
#line 95
  png_save_uint_32(buf + 4, chunk_name);
#line 96
  png_write_data(png_ptr, (png_const_bytep )(buf), (png_size_t )8);
#line 99
  png_ptr->chunk_name = chunk_name;
#line 102
  png_reset_crc(png_ptr);
#line 104
  png_calculate_crc(png_ptr, (png_const_bytep )(buf + 4), (png_size_t )4);
#line 110
  png_ptr->io_state = (png_uint_32 )66;
  }
#line 112
  return;
}
}
#line 114 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_chunk_start(png_structrp png_ptr , png_const_bytep chunk_string , png_uint_32 length ) 
{ 


  {
  {
#line 118
  png_write_chunk_header(png_ptr, ((((png_uint_32 )(255 & (int )*(chunk_string + 0)) << 24) | ((png_uint_32 )(255 & (int )*(chunk_string + 1)) << 16)) | ((png_uint_32 )(255 & (int )*(chunk_string + 2)) << 8)) | (png_uint_32 )(255 & (int )*(chunk_string + 3)),
                         length);
  }
#line 119
  return;
}
}
#line 126 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_chunk_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) 
{ 


  {
#line 131
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 132
    return;
  }
#line 134
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 134
    if (length > 0UL) {
      {
#line 136
      png_write_data(png_ptr, data, length);
#line 141
      png_calculate_crc(png_ptr, data, length);
      }
    }
  }
#line 143
  return;
}
}
#line 146 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_chunk_end(png_structrp png_ptr ) 
{ 
  png_byte buf[4] ;

  {
#line 151
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 151
    return;
  }
  {
#line 157
  png_ptr->io_state = (png_uint_32 )130;
#line 161
  png_save_uint_32(buf, png_ptr->crc);
#line 163
  png_write_data(png_ptr, (png_const_bytep )(buf), (png_size_t )4);
  }
#line 164
  return;
}
}
#line 175 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void png_write_complete_chunk(png_structrp png_ptr , png_uint_32 chunk_name ,
                                     png_const_bytep data , png_size_t length ) 
{ 


  {
#line 179
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 180
    return;
  }
#line 183
  if (length > 2147483647UL) {
    {
#line 184
    png_error((png_const_structrp )png_ptr, "length exceeds PNG maximum");
    }
  }
  {
#line 186
  png_write_chunk_header(png_ptr, chunk_name, (png_uint_32 )length);
#line 187
  png_write_chunk_data(png_ptr, data, length);
#line 188
  png_write_chunk_end(png_ptr);
  }
#line 189
  return;
}
}
#line 192 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_chunk(png_structrp png_ptr , png_const_bytep chunk_string , png_const_bytep data ,
                     png_size_t length ) 
{ 


  {
  {
#line 196
  png_write_complete_chunk(png_ptr, ((((png_uint_32 )(255 & (int )*(chunk_string + 0)) << 24) | ((png_uint_32 )(255 & (int )*(chunk_string + 1)) << 16)) | ((png_uint_32 )(255 & (int )*(chunk_string + 2)) << 8)) | (png_uint_32 )(255 & (int )*(chunk_string + 3)),
                           data, length);
  }
#line 198
  return;
}
}
#line 204 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_alloc_size_t png_image_size(png_structrp png_ptr ) 
{ 
  png_uint_32 h ;
  png_uint_32 w ;
  unsigned int pd ;
  png_alloc_size_t cb_base ;
  int pass ;
  png_uint_32 pw ;
  int tmp ;
  int tmp___0 ;
  png_size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 210
  h = png_ptr->height;
#line 212
  if (png_ptr->rowbytes < 32768UL) {
#line 212
    if (h < 32768U) {
#line 214
      if ((int )png_ptr->interlaced != 0) {
#line 219
        w = png_ptr->width;
#line 220
        pd = (unsigned int )png_ptr->pixel_depth;
#line 224
        cb_base = (png_alloc_size_t )0;
#line 224
        pass = 0;
        {
#line 224
        while (1) {
          while_continue: /* CIL Label */ ;
#line 224
          if (! (pass <= 6)) {
#line 224
            goto while_break;
          }
#line 226
          if (pass > 1) {
#line 226
            tmp = (7 - pass) >> 1;
          } else {
#line 226
            tmp = 3;
          }
#line 226
          if (pass > 1) {
#line 226
            tmp___0 = (7 - pass) >> 1;
          } else {
#line 226
            tmp___0 = 3;
          }
#line 226
          pw = (w + (png_uint_32 )(((1 << tmp) - 1) - (((1 & pass) << (3 - ((pass + 1) >> 1))) & 7))) >> tmp___0;
#line 228
          if (pw > 0U) {
#line 229
            if (pd >= 8U) {
#line 229
              tmp___1 = (png_size_t )pw * ((png_size_t )pd >> 3);
            } else {
#line 229
              tmp___1 = ((png_size_t )pw * (png_size_t )pd + 7UL) >> 3;
            }
#line 229
            if (pass > 2) {
#line 229
              tmp___2 = (8 - pass) >> 1;
            } else {
#line 229
              tmp___2 = 3;
            }
#line 229
            if (pass > 2) {
#line 229
              tmp___3 = (8 - pass) >> 1;
            } else {
#line 229
              tmp___3 = 3;
            }
#line 229
            cb_base += (tmp___1 + 1UL) * (png_size_t )((h + (png_uint_32 )(((1 << tmp___2) - 1) - (((1 & ~ pass) << (3 - (pass >> 1))) & 7))) >> tmp___3);
          }
#line 224
          pass ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 232
        return (cb_base);
      } else {
#line 236
        return ((png_ptr->rowbytes + 1UL) * (png_size_t )h);
      }
    } else {
#line 240
      return ((png_alloc_size_t )4294967295U);
    }
  } else {
#line 240
    return ((png_alloc_size_t )4294967295U);
  }
}
}
#line 250 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void optimize_cmf(png_bytep data , png_alloc_size_t data_size ) 
{ 
  unsigned int z_cmf ;
  unsigned int z_cinfo ;
  unsigned int half_z_window_size ;
  unsigned int tmp ;

  {
#line 256
  if (data_size <= 16384UL) {
#line 258
    z_cmf = (unsigned int )*(data + 0);
#line 260
    if ((z_cmf & 15U) == 8U) {
#line 260
      if ((z_cmf & 240U) <= 112U) {
#line 265
        z_cinfo = z_cmf >> 4;
#line 266
        half_z_window_size = 1U << (z_cinfo + 7U);
#line 268
        if (data_size <= (png_alloc_size_t )half_z_window_size) {
          {
#line 272
          while (1) {
            while_continue: /* CIL Label */ ;
#line 274
            half_z_window_size >>= 1;
#line 275
            z_cinfo --;
#line 272
            if (z_cinfo > 0U) {
#line 272
              if (! (data_size <= (png_alloc_size_t )half_z_window_size)) {
#line 272
                goto while_break;
              }
            } else {
#line 272
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 279
          z_cmf = (z_cmf & 15U) | (z_cinfo << 4);
#line 281
          *(data + 0) = (png_byte )z_cmf;
#line 282
          tmp = (unsigned int )((int )*(data + 1) & 224);
#line 283
          tmp += 31U - ((z_cmf << 8) + tmp) % 31U;
#line 284
          *(data + 1) = (png_byte )tmp;
        }
      }
    }
  }
#line 288
  return;
}
}
#line 292 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static int png_deflate_claim(png_structrp png_ptr , png_uint_32 owner , png_alloc_size_t data_size ) 
{ 
  char msg[64] ;
  int level ;
  int method ;
  int windowBits ;
  int memLevel ;
  int strategy ;
  int ret ;
  unsigned int half_window_size ;
  int tmp ;

  {
#line 296
  if (png_ptr->zowner != 0U) {
    {
#line 301
    msg[0] = (char )((owner >> 24) & 255U);
#line 301
    msg[1] = (char )((owner >> 16) & 255U);
#line 301
    msg[2] = (char )((owner >> 8) & 255U);
#line 301
    msg[3] = (char )(owner & 255U);
#line 302
    msg[4] = (char )':';
#line 303
    msg[5] = (char )' ';
#line 304
    *((msg + 6) + 0) = (char )((png_ptr->zowner >> 24) & 255U);
#line 304
    *((msg + 6) + 1) = (char )((png_ptr->zowner >> 16) & 255U);
#line 304
    *((msg + 6) + 2) = (char )((png_ptr->zowner >> 8) & 255U);
#line 304
    *((msg + 6) + 3) = (char )(png_ptr->zowner & 255U);
#line 309
    png_safecat(msg, sizeof(msg), (size_t )10, " using zstream");
#line 312
    png_warning((png_const_structrp )png_ptr, (png_const_charp )(msg));
    }
#line 315
    if (png_ptr->zowner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 317
      png_ptr->zstream.msg = "in use by IDAT";
#line 318
      return (-2);
    }
#line 321
    png_ptr->zowner = (png_uint_32 )0;
  }
#line 328
  level = png_ptr->zlib_level;
#line 329
  method = png_ptr->zlib_method;
#line 330
  windowBits = png_ptr->zlib_window_bits;
#line 331
  memLevel = png_ptr->zlib_mem_level;
#line 335
  if (owner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 337
    if ((png_ptr->flags & 1U) != 0U) {
#line 338
      strategy = png_ptr->zlib_strategy;
    } else
#line 340
    if ((int )png_ptr->do_filter != 8) {
#line 341
      strategy = 1;
    } else {
#line 344
      strategy = 0;
    }
  } else {
#line 361
    strategy = 0;
  }
#line 372
  if (data_size <= 16384UL) {
#line 379
    half_window_size = 1U << (windowBits - 1);
    {
#line 381
    while (1) {
      while_continue: /* CIL Label */ ;
#line 381
      if (! (data_size + 262UL <= (png_alloc_size_t )half_window_size)) {
#line 381
        goto while_break;
      }
#line 383
      half_window_size >>= 1;
#line 384
      windowBits --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 389
  if ((png_ptr->flags & 2U) != 0U) {
#line 389
    if (png_ptr->zlib_set_level != level) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_method != method) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_window_bits != windowBits) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_mem_level != memLevel) {
#line 389
      goto _L;
    } else
#line 389
    if (png_ptr->zlib_set_strategy != strategy) {
      _L: /* CIL Label */ 
      {
#line 396
      tmp = deflateEnd(& png_ptr->zstream);
      }
#line 396
      if (tmp != 0) {
        {
#line 397
        png_warning((png_const_structrp )png_ptr, "deflateEnd failed (ignored)");
        }
      }
#line 399
      png_ptr->flags &= 4294967293U;
    }
  }
#line 405
  png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 406
  png_ptr->zstream.avail_in = (uInt )0;
#line 407
  png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 408
  png_ptr->zstream.avail_out = (uInt )0;
#line 413
  if ((png_ptr->flags & 2U) != 0U) {
    {
#line 414
    ret = deflateReset(& png_ptr->zstream);
    }
  } else {
    {
#line 418
    ret = deflateInit2_(& png_ptr->zstream, level, method, windowBits, memLevel, strategy,
                        "1.2.11-optipng", (int )sizeof(z_stream ));
    }
#line 421
    if (ret == 0) {
#line 422
      png_ptr->flags |= 2U;
    }
  }
#line 428
  if (ret == 0) {
#line 429
    png_ptr->zowner = owner;
  } else {
    {
#line 432
    png_zstream_error(png_ptr, ret);
    }
  }
#line 434
  return (ret);
}
}
#line 439 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_free_buffer_list(png_structrp png_ptr , png_compression_bufferp *listp ) 
{ 
  png_compression_bufferp list ;
  png_compression_bufferp next ;

  {
#line 442
  list = *listp;
#line 444
  if ((unsigned long )list != (unsigned long )((void *)0)) {
#line 446
    *listp = (png_compression_bufferp )((void *)0);
    {
#line 448
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 450
      next = list->next;
#line 452
      png_free((png_const_structrp )png_ptr, (png_voidp )list);
#line 453
      list = next;
      }
#line 448
      if (! ((unsigned long )list != (unsigned long )((void *)0))) {
#line 448
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 457
  return;
}
}
#line 672 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_IHDR(png_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int compression_type , int filter_type ,
                    int interlace_type ) 
{ 
  png_byte buf[13] ;
  int is_invalid_depth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 685
  if (color_type == 0) {
#line 685
    goto case_0;
  }
#line 703
  if (color_type == 2) {
#line 703
    goto case_2___0;
  }
#line 714
  if (color_type == 3) {
#line 714
    goto case_3;
  }
#line 729
  if (color_type == 4) {
#line 729
    goto case_4___1;
  }
#line 740
  if (color_type == 6) {
#line 740
    goto case_6;
  }
#line 751
  goto switch_default___1;
  case_0: /* CIL Label */ 
  {
#line 693
  if (bit_depth == 16) {
#line 693
    goto case_16;
  }
#line 693
  if (bit_depth == 8) {
#line 693
    goto case_16;
  }
#line 693
  if (bit_depth == 4) {
#line 693
    goto case_16;
  }
#line 693
  if (bit_depth == 2) {
#line 693
    goto case_16;
  }
#line 693
  if (bit_depth == 1) {
#line 693
    goto case_16;
  }
#line 697
  goto switch_default;
  case_16: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 695
  png_ptr->channels = (png_byte )1;
#line 695
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 698
  png_error((png_const_structrp )png_ptr, "Invalid bit depth for grayscale image");
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 701
  goto switch_break;
  case_2___0: /* CIL Label */ 
#line 704
  is_invalid_depth = bit_depth != 8;
#line 706
  if (is_invalid_depth) {
#line 706
    if (bit_depth != 16) {
#line 706
      tmp = 1;
    } else {
#line 706
      tmp = 0;
    }
  } else {
#line 706
    tmp = 0;
  }
#line 706
  is_invalid_depth = tmp;
#line 708
  if (is_invalid_depth) {
    {
#line 709
    png_error((png_const_structrp )png_ptr, "Invalid bit depth for RGB image");
    }
  }
#line 711
  png_ptr->channels = (png_byte )3;
#line 712
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 720
  if (bit_depth == 8) {
#line 720
    goto case_8___0;
  }
#line 720
  if (bit_depth == 4) {
#line 720
    goto case_8___0;
  }
#line 720
  if (bit_depth == 2) {
#line 720
    goto case_8___0;
  }
#line 720
  if (bit_depth == 1) {
#line 720
    goto case_8___0;
  }
#line 724
  goto switch_default___0;
  case_8___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_2___1: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
#line 721
  png_ptr->channels = (png_byte )1;
#line 722
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 725
  png_error((png_const_structrp )png_ptr, "Invalid bit depth for paletted image");
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 727
  goto switch_break;
  case_4___1: /* CIL Label */ 
#line 730
  is_invalid_depth = bit_depth != 8;
#line 732
  if (is_invalid_depth) {
#line 732
    if (bit_depth != 16) {
#line 732
      tmp___0 = 1;
    } else {
#line 732
      tmp___0 = 0;
    }
  } else {
#line 732
    tmp___0 = 0;
  }
#line 732
  is_invalid_depth = tmp___0;
#line 734
  if (is_invalid_depth) {
    {
#line 735
    png_error((png_const_structrp )png_ptr, "Invalid bit depth for grayscale+alpha image");
    }
  }
#line 737
  png_ptr->channels = (png_byte )2;
#line 738
  goto switch_break;
  case_6: /* CIL Label */ 
#line 741
  is_invalid_depth = bit_depth != 8;
#line 743
  if (is_invalid_depth) {
#line 743
    if (bit_depth != 16) {
#line 743
      tmp___1 = 1;
    } else {
#line 743
      tmp___1 = 0;
    }
  } else {
#line 743
    tmp___1 = 0;
  }
#line 743
  is_invalid_depth = tmp___1;
#line 745
  if (is_invalid_depth) {
    {
#line 746
    png_error((png_const_structrp )png_ptr, "Invalid bit depth for RGBA image");
    }
  }
#line 748
  png_ptr->channels = (png_byte )4;
#line 749
  goto switch_break;
  switch_default___1: /* CIL Label */ 
  {
#line 752
  png_error((png_const_structrp )png_ptr, "Invalid image color type specified");
  }
  switch_break: /* CIL Label */ ;
  }
#line 755
  if (compression_type != 0) {
    {
#line 757
    png_warning((png_const_structrp )png_ptr, "Invalid compression type specified");
#line 758
    compression_type = 0;
    }
  }
#line 770
  if (filter_type != 0) {
    {
#line 780
    png_warning((png_const_structrp )png_ptr, "Invalid filter type specified");
#line 781
    filter_type = 0;
    }
  }
#line 785
  if (interlace_type != 0) {
#line 785
    if (interlace_type != 1) {
      {
#line 788
      png_warning((png_const_structrp )png_ptr, "Invalid interlace type specified");
#line 789
      interlace_type = 1;
      }
    }
  }
#line 796
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 797
  png_ptr->color_type = (png_byte )color_type;
#line 798
  png_ptr->interlaced = (png_byte )interlace_type;
#line 802
  png_ptr->compression_type = (png_byte )compression_type;
#line 803
  png_ptr->width = width;
#line 804
  png_ptr->height = height;
#line 806
  png_ptr->pixel_depth = (png_byte )(bit_depth * (int )png_ptr->channels);
#line 807
  if ((int )png_ptr->pixel_depth >= 8) {
#line 807
    png_ptr->rowbytes = (png_size_t )width * ((png_size_t )png_ptr->pixel_depth >> 3);
  } else {
#line 807
    png_ptr->rowbytes = ((png_size_t )width * (png_size_t )png_ptr->pixel_depth + 7UL) >> 3;
  }
  {
#line 809
  png_ptr->usr_width = png_ptr->width;
#line 810
  png_ptr->usr_bit_depth = png_ptr->bit_depth;
#line 811
  png_ptr->usr_channels = png_ptr->channels;
#line 814
  png_save_uint_32(buf, width);
#line 815
  png_save_uint_32(buf + 4, height);
#line 816
  buf[8] = (png_byte )bit_depth;
#line 817
  buf[9] = (png_byte )color_type;
#line 818
  buf[10] = (png_byte )compression_type;
#line 819
  buf[11] = (png_byte )filter_type;
#line 820
  buf[12] = (png_byte )interlace_type;
#line 823
  png_write_complete_chunk(png_ptr, (((73U << 24) | (72U << 16)) | (68U << 8)) | 82U,
                           (png_const_bytep )(buf), (png_size_t )13);
  }
#line 825
  if ((int )png_ptr->do_filter == 0) {
#line 827
    if ((int )png_ptr->color_type == 3) {
#line 829
      png_ptr->do_filter = (png_byte )8;
    } else
#line 827
    if ((int )png_ptr->bit_depth < 8) {
#line 829
      png_ptr->do_filter = (png_byte )8;
    } else {
#line 832
      png_ptr->do_filter = (png_byte )248;
    }
  }
#line 835
  png_ptr->mode = (png_uint_32 )1;
#line 836
  return;
}
}
#line 842 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_PLTE(png_structrp png_ptr , png_const_colorp palette , png_uint_32 num_pal ) 
{ 
  png_uint_32 max_palette_length ;
  png_uint_32 i ;
  png_const_colorp pal_ptr ;
  png_byte buf[3] ;

  {
#line 852
  if ((int )png_ptr->color_type == 3) {
#line 852
    max_palette_length = (png_uint_32 )(1 << (int )png_ptr->bit_depth);
  } else {
#line 852
    max_palette_length = (png_uint_32 )256;
  }
#line 855
  if (num_pal == 0U) {
#line 855
    goto _L;
  } else
#line 855
  if (num_pal > max_palette_length) {
    _L: /* CIL Label */ 
#line 861
    if ((int )png_ptr->color_type == 3) {
      {
#line 863
      png_error((png_const_structrp )png_ptr, "Invalid number of colors in palette");
      }
    } else {
      {
#line 868
      png_warning((png_const_structrp )png_ptr, "Invalid number of colors in palette");
      }
#line 869
      return;
    }
  }
#line 873
  if (((int )png_ptr->color_type & 2) == 0) {
    {
#line 875
    png_warning((png_const_structrp )png_ptr, "Ignoring request to write a PLTE chunk in grayscale PNG");
    }
#line 878
    return;
  }
  {
#line 881
  png_ptr->num_palette = (png_uint_16 )num_pal;
#line 884
  png_write_chunk_header(png_ptr, (((80U << 24) | (76U << 16)) | (84U << 8)) | 69U,
                         num_pal * 3U);
#line 887
  i = (png_uint_32 )0;
#line 887
  pal_ptr = palette;
  }
  {
#line 887
  while (1) {
    while_continue: /* CIL Label */ ;
#line 887
    if (! (i < num_pal)) {
#line 887
      goto while_break;
    }
    {
#line 889
    buf[0] = (png_byte )pal_ptr->red;
#line 890
    buf[1] = (png_byte )pal_ptr->green;
#line 891
    buf[2] = (png_byte )pal_ptr->blue;
#line 892
    png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (png_size_t )3);
#line 887
    i ++;
#line 887
    pal_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 910
  png_write_chunk_end(png_ptr);
#line 911
  png_ptr->mode |= 2U;
  }
#line 912
  return;
}
}
#line 931 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_compress_IDAT(png_structrp png_ptr , png_const_bytep input , png_alloc_size_t input_len ,
                       int flush ) 
{ 
  png_voidp __attribute__((__malloc__))  tmp ;
  png_alloc_size_t tmp___0 ;
  int tmp___1 ;
  int ret ;
  uInt avail ;
  int tmp___2 ;
  png_bytep data ;
  uInt size ;
  png_alloc_size_t tmp___3 ;
  png_bytep data___0 ;
  uInt size___0 ;
  png_alloc_size_t tmp___4 ;

  {
#line 935
  if (png_ptr->zowner != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 942
    if ((unsigned long )png_ptr->zbuffer_list == (unsigned long )((void *)0)) {
      {
#line 944
      tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )(& ((png_compression_buffer *)0)->output) + (unsigned long )png_ptr->zbuffer_size);
#line 944
      png_ptr->zbuffer_list = (png_compression_bufferp )tmp;
#line 946
      (png_ptr->zbuffer_list)->next = (struct png_compression_buffer *)((void *)0);
      }
    } else {
      {
#line 950
      png_free_buffer_list(png_ptr, & (png_ptr->zbuffer_list)->next);
      }
    }
    {
#line 953
    tmp___0 = png_image_size(png_ptr);
#line 953
    tmp___1 = png_deflate_claim(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                tmp___0);
    }
#line 953
    if (tmp___1 != 0) {
      {
#line 954
      png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
      }
    }
#line 959
    png_ptr->zstream.next_out = (png_ptr->zbuffer_list)->output;
#line 960
    png_ptr->zstream.avail_out = png_ptr->zbuffer_size;
  }
#line 967
  png_ptr->zstream.next_in = input;
#line 968
  png_ptr->zstream.avail_in = (uInt )0;
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    avail = (uInt )-1;
#line 976
    if ((png_alloc_size_t )avail > input_len) {
#line 977
      avail = (uInt )input_len;
    }
#line 979
    png_ptr->zstream.avail_in = avail;
#line 980
    input_len -= (png_alloc_size_t )avail;
#line 982
    if (input_len > 0UL) {
#line 982
      tmp___2 = 0;
    } else {
#line 982
      tmp___2 = flush;
    }
    {
#line 982
    ret = deflate(& png_ptr->zstream, tmp___2);
#line 985
    input_len += (png_alloc_size_t )png_ptr->zstream.avail_in;
#line 986
    png_ptr->zstream.avail_in = (uInt )0;
    }
#line 992
    if (png_ptr->zstream.avail_out == 0U) {
#line 994
      data = (png_ptr->zbuffer_list)->output;
#line 995
      size = png_ptr->zbuffer_size;
#line 1001
      if ((png_ptr->mode & 4U) == 0U) {
#line 1001
        if ((int )png_ptr->compression_type == 0) {
          {
#line 1003
          tmp___3 = png_image_size(png_ptr);
#line 1003
          optimize_cmf(data, tmp___3);
          }
        }
      }
#line 1006
      if (size > 0U) {
        {
#line 1007
        png_write_complete_chunk(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                 (png_const_bytep )data, (png_size_t )size);
        }
      }
#line 1008
      png_ptr->mode |= 4U;
#line 1010
      png_ptr->zstream.next_out = data;
#line 1011
      png_ptr->zstream.avail_out = size;
#line 1017
      if (ret == 0) {
#line 1017
        if (flush != 0) {
#line 1018
          goto __Cont;
        }
      }
    }
#line 1024
    if (ret == 0) {
#line 1030
      if (input_len == 0UL) {
#line 1032
        if (flush == 4) {
          {
#line 1033
          png_error((png_const_structrp )png_ptr, "Z_OK on Z_FINISH with output space");
          }
        }
#line 1035
        return;
      }
    } else
#line 1039
    if (ret == 1) {
#line 1039
      if (flush == 4) {
#line 1044
        data___0 = (png_ptr->zbuffer_list)->output;
#line 1045
        size___0 = png_ptr->zbuffer_size - png_ptr->zstream.avail_out;
#line 1048
        if ((png_ptr->mode & 4U) == 0U) {
#line 1048
          if ((int )png_ptr->compression_type == 0) {
            {
#line 1050
            tmp___4 = png_image_size(png_ptr);
#line 1050
            optimize_cmf(data___0, tmp___4);
            }
          }
        }
#line 1053
        if (size___0 > 0U) {
          {
#line 1054
          png_write_complete_chunk(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U,
                                   (png_const_bytep )data___0, (png_size_t )size___0);
          }
        }
#line 1055
        png_ptr->zstream.avail_out = (uInt )0;
#line 1056
        png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 1057
        png_ptr->mode |= 12U;
#line 1059
        png_ptr->zowner = (png_uint_32 )0;
#line 1060
        return;
      } else {
        {
#line 1066
        png_zstream_error(png_ptr, ret);
#line 1067
        png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
        }
      }
    } else {
      {
#line 1066
      png_zstream_error(png_ptr, ret);
#line 1067
      png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1073 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_IEND(png_structrp png_ptr ) 
{ 


  {
  {
#line 1078
  png_write_complete_chunk(png_ptr, (((73U << 24) | (69U << 16)) | (78U << 8)) | 68U,
                           (png_const_bytep )((void *)0), (png_size_t )0);
#line 1079
  png_ptr->mode |= 16U;
  }
#line 1080
  return;
}
}
#line 1264 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_sBIT(png_structrp png_ptr , png_const_color_8p sbit , int color_type ) 
{ 
  png_byte buf[4] ;
  png_size_t size ;
  png_byte maxbits ;
  int tmp ;
  png_size_t tmp___0 ;

  {
#line 1273
  if ((color_type & 2) != 0) {
#line 1277
    if (color_type == 3) {
#line 1277
      tmp = 8;
    } else {
#line 1277
      tmp = (int )png_ptr->usr_bit_depth;
    }
#line 1277
    maxbits = (png_byte )tmp;
#line 1280
    if ((int const   )sbit->red == 0) {
      {
#line 1284
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1285
      return;
    } else
#line 1280
    if ((int const   )sbit->red > (int const   )maxbits) {
      {
#line 1284
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1285
      return;
    } else
#line 1280
    if ((int const   )sbit->green == 0) {
      {
#line 1284
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1285
      return;
    } else
#line 1280
    if ((int const   )sbit->green > (int const   )maxbits) {
      {
#line 1284
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1285
      return;
    } else
#line 1280
    if ((int const   )sbit->blue == 0) {
      {
#line 1284
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1285
      return;
    } else
#line 1280
    if ((int const   )sbit->blue > (int const   )maxbits) {
      {
#line 1284
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1285
      return;
    }
#line 1288
    buf[0] = (png_byte )sbit->red;
#line 1289
    buf[1] = (png_byte )sbit->green;
#line 1290
    buf[2] = (png_byte )sbit->blue;
#line 1291
    size = (png_size_t )3;
  } else {
#line 1296
    if ((int const   )sbit->gray == 0) {
      {
#line 1298
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1299
      return;
    } else
#line 1296
    if ((int const   )sbit->gray > (int const   )png_ptr->usr_bit_depth) {
      {
#line 1298
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1299
      return;
    }
#line 1302
    buf[0] = (png_byte )sbit->gray;
#line 1303
    size = (png_size_t )1;
  }
#line 1306
  if ((color_type & 4) != 0) {
#line 1308
    if ((int const   )sbit->alpha == 0) {
      {
#line 1310
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1311
      return;
    } else
#line 1308
    if ((int const   )sbit->alpha > (int const   )png_ptr->usr_bit_depth) {
      {
#line 1310
      png_warning((png_const_structrp )png_ptr, "Invalid sBIT depth specified");
      }
#line 1311
      return;
    }
#line 1314
    tmp___0 = size;
#line 1314
    size ++;
#line 1314
    buf[tmp___0] = (png_byte )sbit->alpha;
  }
  {
#line 1317
  png_write_complete_chunk(png_ptr, (((115U << 24) | (66U << 16)) | (73U << 8)) | 84U,
                           (png_const_bytep )(buf), size);
  }
#line 1318
  return;
}
}
#line 1349 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_tRNS(png_structrp png_ptr , png_const_bytep trans_alpha , png_const_color_16p tran ,
                    int num_trans , int color_type ) 
{ 
  png_byte buf[6] ;

  {
#line 1357
  if (color_type == 3) {
#line 1359
    if (num_trans <= 0) {
      {
#line 1361
      png_app_warning((png_const_structrp )png_ptr, "Invalid number of transparent colors specified");
      }
#line 1363
      return;
    } else
#line 1359
    if (num_trans > (int )png_ptr->num_palette) {
      {
#line 1361
      png_app_warning((png_const_structrp )png_ptr, "Invalid number of transparent colors specified");
      }
#line 1363
      return;
    }
    {
#line 1367
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             trans_alpha, (png_size_t )num_trans);
    }
  } else
#line 1371
  if (color_type == 0) {
#line 1374
    if ((int const   )tran->gray >= (int const   )(1 << (int )png_ptr->bit_depth)) {
      {
#line 1376
      png_app_warning((png_const_structrp )png_ptr, "Ignoring attempt to write tRNS chunk out-of-range for bit_depth");
      }
#line 1379
      return;
    }
    {
#line 1382
    png_save_uint_16(buf, (unsigned int )tran->gray);
#line 1383
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             (png_const_bytep )(buf), (png_size_t )2);
    }
  } else
#line 1386
  if (color_type == 2) {
    {
#line 1389
    png_save_uint_16(buf, (unsigned int )tran->red);
#line 1390
    png_save_uint_16(buf + 2, (unsigned int )tran->green);
#line 1391
    png_save_uint_16(buf + 4, (unsigned int )tran->blue);
    }
#line 1393
    if ((int )png_ptr->bit_depth == 8) {
#line 1393
      if ((((int )buf[0] | (int )buf[2]) | (int )buf[4]) != 0) {
        {
#line 1398
        png_app_warning((png_const_structrp )png_ptr, "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8");
        }
#line 1400
        return;
      }
    }
    {
#line 1403
    png_write_complete_chunk(png_ptr, (((116U << 24) | (82U << 16)) | (78U << 8)) | 83U,
                             (png_const_bytep )(buf), (png_size_t )6);
    }
  } else {
    {
#line 1408
    png_app_warning((png_const_structrp )png_ptr, "Can\'t write tRNS with an alpha channel");
    }
  }
#line 1410
  return;
}
}
#line 1415 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_bKGD(png_structrp png_ptr , png_const_color_16p back , int color_type ) 
{ 
  png_byte buf[6] ;

  {
#line 1422
  if (color_type == 3) {
#line 1424
    if ((int const   )back->index >= (int const   )png_ptr->num_palette) {
      {
#line 1431
      png_warning((png_const_structrp )png_ptr, "Invalid background palette index");
      }
#line 1432
      return;
    }
    {
#line 1435
    buf[0] = (png_byte )back->index;
#line 1436
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (png_size_t )1);
    }
  } else
#line 1439
  if ((color_type & 2) != 0) {
    {
#line 1441
    png_save_uint_16(buf, (unsigned int )back->red);
#line 1442
    png_save_uint_16(buf + 2, (unsigned int )back->green);
#line 1443
    png_save_uint_16(buf + 4, (unsigned int )back->blue);
    }
#line 1445
    if ((int )png_ptr->bit_depth == 8) {
#line 1445
      if ((((int )buf[0] | (int )buf[2]) | (int )buf[4]) != 0) {
        {
#line 1450
        png_warning((png_const_structrp )png_ptr, "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8");
        }
#line 1454
        return;
      }
    }
    {
#line 1457
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (png_size_t )6);
    }
  } else {
#line 1462
    if ((int const   )back->gray >= (int const   )(1 << (int )png_ptr->bit_depth)) {
      {
#line 1464
      png_warning((png_const_structrp )png_ptr, "Ignoring attempt to write bKGD chunk out-of-range for bit_depth");
      }
#line 1467
      return;
    }
    {
#line 1470
    png_save_uint_16(buf, (unsigned int )back->gray);
#line 1471
    png_write_complete_chunk(png_ptr, (((98U << 24) | (75U << 16)) | (71U << 8)) | 68U,
                             (png_const_bytep )(buf), (png_size_t )2);
    }
  }
#line 1473
  return;
}
}
#line 1500 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_hIST(png_structrp png_ptr , png_const_uint_16p hist , int num_hist ) 
{ 
  int i ;
  png_byte buf[3] ;

  {
#line 1508
  if (num_hist > (int )png_ptr->num_palette) {
    {
#line 1513
    png_warning((png_const_structrp )png_ptr, "Invalid number of histogram entries specified");
    }
#line 1514
    return;
  }
  {
#line 1517
  png_write_chunk_header(png_ptr, (((104U << 24) | (73U << 16)) | (83U << 8)) | 84U,
                         (png_uint_32 )(num_hist * 2));
#line 1519
  i = 0;
  }
  {
#line 1519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1519
    if (! (i < num_hist)) {
#line 1519
      goto while_break;
    }
    {
#line 1521
    png_save_uint_16(buf, (unsigned int )*(hist + i));
#line 1522
    png_write_chunk_data(png_ptr, (png_const_bytep )(buf), (png_size_t )2);
#line 1519
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1525
  png_write_chunk_end(png_ptr);
  }
#line 1526
  return;
}
}
#line 1898 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_start[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 1901 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_inc[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 1904 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_ystart[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 1907 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_yinc[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 1891 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_start_row(png_structrp png_ptr ) 
{ 
  png_alloc_size_t buf_size ;
  int usr_pixel_depth ;
  png_byte filters ;
  png_size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  int num_filters ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  png_voidp __attribute__((__malloc__))  tmp___3 ;

  {
#line 1919
  usr_pixel_depth = (int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth;
#line 1920
  if (usr_pixel_depth >= 8) {
#line 1920
    tmp = (png_size_t )png_ptr->width * ((png_size_t )usr_pixel_depth >> 3);
  } else {
#line 1920
    tmp = ((png_size_t )png_ptr->width * (png_size_t )usr_pixel_depth + 7UL) >> 3;
  }
  {
#line 1920
  buf_size = tmp + 1UL;
#line 1923
  png_ptr->transformed_pixel_depth = png_ptr->pixel_depth;
#line 1924
  png_ptr->maximum_pixel_depth = (png_byte )usr_pixel_depth;
#line 1927
  tmp___0 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1927
  png_ptr->row_buf = (png_bytep )tmp___0;
#line 1929
  *(png_ptr->row_buf + 0) = (png_byte )0;
#line 1932
  filters = png_ptr->do_filter;
  }
#line 1934
  if (png_ptr->height == 1U) {
#line 1935
    filters = (png_byte )((int )filters & 31);
  }
#line 1937
  if (png_ptr->width == 1U) {
#line 1938
    filters = (png_byte )((int )filters & 47);
  }
#line 1940
  if ((int )filters == 0) {
#line 1941
    filters = (png_byte )8;
  }
#line 1943
  png_ptr->do_filter = filters;
#line 1945
  if (((int )filters & 240) != 0) {
#line 1945
    if ((unsigned long )png_ptr->try_row == (unsigned long )((void *)0)) {
      {
#line 1948
      num_filters = 0;
#line 1950
      tmp___1 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1950
      png_ptr->try_row = (png_bytep )tmp___1;
      }
#line 1952
      if ((int )filters & 16) {
#line 1953
        num_filters ++;
      }
#line 1955
      if ((int )filters & 32) {
#line 1956
        num_filters ++;
      }
#line 1958
      if ((int )filters & 64) {
#line 1959
        num_filters ++;
      }
#line 1961
      if ((int )filters & 128) {
#line 1962
        num_filters ++;
      }
#line 1964
      if (num_filters > 1) {
        {
#line 1965
        tmp___2 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1965
        png_ptr->tst_row = (png_bytep )tmp___2;
        }
      }
    }
  }
#line 1972
  if (((int )filters & 224) != 0) {
    {
#line 1973
    tmp___3 = png_calloc((png_const_structrp )png_ptr, buf_size);
#line 1973
    png_ptr->prev_row = (png_bytep )tmp___3;
    }
  }
#line 1979
  if ((int )png_ptr->interlaced != 0) {
#line 1981
    if ((png_ptr->transformations & 2U) == 0U) {
#line 1983
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc[0]) - 1U) - (png_uint_32 )png_pass_ystart[0]) / (png_uint_32 )png_pass_yinc[0];
#line 1986
      png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc[0]) - 1U) - (png_uint_32 )png_pass_start[0]) / (png_uint_32 )png_pass_inc[0];
    } else {
#line 1992
      png_ptr->num_rows = png_ptr->height;
#line 1993
      png_ptr->usr_width = png_ptr->width;
    }
  } else {
#line 2000
    png_ptr->num_rows = png_ptr->height;
#line 2001
    png_ptr->usr_width = png_ptr->width;
  }
#line 2003
  return;
}
}
#line 2013 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_start___0[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 2016 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_inc___0[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 2019 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_ystart___0[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 2022 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_yinc___0[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 2006 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_finish_row(png_structrp png_ptr ) 
{ 
  png_size_t tmp ;

  {
#line 2028
  (png_ptr->row_number) ++;
#line 2031
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 2032
    return;
  }
#line 2036
  if ((int )png_ptr->interlaced != 0) {
#line 2038
    png_ptr->row_number = (png_uint_32 )0;
#line 2039
    if ((png_ptr->transformations & 2U) != 0U) {
#line 2041
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
    } else {
      {
#line 2047
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2049
        png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 2051
        if ((int )png_ptr->pass >= 7) {
#line 2052
          goto while_break;
        }
#line 2054
        png_ptr->usr_width = (((png_ptr->width + (png_uint_32 )png_pass_inc___0[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___0[png_ptr->pass]) / (png_uint_32 )png_pass_inc___0[png_ptr->pass];
#line 2059
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___0[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_ystart___0[png_ptr->pass]) / (png_uint_32 )png_pass_yinc___0[png_ptr->pass];
#line 2064
        if ((png_ptr->transformations & 2U) != 0U) {
#line 2065
          goto while_break;
        }
#line 2047
        if (! (png_ptr->usr_width == 0U)) {
#line 2047
          if (! (png_ptr->num_rows == 0U)) {
#line 2047
            goto while_break;
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 2072
    if ((int )png_ptr->pass < 7) {
#line 2074
      if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 2075
        if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 2075
          tmp = (png_size_t )png_ptr->width * ((png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
        } else {
#line 2075
          tmp = ((png_size_t )png_ptr->width * (png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
        }
        {
#line 2075
        memset((void *)png_ptr->prev_row, 0, tmp + 1UL);
        }
      }
#line 2079
      return;
    }
  }
  {
#line 2086
  png_compress_IDAT(png_ptr, (png_const_bytep )((void *)0), (png_alloc_size_t )0,
                    4);
  }
#line 2087
  return;
}
}
#line 2103 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_start___1[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 2106 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_byte const   png_pass_inc___1[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 2097 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_do_write_interlace(png_row_infop row_info , png_bytep row , int pass ) 
{ 
  png_bytep sp___0 ;
  png_bytep dp ;
  unsigned int shift ;
  int d ;
  int value ;
  png_uint_32 i ;
  png_uint_32 row_width ;
  png_bytep tmp ;
  png_bytep sp___1 ;
  png_bytep dp___0 ;
  unsigned int shift___0 ;
  int d___0 ;
  int value___0 ;
  png_uint_32 i___0 ;
  png_uint_32 row_width___0 ;
  png_bytep tmp___0 ;
  png_bytep sp___2 ;
  png_bytep dp___1 ;
  unsigned int shift___1 ;
  int d___1 ;
  int value___1 ;
  png_uint_32 i___1 ;
  png_uint_32 row_width___1 ;
  png_bytep tmp___1 ;
  png_bytep sp___3 ;
  png_bytep dp___2 ;
  png_uint_32 i___2 ;
  png_uint_32 row_width___2 ;
  png_size_t pixel_bytes ;

  {
#line 2111
  if (pass < 6) {
    {
#line 2116
    if ((int )row_info->pixel_depth == 1) {
#line 2116
      goto case_1;
    }
#line 2154
    if ((int )row_info->pixel_depth == 2) {
#line 2154
      goto case_2;
    }
#line 2191
    if ((int )row_info->pixel_depth == 4) {
#line 2191
      goto case_4;
    }
#line 2227
    goto switch_default;
    case_1: /* CIL Label */ 
#line 2124
    row_width = row_info->width;
#line 2126
    dp = row;
#line 2127
    d = 0;
#line 2128
    shift = 7U;
#line 2130
    i = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2130
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2130
      if (! (i < row_width)) {
#line 2130
        goto while_break;
      }
#line 2133
      sp___0 = row + (png_size_t )(i >> 3);
#line 2134
      value = ((int )*sp___0 >> (7 - (int )(i & 7U))) & 1;
#line 2135
      d |= value << shift;
#line 2137
      if (shift == 0U) {
#line 2139
        shift = 7U;
#line 2140
        tmp = dp;
#line 2140
        dp ++;
#line 2140
        *tmp = (png_byte )d;
#line 2141
        d = 0;
      } else {
#line 2145
        shift --;
      }
#line 2130
      i += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break: /* CIL Label */ ;
    }
#line 2148
    if (shift != 7U) {
#line 2149
      *dp = (png_byte )d;
    }
#line 2151
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2162
    row_width___0 = row_info->width;
#line 2164
    dp___0 = row;
#line 2165
    shift___0 = 6U;
#line 2166
    d___0 = 0;
#line 2168
    i___0 = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2168
      if (! (i___0 < row_width___0)) {
#line 2168
        goto while_break___0;
      }
#line 2171
      sp___1 = row + (png_size_t )(i___0 >> 2);
#line 2172
      value___0 = ((int )*sp___1 >> ((3 - (int )(i___0 & 3U)) << 1)) & 3;
#line 2173
      d___0 |= value___0 << shift___0;
#line 2175
      if (shift___0 == 0U) {
#line 2177
        shift___0 = 6U;
#line 2178
        tmp___0 = dp___0;
#line 2178
        dp___0 ++;
#line 2178
        *tmp___0 = (png_byte )d___0;
#line 2179
        d___0 = 0;
      } else {
#line 2183
        shift___0 -= 2U;
      }
#line 2168
      i___0 += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2185
    if (shift___0 != 6U) {
#line 2186
      *dp___0 = (png_byte )d___0;
    }
#line 2188
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2199
    row_width___1 = row_info->width;
#line 2201
    dp___1 = row;
#line 2202
    shift___1 = 4U;
#line 2203
    d___1 = 0;
#line 2204
    i___1 = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2204
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2204
      if (! (i___1 < row_width___1)) {
#line 2204
        goto while_break___1;
      }
#line 2207
      sp___2 = row + (png_size_t )(i___1 >> 1);
#line 2208
      value___1 = ((int )*sp___2 >> ((1 - (int )(i___1 & 1U)) << 2)) & 15;
#line 2209
      d___1 |= value___1 << shift___1;
#line 2211
      if (shift___1 == 0U) {
#line 2213
        shift___1 = 4U;
#line 2214
        tmp___1 = dp___1;
#line 2214
        dp___1 ++;
#line 2214
        *tmp___1 = (png_byte )d___1;
#line 2215
        d___1 = 0;
      } else {
#line 2219
        shift___1 -= 4U;
      }
#line 2204
      i___1 += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2221
    if (shift___1 != 4U) {
#line 2222
      *dp___1 = (png_byte )d___1;
    }
#line 2224
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2232
    row_width___2 = row_info->width;
#line 2236
    dp___2 = row;
#line 2239
    pixel_bytes = (png_size_t )((int )row_info->pixel_depth >> 3);
#line 2242
    i___2 = (png_uint_32 )png_pass_start___1[pass];
    {
#line 2242
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2242
      if (! (i___2 < row_width___2)) {
#line 2242
        goto while_break___2;
      }
#line 2246
      sp___3 = row + (png_size_t )i___2 * pixel_bytes;
#line 2249
      if ((unsigned long )dp___2 != (unsigned long )sp___3) {
        {
#line 2250
        memcpy((void */* __restrict  */)dp___2, (void const   */* __restrict  */)sp___3,
               pixel_bytes);
        }
      }
#line 2253
      dp___2 += pixel_bytes;
#line 2242
      i___2 += (png_uint_32 )png_pass_inc___1[pass];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2255
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2259
    row_info->width = (((row_info->width + (png_uint_32 )png_pass_inc___1[pass]) - 1U) - (png_uint_32 )png_pass_start___1[pass]) / (png_uint_32 )png_pass_inc___1[pass];
#line 2264
    if ((int )row_info->pixel_depth >= 8) {
#line 2264
      row_info->rowbytes = (png_size_t )row_info->width * ((png_size_t )row_info->pixel_depth >> 3);
    } else {
#line 2264
      row_info->rowbytes = ((png_size_t )row_info->width * (png_size_t )row_info->pixel_depth + 7UL) >> 3;
    }
  }
#line 2267
  return;
}
}
#line 2275
static void png_write_filtered_row(png_structrp png_ptr , png_bytep filtered_row ,
                                   png_size_t full_row_length ) ;
#line 2280 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_size_t png_setup_sub_row(png_structrp png_ptr , png_uint_32 const   bpp ,
                                    png_size_t const   row_bytes , png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep lp ;
  png_size_t i ;
  png_size_t sum ;
  unsigned int v ;
  png_byte tmp ;
  unsigned int tmp___0 ;
  png_byte tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 2286
  sum = (png_size_t )0;
#line 2289
  *(png_ptr->try_row + 0) = (png_byte )1;
#line 2291
  i = (png_size_t )0;
#line 2291
  rp = png_ptr->row_buf + 1;
#line 2291
  dp = png_ptr->try_row + 1;
  {
#line 2291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2291
    if (! (i < (png_size_t )bpp)) {
#line 2291
      goto while_break;
    }
#line 2294
    tmp = *rp;
#line 2294
    *dp = tmp;
#line 2294
    v = (unsigned int )tmp;
#line 2298
    if (v < 128U) {
#line 2298
      tmp___0 = v;
    } else {
#line 2298
      tmp___0 = 256U - v;
    }
#line 2298
    sum += (png_size_t )tmp___0;
#line 2291
    i ++;
#line 2291
    rp ++;
#line 2291
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2302
  lp = png_ptr->row_buf + 1;
  {
#line 2302
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2302
    if (! (i < (png_size_t )row_bytes)) {
#line 2302
      goto while_break___0;
    }
#line 2305
    tmp___1 = (png_byte )(((int )*rp - (int )*lp) & 255);
#line 2305
    *dp = tmp___1;
#line 2305
    v = (unsigned int )tmp___1;
#line 2309
    if (v < 128U) {
#line 2309
      tmp___2 = v;
    } else {
#line 2309
      tmp___2 = 256U - v;
    }
#line 2309
    sum += (png_size_t )tmp___2;
#line 2312
    if (sum > (png_size_t )lmins) {
#line 2313
      goto while_break___0;
    }
#line 2302
    i ++;
#line 2302
    rp ++;
#line 2302
    lp ++;
#line 2302
    dp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2316
  return (sum);
}
}
#line 2319 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void png_setup_sub_row_only(png_structrp png_ptr , png_uint_32 const   bpp ,
                                   png_size_t const   row_bytes ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep lp ;
  png_size_t i ;

  {
#line 2326
  *(png_ptr->try_row + 0) = (png_byte )1;
#line 2328
  i = (png_size_t )0;
#line 2328
  rp = png_ptr->row_buf + 1;
#line 2328
  dp = png_ptr->try_row + 1;
  {
#line 2328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2328
    if (! (i < (png_size_t )bpp)) {
#line 2328
      goto while_break;
    }
#line 2331
    *dp = *rp;
#line 2328
    i ++;
#line 2328
    rp ++;
#line 2328
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2334
  lp = png_ptr->row_buf + 1;
  {
#line 2334
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2334
    if (! (i < (png_size_t )row_bytes)) {
#line 2334
      goto while_break___0;
    }
#line 2337
    *dp = (png_byte )(((int )*rp - (int )*lp) & 255);
#line 2334
    i ++;
#line 2334
    rp ++;
#line 2334
    lp ++;
#line 2334
    dp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2339
  return;
}
}
#line 2341 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_size_t png_setup_up_row(png_structrp png_ptr , png_size_t const   row_bytes ,
                                   png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_size_t i ;
  png_size_t sum ;
  unsigned int v ;
  png_byte tmp ;
  unsigned int tmp___0 ;

  {
#line 2347
  sum = (png_size_t )0;
#line 2350
  *(png_ptr->try_row + 0) = (png_byte )2;
#line 2352
  i = (png_size_t )0;
#line 2352
  rp = png_ptr->row_buf + 1;
#line 2352
  dp = png_ptr->try_row + 1;
#line 2352
  pp = png_ptr->prev_row + 1;
  {
#line 2352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2352
    if (! (i < (png_size_t )row_bytes)) {
#line 2352
      goto while_break;
    }
#line 2356
    tmp = (png_byte )(((int )*rp - (int )*pp) & 255);
#line 2356
    *dp = tmp;
#line 2356
    v = (unsigned int )tmp;
#line 2360
    if (v < 128U) {
#line 2360
      tmp___0 = v;
    } else {
#line 2360
      tmp___0 = 256U - v;
    }
#line 2360
    sum += (png_size_t )tmp___0;
#line 2363
    if (sum > (png_size_t )lmins) {
#line 2364
      goto while_break;
    }
#line 2352
    i ++;
#line 2352
    rp ++;
#line 2352
    pp ++;
#line 2352
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2367
  return (sum);
}
}
#line 2369 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void png_setup_up_row_only(png_structrp png_ptr , png_size_t const   row_bytes ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_size_t i ;

  {
#line 2375
  *(png_ptr->try_row + 0) = (png_byte )2;
#line 2377
  i = (png_size_t )0;
#line 2377
  rp = png_ptr->row_buf + 1;
#line 2377
  dp = png_ptr->try_row + 1;
#line 2377
  pp = png_ptr->prev_row + 1;
  {
#line 2377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2377
    if (! (i < (png_size_t )row_bytes)) {
#line 2377
      goto while_break;
    }
#line 2381
    *dp = (png_byte )(((int )*rp - (int )*pp) & 255);
#line 2377
    i ++;
#line 2377
    rp ++;
#line 2377
    pp ++;
#line 2377
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2383
  return;
}
}
#line 2385 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_size_t png_setup_avg_row(png_structrp png_ptr , png_uint_32 const   bpp ,
                                    png_size_t const   row_bytes , png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep lp ;
  png_uint_32 i ;
  png_size_t sum ;
  unsigned int v ;
  png_bytep tmp ;
  png_byte tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  unsigned int tmp___3 ;
  png_bytep tmp___4 ;
  png_byte tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;
  png_bytep tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 2391
  sum = (png_size_t )0;
#line 2394
  *(png_ptr->try_row + 0) = (png_byte )3;
#line 2396
  i = (png_uint_32 )0;
#line 2396
  rp = png_ptr->row_buf + 1;
#line 2396
  dp = png_ptr->try_row + 1;
#line 2396
  pp = png_ptr->prev_row + 1;
  {
#line 2396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2396
    if (! (i < (png_uint_32 )bpp)) {
#line 2396
      goto while_break;
    }
#line 2399
    tmp = dp;
#line 2399
    dp ++;
#line 2399
    tmp___1 = rp;
#line 2399
    rp ++;
#line 2399
    tmp___2 = pp;
#line 2399
    pp ++;
#line 2399
    tmp___0 = (png_byte )(((int )*tmp___1 - (int )*tmp___2 / 2) & 255);
#line 2399
    *tmp = tmp___0;
#line 2399
    v = (unsigned int )tmp___0;
#line 2404
    if (v < 128U) {
#line 2404
      tmp___3 = v;
    } else {
#line 2404
      tmp___3 = 256U - v;
    }
#line 2404
    sum += (png_size_t )tmp___3;
#line 2396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2408
  lp = png_ptr->row_buf + 1;
  {
#line 2408
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2408
    if (! ((png_size_t const   )i < row_bytes)) {
#line 2408
      goto while_break___0;
    }
#line 2410
    tmp___4 = dp;
#line 2410
    dp ++;
#line 2410
    tmp___6 = rp;
#line 2410
    rp ++;
#line 2410
    tmp___7 = pp;
#line 2410
    pp ++;
#line 2410
    tmp___8 = lp;
#line 2410
    lp ++;
#line 2410
    tmp___5 = (png_byte )(((int )*tmp___6 - ((int )*tmp___7 + (int )*tmp___8) / 2) & 255);
#line 2410
    *tmp___4 = tmp___5;
#line 2410
    v = (unsigned int )tmp___5;
#line 2416
    if (v < 128U) {
#line 2416
      tmp___9 = v;
    } else {
#line 2416
      tmp___9 = 256U - v;
    }
#line 2416
    sum += (png_size_t )tmp___9;
#line 2419
    if (sum > (png_size_t )lmins) {
#line 2420
      goto while_break___0;
    }
#line 2408
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2423
  return (sum);
}
}
#line 2425 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void png_setup_avg_row_only(png_structrp png_ptr , png_uint_32 const   bpp ,
                                   png_size_t const   row_bytes ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep lp ;
  png_uint_32 i ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;

  {
#line 2432
  *(png_ptr->try_row + 0) = (png_byte )3;
#line 2434
  i = (png_uint_32 )0;
#line 2434
  rp = png_ptr->row_buf + 1;
#line 2434
  dp = png_ptr->try_row + 1;
#line 2434
  pp = png_ptr->prev_row + 1;
  {
#line 2434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2434
    if (! (i < (png_uint_32 )bpp)) {
#line 2434
      goto while_break;
    }
#line 2437
    tmp = dp;
#line 2437
    dp ++;
#line 2437
    tmp___0 = rp;
#line 2437
    rp ++;
#line 2437
    tmp___1 = pp;
#line 2437
    pp ++;
#line 2437
    *tmp = (png_byte )(((int )*tmp___0 - (int )*tmp___1 / 2) & 255);
#line 2434
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2440
  lp = png_ptr->row_buf + 1;
  {
#line 2440
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2440
    if (! ((png_size_t const   )i < row_bytes)) {
#line 2440
      goto while_break___0;
    }
#line 2442
    tmp___2 = dp;
#line 2442
    dp ++;
#line 2442
    tmp___3 = rp;
#line 2442
    rp ++;
#line 2442
    tmp___4 = pp;
#line 2442
    pp ++;
#line 2442
    tmp___5 = lp;
#line 2442
    lp ++;
#line 2442
    *tmp___2 = (png_byte )(((int )*tmp___3 - ((int )*tmp___4 + (int )*tmp___5) / 2) & 255);
#line 2440
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2445
  return;
}
}
#line 2447 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static png_size_t png_setup_paeth_row(png_structrp png_ptr , png_uint_32 const   bpp ,
                                      png_size_t const   row_bytes , png_size_t const   lmins ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep cp ;
  png_bytep lp ;
  png_size_t i ;
  png_size_t sum ;
  unsigned int v ;
  png_bytep tmp ;
  png_byte tmp___0 ;
  png_bytep tmp___1 ;
  png_bytep tmp___2 ;
  unsigned int tmp___3 ;
  int a ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_bytep tmp___4 ;
  png_bytep tmp___5 ;
  png_bytep tmp___6 ;
  int tmp___7 ;
  png_bytep tmp___8 ;
  png_byte tmp___9 ;
  png_bytep tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 2453
  sum = (png_size_t )0;
#line 2456
  *(png_ptr->try_row + 0) = (png_byte )4;
#line 2458
  i = (png_size_t )0;
#line 2458
  rp = png_ptr->row_buf + 1;
#line 2458
  dp = png_ptr->try_row + 1;
#line 2458
  pp = png_ptr->prev_row + 1;
  {
#line 2458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2458
    if (! (i < (png_size_t )bpp)) {
#line 2458
      goto while_break;
    }
#line 2461
    tmp = dp;
#line 2461
    dp ++;
#line 2461
    tmp___1 = rp;
#line 2461
    rp ++;
#line 2461
    tmp___2 = pp;
#line 2461
    pp ++;
#line 2461
    tmp___0 = (png_byte )(((int )*tmp___1 - (int )*tmp___2) & 255);
#line 2461
    *tmp = tmp___0;
#line 2461
    v = (unsigned int )tmp___0;
#line 2466
    if (v < 128U) {
#line 2466
      tmp___3 = v;
    } else {
#line 2466
      tmp___3 = 256U - v;
    }
#line 2466
    sum += (png_size_t )tmp___3;
#line 2458
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2470
  lp = png_ptr->row_buf + 1;
#line 2470
  cp = png_ptr->prev_row + 1;
  {
#line 2470
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2470
    if (! (i < (png_size_t )row_bytes)) {
#line 2470
      goto while_break___0;
    }
#line 2475
    tmp___4 = pp;
#line 2475
    pp ++;
#line 2475
    b = (int )*tmp___4;
#line 2476
    tmp___5 = cp;
#line 2476
    cp ++;
#line 2476
    c = (int )*tmp___5;
#line 2477
    tmp___6 = lp;
#line 2477
    lp ++;
#line 2477
    a = (int )*tmp___6;
#line 2479
    p = b - c;
#line 2480
    pc = a - c;
#line 2487
    if (p < 0) {
#line 2487
      pa = - p;
    } else {
#line 2487
      pa = p;
    }
#line 2488
    if (pc < 0) {
#line 2488
      pb = - pc;
    } else {
#line 2488
      pb = pc;
    }
#line 2489
    if (p + pc < 0) {
#line 2489
      pc = - (p + pc);
    } else {
#line 2489
      pc = p + pc;
    }
#line 2492
    if (pa <= pb) {
#line 2492
      if (pa <= pc) {
#line 2492
        p = a;
      } else {
#line 2492
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2492
      if (pb <= pc) {
#line 2492
        tmp___7 = b;
      } else {
#line 2492
        tmp___7 = c;
      }
#line 2492
      p = tmp___7;
    }
#line 2494
    tmp___8 = dp;
#line 2494
    dp ++;
#line 2494
    tmp___10 = rp;
#line 2494
    rp ++;
#line 2494
    tmp___9 = (png_byte )(((int )*tmp___10 - p) & 255);
#line 2494
    *tmp___8 = tmp___9;
#line 2494
    v = (unsigned int )tmp___9;
#line 2499
    if (v < 128U) {
#line 2499
      tmp___11 = v;
    } else {
#line 2499
      tmp___11 = 256U - v;
    }
#line 2499
    sum += (png_size_t )tmp___11;
#line 2502
    if (sum > (png_size_t )lmins) {
#line 2503
      goto while_break___0;
    }
#line 2470
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2506
  return (sum);
}
}
#line 2508 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void png_setup_paeth_row_only(png_structrp png_ptr , png_uint_32 const   bpp ,
                                     png_size_t const   row_bytes ) 
{ 
  png_bytep rp ;
  png_bytep dp ;
  png_bytep pp ;
  png_bytep cp ;
  png_bytep lp ;
  png_size_t i ;
  png_bytep tmp ;
  png_bytep tmp___0 ;
  png_bytep tmp___1 ;
  int a ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;
  png_bytep tmp___4 ;
  int tmp___5 ;
  png_bytep tmp___6 ;
  png_bytep tmp___7 ;

  {
#line 2515
  *(png_ptr->try_row + 0) = (png_byte )4;
#line 2517
  i = (png_size_t )0;
#line 2517
  rp = png_ptr->row_buf + 1;
#line 2517
  dp = png_ptr->try_row + 1;
#line 2517
  pp = png_ptr->prev_row + 1;
  {
#line 2517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2517
    if (! (i < (png_size_t )bpp)) {
#line 2517
      goto while_break;
    }
#line 2520
    tmp = dp;
#line 2520
    dp ++;
#line 2520
    tmp___0 = rp;
#line 2520
    rp ++;
#line 2520
    tmp___1 = pp;
#line 2520
    pp ++;
#line 2520
    *tmp = (png_byte )(((int )*tmp___0 - (int )*tmp___1) & 255);
#line 2517
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2523
  lp = png_ptr->row_buf + 1;
#line 2523
  cp = png_ptr->prev_row + 1;
  {
#line 2523
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2523
    if (! (i < (png_size_t )row_bytes)) {
#line 2523
      goto while_break___0;
    }
#line 2528
    tmp___2 = pp;
#line 2528
    pp ++;
#line 2528
    b = (int )*tmp___2;
#line 2529
    tmp___3 = cp;
#line 2529
    cp ++;
#line 2529
    c = (int )*tmp___3;
#line 2530
    tmp___4 = lp;
#line 2530
    lp ++;
#line 2530
    a = (int )*tmp___4;
#line 2532
    p = b - c;
#line 2533
    pc = a - c;
#line 2540
    if (p < 0) {
#line 2540
      pa = - p;
    } else {
#line 2540
      pa = p;
    }
#line 2541
    if (pc < 0) {
#line 2541
      pb = - pc;
    } else {
#line 2541
      pb = pc;
    }
#line 2542
    if (p + pc < 0) {
#line 2542
      pc = - (p + pc);
    } else {
#line 2542
      pc = p + pc;
    }
#line 2545
    if (pa <= pb) {
#line 2545
      if (pa <= pc) {
#line 2545
        p = a;
      } else {
#line 2545
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2545
      if (pb <= pc) {
#line 2545
        tmp___5 = b;
      } else {
#line 2545
        tmp___5 = c;
      }
#line 2545
      p = tmp___5;
    }
#line 2547
    tmp___6 = dp;
#line 2547
    dp ++;
#line 2547
    tmp___7 = rp;
#line 2547
    rp ++;
#line 2547
    *tmp___6 = (png_byte )(((int )*tmp___7 - p) & 255);
#line 2523
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2549
  return;
}
}
#line 2552 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
void png_write_find_filter(png_structrp png_ptr , png_row_infop row_info ) 
{ 
  unsigned int filter_to_do ;
  png_bytep row_buf ;
  png_bytep best_row ;
  png_uint_32 bpp ;
  png_size_t mins ;
  png_size_t row_bytes ;
  png_bytep rp ;
  png_size_t sum ;
  png_size_t i ;
  unsigned int v ;
  unsigned int tmp ;
  png_size_t sum___0 ;
  png_size_t lmins ;
  png_size_t sum___1 ;
  png_size_t lmins___0 ;
  png_size_t sum___2 ;
  png_size_t lmins___1 ;
  png_size_t sum___3 ;
  png_size_t lmins___2 ;

  {
#line 2558
  filter_to_do = (unsigned int )png_ptr->do_filter;
#line 2563
  row_bytes = row_info->rowbytes;
#line 2568
  bpp = (png_uint_32 )(((int )row_info->pixel_depth + 7) >> 3);
#line 2570
  row_buf = png_ptr->row_buf;
#line 2571
  mins = 0xfffffffffffffeffUL;
#line 2602
  best_row = png_ptr->row_buf;
#line 2604
  if (144115188075855871UL <= row_bytes) {
#line 2609
    filter_to_do &= 0U - filter_to_do;
  } else
#line 2611
  if ((filter_to_do & 8U) != 0U) {
#line 2611
    if (filter_to_do != 8U) {
#line 2618
      sum = (png_size_t )0;
#line 2623
      i = (png_size_t )0;
#line 2623
      rp = row_buf + 1;
      {
#line 2623
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2623
        if (! (i < row_bytes)) {
#line 2623
          goto while_break;
        }
#line 2625
        v = (unsigned int )*rp;
#line 2629
        if (v < 128U) {
#line 2629
          tmp = v;
        } else {
#line 2629
          tmp = 256U - v;
        }
#line 2629
        sum += (png_size_t )tmp;
#line 2623
        i ++;
#line 2623
        rp ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2634
      mins = sum;
    }
  }
#line 2638
  if (filter_to_do == 16U) {
    {
#line 2641
    png_setup_sub_row_only(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes);
#line 2642
    best_row = png_ptr->try_row;
    }
  } else
#line 2645
  if ((filter_to_do & 16U) != 0U) {
    {
#line 2648
    lmins = mins;
#line 2650
    sum___0 = png_setup_sub_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                                (png_size_t const   )lmins);
    }
#line 2652
    if (sum___0 < mins) {
#line 2654
      mins = sum___0;
#line 2655
      best_row = png_ptr->try_row;
#line 2656
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2658
        png_ptr->try_row = png_ptr->tst_row;
#line 2659
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2665
  if (filter_to_do == 32U) {
    {
#line 2667
    png_setup_up_row_only(png_ptr, (png_size_t const   )row_bytes);
#line 2668
    best_row = png_ptr->try_row;
    }
  } else
#line 2671
  if ((filter_to_do & 32U) != 0U) {
    {
#line 2674
    lmins___0 = mins;
#line 2676
    sum___1 = png_setup_up_row(png_ptr, (png_size_t const   )row_bytes, (png_size_t const   )lmins___0);
    }
#line 2678
    if (sum___1 < mins) {
#line 2680
      mins = sum___1;
#line 2681
      best_row = png_ptr->try_row;
#line 2682
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2684
        png_ptr->try_row = png_ptr->tst_row;
#line 2685
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2691
  if (filter_to_do == 64U) {
    {
#line 2693
    png_setup_avg_row_only(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes);
#line 2694
    best_row = png_ptr->try_row;
    }
  } else
#line 2697
  if ((filter_to_do & 64U) != 0U) {
    {
#line 2700
    lmins___1 = mins;
#line 2702
    sum___2 = png_setup_avg_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                                (png_size_t const   )lmins___1);
    }
#line 2704
    if (sum___2 < mins) {
#line 2706
      mins = sum___2;
#line 2707
      best_row = png_ptr->try_row;
#line 2708
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2710
        png_ptr->try_row = png_ptr->tst_row;
#line 2711
        png_ptr->tst_row = best_row;
      }
    }
  }
#line 2717
  if (filter_to_do == 128U) {
    {
#line 2719
    png_setup_paeth_row_only(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes);
#line 2720
    best_row = png_ptr->try_row;
    }
  } else
#line 2723
  if ((filter_to_do & 128U) != 0U) {
    {
#line 2726
    lmins___2 = mins;
#line 2728
    sum___3 = png_setup_paeth_row(png_ptr, (png_uint_32 const   )bpp, (png_size_t const   )row_bytes,
                                  (png_size_t const   )lmins___2);
    }
#line 2730
    if (sum___3 < mins) {
#line 2732
      best_row = png_ptr->try_row;
#line 2733
      if ((unsigned long )png_ptr->tst_row != (unsigned long )((void *)0)) {
#line 2735
        png_ptr->try_row = png_ptr->tst_row;
#line 2736
        png_ptr->tst_row = best_row;
      }
    }
  }
  {
#line 2742
  png_write_filtered_row(png_ptr, best_row, row_info->rowbytes + 1UL);
  }
#line 2745
  return;
}
}
#line 2749 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwutil.c"
static void png_write_filtered_row(png_structrp png_ptr , png_bytep filtered_row ,
                                   png_size_t full_row_length ) 
{ 
  png_bytep tptr ;

  {
  {
#line 2757
  png_compress_IDAT(png_ptr, (png_const_bytep )filtered_row, full_row_length, 0);
  }
#line 2761
  if ((unsigned long )png_ptr->prev_row != (unsigned long )((void *)0)) {
#line 2765
    tptr = png_ptr->prev_row;
#line 2766
    png_ptr->prev_row = png_ptr->row_buf;
#line 2767
    png_ptr->row_buf = tptr;
  }
  {
#line 2772
  png_write_finish_row(png_ptr);
#line 2775
  (png_ptr->flush_rows) ++;
  }
#line 2777
  if (png_ptr->flush_dist > 0U) {
#line 2777
    if (png_ptr->flush_rows >= png_ptr->flush_dist) {
      {
#line 2780
      png_write_flush(png_ptr);
      }
    }
  }
#line 2783
  return;
}
}
#line 959 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
png_structp __attribute__((__malloc__))  png_create_write_struct(png_const_charp user_png_ver ,
                                                                 png_voidp error_ptr ,
                                                                 void (*error_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                 void (*warn_fn)(png_structp  ,
                                                                                 png_const_charp  ) ) ;
#line 1046
void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1048
void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1316
int png_set_interlace_handling(png_structrp png_ptr ) ;
#line 1389
void png_set_flush(png_structrp png_ptr , int nrows ) ;
#line 1419
void png_write_row(png_structrp png_ptr , png_const_bytep row ) ;
#line 1427
void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) ;
#line 1431
void png_write_image(png_structrp png_ptr , png_bytepp image___0 ) ;
#line 1434
void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1443
void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) ;
#line 1451
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) ;
#line 1486
void png_set_filter(png_structrp png_ptr , int method , int filters ) ;
#line 1539
void png_set_compression_level(png_structrp png_ptr , int level ) ;
#line 1542
void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) ;
#line 1545
void png_set_compression_strategy(png_structrp png_ptr , int strategy ) ;
#line 1551
void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) ;
#line 1554
void png_set_compression_method(png_structrp png_ptr , int method ) ;
#line 1618
void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      png_size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) ) ;
#line 1631
void png_set_write_status_fn(png_structrp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                         png_uint_32  ,
                                                                         int  ) ) ;
#line 1835
void png_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 2318
int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) ;
#line 2356
void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) ;
#line 1024 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
png_structp __attribute__((__malloc__))  png_create_png_struct(png_const_charp user_png_ver ,
                                                               png_voidp error_ptr ,
                                                               void (*error_fn)(png_structp  ,
                                                                                png_const_charp  ) ,
                                                               void (*warn_fn)(png_structp  ,
                                                                               png_const_charp  ) ,
                                                               png_voidp mem_ptr ,
                                                               png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                                                               void (*free_fn)(png_structp  ,
                                                                               png_voidp  ) ) ;
#line 1030
void png_destroy_png_struct(png_structrp png_ptr ) ;
#line 1104
void png_flush(png_structrp png_ptr ) ;
#line 1710
void png_do_check_palette_indexes(png_structrp png_ptr , png_row_infop row_info ) ;
#line 1812
void png_app_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 23 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
static void write_unknown_chunks(png_structrp png_ptr , png_const_inforp info_ptr ,
                                 unsigned int where ) 
{ 
  png_const_unknown_chunkp up ;
  int keep ;
  int tmp ;

  {
#line 27
  if (info_ptr->unknown_chunks_num != 0) {
#line 33
    up = (png_const_unknown_chunkp )info_ptr->unknown_chunks;
    {
#line 33
    while (1) {
      while_continue: /* CIL Label */ ;
#line 33
      if (! ((unsigned long )up < (unsigned long )(info_ptr->unknown_chunks + info_ptr->unknown_chunks_num))) {
#line 33
        goto while_break;
      }
#line 36
      if (((unsigned int )up->location & where) != 0U) {
        {
#line 42
        tmp = png_handle_as_unknown((png_const_structrp )png_ptr, (png_const_bytep )(up->name));
#line 42
        keep = tmp;
        }
#line 56
        if (keep != 1) {
#line 56
          if ((int )up->name[3] & 32) {
#line 56
            goto _L;
          } else
#line 56
          if (keep == 3) {
#line 56
            goto _L;
          } else
#line 56
          if (keep == 0) {
#line 56
            if (png_ptr->unknown_default == 3) {
              _L: /* CIL Label */ 
#line 64
              if (up->size == 0UL) {
                {
#line 65
                png_warning((png_const_structrp )png_ptr, "Writing zero-length unknown chunk");
                }
              }
              {
#line 67
              png_write_chunk(png_ptr, (png_const_bytep )(up->name), (png_const_bytep )up->data,
                              (png_size_t )up->size);
              }
            }
          }
        }
      }
#line 33
      up ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 71
  return;
}
}
#line 83 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_info_before_PLTE(png_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 88
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 89
    return;
  } else
#line 88
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 89
    return;
  }
#line 91
  if ((png_ptr->mode & 1024U) == 0U) {
    {
#line 94
    png_write_sig(png_ptr);
#line 107
    png_write_IHDR(png_ptr, (png_uint_32 )info_ptr->width, (png_uint_32 )info_ptr->height,
                   (int )info_ptr->bit_depth, (int )info_ptr->color_type, (int )info_ptr->compression_type,
                   (int )info_ptr->filter_type, (int )info_ptr->interlace_type);
    }
#line 170
    if ((info_ptr->valid & 2U) != 0U) {
      {
#line 171
      png_write_sBIT(png_ptr, & info_ptr->sig_bit, (int )info_ptr->color_type);
      }
    }
    {
#line 184
    write_unknown_chunks(png_ptr, info_ptr, 1U);
#line 187
    png_ptr->mode |= 1024U;
    }
  }
#line 189
  return;
}
}
#line 191 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_info(png_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 200
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 201
    return;
  } else
#line 200
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 201
    return;
  }
  {
#line 203
  png_write_info_before_PLTE(png_ptr, info_ptr);
  }
#line 205
  if ((info_ptr->valid & 8U) != 0U) {
    {
#line 206
    png_write_PLTE(png_ptr, (png_const_colorp )info_ptr->palette, (png_uint_32 )info_ptr->num_palette);
    }
  } else
#line 209
  if ((int const   )info_ptr->color_type == 3) {
    {
#line 210
    png_error((png_const_structrp )png_ptr, "Valid palette required for paletted images");
    }
  }
#line 213
  if ((info_ptr->valid & 16U) != 0U) {
    {
#line 231
    png_write_tRNS(png_ptr, (png_const_bytep )info_ptr->trans_alpha, & info_ptr->trans_color,
                   (int )info_ptr->num_trans, (int )info_ptr->color_type);
    }
  }
#line 236
  if ((info_ptr->valid & 32U) != 0U) {
    {
#line 237
    png_write_bKGD(png_ptr, & info_ptr->background, (int )info_ptr->color_type);
    }
  }
#line 246
  if ((info_ptr->valid & 64U) != 0U) {
    {
#line 247
    png_write_hIST(png_ptr, (png_const_uint_16p )info_ptr->hist, (int )info_ptr->num_palette);
    }
  }
  {
#line 348
  write_unknown_chunks(png_ptr, info_ptr, 2U);
  }
#line 350
  return;
}
}
#line 357 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_end(png_structrp png_ptr , png_inforp info_ptr ) 
{ 


  {
#line 362
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 363
    return;
  }
#line 365
  if ((png_ptr->mode & 4U) == 0U) {
    {
#line 366
    png_error((png_const_structrp )png_ptr, "No IDATs written into file");
    }
  }
#line 369
  if (png_ptr->num_palette_max > (int )png_ptr->num_palette) {
    {
#line 370
    png_benign_error((png_const_structrp )png_ptr, "Wrote palette index exceeding num_palette");
    }
  }
#line 374
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 447
    write_unknown_chunks(png_ptr, (png_const_inforp )info_ptr, 8U);
    }
  }
  {
#line 451
  png_ptr->mode |= 8U;
#line 454
  png_write_IEND(png_ptr);
  }
#line 468
  return;
}
}
#line 497 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
png_structp __attribute__((__malloc__))  png_create_write_struct(png_const_charp user_png_ver ,
                                                                 png_voidp error_ptr ,
                                                                 void (*error_fn)(png_structp  ,
                                                                                  png_const_charp  ) ,
                                                                 void (*warn_fn)(png_structp  ,
                                                                                 png_const_charp  ) ) 
{ 
  png_structrp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;

  {
  {
#line 502
  tmp = png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, (void *)0,
                              (png_voidp (*)(png_structp  , png_alloc_size_t  ))((void *)0),
                              (void (*)(png_structp  , png_voidp  ))((void *)0));
#line 502
  png_ptr = (png_structrp )tmp;
  }
#line 518
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 523
    png_ptr->zbuffer_size = (uInt )8192;
#line 529
    png_ptr->zlib_strategy = 1;
#line 530
    png_ptr->zlib_level = -1;
#line 531
    png_ptr->zlib_mem_level = 8;
#line 532
    png_ptr->zlib_window_bits = 15;
#line 533
    png_ptr->zlib_method = 8;
#line 559
    png_ptr->flags |= 2097152U;
#line 566
    png_set_write_fn(png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0),
                     (void (*)(png_structp  ))((void *)0));
    }
  }
#line 569
  return ((png_structp __attribute__((__malloc__))  )png_ptr);
}
}
#line 578 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_rows(png_structrp png_ptr , png_bytepp row , png_uint_32 num_rows ) 
{ 
  png_uint_32 i ;
  png_bytepp rp ;

  {
#line 587
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 588
    return;
  }
#line 591
  i = (png_uint_32 )0;
#line 591
  rp = row;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    if (! (i < num_rows)) {
#line 591
      goto while_break;
    }
    {
#line 593
    png_write_row(png_ptr, (png_const_bytep )*rp);
#line 591
    i ++;
#line 591
    rp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  return;
}
}
#line 600 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_image(png_structrp png_ptr , png_bytepp image___0 ) 
{ 
  png_uint_32 i ;
  int pass ;
  int num_pass ;
  png_bytepp rp ;

  {
#line 607
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 608
    return;
  }
  {
#line 616
  num_pass = png_set_interlace_handling(png_ptr);
#line 621
  pass = 0;
  }
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if (! (pass < num_pass)) {
#line 621
      goto while_break;
    }
#line 624
    i = (png_uint_32 )0;
#line 624
    rp = image___0;
    {
#line 624
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 624
      if (! (i < png_ptr->height)) {
#line 624
        goto while_break___0;
      }
      {
#line 626
      png_write_row(png_ptr, (png_const_bytep )*rp);
#line 624
      i ++;
#line 624
      rp ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 621
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 697 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_row(png_structrp png_ptr , png_const_bytep row ) 
{ 
  png_row_info row_info ;

  {
#line 703
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 704
    return;
  }
#line 710
  if (png_ptr->row_number == 0U) {
#line 710
    if ((int )png_ptr->pass == 0) {
#line 713
      if ((png_ptr->mode & 1024U) == 0U) {
        {
#line 714
        png_error((png_const_structrp )png_ptr, "png_write_info was never called before png_write_row");
        }
      }
      {
#line 754
      png_write_start_row(png_ptr);
      }
    }
  }
#line 759
  if ((int )png_ptr->interlaced != 0) {
#line 759
    if ((png_ptr->transformations & 2U) != 0U) {
      {
#line 764
      if ((int )png_ptr->pass == 0) {
#line 764
        goto case_0;
      }
#line 772
      if ((int )png_ptr->pass == 1) {
#line 772
        goto case_1;
      }
#line 780
      if ((int )png_ptr->pass == 2) {
#line 780
        goto case_2;
      }
#line 788
      if ((int )png_ptr->pass == 3) {
#line 788
        goto case_3;
      }
#line 796
      if ((int )png_ptr->pass == 4) {
#line 796
        goto case_4;
      }
#line 804
      if ((int )png_ptr->pass == 5) {
#line 804
        goto case_5;
      }
#line 812
      if ((int )png_ptr->pass == 6) {
#line 812
        goto case_6;
      }
#line 820
      goto switch_default;
      case_0: /* CIL Label */ 
#line 765
      if ((png_ptr->row_number & 7U) != 0U) {
        {
#line 767
        png_write_finish_row(png_ptr);
        }
#line 768
        return;
      }
#line 770
      goto switch_break;
      case_1: /* CIL Label */ 
#line 773
      if ((png_ptr->row_number & 7U) != 0U) {
        {
#line 775
        png_write_finish_row(png_ptr);
        }
#line 776
        return;
      } else
#line 773
      if (png_ptr->width < 5U) {
        {
#line 775
        png_write_finish_row(png_ptr);
        }
#line 776
        return;
      }
#line 778
      goto switch_break;
      case_2: /* CIL Label */ 
#line 781
      if ((png_ptr->row_number & 7U) != 4U) {
        {
#line 783
        png_write_finish_row(png_ptr);
        }
#line 784
        return;
      }
#line 786
      goto switch_break;
      case_3: /* CIL Label */ 
#line 789
      if ((png_ptr->row_number & 3U) != 0U) {
        {
#line 791
        png_write_finish_row(png_ptr);
        }
#line 792
        return;
      } else
#line 789
      if (png_ptr->width < 3U) {
        {
#line 791
        png_write_finish_row(png_ptr);
        }
#line 792
        return;
      }
#line 794
      goto switch_break;
      case_4: /* CIL Label */ 
#line 797
      if ((png_ptr->row_number & 3U) != 2U) {
        {
#line 799
        png_write_finish_row(png_ptr);
        }
#line 800
        return;
      }
#line 802
      goto switch_break;
      case_5: /* CIL Label */ 
#line 805
      if ((png_ptr->row_number & 1U) != 0U) {
        {
#line 807
        png_write_finish_row(png_ptr);
        }
#line 808
        return;
      } else
#line 805
      if (png_ptr->width < 2U) {
        {
#line 807
        png_write_finish_row(png_ptr);
        }
#line 808
        return;
      }
#line 810
      goto switch_break;
      case_6: /* CIL Label */ 
#line 813
      if ((png_ptr->row_number & 1U) == 0U) {
        {
#line 815
        png_write_finish_row(png_ptr);
        }
#line 816
        return;
      }
#line 818
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 821
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 827
  row_info.color_type = png_ptr->color_type;
#line 828
  row_info.width = png_ptr->usr_width;
#line 829
  row_info.channels = png_ptr->usr_channels;
#line 830
  row_info.bit_depth = png_ptr->usr_bit_depth;
#line 831
  row_info.pixel_depth = (png_byte )((int )row_info.bit_depth * (int )row_info.channels);
#line 832
  if ((int )row_info.pixel_depth >= 8) {
#line 832
    row_info.rowbytes = (png_size_t )row_info.width * ((png_size_t )row_info.pixel_depth >> 3);
  } else {
#line 832
    row_info.rowbytes = ((png_size_t )row_info.width * (png_size_t )row_info.pixel_depth + 7UL) >> 3;
  }
  {
#line 842
  memcpy((void */* __restrict  */)(png_ptr->row_buf + 1), (void const   */* __restrict  */)row,
         row_info.rowbytes);
  }
#line 846
  if (png_ptr->interlaced) {
#line 846
    if ((int )png_ptr->pass < 6) {
#line 846
      if ((png_ptr->transformations & 2U) != 0U) {
        {
#line 849
        png_do_write_interlace(& row_info, png_ptr->row_buf + 1, (int )png_ptr->pass);
        }
#line 851
        if (row_info.width == 0U) {
          {
#line 853
          png_write_finish_row(png_ptr);
          }
#line 854
          return;
        }
      }
    }
  }
#line 868
  if ((int )row_info.pixel_depth != (int )png_ptr->pixel_depth) {
    {
#line 870
    png_error((png_const_structrp )png_ptr, "internal write transform logic error");
    }
  } else
#line 868
  if ((int )row_info.pixel_depth != (int )png_ptr->transformed_pixel_depth) {
    {
#line 870
    png_error((png_const_structrp )png_ptr, "internal write transform logic error");
    }
  }
#line 893
  if ((int )row_info.color_type == 3) {
#line 893
    if (png_ptr->num_palette_max >= 0) {
      {
#line 895
      png_do_check_palette_indexes(png_ptr, & row_info);
      }
    }
  }
  {
#line 899
  png_write_find_filter(png_ptr, & row_info);
  }
#line 901
  if ((unsigned long )png_ptr->write_row_fn != (unsigned long )((void *)0)) {
    {
#line 902
    (*(png_ptr->write_row_fn))((png_structp )png_ptr, png_ptr->row_number, (int )png_ptr->pass);
    }
  }
#line 903
  return;
}
}
#line 907 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_flush(png_structrp png_ptr , int nrows ) 
{ 


  {
#line 912
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 913
    return;
  }
#line 915
  if (nrows < 0) {
#line 915
    png_ptr->flush_dist = (png_uint_32 )0;
  } else {
#line 915
    png_ptr->flush_dist = (png_uint_32 )nrows;
  }
#line 916
  return;
}
}
#line 919 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_flush(png_structrp png_ptr ) 
{ 


  {
#line 924
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 925
    return;
  }
#line 928
  if (png_ptr->row_number >= png_ptr->num_rows) {
#line 929
    return;
  }
  {
#line 931
  png_compress_IDAT(png_ptr, (png_const_bytep )((void *)0), (png_alloc_size_t )0,
                    2);
#line 932
  png_ptr->flush_rows = (png_uint_32 )0;
#line 933
  png_flush(png_ptr);
  }
#line 934
  return;
}
}
#line 938 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
static void png_write_destroy(png_structrp png_ptr ) 
{ 


  {
#line 944
  if ((png_ptr->flags & 2U) != 0U) {
    {
#line 945
    deflateEnd(& png_ptr->zstream);
    }
  }
  {
#line 948
  png_free_buffer_list(png_ptr, & png_ptr->zbuffer_list);
#line 949
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->row_buf);
#line 950
  png_ptr->row_buf = (png_bytep )((void *)0);
#line 952
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->prev_row);
#line 953
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->try_row);
#line 954
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->tst_row);
#line 955
  png_ptr->prev_row = (png_bytep )((void *)0);
#line 956
  png_ptr->try_row = (png_bytep )((void *)0);
#line 957
  png_ptr->tst_row = (png_bytep )((void *)0);
#line 961
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
#line 962
  png_ptr->chunk_list = (png_bytep )((void *)0);
  }
#line 969
  return;
}
}
#line 978 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_destroy_write_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ) 
{ 
  png_structrp png_ptr ;

  {
#line 983
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 985
    png_ptr = (png_structrp )*png_ptr_ptr;
#line 987
    if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
      {
#line 989
      png_destroy_info_struct((png_const_structrp )png_ptr, info_ptr_ptr);
#line 991
      *png_ptr_ptr = (png_struct *)((void *)0);
#line 992
      png_write_destroy(png_ptr);
#line 993
      png_destroy_png_struct(png_ptr);
      }
    }
  }
#line 996
  return;
}
}
#line 999 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_filter(png_structrp png_ptr , int method , int filters ) 
{ 
  int num_filters ;
  png_alloc_size_t buf_size ;
  png_size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;

  {
#line 1004
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1005
    return;
  }
#line 1013
  if (method == 0) {
    {
#line 1020
    if ((filters & 255) == 7) {
#line 1020
      goto case_7;
    }
#line 1020
    if ((filters & 255) == 6) {
#line 1020
      goto case_7;
    }
#line 1020
    if ((filters & 255) == 5) {
#line 1020
      goto case_7;
    }
#line 1023
    if ((filters & 255) == 0) {
#line 1023
      goto case_0;
    }
#line 1027
    if ((filters & 255) == 1) {
#line 1027
      goto case_1;
    }
#line 1030
    if ((filters & 255) == 2) {
#line 1030
      goto case_2;
    }
#line 1033
    if ((filters & 255) == 3) {
#line 1033
      goto case_3;
    }
#line 1036
    if ((filters & 255) == 4) {
#line 1036
      goto case_4;
    }
#line 1039
    goto switch_default;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    {
#line 1020
    png_app_error((png_const_structrp )png_ptr, "Unknown row filter for method 0");
    }
    case_0: /* CIL Label */ 
#line 1024
    png_ptr->do_filter = (png_byte )8;
#line 1024
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1028
    png_ptr->do_filter = (png_byte )16;
#line 1028
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1031
    png_ptr->do_filter = (png_byte )32;
#line 1031
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1034
    png_ptr->do_filter = (png_byte )64;
#line 1034
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1037
    png_ptr->do_filter = (png_byte )128;
#line 1037
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1040
    png_ptr->do_filter = (png_byte )filters;
#line 1040
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1061
    if ((unsigned long )png_ptr->row_buf != (unsigned long )((void *)0)) {
#line 1070
      if (png_ptr->height == 1U) {
#line 1071
        filters &= -225;
      }
#line 1073
      if (png_ptr->width == 1U) {
#line 1074
        filters &= -209;
      }
#line 1076
      if ((filters & 224) != 0) {
#line 1076
        if ((unsigned long )png_ptr->prev_row == (unsigned long )((void *)0)) {
          {
#line 1082
          png_app_warning((png_const_structrp )png_ptr, "png_set_filter: UP/AVG/PAETH cannot be added after start");
#line 1084
          filters &= -225;
          }
        }
      }
#line 1087
      num_filters = 0;
#line 1089
      if (filters & 16) {
#line 1090
        num_filters ++;
      }
#line 1092
      if (filters & 32) {
#line 1093
        num_filters ++;
      }
#line 1095
      if (filters & 64) {
#line 1096
        num_filters ++;
      }
#line 1098
      if (filters & 128) {
#line 1099
        num_filters ++;
      }
#line 1104
      if ((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth >= 8) {
#line 1104
        tmp = (png_size_t )png_ptr->width * ((png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) >> 3);
      } else {
#line 1104
        tmp = ((png_size_t )png_ptr->width * (png_size_t )((int )png_ptr->usr_channels * (int )png_ptr->usr_bit_depth) + 7UL) >> 3;
      }
#line 1104
      buf_size = tmp + 1UL;
#line 1107
      if ((unsigned long )png_ptr->try_row == (unsigned long )((void *)0)) {
        {
#line 1108
        tmp___0 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1108
        png_ptr->try_row = (png_bytep )tmp___0;
        }
      }
#line 1111
      if (num_filters > 1) {
#line 1113
        if ((unsigned long )png_ptr->tst_row == (unsigned long )((void *)0)) {
          {
#line 1114
          tmp___1 = png_malloc((png_const_structrp )png_ptr, buf_size);
#line 1114
          png_ptr->tst_row = (png_bytep )tmp___1;
          }
        }
      }
    }
#line 1118
    png_ptr->do_filter = (png_byte )filters;
  } else {
    {
#line 1122
    png_error((png_const_structrp )png_ptr, "Unknown custom filter method");
    }
  }
#line 1123
  return;
}
}
#line 1157 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_compression_level(png_structrp png_ptr , int level ) 
{ 


  {
#line 1162
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1163
    return;
  }
#line 1165
  png_ptr->zlib_level = level;
#line 1166
  return;
}
}
#line 1168 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_compression_mem_level(png_structrp png_ptr , int mem_level ) 
{ 


  {
#line 1173
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1174
    return;
  }
#line 1176
  png_ptr->zlib_mem_level = mem_level;
#line 1177
  return;
}
}
#line 1179 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_compression_strategy(png_structrp png_ptr , int strategy ) 
{ 


  {
#line 1184
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1185
    return;
  }
#line 1189
  png_ptr->flags |= 1U;
#line 1190
  png_ptr->zlib_strategy = strategy;
#line 1191
  return;
}
}
#line 1196 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_compression_window_bits(png_structrp png_ptr , int window_bits ) 
{ 


  {
#line 1199
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1200
    return;
  }
#line 1208
  if (window_bits > 15) {
    {
#line 1210
    png_warning((png_const_structrp )png_ptr, "Only compression windows <= 32k supported by PNG");
#line 1211
    window_bits = 15;
    }
  } else
#line 1214
  if (window_bits < 8) {
    {
#line 1216
    png_warning((png_const_structrp )png_ptr, "Only compression windows >= 256 supported by PNG");
#line 1217
    window_bits = 8;
    }
  }
#line 1220
  png_ptr->zlib_window_bits = window_bits;
#line 1221
  return;
}
}
#line 1223 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_compression_method(png_structrp png_ptr , int method ) 
{ 


  {
#line 1228
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1229
    return;
  }
#line 1234
  if (method != 8) {
    {
#line 1235
    png_warning((png_const_structrp )png_ptr, "Only compression method 8 is supported by PNG");
    }
  }
#line 1237
  png_ptr->zlib_method = method;
#line 1238
  return;
}
}
#line 1316 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_set_write_status_fn(png_structrp png_ptr , void (*write_row_fn)(png_structp  ,
                                                                         png_uint_32  ,
                                                                         int  ) ) 
{ 


  {
#line 1319
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1320
    return;
  }
#line 1322
  png_ptr->write_row_fn = write_row_fn;
#line 1323
  return;
}
}
#line 1342 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwrite.c"
void png_write_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) 
{ 


  {
#line 1346
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1347
    return;
  } else
#line 1346
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1347
    return;
  }
#line 1349
  if ((info_ptr->valid & 32768U) == 0U) {
    {
#line 1351
    png_app_error((png_const_structrp )png_ptr, "no rows for png_write_image to write");
    }
#line 1352
    return;
  }
  {
#line 1356
  png_write_info(png_ptr, (png_const_inforp )info_ptr);
  }
#line 1361
  if ((transforms & 32) != 0) {
    {
#line 1365
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_MONO not supported");
    }
  }
#line 1371
  if ((transforms & 64) != 0) {
    {
#line 1376
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SHIFT not supported");
    }
  }
#line 1380
  if ((transforms & 4) != 0) {
    {
#line 1384
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKING not supported");
    }
  }
#line 1388
  if ((transforms & 256) != 0) {
    {
#line 1392
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ALPHA not supported");
    }
  }
#line 1399
  if ((transforms & 6144) != 0) {
    {
#line 1416
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_STRIP_FILLER not supported");
    }
  }
#line 1421
  if ((transforms & 128) != 0) {
    {
#line 1425
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_BGR not supported");
    }
  }
#line 1429
  if ((transforms & 512) != 0) {
    {
#line 1433
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ENDIAN not supported");
    }
  }
#line 1437
  if ((transforms & 8) != 0) {
    {
#line 1441
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKSWAP not supported");
    }
  }
#line 1445
  if ((transforms & 1024) != 0) {
    {
#line 1449
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_ALPHA not supported");
    }
  }
  {
#line 1455
  png_write_image(png_ptr, info_ptr->row_pointers);
#line 1458
  png_write_end(png_ptr, info_ptr);
  }
#line 1461
  return;
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 1056 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
void png_default_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 1061
void png_default_flush(png_structp png_ptr ) ;
#line 32 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwio.c"
void png_write_data(png_structrp png_ptr , png_const_bytep data , png_size_t length ) 
{ 


  {
#line 36
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
    {
#line 37
    (*(png_ptr->write_data_fn))((png_structp )png_ptr, (png_bytep )((png_ptruint )((void const   *)data)),
                                length);
    }
  } else {
    {
#line 41
    png_error((png_const_structrp )png_ptr, "Call to NULL write function");
    }
  }
#line 42
  return;
}
}
#line 50 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwio.c"
void png_default_write_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  png_size_t check ;

  {
#line 55
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 56
    return;
  }
  {
#line 58
  check = fwrite((void const   */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)((png_FILE_p )png_ptr->io_ptr));
  }
#line 60
  if (check != length) {
    {
#line 61
    png_error((png_const_structrp )png_ptr, "Write Error");
    }
  }
#line 62
  return;
}
}
#line 70 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwio.c"
void png_flush(png_structrp png_ptr ) 
{ 


  {
#line 73
  if ((unsigned long )png_ptr->output_flush_fn != (unsigned long )((void *)0)) {
    {
#line 74
    (*(png_ptr->output_flush_fn))((png_structp )png_ptr);
    }
  }
#line 75
  return;
}
}
#line 78 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwio.c"
void png_default_flush(png_structp png_ptr ) 
{ 
  png_FILE_p io_ptr ;

  {
#line 83
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 84
    return;
  }
  {
#line 86
  io_ptr = (png_FILE_p )png_ptr->io_ptr;
#line 87
  fflush(io_ptr);
  }
#line 88
  return;
}
}
#line 121 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngwio.c"
void png_set_write_fn(png_structrp png_ptr , png_voidp io_ptr , void (*write_data_fn)(png_structp  ,
                                                                                      png_bytep  ,
                                                                                      png_size_t  ) ,
                      void (*output_flush_fn)(png_structp  ) ) 
{ 


  {
#line 125
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 126
    return;
  }
#line 128
  png_ptr->io_ptr = io_ptr;
#line 131
  if ((unsigned long )write_data_fn != (unsigned long )((void *)0)) {
#line 132
    png_ptr->write_data_fn = write_data_fn;
  } else {
#line 135
    png_ptr->write_data_fn = & png_default_write_data;
  }
#line 143
  if ((unsigned long )output_flush_fn != (unsigned long )((void *)0)) {
#line 144
    png_ptr->output_flush_fn = output_flush_fn;
  } else {
#line 147
    png_ptr->output_flush_fn = & png_default_flush;
  }
#line 158
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
    {
#line 160
    png_ptr->read_data_fn = (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0);
#line 162
    png_warning((png_const_structrp )png_ptr, "Can\'t set both read_data_fn and write_data_fn in the same structure");
    }
  }
#line 167
  return;
}
}
#line 98 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngtrans.c"
int png_set_interlace_handling(png_structrp png_ptr ) 
{ 


  {
#line 103
  if ((unsigned long )png_ptr != (unsigned long )((png_structrp )0)) {
#line 103
    if ((int )png_ptr->interlaced != 0) {
#line 105
      png_ptr->transformations |= 2U;
#line 106
      return (7);
    }
  }
#line 109
  return (1);
}
}
#line 698 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngtrans.c"
void png_do_check_palette_indexes(png_structrp png_ptr , png_row_infop row_info ) 
{ 
  int padding ;
  png_bytep rp ;
  int i ;
  int i___0 ;

  {
#line 701
  if ((int )png_ptr->num_palette < 1 << (int )row_info->bit_depth) {
#line 701
    if ((int )png_ptr->num_palette > 0) {
#line 710
      padding = (int )((8U - ((unsigned int )row_info->pixel_depth * (row_info->width % 8U)) % 8U) % 8U);
#line 711
      rp = (png_ptr->row_buf + row_info->rowbytes) - 1;
      {
#line 715
      if ((int )row_info->bit_depth == 1) {
#line 715
        goto case_1;
      }
#line 730
      if ((int )row_info->bit_depth == 2) {
#line 730
        goto case_2;
      }
#line 760
      if ((int )row_info->bit_depth == 4) {
#line 760
        goto case_4;
      }
#line 780
      if ((int )row_info->bit_depth == 8) {
#line 780
        goto case_8;
      }
#line 791
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 720
      while (1) {
        while_continue: /* CIL Label */ ;
#line 720
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 720
          goto while_break;
        }
#line 722
        if ((int )*rp >> padding != 0) {
#line 723
          png_ptr->num_palette_max = 1;
        }
#line 724
        padding = 0;
#line 720
        rp --;
      }
      while_break: /* CIL Label */ ;
      }
#line 727
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 732
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 732
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 732
          goto while_break___0;
        }
#line 734
        i = ((int )*rp >> padding) & 3;
#line 736
        if (i > png_ptr->num_palette_max) {
#line 737
          png_ptr->num_palette_max = i;
        }
#line 739
        i = (((int )*rp >> padding) >> 2) & 3;
#line 741
        if (i > png_ptr->num_palette_max) {
#line 742
          png_ptr->num_palette_max = i;
        }
#line 744
        i = (((int )*rp >> padding) >> 4) & 3;
#line 746
        if (i > png_ptr->num_palette_max) {
#line 747
          png_ptr->num_palette_max = i;
        }
#line 749
        i = (((int )*rp >> padding) >> 6) & 3;
#line 751
        if (i > png_ptr->num_palette_max) {
#line 752
          png_ptr->num_palette_max = i;
        }
#line 754
        padding = 0;
#line 732
        rp --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 757
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 762
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 762
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 762
          goto while_break___1;
        }
#line 764
        i___0 = ((int )*rp >> padding) & 15;
#line 766
        if (i___0 > png_ptr->num_palette_max) {
#line 767
          png_ptr->num_palette_max = i___0;
        }
#line 769
        i___0 = (((int )*rp >> padding) >> 4) & 15;
#line 771
        if (i___0 > png_ptr->num_palette_max) {
#line 772
          png_ptr->num_palette_max = i___0;
        }
#line 774
        padding = 0;
#line 762
        rp --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 777
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 782
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 782
        if (! ((unsigned long )rp > (unsigned long )png_ptr->row_buf)) {
#line 782
          goto while_break___2;
        }
#line 784
        if ((int )*rp > png_ptr->num_palette_max) {
#line 785
          png_ptr->num_palette_max = (int )*rp;
        }
#line 782
        rp --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 788
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 792
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 795
  return;
}
}
#line 967 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
void png_set_compression_buffer_size(png_structrp png_ptr , png_size_t size ) ;
#line 1754
png_voidp __attribute__((__malloc__))  png_malloc_warn(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) ;
#line 1761
void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 mask ,
                   int num ) ;
#line 1844
void png_set_benign_errors(png_structrp png_ptr , int allowed ) ;
#line 1886
void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) ;
#line 1961
void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) ;
#line 2042
void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) ;
#line 2051
void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                  png_uint_32 height , int bit_depth , int color_type , int interlace_type ,
                  int compression_type , int filter_type ) ;
#line 2095
void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                  int num_palette ) ;
#line 2104
void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) ;
#line 2177
void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                  int num_trans , png_const_color_16p trans_color ) ;
#line 2310
void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                 int num_chunks_in ) ;
#line 2323
void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_const_unknown_chunkp unknowns ,
                            int num_unknowns ) ;
#line 2335
void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                    int chunk , int location ) ;
#line 2346
void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) ;
#line 2392
void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max , png_uint_32 user_height_max ) ;
#line 2399
void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) ;
#line 2404
void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_malloc_max ) ;
#line 2643
void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) ;
#line 998 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
png_voidp __attribute__((__malloc__))  png_malloc_base(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) ;
#line 1013
png_voidp __attribute__((__malloc__))  png_realloc_array(png_const_structrp png_ptr ,
                                                         png_const_voidp old_array ,
                                                         int old_elements , int add_elements ,
                                                         size_t element_size ) ;
#line 1702
void png_check_IHDR(png_const_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int interlace_type , int compression_type ,
                    int filter_type ) ;
#line 1822
void png_chunk_report(png_const_structrp png_ptr , png_const_charp message , int error___0 ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_16p background ) 
{ 


  {
#line 30
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 31
    return;
  } else
#line 30
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 31
    return;
  } else
#line 30
  if ((unsigned long )background == (unsigned long )((void *)0)) {
#line 31
    return;
  }
#line 33
  info_ptr->background = (png_color_16 )*background;
#line 34
  info_ptr->valid |= 32U;
#line 35
  return;
}
}
#line 209 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_const_uint_16p hist ) 
{ 
  int i ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 217
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 218
    return;
  } else
#line 217
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 218
    return;
  }
#line 220
  if ((int )info_ptr->num_palette == 0) {
    {
#line 223
    png_warning(png_ptr, "Invalid palette size, hIST allocation skipped");
    }
#line 226
    return;
  } else
#line 220
  if ((int )info_ptr->num_palette > 256) {
    {
#line 223
    png_warning(png_ptr, "Invalid palette size, hIST allocation skipped");
    }
#line 226
    return;
  }
  {
#line 229
  png_free_data(png_ptr, info_ptr, 8U, 0);
#line 234
  tmp = png_malloc_warn(png_ptr, 256UL * sizeof(png_uint_16 ));
#line 234
  info_ptr->hist = (png_uint_16p )tmp;
  }
#line 237
  if ((unsigned long )info_ptr->hist == (unsigned long )((void *)0)) {
    {
#line 239
    png_warning(png_ptr, "Insufficient memory for hIST chunk data");
    }
#line 241
    return;
  }
#line 244
  info_ptr->free_me |= 8U;
#line 246
  i = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (i < (int )info_ptr->num_palette)) {
#line 246
      goto while_break;
    }
#line 247
    *(info_ptr->hist + i) = (png_uint_16 )*(hist + i);
#line 246
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  info_ptr->valid |= 64U;
#line 250
  return;
}
}
#line 253 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_IHDR(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 width ,
                  png_uint_32 height , int bit_depth , int color_type , int interlace_type ,
                  int compression_type , int filter_type ) 
{ 


  {
#line 261
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 262
    return;
  } else
#line 261
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 262
    return;
  }
  {
#line 264
  info_ptr->width = width;
#line 265
  info_ptr->height = height;
#line 266
  info_ptr->bit_depth = (png_byte )bit_depth;
#line 267
  info_ptr->color_type = (png_byte )color_type;
#line 268
  info_ptr->compression_type = (png_byte )compression_type;
#line 269
  info_ptr->filter_type = (png_byte )filter_type;
#line 270
  info_ptr->interlace_type = (png_byte )interlace_type;
#line 272
  png_check_IHDR(png_ptr, info_ptr->width, info_ptr->height, (int )info_ptr->bit_depth,
                 (int )info_ptr->color_type, (int )info_ptr->interlace_type, (int )info_ptr->compression_type,
                 (int )info_ptr->filter_type);
  }
#line 276
  if ((int )info_ptr->color_type == 3) {
#line 277
    info_ptr->channels = (png_byte )1;
  } else
#line 279
  if (((int )info_ptr->color_type & 2) != 0) {
#line 280
    info_ptr->channels = (png_byte )3;
  } else {
#line 283
    info_ptr->channels = (png_byte )1;
  }
#line 285
  if (((int )info_ptr->color_type & 4) != 0) {
#line 286
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 288
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 290
  if ((int )info_ptr->pixel_depth >= 8) {
#line 290
    info_ptr->rowbytes = (png_size_t )width * ((png_size_t )info_ptr->pixel_depth >> 3);
  } else {
#line 290
    info_ptr->rowbytes = ((png_size_t )width * (png_size_t )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 291
  return;
}
}
#line 571 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_const_colorp palette ,
                  int num_palette ) 
{ 
  png_uint_32 max_palette_length ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_uint_16 tmp___0 ;

  {
#line 580
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 581
    return;
  } else
#line 580
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 581
    return;
  }
#line 583
  if ((int )info_ptr->color_type == 3) {
#line 583
    max_palette_length = (png_uint_32 )(1 << (int )info_ptr->bit_depth);
  } else {
#line 583
    max_palette_length = (png_uint_32 )256;
  }
#line 586
  if (num_palette < 0) {
#line 586
    goto _L;
  } else
#line 586
  if (num_palette > (int )max_palette_length) {
    _L: /* CIL Label */ 
#line 588
    if ((int )info_ptr->color_type == 3) {
      {
#line 589
      png_error((png_const_structrp )png_ptr, "Invalid palette length");
      }
    } else {
      {
#line 593
      png_warning((png_const_structrp )png_ptr, "Invalid palette length");
      }
#line 595
      return;
    }
  }
#line 599
  if (num_palette > 0) {
#line 599
    if ((unsigned long )palette == (unsigned long )((void *)0)) {
      {
#line 606
      png_error((png_const_structrp )png_ptr, "Invalid palette");
      }
    } else {
#line 599
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 599
  if (num_palette == 0) {
    {
#line 606
    png_error((png_const_structrp )png_ptr, "Invalid palette");
    }
  }
  {
#line 616
  png_free_data((png_const_structrp )png_ptr, info_ptr, 4096U, 0);
#line 622
  tmp = png_calloc((png_const_structrp )png_ptr, 256UL * sizeof(png_color ));
#line 622
  png_ptr->palette = (png_colorp )tmp;
  }
#line 625
  if (num_palette > 0) {
    {
#line 626
    memcpy((void */* __restrict  */)png_ptr->palette, (void const   */* __restrict  */)palette,
           (unsigned long )((unsigned int )num_palette) * sizeof(png_color ));
    }
  }
#line 628
  info_ptr->palette = png_ptr->palette;
#line 629
  tmp___0 = (png_uint_16 )num_palette;
#line 629
  png_ptr->num_palette = tmp___0;
#line 629
  info_ptr->num_palette = tmp___0;
#line 631
  info_ptr->free_me |= 4096U;
#line 633
  info_ptr->valid |= 8U;
#line 634
  return;
}
}
#line 637 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_const_color_8p sig_bit ) 
{ 


  {
#line 643
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 644
    return;
  } else
#line 643
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 644
    return;
  } else
#line 643
  if ((unsigned long )sig_bit == (unsigned long )((void *)0)) {
#line 644
    return;
  }
#line 646
  info_ptr->sig_bit = (png_color_8 )*sig_bit;
#line 647
  info_ptr->valid |= 2U;
#line 648
  return;
}
}
#line 993 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_const_bytep trans_alpha ,
                  int num_trans , png_const_color_16p trans_color ) 
{ 
  png_voidp __attribute__((__malloc__))  tmp ;
  int sample_max ;

  {
#line 999
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1001
    return;
  } else
#line 999
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1001
    return;
  }
#line 1003
  if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
    {
#line 1014
    png_free_data((png_const_structrp )png_ptr, info_ptr, 8192U, 0);
    }
#line 1016
    if (num_trans > 0) {
#line 1016
      if (num_trans <= 256) {
        {
#line 1019
        tmp = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )256);
#line 1019
        info_ptr->trans_alpha = (png_bytep )tmp;
#line 1021
        memcpy((void */* __restrict  */)info_ptr->trans_alpha, (void const   */* __restrict  */)trans_alpha,
               (png_size_t )num_trans);
        }
      }
    }
#line 1023
    png_ptr->trans_alpha = info_ptr->trans_alpha;
  }
#line 1026
  if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1029
    if ((int )info_ptr->bit_depth < 16) {
#line 1031
      sample_max = (1 << (int )info_ptr->bit_depth) - 1;
#line 1033
      if ((int )info_ptr->color_type == 0) {
#line 1033
        if ((int const   )trans_color->gray > (int const   )sample_max) {
          {
#line 1039
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        } else {
#line 1033
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1033
      if ((int )info_ptr->color_type == 2) {
#line 1033
        if ((int const   )trans_color->red > (int const   )sample_max) {
          {
#line 1039
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        } else
#line 1033
        if ((int const   )trans_color->green > (int const   )sample_max) {
          {
#line 1039
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        } else
#line 1033
        if ((int const   )trans_color->blue > (int const   )sample_max) {
          {
#line 1039
          png_warning((png_const_structrp )png_ptr, "tRNS chunk has out-of-range samples for bit_depth");
          }
        }
      }
    }
#line 1044
    info_ptr->trans_color = (png_color_16 )*trans_color;
#line 1046
    if (num_trans == 0) {
#line 1047
      num_trans = 1;
    }
  }
#line 1050
  info_ptr->num_trans = (png_uint_16 )num_trans;
#line 1052
  if (num_trans != 0) {
#line 1054
    info_ptr->valid |= 16U;
#line 1055
    info_ptr->free_me |= 8192U;
  }
#line 1057
  return;
}
}
#line 1162 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
static png_byte check_location(png_const_structrp png_ptr , int location ) 
{ 


  {
#line 1165
  location &= 11;
#line 1171
  if (location == 0) {
#line 1171
    if ((png_ptr->mode & 32768U) == 0U) {
      {
#line 1174
      png_app_warning(png_ptr, "png_set_unknown_chunks now expects a valid location");
#line 1177
      location = (int )((png_byte )(png_ptr->mode & 11U));
      }
    }
  }
#line 1184
  if (location == 0) {
    {
#line 1185
    png_error(png_ptr, "invalid location in png_set_unknown_chunks");
    }
  }
  {
#line 1190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1190
    if (! (location != (location & - location))) {
#line 1190
      goto while_break;
    }
#line 1191
    location &= ~ (location & - location);
  }
  while_break: /* CIL Label */ ;
  }
#line 1196
  return ((png_byte )location);
}
}
#line 1199 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_const_unknown_chunkp unknowns ,
                            int num_unknowns ) 
{ 
  png_unknown_chunkp np ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
#line 1205
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1207
    return;
  } else
#line 1205
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1207
    return;
  } else
#line 1205
  if (num_unknowns <= 0) {
#line 1207
    return;
  } else
#line 1205
  if ((unsigned long )unknowns == (unsigned long )((void *)0)) {
#line 1207
    return;
  }
  {
#line 1239
  tmp = png_realloc_array(png_ptr, (png_const_voidp )info_ptr->unknown_chunks, info_ptr->unknown_chunks_num,
                          num_unknowns, sizeof(*np));
#line 1239
  np = (png_unknown_chunkp )tmp;
  }
#line 1243
  if ((unsigned long )np == (unsigned long )((void *)0)) {
    {
#line 1245
    png_chunk_report(png_ptr, "too many unknown chunks", 1);
    }
#line 1248
    return;
  }
  {
#line 1251
  png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 1252
  info_ptr->unknown_chunks = np;
#line 1253
  info_ptr->free_me |= 512U;
#line 1255
  np += info_ptr->unknown_chunks_num;
  }
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (num_unknowns > 0)) {
#line 1260
      goto while_break;
    }
    {
#line 1262
    memcpy((void */* __restrict  */)(np->name), (void const   */* __restrict  */)(unknowns->name),
           sizeof(np->name));
#line 1263
    np->name[sizeof(np->name) - 1UL] = (png_byte )'\000';
#line 1264
    np->location = check_location(png_ptr, (int )unknowns->location);
    }
#line 1266
    if (unknowns->size == 0UL) {
#line 1268
      np->data = (png_byte *)((void *)0);
#line 1269
      np->size = (png_size_t )0;
    } else {
      {
#line 1274
      tmp___0 = png_malloc_base(png_ptr, (png_alloc_size_t )unknowns->size);
#line 1274
      np->data = (png_byte *)tmp___0;
      }
#line 1277
      if ((unsigned long )np->data == (unsigned long )((void *)0)) {
        {
#line 1279
        png_chunk_report(png_ptr, "unknown chunk: out of memory", 1);
        }
#line 1282
        goto __Cont;
      }
      {
#line 1285
      memcpy((void */* __restrict  */)np->data, (void const   */* __restrict  */)unknowns->data,
             (size_t )unknowns->size);
#line 1286
      np->size = (png_size_t )unknowns->size;
      }
    }
#line 1293
    np ++;
#line 1294
    (info_ptr->unknown_chunks_num) ++;
    __Cont: /* CIL Label */ 
#line 1260
    num_unknowns --;
#line 1260
    unknowns ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1296
  return;
}
}
#line 1298 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_unknown_chunk_location(png_const_structrp png_ptr , png_inforp info_ptr ,
                                    int chunk , int location ) 
{ 


  {
#line 1307
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1307
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1307
      if (chunk >= 0) {
#line 1307
        if (chunk < info_ptr->unknown_chunks_num) {
#line 1310
          if ((location & 11) == 0) {
            {
#line 1312
            png_app_error(png_ptr, "invalid unknown chunk location");
            }
#line 1314
            if (((unsigned int )location & 4U) != 0U) {
#line 1315
              location = 8;
            } else {
#line 1318
              location = 1;
            }
          }
          {
#line 1321
          (info_ptr->unknown_chunks + chunk)->location = check_location(png_ptr, location);
          }
        }
      }
    }
  }
#line 1324
  return;
}
}
#line 1343 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
static unsigned int add_one_chunk(png_bytep list , unsigned int count , png_const_bytep add ,
                                  int keep ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 1351
  i = 0U;
  {
#line 1351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1351
    if (! (i < count)) {
#line 1351
      goto while_break;
    }
    {
#line 1353
    tmp = memcmp((void const   *)list, (void const   *)add, (size_t )4);
    }
#line 1353
    if (tmp == 0) {
#line 1355
      *(list + 4) = (png_byte )keep;
#line 1357
      return (count);
    }
#line 1351
    i ++;
#line 1351
    list += 5;
  }
  while_break: /* CIL Label */ ;
  }
#line 1361
  if (keep != 0) {
    {
#line 1363
    count ++;
#line 1364
    memcpy((void */* __restrict  */)list, (void const   */* __restrict  */)add, (size_t )4);
#line 1365
    *(list + 4) = (png_byte )keep;
    }
  }
#line 1368
  return (count);
}
}
#line 1402 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
static png_byte const   chunks_to_ignore[90]  = 
#line 1402
  {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68, 
        (png_byte const   )'\000',      (png_byte const   )99,      (png_byte const   )72,      (png_byte const   )82, 
        (png_byte const   )77,      (png_byte const   )'\000',      (png_byte const   )101,      (png_byte const   )88, 
        (png_byte const   )73,      (png_byte const   )102,      (png_byte const   )'\000',      (png_byte const   )103, 
        (png_byte const   )65,      (png_byte const   )77,      (png_byte const   )65,      (png_byte const   )'\000', 
        (png_byte const   )104,      (png_byte const   )73,      (png_byte const   )83,      (png_byte const   )84, 
        (png_byte const   )'\000',      (png_byte const   )105,      (png_byte const   )67,      (png_byte const   )67, 
        (png_byte const   )80,      (png_byte const   )'\000',      (png_byte const   )105,      (png_byte const   )84, 
        (png_byte const   )88,      (png_byte const   )116,      (png_byte const   )'\000',      (png_byte const   )111, 
        (png_byte const   )70,      (png_byte const   )70,      (png_byte const   )115,      (png_byte const   )'\000', 
        (png_byte const   )112,      (png_byte const   )67,      (png_byte const   )65,      (png_byte const   )76, 
        (png_byte const   )'\000',      (png_byte const   )112,      (png_byte const   )72,      (png_byte const   )89, 
        (png_byte const   )115,      (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )66, 
        (png_byte const   )73,      (png_byte const   )84,      (png_byte const   )'\000',      (png_byte const   )115, 
        (png_byte const   )67,      (png_byte const   )65,      (png_byte const   )76,      (png_byte const   )'\000', 
        (png_byte const   )115,      (png_byte const   )80,      (png_byte const   )76,      (png_byte const   )84, 
        (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )84,      (png_byte const   )69, 
        (png_byte const   )82,      (png_byte const   )'\000',      (png_byte const   )115,      (png_byte const   )82, 
        (png_byte const   )71,      (png_byte const   )66,      (png_byte const   )'\000',      (png_byte const   )116, 
        (png_byte const   )69,      (png_byte const   )88,      (png_byte const   )116,      (png_byte const   )'\000', 
        (png_byte const   )116,      (png_byte const   )73,      (png_byte const   )77,      (png_byte const   )69, 
        (png_byte const   )'\000',      (png_byte const   )122,      (png_byte const   )84,      (png_byte const   )88, 
        (png_byte const   )116,      (png_byte const   )'\000'};
#line 1371 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_keep_unknown_chunks(png_structrp png_ptr , int keep , png_const_bytep chunk_list ,
                                 int num_chunks_in ) 
{ 
  png_bytep new_list ;
  unsigned int num_chunks ;
  unsigned int old_num_chunks ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_const_bytep inlist ;
  png_bytep outlist ;
  unsigned int i ;

  {
#line 1378
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1379
    return;
  }
#line 1381
  if (keep < 0) {
    {
#line 1383
    png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: invalid keep");
    }
#line 1385
    return;
  } else
#line 1381
  if (keep >= 4) {
    {
#line 1383
    png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: invalid keep");
    }
#line 1385
    return;
  }
#line 1388
  if (num_chunks_in <= 0) {
#line 1390
    png_ptr->unknown_default = keep;
#line 1393
    if (num_chunks_in == 0) {
#line 1394
      return;
    }
  }
#line 1397
  if (num_chunks_in < 0) {
#line 1423
    chunk_list = chunks_to_ignore;
#line 1424
    num_chunks = (unsigned int )sizeof(chunks_to_ignore) / 5U;
  } else {
#line 1429
    if ((unsigned long )chunk_list == (unsigned long )((void *)0)) {
      {
#line 1434
      png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: no chunk list");
      }
#line 1436
      return;
    }
#line 1439
    num_chunks = (unsigned int )num_chunks_in;
  }
#line 1442
  old_num_chunks = png_ptr->num_chunk_list;
#line 1443
  if ((unsigned long )png_ptr->chunk_list == (unsigned long )((void *)0)) {
#line 1444
    old_num_chunks = 0U;
  }
#line 1448
  if (num_chunks + old_num_chunks > 858993459U) {
    {
#line 1450
    png_app_error((png_const_structrp )png_ptr, "png_set_keep_unknown_chunks: too many chunks");
    }
#line 1452
    return;
  }
#line 1459
  if (keep != 0) {
    {
#line 1461
    tmp = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )(5U * (num_chunks + old_num_chunks)));
#line 1461
    new_list = (png_bytep )tmp;
    }
#line 1464
    if (old_num_chunks > 0U) {
      {
#line 1465
      memcpy((void */* __restrict  */)new_list, (void const   */* __restrict  */)png_ptr->chunk_list,
             (size_t )(5U * old_num_chunks));
      }
    }
  } else
#line 1468
  if (old_num_chunks > 0U) {
#line 1469
    new_list = png_ptr->chunk_list;
  } else {
#line 1472
    new_list = (png_bytep )((void *)0);
  }
#line 1479
  if ((unsigned long )new_list != (unsigned long )((void *)0)) {
#line 1485
    i = 0U;
    {
#line 1485
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1485
      if (! (i < num_chunks)) {
#line 1485
        goto while_break;
      }
      {
#line 1487
      old_num_chunks = add_one_chunk(new_list, old_num_chunks, chunk_list + 5U * i,
                                     keep);
#line 1485
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1492
    num_chunks = 0U;
#line 1493
    i = 0U;
#line 1493
    outlist = new_list;
#line 1493
    inlist = (png_const_bytep )outlist;
    {
#line 1493
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1493
      if (! (i < old_num_chunks)) {
#line 1493
        goto while_break___0;
      }
#line 1495
      if (*(inlist + 4)) {
#line 1497
        if ((unsigned long )outlist != (unsigned long )inlist) {
          {
#line 1498
          memcpy((void */* __restrict  */)outlist, (void const   */* __restrict  */)inlist,
                 (size_t )5);
          }
        }
#line 1499
        outlist += 5;
#line 1500
        num_chunks ++;
      }
#line 1493
      i ++;
#line 1493
      inlist += 5;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1505
    if (num_chunks == 0U) {
#line 1507
      if ((unsigned long )png_ptr->chunk_list != (unsigned long )new_list) {
        {
#line 1508
        png_free((png_const_structrp )png_ptr, (png_voidp )new_list);
        }
      }
#line 1510
      new_list = (png_bytep )((void *)0);
    }
  } else {
#line 1515
    num_chunks = 0U;
  }
#line 1517
  png_ptr->num_chunk_list = num_chunks;
#line 1519
  if ((unsigned long )png_ptr->chunk_list != (unsigned long )new_list) {
#line 1521
    if ((unsigned long )png_ptr->chunk_list != (unsigned long )((void *)0)) {
      {
#line 1522
      png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
      }
    }
#line 1524
    png_ptr->chunk_list = new_list;
  }
#line 1526
  return;
}
}
#line 1545 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_rows(png_const_structrp png_ptr , png_inforp info_ptr , png_bytepp row_pointers ) 
{ 


  {
#line 1551
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1552
    return;
  } else
#line 1551
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1552
    return;
  }
#line 1554
  if ((unsigned long )info_ptr->row_pointers != (unsigned long )((void *)0)) {
#line 1554
    if ((unsigned long )info_ptr->row_pointers != (unsigned long )row_pointers) {
      {
#line 1556
      png_free_data(png_ptr, info_ptr, 64U, 0);
      }
    }
  }
#line 1558
  info_ptr->row_pointers = row_pointers;
#line 1560
  if ((unsigned long )row_pointers != (unsigned long )((void *)0)) {
#line 1561
    info_ptr->valid |= 32768U;
  }
#line 1562
  return;
}
}
#line 1565 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_compression_buffer_size(png_structrp png_ptr , png_size_t size ) 
{ 


  {
#line 1568
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1569
    return;
  }
#line 1571
  if (size == 0UL) {
    {
#line 1572
    png_error((png_const_structrp )png_ptr, "invalid compression buffer size");
    }
  } else
#line 1571
  if (size > 2147483647UL) {
    {
#line 1572
    png_error((png_const_structrp )png_ptr, "invalid compression buffer size");
    }
  }
#line 1575
  if ((png_ptr->mode & 32768U) != 0U) {
#line 1577
    png_ptr->IDAT_read_size = (png_uint_32 )size;
#line 1578
    return;
  }
#line 1583
  if ((png_ptr->mode & 32768U) == 0U) {
#line 1585
    if (png_ptr->zowner != 0U) {
      {
#line 1587
      png_warning((png_const_structrp )png_ptr, "Compression buffer size cannot be changed because it is in use");
      }
#line 1590
      return;
    }
#line 1597
    if (size > 4294967295UL) {
      {
#line 1599
      png_warning((png_const_structrp )png_ptr, "Compression buffer size limited to system maximum");
#line 1601
      size = (png_size_t )((uInt )-1);
      }
    }
#line 1605
    if (size < 6UL) {
      {
#line 1610
      png_warning((png_const_structrp )png_ptr, "Compression buffer size cannot be reduced below 6");
      }
#line 1613
      return;
    }
#line 1616
    if ((png_size_t )png_ptr->zbuffer_size != size) {
      {
#line 1618
      png_free_buffer_list(png_ptr, & png_ptr->zbuffer_list);
#line 1619
      png_ptr->zbuffer_size = (uInt )size;
      }
    }
  }
#line 1623
  return;
}
}
#line 1625 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_invalid(png_const_structrp png_ptr , png_inforp info_ptr , int mask ) 
{ 


  {
#line 1628
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1628
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1629
      info_ptr->valid &= (unsigned int )(~ mask);
    }
  }
#line 1630
  return;
}
}
#line 1635 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_user_limits(png_structrp png_ptr , png_uint_32 user_width_max , png_uint_32 user_height_max ) 
{ 


  {
#line 1643
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1644
    return;
  }
#line 1646
  png_ptr->user_width_max = user_width_max;
#line 1647
  png_ptr->user_height_max = user_height_max;
#line 1648
  return;
}
}
#line 1651 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_chunk_cache_max(png_structrp png_ptr , png_uint_32 user_chunk_cache_max ) 
{ 


  {
#line 1654
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1655
    png_ptr->user_chunk_cache_max = user_chunk_cache_max;
  }
#line 1656
  return;
}
}
#line 1659 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_chunk_malloc_max(png_structrp png_ptr , png_alloc_size_t user_chunk_malloc_max ) 
{ 


  {
#line 1663
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1664
    png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
  }
#line 1665
  return;
}
}
#line 1670 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_benign_errors(png_structrp png_ptr , int allowed ) 
{ 


  {
#line 1681
  if (allowed != 0) {
#line 1682
    png_ptr->flags |= 7340032U;
  } else {
#line 1686
    png_ptr->flags &= 4287627263U;
  }
#line 1688
  return;
}
}
#line 1700 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngset.c"
void png_set_check_for_invalid_index(png_structrp png_ptr , int allowed ) 
{ 


  {
#line 1705
  if (allowed > 0) {
#line 1706
    png_ptr->num_palette_max = 0;
  } else {
#line 1709
    png_ptr->num_palette_max = -1;
  }
#line 1710
  return;
}
}
#line 944 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
int png_sig_cmp(png_const_bytep sig , png_size_t start , png_size_t num_to_check ) ;
#line 1809
 __attribute__((__noreturn__)) void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 1825
void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 1840
void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 2575
png_uint_32 png_get_uint_32(png_const_bytep buf ) ;
#line 2576
png_uint_16 png_get_uint_16(png_const_bytep buf ) ;
#line 2577
png_int_32 png_get_int_32(png_const_bytep buf ) ;
#line 2580
png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) ;
#line 1074 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
void png_read_sig(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1078
png_uint_32 png_read_chunk_header(png_structrp png_ptr ) ;
#line 1082
void png_read_data(png_structrp png_ptr , png_bytep data , png_size_t length ) ;
#line 1086
void png_crc_read(png_structrp png_ptr , png_bytep buf , png_uint_32 length ) ;
#line 1090
int png_crc_finish(png_structrp png_ptr , png_uint_32 skip ) ;
#line 1094
int png_crc_error(png_structrp png_ptr ) ;
#line 1264
void png_combine_row(png_const_structrp png_ptr , png_bytep dp , int display ) ;
#line 1274
void png_do_read_interlace(png_row_infop row_info , png_bytep row , int pass , png_uint_32 transformations ) ;
#line 1289
void png_read_filter_row(png_structrp pp , png_row_infop row_info , png_bytep row ,
                         png_const_bytep prev_row , int filter ) ;
#line 1363
void png_read_IDAT_data(png_structrp png_ptr , png_bytep output , png_alloc_size_t avail_out ) ;
#line 1370
void png_read_finish_IDAT(png_structrp png_ptr ) ;
#line 1376
void png_read_finish_row(png_structrp png_ptr ) ;
#line 1382
void png_read_start_row(png_structrp png_ptr ) ;
#line 1385
int png_zlib_inflate(png_structrp png_ptr , int flush ) ;
#line 1433
void png_handle_IHDR(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1435
void png_handle_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1437
void png_handle_IEND(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1441
void png_handle_bKGD(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1461
void png_handle_hIST(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1491
void png_handle_sBIT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1521
void png_handle_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) ;
#line 1530
void png_check_chunk_name(png_const_structrp png_ptr , png_uint_32 const   chunk_name ) ;
#line 1533
void png_check_chunk_length(png_const_structrp png_ptr , png_uint_32 const   length ) ;
#line 1536
void png_handle_unknown(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ,
                        int keep ) ;
#line 1564
void png_init_read_transformations(png_structrp png_ptr ) ;
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
png_uint_32 png_get_uint_31(png_const_structrp png_ptr , png_const_bytep buf ) 
{ 
  png_uint_32 uval ;

  {
#line 24
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 26
  if (uval > 2147483647U) {
    {
#line 27
    png_error(png_ptr, "PNG unsigned integer out of range");
    }
  }
#line 29
  return (uval);
}
}
#line 67 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
png_uint_32 png_get_uint_32(png_const_bytep buf ) 
{ 
  png_uint_32 uval ;

  {
#line 70
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 76
  return (uval);
}
}
#line 84 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
png_int_32 png_get_int_32(png_const_bytep buf ) 
{ 
  png_uint_32 uval ;

  {
#line 87
  uval = ((((png_uint_32 )*buf << 24) + ((png_uint_32 )*(buf + 1) << 16)) + ((png_uint_32 )*(buf + 2) << 8)) + (png_uint_32 )*(buf + 3);
#line 88
  if ((uval & 2147483648U) == 0U) {
#line 89
    return ((png_int_32 )uval);
  }
#line 91
  uval = (uval ^ 4294967295U) + 1U;
#line 92
  if ((uval & 2147483648U) == 0U) {
#line 93
    return (- ((png_int_32 )uval));
  }
#line 98
  return (0);
}
}
#line 102 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
png_uint_16 png_get_uint_16(png_const_bytep buf ) 
{ 
  unsigned int val ;

  {
#line 110
  val = ((unsigned int )*buf << 8) + (unsigned int )*(buf + 1);
#line 114
  return ((png_uint_16 )val);
}
}
#line 120 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_read_sig(png_structrp png_ptr , png_inforp info_ptr ) 
{ 
  png_size_t num_checked ;
  png_size_t num_to_check ;
  int tmp ;
  int tmp___0 ;

  {
#line 126
  if ((int )png_ptr->sig_bytes >= 8) {
#line 127
    return;
  }
  {
#line 129
  num_checked = (png_size_t )png_ptr->sig_bytes;
#line 130
  num_to_check = 8UL - num_checked;
#line 133
  png_ptr->io_state = (png_uint_32 )17;
#line 137
  png_read_data(png_ptr, & info_ptr->signature[num_checked], num_to_check);
#line 138
  png_ptr->sig_bytes = (png_byte )8;
#line 140
  tmp___0 = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check);
  }
#line 140
  if (tmp___0 != 0) {
#line 142
    if (num_checked < 4UL) {
      {
#line 142
      tmp = png_sig_cmp((png_const_bytep )(info_ptr->signature), num_checked, num_to_check - 4UL);
      }
#line 142
      if (tmp) {
        {
#line 144
        png_error((png_const_structrp )png_ptr, "Not a PNG file");
        }
      } else {
        {
#line 146
        png_error((png_const_structrp )png_ptr, "PNG file corrupted by ASCII conversion");
        }
      }
    } else {
      {
#line 146
      png_error((png_const_structrp )png_ptr, "PNG file corrupted by ASCII conversion");
      }
    }
  }
#line 148
  if (num_checked < 3UL) {
#line 149
    png_ptr->mode |= 4096U;
  }
#line 150
  return;
}
}
#line 155 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
png_uint_32 png_read_chunk_header(png_structrp png_ptr ) 
{ 
  png_byte buf[8] ;
  png_uint_32 length ;

  {
  {
#line 162
  png_ptr->io_state = (png_uint_32 )33;
#line 168
  png_read_data(png_ptr, buf, (png_size_t )8);
#line 169
  length = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf));
#line 172
  png_ptr->chunk_name = ((((png_uint_32 )(255 & (int )*((buf + 4) + 0)) << 24) | ((png_uint_32 )(255 & (int )*((buf + 4) + 1)) << 16)) | ((png_uint_32 )(255 & (int )*((buf + 4) + 2)) << 8)) | (png_uint_32 )(255 & (int )*((buf + 4) + 3));
#line 178
  png_reset_crc(png_ptr);
#line 179
  png_calculate_crc(png_ptr, (png_const_bytep )(buf + 4), (png_size_t )4);
#line 182
  png_check_chunk_name((png_const_structrp )png_ptr, (png_uint_32 const   )png_ptr->chunk_name);
#line 185
  png_check_chunk_length((png_const_structrp )png_ptr, (png_uint_32 const   )length);
#line 188
  png_ptr->io_state = (png_uint_32 )65;
  }
#line 191
  return (length);
}
}
#line 195 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_crc_read(png_structrp png_ptr , png_bytep buf , png_uint_32 length ) 
{ 


  {
#line 198
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 199
    return;
  }
  {
#line 201
  png_read_data(png_ptr, buf, (png_size_t )length);
#line 202
  png_calculate_crc(png_ptr, (png_const_bytep )buf, (png_size_t )length);
  }
#line 203
  return;
}
}
#line 210 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
int png_crc_finish(png_structrp png_ptr , png_uint_32 skip ) 
{ 
  png_uint_32 len ;
  png_byte tmpbuf[1024] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (skip > 0U)) {
#line 216
      goto while_break;
    }
#line 221
    len = (png_uint_32 )sizeof(tmpbuf);
#line 222
    if (len > skip) {
#line 223
      len = skip;
    }
    {
#line 224
    skip -= len;
#line 226
    png_crc_read(png_ptr, tmpbuf, len);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 229
  tmp___0 = png_crc_error(png_ptr);
  }
#line 229
  if (tmp___0 != 0) {
#line 231
    if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 231
      tmp = (png_ptr->flags & 512U) == 0U;
    } else {
#line 231
      tmp = (png_ptr->flags & 1024U) != 0U;
    }
#line 231
    if (tmp) {
      {
#line 235
      png_chunk_warning((png_const_structrp )png_ptr, "CRC error");
      }
    } else {
      {
#line 239
      png_chunk_error((png_const_structrp )png_ptr, "CRC error");
      }
    }
#line 241
    return (1);
  }
#line 244
  return (0);
}
}
#line 250 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
int png_crc_error(png_structrp png_ptr ) 
{ 
  png_byte crc_bytes[4] ;
  png_uint_32 crc ;
  int need_crc ;

  {
#line 255
  need_crc = 1;
#line 257
  if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 259
    if ((png_ptr->flags & 768U) == 768U) {
#line 261
      need_crc = 0;
    }
  } else
#line 266
  if ((png_ptr->flags & 2048U) != 0U) {
#line 267
    need_crc = 0;
  }
  {
#line 271
  png_ptr->io_state = (png_uint_32 )129;
#line 275
  png_read_data(png_ptr, crc_bytes, (png_size_t )4);
  }
#line 277
  if (need_crc != 0) {
#line 279
    crc = ((((png_uint_32 )crc_bytes[0] << 24) + ((png_uint_32 )*(crc_bytes + 1) << 16)) + ((png_uint_32 )*(crc_bytes + 2) << 8)) + (png_uint_32 )*(crc_bytes + 3);
#line 280
    return (crc != png_ptr->crc);
  } else {
#line 284
    return (0);
  }
}
}
#line 297 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_bytep png_read_buffer(png_structrp png_ptr , png_alloc_size_t new_size ,
                                 int warn ) 
{ 
  png_bytep buffer___0 ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 300
  buffer___0 = png_ptr->read_buffer;
#line 302
  if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 302
    if (new_size > png_ptr->read_buffer_size) {
      {
#line 304
      png_ptr->read_buffer = (png_bytep )((void *)0);
#line 305
      png_ptr->read_buffer = (png_bytep )((void *)0);
#line 306
      png_ptr->read_buffer_size = (png_alloc_size_t )0;
#line 307
      png_free((png_const_structrp )png_ptr, (png_voidp )buffer___0);
#line 308
      buffer___0 = (png_bytep )((void *)0);
      }
    }
  }
#line 311
  if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
    {
#line 313
    tmp = png_malloc_base((png_const_structrp )png_ptr, new_size);
#line 313
    buffer___0 = (png_bytep )tmp;
    }
#line 315
    if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
      {
#line 317
      memset((void *)buffer___0, 0, new_size);
#line 318
      png_ptr->read_buffer = buffer___0;
#line 319
      png_ptr->read_buffer_size = new_size;
      }
    } else
#line 322
    if (warn < 2) {
#line 324
      if (warn != 0) {
        {
#line 325
        png_chunk_warning((png_const_structrp )png_ptr, "insufficient memory to read chunk");
        }
      } else {
        {
#line 328
        png_chunk_error((png_const_structrp )png_ptr, "insufficient memory to read chunk");
        }
      }
    }
  }
#line 332
  return (buffer___0);
}
}
#line 341 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static int png_inflate_claim(png_structrp png_ptr , png_uint_32 owner ) 
{ 
  char msg[64] ;
  int ret ;
  int window_bits ;

  {
#line 344
  if (png_ptr->zowner != 0U) {
    {
#line 348
    msg[0] = (char )((png_ptr->zowner >> 24) & 255U);
#line 348
    msg[1] = (char )((png_ptr->zowner >> 16) & 255U);
#line 348
    msg[2] = (char )((png_ptr->zowner >> 8) & 255U);
#line 348
    msg[3] = (char )(png_ptr->zowner & 255U);
#line 353
    png_safecat(msg, sizeof(msg), (size_t )4, " using zstream");
#line 355
    png_chunk_warning((png_const_structrp )png_ptr, (png_const_charp )(msg));
#line 356
    png_ptr->zowner = (png_uint_32 )0;
    }
  }
#line 378
  window_bits = 0;
#line 399
  png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 400
  png_ptr->zstream.avail_in = (uInt )0;
#line 401
  png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 402
  png_ptr->zstream.avail_out = (uInt )0;
#line 404
  if ((png_ptr->flags & 2U) != 0U) {
    {
#line 407
    ret = inflateReset2(& png_ptr->zstream, window_bits);
    }
  } else {
    {
#line 416
    ret = inflateInit2_(& png_ptr->zstream, window_bits, "1.2.11-optipng", (int )sizeof(z_stream ));
    }
#line 421
    if (ret == 0) {
#line 422
      png_ptr->flags |= 2U;
    }
  }
#line 432
  if (ret == 0) {
#line 433
    png_ptr->zowner = owner;
  } else {
    {
#line 436
    png_zstream_error(png_ptr, ret);
    }
  }
#line 438
  return (ret);
}
}
#line 453 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
int png_zlib_inflate(png_structrp png_ptr , int flush ) 
{ 
  int tmp ;

  {
#line 456
  if (png_ptr->zstream_start) {
#line 456
    if (png_ptr->zstream.avail_in > 0U) {
#line 458
      if ((int const   )*(png_ptr->zstream.next_in) >> 4 > 7) {
#line 460
        png_ptr->zstream.msg = "invalid window size (libpng)";
#line 461
        return (-3);
      }
#line 464
      png_ptr->zstream_start = (png_byte )0;
    }
  }
  {
#line 467
  tmp = inflate(& png_ptr->zstream, flush);
  }
#line 467
  return (tmp);
}
}
#line 838 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_IHDR(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  png_byte buf[13] ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int compression_type ;
  int filter_type ;
  int interlace_type ;

  {
#line 848
  if ((png_ptr->mode & 1U) != 0U) {
    {
#line 849
    png_chunk_error((png_const_structrp )png_ptr, "out of place");
    }
  }
#line 852
  if (length != 13U) {
    {
#line 853
    png_chunk_error((png_const_structrp )png_ptr, "invalid");
    }
  }
  {
#line 855
  png_ptr->mode |= 1U;
#line 857
  png_crc_read(png_ptr, buf, (png_uint_32 )13);
#line 858
  png_crc_finish(png_ptr, (png_uint_32 )0);
#line 860
  width = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf));
#line 861
  height = png_get_uint_31((png_const_structrp )png_ptr, (png_const_bytep )(buf + 4));
#line 862
  bit_depth = (int )buf[8];
#line 863
  color_type = (int )buf[9];
#line 864
  compression_type = (int )buf[10];
#line 865
  filter_type = (int )buf[11];
#line 866
  interlace_type = (int )buf[12];
#line 869
  png_ptr->width = width;
#line 870
  png_ptr->height = height;
#line 871
  png_ptr->bit_depth = (png_byte )bit_depth;
#line 872
  png_ptr->interlaced = (png_byte )interlace_type;
#line 873
  png_ptr->color_type = (png_byte )color_type;
#line 877
  png_ptr->compression_type = (png_byte )compression_type;
  }
  {
#line 888
  if ((int )png_ptr->color_type == 2) {
#line 888
    goto case_2;
  }
#line 892
  if ((int )png_ptr->color_type == 4) {
#line 892
    goto case_4;
  }
#line 896
  if ((int )png_ptr->color_type == 6) {
#line 896
    goto case_6;
  }
#line 882
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 885
  png_ptr->channels = (png_byte )1;
#line 886
  goto switch_break;
  case_2: /* CIL Label */ 
#line 889
  png_ptr->channels = (png_byte )3;
#line 890
  goto switch_break;
  case_4: /* CIL Label */ 
#line 893
  png_ptr->channels = (png_byte )2;
#line 894
  goto switch_break;
  case_6: /* CIL Label */ 
#line 897
  png_ptr->channels = (png_byte )4;
#line 898
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 902
  png_ptr->pixel_depth = (png_byte )((int )png_ptr->bit_depth * (int )png_ptr->channels);
#line 903
  if ((int )png_ptr->pixel_depth >= 8) {
#line 903
    png_ptr->rowbytes = (png_size_t )png_ptr->width * ((png_size_t )png_ptr->pixel_depth >> 3);
  } else {
#line 903
    png_ptr->rowbytes = ((png_size_t )png_ptr->width * (png_size_t )png_ptr->pixel_depth + 7UL) >> 3;
  }
  {
#line 907
  png_set_IHDR((png_const_structrp )png_ptr, info_ptr, width, height, bit_depth, color_type,
               interlace_type, compression_type, filter_type);
  }
#line 909
  return;
}
}
#line 912 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_PLTE(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  png_color palette[256] ;
  int max_palette_length ;
  int num ;
  int i ;
  png_colorp pal_ptr ;
  png_byte buf[3] ;

  {
#line 923
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 924
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 931
  if ((png_ptr->mode & 2U) != 0U) {
    {
#line 932
    png_chunk_error((png_const_structrp )png_ptr, "duplicate");
    }
  } else
#line 934
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 939
    png_crc_finish(png_ptr, length);
#line 940
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 941
    return;
  }
#line 944
  png_ptr->mode |= 2U;
#line 946
  if (((int )png_ptr->color_type & 2) == 0) {
    {
#line 948
    png_crc_finish(png_ptr, length);
#line 949
    png_chunk_benign_error((png_const_structrp )png_ptr, "ignored in grayscale PNG");
    }
#line 950
    return;
  }
#line 961
  if (length > 768U) {
#line 961
    goto _L;
  } else
#line 961
  if (length % 3U) {
    _L: /* CIL Label */ 
    {
#line 963
    png_crc_finish(png_ptr, length);
    }
#line 965
    if ((int )png_ptr->color_type != 3) {
      {
#line 966
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
    } else {
      {
#line 969
      png_chunk_error((png_const_structrp )png_ptr, "invalid");
      }
    }
#line 971
    return;
  }
#line 975
  num = (int )length / 3;
#line 982
  if ((int )png_ptr->color_type == 3) {
#line 983
    max_palette_length = 1 << (int )png_ptr->bit_depth;
  } else {
#line 985
    max_palette_length = 256;
  }
#line 987
  if (num > max_palette_length) {
#line 988
    num = max_palette_length;
  }
#line 991
  i = 0;
#line 991
  pal_ptr = palette;
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    if (! (i < num)) {
#line 991
      goto while_break;
    }
    {
#line 995
    png_crc_read(png_ptr, buf, (png_uint_32 )3);
#line 996
    pal_ptr->red = buf[0];
#line 997
    pal_ptr->green = buf[1];
#line 998
    pal_ptr->blue = buf[2];
#line 991
    i ++;
#line 991
    pal_ptr ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1022
  png_crc_finish(png_ptr, length - (unsigned int )num * 3U);
#line 1060
  png_set_PLTE(png_ptr, info_ptr, (png_const_colorp )(palette), num);
  }
#line 1072
  if ((int )png_ptr->num_trans > 0) {
#line 1072
    goto _L___0;
  } else
#line 1072
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1072
    if ((info_ptr->valid & 16U) != 0U) {
      _L___0: /* CIL Label */ 
#line 1079
      png_ptr->num_trans = (png_uint_16 )0;
#line 1081
      if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1082
        info_ptr->num_trans = (png_uint_16 )0;
      }
      {
#line 1084
      png_chunk_benign_error((png_const_structrp )png_ptr, "tRNS must be after");
      }
    }
  }
#line 1089
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1089
    if ((info_ptr->valid & 64U) != 0U) {
      {
#line 1090
      png_chunk_benign_error((png_const_structrp )png_ptr, "hIST must be after");
      }
    }
  }
#line 1094
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1094
    if ((info_ptr->valid & 32U) != 0U) {
      {
#line 1095
      png_chunk_benign_error((png_const_structrp )png_ptr, "bKGD must be after");
      }
    }
  }
#line 1097
  return;
}
}
#line 1099 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_IEND(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 


  {
#line 1104
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1106
    png_chunk_error((png_const_structrp )png_ptr, "out of place");
    }
  } else
#line 1104
  if ((png_ptr->mode & 4U) == 0U) {
    {
#line 1106
    png_chunk_error((png_const_structrp )png_ptr, "out of place");
    }
  }
  {
#line 1108
  png_ptr->mode |= 24U;
#line 1110
  png_crc_finish(png_ptr, length);
  }
#line 1112
  if (length != 0U) {
    {
#line 1113
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
  }
#line 1116
  return;
}
}
#line 1157 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_sBIT(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  unsigned int truelen ;
  unsigned int i ;
  png_byte sample_depth ;
  png_byte buf[4] ;
  int tmp ;

  {
#line 1166
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1167
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 1169
  if ((png_ptr->mode & 6U) != 0U) {
    {
#line 1171
    png_crc_finish(png_ptr, length);
#line 1172
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 1173
    return;
  }
#line 1176
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1176
    if ((info_ptr->valid & 2U) != 0U) {
      {
#line 1178
      png_crc_finish(png_ptr, length);
#line 1179
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 1180
      return;
    }
  }
#line 1183
  if ((int )png_ptr->color_type == 3) {
#line 1185
    truelen = 3U;
#line 1186
    sample_depth = (png_byte )8;
  } else {
#line 1191
    truelen = (unsigned int )png_ptr->channels;
#line 1192
    sample_depth = png_ptr->bit_depth;
  }
#line 1195
  if (length != truelen) {
    {
#line 1197
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
#line 1198
    png_crc_finish(png_ptr, length);
    }
#line 1199
    return;
  } else
#line 1195
  if (length > 4U) {
    {
#line 1197
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
#line 1198
    png_crc_finish(png_ptr, length);
    }
#line 1199
    return;
  }
  {
#line 1202
  buf[3] = sample_depth;
#line 1202
  buf[2] = buf[3];
#line 1202
  buf[1] = buf[2];
#line 1202
  buf[0] = buf[1];
#line 1203
  png_crc_read(png_ptr, buf, truelen);
#line 1205
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1205
  if (tmp != 0) {
#line 1206
    return;
  }
#line 1208
  i = 0U;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! (i < truelen)) {
#line 1208
      goto while_break;
    }
#line 1210
    if ((int )buf[i] == 0) {
      {
#line 1212
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1213
      return;
    } else
#line 1210
    if ((int )buf[i] > (int )sample_depth) {
      {
#line 1212
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1213
      return;
    }
#line 1208
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1217
  if (((int )png_ptr->color_type & 2) != 0) {
#line 1219
    png_ptr->sig_bit.red = buf[0];
#line 1220
    png_ptr->sig_bit.green = buf[1];
#line 1221
    png_ptr->sig_bit.blue = buf[2];
#line 1222
    png_ptr->sig_bit.alpha = buf[3];
  } else {
#line 1227
    png_ptr->sig_bit.gray = buf[0];
#line 1228
    png_ptr->sig_bit.red = buf[0];
#line 1229
    png_ptr->sig_bit.green = buf[0];
#line 1230
    png_ptr->sig_bit.blue = buf[0];
#line 1231
    png_ptr->sig_bit.alpha = buf[1];
  }
  {
#line 1234
  png_set_sBIT((png_const_structrp )png_ptr, info_ptr, (png_const_color_8p )(& png_ptr->sig_bit));
  }
#line 1235
  return;
}
}
#line 1817 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_tRNS(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  png_byte readbuf[256] ;
  png_byte buf[2] ;
  png_byte buf___0[6] ;
  int tmp ;

  {
#line 1824
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1825
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 1827
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 1829
    png_crc_finish(png_ptr, length);
#line 1830
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 1831
    return;
  } else
#line 1834
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1834
    if ((info_ptr->valid & 16U) != 0U) {
      {
#line 1836
      png_crc_finish(png_ptr, length);
#line 1837
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 1838
      return;
    }
  }
#line 1841
  if ((int )png_ptr->color_type == 0) {
#line 1845
    if (length != 2U) {
      {
#line 1847
      png_crc_finish(png_ptr, length);
#line 1848
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1849
      return;
    }
    {
#line 1852
    png_crc_read(png_ptr, buf, (png_uint_32 )2);
#line 1853
    png_ptr->num_trans = (png_uint_16 )1;
#line 1854
    png_ptr->trans_color.gray = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
    }
  } else
#line 1857
  if ((int )png_ptr->color_type == 2) {
#line 1861
    if (length != 6U) {
      {
#line 1863
      png_crc_finish(png_ptr, length);
#line 1864
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1865
      return;
    }
    {
#line 1868
    png_crc_read(png_ptr, buf___0, length);
#line 1869
    png_ptr->num_trans = (png_uint_16 )1;
#line 1870
    png_ptr->trans_color.red = (png_uint_16 )(((unsigned int )buf___0[0] << 8) + (unsigned int )*(buf___0 + 1));
#line 1871
    png_ptr->trans_color.green = (png_uint_16 )(((unsigned int )*(buf___0 + 2) << 8) + (unsigned int )*((buf___0 + 2) + 1));
#line 1872
    png_ptr->trans_color.blue = (png_uint_16 )(((unsigned int )*(buf___0 + 4) << 8) + (unsigned int )*((buf___0 + 4) + 1));
    }
  } else
#line 1875
  if ((int )png_ptr->color_type == 3) {
#line 1877
    if ((png_ptr->mode & 2U) == 0U) {
      {
#line 1880
      png_crc_finish(png_ptr, length);
#line 1881
      png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
      }
#line 1882
      return;
    }
#line 1885
    if (length > (unsigned int )png_ptr->num_palette) {
      {
#line 1889
      png_crc_finish(png_ptr, length);
#line 1890
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1891
      return;
    } else
#line 1885
    if (length > 256U) {
      {
#line 1889
      png_crc_finish(png_ptr, length);
#line 1890
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1891
      return;
    } else
#line 1885
    if (length == 0U) {
      {
#line 1889
      png_crc_finish(png_ptr, length);
#line 1890
      png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
      }
#line 1891
      return;
    }
    {
#line 1894
    png_crc_read(png_ptr, readbuf, length);
#line 1895
    png_ptr->num_trans = (png_uint_16 )length;
    }
  } else {
    {
#line 1900
    png_crc_finish(png_ptr, length);
#line 1901
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid with alpha channel");
    }
#line 1902
    return;
  }
  {
#line 1905
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1905
  if (tmp != 0) {
#line 1907
    png_ptr->num_trans = (png_uint_16 )0;
#line 1908
    return;
  }
  {
#line 1915
  png_set_tRNS(png_ptr, info_ptr, (png_const_bytep )(readbuf), (int )png_ptr->num_trans,
               (png_const_color_16p )(& png_ptr->trans_color));
  }
#line 1917
  return;
}
}
#line 1921 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_bKGD(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  unsigned int truelen ;
  png_byte buf[6] ;
  png_color_16 background ;
  int tmp ;

  {
#line 1930
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 1931
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 1933
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 1937
    png_crc_finish(png_ptr, length);
#line 1938
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 1939
    return;
  } else
#line 1933
  if ((int )png_ptr->color_type == 3) {
#line 1933
    if ((png_ptr->mode & 2U) == 0U) {
      {
#line 1937
      png_crc_finish(png_ptr, length);
#line 1938
      png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
      }
#line 1939
      return;
    } else {
#line 1933
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1942
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1942
    if ((info_ptr->valid & 32U) != 0U) {
      {
#line 1944
      png_crc_finish(png_ptr, length);
#line 1945
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 1946
      return;
    }
  }
#line 1949
  if ((int )png_ptr->color_type == 3) {
#line 1950
    truelen = 1U;
  } else
#line 1952
  if (((int )png_ptr->color_type & 2) != 0) {
#line 1953
    truelen = 6U;
  } else {
#line 1956
    truelen = 2U;
  }
#line 1958
  if (length != truelen) {
    {
#line 1960
    png_crc_finish(png_ptr, length);
#line 1961
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
#line 1962
    return;
  }
  {
#line 1965
  png_crc_read(png_ptr, buf, truelen);
#line 1967
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 1967
  if (tmp != 0) {
#line 1968
    return;
  }
#line 1975
  if ((int )png_ptr->color_type == 3) {
#line 1977
    background.index = buf[0];
#line 1979
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1979
      if ((int )info_ptr->num_palette != 0) {
#line 1981
        if ((int )buf[0] >= (int )info_ptr->num_palette) {
          {
#line 1983
          png_chunk_benign_error((png_const_structrp )png_ptr, "invalid index");
          }
#line 1984
          return;
        }
#line 1987
        background.red = (png_uint_16 )(png_ptr->palette + buf[0])->red;
#line 1988
        background.green = (png_uint_16 )(png_ptr->palette + buf[0])->green;
#line 1989
        background.blue = (png_uint_16 )(png_ptr->palette + buf[0])->blue;
      } else {
#line 1993
        background.blue = (png_uint_16 )0;
#line 1993
        background.green = background.blue;
#line 1993
        background.red = background.green;
      }
    } else {
#line 1993
      background.blue = (png_uint_16 )0;
#line 1993
      background.green = background.blue;
#line 1993
      background.red = background.green;
    }
#line 1995
    background.gray = (png_uint_16 )0;
  } else
#line 1998
  if (((int )png_ptr->color_type & 2) == 0) {
#line 2000
    background.index = (png_byte )0;
#line 2001
    background.gray = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2001
    background.blue = background.gray;
#line 2001
    background.green = background.blue;
#line 2001
    background.red = background.green;
  } else {
#line 2009
    background.index = (png_byte )0;
#line 2010
    background.red = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2011
    background.green = (png_uint_16 )(((unsigned int )*(buf + 2) << 8) + (unsigned int )*((buf + 2) + 1));
#line 2012
    background.blue = (png_uint_16 )(((unsigned int )*(buf + 4) << 8) + (unsigned int )*((buf + 4) + 1));
#line 2013
    background.gray = (png_uint_16 )0;
  }
  {
#line 2016
  png_set_bKGD((png_const_structrp )png_ptr, info_ptr, (png_const_color_16p )(& background));
  }
#line 2017
  return;
}
}
#line 2084 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_hIST(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ) 
{ 
  unsigned int num ;
  unsigned int i ;
  png_uint_16 readbuf[256] ;
  png_byte buf[2] ;
  int tmp ;

  {
#line 2092
  if ((png_ptr->mode & 1U) == 0U) {
    {
#line 2093
    png_chunk_error((png_const_structrp )png_ptr, "missing IHDR");
    }
  } else
#line 2095
  if ((png_ptr->mode & 4U) != 0U) {
    {
#line 2098
    png_crc_finish(png_ptr, length);
#line 2099
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 2100
    return;
  } else
#line 2095
  if ((png_ptr->mode & 2U) == 0U) {
    {
#line 2098
    png_crc_finish(png_ptr, length);
#line 2099
    png_chunk_benign_error((png_const_structrp )png_ptr, "out of place");
    }
#line 2100
    return;
  } else
#line 2103
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 2103
    if ((info_ptr->valid & 64U) != 0U) {
      {
#line 2105
      png_crc_finish(png_ptr, length);
#line 2106
      png_chunk_benign_error((png_const_structrp )png_ptr, "duplicate");
      }
#line 2107
      return;
    }
  }
#line 2110
  num = length / 2U;
#line 2112
  if (num != (unsigned int )png_ptr->num_palette) {
    {
#line 2115
    png_crc_finish(png_ptr, length);
#line 2116
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
#line 2117
    return;
  } else
#line 2112
  if (num > 256U) {
    {
#line 2115
    png_crc_finish(png_ptr, length);
#line 2116
    png_chunk_benign_error((png_const_structrp )png_ptr, "invalid");
    }
#line 2117
    return;
  }
#line 2120
  i = 0U;
  {
#line 2120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2120
    if (! (i < num)) {
#line 2120
      goto while_break;
    }
    {
#line 2124
    png_crc_read(png_ptr, buf, (png_uint_32 )2);
#line 2125
    readbuf[i] = (png_uint_16 )(((unsigned int )buf[0] << 8) + (unsigned int )*(buf + 1));
#line 2120
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2128
  tmp = png_crc_finish(png_ptr, (png_uint_32 )0);
  }
#line 2128
  if (tmp != 0) {
#line 2129
    return;
  }
  {
#line 2131
  png_set_hIST((png_const_structrp )png_ptr, info_ptr, (png_const_uint_16p )(readbuf));
  }
#line 2132
  return;
}
}
#line 2845 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static int png_cache_unknown_chunk(png_structrp png_ptr , png_uint_32 length ) 
{ 
  png_alloc_size_t limit ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 2848
  limit = (png_size_t )-1;
#line 2850
  if ((unsigned long )png_ptr->unknown_chunk.data != (unsigned long )((void *)0)) {
    {
#line 2852
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
#line 2853
    png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
    }
  }
#line 2857
  if (png_ptr->user_chunk_malloc_max > 0UL) {
#line 2857
    if (png_ptr->user_chunk_malloc_max < limit) {
#line 2859
      limit = png_ptr->user_chunk_malloc_max;
    }
  }
#line 2866
  if ((png_alloc_size_t )length <= limit) {
#line 2868
    *((char *)(png_ptr->unknown_chunk.name) + 0) = (char )((png_ptr->chunk_name >> 24) & 255U);
#line 2868
    *((char *)(png_ptr->unknown_chunk.name) + 1) = (char )((png_ptr->chunk_name >> 16) & 255U);
#line 2868
    *((char *)(png_ptr->unknown_chunk.name) + 2) = (char )((png_ptr->chunk_name >> 8) & 255U);
#line 2868
    *((char *)(png_ptr->unknown_chunk.name) + 3) = (char )(png_ptr->chunk_name & 255U);
#line 2868
    *((char *)(png_ptr->unknown_chunk.name) + 4) = (char)0;
#line 2870
    png_ptr->unknown_chunk.size = (png_size_t )length;
#line 2872
    png_ptr->unknown_chunk.location = (png_byte )png_ptr->mode;
#line 2874
    if (length == 0U) {
#line 2875
      png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
    } else {
      {
#line 2880
      tmp = png_malloc_warn((png_const_structrp )png_ptr, (png_alloc_size_t )length);
#line 2880
      png_ptr->unknown_chunk.data = (png_byte *)tmp;
      }
    }
  }
#line 2885
  if ((unsigned long )png_ptr->unknown_chunk.data == (unsigned long )((void *)0)) {
#line 2885
    if (length > 0U) {
      {
#line 2888
      png_crc_finish(png_ptr, length);
#line 2889
      png_chunk_benign_error((png_const_structrp )png_ptr, "unknown chunk exceeds memory limits");
      }
#line 2890
      return (0);
    } else {
#line 2885
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2895
    if (length > 0U) {
      {
#line 2896
      png_crc_read(png_ptr, png_ptr->unknown_chunk.data, length);
      }
    }
    {
#line 2897
    png_crc_finish(png_ptr, (png_uint_32 )0);
    }
#line 2898
    return (1);
  }
}
}
#line 2904 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_handle_unknown(png_structrp png_ptr , png_inforp info_ptr , png_uint_32 length ,
                        int keep ) 
{ 
  int handled ;
  int tmp ;

  {
#line 2908
  handled = 0;
#line 3010
  if (keep == 0) {
#line 3011
    keep = png_ptr->unknown_default;
  }
#line 3013
  if (keep == 3) {
#line 3013
    goto _L;
  } else
#line 3013
  if (keep == 2) {
#line 3013
    if (1U & (png_ptr->chunk_name >> 29)) {
      _L: /* CIL Label */ 
      {
#line 3017
      tmp = png_cache_unknown_chunk(png_ptr, length);
      }
#line 3017
      if (tmp == 0) {
#line 3018
        keep = 1;
      }
    } else {
      {
#line 3022
      png_crc_finish(png_ptr, length);
      }
    }
  } else {
    {
#line 3022
    png_crc_finish(png_ptr, length);
    }
  }
#line 3047
  if (keep == 3) {
#line 3047
    goto _L___0;
  } else
#line 3047
  if (keep == 2) {
#line 3047
    if (1U & (png_ptr->chunk_name >> 29)) {
      _L___0: /* CIL Label */ 
      {
#line 3054
      if (png_ptr->user_chunk_cache_max == 2U) {
#line 3054
        goto case_2;
      }
#line 3058
      if (png_ptr->user_chunk_cache_max == 1U) {
#line 3058
        goto case_1;
      }
#line 3067
      if (png_ptr->user_chunk_cache_max == 0U) {
#line 3067
        goto case_0;
      }
#line 3064
      goto switch_default;
      case_2: /* CIL Label */ 
      {
#line 3055
      png_ptr->user_chunk_cache_max = (png_uint_32 )1;
#line 3056
      png_chunk_benign_error((png_const_structrp )png_ptr, "no space in chunk cache");
      }
      case_1: /* CIL Label */ 
#line 3062
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 3065
      (png_ptr->user_chunk_cache_max) --;
      case_0: /* CIL Label */ 
      {
#line 3072
      png_set_unknown_chunks((png_const_structrp )png_ptr, info_ptr, (png_const_unknown_chunkp )(& png_ptr->unknown_chunk),
                             1);
#line 3074
      handled = 1;
      }
#line 3076
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 3088
  if ((unsigned long )png_ptr->unknown_chunk.data != (unsigned long )((void *)0)) {
    {
#line 3089
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
    }
  }
#line 3090
  png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
#line 3100
  if (handled == 0) {
#line 3100
    if (! (1U & (png_ptr->chunk_name >> 29))) {
      {
#line 3101
      png_chunk_error((png_const_structrp )png_ptr, "unhandled critical chunk");
      }
    }
  }
#line 3102
  return;
}
}
#line 3116 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_check_chunk_name(png_const_structrp png_ptr , png_uint_32 const   chunk_name ) 
{ 
  int i ;
  png_uint_32 cn ;
  int c ;

  {
#line 3120
  cn = (png_uint_32 )chunk_name;
#line 3124
  i = 1;
  {
#line 3124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3124
    if (! (i <= 4)) {
#line 3124
      goto while_break;
    }
#line 3126
    c = (int )(cn & 255U);
#line 3128
    if (c < 65) {
      {
#line 3129
      png_chunk_error(png_ptr, "invalid chunk type");
      }
    } else
#line 3128
    if (c > 122) {
      {
#line 3129
      png_chunk_error(png_ptr, "invalid chunk type");
      }
    } else
#line 3128
    if (c > 90) {
#line 3128
      if (c < 97) {
        {
#line 3129
        png_chunk_error(png_ptr, "invalid chunk type");
        }
      }
    }
#line 3131
    cn >>= 8;
#line 3124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3133
  return;
}
}
#line 3135 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_check_chunk_length(png_const_structrp png_ptr , png_uint_32 const   length ) 
{ 
  png_alloc_size_t limit ;
  png_alloc_size_t idat_limit ;
  size_t row_factor ;
  int tmp ;
  int tmp___0 ;

  {
#line 3138
  limit = (png_alloc_size_t )((png_uint_32 )2147483647L);
#line 3141
  if (png_ptr->user_chunk_malloc_max > 0UL) {
#line 3141
    if (png_ptr->user_chunk_malloc_max < (png_alloc_size_t const   )limit) {
#line 3143
      limit = (png_alloc_size_t )png_ptr->user_chunk_malloc_max;
    }
  }
#line 3148
  if (png_ptr->chunk_name == (png_uint_32 const   )((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 3150
    idat_limit = (png_alloc_size_t )((png_uint_32 )2147483647L);
#line 3151
    if ((int const   )png_ptr->bit_depth > 8) {
#line 3151
      tmp = 2;
    } else {
#line 3151
      tmp = 1;
    }
#line 3151
    if (png_ptr->interlaced) {
#line 3151
      tmp___0 = 6;
    } else {
#line 3151
      tmp___0 = 0;
    }
#line 3151
    row_factor = (size_t )(((png_ptr->width * (png_uint_32 const   )png_ptr->channels) * (png_uint_32 const   )tmp + 1U) + (png_uint_32 const   )tmp___0);
#line 3154
    if ((size_t )png_ptr->height > 4294967295UL / row_factor) {
#line 3155
      idat_limit = (png_alloc_size_t )((png_uint_32 )2147483647L);
    } else {
#line 3157
      idat_limit = (size_t )png_ptr->height * row_factor;
    }
#line 3158
    if (row_factor > 32566UL) {
#line 3158
      row_factor = (size_t )32566;
    } else {
#line 3158
      row_factor = row_factor;
    }
#line 3159
    idat_limit += 6UL + 5UL * (idat_limit / row_factor + 1UL);
#line 3160
    if (idat_limit < 2147483647UL) {
#line 3160
      idat_limit = idat_limit;
    } else {
#line 3160
      idat_limit = (png_alloc_size_t )((png_uint_32 )2147483647L);
    }
#line 3161
    if (limit < idat_limit) {
#line 3161
      limit = idat_limit;
    } else {
#line 3161
      limit = limit;
    }
  }
#line 3164
  if ((png_alloc_size_t )length > limit) {
    {
#line 3168
    png_chunk_error(png_ptr, "chunk data is too large");
    }
  }
#line 3170
  return;
}
}
#line 3345 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_uint_32 const   row_mask[2][3][6]  = { { {          (png_uint_32 const   )(((1U << 1) - 1U) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) << 4) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) + (((1U << 1) - 1U) << 4)) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 2) + (((1U << 1) - 1U) << 6)) * 16843009U), 
                (png_uint_32 const   )((((((1U << 1) - 1U) + (((1U << 1) - 1U) << 2)) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 6)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 1) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 7)) * 16843009U)}, 
     {          (png_uint_32 const   )(((1U << 2) - 1U) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) << 8) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 4) + (((1U << 2) - 1U) << 12)) * 65537U), 
                (png_uint_32 const   )((((((1U << 2) - 1U) + (((1U << 2) - 1U) << 4)) + (((1U << 2) - 1U) << 8)) + (((1U << 2) - 1U) << 12)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 14)) * 65537U)}, 
     {          (png_uint_32 const   )((1U << 4) - 1U),          (png_uint_32 const   )(((1U << 4) - 1U) << 16),          (png_uint_32 const   )(((1U << 4) - 1U) + (((1U << 4) - 1U) << 16)),          (png_uint_32 const   )((((1U << 4) - 1U) << 8) + (((1U << 4) - 1U) << 24)), 
                (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28))}}, 
   { {          (png_uint_32 const   )((((1U << 1) - 1U) << 7) * 16843009U),          (png_uint_32 const   )((((1U << 1) - 1U) << 3) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 7) + (((1U << 1) - 1U) << 3)) * 16843009U),          (png_uint_32 const   )(((((1U << 1) - 1U) << 5) + (((1U << 1) - 1U) << 1)) * 16843009U), 
                (png_uint_32 const   )(((((((1U << 1) - 1U) << 7) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 1)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 6) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 2)) + ((1U << 1) - 1U)) * 16843009U)}, 
     {          (png_uint_32 const   )((((1U << 2) - 1U) << 6) * 65537U),          (png_uint_32 const   )((((1U << 2) - 1U) << 14) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 6) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 10)) * 65537U), 
                (png_uint_32 const   )(((((((1U << 2) - 1U) << 6) + (((1U << 2) - 1U) << 2)) + (((1U << 2) - 1U) << 14)) + (((1U << 2) - 1U) << 10)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 8)) * 65537U)}, 
     {          (png_uint_32 const   )(((1U << 4) - 1U) << 4),          (png_uint_32 const   )(((1U << 4) - 1U) << 20),          (png_uint_32 const   )((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 20)),          (png_uint_32 const   )((((1U << 4) - 1U) << 12) + (((1U << 4) - 1U) << 28)), 
                (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24))}}};
#line 3356 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_uint_32 const   display_mask[2][3][3]  = { { {          (png_uint_32 const   )(((((((1U << 1) - 1U) << 4) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 6)) + (((1U << 1) - 1U) << 7)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 2) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 6)) + (((1U << 1) - 1U) << 7)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 1) + (((1U << 1) - 1U) << 3)) + (((1U << 1) - 1U) << 5)) + (((1U << 1) - 1U) << 7)) * 16843009U)}, 
     {          (png_uint_32 const   )(((((((1U << 2) - 1U) << 8) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 14)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + (((1U << 2) - 1U) << 6)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 14)) * 65537U)}, 
     {          (png_uint_32 const   )((((((1U << 4) - 1U) << 16) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 24)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 8) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 24)) + (((1U << 4) - 1U) << 28)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 4) + (((1U << 4) - 1U) << 12)) + (((1U << 4) - 1U) << 20)) + (((1U << 4) - 1U) << 28))}}, 
   { {          (png_uint_32 const   )(((((((1U << 1) - 1U) << 3) + (((1U << 1) - 1U) << 2)) + (((1U << 1) - 1U) << 1)) + ((1U << 1) - 1U)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 5) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 1)) + ((1U << 1) - 1U)) * 16843009U),          (png_uint_32 const   )(((((((1U << 1) - 1U) << 6) + (((1U << 1) - 1U) << 4)) + (((1U << 1) - 1U) << 2)) + ((1U << 1) - 1U)) * 16843009U)}, 
     {          (png_uint_32 const   )(((((((1U << 2) - 1U) << 14) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 2) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 10)) + (((1U << 2) - 1U) << 8)) * 65537U),          (png_uint_32 const   )(((((((1U << 2) - 1U) << 4) + ((1U << 2) - 1U)) + (((1U << 2) - 1U) << 12)) + (((1U << 2) - 1U) << 8)) * 65537U)}, 
     {          (png_uint_32 const   )((((((1U << 4) - 1U) << 20) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 28)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )((((((1U << 4) - 1U) << 12) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 28)) + (((1U << 4) - 1U) << 24)),          (png_uint_32 const   )(((((1U << 4) - 1U) + (((1U << 4) - 1U) << 8)) + (((1U << 4) - 1U) << 16)) + (((1U << 4) - 1U) << 24))}}};
#line 3179 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_combine_row(png_const_structrp png_ptr , png_bytep dp , int display ) 
{ 
  unsigned int pixel_depth ;
  png_const_bytep sp___0 ;
  png_alloc_size_t row_width ;
  unsigned int pass ;
  png_bytep end_ptr ;
  png_byte end_byte ;
  unsigned int end_mask ;
  png_size_t tmp ;
  png_size_t tmp___0 ;
  png_uint_32 pixels_per_byte ;
  png_uint_32 mask ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  png_uint_32 m ;
  unsigned int bytes_to_copy ;
  unsigned int bytes_to_jump ;
  unsigned int offset ;
  png_uint_32p dp32 ;
  png_const_uint_32p sp32 ;
  size_t skip ;
  size_t c ;
  png_uint_32p tmp___5 ;
  png_const_uint_32p tmp___6 ;
  png_bytep tmp___7 ;
  png_const_bytep tmp___8 ;
  png_uint_16p dp16 ;
  png_const_uint_16p sp16 ;
  size_t skip___0 ;
  size_t c___0 ;
  png_uint_16p tmp___9 ;
  png_const_uint_16p tmp___10 ;
  png_bytep tmp___11 ;
  png_const_bytep tmp___12 ;
  png_size_t tmp___13 ;

  {
#line 3182
  pixel_depth = (unsigned int )png_ptr->transformed_pixel_depth;
#line 3183
  sp___0 = (png_const_bytep )(png_ptr->row_buf + 1);
#line 3184
  row_width = (png_alloc_size_t )png_ptr->width;
#line 3185
  pass = (unsigned int )png_ptr->pass;
#line 3186
  end_ptr = (png_bytep )0;
#line 3187
  end_byte = (png_byte )0;
#line 3195
  if (pixel_depth == 0U) {
    {
#line 3196
    png_error(png_ptr, "internal row logic error");
    }
  }
#line 3202
  if (png_ptr->info_rowbytes != 0UL) {
#line 3202
    if (pixel_depth >= 8U) {
#line 3202
      tmp = row_width * ((png_size_t )pixel_depth >> 3);
    } else {
#line 3202
      tmp = (row_width * (png_size_t )pixel_depth + 7UL) >> 3;
    }
#line 3202
    if (png_ptr->info_rowbytes != (png_size_t const   )tmp) {
      {
#line 3204
      png_error(png_ptr, "internal row size calculation error");
      }
    }
  }
#line 3207
  if (row_width == 0UL) {
    {
#line 3208
    png_error(png_ptr, "internal row width error");
    }
  }
#line 3214
  end_mask = (unsigned int )((png_alloc_size_t )pixel_depth * row_width & 7UL);
#line 3215
  if (end_mask != 0U) {
#line 3218
    if (pixel_depth >= 8U) {
#line 3218
      tmp___0 = row_width * ((png_size_t )pixel_depth >> 3);
    } else {
#line 3218
      tmp___0 = (row_width * (png_size_t )pixel_depth + 7UL) >> 3;
    }
#line 3218
    end_ptr = (dp + tmp___0) - 1;
#line 3219
    end_byte = *end_ptr;
#line 3227
    end_mask = (unsigned int )(255 >> end_mask);
  }
#line 3238
  if ((int const   )png_ptr->interlaced != 0) {
#line 3238
    if ((png_ptr->transformations & 2U) != 0U) {
#line 3238
      if (pass < 6U) {
#line 3238
        if (display == 0) {
#line 3238
          goto _L___3;
        } else
#line 3238
        if (display == 1) {
#line 3238
          if ((pass & 1U) != 0U) {
            _L___3: /* CIL Label */ 
#line 3247
            if (row_width <= (png_alloc_size_t )(((1U & pass) << (3U - ((pass + 1U) >> 1))) & 7U)) {
#line 3248
              return;
            }
#line 3250
            if (pixel_depth < 8U) {
#line 3381
              pixels_per_byte = 8U / pixel_depth;
#line 3390
              if (display) {
#line 3390
                if (pixel_depth == 1U) {
#line 3390
                  tmp___2 = 0;
                } else {
#line 3390
                  if (pixel_depth == 2U) {
#line 3390
                    tmp___1 = 1;
                  } else {
#line 3390
                    tmp___1 = 2;
                  }
#line 3390
                  tmp___2 = tmp___1;
                }
#line 3390
                mask = (png_uint_32 )display_mask[1][tmp___2][pass >> 1];
              } else {
#line 3390
                if (pixel_depth == 1U) {
#line 3390
                  tmp___4 = 0;
                } else {
#line 3390
                  if (pixel_depth == 2U) {
#line 3390
                    tmp___3 = 1;
                  } else {
#line 3390
                    tmp___3 = 2;
                  }
#line 3390
                  tmp___4 = tmp___3;
                }
#line 3390
                mask = (png_uint_32 )row_mask[1][tmp___4][pass];
              }
              {
#line 3392
              while (1) {
                while_continue: /* CIL Label */ ;
#line 3400
                m = mask;
#line 3401
                mask = (m >> 8) | (m << 24);
#line 3402
                m &= 255U;
#line 3404
                if (m != 0U) {
#line 3406
                  if (m != 255U) {
#line 3407
                    *dp = (png_byte )(((unsigned int )*dp & ~ m) | ((unsigned int )*sp___0 & m));
                  } else {
#line 3409
                    *dp = (png_byte )*sp___0;
                  }
                }
#line 3416
                if (row_width <= (png_alloc_size_t )pixels_per_byte) {
#line 3417
                  goto while_break;
                }
#line 3419
                row_width -= (png_alloc_size_t )pixels_per_byte;
#line 3420
                dp ++;
#line 3421
                sp___0 ++;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 3430
              if (pixel_depth & 7U) {
                {
#line 3431
                png_error(png_ptr, "invalid user transform pixel depth");
                }
              }
#line 3433
              pixel_depth >>= 3;
#line 3434
              row_width *= (png_alloc_size_t )pixel_depth;
#line 3441
              offset = (((1U & pass) << (3U - ((pass + 1U) >> 1))) & 7U) * pixel_depth;
#line 3443
              row_width -= (png_alloc_size_t )offset;
#line 3444
              dp += offset;
#line 3445
              sp___0 += offset;
#line 3449
              if (display != 0) {
#line 3455
                bytes_to_copy = (unsigned int )(1 << ((6U - pass) >> 1)) * pixel_depth;
#line 3458
                if ((png_alloc_size_t )bytes_to_copy > row_width) {
#line 3459
                  bytes_to_copy = (unsigned int )row_width;
                }
              } else {
#line 3463
                bytes_to_copy = pixel_depth;
              }
#line 3466
              bytes_to_jump = (unsigned int )(1 << ((7U - pass) >> 1)) * pixel_depth;
              {
#line 3478
              if (bytes_to_copy == 1U) {
#line 3478
                goto case_1;
              }
#line 3491
              if (bytes_to_copy == 2U) {
#line 3491
                goto case_2;
              }
#line 3512
              if (bytes_to_copy == 3U) {
#line 3512
                goto case_3;
              }
#line 3528
              goto switch_default;
              case_1: /* CIL Label */ 
              {
#line 3479
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 3481
                *dp = (png_byte )*sp___0;
#line 3483
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3484
                  return;
                }
#line 3486
                dp += bytes_to_jump;
#line 3487
                sp___0 += bytes_to_jump;
#line 3488
                row_width -= (png_alloc_size_t )bytes_to_jump;
              }
              while_break___0: /* CIL Label */ ;
              }
              case_2: /* CIL Label */ 
              {
#line 3495
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 3497
                *(dp + 0) = (png_byte )*(sp___0 + 0);
#line 3497
                *(dp + 1) = (png_byte )*(sp___0 + 1);
#line 3499
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3500
                  return;
                }
#line 3502
                sp___0 += bytes_to_jump;
#line 3503
                dp += bytes_to_jump;
#line 3504
                row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3495
                if (! (row_width > 1UL)) {
#line 3495
                  goto while_break___1;
                }
              }
              while_break___1: /* CIL Label */ ;
              }
#line 3509
              *dp = (png_byte )*sp___0;
#line 3510
              return;
              case_3: /* CIL Label */ 
              {
#line 3516
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 3518
                *(dp + 0) = (png_byte )*(sp___0 + 0);
#line 3518
                *(dp + 1) = (png_byte )*(sp___0 + 1);
#line 3518
                *(dp + 2) = (png_byte )*(sp___0 + 2);
#line 3520
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3521
                  return;
                }
#line 3523
                sp___0 += bytes_to_jump;
#line 3524
                dp += bytes_to_jump;
#line 3525
                row_width -= (png_alloc_size_t )bytes_to_jump;
              }
              while_break___2: /* CIL Label */ ;
              }
              switch_default: /* CIL Label */ 
#line 3535
              if (bytes_to_copy < 16U) {
#line 3535
                if (((int )((png_uint_16 )((char const   *)dp - (char const   *)0)) & (int )((png_uint_16 )(sizeof(png_uint_16 ) - 1UL))) == 0) {
#line 3535
                  if (((int )((png_uint_16 )((char const   *)sp___0 - (char const   *)0)) & (int )((png_uint_16 )(sizeof(png_uint_16 ) - 1UL))) == 0) {
#line 3535
                    if ((unsigned long )bytes_to_copy % sizeof(png_uint_16 ) == 0UL) {
#line 3535
                      if ((unsigned long )bytes_to_jump % sizeof(png_uint_16 ) == 0UL) {
#line 3544
                        if (((png_uint_32 )((char const   *)dp - (char const   *)0) & (png_uint_32 )(sizeof(png_uint_32 ) - 1UL)) == 0U) {
#line 3544
                          if (((png_uint_32 )((char const   *)sp___0 - (char const   *)0) & (png_uint_32 )(sizeof(png_uint_32 ) - 1UL)) == 0U) {
#line 3544
                            if ((unsigned long )bytes_to_copy % sizeof(png_uint_32 ) == 0UL) {
#line 3544
                              if ((unsigned long )bytes_to_jump % sizeof(png_uint_32 ) == 0UL) {
#line 3549
                                dp32 = (png_uint_32p )((void *)dp);
#line 3550
                                sp32 = (png_const_uint_32p )((void const   *)sp___0);
#line 3552
                                skip = (unsigned long )(bytes_to_jump - bytes_to_copy) / sizeof(png_uint_32 );
                                {
#line 3555
                                while (1) {
                                  while_continue___3: /* CIL Label */ ;
#line 3557
                                  c = (size_t )bytes_to_copy;
                                  {
#line 3558
                                  while (1) {
                                    while_continue___4: /* CIL Label */ ;
#line 3560
                                    tmp___5 = dp32;
#line 3560
                                    dp32 ++;
#line 3560
                                    tmp___6 = sp32;
#line 3560
                                    sp32 ++;
#line 3560
                                    *tmp___5 = (png_uint_32 )*tmp___6;
#line 3561
                                    c -= sizeof(png_uint_32 );
#line 3558
                                    if (! (c > 0UL)) {
#line 3558
                                      goto while_break___4;
                                    }
                                  }
                                  while_break___4: /* CIL Label */ ;
                                  }
#line 3565
                                  if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3566
                                    return;
                                  }
#line 3568
                                  dp32 += skip;
#line 3569
                                  sp32 += skip;
#line 3570
                                  row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3555
                                  if (! ((png_alloc_size_t )bytes_to_copy <= row_width)) {
#line 3555
                                    goto while_break___3;
                                  }
                                }
                                while_break___3: /* CIL Label */ ;
                                }
#line 3578
                                dp = (png_bytep )dp32;
#line 3579
                                sp___0 = (png_const_bytep )sp32;
                                {
#line 3580
                                while (1) {
                                  while_continue___5: /* CIL Label */ ;
#line 3581
                                  tmp___7 = dp;
#line 3581
                                  dp ++;
#line 3581
                                  tmp___8 = sp___0;
#line 3581
                                  sp___0 ++;
#line 3581
                                  *tmp___7 = (png_byte )*tmp___8;
#line 3580
                                  row_width --;
#line 3580
                                  if (! (row_width > 0UL)) {
#line 3580
                                    goto while_break___5;
                                  }
                                }
                                while_break___5: /* CIL Label */ ;
                                }
#line 3583
                                return;
                              } else {
#line 3544
                                goto _L___1;
                              }
                            } else {
#line 3544
                              goto _L___1;
                            }
                          } else {
#line 3544
                            goto _L___1;
                          }
                        } else {
                          _L___1: /* CIL Label */ 
#line 3591
                          dp16 = (png_uint_16p )((void *)dp);
#line 3592
                          sp16 = (png_const_uint_16p )((void const   *)sp___0);
#line 3594
                          skip___0 = (unsigned long )(bytes_to_jump - bytes_to_copy) / sizeof(png_uint_16 );
                          {
#line 3597
                          while (1) {
                            while_continue___6: /* CIL Label */ ;
#line 3599
                            c___0 = (size_t )bytes_to_copy;
                            {
#line 3600
                            while (1) {
                              while_continue___7: /* CIL Label */ ;
#line 3602
                              tmp___9 = dp16;
#line 3602
                              dp16 ++;
#line 3602
                              tmp___10 = sp16;
#line 3602
                              sp16 ++;
#line 3602
                              *tmp___9 = (png_uint_16 )*tmp___10;
#line 3603
                              c___0 -= sizeof(png_uint_16 );
#line 3600
                              if (! (c___0 > 0UL)) {
#line 3600
                                goto while_break___7;
                              }
                            }
                            while_break___7: /* CIL Label */ ;
                            }
#line 3607
                            if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3608
                              return;
                            }
#line 3610
                            dp16 += skip___0;
#line 3611
                            sp16 += skip___0;
#line 3612
                            row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3597
                            if (! ((png_alloc_size_t )bytes_to_copy <= row_width)) {
#line 3597
                              goto while_break___6;
                            }
                          }
                          while_break___6: /* CIL Label */ ;
                          }
#line 3617
                          dp = (png_bytep )dp16;
#line 3618
                          sp___0 = (png_const_bytep )sp16;
                          {
#line 3619
                          while (1) {
                            while_continue___8: /* CIL Label */ ;
#line 3620
                            tmp___11 = dp;
#line 3620
                            dp ++;
#line 3620
                            tmp___12 = sp___0;
#line 3620
                            sp___0 ++;
#line 3620
                            *tmp___11 = (png_byte )*tmp___12;
#line 3619
                            row_width --;
#line 3619
                            if (! (row_width > 0UL)) {
#line 3619
                              goto while_break___8;
                            }
                          }
                          while_break___8: /* CIL Label */ ;
                          }
#line 3622
                          return;
                        }
                      }
                    }
                  }
                }
              }
              {
#line 3628
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 3630
                memcpy((void */* __restrict  */)dp, (void const   */* __restrict  */)sp___0,
                       (size_t )bytes_to_copy);
                }
#line 3632
                if (row_width <= (png_alloc_size_t )bytes_to_jump) {
#line 3633
                  return;
                }
#line 3635
                sp___0 += bytes_to_jump;
#line 3636
                dp += bytes_to_jump;
#line 3637
                row_width -= (png_alloc_size_t )bytes_to_jump;
#line 3638
                if ((png_alloc_size_t )bytes_to_copy > row_width) {
#line 3639
                  bytes_to_copy = (unsigned int )row_width;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
              switch_break: /* CIL Label */ ;
              }
            }
          } else {
#line 3238
            goto _L___5;
          }
        } else {
#line 3238
          goto _L___5;
        }
      } else {
#line 3238
        goto _L___5;
      }
    } else {
#line 3238
      goto _L___5;
    }
  } else {
    _L___5: /* CIL Label */ 
#line 3655
    if (pixel_depth >= 8U) {
#line 3655
      tmp___13 = row_width * ((png_size_t )pixel_depth >> 3);
    } else {
#line 3655
      tmp___13 = (row_width * (png_size_t )pixel_depth + 7UL) >> 3;
    }
    {
#line 3655
    memcpy((void */* __restrict  */)dp, (void const   */* __restrict  */)sp___0, tmp___13);
    }
  }
#line 3658
  if ((unsigned long )end_ptr != (unsigned long )((void *)0)) {
#line 3659
    *end_ptr = (png_byte )(((unsigned int )end_byte & end_mask) | ((unsigned int )*end_ptr & ~ end_mask));
  }
#line 3660
  return;
}
}
#line 3669 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static unsigned int const   png_pass_inc___2[7]  = {      (unsigned int const   )8,      (unsigned int const   )8,      (unsigned int const   )4,      (unsigned int const   )4, 
        (unsigned int const   )2,      (unsigned int const   )2,      (unsigned int const   )1};
#line 3663 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_do_read_interlace(png_row_infop row_info , png_bytep row , int pass , png_uint_32 transformations ) 
{ 
  png_uint_32 final_width ;
  png_bytep sp___0 ;
  png_bytep dp ;
  unsigned int sshift ;
  unsigned int dshift ;
  unsigned int s_start ;
  unsigned int s_end ;
  int s_inc ;
  int jstop ;
  png_byte v ;
  png_uint_32 i ;
  int j ;
  unsigned int tmp ;
  png_bytep sp___1 ;
  png_bytep dp___0 ;
  unsigned int sshift___0 ;
  unsigned int dshift___0 ;
  unsigned int s_start___0 ;
  unsigned int s_end___0 ;
  int s_inc___0 ;
  int jstop___0 ;
  png_uint_32 i___0 ;
  png_byte v___0 ;
  int j___0 ;
  unsigned int tmp___0 ;
  png_bytep sp___2 ;
  png_bytep dp___1 ;
  unsigned int sshift___1 ;
  unsigned int dshift___1 ;
  unsigned int s_start___1 ;
  unsigned int s_end___1 ;
  int s_inc___1 ;
  png_uint_32 i___1 ;
  int jstop___1 ;
  png_byte v___1 ;
  int j___1 ;
  unsigned int tmp___1 ;
  png_size_t pixel_bytes ;
  png_bytep sp___3 ;
  png_bytep dp___2 ;
  int jstop___2 ;
  png_uint_32 i___2 ;
  png_byte v___2[8] ;
  int j___2 ;

  {
#line 3672
  if ((unsigned long )row != (unsigned long )((void *)0)) {
#line 3672
    if ((unsigned long )row_info != (unsigned long )((void *)0)) {
#line 3676
      final_width = row_info->width * (png_uint_32 )png_pass_inc___2[pass];
      {
#line 3680
      if ((int )row_info->pixel_depth == 1) {
#line 3680
        goto case_1;
      }
#line 3743
      if ((int )row_info->pixel_depth == 2) {
#line 3743
        goto case_2;
      }
#line 3807
      if ((int )row_info->pixel_depth == 4) {
#line 3807
        goto case_4;
      }
#line 3870
      goto switch_default;
      case_1: /* CIL Label */ 
#line 3682
      sp___0 = row + (png_size_t )((row_info->width - 1U) >> 3);
#line 3683
      dp = row + (png_size_t )((final_width - 1U) >> 3);
#line 3687
      jstop = (int )png_pass_inc___2[pass];
#line 3705
      sshift = 7U - ((row_info->width + 7U) & 7U);
#line 3706
      dshift = 7U - ((final_width + 7U) & 7U);
#line 3707
      s_start = 0U;
#line 3708
      s_end = 7U;
#line 3709
      s_inc = 1;
#line 3712
      i = (png_uint_32 )0;
      {
#line 3712
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3712
        if (! (i < row_info->width)) {
#line 3712
          goto while_break;
        }
#line 3714
        v = (png_byte )(((int )*sp___0 >> sshift) & 1);
#line 3715
        j = 0;
        {
#line 3715
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3715
          if (! (j < jstop)) {
#line 3715
            goto while_break___0;
          }
#line 3717
          tmp = (unsigned int )((int )*dp & (32639 >> (7U - dshift)));
#line 3718
          tmp |= (unsigned int )((int )v << dshift);
#line 3719
          *dp = (png_byte )(tmp & 255U);
#line 3721
          if (dshift == s_end) {
#line 3723
            dshift = s_start;
#line 3724
            dp --;
          } else {
#line 3728
            dshift = (unsigned int )((int )dshift + s_inc);
          }
#line 3715
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 3731
        if (sshift == s_end) {
#line 3733
          sshift = s_start;
#line 3734
          sp___0 --;
        } else {
#line 3738
          sshift = (unsigned int )((int )sshift + s_inc);
        }
#line 3712
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 3740
      goto switch_break;
      case_2: /* CIL Label */ 
#line 3745
      sp___1 = row + ((row_info->width - 1U) >> 2);
#line 3746
      dp___0 = row + ((final_width - 1U) >> 2);
#line 3750
      jstop___0 = (int )png_pass_inc___2[pass];
#line 3766
      sshift___0 = (3U - ((row_info->width + 3U) & 3U)) << 1;
#line 3767
      dshift___0 = (3U - ((final_width + 3U) & 3U)) << 1;
#line 3768
      s_start___0 = 0U;
#line 3769
      s_end___0 = 6U;
#line 3770
      s_inc___0 = 2;
#line 3773
      i___0 = (png_uint_32 )0;
      {
#line 3773
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3773
        if (! (i___0 < row_info->width)) {
#line 3773
          goto while_break___1;
        }
#line 3778
        v___0 = (png_byte )(((int )*sp___1 >> sshift___0) & 3);
#line 3779
        j___0 = 0;
        {
#line 3779
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3779
          if (! (j___0 < jstop___0)) {
#line 3779
            goto while_break___2;
          }
#line 3781
          tmp___0 = (unsigned int )((int )*dp___0 & (16191 >> (6U - dshift___0)));
#line 3782
          tmp___0 |= (unsigned int )((int )v___0 << dshift___0);
#line 3783
          *dp___0 = (png_byte )(tmp___0 & 255U);
#line 3785
          if (dshift___0 == s_end___0) {
#line 3787
            dshift___0 = s_start___0;
#line 3788
            dp___0 --;
          } else {
#line 3792
            dshift___0 = (unsigned int )((int )dshift___0 + s_inc___0);
          }
#line 3779
          j___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3795
        if (sshift___0 == s_end___0) {
#line 3797
          sshift___0 = s_start___0;
#line 3798
          sp___1 --;
        } else {
#line 3802
          sshift___0 = (unsigned int )((int )sshift___0 + s_inc___0);
        }
#line 3773
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3804
      goto switch_break;
      case_4: /* CIL Label */ 
#line 3809
      sp___2 = row + (png_size_t )((row_info->width - 1U) >> 1);
#line 3810
      dp___1 = row + (png_size_t )((final_width - 1U) >> 1);
#line 3815
      jstop___1 = (int )png_pass_inc___2[pass];
#line 3830
      sshift___1 = (1U - ((row_info->width + 1U) & 1U)) << 2;
#line 3831
      dshift___1 = (1U - ((final_width + 1U) & 1U)) << 2;
#line 3832
      s_start___1 = 0U;
#line 3833
      s_end___1 = 4U;
#line 3834
      s_inc___1 = 4;
#line 3837
      i___1 = (png_uint_32 )0;
      {
#line 3837
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3837
        if (! (i___1 < row_info->width)) {
#line 3837
          goto while_break___3;
        }
#line 3839
        v___1 = (png_byte )(((int )*sp___2 >> sshift___1) & 15);
#line 3842
        j___1 = 0;
        {
#line 3842
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 3842
          if (! (j___1 < jstop___1)) {
#line 3842
            goto while_break___4;
          }
#line 3844
          tmp___1 = (unsigned int )((int )*dp___1 & (3855 >> (4U - dshift___1)));
#line 3845
          tmp___1 |= (unsigned int )((int )v___1 << dshift___1);
#line 3846
          *dp___1 = (png_byte )(tmp___1 & 255U);
#line 3848
          if (dshift___1 == s_end___1) {
#line 3850
            dshift___1 = s_start___1;
#line 3851
            dp___1 --;
          } else {
#line 3855
            dshift___1 = (unsigned int )((int )dshift___1 + s_inc___1);
          }
#line 3842
          j___1 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 3858
        if (sshift___1 == s_end___1) {
#line 3860
          sshift___1 = s_start___1;
#line 3861
          sp___2 --;
        } else {
#line 3865
          sshift___1 = (unsigned int )((int )sshift___1 + s_inc___1);
        }
#line 3837
        i___1 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3867
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 3872
      pixel_bytes = (png_size_t )((int )row_info->pixel_depth >> 3);
#line 3874
      sp___3 = row + (png_size_t )(row_info->width - 1U) * pixel_bytes;
#line 3877
      dp___2 = row + (png_size_t )(final_width - 1U) * pixel_bytes;
#line 3879
      jstop___2 = (int )png_pass_inc___2[pass];
#line 3882
      i___2 = (png_uint_32 )0;
      {
#line 3882
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3882
        if (! (i___2 < row_info->width)) {
#line 3882
          goto while_break___5;
        }
        {
#line 3887
        memcpy((void */* __restrict  */)(v___2), (void const   */* __restrict  */)sp___3,
               pixel_bytes);
#line 3889
        j___2 = 0;
        }
        {
#line 3889
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 3889
          if (! (j___2 < jstop___2)) {
#line 3889
            goto while_break___6;
          }
          {
#line 3891
          memcpy((void */* __restrict  */)dp___2, (void const   */* __restrict  */)(v___2),
                 pixel_bytes);
#line 3892
          dp___2 -= pixel_bytes;
#line 3889
          j___2 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
#line 3895
        sp___3 -= pixel_bytes;
#line 3882
        i___2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3897
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 3901
      row_info->width = final_width;
#line 3902
      if ((int )row_info->pixel_depth >= 8) {
#line 3902
        row_info->rowbytes = (png_size_t )final_width * ((png_size_t )row_info->pixel_depth >> 3);
      } else {
#line 3902
        row_info->rowbytes = ((png_size_t )final_width * (png_size_t )row_info->pixel_depth + 7UL) >> 3;
      }
    }
  }
#line 3907
  return;
}
}
#line 3910 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static void png_read_filter_row_sub(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) 
{ 
  png_size_t i ;
  png_size_t istop ;
  unsigned int bpp ;
  png_bytep rp ;

  {
#line 3915
  istop = row_info->rowbytes;
#line 3916
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 3917
  rp = row + bpp;
#line 3921
  i = (png_size_t )bpp;
  {
#line 3921
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3921
    if (! (i < istop)) {
#line 3921
      goto while_break;
    }
#line 3923
    *rp = (png_byte )(((int )*rp + (int )*(rp - bpp)) & 255);
#line 3924
    rp ++;
#line 3921
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3926
  return;
}
}
#line 3928 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static void png_read_filter_row_up(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) 
{ 
  png_size_t i ;
  png_size_t istop ;
  png_bytep rp ;
  png_const_bytep pp ;
  png_const_bytep tmp ;

  {
#line 3933
  istop = row_info->rowbytes;
#line 3934
  rp = row;
#line 3935
  pp = prev_row;
#line 3937
  i = (png_size_t )0;
  {
#line 3937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3937
    if (! (i < istop)) {
#line 3937
      goto while_break;
    }
#line 3939
    tmp = pp;
#line 3939
    pp ++;
#line 3939
    *rp = (png_byte )(((int )*rp + (int )*tmp) & 255);
#line 3940
    rp ++;
#line 3937
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3942
  return;
}
}
#line 3944 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static void png_read_filter_row_avg(png_row_infop row_info , png_bytep row , png_const_bytep prev_row ) 
{ 
  png_size_t i ;
  png_bytep rp ;
  png_const_bytep pp ;
  unsigned int bpp ;
  png_size_t istop ;
  png_const_bytep tmp ;
  png_const_bytep tmp___0 ;

  {
#line 3949
  rp = row;
#line 3950
  pp = prev_row;
#line 3951
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 3952
  istop = row_info->rowbytes - (png_size_t )bpp;
#line 3954
  i = (png_size_t )0;
  {
#line 3954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3954
    if (! (i < (png_size_t )bpp)) {
#line 3954
      goto while_break;
    }
#line 3956
    tmp = pp;
#line 3956
    pp ++;
#line 3956
    *rp = (png_byte )(((int )*rp + (int )*tmp / 2) & 255);
#line 3959
    rp ++;
#line 3954
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3962
  i = (png_size_t )0;
  {
#line 3962
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3962
    if (! (i < istop)) {
#line 3962
      goto while_break___0;
    }
#line 3964
    tmp___0 = pp;
#line 3964
    pp ++;
#line 3964
    *rp = (png_byte )(((int )*rp + (int )((int const   )*tmp___0 + (int const   )*(rp - bpp)) / 2) & 255);
#line 3967
    rp ++;
#line 3962
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3969
  return;
}
}
#line 3971 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static void png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info , png_bytep row ,
                                                  png_const_bytep prev_row ) 
{ 
  png_bytep rp_end ;
  int a ;
  int c ;
  png_const_bytep tmp ;
  png_bytep tmp___0 ;
  int b ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_const_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 3975
  rp_end = row + row_info->rowbytes;
#line 3979
  tmp = prev_row;
#line 3979
  prev_row ++;
#line 3979
  c = (int )*tmp;
#line 3980
  a = (int )*row + c;
#line 3981
  tmp___0 = row;
#line 3981
  row ++;
#line 3981
  *tmp___0 = (png_byte )a;
  {
#line 3984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3984
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 3984
      goto while_break;
    }
#line 3988
    a &= 255;
#line 3989
    tmp___1 = prev_row;
#line 3989
    prev_row ++;
#line 3989
    b = (int )*tmp___1;
#line 3991
    p = b - c;
#line 3992
    pc = a - c;
#line 3999
    if (p < 0) {
#line 3999
      pa = - p;
    } else {
#line 3999
      pa = p;
    }
#line 4000
    if (pc < 0) {
#line 4000
      pb = - pc;
    } else {
#line 4000
      pb = pc;
    }
#line 4001
    if (p + pc < 0) {
#line 4001
      pc = - (p + pc);
    } else {
#line 4001
      pc = p + pc;
    }
#line 4007
    if (pb < pa) {
#line 4009
      pa = pb;
#line 4009
      a = b;
    }
#line 4011
    if (pc < pa) {
#line 4011
      a = c;
    }
#line 4016
    c = b;
#line 4017
    a += (int )*row;
#line 4018
    tmp___2 = row;
#line 4018
    row ++;
#line 4018
    *tmp___2 = (png_byte )a;
  }
  while_break: /* CIL Label */ ;
  }
#line 4020
  return;
}
}
#line 4022 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static void png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info , png_bytep row ,
                                                      png_const_bytep prev_row ) 
{ 
  unsigned int bpp ;
  png_bytep rp_end ;
  int a ;
  png_const_bytep tmp ;
  png_bytep tmp___0 ;
  int a___0 ;
  int b ;
  int c ;
  int pa ;
  int pb ;
  int pc ;
  int p ;
  png_const_bytep tmp___1 ;
  png_bytep tmp___2 ;

  {
#line 4026
  bpp = (unsigned int )(((int )row_info->pixel_depth + 7) >> 3);
#line 4027
  rp_end = row + bpp;
  {
#line 4032
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4032
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 4032
      goto while_break;
    }
#line 4034
    tmp = prev_row;
#line 4034
    prev_row ++;
#line 4034
    a = (int )*row + (int )*tmp;
#line 4035
    tmp___0 = row;
#line 4035
    row ++;
#line 4035
    *tmp___0 = (png_byte )a;
  }
  while_break: /* CIL Label */ ;
  }
#line 4039
  rp_end += row_info->rowbytes - (png_size_t )bpp;
  {
#line 4041
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4041
    if (! ((unsigned long )row < (unsigned long )rp_end)) {
#line 4041
      goto while_break___0;
    }
#line 4045
    c = (int )*(prev_row - bpp);
#line 4046
    a___0 = (int )*(row - bpp);
#line 4047
    tmp___1 = prev_row;
#line 4047
    prev_row ++;
#line 4047
    b = (int )*tmp___1;
#line 4049
    p = b - c;
#line 4050
    pc = a___0 - c;
#line 4057
    if (p < 0) {
#line 4057
      pa = - p;
    } else {
#line 4057
      pa = p;
    }
#line 4058
    if (pc < 0) {
#line 4058
      pb = - pc;
    } else {
#line 4058
      pb = pc;
    }
#line 4059
    if (p + pc < 0) {
#line 4059
      pc = - (p + pc);
    } else {
#line 4059
      pc = p + pc;
    }
#line 4062
    if (pb < pa) {
#line 4064
      pa = pb;
#line 4064
      a___0 = b;
    }
#line 4066
    if (pc < pa) {
#line 4066
      a___0 = c;
    }
#line 4068
    a___0 += (int )*row;
#line 4069
    tmp___2 = row;
#line 4069
    row ++;
#line 4069
    *tmp___2 = (png_byte )a___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4071
  return;
}
}
#line 4073 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static void png_init_filter_functions(png_structrp pp ) 
{ 
  unsigned int bpp ;

  {
#line 4085
  bpp = (unsigned int )(((int )pp->pixel_depth + 7) >> 3);
#line 4087
  pp->read_filter[0] = & png_read_filter_row_sub;
#line 4088
  pp->read_filter[1] = & png_read_filter_row_up;
#line 4089
  pp->read_filter[2] = & png_read_filter_row_avg;
#line 4090
  if (bpp == 1U) {
#line 4091
    pp->read_filter[3] = & png_read_filter_row_paeth_1byte_pixel;
  } else {
#line 4094
    pp->read_filter[3] = & png_read_filter_row_paeth_multibyte_pixel;
  }
#line 4108
  return;
}
}
#line 4110 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_read_filter_row(png_structrp pp , png_row_infop row_info , png_bytep row ,
                         png_const_bytep prev_row , int filter ) 
{ 


  {
#line 4118
  if (filter > 0) {
#line 4118
    if (filter < 5) {
#line 4120
      if ((unsigned long )pp->read_filter[0] == (unsigned long )((void *)0)) {
        {
#line 4121
        png_init_filter_functions(pp);
        }
      }
      {
#line 4123
      (*(pp->read_filter[filter - 1]))(row_info, row, prev_row);
      }
    }
  }
#line 4125
  return;
}
}
#line 4128 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_read_IDAT_data(png_structrp png_ptr , png_bytep output , png_alloc_size_t avail_out ) 
{ 
  int ret ;
  png_byte tmpbuf[1024] ;
  uInt avail_in ;
  png_bytep buffer___0 ;
  uInt out ;

  {
#line 4133
  png_ptr->zstream.next_out = output;
#line 4134
  png_ptr->zstream.avail_out = (uInt )0;
#line 4136
  if ((unsigned long )output == (unsigned long )((void *)0)) {
#line 4137
    avail_out = (png_alloc_size_t )0;
  }
  {
#line 4139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4144
    if (png_ptr->zstream.avail_in == 0U) {
      {
#line 4149
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4149
        if (! (png_ptr->idat_size == 0U)) {
#line 4149
          goto while_break___0;
        }
        {
#line 4151
        png_crc_finish(png_ptr, (png_uint_32 )0);
#line 4153
        png_ptr->idat_size = png_read_chunk_header(png_ptr);
        }
#line 4157
        if (png_ptr->chunk_name != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
          {
#line 4158
          png_error((png_const_structrp )png_ptr, "Not enough image data");
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4161
      avail_in = png_ptr->IDAT_read_size;
#line 4163
      if (avail_in > png_ptr->idat_size) {
#line 4164
        avail_in = png_ptr->idat_size;
      }
      {
#line 4171
      buffer___0 = png_read_buffer(png_ptr, (png_alloc_size_t )avail_in, 0);
#line 4173
      png_crc_read(png_ptr, buffer___0, avail_in);
#line 4174
      png_ptr->idat_size -= avail_in;
#line 4176
      png_ptr->zstream.next_in = (Bytef const   *)buffer___0;
#line 4177
      png_ptr->zstream.avail_in = avail_in;
      }
    }
#line 4181
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4183
      out = (uInt )-1;
#line 4185
      if ((png_alloc_size_t )out > avail_out) {
#line 4186
        out = (uInt )avail_out;
      }
#line 4188
      avail_out -= (png_alloc_size_t )out;
#line 4189
      png_ptr->zstream.avail_out = out;
    } else {
#line 4194
      png_ptr->zstream.next_out = tmpbuf;
#line 4195
      png_ptr->zstream.avail_out = (uInt )sizeof(tmpbuf);
    }
    {
#line 4205
    ret = png_zlib_inflate(png_ptr, 0);
    }
#line 4208
    if ((unsigned long )output != (unsigned long )((void *)0)) {
#line 4209
      avail_out += (png_alloc_size_t )png_ptr->zstream.avail_out;
    } else {
#line 4212
      avail_out += sizeof(tmpbuf) - (unsigned long )png_ptr->zstream.avail_out;
    }
#line 4214
    png_ptr->zstream.avail_out = (uInt )0;
#line 4216
    if (ret == 1) {
#line 4219
      png_ptr->zstream.next_out = (Bytef *)((void *)0);
#line 4221
      png_ptr->mode |= 8U;
#line 4222
      png_ptr->flags |= 8U;
#line 4224
      if (png_ptr->zstream.avail_in > 0U) {
        {
#line 4225
        png_chunk_benign_error((png_const_structrp )png_ptr, "Extra compressed data");
        }
      } else
#line 4224
      if (png_ptr->idat_size > 0U) {
        {
#line 4225
        png_chunk_benign_error((png_const_structrp )png_ptr, "Extra compressed data");
        }
      }
#line 4226
      goto while_break;
    }
#line 4229
    if (ret != 0) {
      {
#line 4231
      png_zstream_error(png_ptr, ret);
      }
#line 4233
      if ((unsigned long )output != (unsigned long )((void *)0)) {
        {
#line 4234
        png_chunk_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
        }
      } else {
        {
#line 4238
        png_chunk_benign_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
        }
#line 4239
        return;
      }
    }
#line 4139
    if (! (avail_out > 0UL)) {
#line 4139
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4244
  if (avail_out > 0UL) {
#line 4249
    if ((unsigned long )output != (unsigned long )((void *)0)) {
      {
#line 4250
      png_error((png_const_structrp )png_ptr, "Not enough image data");
      }
    } else {
      {
#line 4253
      png_chunk_benign_error((png_const_structrp )png_ptr, "Too much image data");
      }
    }
  }
#line 4255
  return;
}
}
#line 4257 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_read_finish_IDAT(png_structrp png_ptr ) 
{ 


  {
#line 4265
  if ((png_ptr->flags & 8U) == 0U) {
    {
#line 4271
    png_read_IDAT_data(png_ptr, (png_bytep )((void *)0), (png_alloc_size_t )0);
#line 4272
    png_ptr->zstream.next_out = (Bytef *)((void *)0);
    }
#line 4277
    if ((png_ptr->flags & 8U) == 0U) {
#line 4279
      png_ptr->mode |= 8U;
#line 4280
      png_ptr->flags |= 8U;
    }
  }
#line 4287
  if (png_ptr->zowner == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
    {
#line 4290
    png_ptr->zstream.next_in = (Bytef const   *)((void *)0);
#line 4291
    png_ptr->zstream.avail_in = (uInt )0;
#line 4294
    png_ptr->zowner = (png_uint_32 )0;
#line 4301
    png_crc_finish(png_ptr, png_ptr->idat_size);
    }
  }
#line 4303
  return;
}
}
#line 4311 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_start___2[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 4314 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_inc___3[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 4317 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_ystart___1[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 4320 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_yinc___1[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 4305 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_read_finish_row(png_structrp png_ptr ) 
{ 


  {
#line 4323
  (png_ptr->row_number) ++;
#line 4324
  if (png_ptr->row_number < png_ptr->num_rows) {
#line 4325
    return;
  }
#line 4327
  if ((int )png_ptr->interlaced != 0) {
    {
#line 4329
    png_ptr->row_number = (png_uint_32 )0;
#line 4334
    memset((void *)png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
    }
    {
#line 4336
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4338
      png_ptr->pass = (png_byte )((int )png_ptr->pass + 1);
#line 4340
      if ((int )png_ptr->pass >= 7) {
#line 4341
        goto while_break;
      }
#line 4343
      png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc___3[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___2[png_ptr->pass]) / (png_uint_32 )png_pass_inc___3[png_ptr->pass];
#line 4348
      if ((png_ptr->transformations & 2U) == 0U) {
#line 4350
        png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___1[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_ystart___1[png_ptr->pass]) / (png_uint_32 )png_pass_yinc___1[png_ptr->pass];
      } else {
#line 4357
        goto while_break;
      }
#line 4336
      if (! (png_ptr->num_rows == 0U)) {
#line 4336
        if (! (png_ptr->iwidth == 0U)) {
#line 4336
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 4361
    if ((int )png_ptr->pass < 7) {
#line 4362
      return;
    }
  }
  {
#line 4366
  png_read_finish_IDAT(png_ptr);
  }
#line 4367
  return;
}
}
#line 4376 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_start___3[7]  = {      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0,      (png_byte const   )2, 
        (png_byte const   )0,      (png_byte const   )1,      (png_byte const   )0};
#line 4379 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_inc___4[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4,      (png_byte const   )4, 
        (png_byte const   )2,      (png_byte const   )2,      (png_byte const   )1};
#line 4382 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_ystart___2[7]  = {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )4,      (png_byte const   )0, 
        (png_byte const   )2,      (png_byte const   )0,      (png_byte const   )1};
#line 4385 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
static png_byte const   png_pass_yinc___2[7]  = {      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )8,      (png_byte const   )4, 
        (png_byte const   )4,      (png_byte const   )2,      (png_byte const   )2};
#line 4370 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrutil.c"
void png_read_start_row(png_structrp png_ptr ) 
{ 
  unsigned int max_pixel_depth ;
  png_size_t row_bytes ;
  png_size_t tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  png_bytep temp ;
  int extra ;
  png_bytep buffer___0 ;
  int tmp___3 ;

  {
  {
#line 4393
  png_init_read_transformations(png_ptr);
  }
#line 4395
  if ((int )png_ptr->interlaced != 0) {
#line 4397
    if ((png_ptr->transformations & 2U) == 0U) {
#line 4398
      png_ptr->num_rows = (((png_ptr->height + (png_uint_32 )png_pass_yinc___2[0]) - 1U) - (png_uint_32 )png_pass_ystart___2[0]) / (png_uint_32 )png_pass_yinc___2[0];
    } else {
#line 4402
      png_ptr->num_rows = png_ptr->height;
    }
#line 4404
    png_ptr->iwidth = (((png_ptr->width + (png_uint_32 )png_pass_inc___4[png_ptr->pass]) - 1U) - (png_uint_32 )png_pass_start___3[png_ptr->pass]) / (png_uint_32 )png_pass_inc___4[png_ptr->pass];
  } else {
#line 4412
    png_ptr->num_rows = png_ptr->height;
#line 4413
    png_ptr->iwidth = png_ptr->width;
  }
#line 4416
  max_pixel_depth = (unsigned int )png_ptr->pixel_depth;
#line 4562
  png_ptr->maximum_pixel_depth = (png_byte )max_pixel_depth;
#line 4563
  png_ptr->transformed_pixel_depth = (png_byte )0;
#line 4568
  row_bytes = (png_size_t )((png_ptr->width + 7U) & 4294967288U);
#line 4572
  if (max_pixel_depth >= 8U) {
#line 4572
    tmp = row_bytes * ((png_size_t )max_pixel_depth >> 3);
  } else {
#line 4572
    tmp = (row_bytes * (png_size_t )max_pixel_depth + 7UL) >> 3;
  }
#line 4572
  row_bytes = (tmp + 1UL) + (png_size_t )((max_pixel_depth + 7U) >> 3U);
#line 4580
  if (row_bytes + 48UL > png_ptr->old_big_row_buf_size) {
    {
#line 4582
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_row_buf);
#line 4583
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_prev_row);
    }
#line 4585
    if ((int )png_ptr->interlaced != 0) {
      {
#line 4586
      tmp___0 = png_calloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4586
      png_ptr->big_row_buf = (png_bytep )tmp___0;
      }
    } else {
      {
#line 4590
      tmp___1 = png_malloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4590
      png_ptr->big_row_buf = (png_bytep )tmp___1;
      }
    }
    {
#line 4592
    tmp___2 = png_malloc((png_const_structrp )png_ptr, row_bytes + 48UL);
#line 4592
    png_ptr->big_prev_row = (png_bytep )tmp___2;
#line 4603
    temp = png_ptr->big_row_buf + 32;
#line 4604
    extra = (int )((temp - (png_bytep )0) & 15L);
#line 4605
    png_ptr->row_buf = (temp - extra) - 1;
#line 4607
    temp = png_ptr->big_prev_row + 32;
#line 4608
    extra = (int )((temp - (png_bytep )0) & 15L);
#line 4609
    png_ptr->prev_row = (temp - extra) - 1;
#line 4617
    png_ptr->old_big_row_buf_size = row_bytes + 48UL;
    }
  }
#line 4625
  if (png_ptr->rowbytes > 0xfffffffffffffffeUL) {
    {
#line 4626
    png_error((png_const_structrp )png_ptr, "Row has too many bytes to allocate in memory");
    }
  }
  {
#line 4628
  memset((void *)png_ptr->prev_row, 0, png_ptr->rowbytes + 1UL);
  }
#line 4642
  if ((unsigned long )png_ptr->read_buffer != (unsigned long )((void *)0)) {
    {
#line 4644
    buffer___0 = png_ptr->read_buffer;
#line 4646
    png_ptr->read_buffer_size = (png_alloc_size_t )0;
#line 4647
    png_ptr->read_buffer = (png_bytep )((void *)0);
#line 4648
    png_free((png_const_structrp )png_ptr, (png_voidp )buffer___0);
    }
  }
  {
#line 4656
  tmp___3 = png_inflate_claim(png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U);
  }
#line 4656
  if (tmp___3 != 0) {
    {
#line 4657
    png_error((png_const_structrp )png_ptr, png_ptr->zstream.msg);
    }
  }
#line 4659
  png_ptr->flags |= 64U;
#line 4660
  return;
}
}
#line 1455 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) ;
#line 1394 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
void png_read_transform_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1555
void png_do_read_transformations(png_structrp png_ptr , png_row_infop row_info ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrtran.c"
void png_set_crc_action(png_structrp png_ptr , int crit_action , int ancil_action ) 
{ 


  {
#line 29
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 30
    return;
  }
  {
#line 35
  if (crit_action == 5) {
#line 35
    goto case_5;
  }
#line 38
  if (crit_action == 3) {
#line 38
    goto case_3;
  }
#line 43
  if (crit_action == 4) {
#line 43
    goto case_4;
  }
#line 49
  if (crit_action == 2) {
#line 49
    goto case_2;
  }
#line 56
  goto switch_default;
  case_5: /* CIL Label */ 
#line 36
  goto switch_break;
  case_3: /* CIL Label */ 
#line 39
  png_ptr->flags &= 4294964223U;
#line 40
  png_ptr->flags |= 1024U;
#line 41
  goto switch_break;
  case_4: /* CIL Label */ 
#line 44
  png_ptr->flags &= 4294964223U;
#line 45
  png_ptr->flags |= 3072U;
#line 47
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 50
  png_warning((png_const_structrp )png_ptr, "Can\'t discard critical data on CRC error");
  }
  switch_default: /* CIL Label */ 
#line 57
  png_ptr->flags &= 4294964223U;
#line 58
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 64
  if (ancil_action == 5) {
#line 64
    goto case_5___0;
  }
#line 67
  if (ancil_action == 3) {
#line 67
    goto case_3___0;
  }
#line 72
  if (ancil_action == 4) {
#line 72
    goto case_4___0;
  }
#line 78
  if (ancil_action == 1) {
#line 78
    goto case_1;
  }
#line 86
  goto switch_default___0;
  case_5___0: /* CIL Label */ 
#line 65
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 68
  png_ptr->flags &= 4294966527U;
#line 69
  png_ptr->flags |= 256U;
#line 70
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 73
  png_ptr->flags &= 4294966527U;
#line 74
  png_ptr->flags |= 768U;
#line 76
  goto switch_break___0;
  case_1: /* CIL Label */ 
#line 79
  png_ptr->flags &= 4294966527U;
#line 80
  png_ptr->flags |= 512U;
#line 81
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 87
  png_ptr->flags &= 4294966527U;
#line 88
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 1105 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrtran.c"
static void png_init_palette_transformations(png_structrp png_ptr ) 
{ 
  int input_has_alpha ;
  int input_has_transparency ;
  int i ;

  {
#line 1116
  input_has_alpha = 0;
#line 1117
  input_has_transparency = 0;
#line 1119
  if ((int )png_ptr->num_trans > 0) {
#line 1124
    i = 0;
    {
#line 1124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1124
      if (! (i < (int )png_ptr->num_trans)) {
#line 1124
        goto while_break;
      }
#line 1126
      if (! ((int )*(png_ptr->trans_alpha + i) == 255)) {
#line 1128
        if ((int )*(png_ptr->trans_alpha + i) == 0) {
#line 1129
          input_has_transparency = 1;
        } else {
#line 1132
          input_has_transparency = 1;
#line 1133
          input_has_alpha = 1;
#line 1134
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 1124
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1140
  if (input_has_alpha == 0) {
#line 1146
    png_ptr->transformations &= 4286578687U;
#line 1147
    png_ptr->flags &= 4294959103U;
#line 1149
    if (input_has_transparency == 0) {
#line 1150
      png_ptr->transformations &= 4294966911U;
    }
  }
#line 1192
  return;
}
}
#line 1194 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrtran.c"
static void png_init_rgb_transformations(png_structrp png_ptr ) 
{ 
  int input_has_alpha ;
  int input_has_transparency ;

  {
#line 1201
  input_has_alpha = ((int )png_ptr->color_type & 4) != 0;
#line 1202
  input_has_transparency = (int )png_ptr->num_trans > 0;
#line 1205
  if (input_has_alpha == 0) {
#line 1216
    if (input_has_transparency == 0) {
#line 1217
      png_ptr->transformations &= 4294966911U;
    }
  }
#line 1277
  return;
}
}
#line 1279 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrtran.c"
void png_init_read_transformations(png_structrp png_ptr ) 
{ 


  {
#line 1482
  if ((int )png_ptr->color_type == 3) {
    {
#line 1483
    png_init_palette_transformations(png_ptr);
    }
  } else {
    {
#line 1486
    png_init_rgb_transformations(png_ptr);
    }
  }
#line 1922
  return;
}
}
#line 1928 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrtran.c"
void png_read_transform_info(png_structrp png_ptr , png_inforp info_ptr ) 
{ 


  {
#line 2068
  if ((int )info_ptr->color_type == 3) {
#line 2069
    info_ptr->channels = (png_byte )1;
  } else
#line 2071
  if (((int )info_ptr->color_type & 2) != 0) {
#line 2072
    info_ptr->channels = (png_byte )3;
  } else {
#line 2075
    info_ptr->channels = (png_byte )1;
  }
#line 2086
  if (((int )info_ptr->color_type & 4) != 0) {
#line 2087
    info_ptr->channels = (png_byte )((int )info_ptr->channels + 1);
  }
#line 2114
  info_ptr->pixel_depth = (png_byte )((int )info_ptr->channels * (int )info_ptr->bit_depth);
#line 2117
  if ((int )info_ptr->pixel_depth >= 8) {
#line 2117
    info_ptr->rowbytes = (png_size_t )info_ptr->width * ((png_size_t )info_ptr->pixel_depth >> 3);
  } else {
#line 2117
    info_ptr->rowbytes = ((png_size_t )info_ptr->width * (png_size_t )info_ptr->pixel_depth + 7UL) >> 3;
  }
#line 2125
  png_ptr->info_rowbytes = info_ptr->rowbytes;
#line 2128
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 2129
    return;
  }
#line 2131
  return;
}
}
#line 4716 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrtran.c"
void png_do_read_transformations(png_structrp png_ptr , png_row_infop row_info ) 
{ 


  {
#line 4721
  if ((unsigned long )png_ptr->row_buf == (unsigned long )((void *)0)) {
    {
#line 4727
    png_error((png_const_structrp )png_ptr, "NULL row buffer");
    }
  }
#line 4736
  if ((png_ptr->flags & 16384U) != 0U) {
#line 4736
    if ((png_ptr->flags & 64U) == 0U) {
      {
#line 4743
      png_error((png_const_structrp )png_ptr, "Uninitialized row");
      }
    }
  }
#line 4947
  if ((int )row_info->color_type == 3) {
#line 4947
    if (png_ptr->num_palette_max >= 0) {
      {
#line 4949
      png_do_check_palette_indexes(png_ptr, row_info);
      }
    }
  }
#line 5007
  return;
}
}
#line 1622 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    png_size_t  ) ) ;
#line 1048 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
void png_default_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) ;
#line 31 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrio.c"
void png_read_data(png_structrp png_ptr , png_bytep data , png_size_t length ) 
{ 


  {
#line 36
  if ((unsigned long )png_ptr->read_data_fn != (unsigned long )((void *)0)) {
    {
#line 37
    (*(png_ptr->read_data_fn))((png_structp )png_ptr, data, length);
    }
  } else {
    {
#line 40
    png_error((png_const_structrp )png_ptr, "Call to NULL read function");
    }
  }
#line 41
  return;
}
}
#line 49 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrio.c"
void png_default_read_data(png_structp png_ptr , png_bytep data , png_size_t length ) 
{ 
  png_size_t check ;

  {
#line 54
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 55
    return;
  }
  {
#line 60
  check = fread((void */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)png_ptr->io_ptr);
  }
#line 62
  if (check != length) {
    {
#line 63
    png_error((png_const_structrp )png_ptr, "Read Error");
    }
  }
#line 64
  return;
}
}
#line 86 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngrio.c"
void png_set_read_fn(png_structrp png_ptr , png_voidp io_ptr , void (*read_data_fn)(png_structp  ,
                                                                                    png_bytep  ,
                                                                                    png_size_t  ) ) 
{ 


  {
#line 90
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 91
    return;
  }
#line 93
  png_ptr->io_ptr = io_ptr;
#line 96
  if ((unsigned long )read_data_fn != (unsigned long )((void *)0)) {
#line 97
    png_ptr->read_data_fn = read_data_fn;
  } else {
#line 100
    png_ptr->read_data_fn = & png_default_read_data;
  }
#line 107
  if ((unsigned long )png_ptr->write_data_fn != (unsigned long )((void *)0)) {
    {
#line 109
    png_ptr->write_data_fn = (void (*)(png_structp  , png_bytep  , png_size_t  ))((void *)0);
#line 110
    png_warning((png_const_structrp )png_ptr, "Can\'t set both read_data_fn and write_data_fn in the same structure");
    }
  }
#line 117
  png_ptr->output_flush_fn = (void (*)(png_structp  ))((void *)0);
#line 119
  return;
}
}
#line 953 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
png_structp __attribute__((__malloc__))  png_create_read_struct(png_const_charp user_png_ver ,
                                                                png_voidp error_ptr ,
                                                                void (*error_fn)(png_structp  ,
                                                                                 png_const_charp  ) ,
                                                                void (*warn_fn)(png_structp  ,
                                                                                png_const_charp  ) ) ;
#line 1053
void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1395
void png_start_read_image(png_structrp png_ptr ) ;
#line 1398
void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1403
void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows ) ;
#line 1409
void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep dsp_row ) ;
#line 1415
void png_read_image(png_structrp png_ptr , png_bytepp image___0 ) ;
#line 1439
void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) ;
#line 1447
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr ) ;
#line 1628
void png_set_read_status_fn(png_structrp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                       png_uint_32  ,
                                                                       int  ) ) ;
#line 2352
void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) ;
#line 1041 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
void png_zfree(voidpf png_ptr , voidpf ptr ) ;
#line 1546
int png_chunk_unknown_handling(png_const_structrp png_ptr , png_uint_32 chunk_name ) ;
#line 25 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
png_structp __attribute__((__malloc__))  png_create_read_struct(png_const_charp user_png_ver ,
                                                                png_voidp error_ptr ,
                                                                void (*error_fn)(png_structp  ,
                                                                                 png_const_charp  ) ,
                                                                void (*warn_fn)(png_structp  ,
                                                                                png_const_charp  ) ) 
{ 
  png_structp png_ptr ;
  png_structp __attribute__((__malloc__))  tmp ;

  {
  {
#line 30
  tmp = png_create_png_struct(user_png_ver, error_ptr, error_fn, warn_fn, (void *)0,
                              (png_voidp (*)(png_structp  , png_alloc_size_t  ))((void *)0),
                              (void (*)(png_structp  , png_voidp  ))((void *)0));
#line 30
  png_ptr = (png_structp )tmp;
  }
#line 49
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 51
    png_ptr->mode = 32768U;
#line 57
    png_ptr->IDAT_read_size = (uInt )8192;
#line 61
    png_ptr->flags |= 1048576U;
#line 67
    png_ptr->flags |= 2097152U;
#line 75
    png_set_read_fn((png_structrp )png_ptr, (void *)0, (void (*)(png_structp  , png_bytep  ,
                                                                 png_size_t  ))((void *)0));
    }
  }
#line 78
  return ((png_structp __attribute__((__malloc__))  )png_ptr);
}
}
#line 91 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_read_info(png_structrp png_ptr , png_inforp info_ptr ) 
{ 
  int keep ;
  png_uint_32 length ;
  png_uint_32 tmp ;
  png_uint_32 chunk_name ;

  {
#line 100
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 101
    return;
  } else
#line 100
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 101
    return;
  }
  {
#line 104
  png_read_sig(png_ptr, info_ptr);
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp = png_read_chunk_header(png_ptr);
#line 108
    length = tmp;
#line 109
    chunk_name = png_ptr->chunk_name;
    }
#line 114
    if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 116
      if ((png_ptr->mode & 1U) == 0U) {
        {
#line 117
        png_chunk_error((png_const_structrp )png_ptr, "Missing IHDR before IDAT");
        }
      } else
#line 119
      if ((int )png_ptr->color_type == 3) {
#line 119
        if ((png_ptr->mode & 2U) == 0U) {
          {
#line 121
          png_chunk_error((png_const_structrp )png_ptr, "Missing PLTE before IDAT");
          }
        } else {
#line 119
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 123
      if ((png_ptr->mode & 8U) != 0U) {
        {
#line 124
        png_chunk_benign_error((png_const_structrp )png_ptr, "Too many IDATs found");
        }
      }
#line 126
      png_ptr->mode |= 4U;
    } else
#line 129
    if ((png_ptr->mode & 4U) != 0U) {
#line 131
      png_ptr->mode |= 8192U;
#line 132
      png_ptr->mode |= 8U;
    }
#line 138
    if (chunk_name == ((((73U << 24) | (72U << 16)) | (68U << 8)) | 82U)) {
      {
#line 139
      png_handle_IHDR(png_ptr, info_ptr, length);
      }
    } else
#line 141
    if (chunk_name == ((((73U << 24) | (69U << 16)) | (78U << 8)) | 68U)) {
      {
#line 142
      png_handle_IEND(png_ptr, info_ptr, length);
      }
    } else {
      {
#line 145
      keep = png_chunk_unknown_handling((png_const_structrp )png_ptr, chunk_name);
      }
#line 145
      if (keep != 0) {
        {
#line 147
        png_handle_unknown(png_ptr, info_ptr, length, keep);
        }
#line 149
        if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 150
          png_ptr->mode |= 2U;
        } else
#line 152
        if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 154
          png_ptr->idat_size = (png_uint_32 )0;
#line 155
          goto while_break;
        }
      } else
#line 159
      if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
        {
#line 160
        png_handle_PLTE(png_ptr, info_ptr, length);
        }
      } else
#line 162
      if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 164
        png_ptr->idat_size = length;
#line 165
        goto while_break;
      } else
#line 169
      if (chunk_name == ((((98U << 24) | (75U << 16)) | (71U << 8)) | 68U)) {
        {
#line 170
        png_handle_bKGD(png_ptr, info_ptr, length);
        }
      } else
#line 189
      if (chunk_name == ((((104U << 24) | (73U << 16)) | (83U << 8)) | 84U)) {
        {
#line 190
        png_handle_hIST(png_ptr, info_ptr, length);
        }
      } else
#line 214
      if (chunk_name == ((((115U << 24) | (66U << 16)) | (73U << 8)) | 84U)) {
        {
#line 215
        png_handle_sBIT(png_ptr, info_ptr, length);
        }
      } else
#line 244
      if (chunk_name == ((((116U << 24) | (82U << 16)) | (78U << 8)) | 83U)) {
        {
#line 245
        png_handle_tRNS(png_ptr, info_ptr, length);
        }
      } else {
        {
#line 259
        png_handle_unknown(png_ptr, info_ptr, length, 0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 266 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_read_update_info(png_structrp png_ptr , png_inforp info_ptr ) 
{ 


  {
#line 271
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 273
    if ((png_ptr->flags & 64U) == 0U) {
      {
#line 275
      png_read_start_row(png_ptr);
#line 278
      png_read_transform_info(png_ptr, info_ptr);
      }
    } else {
      {
#line 286
      png_app_error((png_const_structrp )png_ptr, "png_read_update_info/png_start_read_image: duplicate call");
      }
    }
  }
#line 289
  return;
}
}
#line 297 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_start_read_image(png_structrp png_ptr ) 
{ 


  {
#line 302
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 304
    if ((png_ptr->flags & 64U) == 0U) {
      {
#line 305
      png_read_start_row(png_ptr);
      }
    } else {
      {
#line 309
      png_app_error((png_const_structrp )png_ptr, "png_start_read_image/png_read_update_info: duplicate call");
      }
    }
  }
#line 312
  return;
}
}
#line 382 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_read_row(png_structrp png_ptr , png_bytep row , png_bytep dsp_row ) 
{ 
  png_row_info row_info ;
  int tmp ;

  {
#line 387
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 388
    return;
  }
#line 396
  if ((png_ptr->flags & 64U) == 0U) {
    {
#line 397
    png_read_start_row(png_ptr);
    }
  }
#line 400
  row_info.width = png_ptr->iwidth;
#line 401
  row_info.color_type = png_ptr->color_type;
#line 402
  row_info.bit_depth = png_ptr->bit_depth;
#line 403
  row_info.channels = png_ptr->channels;
#line 404
  row_info.pixel_depth = png_ptr->pixel_depth;
#line 405
  if ((int )row_info.pixel_depth >= 8) {
#line 405
    row_info.rowbytes = (png_size_t )row_info.width * ((png_size_t )row_info.pixel_depth >> 3);
  } else {
#line 405
    row_info.rowbytes = ((png_size_t )row_info.width * (png_size_t )row_info.pixel_depth + 7UL) >> 3;
  }
#line 408
  if (png_ptr->row_number == 0U) {
#line 408
    if ((int )png_ptr->pass == 0) {
#line 408
      tmp = 1;
    } else {
#line 408
      tmp = 0;
    }
  } else {
#line 408
    tmp = 0;
  }
#line 456
  if ((int )png_ptr->interlaced != 0) {
#line 456
    if ((png_ptr->transformations & 2U) != 0U) {
      {
#line 461
      if ((int )png_ptr->pass == 0) {
#line 461
        goto case_0;
      }
#line 471
      if ((int )png_ptr->pass == 1) {
#line 471
        goto case_1;
      }
#line 482
      if ((int )png_ptr->pass == 2) {
#line 482
        goto case_2;
      }
#line 493
      if ((int )png_ptr->pass == 3) {
#line 493
        goto case_3;
      }
#line 504
      if ((int )png_ptr->pass == 4) {
#line 504
        goto case_4;
      }
#line 515
      if ((int )png_ptr->pass == 5) {
#line 515
        goto case_5;
      }
#line 526
      goto switch_default;
      case_0: /* CIL Label */ 
#line 462
      if (png_ptr->row_number & 7U) {
#line 464
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 465
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 466
        png_read_finish_row(png_ptr);
        }
#line 467
        return;
      }
#line 469
      goto switch_break;
      case_1: /* CIL Label */ 
#line 472
      if (png_ptr->row_number & 7U) {
#line 472
        goto _L;
      } else
#line 472
      if (png_ptr->width < 5U) {
        _L: /* CIL Label */ 
#line 474
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 475
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 477
        png_read_finish_row(png_ptr);
        }
#line 478
        return;
      }
#line 480
      goto switch_break;
      case_2: /* CIL Label */ 
#line 483
      if ((png_ptr->row_number & 7U) != 4U) {
#line 485
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 485
          if (png_ptr->row_number & 4U) {
            {
#line 486
            png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
            }
          }
        }
        {
#line 488
        png_read_finish_row(png_ptr);
        }
#line 489
        return;
      }
#line 491
      goto switch_break;
      case_3: /* CIL Label */ 
#line 494
      if (png_ptr->row_number & 3U) {
#line 494
        goto _L___0;
      } else
#line 494
      if (png_ptr->width < 3U) {
        _L___0: /* CIL Label */ 
#line 496
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 497
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 499
        png_read_finish_row(png_ptr);
        }
#line 500
        return;
      }
#line 502
      goto switch_break;
      case_4: /* CIL Label */ 
#line 505
      if ((png_ptr->row_number & 3U) != 2U) {
#line 507
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
#line 507
          if (png_ptr->row_number & 2U) {
            {
#line 508
            png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
            }
          }
        }
        {
#line 510
        png_read_finish_row(png_ptr);
        }
#line 511
        return;
      }
#line 513
      goto switch_break;
      case_5: /* CIL Label */ 
#line 516
      if (png_ptr->row_number & 1U) {
#line 516
        goto _L___1;
      } else
#line 516
      if (png_ptr->width < 2U) {
        _L___1: /* CIL Label */ 
#line 518
        if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
          {
#line 519
          png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
          }
        }
        {
#line 521
        png_read_finish_row(png_ptr);
        }
#line 522
        return;
      }
#line 524
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 528
      if ((png_ptr->row_number & 1U) == 0U) {
        {
#line 530
        png_read_finish_row(png_ptr);
        }
#line 531
        return;
      }
#line 533
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 538
  if ((png_ptr->mode & 4U) == 0U) {
    {
#line 539
    png_error((png_const_structrp )png_ptr, "Invalid attempt to read row data");
    }
  }
  {
#line 542
  *(png_ptr->row_buf + 0) = (png_byte )255;
#line 543
  png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1UL);
  }
#line 545
  if ((int )*(png_ptr->row_buf + 0) > 0) {
#line 547
    if ((int )*(png_ptr->row_buf + 0) < 5) {
      {
#line 548
      png_read_filter_row(png_ptr, & row_info, png_ptr->row_buf + 1, (png_const_bytep )(png_ptr->prev_row + 1),
                          (int )*(png_ptr->row_buf + 0));
      }
    } else {
      {
#line 551
      png_error((png_const_structrp )png_ptr, "bad adaptive filter value");
      }
    }
  }
  {
#line 559
  memcpy((void */* __restrict  */)png_ptr->prev_row, (void const   */* __restrict  */)png_ptr->row_buf,
         row_info.rowbytes + 1UL);
  }
#line 571
  if (png_ptr->transformations) {
    {
#line 572
    png_do_read_transformations(png_ptr, & row_info);
    }
  }
#line 576
  if ((int )png_ptr->transformed_pixel_depth == 0) {
#line 578
    png_ptr->transformed_pixel_depth = row_info.pixel_depth;
#line 579
    if ((int )row_info.pixel_depth > (int )png_ptr->maximum_pixel_depth) {
      {
#line 580
      png_error((png_const_structrp )png_ptr, "sequential row overflow");
      }
    }
  } else
#line 583
  if ((int )png_ptr->transformed_pixel_depth != (int )row_info.pixel_depth) {
    {
#line 584
    png_error((png_const_structrp )png_ptr, "internal sequential row size calculation error");
    }
  }
#line 588
  if ((int )png_ptr->interlaced != 0) {
#line 588
    if ((png_ptr->transformations & 2U) != 0U) {
#line 591
      if ((int )png_ptr->pass < 6) {
        {
#line 592
        png_do_read_interlace(& row_info, png_ptr->row_buf + 1, (int )png_ptr->pass,
                              png_ptr->transformations);
        }
      }
#line 595
      if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
        {
#line 596
        png_combine_row((png_const_structrp )png_ptr, dsp_row, 1);
        }
      }
#line 598
      if ((unsigned long )row != (unsigned long )((void *)0)) {
        {
#line 599
        png_combine_row((png_const_structrp )png_ptr, row, 0);
        }
      }
    } else {
#line 588
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 605
    if ((unsigned long )row != (unsigned long )((void *)0)) {
      {
#line 606
      png_combine_row((png_const_structrp )png_ptr, row, -1);
      }
    }
#line 608
    if ((unsigned long )dsp_row != (unsigned long )((void *)0)) {
      {
#line 609
      png_combine_row((png_const_structrp )png_ptr, dsp_row, -1);
      }
    }
  }
  {
#line 611
  png_read_finish_row(png_ptr);
  }
#line 613
  if ((unsigned long )png_ptr->read_row_fn != (unsigned long )((void *)0)) {
    {
#line 614
    (*(png_ptr->read_row_fn))((png_structp )png_ptr, png_ptr->row_number, (int )png_ptr->pass);
    }
  }
#line 616
  return;
}
}
#line 644 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_read_rows(png_structrp png_ptr , png_bytepp row , png_bytepp display_row ,
                   png_uint_32 num_rows ) 
{ 
  png_uint_32 i ;
  png_bytepp rp ;
  png_bytepp dp ;
  png_bytep rptr ;
  png_bytepp tmp ;
  png_bytep dptr ;
  png_bytepp tmp___0 ;
  png_bytep rptr___0 ;
  png_bytep dptr___0 ;

  {
#line 654
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 655
    return;
  }
#line 657
  rp = row;
#line 658
  dp = display_row;
#line 659
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 659
    if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 660
      i = (png_uint_32 )0;
      {
#line 660
      while (1) {
        while_continue: /* CIL Label */ ;
#line 660
        if (! (i < num_rows)) {
#line 660
          goto while_break;
        }
        {
#line 662
        tmp = rp;
#line 662
        rp ++;
#line 662
        rptr = *tmp;
#line 663
        tmp___0 = dp;
#line 663
        dp ++;
#line 663
        dptr = *tmp___0;
#line 665
        png_read_row(png_ptr, rptr, dptr);
#line 660
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 659
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 668
  if ((unsigned long )rp != (unsigned long )((void *)0)) {
#line 669
    i = (png_uint_32 )0;
    {
#line 669
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 669
      if (! (i < num_rows)) {
#line 669
        goto while_break___0;
      }
      {
#line 671
      rptr___0 = *rp;
#line 672
      png_read_row(png_ptr, rptr___0, (png_bytep )((void *)0));
#line 673
      rp ++;
#line 669
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 676
  if ((unsigned long )dp != (unsigned long )((void *)0)) {
#line 677
    i = (png_uint_32 )0;
    {
#line 677
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 677
      if (! (i < num_rows)) {
#line 677
        goto while_break___1;
      }
      {
#line 679
      dptr___0 = *dp;
#line 680
      png_read_row(png_ptr, (png_bytep )((void *)0), dptr___0);
#line 681
      dp ++;
#line 677
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 683
  return;
}
}
#line 699 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_read_image(png_structrp png_ptr , png_bytepp image___0 ) 
{ 
  png_uint_32 i ;
  png_uint_32 image_height ;
  int pass ;
  int j ;
  png_bytepp rp ;

  {
#line 708
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 709
    return;
  }
#line 712
  if ((png_ptr->flags & 64U) == 0U) {
    {
#line 714
    pass = png_set_interlace_handling(png_ptr);
#line 716
    png_start_read_image(png_ptr);
    }
  } else {
#line 720
    if ((int )png_ptr->interlaced != 0) {
#line 720
      if ((png_ptr->transformations & 2U) == 0U) {
        {
#line 727
        png_warning((png_const_structrp )png_ptr, "Interlace handling should be turned on when using png_read_image");
#line 730
        png_ptr->num_rows = png_ptr->height;
        }
      }
    }
    {
#line 736
    pass = png_set_interlace_handling(png_ptr);
    }
  }
#line 746
  image_height = png_ptr->height;
#line 748
  j = 0;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (j < pass)) {
#line 748
      goto while_break;
    }
#line 750
    rp = image___0;
#line 751
    i = (png_uint_32 )0;
    {
#line 751
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 751
      if (! (i < image_height)) {
#line 751
        goto while_break___0;
      }
      {
#line 753
      png_read_row(png_ptr, *rp, (png_bytep )((void *)0));
#line 754
      rp ++;
#line 751
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 748
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  return;
}
}
#line 765 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_read_end(png_structrp png_ptr , png_inforp info_ptr ) 
{ 
  int keep ;
  int tmp ;
  png_uint_32 length ;
  png_uint_32 tmp___0 ;
  png_uint_32 chunk_name ;

  {
#line 774
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 775
    return;
  }
  {
#line 781
  tmp = png_chunk_unknown_handling((png_const_structrp )png_ptr, (((73U << 24) | (68U << 16)) | (65U << 8)) | 84U);
  }
#line 781
  if (tmp == 0) {
    {
#line 783
    png_read_finish_IDAT(png_ptr);
    }
  }
#line 787
  if ((int )png_ptr->color_type == 3) {
#line 787
    if (png_ptr->num_palette_max > (int )png_ptr->num_palette) {
      {
#line 789
      png_benign_error((png_const_structrp )png_ptr, "Read palette index exceeding num_palette");
      }
    }
  }
  {
#line 792
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 794
    tmp___0 = png_read_chunk_header(png_ptr);
#line 794
    length = tmp___0;
#line 795
    chunk_name = png_ptr->chunk_name;
    }
#line 797
    if (chunk_name != ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 798
      png_ptr->mode |= 8192U;
    }
#line 800
    if (chunk_name == ((((73U << 24) | (69U << 16)) | (78U << 8)) | 68U)) {
      {
#line 801
      png_handle_IEND(png_ptr, info_ptr, length);
      }
    } else
#line 803
    if (chunk_name == ((((73U << 24) | (72U << 16)) | (68U << 8)) | 82U)) {
      {
#line 804
      png_handle_IHDR(png_ptr, info_ptr, length);
      }
    } else
#line 806
    if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
      {
#line 807
      png_crc_finish(png_ptr, length);
      }
    } else {
      {
#line 810
      keep = png_chunk_unknown_handling((png_const_structrp )png_ptr, chunk_name);
      }
#line 810
      if (keep != 0) {
#line 812
        if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 814
          if (length > 0U) {
#line 814
            if (! (png_ptr->flags & 8U)) {
              {
#line 816
              png_benign_error((png_const_structrp )png_ptr, ".Too many IDATs found");
              }
            } else {
#line 814
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 814
          if ((png_ptr->mode & 8192U) != 0U) {
            {
#line 816
            png_benign_error((png_const_structrp )png_ptr, ".Too many IDATs found");
            }
          }
        }
        {
#line 818
        png_handle_unknown(png_ptr, info_ptr, length, keep);
        }
#line 819
        if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
#line 820
          png_ptr->mode |= 2U;
        }
      } else
#line 824
      if (chunk_name == ((((73U << 24) | (68U << 16)) | (65U << 8)) | 84U)) {
#line 832
        if (length > 0U) {
#line 832
          if (! (png_ptr->flags & 8U)) {
            {
#line 834
            png_benign_error((png_const_structrp )png_ptr, "..Too many IDATs found");
            }
          } else {
#line 832
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 832
        if ((png_ptr->mode & 8192U) != 0U) {
          {
#line 834
          png_benign_error((png_const_structrp )png_ptr, "..Too many IDATs found");
          }
        }
        {
#line 836
        png_crc_finish(png_ptr, length);
        }
      } else
#line 838
      if (chunk_name == ((((80U << 24) | (76U << 16)) | (84U << 8)) | 69U)) {
        {
#line 839
        png_handle_PLTE(png_ptr, info_ptr, length);
        }
      } else
#line 842
      if (chunk_name == ((((98U << 24) | (75U << 16)) | (71U << 8)) | 68U)) {
        {
#line 843
        png_handle_bKGD(png_ptr, info_ptr, length);
        }
      } else
#line 862
      if (chunk_name == ((((104U << 24) | (73U << 16)) | (83U << 8)) | 84U)) {
        {
#line 863
        png_handle_hIST(png_ptr, info_ptr, length);
        }
      } else
#line 887
      if (chunk_name == ((((115U << 24) | (66U << 16)) | (73U << 8)) | 84U)) {
        {
#line 888
        png_handle_sBIT(png_ptr, info_ptr, length);
        }
      } else
#line 917
      if (chunk_name == ((((116U << 24) | (82U << 16)) | (78U << 8)) | 83U)) {
        {
#line 918
        png_handle_tRNS(png_ptr, info_ptr, length);
        }
      } else {
        {
#line 932
        png_handle_unknown(png_ptr, info_ptr, length, 0);
        }
      }
    }
#line 792
    if (! ((png_ptr->mode & 16U) == 0U)) {
#line 792
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 935
  return;
}
}
#line 939 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
static void png_read_destroy(png_structrp png_ptr ) 
{ 


  {
  {
#line 948
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_row_buf);
#line 949
  png_ptr->big_row_buf = (png_bytep )((void *)0);
#line 950
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->big_prev_row);
#line 951
  png_ptr->big_prev_row = (png_bytep )((void *)0);
#line 952
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->read_buffer);
#line 953
  png_ptr->read_buffer = (png_bytep )((void *)0);
  }
#line 962
  if ((png_ptr->free_me & 4096U) != 0U) {
    {
#line 964
    png_zfree((voidpf )png_ptr, (voidpf )png_ptr->palette);
#line 965
    png_ptr->palette = (png_colorp )((void *)0);
    }
  }
#line 967
  png_ptr->free_me &= 4294963199U;
#line 971
  if ((png_ptr->free_me & 8192U) != 0U) {
    {
#line 973
    png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->trans_alpha);
#line 974
    png_ptr->trans_alpha = (png_bytep )((void *)0);
    }
  }
  {
#line 976
  png_ptr->free_me &= 4294959103U;
#line 979
  inflateEnd(& png_ptr->zstream);
#line 988
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->unknown_chunk.data);
#line 989
  png_ptr->unknown_chunk.data = (png_byte *)((void *)0);
#line 993
  png_free((png_const_structrp )png_ptr, (png_voidp )png_ptr->chunk_list);
#line 994
  png_ptr->chunk_list = (png_bytep )((void *)0);
  }
#line 1001
  return;
}
}
#line 1004 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_destroy_read_struct(png_structpp png_ptr_ptr , png_infopp info_ptr_ptr ,
                             png_infopp end_info_ptr_ptr ) 
{ 
  png_structrp png_ptr ;

  {
#line 1008
  png_ptr = (png_structrp )((void *)0);
#line 1012
  if ((unsigned long )png_ptr_ptr != (unsigned long )((void *)0)) {
#line 1013
    png_ptr = (png_structrp )*png_ptr_ptr;
  }
#line 1015
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1016
    return;
  }
  {
#line 1022
  png_destroy_info_struct((png_const_structrp )png_ptr, end_info_ptr_ptr);
#line 1023
  png_destroy_info_struct((png_const_structrp )png_ptr, info_ptr_ptr);
#line 1025
  *png_ptr_ptr = (png_struct *)((void *)0);
#line 1026
  png_read_destroy(png_ptr);
#line 1027
  png_destroy_png_struct(png_ptr);
  }
#line 1028
  return;
}
}
#line 1030 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_set_read_status_fn(png_structrp png_ptr , void (*read_row_fn)(png_structp  ,
                                                                       png_uint_32  ,
                                                                       int  ) ) 
{ 


  {
#line 1033
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1034
    return;
  }
#line 1036
  png_ptr->read_row_fn = read_row_fn;
#line 1037
  return;
}
}
#line 1042 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngread.c"
void png_read_png(png_structrp png_ptr , png_inforp info_ptr , int transforms , void *params ) 
{ 
  png_uint_32 iptr ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
#line 1046
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1047
    return;
  } else
#line 1046
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 1047
    return;
  }
  {
#line 1052
  png_read_info(png_ptr, info_ptr);
  }
#line 1053
  if ((unsigned long )info_ptr->height > 4294967295UL / sizeof(png_bytep )) {
    {
#line 1054
    png_error((png_const_structrp )png_ptr, "Image is too high to process with png_read_png()");
    }
  }
#line 1065
  if ((transforms & 32768) != 0) {
    {
#line 1072
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SCALE_16 not supported");
    }
  }
#line 1079
  if ((transforms & 1) != 0) {
    {
#line 1083
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_STRIP_16 not supported");
    }
  }
#line 1089
  if ((transforms & 2) != 0) {
    {
#line 1093
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_STRIP_ALPHA not supported");
    }
  }
#line 1099
  if ((transforms & 4) != 0) {
    {
#line 1103
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKING not supported");
    }
  }
#line 1109
  if ((transforms & 8) != 0) {
    {
#line 1113
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_PACKSWAP not supported");
    }
  }
#line 1121
  if ((transforms & 16) != 0) {
    {
#line 1125
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_EXPAND not supported");
    }
  }
#line 1133
  if ((transforms & 32) != 0) {
    {
#line 1137
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_MONO not supported");
    }
  }
#line 1144
  if ((transforms & 64) != 0) {
    {
#line 1149
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SHIFT not supported");
    }
  }
#line 1153
  if ((transforms & 128) != 0) {
    {
#line 1157
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_BGR not supported");
    }
  }
#line 1161
  if ((transforms & 256) != 0) {
    {
#line 1165
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ALPHA not supported");
    }
  }
#line 1169
  if ((transforms & 512) != 0) {
    {
#line 1173
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_SWAP_ENDIAN not supported");
    }
  }
#line 1178
  if ((transforms & 1024) != 0) {
    {
#line 1182
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_INVERT_ALPHA not supported");
    }
  }
#line 1187
  if ((transforms & 8192) != 0) {
    {
#line 1191
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_GRAY_TO_RGB not supported");
    }
  }
#line 1195
  if ((transforms & 16384) != 0) {
    {
#line 1199
    png_app_error((png_const_structrp )png_ptr, "PNG_TRANSFORM_EXPAND_16 not supported");
    }
  }
  {
#line 1207
  png_set_interlace_handling(png_ptr);
#line 1213
  png_read_update_info(png_ptr, info_ptr);
#line 1217
  png_free_data((png_const_structrp )png_ptr, info_ptr, 64U, 0);
  }
#line 1218
  if ((unsigned long )info_ptr->row_pointers == (unsigned long )((void *)0)) {
    {
#line 1222
    tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )info_ptr->height * sizeof(png_bytep ));
#line 1222
    info_ptr->row_pointers = (png_bytepp )tmp;
#line 1225
    iptr = (png_uint_32 )0;
    }
    {
#line 1225
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1225
      if (! (iptr < info_ptr->height)) {
#line 1225
        goto while_break;
      }
#line 1226
      *(info_ptr->row_pointers + iptr) = (png_byte *)((void *)0);
#line 1225
      iptr ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1228
    info_ptr->free_me |= 64U;
#line 1230
    iptr = (png_uint_32 )0;
    {
#line 1230
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1230
      if (! (iptr < info_ptr->height)) {
#line 1230
        goto while_break___0;
      }
      {
#line 1231
      tmp___0 = png_malloc((png_const_structrp )png_ptr, info_ptr->rowbytes);
#line 1231
      *(info_ptr->row_pointers + iptr) = (png_byte *)tmp___0;
#line 1230
      iptr ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1235
  png_read_image(png_ptr, info_ptr->row_pointers);
#line 1236
  info_ptr->valid |= 32768U;
#line 1239
  png_read_end(png_ptr, info_ptr);
  }
#line 1242
  return;
}
}
#line 932 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
png_uint_32 png_access_version_number(void) ;
#line 937
void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) ;
#line 999
int png_reset_zstream(png_structrp png_ptr ) ;
#line 1035
png_infop __attribute__((__malloc__))  png_create_info_struct(png_const_structrp png_ptr ) ;
#line 1042
void png_info_init_3(png_infopp ptr_ptr , png_size_t png_info_struct_size ) ;
#line 1591
void png_init_io(png_structrp png_ptr , png_FILE_p fp ) ;
#line 1602
void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) ) ;
#line 1626
png_voidp png_get_io_ptr(png_const_structrp png_ptr ) ;
#line 1771
void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                    png_uint_32 mask ) ;
#line 2361
png_const_charp png_get_copyright(png_const_structrp png_ptr ) ;
#line 2363
png_const_charp png_get_header_ver(png_const_structrp png_ptr ) ;
#line 2365
png_const_charp png_get_header_version(png_const_structrp png_ptr ) ;
#line 2367
png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) ;
#line 2589
void png_save_int_32(png_bytep buf , png_int_32 i ) ;
#line 991 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
int png_user_version_check(png_structrp png_ptr , png_const_charp user_png_ver ) ;
#line 1037
voidpf __attribute__((__malloc__))  png_zalloc(voidpf png_ptr , uInt items , uInt size ) ;
#line 46 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_set_sig_bytes(png_structrp png_ptr , int num_bytes ) 
{ 
  unsigned int nb ;

  {
#line 49
  nb = (unsigned int )num_bytes;
#line 53
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 54
    return;
  }
#line 56
  if (num_bytes < 0) {
#line 57
    nb = 0U;
  }
#line 59
  if (nb > 8U) {
    {
#line 60
    png_error((png_const_structrp )png_ptr, "Too many bytes for PNG signature");
    }
  }
#line 62
  png_ptr->sig_bytes = (png_byte )nb;
#line 63
  return;
}
}
#line 73 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
int png_sig_cmp(png_const_bytep sig , png_size_t start , png_size_t num_to_check ) 
{ 
  png_byte png_signature[8] ;
  int tmp ;

  {
#line 76
  png_signature[0] = (png_byte )137;
#line 76
  png_signature[1] = (png_byte )80;
#line 76
  png_signature[2] = (png_byte )78;
#line 76
  png_signature[3] = (png_byte )71;
#line 76
  png_signature[4] = (png_byte )13;
#line 76
  png_signature[5] = (png_byte )10;
#line 76
  png_signature[6] = (png_byte )26;
#line 76
  png_signature[7] = (png_byte )10;
#line 78
  if (num_to_check > 8UL) {
#line 79
    num_to_check = (png_size_t )8;
  } else
#line 81
  if (num_to_check < 1UL) {
#line 82
    return (-1);
  }
#line 84
  if (start > 7UL) {
#line 85
    return (-1);
  }
#line 87
  if (start + num_to_check > 8UL) {
#line 88
    num_to_check = 8UL - start;
  }
  {
#line 90
  tmp = memcmp((void const   *)(sig + start), (void const   *)(& png_signature[start]),
               num_to_check);
  }
#line 90
  return (tmp);
}
}
#line 97 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
voidpf __attribute__((__malloc__))  png_zalloc(voidpf png_ptr , uInt items , uInt size ) 
{ 
  png_alloc_size_t num_bytes ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 100
  num_bytes = (png_alloc_size_t )size;
#line 102
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 103
    return ((voidpf __attribute__((__malloc__))  )((void *)0));
  }
#line 105
  if ((png_alloc_size_t )items >= 0xffffffffffffffffUL / (png_alloc_size_t )size) {
    {
#line 107
    png_warning((png_const_structrp )png_ptr, "Potential overflow in png_zalloc()");
    }
#line 109
    return ((voidpf __attribute__((__malloc__))  )((void *)0));
  }
  {
#line 112
  num_bytes *= (png_alloc_size_t )items;
#line 113
  tmp = png_malloc_warn((png_const_structrp )png_ptr, num_bytes);
  }
#line 113
  return (tmp);
}
}
#line 117 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_zfree(voidpf png_ptr , voidpf ptr ) 
{ 


  {
  {
#line 120
  png_free((png_const_structrp )png_ptr, ptr);
  }
#line 121
  return;
}
}
#line 126 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_reset_crc(png_structrp png_ptr ) 
{ 
  uLong tmp ;

  {
  {
#line 130
  tmp = crc32((uLong )0, (Bytef const   *)0, (uInt )0);
#line 130
  png_ptr->crc = (png_uint_32 )tmp;
  }
#line 131
  return;
}
}
#line 138 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_calculate_crc(png_structrp png_ptr , png_const_bytep ptr , png_size_t length ) 
{ 
  int need_crc ;
  uLong crc ;
  uInt safe_length ;

  {
#line 141
  need_crc = 1;
#line 143
  if ((1U & (png_ptr->chunk_name >> 29)) != 0U) {
#line 145
    if ((png_ptr->flags & 768U) == 768U) {
#line 147
      need_crc = 0;
    }
  } else
#line 152
  if ((png_ptr->flags & 2048U) != 0U) {
#line 153
    need_crc = 0;
  }
#line 161
  if (need_crc != 0) {
#line 161
    if (length > 0UL) {
#line 163
      crc = (uLong )png_ptr->crc;
      {
#line 165
      while (1) {
        while_continue: /* CIL Label */ ;
#line 167
        safe_length = (uInt )length;
#line 169
        if (safe_length == 0U) {
#line 170
          safe_length = (uInt )-1;
        }
        {
#line 173
        crc = crc32(crc, ptr, safe_length);
#line 179
        ptr += safe_length;
#line 180
        length -= (png_size_t )safe_length;
        }
#line 165
        if (! (length > 0UL)) {
#line 165
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 185
      png_ptr->crc = (png_uint_32 )crc;
    }
  }
#line 187
  return;
}
}
#line 192 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
int png_user_version_check(png_structrp png_ptr , png_const_charp user_png_ver ) 
{ 
  int i ;
  int found_dots ;
  size_t pos ;
  char m[128] ;

  {
#line 200
  if ((unsigned long )user_png_ver != (unsigned long )((void *)0)) {
#line 202
    i = -1;
#line 203
    found_dots = 0;
    {
#line 205
    while (1) {
      while_continue: /* CIL Label */ ;
#line 207
      i ++;
#line 208
      if ((int const   )*(user_png_ver + i) != (int const   )*("1.6.34" + i)) {
#line 209
        png_ptr->flags |= 131072U;
      }
#line 210
      if ((int const   )*(user_png_ver + i) == 46) {
#line 211
        found_dots ++;
      }
#line 205
      if (found_dots < 2) {
#line 205
        if ((int const   )*(user_png_ver + i) != 0) {
#line 205
          if (! ((int const   )*("1.6.34" + i) != 0)) {
#line 205
            goto while_break;
          }
        } else {
#line 205
          goto while_break;
        }
      } else {
#line 205
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 217
    png_ptr->flags |= 131072U;
  }
#line 219
  if ((png_ptr->flags & 131072U) != 0U) {
    {
#line 222
    pos = (size_t )0;
#line 225
    pos = png_safecat(m, sizeof(m), pos, "Application built with libpng-");
#line 227
    pos = png_safecat(m, sizeof(m), pos, user_png_ver);
#line 228
    pos = png_safecat(m, sizeof(m), pos, " but running with ");
#line 229
    pos = png_safecat(m, sizeof(m), pos, "1.6.34");
#line 232
    png_warning((png_const_structrp )png_ptr, (png_const_charp )(m));
    }
#line 239
    return (0);
  }
#line 243
  return (1);
}
}
#line 249 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_structp __attribute__((__malloc__))  png_create_png_struct(png_const_charp user_png_ver ,
                                                               png_voidp error_ptr ,
                                                               void (*error_fn)(png_structp  ,
                                                                                png_const_charp  ) ,
                                                               void (*warn_fn)(png_structp  ,
                                                                               png_const_charp  ) ,
                                                               png_voidp mem_ptr ,
                                                               png_voidp (*malloc_fn)(png_structp  ,
                                                                                      png_alloc_size_t  ) ,
                                                               void (*free_fn)(png_structp  ,
                                                                               png_voidp  ) ) 
{ 
  png_struct create_struct ;
  png_structrp png_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;
  int tmp___0 ;

  {
  {
#line 263
  memset((void *)(& create_struct), 0, sizeof(create_struct));
#line 267
  create_struct.user_width_max = (png_uint_32 )1000000;
#line 268
  create_struct.user_height_max = (png_uint_32 )1000000;
#line 272
  create_struct.user_chunk_cache_max = (png_uint_32 )1000;
#line 279
  create_struct.user_chunk_malloc_max = (png_alloc_size_t )8000000;
#line 299
  png_set_error_fn((png_structrp )(& create_struct), error_ptr, error_fn, warn_fn);
#line 317
  tmp___0 = png_user_version_check((png_structrp )(& create_struct), user_png_ver);
  }
#line 317
  if (tmp___0 != 0) {
    {
#line 319
    tmp = png_malloc_warn((png_const_structrp )(& create_struct), sizeof(*png_ptr));
#line 319
    png_ptr = (png_structrp )tmp;
    }
#line 322
    if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 327
      create_struct.zstream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))(& png_zalloc);
#line 328
      create_struct.zstream.zfree = & png_zfree;
#line 329
      create_struct.zstream.opaque = (voidpf )png_ptr;
#line 338
      *png_ptr = create_struct;
#line 341
      return ((png_structp __attribute__((__malloc__))  )png_ptr);
    }
  }
#line 349
  return ((png_structp __attribute__((__malloc__))  )((void *)0));
}
}
#line 353 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_infop __attribute__((__malloc__))  png_create_info_struct(png_const_structrp png_ptr ) 
{ 
  png_inforp info_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 360
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 361
    return ((png_infop __attribute__((__malloc__))  )((void *)0));
  }
  {
#line 368
  tmp = png_malloc_base(png_ptr, sizeof(*info_ptr));
#line 368
  info_ptr = (png_inforp )tmp;
  }
#line 371
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 372
    memset((void *)info_ptr, 0, sizeof(*info_ptr));
    }
  }
#line 374
  return ((png_infop __attribute__((__malloc__))  )info_ptr);
}
}
#line 385 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_destroy_info_struct(png_const_structrp png_ptr , png_infopp info_ptr_ptr ) 
{ 
  png_inforp info_ptr ;

  {
#line 388
  info_ptr = (png_inforp )((void *)0);
#line 392
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 393
    return;
  }
#line 395
  if ((unsigned long )info_ptr_ptr != (unsigned long )((void *)0)) {
#line 396
    info_ptr = (png_inforp )*info_ptr_ptr;
  }
#line 398
  if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
    {
#line 406
    *info_ptr_ptr = (png_info *)((void *)0);
#line 408
    png_free_data(png_ptr, info_ptr, 65535U, -1);
#line 409
    memset((void *)info_ptr, 0, sizeof(*info_ptr));
#line 410
    png_free(png_ptr, (png_voidp )info_ptr);
    }
  }
#line 412
  return;
}
}
#line 423 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_info_init_3(png_infopp ptr_ptr , png_size_t png_info_struct_size ) 
{ 
  png_inforp info_ptr ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 427
  info_ptr = (png_inforp )*ptr_ptr;
#line 431
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 432
    return;
  }
#line 434
  if (sizeof(png_info ) > png_info_struct_size) {
    {
#line 436
    *ptr_ptr = (png_info *)((void *)0);
#line 438
    free((void *)info_ptr);
#line 439
    tmp = png_malloc_base((png_const_structrp )((void *)0), sizeof(*info_ptr));
#line 439
    info_ptr = (png_inforp )tmp;
    }
#line 441
    if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 442
      return;
    }
#line 443
    *ptr_ptr = (png_info *)info_ptr;
  }
  {
#line 447
  memset((void *)info_ptr, 0, sizeof(*info_ptr));
  }
#line 448
  return;
}
}
#line 451 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_data_freer(png_const_structrp png_ptr , png_inforp info_ptr , int freer ,
                    png_uint_32 mask ) 
{ 


  {
#line 457
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 458
    return;
  } else
#line 457
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 458
    return;
  }
#line 460
  if (freer == 1) {
#line 461
    info_ptr->free_me |= mask;
  } else
#line 463
  if (freer == 2) {
#line 464
    info_ptr->free_me &= ~ mask;
  } else {
    {
#line 467
    png_error(png_ptr, "Unknown freer parameter in png_data_freer");
    }
  }
#line 468
  return;
}
}
#line 470 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_free_data(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_32 mask ,
                   int num ) 
{ 
  int i ;
  png_uint_32 row ;

  {
#line 476
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 477
    return;
  } else
#line 476
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 477
    return;
  }
#line 507
  if (((mask & 8192U) & info_ptr->free_me) != 0U) {
    {
#line 509
    info_ptr->valid &= 4294967279U;
#line 510
    png_free(png_ptr, (png_voidp )info_ptr->trans_alpha);
#line 511
    info_ptr->trans_alpha = (png_bytep )((void *)0);
#line 512
    info_ptr->num_trans = (png_uint_16 )0;
    }
  }
#line 595
  if ((unsigned long )info_ptr->unknown_chunks != (unsigned long )((void *)0)) {
#line 595
    if (((mask & 512U) & info_ptr->free_me) != 0U) {
#line 598
      if (num != -1) {
        {
#line 600
        png_free(png_ptr, (png_voidp )(info_ptr->unknown_chunks + num)->data);
#line 601
        (info_ptr->unknown_chunks + num)->data = (png_byte *)((void *)0);
        }
      } else {
#line 608
        i = 0;
        {
#line 608
        while (1) {
          while_continue: /* CIL Label */ ;
#line 608
          if (! (i < info_ptr->unknown_chunks_num)) {
#line 608
            goto while_break;
          }
          {
#line 609
          png_free(png_ptr, (png_voidp )(info_ptr->unknown_chunks + i)->data);
#line 608
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 611
        png_free(png_ptr, (png_voidp )info_ptr->unknown_chunks);
#line 612
        info_ptr->unknown_chunks = (png_unknown_chunkp )((void *)0);
#line 613
        info_ptr->unknown_chunks_num = 0;
        }
      }
    }
  }
#line 640
  if (((mask & 8U) & info_ptr->free_me) != 0U) {
    {
#line 642
    png_free(png_ptr, (png_voidp )info_ptr->hist);
#line 643
    info_ptr->hist = (png_uint_16p )((void *)0);
#line 644
    info_ptr->valid &= 4294967231U;
    }
  }
#line 649
  if (((mask & 4096U) & info_ptr->free_me) != 0U) {
    {
#line 651
    png_free(png_ptr, (png_voidp )info_ptr->palette);
#line 652
    info_ptr->palette = (png_colorp )((void *)0);
#line 653
    info_ptr->valid &= 4294967287U;
#line 654
    info_ptr->num_palette = (png_uint_16 )0;
    }
  }
#line 659
  if (((mask & 64U) & info_ptr->free_me) != 0U) {
#line 661
    if ((unsigned long )info_ptr->row_pointers != (unsigned long )((void *)0)) {
#line 664
      row = (png_uint_32 )0;
      {
#line 664
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 664
        if (! (row < info_ptr->height)) {
#line 664
          goto while_break___0;
        }
        {
#line 665
        png_free(png_ptr, (png_voidp )*(info_ptr->row_pointers + row));
#line 664
        row ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 667
      png_free(png_ptr, (png_voidp )info_ptr->row_pointers);
#line 668
      info_ptr->row_pointers = (png_bytepp )((void *)0);
      }
    }
#line 670
    info_ptr->valid &= 4294934527U;
  }
#line 674
  if (num != -1) {
#line 675
    mask &= 4294950367U;
  }
#line 677
  info_ptr->free_me &= ~ mask;
#line 678
  return;
}
}
#line 685 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_voidp png_get_io_ptr(png_const_structrp png_ptr ) 
{ 


  {
#line 688
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 689
    return ((void *)0);
  }
#line 691
  return ((png_voidp )png_ptr->io_ptr);
}
}
#line 702 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_init_io(png_structrp png_ptr , png_FILE_p fp ) 
{ 


  {
#line 707
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 708
    return;
  }
#line 710
  png_ptr->io_ptr = (png_voidp )fp;
#line 711
  return;
}
}
#line 725 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_save_int_32(png_bytep buf , png_int_32 i ) 
{ 


  {
  {
#line 728
  png_save_uint_32(buf, (png_uint_32 )i);
  }
#line 729
  return;
}
}
#line 810 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_const_charp png_get_copyright(png_const_structrp png_ptr ) 
{ 


  {
#line 818
  return ("\nlibpng version 1.6.34 - September 29, 2017\nCopyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson\nCopyright (c) 1996-1997 Andreas Dilger\nCopyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.\n");
}
}
#line 842 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_const_charp png_get_libpng_ver(png_const_structrp png_ptr ) 
{ 
  png_const_charp tmp ;

  {
  {
#line 846
  tmp = png_get_header_ver(png_ptr);
  }
#line 846
  return (tmp);
}
}
#line 849 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_const_charp png_get_header_ver(png_const_structrp png_ptr ) 
{ 


  {
#line 854
  return ("1.6.34");
}
}
#line 857 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_const_charp png_get_header_version(png_const_structrp png_ptr ) 
{ 


  {
#line 863
  return (" libpng version 1.6.34 - September 29, 2017\n\n");
}
}
#line 931 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
int png_handle_as_unknown(png_const_structrp png_ptr , png_const_bytep chunk_name ) 
{ 
  png_const_bytep p ;
  png_const_bytep p_end ;
  int tmp ;

  {
#line 937
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 938
    return (0);
  } else
#line 937
  if ((unsigned long )chunk_name == (unsigned long )((void *)0)) {
#line 938
    return (0);
  } else
#line 937
  if (png_ptr->num_chunk_list == 0U) {
#line 938
    return (0);
  }
#line 940
  p_end = (png_const_bytep )png_ptr->chunk_list;
#line 941
  p = p_end + png_ptr->num_chunk_list * 5U;
  {
#line 947
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 949
    p -= 5;
#line 951
    tmp = memcmp((void const   *)chunk_name, (void const   *)p, (size_t )4);
    }
#line 951
    if (tmp == 0) {
#line 952
      return ((int )*(p + 4));
    }
#line 947
    if (! ((unsigned long )p > (unsigned long )p_end)) {
#line 947
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 961
  return (0);
}
}
#line 966 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
int png_chunk_unknown_handling(png_const_structrp png_ptr , png_uint_32 chunk_name ) 
{ 
  png_byte chunk_string[5] ;
  int tmp ;

  {
  {
#line 971
  *((char *)(chunk_string) + 0) = (char )((chunk_name >> 24) & 255U);
#line 971
  *((char *)(chunk_string) + 1) = (char )((chunk_name >> 16) & 255U);
#line 971
  *((char *)(chunk_string) + 2) = (char )((chunk_name >> 8) & 255U);
#line 971
  *((char *)(chunk_string) + 3) = (char )(chunk_name & 255U);
#line 971
  *((char *)(chunk_string) + 4) = (char)0;
#line 972
  tmp = png_handle_as_unknown(png_ptr, (png_const_bytep )(chunk_string));
  }
#line 972
  return (tmp);
}
}
#line 979 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
int png_reset_zstream(png_structrp png_ptr ) 
{ 
  int tmp ;

  {
#line 982
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 983
    return (-2);
  }
  {
#line 986
  tmp = inflateReset(& png_ptr->zstream);
  }
#line 986
  return (tmp);
}
}
#line 991 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
png_uint_32 png_access_version_number(void) 
{ 


  {
#line 995
  return ((png_uint_32 )10634);
}
}
#line 1003 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_zstream_error(png_structrp png_ptr , int ret ) 
{ 


  {
#line 1010
  if ((unsigned long )png_ptr->zstream.msg == (unsigned long )((void *)0)) {
    {
#line 1017
    if (ret == 1) {
#line 1017
      goto case_1;
    }
#line 1022
    if (ret == 2) {
#line 1022
      goto case_2;
    }
#line 1029
    if (ret == -1) {
#line 1029
      goto case_neg_1;
    }
#line 1034
    if (ret == -2) {
#line 1034
      goto case_neg_2;
    }
#line 1039
    if (ret == -3) {
#line 1039
      goto case_neg_3;
    }
#line 1043
    if (ret == -4) {
#line 1043
      goto case_neg_4;
    }
#line 1047
    if (ret == -5) {
#line 1047
      goto case_neg_5;
    }
#line 1054
    if (ret == -6) {
#line 1054
      goto case_neg_6;
    }
#line 1058
    if (ret == -7) {
#line 1058
      goto case_neg_7;
    }
#line 1012
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 1014
    png_ptr->zstream.msg = "unexpected zlib return code";
#line 1015
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1019
    png_ptr->zstream.msg = "unexpected end of LZ stream";
#line 1020
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1026
    png_ptr->zstream.msg = "missing LZ dictionary";
#line 1027
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 1031
    png_ptr->zstream.msg = "zlib IO error";
#line 1032
    goto switch_break;
    case_neg_2: /* CIL Label */ 
#line 1036
    png_ptr->zstream.msg = "bad parameters to zlib";
#line 1037
    goto switch_break;
    case_neg_3: /* CIL Label */ 
#line 1040
    png_ptr->zstream.msg = "damaged LZ stream";
#line 1041
    goto switch_break;
    case_neg_4: /* CIL Label */ 
#line 1044
    png_ptr->zstream.msg = "insufficient memory";
#line 1045
    goto switch_break;
    case_neg_5: /* CIL Label */ 
#line 1051
    png_ptr->zstream.msg = "truncated";
#line 1052
    goto switch_break;
    case_neg_6: /* CIL Label */ 
#line 1055
    png_ptr->zstream.msg = "unsupported zlib version";
#line 1056
    goto switch_break;
    case_neg_7: /* CIL Label */ 
#line 1064
    png_ptr->zstream.msg = "unexpected zlib return";
#line 1065
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1067
  return;
}
}
#line 2543 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
static int png_gt(size_t a , size_t b ) 
{ 


  {
#line 2546
  return (a > b);
}
}
#line 2552 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.c"
void png_check_IHDR(png_const_structrp png_ptr , png_uint_32 width , png_uint_32 height ,
                    int bit_depth , int color_type , int interlace_type , int compression_type ,
                    int filter_type ) 
{ 
  int error___0 ;
  int tmp ;

  {
#line 2558
  error___0 = 0;
#line 2561
  if (width == 0U) {
    {
#line 2563
    png_warning(png_ptr, "Image width is zero in IHDR");
#line 2564
    error___0 = 1;
    }
  }
#line 2567
  if (width > 2147483647U) {
    {
#line 2569
    png_warning(png_ptr, "Invalid image width in IHDR");
#line 2570
    error___0 = 1;
    }
  }
  {
#line 2573
  tmp = png_gt((size_t )((width + 7U) & 4294967288U), 2305843009213693944UL);
  }
#line 2573
  if (tmp) {
    {
#line 2591
    png_warning(png_ptr, "Image width is too large for this architecture");
#line 2592
    error___0 = 1;
    }
  }
#line 2596
  if (width > (png_uint_32 )png_ptr->user_width_max) {
    {
#line 2601
    png_warning(png_ptr, "Image width exceeds user limit in IHDR");
#line 2602
    error___0 = 1;
    }
  }
#line 2605
  if (height == 0U) {
    {
#line 2607
    png_warning(png_ptr, "Image height is zero in IHDR");
#line 2608
    error___0 = 1;
    }
  }
#line 2611
  if (height > 2147483647U) {
    {
#line 2613
    png_warning(png_ptr, "Invalid image height in IHDR");
#line 2614
    error___0 = 1;
    }
  }
#line 2618
  if (height > (png_uint_32 )png_ptr->user_height_max) {
    {
#line 2623
    png_warning(png_ptr, "Image height exceeds user limit in IHDR");
#line 2624
    error___0 = 1;
    }
  }
#line 2628
  if (bit_depth != 1) {
#line 2628
    if (bit_depth != 2) {
#line 2628
      if (bit_depth != 4) {
#line 2628
        if (bit_depth != 8) {
#line 2628
          if (bit_depth != 16) {
            {
#line 2631
            png_warning(png_ptr, "Invalid bit depth in IHDR");
#line 2632
            error___0 = 1;
            }
          }
        }
      }
    }
  }
#line 2635
  if (color_type < 0) {
    {
#line 2638
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2639
    error___0 = 1;
    }
  } else
#line 2635
  if (color_type == 1) {
    {
#line 2638
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2639
    error___0 = 1;
    }
  } else
#line 2635
  if (color_type == 5) {
    {
#line 2638
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2639
    error___0 = 1;
    }
  } else
#line 2635
  if (color_type > 6) {
    {
#line 2638
    png_warning(png_ptr, "Invalid color type in IHDR");
#line 2639
    error___0 = 1;
    }
  }
#line 2642
  if (color_type == 3) {
#line 2642
    if (bit_depth > 8) {
      {
#line 2647
      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
#line 2648
      error___0 = 1;
      }
    } else {
#line 2642
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2642
  if (color_type == 2) {
#line 2642
    goto _L;
  } else
#line 2642
  if (color_type == 4) {
#line 2642
    goto _L;
  } else
#line 2642
  if (color_type == 6) {
    _L: /* CIL Label */ 
#line 2642
    if (bit_depth < 8) {
      {
#line 2647
      png_warning(png_ptr, "Invalid color type/bit depth combination in IHDR");
#line 2648
      error___0 = 1;
      }
    }
  }
#line 2651
  if (interlace_type >= 2) {
    {
#line 2653
    png_warning(png_ptr, "Unknown interlace method in IHDR");
#line 2654
    error___0 = 1;
    }
  }
#line 2657
  if (compression_type != 0) {
    {
#line 2659
    png_warning(png_ptr, "Unknown compression method in IHDR");
#line 2660
    error___0 = 1;
    }
  }
#line 2697
  if (filter_type != 0) {
    {
#line 2699
    png_warning(png_ptr, "Unknown filter method in IHDR");
#line 2700
    error___0 = 1;
    }
  }
#line 2704
  if (error___0 == 1) {
    {
#line 2705
    png_error(png_ptr, "Invalid IHDR data");
    }
  }
#line 2706
  return;
}
}
#line 1006 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
png_voidp __attribute__((__malloc__))  png_malloc_array(png_const_structrp png_ptr ,
                                                        int nelements , size_t element_size ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
void png_destroy_png_struct(png_structrp png_ptr ) 
{ 
  png_struct dummy_struct ;

  {
#line 27
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 32
    dummy_struct = *png_ptr;
#line 33
    memset((void *)png_ptr, 0, sizeof(*png_ptr));
#line 34
    png_free((png_const_structrp )(& dummy_struct), (png_voidp )png_ptr);
    }
  }
#line 41
  return;
}
}
#line 49 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_calloc(png_const_structrp png_ptr , png_alloc_size_t size ) 
{ 
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
  {
#line 54
  tmp = png_malloc(png_ptr, size);
#line 54
  ret = (png_voidp )tmp;
  }
#line 56
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    {
#line 57
    memset(ret, 0, size);
    }
  }
#line 59
  return ((png_voidp __attribute__((__malloc__))  )ret);
}
}
#line 67 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_base(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) 
{ 
  void *tmp ;

  {
#line 83
  if (size > 0UL) {
#line 83
    if (size <= 0xffffffffffffffffUL) {
      {
#line 95
      tmp = malloc(size);
      }
#line 95
      return ((png_voidp __attribute__((__malloc__))  )tmp);
    } else {
#line 99
      return ((png_voidp __attribute__((__malloc__))  )((void *)0));
    }
  } else {
#line 99
    return ((png_voidp __attribute__((__malloc__))  )((void *)0));
  }
}
}
#line 108 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
static png_voidp png_malloc_array_checked(png_const_structrp png_ptr , int nelements ,
                                          size_t element_size ) 
{ 
  png_alloc_size_t req ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 112
  req = (png_alloc_size_t )nelements;
#line 114
  if (req <= 0xffffffffffffffffUL / element_size) {
    {
#line 115
    tmp = png_malloc_base(png_ptr, req * element_size);
    }
#line 115
    return ((png_voidp )tmp);
  }
#line 118
  return ((void *)0);
}
}
#line 121 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_array(png_const_structrp png_ptr ,
                                                        int nelements , size_t element_size ) 
{ 
  png_voidp tmp ;

  {
#line 125
  if (nelements <= 0) {
    {
#line 126
    png_error(png_ptr, "internal error: array alloc");
    }
  } else
#line 125
  if (element_size == 0UL) {
    {
#line 126
    png_error(png_ptr, "internal error: array alloc");
    }
  }
  {
#line 128
  tmp = png_malloc_array_checked(png_ptr, nelements, element_size);
  }
#line 128
  return ((png_voidp __attribute__((__malloc__))  )tmp);
}
}
#line 131 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_realloc_array(png_const_structrp png_ptr ,
                                                         png_const_voidp old_array ,
                                                         int old_elements , int add_elements ,
                                                         size_t element_size ) 
{ 
  png_voidp new_array ;
  png_voidp tmp ;

  {
#line 136
  if (add_elements <= 0) {
    {
#line 138
    png_error(png_ptr, "internal error: array realloc");
    }
  } else
#line 136
  if (element_size == 0UL) {
    {
#line 138
    png_error(png_ptr, "internal error: array realloc");
    }
  } else
#line 136
  if (old_elements < 0) {
    {
#line 138
    png_error(png_ptr, "internal error: array realloc");
    }
  } else
#line 136
  if ((unsigned long )old_array == (unsigned long )((void *)0)) {
#line 136
    if (old_elements > 0) {
      {
#line 138
      png_error(png_ptr, "internal error: array realloc");
      }
    }
  }
#line 143
  if (add_elements <= 2147483647 - old_elements) {
    {
#line 145
    tmp = png_malloc_array_checked(png_ptr, old_elements + add_elements, element_size);
#line 145
    new_array = tmp;
    }
#line 148
    if ((unsigned long )new_array != (unsigned long )((void *)0)) {
#line 153
      if (old_elements > 0) {
        {
#line 154
        memcpy((void */* __restrict  */)new_array, (void const   */* __restrict  */)old_array,
               element_size * (size_t )((unsigned int )old_elements));
        }
      }
      {
#line 156
      memset((void *)((char *)new_array + element_size * (size_t )((unsigned int )old_elements)),
             0, element_size * (size_t )((unsigned int )add_elements));
      }
#line 159
      return ((png_voidp __attribute__((__malloc__))  )new_array);
    }
  }
#line 163
  return ((png_voidp __attribute__((__malloc__))  )((void *)0));
}
}
#line 171 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc(png_const_structrp png_ptr , png_alloc_size_t size ) 
{ 
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 176
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 177
    return ((png_voidp __attribute__((__malloc__))  )((void *)0));
  }
  {
#line 179
  tmp = png_malloc_base(png_ptr, size);
#line 179
  ret = (png_voidp )tmp;
  }
#line 181
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    {
#line 182
    png_error(png_ptr, "Out of memory");
    }
  }
#line 184
  return ((png_voidp __attribute__((__malloc__))  )ret);
}
}
#line 211 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
png_voidp __attribute__((__malloc__))  png_malloc_warn(png_const_structrp png_ptr ,
                                                       png_alloc_size_t size ) 
{ 
  png_voidp ret ;
  png_voidp __attribute__((__malloc__))  tmp ;

  {
#line 215
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
    {
#line 217
    tmp = png_malloc_base(png_ptr, size);
#line 217
    ret = (png_voidp )tmp;
    }
#line 219
    if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 220
      return ((png_voidp __attribute__((__malloc__))  )ret);
    }
    {
#line 222
    png_warning(png_ptr, "Out of memory");
    }
  }
#line 225
  return ((png_voidp __attribute__((__malloc__))  )((void *)0));
}
}
#line 231 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngmem.c"
void png_free(png_const_structrp png_ptr , png_voidp ptr ) 
{ 


  {
#line 234
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 235
    return;
  } else
#line 234
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 235
    return;
  }
  {
#line 252
  free(ptr);
  }
#line 253
  return;
}
}
#line 964 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
png_size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) ;
#line 1869
png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                          png_uint_32 flag ) ;
#line 1873
png_size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1880
png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1891
png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1896
png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1900
png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1904
png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1908
png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1912
png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1916
png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1920
png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1924
png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1926
png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1928
png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1934
png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1938
png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1940
png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1942
png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1944
png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1951
png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) ;
#line 1956
png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_color_16p *background ) ;
#line 2040
png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_16p *hist ) ;
#line 2046
png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                         int *color_type , int *interlace_type , int *compression_type ,
                         int *filter_type ) ;
#line 2092
png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr , png_colorp *palette ,
                         int *num_palette ) ;
#line 2099
png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_color_8p *sig_bit ) ;
#line 2171
png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *trans_alpha ,
                         int *num_trans , png_color_16p *trans_color ) ;
#line 2338
int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_unknown_chunkpp unknowns ) ;
#line 2394
png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) ;
#line 2396
png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) ;
#line 2401
png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) ;
#line 2406
png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) ;
#line 2443
png_uint_32 png_get_io_state(png_const_structrp png_ptr ) ;
#line 2449
png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) ;
#line 2646
int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_valid(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                          png_uint_32 flag ) 
{ 


  {
#line 23
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 23
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 24
      return ((png_uint_32 )(info_ptr->valid & (unsigned int const   )flag));
    }
  }
#line 26
  return ((png_uint_32 )0);
}
}
#line 29 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_size_t png_get_rowbytes(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 32
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 32
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 33
      return ((png_size_t )info_ptr->rowbytes);
    }
  }
#line 35
  return ((png_size_t )0);
}
}
#line 39 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_bytepp png_get_rows(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 42
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 42
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 43
      return ((png_bytepp )info_ptr->row_pointers);
    }
  }
#line 45
  return ((png_bytepp )0);
}
}
#line 51 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_image_width(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 54
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 54
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 55
      return ((png_uint_32 )info_ptr->width);
    }
  }
#line 57
  return ((png_uint_32 )0);
}
}
#line 60 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_image_height(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 63
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 63
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 64
      return ((png_uint_32 )info_ptr->height);
    }
  }
#line 66
  return ((png_uint_32 )0);
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_byte png_get_bit_depth(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 72
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 72
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 73
      return ((png_byte )info_ptr->bit_depth);
    }
  }
#line 75
  return ((png_byte )0);
}
}
#line 78 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_byte png_get_color_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 81
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 81
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 82
      return ((png_byte )info_ptr->color_type);
    }
  }
#line 84
  return ((png_byte )0);
}
}
#line 87 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_byte png_get_filter_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 90
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 90
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 91
      return ((png_byte )info_ptr->filter_type);
    }
  }
#line 93
  return ((png_byte )0);
}
}
#line 96 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_byte png_get_interlace_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 99
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 99
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 100
      return ((png_byte )info_ptr->interlace_type);
    }
  }
#line 102
  return ((png_byte )0);
}
}
#line 105 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_byte png_get_compression_type(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 108
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 108
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 109
      return ((png_byte )info_ptr->compression_type);
    }
  }
#line 111
  return ((png_byte )0);
}
}
#line 114 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_x_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 133
  return ((png_uint_32 )0);
}
}
#line 136 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_y_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 155
  return ((png_uint_32 )0);
}
}
#line 158 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_pixels_per_meter(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 176
  return ((png_uint_32 )0);
}
}
#line 204 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_fixed_point png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 231
  return (0);
}
}
#line 235 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_int_32 png_get_x_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 252
  return (0);
}
}
#line 255 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_int_32 png_get_y_offset_microns(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 272
  return (0);
}
}
#line 275 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_int_32 png_get_x_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 292
  return (0);
}
}
#line 295 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_int_32 png_get_y_offset_pixels(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 312
  return (0);
}
}
#line 466 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_byte png_get_channels(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 469
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 469
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 470
      return ((png_byte )info_ptr->channels);
    }
  }
#line 472
  return ((png_byte )0);
}
}
#line 476 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_const_bytep png_get_signature(png_const_structrp png_ptr , png_const_inforp info_ptr ) 
{ 


  {
#line 479
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 479
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 480
      return ((png_const_bytep )(info_ptr->signature));
    }
  }
#line 482
  return ((png_const_bytep )((void *)0));
}
}
#line 487 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_bKGD(png_const_structrp png_ptr , png_inforp info_ptr , png_color_16p *background ) 
{ 


  {
#line 491
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 491
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 491
      if ((info_ptr->valid & 32U) != 0U) {
#line 491
        if ((unsigned long )background != (unsigned long )((void *)0)) {
#line 497
          *background = & info_ptr->background;
#line 498
          return (32U);
        }
      }
    }
  }
#line 501
  return ((png_uint_32 )0);
}
}
#line 806 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_hIST(png_const_structrp png_ptr , png_inforp info_ptr , png_uint_16p *hist ) 
{ 


  {
#line 812
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 812
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 812
      if ((info_ptr->valid & 64U) != 0U) {
#line 812
        if ((unsigned long )hist != (unsigned long )((void *)0)) {
#line 815
          *hist = info_ptr->hist;
#line 816
          return (64U);
        }
      }
    }
  }
#line 819
  return ((png_uint_32 )0);
}
}
#line 823 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_IHDR(png_const_structrp png_ptr , png_const_inforp info_ptr ,
                         png_uint_32 *width , png_uint_32 *height , int *bit_depth ,
                         int *color_type , int *interlace_type , int *compression_type ,
                         int *filter_type ) 
{ 


  {
#line 831
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 832
    return ((png_uint_32 )0);
  } else
#line 831
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 832
    return ((png_uint_32 )0);
  }
#line 834
  if ((unsigned long )width != (unsigned long )((void *)0)) {
#line 835
    *width = (png_uint_32 )info_ptr->width;
  }
#line 837
  if ((unsigned long )height != (unsigned long )((void *)0)) {
#line 838
    *height = (png_uint_32 )info_ptr->height;
  }
#line 840
  if ((unsigned long )bit_depth != (unsigned long )((void *)0)) {
#line 841
    *bit_depth = (int )info_ptr->bit_depth;
  }
#line 843
  if ((unsigned long )color_type != (unsigned long )((void *)0)) {
#line 844
    *color_type = (int )info_ptr->color_type;
  }
#line 846
  if ((unsigned long )compression_type != (unsigned long )((void *)0)) {
#line 847
    *compression_type = (int )info_ptr->compression_type;
  }
#line 849
  if ((unsigned long )filter_type != (unsigned long )((void *)0)) {
#line 850
    *filter_type = (int )info_ptr->filter_type;
  }
#line 852
  if ((unsigned long )interlace_type != (unsigned long )((void *)0)) {
#line 853
    *interlace_type = (int )info_ptr->interlace_type;
  }
  {
#line 860
  png_check_IHDR(png_ptr, (png_uint_32 )info_ptr->width, (png_uint_32 )info_ptr->height,
                 (int )info_ptr->bit_depth, (int )info_ptr->color_type, (int )info_ptr->interlace_type,
                 (int )info_ptr->compression_type, (int )info_ptr->filter_type);
  }
#line 864
  return ((png_uint_32 )1);
}
}
#line 1010 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_PLTE(png_const_structrp png_ptr , png_inforp info_ptr , png_colorp *palette ,
                         int *num_palette ) 
{ 


  {
#line 1016
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1016
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1016
      if ((info_ptr->valid & 8U) != 0U) {
#line 1016
        if ((unsigned long )palette != (unsigned long )((void *)0)) {
#line 1019
          *palette = info_ptr->palette;
#line 1020
          *num_palette = (int )info_ptr->num_palette;
#line 1022
          return (8U);
        }
      }
    }
  }
#line 1025
  return ((png_uint_32 )0);
}
}
#line 1029 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_sBIT(png_const_structrp png_ptr , png_inforp info_ptr , png_color_8p *sig_bit ) 
{ 


  {
#line 1035
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1035
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1035
      if ((info_ptr->valid & 2U) != 0U) {
#line 1035
        if ((unsigned long )sig_bit != (unsigned long )((void *)0)) {
#line 1038
          *sig_bit = & info_ptr->sig_bit;
#line 1039
          return (2U);
        }
      }
    }
  }
#line 1042
  return ((png_uint_32 )0);
}
}
#line 1091 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_tRNS(png_const_structrp png_ptr , png_inforp info_ptr , png_bytep *trans_alpha ,
                         int *num_trans , png_color_16p *trans_color ) 
{ 
  png_uint_32 retval ;

  {
#line 1095
  retval = (png_uint_32 )0;
#line 1096
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1096
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1096
      if ((info_ptr->valid & 16U) != 0U) {
#line 1101
        if ((int )info_ptr->color_type == 3) {
#line 1103
          if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1105
            *trans_alpha = info_ptr->trans_alpha;
#line 1106
            retval |= 16U;
          }
#line 1109
          if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1110
            *trans_color = & info_ptr->trans_color;
          }
        } else {
#line 1115
          if ((unsigned long )trans_color != (unsigned long )((void *)0)) {
#line 1117
            *trans_color = & info_ptr->trans_color;
#line 1118
            retval |= 16U;
          }
#line 1121
          if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1122
            *trans_alpha = (png_bytep )((void *)0);
          }
        }
#line 1125
        if ((unsigned long )num_trans != (unsigned long )((void *)0)) {
#line 1127
          *num_trans = (int )info_ptr->num_trans;
#line 1128
          retval |= 16U;
        }
      }
    }
  }
#line 1132
  return (retval);
}
}
#line 1137 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
int png_get_unknown_chunks(png_const_structrp png_ptr , png_inforp info_ptr , png_unknown_chunkpp unknowns ) 
{ 


  {
#line 1141
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1141
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1141
      if ((unsigned long )unknowns != (unsigned long )((void *)0)) {
#line 1143
        *unknowns = info_ptr->unknown_chunks;
#line 1144
        return (info_ptr->unknown_chunks_num);
      }
    }
  }
#line 1147
  return (0);
}
}
#line 1167 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_size_t png_get_compression_buffer_size(png_const_structrp png_ptr ) 
{ 


  {
#line 1170
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 1171
    return ((png_size_t )0);
  }
#line 1174
  if ((png_ptr->mode & 32768U) != 0U) {
#line 1178
    return ((png_size_t )png_ptr->IDAT_read_size);
  } else {
#line 1186
    return ((png_size_t )png_ptr->zbuffer_size);
  }
}
}
#line 1193 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_user_width_max(png_const_structrp png_ptr ) 
{ 
  png_uint_32 tmp ;

  {
#line 1196
  if (png_ptr) {
#line 1196
    tmp = png_ptr->user_width_max;
  } else {
#line 1196
    tmp = (png_uint_32 const   )0;
  }
#line 1196
  return ((png_uint_32 )tmp);
}
}
#line 1199 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_user_height_max(png_const_structrp png_ptr ) 
{ 
  png_uint_32 tmp ;

  {
#line 1202
  if (png_ptr) {
#line 1202
    tmp = png_ptr->user_height_max;
  } else {
#line 1202
    tmp = (png_uint_32 const   )0;
  }
#line 1202
  return ((png_uint_32 )tmp);
}
}
#line 1206 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_chunk_cache_max(png_const_structrp png_ptr ) 
{ 
  png_uint_32 tmp ;

  {
#line 1209
  if (png_ptr) {
#line 1209
    tmp = png_ptr->user_chunk_cache_max;
  } else {
#line 1209
    tmp = (png_uint_32 const   )0;
  }
#line 1209
  return ((png_uint_32 )tmp);
}
}
#line 1213 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_alloc_size_t png_get_chunk_malloc_max(png_const_structrp png_ptr ) 
{ 
  png_alloc_size_t tmp ;

  {
#line 1216
  if (png_ptr) {
#line 1216
    tmp = png_ptr->user_chunk_malloc_max;
  } else {
#line 1216
    tmp = (png_alloc_size_t const   )0;
  }
#line 1216
  return ((png_alloc_size_t )tmp);
}
}
#line 1222 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_io_state(png_const_structrp png_ptr ) 
{ 


  {
#line 1225
  return ((png_uint_32 )png_ptr->io_state);
}
}
#line 1228 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
png_uint_32 png_get_io_chunk_type(png_const_structrp png_ptr ) 
{ 


  {
#line 1231
  return ((png_uint_32 )png_ptr->chunk_name);
}
}
#line 1237 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngget.c"
int png_get_palette_max(png_const_structp png_ptr , png_const_infop info_ptr ) 
{ 


  {
#line 1240
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 1240
    if ((unsigned long )info_ptr != (unsigned long )((void *)0)) {
#line 1241
      return ((int )png_ptr->num_palette_max);
    }
  }
#line 1243
  return (-1);
}
}
#line 994 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/png.h"
 __attribute__((__noreturn__)) void png_longjmp(png_const_structrp png_ptr , int val ) ;
#line 1606
png_voidp png_get_error_ptr(png_const_structrp png_ptr ) ;
#line 1735 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngpriv.h"
png_charp png_format_number(png_const_charp start , png_charp end , int format , png_alloc_size_t number ) ;
#line 1768
void png_warning_parameter(char (*p)[32] , int number , png_const_charp string ) ;
#line 1773
void png_warning_parameter_unsigned(char (*p)[32] , int number , int format , png_alloc_size_t value ) ;
#line 1779
void png_warning_parameter_signed(char (*p)[32] , int number , int format , png_int_32 value ) ;
#line 1783
void png_formatted_warning(png_const_structrp png_ptr , char (*p)[32] , png_const_charp message ) ;
#line 23 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
static  __attribute__((__noreturn__)) void png_default_error(png_const_structrp png_ptr ,
                                                             png_const_charp error_message ) ;
#line 27
static void png_default_warning(png_const_structrp png_ptr , png_const_charp warning_message ) ;
#line 38
 __attribute__((__noreturn__)) void png_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 38 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 82
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 82
    if ((unsigned long )png_ptr->error_fn != (unsigned long )((void *)0)) {
      {
#line 83
      (*(png_ptr->error_fn))((png_structp )((png_structrp )((png_ptruint )((void const   *)png_ptr))),
                             error_message);
      }
    }
  }
  {
#line 88
  png_default_error(png_ptr, error_message);
  }
}
}
#line 111 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
size_t png_safecat(png_charp buffer___0 , size_t bufsize , size_t pos , png_const_charp string ) 
{ 
  size_t tmp ;
  png_const_charp tmp___0 ;

  {
#line 115
  if ((unsigned long )buffer___0 != (unsigned long )((void *)0)) {
#line 115
    if (pos < bufsize) {
#line 117
      if ((unsigned long )string != (unsigned long )((void *)0)) {
        {
#line 118
        while (1) {
          while_continue: /* CIL Label */ ;
#line 118
          if ((int const   )*string != 0) {
#line 118
            if (! (pos < bufsize - 1UL)) {
#line 118
              goto while_break;
            }
          } else {
#line 118
            goto while_break;
          }
#line 119
          tmp = pos;
#line 119
          pos ++;
#line 119
          tmp___0 = string;
#line 119
          string ++;
#line 119
          *(buffer___0 + tmp) = (char )*tmp___0;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 121
      *(buffer___0 + pos) = (char )'\000';
    }
  }
#line 124
  return (pos);
}
}
#line 148 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
static char const   digits[17]  = 
#line 148
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'\000'};
#line 132 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
png_charp png_format_number(png_const_charp start , png_charp end , int format , png_alloc_size_t number ) 
{ 
  int count ;
  int mincount ;
  int output ;

  {
#line 136
  count = 0;
#line 137
  mincount = 1;
#line 138
  output = 0;
#line 140
  end --;
#line 140
  *end = (char )'\000';
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if ((unsigned long )end > (unsigned long )start) {
#line 145
      if (! (number != 0UL)) {
#line 145
        if (! (count < mincount)) {
#line 145
          goto while_break;
        }
      }
    } else {
#line 145
      goto while_break;
    }
    {
#line 152
    if (format == 5) {
#line 152
      goto case_5;
    }
#line 163
    if (format == 2) {
#line 163
      goto case_2;
    }
#line 168
    if (format == 1) {
#line 168
      goto case_1;
    }
#line 173
    if (format == 4) {
#line 173
      goto case_4;
    }
#line 178
    if (format == 3) {
#line 178
      goto case_3;
    }
#line 183
    goto switch_default;
    case_5: /* CIL Label */ 
#line 154
    mincount = 5;
#line 155
    if (output != 0) {
#line 157
      end --;
#line 157
      *end = (char )digits[number % 10UL];
#line 158
      output = 1;
    } else
#line 155
    if (number % 10UL != 0UL) {
#line 157
      end --;
#line 157
      *end = (char )digits[number % 10UL];
#line 158
      output = 1;
    }
#line 160
    number /= 10UL;
#line 161
    goto switch_break;
    case_2: /* CIL Label */ 
#line 165
    mincount = 2;
    case_1: /* CIL Label */ 
#line 169
    end --;
#line 169
    *end = (char )digits[number % 10UL];
#line 170
    number /= 10UL;
#line 171
    goto switch_break;
    case_4: /* CIL Label */ 
#line 175
    mincount = 2;
    case_3: /* CIL Label */ 
#line 179
    end --;
#line 179
    *end = (char )digits[number & 15UL];
#line 180
    number >>= 4;
#line 181
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    number = (png_alloc_size_t )0;
#line 185
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 189
    count ++;
#line 192
    if (format == 5) {
#line 192
      if (count == 5) {
#line 192
        if ((unsigned long )end > (unsigned long )start) {
#line 198
          if (output != 0) {
#line 199
            end --;
#line 199
            *end = (char )'.';
          } else
#line 200
          if (number == 0UL) {
#line 201
            end --;
#line 201
            *end = (char )'0';
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return (end);
}
}
#line 215 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_warning(png_const_structrp png_ptr , png_const_charp warning_message ) 
{ 
  int offset ;

  {
#line 218
  offset = 0;
#line 219
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 226
    if ((int const   )*warning_message == 35) {
#line 228
      offset = 1;
      {
#line 228
      while (1) {
        while_continue: /* CIL Label */ ;
#line 228
        if (! (offset < 15)) {
#line 228
          goto while_break;
        }
#line 229
        if ((int const   )*(warning_message + offset) == 32) {
#line 230
          goto while_break;
        }
#line 228
        offset ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 234
  if ((unsigned long )png_ptr != (unsigned long )((void *)0)) {
#line 234
    if ((unsigned long )png_ptr->warning_fn != (unsigned long )((void *)0)) {
      {
#line 235
      (*(png_ptr->warning_fn))((png_structp )((png_structrp )((png_ptruint )((void const   *)png_ptr))),
                               warning_message + offset);
      }
    } else {
      {
#line 238
      png_default_warning(png_ptr, warning_message + offset);
      }
    }
  } else {
    {
#line 238
    png_default_warning(png_ptr, warning_message + offset);
    }
  }
#line 239
  return;
}
}
#line 246 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_warning_parameter(char (*p)[32] , int number , png_const_charp string ) 
{ 


  {
#line 250
  if (number > 0) {
#line 250
    if (number <= 8) {
      {
#line 251
      png_safecat(*(p + (number - 1)), sizeof(*(p + (number - 1))), (size_t )0, string);
      }
    }
  }
#line 252
  return;
}
}
#line 254 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_warning_parameter_unsigned(char (*p)[32] , int number , int format , png_alloc_size_t value ) 
{ 
  char buffer___0[24] ;
  png_charp tmp ;

  {
  {
#line 259
  tmp = png_format_number((png_const_charp )(buffer___0), buffer___0 + sizeof(buffer___0),
                          format, value);
#line 259
  png_warning_parameter(p, number, (png_const_charp )tmp);
  }
#line 260
  return;
}
}
#line 262 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_warning_parameter_signed(char (*p)[32] , int number , int format , png_int_32 value ) 
{ 
  png_alloc_size_t u ;
  png_charp str ;
  char buffer___0[24] ;

  {
#line 271
  u = (png_alloc_size_t )value;
#line 272
  if (value < 0) {
#line 273
    u = ~ u + 1UL;
  }
  {
#line 275
  str = png_format_number((png_const_charp )(buffer___0), buffer___0 + sizeof(buffer___0),
                          format, u);
  }
#line 277
  if (value < 0) {
#line 277
    if ((unsigned long )str > (unsigned long )(buffer___0)) {
#line 278
      str --;
#line 278
      *str = (char )'-';
    }
  }
  {
#line 280
  png_warning_parameter(p, number, (png_const_charp )str);
  }
#line 281
  return;
}
}
#line 309 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
static char const   valid_parameters[10]  = 
#line 309
  {      (char const   )'1',      (char const   )'2',      (char const   )'3',      (char const   )'4', 
        (char const   )'5',      (char const   )'6',      (char const   )'7',      (char const   )'8', 
        (char const   )'9',      (char const   )'\000'};
#line 283 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_formatted_warning(png_const_structrp png_ptr , char (*p)[32] , png_const_charp message ) 
{ 
  size_t i ;
  char msg[192] ;
  int parameter_char ;
  int parameter ;
  png_const_charp parm ;
  png_const_charp pend ;
  size_t tmp ;
  png_const_charp tmp___0 ;
  size_t tmp___1 ;
  png_const_charp tmp___2 ;

  {
#line 292
  i = (size_t )0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (i < sizeof(msg) - 1UL) {
#line 301
      if (! ((int const   )*message != 0)) {
#line 301
        goto while_break;
      }
    } else {
#line 301
      goto while_break;
    }
#line 306
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 306
      if ((int const   )*message == 64) {
#line 306
        if ((int const   )*(message + 1) != 0) {
#line 308
          message ++;
#line 308
          parameter_char = (int )*message;
#line 310
          parameter = 0;
          {
#line 315
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 315
            if ((int const   )valid_parameters[parameter] != (int const   )parameter_char) {
#line 315
              if (! ((int const   )valid_parameters[parameter] != 0)) {
#line 315
                goto while_break___0;
              }
            } else {
#line 315
              goto while_break___0;
            }
#line 317
            parameter ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 320
          if (parameter < 8) {
#line 323
            parm = (png_const_charp )(*(p + parameter));
#line 324
            pend = (png_const_charp )(*(p + parameter) + sizeof(*(p + parameter)));
            {
#line 330
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 330
              if (i < sizeof(msg) - 1UL) {
#line 330
                if ((int const   )*parm != 0) {
#line 330
                  if (! ((unsigned long )parm < (unsigned long )pend)) {
#line 330
                    goto while_break___1;
                  }
                } else {
#line 330
                  goto while_break___1;
                }
              } else {
#line 330
                goto while_break___1;
              }
#line 331
              tmp = i;
#line 331
              i ++;
#line 331
              tmp___0 = parm;
#line 331
              parm ++;
#line 331
              msg[tmp] = (char )*tmp___0;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 334
            message ++;
#line 335
            goto while_continue;
          }
        }
      }
    }
#line 346
    tmp___1 = i;
#line 346
    i ++;
#line 346
    tmp___2 = message;
#line 346
    message ++;
#line 346
    msg[tmp___1] = (char )*tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 350
  msg[i] = (char )'\000';
#line 356
  png_warning(png_ptr, (png_const_charp )(msg));
  }
#line 357
  return;
}
}
#line 361 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 364
  if ((png_ptr->flags & 1048576U) != 0U) {
#line 367
    if ((png_ptr->mode & 32768U) != 0U) {
#line 367
      if (png_ptr->chunk_name != 0U) {
        {
#line 369
        png_chunk_warning(png_ptr, error_message);
        }
      } else {
        {
#line 372
        png_warning(png_ptr, error_message);
        }
      }
    } else {
      {
#line 372
      png_warning(png_ptr, error_message);
      }
    }
  } else
#line 378
  if ((png_ptr->mode & 32768U) != 0U) {
#line 378
    if (png_ptr->chunk_name != 0U) {
      {
#line 380
      png_chunk_error(png_ptr, error_message);
      }
    } else {
      {
#line 383
      png_error(png_ptr, error_message);
      }
    }
  } else {
    {
#line 383
    png_error(png_ptr, error_message);
    }
  }
#line 389
  return;
}
}
#line 391 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_app_warning(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 394
  if ((png_ptr->flags & 2097152U) != 0U) {
    {
#line 395
    png_warning(png_ptr, error_message);
    }
  } else {
    {
#line 397
    png_error(png_ptr, error_message);
    }
  }
#line 402
  return;
}
}
#line 404 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_app_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 407
  if ((png_ptr->flags & 4194304U) != 0U) {
    {
#line 408
    png_warning(png_ptr, error_message);
    }
  } else {
    {
#line 410
    png_error(png_ptr, error_message);
    }
  }
#line 415
  return;
}
}
#line 428 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
static char const   png_digit[16]  = 
#line 428
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F'};
#line 433 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
static void png_format_buffer(png_const_structrp png_ptr , png_charp buffer___0 ,
                              png_const_charp error_message ) 
{ 
  png_uint_32 chunk_name ;
  int iout ;
  int ishift ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int iin ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 437
  chunk_name = (png_uint_32 )png_ptr->chunk_name;
#line 438
  iout = 0;
#line 438
  ishift = 24;
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (ishift >= 0)) {
#line 440
      goto while_break;
    }
#line 442
    c = (int )(chunk_name >> ishift) & 255;
#line 444
    ishift -= 8;
#line 445
    if (c < 65) {
#line 445
      tmp___4 = 1;
    } else
#line 445
    if (c > 122) {
#line 445
      tmp___4 = 1;
    } else
#line 445
    if (c > 90) {
#line 445
      if (c < 97) {
#line 445
        tmp___4 = 1;
      } else {
#line 445
        tmp___4 = 0;
      }
    } else {
#line 445
      tmp___4 = 0;
    }
#line 445
    if (tmp___4 != 0) {
#line 447
      tmp = iout;
#line 447
      iout ++;
#line 447
      *(buffer___0 + tmp) = (char)91;
#line 448
      tmp___0 = iout;
#line 448
      iout ++;
#line 448
      *(buffer___0 + tmp___0) = (char )png_digit[(c & 240) >> 4];
#line 449
      tmp___1 = iout;
#line 449
      iout ++;
#line 449
      *(buffer___0 + tmp___1) = (char )png_digit[c & 15];
#line 450
      tmp___2 = iout;
#line 450
      iout ++;
#line 450
      *(buffer___0 + tmp___2) = (char)93;
    } else {
#line 455
      tmp___3 = iout;
#line 455
      iout ++;
#line 455
      *(buffer___0 + tmp___3) = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  if ((unsigned long )error_message == (unsigned long )((void *)0)) {
#line 460
    *(buffer___0 + iout) = (char )'\000';
  } else {
#line 464
    iin = 0;
#line 466
    tmp___5 = iout;
#line 466
    iout ++;
#line 466
    *(buffer___0 + tmp___5) = (char )':';
#line 467
    tmp___6 = iout;
#line 467
    iout ++;
#line 467
    *(buffer___0 + tmp___6) = (char )' ';
    {
#line 469
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 469
      if (iin < 195) {
#line 469
        if (! ((int const   )*(error_message + iin) != 0)) {
#line 469
          goto while_break___0;
        }
      } else {
#line 469
        goto while_break___0;
      }
#line 470
      tmp___7 = iout;
#line 470
      iout ++;
#line 470
      tmp___8 = iin;
#line 470
      iin ++;
#line 470
      *(buffer___0 + tmp___7) = (char )*(error_message + tmp___8);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 473
    *(buffer___0 + iout) = (char )'\000';
  }
#line 475
  return;
}
}
#line 479
 __attribute__((__noreturn__)) void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) ;
#line 479 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_chunk_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 
  char msg[214] ;

  {
#line 484
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
    {
#line 485
    png_error(png_ptr, error_message);
    }
  } else {
    {
#line 489
    png_format_buffer(png_ptr, msg, error_message);
#line 490
    png_error(png_ptr, (png_const_charp )(msg));
    }
  }
}
}
#line 496 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_chunk_warning(png_const_structrp png_ptr , png_const_charp warning_message ) 
{ 
  char msg[214] ;

  {
#line 500
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
    {
#line 501
    png_warning(png_ptr, warning_message);
    }
  } else {
    {
#line 505
    png_format_buffer(png_ptr, msg, warning_message);
#line 506
    png_warning(png_ptr, (png_const_charp )(msg));
    }
  }
#line 508
  return;
}
}
#line 513 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_chunk_benign_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 


  {
#line 517
  if ((png_ptr->flags & 1048576U) != 0U) {
    {
#line 518
    png_chunk_warning(png_ptr, error_message);
    }
  } else {
    {
#line 521
    png_chunk_error(png_ptr, error_message);
    }
  }
#line 526
  return;
}
}
#line 530 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_chunk_report(png_const_structrp png_ptr , png_const_charp message , int error___0 ) 
{ 


  {
#line 541
  if ((png_ptr->mode & 32768U) != 0U) {
#line 546
    if (error___0 < 2) {
      {
#line 547
      png_chunk_warning(png_ptr, message);
      }
    } else {
      {
#line 550
      png_chunk_benign_error(png_ptr, message);
      }
    }
  } else
#line 555
  if ((png_ptr->mode & 32768U) == 0U) {
#line 560
    if (error___0 < 1) {
      {
#line 561
      png_app_warning(png_ptr, message);
      }
    } else {
      {
#line 564
      png_app_error(png_ptr, message);
      }
    }
  }
#line 567
  return;
}
}
#line 710
static  __attribute__((__noreturn__)) void png_default_error(png_const_structrp png_ptr ,
                                                             png_const_charp error_message ) ;
#line 710 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
static void png_default_error(png_const_structrp png_ptr , png_const_charp error_message ) 
{ 
  png_const_charp tmp ;

  {
#line 747
  if (error_message) {
#line 747
    tmp = error_message;
  } else {
#line 747
    tmp = "undefined";
  }
  {
#line 747
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libpng error: %s",
          tmp);
#line 749
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 754
  png_longjmp(png_ptr, 1);
  }
}
}
#line 757
 __attribute__((__noreturn__)) void png_longjmp(png_const_structrp png_ptr , int val ) ;
#line 757 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_longjmp(png_const_structrp png_ptr , int val ) 
{ 


  {
  {
#line 775
  abort();
  }
}
}
#line 784 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
static void png_default_warning(png_const_structrp png_ptr , png_const_charp warning_message ) 
{ 


  {
  {
#line 819
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libpng warning: %s",
          warning_message);
#line 820
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 826
  return;
}
}
#line 834 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
void png_set_error_fn(png_structrp png_ptr , png_voidp error_ptr , void (*error_fn)(png_structp  ,
                                                                                    png_const_charp  ) ,
                      void (*warning_fn)(png_structp  , png_const_charp  ) ) 
{ 


  {
#line 838
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 839
    return;
  }
#line 841
  png_ptr->error_ptr = error_ptr;
#line 842
  png_ptr->error_fn = error_fn;
#line 844
  png_ptr->warning_fn = warning_fn;
#line 848
  return;
}
}
#line 855 "/home/khheo/project/benchmark/optipng-0.7.7/src/libpng/pngerror.c"
png_voidp png_get_error_ptr(png_const_structrp png_ptr ) 
{ 


  {
#line 858
  if ((unsigned long )png_ptr == (unsigned long )((void *)0)) {
#line 859
    return ((void *)0);
  }
#line 861
  return ((png_voidp )png_ptr->error_ptr);
}
}
#line 21 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxutil.h"
void pngx_set_compression_type(png_structp png_ptr , png_infop info_ptr , int compression_type ) ;
#line 23
void pngx_set_filter_type(png_structp png_ptr , png_infop info_ptr , int filter_type ) ;
#line 25
void pngx_set_interlace_type(png_structp png_ptr , png_infop info_ptr , int interlace_type ) ;
#line 22 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxset.c"
void pngx_set_compression_type(png_structp png_ptr , png_infop info_ptr , int compression_type ) 
{ 
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int interlace_type ;
  int filter_type ;
  int old_compression_type ;
  png_uint_32 tmp ;

  {
  {
#line 30
  tmp = png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
                     & height, & bit_depth, & color_type, & interlace_type, & old_compression_type,
                     & filter_type);
  }
#line 30
  if (! tmp) {
#line 32
    return;
  }
#line 33
  if (compression_type == old_compression_type) {
#line 34
    return;
  }
  {
#line 35
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 37
  return;
}
}
#line 39 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxset.c"
void pngx_set_filter_type(png_structp png_ptr , png_infop info_ptr , int filter_type ) 
{ 
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int old_filter_type ;
  png_uint_32 tmp ;

  {
  {
#line 47
  tmp = png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
                     & height, & bit_depth, & color_type, & interlace_type, & compression_type,
                     & old_filter_type);
  }
#line 47
  if (! tmp) {
#line 49
    return;
  }
#line 50
  if (filter_type == old_filter_type) {
#line 51
    return;
  }
  {
#line 52
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 54
  return;
}
}
#line 56 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxset.c"
void pngx_set_interlace_type(png_structp png_ptr , png_infop info_ptr , int interlace_type ) 
{ 
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int compression_type ;
  int filter_type ;
  int old_interlace_type ;
  png_uint_32 tmp ;

  {
  {
#line 64
  tmp = png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
                     & height, & bit_depth, & color_type, & old_interlace_type, & compression_type,
                     & filter_type);
  }
#line 64
  if (! tmp) {
#line 66
    return;
  }
#line 67
  if (interlace_type == old_interlace_type) {
#line 68
    return;
  }
  {
#line 69
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 71
  return;
}
}
#line 43 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxutil.h"
png_bytepp pngx_malloc_rows(png_structp png_ptr , png_infop info_ptr , int filler ) ;
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 56 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxpriv.h"
int pngx_sig_is_tiff(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) ;
#line 59
int pngx_read_tiff(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 19 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
static char const   tiff_fmt_name[5]  = {      (char const   )'T',      (char const   )'I',      (char const   )'F',      (char const   )'F', 
        (char const   )'\000'};
#line 20 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
static char const   tiff_fmt_long_name[25]  = 
#line 20
  {      (char const   )'T',      (char const   )'a',      (char const   )'g',      (char const   )'g', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'I', 
        (char const   )'m',      (char const   )'a',      (char const   )'g',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'\000'};
#line 23 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
int pngx_sig_is_tiff(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 29
  if (sig_size < 8UL) {
#line 30
    return (-1);
  }
  {
#line 31
  tmp = memcmp((void const   *)sig, (void const   *)(minitiff_sig_m), (size_t )4);
  }
#line 31
  if (tmp != 0) {
    {
#line 31
    tmp___0 = memcmp((void const   *)sig, (void const   *)(minitiff_sig_i), (size_t )4);
    }
#line 31
    if (tmp___0 != 0) {
#line 33
      return (0);
    }
  }
#line 36
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 37
    *fmt_name_ptr = tiff_fmt_name;
  }
#line 38
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 39
    *fmt_long_name_ptr = tiff_fmt_long_name;
  }
#line 40
  return (1);
}
}
#line 45 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
static png_structp err_png_ptr  =    (png_structp )((void *)0);
#line 46 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
static unsigned int num_extra_images  ;
#line 48 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
static void pngx_tiff_error(char const   *msg ) 
{ 


  {
  {
#line 50
  png_error((png_const_structrp )err_png_ptr, msg);
  }
}
}
#line 53 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
static void pngx_tiff_warning(char const   *msg ) 
{ 
  char *tmp ;

  {
  {
#line 59
  tmp = strstr(msg, "multi-image");
  }
#line 59
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 60
    num_extra_images ++;
  }
#line 66
  return;
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrtif.c"
int pngx_read_tiff(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  struct minitiff_info tiff_info ;
  unsigned int width ;
  unsigned int height ;
  unsigned int pixel_size ;
  unsigned int sample_depth ;
  unsigned int sample_max ;
  int color_type ;
  int sample_overflow ;
  png_bytepp row_pointers ;
  png_bytep row ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  int tmp ;
  unsigned int b ;
  png_byte b___0 ;
  unsigned int b___1 ;

  {
  {
#line 80
  err_png_ptr = png_ptr;
#line 81
  num_extra_images = 0U;
#line 82
  minitiff_init_info(& tiff_info);
#line 83
  tiff_info.error_handler = & pngx_tiff_error;
#line 84
  tiff_info.warning_handler = & pngx_tiff_warning;
#line 85
  minitiff_read_info(& tiff_info, stream);
#line 86
  minitiff_validate_info((struct minitiff_info  const  *)(& tiff_info));
#line 88
  width = (unsigned int )tiff_info.width;
#line 89
  height = (unsigned int )tiff_info.height;
#line 90
  pixel_size = tiff_info.samples_per_pixel;
#line 91
  sample_depth = tiff_info.bits_per_sample;
  }
  {
#line 94
  if (pixel_size == 1U) {
#line 94
    goto case_1;
  }
#line 97
  if (pixel_size == 2U) {
#line 97
    goto case_2;
  }
#line 100
  if (pixel_size == 3U) {
#line 100
    goto case_3;
  }
#line 103
  if (pixel_size == 4U) {
#line 103
    goto case_4;
  }
#line 106
  goto switch_default;
  case_1: /* CIL Label */ 
#line 95
  color_type = 0;
#line 96
  goto switch_break;
  case_2: /* CIL Label */ 
#line 98
  color_type = 4;
#line 99
  goto switch_break;
  case_3: /* CIL Label */ 
#line 101
  color_type = 2;
#line 102
  goto switch_break;
  case_4: /* CIL Label */ 
#line 104
  color_type = 6;
#line 105
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 107
  png_error((png_const_structrp )png_ptr, "Unsupported TIFF color space");
  }
#line 109
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 111
  if (sample_depth > 16U) {
    {
#line 112
    png_error((png_const_structrp )png_ptr, "Unsupported TIFF sample depth");
    }
  }
#line 113
  sample_max = (unsigned int )((1 << sample_depth) - 1);
#line 114
  sample_overflow = 0;
#line 116
  if (sample_depth <= 8U) {
#line 116
    tmp = 8;
  } else {
#line 116
    tmp = 16;
  }
  {
#line 116
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               tmp, color_type, 0, 0, 0);
#line 120
  row_pointers = pngx_malloc_rows(png_ptr, info_ptr, 0);
  }
#line 122
  if (sample_depth <= 8U) {
#line 124
    i = 0U;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (! (i < height)) {
#line 124
        goto while_break;
      }
      {
#line 126
      row = *(row_pointers + i);
#line 127
      minitiff_read_row(& tiff_info, row, (size_t )i, stream);
      }
#line 128
      if (sample_depth < 8U) {
#line 130
        j = 0U;
        {
#line 130
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 130
          if (! (j < pixel_size * width)) {
#line 130
            goto while_break___0;
          }
#line 132
          b = (unsigned int )*(row + j);
#line 133
          if (b > sample_max) {
#line 135
            b = sample_max;
#line 136
            sample_overflow = 1;
          }
#line 138
          *(row + j) = (png_byte )((b * 255U + sample_max / 2U) / sample_max);
#line 130
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 141
      if (tiff_info.photometric == 0U) {
#line 143
        j = 0U;
        {
#line 143
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 143
          if (! (j < pixel_size * width)) {
#line 143
            goto while_break___1;
          }
#line 144
          *(row + j) = (png_byte )(255 - (int )*(row + j));
#line 143
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 124
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 150
    i = 0U;
    {
#line 150
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 150
      if (! (i < height)) {
#line 150
        goto while_break___2;
      }
      {
#line 152
      row = *(row_pointers + i);
#line 153
      minitiff_read_row(& tiff_info, row, (size_t )i, stream);
      }
#line 154
      if (tiff_info.byte_order == 73) {
#line 157
        k = 0U;
#line 157
        j = k;
        {
#line 157
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 157
          if (! (j < pixel_size * width)) {
#line 157
            goto while_break___3;
          }
#line 159
          b___0 = *(row + k);
#line 160
          *(row + k) = *(row + (k + 1U));
#line 161
          *(row + (k + 1U)) = b___0;
#line 157
          j ++;
#line 157
          k += 2U;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 164
      if (sample_depth < 16U) {
#line 166
        k = 0U;
#line 166
        j = k;
        {
#line 166
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 166
          if (! (k < pixel_size * width)) {
#line 166
            goto while_break___4;
          }
#line 168
          b___1 = (unsigned int )(((int )*(row + k) << 8) + (int )*(row + (k + 1U)));
#line 169
          if (b___1 > sample_max) {
#line 171
            b___1 = sample_max;
#line 172
            sample_overflow = 1;
          }
#line 174
          b___1 = (b___1 * 65535U + sample_max / 2U) / sample_max;
#line 175
          *(row + k) = (png_byte )(b___1 >> 8);
#line 176
          *(row + (k + 1U)) = (png_byte )(b___1 & 255U);
#line 166
          j ++;
#line 166
          k += 2U;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 150
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 182
  if (sample_overflow) {
    {
#line 183
    png_warning((png_const_structrp )png_ptr, "Overflow in TIFF samples");
    }
  }
  {
#line 185
  minitiff_destroy_info(& tiff_info);
  }
#line 186
  return ((int )(1U + num_extra_images));
}
}
#line 50 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxpriv.h"
int pngx_sig_is_pnm(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 53
int pngx_read_pnm(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 24 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   pbm_fmt_name[4]  = {      (char const   )'P',      (char const   )'B',      (char const   )'M',      (char const   )'\000'};
#line 25 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   pgm_fmt_name[4]  = {      (char const   )'P',      (char const   )'G',      (char const   )'M',      (char const   )'\000'};
#line 26 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   ppm_fmt_name[4]  = {      (char const   )'P',      (char const   )'P',      (char const   )'M',      (char const   )'\000'};
#line 27 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   pam_fmt_name[4]  = {      (char const   )'P',      (char const   )'A',      (char const   )'M',      (char const   )'\000'};
#line 28 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   pbm_fmt_long_name[16]  = 
#line 28
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'B',      (char const   )'i',      (char const   )'t', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 29 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   pgm_fmt_long_name[17]  = 
#line 29
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'G',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )'m',      (char const   )'a',      (char const   )'p', 
        (char const   )'\000'};
#line 30 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   ppm_fmt_long_name[16]  = 
#line 30
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'P',      (char const   )'i',      (char const   )'x', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 31 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   pam_fmt_long_name[16]  = 
#line 31
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'A',      (char const   )'n',      (char const   )'y', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 39 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   *fmt_names[7]  = {      pbm_fmt_name,      pgm_fmt_name,      ppm_fmt_name,      pbm_fmt_name, 
        pgm_fmt_name,      ppm_fmt_name,      pam_fmt_name};
#line 45 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static char const   *fmt_long_names[7]  = {      pbm_fmt_long_name,      pgm_fmt_long_name,      ppm_fmt_long_name,      pbm_fmt_long_name, 
        pgm_fmt_long_name,      ppm_fmt_long_name,      pam_fmt_long_name};
#line 34 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
int pngx_sig_is_pnm(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 


  {
#line 53
  if (sig_size < 4UL) {
#line 54
    return (-1);
  }
#line 55
  if ((int )*(sig + 0) != 80) {
#line 56
    return (0);
  } else
#line 55
  if ((int )*(sig + 1) < 49) {
#line 56
    return (0);
  } else
#line 55
  if ((int )*(sig + 1) > 55) {
#line 56
    return (0);
  }
#line 57
  if ((int )*(sig + 2) != 32) {
#line 57
    if ((int )*(sig + 2) != 9) {
#line 57
      if ((int )*(sig + 2) != 10) {
#line 57
        if ((int )*(sig + 2) != 13) {
#line 57
          if ((int )*(sig + 2) != 35) {
#line 59
            return (0);
          }
        }
      }
    }
  }
#line 62
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 63
    *fmt_name_ptr = fmt_names[(int )*(sig + 1) - 49];
  }
#line 64
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 65
    *fmt_long_name_ptr = fmt_long_names[(int )*(sig + 1) - 49];
  }
#line 66
  return (1);
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
static int pnm_fpeek_eof(pnm_struct *pnm_ptr , FILE *stream ) 
{ 
  int ch ;

  {
#line 74
  if (pnm_ptr->format >= 1U) {
#line 74
    if (pnm_ptr->format <= 3U) {
      {
#line 76
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 78
        ch = _IO_getc(stream);
        }
#line 79
        if (ch == 35) {
          {
#line 81
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 82
            ch = _IO_getc(stream);
            }
#line 81
            if (ch != -1) {
#line 81
              if (ch != 10) {
#line 81
                if (! (ch != 13)) {
#line 81
                  goto while_break___0;
                }
              } else {
#line 81
                goto while_break___0;
              }
            } else {
#line 81
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 85
        if (ch == -1) {
#line 86
          return (1);
        }
#line 76
        if (! (ch == 32)) {
#line 76
          if (! (ch == 9)) {
#line 76
            if (! (ch == 10)) {
#line 76
              if (! (ch == 13)) {
#line 76
                goto while_break;
              }
            }
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 74
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 91
    ch = _IO_getc(stream);
    }
#line 92
    if (ch == -1) {
#line 93
      return (1);
    }
  }
  {
#line 96
  ungetc(ch, stream);
  }
#line 97
  return (0);
}
}
#line 100 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrpnm.c"
int pngx_read_pnm(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  pnm_struct pnminfo ;
  unsigned int format ;
  unsigned int depth ;
  unsigned int width ;
  unsigned int height ;
  unsigned int maxval ;
  unsigned int max_width ;
  unsigned int num_samples ;
  unsigned int sample_size ;
  unsigned int *pnmrow ;
  size_t row_size ;
  png_bytepp row_pointers ;
  png_color_8 sig_bit ;
  unsigned int i ;
  unsigned int j ;
  int failed ;
  int overflow ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  png_voidp __attribute__((__malloc__))  tmp___2 ;
  int tmp___3 ;
  unsigned int val ;
  png_uint_32 val___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 114
  tmp = pnm_fget_header(& pnminfo, stream);
  }
#line 114
  if (tmp != 1) {
#line 115
    return (0);
  }
#line 116
  format = pnminfo.format;
#line 117
  depth = pnminfo.depth;
#line 118
  width = pnminfo.width;
#line 119
  height = pnminfo.height;
#line 120
  maxval = pnminfo.maxval;
#line 121
  if (format > 6U) {
    {
#line 122
    png_error((png_const_structrp )png_ptr, "Can\'t handle PNM formats newer than PPM (\"P6\")");
    }
  }
#line 123
  if (sizeof(size_t ) <= sizeof(unsigned int )) {
#line 123
    max_width = (unsigned int )((4294967295UL / sizeof(unsigned int )) / (unsigned long )depth);
  } else {
#line 123
    max_width = 4294967295U;
  }
#line 127
  if (max_width > 2147483647U) {
#line 128
    max_width = 2147483647U;
  }
#line 130
  if (width > max_width) {
    {
#line 131
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large PNM dimensions");
    }
  }
#line 132
  sample_size = 1U;
#line 133
  num_samples = depth * width;
#line 133
  row_size = (size_t )num_samples;
#line 134
  if (maxval > 65535U) {
    {
#line 135
    png_error((png_const_structrp )png_ptr, "Can\'t handle PNM samples larger than 16 bits");
    }
  } else
#line 136
  if (maxval > 255U) {
#line 138
    sample_size = 2U;
#line 139
    row_size *= 2UL;
  }
#line 143
  if (depth == 1U) {
#line 143
    tmp___0 = 0;
  } else {
#line 143
    tmp___0 = 2;
  }
#line 143
  if (maxval <= 255U) {
#line 143
    tmp___1 = 8;
  } else {
#line 143
    tmp___1 = 16;
  }
  {
#line 143
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               tmp___1, tmp___0, 0, 0, 0);
#line 148
  i = 1U;
#line 148
  j = 2U;
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (j - 1U < maxval)) {
#line 148
      goto while_break;
    }
#line 148
    i ++;
#line 148
    j <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (j - 1U != maxval) {
    {
#line 150
    png_warning((png_const_structrp )png_ptr, "Possibly inexact sample conversion from PNM to PNG");
    }
  } else
#line 152
  if (i % 8U != 0U) {
#line 152
    if (depth > 1U) {
#line 152
      goto _L;
    } else
#line 152
    if (8U % i != 0U) {
      _L: /* CIL Label */ 
      {
#line 154
      sig_bit.gray = (png_byte )i;
#line 154
      sig_bit.blue = sig_bit.gray;
#line 154
      sig_bit.green = sig_bit.blue;
#line 154
      sig_bit.red = sig_bit.green;
#line 155
      sig_bit.alpha = (png_byte )0;
#line 156
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    }
  }
  {
#line 160
  row_pointers = pngx_malloc_rows(png_ptr, info_ptr, -1);
  }
#line 161
  if (format >= 4U) {
#line 161
    if (maxval == 255U) {
#line 162
      pnmrow = (unsigned int *)((void *)0);
    } else
#line 161
    if (maxval == 65535U) {
#line 162
      pnmrow = (unsigned int *)((void *)0);
    } else {
      {
#line 164
      tmp___2 = png_malloc((png_const_structrp )png_ptr, (unsigned long )num_samples * sizeof(unsigned int ));
#line 164
      pnmrow = (unsigned int *)tmp___2;
      }
    }
  } else {
    {
#line 164
    tmp___2 = png_malloc((png_const_structrp )png_ptr, (unsigned long )num_samples * sizeof(unsigned int ));
#line 164
    pnmrow = (unsigned int *)tmp___2;
    }
  }
#line 168
  failed = 0;
#line 169
  overflow = 0;
#line 170
  if ((unsigned long )pnmrow != (unsigned long )((void *)0)) {
#line 172
    i = 0U;
    {
#line 172
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 172
      if (! (i < height)) {
#line 172
        goto while_break___0;
      }
      {
#line 174
      tmp___3 = pnm_fget_values((pnm_struct const   *)(& pnminfo), pnmrow, 1U, stream);
      }
#line 174
      if (tmp___3 <= 0) {
#line 175
        failed = 1;
      }
#line 177
      if (maxval <= 255U) {
#line 179
        j = 0U;
        {
#line 179
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 179
          if (! (j < num_samples)) {
#line 179
            goto while_break___1;
          }
#line 181
          val = *(pnmrow + j);
#line 182
          if (val > maxval) {
#line 184
            val = 255U;
#line 185
            overflow = 1;
          } else
#line 187
          if (maxval != 255U) {
#line 188
            val = (val * 255U + maxval / 2U) / maxval;
          }
#line 189
          *(*(row_pointers + i) + j) = (png_byte )val;
#line 179
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 194
        j = 0U;
        {
#line 194
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 194
          if (! (j < num_samples)) {
#line 194
            goto while_break___2;
          }
#line 196
          val___0 = *(pnmrow + j);
#line 197
          if (val___0 > maxval) {
#line 199
            val___0 = (png_uint_32 )65535;
#line 200
            overflow = 1;
          } else
#line 202
          if (maxval != 65535U) {
#line 203
            val___0 = (val___0 * 65535U + maxval / 2U) / maxval;
          }
#line 204
          *(*(row_pointers + i) + 2U * j) = (png_byte )(val___0 >> 8);
#line 205
          *(*(row_pointers + i) + (2U * j + 1U)) = (png_byte )(val___0 & 255U);
#line 194
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 208
      if (failed) {
#line 209
        goto while_break___0;
      }
#line 172
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 214
    i = 0U;
    {
#line 214
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 214
      if (! (i < height)) {
#line 214
        goto while_break___3;
      }
      {
#line 216
      tmp___4 = pnm_fget_bytes((pnm_struct const   *)(& pnminfo), *(row_pointers + i),
                               (size_t )sample_size, 1U, stream);
      }
#line 216
      if (tmp___4 <= 0) {
#line 219
        failed = 1;
#line 220
        goto while_break___3;
      }
#line 214
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 226
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 226
    if (! (i < height)) {
#line 226
      goto while_break___4;
    }
    {
#line 227
    memset((void *)*(row_pointers + i), 0, row_size);
#line 226
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 230
  if ((unsigned long )pnmrow != (unsigned long )((void *)0)) {
    {
#line 231
    png_free((png_const_structrp )png_ptr, (png_voidp )pnmrow);
    }
  }
#line 234
  if (overflow) {
    {
#line 235
    png_warning((png_const_structrp )png_ptr, "Overflow in PNM samples");
    }
  }
#line 236
  if (failed) {
    {
#line 237
    png_error((png_const_structrp )png_ptr, "Error in PNM image file");
    }
  } else {
    {
#line 238
    tmp___5 = pnm_fpeek_eof(& pnminfo, stream);
    }
#line 238
    if (! tmp___5) {
      {
#line 239
      png_warning((png_const_structrp )png_ptr, "Extraneous data found after PNM image");
      }
    }
  }
#line 242
  return (1);
}
}
#line 44 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxpriv.h"
int pngx_sig_is_jpeg(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) ;
#line 47
int pngx_read_jpeg(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 37 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jp2[12]  = 
#line 37 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrjpg.c"
  {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )12, 
        (png_byte const   )106,      (png_byte const   )80,      (png_byte const   )32,      (png_byte const   )32, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )135,      (png_byte const   )10};
#line 39 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jpc[4]  = {      (png_byte const   )255,      (png_byte const   )79,      (png_byte const   )255,      (png_byte const   )81};
#line 41 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jng[8]  = 
#line 41
  {      (png_byte const   )139,      (png_byte const   )74,      (png_byte const   )78,      (png_byte const   )71, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )26,      (png_byte const   )10};
#line 43 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrjpg.c"
static png_byte const   jpeg_sig_jng_jhdr[8]  = 
#line 43
  {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )26, 
        (png_byte const   )74,      (png_byte const   )72,      (png_byte const   )68,      (png_byte const   )82};
#line 47 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrjpg.c"
int pngx_sig_is_jpeg(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                     png_const_charpp fmt_long_name_ptr ) 
{ 
  char const   *fmt ;
  unsigned int marker ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 56
  if (sig_size < 12UL) {
#line 57
    return (-1);
  }
#line 58
  if ((int )*(sig + 0) == 255) {
#line 58
    if ((int )*(sig + 1) == 216) {
#line 58
      if ((int )*(sig + 2) == 255) {
#line 60
        marker = 65280U | (unsigned int )*(sig + 3);
#line 61
        if (marker >= 65472U) {
#line 61
          if (marker <= 65487U) {
#line 64
            fmt = "JPEG";
#line 65
            result = 1;
          } else {
#line 61
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 61
        if (marker >= 65498U) {
#line 61
          if (marker <= 65534U) {
#line 64
            fmt = "JPEG";
#line 65
            result = 1;
          } else {
#line 68
            return (0);
          }
        } else {
#line 68
          return (0);
        }
      } else {
#line 58
        goto _L___1;
      }
    } else {
#line 58
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 70
    tmp___1 = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jp2), (size_t )12);
    }
#line 70
    if (tmp___1 == 0) {
#line 73
      fmt = "JPEG-2000";
#line 74
      result = 2;
    } else {
      {
#line 70
      tmp___2 = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jpc), (size_t )4);
      }
#line 70
      if (tmp___2 == 0) {
#line 73
        fmt = "JPEG-2000";
#line 74
        result = 2;
      } else {
        {
#line 76
        tmp = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jng), (size_t )8);
        }
#line 76
        if (tmp == 0) {
#line 79
          fmt = "JNG";
#line 80
          result = 3;
        } else {
          {
#line 76
          tmp___0 = memcmp((void const   *)sig, (void const   *)(jpeg_sig_jng_jhdr),
                           (size_t )8);
          }
#line 76
          if (tmp___0 == 0) {
#line 79
            fmt = "JNG";
#line 80
            result = 3;
          } else {
#line 83
            return (0);
          }
        }
      }
    }
  }
#line 86
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 87
    *fmt_name_ptr = fmt;
  }
#line 88
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 89
    *fmt_long_name_ptr = fmt;
  }
#line 90
  return (result);
}
}
#line 93 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrjpg.c"
int pngx_read_jpeg(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  png_byte buf[12] ;
  int sig_code ;
  size_t tmp ;

  {
  {
#line 99
  tmp = fread((void */* __restrict  */)(buf), (size_t )12, (size_t )1, (FILE */* __restrict  */)stream);
  }
#line 99
  if (tmp != 1UL) {
#line 100
    return (0);
  }
  {
#line 101
  sig_code = pngx_sig_is_jpeg(buf, (size_t )12, (png_const_charpp )((void *)0), (png_const_charpp )((void *)0));
  }
  {
#line 105
  if (sig_code == 1) {
#line 105
    goto case_1;
  }
#line 109
  if (sig_code == 2) {
#line 109
    goto case_2;
  }
#line 113
  if (sig_code == 3) {
#line 113
    goto case_3;
  }
#line 103
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 106
  png_error((png_const_structrp )png_ptr, "JPEG decoding is not supported");
  }
#line 108
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 110
  png_error((png_const_structrp )png_ptr, "JPEG-2000 decoding is not supported");
  }
#line 112
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 114
  png_error((png_const_structrp )png_ptr, "JNG (JPEG) decoding is not supported");
  }
#line 116
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 118
  if ((unsigned long )info_ptr == (unsigned long )((void *)0)) {
#line 119
    return (0);
  }
#line 120
  return (0);
}
}
#line 38 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxpriv.h"
int pngx_sig_is_gif(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 41
int pngx_read_gif(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 17 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static char const   gif_fmt_name[4]  = {      (char const   )'G',      (char const   )'I',      (char const   )'F',      (char const   )'\000'};
#line 18 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static char const   gif_fmt_long_name[28]  = 
#line 18
  {      (char const   )'G',      (char const   )'r',      (char const   )'a',      (char const   )'p', 
        (char const   )'h',      (char const   )'i',      (char const   )'c',      (char const   )'s', 
        (char const   )' ',      (char const   )'I',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'n',      (char const   )'g',      (char const   )'e', 
        (char const   )' ',      (char const   )'F',      (char const   )'o',      (char const   )'r', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'\000'};
#line 20 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static png_byte const   gif_sig_gif87a[6]  = {      (png_byte const   )71,      (png_byte const   )73,      (png_byte const   )70,      (png_byte const   )56, 
        (png_byte const   )55,      (png_byte const   )97};
#line 22 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static png_byte const   gif_sig_gif89a[6]  = {      (png_byte const   )71,      (png_byte const   )73,      (png_byte const   )70,      (png_byte const   )56, 
        (png_byte const   )57,      (png_byte const   )97};
#line 26 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
int pngx_sig_is_gif(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 32
  if (sig_size < 13UL) {
#line 33
    return (-1);
  }
  {
#line 34
  tmp = memcmp((void const   *)sig, (void const   *)(gif_sig_gif87a), (size_t )6);
  }
#line 34
  if (tmp != 0) {
    {
#line 34
    tmp___0 = memcmp((void const   *)sig, (void const   *)(gif_sig_gif89a), (size_t )6);
    }
#line 34
    if (tmp___0 != 0) {
#line 36
      return (0);
    }
  }
#line 39
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 40
    *fmt_name_ptr = gif_fmt_name;
  }
#line 41
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 42
    *fmt_long_name_ptr = gif_fmt_long_name;
  }
#line 43
  return (1);
}
}
#line 48 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static png_structp err_png_ptr___0  ;
#line 49 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static struct GIFImage *err_gif_image_ptr  ;
#line 50 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static struct GIFExtension *err_gif_ext_ptr  ;
#line 52 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static void pngx_gif_error(char const   *msg ) 
{ 


  {
#line 55
  if ((unsigned long )err_gif_image_ptr != (unsigned long )((void *)0)) {
    {
#line 56
    GIFDestroyImage(err_gif_image_ptr);
    }
  }
#line 57
  if ((unsigned long )err_gif_ext_ptr != (unsigned long )((void *)0)) {
    {
#line 58
    GIFDestroyExtension(err_gif_ext_ptr);
    }
  }
  {
#line 59
  png_error((png_const_structrp )err_png_ptr___0, msg);
  }
}
}
#line 62 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static void pngx_gif_warning(char const   *msg ) 
{ 


  {
  {
#line 65
  png_warning((png_const_structrp )err_png_ptr___0, msg);
  }
#line 66
  return;
}
}
#line 69 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static void pngx_set_gif_palette(png_structp png_ptr , png_infop info_ptr , unsigned char *color_table ,
                                 unsigned int num_colors ) 
{ 
  png_color palette[256] ;
  unsigned int i ;

  {
#line 79
  i = 0U;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < num_colors)) {
#line 79
      goto while_break;
    }
#line 81
    palette[i].red = *(color_table + 3U * i);
#line 82
    palette[i].green = *(color_table + (3U * i + 1U));
#line 83
    palette[i].blue = *(color_table + (3U * i + 2U));
#line 79
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(palette),
               (int )num_colors);
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
static void pngx_set_gif_transparent(png_structp png_ptr , png_infop info_ptr , unsigned int transparent ) 
{ 
  png_byte trans[256] ;
  unsigned int i ;

  {
#line 97
  i = 0U;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < transparent)) {
#line 97
      goto while_break;
    }
#line 98
    trans[i] = (png_byte )255;
#line 97
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  trans[transparent] = (png_byte )0;
#line 100
  png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )(trans),
               (int )transparent + 1, (png_const_color_16p )((void *)0));
  }
#line 101
  return;
}
}
#line 103 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrgif.c"
int pngx_read_gif(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  struct GIFScreen screen ;
  struct GIFImage image___0 ;
  struct GIFExtension ext ;
  struct GIFGraphicCtlExt graphicExt ;
  int blockCode ;
  unsigned char *colorTable ;
  unsigned int numColors ;
  unsigned int transparent ;
  unsigned int numImages ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_bytepp row_pointers ;

  {
  {
#line 121
  GIFError = & pngx_gif_error;
#line 122
  GIFWarning = & pngx_gif_warning;
#line 123
  err_png_ptr___0 = png_ptr;
#line 124
  err_gif_image_ptr = (struct GIFImage *)((void *)0);
#line 125
  err_gif_ext_ptr = (struct GIFExtension *)((void *)0);
#line 128
  GIFReadScreen(& screen, stream);
#line 129
  width = screen.Width;
#line 130
  height = screen.Height;
#line 133
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               8, 3, 0, 0, 0);
#line 138
  row_pointers = pngx_malloc_rows(png_ptr, info_ptr, (int )screen.Background);
#line 141
  GIFInitImage(& image___0, & screen, row_pointers);
#line 142
  err_gif_image_ptr = & image___0;
#line 143
  GIFInitExtension(& ext, & screen, 256U);
#line 144
  err_gif_ext_ptr = & ext;
#line 145
  numImages = 0U;
#line 146
  transparent = 4294967295U;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 151
    blockCode = GIFReadNextBlock(& image___0, & ext, stream);
    }
#line 152
    if (blockCode == 44) {
#line 154
      if ((unsigned long )image___0.Rows != (unsigned long )((void *)0)) {
#line 157
        if (image___0.InterlaceFlag) {
          {
#line 158
          pngx_set_interlace_type(png_ptr, info_ptr, 1);
          }
        }
        {
#line 160
        GIFGetColorTable(& colorTable, & numColors, & image___0);
#line 161
        pngx_set_gif_palette(png_ptr, info_ptr, colorTable, numColors);
        }
#line 162
        if (transparent < 256U) {
          {
#line 163
          pngx_set_gif_transparent(png_ptr, info_ptr, transparent);
          }
        }
#line 166
        image___0.Rows = (unsigned char **)((void *)0);
      }
#line 168
      numImages ++;
    } else
#line 170
    if (blockCode == 33) {
#line 172
      if ((int )ext.Label == 249) {
        {
#line 174
        GIFGetGraphicCtl(& graphicExt, & ext);
        }
#line 175
        if ((unsigned long )image___0.Rows != (unsigned long )((void *)0)) {
#line 175
          if (graphicExt.TransparentFlag) {
#line 177
            if (transparent >= 256U) {
#line 178
              transparent = graphicExt.Transparent;
            }
          }
        }
      }
    } else
#line 182
    if (blockCode == 59) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if ((unsigned long )image___0.Rows != (unsigned long )((void *)0)) {
    {
#line 187
    png_error((png_const_structrp )png_ptr, "No image in GIF file");
    }
  }
  {
#line 189
  GIFDestroyImage(& image___0);
#line 190
  GIFDestroyExtension(& ext);
  }
#line 191
  return ((int )numImages);
}
}
#line 731 "/usr/include/stdio.h"
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos ) ;
#line 736
extern int fsetpos(FILE *__stream , fpos_t const   *__pos ) ;
#line 47 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxtern.h"
int pngx_read_image(png_structp png_ptr , png_infop info_ptr , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 32 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxpriv.h"
int pngx_sig_is_bmp(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) ;
#line 35
int pngx_read_bmp(png_structp png_ptr , png_infop info_ptr , FILE *stream ) ;
#line 27 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static int pngx_sig_is_png(png_structp png_ptr , png_bytep sig , size_t sig_size ,
                           png_const_charpp fmt_name_ptr , png_const_charpp fmt_long_name_ptr ) ;
#line 27 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static char const   pngx_png_standalone_fmt_name[4]  = {      (char const   )'P',      (char const   )'N',      (char const   )'G',      (char const   )'\000'};
#line 29 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static char const   pngx_png_datastream_fmt_name[15]  = 
#line 29
  {      (char const   )'P',      (char const   )'N',      (char const   )'G',      (char const   )' ', 
        (char const   )'d',      (char const   )'a',      (char const   )'t',      (char const   )'a', 
        (char const   )'s',      (char const   )'t',      (char const   )'r',      (char const   )'e', 
        (char const   )'a',      (char const   )'m',      (char const   )'\000'};
#line 31 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static char const   pngx_png_standalone_fmt_long_name[26]  = 
#line 31
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'N',      (char const   )'e',      (char const   )'t', 
        (char const   )'w',      (char const   )'o',      (char const   )'r',      (char const   )'k', 
        (char const   )' ',      (char const   )'G',      (char const   )'r',      (char const   )'a', 
        (char const   )'p',      (char const   )'h',      (char const   )'i',      (char const   )'c', 
        (char const   )'s',      (char const   )'\000'};
#line 33 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static char const   pngx_png_datastream_fmt_long_name[46]  = 
#line 33
  {      (char const   )'P',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'N',      (char const   )'e',      (char const   )'t', 
        (char const   )'w',      (char const   )'o',      (char const   )'r',      (char const   )'k', 
        (char const   )' ',      (char const   )'G',      (char const   )'r',      (char const   )'a', 
        (char const   )'p',      (char const   )'h',      (char const   )'i',      (char const   )'c', 
        (char const   )'s',      (char const   )' ',      (char const   )'e',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'d',      (char const   )'d', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'d', 
        (char const   )'a',      (char const   )'t',      (char const   )'a',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'m',      (char const   )'\000'};
#line 36 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static png_byte const   png_file_sig[8]  = 
#line 36
  {      (png_byte const   )137,      (png_byte const   )80,      (png_byte const   )78,      (png_byte const   )71, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )26,      (png_byte const   )10};
#line 37 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static png_byte const   mng_file_sig[8]  = 
#line 37
  {      (png_byte const   )138,      (png_byte const   )77,      (png_byte const   )78,      (png_byte const   )71, 
        (png_byte const   )13,      (png_byte const   )10,      (png_byte const   )26,      (png_byte const   )10};
#line 38 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static png_byte const   png_ihdr_sig[8]  = 
#line 38
  {      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )0,      (png_byte const   )13, 
        (png_byte const   )73,      (png_byte const   )72,      (png_byte const   )68,      (png_byte const   )82};
#line 16 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
static int pngx_sig_is_png(png_structp png_ptr , png_bytep sig , size_t sig_size ,
                           png_const_charpp fmt_name_ptr , png_const_charpp fmt_long_name_ptr ) 
{ 
  int has_png_sig ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 46
  if (sig_size <= 43UL) {
#line 47
    return (-1);
  }
  {
#line 48
  tmp = memcmp((void const   *)sig, (void const   *)(png_file_sig), (size_t )8);
#line 48
  has_png_sig = tmp == 0;
  }
#line 49
  if (has_png_sig) {
#line 49
    tmp___2 = 8;
  } else {
#line 49
    tmp___2 = 0;
  }
  {
#line 49
  tmp___3 = memcmp((void const   *)(sig + tmp___2), (void const   *)(png_ihdr_sig),
                   (size_t )8);
  }
#line 49
  if (tmp___3 != 0) {
    {
#line 52
    tmp___1 = memcmp((void const   *)sig, (void const   *)(png_file_sig), (size_t )4);
    }
#line 52
    if (tmp___1 == 0) {
#line 52
      if ((int )*(sig + 4) == 10) {
        {
#line 53
        png_error((png_const_structrp )png_ptr, "PNG file appears to be corrupted by text file conversions");
        }
      } else
#line 52
      if ((int )*(sig + 4) == 13) {
        {
#line 53
        png_error((png_const_structrp )png_ptr, "PNG file appears to be corrupted by text file conversions");
        }
      } else {
#line 52
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 55
      tmp___0 = memcmp((void const   *)sig, (void const   *)(mng_file_sig), (size_t )8);
      }
#line 55
      if (tmp___0 == 0) {
        {
#line 56
        png_error((png_const_structrp )png_ptr, "MNG decoding is not supported");
        }
      }
    }
#line 58
    return (0);
  }
#line 62
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 64
    if (has_png_sig) {
#line 64
      *fmt_name_ptr = pngx_png_standalone_fmt_name;
    } else {
#line 64
      *fmt_name_ptr = pngx_png_datastream_fmt_name;
    }
  }
#line 68
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 70
    if (has_png_sig) {
#line 70
      *fmt_long_name_ptr = pngx_png_standalone_fmt_long_name;
    } else {
#line 70
      *fmt_long_name_ptr = pngx_png_datastream_fmt_long_name;
    }
  }
#line 74
  return (1);
}
}
#line 77 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxread.c"
int pngx_read_image(png_structp png_ptr , png_infop info_ptr , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 
  png_byte sig[128] ;
  size_t num ;
  int (*read_fn)(png_structp  , png_infop  , FILE * ) ;
  FILE *stream ;
  fpos_t fpos ;
  int result ;
  png_voidp tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 96
  tmp = png_get_io_ptr((png_const_structrp )png_ptr);
#line 96
  stream = (FILE *)tmp;
#line 97
  tmp___0 = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& fpos));
  }
#line 97
  if (tmp___0 != 0) {
    {
#line 98
    png_error((png_const_structrp )png_ptr, "Can\'t ftell in input file stream");
    }
  }
  {
#line 99
  num = fread((void */* __restrict  */)(sig), (size_t )1, sizeof(sig), (FILE */* __restrict  */)stream);
#line 100
  tmp___1 = fsetpos(stream, (fpos_t const   *)(& fpos));
  }
#line 100
  if (tmp___1 != 0) {
    {
#line 101
    png_error((png_const_structrp )png_ptr, "Can\'t fseek in input file stream");
    }
  }
  {
#line 104
  tmp___3 = pngx_sig_is_png(png_ptr, sig, num, fmt_name_ptr, fmt_long_name_ptr);
  }
#line 104
  if (tmp___3 > 0) {
    {
#line 106
    png_read_png((png_structrp )png_ptr, (png_inforp )info_ptr, 0, (void *)0);
#line 107
    tmp___2 = _IO_getc(stream);
    }
#line 107
    if (tmp___2 != -1) {
      {
#line 109
      png_warning((png_const_structrp )png_ptr, "Extraneous data found after IEND");
#line 110
      fseek(stream, 0L, 2);
      }
    }
#line 112
    return (1);
  }
  {
#line 116
  tmp___8 = pngx_sig_is_bmp(sig, num, fmt_name_ptr, fmt_long_name_ptr);
  }
#line 116
  if (tmp___8 > 0) {
#line 117
    read_fn = & pngx_read_bmp;
  } else {
    {
#line 118
    tmp___7 = pngx_sig_is_gif(sig, num, fmt_name_ptr, fmt_long_name_ptr);
    }
#line 118
    if (tmp___7 > 0) {
#line 119
      read_fn = & pngx_read_gif;
    } else {
      {
#line 120
      tmp___6 = pngx_sig_is_jpeg(sig, num, fmt_name_ptr, fmt_long_name_ptr);
      }
#line 120
      if (tmp___6 > 0) {
#line 121
        read_fn = & pngx_read_jpeg;
      } else {
        {
#line 122
        tmp___5 = pngx_sig_is_pnm(sig, num, fmt_name_ptr, fmt_long_name_ptr);
        }
#line 122
        if (tmp___5 > 0) {
#line 123
          read_fn = & pngx_read_pnm;
        } else {
          {
#line 124
          tmp___4 = pngx_sig_is_tiff(sig, num, fmt_name_ptr, fmt_long_name_ptr);
          }
#line 124
          if (tmp___4 > 0) {
#line 125
            read_fn = & pngx_read_tiff;
          } else {
#line 127
            return (0);
          }
        }
      }
    }
  }
  {
#line 130
  result = (*read_fn)(png_ptr, info_ptr, stream);
  }
#line 132
  if (result <= 0) {
    {
#line 133
    tmp___9 = fsetpos(stream, (fpos_t const   *)(& fpos));
    }
#line 133
    if (tmp___9 != 0) {
      {
#line 134
      png_error((png_const_structrp )png_ptr, "Can\'t fseek in input file stream");
      }
    }
  }
#line 135
  return (result);
}
}
#line 45 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxutil.h"
png_bytepp pngx_malloc_rows_extended(png_structp png_ptr , png_infop info_ptr , pngx_alloc_size_t min_row_size ,
                                     int filler ) ;
#line 96 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static unsigned int bmp_get_word(png_bytep ptr ) 
{ 


  {
#line 99
  return ((unsigned int )*(ptr + 0) + ((unsigned int )*(ptr + 1) << 8));
}
}
#line 102 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static png_uint_32 bmp_get_dword(png_bytep ptr ) 
{ 


  {
#line 105
  return ((((png_uint_32 )*(ptr + 0) + ((png_uint_32 )*(ptr + 1) << 8)) + ((png_uint_32 )*(ptr + 2) << 16)) + ((png_uint_32 )*(ptr + 3) << 24));
}
}
#line 114 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static void bmp_memset_bytes(png_bytep ptr , size_t offset , int ch , size_t len ) 
{ 


  {
  {
#line 117
  memset((void *)(ptr + offset), ch, len);
  }
#line 118
  return;
}
}
#line 120 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static void bmp_memset_halfbytes(png_bytep ptr , size_t offset , int ch , size_t len ) 
{ 


  {
#line 123
  if (len == 0UL) {
#line 124
    return;
  }
#line 125
  ptr += offset / 2UL;
#line 126
  if (offset & 1UL) {
#line 128
    *ptr = (png_byte )(((int )*ptr & 240) | (ch & 15));
#line 129
    ch = ((ch & 240) >> 4) | ((ch & 15) << 4);
#line 130
    ptr ++;
#line 131
    len --;
  }
  {
#line 133
  memset((void *)ptr, ch, len / 2UL);
  }
#line 134
  if (len & 1UL) {
#line 135
    *(ptr + len / 2UL) = (png_byte )(ch & 240);
  }
#line 136
  return;
}
}
#line 138 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static size_t bmp_fread_bytes(png_bytep ptr , size_t offset , size_t len , FILE *stream ) 
{ 
  size_t result ;

  {
  {
#line 143
  result = fread((void */* __restrict  */)(ptr + offset), (size_t )1, len, (FILE */* __restrict  */)stream);
  }
#line 144
  if (len & 1UL) {
    {
#line 145
    _IO_getc(stream);
    }
  }
#line 146
  return (result);
}
}
#line 149 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static size_t bmp_fread_halfbytes(png_bytep ptr , size_t offset , size_t len , FILE *stream ) 
{ 
  size_t result ;
  int ch ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 155
  if (len == 0UL) {
#line 156
    return ((size_t )0);
  }
#line 157
  ptr += offset / 2UL;
#line 158
  if (offset & 1UL) {
#line 160
    result = (size_t )0;
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      if (! (result < len - 1UL)) {
#line 160
        goto while_break;
      }
      {
#line 162
      ch = _IO_getc(stream);
      }
#line 163
      if (ch == -1) {
#line 164
        goto while_break;
      }
#line 165
      *ptr = (png_byte )(((int )*ptr & 240) | ((ch & 240) >> 4));
#line 166
      ptr ++;
#line 167
      *ptr = (png_byte )((ch & 15) << 4);
#line 160
      result += 2UL;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 172
    tmp = fread((void */* __restrict  */)ptr, (size_t )1, (len + 1UL) / 2UL, (FILE */* __restrict  */)stream);
#line 172
    result = tmp * 2UL;
    }
  }
#line 174
  if (len & 2UL) {
    {
#line 175
    _IO_getc(stream);
    }
  }
#line 176
  if (result <= len) {
#line 176
    tmp___0 = result;
  } else {
#line 176
    tmp___0 = len;
  }
#line 176
  return (tmp___0);
}
}
#line 184 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static void bmp_process_mask(png_uint_32 bmp_mask , png_bytep sig_bit , png_bytep shift_bit ) 
{ 
  png_byte tmp ;

  {
#line 187
  tmp = (png_byte )0;
#line 187
  *shift_bit = tmp;
#line 187
  *sig_bit = tmp;
#line 188
  if (bmp_mask == 0U) {
#line 189
    return;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((bmp_mask & 1U) == 0U)) {
#line 190
      goto while_break;
    }
#line 192
    bmp_mask >>= 1;
#line 193
    *shift_bit = (png_byte )((int )*shift_bit + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (bmp_mask != 0U)) {
#line 195
      goto while_break___0;
    }
#line 197
    if ((bmp_mask & 1U) == 0U) {
#line 199
      *sig_bit = (png_byte )0;
#line 200
      return;
    } else
#line 197
    if ((int )*sig_bit >= 8) {
#line 199
      *sig_bit = (png_byte )0;
#line 200
      return;
    }
#line 202
    bmp_mask >>= 1;
#line 203
    *sig_bit = (png_byte )((int )*sig_bit + 1);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 212 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static size_t bmp_read_rows(png_bytepp begin_row , png_bytepp end_row , size_t row_size ,
                            unsigned int compression , FILE *stream ) 
{ 
  size_t result ;
  png_bytepp crt_row ;
  int inc ;
  size_t crtn ;
  size_t dcrtn ;
  size_t endn ;
  unsigned int len ;
  unsigned int b1 ;
  unsigned int b2 ;
  int ch ;
  void (*bmp_memset_fn)(png_bytep  , size_t  , int  , size_t  ) ;
  size_t (*bmp_fread_fn)(png_bytep  , size_t  , size_t  , FILE * ) ;
  size_t tmp ;

  {
#line 225
  if (row_size == 0UL) {
#line 226
    return ((size_t )0);
  }
#line 228
  if ((unsigned long )begin_row <= (unsigned long )end_row) {
#line 228
    inc = 1;
  } else {
#line 228
    inc = -1;
  }
#line 229
  crtn = (size_t )0;
#line 230
  result = (size_t )0;
#line 231
  if (compression == 2U) {
#line 233
    endn = row_size * 2UL;
#line 234
    if (endn <= row_size) {
#line 235
      return ((size_t )0);
    }
#line 236
    bmp_memset_fn = & bmp_memset_halfbytes;
#line 237
    bmp_fread_fn = & bmp_fread_halfbytes;
  } else {
#line 241
    endn = row_size;
#line 242
    bmp_memset_fn = & bmp_memset_bytes;
#line 243
    bmp_fread_fn = & bmp_fread_bytes;
  }
#line 246
  if (compression == 0U) {
#line 246
    goto _L___0;
  } else
#line 246
  if (compression == 3U) {
    _L___0: /* CIL Label */ 
#line 249
    crt_row = begin_row;
    {
#line 249
    while (1) {
      while_continue: /* CIL Label */ ;
#line 249
      if (! ((unsigned long )crt_row != (unsigned long )end_row)) {
#line 249
        goto while_break;
      }
      {
#line 251
      crtn = (*bmp_fread_fn)(*crt_row, (size_t )0, endn, stream);
      }
#line 252
      if (crtn != endn) {
#line 253
        goto while_break;
      }
#line 254
      result ++;
#line 249
      crt_row += inc;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 257
  if (compression == 1U) {
#line 257
    goto _L;
  } else
#line 257
  if (compression == 2U) {
    _L: /* CIL Label */ 
#line 260
    if (compression == 1U) {
#line 262
      endn = row_size;
    } else {
#line 266
      endn = row_size * 2UL;
#line 267
      if (endn <= row_size) {
#line 268
        return ((size_t )0);
      }
    }
#line 270
    crt_row = begin_row;
    {
#line 270
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 270
      if (! ((unsigned long )crt_row != (unsigned long )end_row)) {
#line 270
        goto while_break___0;
      }
      {
#line 272
      ch = _IO_getc(stream);
#line 272
      b1 = (unsigned int )ch;
#line 273
      ch = _IO_getc(stream);
#line 273
      b2 = (unsigned int )ch;
      }
#line 274
      if (ch == -1) {
#line 275
        goto while_break___0;
      }
#line 276
      if (b1 == 0U) {
#line 278
        if (b2 == 0U) {
          {
#line 280
          (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 281
          crt_row += inc;
#line 282
          crtn = (size_t )0;
#line 283
          result ++;
          }
#line 284
          if ((unsigned long )crt_row == (unsigned long )end_row) {
            {
#line 286
            ch = _IO_getc(stream);
            }
#line 287
            if (ch != -1) {
#line 287
              if (ch != 0) {
                {
#line 289
                ungetc(ch, stream);
                }
#line 290
                goto while_break___0;
              }
            }
            {
#line 292
            _IO_getc(stream);
            }
#line 293
            goto while_break___0;
          }
        } else
#line 296
        if (b2 == 1U) {
          {
#line 298
          (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 299
          crt_row += inc;
#line 300
          crtn = (size_t )0;
          }
#line 301
          if ((unsigned long )begin_row <= (unsigned long )end_row) {
#line 301
            result = (size_t )(end_row - begin_row);
          } else {
#line 301
            result = (size_t )(begin_row - end_row);
          }
#line 303
          goto while_break___0;
        } else
#line 305
        if (b2 == 2U) {
          {
#line 307
          ch = _IO_getc(stream);
#line 307
          b1 = (unsigned int )ch;
#line 308
          ch = _IO_getc(stream);
#line 308
          b2 = (unsigned int )ch;
          }
#line 309
          if (ch == -1) {
#line 310
            goto while_break___0;
          }
#line 311
          if ((size_t )b1 < endn - crtn) {
#line 311
            dcrtn = crtn + (size_t )b1;
          } else {
#line 311
            dcrtn = endn;
          }
          {
#line 312
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 312
            if (! (b2 > 0U)) {
#line 312
              goto while_break___1;
            }
            {
#line 314
            (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 315
            crt_row += inc;
#line 316
            crtn = (size_t )0;
#line 317
            result ++;
            }
#line 318
            if ((unsigned long )crt_row == (unsigned long )end_row) {
#line 319
              goto while_break___1;
            }
#line 312
            b2 --;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 321
          if ((unsigned long )crt_row != (unsigned long )end_row) {
            {
#line 322
            (*bmp_memset_fn)(*crt_row, crtn, 0, dcrtn - crtn);
            }
          }
        } else {
#line 326
          if ((size_t )b2 <= endn - crtn) {
#line 326
            len = b2;
          } else {
#line 326
            len = (unsigned int )(endn - crtn);
          }
          {
#line 327
          tmp = (*bmp_fread_fn)(*crt_row, crtn, (size_t )len, stream);
          }
#line 327
          if (tmp != (size_t )len) {
#line 328
            goto while_break___0;
          }
#line 329
          crtn += (size_t )len;
        }
      } else {
#line 334
        if ((size_t )b1 <= endn - crtn) {
#line 334
          len = b1;
        } else {
#line 334
          len = (unsigned int )(endn - crtn);
        }
        {
#line 335
        (*bmp_memset_fn)(*crt_row, crtn, (int )b2, (size_t )len);
#line 336
        crtn += (size_t )len;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 341
    return ((size_t )0);
  }
  {
#line 344
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )crt_row != (unsigned long )end_row)) {
#line 344
      goto while_break___2;
    }
    {
#line 346
    (*bmp_memset_fn)(*crt_row, crtn, 0, endn - crtn);
#line 347
    crtn = (size_t )0;
#line 344
    crt_row += inc;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 350
  return (result);
}
}
#line 358 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static void bmp_to_png_rows(png_bytepp row_pointers , png_uint_32 width , png_uint_32 height ,
                            unsigned int pixdepth , png_bytep rgba_sig , png_bytep rgba_shift ) 
{ 
  png_bytep src_ptr ;
  png_bytep dest_ptr ;
  unsigned int rgba_mask[4] ;
  unsigned int num_samples ;
  unsigned int sample ;
  unsigned int mask ;
  unsigned int wpix ;
  png_uint_32 dwpix ;
  png_uint_32 x ;
  png_uint_32 y ;
  unsigned int i ;
  png_byte tmp ;

  {
#line 371
  if (pixdepth == 24U) {
#line 373
    y = (png_uint_32 )0;
    {
#line 373
    while (1) {
      while_continue: /* CIL Label */ ;
#line 373
      if (! (y < height)) {
#line 373
        goto while_break;
      }
#line 375
      src_ptr = *(row_pointers + y);
#line 376
      x = (png_uint_32 )0;
      {
#line 376
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 376
        if (! (x < width)) {
#line 376
          goto while_break___0;
        }
#line 378
        tmp = *(src_ptr + 0);
#line 379
        *(src_ptr + 0) = *(src_ptr + 2);
#line 380
        *(src_ptr + 2) = tmp;
#line 376
        x ++;
#line 376
        src_ptr += 3;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 373
      y ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 383
    return;
  }
#line 386
  if ((int )*(rgba_sig + 3) != 0) {
#line 386
    num_samples = 4U;
  } else {
#line 386
    num_samples = 3U;
  }
#line 387
  i = 0U;
  {
#line 387
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 387
    if (! (i < num_samples)) {
#line 387
      goto while_break___1;
    }
#line 388
    rgba_mask[i] = (1U << (int )*(rgba_sig + i)) - 1U;
#line 387
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 390
  if (pixdepth == 16U) {
#line 392
    y = (png_uint_32 )0;
    {
#line 392
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 392
      if (! (y < height)) {
#line 392
        goto while_break___2;
      }
#line 394
      src_ptr = *(row_pointers + y) + (width - 1U) * 2U;
#line 395
      dest_ptr = *(row_pointers + y) + (width - 1U) * num_samples;
#line 396
      x = (png_uint_32 )0;
      {
#line 396
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 396
        if (! (x < width)) {
#line 396
          goto while_break___3;
        }
#line 399
        wpix = (unsigned int )*(src_ptr + 0) + ((unsigned int )*(src_ptr + 1) << 8);
#line 400
        i = 0U;
        {
#line 400
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 400
          if (! (i < num_samples)) {
#line 400
            goto while_break___4;
          }
#line 402
          mask = rgba_mask[i];
#line 403
          sample = (wpix >> (int )*(rgba_shift + i)) & mask;
#line 404
          *(dest_ptr + i) = (png_byte )((sample * 255U + mask / 2U) / mask);
#line 400
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 396
        x ++;
#line 396
        src_ptr -= 2;
#line 396
        dest_ptr -= num_samples;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 392
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 409
  if (pixdepth == 32U) {
#line 411
    y = (png_uint_32 )0;
    {
#line 411
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 411
      if (! (y < height)) {
#line 411
        goto while_break___5;
      }
#line 413
      dest_ptr = *(row_pointers + y);
#line 413
      src_ptr = dest_ptr;
#line 414
      x = (png_uint_32 )0;
      {
#line 414
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 414
        if (! (x < width)) {
#line 414
          goto while_break___6;
        }
#line 417
        dwpix = (((png_uint_32 )*(src_ptr + 0) + ((png_uint_32 )*(src_ptr + 1) << 8)) + ((png_uint_32 )*(src_ptr + 2) << 16)) + ((png_uint_32 )*(src_ptr + 3) << 24);
#line 419
        i = 0U;
        {
#line 419
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 419
          if (! (i < num_samples)) {
#line 419
            goto while_break___7;
          }
#line 421
          mask = rgba_mask[i];
#line 422
          sample = (dwpix >> (int )*(rgba_shift + i)) & mask;
#line 423
          *(dest_ptr + i) = (png_byte )((sample * 255U + mask / 2U) / mask);
#line 419
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 414
        x ++;
#line 414
        src_ptr += 4;
#line 414
        dest_ptr += num_samples;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 411
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 429
  return;
}
}
#line 441 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static char const   bmp_fmt_name[4]  = {      (char const   )'B',      (char const   )'M',      (char const   )'P',      (char const   )'\000'};
#line 442 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static char const   os2bmp_fmt_long_name[12]  = 
#line 442
  {      (char const   )'O',      (char const   )'S',      (char const   )'/',      (char const   )'2', 
        (char const   )' ',      (char const   )'B',      (char const   )'i',      (char const   )'t', 
        (char const   )'m',      (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 443 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
static char const   winbmp_fmt_long_name[15]  = 
#line 443
  {      (char const   )'W',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'o',      (char const   )'w',      (char const   )'s',      (char const   )' ', 
        (char const   )'B',      (char const   )'i',      (char const   )'t',      (char const   )'m', 
        (char const   )'a',      (char const   )'p',      (char const   )'\000'};
#line 436 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
int pngx_sig_is_bmp(png_bytep sig , size_t sig_size , png_const_charpp fmt_name_ptr ,
                    png_const_charpp fmt_long_name_ptr ) 
{ 
  png_uint_32 bihsize ;
  unsigned int tmp ;

  {
#line 447
  if (sig_size < 18UL) {
#line 448
    return (-1);
  }
  {
#line 449
  tmp = bmp_get_word(sig);
  }
#line 449
  if (tmp != 19778U) {
#line 450
    return (0);
  }
  {
#line 452
  bihsize = bmp_get_dword(sig + 14);
  }
#line 453
  if (bihsize > 2147483647U) {
#line 455
    return (0);
  } else
#line 453
  if (bihsize != 12U) {
#line 453
    if (bihsize < 40U) {
#line 455
      return (0);
    }
  }
#line 458
  if ((unsigned long )fmt_name_ptr != (unsigned long )((void *)0)) {
#line 459
    *fmt_name_ptr = bmp_fmt_name;
  }
#line 460
  if ((unsigned long )fmt_long_name_ptr != (unsigned long )((void *)0)) {
#line 462
    if (bihsize == 12U) {
#line 463
      *fmt_long_name_ptr = os2bmp_fmt_long_name;
    } else {
#line 465
      *fmt_long_name_ptr = winbmp_fmt_long_name;
    }
  }
#line 467
  return (1);
}
}
#line 470 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxrbmp.c"
int pngx_read_bmp(png_structp png_ptr , png_infop info_ptr , FILE *stream ) 
{ 
  png_byte bfh[138] ;
  png_bytep bih ;
  png_byte rgbq[4] ;
  png_uint_32 offbits ;
  png_uint_32 bihsize ;
  png_uint_32 skip ;
  png_uint_32 width ;
  png_uint_32 height ;
  png_uint_32 rowsize ;
  int topdown ;
  unsigned int pixdepth ;
  png_uint_32 compression ;
  unsigned int palsize ;
  unsigned int palnum ;
  png_uint_32 rgba_mask[4] ;
  png_byte rgba_sig[4] ;
  png_byte rgba_shift[4] ;
  int bit_depth ;
  int color_type ;
  png_color palette[256] ;
  png_color_8 sig_bit ;
  png_bytepp row_pointers ;
  png_bytepp begin_row ;
  png_bytepp end_row ;
  unsigned int i ;
  size_t y ;
  unsigned int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 474
  bih = bfh + 14;
#line 492
  i = 0U;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 494
    tmp___0 = fread((void */* __restrict  */)(bfh), (size_t )18, (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 494
    if (tmp___0 != 1UL) {
#line 495
      i ++;
    } else {
      {
#line 496
      tmp = bmp_get_word(bfh + 0);
      }
#line 496
      if (tmp == 19778U) {
#line 497
        goto while_break;
      }
    }
    {
#line 498
    tmp___1 = fread((void */* __restrict  */)(bfh), (size_t )110, (size_t )1, (FILE */* __restrict  */)stream);
    }
#line 498
    if (tmp___1 != 1UL) {
#line 499
      i ++;
    }
#line 500
    if (i > 0U) {
#line 501
      return (0);
    }
#line 492
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 505
  offbits = bmp_get_dword(bfh + 10);
#line 506
  bihsize = bmp_get_dword(bfh + 14);
  }
#line 507
  if (offbits > 2147483647U) {
#line 510
    return (0);
  } else
#line 507
  if (bihsize > 2147483647U) {
#line 510
    return (0);
  } else
#line 507
  if (offbits < bihsize + 14U) {
#line 510
    return (0);
  } else
#line 507
  if (bihsize != 12U) {
#line 507
    if (bihsize < 40U) {
#line 510
      return (0);
    }
  }
#line 511
  if (bihsize > 124U) {
#line 513
    skip = bihsize - 124U;
#line 514
    bihsize = (png_uint_32 )124;
  } else {
#line 517
    skip = (png_uint_32 )0;
  }
  {
#line 518
  tmp___2 = fread((void */* __restrict  */)(bih + 4), (size_t )(bihsize - 4U), (size_t )1,
                  (FILE */* __restrict  */)stream);
  }
#line 518
  if (tmp___2 != 1UL) {
#line 519
    return (0);
  }
#line 520
  if (skip > 0U) {
    {
#line 521
    tmp___3 = fseek(stream, (long )skip, 1);
    }
#line 521
    if (tmp___3 != 0) {
#line 522
      return (0);
    }
  }
#line 523
  skip = (offbits - bihsize) - 14U;
#line 524
  topdown = 0;
#line 525
  if (bihsize < 40U) {
    {
#line 527
    width = bmp_get_word(bih + 4);
#line 528
    height = bmp_get_word(bih + 6);
#line 529
    pixdepth = bmp_get_word(bih + 10);
#line 530
    compression = (png_uint_32 )0;
#line 531
    palsize = 3U;
    }
  } else {
    {
#line 535
    width = bmp_get_dword(bih + 4);
#line 536
    height = bmp_get_dword(bih + 8);
#line 537
    pixdepth = bmp_get_word(bih + 14);
#line 538
    compression = bmp_get_dword(bih + 16);
#line 539
    palsize = 4U;
    }
#line 540
    if (height > 2147483647U) {
#line 542
      height = (4294967295U - height) + 1U;
#line 543
      topdown = 1;
    }
#line 545
    if (bihsize == 40U) {
#line 545
      if (compression == 3U) {
#line 548
        if (skip <= 16U) {
#line 548
          i = skip;
        } else {
#line 548
          i = 16U;
        }
        {
#line 549
        tmp___4 = fread((void */* __restrict  */)(bih + 40), (size_t )i, (size_t )1,
                        (FILE */* __restrict  */)stream);
        }
#line 549
        if (tmp___4 != 1UL) {
#line 550
          return (0);
        }
#line 551
        bihsize += i;
#line 552
        skip -= i;
      }
    }
  }
  {
#line 556
  memset((void *)(rgba_mask), 0, sizeof(rgba_mask));
  }
#line 557
  if (pixdepth > 8U) {
#line 559
    if (compression == 0U) {
#line 561
      if (pixdepth == 16U) {
#line 563
        compression = (png_uint_32 )3;
#line 564
        rgba_mask[0] = (png_uint_32 )31744;
#line 565
        rgba_mask[1] = (png_uint_32 )992;
#line 566
        rgba_mask[2] = (png_uint_32 )31;
      } else {
#line 570
        rgba_mask[0] = (png_uint_32 )16711680L;
#line 571
        rgba_mask[1] = (png_uint_32 )65280L;
#line 572
        rgba_mask[2] = (png_uint_32 )255L;
      }
    } else
#line 575
    if (compression == 3U) {
#line 577
      if (bihsize >= 52U) {
        {
#line 579
        rgba_mask[0] = bmp_get_dword(bih + 40);
#line 580
        rgba_mask[1] = bmp_get_dword(bih + 44);
#line 581
        rgba_mask[2] = bmp_get_dword(bih + 48);
        }
      } else {
        {
#line 584
        png_error((png_const_structrp )png_ptr, "Missing color mask in BMP file");
        }
      }
    }
#line 586
    if (bihsize >= 56U) {
      {
#line 587
      rgba_mask[3] = bmp_get_dword(bih + 52);
      }
    }
  }
  {
#line 592
  if (compression == 0U) {
#line 592
    goto case_0;
  }
#line 600
  if (compression == 1U) {
#line 600
    goto case_1;
  }
#line 604
  if (compression == 2U) {
#line 604
    goto case_2;
  }
#line 608
  if (compression == 3U) {
#line 608
    goto case_3;
  }
#line 612
  if (compression == 4U) {
#line 612
    goto case_4;
  }
#line 616
  if (compression == 5U) {
#line 616
    goto case_5;
  }
#line 623
  goto switch_default;
  case_0: /* CIL Label */ 
#line 597
  if (pixdepth > 0U) {
#line 597
    if (32U % pixdepth != 0U) {
#line 597
      if (pixdepth != 24U) {
#line 598
        pixdepth = 0U;
      }
    }
  }
#line 599
  goto switch_break;
  case_1: /* CIL Label */ 
#line 601
  if (pixdepth != 8U) {
#line 602
    pixdepth = 0U;
  }
#line 603
  goto switch_break;
  case_2: /* CIL Label */ 
#line 605
  if (pixdepth != 4U) {
#line 606
    pixdepth = 0U;
  }
#line 607
  goto switch_break;
  case_3: /* CIL Label */ 
#line 609
  if (pixdepth != 16U) {
#line 609
    if (pixdepth != 32U) {
#line 610
      pixdepth = 0U;
    }
  }
#line 611
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 613
  png_error((png_const_structrp )png_ptr, "JPEG-compressed BMP files are not supported");
  }
#line 615
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 617
  tmp___5 = _IO_getc(stream);
#line 617
  tmp___6 = ungetc(tmp___5, stream);
  }
#line 617
  if (tmp___6 == 0) {
    {
#line 618
    png_set_sig_bytes((png_structrp )png_ptr, 8);
    }
  }
  {
#line 619
  png_set_read_fn((png_structrp )png_ptr, (png_voidp )stream, (void (*)(png_structp  ,
                                                                        png_bytep  ,
                                                                        png_size_t  ))((void *)0));
#line 620
  png_read_png((png_structrp )png_ptr, (png_inforp )info_ptr, 0, (void *)0);
  }
#line 622
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 624
  png_error((png_const_structrp )png_ptr, "Unsupported compression method in BMP file");
  }
  switch_break: /* CIL Label */ ;
  }
#line 628
  if (width == 0U) {
    {
#line 629
    png_error((png_const_structrp )png_ptr, "Invalid image dimensions in BMP file");
    }
  } else
#line 628
  if (width > 2147483647U) {
    {
#line 629
    png_error((png_const_structrp )png_ptr, "Invalid image dimensions in BMP file");
    }
  } else
#line 628
  if (height == 0U) {
    {
#line 629
    png_error((png_const_structrp )png_ptr, "Invalid image dimensions in BMP file");
    }
  }
#line 630
  if (pixdepth == 0U) {
    {
#line 631
    png_error((png_const_structrp )png_ptr, "Invalid pixel depth in BMP file");
    }
  }
#line 634
  if (pixdepth <= 8U) {
#line 636
    palnum = skip / palsize;
#line 637
    if (palnum > 256U) {
#line 638
      palnum = 256U;
    }
#line 639
    skip -= palsize * palnum;
#line 640
    rowsize = (((width + 32U / pixdepth) - 1U) / (32U / pixdepth)) * 4U;
#line 642
    bit_depth = (int )pixdepth;
#line 643
    if (palnum > 0U) {
#line 643
      color_type = 3;
    } else {
#line 643
      color_type = 0;
    }
  } else {
#line 647
    palnum = 0U;
#line 648
    bit_depth = 8;
    {
#line 651
    if (pixdepth == 16U) {
#line 651
      goto case_16;
    }
#line 654
    if (pixdepth == 24U) {
#line 654
      goto case_24;
    }
#line 657
    if (pixdepth == 32U) {
#line 657
      goto case_32;
    }
#line 660
    goto switch_default___0;
    case_16: /* CIL Label */ 
#line 652
    rowsize = (width * 2U + 3U) & 4294967292U;
#line 653
    goto switch_break___0;
    case_24: /* CIL Label */ 
#line 655
    rowsize = (width * 3U + 3U) & 4294967292U;
#line 656
    goto switch_break___0;
    case_32: /* CIL Label */ 
#line 658
    rowsize = width * 4U;
#line 659
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 661
    bit_depth = 0;
#line 662
    rowsize = (png_uint_32 )0;
    switch_break___0: /* CIL Label */ ;
    }
#line 664
    if (rowsize / width < pixdepth / 8U) {
#line 665
      rowsize = (png_uint_32 )0;
    }
#line 666
    if (rgba_mask[3] != 0U) {
#line 666
      color_type = 6;
    } else {
#line 666
      color_type = 2;
    }
  }
#line 669
  if (rowsize == 0U) {
    {
#line 670
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large BMP dimensions");
    }
  }
  {
#line 673
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, color_type, 0, 0, 0);
  }
#line 676
  if (pixdepth > 8U) {
#line 678
    i = 0U;
    {
#line 678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 678
      if (! (i < 4U)) {
#line 678
        goto while_break___0;
      }
      {
#line 679
      bmp_process_mask(rgba_mask[i], & rgba_sig[i], & rgba_shift[i]);
#line 678
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 680
    if ((int )rgba_sig[0] == 0) {
      {
#line 681
      png_error((png_const_structrp )png_ptr, "Invalid color mask in BMP file");
      }
    } else
#line 680
    if ((int )rgba_sig[1] == 0) {
      {
#line 681
      png_error((png_const_structrp )png_ptr, "Invalid color mask in BMP file");
      }
    } else
#line 680
    if ((int )rgba_sig[2] == 0) {
      {
#line 681
      png_error((png_const_structrp )png_ptr, "Invalid color mask in BMP file");
      }
    }
#line 682
    if ((int )rgba_sig[0] != 8) {
      {
#line 685
      sig_bit.red = rgba_sig[0];
#line 686
      sig_bit.green = rgba_sig[1];
#line 687
      sig_bit.blue = rgba_sig[2];
#line 688
      sig_bit.alpha = rgba_sig[3];
#line 689
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    } else
#line 682
    if ((int )rgba_sig[1] != 8) {
      {
#line 685
      sig_bit.red = rgba_sig[0];
#line 686
      sig_bit.green = rgba_sig[1];
#line 687
      sig_bit.blue = rgba_sig[2];
#line 688
      sig_bit.alpha = rgba_sig[3];
#line 689
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    } else
#line 682
    if ((int )rgba_sig[2] != 8) {
      {
#line 685
      sig_bit.red = rgba_sig[0];
#line 686
      sig_bit.green = rgba_sig[1];
#line 687
      sig_bit.blue = rgba_sig[2];
#line 688
      sig_bit.alpha = rgba_sig[3];
#line 689
      png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
      }
    } else
#line 682
    if ((int )rgba_sig[3] != 0) {
#line 682
      if ((int )rgba_sig[3] != 8) {
        {
#line 685
        sig_bit.red = rgba_sig[0];
#line 686
        sig_bit.green = rgba_sig[1];
#line 687
        sig_bit.blue = rgba_sig[2];
#line 688
        sig_bit.alpha = rgba_sig[3];
#line 689
        png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )(& sig_bit));
        }
      }
    }
  }
#line 694
  if (palnum > 0U) {
#line 696
    i = 0U;
    {
#line 696
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 696
      if (! (i < palnum)) {
#line 696
        goto while_break___1;
      }
      {
#line 698
      tmp___7 = fread((void */* __restrict  */)(rgbq), (size_t )palsize, (size_t )1,
                      (FILE */* __restrict  */)stream);
      }
#line 698
      if (tmp___7 != 1UL) {
#line 699
        goto while_break___1;
      }
#line 700
      palette[i].red = rgbq[2];
#line 701
      palette[i].green = rgbq[1];
#line 702
      palette[i].blue = rgbq[0];
#line 696
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 704
    png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(palette),
                 (int )i);
    }
#line 705
    if (i != palnum) {
      {
#line 706
      png_error((png_const_structrp )png_ptr, "Error reading color palette in BMP file");
      }
    }
  }
  {
#line 710
  row_pointers = pngx_malloc_rows_extended(png_ptr, info_ptr, (pngx_alloc_size_t )rowsize,
                                           -1);
  }
#line 711
  if (topdown) {
#line 713
    begin_row = row_pointers;
#line 714
    end_row = row_pointers + height;
  } else {
#line 718
    begin_row = (row_pointers + height) - 1;
#line 719
    end_row = row_pointers - 1;
  }
#line 721
  if (skip > 0U) {
    {
#line 722
    fseek(stream, (long )skip, 1);
    }
  }
  {
#line 723
  y = bmp_read_rows(begin_row, end_row, (size_t )rowsize, compression, stream);
  }
#line 726
  if (pixdepth > 8U) {
    {
#line 727
    bmp_to_png_rows(row_pointers, width, height, pixdepth, rgba_sig, rgba_shift);
    }
  }
#line 731
  if (y != (size_t )height) {
    {
#line 732
    png_error((png_const_structrp )png_ptr, "Error reading BMP file");
    }
  }
#line 734
  return (1);
}
}
#line 16 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxmem.c"
png_bytepp pngx_malloc_rows(png_structp png_ptr , png_infop info_ptr , int filler ) 
{ 
  png_bytepp tmp ;

  {
  {
#line 19
  tmp = pngx_malloc_rows_extended(png_ptr, info_ptr, (pngx_alloc_size_t )0, filler);
  }
#line 19
  return (tmp);
}
}
#line 22 "/home/khheo/project/benchmark/optipng-0.7.7/src/pngxtern/pngxmem.c"
png_bytepp pngx_malloc_rows_extended(png_structp png_ptr , png_infop info_ptr , pngx_alloc_size_t min_row_size ,
                                     int filler ) 
{ 
  pngx_alloc_size_t row_size ;
  png_bytep row ;
  png_bytepp rows ;
  png_uint_32 height ;
  png_uint_32 i ;
  png_voidp __attribute__((__malloc__))  tmp ;
  png_voidp __attribute__((__malloc__))  tmp___0 ;

  {
  {
#line 32
  height = png_get_image_height((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 33
  if (height == 0U) {
    {
#line 34
    png_error((png_const_structrp )png_ptr, "Missing IHDR");
    }
  }
  {
#line 35
  row_size = png_get_rowbytes((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 37
  if (row_size == 0UL) {
    {
#line 39
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large image dimensions");
    }
  } else
#line 37
  if ((pngx_alloc_size_t )height > 0xffffffffffffffffUL / sizeof(png_bytep )) {
    {
#line 39
    png_error((png_const_structrp )png_ptr, "Can\'t handle exceedingly large image dimensions");
    }
  }
#line 40
  if (row_size < min_row_size) {
#line 41
    row_size = min_row_size;
  }
  {
#line 44
  png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 64U, 0);
#line 47
  tmp = png_malloc((png_const_structrp )png_ptr, (unsigned long )height * sizeof(png_bytep ));
#line 47
  rows = (png_bytepp )tmp;
  }
#line 49
  if ((unsigned long )rows == (unsigned long )((void *)0)) {
#line 50
    return ((png_bytepp )((void *)0));
  }
#line 53
  i = (png_uint_32 )0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i < height)) {
#line 53
      goto while_break;
    }
    {
#line 55
    tmp___0 = png_malloc((png_const_structrp )png_ptr, row_size);
#line 55
    row = (png_bytep )tmp___0;
    }
#line 56
    if ((unsigned long )row == (unsigned long )((void *)0)) {
      {
#line 59
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 59
        if (! (i > 0U)) {
#line 59
          goto while_break___0;
        }
        {
#line 60
        i --;
#line 60
        png_free((png_const_structrp )png_ptr, (png_voidp )*(rows + i));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 61
      png_free((png_const_structrp )png_ptr, (png_voidp )rows);
      }
#line 62
      return ((png_bytepp )((void *)0));
    }
#line 64
    if (filler >= 0) {
      {
#line 65
      memset((void *)row, filler, row_size);
      }
    }
#line 66
    *(rows + i) = row;
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 70
  png_set_rows((png_const_structrp )png_ptr, (png_inforp )info_ptr, rows);
  }
#line 71
  return (rows);
}
}
#line 28 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.h"
int opng_validate_image(png_structp png_ptr , png_infop info_ptr ) ;
#line 55
png_uint_32 opng_reduce_image(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 46 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
int opng_validate_image(png_structp png_ptr , png_infop info_ptr ) 
{ 
  png_byte tmp ;
  png_uint_32 tmp___0 ;
  png_byte tmp___1 ;
  png_uint_32 tmp___2 ;

  {
  {
#line 52
  tmp = png_get_bit_depth((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 52
  if ((int )tmp == 0) {
#line 53
    return (0);
  }
  {
#line 56
  tmp___1 = png_get_color_type((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 56
  if ((int )tmp___1 & 1) {
    {
#line 58
    tmp___0 = png_get_valid((png_const_structrp )png_ptr, (png_const_inforp )info_ptr,
                            8U);
    }
#line 58
    if (! tmp___0) {
#line 59
      return (0);
    }
  }
  {
#line 63
  tmp___2 = png_get_valid((png_const_structrp )png_ptr, (png_const_inforp )info_ptr,
                          32768U);
  }
#line 63
  if (! tmp___2) {
#line 64
    return (0);
  }
#line 66
  return (1);
}
}
#line 100 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static int opng_insert_palette_entry(png_colorp palette , int *num_palette , png_bytep trans_alpha ,
                                     int *num_trans , int max_tuples , unsigned int red ,
                                     unsigned int green , unsigned int blue , unsigned int alpha ,
                                     int *index___0 ) 
{ 
  int low ;
  int high ;
  int mid ;
  int cmp ;
  int i ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 109
  if (*num_palette >= 0) {
#line 109
    if (! (*num_palette <= max_tuples)) {
      {
#line 109
      __assert_fail("*num_palette >= 0 && *num_palette <= max_tuples", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    109U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 109
    __assert_fail("*num_palette >= 0 && *num_palette <= max_tuples", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  109U, "opng_insert_palette_entry");
    }
  }
#line 110
  if (*num_trans >= 0) {
#line 110
    if (! (*num_trans <= *num_palette)) {
      {
#line 110
      __assert_fail("*num_trans >= 0 && *num_trans <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    110U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 110
    __assert_fail("*num_trans >= 0 && *num_trans <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  110U, "opng_insert_palette_entry");
    }
  }
#line 112
  if (alpha < 255U) {
#line 115
    low = 0;
#line 116
    high = *num_trans - 1;
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! (low <= high)) {
#line 117
        goto while_break;
      }
#line 119
      mid = (low + high) / 2;
#line 120
      if ((int )alpha != (int )*(trans_alpha + mid)) {
#line 120
        cmp = (int )alpha - (int )*(trans_alpha + mid);
      } else {
#line 120
        if ((int )red != (int )(palette + mid)->red) {
#line 120
          tmp___2 = (int )red - (int )(palette + mid)->red;
        } else {
#line 120
          if ((int )green != (int )(palette + mid)->green) {
#line 120
            tmp___1 = (int )green - (int )(palette + mid)->green;
          } else {
#line 120
            tmp___1 = (int )blue - (int )(palette + mid)->blue;
          }
#line 120
          tmp___2 = tmp___1;
        }
#line 120
        cmp = tmp___2;
      }
#line 123
      if (cmp < 0) {
#line 124
        high = mid - 1;
      } else
#line 125
      if (cmp > 0) {
#line 126
        low = mid + 1;
      } else {
#line 129
        *index___0 = mid;
#line 130
        return (0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 137
    low = *num_trans;
#line 138
    high = *num_palette - 1;
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 139
      if (! (low <= high)) {
#line 139
        goto while_break___0;
      }
#line 141
      mid = (low + high) / 2;
#line 142
      if ((int )red != (int )(palette + mid)->red) {
#line 142
        cmp = (int )red - (int )(palette + mid)->red;
      } else {
#line 142
        if ((int )green != (int )(palette + mid)->green) {
#line 142
          tmp___3 = (int )green - (int )(palette + mid)->green;
        } else {
#line 142
          tmp___3 = (int )blue - (int )(palette + mid)->blue;
        }
#line 142
        cmp = tmp___3;
      }
#line 144
      if (cmp < 0) {
#line 145
        high = mid - 1;
      } else
#line 146
      if (cmp > 0) {
#line 147
        low = mid + 1;
      } else {
#line 150
        *index___0 = mid;
#line 151
        return (0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 155
  if (alpha > 255U) {
#line 159
    i = 0;
    {
#line 159
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 159
      if (! (i < *num_trans)) {
#line 159
        goto while_break___1;
      }
#line 161
      if ((int )red != (int )(palette + i)->red) {
#line 161
        cmp = (int )red - (int )(palette + i)->red;
      } else {
#line 161
        if ((int )green != (int )(palette + i)->green) {
#line 161
          tmp___4 = (int )green - (int )(palette + i)->green;
        } else {
#line 161
          tmp___4 = (int )blue - (int )(palette + i)->blue;
        }
#line 161
        cmp = tmp___4;
      }
#line 163
      if (cmp == 0) {
#line 165
        *index___0 = i;
#line 166
        return (0);
      }
#line 159
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 172
  if (*num_palette >= max_tuples) {
#line 174
    tmp___6 = -1;
#line 174
    *index___0 = tmp___6;
#line 174
    tmp___5 = tmp___6;
#line 174
    *num_trans = tmp___5;
#line 174
    *num_palette = tmp___5;
#line 175
    return (-1);
  }
#line 179
  if (low >= 0) {
#line 179
    if (! (low <= *num_palette)) {
      {
#line 179
      __assert_fail("low >= 0 && low <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    179U, "opng_insert_palette_entry");
      }
    }
  } else {
    {
#line 179
    __assert_fail("low >= 0 && low <= *num_palette", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  179U, "opng_insert_palette_entry");
    }
  }
#line 180
  i = *num_palette;
  {
#line 180
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 180
    if (! (i > low)) {
#line 180
      goto while_break___2;
    }
#line 181
    *(palette + i) = *(palette + (i - 1));
#line 180
    i --;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 182
  (palette + low)->red = (png_byte )red;
#line 183
  (palette + low)->green = (png_byte )green;
#line 184
  (palette + low)->blue = (png_byte )blue;
#line 185
  (*num_palette) ++;
#line 186
  if (alpha < 255U) {
#line 188
    if (! (low <= *num_trans)) {
      {
#line 188
      __assert_fail("low <= *num_trans", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    188U, "opng_insert_palette_entry");
      }
    }
#line 189
    i = *num_trans;
    {
#line 189
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 189
      if (! (i > low)) {
#line 189
        goto while_break___3;
      }
#line 190
      *(trans_alpha + i) = *(trans_alpha + (i - 1));
#line 189
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 191
    *(trans_alpha + low) = (png_byte )alpha;
#line 192
    (*num_trans) ++;
  }
#line 194
  *index___0 = low;
#line 195
  return (1);
}
}
#line 203 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static void opng_realloc_PLTE(png_structp png_ptr , png_infop info_ptr , int num_palette ) 
{ 
  png_color buffer___0[256] ;
  png_colorp palette ;
  int src_num_palette ;

  {
#line 212
  if (! (num_palette > 0)) {
    {
#line 212
    __assert_fail("num_palette > 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  212U, "opng_realloc_PLTE");
    }
  }
  {
#line 213
  src_num_palette = 0;
#line 214
  png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette, & src_num_palette);
  }
#line 215
  if (num_palette == src_num_palette) {
#line 216
    return;
  }
  {
#line 217
  memcpy((void */* __restrict  */)(buffer___0), (void const   */* __restrict  */)palette,
         (unsigned long )num_palette * sizeof(png_color ));
  }
#line 218
  if (num_palette > src_num_palette) {
    {
#line 219
    memset((void *)(buffer___0 + src_num_palette), 0, (unsigned long )(num_palette - src_num_palette) * sizeof(png_color ));
    }
  }
  {
#line 221
  png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(buffer___0),
               num_palette);
  }
#line 222
  return;
}
}
#line 229 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static void opng_realloc_tRNS(png_structp png_ptr , png_infop info_ptr , int num_trans ) 
{ 
  png_byte buffer___0[256] ;
  png_bytep trans_alpha ;
  int src_num_trans ;

  {
#line 238
  if (! (num_trans > 0)) {
    {
#line 238
    __assert_fail("num_trans > 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  238U, "opng_realloc_tRNS");
    }
  }
  {
#line 239
  src_num_trans = 0;
#line 240
  png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & trans_alpha,
               & src_num_trans, (png_color_16p *)((void *)0));
  }
#line 241
  if (num_trans == src_num_trans) {
#line 242
    return;
  }
  {
#line 243
  memcpy((void */* __restrict  */)(buffer___0), (void const   */* __restrict  */)trans_alpha,
         (size_t )num_trans);
  }
#line 244
  if (num_trans > src_num_trans) {
    {
#line 245
    memset((void *)(buffer___0 + src_num_trans), 0, (size_t )(num_trans - src_num_trans));
    }
  }
  {
#line 246
  png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )(buffer___0),
               num_trans, (png_const_color_16p )((void *)0));
  }
#line 247
  return;
}
}
#line 252 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static void opng_get_alpha_row(png_row_infop row_info_ptr , png_color_16p trans_color ,
                               png_bytep row , png_bytep alpha_row ) 
{ 
  png_bytep sample_ptr ;
  png_uint_32 width ;
  int color_type ;
  int bit_depth ;
  int channels ;
  png_byte trans_red ;
  png_byte trans_green ;
  png_byte trans_blue ;
  png_byte trans_gray ;
  png_uint_32 i ;
  int tmp___2 ;
  int tmp___5 ;

  {
#line 262
  width = row_info_ptr->width;
#line 263
  color_type = (int )row_info_ptr->color_type;
#line 264
  bit_depth = (int )row_info_ptr->bit_depth;
#line 265
  channels = (int )row_info_ptr->channels;
#line 267
  if (! (! (color_type & 1))) {
    {
#line 267
    __assert_fail("!(color_type & 1)", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  267U, "opng_get_alpha_row");
    }
  }
#line 268
  if (! (bit_depth == 8)) {
    {
#line 268
    __assert_fail("bit_depth == 8", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  268U, "opng_get_alpha_row");
    }
  }
#line 270
  if (! (color_type & 4)) {
#line 272
    if ((unsigned long )trans_color == (unsigned long )((void *)0)) {
      {
#line 275
      memset((void *)alpha_row, 255, (size_t )width);
      }
#line 276
      return;
    }
#line 278
    if (color_type == 2) {
#line 280
      if (! (channels == 3)) {
        {
#line 280
        __assert_fail("channels == 3", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                      280U, "opng_get_alpha_row");
        }
      }
#line 281
      trans_red = (png_byte )trans_color->red;
#line 282
      trans_green = (png_byte )trans_color->green;
#line 283
      trans_blue = (png_byte )trans_color->blue;
#line 284
      sample_ptr = row;
#line 285
      i = (png_uint_32 )0;
      {
#line 285
      while (1) {
        while_continue: /* CIL Label */ ;
#line 285
        if (! (i < width)) {
#line 285
          goto while_break;
        }
#line 286
        if ((int )*(sample_ptr + 0) == (int )trans_red) {
#line 286
          if ((int )*(sample_ptr + 1) == (int )trans_green) {
#line 286
            if ((int )*(sample_ptr + 2) == (int )trans_blue) {
#line 286
              tmp___2 = 0;
            } else {
#line 286
              tmp___2 = 255;
            }
          } else {
#line 286
            tmp___2 = 255;
          }
        } else {
#line 286
          tmp___2 = 255;
        }
#line 286
        *(alpha_row + i) = (png_byte )tmp___2;
#line 285
        i ++;
#line 285
        sample_ptr += 3;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 293
      if (! (color_type == 0)) {
        {
#line 293
        __assert_fail("color_type == 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                      293U, "opng_get_alpha_row");
        }
      }
#line 294
      if (! (channels == 1)) {
        {
#line 294
        __assert_fail("channels == 1", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                      294U, "opng_get_alpha_row");
        }
      }
#line 295
      trans_gray = (png_byte )trans_color->gray;
#line 296
      i = (png_uint_32 )0;
      {
#line 296
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 296
        if (! (i < width)) {
#line 296
          goto while_break___0;
        }
#line 297
        if ((int )*(row + i) == (int )trans_gray) {
#line 297
          tmp___5 = 0;
        } else {
#line 297
          tmp___5 = 255;
        }
#line 297
        *(alpha_row + i) = (png_byte )tmp___5;
#line 296
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 299
    return;
  }
#line 303
  if (! (channels > 1)) {
    {
#line 303
    __assert_fail("channels > 1", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  303U, "opng_get_alpha_row");
    }
  }
#line 304
  sample_ptr = row + (channels - 1);
#line 305
  i = (png_uint_32 )0;
  {
#line 305
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 305
    if (! (i < width)) {
#line 305
      goto while_break___1;
    }
#line 306
    *alpha_row = *sample_ptr;
#line 305
    i ++;
#line 305
    sample_ptr += channels;
#line 305
    alpha_row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 314 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static png_uint_32 opng_analyze_bits(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep component_ptr ;
  png_uint_32 height ;
  png_uint_32 width ;
  int bit_depth ;
  int color_type ;
  int byte_depth ;
  int channels ;
  int sample_size ;
  int offset_alpha ;
  png_color_16p background ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_byte tmp ;
  png_uint_32 tmp___0 ;

  {
  {
#line 329
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & bit_depth, & color_type, (int *)((void *)0), (int *)((void *)0),
               (int *)((void *)0));
  }
#line 331
  if (bit_depth < 8) {
#line 332
    return ((png_uint_32 )0);
  }
#line 333
  if (color_type & 1) {
#line 334
    return ((png_uint_32 )0);
  }
  {
#line 336
  byte_depth = bit_depth / 8;
#line 337
  tmp = png_get_channels((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 337
  channels = (int )tmp;
#line 338
  sample_size = channels * byte_depth;
#line 339
  offset_alpha = (channels - 1) * byte_depth;
#line 342
  reductions &= 13U;
  }
#line 344
  if (bit_depth <= 8) {
#line 345
    reductions &= 4294967294U;
  }
#line 346
  if (! (color_type & 2)) {
#line 347
    reductions &= 4294967291U;
  }
#line 348
  if (! (color_type & 4)) {
#line 349
    reductions &= 4294967287U;
  }
  {
#line 353
  tmp___0 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 353
  if (tmp___0) {
#line 355
    if (reductions & 1U) {
#line 357
      if ((int )background->red % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      } else
#line 357
      if ((int )background->green % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      } else
#line 357
      if ((int )background->blue % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      } else
#line 357
      if ((int )background->gray % 257 != 0) {
#line 361
        reductions &= 4294967294U;
      }
    }
#line 363
    if (reductions & 4U) {
#line 365
      if ((int )background->red != (int )background->green) {
#line 367
        reductions &= 4294967291U;
      } else
#line 365
      if ((int )background->red != (int )background->blue) {
#line 367
        reductions &= 4294967291U;
      }
    }
  }
  {
#line 373
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 374
  i = (png_uint_32 )0;
  }
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (! (i < height)) {
#line 374
      goto while_break;
    }
#line 376
    if (reductions == 0U) {
#line 377
      return ((png_uint_32 )0);
    }
#line 380
    if (reductions & 1U) {
#line 382
      component_ptr = *row_ptr;
#line 383
      j = (png_uint_32 )0;
      {
#line 383
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 383
        if (! (j < (png_uint_32 )channels * width)) {
#line 383
          goto while_break___0;
        }
#line 385
        if ((int )*(component_ptr + 0) != (int )*(component_ptr + 1)) {
#line 387
          reductions &= 4294967294U;
#line 388
          goto while_break___0;
        }
#line 383
        j ++;
#line 383
        component_ptr += 2;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 393
    if (bit_depth == 8) {
#line 396
      if (reductions & 4U) {
#line 398
        component_ptr = *row_ptr;
#line 399
        j = (png_uint_32 )0;
        {
#line 399
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 399
          if (! (j < width)) {
#line 399
            goto while_break___1;
          }
#line 401
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 1)) {
#line 404
            reductions &= 4294967291U;
#line 405
            goto while_break___1;
          } else
#line 401
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 2)) {
#line 404
            reductions &= 4294967291U;
#line 405
            goto while_break___1;
          }
#line 399
          j ++;
#line 399
          component_ptr += sample_size;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 411
      if (reductions & 8U) {
#line 413
        component_ptr = *row_ptr + offset_alpha;
#line 414
        j = (png_uint_32 )0;
        {
#line 414
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 414
          if (! (j < width)) {
#line 414
            goto while_break___2;
          }
#line 416
          if ((int )*(component_ptr + 0) != 255) {
#line 418
            reductions &= 4294967287U;
#line 419
            goto while_break___2;
          }
#line 414
          j ++;
#line 414
          component_ptr += sample_size;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    } else {
#line 427
      if (reductions & 4U) {
#line 429
        component_ptr = *row_ptr;
#line 430
        j = (png_uint_32 )0;
        {
#line 430
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 430
          if (! (j < width)) {
#line 430
            goto while_break___3;
          }
#line 432
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 2)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          } else
#line 432
          if ((int )*(component_ptr + 0) != (int )*(component_ptr + 4)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          } else
#line 432
          if ((int )*(component_ptr + 1) != (int )*(component_ptr + 3)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          } else
#line 432
          if ((int )*(component_ptr + 1) != (int )*(component_ptr + 5)) {
#line 437
            reductions &= 4294967291U;
#line 438
            goto while_break___3;
          }
#line 430
          j ++;
#line 430
          component_ptr += sample_size;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 444
      if (reductions & 8U) {
#line 446
        component_ptr = *row_ptr + offset_alpha;
#line 447
        j = (png_uint_32 )0;
        {
#line 447
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 447
          if (! (j < width)) {
#line 447
            goto while_break___4;
          }
#line 449
          if ((int )*(component_ptr + 0) != 255) {
#line 451
            reductions &= 4294967287U;
#line 452
            goto while_break___4;
          } else
#line 449
          if ((int )*(component_ptr + 1) != 255) {
#line 451
            reductions &= 4294967287U;
#line 452
            goto while_break___4;
          }
#line 447
          j ++;
#line 447
          component_ptr += sample_size;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 374
    i ++;
#line 374
    row_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 459
  return (reductions);
}
}
#line 470 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_bits(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep src_ptr ;
  png_bytep dest_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int src_bit_depth ;
  int dest_bit_depth ;
  int src_byte_depth ;
  int dest_byte_depth ;
  int src_color_type ;
  int dest_color_type ;
  int src_channels ;
  int dest_channels ;
  int src_sample_size ;
  int dest_sample_size ;
  int tran_tbl[8] ;
  png_color_16p trans_color ;
  png_color_16p background ;
  png_color_8p sig_bits ;
  png_uint_32 i ;
  png_uint_32 j ;
  int k ;
  png_byte tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  png_uint_32 tmp___7 ;
  png_uint_32 tmp___8 ;
  png_byte max_sig_bits ;
  png_uint_32 tmp___9 ;

  {
  {
#line 497
  reductions = opng_analyze_bits(png_ptr, info_ptr, reductions);
  }
#line 498
  if (reductions == 0U) {
#line 499
    return ((png_uint_32 )0);
  }
  {
#line 501
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & src_bit_depth, & src_color_type, & interlace_type, & compression_type,
               & filter_type);
  }
#line 506
  if (! (src_bit_depth >= 8)) {
    {
#line 506
    __assert_fail("src_bit_depth >= 8", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  506U, "opng_reduce_bits");
    }
  }
#line 507
  if (reductions & 1U) {
#line 509
    if (! (src_bit_depth == 16)) {
      {
#line 509
      __assert_fail("src_bit_depth == 16", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    509U, "opng_reduce_bits");
      }
    }
#line 510
    dest_bit_depth = 8;
  } else {
#line 513
    dest_bit_depth = src_bit_depth;
  }
#line 515
  src_byte_depth = src_bit_depth / 8;
#line 516
  dest_byte_depth = dest_bit_depth / 8;
#line 518
  dest_color_type = src_color_type;
#line 519
  if (reductions & 4U) {
#line 521
    if (! (src_color_type & 2)) {
      {
#line 521
      __assert_fail("src_color_type & 2", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    521U, "opng_reduce_bits");
      }
    }
#line 522
    dest_color_type &= -3;
  }
#line 524
  if (reductions & 8U) {
#line 526
    if (! (src_color_type & 4)) {
      {
#line 526
      __assert_fail("src_color_type & 4", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    526U, "opng_reduce_bits");
      }
    }
#line 527
    dest_color_type &= -5;
  }
  {
#line 530
  tmp___3 = png_get_channels((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 530
  src_channels = (int )tmp___3;
  }
#line 531
  if (dest_color_type & 2) {
#line 531
    tmp___4 = 3;
  } else {
#line 531
    tmp___4 = 1;
  }
#line 531
  if (dest_color_type & 4) {
#line 531
    tmp___5 = 1;
  } else {
#line 531
    tmp___5 = 0;
  }
#line 531
  dest_channels = tmp___4 + tmp___5;
#line 535
  src_sample_size = src_channels * src_byte_depth;
#line 536
  dest_sample_size = dest_channels * dest_byte_depth;
#line 539
  k = 0;
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
#line 539
    if (! (k < 4 * dest_byte_depth)) {
#line 539
      goto while_break;
    }
#line 540
    tran_tbl[k] = (k * src_bit_depth) / dest_bit_depth;
#line 539
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  if (reductions & 4U) {
#line 542
    if (dest_color_type & 4) {
#line 545
      tran_tbl[dest_byte_depth] = tran_tbl[3 * dest_byte_depth];
#line 546
      if (dest_byte_depth == 2) {
#line 547
        tran_tbl[dest_byte_depth + 1] = tran_tbl[3 * dest_byte_depth + 1];
      }
    }
  }
#line 551
  if (! (src_sample_size > dest_sample_size)) {
    {
#line 551
    __assert_fail("src_sample_size > dest_sample_size", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  551U, "opng_reduce_bits");
    }
  }
  {
#line 552
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 553
  i = (png_uint_32 )0;
  }
  {
#line 553
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 553
    if (! (i < height)) {
#line 553
      goto while_break___0;
    }
#line 555
    dest_ptr = *row_ptr;
#line 555
    src_ptr = dest_ptr;
#line 556
    j = (png_uint_32 )0;
    {
#line 556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 556
      if (! (j < width)) {
#line 556
        goto while_break___1;
      }
#line 558
      k = 0;
      {
#line 558
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 558
        if (! (k < dest_sample_size)) {
#line 558
          goto while_break___2;
        }
#line 559
        *(dest_ptr + k) = *(src_ptr + tran_tbl[k]);
#line 558
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 560
      src_ptr += src_sample_size;
#line 561
      dest_ptr += dest_sample_size;
#line 556
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 553
    i ++;
#line 553
    row_ptr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 566
  tmp___7 = png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_bytep *)((void *)0),
                         (int *)((void *)0), & trans_color);
  }
#line 566
  if (tmp___7) {
#line 568
    if (reductions & 1U) {
#line 570
      if ((int )trans_color->red % 257 == 0) {
#line 570
        if ((int )trans_color->green % 257 == 0) {
#line 570
          if ((int )trans_color->blue % 257 == 0) {
#line 570
            if ((int )trans_color->gray % 257 == 0) {
#line 575
              trans_color->red = (png_uint_16 )((int )trans_color->red & 255);
#line 576
              trans_color->green = (png_uint_16 )((int )trans_color->green & 255);
#line 577
              trans_color->blue = (png_uint_16 )((int )trans_color->blue & 255);
#line 578
              trans_color->gray = (png_uint_16 )((int )trans_color->gray & 255);
            } else {
              {
#line 583
              png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8192U,
                            -1);
#line 584
              png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr,
                              16);
              }
            }
          } else {
            {
#line 583
            png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8192U,
                          -1);
#line 584
            png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
            }
          }
        } else {
          {
#line 583
          png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8192U,
                        -1);
#line 584
          png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
          }
        }
      } else {
        {
#line 583
        png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8192U,
                      -1);
#line 584
        png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
        }
      }
    }
#line 587
    if (reductions & 4U) {
#line 589
      if ((int )trans_color->red == (int )trans_color->green) {
#line 591
        trans_color->gray = trans_color->red;
      } else
#line 589
      if ((int )trans_color->red == (int )trans_color->blue) {
#line 591
        trans_color->gray = trans_color->red;
      } else {
        {
#line 595
        png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8192U,
                      -1);
#line 596
        png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
        }
      }
    }
  }
  {
#line 601
  tmp___8 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 601
  if (tmp___8) {
#line 603
    if (reductions & 1U) {
#line 605
      background->red = (png_uint_16 )((int )background->red & 255);
#line 606
      background->green = (png_uint_16 )((int )background->green & 255);
#line 607
      background->blue = (png_uint_16 )((int )background->blue & 255);
#line 608
      background->gray = (png_uint_16 )((int )background->gray & 255);
    }
#line 610
    if (reductions & 4U) {
#line 611
      background->gray = background->red;
    }
  }
  {
#line 615
  tmp___9 = png_get_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, & sig_bits);
  }
#line 615
  if (tmp___9) {
#line 617
    if (reductions & 1U) {
#line 619
      if ((int )sig_bits->red > 8) {
#line 620
        sig_bits->red = (png_byte )8;
      }
#line 621
      if ((int )sig_bits->green > 8) {
#line 622
        sig_bits->green = (png_byte )8;
      }
#line 623
      if ((int )sig_bits->blue > 8) {
#line 624
        sig_bits->blue = (png_byte )8;
      }
#line 625
      if ((int )sig_bits->gray > 8) {
#line 626
        sig_bits->gray = (png_byte )8;
      }
#line 627
      if ((int )sig_bits->alpha > 8) {
#line 628
        sig_bits->alpha = (png_byte )8;
      }
    }
#line 630
    if (reductions & 4U) {
#line 632
      max_sig_bits = sig_bits->red;
#line 633
      if ((int )max_sig_bits < (int )sig_bits->green) {
#line 634
        max_sig_bits = sig_bits->green;
      }
#line 635
      if ((int )max_sig_bits < (int )sig_bits->blue) {
#line 636
        max_sig_bits = sig_bits->blue;
      }
#line 637
      sig_bits->gray = max_sig_bits;
    }
  }
  {
#line 643
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               dest_bit_depth, dest_color_type, interlace_type, compression_type,
               filter_type);
  }
#line 647
  return (reductions);
}
}
#line 655 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_palette_bits(png_structp png_ptr , png_infop info_ptr ,
                                            png_uint_32 reductions ) 
{ 
  png_bytepp row_ptr ;
  png_bytep src_sample_ptr ;
  png_bytep dest_sample_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int src_bit_depth ;
  int dest_bit_depth ;
  unsigned int src_mask_init ;
  unsigned int src_mask ;
  unsigned int src_shift ;
  unsigned int dest_shift ;
  unsigned int sample ;
  unsigned int dest_buf ;
  png_colorp palette ;
  int num_palette ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_uint_32 tmp ;
  png_bytep tmp___2 ;
  png_bytep tmp___3 ;

  {
#line 673
  if (! (reductions & 2U)) {
#line 674
    return ((png_uint_32 )0);
  }
  {
#line 675
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & src_bit_depth, & color_type, & interlace_type, & compression_type,
               & filter_type);
  }
#line 677
  if (color_type != 3) {
#line 678
    return ((png_uint_32 )0);
  }
  {
#line 679
  tmp = png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette,
                     & num_palette);
  }
#line 679
  if (! tmp) {
#line 680
    num_palette = 0;
  }
#line 683
  if (num_palette > 16) {
#line 684
    return ((png_uint_32 )0);
  } else
#line 685
  if (num_palette > 4) {
#line 686
    dest_bit_depth = 4;
  } else
#line 687
  if (num_palette > 2) {
#line 688
    dest_bit_depth = 2;
  } else {
#line 691
    if (! (num_palette > 0)) {
      {
#line 691
      __assert_fail("num_palette > 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    691U, "opng_reduce_palette_bits");
      }
    }
#line 692
    dest_bit_depth = 1;
  }
#line 695
  if (src_bit_depth <= dest_bit_depth) {
#line 697
    if (! (src_bit_depth == dest_bit_depth)) {
      {
#line 697
      __assert_fail("src_bit_depth == dest_bit_depth", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    697U, "opng_reduce_palette_bits");
      }
    }
#line 698
    return ((png_uint_32 )0);
  }
  {
#line 702
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
  }
#line 703
  if (src_bit_depth == 8) {
#line 705
    i = (png_uint_32 )0;
    {
#line 705
    while (1) {
      while_continue: /* CIL Label */ ;
#line 705
      if (! (i < height)) {
#line 705
        goto while_break;
      }
#line 707
      dest_sample_ptr = *row_ptr;
#line 707
      src_sample_ptr = dest_sample_ptr;
#line 708
      dest_shift = 8U;
#line 709
      dest_buf = 0U;
#line 710
      j = (png_uint_32 )0;
      {
#line 710
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 710
        if (! (j < width)) {
#line 710
          goto while_break___0;
        }
#line 712
        dest_shift -= (unsigned int )dest_bit_depth;
#line 713
        if (dest_shift > 0U) {
#line 714
          dest_buf |= (unsigned int )((int )*src_sample_ptr << dest_shift);
        } else {
#line 717
          tmp___2 = dest_sample_ptr;
#line 717
          dest_sample_ptr ++;
#line 717
          *tmp___2 = (png_byte )(dest_buf | (unsigned int )*src_sample_ptr);
#line 718
          dest_shift = 8U;
#line 719
          dest_buf = 0U;
        }
#line 721
        src_sample_ptr ++;
#line 710
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 723
      if (dest_shift != 0U) {
#line 724
        *dest_sample_ptr = (png_byte )dest_buf;
      }
#line 705
      i ++;
#line 705
      row_ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 729
    src_mask_init = (unsigned int )((1 << (8 + src_bit_depth)) - (1 << 8));
#line 730
    i = (png_uint_32 )0;
    {
#line 730
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 730
      if (! (i < height)) {
#line 730
        goto while_break___1;
      }
#line 732
      dest_sample_ptr = *row_ptr;
#line 732
      src_sample_ptr = dest_sample_ptr;
#line 733
      dest_shift = 8U;
#line 733
      src_shift = dest_shift;
#line 734
      src_mask = src_mask_init;
#line 735
      dest_buf = 0U;
#line 736
      j = (png_uint_32 )0;
      {
#line 736
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 736
        if (! (j < width)) {
#line 736
          goto while_break___2;
        }
#line 738
        src_shift -= (unsigned int )src_bit_depth;
#line 739
        src_mask >>= src_bit_depth;
#line 740
        sample = ((unsigned int )*src_sample_ptr & src_mask) >> src_shift;
#line 741
        dest_shift -= (unsigned int )dest_bit_depth;
#line 742
        if (dest_shift > 0U) {
#line 743
          dest_buf |= sample << dest_shift;
        } else {
#line 746
          tmp___3 = dest_sample_ptr;
#line 746
          dest_sample_ptr ++;
#line 746
          *tmp___3 = (png_byte )(dest_buf | sample);
#line 747
          dest_shift = 8U;
#line 748
          dest_buf = 0U;
        }
#line 750
        if (src_shift == 0U) {
#line 752
          src_shift = 8U;
#line 753
          src_mask = src_mask_init;
#line 754
          src_sample_ptr ++;
        }
#line 736
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 757
      if (dest_shift != 0U) {
#line 758
        *dest_sample_ptr = (png_byte )dest_buf;
      }
#line 730
      i ++;
#line 730
      row_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 763
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               dest_bit_depth, color_type, interlace_type, compression_type, filter_type);
  }
#line 765
  return ((png_uint_32 )2);
}
}
#line 774 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_to_palette(png_structp png_ptr , png_infop info_ptr ,
                                          png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  png_row_info row_info ;
  png_bytepp row_ptr ;
  png_bytep sample_ptr ;
  png_bytep alpha_row ;
  png_uint_32 height ;
  png_uint_32 width ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int src_bit_depth ;
  int dest_bit_depth ;
  int channels ;
  png_color palette[256] ;
  png_byte trans_alpha[256] ;
  png_color_16p trans_color ;
  int num_palette ;
  int num_trans ;
  int index___0 ;
  unsigned int gray ;
  unsigned int red ;
  unsigned int green ;
  unsigned int blue ;
  unsigned int alpha ;
  unsigned int prev_gray ;
  unsigned int prev_red ;
  unsigned int prev_green ;
  unsigned int prev_blue ;
  unsigned int prev_alpha ;
  png_color_16p background ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_byte tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  png_uint_32 tmp___6 ;
  int tmp___9 ;
  int tmp___11 ;
  png_uint_32 tmp___13 ;

  {
  {
#line 798
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & src_bit_depth, & color_type, & interlace_type, & compression_type,
               & filter_type);
  }
#line 800
  if (src_bit_depth != 8) {
#line 801
    return ((png_uint_32 )0);
  }
#line 802
  if (! (! (color_type & 1))) {
    {
#line 802
    __assert_fail("!(color_type & 1)", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  802U, "opng_reduce_to_palette");
    }
  }
  {
#line 804
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 805
  tmp___0 = png_get_channels((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 805
  channels = (int )tmp___0;
#line 806
  tmp___1 = png_malloc((png_const_structrp )png_ptr, (png_alloc_size_t )width);
#line 806
  alpha_row = (png_bytep )tmp___1;
#line 808
  row_info.width = width;
#line 809
  row_info.rowbytes = (png_size_t )0;
#line 810
  row_info.color_type = (png_byte )color_type;
#line 811
  row_info.bit_depth = (png_byte )src_bit_depth;
#line 812
  row_info.channels = (png_byte )channels;
#line 813
  row_info.pixel_depth = (png_byte )0;
#line 816
  num_trans = 0;
#line 816
  num_palette = num_trans;
#line 817
  trans_color = (png_color_16p )((void *)0);
#line 818
  png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_bytep *)((void *)0),
               (int *)((void *)0), & trans_color);
#line 819
  prev_alpha = 256U;
#line 819
  prev_blue = prev_alpha;
#line 819
  prev_green = prev_blue;
#line 819
  prev_red = prev_green;
#line 819
  prev_gray = prev_red;
#line 820
  i = (png_uint_32 )0;
  }
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (i < height)) {
#line 820
      goto while_break;
    }
    {
#line 822
    sample_ptr = *row_ptr;
#line 823
    opng_get_alpha_row(& row_info, trans_color, *row_ptr, alpha_row);
    }
#line 824
    if (color_type & 2) {
#line 826
      j = (png_uint_32 )0;
      {
#line 826
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 826
        if (! (j < width)) {
#line 826
          goto while_break___0;
        }
#line 828
        red = (unsigned int )*(sample_ptr + 0);
#line 829
        green = (unsigned int )*(sample_ptr + 1);
#line 830
        blue = (unsigned int )*(sample_ptr + 2);
#line 831
        alpha = (unsigned int )*(alpha_row + j);
#line 833
        if (red != prev_red) {
#line 833
          goto _L;
        } else
#line 833
        if (green != prev_green) {
#line 833
          goto _L;
        } else
#line 833
        if (blue != prev_blue) {
#line 833
          goto _L;
        } else
#line 833
        if (alpha != prev_alpha) {
          _L: /* CIL Label */ 
          {
#line 836
          prev_red = red;
#line 837
          prev_green = green;
#line 838
          prev_blue = blue;
#line 839
          prev_alpha = alpha;
#line 840
          tmp___3 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                              & num_trans, 256, red, green, blue,
                                              alpha, & index___0);
          }
#line 840
          if (tmp___3 < 0) {
#line 844
            if (! (num_palette < 0)) {
              {
#line 844
              __assert_fail("num_palette < 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                            844U, "opng_reduce_to_palette");
              }
            }
#line 845
            i = height;
#line 846
            goto while_break___0;
          }
        }
#line 826
        j ++;
#line 826
        sample_ptr += channels;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 853
      j = (png_uint_32 )0;
      {
#line 853
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 853
        if (! (j < width)) {
#line 853
          goto while_break___1;
        }
#line 855
        gray = (unsigned int )*(sample_ptr + 0);
#line 856
        alpha = (unsigned int )*(alpha_row + j);
#line 858
        if (gray != prev_gray) {
#line 858
          goto _L___0;
        } else
#line 858
        if (alpha != prev_alpha) {
          _L___0: /* CIL Label */ 
          {
#line 860
          prev_gray = gray;
#line 861
          prev_alpha = alpha;
#line 862
          tmp___5 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                              & num_trans, 256, gray, gray, gray,
                                              alpha, & index___0);
          }
#line 862
          if (tmp___5 < 0) {
#line 866
            if (! (num_palette < 0)) {
              {
#line 866
              __assert_fail("num_palette < 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                            866U, "opng_reduce_to_palette");
              }
            }
#line 867
            i = height;
#line 868
            goto while_break___1;
          }
        }
#line 853
        j ++;
#line 853
        sample_ptr += channels;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 820
    i ++;
#line 820
    row_ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  if (num_palette >= 0) {
    {
#line 875
    tmp___6 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
    }
#line 875
    if (tmp___6) {
#line 878
      if (color_type & 2) {
#line 880
        red = (unsigned int )background->red;
#line 881
        green = (unsigned int )background->green;
#line 882
        blue = (unsigned int )background->blue;
      } else {
#line 885
        blue = (unsigned int )background->gray;
#line 885
        green = blue;
#line 885
        red = green;
      }
      {
#line 886
      opng_insert_palette_entry(palette, & num_palette, trans_alpha, & num_trans,
                                256, red, green, blue, 256U, & index___0);
      }
#line 889
      if (index___0 >= 0) {
#line 890
        background->index = (png_byte )index___0;
      }
    }
  }
#line 903
  if (num_palette >= 0) {
#line 905
    if (num_palette > 0) {
#line 905
      if (! (num_palette <= 256)) {
        {
#line 905
        __assert_fail("num_palette > 0 && num_palette <= 256", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                      905U, "opng_reduce_to_palette");
        }
      }
    } else {
      {
#line 905
      __assert_fail("num_palette > 0 && num_palette <= 256", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    905U, "opng_reduce_to_palette");
      }
    }
#line 906
    if (num_trans >= 0) {
#line 906
      if (! (num_trans <= num_palette)) {
        {
#line 906
        __assert_fail("num_trans >= 0 && num_trans <= num_palette", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                      906U, "opng_reduce_to_palette");
        }
      }
    } else {
      {
#line 906
      __assert_fail("num_trans >= 0 && num_trans <= num_palette", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    906U, "opng_reduce_to_palette");
      }
    }
#line 907
    if (num_palette <= 2) {
#line 908
      dest_bit_depth = 1;
    } else
#line 909
    if (num_palette <= 4) {
#line 910
      dest_bit_depth = 2;
    } else
#line 911
    if (num_palette <= 16) {
#line 912
      dest_bit_depth = 4;
    } else {
#line 914
      dest_bit_depth = 8;
    }
#line 916
    if (channels * 8 == dest_bit_depth) {
#line 919
      num_palette = -1;
    } else
#line 916
    if (((png_uint_32 )(((3 * num_palette + num_trans) * 8) / (channels * 8 - dest_bit_depth)) / width) / height >= 1U) {
#line 919
      num_palette = -1;
    }
  }
#line 922
  if (num_palette < 0) {
    {
#line 924
    png_free((png_const_structrp )png_ptr, (png_voidp )alpha_row);
    }
#line 925
    return ((png_uint_32 )0);
  }
  {
#line 929
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 930
  index___0 = -1;
#line 931
  prev_alpha = 4294967295U;
#line 931
  prev_blue = prev_alpha;
#line 931
  prev_green = prev_blue;
#line 931
  prev_red = prev_green;
#line 932
  i = (png_uint_32 )0;
  }
  {
#line 932
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 932
    if (! (i < height)) {
#line 932
      goto while_break___2;
    }
    {
#line 934
    sample_ptr = *row_ptr;
#line 935
    opng_get_alpha_row(& row_info, trans_color, *row_ptr, alpha_row);
    }
#line 936
    if (color_type & 2) {
#line 938
      j = (png_uint_32 )0;
      {
#line 938
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 938
        if (! (j < width)) {
#line 938
          goto while_break___3;
        }
#line 940
        red = (unsigned int )*(sample_ptr + 0);
#line 941
        green = (unsigned int )*(sample_ptr + 1);
#line 942
        blue = (unsigned int )*(sample_ptr + 2);
#line 943
        alpha = (unsigned int )*(alpha_row + j);
#line 945
        if (red != prev_red) {
#line 945
          goto _L___1;
        } else
#line 945
        if (green != prev_green) {
#line 945
          goto _L___1;
        } else
#line 945
        if (blue != prev_blue) {
#line 945
          goto _L___1;
        } else
#line 945
        if (alpha != prev_alpha) {
          _L___1: /* CIL Label */ 
          {
#line 948
          prev_red = red;
#line 949
          prev_green = green;
#line 950
          prev_blue = blue;
#line 951
          prev_alpha = alpha;
#line 952
          tmp___9 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                              & num_trans, 256, red, green, blue,
                                              alpha, & index___0);
          }
#line 952
          if (tmp___9 != 0) {
#line 955
            index___0 = -1;
          }
        }
#line 957
        if (! (index___0 >= 0)) {
          {
#line 957
          __assert_fail("index >= 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                        957U, "opng_reduce_to_palette");
          }
        }
#line 958
        *(*row_ptr + j) = (png_byte )index___0;
#line 938
        j ++;
#line 938
        sample_ptr += channels;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 963
      j = (png_uint_32 )0;
      {
#line 963
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 963
        if (! (j < width)) {
#line 963
          goto while_break___4;
        }
#line 965
        gray = (unsigned int )*(sample_ptr + 0);
#line 966
        alpha = (unsigned int )*(alpha_row + j);
#line 968
        if (gray != prev_gray) {
#line 968
          goto _L___2;
        } else
#line 968
        if (alpha != prev_alpha) {
          _L___2: /* CIL Label */ 
          {
#line 970
          prev_gray = gray;
#line 971
          prev_alpha = alpha;
#line 972
          tmp___11 = opng_insert_palette_entry(palette, & num_palette, trans_alpha,
                                               & num_trans, 256, gray, gray, gray,
                                               alpha, & index___0);
          }
#line 972
          if (tmp___11 != 0) {
#line 975
            index___0 = -1;
          }
        }
#line 977
        if (! (index___0 >= 0)) {
          {
#line 977
          __assert_fail("index >= 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                        977U, "opng_reduce_to_palette");
          }
        }
#line 978
        *(*row_ptr + j) = (png_byte )index___0;
#line 963
        j ++;
#line 963
        sample_ptr += channels;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 932
    i ++;
#line 932
    row_ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 984
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               8, 3, interlace_type, compression_type, filter_type);
#line 986
  png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )(palette),
               num_palette);
  }
#line 987
  if (num_trans > 0) {
    {
#line 988
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )(trans_alpha),
                 num_trans, (png_const_color_16p )((void *)0));
    }
  }
  {
#line 991
  png_free((png_const_structrp )png_ptr, (png_voidp )alpha_row);
#line 993
  result = (png_uint_32 )16;
  }
#line 994
  if (reductions & 2U) {
    {
#line 995
    tmp___13 = opng_reduce_palette_bits(png_ptr, info_ptr, reductions);
#line 995
    result |= tmp___13;
    }
  }
#line 996
  return (result);
}
}
#line 1005 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static void opng_analyze_sample_usage(png_structp png_ptr , png_infop info_ptr , png_bytep usage_map ) 
{ 
  png_bytepp row_ptr ;
  png_bytep sample_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int init_shift ;
  int init_mask ;
  int shift ;
  int mask ;
  png_color_16p background ;
  png_uint_32 i ;
  png_uint_32 j ;
  png_byte tmp ;
  png_uint_32 tmp___1 ;

  {
  {
#line 1020
  height = png_get_image_height((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1021
  width = png_get_image_width((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1022
  tmp = png_get_bit_depth((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1022
  bit_depth = (int )tmp;
#line 1023
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1026
  memset((void *)usage_map, 0, (size_t )256);
  }
#line 1029
  if (bit_depth == 8) {
#line 1031
    i = (png_uint_32 )0;
    {
#line 1031
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1031
      if (! (i < height)) {
#line 1031
        goto while_break;
      }
#line 1033
      j = (png_uint_32 )0;
#line 1033
      sample_ptr = *row_ptr;
      {
#line 1033
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1033
        if (! (j < width)) {
#line 1033
          goto while_break___0;
        }
#line 1034
        *(usage_map + *sample_ptr) = (png_byte )1;
#line 1033
        j ++;
#line 1033
        sample_ptr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1031
      i ++;
#line 1031
      row_ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1039
    if (! (bit_depth < 8)) {
      {
#line 1039
      __assert_fail("bit_depth < 8", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    1039U, "opng_analyze_sample_usage");
      }
    }
#line 1040
    init_shift = 8 - bit_depth;
#line 1041
    init_mask = (1 << 8) - (1 << init_shift);
#line 1042
    i = (png_uint_32 )0;
    {
#line 1042
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1042
      if (! (i < height)) {
#line 1042
        goto while_break___1;
      }
#line 1044
      j = (png_uint_32 )0;
#line 1044
      sample_ptr = *row_ptr;
      {
#line 1044
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1044
        if (! (j < width)) {
#line 1044
          goto while_break___2;
        }
#line 1046
        mask = init_mask;
#line 1047
        shift = init_shift;
        {
#line 1048
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1050
          *(usage_map + (((int )*sample_ptr & mask) >> shift)) = (png_byte )1;
#line 1051
          mask >>= bit_depth;
#line 1052
          shift -= bit_depth;
#line 1053
          j ++;
#line 1048
          if (mask > 0) {
#line 1048
            if (! (j < width)) {
#line 1048
              goto while_break___3;
            }
          } else {
#line 1048
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1044
        sample_ptr ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1042
      i ++;
#line 1042
      row_ptr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1061
  tmp___1 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 1061
  if (tmp___1) {
#line 1062
    *(usage_map + background->index) = (png_byte )1;
  }
#line 1064
  return;
}
}
#line 1071 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
static png_uint_32 opng_reduce_palette(png_structp png_ptr , png_infop info_ptr ,
                                       png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  png_colorp palette ;
  png_bytep trans_alpha ;
  png_bytepp row_ptr ;
  png_uint_32 width ;
  png_uint_32 height ;
  int bit_depth ;
  int color_type ;
  int interlace_type ;
  int compression_type ;
  int filter_type ;
  int num_palette ;
  int num_trans ;
  int last_color_index ;
  int last_trans_index ;
  png_byte crt_trans_value ;
  png_byte last_trans_value ;
  png_byte is_used[256] ;
  png_color_16 gray_trans ;
  int is_gray ;
  png_color_16p background ;
  png_uint_16p hist ;
  png_color_8p sig_bits ;
  png_uint_32 i ;
  png_uint_32 j ;
  int k ;
  png_uint_32 tmp ;
  png_uint_32 tmp___1 ;
  int tmp___2 ;
  png_uint_32 tmp___8 ;
  png_byte tmp___9 ;
  png_uint_32 tmp___10 ;
  png_uint_32 tmp___11 ;
  png_byte max_sig_bits ;
  png_uint_32 tmp___12 ;

  {
  {
#line 1101
  result = (png_uint_32 )0;
#line 1103
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & width,
               & height, & bit_depth, & color_type, & interlace_type, & compression_type,
               & filter_type);
#line 1105
  row_ptr = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1106
  tmp = png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette,
                     & num_palette);
  }
#line 1106
  if (! tmp) {
#line 1108
    palette = (png_colorp )((void *)0);
#line 1109
    num_palette = 0;
  }
  {
#line 1111
  tmp___1 = png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & trans_alpha,
                         & num_trans, (png_color_16p *)((void *)0));
  }
#line 1111
  if (tmp___1) {
#line 1117
    if ((unsigned long )trans_alpha != (unsigned long )((void *)0)) {
#line 1117
      if (! (num_trans > 0)) {
        {
#line 1117
        __assert_fail("trans_alpha != ((void *)0) && num_trans > 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                      1117U, "opng_reduce_palette");
        }
      }
    } else {
      {
#line 1117
      __assert_fail("trans_alpha != ((void *)0) && num_trans > 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    1117U, "opng_reduce_palette");
      }
    }
  } else {
#line 1113
    trans_alpha = (png_bytep )((void *)0);
#line 1114
    num_trans = 0;
  }
  {
#line 1119
  opng_analyze_sample_usage(png_ptr, info_ptr, is_used);
  }
#line 1121
  if (reductions & 128U) {
#line 1121
    if (bit_depth == 8) {
#line 1121
      tmp___2 = 1;
    } else {
#line 1121
      tmp___2 = 0;
    }
  } else {
#line 1121
    tmp___2 = 0;
  }
#line 1121
  is_gray = tmp___2;
#line 1122
  last_trans_index = -1;
#line 1122
  last_color_index = last_trans_index;
#line 1123
  k = 0;
  {
#line 1123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1123
    if (! (k < 256)) {
#line 1123
      goto while_break;
    }
#line 1125
    if (! is_used[k]) {
#line 1126
      goto __Cont;
    }
#line 1127
    last_color_index = k;
#line 1128
    if (k < num_trans) {
#line 1128
      if ((int )*(trans_alpha + k) < 255) {
#line 1129
        last_trans_index = k;
      }
    }
#line 1130
    if (is_gray) {
#line 1131
      if ((int )(palette + k)->red != (int )(palette + k)->green) {
#line 1133
        is_gray = 0;
      } else
#line 1131
      if ((int )(palette + k)->red != (int )(palette + k)->blue) {
#line 1133
        is_gray = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1123
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1135
  if (! (last_color_index >= 0)) {
    {
#line 1135
    __assert_fail("last_color_index >= 0", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  1135U, "opng_reduce_palette");
    }
  }
#line 1136
  if (! (last_color_index >= last_trans_index)) {
    {
#line 1136
    __assert_fail("last_color_index >= last_trans_index", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                  1136U, "opng_reduce_palette");
    }
  }
#line 1139
  if (last_color_index >= num_palette) {
    {
#line 1141
    png_warning((png_const_structrp )png_ptr, "Too few colors in PLTE");
#line 1143
    opng_realloc_PLTE(png_ptr, info_ptr, last_color_index + 1);
#line 1144
    png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette, & num_palette);
    }
#line 1145
    if (! (num_palette == last_color_index + 1)) {
      {
#line 1145
      __assert_fail("num_palette == last_color_index + 1", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                    1145U, "opng_reduce_palette");
      }
    }
#line 1146
    result |= 8192U;
  }
#line 1148
  if (num_trans > num_palette) {
    {
#line 1150
    png_warning((png_const_structrp )png_ptr, "Too many alpha values in tRNS");
#line 1152
    result |= 8192U;
    }
  }
#line 1156
  if (is_gray) {
#line 1156
    if (last_trans_index >= 0) {
#line 1158
      gray_trans.gray = (png_uint_16 )(palette + last_trans_index)->red;
#line 1159
      last_trans_value = *(trans_alpha + last_trans_index);
#line 1160
      k = 0;
      {
#line 1160
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1160
        if (! (k <= last_color_index)) {
#line 1160
          goto while_break___0;
        }
#line 1162
        if (! is_used[k]) {
#line 1163
          goto __Cont___0;
        }
#line 1164
        if (k <= last_trans_index) {
#line 1166
          crt_trans_value = *(trans_alpha + k);
#line 1168
          if ((int )crt_trans_value < 255) {
#line 1168
            if ((int )(palette + k)->red != (int )gray_trans.gray) {
#line 1170
              is_gray = 0;
#line 1171
              goto while_break___0;
            }
          }
        } else {
#line 1175
          crt_trans_value = (png_byte )255;
        }
#line 1177
        if ((int )(palette + k)->red == (int )gray_trans.gray) {
#line 1177
          if ((int )crt_trans_value != (int )last_trans_value) {
#line 1180
            is_gray = 0;
#line 1181
            goto while_break___0;
          }
        }
        __Cont___0: /* CIL Label */ 
#line 1160
        k ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1187
  if (num_trans > 0) {
#line 1187
    if (last_trans_index < 0) {
      {
#line 1189
      num_trans = 0;
#line 1190
      png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8192U, -1);
#line 1191
      png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 16);
#line 1192
      result |= 512U;
      }
    }
  }
#line 1195
  if (reductions & 512U) {
#line 1197
    if (num_palette != last_color_index + 1) {
      {
#line 1201
      opng_realloc_PLTE(png_ptr, info_ptr, last_color_index + 1);
#line 1202
      png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & palette,
                   & num_palette);
      }
#line 1203
      if (! (num_palette == last_color_index + 1)) {
        {
#line 1203
        __assert_fail("num_palette == last_color_index + 1", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                      1203U, "opng_reduce_palette");
        }
      }
#line 1204
      result |= 512U;
    }
#line 1207
    if (num_trans > 0) {
#line 1207
      if (num_trans != last_trans_index + 1) {
        {
#line 1210
        opng_realloc_tRNS(png_ptr, info_ptr, last_trans_index + 1);
#line 1211
        png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & trans_alpha,
                     & num_trans, (png_color_16p *)((void *)0));
        }
#line 1212
        if (! (num_trans == last_trans_index + 1)) {
          {
#line 1212
          __assert_fail("num_trans == last_trans_index + 1", "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c",
                        1212U, "opng_reduce_palette");
          }
        }
#line 1213
        result |= 512U;
      }
    }
  }
#line 1217
  if (reductions & 2U) {
    {
#line 1219
    tmp___8 = opng_reduce_palette_bits(png_ptr, info_ptr, reductions);
#line 1219
    result |= tmp___8;
#line 1221
    tmp___9 = png_get_bit_depth((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1221
    bit_depth = (int )tmp___9;
    }
  }
#line 1223
  if (bit_depth < 8) {
#line 1224
    return (result);
  } else
#line 1223
  if (! is_gray) {
#line 1224
    return (result);
  }
#line 1227
  i = (png_uint_32 )0;
  {
#line 1227
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1227
    if (! (i < height)) {
#line 1227
      goto while_break___1;
    }
#line 1229
    j = (png_uint_32 )0;
    {
#line 1229
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1229
      if (! (j < width)) {
#line 1229
        goto while_break___2;
      }
#line 1230
      *(*(row_ptr + i) + j) = (palette + *(*(row_ptr + i) + j))->red;
#line 1229
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1227
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1234
  if (num_trans > 0) {
    {
#line 1235
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )((void *)0),
                 0, (png_const_color_16p )(& gray_trans));
    }
  }
  {
#line 1237
  tmp___10 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & background);
  }
#line 1237
  if (tmp___10) {
#line 1238
    background->gray = (png_uint_16 )(palette + background->index)->red;
  }
  {
#line 1241
  tmp___11 = png_get_hIST((png_const_structrp )png_ptr, (png_inforp )info_ptr, & hist);
  }
#line 1241
  if (tmp___11) {
    {
#line 1243
    png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8U, -1);
#line 1244
    png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 64);
    }
  }
  {
#line 1248
  tmp___12 = png_get_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, & sig_bits);
  }
#line 1248
  if (tmp___12) {
#line 1250
    max_sig_bits = sig_bits->red;
#line 1251
    if ((int )max_sig_bits < (int )sig_bits->green) {
#line 1252
      max_sig_bits = sig_bits->green;
    }
#line 1253
    if ((int )max_sig_bits < (int )sig_bits->blue) {
#line 1254
      max_sig_bits = sig_bits->blue;
    }
#line 1255
    sig_bits->gray = max_sig_bits;
  }
  {
#line 1260
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, width, height,
               bit_depth, 0, interlace_type, compression_type, filter_type);
#line 1262
  png_free_data((png_const_structrp )png_ptr, (png_inforp )info_ptr, 4096U, -1);
#line 1263
  png_set_invalid((png_const_structrp )png_ptr, (png_inforp )info_ptr, 8);
  }
#line 1264
  return ((png_uint_32 )128);
}
}
#line 1275 "/home/khheo/project/benchmark/optipng-0.7.7/src/opngreduc/opngreduc.c"
png_uint_32 opng_reduce_image(png_structp png_ptr , png_infop info_ptr , png_uint_32 reductions ) 
{ 
  png_uint_32 result ;
  int color_type ;
  int tmp ;
  png_byte tmp___0 ;
  png_uint_32 tmp___1 ;
  png_uint_32 tmp___2 ;

  {
  {
#line 1284
  tmp = opng_validate_image(png_ptr, info_ptr);
  }
#line 1284
  if (! tmp) {
    {
#line 1286
    png_warning((png_const_structrp )png_ptr, "Image reduction requires the presence of all critical information");
    }
#line 1288
    return ((png_uint_32 )0);
  }
  {
#line 1291
  tmp___0 = png_get_color_type((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 1291
  color_type = (int )tmp___0;
#line 1296
  result = opng_reduce_bits(png_ptr, info_ptr, reductions);
  }
#line 1299
  if (color_type == 3) {
#line 1299
    if (reductions & 642U) {
      {
#line 1304
      tmp___1 = opng_reduce_palette(png_ptr, info_ptr, reductions);
#line 1304
      result |= tmp___1;
      }
    }
  }
#line 1307
  if ((color_type & -5) == 0) {
#line 1307
    if (reductions & 64U) {
#line 1307
      goto _L;
    } else {
#line 1307
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1307
  if ((color_type & -5) == 2) {
#line 1307
    if (reductions & 16U) {
      _L: /* CIL Label */ 
#line 1312
      if (! (result & 128U)) {
        {
#line 1313
        tmp___2 = opng_reduce_to_palette(png_ptr, info_ptr, reductions);
#line 1313
        result |= tmp___2;
        }
      }
    }
  }
#line 1316
  return (result);
}
}
#line 124 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.h"
int opng_ulratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) ;
#line 140
int opng_ulratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) ;
#line 150
int opng_ullratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) ;
#line 158
int opng_ullratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) ;
#line 39 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.c"
static int opng_snprintf_impl(char *buffer___0 , size_t buffer_size , char const   *format 
                              , ...) 
{ 
  va_list arg_ptr ;
  int result ;

  {
  {
#line 52
  __builtin_va_start(arg_ptr, format);
#line 53
  result = vsnprintf((char */* __restrict  */)buffer___0, buffer_size, (char const   */* __restrict  */)format,
                     arg_ptr);
#line 54
  __builtin_va_end(arg_ptr);
  }
#line 56
  if (result < 0) {
#line 56
    goto _L;
  } else
#line 56
  if ((size_t )result >= buffer_size) {
    _L: /* CIL Label */ 
#line 59
    if (buffer_size > 0UL) {
#line 60
      *(buffer___0 + (buffer_size - 1UL)) = (char )'\000';
    }
#line 61
    return (-1);
  }
#line 63
  return (result);
}
}
#line 74 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.c"
static int opng_sprint_uratio_impl(char *buffer___0 , size_t buffer_size , opng_uxlong_impl_t num ,
                                   opng_uxlong_impl_t denom , int always_percent ) 
{ 
  opng_uxlong_impl_t integer_part ;
  opng_uxlong_impl_t remainder ;
  unsigned int fractional_part ;
  unsigned int scale ;
  double scaled_ratio ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 95
  if (denom == 0ULL) {
#line 96
    if (num == 0ULL) {
#line 96
      tmp = "??%%";
    } else {
#line 96
      tmp = "INFINITY%%";
    }
    {
#line 96
    tmp___0 = opng_snprintf_impl(buffer___0, buffer_size, tmp);
    }
#line 96
    return (tmp___0);
  }
#line 101
  if (num < denom) {
#line 101
    if (denom / (denom - num) < 20000ULL) {
#line 103
      scale = 10000U;
#line 104
      scaled_ratio = ((double )num * (double )scale) / (double )denom;
#line 105
      fractional_part = (unsigned int )(scaled_ratio + 0.5);
#line 108
      if (fractional_part >= scale) {
#line 109
        fractional_part = scale - 1U;
      }
      {
#line 110
      tmp___1 = opng_snprintf_impl(buffer___0, buffer_size, "%u.%02u%%", fractional_part / 100U,
                                   fractional_part % 100U);
      }
#line 110
      return (tmp___1);
    }
  }
#line 117
  integer_part = num / denom;
#line 118
  remainder = num % denom;
#line 119
  scale = 100U;
#line 120
  scaled_ratio = ((double )remainder * (double )scale) / (double )denom;
#line 121
  fractional_part = (unsigned int )(scaled_ratio + 0.5);
#line 122
  if (fractional_part >= scale) {
#line 124
    fractional_part = 0U;
#line 125
    integer_part ++;
  }
#line 129
  if (always_percent) {
    {
#line 130
    tmp___2 = opng_snprintf_impl(buffer___0, buffer_size, "%llu%02u%%", integer_part,
                                 fractional_part);
    }
#line 130
    return (tmp___2);
  }
#line 135
  if (integer_part < 100ULL) {
    {
#line 136
    tmp___3 = opng_snprintf_impl(buffer___0, buffer_size, "%llu.%02ux", integer_part,
                                 fractional_part);
    }
#line 136
    return (tmp___3);
  }
#line 143
  integer_part = num / denom;
#line 144
  if (remainder > (denom - 1ULL) / 2ULL) {
#line 145
    integer_part ++;
  }
  {
#line 146
  tmp___4 = opng_snprintf_impl(buffer___0, buffer_size, "%llux", integer_part);
  }
#line 146
  return (tmp___4);
}
}
#line 154 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.c"
int opng_ulratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) 
{ 
  opng_uxlong_impl_t num ;
  opng_uxlong_impl_t denom ;
  int tmp ;

  {
  {
#line 158
  num = (opng_uxlong_impl_t )ratio->num;
#line 159
  denom = (opng_uxlong_impl_t )ratio->denom;
#line 160
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 0);
  }
#line 160
  return (tmp);
}
}
#line 166 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.c"
int opng_ulratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ulratio  const  *ratio ) 
{ 
  opng_uxlong_impl_t num ;
  opng_uxlong_impl_t denom ;
  int tmp ;

  {
  {
#line 170
  num = (opng_uxlong_impl_t )ratio->num;
#line 171
  denom = (opng_uxlong_impl_t )ratio->denom;
#line 172
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 1);
  }
#line 172
  return (tmp);
}
}
#line 180 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.c"
int opng_ullratio_to_factor_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) 
{ 
  opng_uxlong_impl_t num ;
  opng_uxlong_impl_t denom ;
  int tmp ;

  {
  {
#line 184
  num = (opng_uxlong_impl_t )ratio->num;
#line 185
  denom = (opng_uxlong_impl_t )ratio->denom;
#line 186
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 0);
  }
#line 186
  return (tmp);
}
}
#line 192 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ratio.c"
int opng_ullratio_to_percent_string(char *buffer___0 , size_t buffer_size , struct opng_ullratio  const  *ratio ) 
{ 
  opng_uxlong_impl_t num ;
  opng_uxlong_impl_t denom ;
  int tmp ;

  {
  {
#line 196
  num = (opng_uxlong_impl_t )ratio->num;
#line 197
  denom = (opng_uxlong_impl_t )ratio->denom;
#line 198
  tmp = opng_sprint_uratio_impl(buffer___0, buffer_size, num, denom, 1);
  }
#line 198
  return (tmp);
}
}
#line 146 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 110 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.h"
opng_foffset_t opng_ftello(FILE *stream ) ;
#line 117
int opng_fseeko(FILE *stream , opng_foffset_t offset , int whence ) ;
#line 127
size_t opng_freado(FILE *stream , opng_foffset_t offset , int whence , void *block ,
                   size_t blocksize ) ;
#line 138
size_t opng_fwriteo(FILE *stream , opng_foffset_t offset , int whence , void const   *block ,
                    size_t blocksize ) ;
#line 147
int opng_fgetsize(FILE *stream , opng_fsize_t *size ) ;
#line 161
char *opng_path_replace_dir(char *buffer___0 , size_t bufsize , char const   *old_path ,
                            char const   *new_dirname ) ;
#line 174
char *opng_path_replace_ext(char *buffer___0 , size_t bufsize , char const   *old_path ,
                            char const   *new_extname ) ;
#line 183
char *opng_path_make_backup(char *buffer___0 , size_t bufsize , char const   *path ) ;
#line 191
int opng_os_rename(char const   *src_path , char const   *dest_path , int clobber ) ;
#line 200
int opng_os_copy_attr(char const   *src_path , char const   *dest_path ) ;
#line 209
int opng_os_create_dir(char const   *dirname ) ;
#line 226
int opng_os_test(char const   *path , char const   *mode ) ;
#line 237
int opng_os_test_eq(char const   *path1 , char const   *path2 ) ;
#line 245
int opng_os_unlink(char const   *path ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 302
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 476
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 317
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd ,
                                                                                                char const   *__path ,
                                                                                                struct timespec  const  *__times ,
                                                                                                int __flags ) ;
#line 178 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
opng_foffset_t opng_ftello(FILE *stream ) 
{ 
  long tmp ;

  {
  {
#line 195
  tmp = ftell(stream);
  }
#line 195
  return (tmp);
}
}
#line 203 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_fseeko(FILE *stream , opng_foffset_t offset , int whence ) 
{ 
  int tmp ;

  {
  {
#line 219
  tmp = fseek(stream, offset, whence);
  }
#line 219
  return (tmp);
}
}
#line 232 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
size_t opng_freado(FILE *stream , opng_foffset_t offset , int whence , void *block ,
                   size_t blocksize ) 
{ 
  fpos_t pos ;
  size_t result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 239
  tmp = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& pos));
  }
#line 239
  if (tmp != 0) {
#line 240
    return ((size_t )0);
  }
  {
#line 241
  tmp___0 = opng_fseeko(stream, offset, whence);
  }
#line 241
  if (tmp___0 == 0) {
    {
#line 242
    result = fread((void */* __restrict  */)block, (size_t )1, blocksize, (FILE */* __restrict  */)stream);
    }
  } else {
#line 244
    result = (size_t )0;
  }
  {
#line 245
  tmp___1 = fsetpos(stream, (fpos_t const   *)(& pos));
  }
#line 245
  if (tmp___1 != 0) {
#line 246
    result = (size_t )0;
  }
#line 247
  return (result);
}
}
#line 253 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
size_t opng_fwriteo(FILE *stream , opng_foffset_t offset , int whence , void const   *block ,
                    size_t blocksize ) 
{ 
  fpos_t pos ;
  size_t result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 260
  tmp = fgetpos((FILE */* __restrict  */)stream, (fpos_t */* __restrict  */)(& pos));
  }
#line 260
  if (tmp != 0) {
#line 261
    return ((size_t )0);
  } else {
    {
#line 260
    tmp___0 = fflush(stream);
    }
#line 260
    if (tmp___0 != 0) {
#line 261
      return ((size_t )0);
    }
  }
  {
#line 262
  tmp___1 = opng_fseeko(stream, offset, whence);
  }
#line 262
  if (tmp___1 == 0) {
    {
#line 263
    result = fwrite((void const   */* __restrict  */)block, (size_t )1, blocksize,
                    (FILE */* __restrict  */)stream);
    }
  } else {
#line 265
    result = (size_t )0;
  }
  {
#line 266
  tmp___2 = fflush(stream);
  }
#line 266
  if (tmp___2 != 0) {
#line 267
    result = (size_t )0;
  }
  {
#line 268
  tmp___3 = fsetpos(stream, (fpos_t const   *)(& pos));
  }
#line 268
  if (tmp___3 != 0) {
#line 269
    result = (size_t )0;
  }
#line 270
  return (result);
}
}
#line 276 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_fgetsize(FILE *stream , opng_fsize_t *size ) 
{ 
  struct stat sbuf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 295
  tmp = fileno(stream);
#line 295
  tmp___0 = fstat(tmp, & sbuf);
  }
#line 295
  if (tmp___0 != 0) {
#line 296
    return (-1);
  }
#line 297
  if (sbuf.st_size < 0L) {
#line 298
    return (-1);
  }
#line 299
  *size = (opng_fsize_t )sbuf.st_size;
#line 300
  return (0);
}
}
#line 321 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
char *opng_path_replace_dir(char *buffer___0 , size_t bufsize , char const   *old_path ,
                            char const   *new_dirname ) 
{ 
  char const   *path ;
  char const   *ptr ;
  size_t dirlen ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
#line 329
  path = old_path;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 337
    tmp = strpbrk(path, "/");
#line 337
    ptr = (char const   *)tmp;
    }
#line 338
    if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 339
      goto while_break;
    }
#line 340
    path = ptr + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 344
  dirlen = strlen(new_dirname);
#line 345
  tmp___0 = strlen(path);
  }
#line 345
  if ((dirlen + tmp___0) + 2UL >= bufsize) {
#line 346
    return ((char *)((void *)0));
  }
#line 349
  if (dirlen > 0UL) {
    {
#line 351
    strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)new_dirname);
#line 361
    tmp___2 = strchr("/", (int )*(buffer___0 + (dirlen - 1UL)));
    }
#line 361
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 362
      tmp___1 = dirlen;
#line 362
      dirlen ++;
#line 362
      *(buffer___0 + tmp___1) = (char )'/';
    }
  }
  {
#line 367
  strcpy((char */* __restrict  */)(buffer___0 + dirlen), (char const   */* __restrict  */)path);
  }
#line 368
  return (buffer___0);
}
}
#line 375 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
char *opng_path_replace_ext(char *buffer___0 , size_t bufsize , char const   *old_path ,
                            char const   *new_extname ) 
{ 
  size_t i ;
  size_t pos ;
  char tmp ;
  char tmp___0 ;

  {
#line 381
  if ((int const   )*(new_extname + 0) != 46) {
#line 382
    return ((char *)((void *)0));
  }
#line 383
  i = (size_t )0;
#line 383
  pos = (size_t )-1;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! ((int const   )*(old_path + i) != 0)) {
#line 383
      goto while_break;
    }
#line 385
    if (i >= bufsize) {
#line 386
      return ((char *)((void *)0));
    }
#line 387
    tmp = (char )*(old_path + i);
#line 387
    *(buffer___0 + i) = tmp;
#line 387
    if ((int )tmp == 46) {
#line 388
      pos = i;
    }
#line 383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  if (i > pos) {
#line 393
    i = pos;
  }
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 397
    if (i >= bufsize) {
#line 398
      return ((char *)((void *)0));
    }
#line 399
    tmp___0 = (char )*new_extname;
#line 399
    *(buffer___0 + i) = tmp___0;
#line 399
    if ((int )tmp___0 == 0) {
#line 400
      return (buffer___0);
    }
#line 395
    i ++;
#line 395
    new_extname ++;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 410 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
static char const   bak_extname[5]  = {      (char const   )'.',      (char const   )'b',      (char const   )'a',      (char const   )'k', 
        (char const   )'\000'};
#line 407 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
char *opng_path_make_backup(char *buffer___0 , size_t bufsize , char const   *path ) 
{ 
  size_t tmp ;

  {
  {
#line 412
  tmp = strlen(path);
  }
#line 412
  if (tmp + sizeof(bak_extname) > bufsize) {
#line 413
    return ((char *)((void *)0));
  }
  {
#line 421
  strcpy((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)path);
#line 422
  strcat((char */* __restrict  */)buffer___0, (char const   */* __restrict  */)(bak_extname));
  }
#line 423
  return (buffer___0);
}
}
#line 431 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_os_rename(char const   *src_path , char const   *dest_path , int clobber ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 456
  if (! clobber) {
    {
#line 458
    tmp = access(dest_path, 0);
    }
#line 458
    if (tmp >= 0) {
#line 459
      return (-1);
    }
  }
  {
#line 461
  tmp___0 = rename(src_path, dest_path);
  }
#line 461
  return (tmp___0);
}
}
#line 480 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_os_copy_attr(char const   *src_path , char const   *dest_path ) 
{ 
  struct stat sbuf ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct timespec times[2] ;
  int tmp___2 ;

  {
  {
#line 515
  tmp = stat((char const   */* __restrict  */)src_path, (struct stat */* __restrict  */)(& sbuf));
  }
#line 515
  if (tmp != 0) {
#line 516
    return (-1);
  }
  {
#line 518
  result = 0;
#line 520
  tmp___0 = chown(dest_path, sbuf.st_uid, sbuf.st_gid);
#line 525
  tmp___1 = chmod(dest_path, sbuf.st_mode);
  }
#line 525
  if (tmp___1 != 0) {
#line 526
    result = -1;
  }
  {
#line 536
  times[0] = sbuf.st_atim;
#line 537
  times[1] = sbuf.st_mtim;
#line 539
  tmp___2 = utimensat(-100, dest_path, (struct timespec  const  *)(times), 0);
  }
#line 539
  if (tmp___2 != 0) {
#line 540
    result = -1;
  }
#line 553
  return (result);
}
}
#line 569 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_os_create_dir(char const   *dirname ) 
{ 
  struct stat sbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 573
  if ((int const   )*(dirname + 0) == 0) {
#line 574
    return (0);
  }
  {
#line 620
  tmp___0 = stat((char const   */* __restrict  */)dirname, (struct stat */* __restrict  */)(& sbuf));
  }
#line 620
  if (tmp___0 == 0) {
#line 621
    if (sbuf.st_mode & 16384U) {
#line 621
      tmp = 0;
    } else {
#line 621
      tmp = -1;
    }
#line 621
    return (tmp);
  }
  {
#line 625
  tmp___1 = mkdir(dirname, (__mode_t )511);
  }
#line 625
  return (tmp___1);
}
}
#line 645 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_os_test(char const   *path , char const   *mode ) 
{ 
  int faccess ;
  int freg ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat sbuf ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 650
  freg = 0;
#line 650
  faccess = freg;
#line 651
  tmp = strchr(mode, 'f');
  }
#line 651
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 652
    freg = 1;
  }
  {
#line 653
  tmp___0 = strchr(mode, 'r');
  }
#line 653
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 654
    faccess |= 4;
  }
  {
#line 655
  tmp___1 = strchr(mode, 'w');
  }
#line 655
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 656
    faccess |= 2;
  }
  {
#line 657
  tmp___2 = strchr(mode, 'x');
  }
#line 657
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 658
    faccess |= 1;
  }
#line 659
  if (faccess == 0) {
#line 659
    if (! freg) {
      {
#line 661
      tmp___3 = strchr(mode, 'e');
      }
#line 661
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 662
        return (0);
      }
    }
  }
  {
#line 685
  tmp___4 = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& sbuf));
  }
#line 685
  if (tmp___4 != 0) {
#line 686
    return (-1);
  }
#line 687
  if (freg) {
#line 687
    if ((sbuf.st_mode & 32768U) != 32768U) {
#line 688
      return (-1);
    }
  }
#line 689
  if (faccess == 0) {
#line 690
    return (0);
  }
  {
#line 691
  tmp___5 = access(path, faccess);
  }
#line 691
  return (tmp___5);
}
}
#line 716 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_os_test_eq(char const   *path1 , char const   *path2 ) 
{ 
  struct stat sbuf1 ;
  struct stat sbuf2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 760
  tmp = stat((char const   */* __restrict  */)path1, (struct stat */* __restrict  */)(& sbuf1));
  }
#line 760
  if (tmp != 0) {
#line 763
    return (-1);
  } else {
    {
#line 760
    tmp___0 = stat((char const   */* __restrict  */)path2, (struct stat */* __restrict  */)(& sbuf2));
    }
#line 760
    if (tmp___0 != 0) {
#line 763
      return (-1);
    }
  }
#line 765
  if (sbuf1.st_dev == sbuf2.st_dev) {
#line 765
    if (sbuf1.st_ino == sbuf2.st_ino) {
#line 769
      if (sbuf1.st_ino != 0UL) {
#line 769
        tmp___1 = 1;
      } else {
#line 769
        tmp___1 = -1;
      }
#line 769
      return (tmp___1);
    } else {
#line 774
      return (0);
    }
  } else {
#line 774
    return (0);
  }
}
}
#line 791 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/ioutil.c"
int opng_os_unlink(char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 800
  tmp = unlink(path);
  }
#line 800
  return (tmp);
}
}
#line 174 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.h"
unsigned int opng_bitset_count(opng_bitset_t set ) ;
#line 183
int opng_bitset_find_first(opng_bitset_t set ) ;
#line 192
int opng_bitset_find_next(opng_bitset_t set , int elt ) ;
#line 201
int opng_bitset_find_last(opng_bitset_t set ) ;
#line 210
int opng_bitset_find_prev(opng_bitset_t set , int elt ) ;
#line 241
int opng_strparse_rangeset_to_bitset(opng_bitset_t *out_set , char const   *rangeset_str ,
                                     opng_bitset_t mask_set ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 44 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.c"
unsigned int opng_bitset_count(opng_bitset_t set ) 
{ 
  unsigned int result ;

  {
#line 50
  result = 0U;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (set != 0U)) {
#line 51
      goto while_break;
    }
#line 53
    set &= set - 1U;
#line 54
    result ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (result);
}
}
#line 62 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.c"
int opng_bitset_find_first(opng_bitset_t set ) 
{ 
  int i ;

  {
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
#line 67
    if (! (i <= 31)) {
#line 67
      goto while_break;
    }
#line 69
    if ((set & (1U << i)) != 0U) {
#line 70
      return (i);
    }
#line 67
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (-1);
}
}
#line 78 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.c"
int opng_bitset_find_next(opng_bitset_t set , int elt ) 
{ 
  int i ;
  int tmp ;

  {
#line 83
  if (elt > -1) {
#line 83
    tmp = elt;
  } else {
#line 83
    tmp = -1;
  }
#line 83
  i = tmp + 1;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i <= 31)) {
#line 83
      goto while_break;
    }
#line 85
    if ((set & (1U << i)) != 0U) {
#line 86
      return (i);
    }
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  return (-1);
}
}
#line 94 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.c"
int opng_bitset_find_last(opng_bitset_t set ) 
{ 
  int i ;

  {
#line 99
  i = 31;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i >= 0)) {
#line 99
      goto while_break;
    }
#line 101
    if ((set & (1U << i)) != 0U) {
#line 102
      return (i);
    }
#line 99
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (-1);
}
}
#line 110 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.c"
int opng_bitset_find_prev(opng_bitset_t set , int elt ) 
{ 
  int i ;
  int tmp ;

  {
#line 115
  if (elt < 32) {
#line 115
    tmp = elt;
  } else {
#line 115
    tmp = 32;
  }
#line 115
  i = tmp - 1;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i >= 0)) {
#line 115
      goto while_break;
    }
#line 117
    if ((set & (1U << i)) != 0U) {
#line 118
      return (i);
    }
#line 115
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (-1);
}
}
#line 126 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/bitset.c"
int opng_strparse_rangeset_to_bitset(opng_bitset_t *out_set , char const   *rangeset_str ,
                                     opng_bitset_t mask_set ) 
{ 
  opng_bitset_t result ;
  char const   *ptr ;
  int state ;
  int num ;
  int num1 ;
  int num2 ;
  int err_invalid ;
  int err_range ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 137
  result = 0U;
#line 138
  ptr = rangeset_str;
#line 139
  state = 0;
#line 140
  err_range = 0;
#line 140
  err_invalid = err_range;
#line 141
  num2 = -1;
#line 141
  num1 = num2;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 145
      tmp = isspace((int )*ptr);
      }
#line 145
      if (! tmp) {
#line 145
        goto while_break___0;
      }
#line 145
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 149
    if (state == 2) {
#line 149
      goto case_2;
    }
#line 149
    if (state == 0) {
#line 149
      goto case_2;
    }
#line 173
    if (state == 1) {
#line 173
      goto case_1;
    }
#line 146
    goto switch_break;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 151
    if ((int const   )*ptr >= 48) {
#line 151
      if ((int const   )*ptr <= 57) {
#line 153
        num = 0;
        {
#line 154
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 156
          num = 10 * num + (int )((int const   )*ptr - 48);
#line 157
          if (num > 31) {
#line 159
            num = 31;
#line 160
            err_range = 1;
          }
#line 162
          ptr ++;
#line 154
          if ((int const   )*ptr >= 48) {
#line 154
            if (! ((int const   )*ptr <= 57)) {
#line 154
              goto while_break___1;
            }
          } else {
#line 154
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 164
        if (! ((mask_set & (1U << num)) != 0U)) {
#line 165
          err_range = 1;
        }
#line 166
        if (state == 0) {
#line 167
          num1 = num;
        }
#line 168
        num2 = num;
#line 169
        state ++;
#line 170
        goto __Cont;
      }
    }
#line 172
    goto switch_break;
    case_1: /* CIL Label */ 
#line 175
    if ((int const   )*ptr == 45) {
#line 177
      ptr ++;
#line 178
      num2 = 31;
#line 179
      state ++;
#line 180
      goto __Cont;
    }
#line 182
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 185
    if (state > 0) {
#line 188
      if (num1 <= num2) {
#line 190
        if (num1 <= num2) {
#line 190
          tmp___0 = (((1U << (num2 - num1)) << 1) - 1U) << num1;
        } else {
#line 190
          tmp___0 = 0U;
        }
#line 190
        result |= tmp___0;
#line 191
        result &= mask_set;
      } else {
#line 196
        err_range = 1;
      }
#line 198
      state = 0;
    }
#line 201
    if ((int const   )*ptr == 44) {
#line 204
      ptr ++;
#line 205
      goto __Cont;
    } else
#line 201
    if ((int const   )*ptr == 59) {
#line 204
      ptr ++;
#line 205
      goto __Cont;
    } else
#line 207
    if ((int const   )*ptr == 45) {
#line 210
      err_invalid = 1;
#line 211
      goto while_break;
    } else {
#line 216
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 220
    tmp___1 = isspace((int )*ptr);
    }
#line 220
    if (! tmp___1) {
#line 220
      goto while_break___2;
    }
#line 220
    ptr ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 221
  if ((int const   )*ptr != 0) {
#line 224
    err_invalid = 1;
  }
#line 227
  if (err_invalid) {
    {
#line 231
    tmp___2 = __errno_location();
#line 231
    *tmp___2 = 22;
#line 233
    *out_set = 0U;
    }
#line 234
    return (-1);
  } else
#line 236
  if (err_range) {
    {
#line 240
    tmp___3 = __errno_location();
#line 240
    *tmp___3 = 34;
#line 242
    *out_set = ~ 0U;
    }
#line 243
    return (-1);
  } else {
#line 248
    *out_set = result;
#line 249
    return (0);
  }
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 73 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.h"
int opng_initialize(struct opng_options  const  *init_options , struct opng_ui  const  *init_ui ) ;
#line 79
int opng_optimize(char const   *infile_name ) ;
#line 84
int opng_finalize(void) ;
#line 58 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 67
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 35 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
struct exception_context the_exception_context[1]  ;
#line 41 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static struct opng_preset  const  presets[8]  = 
#line 41
  {      {"", "", "", ""}, 
        {"", "", "", ""}, 
        {"9", "8", "0-", "0,5"}, 
        {"9", "8-9", "0-", "0,5"}, 
        {"9", "8", "0-", "0-"}, 
        {"9", "8-9", "0-", "0-"}, 
        {"1-9", "8", "0-", "0-"}, 
        {"1-9", "8-9", "0-", "0-"}};
#line 63 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int const   filter_table[6]  = {      (int const   )8,      (int const   )16,      (int const   )32,      (int const   )64, 
        (int const   )128,      (int const   )248};
#line 95 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_PLTE[4]  = {      (png_byte const   )80,      (png_byte const   )76,      (png_byte const   )84,      (png_byte const   )69};
#line 96 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_tRNS[4]  = {      (png_byte const   )116,      (png_byte const   )82,      (png_byte const   )78,      (png_byte const   )83};
#line 97 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_IDAT[4]  = {      (png_byte const   )73,      (png_byte const   )68,      (png_byte const   )65,      (png_byte const   )84};
#line 98 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_IEND[4]  = {      (png_byte const   )73,      (png_byte const   )69,      (png_byte const   )78,      (png_byte const   )68};
#line 99 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_bKGD[4]  = {      (png_byte const   )98,      (png_byte const   )75,      (png_byte const   )71,      (png_byte const   )68};
#line 100 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_hIST[4]  = {      (png_byte const   )104,      (png_byte const   )73,      (png_byte const   )83,      (png_byte const   )84};
#line 101 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_sBIT[4]  = {      (png_byte const   )115,      (png_byte const   )66,      (png_byte const   )73,      (png_byte const   )84};
#line 102 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_dSIG[4]  = {      (png_byte const   )100,      (png_byte const   )83,      (png_byte const   )73,      (png_byte const   )71};
#line 103 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_acTL[4]  = {      (png_byte const   )97,      (png_byte const   )99,      (png_byte const   )84,      (png_byte const   )76};
#line 104 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_fcTL[4]  = {      (png_byte const   )102,      (png_byte const   )99,      (png_byte const   )84,      (png_byte const   )76};
#line 105 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_byte const   sig_fdAT[4]  = {      (png_byte const   )102,      (png_byte const   )100,      (png_byte const   )65,      (png_byte const   )84};
#line 111 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static struct opng_engine_struct engine  ;
#line 119 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static struct opng_process_struct process  ;
#line 136 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static unsigned long const   idat_size_max  =    (opng_fsize_t const   )((png_uint_32 )2147483647L);
#line 137 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static char const   *idat_size_max_string  =    "2GB";
#line 142 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static struct opng_summary_struct summary  ;
#line 153 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static struct opng_image_struct image  ;
#line 181 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static struct opng_options options  ;
#line 187 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void (*usr_printf)(char const   *fmt  , ...)  ;
#line 188 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void (*usr_print_cntrl)(int cntrl_code )  ;
#line 189 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void (*usr_progress)(unsigned long num , unsigned long denom )  ;
#line 190 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void (*usr_panic)(char const   *msg )  ;
#line 196 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_structp read_ptr  ;
#line 197 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_infop read_info_ptr  ;
#line 198 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_structp write_ptr  ;
#line 199 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_infop write_info_ptr  ;
#line 212 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_print_fsize_ratio(opng_fsize_t num , opng_fsize_t denom ) 
{ 
  char buffer___0[32] ;
  struct opng_ulratio ratio ;
  int result ;
  char const   *tmp ;

  {
  {
#line 227
  ratio.num = num;
#line 228
  ratio.denom = denom;
#line 229
  result = opng_ulratio_to_factor_string(buffer___0, sizeof(buffer___0), (struct opng_ulratio  const  *)(& ratio));
  }
#line 230
  if (result > 0) {
#line 230
    tmp = "";
  } else {
#line 230
    tmp = "...";
  }
  {
#line 230
  (*usr_printf)("%s%s", buffer___0, tmp);
  }
#line 234
  return;
}
}
#line 239 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_print_fsize_difference(opng_fsize_t init_size , opng_fsize_t final_size ,
                                        int show_ratio ) 
{ 
  opng_fsize_t difference ;
  int sign ;
  char const   *tmp ;

  {
#line 246
  if (init_size <= final_size) {
#line 248
    sign = 0;
#line 249
    difference = final_size - init_size;
  } else {
#line 253
    sign = 1;
#line 254
    difference = init_size - final_size;
  }
#line 257
  if (difference == 0UL) {
    {
#line 259
    (*usr_printf)("no change");
    }
#line 260
    return;
  }
#line 262
  if (difference == 1UL) {
    {
#line 263
    (*usr_printf)("1 byte");
    }
  } else {
    {
#line 265
    (*usr_printf)("%lu bytes", difference);
    }
  }
#line 266
  if (show_ratio) {
#line 266
    if (init_size > 0UL) {
      {
#line 268
      (*usr_printf)(" = ");
#line 269
      opng_print_fsize_ratio(difference, init_size);
      }
    }
  }
#line 271
  if (sign == 0) {
#line 271
    tmp = " increase";
  } else {
#line 271
    tmp = " decrease";
  }
  {
#line 271
  (*usr_printf)(tmp);
  }
#line 272
  return;
}
}
#line 281
static void opng_print_image_info(int show_dim , int show_depth , int show_type ,
                                  int show_interlaced ) ;
#line 281 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int const   type_channels[8]  = 
#line 281
  {      (int const   )1,      (int const   )0,      (int const   )3,      (int const   )1, 
        (int const   )2,      (int const   )0,      (int const   )4,      (int const   )0};
#line 277 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_print_image_info(int show_dim , int show_depth , int show_type ,
                                  int show_interlaced ) 
{ 
  int channels ;
  int printed ;
  char const   *tmp ;

  {
#line 284
  printed = 0;
#line 285
  if (show_dim) {
    {
#line 287
    printed = 1;
#line 288
    (*usr_printf)("%lux%lu pixels", (unsigned long )image.width, (unsigned long )image.height);
    }
  }
#line 291
  if (show_depth) {
#line 293
    if (printed) {
      {
#line 294
      (*usr_printf)(", ");
      }
    }
#line 295
    printed = 1;
#line 296
    channels = (int )type_channels[image.color_type & 7];
#line 297
    if (channels != 1) {
      {
#line 298
      (*usr_printf)("%dx%d bits/pixel", channels, image.bit_depth);
      }
    } else
#line 299
    if (image.bit_depth != 1) {
      {
#line 300
      (*usr_printf)("%d bits/pixel", image.bit_depth);
      }
    } else {
      {
#line 302
      (*usr_printf)("1 bit/pixel");
      }
    }
  }
#line 304
  if (show_type) {
#line 306
    if (printed) {
      {
#line 307
      (*usr_printf)(", ");
      }
    }
#line 308
    printed = 1;
#line 309
    if (image.color_type & 1) {
#line 311
      if (image.num_palette == 1) {
        {
#line 312
        (*usr_printf)("1 color");
        }
      } else {
        {
#line 314
        (*usr_printf)("%d colors", image.num_palette);
        }
      }
#line 315
      if (image.num_trans > 0) {
        {
#line 316
        (*usr_printf)(" (%d transparent)", image.num_trans);
        }
      }
      {
#line 317
      (*usr_printf)(" in palette");
      }
    } else {
#line 321
      if (image.color_type & 2) {
#line 321
        tmp = "RGB";
      } else {
#line 321
        tmp = "grayscale";
      }
      {
#line 321
      (*usr_printf)(tmp);
      }
#line 323
      if (image.color_type & 4) {
        {
#line 324
        (*usr_printf)("+alpha");
        }
      } else
#line 325
      if ((unsigned long )image.trans_color_ptr != (unsigned long )((void *)0)) {
        {
#line 326
        (*usr_printf)("+transparency");
        }
      }
    }
  }
#line 329
  if (show_interlaced) {
#line 331
    if (image.interlace_type != 0) {
#line 333
      if (printed) {
        {
#line 334
        (*usr_printf)(", ");
        }
      }
      {
#line 335
      (*usr_printf)("interlaced");
      }
    }
  }
#line 338
  return;
}
}
#line 343 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_print_warning(char const   *msg ) 
{ 


  {
  {
#line 346
  (*usr_print_cntrl)('\v');
#line 347
  (*usr_printf)("Warning: %s\n", msg);
  }
#line 348
  return;
}
}
#line 353 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_print_error(char const   *msg ) 
{ 


  {
  {
#line 356
  (*usr_print_cntrl)('\v');
#line 357
  (*usr_printf)("Error: %s\n", msg);
  }
#line 358
  return;
}
}
#line 363 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_warning(png_structp png_ptr , png_const_charp msg ) 
{ 


  {
#line 368
  if ((unsigned long )png_ptr == (unsigned long )read_ptr) {
#line 369
    process.status |= 8448U;
  }
  {
#line 370
  opng_print_warning(msg);
  }
#line 371
  return;
}
}
#line 376 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_error(png_structp png_ptr , png_const_charp msg ) 
{ 


  {
#line 381
  if ((unsigned long )png_ptr == (unsigned long )read_ptr) {
#line 382
    process.status |= 8448U;
  }
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 383
    the_exception_context[0].v.etmp = (char const   */* volatile  */)msg;
#line 383
    longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 389 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_free(void *ptr ) 
{ 


  {
  {
#line 396
  free(ptr);
  }
#line 397
  return;
}
}
#line 402 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_check_idat_size(opng_fsize_t size ) 
{ 


  {
#line 405
  if (size > (opng_fsize_t )idat_size_max) {
    {
#line 406
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 406
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"IDAT sizes larger than the maximum chunk size are currently unsupported";
#line 406
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 408
  return;
}
}
#line 413 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_set_keep_unknown_chunk(png_structp png_ptr , int keep , png_bytep chunk_type ) 
{ 
  png_byte chunk_name[5] ;
  int tmp ;

  {
  {
#line 420
  memcpy((void */* __restrict  */)(chunk_name), (void const   */* __restrict  */)chunk_type,
         (size_t )4);
#line 421
  chunk_name[4] = (png_byte )0;
#line 422
  tmp = png_handle_as_unknown((png_const_structrp )png_ptr, (png_const_bytep )(chunk_name));
  }
#line 422
  if (! tmp) {
    {
#line 423
    png_set_keep_unknown_chunks((png_structrp )png_ptr, keep, (png_const_bytep )(chunk_name),
                                1);
    }
  }
#line 424
  return;
}
}
#line 429 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int opng_is_image_chunk(png_bytep chunk_type ) 
{ 
  int tmp ;

  {
#line 432
  if (((int )*(chunk_type + 0) & 32) == 0) {
#line 433
    return (1);
  }
  {
#line 439
  tmp = memcmp((void const   *)chunk_type, (void const   *)(sig_tRNS), (size_t )4);
  }
#line 439
  if (tmp == 0) {
#line 440
    return (1);
  }
#line 441
  return (0);
}
}
#line 447 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int opng_is_apng_chunk(png_bytep chunk_type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 450
  tmp = memcmp((void const   *)chunk_type, (void const   *)(sig_acTL), (size_t )4);
  }
#line 450
  if (tmp == 0) {
#line 453
    return (1);
  } else {
    {
#line 450
    tmp___0 = memcmp((void const   *)chunk_type, (void const   *)(sig_fcTL), (size_t )4);
    }
#line 450
    if (tmp___0 == 0) {
#line 453
      return (1);
    } else {
      {
#line 450
      tmp___1 = memcmp((void const   *)chunk_type, (void const   *)(sig_fdAT), (size_t )4);
      }
#line 450
      if (tmp___1 == 0) {
#line 453
        return (1);
      }
    }
  }
#line 454
  return (0);
}
}
#line 460 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int opng_allow_chunk(png_bytep chunk_type ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 464
  tmp = opng_is_image_chunk(chunk_type);
  }
#line 464
  if (tmp) {
#line 465
    return (1);
  }
#line 467
  if (options.strip_all) {
#line 468
    return (0);
  }
  {
#line 470
  tmp___0 = memcmp((void const   *)chunk_type, (void const   *)(sig_dSIG), (size_t )4);
  }
#line 470
  if (tmp___0 == 0) {
#line 471
    return (0);
  }
#line 473
  if (options.snip) {
    {
#line 473
    tmp___1 = opng_is_apng_chunk(chunk_type);
    }
#line 473
    if (tmp___1) {
#line 474
      return (0);
    }
  }
#line 476
  return (1);
}
}
#line 482 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_handle_chunk(png_structp png_ptr , png_bytep chunk_type ) 
{ 
  int keep ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 487
  tmp = opng_is_image_chunk(chunk_type);
  }
#line 487
  if (tmp) {
#line 488
    return;
  }
#line 490
  if (options.strip_all) {
    {
#line 492
    process.status |= 192U;
#line 493
    opng_set_keep_unknown_chunk(png_ptr, 1, chunk_type);
    }
#line 495
    return;
  }
  {
#line 499
  tmp___0 = memcmp((void const   *)chunk_type, (void const   *)(sig_bKGD), (size_t )4);
  }
#line 499
  if (tmp___0 == 0) {
#line 502
    return;
  } else {
    {
#line 499
    tmp___1 = memcmp((void const   *)chunk_type, (void const   *)(sig_hIST), (size_t )4);
    }
#line 499
    if (tmp___1 == 0) {
#line 502
      return;
    } else {
      {
#line 499
      tmp___2 = memcmp((void const   *)chunk_type, (void const   *)(sig_sBIT), (size_t )4);
      }
#line 499
      if (tmp___2 == 0) {
#line 502
        return;
      }
    }
  }
  {
#line 505
  keep = 3;
#line 506
  tmp___5 = memcmp((void const   *)chunk_type, (void const   *)(sig_dSIG), (size_t )4);
  }
#line 506
  if (tmp___5 == 0) {
#line 509
    process.status |= 8U;
  } else {
    {
#line 511
    tmp___4 = opng_is_apng_chunk(chunk_type);
    }
#line 511
    if (tmp___4) {
      {
#line 514
      process.status |= 32U;
#line 515
      tmp___3 = memcmp((void const   *)chunk_type, (void const   *)(sig_fdAT), (size_t )4);
      }
#line 515
      if (tmp___3 == 0) {
#line 516
        process.status |= 16U;
      }
#line 517
      if (options.snip) {
#line 519
        process.status |= 128U;
#line 520
        keep = 1;
      }
    }
  }
  {
#line 523
  opng_set_keep_unknown_chunk(png_ptr, keep, chunk_type);
  }
#line 524
  return;
}
}
#line 529 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_init_read_data(void) 
{ 


  {
#line 535
  return;
}
}
#line 540 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_init_write_data(void) 
{ 


  {
#line 543
  process.out_file_size = (opng_fsize_t )0;
#line 544
  process.out_plte_trns_size = (png_uint_32 )0;
#line 545
  process.out_idat_size = (opng_fsize_t )0;
#line 546
  return;
}
}
#line 551 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_read_data(png_structp png_ptr , png_bytep data , size_t length ) 
{ 
  FILE *stream ;
  png_voidp tmp ;
  int io_state ;
  png_uint_32 tmp___0 ;
  int io_state_loc ;
  png_bytep chunk_sig ;
  size_t tmp___1 ;
  opng_foffset_t tmp___2 ;
  png_uint_32 tmp___3 ;
  png_bytepp tmp___4 ;
  png_bytepp tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 554
  tmp = png_get_io_ptr((png_const_structrp )png_ptr);
#line 554
  stream = (FILE *)tmp;
#line 555
  tmp___0 = png_get_io_state((png_const_structrp )png_ptr);
#line 555
  io_state = (int )tmp___0;
#line 556
  io_state_loc = io_state & 240;
#line 560
  tmp___1 = fread((void */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)stream);
  }
#line 560
  if (tmp___1 != length) {
    {
#line 561
    png_error((png_const_structrp )png_ptr, "Can\'t read the input file or unexpected end of file");
    }
  }
#line 564
  if (process.in_file_size == 0UL) {
#line 566
    if (! (length == 8UL)) {
      {
#line 566
      (*usr_panic)("PNG I/O must start with the first 8 bytes");
      }
    }
    {
#line 567
    tmp___2 = opng_ftello(stream);
#line 567
    process.in_datastream_offset = tmp___2 - 8L;
#line 568
    process.status |= 2U;
    }
#line 569
    if (io_state_loc == 16) {
#line 570
      process.status |= 4U;
    }
#line 571
    if (process.in_datastream_offset == 0L) {
#line 572
      process.status |= 1U;
    } else
#line 573
    if (process.in_datastream_offset < 0L) {
      {
#line 574
      png_error((png_const_structrp )png_ptr, "Can\'t get the file-position indicator in input file");
      }
    }
#line 576
    process.in_file_size = (opng_fsize_t )process.in_datastream_offset;
  }
#line 578
  process.in_file_size += length;
#line 581
  if (io_state & 1) {
#line 581
    if (! (io_state_loc != 0)) {
      {
#line 581
      (*usr_panic)("Incorrect info in png_ptr->io_state");
      }
    }
  } else {
    {
#line 581
    (*usr_panic)("Incorrect info in png_ptr->io_state");
    }
  }
#line 583
  if (io_state_loc == 32) {
#line 589
    if (! (length == 8UL)) {
      {
#line 589
      (*usr_panic)("Reading chunk header, expecting 8 bytes");
      }
    }
    {
#line 590
    chunk_sig = data + 4;
#line 592
    tmp___8 = memcmp((void const   *)chunk_sig, (void const   *)(sig_IDAT), (size_t )4);
    }
#line 592
    if (tmp___8 == 0) {
#line 594
      if (! ((unsigned long )png_ptr == (unsigned long )read_ptr)) {
        {
#line 594
        (*usr_panic)("Incorrect I/O handler setup");
        }
      }
      {
#line 595
      tmp___5 = png_get_rows((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr);
      }
#line 595
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 597
        if (! (process.in_idat_size == 0UL)) {
          {
#line 597
          (*usr_panic)("Found IDAT with no rows");
          }
        }
        {
#line 603
        tmp___3 = png_get_image_height((png_const_structrp )read_ptr, (png_const_inforp )read_info_ptr);
        }
#line 603
        if (tmp___3 == 0U) {
#line 604
          return;
        }
        {
#line 605
        tmp___4 = pngx_malloc_rows(read_ptr, read_info_ptr, 0);
        }
#line 605
        if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
          {
#line 605
          (*usr_panic)("Failed allocation of image rows; unsafe libpng allocator");
          }
        }
        {
#line 609
        png_data_freer((png_const_structrp )read_ptr, (png_inforp )read_info_ptr,
                       2, 64U);
        }
      } else {
#line 615
        process.status |= 128U;
      }
#line 617
      process.in_idat_size += (opng_fsize_t )(((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3));
    } else {
      {
#line 619
      tmp___6 = memcmp((void const   *)chunk_sig, (void const   *)(sig_PLTE), (size_t )4);
      }
#line 619
      if (tmp___6 == 0) {
#line 623
        process.in_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
      } else {
        {
#line 619
        tmp___7 = memcmp((void const   *)chunk_sig, (void const   *)(sig_tRNS), (size_t )4);
        }
#line 619
        if (tmp___7 == 0) {
#line 623
          process.in_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
        } else {
          {
#line 626
          opng_handle_chunk(png_ptr, chunk_sig);
          }
        }
      }
    }
  } else
#line 628
  if (io_state_loc == 128) {
#line 630
    if (! (length == 4UL)) {
      {
#line 630
      (*usr_panic)("Reading chunk CRC, expecting 4 bytes");
      }
    }
  }
#line 632
  return;
}
}
#line 640 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int allow_crt_chunk  ;
#line 641 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int crt_chunk_is_idat  ;
#line 642 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static opng_foffset_t crt_idat_offset  ;
#line 643 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static opng_fsize_t crt_idat_size  ;
#line 644 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static png_uint_32 crt_idat_crc  ;
#line 637 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_write_data(png_structp png_ptr , png_bytep data , size_t length ) 
{ 
  FILE *stream ;
  png_voidp tmp ;
  int io_state ;
  png_uint_32 tmp___0 ;
  int io_state_loc ;
  png_bytep chunk_sig ;
  png_byte buf[4] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uLong tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  uLong tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 645
  tmp = png_get_io_ptr((png_const_structrp )png_ptr);
#line 645
  stream = (FILE *)tmp;
#line 646
  tmp___0 = png_get_io_state((png_const_structrp )png_ptr);
#line 646
  io_state = (int )tmp___0;
#line 647
  io_state_loc = io_state & 240;
  }
#line 651
  if (io_state & 2) {
#line 651
    if (! (io_state_loc != 0)) {
      {
#line 651
      (*usr_panic)("Incorrect info in png_ptr->io_state");
      }
    }
  } else {
    {
#line 651
    (*usr_panic)("Incorrect info in png_ptr->io_state");
    }
  }
#line 655
  if (io_state_loc == 32) {
#line 657
    if (! (length == 8UL)) {
      {
#line 657
      (*usr_panic)("Writing chunk header, expecting 8 bytes");
      }
    }
    {
#line 658
    chunk_sig = data + 4;
#line 659
    allow_crt_chunk = opng_allow_chunk(chunk_sig);
#line 660
    tmp___3 = memcmp((void const   *)chunk_sig, (void const   *)(sig_IDAT), (size_t )4);
    }
#line 660
    if (tmp___3 == 0) {
#line 662
      crt_chunk_is_idat = 1;
#line 663
      process.out_idat_size += (opng_fsize_t )(((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3));
#line 665
      if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 667
        if (process.out_idat_size > process.max_idat_size) {
          {
#line 668
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 668
            the_exception_context[0].v.etmp = (char const   */* volatile  */)((void *)0);
#line 668
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
      }
    } else {
      {
#line 673
      crt_chunk_is_idat = 0;
#line 674
      tmp___1 = memcmp((void const   *)chunk_sig, (void const   *)(sig_PLTE), (size_t )4);
      }
#line 674
      if (tmp___1 == 0) {
#line 678
        process.out_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
      } else {
        {
#line 674
        tmp___2 = memcmp((void const   *)chunk_sig, (void const   *)(sig_tRNS), (size_t )4);
        }
#line 674
        if (tmp___2 == 0) {
#line 678
          process.out_plte_trns_size += (((((png_uint_32 )*data << 24) + ((png_uint_32 )*(data + 1) << 16)) + ((png_uint_32 )*(data + 2) << 8)) + (png_uint_32 )*(data + 3)) + 12U;
        }
      }
    }
  } else
#line 682
  if (io_state_loc == 128) {
#line 684
    if (! (length == 4UL)) {
      {
#line 684
      (*usr_panic)("Writing chunk CRC, expecting 4 bytes");
      }
    }
  }
#line 688
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 689
    return;
  }
#line 692
  if (io_state_loc != 16) {
#line 692
    if (! allow_crt_chunk) {
#line 693
      return;
    }
  }
  {
#line 701
  if (io_state_loc == 32) {
#line 701
    goto case_32;
  }
#line 761
  if (io_state_loc == 64) {
#line 761
    goto case_64;
  }
#line 765
  if (io_state_loc == 128) {
#line 765
    goto case_128;
  }
#line 699
  goto switch_break;
  case_32: /* CIL Label */ 
#line 702
  if (crt_chunk_is_idat) {
#line 704
    if (crt_idat_offset == 0L) {
      {
#line 707
      crt_idat_offset = opng_ftello(stream);
      }
#line 709
      if (process.best_idat_size > 0UL) {
#line 712
        crt_idat_size = process.best_idat_size;
      } else {
#line 719
        crt_idat_size = length;
      }
      {
#line 721
      png_save_uint_32(data, (png_uint_32 )crt_idat_size);
#line 723
      tmp___4 = crc32((uLong )0, sig_IDAT, (uInt )4);
#line 723
      crt_idat_crc = (png_uint_32 )tmp___4;
      }
    } else {
#line 728
      return;
    }
  } else
#line 733
  if (crt_idat_offset != 0L) {
    {
#line 738
    png_save_uint_32(buf, crt_idat_crc);
#line 739
    tmp___5 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                     (FILE */* __restrict  */)stream);
    }
#line 739
    if (tmp___5 != 4UL) {
#line 740
      io_state = 0;
    }
#line 741
    process.out_file_size += 4UL;
#line 742
    if (process.out_idat_size != crt_idat_size) {
#line 747
      if (! (process.best_idat_size == 0UL)) {
        {
#line 747
        (*usr_panic)("Wrong guess of the output IDAT size");
        }
      }
      {
#line 749
      opng_check_idat_size(process.out_idat_size);
#line 750
      png_save_uint_32(buf, (png_uint_32 )process.out_idat_size);
#line 751
      tmp___6 = opng_fwriteo(stream, crt_idat_offset, 0, (void const   *)(buf), (size_t )4);
      }
#line 751
      if (tmp___6 != 4UL) {
#line 753
        io_state = 0;
      }
    }
#line 755
    if (io_state == 0) {
      {
#line 756
      png_error((png_const_structrp )png_ptr, "Can\'t finalize IDAT");
      }
    }
#line 757
    crt_idat_offset = (opng_foffset_t )0;
  }
#line 760
  goto switch_break;
  case_64: /* CIL Label */ 
#line 762
  if (crt_chunk_is_idat) {
    {
#line 763
    tmp___7 = crc32((uLong )crt_idat_crc, (Bytef const   *)data, (uInt )length);
#line 763
    crt_idat_crc = (png_uint_32 )tmp___7;
    }
  }
#line 764
  goto switch_break;
  case_128: /* CIL Label */ 
#line 766
  if (crt_chunk_is_idat) {
#line 769
    return;
  }
#line 771
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 775
  tmp___8 = fwrite((void const   */* __restrict  */)data, (size_t )1, length, (FILE */* __restrict  */)stream);
  }
#line 775
  if (tmp___8 != length) {
    {
#line 776
    png_error((png_const_structrp )png_ptr, "Can\'t write the output file");
    }
  }
#line 777
  process.out_file_size += length;
#line 778
  return;
}
}
#line 783 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_clear_image_info(void) 
{ 


  {
  {
#line 786
  memset((void *)(& image), 0, sizeof(image));
  }
#line 787
  return;
}
}
#line 792 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_load_image_info(png_structp png_ptr , png_infop info_ptr , int load_meta ) 
{ 
  png_uint_32 tmp ;
  png_uint_32 tmp___0 ;
  png_uint_32 tmp___1 ;

  {
  {
#line 795
  memset((void *)(& image), 0, sizeof(image));
#line 797
  png_get_IHDR((png_const_structrp )png_ptr, (png_const_inforp )info_ptr, & image.width,
               & image.height, & image.bit_depth, & image.color_type, & image.interlace_type,
               & image.compression_type, & image.filter_type);
#line 801
  image.row_pointers = png_get_rows((png_const_structrp )png_ptr, (png_const_inforp )info_ptr);
#line 802
  png_get_PLTE((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.palette,
               & image.num_palette);
#line 806
  tmp = png_get_tRNS((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.trans_alpha,
                     & image.num_trans, & image.trans_color_ptr);
  }
#line 806
  if (tmp) {
#line 813
    if ((unsigned long )image.trans_color_ptr != (unsigned long )((void *)0)) {
#line 815
      image.trans_color = *(image.trans_color_ptr);
#line 816
      image.trans_color_ptr = & image.trans_color;
    }
  }
#line 820
  if (! load_meta) {
#line 821
    return;
  }
  {
#line 823
  tmp___0 = png_get_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.background_ptr);
  }
#line 823
  if (tmp___0) {
#line 826
    image.background = *(image.background_ptr);
#line 827
    image.background_ptr = & image.background;
  }
  {
#line 829
  png_get_hIST((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.hist);
#line 830
  tmp___1 = png_get_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, & image.sig_bit_ptr);
  }
#line 830
  if (tmp___1) {
#line 833
    image.sig_bit = *(image.sig_bit_ptr);
#line 834
    image.sig_bit_ptr = & image.sig_bit;
  }
  {
#line 836
  image.num_unknowns = png_get_unknown_chunks((png_const_structrp )png_ptr, (png_inforp )info_ptr,
                                              & image.unknowns);
  }
#line 838
  return;
}
}
#line 843 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_store_image_info(png_structp png_ptr , png_infop info_ptr , int store_meta ) 
{ 
  int i ;

  {
#line 848
  if (! ((unsigned long )image.row_pointers != (unsigned long )((void *)0))) {
    {
#line 848
    (*usr_panic)("No info in image");
    }
  }
  {
#line 850
  png_set_IHDR((png_const_structrp )png_ptr, (png_inforp )info_ptr, image.width, image.height,
               image.bit_depth, image.color_type, image.interlace_type, image.compression_type,
               image.filter_type);
#line 854
  png_set_rows((png_const_structrp )write_ptr, (png_inforp )write_info_ptr, image.row_pointers);
  }
#line 855
  if ((unsigned long )image.palette != (unsigned long )((void *)0)) {
    {
#line 856
    png_set_PLTE((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_colorp )image.palette,
                 image.num_palette);
    }
  }
#line 860
  if ((unsigned long )image.trans_alpha != (unsigned long )((void *)0)) {
    {
#line 861
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )image.trans_alpha,
                 image.num_trans, (png_const_color_16p )image.trans_color_ptr);
    }
  } else
#line 860
  if ((unsigned long )image.trans_color_ptr != (unsigned long )((void *)0)) {
    {
#line 861
    png_set_tRNS((png_structrp )png_ptr, (png_inforp )info_ptr, (png_const_bytep )image.trans_alpha,
                 image.num_trans, (png_const_color_16p )image.trans_color_ptr);
    }
  }
#line 865
  if (! store_meta) {
#line 866
    return;
  }
#line 868
  if ((unsigned long )image.background_ptr != (unsigned long )((void *)0)) {
    {
#line 869
    png_set_bKGD((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_16p )image.background_ptr);
    }
  }
#line 870
  if ((unsigned long )image.hist != (unsigned long )((void *)0)) {
    {
#line 871
    png_set_hIST((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_uint_16p )image.hist);
    }
  }
#line 872
  if ((unsigned long )image.sig_bit_ptr != (unsigned long )((void *)0)) {
    {
#line 873
    png_set_sBIT((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_color_8p )image.sig_bit_ptr);
    }
  }
#line 874
  if (image.num_unknowns != 0) {
    {
#line 876
    png_set_unknown_chunks((png_const_structrp )png_ptr, (png_inforp )info_ptr, (png_const_unknown_chunkp )image.unknowns,
                           image.num_unknowns);
#line 879
    i = 0;
    }
    {
#line 879
    while (1) {
      while_continue: /* CIL Label */ ;
#line 879
      if (! (i < image.num_unknowns)) {
#line 879
        goto while_break;
      }
      {
#line 880
      png_set_unknown_chunk_location((png_const_structrp )png_ptr, (png_inforp )info_ptr,
                                     i, (int )(image.unknowns + i)->location);
#line 879
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 883
  return;
}
}
#line 888 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_destroy_image_info(void) 
{ 
  png_uint_32 i ;
  int j ;

  {
#line 894
  if ((unsigned long )image.row_pointers == (unsigned long )((void *)0)) {
#line 895
    return;
  }
#line 897
  i = (png_uint_32 )0;
  {
#line 897
  while (1) {
    while_continue: /* CIL Label */ ;
#line 897
    if (! (i < image.height)) {
#line 897
      goto while_break;
    }
    {
#line 898
    opng_free((void *)*(image.row_pointers + i));
#line 897
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 899
  opng_free((void *)image.row_pointers);
#line 900
  opng_free((void *)image.palette);
#line 901
  opng_free((void *)image.trans_alpha);
#line 902
  opng_free((void *)image.hist);
#line 903
  j = 0;
  }
  {
#line 903
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 903
    if (! (j < image.num_unknowns)) {
#line 903
      goto while_break___0;
    }
    {
#line 904
    opng_free((void *)(image.unknowns + j)->data);
#line 903
    j ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 905
  opng_free((void *)image.unknowns);
#line 913
  memset((void *)(& image), 0, sizeof(image));
  }
#line 914
  return;
}
}
#line 919 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_read_file(FILE *infile___0 ) 
{ 
  char const   *fmt_name ;
  int num_img ;
  png_uint_32 reductions ;
  char const   * volatile  err_msg ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  jmp_buf * volatile  exception__prev___0 ;
  jmp_buf exception__env___0 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 927
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 927
  the_exception_context[0].penv = & exception__env;
#line 927
  tmp___2 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 927
  if (tmp___2 == 0) {
    {
#line 927
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 929
      tmp = png_create_read_struct("1.6.34", (void *)0, & opng_error, & opng_warning);
#line 929
      read_ptr = (png_structp )tmp;
#line 931
      tmp___0 = png_create_info_struct((png_const_structrp )read_ptr);
#line 931
      read_info_ptr = (png_infop )tmp___0;
      }
#line 932
      if ((unsigned long )read_info_ptr == (unsigned long )((void *)0)) {
        {
#line 933
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 933
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 933
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 936
      png_set_keep_unknown_chunks((png_structrp )read_ptr, 3, (png_const_bytep )((void *)0),
                                  0);
#line 938
      png_set_user_limits((png_structrp )read_ptr, (png_uint_32 )2147483647L, (png_uint_32 )2147483647L);
#line 941
      opng_init_read_data();
#line 942
      png_set_read_fn((png_structrp )read_ptr, (png_voidp )infile___0, & opng_read_data);
#line 943
      fmt_name = (char const   *)((void *)0);
#line 944
      num_img = pngx_read_image(read_ptr, read_info_ptr, & fmt_name, (png_const_charpp )((void *)0));
      }
#line 945
      if (num_img <= 0) {
        {
#line 946
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 946
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Unrecognized image file format";
#line 946
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 947
      if (num_img > 1) {
#line 948
        process.status |= 16U;
      }
#line 949
      if (process.status & 1U) {
#line 949
        if (process.status & 16U) {
#line 953
          if (process.status & 4U) {
#line 953
            fmt_name = "APNG";
          } else {
#line 953
            fmt_name = "APNG datastream";
          }
        }
      }
#line 956
      if (! ((unsigned long )fmt_name != (unsigned long )((void *)0))) {
        {
#line 956
        (*usr_panic)("No format name from pngxtern");
        }
      }
#line 958
      if (process.in_file_size == 0UL) {
        {
#line 960
        tmp___1 = opng_fgetsize(infile___0, & process.in_file_size);
        }
#line 960
        if (tmp___1 < 0) {
          {
#line 962
          opng_print_warning("Can\'t get the correct file size");
#line 963
          process.in_file_size = (opng_fsize_t )0;
          }
        }
      }
#line 967
      err_msg = (char const   */* volatile  */)((void *)0);
#line 927
      the_exception_context[0].caught = 0;
#line 927
      if (! the_exception_context[0].caught) {
#line 927
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 969
    the_exception_context[0].caught = 1;
  }
#line 969
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 969
  if (! (! the_exception_context[0].caught)) {
    {
#line 969
    err_msg = the_exception_context[0].v.etmp;
#line 974
    tmp___3 = opng_validate_image(read_ptr, read_info_ptr);
    }
#line 974
    if (tmp___3) {
      {
#line 976
      png_warning((png_const_structrp )read_ptr, (png_const_charp )err_msg);
#line 977
      err_msg = (char const   */* volatile  */)((void *)0);
      }
    }
  }
  {
#line 981
  exception__prev___0 = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 981
  the_exception_context[0].penv = & exception__env___0;
#line 981
  tmp___5 = _setjmp((struct __jmp_buf_tag *)(exception__env___0));
  }
#line 981
  if (tmp___5 == 0) {
    {
#line 981
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 983
      if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
        {
#line 984
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 984
          the_exception_context[0].v.etmp = err_msg;
#line 984
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 987
      tmp___4 = strcmp(fmt_name, "PNG");
      }
#line 987
      if (tmp___4 != 0) {
        {
#line 989
        (*usr_printf)("Importing %s", fmt_name);
        }
#line 990
        if (process.status & 16U) {
#line 992
          if (! (process.status & 1U)) {
            {
#line 993
            (*usr_printf)(" (multi-image or animation)");
            }
          }
#line 994
          if (options.snip) {
            {
#line 995
            (*usr_printf)("; snipping...");
            }
          }
        }
        {
#line 997
        (*usr_printf)("\n");
        }
      }
      {
#line 999
      opng_load_image_info(read_ptr, read_info_ptr, 1);
#line 1000
      opng_print_image_info(1, 1, 1, 1);
#line 1001
      (*usr_printf)("\n");
#line 1004
      reductions = (png_uint_32 )1023;
      }
#line 1005
      if (options.nb) {
#line 1006
        reductions &= 4294967292U;
      }
#line 1007
      if (options.nc) {
#line 1008
        reductions &= 4294967043U;
      }
#line 1009
      if (options.np) {
#line 1010
        reductions &= 4294966527U;
      }
#line 1011
      if (options.nz) {
#line 1011
        if (process.status & 2U) {
#line 1014
          reductions = (png_uint_32 )0;
        }
      }
#line 1016
      if (process.status & 8U) {
#line 1019
        reductions = (png_uint_32 )0;
      }
#line 1021
      if (process.status & 1U) {
#line 1021
        if (process.status & 16U) {
#line 1021
          if (reductions != 0U) {
#line 1021
            if (! options.snip) {
              {
#line 1025
              (*usr_printf)("Can\'t reliably reduce APNG file; disabling reductions.\n(Did you want to -snip and optimize the first frame?)\n");
#line 1028
              reductions = (png_uint_32 )0;
              }
            }
          }
        }
      }
      {
#line 1032
      process.reductions = opng_reduce_image(read_ptr, read_info_ptr, reductions);
      }
#line 1036
      if (process.reductions != 0U) {
        {
#line 1038
        opng_load_image_info(read_ptr, read_info_ptr, 1);
#line 1039
        (*usr_printf)("Reducing image to ");
#line 1040
        opng_print_image_info(0, 1, 1, 0);
#line 1041
        (*usr_printf)("\n");
        }
      }
#line 1045
      if (options.interlace >= 0) {
#line 1045
        if (image.interlace_type != options.interlace) {
#line 1048
          image.interlace_type = options.interlace;
#line 1050
          process.status |= 8192U;
        }
      }
#line 981
      the_exception_context[0].caught = 0;
#line 981
      if (! the_exception_context[0].caught) {
#line 981
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
#line 1053
    the_exception_context[0].caught = 1;
  }
#line 1053
  the_exception_context[0].penv = (jmp_buf *)exception__prev___0;
#line 1053
  if (! (! the_exception_context[0].caught)) {
    {
#line 1053
    err_msg = the_exception_context[0].v.etmp;
#line 1056
    png_data_freer((png_const_structrp )read_ptr, (png_inforp )read_info_ptr, 1, 65535U);
#line 1058
    png_destroy_read_struct(& read_ptr, & read_info_ptr, (png_infopp )((void *)0));
    }
    {
#line 1059
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1059
      the_exception_context[0].v.etmp = err_msg;
#line 1059
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1065
  png_data_freer((png_const_structrp )read_ptr, (png_inforp )read_info_ptr, 2, 65535U);
#line 1067
  png_destroy_read_struct(& read_ptr, & read_info_ptr, (png_infopp )((void *)0));
  }
#line 1068
  return;
}
}
#line 1076 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_write_file(FILE *outfile___0 , int compression_level , int memory_level ,
                            int compression_strategy , int filter ) 
{ 
  char const   * volatile  err_msg ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  png_structp __attribute__((__malloc__))  tmp ;
  png_infop __attribute__((__malloc__))  tmp___0 ;
  int tmp___1 ;

  {
#line 1083
  if (compression_level >= 1) {
#line 1083
    if (compression_level <= 9) {
#line 1083
      if (memory_level >= 1) {
#line 1083
        if (memory_level <= 9) {
#line 1083
          if (compression_strategy >= 0) {
#line 1083
            if (compression_strategy <= 3) {
#line 1083
              if (filter >= 0) {
#line 1083
                if (! (filter <= 5)) {
                  {
#line 1083
                  (*usr_panic)("Invalid encoding parameters");
                  }
                }
              } else {
                {
#line 1083
                (*usr_panic)("Invalid encoding parameters");
                }
              }
            } else {
              {
#line 1083
              (*usr_panic)("Invalid encoding parameters");
              }
            }
          } else {
            {
#line 1083
            (*usr_panic)("Invalid encoding parameters");
            }
          }
        } else {
          {
#line 1083
          (*usr_panic)("Invalid encoding parameters");
          }
        }
      } else {
        {
#line 1083
        (*usr_panic)("Invalid encoding parameters");
        }
      }
    } else {
      {
#line 1083
      (*usr_panic)("Invalid encoding parameters");
      }
    }
  } else {
    {
#line 1083
    (*usr_panic)("Invalid encoding parameters");
    }
  }
  {
#line 1093
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1093
  the_exception_context[0].penv = & exception__env;
#line 1093
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1093
  if (tmp___1 == 0) {
    {
#line 1093
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1095
      tmp = png_create_write_struct("1.6.34", (void *)0, & opng_error, & opng_warning);
#line 1095
      write_ptr = (png_structp )tmp;
#line 1097
      tmp___0 = png_create_info_struct((png_const_structrp )write_ptr);
#line 1097
      write_info_ptr = (png_infop )tmp___0;
      }
#line 1098
      if ((unsigned long )write_info_ptr == (unsigned long )((void *)0)) {
        {
#line 1099
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1099
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 1099
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 1101
      png_set_compression_level((png_structrp )write_ptr, compression_level);
#line 1102
      png_set_compression_mem_level((png_structrp )write_ptr, memory_level);
#line 1103
      png_set_compression_strategy((png_structrp )write_ptr, compression_strategy);
#line 1104
      png_set_filter((png_structrp )write_ptr, 0, (int )filter_table[filter]);
      }
#line 1105
      if (compression_strategy != 2) {
#line 1105
        if (compression_strategy != 3) {
#line 1108
          if (options.window_bits > 0) {
            {
#line 1109
            png_set_compression_window_bits((png_structrp )write_ptr, options.window_bits);
            }
          }
        } else {
          {
#line 1117
          png_set_compression_window_bits((png_structrp )write_ptr, 9);
          }
        }
      } else {
        {
#line 1117
        png_set_compression_window_bits((png_structrp )write_ptr, 9);
        }
      }
      {
#line 1122
      png_set_keep_unknown_chunks((png_structrp )write_ptr, 3, (png_const_bytep )((void *)0),
                                  0);
#line 1124
      png_set_user_limits((png_structrp )write_ptr, (png_uint_32 )2147483647L, (png_uint_32 )2147483647L);
#line 1127
      opng_store_image_info(write_ptr, write_info_ptr, (unsigned long )outfile___0 != (unsigned long )((void *)0));
#line 1128
      opng_init_write_data();
#line 1129
      png_set_write_fn((png_structrp )write_ptr, (png_voidp )outfile___0, & opng_write_data,
                       (void (*)(png_structp  ))((void *)0));
#line 1130
      png_write_png((png_structrp )write_ptr, (png_inforp )write_info_ptr, 0, (void *)0);
#line 1132
      err_msg = (char const   */* volatile  */)((void *)0);
#line 1093
      the_exception_context[0].caught = 0;
      }
#line 1093
      if (! the_exception_context[0].caught) {
#line 1093
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1134
    the_exception_context[0].caught = 1;
  }
#line 1134
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1134
  if (! (! the_exception_context[0].caught)) {
#line 1134
    err_msg = the_exception_context[0].v.etmp;
#line 1137
    process.out_idat_size = (opng_fsize_t )(idat_size_max + 1UL);
  }
  {
#line 1141
  png_destroy_write_struct(& write_ptr, & write_info_ptr);
  }
#line 1143
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1144
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1144
      the_exception_context[0].v.etmp = err_msg;
#line 1144
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1145
  return;
}
}
#line 1150 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_copy_file(FILE *infile___0 , FILE *outfile___0 ) 
{ 
  png_bytep volatile   buf ;
  png_uint_32 buf_size_incr ;
  png_uint_32 buf_size ;
  png_uint_32 length ;
  png_byte chunk_hdr[8] ;
  char const   * volatile  err_msg ;
  png_structp __attribute__((__malloc__))  tmp ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  size_t tmp___0 ;
  png_voidp __attribute__((__malloc__))  tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1154
  buf_size_incr = (png_uint_32 )4096;
#line 1159
  tmp = png_create_write_struct("1.6.34", (void *)0, & opng_error, & opng_warning);
#line 1159
  write_ptr = (png_structp )tmp;
  }
#line 1161
  if ((unsigned long )write_ptr == (unsigned long )((void *)0)) {
    {
#line 1162
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1162
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Out of memory";
#line 1162
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1163
  opng_init_write_data();
#line 1164
  png_set_write_fn((png_structrp )write_ptr, (png_voidp )outfile___0, & opng_write_data,
                   (void (*)(png_structp  ))((void *)0));
#line 1166
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1166
  the_exception_context[0].penv = & exception__env;
#line 1166
  tmp___4 = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1166
  if (tmp___4 == 0) {
    {
#line 1166
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1168
      buf = (png_bytep volatile   )((void *)0);
#line 1169
      buf_size = (png_uint_32 )0;
#line 1172
      png_write_sig((png_structrp )write_ptr);
      }
      {
#line 1176
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1178
        tmp___0 = fread((void */* __restrict  */)(chunk_hdr), (size_t )8, (size_t )1,
                        (FILE */* __restrict  */)infile___0);
        }
#line 1178
        if (tmp___0 != 1UL) {
          {
#line 1179
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1179
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Read error";
#line 1179
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 1180
        length = ((((png_uint_32 )chunk_hdr[0] << 24) + ((png_uint_32 )*(chunk_hdr + 1) << 16)) + ((png_uint_32 )*(chunk_hdr + 2) << 8)) + (png_uint_32 )*(chunk_hdr + 3);
#line 1181
        if (length > 2147483647U) {
#line 1183
          if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1183
            if ((unsigned long )length == 2303741511UL) {
#line 1186
              goto __Cont;
            }
          }
          {
#line 1188
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 1188
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Data error";
#line 1188
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 1190
        if (length + 4U > buf_size) {
          {
#line 1192
          png_free((png_const_structrp )write_ptr, (png_voidp )buf);
#line 1193
          buf_size = (((length + 4U) + (buf_size_incr - 1U)) / buf_size_incr) * buf_size_incr;
#line 1196
          tmp___1 = png_malloc((png_const_structrp )write_ptr, (png_alloc_size_t )buf_size);
#line 1196
          buf = (png_bytep volatile   )((png_bytep )tmp___1);
          }
        }
        {
#line 1199
        tmp___2 = fread((void */* __restrict  */)buf, (size_t )(length + 4U), (size_t )1,
                        (FILE */* __restrict  */)infile___0);
        }
#line 1199
        if (tmp___2 != 1UL) {
          {
#line 1200
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 1200
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Read error";
#line 1200
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___4: /* CIL Label */ ;
          }
        }
        {
#line 1201
        png_write_chunk((png_structrp )write_ptr, (png_const_bytep )(chunk_hdr + 4),
                        (png_const_bytep )buf, (png_size_t )length);
        }
        __Cont: /* CIL Label */ 
        {
#line 1176
        tmp___3 = memcmp((void const   *)(chunk_hdr + 4), (void const   *)(sig_IEND),
                         (size_t )4);
        }
#line 1176
        if (! (tmp___3 != 0)) {
#line 1176
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1204
      err_msg = (char const   */* volatile  */)((void *)0);
#line 1166
      the_exception_context[0].caught = 0;
#line 1166
      if (! the_exception_context[0].caught) {
#line 1166
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1206
    the_exception_context[0].caught = 1;
  }
#line 1206
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1206
  if (! the_exception_context[0].caught) {
#line 1206
    tmp___5 = 1;
  } else {
#line 1206
    err_msg = the_exception_context[0].v.etmp;
#line 1206
    tmp___5 = 0;
  }
  {
#line 1210
  png_free((png_const_structrp )write_ptr, (png_voidp )buf);
#line 1211
  png_destroy_write_struct(& write_ptr, (png_infopp )((void *)0));
  }
#line 1213
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1214
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 1214
      the_exception_context[0].v.etmp = err_msg;
#line 1214
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1215
  return;
}
}
#line 1220 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_init_iteration(opng_bitset_t cmdline_set , opng_bitset_t mask_set ,
                                char const   *preset , opng_bitset_t *output_set ) 
{ 
  opng_bitset_t preset_set ;
  int check ;

  {
#line 1227
  *output_set = cmdline_set & mask_set;
#line 1228
  if (*output_set == 0U) {
#line 1228
    if (cmdline_set != 0U) {
      {
#line 1229
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1229
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Iteration parameter(s) out of range";
#line 1229
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1230
  if (*output_set == 0U) {
#line 1230
    goto _L;
  } else
#line 1230
  if (options.optim_level >= 0) {
    _L: /* CIL Label */ 
    {
#line 1232
    check = opng_strparse_rangeset_to_bitset(& preset_set, preset, mask_set);
    }
#line 1234
    if (! (check == 0)) {
      {
#line 1234
      (*usr_panic)("[internal] Invalid preset");
      }
    }
#line 1235
    *output_set |= preset_set & mask_set;
  }
#line 1237
  return;
}
}
#line 1242 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_init_iterations(void) 
{ 
  opng_bitset_t compr_level_set ;
  opng_bitset_t mem_level_set ;
  opng_bitset_t strategy_set ;
  opng_bitset_t filter_set ;
  opng_bitset_t strategy_singles_set ;
  int preset_index ;
  int t1 ;
  int t2 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1254
  if (process.status & 8192U) {
#line 1255
    process.max_idat_size = (opng_fsize_t )idat_size_max;
  } else
#line 1254
  if (options.full) {
#line 1255
    process.max_idat_size = (opng_fsize_t )idat_size_max;
  } else {
#line 1258
    if (! (process.in_idat_size > 0UL)) {
      {
#line 1258
      (*usr_panic)("No IDAT in input");
      }
    }
#line 1265
    process.max_idat_size = process.in_idat_size + (opng_fsize_t )process.in_plte_trns_size;
  }
#line 1273
  preset_index = options.optim_level;
#line 1274
  if (preset_index < 0) {
#line 1275
    preset_index = 2;
  } else
#line 1276
  if (preset_index > 7) {
#line 1277
    preset_index = 7;
  }
  {
#line 1282
  opng_init_iteration(options.compr_level_set, (opng_bitset_t )((1 << 10) - (1 << 1)),
                      (char const   *)presets[preset_index].compr_level, & compr_level_set);
#line 1284
  opng_init_iteration(options.mem_level_set, (opng_bitset_t )((1 << 10) - (1 << 1)),
                      (char const   *)presets[preset_index].mem_level, & mem_level_set);
#line 1286
  opng_init_iteration(options.strategy_set, (opng_bitset_t )((1 << 4) - 1), (char const   *)presets[preset_index].strategy,
                      & strategy_set);
#line 1288
  opng_init_iteration(options.filter_set, (opng_bitset_t )((1 << 6) - 1), (char const   *)presets[preset_index].filter,
                      & filter_set);
  }
#line 1292
  if (compr_level_set == 0U) {
#line 1293
    compr_level_set |= 1U << 9;
  }
#line 1294
  if (mem_level_set == 0U) {
#line 1295
    mem_level_set |= 1U << 8;
  }
#line 1296
  if (image.bit_depth < 8) {
#line 1296
    goto _L;
  } else
#line 1296
  if ((unsigned long )image.palette != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 1298
    if (strategy_set == 0U) {
#line 1299
      strategy_set |= 1U;
    }
#line 1300
    if (filter_set == 0U) {
#line 1301
      filter_set |= 1U;
    }
  } else {
#line 1305
    if (strategy_set == 0U) {
#line 1306
      strategy_set |= 1U << 1;
    }
#line 1307
    if (filter_set == 0U) {
#line 1308
      filter_set |= 1U << 5;
    }
  }
  {
#line 1312
  process.compr_level_set = compr_level_set;
#line 1313
  process.mem_level_set = mem_level_set;
#line 1314
  process.strategy_set = strategy_set;
#line 1315
  process.filter_set = filter_set;
#line 1316
  strategy_singles_set = (opng_bitset_t )((1 << 2) | (1 << 3));
#line 1317
  tmp = opng_bitset_count(compr_level_set);
#line 1317
  tmp___0 = opng_bitset_count(strategy_set & ~ strategy_singles_set);
#line 1317
  t1 = (int )(tmp * tmp___0);
#line 1319
  tmp___1 = opng_bitset_count(strategy_set & strategy_singles_set);
#line 1319
  t2 = (int )tmp___1;
#line 1320
  tmp___2 = opng_bitset_count(mem_level_set);
#line 1320
  tmp___3 = opng_bitset_count(filter_set);
#line 1320
  process.num_iterations = (int )(((unsigned int )(t1 + t2) * tmp___2) * tmp___3);
  }
#line 1323
  if (! (process.num_iterations > 0)) {
    {
#line 1323
    (*usr_panic)("Invalid iteration parameters");
    }
  }
#line 1324
  return;
}
}
#line 1329 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_iterate(void) 
{ 
  opng_bitset_t compr_level_set ;
  opng_bitset_t mem_level_set ;
  opng_bitset_t strategy_set ;
  opng_bitset_t filter_set ;
  int compr_level ;
  int mem_level ;
  int strategy ;
  int filter ;
  int counter ;
  int line_reused ;

  {
#line 1337
  if (! (process.num_iterations > 0)) {
    {
#line 1337
    (*usr_panic)("Iterations not initialized");
    }
  }
#line 1339
  compr_level_set = process.compr_level_set;
#line 1340
  mem_level_set = process.mem_level_set;
#line 1341
  strategy_set = process.strategy_set;
#line 1342
  filter_set = process.filter_set;
#line 1344
  if (process.num_iterations == 1) {
#line 1344
    if (process.status & 8192U) {
      {
#line 1348
      process.best_idat_size = (opng_fsize_t )0;
#line 1349
      process.best_compr_level = opng_bitset_find_first(compr_level_set);
#line 1350
      process.best_mem_level = opng_bitset_find_first(mem_level_set);
#line 1351
      process.best_strategy = opng_bitset_find_first(strategy_set);
#line 1352
      process.best_filter = opng_bitset_find_first(filter_set);
      }
#line 1353
      return;
    }
  }
  {
#line 1357
  process.best_idat_size = (opng_fsize_t )(idat_size_max + 1UL);
#line 1358
  process.best_compr_level = -1;
#line 1359
  process.best_mem_level = -1;
#line 1360
  process.best_strategy = -1;
#line 1361
  process.best_filter = -1;
#line 1364
  (*usr_printf)("\nTrying:\n");
#line 1365
  line_reused = 0;
#line 1366
  counter = 0;
#line 1367
  filter = 0;
  }
  {
#line 1367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1367
    if (! (filter <= 5)) {
#line 1367
      goto while_break;
    }
#line 1371
    if (! ((filter_set & (1U << filter)) != 0U)) {
#line 1372
      goto __Cont;
    }
#line 1373
    strategy = 0;
    {
#line 1373
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1373
      if (! (strategy <= 3)) {
#line 1373
        goto while_break___0;
      }
#line 1377
      if (! ((strategy_set & (1U << strategy)) != 0U)) {
#line 1378
        goto __Cont___0;
      }
#line 1379
      if (strategy == 2) {
#line 1385
        compr_level_set = (opng_bitset_t )0;
#line 1386
        compr_level_set |= 1U << 1;
      } else
#line 1388
      if (strategy == 3) {
#line 1394
        compr_level_set = (opng_bitset_t )0;
#line 1395
        compr_level_set |= 1U << 9;
      } else {
#line 1400
        compr_level_set = process.compr_level_set;
      }
#line 1402
      compr_level = 9;
      {
#line 1402
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1402
        if (! (compr_level >= 1)) {
#line 1402
          goto while_break___1;
        }
#line 1406
        if (! ((compr_level_set & (1U << compr_level)) != 0U)) {
#line 1407
          goto __Cont___1;
        }
#line 1408
        mem_level = 9;
        {
#line 1408
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1408
          if (! (mem_level >= 1)) {
#line 1408
            goto while_break___2;
          }
#line 1412
          if (! ((mem_level_set & (1U << mem_level)) != 0U)) {
#line 1413
            goto __Cont___2;
          }
          {
#line 1414
          (*usr_printf)("  zc = %d  zm = %d  zs = %d  f = %d", compr_level, mem_level,
                        strategy, filter);
#line 1416
          (*usr_progress)((unsigned long )counter, (unsigned long )process.num_iterations);
#line 1417
          counter ++;
#line 1418
          opng_write_file((FILE *)((void *)0), compr_level, mem_level, strategy, filter);
          }
#line 1420
          if (process.out_idat_size > (opng_fsize_t )idat_size_max) {
#line 1422
            if (options.verbose) {
              {
#line 1424
              (*usr_printf)("\t\tIDAT too big\n");
#line 1425
              line_reused = 0;
              }
            } else {
              {
#line 1429
              (*usr_print_cntrl)('\r');
#line 1430
              line_reused = 1;
              }
            }
#line 1432
            goto __Cont___2;
          }
          {
#line 1434
          (*usr_printf)("\t\tIDAT size = %lu\n", process.out_idat_size);
#line 1436
          line_reused = 0;
          }
#line 1437
          if (process.best_idat_size < process.out_idat_size) {
#line 1442
            goto __Cont___2;
          }
#line 1444
          if (process.best_idat_size == process.out_idat_size) {
#line 1444
            if (process.best_strategy == 2) {
#line 1452
              goto __Cont___2;
            } else
#line 1444
            if (process.best_strategy == 3) {
#line 1452
              goto __Cont___2;
            }
          }
#line 1454
          process.best_compr_level = compr_level;
#line 1455
          process.best_mem_level = mem_level;
#line 1456
          process.best_strategy = strategy;
#line 1457
          process.best_filter = filter;
#line 1458
          process.best_idat_size = process.out_idat_size;
#line 1459
          if (! options.full) {
#line 1460
            process.max_idat_size = process.out_idat_size;
          }
          __Cont___2: /* CIL Label */ 
#line 1408
          mem_level --;
        }
        while_break___2: /* CIL Label */ ;
        }
        __Cont___1: /* CIL Label */ 
#line 1402
        compr_level --;
      }
      while_break___1: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 1373
      strategy ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1367
    filter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1465
  if (line_reused) {
    {
#line 1466
    (*usr_print_cntrl)(-31);
    }
  }
#line 1468
  if (! (counter == process.num_iterations)) {
    {
#line 1468
    (*usr_panic)("Inconsistent iteration counter");
    }
  }
  {
#line 1470
  (*usr_progress)((unsigned long )counter, (unsigned long )process.num_iterations);
  }
#line 1471
  return;
}
}
#line 1476 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_finish_iterations(void) 
{ 


  {
#line 1479
  if (process.best_idat_size + (opng_fsize_t )process.out_plte_trns_size < process.in_idat_size + (opng_fsize_t )process.in_plte_trns_size) {
#line 1481
    process.status |= 8192U;
  }
#line 1482
  if (process.status & 8192U) {
#line 1484
    if (process.best_idat_size <= (opng_fsize_t )idat_size_max) {
      {
#line 1486
      (*usr_printf)("\nSelecting parameters:\n");
#line 1487
      (*usr_printf)("  zc = %d  zm = %d  zs = %d  f = %d", process.best_compr_level,
                    process.best_mem_level, process.best_strategy, process.best_filter);
      }
#line 1490
      if (process.best_idat_size > 0UL) {
        {
#line 1493
        (*usr_printf)("\t\tIDAT size = %lu", process.best_idat_size);
        }
      }
      {
#line 1496
      (*usr_printf)("\n");
      }
    } else {
      {
#line 1501
      (*usr_printf)("  zc = *  zm = *  zs = *  f = *\t\tIDAT size > %s\n", idat_size_max_string);
      }
    }
  }
#line 1505
  return;
}
}
#line 1513 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static FILE *infile  ;
#line 1513 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static FILE *outfile  ;
#line 1514 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static char const   *infile_name_local  ;
#line 1515 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static char const   *outfile_name  ;
#line 1515 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static char const   *bakfile_name  ;
#line 1516 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int new_outfile  ;
#line 1516 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static int has_backup  ;
#line 1510 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
static void opng_optimize_impl(char const   *infile_name ) 
{ 
  char name_buf[4096] ;
  char tmp_buf[4096] ;
  char const   * volatile  err_msg ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  int tmp ;
  char *tmp___0 ;
  char const   *tmp_name ;
  char *tmp___1 ;
  int test_eq ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  jmp_buf * volatile  exception__prev___0 ;
  jmp_buf exception__env___0 ;
  char const   *tmp___12 ;
  jmp_buf * volatile  exception__prev___1 ;
  jmp_buf exception__env___1 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;

  {
  {
#line 1520
  memset((void *)(& process), 0, sizeof(process));
  }
#line 1521
  if (options.force) {
#line 1522
    process.status |= 8192U;
  }
  {
#line 1524
  err_msg = (char const   */* volatile  */)((void *)0);
#line 1526
  infile_name_local = infile_name;
#line 1527
  infile = fopen((char const   */* __restrict  */)infile_name_local, (char const   */* __restrict  */)"rb");
  }
#line 1527
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
    {
#line 1528
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1528
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open the input file";
#line 1528
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1529
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1529
  the_exception_context[0].penv = & exception__env;
#line 1529
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1529
  if (tmp == 0) {
    {
#line 1529
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1531
      opng_read_file(infile);
#line 1529
      the_exception_context[0].caught = 0;
      }
#line 1529
      if (! the_exception_context[0].caught) {
#line 1529
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 1533
    the_exception_context[0].caught = 1;
  }
#line 1533
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1533
  if (! (! the_exception_context[0].caught)) {
#line 1533
    err_msg = the_exception_context[0].v.etmp;
#line 1535
    if (! ((unsigned long )err_msg != (unsigned long )((void *)0))) {
      {
#line 1535
      (*usr_panic)("Mysterious error in opng_read_file");
      }
    }
  }
  {
#line 1537
  fclose(infile);
  }
#line 1538
  if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
    {
#line 1539
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1539
      the_exception_context[0].v.etmp = err_msg;
#line 1539
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1542
  if (process.status & 256U) {
    {
#line 1544
    (*usr_printf)("Recoverable errors found in input.");
    }
#line 1545
    if (options.fix) {
      {
#line 1547
      (*usr_printf)(" Fixing...\n");
#line 1548
      process.status |= 4096U;
      }
    } else {
      {
#line 1552
      (*usr_printf)(" Rerun OptiPNG with -fix enabled.\n");
      }
      {
#line 1553
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1553
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Previous error(s) not fixed";
#line 1553
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
#line 1558
  if (process.status & 128U) {
#line 1559
    process.status |= 4096U;
  }
#line 1562
  if (! (process.status & 4U)) {
#line 1563
    process.status |= 4096U;
  }
#line 1564
  if (process.status & 2U) {
#line 1566
    if (options.nz) {
#line 1566
      if (process.status & 8192U) {
        {
#line 1568
        (*usr_printf)("IDAT recoding is necessary, but is disabled by the user.\n");
        }
        {
#line 1570
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1570
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t continue";
#line 1570
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
  } else {
#line 1574
    process.status |= 8192U;
  }
#line 1577
  if (process.status & 8U) {
    {
#line 1579
    (*usr_printf)("Digital signature found in input.");
    }
#line 1580
    if (options.force) {
      {
#line 1582
      (*usr_printf)(" Erasing...\n");
#line 1583
      process.status |= 4096U;
      }
    } else {
      {
#line 1587
      (*usr_printf)(" Rerun OptiPNG with -force enabled.\n");
      }
      {
#line 1588
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1588
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t optimize digitally-signed files";
#line 1588
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1593
  if (process.status & 16U) {
#line 1595
    if (! options.snip) {
#line 1595
      if (! (process.status & 1U)) {
        {
#line 1597
        (*usr_printf)("Conversion to PNG requires snipping. Rerun OptiPNG with -snip enabled.\n");
        }
        {
#line 1599
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 1599
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Incompatible input format";
#line 1599
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
  }
#line 1602
  if (process.status & 32U) {
#line 1602
    if (options.snip) {
#line 1603
      process.status |= 4096U;
    }
  }
#line 1606
  if (process.status & 64U) {
    {
#line 1607
    (*usr_printf)("Stripping metadata...\n");
    }
  }
#line 1610
  outfile_name = (char const   *)((void *)0);
#line 1611
  if (! (process.status & 1U)) {
    {
#line 1613
    tmp___0 = opng_path_replace_ext(name_buf, sizeof(name_buf), infile_name_local,
                                    ".png");
    }
#line 1613
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 1615
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 1615
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create the output file (name too long)";
#line 1615
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 1616
    outfile_name = (char const   *)(name_buf);
  }
#line 1618
  if ((unsigned long )options.out_name != (unsigned long )((void *)0)) {
#line 1619
    outfile_name = options.out_name;
  }
#line 1620
  if ((unsigned long )options.dir_name != (unsigned long )((void *)0)) {
#line 1623
    if ((unsigned long )outfile_name != (unsigned long )((void *)0)) {
      {
#line 1625
      strcpy((char */* __restrict  */)(tmp_buf), (char const   */* __restrict  */)outfile_name);
#line 1626
      tmp_name = (char const   *)(tmp_buf);
      }
    } else {
#line 1629
      tmp_name = infile_name_local;
    }
    {
#line 1630
    tmp___1 = opng_path_replace_dir(name_buf, sizeof(name_buf), tmp_name, options.dir_name);
    }
#line 1630
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 1632
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1632
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create the output file (name too long)";
#line 1632
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 1633
    outfile_name = (char const   *)(name_buf);
  }
#line 1635
  if ((unsigned long )outfile_name == (unsigned long )((void *)0)) {
#line 1637
    outfile_name = infile_name_local;
#line 1638
    new_outfile = 0;
  } else {
    {
#line 1642
    tmp___2 = opng_os_test_eq(infile_name_local, outfile_name);
#line 1642
    test_eq = tmp___2;
    }
#line 1643
    if (test_eq >= 0) {
#line 1644
      new_outfile = test_eq == 0;
    } else {
      {
#line 1650
      tmp___3 = strcmp(infile_name_local, outfile_name);
#line 1650
      new_outfile = tmp___3 != 0;
      }
    }
  }
#line 1655
  bakfile_name = (char const   *)(tmp_buf);
#line 1656
  if (new_outfile) {
    {
#line 1658
    tmp___4 = opng_path_make_backup(tmp_buf, sizeof(tmp_buf), outfile_name);
    }
#line 1658
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 1660
      bakfile_name = (char const   *)((void *)0);
    }
  } else {
    {
#line 1664
    tmp___5 = opng_path_make_backup(tmp_buf, sizeof(tmp_buf), infile_name_local);
    }
#line 1664
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 1666
      bakfile_name = (char const   *)((void *)0);
    }
  }
#line 1669
  if ((unsigned long )bakfile_name == (unsigned long )((void *)0)) {
    {
#line 1670
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 1670
      the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t create backup file (name too long)";
#line 1670
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 1672
  if (! options.simulate) {
    {
#line 1672
    tmp___8 = opng_os_test(outfile_name, "e");
    }
#line 1672
    if (tmp___8 == 0) {
#line 1674
      if (new_outfile) {
#line 1674
        if (! options.backup) {
#line 1674
          if (! options.clobber) {
            {
#line 1676
            (*usr_printf)("The output file exists. Rerun OptiPNG with -backup enabled.\n");
            }
            {
#line 1678
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 1678
              the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t overwrite the output file";
#line 1678
              longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                      1);
              }
            }
            while_break___9: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 1680
      tmp___6 = opng_os_test(outfile_name, "fw");
      }
#line 1680
      if (tmp___6 != 0) {
#line 1680
        goto _L;
      } else
#line 1680
      if (! options.clobber) {
        {
#line 1680
        tmp___7 = opng_os_test(bakfile_name, "e");
        }
#line 1680
        if (tmp___7 == 0) {
          _L: /* CIL Label */ 
          {
#line 1682
          while (1) {
            while_continue___10: /* CIL Label */ ;
            {
#line 1682
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the existing output file";
#line 1682
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___10: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 1686
  if (process.status & 2U) {
    {
#line 1687
    (*usr_printf)("Input IDAT size = %lu bytes\n", process.in_idat_size);
    }
  }
  {
#line 1689
  (*usr_printf)("Input file size = %lu bytes\n", process.in_file_size);
  }
#line 1693
  if (! options.nz) {
    {
#line 1695
    opng_init_iterations();
#line 1696
    opng_iterate();
#line 1697
    opng_finish_iterations();
    }
  } else
#line 1693
  if (process.status & 8192U) {
    {
#line 1695
    opng_init_iterations();
#line 1696
    opng_iterate();
#line 1697
    opng_finish_iterations();
    }
  }
#line 1699
  if (process.status & 8192U) {
    {
#line 1701
    process.status |= 4096U;
#line 1702
    opng_check_idat_size(process.best_idat_size);
    }
  }
#line 1706
  if (! (process.status & 4096U)) {
    {
#line 1708
    (*usr_printf)("\n%s is already optimized.\n", infile_name_local);
    }
#line 1709
    if (! new_outfile) {
#line 1710
      return;
    }
  }
#line 1712
  if (options.simulate) {
    {
#line 1714
    (*usr_printf)("\nNo output: simulation mode.\n");
    }
#line 1715
    return;
  }
#line 1719
  if (new_outfile) {
    {
#line 1721
    (*usr_printf)("\nOutput file: %s\n", outfile_name);
    }
#line 1722
    if ((unsigned long )options.dir_name != (unsigned long )((void *)0)) {
      {
#line 1723
      opng_os_create_dir(options.dir_name);
      }
    }
    {
#line 1724
    has_backup = 0;
#line 1725
    tmp___10 = opng_os_test(outfile_name, "e");
    }
#line 1725
    if (tmp___10 == 0) {
      {
#line 1727
      tmp___9 = opng_os_rename(outfile_name, bakfile_name, options.clobber);
      }
#line 1727
      if (tmp___9 != 0) {
        {
#line 1729
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 1729
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the output file";
#line 1729
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___11: /* CIL Label */ ;
        }
      }
#line 1730
      has_backup = 1;
    }
  } else {
    {
#line 1735
    tmp___11 = opng_os_rename(infile_name_local, bakfile_name, options.clobber);
    }
#line 1735
    if (tmp___11 != 0) {
      {
#line 1737
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1737
        the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t back up the input file";
#line 1737
        longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1738
    has_backup = 1;
  }
  {
#line 1741
  outfile = fopen((char const   */* __restrict  */)outfile_name, (char const   */* __restrict  */)"wb");
#line 1742
  exception__prev___0 = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1742
  the_exception_context[0].penv = & exception__env___0;
#line 1742
  tmp___15 = _setjmp((struct __jmp_buf_tag *)(exception__env___0));
  }
#line 1742
  if (tmp___15 == 0) {
    {
#line 1742
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1744
      if ((unsigned long )outfile == (unsigned long )((void *)0)) {
        {
#line 1745
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 1745
          the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t open the output file";
#line 1745
          longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
          }
        }
        while_break___14: /* CIL Label */ ;
        }
      }
#line 1746
      if (process.status & 8192U) {
        {
#line 1749
        opng_write_file(outfile, process.best_compr_level, process.best_mem_level,
                        process.best_strategy, process.best_filter);
        }
      } else {
#line 1756
        if (new_outfile) {
#line 1756
          tmp___12 = infile_name_local;
        } else {
#line 1756
          tmp___12 = bakfile_name;
        }
        {
#line 1756
        infile = fopen((char const   */* __restrict  */)tmp___12, (char const   */* __restrict  */)"rb");
        }
#line 1758
        if ((unsigned long )infile == (unsigned long )((void *)0)) {
          {
#line 1759
          while (1) {
            while_continue___15: /* CIL Label */ ;
            {
#line 1759
            the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t reopen the input file";
#line 1759
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___15: /* CIL Label */ ;
          }
        }
        {
#line 1760
        exception__prev___1 = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1760
        the_exception_context[0].penv = & exception__env___1;
#line 1760
        tmp___14 = _setjmp((struct __jmp_buf_tag *)(exception__env___1));
        }
#line 1760
        if (tmp___14 == 0) {
          {
#line 1760
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 1762
            if (process.in_datastream_offset > 0L) {
              {
#line 1762
              tmp___13 = opng_fseeko(infile, process.in_datastream_offset, 0);
              }
#line 1762
              if (tmp___13 != 0) {
                {
#line 1765
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  {
#line 1765
                  the_exception_context[0].v.etmp = (char const   */* volatile  */)"Can\'t reposition the input file";
#line 1765
                  longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)),
                          1);
                  }
                }
                while_break___17: /* CIL Label */ ;
                }
              }
            }
            {
#line 1766
            process.best_idat_size = process.in_idat_size;
#line 1767
            opng_copy_file(infile, outfile);
#line 1760
            the_exception_context[0].caught = 0;
            }
#line 1760
            if (! the_exception_context[0].caught) {
#line 1760
              goto while_break___16;
            }
          }
          while_break___16: /* CIL Label */ ;
          }
        } else {
#line 1769
          the_exception_context[0].caught = 1;
        }
#line 1769
        the_exception_context[0].penv = (jmp_buf *)exception__prev___1;
#line 1769
        if (! (! the_exception_context[0].caught)) {
#line 1769
          err_msg = the_exception_context[0].v.etmp;
#line 1771
          if (! ((unsigned long )err_msg != (unsigned long )((void *)0))) {
            {
#line 1771
            (*usr_panic)("Mysterious error in opng_copy_file");
            }
          }
        }
        {
#line 1774
        fclose(infile);
        }
#line 1775
        if ((unsigned long )err_msg != (unsigned long )((void *)0)) {
          {
#line 1776
          while (1) {
            while_continue___18: /* CIL Label */ ;
            {
#line 1776
            the_exception_context[0].v.etmp = err_msg;
#line 1776
            longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
            }
          }
          while_break___18: /* CIL Label */ ;
          }
        }
      }
#line 1742
      the_exception_context[0].caught = 0;
#line 1742
      if (! the_exception_context[0].caught) {
#line 1742
        goto while_break___13;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
  } else {
#line 1779
    the_exception_context[0].caught = 1;
  }
#line 1779
  the_exception_context[0].penv = (jmp_buf *)exception__prev___0;
#line 1779
  if (! (! the_exception_context[0].caught)) {
#line 1779
    err_msg = the_exception_context[0].v.etmp;
#line 1781
    if ((unsigned long )outfile != (unsigned long )((void *)0)) {
      {
#line 1782
      fclose(outfile);
      }
    }
#line 1784
    if (has_backup) {
#line 1786
      if (new_outfile) {
#line 1786
        tmp___16 = outfile_name;
      } else {
#line 1786
        tmp___16 = infile_name_local;
      }
      {
#line 1786
      tmp___17 = opng_os_rename(bakfile_name, tmp___16, 1);
      }
#line 1786
      if (tmp___17 != 0) {
        {
#line 1789
        opng_print_warning("Can\'t recover the original file from backup");
        }
      }
    } else {
#line 1794
      if (! new_outfile) {
        {
#line 1794
        (*usr_panic)("Overwrote input with no temporary backup");
        }
      }
      {
#line 1796
      tmp___18 = opng_os_unlink(outfile_name);
      }
#line 1796
      if (tmp___18 != 0) {
        {
#line 1797
        opng_print_warning("Can\'t remove the broken output file");
        }
      }
    }
    {
#line 1799
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 1799
      the_exception_context[0].v.etmp = err_msg;
#line 1799
      longjmp((struct __jmp_buf_tag *)(*(the_exception_context[0].penv)), 1);
      }
    }
    while_break___19: /* CIL Label */ ;
    }
  }
  {
#line 1802
  fclose(outfile);
  }
#line 1807
  if (options.preserve) {
#line 1808
    if (new_outfile) {
#line 1808
      tmp___19 = infile_name_local;
    } else {
#line 1808
      tmp___19 = bakfile_name;
    }
    {
#line 1808
    opng_os_copy_attr(tmp___19, outfile_name);
    }
  }
#line 1812
  if (! new_outfile) {
#line 1812
    if (! options.backup) {
      {
#line 1814
      tmp___20 = opng_os_unlink(bakfile_name);
      }
#line 1814
      if (tmp___20 != 0) {
        {
#line 1815
        opng_print_warning("Can\'t remove the backup file");
        }
      }
    }
  }
  {
#line 1819
  (*usr_printf)("\nOutput IDAT size = %lu bytes", process.out_idat_size);
  }
#line 1821
  if (process.status & 2U) {
    {
#line 1823
    (*usr_printf)(" (");
#line 1824
    opng_print_fsize_difference(process.in_idat_size, process.out_idat_size, 0);
#line 1826
    (*usr_printf)(")");
    }
  }
  {
#line 1828
  (*usr_printf)("\nOutput file size = %lu bytes (", process.out_file_size);
#line 1830
  opng_print_fsize_difference(process.in_file_size, process.out_file_size, 1);
#line 1832
  (*usr_printf)(")\n");
  }
#line 1833
  return;
}
}
#line 1838 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
int opng_initialize(struct opng_options  const  *init_options , struct opng_ui  const  *init_ui ) 
{ 


  {
#line 1843
  usr_printf = (void (*)(char const   *fmt  , ...))init_ui->printf_fn;
#line 1844
  usr_print_cntrl = (void (*)(int cntrl_code ))init_ui->print_cntrl_fn;
#line 1845
  usr_progress = (void (*)(unsigned long num , unsigned long denom ))init_ui->progress_fn;
#line 1846
  usr_panic = (void (*)(char const   *msg ))init_ui->panic_fn;
#line 1847
  if ((unsigned long )usr_printf == (unsigned long )((void *)0)) {
#line 1851
    return (-1);
  } else
#line 1847
  if ((unsigned long )usr_print_cntrl == (unsigned long )((void *)0)) {
#line 1851
    return (-1);
  } else
#line 1847
  if ((unsigned long )usr_progress == (unsigned long )((void *)0)) {
#line 1851
    return (-1);
  } else
#line 1847
  if ((unsigned long )usr_panic == (unsigned long )((void *)0)) {
#line 1851
    return (-1);
  }
#line 1854
  options = (struct opng_options )*init_options;
#line 1855
  if (options.optim_level == 0) {
#line 1857
    options.np = 1;
#line 1857
    options.nc = options.np;
#line 1857
    options.nb = options.nc;
#line 1858
    options.nz = 1;
  }
  {
#line 1862
  memset((void *)(& summary), 0, sizeof(summary));
#line 1863
  engine.started = 1;
  }
#line 1864
  return (0);
}
}
#line 1870 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
int opng_optimize(char const   *infile_name ) 
{ 
  char const   *err_msg ;
  int volatile   result ;
  jmp_buf * volatile  exception__prev ;
  jmp_buf exception__env ;
  int tmp ;

  {
#line 1876
  if (! engine.started) {
    {
#line 1876
    (*usr_panic)("The OptiPNG engine is not running");
    }
  }
  {
#line 1878
  (*usr_printf)("** Processing: %s\n", infile_name);
#line 1879
  (summary.file_count) ++;
#line 1880
  opng_clear_image_info();
#line 1881
  exception__prev = (jmp_buf */* volatile  */)the_exception_context[0].penv;
#line 1881
  the_exception_context[0].penv = & exception__env;
#line 1881
  tmp = _setjmp((struct __jmp_buf_tag *)(exception__env));
  }
#line 1881
  if (tmp == 0) {
    {
#line 1881
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1883
      opng_optimize_impl(infile_name);
      }
#line 1884
      if (process.status & 256U) {
#line 1886
        (summary.err_count) ++;
#line 1887
        (summary.fix_count) ++;
      }
#line 1889
      if (process.status & 16U) {
#line 1891
        if (options.snip) {
#line 1892
          (summary.snip_count) ++;
        }
      }
#line 1894
      result = (int volatile   )0;
#line 1881
      the_exception_context[0].caught = 0;
#line 1881
      if (! the_exception_context[0].caught) {
#line 1881
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1896
    the_exception_context[0].caught = 1;
  }
#line 1896
  the_exception_context[0].penv = (jmp_buf *)exception__prev;
#line 1896
  if (! (! the_exception_context[0].caught)) {
    {
#line 1896
    err_msg = (char const   *)the_exception_context[0].v.etmp;
#line 1898
    (summary.err_count) ++;
#line 1899
    opng_print_error(err_msg);
#line 1900
    result = (int volatile   )-1;
    }
  }
  {
#line 1902
  opng_destroy_image_info();
#line 1903
  (*usr_printf)("\n");
  }
#line 1904
  return ((int )result);
}
}
#line 1910 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optim.c"
int opng_finalize(void) 
{ 


  {
#line 1914
  if (options.verbose) {
#line 1914
    goto _L;
  } else
#line 1914
  if (summary.snip_count > 0U) {
#line 1914
    goto _L;
  } else
#line 1914
  if (summary.err_count > 0U) {
    _L: /* CIL Label */ 
    {
#line 1916
    (*usr_printf)("** Status report\n");
#line 1917
    (*usr_printf)("%u file(s) have been processed.\n", summary.file_count);
    }
#line 1918
    if (summary.snip_count > 0U) {
      {
#line 1920
      (*usr_printf)("%u multi-image file(s) have been snipped.\n", summary.snip_count);
      }
    }
#line 1923
    if (summary.err_count > 0U) {
      {
#line 1925
      (*usr_printf)("%u error(s) have been encountered.\n", summary.err_count);
      }
#line 1927
      if (summary.fix_count > 0U) {
        {
#line 1928
        (*usr_printf)("%u erroneous file(s) have been fixed.\n", summary.fix_count);
        }
      }
    }
  }
#line 1934
  engine.started = 0;
#line 1935
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 122
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 294
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 517
extern int fputc(int __c , FILE *__stream ) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 37 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char const   *msg_intro  =    "OptiPNG version 0.7.7\nCopyright (C) 2001-2017 Cosmin Truta and the Contributing Authors.\n";
#line 41 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char const   *msg_license  =    "This program is open-source software. See LICENSE for more details.\n\nPortions of this software are based in part on the work of:\n  Jean-loup Gailly and Mark Adler (zlib)\n  Glenn Randers-Pehrson and the PNG Development Group (libpng)\n  Miyasaka Masaru (BMP support)\n  David Koblas (GIF support)\n";
#line 50 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char const   *msg_help_synopsis  =    "Synopsis:\n    optipng [options] files ...\nFiles:\n    Image files of type: PNG, BMP, GIF, PNM or TIFF\n";
#line 56 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char const   *msg_help_basic_options  =    "Basic options:\n    -?, -h, -help\tshow the extended help\n    -o <level>\t\toptimization level (0-7)\t\t[default: 2]\n    -v\t\t\trun in verbose mode / show copyright and version info\n";
#line 62 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char const   *msg_help_options  =    "Basic options:\n    -?, -h, -help\tshow this help\n    -o <level>\t\toptimization level (0-7)\t\t[default: 2]\n    -v\t\t\trun in verbose mode / show copyright and version info\nGeneral options:\n    -backup, -keep\tkeep a backup of the modified files\n    -clobber\t\toverwrite existing files\n    -fix\t\tenable error recovery\n    -force\t\tenforce writing of a new output file\n    -preserve\t\tpreserve file attributes if possible\n    -quiet, -silent\trun in quiet mode\n    -simulate\t\trun in simulation mode\n    -out <file>\t\twrite output file to <file>\n    -dir <directory>\twrite output file(s) to <directory>\n    -log <file>\t\tlog messages to <file>\n    --\t\t\tstop option switch parsing\nOptimization options:\n    -f <filters>\tPNG delta filters (0-5)\t\t\t[default: 0,5]\n    -i <type>\t\tPNG interlace type (0-1)\n    -zc <levels>\tzlib compression levels (1-9)\t\t[default: 9]\n    -zm <levels>\tzlib memory levels (1-9)\t\t[default: 8]\n    -zs <strategies>\tzlib compression strategies (0-3)\t[default: 0-3]\n    -zw <size>\t\tzlib window size (256,512,1k,2k,4k,8k,16k,32k)\n    -full\t\tproduce a full report on IDAT (might reduce speed)\n    -nb\t\t\tno bit depth reduction\n    -nc\t\t\tno color type reduction\n    -np\t\t\tno palette reduction\n    -nx\t\t\tno reductions\n    -nz\t\t\tno IDAT recoding\nEditing options:\n    -snip\t\tcut one image out of multi-image or animation files\n    -strip <objects>\tstrip metadata objects (e.g. \"all\")\nOptimization levels:\n    -o0\t\t<=>\t-o1 -nx -nz\t\t\t\t(0 or 1 trials)\n    -o1\t\t<=>\t-zc9 -zm8 -zs0 -f0\t\t\t(1 trial)\n    \t\t(or...)\t-zc9 -zm8 -zs1 -f5\t\t\t(1 trial)\n    -o2\t\t<=>\t-zc9 -zm8 -zs0-3 -f0,5\t\t\t(8 trials)\n    -o3\t\t<=>\t-zc9 -zm8-9 -zs0-3 -f0,5\t\t(16 trials)\n    -o4\t\t<=>\t-zc9 -zm8 -zs0-3 -f0-5\t\t\t(24 trials)\n    -o5\t\t<=>\t-zc9 -zm8-9 -zs0-3 -f0-5\t\t(48 trials)\n    -o6\t\t<=>\t-zc1-9 -zm8 -zs0-3 -f0-5\t\t(120 trials)\n    -o7\t\t<=>\t-zc1-9 -zm8-9 -zs0-3 -f0-5\t\t(240 trials)\n    -o7 -zm1-9\t<=>\t-zc1-9 -zm1-9 -zs0-3 -f0-5\t\t(1080 trials)\nNotes:\n    The combination for -o1 is chosen heuristically.\n    Exhaustive combinations such as \"-o7 -zm1-9\" are not generally recommended.\n";
#line 113 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char const   *msg_help_examples  =    "Examples:\n    optipng file.png\t\t\t\t\t\t(default speed)\n    optipng -o5 file.png\t\t\t\t\t(slow)\n    optipng -o7 file.png\t\t\t\t\t(very slow)\n";
#line 119 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char const   *msg_help_more  =    "Type \"optipng -h\" for extended help.\n";
#line 123 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static enum __anonenum_operation_981116399 operation  ;
#line 130 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static struct __anonstruct_local_options_1029054173 local_options  ;
#line 136 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static struct opng_options options___0  ;
#line 138 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static FILE *con_file  ;
#line 139 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static FILE *log_file  ;
#line 141 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static int start_of_line  ;
#line 147 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void error(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;

  {
  {
#line 153
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"** Error: ");
#line 154
  __builtin_va_start(arg_ptr, fmt);
#line 155
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           arg_ptr);
#line 156
  __builtin_va_end(arg_ptr);
#line 157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 158
  exit(1);
  }
}
}
#line 164 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void panic(char const   *msg ) 
{ 


  {
  {
#line 168
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n** INTERNAL ERROR: %s\n",
          msg);
#line 169
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please submit a defect report.\nhttp://optipng.sourceforge.net/\n\n");
#line 170
  fflush(stderr);
  }
#line 171
  if (options___0.debug) {
    {
#line 174
    abort();
    }
  } else {
    {
#line 179
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The execution of this program has been terminated abnormally.\n");
#line 181
    exit(70);
    }
  }
}
}
#line 188 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static int opng_strcasecmp(char const   *str1 , char const   *str2 ) 
{ 
  int ch1 ;
  int ch2 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    tmp = str1;
#line 196
    str1 ++;
#line 196
    ch1 = tolower((int )*tmp);
#line 197
    tmp___0 = str2;
#line 197
    str2 ++;
#line 197
    ch2 = tolower((int )*tmp___0);
    }
#line 198
    if (ch1 != ch2) {
#line 199
      return (ch1 - ch2);
    }
#line 200
    if (ch1 == 0) {
#line 201
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 209 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char *opng_strltrim(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp = __ctype_b_loc();
    }
#line 213
    if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 213
      goto while_break;
    }
#line 214
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return ((char *)str);
}
}
#line 221 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char *opng_strtail(char const   *str , size_t num ) 
{ 
  size_t len ;

  {
  {
#line 227
  len = strlen(str);
  }
#line 228
  if (len <= num) {
#line 229
    return ((char *)str);
  }
#line 230
  return (((char *)str + len) - num);
}
}
#line 236 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static char *opng_strpbrk_digit(char const   *str ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if ((int const   )*str == 0) {
#line 242
      return ((char *)((void *)0));
    }
    {
#line 243
    tmp = __ctype_b_loc();
    }
#line 243
    if ((int const   )*(*tmp + (int )*str) & 2048) {
#line 244
      return ((char *)str);
    }
#line 245
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 252 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static int opng_str2ulong(unsigned long *out_val , char const   *in_str , int allow_multiplier ) 
{ 
  char const   *begin_ptr ;
  char *end_ptr ;
  unsigned long multiplier ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 262
  end_ptr = opng_strltrim(in_str);
#line 262
  begin_ptr = (char const   *)end_ptr;
  }
#line 263
  if ((int const   )*begin_ptr >= 48) {
#line 263
    if ((int const   )*begin_ptr <= 57) {
      {
#line 264
      *out_val = strtoul((char const   */* __restrict  */)begin_ptr, (char **/* __restrict  */)(& end_ptr),
                         10);
      }
    }
  }
#line 265
  if ((unsigned long )begin_ptr == (unsigned long )end_ptr) {
    {
#line 267
    tmp = __errno_location();
#line 267
    *tmp = 22;
#line 268
    *out_val = 0UL;
    }
#line 269
    return (-1);
  }
#line 272
  if (allow_multiplier) {
#line 279
    if ((int )*end_ptr == 107) {
#line 281
      end_ptr ++;
#line 282
      multiplier = 1024UL;
    } else
#line 279
    if ((int )*end_ptr == 75) {
#line 281
      end_ptr ++;
#line 282
      multiplier = 1024UL;
    } else
#line 284
    if ((int )*end_ptr == 77) {
#line 286
      end_ptr ++;
#line 287
      multiplier = 1048576UL;
    } else
#line 289
    if ((int )*end_ptr == 71) {
#line 291
      end_ptr ++;
#line 292
      multiplier = 1073741824UL;
    } else {
#line 295
      multiplier = 1UL;
    }
#line 296
    if (multiplier > 1UL) {
#line 298
      if (*out_val > 0xffffffffffffffffUL / multiplier) {
        {
#line 300
        tmp___0 = __errno_location();
#line 300
        *tmp___0 = 34;
#line 301
        *out_val = 0xffffffffffffffffUL;
        }
      } else {
#line 304
        *out_val *= multiplier;
      }
    }
  }
  {
#line 309
  tmp___2 = opng_strltrim((char const   *)end_ptr);
  }
#line 309
  if ((int )*tmp___2 != 0) {
    {
#line 311
    tmp___1 = __errno_location();
#line 311
    *tmp___1 = 22;
    }
#line 312
    return (-1);
  }
#line 314
  return (0);
}
}
#line 320 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void err_option_arg(char const   *opt , char const   *opt_arg ) 
{ 
  char *tmp ;

  {
#line 324
  if ((unsigned long )opt_arg == (unsigned long )((void *)0)) {
    {
#line 325
    error("Missing argument for option %s", opt);
    }
  } else {
    {
#line 324
    tmp = opng_strltrim(opt_arg);
    }
#line 324
    if ((int )*tmp == 0) {
      {
#line 325
      error("Missing argument for option %s", opt);
      }
    } else {
      {
#line 327
      error("Invalid argument for option %s: %s", opt, opt_arg);
      }
    }
  }
#line 328
  return;
}
}
#line 333 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static int check_num_option(char const   *opt , char const   *opt_arg , int lowest ,
                            int highest ) 
{ 
  unsigned long value ;
  int tmp ;

  {
  {
#line 340
  tmp = opng_str2ulong(& value, opt_arg, 0);
  }
#line 340
  if (tmp != 0) {
    {
#line 342
    err_option_arg(opt, opt_arg);
    }
  } else
#line 340
  if (value > 2147483647UL) {
    {
#line 342
    err_option_arg(opt, opt_arg);
    }
  } else
#line 340
  if ((int )value < lowest) {
    {
#line 342
    err_option_arg(opt, opt_arg);
    }
  } else
#line 340
  if ((int )value > highest) {
    {
#line 342
    err_option_arg(opt, opt_arg);
    }
  }
#line 343
  return ((int )value);
}
}
#line 349 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static int check_power2_option(char const   *opt , char const   *opt_arg , int lowest ,
                               int highest ) 
{ 
  unsigned long value ;
  int result ;
  int tmp ;

  {
  {
#line 358
  tmp = opng_str2ulong(& value, opt_arg, 1);
  }
#line 358
  if (tmp == 0) {
#line 360
    if (lowest < 0) {
#line 361
      lowest = 0;
    }
#line 362
    if (highest > (int )(8UL * sizeof(long ) - 2UL)) {
#line 363
      highest = (int )(8UL * sizeof(long ) - 2UL);
    }
#line 364
    result = lowest;
    {
#line 364
    while (1) {
      while_continue: /* CIL Label */ ;
#line 364
      if (! (result <= highest)) {
#line 364
        goto while_break;
      }
#line 366
      if (1UL << result == value) {
#line 367
        return (result);
      }
#line 364
      result ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 370
  err_option_arg(opt, opt_arg);
  }
#line 371
  return (-1);
}
}
#line 377 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static opng_bitset_t check_rangeset_option(char const   *opt , char const   *opt_arg ,
                                           opng_bitset_t result_mask ) 
{ 
  opng_bitset_t result ;
  int tmp ;

  {
  {
#line 386
  tmp = opng_strparse_rangeset_to_bitset(& result, opt_arg, result_mask);
  }
#line 386
  if (tmp != 0) {
#line 387
    result = 0U;
  }
#line 388
  if ((result & result_mask) != result) {
#line 389
    result = 0U;
  }
#line 390
  if (result == 0U) {
    {
#line 391
    err_option_arg(opt, opt_arg);
    }
  }
#line 392
  return (result);
}
}
#line 398 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void check_obj_option(char const   *opt , char const   *opt_arg ) 
{ 
  unsigned int i ;
  int tmp ;

  {
  {
#line 403
  tmp = strcmp("all", opt_arg);
  }
#line 403
  if (tmp == 0) {
#line 404
    return;
  }
#line 408
  i = 0U;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (i < 4U)) {
#line 408
      goto while_break;
    }
#line 411
    if ((int const   )*(opt_arg + i) >= 65) {
#line 411
      if (! ((int const   )*(opt_arg + i) <= 90)) {
#line 411
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 411
    if ((int const   )*(opt_arg + i) >= 97) {
#line 411
      if (! ((int const   )*(opt_arg + i) <= 122)) {
#line 413
        goto while_break;
      }
    } else {
#line 413
      goto while_break;
    }
#line 408
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  if (i == 4U) {
#line 415
    if ((int const   )*(opt_arg + i) == 0) {
      {
#line 416
      error("Manipulation of individual chunks is not implemented");
      }
    } else {
      {
#line 418
      err_option_arg(opt, opt_arg);
      }
    }
  } else {
    {
#line 418
    err_option_arg(opt, opt_arg);
    }
  }
#line 419
  return;
}
}
#line 424 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static int scan_option(char const   *str , char *opt_buf , size_t opt_buf_size , char const   **opt_arg_ptr ) 
{ 
  char const   *ptr ;
  unsigned int opt_len ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 432
  if ((int const   )*(str + 0) != 45) {
#line 433
    return (0);
  } else
#line 432
  if ((int const   )*(str + 1) == 0) {
#line 433
    return (0);
  }
#line 436
  opt_len = 0U;
#line 437
  ptr = str + 1;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! ((int const   )*ptr == 45)) {
#line 438
      goto while_break;
    }
#line 439
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 440
  if ((int const   )*ptr == 0) {
#line 441
    ptr --;
  }
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 444
    if ((size_t )opt_len < opt_buf_size) {
      {
#line 445
      tmp = tolower((int )*ptr);
#line 445
      *(opt_buf + opt_len) = (char )tmp;
      }
    }
#line 446
    opt_len ++;
#line 447
    ptr ++;
#line 448
    if ((int const   )*ptr == 0) {
#line 448
      goto _L;
    } else {
      {
#line 448
      tmp___1 = __ctype_b_loc();
      }
#line 448
      if ((int const   )*(*tmp___1 + (int )*ptr) & 8192) {
        _L: /* CIL Label */ 
        {
#line 450
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 450
          tmp___0 = __ctype_b_loc();
          }
#line 450
          if (! ((int const   )*(*tmp___0 + (int )*ptr) & 8192)) {
#line 450
            goto while_break___1;
          }
#line 451
          ptr ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 452
        if ((int const   )*ptr != 0) {
#line 452
          *opt_arg_ptr = ptr;
        } else {
#line 452
          *opt_arg_ptr = (char const   *)((void *)0);
        }
#line 453
        goto while_break___0;
      }
    }
#line 455
    if ((int const   )*ptr == 61) {
#line 457
      ptr ++;
#line 458
      *opt_arg_ptr = ptr;
#line 459
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 464
  if (opt_buf_size > 0UL) {
#line 466
    if ((size_t )opt_len < opt_buf_size) {
#line 467
      *(opt_buf + opt_len) = (char )'\000';
    } else {
#line 469
      *(opt_buf + (opt_buf_size - 1UL)) = (char )'\000';
    }
  }
#line 471
  return (1);
}
}
#line 477 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void parse_args(int argc , char **argv ) 
{ 
  char *arg ;
  char opt[16] ;
  size_t opt_len ;
  char const   *xopt ;
  int simple_opt ;
  int stop_switch ;
  opng_bitset_t set ;
  int val ;
  unsigned int file_count ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;

  {
  {
#line 491
  memset((void *)(& options___0), 0, sizeof(options___0));
#line 492
  options___0.optim_level = -1;
#line 493
  options___0.interlace = -1;
#line 494
  file_count = 0U;
#line 497
  stop_switch = 0;
#line 498
  i = 1;
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (! (i < argc)) {
#line 498
      goto while_break;
    }
#line 500
    arg = *(argv + i);
#line 501
    if (stop_switch) {
#line 503
      file_count ++;
#line 504
      goto __Cont;
    } else {
      {
#line 501
      tmp = scan_option((char const   *)arg, opt, sizeof(opt), & xopt);
      }
#line 501
      if (tmp < 1) {
#line 503
        file_count ++;
#line 504
        goto __Cont;
      }
    }
    {
#line 506
    opt_len = strlen((char const   *)(opt));
#line 509
    *(argv + i) = (char *)((void *)0);
#line 512
    tmp___2 = strchr("fio", (int )opt[0]);
    }
#line 512
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      {
#line 512
      tmp___3 = __ctype_b_loc();
      }
#line 512
      if ((int const   )*(*tmp___3 + (int )opt[1]) & 2048) {
        {
#line 518
        tmp___0 = opng_strpbrk_digit((char const   *)(opt));
#line 518
        opt_len = (size_t )(tmp___0 - opt);
#line 519
        opt[opt_len] = (char )'\000';
#line 520
        tmp___1 = opng_strpbrk_digit((char const   *)arg);
#line 520
        xopt = (char const   *)tmp___1;
        }
      } else {
#line 512
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 512
    if ((int )opt[0] == 122) {
      {
#line 512
      tmp___4 = __ctype_b_loc();
      }
#line 512
      if ((int const   )*(*tmp___4 + (int )opt[1]) & 1024) {
        {
#line 512
        tmp___5 = __ctype_b_loc();
        }
#line 512
        if ((int const   )*(*tmp___5 + (int )opt[2]) & 2048) {
          {
#line 518
          tmp___0 = opng_strpbrk_digit((char const   *)(opt));
#line 518
          opt_len = (size_t )(tmp___0 - opt);
#line 519
          opt[opt_len] = (char )'\000';
#line 520
          tmp___1 = opng_strpbrk_digit((char const   *)arg);
#line 520
          xopt = (char const   *)tmp___1;
          }
        }
      }
    }
    {
#line 524
    simple_opt = 1;
#line 525
    tmp___28 = strcmp("-", (char const   *)(opt));
    }
#line 525
    if (tmp___28 == 0) {
#line 528
      stop_switch = 1;
    } else {
      {
#line 530
      tmp___26 = strcmp("?", (char const   *)(opt));
      }
#line 530
      if (tmp___26 == 0) {
#line 534
        local_options.help = 1;
      } else {
        {
#line 530
        tmp___27 = strncmp("help", (char const   *)(opt), opt_len);
        }
#line 530
        if (tmp___27 == 0) {
#line 534
          local_options.help = 1;
        } else {
          {
#line 536
          tmp___24 = strncmp("backup", (char const   *)(opt), opt_len);
          }
#line 536
          if (tmp___24 == 0) {
#line 540
            options___0.backup = 1;
          } else {
            {
#line 536
            tmp___25 = strncmp("keep", (char const   *)(opt), opt_len);
            }
#line 536
            if (tmp___25 == 0) {
#line 540
              options___0.backup = 1;
            } else {
              {
#line 542
              tmp___23 = strncmp("clobber", (char const   *)(opt), opt_len);
              }
#line 542
              if (tmp___23 == 0) {
#line 545
                options___0.clobber = 1;
              } else {
                {
#line 547
                tmp___22 = strcmp("debug", (char const   *)(opt));
                }
#line 547
                if (tmp___22 == 0) {
#line 551
                  options___0.debug = 1;
                } else {
                  {
#line 553
                  tmp___21 = strncmp("fix", (char const   *)(opt), opt_len);
                  }
#line 553
                  if (tmp___21 == 0) {
#line 553
                    if (opt_len >= 2UL) {
#line 556
                      options___0.fix = 1;
                    } else {
#line 553
                      goto _L___7;
                    }
                  } else {
                    _L___7: /* CIL Label */ 
                    {
#line 558
                    tmp___20 = strncmp("force", (char const   *)(opt), opt_len);
                    }
#line 558
                    if (tmp___20 == 0) {
#line 558
                      if (opt_len >= 2UL) {
#line 561
                        options___0.force = 1;
                      } else {
#line 558
                        goto _L___6;
                      }
                    } else {
                      _L___6: /* CIL Label */ 
                      {
#line 563
                      tmp___19 = strncmp("full", (char const   *)(opt), opt_len);
                      }
#line 563
                      if (tmp___19 == 0) {
#line 563
                        if (opt_len >= 2UL) {
#line 566
                          options___0.full = 1;
                        } else {
#line 563
                          goto _L___5;
                        }
                      } else {
                        _L___5: /* CIL Label */ 
                        {
#line 568
                        tmp___18 = strcmp("nb", (char const   *)(opt));
                        }
#line 568
                        if (tmp___18 == 0) {
#line 571
                          options___0.nb = 1;
                        } else {
                          {
#line 573
                          tmp___17 = strcmp("nc", (char const   *)(opt));
                          }
#line 573
                          if (tmp___17 == 0) {
#line 576
                            options___0.nc = 1;
                          } else {
                            {
#line 578
                            tmp___16 = strcmp("np", (char const   *)(opt));
                            }
#line 578
                            if (tmp___16 == 0) {
#line 581
                              options___0.np = 1;
                            } else {
                              {
#line 583
                              tmp___15 = strcmp("nx", (char const   *)(opt));
                              }
#line 583
                              if (tmp___15 == 0) {
#line 586
                                options___0.np = 1;
#line 586
                                options___0.nc = options___0.np;
#line 586
                                options___0.nb = options___0.nc;
                              } else {
                                {
#line 589
                                tmp___14 = strcmp("nz", (char const   *)(opt));
                                }
#line 589
                                if (tmp___14 == 0) {
#line 592
                                  options___0.nz = 1;
                                } else {
                                  {
#line 594
                                  tmp___13 = strncmp("preserve", (char const   *)(opt),
                                                     opt_len);
                                  }
#line 594
                                  if (tmp___13 == 0) {
#line 597
                                    options___0.preserve = 1;
                                  } else {
                                    {
#line 599
                                    tmp___11 = strncmp("quiet", (char const   *)(opt),
                                                       opt_len);
                                    }
#line 599
                                    if (tmp___11 == 0) {
#line 603
                                      options___0.quiet = 1;
                                    } else {
                                      {
#line 599
                                      tmp___12 = strncmp("silent", (char const   *)(opt),
                                                         opt_len);
                                      }
#line 599
                                      if (tmp___12 == 0) {
#line 599
                                        if (opt_len >= 3UL) {
#line 603
                                          options___0.quiet = 1;
                                        } else {
#line 599
                                          goto _L___4;
                                        }
                                      } else {
                                        _L___4: /* CIL Label */ 
                                        {
#line 605
                                        tmp___10 = strncmp("simulate", (char const   *)(opt),
                                                           opt_len);
                                        }
#line 605
                                        if (tmp___10 == 0) {
#line 605
                                          if (opt_len >= 3UL) {
#line 608
                                            options___0.simulate = 1;
                                          } else {
#line 605
                                            goto _L___3;
                                          }
                                        } else {
                                          _L___3: /* CIL Label */ 
                                          {
#line 610
                                          tmp___9 = strncmp("snip", (char const   *)(opt),
                                                            opt_len);
                                          }
#line 610
                                          if (tmp___9 == 0) {
#line 610
                                            if (opt_len >= 2UL) {
#line 613
                                              options___0.snip = 1;
                                            } else {
#line 610
                                              goto _L___2;
                                            }
                                          } else {
                                            _L___2: /* CIL Label */ 
                                            {
#line 615
                                            tmp___8 = strcmp("v", (char const   *)(opt));
                                            }
#line 615
                                            if (tmp___8 == 0) {
#line 618
                                              options___0.verbose = 1;
#line 619
                                              local_options.version = 1;
                                            } else {
                                              {
#line 621
                                              tmp___7 = strncmp("verbose", (char const   *)(opt),
                                                                opt_len);
                                              }
#line 621
                                              if (tmp___7 == 0) {
#line 621
                                                if (opt_len >= 4UL) {
#line 624
                                                  options___0.verbose = 1;
                                                } else {
#line 621
                                                  goto _L___1;
                                                }
                                              } else {
                                                _L___1: /* CIL Label */ 
                                                {
#line 626
                                                tmp___6 = strncmp("version", (char const   *)(opt),
                                                                  opt_len);
                                                }
#line 626
                                                if (tmp___6 == 0) {
#line 626
                                                  if (opt_len >= 4UL) {
#line 629
                                                    local_options.version = 1;
                                                  } else {
#line 626
                                                    goto _L___0;
                                                  }
                                                } else {
                                                  _L___0: /* CIL Label */ 
#line 633
                                                  simple_opt = 0;
#line 634
                                                  if ((unsigned long )xopt == (unsigned long )((void *)0)) {
#line 636
                                                    i ++;
#line 636
                                                    if (i < argc) {
#line 638
                                                      xopt = (char const   *)*(argv + i);
#line 640
                                                      *(argv + i) = (char *)((void *)0);
                                                    } else {
#line 645
                                                      xopt = "";
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 651
    if (simple_opt) {
#line 653
      if ((unsigned long )xopt != (unsigned long )((void *)0)) {
        {
#line 654
        error("No argument allowed for option: %s", arg);
        }
      }
    } else {
      {
#line 656
      tmp___39 = strcmp("o", (char const   *)(opt));
      }
#line 656
      if (tmp___39 == 0) {
        {
#line 659
        val = check_num_option("-o", xopt, 0, 2147483647);
        }
#line 660
        if (options___0.optim_level < 0) {
#line 661
          options___0.optim_level = val;
        } else
#line 662
        if (options___0.optim_level != val) {
          {
#line 663
          error("Multiple optimization levels are not permitted");
          }
        }
      } else {
        {
#line 665
        tmp___38 = strcmp("i", (char const   *)(opt));
        }
#line 665
        if (tmp___38 == 0) {
          {
#line 668
          val = check_num_option("-i", xopt, 0, 1);
          }
#line 669
          if (options___0.interlace < 0) {
#line 670
            options___0.interlace = val;
          } else
#line 671
          if (options___0.interlace != val) {
            {
#line 672
            error("Multiple interlace types are not permitted");
            }
          }
        } else {
          {
#line 674
          tmp___37 = strcmp("f", (char const   *)(opt));
          }
#line 674
          if (tmp___37 == 0) {
            {
#line 677
            set = check_rangeset_option("-f", xopt, (opng_bitset_t )((1 << 6) - 1));
#line 678
            options___0.filter_set |= set;
            }
          } else {
            {
#line 680
            tmp___36 = strcmp("zc", (char const   *)(opt));
            }
#line 680
            if (tmp___36 == 0) {
              {
#line 683
              set = check_rangeset_option("-zc", xopt, (opng_bitset_t )((1 << 10) - (1 << 1)));
#line 684
              options___0.compr_level_set |= set;
              }
            } else {
              {
#line 686
              tmp___35 = strcmp("zm", (char const   *)(opt));
              }
#line 686
              if (tmp___35 == 0) {
                {
#line 689
                set = check_rangeset_option("-zm", xopt, (opng_bitset_t )((1 << 10) - (1 << 1)));
#line 690
                options___0.mem_level_set |= set;
                }
              } else {
                {
#line 692
                tmp___34 = strcmp("zs", (char const   *)(opt));
                }
#line 692
                if (tmp___34 == 0) {
                  {
#line 695
                  set = check_rangeset_option("-zs", xopt, (opng_bitset_t )((1 << 4) - 1));
#line 696
                  options___0.strategy_set |= set;
                  }
                } else {
                  {
#line 698
                  tmp___33 = strcmp("zw", (char const   *)(opt));
                  }
#line 698
                  if (tmp___33 == 0) {
                    {
#line 701
                    val = check_power2_option("-zw", xopt, 8, 15);
                    }
#line 702
                    if (options___0.window_bits == 0) {
#line 703
                      options___0.window_bits = val;
                    } else
#line 704
                    if (options___0.window_bits != val) {
                      {
#line 705
                      error("Multiple window sizes are not permitted");
                      }
                    }
                  } else {
                    {
#line 707
                    tmp___32 = strncmp("strip", (char const   *)(opt), opt_len);
                    }
#line 707
                    if (tmp___32 == 0) {
#line 707
                      if (opt_len >= 2UL) {
                        {
#line 710
                        check_obj_option("-strip", xopt);
#line 711
                        options___0.strip_all = 1;
                        }
                      } else {
#line 707
                        goto _L___9;
                      }
                    } else {
                      _L___9: /* CIL Label */ 
                      {
#line 713
                      tmp___31 = strncmp("out", (char const   *)(opt), opt_len);
                      }
#line 713
                      if (tmp___31 == 0) {
#line 713
                        if (opt_len >= 2UL) {
#line 716
                          if ((unsigned long )options___0.out_name != (unsigned long )((void *)0)) {
                            {
#line 717
                            error("Multiple output file names are not permitted");
                            }
                          }
#line 718
                          if ((int const   )*(xopt + 0) == 0) {
                            {
#line 719
                            err_option_arg("-out", (char const   *)((void *)0));
                            }
                          }
#line 720
                          options___0.out_name = xopt;
                        } else {
#line 713
                          goto _L___8;
                        }
                      } else {
                        _L___8: /* CIL Label */ 
                        {
#line 722
                        tmp___30 = strncmp("dir", (char const   *)(opt), opt_len);
                        }
#line 722
                        if (tmp___30 == 0) {
#line 725
                          if ((unsigned long )options___0.dir_name != (unsigned long )((void *)0)) {
                            {
#line 726
                            error("Multiple output dir names are not permitted");
                            }
                          }
#line 727
                          if ((int const   )*(xopt + 0) == 0) {
                            {
#line 728
                            err_option_arg("-dir", (char const   *)((void *)0));
                            }
                          }
#line 729
                          options___0.dir_name = xopt;
                        } else {
                          {
#line 731
                          tmp___29 = strncmp("log", (char const   *)(opt), opt_len);
                          }
#line 731
                          if (tmp___29 == 0) {
#line 734
                            if ((unsigned long )options___0.log_name != (unsigned long )((void *)0)) {
                              {
#line 735
                              error("Multiple log file names are not permitted");
                              }
                            }
#line 736
                            if ((int const   )*(xopt + 0) == 0) {
                              {
#line 737
                              err_option_arg("-log", (char const   *)((void *)0));
                              }
                            }
#line 738
                            options___0.log_name = xopt;
                          } else {
                            {
#line 742
                            error("Unrecognized option: %s", arg);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 498
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 747
  if ((unsigned long )options___0.out_name != (unsigned long )((void *)0)) {
#line 749
    if (file_count > 1U) {
      {
#line 750
      error("The option -out requires one input file");
      }
    }
#line 751
    if ((unsigned long )options___0.dir_name != (unsigned long )((void *)0)) {
      {
#line 752
      error("The options -out and -dir are mutually exclusive");
      }
    }
  }
#line 754
  if ((unsigned long )options___0.log_name != (unsigned long )((void *)0)) {
    {
#line 756
    tmp___40 = opng_strtail(options___0.log_name, (size_t )4);
#line 756
    tmp___41 = opng_strcasecmp(".log", (char const   *)tmp___40);
    }
#line 756
    if (tmp___41 != 0) {
      {
#line 757
      error("To prevent accidental data corruption, the log file name must end with \".log\"");
      }
    }
  }
#line 760
  if (local_options.help) {
#line 761
    operation = (enum __anonenum_operation_981116399 )1;
  } else
#line 762
  if (file_count != 0U) {
#line 763
    operation = (enum __anonenum_operation_981116399 )0;
  } else
#line 764
  if (local_options.version) {
#line 765
    operation = (enum __anonenum_operation_981116399 )2;
  } else {
#line 767
    operation = (enum __anonenum_operation_981116399 )1;
  }
#line 768
  return;
}
}
#line 773 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void app_printf(char const   *fmt  , ...) 
{ 
  va_list arg_ptr ;
  size_t tmp___0 ;

  {
#line 778
  if ((int const   )*(fmt + 0) == 0) {
#line 779
    return;
  }
  {
#line 780
  tmp___0 = strlen(fmt);
  }
#line 780
  if ((int const   )*(fmt + (tmp___0 - 1UL)) == 10) {
#line 780
    start_of_line = 1;
  } else {
#line 780
    start_of_line = 0;
  }
#line 782
  if ((unsigned long )con_file != (unsigned long )((void *)0)) {
    {
#line 784
    __builtin_va_start(arg_ptr, fmt);
#line 785
    vfprintf((FILE */* __restrict  */)con_file, (char const   */* __restrict  */)fmt,
             arg_ptr);
#line 786
    __builtin_va_end(arg_ptr);
    }
  }
#line 788
  if ((unsigned long )log_file != (unsigned long )((void *)0)) {
    {
#line 790
    __builtin_va_start(arg_ptr, fmt);
#line 791
    vfprintf((FILE */* __restrict  */)log_file, (char const   */* __restrict  */)fmt,
             arg_ptr);
#line 792
    __builtin_va_end(arg_ptr);
    }
  }
#line 794
  return;
}
}
#line 799 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void app_print_cntrl(int cntrl_code ) 
{ 
  char const   *con_str ;
  char const   *log_str ;
  int i ;

  {
#line 805
  if (cntrl_code == 13) {
#line 808
    con_str = "\r";
#line 809
    log_str = "\n";
#line 810
    start_of_line = 1;
  } else
#line 812
  if (cntrl_code == 11) {
#line 815
    if (! start_of_line) {
#line 817
      log_str = "\n";
#line 817
      con_str = log_str;
#line 818
      start_of_line = 1;
    } else {
#line 821
      log_str = "";
#line 821
      con_str = log_str;
    }
  } else
#line 823
  if (cntrl_code < 0) {
#line 823
    if (cntrl_code > -80) {
#line 823
      if (start_of_line) {
#line 826
        if ((unsigned long )con_file != (unsigned long )((void *)0)) {
#line 828
          i = 0;
          {
#line 828
          while (1) {
            while_continue: /* CIL Label */ ;
#line 828
            if (! (i > cntrl_code)) {
#line 828
              goto while_break;
            }
            {
#line 829
            fputc(' ', con_file);
#line 828
            i --;
            }
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 831
        con_str = "\r";
#line 832
        log_str = "";
      } else {
#line 837
        log_str = "<?>";
#line 837
        con_str = log_str;
      }
    } else {
#line 837
      log_str = "<?>";
#line 837
      con_str = log_str;
    }
  } else {
#line 837
    log_str = "<?>";
#line 837
    con_str = log_str;
  }
#line 840
  if ((unsigned long )con_file != (unsigned long )((void *)0)) {
    {
#line 841
    fputs((char const   */* __restrict  */)con_str, (FILE */* __restrict  */)con_file);
    }
  }
#line 842
  if ((unsigned long )log_file != (unsigned long )((void *)0)) {
    {
#line 843
    fputs((char const   */* __restrict  */)log_str, (FILE */* __restrict  */)log_file);
    }
  }
#line 844
  return;
}
}
#line 849 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void app_progress(unsigned long current_step , unsigned long total_steps ) 
{ 


  {
#line 853
  if ((unsigned long )con_file != (unsigned long )((void *)0)) {
    {
#line 854
    fflush(con_file);
    }
  }
#line 859
  if (current_step) {
#line 859
    if (total_steps) {
#line 860
      return;
    }
  }
#line 861
  return;
}
}
#line 866 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void app_init(void) 
{ 


  {
#line 869
  start_of_line = 1;
#line 871
  if ((unsigned int )operation == 1U) {
#line 872
    con_file = stdout;
  } else
#line 871
  if ((unsigned int )operation == 2U) {
#line 872
    con_file = stdout;
  } else
#line 873
  if (! options___0.quiet) {
#line 874
    con_file = stderr;
  } else {
#line 876
    con_file = (FILE *)((void *)0);
  }
#line 878
  if ((unsigned long )options___0.log_name != (unsigned long )((void *)0)) {
    {
#line 881
    log_file = fopen((char const   */* __restrict  */)options___0.log_name, (char const   */* __restrict  */)"a");
    }
#line 881
    if ((unsigned long )log_file == (unsigned long )((void *)0)) {
      {
#line 882
      error("Can\'t open log file: %s\n", options___0.log_name);
      }
    }
    {
#line 883
    setvbuf((FILE */* __restrict  */)log_file, (char */* __restrict  */)((void *)0),
            1, (size_t )8192);
#line 884
    app_printf("** Warning: %s\n\n", "The option -log is deprecated; use shell redirection");
    }
  }
#line 887
  return;
}
}
#line 892 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static void app_finish(void) 
{ 


  {
#line 895
  if ((unsigned long )log_file != (unsigned long )((void *)0)) {
    {
#line 898
    fclose(log_file);
    }
  }
#line 900
  return;
}
}
#line 905 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
static int process_files(int argc , char **argv ) 
{ 
  int result ;
  struct opng_ui ui ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 913
  ui.printf_fn = & app_printf;
#line 914
  ui.print_cntrl_fn = & app_print_cntrl;
#line 915
  ui.progress_fn = & app_progress;
#line 916
  ui.panic_fn = & panic;
#line 917
  tmp = opng_initialize((struct opng_options  const  *)(& options___0), (struct opng_ui  const  *)(& ui));
  }
#line 917
  if (tmp != 0) {
    {
#line 918
    panic("Can\'t initialize optimization engine");
    }
  }
#line 921
  result = 0;
#line 922
  i = 1;
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! (i < argc)) {
#line 922
      goto while_break;
    }
#line 924
    if ((unsigned long )*(argv + i) == (unsigned long )((void *)0)) {
#line 925
      goto __Cont;
    } else
#line 924
    if ((int )*(*(argv + i) + 0) == 0) {
#line 925
      goto __Cont;
    }
    {
#line 926
    tmp___0 = opng_optimize((char const   *)*(argv + i));
    }
#line 926
    if (tmp___0 != 0) {
#line 927
      result = 1;
    }
    __Cont: /* CIL Label */ 
#line 922
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 931
  tmp___1 = opng_finalize();
  }
#line 931
  if (tmp___1 != 0) {
    {
#line 932
    panic("Can\'t finalize optimization engine");
    }
  }
#line 934
  return (result);
}
}
#line 940 "/home/khheo/project/benchmark/optipng-0.7.7/src/optipng/optipng.c"
int main(int argc , char **argv ) 
{ 
  int result ;
  char const   *tmp ;
  png_const_charp tmp___0 ;

  {
  {
#line 946
  parse_args(argc, argv);
#line 947
  app_init();
#line 948
  result = 0;
  }
#line 950
  if (local_options.version) {
    {
#line 953
    app_printf("%s\n", msg_intro);
    }
  }
  {
#line 958
  if ((unsigned int )operation == 0U) {
#line 958
    goto case_0;
  }
#line 962
  if ((unsigned int )operation == 1U) {
#line 962
    goto case_1;
  }
#line 981
  if ((unsigned int )operation == 2U) {
#line 981
    goto case_2;
  }
#line 987
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 960
  result = process_files(argc, argv);
  }
#line 961
  goto switch_break;
  case_1: /* CIL Label */ 
#line 963
  if (local_options.help) {
    {
#line 966
    app_printf("%s%s%s", msg_help_synopsis, msg_help_options, msg_help_examples);
    }
  } else {
    {
#line 974
    app_printf("%s%s%s%s", msg_help_synopsis, msg_help_basic_options, msg_help_examples,
               msg_help_more);
    }
  }
#line 980
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 983
  app_printf("%s\n", msg_license);
#line 984
  tmp = zlibVersion();
#line 984
  tmp___0 = png_get_libpng_ver((png_const_structrp )((void *)0));
#line 984
  app_printf("Using libpng version %s and zlib version %s\n", tmp___0, tmp);
  }
#line 986
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 988
  result = -1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 992
  app_finish();
  }
#line 993
  return (result);
}
}
