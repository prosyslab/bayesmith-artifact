/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 46 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stddef.h"
typedef unsigned long size_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 74 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stddef.h"
typedef int wchar_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_15065285 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_15065285 __mbstate_t;
#line 32 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 202 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __sig_atomic_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h"
typedef __sig_atomic_t sig_atomic_t;
#line 61 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
struct __anonstruct_slaves_entry_t_191227824 {
   sig_atomic_t volatile   used ;
   pid_t volatile   child ;
};
#line 61 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
typedef struct __anonstruct_slaves_entry_t_191227824 slaves_entry_t;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list___0;
#line 49 "./printf-args.h"
enum __anonenum_arg_type_817662448 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 49 "./printf-args.h"
typedef enum __anonenum_arg_type_817662448 arg_type;
#line 87 "./printf-args.h"
union __anonunion_a_145370145 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 87 "./printf-args.h"
struct __anonstruct_argument_517936282 {
   arg_type type ;
   union __anonunion_a_145370145 a ;
};
#line 87 "./printf-args.h"
typedef struct __anonstruct_argument_517936282 argument;
#line 133 "./printf-args.h"
struct __anonstruct_arguments_927136039 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
#line 133 "./printf-args.h"
typedef struct __anonstruct_arguments_927136039 arguments;
#line 53 "./printf-parse.h"
struct __anonstruct_char_directive_658480644 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 53 "./printf-parse.h"
typedef struct __anonstruct_char_directive_658480644 char_directive;
#line 70 "./printf-parse.h"
struct __anonstruct_char_directives_461991359 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
#line 70 "./printf-parse.h"
typedef struct __anonstruct_char_directives_461991359 char_directives;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 778 "./time.h"
struct tm_zone ;
#line 778 "./time.h"
typedef struct tm_zone *timezone_t;
#line 21 "./time-internal.h"
struct tm_zone {
   struct tm_zone *next ;
   char tz_is_set ;
   char abbrs[] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_497773352 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_5815191 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_497773352 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_243330693 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_310905018 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_5815191 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_243330693 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_1020988882 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_310905018 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_1020988882 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 32 "./sig-handler.h"
typedef void (*sa_handler_t)(int  );
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 260 "./acl-internal.h"
struct permission_context {
   mode_t mode ;
};
#line 82 "./selinux/selinux.h"
typedef unsigned short security_class_t;
#line 83 "./selinux/selinux.h"
typedef char *security_context_t;
#line 53 "./selinux/context.h"
typedef int context_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 45 "./regex.h"
typedef size_t __re_size_t;
#line 49 "./regex.h"
typedef size_t __re_long_size_t;
#line 72 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 346
enum __anonenum_reg_errcode_t_721730718 {
    _REG_ENOSYS = -1,
    _REG_NOERROR = 0,
    _REG_NOMATCH = 1,
    _REG_BADPAT = 2,
    _REG_ECOLLATE = 3,
    _REG_ECTYPE = 4,
    _REG_EESCAPE = 5,
    _REG_ESUBREG = 6,
    _REG_EBRACK = 7,
    _REG_EPAREN = 8,
    _REG_EBRACE = 9,
    _REG_BADBR = 10,
    _REG_ERANGE = 11,
    _REG_ESPACE = 12,
    _REG_BADRPT = 13,
    _REG_EEND = 14,
    _REG_ESIZE = 15,
    _REG_ERPAREN = 16
} ;
#line 346 "./regex.h"
typedef enum __anonenum_reg_errcode_t_721730718 reg_errcode_t;
#line 413
struct re_dfa_t ;
#line 413 "./regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 478 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 486 "./regex.h"
typedef ssize_t regoff_t;
#line 497 "./regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 517 "./regex.h"
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 517 "./regex.h"
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 38 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
typedef unsigned long wctype_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 155 "./regex_internal.h"
typedef regoff_t Idx;
#line 163 "./regex_internal.h"
typedef __re_size_t re_hashval_t;
#line 167 "./regex_internal.h"
typedef unsigned long bitset_word_t;
#line 176 "./regex_internal.h"
typedef bitset_word_t bitset_t[4];
#line 177 "./regex_internal.h"
typedef bitset_word_t *re_bitset_ptr_t;
#line 178 "./regex_internal.h"
typedef bitset_word_t const   *re_const_bitset_ptr_t;
#line 191
enum __anonenum_re_context_type_961346151 {
    INSIDE_WORD = 5,
    WORD_FIRST = 6,
    WORD_LAST = 9,
    INSIDE_NOTWORD = 10,
    LINE_FIRST = 16,
    LINE_LAST = 32,
    BUF_FIRST = 64,
    BUF_LAST = 128,
    WORD_DELIM = 256,
    NOT_WORD_DELIM = 512
} ;
#line 191 "./regex_internal.h"
typedef enum __anonenum_re_context_type_961346151 re_context_type;
#line 205 "./regex_internal.h"
struct __anonstruct_re_node_set_397540522 {
   Idx alloc ;
   Idx nelem ;
   Idx *elems ;
};
#line 205 "./regex_internal.h"
typedef struct __anonstruct_re_node_set_397540522 re_node_set;
#line 212
enum __anonenum_re_token_type_t_412351811 {
    NON_TYPE = 0,
    CHARACTER = 1,
    END_OF_RE = 2,
    SIMPLE_BRACKET = 3,
    OP_BACK_REF = 4,
    OP_PERIOD = 5,
    COMPLEX_BRACKET = 6,
    OP_UTF8_PERIOD = 7,
    OP_OPEN_SUBEXP = 8,
    OP_CLOSE_SUBEXP = 9,
    OP_ALT = 10,
    OP_DUP_ASTERISK = 11,
    ANCHOR = 12,
    CONCAT = 16,
    SUBEXP = 17,
    OP_DUP_PLUS = 18,
    OP_DUP_QUESTION = 19,
    OP_OPEN_BRACKET = 20,
    OP_CLOSE_BRACKET = 21,
    OP_CHARSET_RANGE = 22,
    OP_OPEN_DUP_NUM = 23,
    OP_CLOSE_DUP_NUM = 24,
    OP_NON_MATCH_LIST = 25,
    OP_OPEN_COLL_ELEM = 26,
    OP_CLOSE_COLL_ELEM = 27,
    OP_OPEN_EQUIV_CLASS = 28,
    OP_CLOSE_EQUIV_CLASS = 29,
    OP_OPEN_CHAR_CLASS = 30,
    OP_CLOSE_CHAR_CLASS = 31,
    OP_WORD = 32,
    OP_NOTWORD = 33,
    OP_SPACE = 34,
    OP_NOTSPACE = 35,
    BACK_SLASH = 36
} ;
#line 212 "./regex_internal.h"
typedef enum __anonenum_re_token_type_t_412351811 re_token_type_t;
#line 264 "./regex_internal.h"
struct __anonstruct_re_charset_t_533161772 {
   wchar_t *mbchars ;
   wchar_t *range_starts ;
   wchar_t *range_ends ;
   wctype_t *char_classes ;
   unsigned int non_match : 1 ;
   Idx nmbchars ;
   Idx ncoll_syms ;
   Idx nequiv_classes ;
   Idx nranges ;
   Idx nchar_classes ;
};
#line 264 "./regex_internal.h"
typedef struct __anonstruct_re_charset_t_533161772 re_charset_t;
#line 311 "./regex_internal.h"
union __anonunion_opr_701081363 {
   unsigned char c ;
   re_bitset_ptr_t sbcset ;
   re_charset_t *mbcset ;
   Idx idx ;
   re_context_type ctx_type ;
};
#line 311 "./regex_internal.h"
struct __anonstruct_re_token_t_670038049 {
   union __anonunion_opr_701081363 opr ;
   re_token_type_t type : 8 ;
   unsigned int constraint : 10 ;
   unsigned int duplicated : 1 ;
   unsigned int opt_subexp : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int mb_partial : 1 ;
   unsigned int word_char : 1 ;
};
#line 311 "./regex_internal.h"
typedef struct __anonstruct_re_token_t_670038049 re_token_t;
#line 342 "./regex_internal.h"
struct re_string_t {
   unsigned char const   *raw_mbs ;
   unsigned char *mbs ;
   wint_t *wcs ;
   Idx *offsets ;
   mbstate_t cur_state ;
   Idx raw_mbs_idx ;
   Idx valid_len ;
   Idx valid_raw_len ;
   Idx bufs_len ;
   Idx cur_idx ;
   Idx raw_len ;
   Idx len ;
   Idx raw_stop ;
   Idx stop ;
   unsigned int tip_context ;
   unsigned char *trans ;
   re_const_bitset_ptr_t word_char ;
   unsigned char icase ;
   unsigned char is_utf8 ;
   unsigned char map_notascii ;
   unsigned char mbs_allocated ;
   unsigned char offsets_needed ;
   unsigned char newline_anchor ;
   unsigned char word_ops_used ;
   int mb_cur_max ;
};
#line 397 "./regex_internal.h"
typedef struct re_string_t re_string_t;
#line 401 "./regex_internal.h"
typedef struct re_dfa_t re_dfa_t;
#line 460 "./regex_internal.h"
struct bin_tree_t {
   struct bin_tree_t *parent ;
   struct bin_tree_t *left ;
   struct bin_tree_t *right ;
   struct bin_tree_t *first ;
   struct bin_tree_t *next ;
   re_token_t token ;
   Idx node_idx ;
};
#line 474 "./regex_internal.h"
typedef struct bin_tree_t bin_tree_t;
#line 479 "./regex_internal.h"
struct bin_tree_storage_t {
   struct bin_tree_storage_t *next ;
   bin_tree_t data[(1024UL - sizeof(void *)) / sizeof(bin_tree_t )] ;
};
#line 484 "./regex_internal.h"
typedef struct bin_tree_storage_t bin_tree_storage_t;
#line 514 "./regex_internal.h"
struct re_dfastate_t {
   re_hashval_t hash ;
   re_node_set nodes ;
   re_node_set non_eps_nodes ;
   re_node_set inveclosure ;
   re_node_set *entrance_nodes ;
   struct re_dfastate_t **trtable ;
   struct re_dfastate_t **word_trtable ;
   unsigned int context : 4 ;
   unsigned int halt : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int has_backref : 1 ;
   unsigned int has_constraint : 1 ;
};
#line 532 "./regex_internal.h"
typedef struct re_dfastate_t re_dfastate_t;
#line 534 "./regex_internal.h"
struct re_state_table_entry {
   Idx num ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 543 "./regex_internal.h"
struct __anonstruct_state_array_t_793059239 {
   Idx next_idx ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 543 "./regex_internal.h"
typedef struct __anonstruct_state_array_t_793059239 state_array_t;
#line 552 "./regex_internal.h"
struct __anonstruct_re_sub_match_last_t_590766955 {
   Idx node ;
   Idx str_idx ;
   state_array_t path ;
};
#line 552 "./regex_internal.h"
typedef struct __anonstruct_re_sub_match_last_t_590766955 re_sub_match_last_t;
#line 563 "./regex_internal.h"
struct __anonstruct_re_sub_match_top_t_1066558227 {
   Idx str_idx ;
   Idx node ;
   state_array_t *path ;
   Idx alasts ;
   Idx nlasts ;
   re_sub_match_last_t **lasts ;
};
#line 563 "./regex_internal.h"
typedef struct __anonstruct_re_sub_match_top_t_1066558227 re_sub_match_top_t;
#line 573 "./regex_internal.h"
struct re_backref_cache_entry {
   Idx node ;
   Idx str_idx ;
   Idx subexp_from ;
   Idx subexp_to ;
   bitset_word_t eps_reachable_subexps_map ;
   char more ;
};
#line 583 "./regex_internal.h"
struct __anonstruct_re_match_context_t_201234058 {
   re_string_t input ;
   re_dfa_t const   *dfa ;
   int eflags ;
   Idx match_last ;
   Idx last_node ;
   re_dfastate_t **state_log ;
   Idx state_log_top ;
   Idx nbkref_ents ;
   Idx abkref_ents ;
   struct re_backref_cache_entry *bkref_ents ;
   int max_mb_elem_len ;
   Idx nsub_tops ;
   Idx asub_tops ;
   re_sub_match_top_t **sub_tops ;
};
#line 583 "./regex_internal.h"
typedef struct __anonstruct_re_match_context_t_201234058 re_match_context_t;
#line 606 "./regex_internal.h"
struct __anonstruct_re_sift_context_t_945197081 {
   re_dfastate_t **sifted_states ;
   re_dfastate_t **limited_states ;
   Idx last_node ;
   Idx last_str_idx ;
   re_node_set limits ;
};
#line 606 "./regex_internal.h"
typedef struct __anonstruct_re_sift_context_t_945197081 re_sift_context_t;
#line 615 "./regex_internal.h"
struct re_fail_stack_ent_t {
   Idx idx ;
   Idx node ;
   regmatch_t *regs ;
   re_node_set eps_via_nodes ;
};
#line 623 "./regex_internal.h"
struct re_fail_stack_t {
   Idx num ;
   Idx alloc ;
   struct re_fail_stack_ent_t *stack ;
};
#line 630 "./regex_internal.h"
struct re_dfa_t {
   re_token_t *nodes ;
   size_t nodes_alloc ;
   size_t nodes_len ;
   Idx *nexts ;
   Idx *org_indices ;
   re_node_set *edests ;
   re_node_set *eclosures ;
   re_node_set *inveclosures ;
   struct re_state_table_entry *state_table ;
   re_dfastate_t *init_state ;
   re_dfastate_t *init_state_word ;
   re_dfastate_t *init_state_nl ;
   re_dfastate_t *init_state_begbuf ;
   bin_tree_t *str_tree ;
   bin_tree_storage_t *str_tree_storage ;
   re_bitset_ptr_t sb_char ;
   int str_tree_storage_idx ;
   re_hashval_t state_hash_mask ;
   Idx init_node ;
   Idx nbackref ;
   bitset_word_t used_bkref_map ;
   bitset_word_t completed_bkref_map ;
   unsigned int has_plural_match : 1 ;
   unsigned int has_mb_node : 1 ;
   unsigned int is_utf8 : 1 ;
   unsigned int map_notascii : 1 ;
   unsigned int word_ops_used : 1 ;
   int mb_cur_max ;
   bitset_t word_char ;
   reg_syntax_t syntax ;
   Idx *subexp_map ;
};
#line 684
enum __anonenum_bracket_elem_type_1002392186 {
    SB_CHAR = 0,
    MB_CHAR = 1,
    EQUIV_CLASS = 2,
    COLL_SYM = 3,
    CHAR_CLASS = 4
} ;
#line 684 "./regex_internal.h"
typedef enum __anonenum_bracket_elem_type_1002392186 bracket_elem_type;
#line 693 "./regex_internal.h"
union __anonunion_opr_675232149 {
   unsigned char ch ;
   unsigned char *name ;
   wchar_t wch ;
};
#line 693 "./regex_internal.h"
struct __anonstruct_bracket_elem_t_384677678 {
   bracket_elem_type type ;
   union __anonunion_opr_675232149 opr ;
};
#line 693 "./regex_internal.h"
typedef struct __anonstruct_bracket_elem_t_384677678 bracket_elem_t;
#line 3271 "./regexec.c"
struct dests_alloc {
   re_node_set dests_node[256] ;
   bitset_t dests_ch[256] ;
};
#line 57 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 32 "./quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    shell_escape_quoting_style = 3,
    shell_escape_always_quoting_style = 4,
    c_quoting_style = 5,
    c_maybe_quoting_style = 6,
    escape_quoting_style = 7,
    locale_quoting_style = 8,
    clocale_quoting_style = 9,
    custom_quoting_style = 10
} ;
#line 270
struct quoting_options ;
#line 65 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 834 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 35 "/home/ubuntu/Desktop/llvm/virtualroot/lib/clang/11.0.0/include/stddef.h"
typedef long ptrdiff_t;
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 67 "./fpucw.h"
typedef unsigned short fpucw_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 151 "parse-datetime.y"
struct __anonstruct_textint_254890571 {
   _Bool negative ;
   intmax_t value ;
   ptrdiff_t digits ;
};
#line 151 "parse-datetime.y"
typedef struct __anonstruct_textint_254890571 textint;
#line 159 "parse-datetime.y"
struct __anonstruct_table_528220008 {
   char const   *name ;
   int type ;
   int value ;
};
#line 159 "parse-datetime.y"
typedef struct __anonstruct_table_528220008 table;
#line 175 "parse-datetime.y"
struct __anonstruct_relative_time_606565990 {
   intmax_t year ;
   intmax_t month ;
   intmax_t day ;
   intmax_t hour ;
   intmax_t minutes ;
   intmax_t seconds ;
   int ns ;
};
#line 175 "parse-datetime.y"
typedef struct __anonstruct_relative_time_606565990 relative_time;
#line 194 "parse-datetime.y"
struct __anonstruct_parser_control_396855831 {
   char const   *input ;
   intmax_t day_ordinal ;
   int day_number ;
   int local_isdst ;
   int time_zone ;
   int meridian ;
   textint year ;
   intmax_t month ;
   intmax_t day ;
   intmax_t hour ;
   intmax_t minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   ptrdiff_t dates_seen ;
   ptrdiff_t days_seen ;
   ptrdiff_t local_zones_seen ;
   ptrdiff_t dsts_seen ;
   ptrdiff_t times_seen ;
   ptrdiff_t zones_seen ;
   _Bool year_seen ;
   _Bool parse_datetime_debug ;
   _Bool debug_dates_seen ;
   _Bool debug_days_seen ;
   _Bool debug_local_zones_seen ;
   _Bool debug_times_seen ;
   _Bool debug_zones_seen ;
   _Bool debug_year_seen ;
   _Bool debug_ordinal_day_seen ;
   table local_time_zone_table[3] ;
};
#line 194 "parse-datetime.y"
typedef struct __anonstruct_parser_control_396855831 parser_control;
#line 254
union YYSTYPE ;
#line 691 "parse-datetime.tab.c"
union YYSTYPE {
   intmax_t intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 703 "parse-datetime.tab.c"
typedef union YYSTYPE YYSTYPE;
#line 725 "parse-datetime.tab.c"
typedef unsigned char yytype_uint8;
#line 731 "parse-datetime.tab.c"
typedef signed char yytype_int8;
#line 743 "parse-datetime.tab.c"
typedef short yytype_int16;
#line 900 "parse-datetime.tab.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 167 "./obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[] ;
};
#line 174 "./obstack.h"
union __anonunion_temp_355861816 {
   size_t i ;
   void *p ;
};
#line 174 "./obstack.h"
union __anonunion_chunkfun_5259977 {
   void *(*plain)(size_t  ) ;
   void *(*extra)(void * , size_t  ) ;
};
#line 174 "./obstack.h"
union __anonunion_freefun_5259978 {
   void (*plain)(void * ) ;
   void (*extra)(void * , void * ) ;
};
#line 174 "./obstack.h"
struct obstack {
   size_t chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_355861816 temp ;
   size_t alignment_mask ;
   union __anonunion_chunkfun_5259977 chunkfun ;
   union __anonunion_freefun_5259978 freefun ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 35 "./mktime-internal.h"
typedef time_t mktime_offset_t;
#line 122 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
typedef long long_int;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/malloca.c"
typedef unsigned char small_t;
#line 65 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h"
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 82 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 118 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
#line 53 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 67 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
#line 86 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
#line 93 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
#line 418 "./glthread/lock.h"
typedef pthread_mutex_t gl_recursive_lock_t;
#line 80 "./isnan.c"
union __anonunion_memory_double_618071262 {
   long double value ;
   unsigned int word[((sizeof(long double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 80 "./isnan.c"
typedef union __anonunion_memory_double_618071262 memory_double;
#line 80 "./isnan.c"
union __anonunion_memory_double_1062461384 {
   float value ;
   unsigned int word[((sizeof(float ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 80 "./isnan.c"
typedef union __anonunion_memory_double_1062461384 memory_double___0;
#line 117 "./gl_list.h"
struct gl_list_impl ;
#line 119 "./gl_list.h"
typedef struct gl_list_impl *gl_list_t;
#line 121
struct gl_list_node_impl ;
#line 125 "./gl_list.h"
typedef struct gl_list_node_impl *gl_list_node_t;
#line 127
struct gl_list_implementation ;
#line 129 "./gl_list.h"
typedef struct gl_list_implementation  const  *gl_list_implementation_t;
#line 350 "./gl_list.h"
struct __anonstruct_gl_list_iterator_t_219508658 {
   struct gl_list_implementation  const  *vtable ;
   gl_list_t list ;
   size_t count ;
   void *p ;
   void *q ;
   size_t i ;
   size_t j ;
};
#line 350 "./gl_list.h"
typedef struct __anonstruct_gl_list_iterator_t_219508658 gl_list_iterator_t;
#line 474 "./gl_list.h"
struct gl_list_implementation {
   gl_list_t (*nx_create_empty)(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                             void const   *elt2 ) ,
                                size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                                _Bool allow_duplicates ) ;
   gl_list_t (*nx_create)(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                       void const   *elt2 ) ,
                          size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                          _Bool allow_duplicates , size_t count , void const   **contents ) ;
   size_t (*size)(gl_list_t list ) ;
   void const   *(*node_value)(gl_list_t list , gl_list_node_t node ) ;
   int (*node_nx_set_value)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*next_node)(gl_list_t list , gl_list_node_t node ) ;
   gl_list_node_t (*previous_node)(gl_list_t list , gl_list_node_t node ) ;
   void const   *(*get_at)(gl_list_t list , size_t position ) ;
   gl_list_node_t (*nx_set_at)(gl_list_t list , size_t position , void const   *elt ) ;
   gl_list_node_t (*search_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                                    void const   *elt ) ;
   size_t (*indexof_from_to)(gl_list_t list , size_t start_index , size_t end_index ,
                             void const   *elt ) ;
   gl_list_node_t (*nx_add_first)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*nx_add_last)(gl_list_t list , void const   *elt ) ;
   gl_list_node_t (*nx_add_before)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*nx_add_after)(gl_list_t list , gl_list_node_t node , void const   *elt ) ;
   gl_list_node_t (*nx_add_at)(gl_list_t list , size_t position , void const   *elt ) ;
   _Bool (*remove_node)(gl_list_t list , gl_list_node_t node ) ;
   _Bool (*remove_at)(gl_list_t list , size_t position ) ;
   _Bool (*remove_elt)(gl_list_t list , void const   *elt ) ;
   void (*list_free)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator)(gl_list_t list ) ;
   gl_list_iterator_t (*iterator_from_to)(gl_list_t list , size_t start_index , size_t end_index ) ;
   _Bool (*iterator_next)(gl_list_iterator_t *iterator , void const   **eltp , gl_list_node_t *nodep ) ;
   void (*iterator_free)(gl_list_iterator_t *iterator ) ;
   gl_list_node_t (*sortedlist_search)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                      void const   *elt2 ) ,
                                       void const   *elt ) ;
   gl_list_node_t (*sortedlist_search_from_to)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                              void const   *elt2 ) ,
                                               size_t start_index , size_t end_index ,
                                               void const   *elt ) ;
   size_t (*sortedlist_indexof)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                               void const   *elt2 ) ,
                                void const   *elt ) ;
   size_t (*sortedlist_indexof_from_to)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                       void const   *elt2 ) ,
                                        size_t start_index , size_t end_index , void const   *elt ) ;
   gl_list_node_t (*sortedlist_nx_add)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                      void const   *elt2 ) ,
                                       void const   *elt ) ;
   _Bool (*sortedlist_remove)(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                             void const   *elt2 ) ,
                              void const   *elt ) ;
};
#line 545 "./gl_list.h"
struct gl_list_impl_base {
   struct gl_list_implementation  const  *vtable ;
   _Bool (*equals_fn)(void const   *elt1 , void const   *elt2 ) ;
   size_t (*hashcode_fn)(void const   *elt ) ;
   void (*dispose_fn)(void const   *elt ) ;
   _Bool allow_duplicates ;
};
#line 34 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
struct gl_list_impl {
   struct gl_list_impl_base base ;
   void const   **elements ;
   size_t count ;
   size_t allocated ;
};
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 115 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
struct __anonstruct_actions_entry_t_281882088 {
   void (* volatile  action)(int sig ) ;
};
#line 115 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
typedef struct __anonstruct_actions_entry_t_281882088 actions_entry_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct sched_param {
   int sched_priority ;
};
#line 29 "/usr/include/spawn.h"
struct __anonstruct_posix_spawnattr_t_184215199 {
   short __flags ;
   pid_t __pgrp ;
   sigset_t __sd ;
   sigset_t __ss ;
   struct sched_param __sp ;
   int __policy ;
   int __pad[16] ;
};
#line 29 "/usr/include/spawn.h"
typedef struct __anonstruct_posix_spawnattr_t_184215199 posix_spawnattr_t;
#line 43
struct __spawn_action ;
#line 43 "/usr/include/spawn.h"
struct __anonstruct_posix_spawn_file_actions_t_439791642 {
   int __allocated ;
   int __used ;
   struct __spawn_action *__actions ;
   int __pad[16] ;
};
#line 43 "/usr/include/spawn.h"
typedef struct __anonstruct_posix_spawn_file_actions_t_439791642 posix_spawn_file_actions_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 35 "./base64.h"
struct base64_decode_context {
   unsigned int i ;
   char buf[4] ;
};
#line 717 "./rec.h"
struct rec_field_s ;
#line 717 "./rec.h"
typedef struct rec_field_s *rec_field_t;
#line 847
struct rec_record_s ;
#line 847 "./rec.h"
typedef struct rec_record_s *rec_record_t;
#line 1071
struct rec_rset_s ;
#line 1071 "./rec.h"
typedef struct rec_rset_s *rec_rset_t;
#line 65
struct rec_mset_s ;
#line 65 "./rec.h"
typedef struct rec_mset_s *rec_mset_t;
#line 70
struct rec_mset_elem_s ;
#line 70 "./rec.h"
typedef struct rec_mset_elem_s *rec_mset_elem_t;
#line 77 "./rec.h"
struct __anonstruct_rec_mset_list_iter_t_783153039 {
   void *vtable ;
   void *list ;
   size_t count ;
   void *p ;
   void *q ;
   size_t i ;
   size_t j ;
};
#line 77 "./rec.h"
typedef struct __anonstruct_rec_mset_list_iter_t_783153039 rec_mset_list_iter_t;
#line 86 "./rec.h"
struct __anonstruct_rec_mset_iterator_t_680582983 {
   rec_mset_t mset ;
   rec_mset_list_iter_t list_iter ;
};
#line 86 "./rec.h"
typedef struct __anonstruct_rec_mset_iterator_t_680582983 rec_mset_iterator_t;
#line 107 "./rec.h"
typedef int rec_mset_type_t;
#line 1311
struct rec_aggregate_reg_s ;
#line 1311 "./rec.h"
typedef struct rec_aggregate_reg_s *rec_aggregate_reg_t;
#line 2219 "./rec.h"
typedef char *(*rec_aggregate_t)(rec_rset_t rset , rec_record_t record , char const   *field_name );
#line 44 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
struct rec_aggregate_reg_elem_s {
   char *name ;
   char *(*function)(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
};
#line 50 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
struct rec_aggregate_reg_s {
   struct rec_aggregate_reg_elem_s functions[40] ;
   size_t num_functions ;
};
#line 94 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
struct rec_aggregate_descriptor_s {
   char const   *name ;
   char *(*func)(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
};
#line 320 "./rec.h"
struct rec_buf_s ;
#line 320 "./rec.h"
typedef struct rec_buf_s *rec_buf_t;
#line 35 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-buf.c"
struct rec_buf_s {
   char *data ;
   size_t size ;
   size_t used ;
   char **data_pointer ;
   size_t *size_pointer ;
};
#line 575 "./rec.h"
enum rec_type_kind_e {
    REC_TYPE_NONE = 0,
    REC_TYPE_INT = 1,
    REC_TYPE_BOOL = 2,
    REC_TYPE_RANGE = 3,
    REC_TYPE_REAL = 4,
    REC_TYPE_SIZE = 5,
    REC_TYPE_LINE = 6,
    REC_TYPE_REGEXP = 7,
    REC_TYPE_DATE = 8,
    REC_TYPE_ENUM = 9,
    REC_TYPE_FIELD = 10,
    REC_TYPE_EMAIL = 11,
    REC_TYPE_UUID = 12,
    REC_TYPE_REC = 13
} ;
#line 607
struct rec_type_s ;
#line 607 "./rec.h"
typedef struct rec_type_s *rec_type_t;
#line 685
struct rec_type_reg_s ;
#line 685 "./rec.h"
typedef struct rec_type_reg_s *rec_type_reg_t;
#line 228 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
union __anonunion_data_627815733 {
   size_t max_size ;
   int range[2] ;
   regex_t regexp ;
   char *recname ;
   char **names ;
};
#line 228 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
struct rec_type_s {
   char *name ;
   enum rec_type_kind_e kind ;
   char *expr ;
   size_t size ;
   union __anonunion_data_627815733 data ;
};
#line 252 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
struct rec_type_reg_entry_s {
   char *type_name ;
   rec_type_t type ;
   char *to_type ;
   _Bool visited_p ;
};
#line 261 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
struct rec_type_reg_s {
   size_t num_types ;
   struct rec_type_reg_entry_s *types ;
};
#line 444 "./rec.h"
struct rec_fex_s ;
#line 444 "./rec.h"
typedef struct rec_fex_s *rec_fex_t;
#line 445
struct rec_fex_elem_s ;
#line 445 "./rec.h"
typedef struct rec_fex_elem_s *rec_fex_elem_t;
#line 447
enum rec_fex_kind_e {
    REC_FEX_SIMPLE = 0,
    REC_FEX_CSV = 1,
    REC_FEX_SUBSCRIPTS = 2
} ;
#line 41 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
struct rec_fex_elem_s {
   char *str ;
   char *field_name ;
   char *rewrite_to ;
   int max ;
   int min ;
   char *function_name ;
   void *function_data ;
};
#line 56 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
struct rec_fex_s {
   int num_elems ;
   char *str ;
   rec_fex_elem_t elems[256] ;
};
#line 1077 "./rec.h"
struct rec_sex_s ;
#line 1077 "./rec.h"
typedef struct rec_sex_s *rec_sex_t;
#line 34 "./rec-sex-ast.h"
enum rec_sex_ast_node_type_e {
    REC_SEX_NOVAL = 0,
    REC_SEX_OP_NEG = 1,
    REC_SEX_OP_ADD = 2,
    REC_SEX_OP_SUB = 3,
    REC_SEX_OP_MUL = 4,
    REC_SEX_OP_DIV = 5,
    REC_SEX_OP_MOD = 6,
    REC_SEX_OP_EQL = 7,
    REC_SEX_OP_NEQ = 8,
    REC_SEX_OP_MAT = 9,
    REC_SEX_OP_LT = 10,
    REC_SEX_OP_GT = 11,
    REC_SEX_OP_LTE = 12,
    REC_SEX_OP_GTE = 13,
    REC_SEX_OP_AND = 14,
    REC_SEX_OP_OR = 15,
    REC_SEX_OP_NOT = 16,
    REC_SEX_OP_SHA = 17,
    REC_SEX_OP_SAMETIME = 18,
    REC_SEX_OP_IMPLIES = 19,
    REC_SEX_OP_BEFORE = 20,
    REC_SEX_OP_AFTER = 21,
    REC_SEX_OP_COND = 22,
    REC_SEX_OP_CONCAT = 23,
    REC_SEX_INT = 24,
    REC_SEX_REAL = 25,
    REC_SEX_STR = 26,
    REC_SEX_NAME = 27
} ;
#line 70
struct rec_sex_ast_node_s ;
#line 70 "./rec-sex-ast.h"
typedef struct rec_sex_ast_node_s *rec_sex_ast_node_t;
#line 71
struct rec_sex_ast_s ;
#line 71 "./rec-sex-ast.h"
typedef struct rec_sex_ast_s *rec_sex_ast_t;
#line 37 "./rec-sex-parser.h"
struct rec_sex_parser_s ;
#line 37 "./rec-sex-parser.h"
typedef struct rec_sex_parser_s *rec_sex_parser_t;
#line 44 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
struct rec_sex_s {
   rec_sex_ast_t ast ;
   rec_sex_parser_t parser ;
};
#line 54 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
struct rec_sex_val_s {
   int type ;
   int int_val ;
   double real_val ;
   char *str_val ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 290 "rec-sex-lex.c"
typedef uint8_t flex_uint8_t;
#line 291 "rec-sex-lex.c"
typedef int16_t flex_int16_t;
#line 372 "rec-sex-lex.c"
typedef void *yyscan_t;
#line 427
struct yy_buffer_state ;
#line 427 "rec-sex-lex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 432 "rec-sex-lex.c"
typedef size_t yy_size_t;
#line 467 "rec-sex-lex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   int yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 616 "rec-sex-lex.c"
typedef flex_uint8_t YY_CHAR;
#line 618 "rec-sex-lex.c"
typedef int yy_state_type;
#line 86 "./rec-sex-tab.h"
union YYSTYPE___0 {
   rec_sex_ast_node_t node ;
   rec_sex_ast_t ast ;
};
#line 96 "rec-sex-tab.h"
typedef union YYSTYPE___0 YYSTYPE___0;
#line 861 "rec-sex-lex.c"
struct yyguts_t {
   void *yyextra_r ;
   FILE *yyin_r ;
   FILE *yyout_r ;
   size_t yy_buffer_stack_top ;
   size_t yy_buffer_stack_max ;
   YY_BUFFER_STATE *yy_buffer_stack ;
   char yy_hold_char ;
   int yy_n_chars ;
   int yyleng_r ;
   char *yy_c_buf_p ;
   int yy_init ;
   int yy_start ;
   int yy_did_buffer_switch_on_eof ;
   int yy_start_stack_ptr ;
   int yy_start_stack_depth ;
   int *yy_start_stack ;
   yy_state_type yy_last_accepting_state ;
   char *yy_last_accepting_cpos ;
   int yylineno_r ;
   int yy_flex_debug_r ;
   char *yytext_r ;
   int yy_more_flag ;
   int yy_more_len ;
   YYSTYPE___0 *yylval_r ;
};
#line 412 "rec-sex-tab.c"
union yyalloc___0 {
   yytype_int16 yyss_alloc ;
   YYSTYPE___0 yyvs_alloc ;
};
#line 41 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
union __anonunion_val_676379575 {
   int integer ;
   double real ;
   char *string ;
   char *name[2] ;
};
#line 41 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
struct rec_sex_ast_node_s {
   enum rec_sex_ast_node_type_e type ;
   union __anonunion_val_676379575 val ;
   int index ;
   _Bool fixed ;
   char *fixed_val ;
   rec_sex_ast_node_t children[3] ;
   size_t num_children ;
};
#line 58 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
struct rec_sex_ast_s {
   rec_sex_ast_node_t top ;
};
#line 41 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
struct rec_sex_parser_s {
   char *in ;
   size_t index ;
   void *scanner ;
   _Bool case_insensitive ;
   rec_sex_ast_t ast ;
};
#line 394 "./rec.h"
enum rec_std_field_e {
    REC_FIELD_AUTO = 0,
    REC_FIELD_CONFIDENTIAL = 1,
    REC_FIELD_KEY = 2,
    REC_FIELD_MANDATORY = 3,
    REC_FIELD_PROHIBIT = 4,
    REC_FIELD_REC = 5,
    REC_FIELD_SIZE = 6,
    REC_FIELD_SORT = 7,
    REC_FIELD_TYPE = 8,
    REC_FIELD_TYPEDEF = 9,
    REC_FIELD_UNIQUE = 10,
    REC_FIELD_CONSTRAINT = 11,
    REC_FIELD_ALLOWED = 12
} ;
#line 1305
struct rec_db_s ;
#line 1305 "./rec.h"
typedef struct rec_db_s *rec_db_t;
#line 1850
struct rec_parser_s ;
#line 1850 "./rec.h"
typedef struct rec_parser_s *rec_parser_t;
#line 342 "./rec.h"
typedef char *rec_comment_t;
#line 1968
struct rec_writer_s ;
#line 1968 "./rec.h"
typedef struct rec_writer_s *rec_writer_t;
#line 1974
enum rec_writer_mode_e {
    REC_WRITER_NORMAL = 0,
    REC_WRITER_VALUES = 1,
    REC_WRITER_VALUES_ROW = 2,
    REC_WRITER_SEXP = 3
} ;
#line 1982 "./rec.h"
typedef enum rec_writer_mode_e rec_writer_mode_t;
#line 46 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
struct rec_writer_s {
   FILE *file_out ;
   rec_buf_t buf_out ;
   _Bool eof ;
   int line ;
   _Bool collapse_p ;
   _Bool skip_comments_p ;
   enum rec_writer_mode_e mode ;
};
#line 59 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
enum rec_parser_error_e {
    REC_PARSER_NOERROR = 0,
    REC_PARSER_ERROR = 1,
    REC_PARSER_EUNGETC = 2,
    REC_PARSER_EFNAME = 3,
    REC_PARSER_ENOMEM = 4,
    REC_PARSER_ETOOMUCHNAMEPARTS = 5,
    REC_PARSER_ECOMMENT = 6,
    REC_PARSER_EFIELD = 7,
    REC_PARSER_ERECORD = 8
} ;
#line 72 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
struct rec_parser_s {
   FILE *in_file ;
   char const   *in_buffer ;
   size_t in_size ;
   char const   *p ;
   char *source ;
   rec_record_t prev_descriptor ;
   _Bool eof ;
   enum rec_parser_error_e error ;
   size_t line ;
   size_t character ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 423 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 42 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
struct rec_db_s {
   size_t size ;
   gl_list_t rset_list ;
   rec_aggregate_reg_t aggregates ;
};
#line 36 "./rec-utils.h"
enum rec_size_condition_e {
    SIZE_COND_E = 0,
    SIZE_COND_L = 1,
    SIZE_COND_LE = 2,
    SIZE_COND_G = 3,
    SIZE_COND_GE = 4
} ;
#line 53 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
struct rec_rset_fprops_s {
   char *fname ;
   _Bool key_p ;
   _Bool auto_p ;
   rec_type_t type ;
   char *type_name ;
   struct rec_rset_fprops_s *next ;
};
#line 68 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
typedef struct rec_rset_fprops_s *rec_rset_fprops_t;
#line 73 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
struct rec_rset_s {
   rec_record_t descriptor ;
   size_t descriptor_pos ;
   rec_rset_fprops_t field_props ;
   rec_type_reg_t type_reg ;
   rec_fex_t order_by_fields ;
   size_t min_size ;
   size_t max_size ;
   rec_sex_t *constraints ;
   size_t num_constraints ;
   int record_type ;
   int comment_type ;
   rec_mset_t mset ;
};
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
struct rec_record_s {
   void *container ;
   int field_type ;
   int comment_type ;
   char *source ;
   size_t location ;
   char *location_str ;
   size_t char_location ;
   char *char_location_str ;
   rec_mset_t mset ;
};
#line 40 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
struct rec_field_s {
   char *name ;
   char *value ;
   char *source ;
   size_t location ;
   char *location_str ;
   size_t char_location ;
   char *char_location_str ;
   int mark ;
};
#line 96 "./rec.h"
typedef void (*rec_mset_disp_fn_t)(void *data );
#line 97 "./rec.h"
typedef _Bool (*rec_mset_equal_fn_t)(void *data1 , void *data2 );
#line 98 "./rec.h"
typedef void *(*rec_mset_dup_fn_t)(void *data );
#line 99 "./rec.h"
typedef int (*rec_mset_compare_fn_t)(void *data1 , void *data2 , int type2 );
#line 44 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
struct rec_mset_elem_s {
   rec_mset_type_t type ;
   void *data ;
   gl_list_node_t list_node ;
   rec_mset_t mset ;
};
#line 55 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
struct rec_mset_s {
   int ntypes ;
   char *name[4] ;
   rec_mset_disp_fn_t disp_fn[4] ;
   rec_mset_equal_fn_t equal_fn[4] ;
   rec_mset_dup_fn_t dup_fn[4] ;
   rec_mset_compare_fn_t compare_fn[4] ;
   size_t count[4] ;
   gl_list_t elem_list ;
};
#line 59 "./xsize.h"
__inline size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 65
  sum = size1 + size2;
#line 66
  if (sum >= size1) {
#line 66
    tmp = sum;
  } else {
#line 66
    tmp = 0xffffffffffffffffUL;
  }
#line 66
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 70 "./xsize.h"
__inline size_t __attribute__((__pure__))  xsum3(size_t size1 , size_t size2 , size_t size3 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 76
  tmp = xsum(size1, size2);
#line 76
  tmp___0 = xsum((size_t )tmp, size3);
  }
#line 76
  return (tmp___0);
}
}
#line 80 "./xsize.h"
__inline size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 , size_t size3 ,
                                                 size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 86
  tmp = xsum(size1, size2);
#line 86
  tmp___0 = xsum((size_t )tmp, size3);
#line 86
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 86
  return (tmp___1);
}
}
#line 90 "./xsize.h"
__inline size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 98
  if (size1 >= size2) {
#line 98
    tmp = size1;
  } else {
#line 98
    tmp = size2;
  }
#line 98
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 51 "./xalloc.h"
void xalloc_die(void) ;
#line 53
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 55
void *xzalloc(size_t n )  __attribute__((__malloc__)) ;
#line 57
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 59
void *xrealloc(void *p , size_t n ) ;
#line 61
void *x2realloc(void *p , size_t *pn ) ;
#line 62
void *xmemdup(void const   *p , size_t s ) ;
#line 64
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 96
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 98
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 98 "./xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 101
  if (9223372036854775807UL / s < n) {
    {
#line 102
    xalloc_die();
    }
  }
  {
#line 103
  tmp = xmalloc(n * s);
  }
#line 103
  return (tmp);
}
}
#line 109
__inline void *xnrealloc(void *p , size_t n , size_t s ) ;
#line 111 "./xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 114
  if (9223372036854775807UL / s < n) {
    {
#line 115
    xalloc_die();
    }
  }
  {
#line 116
  tmp = xrealloc(p, n * s);
  }
#line 116
  return (tmp);
}
}
#line 173 "./xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 176
  n = *pn;
#line 178
  if (! p) {
#line 180
    if (! n) {
#line 188
      n = 128UL / s;
#line 189
      n += (size_t )(! n);
    }
#line 191
    if (9223372036854775807UL / s < n) {
      {
#line 192
      xalloc_die();
      }
    }
  } else {
#line 200
    if (6148914691236517204UL / s <= n) {
      {
#line 202
      xalloc_die();
      }
    }
#line 203
    n += n / 2UL + 1UL;
  }
  {
#line 206
  *pn = n;
#line 207
  tmp = xrealloc(p, n * s);
  }
#line 207
  return (tmp);
}
}
#line 213
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 215
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 215 "./xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 218
  if (sizeof(char ) == 1UL) {
    {
#line 218
    tmp = xmalloc(n);
#line 218
    tmp___1 = tmp;
    }
  } else {
    {
#line 218
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 218
    tmp___1 = tmp___0;
    }
  }
#line 218
  return ((char *)tmp___1);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 117
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
#line 360
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 360 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 363
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 363
  return ((int )tmp);
}
}
#line 365
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 365 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  {
#line 368
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 368
  return (tmp);
}
}
#line 372
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 372 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  {
#line 375
  tmp = strtoll((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
                10);
  }
#line 375
  return (tmp);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                         unsigned int __minor )  __attribute__((__const__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_major)(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major = (unsigned int )((unsigned long )__major | ((__dev & 0xfffff00000000000UL) >> 32));
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__gnu_inline__)) gnu_dev_minor)(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor = (unsigned int )((unsigned long )__minor | ((__dev & 17592184995840UL) >> 12));
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                         unsigned int __minor )  __attribute__((__const__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t ( __attribute__((__gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                           unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 817
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
#line 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  {
#line 27
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
#line 27
  return (tmp);
}
}
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t n )  __attribute__((__malloc__)) ;
#line 83 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
void *xzalloc(size_t n ) 
{ 
  void *tmp ;

  {
  {
#line 86
  tmp = xcalloc(n, (size_t )1);
  }
#line 86
  return (tmp);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 92 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
#line 100
  if (9223372036854775807UL / s < n) {
    {
#line 102
    xalloc_die();
    }
  } else {
    {
#line 100
    p = calloc(n, s);
    }
#line 100
    if (! p) {
      {
#line 102
      xalloc_die();
      }
    }
  }
#line 103
  return (p);
}
}
#line 110 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 52 "./error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "./exitfail.h"
int volatile   exit_failure ;
#line 51 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category )  __attribute__((__format_arg__(2))) ;
#line 31 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 333
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
#line 484
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 495
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 496
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 506
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 524
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 603
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 616
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 38
  return (tmp);
}
}
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  {
#line 46
  tmp = _IO_getc(stdin);
  }
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 55
  if (tmp___3) {
    {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
    }
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 72
  if (tmp___3) {
    {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
    }
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  {
#line 81
  tmp = _IO_putc(__c, stdout);
  }
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 90
  if (tmp___4) {
    {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
    }
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 107
  if (tmp___4) {
    {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
    }
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 114 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  {
#line 117
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 117
  return (tmp);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 284 "/usr/include/wchar.h"
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
#line 288
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
#line 296
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t * __restrict  __p ) ;
#line 305
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   * __restrict  __s ,
                                                     size_t __n , mbstate_t * __restrict  __ps ) ;
#line 307
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
#line 316
extern wint_t __btowc_alias(int __c )  __asm__("btowc")  ;
#line 317
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
#line 317 "/usr/include/wchar.h"
__inline extern wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) 
{ 
  wint_t tmp ;

  {
  {
#line 319
  tmp = __btowc_alias(__c);
  }
#line 319
  return (tmp);
}
}
#line 322
extern int __wctob_alias(wint_t __c )  __asm__("wctob")  ;
#line 323
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
#line 323 "/usr/include/wchar.h"
__inline extern int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) 
{ 
  int tmp ;

  {
  {
#line 325
  tmp = __wctob_alias(__wc);
  }
#line 325
  return (tmp);
}
}
#line 328
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
#line 328 "/usr/include/wchar.h"
__inline extern size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                 size_t __n , mbstate_t * __restrict  __ps ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 331
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    {
#line 331
    tmp = mbrtowc((wchar_t */* __restrict  */)((void *)0), __s, __n, __ps);
#line 331
    tmp___1 = tmp;
    }
  } else {
    {
#line 331
    tmp___0 = __mbrlen(__s, __n, (mbstate_t */* __restrict  */)((void *)0));
#line 331
    tmp___1 = tmp___0;
    }
  }
#line 331
  return (tmp___1);
}
}
#line 592 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
#line 57 "./wait-process.h"
int wait_subprocess(pid_t child , char const   *progname , _Bool ignore_sigpipe ,
                    _Bool null_stderr , _Bool slave_process , _Bool exit_on_error ,
                    int *termsigp ) ;
#line 66
void register_slave_subprocess(pid_t child ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 55 "./fatal-signal.h"
void at_fatal_signal(void (*action)(int sig ) ) ;
#line 69 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static slaves_entry_t static_slaves[32]  ;
#line 70 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static slaves_entry_t * volatile  slaves  =    (slaves_entry_t */* volatile  */)(static_slaves);
#line 71 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static int volatile   slaves_count  =    (sig_atomic_t volatile   )0;
#line 72 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static size_t slaves_allocated  =    sizeof(static_slaves) / sizeof(static_slaves[0]);
#line 83 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static void cleanup_slaves(void) 
{ 
  size_t n ;
  pid_t slave ;

  {
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    n = (size_t )slaves_count;
#line 90
    if (n == 0UL) {
#line 91
      goto while_break;
    }
#line 92
    n --;
#line 93
    slaves_count = (int volatile   )n;
#line 95
    if ((slaves + n)->used) {
      {
#line 97
      slave = (pid_t )(slaves + n)->child;
#line 100
      kill(slave, 1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 107 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static void cleanup_slaves_action(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 110
  cleanup_slaves();
  }
#line 111
  return;
}
}
#line 120 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static _Bool cleanup_slaves_registered  =    (_Bool)0;
#line 117 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
void register_slave_subprocess(pid_t child ) 
{ 
  slaves_entry_t *s ;
  slaves_entry_t *s_end ;
  slaves_entry_t *old_slaves ;
  size_t new_slaves_allocated ;
  slaves_entry_t *new_slaves ;
  void *tmp ;

  {
#line 121
  if (! cleanup_slaves_registered) {
    {
#line 123
    atexit(& cleanup_slaves);
#line 124
    at_fatal_signal(& cleanup_slaves_action);
#line 125
    cleanup_slaves_registered = (_Bool)1;
    }
  }
#line 130
  s = (slaves_entry_t *)slaves;
#line 131
  s_end = s + slaves_count;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 133
      goto while_break;
    }
#line 134
    if (! s->used) {
#line 140
      s->child = (pid_t volatile   )child;
#line 141
      s->used = (sig_atomic_t volatile   )1;
#line 142
      return;
    }
#line 133
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 146
  if ((size_t )slaves_count == slaves_allocated) {
    {
#line 151
    old_slaves = (slaves_entry_t *)slaves;
#line 152
    new_slaves_allocated = 2UL * slaves_allocated;
#line 153
    tmp = malloc(new_slaves_allocated * sizeof(slaves_entry_t ));
#line 153
    new_slaves = (slaves_entry_t *)tmp;
    }
#line 156
    if ((unsigned long )new_slaves == (unsigned long )((void *)0)) {
      {
#line 161
      kill(child, 1);
#line 162
      xalloc_die();
      }
    }
    {
#line 164
    memcpy((void */* __restrict  */)new_slaves, (void const   */* __restrict  */)old_slaves,
           slaves_allocated * sizeof(slaves_entry_t ));
#line 166
    slaves = (slaves_entry_t */* volatile  */)new_slaves;
#line 167
    slaves_allocated = new_slaves_allocated;
    }
#line 169
    if ((unsigned long )old_slaves != (unsigned long )(static_slaves)) {
      {
#line 170
      free((void *)old_slaves);
      }
    }
  }
#line 176
  (slaves + slaves_count)->child = (pid_t volatile   )child;
#line 177
  (slaves + slaves_count)->used = (sig_atomic_t volatile   )1;
#line 178
  slaves_count += (int volatile   )1;
#line 179
  return;
}
}
#line 182 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
static void unregister_slave_subprocess(pid_t child ) 
{ 
  slaves_entry_t *s ;
  slaves_entry_t *s_end ;

  {
#line 188
  s = (slaves_entry_t *)slaves;
#line 189
  s_end = s + slaves_count;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! ((unsigned long )s < (unsigned long )s_end)) {
#line 191
      goto while_break;
    }
#line 192
    if (s->used) {
#line 192
      if (s->child == (pid_t volatile   )child) {
#line 193
        s->used = (sig_atomic_t volatile   )0;
      }
    }
#line 191
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 200 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/wait-process.c"
int wait_subprocess(pid_t child , char const   *progname , _Bool ignore_sigpipe ,
                    _Bool null_stderr , _Bool slave_process , _Bool exit_on_error ,
                    int *termsigp ) 
{ 
  int status ;
  int result ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 301
  if ((unsigned long )termsigp != (unsigned long )((void *)0)) {
#line 302
    *termsigp = 0;
  }
#line 303
  status = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 306
    tmp = waitpid(child, & status, 0);
#line 306
    result = tmp;
    }
#line 308
    if (result != child) {
      {
#line 311
      tmp___0 = __errno_location();
      }
#line 311
      if (*tmp___0 == 4) {
#line 312
        goto __Cont;
      }
#line 323
      if (exit_on_error) {
#line 323
        goto _L;
      } else
#line 323
      if (! null_stderr) {
        _L: /* CIL Label */ 
        {
#line 324
        tmp___1 = dcgettext((char const   *)((void *)0), "%s subprocess", 5);
#line 324
        tmp___2 = __errno_location();
        }
#line 324
        if (exit_on_error) {
#line 324
          tmp___3 = 1;
        } else {
#line 324
          tmp___3 = 0;
        }
        {
#line 324
        error(tmp___3, *tmp___2, (char const   *)tmp___1, progname);
        }
      }
#line 326
      return (127);
    }
#line 332
    if (! ((status & 255) == 127)) {
#line 333
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  if (slave_process) {
    {
#line 342
    unregister_slave_subprocess(child);
    }
  }
#line 344
  if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
#line 346
    if ((unsigned long )termsigp != (unsigned long )((void *)0)) {
#line 347
      *termsigp = status & 127;
    }
#line 349
    if ((status & 127) == 13) {
#line 349
      if (ignore_sigpipe) {
#line 350
        return (0);
      }
    }
#line 352
    if (exit_on_error) {
#line 352
      goto _L___0;
    } else
#line 352
    if (! null_stderr) {
#line 352
      if ((unsigned long )termsigp == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
        {
#line 353
        tmp___4 = dcgettext((char const   *)((void *)0), "%s subprocess got fatal signal %d",
                            5);
        }
#line 353
        if (exit_on_error) {
#line 353
          tmp___5 = 1;
        } else {
#line 353
          tmp___5 = 0;
        }
        {
#line 353
        error(tmp___5, 0, (char const   *)tmp___4, progname, status & 127);
        }
      }
    }
#line 356
    return (127);
  }
#line 358
  if (! ((status & 127) == 0)) {
    {
#line 359
    abort();
    }
  }
#line 360
  if ((status & 65280) >> 8 == 127) {
#line 362
    if (exit_on_error) {
#line 362
      goto _L___1;
    } else
#line 362
    if (! null_stderr) {
      _L___1: /* CIL Label */ 
      {
#line 363
      tmp___6 = dcgettext((char const   *)((void *)0), "%s subprocess failed", 5);
      }
#line 363
      if (exit_on_error) {
#line 363
        tmp___7 = 1;
      } else {
#line 363
        tmp___7 = 0;
      }
      {
#line 363
      error(tmp___7, 0, (char const   *)tmp___6, progname);
      }
    }
#line 365
    return (127);
  }
#line 367
  return ((status & 65280) >> 8);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 312 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "./version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list___0 authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 60 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 66
  if (command_name) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 69
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 83
  tmp = dcgettext((char const   *)((void *)0), "(C)", 5);
#line 83
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2020);
#line 85
  fputs_unlocked((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stream);
#line 88
  tmp___0 = dcgettext((char const   *)((void *)0), "License GPLv3+: GNU GPL version 3 or later <%s>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n",
                      5);
#line 88
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___0,
          "https://gnu.org/licenses/gpl.html");
#line 95
  fputs_unlocked((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stream);
  }
  {
#line 99
  if (n_authors == 0UL) {
#line 99
    goto case_0;
  }
#line 103
  if (n_authors == 1UL) {
#line 103
    goto case_1;
  }
#line 107
  if (n_authors == 2UL) {
#line 107
    goto case_2;
  }
#line 111
  if (n_authors == 3UL) {
#line 111
    goto case_3;
  }
#line 116
  if (n_authors == 4UL) {
#line 116
    goto case_4;
  }
#line 123
  if (n_authors == 5UL) {
#line 123
    goto case_5;
  }
#line 130
  if (n_authors == 6UL) {
#line 130
    goto case_6;
  }
#line 138
  if (n_authors == 7UL) {
#line 138
    goto case_7;
  }
#line 146
  if (n_authors == 8UL) {
#line 146
    goto case_8;
  }
#line 155
  if (n_authors == 9UL) {
#line 155
    goto case_9;
  }
#line 164
  goto switch_default;
  case_0: /* CIL Label */ 
#line 102
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 105
  tmp___1 = dcgettext((char const   *)((void *)0), "Written by %s.\n", 5);
#line 105
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 106
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 109
  tmp___2 = dcgettext((char const   *)((void *)0), "Written by %s and %s.\n", 5);
#line 109
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 110
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 113
  tmp___3 = dcgettext((char const   *)((void *)0), "Written by %s, %s, and %s.\n",
                      5);
#line 113
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 115
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 120
  tmp___4 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\nand %s.\n",
                      5);
#line 120
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 122
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 127
  tmp___5 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, and %s.\n",
                      5);
#line 127
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 129
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 134
  tmp___6 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, and %s.\n",
                      5);
#line 134
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 137
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 142
  tmp___7 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, and %s.\n",
                      5);
#line 142
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 145
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 150
  tmp___8 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n",
                      5);
#line 150
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 154
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 159
  tmp___9 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n",
                      5);
#line 159
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 170
  tmp___10 = dcgettext((char const   *)((void *)0), "Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n",
                       5);
#line 170
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 174
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 182 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 189
  n_authors = (size_t )0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! *(authors + n_authors)) {
#line 189
      goto while_break;
    }
#line 189
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 192
  return;
}
}
#line 198 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list___0 authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 206
  n_authors = (size_t )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (n_authors < 10UL) {
      {
#line 206
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 206
      tmp = tmp___0;
#line 206
      authtab[n_authors] = tmp;
      }
#line 206
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 206
        goto while_break;
      }
    } else {
#line 206
      goto while_break;
    }
#line 206
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 211
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 213
  return;
}
}
#line 229
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 229 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list___0 authors ;

  {
  {
#line 236
  __builtin_va_start(authors, version);
#line 237
  version_etc_va(stream, command_name, package, version, authors);
#line 238
  __builtin_va_end(authors);
  }
#line 239
  return;
}
}
#line 241 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 244
  fputs_unlocked((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
#line 249
  tmp = dcgettext((char const   *)((void *)0), "Report bugs to: %s\n", 5);
#line 249
  printf((char const   */* __restrict  */)tmp, "bug-recutils@gnu.org");
#line 255
  tmp___0 = dcgettext((char const   *)((void *)0), "%s home page: <%s>\n", 5);
#line 255
  printf((char const   */* __restrict  */)tmp___0, "GNU recutils", "http://www.gnu.org/software/recutils/");
#line 260
  tmp___1 = dcgettext((char const   *)((void *)0), "General help using GNU software: <%s>\n",
                      5);
#line 260
  printf((char const   */* __restrict  */)tmp___1, "https://www.gnu.org/gethelp/");
  }
#line 262
  return;
}
}
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 72 "./vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            __builtin_va_list args ) ;
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 146 "./printf-args.h"
int printf_fetchargs(va_list___0 args , arguments *a ) ;
#line 188 "./printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 1776 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            __builtin_va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t n___0 ;
  char const   *mp ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___33 ;
  size_t __attribute__((__pure__))  tmp___34 ;
  size_t __attribute__((__pure__))  tmp___35 ;
  void *tmp___36 ;
  void *tmp___37 ;
  size_t __attribute__((__pure__))  tmp___38 ;
  int *tmp___39 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int *tmp___40 ;
  int arg ;
  unsigned int arg___0 ;
  int arg___1 ;
  unsigned int arg___2 ;
  int arg___3 ;
  unsigned int arg___4 ;
  long arg___5 ;
  unsigned long arg___6 ;
  long long arg___7 ;
  unsigned long long arg___8 ;
  double arg___9 ;
  long double arg___10 ;
  int arg___11 ;
  wint_t arg___12 ;
  char const   *arg___13 ;
  wchar_t const   *arg___14 ;
  void *arg___15 ;
  int saved_errno ;
  int *tmp___41 ;
  int *tmp___42 ;
  size_t n___2 ;
  size_t tmp___43 ;
  size_t __attribute__((__pure__))  tmp___44 ;
  size_t __attribute__((__pure__))  tmp___45 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___46 ;
  void *tmp___47 ;
  void *tmp___48 ;
  int *tmp___49 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___50 ;
  size_t __attribute__((__pure__))  tmp___51 ;
  size_t __attribute__((__pure__))  tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  size_t __attribute__((__pure__))  tmp___55 ;
  char *memory___4 ;
  void *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;

  {
  {
#line 1783
  tmp = printf_parse(format, & d, & a);
  }
#line 1783
  if (tmp < 0) {
#line 1785
    return ((char *)((void *)0));
  }
  {
#line 1793
  tmp___1 = printf_fetchargs(args, & a);
  }
#line 1793
  if (tmp___1 < 0) {
#line 1795
    if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
      {
#line 1795
      free((void *)d.dir);
      }
    }
#line 1795
    if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
      {
#line 1795
      free((void *)a.arg);
      }
    }
    {
#line 1796
    tmp___0 = __errno_location();
#line 1796
    *tmp___0 = 22;
    }
#line 1797
    return ((char *)((void *)0));
  }
  {
#line 1814
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1814
  buf_neededlength = (size_t )tmp___2;
  }
#line 1817
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1819
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1819
    buf = (char *)tmp___3;
#line 1820
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1825
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1825
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
#line 1825
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1825
    buf_memsize = tmp___4;
#line 1826
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1827
      goto out_of_memory_1;
    }
    {
#line 1828
    tmp___5 = malloc(buf_memsize);
#line 1828
    buf = (char *)tmp___5;
    }
#line 1829
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1830
      goto out_of_memory_1;
    }
#line 1831
    buf_malloced = buf;
  }
#line 1834
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1836
    result = resultbuf;
#line 1837
    allocated = *lengthp;
  } else {
#line 1841
    result = (char *)((void *)0);
#line 1842
    allocated = (size_t )0;
  }
#line 1844
  length = (size_t )0;
#line 1874
  cp = format;
#line 1874
  i = (size_t )0;
#line 1874
  dp = d.dir + 0;
  {
#line 1874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1876
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1878
      n = (size_t )(dp->dir_start - cp);
#line 1879
      tmp___6 = xsum(length, n);
#line 1879
      augmented_length = (size_t )tmp___6;
      }
#line 1881
      if (augmented_length > allocated) {
#line 1881
        if (allocated > 0UL) {
#line 1881
          if (allocated <= 9223372036854775807UL) {
#line 1881
            tmp___7 = allocated * 2UL;
          } else {
#line 1881
            tmp___7 = 0xffffffffffffffffUL;
          }
#line 1881
          allocated = tmp___7;
        } else {
#line 1881
          allocated = (size_t )12;
        }
#line 1881
        if (augmented_length > allocated) {
#line 1881
          allocated = augmented_length;
        }
#line 1881
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1881
          memory_size = allocated * sizeof(char );
        } else {
#line 1881
          memory_size = 0xffffffffffffffffUL;
        }
#line 1881
        if (memory_size == 0xffffffffffffffffUL) {
#line 1881
          goto out_of_memory;
        }
#line 1881
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1881
          tmp___8 = malloc(memory_size);
#line 1881
          memory = (char *)tmp___8;
          }
        } else
#line 1881
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1881
          tmp___8 = malloc(memory_size);
#line 1881
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1881
          tmp___9 = realloc((void *)result, memory_size);
#line 1881
          memory = (char *)tmp___9;
          }
        }
#line 1881
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1881
          goto out_of_memory;
        }
#line 1881
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1881
          if (length > 0UL) {
            {
#line 1881
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1881
        result = memory;
      }
#line 1885
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1887
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1888
        length = augmented_length;
        }
      } else {
        {
#line 1892
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1893
          tmp___10 = length;
#line 1893
          length ++;
#line 1893
          tmp___11 = cp;
#line 1893
          cp ++;
#line 1893
          *(result + tmp___10) = (char )*tmp___11;
#line 1892
          n --;
#line 1892
          if (! (n > 0UL)) {
#line 1892
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1897
    if (i == d.count) {
#line 1898
      goto while_break;
    }
#line 1901
    if ((int )dp->conversion == 37) {
#line 1905
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
#line 1906
        abort();
        }
      }
      {
#line 1907
      tmp___12 = xsum(length, (size_t )1);
#line 1907
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1908
      if (augmented_length___0 > allocated) {
#line 1908
        if (allocated > 0UL) {
#line 1908
          if (allocated <= 9223372036854775807UL) {
#line 1908
            tmp___13 = allocated * 2UL;
          } else {
#line 1908
            tmp___13 = 0xffffffffffffffffUL;
          }
#line 1908
          allocated = tmp___13;
        } else {
#line 1908
          allocated = (size_t )12;
        }
#line 1908
        if (augmented_length___0 > allocated) {
#line 1908
          allocated = augmented_length___0;
        }
#line 1908
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1908
          memory_size___0 = allocated * sizeof(char );
        } else {
#line 1908
          memory_size___0 = 0xffffffffffffffffUL;
        }
#line 1908
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1908
          goto out_of_memory;
        }
#line 1908
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1908
          tmp___14 = malloc(memory_size___0);
#line 1908
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1908
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1908
          tmp___14 = malloc(memory_size___0);
#line 1908
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1908
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1908
          memory___0 = (char *)tmp___15;
          }
        }
#line 1908
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1908
          goto out_of_memory;
        }
#line 1908
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1908
          if (length > 0UL) {
            {
#line 1908
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1908
        result = memory___0;
      }
#line 1909
      *(result + length) = (char )'%';
#line 1910
      length = augmented_length___0;
    } else {
#line 1914
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
#line 1915
        abort();
        }
      }
#line 1917
      if ((int )dp->conversion == 110) {
        {
#line 1921
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1921
          goto case_18;
        }
#line 1924
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1924
          goto case_19;
        }
#line 1927
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1927
          goto case_20;
        }
#line 1930
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1930
          goto case_21;
        }
#line 1933
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1933
          goto case_22;
        }
#line 1936
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1922
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1923
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1925
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1926
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1928
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1929
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1931
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1932
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1934
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1935
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1937
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4591
        type = (a.arg + dp->arg_index)->type;
#line 4592
        flags = dp->flags;
#line 4758
        fbp = buf;
#line 4759
        tmp___16 = fbp;
#line 4759
        fbp ++;
#line 4759
        *tmp___16 = (char )'%';
#line 4765
        if (flags & 1) {
#line 4766
          tmp___17 = fbp;
#line 4766
          fbp ++;
#line 4766
          *tmp___17 = (char )'\'';
        }
#line 4768
        if (flags & 2) {
#line 4769
          tmp___18 = fbp;
#line 4769
          fbp ++;
#line 4769
          *tmp___18 = (char )'-';
        }
#line 4770
        if (flags & 4) {
#line 4771
          tmp___19 = fbp;
#line 4771
          fbp ++;
#line 4771
          *tmp___19 = (char )'+';
        }
#line 4772
        if (flags & 8) {
#line 4773
          tmp___20 = fbp;
#line 4773
          fbp ++;
#line 4773
          *tmp___20 = (char )' ';
        }
#line 4774
        if (flags & 16) {
#line 4775
          tmp___21 = fbp;
#line 4775
          fbp ++;
#line 4775
          *tmp___21 = (char )'#';
        }
#line 4777
        if (flags & 64) {
#line 4778
          tmp___22 = fbp;
#line 4778
          fbp ++;
#line 4778
          *tmp___22 = (char )'I';
        }
#line 4782
        if (flags & 32) {
#line 4783
          tmp___23 = fbp;
#line 4783
          fbp ++;
#line 4783
          *tmp___23 = (char )'0';
        }
#line 4784
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4786
          n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4789
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4791
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   n___0 * sizeof(char ));
#line 4792
            fbp += n___0;
            }
          } else {
#line 4796
            mp = dp->width_start;
            {
#line 4797
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4798
              tmp___24 = fbp;
#line 4798
              fbp ++;
#line 4798
              tmp___25 = mp;
#line 4798
              mp ++;
#line 4798
              *tmp___24 = (char )*tmp___25;
#line 4797
              n___0 --;
#line 4797
              if (! (n___0 > 0UL)) {
#line 4797
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 4805
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4807
          n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4810
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4812
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   n___1 * sizeof(char ));
#line 4813
            fbp += n___1;
            }
          } else {
#line 4817
            mp___0 = dp->precision_start;
            {
#line 4818
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 4819
              tmp___26 = fbp;
#line 4819
              fbp ++;
#line 4819
              tmp___27 = mp___0;
#line 4819
              mp___0 ++;
#line 4819
              *tmp___26 = (char )*tmp___27;
#line 4818
              n___1 --;
#line 4818
              if (! (n___1 > 0UL)) {
#line 4818
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        {
#line 4828
        if ((unsigned int )type == 10U) {
#line 4828
          goto case_10;
        }
#line 4828
        if ((unsigned int )type == 9U) {
#line 4828
          goto case_10;
        }
#line 4844
        if ((unsigned int )type == 16U) {
#line 4844
          goto case_16;
        }
#line 4844
        if ((unsigned int )type == 14U) {
#line 4844
          goto case_16;
        }
#line 4844
        if ((unsigned int )type == 8U) {
#line 4844
          goto case_16;
        }
#line 4844
        if ((unsigned int )type == 7U) {
#line 4844
          goto case_16;
        }
#line 4848
        if ((unsigned int )type == 12U) {
#line 4848
          goto case_12;
        }
#line 4851
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4835
        tmp___28 = fbp;
#line 4835
        fbp ++;
#line 4835
        *tmp___28 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4846
        tmp___29 = fbp;
#line 4846
        fbp ++;
#line 4846
        *tmp___29 = (char )'l';
#line 4847
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4849
        tmp___30 = fbp;
#line 4849
        fbp ++;
#line 4849
        *tmp___30 = (char )'L';
#line 4850
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4852
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4859
        *fbp = dp->conversion;
#line 4909
        *(fbp + 1) = (char )'\000';
#line 4916
        prefix_count = 0U;
#line 4917
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4919
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4920
            abort();
            }
          }
#line 4921
          tmp___31 = prefix_count;
#line 4921
          prefix_count ++;
#line 4921
          prefixes[tmp___31] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4923
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4925
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4926
            abort();
            }
          }
#line 4927
          tmp___32 = prefix_count;
#line 4927
          prefix_count ++;
#line 4927
          prefixes[tmp___32] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4939
        tmp___38 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        }
#line 4939
        if (tmp___38 > (size_t __attribute__((__pure__))  )allocated) {
#line 4939
          if (allocated > 0UL) {
#line 4939
            if (allocated <= 9223372036854775807UL) {
#line 4939
              tmp___33 = allocated * 2UL;
            } else {
#line 4939
              tmp___33 = 0xffffffffffffffffUL;
            }
#line 4939
            allocated = tmp___33;
          } else {
#line 4939
            allocated = (size_t )12;
          }
          {
#line 4939
          tmp___35 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          }
#line 4939
          if (tmp___35 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4939
            tmp___34 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4939
            allocated = (size_t )tmp___34;
            }
          }
#line 4939
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4939
            memory_size___1 = allocated * sizeof(char );
          } else {
#line 4939
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 4939
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4939
            goto out_of_memory;
          }
#line 4939
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4939
            tmp___36 = malloc(memory_size___1);
#line 4939
            memory___1 = (char *)tmp___36;
            }
          } else
#line 4939
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4939
            tmp___36 = malloc(memory_size___1);
#line 4939
            memory___1 = (char *)tmp___36;
            }
          } else {
            {
#line 4939
            tmp___37 = realloc((void *)result, memory_size___1);
#line 4939
            memory___1 = (char *)tmp___37;
            }
          }
#line 4939
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4939
            goto out_of_memory;
          }
#line 4939
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4939
            if (length > 0UL) {
              {
#line 4939
              memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4939
          result = memory___1;
        }
        {
#line 4944
        *(result + length) = (char )'\000';
#line 4947
        tmp___39 = __errno_location();
#line 4947
        orig_errno = *tmp___39;
        }
        {
#line 4949
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4951
          count = -1;
#line 4954
          retcount = 0;
#line 4955
          maxlen = allocated - length;
#line 4958
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4959
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
          {
#line 4960
          maxlen *= sizeof(char ) / sizeof(char );
#line 5002
          tmp___40 = __errno_location();
#line 5002
          *tmp___40 = 0;
          }
          {
#line 5005
          if ((unsigned int )type == 1U) {
#line 5005
            goto case_1;
          }
#line 5011
          if ((unsigned int )type == 2U) {
#line 5011
            goto case_2___0;
          }
#line 5017
          if ((unsigned int )type == 3U) {
#line 5017
            goto case_3;
          }
#line 5023
          if ((unsigned int )type == 4U) {
#line 5023
            goto case_4;
          }
#line 5029
          if ((unsigned int )type == 5U) {
#line 5029
            goto case_5;
          }
#line 5035
          if ((unsigned int )type == 6U) {
#line 5035
            goto case_6;
          }
#line 5041
          if ((unsigned int )type == 7U) {
#line 5041
            goto case_7___0;
          }
#line 5047
          if ((unsigned int )type == 8U) {
#line 5047
            goto case_8___0;
          }
#line 5053
          if ((unsigned int )type == 9U) {
#line 5053
            goto case_9___0;
          }
#line 5059
          if ((unsigned int )type == 10U) {
#line 5059
            goto case_10___0;
          }
#line 5065
          if ((unsigned int )type == 11U) {
#line 5065
            goto case_11;
          }
#line 5071
          if ((unsigned int )type == 12U) {
#line 5071
            goto case_12___0;
          }
#line 5077
          if ((unsigned int )type == 13U) {
#line 5077
            goto case_13;
          }
#line 5084
          if ((unsigned int )type == 14U) {
#line 5084
            goto case_14___0;
          }
#line 5091
          if ((unsigned int )type == 15U) {
#line 5091
            goto case_15;
          }
#line 5098
          if ((unsigned int )type == 16U) {
#line 5098
            goto case_16___0;
          }
#line 5105
          if ((unsigned int )type == 17U) {
#line 5105
            goto case_17;
          }
#line 5111
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 5007
          arg = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 5008
          if (prefix_count == 0U) {
#line 5008
            goto case_0;
          }
#line 5008
          if (prefix_count == 1U) {
#line 5008
            goto case_1___0;
          }
#line 5008
          if (prefix_count == 2U) {
#line 5008
            goto case_2;
          }
#line 5008
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg, & count);
          }
#line 5008
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg,
                              & count);
          }
#line 5008
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 5008
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg, & count);
          }
#line 5008
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 5008
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 5010
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 5013
          arg___0 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 5014
          if (prefix_count == 0U) {
#line 5014
            goto case_0___0;
          }
#line 5014
          if (prefix_count == 1U) {
#line 5014
            goto case_1___1;
          }
#line 5014
          if (prefix_count == 2U) {
#line 5014
            goto case_2___1;
          }
#line 5014
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 5014
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___0, & count);
          }
#line 5014
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 5014
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___0,
                              & count);
          }
#line 5014
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 5014
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___0, & count);
          }
#line 5014
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 5014
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 5016
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 5019
          arg___1 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 5020
          if (prefix_count == 0U) {
#line 5020
            goto case_0___1;
          }
#line 5020
          if (prefix_count == 1U) {
#line 5020
            goto case_1___2;
          }
#line 5020
          if (prefix_count == 2U) {
#line 5020
            goto case_2___2;
          }
#line 5020
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 5020
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___1, & count);
          }
#line 5020
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 5020
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___1,
                              & count);
          }
#line 5020
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 5020
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___1, & count);
          }
#line 5020
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 5020
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 5022
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 5025
          arg___2 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 5026
          if (prefix_count == 0U) {
#line 5026
            goto case_0___2;
          }
#line 5026
          if (prefix_count == 1U) {
#line 5026
            goto case_1___3;
          }
#line 5026
          if (prefix_count == 2U) {
#line 5026
            goto case_2___3;
          }
#line 5026
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 5026
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___2, & count);
          }
#line 5026
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 5026
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___2,
                              & count);
          }
#line 5026
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 5026
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___2, & count);
          }
#line 5026
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 5026
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 5028
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 5031
          arg___3 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 5032
          if (prefix_count == 0U) {
#line 5032
            goto case_0___3;
          }
#line 5032
          if (prefix_count == 1U) {
#line 5032
            goto case_1___4;
          }
#line 5032
          if (prefix_count == 2U) {
#line 5032
            goto case_2___4;
          }
#line 5032
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 5032
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___3, & count);
          }
#line 5032
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 5032
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___3,
                              & count);
          }
#line 5032
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 5032
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___3, & count);
          }
#line 5032
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 5032
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 5034
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 5037
          arg___4 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 5038
          if (prefix_count == 0U) {
#line 5038
            goto case_0___4;
          }
#line 5038
          if (prefix_count == 1U) {
#line 5038
            goto case_1___5;
          }
#line 5038
          if (prefix_count == 2U) {
#line 5038
            goto case_2___5;
          }
#line 5038
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 5038
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___4, & count);
          }
#line 5038
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 5038
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___4,
                              & count);
          }
#line 5038
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 5038
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___4, & count);
          }
#line 5038
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 5038
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 5040
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 5043
          arg___5 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 5044
          if (prefix_count == 0U) {
#line 5044
            goto case_0___5;
          }
#line 5044
          if (prefix_count == 1U) {
#line 5044
            goto case_1___6;
          }
#line 5044
          if (prefix_count == 2U) {
#line 5044
            goto case_2___6;
          }
#line 5044
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 5044
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___5, & count);
          }
#line 5044
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 5044
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___5,
                              & count);
          }
#line 5044
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 5044
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___5, & count);
          }
#line 5044
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 5044
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 5046
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 5049
          arg___6 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 5050
          if (prefix_count == 0U) {
#line 5050
            goto case_0___6;
          }
#line 5050
          if (prefix_count == 1U) {
#line 5050
            goto case_1___7;
          }
#line 5050
          if (prefix_count == 2U) {
#line 5050
            goto case_2___7;
          }
#line 5050
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___6, & count);
          }
#line 5050
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___6,
                              & count);
          }
#line 5050
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 5050
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___6, & count);
          }
#line 5050
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 5050
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 5052
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 5055
          arg___7 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 5056
          if (prefix_count == 0U) {
#line 5056
            goto case_0___7;
          }
#line 5056
          if (prefix_count == 1U) {
#line 5056
            goto case_1___8;
          }
#line 5056
          if (prefix_count == 2U) {
#line 5056
            goto case_2___8;
          }
#line 5056
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___7, & count);
          }
#line 5056
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___7,
                              & count);
          }
#line 5056
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 5056
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___7, & count);
          }
#line 5056
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 5056
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 5058
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 5061
          arg___8 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 5062
          if (prefix_count == 0U) {
#line 5062
            goto case_0___8;
          }
#line 5062
          if (prefix_count == 1U) {
#line 5062
            goto case_1___9;
          }
#line 5062
          if (prefix_count == 2U) {
#line 5062
            goto case_2___9;
          }
#line 5062
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 5062
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___8, & count);
          }
#line 5062
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 5062
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___8,
                              & count);
          }
#line 5062
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 5062
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___8, & count);
          }
#line 5062
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 5062
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 5064
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 5067
          arg___9 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 5068
          if (prefix_count == 0U) {
#line 5068
            goto case_0___9;
          }
#line 5068
          if (prefix_count == 1U) {
#line 5068
            goto case_1___10;
          }
#line 5068
          if (prefix_count == 2U) {
#line 5068
            goto case_2___10;
          }
#line 5068
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 5068
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___9, & count);
          }
#line 5068
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 5068
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___9,
                              & count);
          }
#line 5068
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 5068
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___9, & count);
          }
#line 5068
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 5068
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 5070
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 5073
          arg___10 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 5074
          if (prefix_count == 0U) {
#line 5074
            goto case_0___10;
          }
#line 5074
          if (prefix_count == 1U) {
#line 5074
            goto case_1___11;
          }
#line 5074
          if (prefix_count == 2U) {
#line 5074
            goto case_2___11;
          }
#line 5074
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 5074
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___10, & count);
          }
#line 5074
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 5074
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___10,
                              & count);
          }
#line 5074
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 5074
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___10, & count);
          }
#line 5074
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 5074
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 5076
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5079
          arg___11 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5080
          if (prefix_count == 0U) {
#line 5080
            goto case_0___11;
          }
#line 5080
          if (prefix_count == 1U) {
#line 5080
            goto case_1___12;
          }
#line 5080
          if (prefix_count == 2U) {
#line 5080
            goto case_2___12;
          }
#line 5080
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5080
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___11, & count);
          }
#line 5080
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5080
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___11,
                              & count);
          }
#line 5080
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5080
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___11, & count);
          }
#line 5080
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5080
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5082
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5086
          arg___12 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5087
          if (prefix_count == 0U) {
#line 5087
            goto case_0___12;
          }
#line 5087
          if (prefix_count == 1U) {
#line 5087
            goto case_1___13;
          }
#line 5087
          if (prefix_count == 2U) {
#line 5087
            goto case_2___13;
          }
#line 5087
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5087
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___12, & count);
          }
#line 5087
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5087
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___12,
                              & count);
          }
#line 5087
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5087
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___12, & count);
          }
#line 5087
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5087
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5089
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5093
          arg___13 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5094
          if (prefix_count == 0U) {
#line 5094
            goto case_0___13;
          }
#line 5094
          if (prefix_count == 1U) {
#line 5094
            goto case_1___14;
          }
#line 5094
          if (prefix_count == 2U) {
#line 5094
            goto case_2___14;
          }
#line 5094
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5094
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___13, & count);
          }
#line 5094
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5094
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___13,
                              & count);
          }
#line 5094
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5094
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___13, & count);
          }
#line 5094
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5094
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5096
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5100
          arg___14 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5101
          if (prefix_count == 0U) {
#line 5101
            goto case_0___14;
          }
#line 5101
          if (prefix_count == 1U) {
#line 5101
            goto case_1___15;
          }
#line 5101
          if (prefix_count == 2U) {
#line 5101
            goto case_2___15;
          }
#line 5101
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5101
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___14, & count);
          }
#line 5101
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5101
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___14,
                              & count);
          }
#line 5101
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5101
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___14, & count);
          }
#line 5101
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5101
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5103
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5107
          arg___15 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5108
          if (prefix_count == 0U) {
#line 5108
            goto case_0___15;
          }
#line 5108
          if (prefix_count == 1U) {
#line 5108
            goto case_1___16;
          }
#line 5108
          if (prefix_count == 2U) {
#line 5108
            goto case_2___16;
          }
#line 5108
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5108
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___15, & count);
          }
#line 5108
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5108
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___15,
                              & count);
          }
#line 5108
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5108
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___15, & count);
          }
#line 5108
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5108
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5110
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5112
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5120
          if (count >= 0) {
#line 5124
            if ((size_t )((unsigned int )count) < maxlen) {
#line 5124
              if ((int )*((result + length) + count) != 0) {
                {
#line 5126
                abort();
                }
              }
            }
#line 5128
            if (retcount > count) {
#line 5129
              count = retcount;
            }
          } else
#line 5135
          if ((int )*(fbp + 1) != 0) {
#line 5139
            *(fbp + 1) = (char )'\000';
#line 5140
            goto __Cont;
          } else
#line 5145
          if (! (retcount < 0)) {
#line 5188
            count = retcount;
          }
#line 5194
          if (count < 0) {
            {
#line 5198
            tmp___41 = __errno_location();
#line 5198
            saved_errno = *tmp___41;
            }
#line 5199
            if (saved_errno == 0) {
#line 5201
              if ((int )dp->conversion == 99) {
#line 5202
                saved_errno = 84;
              } else
#line 5201
              if ((int )dp->conversion == 115) {
#line 5202
                saved_errno = 84;
              } else {
#line 5204
                saved_errno = 22;
              }
            }
#line 5207
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5207
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5208
                free((void *)result);
                }
              }
            }
#line 5209
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5210
              free((void *)buf_malloced);
              }
            }
#line 5211
            if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
              {
#line 5211
              free((void *)d.dir);
              }
            }
#line 5211
            if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
              {
#line 5211
              free((void *)a.arg);
              }
            }
            {
#line 5213
            tmp___42 = __errno_location();
#line 5213
            *tmp___42 = saved_errno;
            }
#line 5214
            return ((char *)((void *)0));
          }
#line 5223
          if ((size_t )((unsigned int )count + 1U) >= maxlen) {
#line 5228
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5229
              goto overflow;
            } else {
#line 5241
              if (allocated <= 9223372036854775807UL) {
#line 5241
                tmp___43 = allocated * 2UL;
              } else {
#line 5241
                tmp___43 = 0xffffffffffffffffUL;
              }
              {
#line 5241
              tmp___44 = xsum(length, (((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 5241
              tmp___45 = xmax((size_t )tmp___44, tmp___43);
#line 5241
              n___2 = (size_t )tmp___45;
              }
#line 5248
              if (n___2 > allocated) {
#line 5248
                if (allocated > 0UL) {
#line 5248
                  if (allocated <= 9223372036854775807UL) {
#line 5248
                    tmp___46 = allocated * 2UL;
                  } else {
#line 5248
                    tmp___46 = 0xffffffffffffffffUL;
                  }
#line 5248
                  allocated = tmp___46;
                } else {
#line 5248
                  allocated = (size_t )12;
                }
#line 5248
                if (n___2 > allocated) {
#line 5248
                  allocated = n___2;
                }
#line 5248
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5248
                  memory_size___2 = allocated * sizeof(char );
                } else {
#line 5248
                  memory_size___2 = 0xffffffffffffffffUL;
                }
#line 5248
                if (memory_size___2 == 0xffffffffffffffffUL) {
#line 5248
                  goto out_of_memory;
                }
#line 5248
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5248
                  tmp___47 = malloc(memory_size___2);
#line 5248
                  memory___2 = (char *)tmp___47;
                  }
                } else
#line 5248
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5248
                  tmp___47 = malloc(memory_size___2);
#line 5248
                  memory___2 = (char *)tmp___47;
                  }
                } else {
                  {
#line 5248
                  tmp___48 = realloc((void *)result, memory_size___2);
#line 5248
                  memory___2 = (char *)tmp___48;
                  }
                }
#line 5248
                if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 5248
                  goto out_of_memory;
                }
#line 5248
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5248
                  if (length > 0UL) {
                    {
#line 5248
                    memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5248
                result = memory___2;
              }
#line 5249
              goto __Cont;
            }
          }
#line 5545
          length += (size_t )count;
#line 5546
          goto while_break___3;
          __Cont: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 5548
        tmp___49 = __errno_location();
#line 5548
        *tmp___49 = orig_errno;
        }
      }
    }
#line 1874
    cp = dp->dir_end;
#line 1874
    i ++;
#line 1874
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5556
  tmp___55 = xsum(length, (size_t )1);
  }
#line 5556
  if (tmp___55 > (size_t __attribute__((__pure__))  )allocated) {
#line 5556
    if (allocated > 0UL) {
#line 5556
      if (allocated <= 9223372036854775807UL) {
#line 5556
        tmp___50 = allocated * 2UL;
      } else {
#line 5556
        tmp___50 = 0xffffffffffffffffUL;
      }
#line 5556
      allocated = tmp___50;
    } else {
#line 5556
      allocated = (size_t )12;
    }
    {
#line 5556
    tmp___52 = xsum(length, (size_t )1);
    }
#line 5556
    if (tmp___52 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5556
      tmp___51 = xsum(length, (size_t )1);
#line 5556
      allocated = (size_t )tmp___51;
      }
    }
#line 5556
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5556
      memory_size___3 = allocated * sizeof(char );
    } else {
#line 5556
      memory_size___3 = 0xffffffffffffffffUL;
    }
#line 5556
    if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5556
      goto out_of_memory;
    }
#line 5556
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5556
      tmp___53 = malloc(memory_size___3);
#line 5556
      memory___3 = (char *)tmp___53;
      }
    } else
#line 5556
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5556
      tmp___53 = malloc(memory_size___3);
#line 5556
      memory___3 = (char *)tmp___53;
      }
    } else {
      {
#line 5556
      tmp___54 = realloc((void *)result, memory_size___3);
#line 5556
      memory___3 = (char *)tmp___54;
      }
    }
#line 5556
    if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5556
      goto out_of_memory;
    }
#line 5556
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5556
      if (length > 0UL) {
        {
#line 5556
        memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5556
    result = memory___3;
  }
#line 5557
  *(result + length) = (char )'\000';
#line 5559
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5559
    if (length + 1UL < allocated) {
      {
#line 5564
      tmp___56 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5564
      memory___4 = (char *)tmp___56;
      }
#line 5565
      if ((unsigned long )memory___4 != (unsigned long )((void *)0)) {
#line 5566
        result = memory___4;
      }
    }
  }
#line 5569
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5570
    free((void *)buf_malloced);
    }
  }
#line 5571
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5571
    free((void *)d.dir);
    }
  }
#line 5571
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5571
    free((void *)a.arg);
    }
  }
#line 5572
  *lengthp = length;
#line 5577
  return (result);
  overflow: 
#line 5581
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5581
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5582
      free((void *)result);
      }
    }
  }
#line 5583
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5584
    free((void *)buf_malloced);
    }
  }
#line 5585
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5585
    free((void *)d.dir);
    }
  }
#line 5585
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5585
    free((void *)a.arg);
    }
  }
  {
#line 5586
  tmp___57 = __errno_location();
#line 5586
  *tmp___57 = 75;
  }
#line 5587
  return ((char *)((void *)0));
  out_of_memory: 
#line 5591
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5591
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5592
      free((void *)result);
      }
    }
  }
#line 5593
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5594
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
#line 5596
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5596
    free((void *)d.dir);
    }
  }
#line 5596
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5596
    free((void *)a.arg);
    }
  }
  {
#line 5597
  tmp___58 = __errno_location();
#line 5597
  *tmp___58 = 12;
  }
#line 5598
  return ((char *)((void *)0));
}
}
/* compiler builtin: 
   void __builtin_unreachable(void) ;  */
#line 21 "./utimens.h"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
#line 22
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 23
int lutimens(char const   *file , struct timespec  const  *timespec ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 224
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
#line 249
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 272
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) utimensat)(int __fd ,
                                                                                      char const   *__path ,
                                                                                      struct timespec  const  *__times ,
                                                                                      int __flags ) ;
#line 368
extern  __attribute__((__nothrow__)) int futimens(int __fd , struct timespec  const  *__times ) ;
#line 395
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
#line 428
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
#line 448
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 448 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 451
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 451
  return (tmp);
}
}
#line 455
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 455 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 458
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 458
  return (tmp);
}
}
#line 462
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 462 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 465
  tmp = __fxstat(1, __fd, __statbuf);
  }
#line 465
  return (tmp);
}
}
#line 469
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
#line 469 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  {
#line 473
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  }
#line 473
  return (tmp);
}
}
#line 478
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 478 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 481
  tmp = __xmknod(0, __path, __mode, & __dev);
  }
#line 481
  return (tmp);
}
}
#line 486
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 486 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 490
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 490
  return (tmp);
}
}
#line 497
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 497 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 500
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 500
  return (tmp);
}
}
#line 504
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
#line 504 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 507
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 507
  return (tmp);
}
}
#line 511
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
#line 511 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 514
  tmp = __fxstat64(1, __fd, __statbuf);
  }
#line 514
  return (tmp);
}
}
#line 518
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
#line 518 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  {
#line 522
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  }
#line 522
  return (tmp);
}
}
#line 135 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utimes)(char const   *__file ,
                                                                                   struct timeval  const  *__tvp ) ;
#line 151
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval  const  *__tvp ) ;
#line 65 "./stat-time.h"
__inline long __attribute__((__pure__))  get_stat_atime_ns(struct stat  const  *st ) 
{ 


  {
#line 69
  return ((long __attribute__((__pure__))  )st->st_atim.tv_nsec);
}
}
#line 78 "./stat-time.h"
__inline long __attribute__((__pure__))  get_stat_ctime_ns(struct stat  const  *st ) 
{ 


  {
#line 82
  return ((long __attribute__((__pure__))  )st->st_ctim.tv_nsec);
}
}
#line 91 "./stat-time.h"
__inline long __attribute__((__pure__))  get_stat_mtime_ns(struct stat  const  *st ) 
{ 


  {
#line 95
  return ((long __attribute__((__pure__))  )st->st_mtim.tv_nsec);
}
}
#line 104 "./stat-time.h"
__inline long __attribute__((__pure__))  get_stat_birthtime_ns(struct stat  const  *st  __attribute__((__unused__)) ) 
{ 


  {
#line 112
  return ((long __attribute__((__pure__))  )0);
}
}
#line 117 "./stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_atime(struct stat  const  *st ) 
{ 


  {
#line 121
  return ((struct timespec  __attribute__((__pure__)) )st->st_atim);
}
}
#line 131 "./stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_ctime(struct stat  const  *st ) 
{ 


  {
#line 135
  return ((struct timespec  __attribute__((__pure__)) )st->st_ctim);
}
}
#line 145 "./stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_mtime(struct stat  const  *st ) 
{ 


  {
#line 149
  return ((struct timespec  __attribute__((__pure__)) )st->st_mtim);
}
}
#line 160 "./stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_birthtime(struct stat  const  *st  __attribute__((__unused__)) ) 
{ 
  struct timespec t ;

  {
#line 183
  t.tv_sec = (__time_t )-1;
#line 184
  t.tv_nsec = (__syscall_slong_t )-1;
#line 202
  return ((struct timespec  __attribute__((__pure__)) )t);
}
}
#line 210 "./stat-time.h"
__inline int stat_time_normalize(int result , struct stat *st  __attribute__((__unused__)) ) 
{ 


  {
#line 243
  return (result);
}
}
#line 53 "./timespec.h"
__inline struct timespec make_timespec(time_t s , long ns ) 
{ 
  struct timespec r ;

  {
#line 57
  r.tv_sec = s;
#line 58
  r.tv_nsec = ns;
#line 59
  return (r);
}
}
#line 88 "./timespec.h"
__inline int __attribute__((__pure__))  timespec_cmp(struct timespec a , struct timespec b ) 
{ 


  {
#line 91
  if (a.tv_sec < b.tv_sec) {
#line 92
    return ((int __attribute__((__pure__))  )-1);
  }
#line 93
  if (a.tv_sec > b.tv_sec) {
#line 94
    return ((int __attribute__((__pure__))  )1);
  }
#line 98
  if (-1L <= a.tv_nsec) {
#line 98
    if (! (a.tv_nsec <= 2000000000L)) {
      {
#line 98
      __builtin_unreachable();
      }
    }
  } else {
    {
#line 98
    __builtin_unreachable();
    }
  }
#line 99
  if (-1L <= b.tv_nsec) {
#line 99
    if (! (b.tv_nsec <= 2000000000L)) {
      {
#line 99
      __builtin_unreachable();
      }
    }
  } else {
    {
#line 99
    __builtin_unreachable();
    }
  }
#line 101
  return ((int __attribute__((__pure__))  )(a.tv_nsec - b.tv_nsec));
}
}
#line 106 "./timespec.h"
__inline int __attribute__((__pure__))  timespec_sign(struct timespec a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 109
  if (a.tv_sec < 0L) {
#line 109
    tmp___0 = -1;
  } else {
#line 109
    if (a.tv_sec) {
#line 109
      tmp = 1;
    } else
#line 109
    if (a.tv_nsec) {
#line 109
      tmp = 1;
    } else {
#line 109
      tmp = 0;
    }
#line 109
    tmp___0 = tmp;
  }
#line 109
  return ((int __attribute__((__pure__))  )tmp___0);
}
}
#line 120 "./timespec.h"
__inline double timespectod(struct timespec a ) 
{ 


  {
#line 123
  return ((double )a.tv_sec + (double )a.tv_nsec / 1e9);
}
}
#line 127
void ( __attribute__((__nonnull__(1))) gettime)(struct timespec *ts ) ;
#line 75 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/utimens.c"
static int utimensat_works_really  ;
#line 76 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/utimens.c"
static int lutimensat_works_really  ;
#line 86 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/utimens.c"
static int validate_timespec(struct timespec *timespec ) 
{ 
  int result ;
  int utime_omit_count ;
  int *tmp ;

  {
#line 89
  result = 0;
#line 90
  utime_omit_count = 0;
#line 91
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
#line 91
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
#line 91
      if (0L <= (timespec + 0)->tv_nsec) {
#line 91
        if ((timespec + 0)->tv_nsec < 1000000000L) {
#line 91
          goto _L___0;
        } else {
          {
#line 100
          tmp = __errno_location();
#line 100
          *tmp = 22;
          }
#line 101
          return (-1);
        }
      } else {
        {
#line 100
        tmp = __errno_location();
#line 100
        *tmp = 22;
        }
#line 101
        return (-1);
      }
    } else {
#line 91
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 91
  if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
#line 91
    if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
#line 91
      if (0L <= (timespec + 1)->tv_nsec) {
#line 91
        if (! ((timespec + 1)->tv_nsec < 1000000000L)) {
          {
#line 100
          tmp = __errno_location();
#line 100
          *tmp = 22;
          }
#line 101
          return (-1);
        }
      } else {
        {
#line 100
        tmp = __errno_location();
#line 100
        *tmp = 22;
        }
#line 101
        return (-1);
      }
    }
  }
#line 107
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 107
    goto _L___1;
  } else
#line 107
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    _L___1: /* CIL Label */ 
#line 110
    (timespec + 0)->tv_sec = (__time_t )0;
#line 111
    result = 1;
#line 112
    if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 113
      utime_omit_count ++;
    }
  }
#line 115
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 115
    goto _L___2;
  } else
#line 115
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    _L___2: /* CIL Label */ 
#line 118
    (timespec + 1)->tv_sec = (__time_t )0;
#line 119
    result = 1;
#line 120
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 121
      utime_omit_count ++;
    }
  }
#line 123
  return (result + (utime_omit_count == 1));
}
}
#line 132 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/utimens.c"
static _Bool update_timespec(struct stat  const  *statbuf , struct timespec **ts ) 
{ 
  struct timespec *timespec ;
  struct timespec  __attribute__((__pure__)) tmp ;
  struct timespec  __attribute__((__pure__)) tmp___0 ;

  {
#line 135
  timespec = *ts;
#line 136
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 136
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 138
      return ((_Bool)1);
    }
  }
#line 139
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 139
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 142
      *ts = (struct timespec *)((void *)0);
#line 143
      return ((_Bool)0);
    }
  }
#line 146
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    {
#line 147
    tmp = get_stat_atime(statbuf);
#line 147
    *(timespec + 0) = (struct timespec )tmp;
    }
  } else
#line 148
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    {
#line 149
    gettime(timespec + 0);
    }
  }
#line 151
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    {
#line 152
    tmp___0 = get_stat_mtime(statbuf);
#line 152
    *(timespec + 1) = (struct timespec )tmp___0;
    }
  } else
#line 153
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    {
#line 154
    gettime(timespec + 1);
    }
  }
#line 156
  return ((_Bool)0);
}
}
#line 169 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/utimens.c"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct timespec  __attribute__((__pure__)) tmp___4 ;
  struct timespec  __attribute__((__pure__)) tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  struct timeval timeval[2] ;
  struct timeval *t ;
  int tmp___14 ;
  _Bool abig ;
  _Bool mbig ;
  time_t adiff ;
  time_t mdiff ;
  struct timeval *tt ;
  struct timeval truncated_timeval[2] ;
  long __attribute__((__pure__))  tmp___15 ;
  long __attribute__((__pure__))  tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 173
  if (timespec) {
#line 173
    tmp = adjusted_timespec;
  } else {
#line 173
    tmp = (struct timespec *)((void *)0);
  }
#line 173
  ts = tmp;
#line 174
  adjustment_needed = 0;
#line 177
  if (ts) {
    {
#line 179
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 180
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 181
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 183
  if (adjustment_needed < 0) {
#line 184
    return (-1);
  }
#line 189
  if (fd < 0) {
#line 189
    if (! file) {
      {
#line 191
      tmp___0 = __errno_location();
#line 191
      *tmp___0 = 9;
      }
#line 192
      return (-1);
    }
  }
#line 218
  if (0 <= utimensat_works_really) {
#line 234
    if (adjustment_needed == 2) {
#line 236
      if (fd < 0) {
        {
#line 236
        tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 236
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 236
        tmp___2 = fstat(fd, & st);
#line 236
        tmp___3 = tmp___2;
        }
      }
#line 236
      if (tmp___3) {
#line 237
        return (-1);
      }
#line 238
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 239
        tmp___4 = get_stat_atime((struct stat  const  *)(& st));
#line 239
        *(ts + 0) = (struct timespec )tmp___4;
        }
      } else
#line 240
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 241
        tmp___5 = get_stat_mtime((struct stat  const  *)(& st));
#line 241
        *(ts + 1) = (struct timespec )tmp___5;
        }
      }
#line 243
      adjustment_needed ++;
    }
#line 247
    if (fd < 0) {
      {
#line 249
      result = utimensat(-100, file, (struct timespec  const  *)ts, 0);
      }
#line 258
      if (0 < result) {
        {
#line 259
        tmp___6 = __errno_location();
#line 259
        *tmp___6 = 38;
        }
      }
#line 261
      if (result == 0) {
#line 263
        utimensat_works_really = 1;
#line 264
        return (result);
      } else {
        {
#line 261
        tmp___7 = __errno_location();
        }
#line 261
        if (*tmp___7 != 38) {
#line 263
          utimensat_works_really = 1;
#line 264
          return (result);
        }
      }
    }
#line 269
    if (0 <= fd) {
      {
#line 271
      result = futimens(fd, (struct timespec  const  *)ts);
      }
#line 274
      if (0 < result) {
        {
#line 275
        tmp___8 = __errno_location();
#line 275
        *tmp___8 = 38;
        }
      }
#line 277
      if (result == 0) {
#line 279
        utimensat_works_really = 1;
#line 280
        return (result);
      } else {
        {
#line 277
        tmp___9 = __errno_location();
        }
#line 277
        if (*tmp___9 != 38) {
#line 279
          utimensat_works_really = 1;
#line 280
          return (result);
        }
      }
    }
  }
#line 285
  utimensat_works_really = -1;
#line 286
  lutimensat_works_really = -1;
#line 377
  if (adjustment_needed) {
#line 377
    goto _L;
  } else
#line 377
  if (0) {
    _L: /* CIL Label */ 
#line 379
    if (adjustment_needed != 3) {
#line 379
      if (fd < 0) {
        {
#line 379
        tmp___10 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 379
        tmp___12 = tmp___10;
        }
      } else {
        {
#line 379
        tmp___11 = fstat(fd, & st);
#line 379
        tmp___12 = tmp___11;
        }
      }
#line 379
      if (tmp___12) {
#line 381
        return (-1);
      }
    }
#line 382
    if (ts) {
      {
#line 382
      tmp___13 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 382
      if (tmp___13) {
#line 383
        return (0);
      }
    }
  }
#line 390
  if (ts) {
#line 392
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 393
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 394
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 395
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 396
    t = timeval;
  } else {
#line 399
    t = (struct timeval *)((void *)0);
  }
#line 401
  if (fd < 0) {
    {
#line 404
    tmp___14 = futimesat(-100, file, (struct timeval  const  *)t);
    }
#line 404
    return (tmp___14);
  } else {
    {
#line 425
    tmp___18 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
    }
#line 425
    if (tmp___18 == 0) {
#line 433
      if (t) {
#line 435
        abig = (_Bool )(500000L <= (t + 0)->tv_usec);
#line 436
        mbig = (_Bool )(500000L <= (t + 1)->tv_usec);
#line 437
        if ((int )abig | (int )mbig) {
          {
#line 437
          tmp___17 = fstat(fd, & st);
          }
#line 437
          if (tmp___17 == 0) {
#line 441
            adiff = st.st_atim.tv_sec - (t + 0)->tv_sec;
#line 442
            mdiff = st.st_mtim.tv_sec - (t + 1)->tv_sec;
#line 444
            tt = (struct timeval *)((void *)0);
#line 446
            truncated_timeval[0] = *(t + 0);
#line 447
            truncated_timeval[1] = *(t + 1);
#line 448
            if (abig) {
#line 448
              if (adiff == 1L) {
                {
#line 448
                tmp___15 = get_stat_atime_ns((struct stat  const  *)(& st));
                }
#line 448
                if (tmp___15 == (long __attribute__((__pure__))  )0) {
#line 450
                  tt = truncated_timeval;
#line 451
                  (tt + 0)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 453
            if (mbig) {
#line 453
              if (mdiff == 1L) {
                {
#line 453
                tmp___16 = get_stat_mtime_ns((struct stat  const  *)(& st));
                }
#line 453
                if (tmp___16 == (long __attribute__((__pure__))  )0) {
#line 455
                  tt = truncated_timeval;
#line 456
                  (tt + 1)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 458
            if (tt) {
              {
#line 459
              futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)tt);
              }
            }
          }
        }
      }
#line 464
      return (0);
    }
  }
#line 470
  if (! file) {
#line 476
    return (-1);
  }
  {
#line 482
  tmp___19 = utimes(file, (struct timeval  const  *)t);
  }
#line 482
  return (tmp___19);
}
}
#line 504 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
  {
#line 507
  tmp = fdutimens(-1, file, timespec);
  }
#line 507
  return (tmp);
}
}
#line 514 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/utimens.c"
int lutimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  struct timespec  __attribute__((__pure__)) tmp___1 ;
  struct timespec  __attribute__((__pure__)) tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 518
  if (timespec) {
#line 518
    tmp = adjusted_timespec;
  } else {
#line 518
    tmp = (struct timespec *)((void *)0);
  }
#line 518
  ts = tmp;
#line 519
  adjustment_needed = 0;
#line 522
  if (ts) {
    {
#line 524
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 525
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 526
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 528
  if (adjustment_needed < 0) {
#line 529
    return (-1);
  }
#line 537
  if (0 <= lutimensat_works_really) {
#line 553
    if (adjustment_needed == 2) {
      {
#line 555
      tmp___0 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 555
      if (tmp___0) {
#line 556
        return (-1);
      }
#line 557
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 558
        tmp___1 = get_stat_atime((struct stat  const  *)(& st));
#line 558
        *(ts + 0) = (struct timespec )tmp___1;
        }
      } else
#line 559
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 560
        tmp___2 = get_stat_mtime((struct stat  const  *)(& st));
#line 560
        *(ts + 1) = (struct timespec )tmp___2;
        }
      }
#line 562
      adjustment_needed ++;
    }
    {
#line 565
    result = utimensat(-100, file, (struct timespec  const  *)ts, 256);
    }
#line 574
    if (0 < result) {
      {
#line 575
      tmp___3 = __errno_location();
#line 575
      *tmp___3 = 38;
      }
    }
#line 577
    if (result == 0) {
#line 579
      utimensat_works_really = 1;
#line 580
      lutimensat_works_really = 1;
#line 581
      return (result);
    } else {
      {
#line 577
      tmp___4 = __errno_location();
      }
#line 577
      if (*tmp___4 != 38) {
#line 579
        utimensat_works_really = 1;
#line 580
        lutimensat_works_really = 1;
#line 581
        return (result);
      }
    }
  }
#line 584
  lutimensat_works_really = -1;
#line 591
  if (adjustment_needed) {
#line 591
    goto _L;
  } else
#line 591
  if (0) {
    _L: /* CIL Label */ 
#line 593
    if (adjustment_needed != 3) {
      {
#line 593
      tmp___5 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 593
      if (tmp___5) {
#line 594
        return (-1);
      }
    }
#line 595
    if (ts) {
      {
#line 595
      tmp___6 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 595
      if (tmp___6) {
#line 596
        return (0);
      }
    }
  }
#line 624
  if (! adjustment_needed) {
    {
#line 624
    tmp___7 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
    }
#line 624
    if (tmp___7) {
#line 625
      return (-1);
    }
  }
#line 626
  if (! ((st.st_mode & 61440U) == 40960U)) {
    {
#line 627
    tmp___8 = fdutimens(-1, file, (struct timespec  const  *)ts);
    }
#line 627
    return (tmp___8);
  }
  {
#line 628
  tmp___9 = __errno_location();
#line 628
  *tmp___9 = 38;
  }
#line 629
  return (-1);
}
}
#line 26 "./tmpdir.h"
int path_search(char *tmpl , size_t tmpl_len , char const   *dir , char const   *pfx ,
                _Bool try_tmpdir ) ;
#line 636 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) secure_getenv)(char const   *__name ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 73 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tmpdir.c"
static _Bool direxists(char const   *dir ) 
{ 
  struct stat buf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 77
  tmp = stat((char const   */* __restrict  */)dir, (struct stat */* __restrict  */)(& buf));
  }
#line 77
  if (tmp == 0) {
#line 77
    if ((buf.st_mode & 61440U) == 16384U) {
#line 77
      tmp___0 = 1;
    } else {
#line 77
      tmp___0 = 0;
    }
  } else {
#line 77
    tmp___0 = 0;
  }
#line 77
  return ((_Bool )tmp___0);
}
}
#line 86 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tmpdir.c"
int path_search(char *tmpl , size_t tmpl_len , char const   *dir , char const   *pfx ,
                _Bool try_tmpdir ) 
{ 
  char const   *d ;
  size_t dlen ;
  size_t plen ;
  _Bool add_slash ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
#line 94
  if (! pfx) {
#line 96
    pfx = "file";
#line 97
    plen = (size_t )4;
  } else
#line 94
  if (! *(pfx + 0)) {
#line 96
    pfx = "file";
#line 97
    plen = (size_t )4;
  } else {
    {
#line 101
    plen = strlen(pfx);
    }
#line 102
    if (plen > 5UL) {
#line 103
      plen = (size_t )5;
    }
  }
#line 106
  if (try_tmpdir) {
    {
#line 108
    tmp = secure_getenv("TMPDIR");
#line 108
    d = (char const   *)tmp;
    }
#line 109
    if ((unsigned long )d != (unsigned long )((void *)0)) {
      {
#line 109
      tmp___1 = direxists(d);
      }
#line 109
      if (tmp___1) {
#line 110
        dir = d;
      } else {
#line 109
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 111
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
      {
#line 111
      tmp___0 = direxists(dir);
      }
#line 111
      if (! tmp___0) {
#line 114
        dir = (char const   *)((void *)0);
      }
    } else {
#line 114
      dir = (char const   *)((void *)0);
    }
  }
#line 116
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 131
    tmp___5 = direxists("/tmp");
    }
#line 131
    if (tmp___5) {
#line 132
      dir = "/tmp";
    } else {
      {
#line 133
      tmp___3 = strcmp("/tmp", "/tmp");
      }
#line 133
      if (tmp___3 != 0) {
        {
#line 133
        tmp___4 = direxists("/tmp");
        }
#line 133
        if (tmp___4) {
#line 134
          dir = "/tmp";
        } else {
          {
#line 137
          tmp___2 = __errno_location();
#line 137
          *tmp___2 = 2;
          }
#line 138
          return (-1);
        }
      } else {
        {
#line 137
        tmp___2 = __errno_location();
#line 137
        *tmp___2 = 2;
        }
#line 138
        return (-1);
      }
    }
  }
  {
#line 142
  dlen = strlen(dir);
  }
#line 146
  if (dlen != 0UL) {
#line 146
    if (! ((int const   )*(dir + (dlen - 1UL)) == 47)) {
#line 146
      tmp___6 = 1;
    } else {
#line 146
      tmp___6 = 0;
    }
  } else {
#line 146
    tmp___6 = 0;
  }
#line 146
  add_slash = (_Bool )tmp___6;
#line 150
  if (tmpl_len < (((dlen + (size_t )add_slash) + plen) + 6UL) + 1UL) {
    {
#line 152
    tmp___7 = __errno_location();
#line 152
    *tmp___7 = 22;
    }
#line 153
    return (-1);
  }
  {
#line 156
  memcpy((void */* __restrict  */)tmpl, (void const   */* __restrict  */)dir, dlen);
#line 157
  sprintf((char */* __restrict  */)(tmpl + dlen), (char const   */* __restrict  */)("/%.*sXXXXXX" + ! add_slash),
          (int )plen, pfx);
  }
#line 158
  return (0);
}
}
#line 82 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 128
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
#line 170
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 196
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 779 "./time.h"
timezone_t tzalloc(char const   *name ) ;
#line 781
void tzfree(timezone_t tz ) ;
#line 783
struct tm *( __attribute__((__nonnull__(2,3))) localtime_rz)(timezone_t tz , time_t const   * __restrict  t ,
                                                             struct tm * __restrict  tm ) ;
#line 789
time_t ( __attribute__((__nonnull__(2))) mktime_z)(timezone_t tz , struct tm * __restrict  tm ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 650
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
#line 654
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unsetenv)(char const   *__name ) ;
#line 55 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static struct tm_zone * const  local_tz  =    (timezone_t const   )((timezone_t )1);
#line 61 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static _Bool isdst_differ(int a , int b ) 
{ 
  int tmp ;

  {
#line 64
  if (! a != ! b) {
#line 64
    if (0 <= a) {
#line 64
      if (0 <= b) {
#line 64
        tmp = 1;
      } else {
#line 64
        tmp = 0;
      }
    } else {
#line 64
      tmp = 0;
    }
  } else {
#line 64
    tmp = 0;
  }
#line 64
  return ((_Bool )tmp);
}
}
#line 68 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static int equal_tm(struct tm  const  *a , struct tm  const  *b ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 71
  tmp = isdst_differ((int )a->tm_isdst, (int )b->tm_isdst);
  }
#line 71
  if (((((((a->tm_sec ^ b->tm_sec) | (a->tm_min ^ b->tm_min)) | (a->tm_hour ^ b->tm_hour)) | (a->tm_mday ^ b->tm_mday)) | (a->tm_mon ^ b->tm_mon)) | (a->tm_year ^ b->tm_year)) | (int const   )tmp) {
#line 71
    tmp___0 = 0;
  } else {
#line 71
    tmp___0 = 1;
  }
#line 71
  return (tmp___0);
}
}
#line 85 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static void extend_abbrs(char *abbrs , char const   *abbr , size_t abbr_size ) 
{ 


  {
  {
#line 88
  memcpy((void */* __restrict  */)abbrs, (void const   */* __restrict  */)abbr, abbr_size);
#line 89
  *(abbrs + abbr_size) = (char )'\000';
  }
#line 90
  return;
}
}
#line 94 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
timezone_t tzalloc(char const   *name ) 
{ 
  size_t name_size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t abbr_size ;
  size_t tmp___1 ;
  timezone_t tz ;
  void *tmp___2 ;

  {
#line 97
  if (name) {
    {
#line 97
    tmp = strlen(name);
#line 97
    tmp___0 = tmp + 1UL;
    }
  } else {
#line 97
    tmp___0 = (size_t )0;
  }
#line 97
  name_size = tmp___0;
#line 98
  if (name_size < 119UL) {
#line 98
    tmp___1 = (size_t )119;
  } else {
#line 98
    tmp___1 = name_size + 1UL;
  }
  {
#line 98
  abbr_size = tmp___1;
#line 99
  tmp___2 = malloc(((((unsigned long )(& ((struct tm_zone *)0)->abbrs) + __alignof__(struct tm_zone )) - 1UL) + abbr_size) & ~ (__alignof__(struct tm_zone ) - 1UL));
#line 99
  tz = (timezone_t )tmp___2;
  }
#line 100
  if (tz) {
#line 102
    tz->next = (struct tm_zone *)((void *)0);
#line 106
    tz->tz_is_set = (char )(! (! name));
#line 107
    tz->abbrs[0] = (char )'\000';
#line 108
    if (name) {
      {
#line 109
      extend_abbrs(tz->abbrs, name, name_size);
      }
    }
  }
#line 111
  return (tz);
}
}
#line 118 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static _Bool save_abbr(timezone_t tz , struct tm *tm ) 
{ 
  char const   *zone ;
  char *zone_copy ;
  size_t zone_size ;
  size_t tmp ;
  size_t zone_used ;
  int *tmp___0 ;
  struct tm_zone *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 122
  zone = (char const   *)((void *)0);
#line 123
  zone_copy = (char *)"";
#line 130
  zone = tm->tm_zone;
#line 142
  if (! zone) {
#line 143
    return ((_Bool)1);
  } else
#line 142
  if ((unsigned long )((char *)tm) <= (unsigned long )zone) {
#line 142
    if ((unsigned long )zone < (unsigned long )((char *)(tm + 1))) {
#line 143
      return ((_Bool)1);
    }
  }
#line 145
  if (*zone) {
#line 147
    zone_copy = tz->abbrs;
    {
#line 149
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 149
      tmp___3 = strcmp((char const   *)zone_copy, zone);
      }
#line 149
      if (! (tmp___3 != 0)) {
#line 149
        goto while_break;
      }
#line 151
      if (! *zone_copy) {
#line 151
        if ((unsigned long )zone_copy == (unsigned long )(tz->abbrs)) {
#line 151
          if (! tz->tz_is_set) {
#line 151
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 153
          tmp = strlen(zone);
#line 153
          zone_size = tmp + 1UL;
#line 154
          zone_used = (size_t )(zone_copy - tz->abbrs);
          }
#line 155
          if (0xffffffffffffffffUL - zone_used < zone_size) {
            {
#line 157
            tmp___0 = __errno_location();
#line 157
            *tmp___0 = 12;
            }
#line 158
            return ((_Bool)0);
          }
#line 160
          if (zone_used + zone_size < 119UL) {
            {
#line 161
            extend_abbrs(zone_copy, zone, zone_size);
            }
          } else {
            {
#line 164
            tmp___1 = tzalloc(zone);
#line 164
            tz->next = tmp___1;
#line 164
            tz = tmp___1;
            }
#line 165
            if (! tz) {
#line 166
              return ((_Bool)0);
            }
#line 167
            tz->tz_is_set = (char)0;
#line 168
            zone_copy = tz->abbrs;
          }
#line 170
          goto while_break;
        }
      }
      {
#line 173
      tmp___2 = strlen((char const   *)zone_copy);
#line 173
      zone_copy += tmp___2 + 1UL;
      }
#line 174
      if (! *zone_copy) {
#line 174
        if (tz->next) {
#line 176
          tz = tz->next;
#line 177
          zone_copy = tz->abbrs;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 184
  tm->tm_zone = (char const   *)zone_copy;
#line 191
  return ((_Bool)1);
}
}
#line 195 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
void tzfree(timezone_t tz ) 
{ 
  timezone_t next ;

  {
#line 198
  if ((unsigned long )tz != (unsigned long )local_tz) {
    {
#line 199
    while (1) {
      while_continue: /* CIL Label */ ;
#line 199
      if (! tz) {
#line 199
        goto while_break;
      }
      {
#line 201
      next = tz->next;
#line 202
      free((void *)tz);
#line 203
      tz = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 205
  return;
}
}
#line 211 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static char *getenv_TZ(void) 
{ 
  char *tmp ;

  {
  {
#line 214
  tmp = getenv("TZ");
  }
#line 214
  return (tmp);
}
}
#line 219 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static int setenv_TZ(char const   *tz ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 222
  if (tz) {
    {
#line 222
    tmp = setenv("TZ", tz, 1);
#line 222
    tmp___1 = tmp;
    }
  } else {
    {
#line 222
    tmp___0 = unsetenv("TZ");
#line 222
    tmp___1 = tmp___0;
    }
  }
#line 222
  return (tmp___1);
}
}
#line 228 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static _Bool change_env(timezone_t tz ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 231
  if (tz->tz_is_set) {
#line 231
    tmp = tz->abbrs;
  } else {
#line 231
    tmp = (char *)((void *)0);
  }
  {
#line 231
  tmp___0 = setenv_TZ((char const   *)tmp);
  }
#line 231
  if (tmp___0 != 0) {
#line 232
    return ((_Bool)0);
  }
  {
#line 233
  tzset();
  }
#line 234
  return ((_Bool)1);
}
}
#line 241 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static timezone_t set_tz(timezone_t tz ) 
{ 
  char *env_tz ;
  char *tmp ;
  timezone_t old_tz ;
  timezone_t tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 244
  tmp = getenv_TZ();
#line 244
  env_tz = tmp;
  }
#line 245
  if (env_tz) {
#line 245
    if (tz->tz_is_set) {
      {
#line 245
      tmp___4 = strcmp((char const   *)(tz->abbrs), (char const   *)env_tz);
      }
#line 245
      if (tmp___4 == 0) {
#line 245
        tmp___5 = 1;
      } else {
#line 245
        tmp___5 = 0;
      }
    } else {
#line 245
      tmp___5 = 0;
    }
#line 245
    tmp___6 = tmp___5;
  } else {
#line 245
    tmp___6 = ! tz->tz_is_set;
  }
#line 245
  if (tmp___6) {
#line 248
    return ((timezone_t )local_tz);
  } else {
    {
#line 251
    tmp___0 = tzalloc((char const   *)env_tz);
#line 251
    old_tz = tmp___0;
    }
#line 252
    if (! old_tz) {
#line 253
      return (old_tz);
    }
    {
#line 254
    tmp___3 = change_env(tz);
    }
#line 254
    if (! tmp___3) {
      {
#line 256
      tmp___1 = __errno_location();
#line 256
      saved_errno = *tmp___1;
#line 257
      tzfree(old_tz);
#line 258
      tmp___2 = __errno_location();
#line 258
      *tmp___2 = saved_errno;
      }
#line 259
      return ((timezone_t )((void *)0));
    }
#line 261
    return (old_tz);
  }
}
}
#line 268 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
static _Bool revert_tz(timezone_t tz ) 
{ 
  int saved_errno ;
  int *tmp ;
  _Bool ok ;
  _Bool tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 271
  if ((unsigned long )tz == (unsigned long )local_tz) {
#line 272
    return ((_Bool)1);
  } else {
    {
#line 275
    tmp = __errno_location();
#line 275
    saved_errno = *tmp;
#line 276
    tmp___0 = change_env(tz);
#line 276
    ok = tmp___0;
    }
#line 277
    if (! ok) {
      {
#line 278
      tmp___1 = __errno_location();
#line 278
      saved_errno = *tmp___1;
      }
    }
    {
#line 279
    tzfree(tz);
#line 280
    tmp___2 = __errno_location();
#line 280
    *tmp___2 = saved_errno;
    }
#line 281
    return (ok);
  }
}
}
#line 286 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
struct tm *( __attribute__((__nonnull__(2,3))) localtime_rz)(timezone_t tz , time_t const   * __restrict  t ,
                                                             struct tm * __restrict  tm ) 
{ 
  struct tm *tmp ;
  timezone_t old_tz ;
  timezone_t tmp___0 ;
  _Bool abbr_saved ;
  struct tm *tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;

  {
#line 304
  if (! tz) {
    {
#line 305
    tmp = gmtime_r(t, tm);
    }
#line 305
    return (tmp);
  } else {
    {
#line 308
    tmp___0 = set_tz(tz);
#line 308
    old_tz = tmp___0;
    }
#line 309
    if (old_tz) {
      {
#line 311
      tmp___1 = localtime_r(t, tm);
      }
#line 311
      if (tmp___1) {
        {
#line 311
        tmp___2 = save_abbr(tz, (struct tm *)tm);
        }
#line 311
        if (tmp___2) {
#line 311
          tmp___3 = 1;
        } else {
#line 311
          tmp___3 = 0;
        }
      } else {
#line 311
        tmp___3 = 0;
      }
      {
#line 311
      abbr_saved = (_Bool )tmp___3;
#line 312
      tmp___4 = revert_tz(old_tz);
      }
#line 312
      if (tmp___4) {
#line 312
        if (abbr_saved) {
#line 313
          return ((struct tm *)tm);
        }
      }
    }
#line 315
    return ((struct tm *)((void *)0));
  }
}
}
#line 320 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/time_rz.c"
time_t ( __attribute__((__nonnull__(2))) mktime_z)(timezone_t tz , struct tm * __restrict  tm ) 
{ 
  time_t tmp ;
  timezone_t old_tz ;
  timezone_t tmp___0 ;
  time_t t ;
  time_t tmp___1 ;
  time_t badtime ;
  struct tm tm_1 ;
  struct tm *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
#line 323
  if (! tz) {
    {
#line 324
    tmp = timegm((struct tm *)tm);
    }
#line 324
    return (tmp);
  } else {
    {
#line 327
    tmp___0 = set_tz(tz);
#line 327
    old_tz = tmp___0;
    }
#line 328
    if (old_tz) {
      {
#line 330
      tmp___1 = mktime((struct tm *)tm);
#line 330
      t = tmp___1;
#line 332
      badtime = (time_t )-1;
      }
#line 334
      if (t != badtime) {
#line 334
        goto _L;
      } else {
        {
#line 334
        tmp___2 = localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& tm_1));
        }
#line 334
        if (tmp___2) {
          {
#line 334
          tmp___3 = equal_tm((struct tm  const  *)tm, (struct tm  const  *)(& tm_1));
          }
#line 334
          if (tmp___3) {
            _L: /* CIL Label */ 
            {
#line 334
            tmp___4 = save_abbr(tz, (struct tm *)tm);
            }
#line 334
            if (! tmp___4) {
#line 337
              t = badtime;
            }
          }
        }
      }
      {
#line 339
      tmp___5 = revert_tz(old_tz);
      }
#line 339
      if (tmp___5) {
#line 340
        return (t);
      }
    }
#line 342
    return ((time_t )-1);
  }
}
}
#line 279 "/usr/include/pthread.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
#line 1153
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
#line 1153 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
#line 1156
  return (__thread1 == __thread2);
}
}
#line 52 "./tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 58
int try_tempname(char *tmpl , int suffixlen , void *args , int (*tryfunc)(char * ,
                                                                          void * ) ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         __timezone_ptr_t __tz ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 176 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
static char const   letters[63]  = 
#line 176 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 185 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
static uint64_t value  ;
#line 179 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
int try_tempname(char *tmpl , int suffixlen , void *args , int (*tryfunc)(char * ,
                                                                          void * ) ) 
{ 
  int len ;
  char *XXXXXX ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  unsigned int attempts ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct timeval tv ;
  __pid_t tmp___3 ;
  uint64_t v ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 188
  fd = -1;
#line 189
  tmp = __errno_location();
#line 189
  save_errno = *tmp;
#line 204
  attempts = 238328U;
#line 207
  tmp___0 = strlen((char const   *)tmpl);
#line 207
  len = (int )tmp___0;
  }
#line 208
  if (len < 6 + suffixlen) {
    {
#line 210
    tmp___1 = __errno_location();
#line 210
    *tmp___1 = 22;
    }
#line 211
    return (-1);
  } else {
    {
#line 208
    tmp___2 = memcmp((void const   *)(tmpl + ((len - 6) - suffixlen)), (void const   *)"XXXXXX",
                     (size_t )6);
    }
#line 208
    if (tmp___2) {
      {
#line 210
      tmp___1 = __errno_location();
#line 210
      *tmp___1 = 22;
      }
#line 211
      return (-1);
    }
  }
  {
#line 215
  XXXXXX = tmpl + ((len - 6) - suffixlen);
#line 223
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 224
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 227
  tmp___3 = getpid();
#line 227
  value += random_time_bits ^ (unsigned long )tmp___3;
#line 229
  count = 0U;
  }
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (count < attempts)) {
#line 229
      goto while_break;
    }
    {
#line 231
    v = value;
#line 234
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 235
    v /= 62UL;
#line 236
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 237
    v /= 62UL;
#line 238
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 239
    v /= 62UL;
#line 240
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 241
    v /= 62UL;
#line 242
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 243
    v /= 62UL;
#line 244
    *(XXXXXX + 5) = (char )letters[v % 62UL];
#line 246
    fd = (*tryfunc)(tmpl, args);
    }
#line 247
    if (fd >= 0) {
      {
#line 249
      tmp___4 = __errno_location();
#line 249
      *tmp___4 = save_errno;
      }
#line 250
      return (fd);
    } else {
      {
#line 252
      tmp___5 = __errno_location();
      }
#line 252
      if (*tmp___5 != 17) {
#line 253
        return (-1);
      }
    }
#line 229
    value += 7777UL;
#line 229
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  tmp___6 = __errno_location();
#line 257
  *tmp___6 = 17;
  }
#line 258
  return (-1);
}
}
#line 261 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
static int try_file(char *tmpl , void *flags ) 
{ 
  int *openflags ;
  int tmp ;

  {
  {
#line 264
  openflags = (int *)flags;
#line 265
  tmp = open((char const   *)tmpl, (((*openflags & -4) | 2) | 64) | 128, 384);
  }
#line 265
  return (tmp);
}
}
#line 270 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
static int try_dir(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 273
  tmp = mkdir((char const   *)tmpl, (__mode_t )448);
  }
#line 273
  return (tmp);
}
}
#line 276 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
static int try_nocreate(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 281
  tmp___0 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
  }
#line 281
  if (tmp___0 == 0) {
    {
#line 282
    tmp = __errno_location();
#line 282
    *tmp = 17;
    }
  } else {
    {
#line 281
    tmp___1 = __errno_location();
    }
#line 281
    if (*tmp___1 == 75) {
      {
#line 282
      tmp = __errno_location();
#line 282
      *tmp = 17;
      }
    }
  }
  {
#line 283
  tmp___4 = __errno_location();
  }
#line 283
  if (*tmp___4 == 2) {
#line 283
    tmp___3 = 0;
  } else {
#line 283
    tmp___3 = -1;
  }
#line 283
  return (tmp___3);
}
}
#line 299 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int (*tryfunc)(char * , void * ) ;
  int tmp ;

  {
  {
#line 306
  if (kind == 0) {
#line 306
    goto case_0;
  }
#line 310
  if (kind == 1) {
#line 310
    goto case_1;
  }
#line 314
  if (kind == 2) {
#line 314
    goto case_2;
  }
#line 318
  goto switch_default;
  case_0: /* CIL Label */ 
#line 307
  tryfunc = & try_file;
#line 308
  goto switch_break;
  case_1: /* CIL Label */ 
#line 311
  tryfunc = & try_dir;
#line 312
  goto switch_break;
  case_2: /* CIL Label */ 
#line 315
  tryfunc = & try_nocreate;
#line 316
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 319
  __assert_fail("! \"invalid KIND in __gen_tempname\"", "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/tempname.c",
                319U, "gen_tempname");
#line 320
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 322
  tmp = try_tempname(tmpl, suffixlen, (void *)(& flags), tryfunc);
  }
#line 322
  return (tmp);
}
}
#line 44 "./dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 46
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 48
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 37 "./sig-handler.h"
__inline sa_handler_t __attribute__((__pure__))  get_handler(struct sigaction  const  *a ) 
{ 


  {
#line 46
  return ((sa_handler_t __attribute__((__pure__))  )a->__sigaction_handler.sa_handler);
}
}
#line 64 "./setlocale_null.h"
int ( __attribute__((__nonnull__(2))) setlocale_null_r)(int category , char *buf ,
                                                        size_t bufsize ) ;
#line 75
char const   *setlocale_null(int category ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 59 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/setlocale_null.c"
static char const   *setlocale_null_androidfix(int category ) 
{ 
  char const   *result ;
  char *tmp ;

  {
  {
#line 62
  tmp = setlocale(category, (char const   *)((void *)0));
#line 62
  result = (char const   *)tmp;
  }
#line 87
  return (result);
}
}
#line 90 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/setlocale_null.c"
static int setlocale_null_unlocked(int category , char *buf , size_t bufsize ) 
{ 
  char const   *result ;
  char const   *tmp ;
  size_t length ;
  size_t tmp___0 ;

  {
  {
#line 140
  tmp = setlocale_null_androidfix(category);
#line 140
  result = tmp;
  }
#line 142
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 145
    if (bufsize > 0UL) {
#line 149
      *(buf + 0) = (char )'\000';
    }
#line 150
    return (22);
  } else {
    {
#line 154
    tmp___0 = strlen(result);
#line 154
    length = tmp___0;
    }
#line 155
    if (length < bufsize) {
      {
#line 157
      memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)result,
             length + 1UL);
      }
#line 158
      return (0);
    } else {
#line 162
      if (bufsize > 0UL) {
        {
#line 167
        memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)result,
               bufsize - 1UL);
#line 168
        *(buf + (bufsize - 1UL)) = (char )'\000';
        }
      }
#line 170
      return (34);
    }
  }
}
}
#line 268 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/setlocale_null.c"
int ( __attribute__((__nonnull__(2))) setlocale_null_r)(int category , char *buf ,
                                                        size_t bufsize ) 
{ 
  int tmp ;

  {
  {
#line 274
  tmp = setlocale_null_unlocked(category, buf, bufsize);
  }
#line 274
  return (tmp);
}
}
#line 300 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/setlocale_null.c"
char const   *setlocale_null(int category ) 
{ 
  char const   *tmp ;

  {
  {
#line 304
  tmp = setlocale_null_androidfix(category);
  }
#line 304
  return (tmp);
}
}
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 33 "./acl.h"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 299 "./acl-internal.h"
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) ;
#line 759 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/set-permissions.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 762
  if (desc != -1) {
    {
#line 763
    tmp = fchmod(desc, mode);
    }
#line 763
    return (tmp);
  } else {
    {
#line 765
    tmp___0 = chmod(name, mode);
    }
#line 765
    return (tmp___0);
  }
}
}
#line 775 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/set-permissions.c"
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) 
{ 
  _Bool acls_set  __attribute__((__unused__)) ;
  _Bool early_chmod ;
  _Bool must_chmod ;
  int ret ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 778
  acls_set = (_Bool)0;
#line 780
  must_chmod = (_Bool)0;
#line 781
  ret = 0;
#line 801
  early_chmod = (_Bool)1;
#line 804
  if (early_chmod) {
    {
#line 806
    ret = chmod_or_fchmod(name, desc, ctx->mode);
    }
#line 807
    if (ret != 0) {
#line 808
      return (-1);
    }
  }
#line 833
  if (must_chmod) {
#line 833
    if (! early_chmod) {
#line 835
      if (ret) {
        {
#line 835
        tmp = __errno_location();
#line 835
        tmp___0 = *tmp;
        }
      } else {
#line 835
        tmp___0 = 0;
      }
      {
#line 835
      saved_errno = tmp___0;
#line 837
      ret = chmod_or_fchmod(name, desc, ctx->mode);
      }
#line 839
      if (saved_errno) {
        {
#line 841
        tmp___1 = __errno_location();
#line 841
        *tmp___1 = saved_errno;
#line 842
        ret = -1;
        }
      }
    }
  }
#line 846
  return (ret);
}
}
#line 29 "./acl.h"
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 30
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 44 "./quote.h"
char const   *quote(char const   *arg ) ;
#line 41 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/set-acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 44
  tmp = qset_acl(name, desc, mode);
#line 44
  ret = tmp;
  }
#line 45
  if (ret != 0) {
    {
#line 46
    tmp___0 = quote(name);
#line 46
    tmp___1 = dcgettext((char const   *)((void *)0), "setting permissions for %s",
                        5);
#line 46
    tmp___2 = __errno_location();
#line 46
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
    }
  }
#line 47
  return (ret);
}
}
#line 86 "./selinux/selinux.h"
__inline extern int getcon(security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 88
  tmp = __errno_location();
#line 88
  *tmp = 95;
  }
#line 88
  return (-1);
}
}
#line 89 "./selinux/selinux.h"
__inline extern void freecon(security_context_t con  __attribute__((__unused__)) ) 
{ 


  {
#line 90
  return;
}
}
#line 95 "./selinux/selinux.h"
__inline extern int setfscreatecon(security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 97
  tmp = __errno_location();
#line 97
  *tmp = 95;
  }
#line 97
  return (-1);
}
}
#line 98 "./selinux/selinux.h"
__inline extern int matchpathcon(char const   *file  __attribute__((__unused__)) ,
                                 mode_t m  __attribute__((__unused__)) , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 102
  tmp = __errno_location();
#line 102
  *tmp = 95;
  }
#line 102
  return (-1);
}
}
#line 103 "./selinux/selinux.h"
__inline extern int getfilecon(char const   *file  __attribute__((__unused__)) , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 106
  tmp = __errno_location();
#line 106
  *tmp = 95;
  }
#line 106
  return (-1);
}
}
#line 111 "./selinux/selinux.h"
__inline extern int fgetfilecon(int fd , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 113
  tmp = __errno_location();
#line 113
  *tmp = 95;
  }
#line 113
  return (-1);
}
}
#line 114 "./selinux/selinux.h"
__inline extern int setfilecon(char const   *file  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 117
  tmp = __errno_location();
#line 117
  *tmp = 95;
  }
#line 117
  return (-1);
}
}
#line 122 "./selinux/selinux.h"
__inline extern int fsetfilecon(int fd  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 125
  tmp = __errno_location();
#line 125
  *tmp = 95;
  }
#line 125
  return (-1);
}
}
#line 136 "./selinux/selinux.h"
__inline extern int security_compute_create(security_context_t scon  __attribute__((__unused__)) ,
                                            security_context_t tcon  __attribute__((__unused__)) ,
                                            security_class_t tclass  __attribute__((__unused__)) ,
                                            security_context_t *newcon  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 141
  tmp = __errno_location();
#line 141
  *tmp = 95;
  }
#line 141
  return (-1);
}
}
#line 142 "./selinux/selinux.h"
__inline extern security_class_t string_to_security_class(char const   *name ) 
{ 
  int *tmp ;

  {
  {
#line 144
  tmp = __errno_location();
#line 144
  *tmp = 95;
  }
#line 144
  return ((security_class_t )0);
}
}
#line 145 "./selinux/selinux.h"
__inline extern int matchpathcon_init_prefix(char const   *path  __attribute__((__unused__)) ,
                                             char const   *prefix  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 148
  tmp = __errno_location();
#line 148
  *tmp = 95;
  }
#line 148
  return (-1);
}
}
#line 54 "./selinux/context.h"
__inline extern context_t context_new(char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 55
  tmp = __errno_location();
#line 55
  *tmp = 95;
  }
#line 55
  return (0);
}
}
#line 56 "./selinux/context.h"
__inline extern char *context_str(context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 57
  tmp = __errno_location();
#line 57
  *tmp = 95;
  }
#line 57
  return ((char *)((void *)0));
}
}
#line 58 "./selinux/context.h"
__inline extern void context_free(context_t c  __attribute__((__unused__)) ) 
{ 


  {
#line 58
  return;
}
}
#line 60 "./selinux/context.h"
__inline extern int context_user_set(context_t sc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 62
  tmp = __errno_location();
#line 62
  *tmp = 95;
  }
#line 62
  return (-1);
}
}
#line 37 "./safe-write.h"
size_t safe_write(int fd , void const   *buf , size_t count ) ;
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 55 "./safe-read.c"
size_t safe_write(int fd , void const   *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    tmp = write(fd, buf, count);
#line 60
    result = tmp;
    }
#line 62
    if (0L <= result) {
#line 63
      return ((size_t )result);
    } else {
      {
#line 64
      tmp___1 = __errno_location();
      }
#line 64
      if (*tmp___1 == 4) {
#line 65
        goto __Cont;
      } else {
        {
#line 66
        tmp___0 = __errno_location();
        }
#line 66
        if (*tmp___0 == 22) {
#line 66
          if (2146435072UL < count) {
#line 67
            count = (size_t )2146435072;
          } else {
#line 69
            return ((size_t )result);
          }
        } else {
#line 69
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 42 "./safe-read.h"
size_t safe_read(int fd , void *buf , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 55 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/safe-read.c"
size_t safe_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    tmp = read(fd, buf, count);
#line 60
    result = tmp;
    }
#line 62
    if (0L <= result) {
#line 63
      return ((size_t )result);
    } else {
      {
#line 64
      tmp___1 = __errno_location();
      }
#line 64
      if (*tmp___1 == 4) {
#line 65
        goto __Cont;
      } else {
        {
#line 66
        tmp___0 = __errno_location();
        }
#line 66
        if (*tmp___0 == 22) {
#line 66
          if (2146435072UL < count) {
#line 67
            count = (size_t )2146435072;
          } else {
#line 69
            return ((size_t )result);
          }
        } else {
#line 69
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 211 "./regex.h"
reg_syntax_t rpl_re_syntax_options  ;
#line 528
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) ;
#line 538
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 545
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 553
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , regoff_t length ,
                       regoff_t start , regoff_t range , struct re_registers *regs ) ;
#line 561
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         regoff_t length1 , char const   *string2 , regoff_t length2 ,
                         regoff_t start , regoff_t range , struct re_registers *regs ,
                         regoff_t stop ) ;
#line 571
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , regoff_t length ,
                      regoff_t start , struct re_registers *regs ) ;
#line 577
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , regoff_t length1 ,
                        char const   *string2 , regoff_t length2 , regoff_t start ,
                        struct re_registers *regs , regoff_t stop ) ;
#line 596
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) ;
#line 639
int rpl_regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern ,
                int cflags ) ;
#line 643
int rpl_regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
                size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
#line 648
size_t rpl_regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                    size_t errbuf_size ) ;
#line 651
void rpl_regfree(regex_t *preg ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 206
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
#line 206 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      tmp = __ctype_tolower_loc();
#line 209
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 209
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 209
    tmp___0 = (__int32_t const   )__c;
  }
#line 209
  return ((int )tmp___0);
}
}
#line 212
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
#line 212 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      tmp = __ctype_toupper_loc();
#line 215
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 215
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 215
    tmp___0 = (__int32_t const   )__c;
  }
#line 215
  return ((int )tmp___0);
}
}
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *nl_langinfo(nl_item __item ) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int mbsinit(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 301
extern  __attribute__((__nothrow__)) size_t wcrtomb(char * __restrict  __s , wchar_t __wc ,
                                                    mbstate_t * __restrict  __ps ) ;
#line 720 "./wchar.h"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int iswalnum(wint_t __wc ) ;
#line 155
extern  __attribute__((__nothrow__)) wctype_t wctype(char const   *__property ) ;
#line 159
extern  __attribute__((__nothrow__)) int iswctype(wint_t __wc , wctype_t __desc ) ;
#line 166
extern  __attribute__((__nothrow__)) wint_t towlower(wint_t __wc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t towupper(wint_t __wc ) ;
#line 707 "./regex_internal.h"
__inline static void bitset_set(bitset_word_t *set , Idx i ) 
{ 


  {
#line 710
  *(set + i / 64L) |= 1UL << i % 64L;
#line 711
  return;
}
}
#line 713 "./regex_internal.h"
__inline static void bitset_clear(bitset_word_t *set , Idx i ) 
{ 


  {
#line 716
  *(set + i / 64L) &= ~ (1UL << i % 64L);
#line 717
  return;
}
}
#line 719 "./regex_internal.h"
__inline static _Bool bitset_contain(bitset_word_t * const  set , Idx i ) 
{ 


  {
#line 722
  return ((_Bool )((*(set + i / 64L) >> i % 64L) & 1UL));
}
}
#line 725 "./regex_internal.h"
__inline static void bitset_empty(bitset_word_t *set ) 
{ 


  {
  {
#line 728
  memset((void *)set, '\000', sizeof(bitset_t ));
  }
#line 729
  return;
}
}
#line 731 "./regex_internal.h"
__inline static void bitset_set_all(bitset_word_t *set ) 
{ 


  {
  {
#line 734
  memset((void *)set, -1, sizeof(bitset_word_t ) * 4UL);
  }
#line 738
  return;
}
}
#line 740 "./regex_internal.h"
__inline static void bitset_copy(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 


  {
  {
#line 743
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, sizeof(bitset_t ));
  }
#line 744
  return;
}
}
#line 746 "./regex_internal.h"
__inline static void bitset_not(bitset_word_t *set ) 
{ 
  int bitset_i ;

  {
#line 750
  bitset_i = 0;
  {
#line 750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 750
    if (! (bitset_i < 4)) {
#line 750
      goto while_break;
    }
#line 751
    *(set + bitset_i) = ~ *(set + bitset_i);
#line 750
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 756
  return;
}
}
#line 758 "./regex_internal.h"
__inline static void bitset_merge(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 762
  bitset_i = 0;
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 762
    if (! (bitset_i < 4)) {
#line 762
      goto while_break;
    }
#line 763
    *(dest + bitset_i) |= *(src + bitset_i);
#line 762
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 764
  return;
}
}
#line 766 "./regex_internal.h"
__inline static void bitset_mask(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 770
  bitset_i = 0;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (bitset_i < 4)) {
#line 770
      goto while_break;
    }
#line 771
    *(dest + bitset_i) &= *(src + bitset_i);
#line 770
    bitset_i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 772
  return;
}
}
#line 776
static int __attribute__((__pure__))  re_string_char_size_at(re_string_t const   *pstr ,
                                                             Idx idx )  __attribute__((__unused__)) ;
#line 776 "./regex_internal.h"
static int __attribute__((__pure__))  re_string_char_size_at(re_string_t const   *pstr ,
                                                             Idx idx ) 
{ 
  int byte_idx ;

  {
#line 781
  if (pstr->mb_cur_max == 1) {
#line 782
    return ((int __attribute__((__pure__))  )1);
  }
#line 783
  byte_idx = 1;
  {
#line 783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 783
    if (! (idx + (Idx )byte_idx < (Idx )pstr->valid_len)) {
#line 783
      goto while_break;
    }
#line 784
    if (*(pstr->wcs + (idx + (Idx )byte_idx)) != 4294967295U) {
#line 785
      goto while_break;
    }
#line 783
    byte_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 786
  return ((int __attribute__((__pure__))  )byte_idx);
}
}
#line 789
static wint_t __attribute__((__pure__))  re_string_wchar_at(re_string_t const   *pstr ,
                                                            Idx idx )  __attribute__((__unused__)) ;
#line 789 "./regex_internal.h"
static wint_t __attribute__((__pure__))  re_string_wchar_at(re_string_t const   *pstr ,
                                                            Idx idx ) 
{ 


  {
#line 793
  if (pstr->mb_cur_max == 1) {
#line 794
    return ((wint_t __attribute__((__pure__))  )((wint_t )*(pstr->mbs + idx)));
  }
#line 795
  return ((wint_t __attribute__((__pure__))  )*(pstr->wcs + idx));
}
}
#line 802
static int __attribute__((__pure__))  re_string_elem_size_at(re_string_t const   *pstr ,
                                                             Idx idx )  __attribute__((__unused__)) ;
#line 802 "./regex_internal.h"
static int __attribute__((__pure__))  re_string_elem_size_at(re_string_t const   *pstr ,
                                                             Idx idx ) 
{ 


  {
#line 824
  return ((int __attribute__((__pure__))  )1);
}
}
#line 20 "./regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) ;
#line 24
static re_dfastate_t *( __attribute__((__warn_unused_result__)) create_ci_newstate)(re_dfa_t const   *dfa ,
                                                                                    re_node_set const   *nodes ,
                                                                                    re_hashval_t hash ) ;
#line 27
static re_dfastate_t *( __attribute__((__warn_unused_result__)) create_cd_newstate)(re_dfa_t const   *dfa ,
                                                                                    re_node_set const   *nodes ,
                                                                                    unsigned int context ,
                                                                                    re_hashval_t hash ) ;
#line 31
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_string_realloc_buffers)(re_string_t *pstr ,
                                                                                          Idx new_buf_len ) ;
#line 34
static void build_wcs_buffer(re_string_t *pstr ) ;
#line 35
static reg_errcode_t ( __attribute__((__warn_unused_result__)) build_wcs_upper_buffer)(re_string_t *pstr ) ;
#line 37
static void build_upper_buffer(re_string_t *pstr ) ;
#line 38
static void re_string_translate_buffer(re_string_t *pstr ) ;
#line 39
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags )  __attribute__((__pure__)) ;
#line 47 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_string_allocate)(re_string_t *pstr ,
                                                                                   char const   *str ,
                                                                                   Idx len ,
                                                                                   Idx init_len ,
                                                                                   unsigned char *trans ,
                                                                                   _Bool icase ,
                                                                                   re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  Idx init_buf_len ;
  long tmp ;

  {
#line 56
  if (init_len < (Idx )dfa->mb_cur_max) {
#line 57
    init_len = (Idx )dfa->mb_cur_max;
  }
#line 58
  if (len + 1L < init_len) {
#line 58
    init_buf_len = len + 1L;
  } else {
#line 58
    init_buf_len = init_len;
  }
  {
#line 59
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
#line 61
  ret = re_string_realloc_buffers(pstr, init_buf_len);
#line 62
  tmp = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 62
  if (tmp) {
#line 63
    return (ret);
  }
#line 65
  pstr->word_char = (re_const_bitset_ptr_t )(dfa->word_char);
#line 66
  pstr->word_ops_used = (unsigned char )dfa->word_ops_used;
#line 67
  if (pstr->mbs_allocated) {
#line 67
    pstr->mbs = pstr->mbs;
  } else {
#line 67
    pstr->mbs = (unsigned char *)str;
  }
#line 68
  if (pstr->mbs_allocated) {
#line 68
    pstr->valid_len = (Idx )0;
  } else
#line 68
  if (dfa->mb_cur_max > 1) {
#line 68
    pstr->valid_len = (Idx )0;
  } else {
#line 68
    pstr->valid_len = len;
  }
#line 69
  pstr->valid_raw_len = pstr->valid_len;
#line 70
  return ((reg_errcode_t )0);
}
}
#line 75 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_string_construct)(re_string_t *pstr ,
                                                                                    char const   *str ,
                                                                                    Idx len ,
                                                                                    unsigned char *trans ,
                                                                                    _Bool icase ,
                                                                                    re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 81
  memset((void *)pstr, '\000', sizeof(re_string_t ));
#line 82
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
  }
#line 84
  if (len > 0L) {
    {
#line 86
    ret = re_string_realloc_buffers(pstr, len + 1L);
#line 87
    tmp = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 87
    if (tmp) {
#line 88
      return (ret);
    }
  }
#line 90
  if (pstr->mbs_allocated) {
#line 90
    pstr->mbs = pstr->mbs;
  } else {
#line 90
    pstr->mbs = (unsigned char *)str;
  }
#line 92
  if (icase) {
#line 95
    if (dfa->mb_cur_max > 1) {
      {
#line 97
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 99
        ret = build_wcs_upper_buffer(pstr);
#line 100
        tmp___0 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 100
        if (tmp___0) {
#line 101
          return (ret);
        }
#line 102
        if (pstr->valid_raw_len >= len) {
#line 103
          goto while_break;
        }
#line 104
        if (pstr->bufs_len > pstr->valid_len + (Idx )dfa->mb_cur_max) {
#line 105
          goto while_break;
        }
        {
#line 106
        ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2L);
#line 107
        tmp___1 = __builtin_expect((long )((int )ret != 0), 0L);
        }
#line 107
        if (tmp___1) {
#line 108
          return (ret);
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 113
      build_upper_buffer(pstr);
      }
    }
  } else
#line 118
  if (dfa->mb_cur_max > 1) {
    {
#line 119
    build_wcs_buffer(pstr);
    }
  } else
#line 123
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
    {
#line 124
    re_string_translate_buffer(pstr);
    }
  } else {
#line 127
    pstr->valid_len = pstr->bufs_len;
#line 128
    pstr->valid_raw_len = pstr->bufs_len;
  }
#line 133
  return ((reg_errcode_t )0);
}
}
#line 138 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_string_realloc_buffers)(re_string_t *pstr ,
                                                                                          Idx new_buf_len ) 
{ 
  wint_t *new_wcs ;
  size_t max_object_size ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  Idx *new_offsets ;
  void *tmp___4 ;
  long tmp___5 ;
  unsigned char *new_mbs ;
  void *tmp___6 ;
  long tmp___7 ;

  {
#line 143
  if (pstr->mb_cur_max > 1) {
#line 148
    if (sizeof(wint_t ) < sizeof(Idx )) {
#line 148
      tmp = sizeof(Idx );
    } else {
#line 148
      tmp = sizeof(wint_t );
    }
#line 148
    max_object_size = tmp;
#line 149
    if (9223372036854775807UL < 0xffffffffffffffffUL / max_object_size) {
#line 149
      tmp___0 = 9223372036854775807UL;
    } else {
#line 149
      tmp___0 = 0xffffffffffffffffUL / max_object_size;
    }
    {
#line 149
    tmp___1 = __builtin_expect((long )(tmp___0 < (unsigned long )new_buf_len), 0L);
    }
#line 149
    if (tmp___1) {
#line 151
      return ((reg_errcode_t )12);
    }
    {
#line 153
    tmp___2 = realloc((void *)pstr->wcs, (unsigned long )new_buf_len * sizeof(wint_t ));
#line 153
    new_wcs = (wint_t *)tmp___2;
#line 154
    tmp___3 = __builtin_expect((long )((unsigned long )new_wcs == (unsigned long )((void *)0)),
                               0L);
    }
#line 154
    if (tmp___3) {
#line 155
      return ((reg_errcode_t )12);
    }
#line 156
    pstr->wcs = new_wcs;
#line 157
    if ((unsigned long )pstr->offsets != (unsigned long )((void *)0)) {
      {
#line 159
      tmp___4 = realloc((void *)pstr->offsets, (unsigned long )new_buf_len * sizeof(Idx ));
#line 159
      new_offsets = (Idx *)tmp___4;
#line 160
      tmp___5 = __builtin_expect((long )((unsigned long )new_offsets == (unsigned long )((void *)0)),
                                 0L);
      }
#line 160
      if (tmp___5) {
#line 161
        return ((reg_errcode_t )12);
      }
#line 162
      pstr->offsets = new_offsets;
    }
  }
#line 166
  if (pstr->mbs_allocated) {
    {
#line 168
    tmp___6 = realloc((void *)pstr->mbs, (unsigned long )new_buf_len * sizeof(unsigned char ));
#line 168
    new_mbs = (unsigned char *)tmp___6;
#line 170
    tmp___7 = __builtin_expect((long )((unsigned long )new_mbs == (unsigned long )((void *)0)),
                               0L);
    }
#line 170
    if (tmp___7) {
#line 171
      return ((reg_errcode_t )12);
    }
#line 172
    pstr->mbs = new_mbs;
  }
#line 174
  pstr->bufs_len = new_buf_len;
#line 175
  return ((reg_errcode_t )0);
}
}
#line 179 "./regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ 
  int tmp ;

  {
#line 184
  pstr->raw_mbs = (unsigned char const   *)str;
#line 185
  pstr->len = len;
#line 186
  pstr->raw_len = len;
#line 187
  pstr->trans = trans;
#line 188
  pstr->icase = (unsigned char )icase;
#line 189
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 189
    tmp = 1;
  } else
#line 189
  if (icase) {
#line 189
    tmp = 1;
  } else {
#line 189
    tmp = 0;
  }
#line 189
  pstr->mbs_allocated = (unsigned char )tmp;
#line 190
  pstr->mb_cur_max = (int )dfa->mb_cur_max;
#line 191
  pstr->is_utf8 = (unsigned char )dfa->is_utf8;
#line 192
  pstr->map_notascii = (unsigned char )dfa->map_notascii;
#line 193
  pstr->stop = pstr->len;
#line 194
  pstr->raw_stop = pstr->stop;
#line 195
  return;
}
}
#line 210 "./regex_internal.c"
static void build_wcs_buffer(re_string_t *pstr ) 
{ 
  unsigned char buf[64] ;
  mbstate_t prev_st ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  wchar_t wc ;
  char const   *p ;
  int i ;
  int ch ;
  unsigned char tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 225
  if (pstr->bufs_len > pstr->len) {
#line 225
    end_idx = pstr->len;
  } else {
#line 225
    end_idx = pstr->bufs_len;
  }
#line 226
  byte_idx = pstr->valid_len;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (byte_idx < end_idx)) {
#line 226
      goto while_break;
    }
    {
#line 231
    remain_len = end_idx - byte_idx;
#line 232
    prev_st = pstr->cur_state;
#line 234
    tmp___0 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                               0L);
    }
#line 234
    if (tmp___0) {
#line 238
      i = 0;
      {
#line 238
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 238
        if (i < pstr->mb_cur_max) {
#line 238
          if (! ((Idx )i < remain_len)) {
#line 238
            goto while_break___0;
          }
        } else {
#line 238
          goto while_break___0;
        }
#line 240
        ch = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + byte_idx) + (Idx )i));
#line 241
        tmp = *(pstr->trans + ch);
#line 241
        *(pstr->mbs + (byte_idx + (Idx )i)) = tmp;
#line 241
        buf[i] = tmp;
#line 238
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 243
      p = (char const   *)(buf);
    } else {
#line 246
      p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx;
    }
    {
#line 247
    mbclen = rpl_mbrtowc(& wc, p, (size_t )remain_len, & pstr->cur_state);
    }
#line 248
    if (mbclen == 0xffffffffffffffffUL) {
#line 248
      tmp___3 = 1;
    } else
#line 248
    if (mbclen == 0UL) {
#line 248
      tmp___3 = 1;
    } else
#line 248
    if (mbclen == 0xfffffffffffffffeUL) {
#line 248
      if (pstr->bufs_len >= pstr->len) {
#line 248
        tmp___3 = 1;
      } else {
#line 248
        tmp___3 = 0;
      }
    } else {
#line 248
      tmp___3 = 0;
    }
    {
#line 248
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 248
    if (tmp___4) {
      {
#line 253
      mbclen = (size_t )1;
#line 254
      wc = (wchar_t )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 255
      tmp___1 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 255
      if (tmp___1) {
#line 256
        wc = (wchar_t )*(pstr->trans + wc);
      }
#line 257
      pstr->cur_state = prev_st;
    } else {
      {
#line 259
      tmp___2 = __builtin_expect((long )(mbclen == 0xfffffffffffffffeUL), 0L);
      }
#line 259
      if (tmp___2) {
#line 262
        pstr->cur_state = prev_st;
#line 263
        goto while_break;
      }
    }
#line 267
    tmp___5 = byte_idx;
#line 267
    byte_idx ++;
#line 267
    *(pstr->wcs + tmp___5) = (wint_t )wc;
#line 269
    remain_len = (Idx )(((size_t )byte_idx + mbclen) - 1UL);
    {
#line 269
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 269
      if (! (byte_idx < remain_len)) {
#line 269
        goto while_break___1;
      }
#line 270
      tmp___6 = byte_idx;
#line 270
      byte_idx ++;
#line 270
      *(pstr->wcs + tmp___6) = 4294967295U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  pstr->valid_len = byte_idx;
#line 273
  pstr->valid_raw_len = byte_idx;
#line 274
  return;
}
}
#line 279 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) build_wcs_upper_buffer)(re_string_t *pstr ) 
{ 
  mbstate_t prev_st ;
  Idx src_idx ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  char buf[64] ;
  wchar_t wc ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  wchar_t wcu ;
  wint_t tmp___2 ;
  size_t mbcdlen ;
  long tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  int ch ;
  Idx tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  wchar_t wc___0 ;
  char const   *p ;
  int i ;
  int ch___0 ;
  long tmp___10 ;
  wchar_t wcu___0 ;
  wint_t tmp___11 ;
  size_t mbcdlen___0 ;
  size_t i___0 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  long tmp___14 ;
  size_t i___1 ;
  long tmp___15 ;
  Idx tmp___16 ;
  Idx tmp___17 ;
  int ch___1 ;
  long tmp___18 ;
  long tmp___19 ;
  Idx tmp___20 ;
  long tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;

  {
#line 293
  byte_idx = pstr->valid_len;
#line 294
  if (pstr->bufs_len > pstr->len) {
#line 294
    end_idx = pstr->len;
  } else {
#line 294
    end_idx = pstr->bufs_len;
  }
#line 298
  if (! pstr->map_notascii) {
#line 298
    if ((unsigned long )pstr->trans == (unsigned long )((void *)0)) {
#line 298
      if (! pstr->offsets_needed) {
        {
#line 300
        while (1) {
          while_continue: /* CIL Label */ ;
#line 300
          if (! (byte_idx < end_idx)) {
#line 300
            goto while_break;
          }
#line 304
          if (((int const   )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)) & -128) == 0) {
            {
#line 304
            tmp___1 = mbsinit((mbstate_t const   *)(& pstr->cur_state));
            }
#line 304
            if (tmp___1) {
#line 309
              if (sizeof(*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx))) > 1UL) {
                {
#line 309
                __res = toupper((int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)));
                }
              } else {
                {
#line 309
                tmp___0 = __ctype_toupper_loc();
#line 309
                __res = (int )*(*tmp___0 + (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)));
                }
              }
#line 309
              *(pstr->mbs + byte_idx) = (unsigned char )__res;
#line 312
              *(pstr->wcs + byte_idx) = (wint_t )((wchar_t )*(pstr->mbs + byte_idx));
#line 313
              byte_idx ++;
#line 314
              goto while_continue;
            }
          }
          {
#line 317
          remain_len = end_idx - byte_idx;
#line 318
          prev_st = pstr->cur_state;
#line 319
          mbclen = rpl_mbrtowc(& wc, ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx,
                               (size_t )remain_len, & pstr->cur_state);
          }
#line 322
          if (0UL < mbclen) {
#line 322
            if (mbclen < 0xfffffffffffffffeUL) {
#line 322
              tmp___8 = 1;
            } else {
#line 322
              tmp___8 = 0;
            }
          } else {
#line 322
            tmp___8 = 0;
          }
          {
#line 322
          tmp___9 = __builtin_expect((long )tmp___8, 1L);
          }
#line 322
          if (tmp___9) {
            {
#line 324
            tmp___2 = towupper((wint_t )wc);
#line 324
            wcu = (wchar_t )tmp___2;
            }
#line 325
            if (wcu != wc) {
              {
#line 329
              mbcdlen = wcrtomb((char */* __restrict  */)(buf), wcu, (mbstate_t */* __restrict  */)(& prev_st));
#line 330
              tmp___3 = __builtin_expect((long )(mbclen == mbcdlen), 1L);
              }
#line 330
              if (tmp___3) {
                {
#line 331
                memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf),
                       mbclen);
                }
              } else {
#line 334
                src_idx = byte_idx;
#line 335
                goto offsets_needed;
              }
            } else {
              {
#line 339
              memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)((pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                     mbclen);
              }
            }
#line 341
            tmp___4 = byte_idx;
#line 341
            byte_idx ++;
#line 341
            *(pstr->wcs + tmp___4) = (wint_t )wcu;
#line 343
            remain_len = (Idx )(((size_t )byte_idx + mbclen) - 1UL);
            {
#line 343
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 343
              if (! (byte_idx < remain_len)) {
#line 343
                goto while_break___0;
              }
#line 344
              tmp___5 = byte_idx;
#line 344
              byte_idx ++;
#line 344
              *(pstr->wcs + tmp___5) = 4294967295U;
            }
            while_break___0: /* CIL Label */ ;
            }
          } else
#line 346
          if (mbclen == 0xffffffffffffffffUL) {
#line 346
            goto _L;
          } else
#line 346
          if (mbclen == 0UL) {
#line 346
            goto _L;
          } else
#line 346
          if (mbclen == 0xfffffffffffffffeUL) {
#line 346
            if (pstr->bufs_len >= pstr->len) {
              _L: /* CIL Label */ 
              {
#line 351
              ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 352
              *(pstr->mbs + byte_idx) = (unsigned char )ch;
#line 354
              tmp___6 = byte_idx;
#line 354
              byte_idx ++;
#line 354
              *(pstr->wcs + tmp___6) = (wint_t )ch;
#line 355
              tmp___7 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL),
                                         0L);
              }
#line 355
              if (tmp___7) {
#line 356
                pstr->cur_state = prev_st;
              }
            } else {
#line 361
              pstr->cur_state = prev_st;
#line 362
              goto while_break;
            }
          } else {
#line 361
            pstr->cur_state = prev_st;
#line 362
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 365
        pstr->valid_len = byte_idx;
#line 366
        pstr->valid_raw_len = byte_idx;
#line 367
        return ((reg_errcode_t )0);
      } else {
#line 298
        goto _L___2;
      }
    } else {
#line 298
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 370
    src_idx = pstr->valid_raw_len;
    {
#line 370
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 370
      if (! (byte_idx < end_idx)) {
#line 370
        goto while_break___1;
      }
      offsets_needed: 
      {
#line 375
      remain_len = end_idx - byte_idx;
#line 376
      prev_st = pstr->cur_state;
#line 377
      tmp___10 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                  0L);
      }
#line 377
      if (tmp___10) {
#line 381
        i = 0;
        {
#line 381
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 381
          if (i < pstr->mb_cur_max) {
#line 381
            if (! ((Idx )i < remain_len)) {
#line 381
              goto while_break___2;
            }
          } else {
#line 381
            goto while_break___2;
          }
#line 383
          ch___0 = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + src_idx) + (Idx )i));
#line 384
          buf[i] = (char )*(pstr->trans + ch___0);
#line 381
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 386
        p = (char const   *)(buf);
      } else {
#line 389
        p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + src_idx;
      }
      {
#line 390
      mbclen = rpl_mbrtowc(& wc___0, p, (size_t )remain_len, & pstr->cur_state);
      }
#line 391
      if (0UL < mbclen) {
#line 391
        if (mbclen < 0xfffffffffffffffeUL) {
#line 391
          tmp___22 = 1;
        } else {
#line 391
          tmp___22 = 0;
        }
      } else {
#line 391
        tmp___22 = 0;
      }
      {
#line 391
      tmp___23 = __builtin_expect((long )tmp___22, 1L);
      }
#line 391
      if (tmp___23) {
        {
#line 393
        tmp___11 = towupper((wint_t )wc___0);
#line 393
        wcu___0 = (wchar_t )tmp___11;
        }
#line 394
        if (wcu___0 != wc___0) {
          {
#line 398
          mbcdlen___0 = wcrtomb((char */* __restrict  */)(buf), wcu___0, (mbstate_t */* __restrict  */)(& prev_st));
#line 399
          tmp___14 = __builtin_expect((long )(mbclen == mbcdlen___0), 1L);
          }
#line 399
          if (tmp___14) {
            {
#line 400
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf),
                   mbclen);
            }
          } else
#line 401
          if (mbcdlen___0 != 0xffffffffffffffffUL) {
#line 405
            if ((size_t )byte_idx + mbcdlen___0 > (size_t )pstr->bufs_len) {
#line 407
              pstr->cur_state = prev_st;
#line 408
              goto while_break___1;
            }
#line 411
            if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
              {
#line 413
              tmp___12 = malloc((unsigned long )pstr->bufs_len * sizeof(Idx ));
#line 413
              pstr->offsets = (Idx *)tmp___12;
              }
#line 415
              if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
#line 416
                return ((reg_errcode_t )12);
              }
            }
#line 418
            if (! pstr->offsets_needed) {
#line 420
              i___0 = (size_t )0;
              {
#line 420
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 420
                if (! (i___0 < (size_t )byte_idx)) {
#line 420
                  goto while_break___3;
                }
#line 421
                *(pstr->offsets + i___0) = (Idx )i___0;
#line 420
                i___0 ++;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 422
              pstr->offsets_needed = (unsigned char)1;
            }
            {
#line 425
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)(buf),
                   mbcdlen___0);
#line 426
            *(pstr->wcs + byte_idx) = (wint_t )wcu___0;
#line 427
            *(pstr->offsets + byte_idx) = src_idx;
#line 428
            i___0 = (size_t )1;
            }
            {
#line 428
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 428
              if (! (i___0 < mbcdlen___0)) {
#line 428
                goto while_break___4;
              }
#line 430
              if (i___0 < mbclen) {
#line 430
                tmp___13 = i___0;
              } else {
#line 430
                tmp___13 = mbclen - 1UL;
              }
#line 430
              *(pstr->offsets + ((size_t )byte_idx + i___0)) = (Idx )((size_t )src_idx + tmp___13);
#line 432
              *(pstr->wcs + ((size_t )byte_idx + i___0)) = 4294967295U;
#line 428
              i___0 ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 434
            pstr->len = (Idx )((size_t )pstr->len + (mbcdlen___0 - mbclen));
#line 435
            if (pstr->raw_stop > src_idx) {
#line 436
              pstr->stop = (Idx )((size_t )pstr->stop + (mbcdlen___0 - mbclen));
            }
#line 437
            if (pstr->bufs_len > pstr->len) {
#line 437
              end_idx = pstr->len;
            } else {
#line 437
              end_idx = pstr->bufs_len;
            }
#line 439
            byte_idx = (Idx )((size_t )byte_idx + mbcdlen___0);
#line 440
            src_idx = (Idx )((size_t )src_idx + mbclen);
#line 441
            goto __Cont;
          } else {
            {
#line 444
            memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)p,
                   mbclen);
            }
          }
        } else {
          {
#line 447
          memcpy((void */* __restrict  */)(pstr->mbs + byte_idx), (void const   */* __restrict  */)p,
                 mbclen);
          }
        }
        {
#line 449
        tmp___15 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
        }
#line 449
        if (tmp___15) {
#line 452
          i___1 = (size_t )0;
          {
#line 452
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 452
            if (! (i___1 < mbclen)) {
#line 452
              goto while_break___5;
            }
#line 453
            *(pstr->offsets + ((size_t )byte_idx + i___1)) = (Idx )((size_t )src_idx + i___1);
#line 452
            i___1 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 455
        src_idx = (Idx )((size_t )src_idx + mbclen);
#line 457
        tmp___16 = byte_idx;
#line 457
        byte_idx ++;
#line 457
        *(pstr->wcs + tmp___16) = (wint_t )wcu___0;
#line 459
        remain_len = (Idx )(((size_t )byte_idx + mbclen) - 1UL);
        {
#line 459
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 459
          if (! (byte_idx < remain_len)) {
#line 459
            goto while_break___6;
          }
#line 460
          tmp___17 = byte_idx;
#line 460
          byte_idx ++;
#line 460
          *(pstr->wcs + tmp___17) = 4294967295U;
        }
        while_break___6: /* CIL Label */ ;
        }
      } else
#line 462
      if (mbclen == 0xffffffffffffffffUL) {
#line 462
        goto _L___0;
      } else
#line 462
      if (mbclen == 0UL) {
#line 462
        goto _L___0;
      } else
#line 462
      if (mbclen == 0xfffffffffffffffeUL) {
#line 462
        if (pstr->bufs_len >= pstr->len) {
          _L___0: /* CIL Label */ 
          {
#line 466
          ch___1 = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + src_idx));
#line 468
          tmp___18 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                      0L);
          }
#line 468
          if (tmp___18) {
#line 469
            ch___1 = (int )*(pstr->trans + ch___1);
          }
          {
#line 470
          *(pstr->mbs + byte_idx) = (unsigned char )ch___1;
#line 472
          tmp___19 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
          }
#line 472
          if (tmp___19) {
#line 473
            *(pstr->offsets + byte_idx) = src_idx;
          }
          {
#line 474
          src_idx ++;
#line 477
          tmp___20 = byte_idx;
#line 477
          byte_idx ++;
#line 477
          *(pstr->wcs + tmp___20) = (wint_t )ch___1;
#line 478
          tmp___21 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
          }
#line 478
          if (tmp___21) {
#line 479
            pstr->cur_state = prev_st;
          }
        } else {
#line 484
          pstr->cur_state = prev_st;
#line 485
          goto while_break___1;
        }
      } else {
#line 484
        pstr->cur_state = prev_st;
#line 485
        goto while_break___1;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 488
  pstr->valid_len = byte_idx;
#line 489
  pstr->valid_raw_len = src_idx;
#line 490
  return ((reg_errcode_t )0);
}
}
#line 496 "./regex_internal.c"
static Idx re_string_skip_chars(re_string_t *pstr , Idx new_raw_idx , wint_t *last_wc ) 
{ 
  mbstate_t prev_st ;
  Idx rawbuf_idx ;
  size_t mbclen ;
  wint_t wc ;
  wchar_t wc2 ;
  Idx remain_len ;
  int tmp ;
  long tmp___0 ;

  {
#line 502
  wc = 4294967295U;
#line 505
  rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (rawbuf_idx < new_raw_idx)) {
#line 505
      goto while_break;
    }
    {
#line 509
    remain_len = pstr->raw_len - rawbuf_idx;
#line 510
    prev_st = pstr->cur_state;
#line 511
    mbclen = rpl_mbrtowc(& wc2, (char const   *)pstr->raw_mbs + rawbuf_idx, (size_t )remain_len,
                         & pstr->cur_state);
    }
#line 513
    if (mbclen == 0xfffffffffffffffeUL) {
#line 513
      tmp = 1;
    } else
#line 513
    if (mbclen == 0xffffffffffffffffUL) {
#line 513
      tmp = 1;
    } else
#line 513
    if (mbclen == 0UL) {
#line 513
      tmp = 1;
    } else {
#line 513
      tmp = 0;
    }
    {
#line 513
    tmp___0 = __builtin_expect((long )tmp, 0L);
    }
#line 513
    if (tmp___0) {
#line 517
      if (mbclen == 0UL) {
#line 518
        wc = (wint_t )0;
      } else
#line 517
      if (remain_len == 0L) {
#line 518
        wc = (wint_t )0;
      } else {
#line 520
        wc = (wint_t )*((unsigned char *)(pstr->raw_mbs + rawbuf_idx));
      }
#line 521
      mbclen = (size_t )1;
#line 522
      pstr->cur_state = prev_st;
    } else {
#line 525
      wc = (wint_t )wc2;
    }
#line 527
    rawbuf_idx = (Idx )((size_t )rawbuf_idx + mbclen);
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  *last_wc = wc;
#line 530
  return (rawbuf_idx);
}
}
#line 537 "./regex_internal.c"
static void build_upper_buffer(re_string_t *pstr ) 
{ 
  Idx char_idx ;
  Idx end_idx ;
  int ch ;
  long tmp ;
  int __res ;
  __int32_t const   **tmp___1 ;

  {
#line 541
  if (pstr->bufs_len > pstr->len) {
#line 541
    end_idx = pstr->len;
  } else {
#line 541
    end_idx = pstr->bufs_len;
  }
#line 543
  char_idx = pstr->valid_len;
  {
#line 543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 543
    if (! (char_idx < end_idx)) {
#line 543
      goto while_break;
    }
    {
#line 545
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + char_idx));
#line 546
    tmp = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                           0L);
    }
#line 546
    if (tmp) {
#line 547
      ch = (int )*(pstr->trans + ch);
    }
#line 548
    if (sizeof(ch) > 1UL) {
      {
#line 548
      __res = toupper(ch);
      }
    } else {
      {
#line 548
      tmp___1 = __ctype_toupper_loc();
#line 548
      __res = (int )*(*tmp___1 + ch);
      }
    }
#line 548
    *(pstr->mbs + char_idx) = (unsigned char )__res;
#line 543
    char_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 550
  pstr->valid_len = char_idx;
#line 551
  pstr->valid_raw_len = char_idx;
#line 552
  return;
}
}
#line 556 "./regex_internal.c"
static void re_string_translate_buffer(re_string_t *pstr ) 
{ 
  Idx buf_idx ;
  Idx end_idx ;
  int ch ;

  {
#line 560
  if (pstr->bufs_len > pstr->len) {
#line 560
    end_idx = pstr->len;
  } else {
#line 560
    end_idx = pstr->bufs_len;
  }
#line 562
  buf_idx = pstr->valid_len;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (buf_idx < end_idx)) {
#line 562
      goto while_break;
    }
#line 564
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + buf_idx));
#line 565
    *(pstr->mbs + buf_idx) = *(pstr->trans + ch);
#line 562
    buf_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  pstr->valid_len = buf_idx;
#line 569
  pstr->valid_raw_len = buf_idx;
#line 570
  return;
}
}
#line 576 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_string_reconstruct)(re_string_t *pstr ,
                                                                                      Idx idx ,
                                                                                      int eflags ) 
{ 
  Idx offset ;
  long tmp ;
  Idx low ;
  Idx high ;
  Idx mid ;
  long tmp___0 ;
  long tmp___1 ;
  Idx prev_valid_len ;
  long tmp___2 ;
  Idx wcs_idx ;
  wint_t wc ;
  unsigned char const   *raw ;
  unsigned char const   *p ;
  unsigned char const   *end ;
  mbstate_t cur_state ;
  wchar_t wc2 ;
  Idx mlen ;
  unsigned char buf[6] ;
  size_t mbclen ;
  unsigned char const   *pp ;
  int i ;
  Idx tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int c ;
  int tmp___13 ;
  _Bool tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;

  {
  {
#line 582
  tmp = __builtin_expect((long )(pstr->raw_mbs_idx <= idx), 0L);
  }
#line 582
  if (tmp) {
#line 583
    offset = idx - pstr->raw_mbs_idx;
  } else {
#line 588
    if (pstr->mb_cur_max > 1) {
      {
#line 589
      memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
      }
    }
#line 591
    pstr->len = pstr->raw_len;
#line 592
    pstr->stop = pstr->raw_stop;
#line 593
    pstr->valid_len = (Idx )0;
#line 594
    pstr->raw_mbs_idx = (Idx )0;
#line 595
    pstr->valid_raw_len = (Idx )0;
#line 596
    pstr->offsets_needed = (unsigned char)0;
#line 597
    if (eflags & 1) {
#line 597
      pstr->tip_context = (unsigned int )((1 << 1) << 1);
    } else {
#line 597
      pstr->tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
    }
#line 599
    if (! pstr->mbs_allocated) {
#line 600
      pstr->mbs = (unsigned char *)pstr->raw_mbs;
    }
#line 601
    offset = idx;
  }
  {
#line 604
  tmp___17 = __builtin_expect((long )(offset != 0L), 1L);
  }
#line 604
  if (tmp___17) {
    {
#line 607
    tmp___15 = __builtin_expect((long )(offset < pstr->valid_raw_len), 1L);
    }
#line 607
    if (tmp___15) {
      {
#line 611
      tmp___1 = __builtin_expect((long )pstr->offsets_needed, 0L);
      }
#line 611
      if (tmp___1) {
#line 613
        low = (Idx )0;
#line 613
        high = pstr->valid_len;
        {
#line 614
        while (1) {
          while_continue: /* CIL Label */ ;
#line 616
          mid = (high + low) / 2L;
#line 617
          if (*(pstr->offsets + mid) > offset) {
#line 618
            high = mid;
          } else
#line 619
          if (*(pstr->offsets + mid) < offset) {
#line 620
            low = mid + 1L;
          } else {
#line 622
            goto while_break;
          }
#line 614
          if (! (low < high)) {
#line 614
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 625
        if (*(pstr->offsets + mid) < offset) {
#line 626
          mid ++;
        }
        {
#line 627
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, mid - 1L,
                                                 eflags);
        }
#line 633
        if (pstr->valid_len > offset) {
#line 633
          if (mid == offset) {
#line 633
            if (*(pstr->offsets + mid) == offset) {
              {
#line 636
              memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (unsigned long )(pstr->valid_len - offset) * sizeof(wint_t ));
#line 638
              memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), (size_t )(pstr->valid_len - offset));
#line 639
              pstr->valid_len -= offset;
#line 640
              pstr->valid_raw_len -= offset;
#line 641
              low = (Idx )0;
              }
              {
#line 641
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 641
                if (! (low < pstr->valid_len)) {
#line 641
                  goto while_break___0;
                }
#line 642
                *(pstr->offsets + low) = *(pstr->offsets + (low + offset)) - offset;
#line 641
                low ++;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
#line 633
              goto _L___0;
            }
          } else {
#line 633
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 648
          pstr->len = (pstr->raw_len - idx) + offset;
#line 649
          pstr->stop = (pstr->raw_stop - idx) + offset;
#line 650
          pstr->offsets_needed = (unsigned char)0;
          {
#line 651
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 651
            if (mid > 0L) {
#line 651
              if (! (*(pstr->offsets + (mid - 1L)) == offset)) {
#line 651
                goto while_break___1;
              }
            } else {
#line 651
              goto while_break___1;
            }
#line 652
            mid --;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 653
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 653
            if (! (mid < pstr->valid_len)) {
#line 653
              goto while_break___2;
            }
#line 654
            if (*(pstr->wcs + mid) != 4294967295U) {
#line 655
              goto while_break___2;
            } else {
#line 657
              mid ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 658
          if (mid == pstr->valid_len) {
#line 659
            pstr->valid_len = (Idx )0;
          } else {
#line 662
            pstr->valid_len = *(pstr->offsets + mid) - offset;
#line 663
            if (pstr->valid_len) {
#line 665
              low = (Idx )0;
              {
#line 665
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 665
                if (! (low < pstr->valid_len)) {
#line 665
                  goto while_break___3;
                }
#line 666
                *(pstr->wcs + low) = 4294967295U;
#line 665
                low ++;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 667
              memset((void *)pstr->mbs, 255, (size_t )pstr->valid_len);
              }
            }
          }
#line 670
          pstr->valid_raw_len = pstr->valid_len;
        }
      } else {
        {
#line 676
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, offset - 1L,
                                                 eflags);
        }
#line 679
        if (pstr->mb_cur_max > 1) {
          {
#line 680
          memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (unsigned long )(pstr->valid_len - offset) * sizeof(wint_t ));
          }
        }
        {
#line 683
        tmp___0 = __builtin_expect((long )pstr->mbs_allocated, 0L);
        }
#line 683
        if (tmp___0) {
          {
#line 684
          memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), (size_t )(pstr->valid_len - offset));
          }
        }
#line 686
        pstr->valid_len -= offset;
#line 687
        pstr->valid_raw_len -= offset;
#line 688
        if (! (pstr->valid_len > 0L)) {
          {
#line 688
          __builtin_unreachable();
          }
        }
      }
    } else {
      {
#line 695
      prev_valid_len = pstr->valid_len;
#line 697
      tmp___2 = __builtin_expect((long )pstr->offsets_needed, 0L);
      }
#line 697
      if (tmp___2) {
#line 699
        pstr->len = (pstr->raw_len - idx) + offset;
#line 700
        pstr->stop = (pstr->raw_stop - idx) + offset;
#line 701
        pstr->offsets_needed = (unsigned char)0;
      }
#line 704
      pstr->valid_len = (Idx )0;
#line 706
      if (pstr->mb_cur_max > 1) {
#line 709
        wc = 4294967295U;
#line 711
        if (pstr->is_utf8) {
#line 717
          raw = pstr->raw_mbs + pstr->raw_mbs_idx;
#line 718
          end = raw + (offset - (Idx )pstr->mb_cur_max);
#line 719
          if ((unsigned long )end < (unsigned long )pstr->raw_mbs) {
#line 720
            end = pstr->raw_mbs;
          }
#line 721
          p = (raw + offset) - 1;
          {
#line 733
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 733
            if (! ((unsigned long )p >= (unsigned long )end)) {
#line 733
              goto while_break___4;
            }
#line 734
            if (((int const   )*p & 192) != 128) {
              {
#line 738
              mlen = (raw + pstr->len) - p;
#line 742
              pp = p;
#line 743
              tmp___4 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                         0L);
              }
#line 743
              if (tmp___4) {
#line 745
                if (mlen < 6L) {
#line 745
                  tmp___3 = mlen;
                } else {
#line 745
                  tmp___3 = (Idx )6;
                }
#line 745
                i = (int )tmp___3;
                {
#line 746
                while (1) {
                  while_continue___5: /* CIL Label */ ;
#line 746
                  i --;
#line 746
                  if (! (i >= 0)) {
#line 746
                    goto while_break___5;
                  }
#line 747
                  buf[i] = *(pstr->trans + *(p + i));
                }
                while_break___5: /* CIL Label */ ;
                }
#line 748
                pp = (unsigned char const   *)(buf);
              }
              {
#line 752
              memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 753
              mbclen = rpl_mbrtowc(& wc2, (char const   *)pp, (size_t )mlen, & cur_state);
              }
#line 755
              if ((size_t )((raw + offset) - p) <= mbclen) {
#line 755
                if (mbclen < 0xfffffffffffffffeUL) {
                  {
#line 758
                  memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
#line 760
                  pstr->valid_len = (Idx )(mbclen - (size_t )((raw + offset) - p));
#line 761
                  wc = (wint_t )wc2;
                  }
                }
              }
#line 763
              goto while_break___4;
            }
#line 733
            p --;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 767
        if (wc == 4294967295U) {
          {
#line 768
          tmp___5 = re_string_skip_chars(pstr, idx, & wc);
#line 768
          pstr->valid_len = tmp___5 - idx;
          }
        }
#line 769
        if (wc == 4294967295U) {
          {
#line 770
          pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, prev_valid_len - 1L,
                                                   eflags);
          }
        } else {
          {
#line 773
          tmp___9 = __builtin_expect((long )((int )pstr->word_ops_used != 0), 0L);
          }
#line 773
          if (tmp___9) {
            {
#line 773
            tmp___10 = iswalnum(wc);
            }
#line 773
            if (tmp___10) {
#line 773
              pstr->tip_context = 1U;
            } else
#line 773
            if (wc == 95U) {
#line 773
              pstr->tip_context = 1U;
            } else {
#line 773
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 773
            if (wc == 10U) {
#line 773
              if (pstr->newline_anchor) {
#line 773
                tmp___8 = 1 << 1;
              } else {
#line 773
                tmp___8 = 0;
              }
            } else {
#line 773
              tmp___8 = 0;
            }
#line 773
            pstr->tip_context = (unsigned int )tmp___8;
          }
        }
        {
#line 779
        tmp___11 = __builtin_expect(pstr->valid_len, 0L);
        }
#line 779
        if (tmp___11) {
#line 781
          wcs_idx = (Idx )0;
          {
#line 781
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 781
            if (! (wcs_idx < pstr->valid_len)) {
#line 781
              goto while_break___6;
            }
#line 782
            *(pstr->wcs + wcs_idx) = 4294967295U;
#line 781
            wcs_idx ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 783
          if (pstr->mbs_allocated) {
            {
#line 784
            memset((void *)pstr->mbs, 255, (size_t )pstr->valid_len);
            }
          }
        }
#line 786
        pstr->valid_raw_len = pstr->valid_len;
      } else {
#line 791
        c = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + offset) - 1L));
#line 792
        pstr->valid_raw_len = (Idx )0;
#line 793
        if (pstr->trans) {
#line 794
          c = (int )*(pstr->trans + c);
        }
        {
#line 795
        tmp___14 = bitset_contain((bitset_word_t */* const  */)pstr->word_char, (Idx )c);
        }
#line 795
        if (tmp___14) {
#line 795
          pstr->tip_context = 1U;
        } else {
#line 795
          if (c == 10) {
#line 795
            if (pstr->newline_anchor) {
#line 795
              tmp___13 = 1 << 1;
            } else {
#line 795
              tmp___13 = 0;
            }
          } else {
#line 795
            tmp___13 = 0;
          }
#line 795
          pstr->tip_context = (unsigned int )tmp___13;
        }
      }
    }
    {
#line 801
    tmp___16 = __builtin_expect((long )pstr->mbs_allocated, 0L);
    }
#line 801
    if (! tmp___16) {
#line 802
      pstr->mbs += offset;
    }
  }
#line 804
  pstr->raw_mbs_idx = idx;
#line 805
  pstr->len -= offset;
#line 806
  pstr->stop -= offset;
#line 810
  if (pstr->mb_cur_max > 1) {
#line 812
    if (pstr->icase) {
      {
#line 814
      tmp___18 = build_wcs_upper_buffer(pstr);
#line 814
      ret = tmp___18;
#line 815
      tmp___19 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 815
      if (tmp___19) {
#line 816
        return (ret);
      }
    } else {
      {
#line 819
      build_wcs_buffer(pstr);
      }
    }
  } else {
    {
#line 823
    tmp___20 = __builtin_expect((long )pstr->mbs_allocated, 0L);
    }
#line 823
    if (tmp___20) {
#line 825
      if (pstr->icase) {
        {
#line 826
        build_upper_buffer(pstr);
        }
      } else
#line 827
      if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
        {
#line 828
        re_string_translate_buffer(pstr);
        }
      }
    } else {
#line 831
      pstr->valid_len = pstr->len;
    }
  }
#line 833
  pstr->cur_idx = (Idx )0;
#line 834
  return ((reg_errcode_t )0);
}
}
#line 837 "./regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_peek_byte_case(re_string_t const   *pstr ,
                                                                         Idx idx ) 
{ 
  int ch ;
  Idx off ;
  long tmp ;

  {
  {
#line 845
  tmp = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
#line 845
  if (tmp) {
#line 846
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
  }
#line 849
  if (pstr->mb_cur_max > 1) {
#line 849
    if (*(pstr->wcs + (pstr->cur_idx + (Idx const   )idx)) != 4294967295U) {
#line 849
      if (! (pstr->valid_len == (pstr->cur_idx + (Idx const   )idx) + 1L)) {
#line 849
        if (! (*(pstr->wcs + ((pstr->cur_idx + (Idx const   )idx) + 1L)) != 4294967295U)) {
#line 851
          return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
        }
      }
    } else {
#line 851
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 854
  off = (Idx )(pstr->cur_idx + (Idx const   )idx);
#line 856
  if (pstr->offsets_needed) {
#line 857
    off = *(pstr->offsets + off);
  }
#line 860
  ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + (Idx const   )off));
#line 867
  if (pstr->offsets_needed) {
#line 867
    if (! ((ch & -128) == 0)) {
#line 868
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 871
  return ((unsigned char __attribute__((__pure__))  )ch);
}
}
#line 874 "./regex_internal.c"
static unsigned char re_string_fetch_byte_case(re_string_t *pstr ) 
{ 
  Idx tmp ;
  long tmp___0 ;
  Idx off ;
  int ch ;
  Idx tmp___1 ;
  Idx tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  Idx tmp___4 ;

  {
  {
#line 877
  tmp___0 = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
  }
#line 877
  if (tmp___0) {
#line 878
    tmp = pstr->cur_idx;
#line 878
    (pstr->cur_idx) ++;
#line 878
    return (*(pstr->mbs + tmp));
  }
#line 881
  if (pstr->offsets_needed) {
#line 893
    if (! (pstr->cur_idx == pstr->valid_len)) {
#line 893
      if (! (*(pstr->wcs + pstr->cur_idx) != 4294967295U)) {
#line 894
        tmp___1 = pstr->cur_idx;
#line 894
        (pstr->cur_idx) ++;
#line 894
        return (*(pstr->mbs + tmp___1));
      }
    }
#line 896
    off = *(pstr->offsets + pstr->cur_idx);
#line 897
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + off));
#line 899
    if (! ((ch & -128) == 0)) {
#line 900
      tmp___2 = pstr->cur_idx;
#line 900
      (pstr->cur_idx) ++;
#line 900
      return (*(pstr->mbs + tmp___2));
    }
    {
#line 902
    tmp___3 = re_string_char_size_at((re_string_t const   *)pstr, pstr->cur_idx);
#line 902
    pstr->cur_idx += (Idx )tmp___3;
    }
#line 904
    return ((unsigned char )ch);
  }
#line 908
  tmp___4 = pstr->cur_idx;
#line 908
  (pstr->cur_idx) ++;
#line 908
  return ((unsigned char )*(pstr->raw_mbs + (pstr->raw_mbs_idx + tmp___4)));
}
}
#line 911 "./regex_internal.c"
static void re_string_destruct(re_string_t *pstr ) 
{ 


  {
  {
#line 915
  free((void *)pstr->wcs);
#line 916
  free((void *)pstr->offsets);
  }
#line 918
  if (pstr->mbs_allocated) {
    {
#line 919
    free((void *)pstr->mbs);
    }
  }
#line 920
  return;
}
}
#line 924
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags )  __attribute__((__pure__)) ;
#line 924 "./regex_internal.c"
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags ) 
{ 
  int c ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  wint_t wc ;
  Idx wc_idx ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;

  {
  {
#line 928
  tmp = __builtin_expect((long )(idx < 0L), 0L);
  }
#line 928
  if (tmp) {
#line 931
    return ((unsigned int )input->tip_context);
  }
  {
#line 932
  tmp___1 = __builtin_expect((long )(idx == (Idx )input->len), 0L);
  }
#line 932
  if (tmp___1) {
#line 933
    if (eflags & (1 << 1)) {
#line 933
      tmp___0 = ((1 << 1) << 1) << 1;
    } else {
#line 933
      tmp___0 = (1 << 1) | (((1 << 1) << 1) << 1);
    }
#line 933
    return ((unsigned int )tmp___0);
  }
#line 936
  if (input->mb_cur_max > 1) {
#line 939
    wc_idx = idx;
    {
#line 940
    while (1) {
      while_continue: /* CIL Label */ ;
#line 940
      if (! (*(input->wcs + wc_idx) == 4294967295U)) {
#line 940
        goto while_break;
      }
#line 942
      if (! (wc_idx >= 0L)) {
        {
#line 942
        __builtin_unreachable();
        }
      }
#line 943
      wc_idx --;
#line 944
      if (wc_idx < 0L) {
#line 945
        return ((unsigned int )input->tip_context);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 947
    wc = *(input->wcs + wc_idx);
#line 948
    tmp___2 = __builtin_expect((long )((int const   )input->word_ops_used != 0), 0L);
    }
#line 948
    if (tmp___2) {
      {
#line 948
      tmp___3 = iswalnum(wc);
      }
#line 948
      if (tmp___3) {
#line 950
        return (1U);
      } else
#line 948
      if (wc == 95U) {
#line 950
        return (1U);
      }
    }
#line 951
    if (wc == 10U) {
#line 951
      if (input->newline_anchor) {
#line 951
        tmp___4 = 1 << 1;
      } else {
#line 951
        tmp___4 = 0;
      }
    } else {
#line 951
      tmp___4 = 0;
    }
#line 951
    return ((unsigned int )tmp___4);
  } else {
    {
#line 957
    c = (int )*(input->mbs + idx);
#line 958
    tmp___5 = bitset_contain((bitset_word_t */* const  */)input->word_char, (Idx )c);
    }
#line 958
    if (tmp___5) {
#line 959
      return (1U);
    }
#line 960
    if (c == 10) {
#line 960
      if (input->newline_anchor) {
#line 960
        tmp___6 = 1 << 1;
      } else {
#line 960
        tmp___6 = 0;
      }
    } else {
#line 960
      tmp___6 = 0;
    }
#line 960
    return ((unsigned int )tmp___6);
  }
}
}
#line 966 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_node_set_alloc)(re_node_set *set ,
                                                                                  Idx size ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 970
  set->alloc = size;
#line 971
  set->nelem = (Idx )0;
#line 972
  tmp = malloc((unsigned long )size * sizeof(Idx ));
#line 972
  set->elems = (Idx *)tmp;
#line 973
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 973
  if (tmp___0) {
#line 975
    return ((reg_errcode_t )12);
  }
#line 976
  return ((reg_errcode_t )0);
}
}
#line 979 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_node_set_init_1)(re_node_set *set ,
                                                                                   Idx elem ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
  {
#line 983
  set->alloc = (Idx )1;
#line 984
  set->nelem = (Idx )1;
#line 985
  tmp = malloc(sizeof(Idx ));
#line 985
  set->elems = (Idx *)tmp;
#line 986
  tmp___1 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 986
  if (tmp___1) {
#line 988
    tmp___0 = (Idx )0;
#line 988
    set->nelem = tmp___0;
#line 988
    set->alloc = tmp___0;
#line 989
    return ((reg_errcode_t )12);
  }
#line 991
  *(set->elems + 0) = elem;
#line 992
  return ((reg_errcode_t )0);
}
}
#line 995 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_node_set_init_2)(re_node_set *set ,
                                                                                   Idx elem1 ,
                                                                                   Idx elem2 ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 999
  set->alloc = (Idx )2;
#line 1000
  tmp = malloc(2UL * sizeof(Idx ));
#line 1000
  set->elems = (Idx *)tmp;
#line 1001
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
  }
#line 1001
  if (tmp___0) {
#line 1002
    return ((reg_errcode_t )12);
  }
#line 1003
  if (elem1 == elem2) {
#line 1005
    set->nelem = (Idx )1;
#line 1006
    *(set->elems + 0) = elem1;
  } else {
#line 1010
    set->nelem = (Idx )2;
#line 1011
    if (elem1 < elem2) {
#line 1013
      *(set->elems + 0) = elem1;
#line 1014
      *(set->elems + 1) = elem2;
    } else {
#line 1018
      *(set->elems + 0) = elem2;
#line 1019
      *(set->elems + 1) = elem1;
    }
  }
#line 1022
  return ((reg_errcode_t )0);
}
}
#line 1025 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_node_set_init_copy)(re_node_set *dest ,
                                                                                      re_node_set const   *src ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
#line 1029
  dest->nelem = (Idx )src->nelem;
#line 1030
  if (src->nelem > 0L) {
    {
#line 1032
    dest->alloc = dest->nelem;
#line 1033
    tmp = malloc((unsigned long )dest->alloc * sizeof(Idx ));
#line 1033
    dest->elems = (Idx *)tmp;
#line 1034
    tmp___1 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1034
    if (tmp___1) {
#line 1036
      tmp___0 = (Idx )0;
#line 1036
      dest->nelem = tmp___0;
#line 1036
      dest->alloc = tmp___0;
#line 1037
      return ((reg_errcode_t )12);
    }
    {
#line 1039
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(Idx ));
    }
  } else {
    {
#line 1042
    memset((void *)dest, '\000', sizeof(re_node_set ));
    }
  }
#line 1043
  return ((reg_errcode_t )0);
}
}
#line 1050 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_node_set_add_intersect)(re_node_set *dest ,
                                                                                          re_node_set const   *src1 ,
                                                                                          re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx is ;
  Idx id ;
  Idx delta ;
  Idx sbase ;
  Idx new_alloc ;
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  Idx tmp___2 ;

  {
#line 1056
  if (src1->nelem == 0L) {
#line 1057
    return ((reg_errcode_t )0);
  } else
#line 1056
  if (src2->nelem == 0L) {
#line 1057
    return ((reg_errcode_t )0);
  }
#line 1061
  if ((src1->nelem + src2->nelem) + (Idx const   )dest->nelem > (Idx const   )dest->alloc) {
    {
#line 1063
    new_alloc = (Idx )((src1->nelem + src2->nelem) + (Idx const   )dest->alloc);
#line 1064
    tmp = realloc((void *)dest->elems, (unsigned long )new_alloc * sizeof(Idx ));
#line 1064
    new_elems = (Idx *)tmp;
#line 1065
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1065
    if (tmp___0) {
#line 1066
      return ((reg_errcode_t )12);
    }
#line 1067
    dest->elems = new_elems;
#line 1068
    dest->alloc = new_alloc;
  }
#line 1073
  sbase = (dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem;
#line 1074
  i1 = (Idx )(src1->nelem - 1L);
#line 1075
  i2 = (Idx )(src2->nelem - 1L);
#line 1076
  id = dest->nelem - 1L;
  {
#line 1077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1079
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
      {
#line 1082
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1082
        if (id >= 0L) {
#line 1082
          if (! (*(dest->elems + id) > *(src1->elems + i1))) {
#line 1082
            goto while_break___0;
          }
        } else {
#line 1082
          goto while_break___0;
        }
#line 1083
        id --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1085
      if (id < 0L) {
#line 1086
        sbase --;
#line 1086
        *(dest->elems + sbase) = *(src1->elems + i1);
      } else
#line 1085
      if (*(dest->elems + id) != *(src1->elems + i1)) {
#line 1086
        sbase --;
#line 1086
        *(dest->elems + sbase) = *(src1->elems + i1);
      }
#line 1088
      i1 --;
#line 1088
      if (i1 < 0L) {
#line 1089
        goto while_break;
      } else {
#line 1088
        i2 --;
#line 1088
        if (i2 < 0L) {
#line 1089
          goto while_break;
        }
      }
    } else
#line 1093
    if (*(src1->elems + i1) < *(src2->elems + i2)) {
#line 1095
      i2 --;
#line 1095
      if (i2 < 0L) {
#line 1096
        goto while_break;
      }
    } else {
#line 1100
      i1 --;
#line 1100
      if (i1 < 0L) {
#line 1101
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1105
  id = dest->nelem - 1L;
#line 1106
  is = ((dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem) - 1L;
#line 1107
  delta = (is - sbase) + 1L;
#line 1112
  dest->nelem += delta;
#line 1113
  if (delta > 0L) {
#line 1113
    if (id >= 0L) {
      {
#line 1114
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1116
        if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1119
          tmp___1 = delta;
#line 1119
          delta --;
#line 1119
          tmp___2 = is;
#line 1119
          is --;
#line 1119
          *(dest->elems + (id + tmp___1)) = *(dest->elems + tmp___2);
#line 1120
          if (delta == 0L) {
#line 1121
            goto while_break___1;
          }
        } else {
#line 1126
          *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1127
          id --;
#line 1127
          if (id < 0L) {
#line 1128
            goto while_break___1;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  {
#line 1133
  memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
         (unsigned long )delta * sizeof(Idx ));
  }
#line 1135
  return ((reg_errcode_t )0);
}
}
#line 1141 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_node_set_init_union)(re_node_set *dest ,
                                                                                       re_node_set const   *src1 ,
                                                                                       re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx id ;
  void *tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  reg_errcode_t tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 1147
  if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1147
    if (src1->nelem > 0L) {
#line 1147
      if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1147
        if (src2->nelem > 0L) {
          {
#line 1149
          dest->alloc = (Idx )(src1->nelem + src2->nelem);
#line 1150
          tmp = malloc((unsigned long )dest->alloc * sizeof(Idx ));
#line 1150
          dest->elems = (Idx *)tmp;
#line 1151
          tmp___0 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                     0L);
          }
#line 1151
          if (tmp___0) {
#line 1152
            return ((reg_errcode_t )12);
          }
        } else {
#line 1147
          goto _L___2;
        }
      } else {
#line 1147
        goto _L___2;
      }
    } else {
#line 1147
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 1156
    if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1156
      if (src1->nelem > 0L) {
        {
#line 1157
        tmp___1 = re_node_set_init_copy(dest, src1);
        }
#line 1157
        return (tmp___1);
      } else {
#line 1156
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1158
    if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1158
      if (src2->nelem > 0L) {
        {
#line 1159
        tmp___2 = re_node_set_init_copy(dest, src2);
        }
#line 1159
        return (tmp___2);
      } else {
        {
#line 1161
        memset((void *)dest, '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 1161
      memset((void *)dest, '\000', sizeof(re_node_set ));
      }
    }
#line 1162
    return ((reg_errcode_t )0);
  }
#line 1164
  id = (Idx )0;
#line 1164
  i2 = id;
#line 1164
  i1 = i2;
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    if (i1 < (Idx )src1->nelem) {
#line 1164
      if (! (i2 < (Idx )src2->nelem)) {
#line 1164
        goto while_break;
      }
    } else {
#line 1164
      goto while_break;
    }
#line 1166
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 1168
      tmp___3 = id;
#line 1168
      id ++;
#line 1168
      tmp___4 = i2;
#line 1168
      i2 ++;
#line 1168
      *(dest->elems + tmp___3) = *(src2->elems + tmp___4);
#line 1169
      goto __Cont;
    }
#line 1171
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1172
      i2 ++;
    }
#line 1173
    tmp___5 = id;
#line 1173
    id ++;
#line 1173
    tmp___6 = i1;
#line 1173
    i1 ++;
#line 1173
    *(dest->elems + tmp___5) = *(src1->elems + tmp___6);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1175
  if (i1 < (Idx )src1->nelem) {
    {
#line 1177
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src1->elems + i1),
           (unsigned long )(src1->nelem - (Idx const   )i1) * sizeof(Idx ));
#line 1179
    id += (Idx )(src1->nelem - (Idx const   )i1);
    }
  } else
#line 1181
  if (i2 < (Idx )src2->nelem) {
    {
#line 1183
    memcpy((void */* __restrict  */)(dest->elems + id), (void const   */* __restrict  */)(src2->elems + i2),
           (unsigned long )(src2->nelem - (Idx const   )i2) * sizeof(Idx ));
#line 1185
    id += (Idx )(src2->nelem - (Idx const   )i2);
    }
  }
#line 1187
  dest->nelem = id;
#line 1188
  return ((reg_errcode_t )0);
}
}
#line 1194 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_node_set_merge)(re_node_set *dest ,
                                                                                  re_node_set const   *src ) 
{ 
  Idx is ;
  Idx id ;
  Idx sbase ;
  Idx delta ;
  Idx new_alloc ;
  Idx *new_buffer ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;

  {
#line 1199
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1200
    return ((reg_errcode_t )0);
  } else
#line 1199
  if (src->nelem == 0L) {
#line 1200
    return ((reg_errcode_t )0);
  }
#line 1201
  if (dest->alloc < (Idx )(2L * src->nelem + (Idx const   )dest->nelem)) {
    {
#line 1203
    new_alloc = (Idx )(2L * (src->nelem + (Idx const   )dest->alloc));
#line 1204
    tmp = realloc((void *)dest->elems, (unsigned long )new_alloc * sizeof(Idx ));
#line 1204
    new_buffer = (Idx *)tmp;
#line 1205
    tmp___0 = __builtin_expect((long )((unsigned long )new_buffer == (unsigned long )((void *)0)),
                               0L);
    }
#line 1205
    if (tmp___0) {
#line 1206
      return ((reg_errcode_t )12);
    }
#line 1207
    dest->elems = new_buffer;
#line 1208
    dest->alloc = new_alloc;
  }
  {
#line 1211
  tmp___1 = __builtin_expect((long )(dest->nelem == 0L), 0L);
  }
#line 1211
  if (tmp___1) {
    {
#line 1213
    dest->nelem = (Idx )src->nelem;
#line 1214
    memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)src->elems,
           (unsigned long )src->nelem * sizeof(Idx ));
    }
#line 1215
    return ((reg_errcode_t )0);
  }
#line 1220
  sbase = dest->nelem + (Idx )(2L * src->nelem);
#line 1220
  is = (Idx )(src->nelem - 1L);
#line 1220
  id = dest->nelem - 1L;
  {
#line 1220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1220
    if (is >= 0L) {
#line 1220
      if (! (id >= 0L)) {
#line 1220
        goto while_break;
      }
    } else {
#line 1220
      goto while_break;
    }
#line 1223
    if (*(dest->elems + id) == *(src->elems + is)) {
#line 1224
      is --;
#line 1224
      id --;
    } else
#line 1225
    if (*(dest->elems + id) < *(src->elems + is)) {
#line 1226
      sbase --;
#line 1226
      tmp___2 = is;
#line 1226
      is --;
#line 1226
      *(dest->elems + sbase) = *(src->elems + tmp___2);
    } else {
#line 1228
      id --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1231
  if (is >= 0L) {
    {
#line 1234
    sbase -= is + 1L;
#line 1235
    memcpy((void */* __restrict  */)(dest->elems + sbase), (void const   */* __restrict  */)src->elems,
           (unsigned long )(is + 1L) * sizeof(Idx ));
    }
  }
#line 1238
  id = dest->nelem - 1L;
#line 1239
  is = (dest->nelem + (Idx )(2L * src->nelem)) - 1L;
#line 1240
  delta = (is - sbase) + 1L;
#line 1241
  if (delta == 0L) {
#line 1242
    return ((reg_errcode_t )0);
  }
#line 1246
  dest->nelem += delta;
  {
#line 1247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1249
    if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1252
      tmp___3 = delta;
#line 1252
      delta --;
#line 1252
      tmp___4 = is;
#line 1252
      is --;
#line 1252
      *(dest->elems + (id + tmp___3)) = *(dest->elems + tmp___4);
#line 1253
      if (delta == 0L) {
#line 1254
        goto while_break___0;
      }
    } else {
#line 1259
      *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1260
      id --;
#line 1260
      if (id < 0L) {
        {
#line 1263
        memcpy((void */* __restrict  */)dest->elems, (void const   */* __restrict  */)(dest->elems + sbase),
               (unsigned long )delta * sizeof(Idx ));
        }
#line 1265
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1270
  return ((reg_errcode_t )0);
}
}
#line 1277 "./regex_internal.c"
static _Bool ( __attribute__((__warn_unused_result__)) re_node_set_insert)(re_node_set *set ,
                                                                           Idx elem ) 
{ 
  Idx idx ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx *new_elems ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 1283
  if (set->alloc == 0L) {
    {
#line 1284
    tmp = re_node_set_init_1(set, elem);
#line 1284
    tmp___0 = __builtin_expect((long )((int )tmp == 0), 1L);
    }
#line 1284
    return ((_Bool )tmp___0);
  }
  {
#line 1286
  tmp___1 = __builtin_expect(set->nelem, 0L);
  }
#line 1286
  if (tmp___1 == 0L) {
#line 1289
    *(set->elems + 0) = elem;
#line 1290
    (set->nelem) ++;
#line 1291
    return ((_Bool)1);
  }
#line 1295
  if (set->alloc == set->nelem) {
    {
#line 1298
    set->alloc *= 2L;
#line 1299
    tmp___2 = realloc((void *)set->elems, (unsigned long )set->alloc * sizeof(Idx ));
#line 1299
    new_elems = (Idx *)tmp___2;
#line 1300
    tmp___3 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1300
    if (tmp___3) {
#line 1301
      return ((_Bool)0);
    }
#line 1302
    set->elems = new_elems;
  }
#line 1307
  if (elem < *(set->elems + 0)) {
#line 1309
    idx = set->nelem;
    {
#line 1309
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1309
      if (! (idx > 0L)) {
#line 1309
        goto while_break;
      }
#line 1310
      *(set->elems + idx) = *(set->elems + (idx - 1L));
#line 1309
      idx --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1314
    idx = set->nelem;
    {
#line 1314
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1314
      if (! (*(set->elems + (idx - 1L)) > elem)) {
#line 1314
        goto while_break___0;
      }
#line 1315
      *(set->elems + idx) = *(set->elems + (idx - 1L));
#line 1314
      idx --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1319
  *(set->elems + idx) = elem;
#line 1320
  (set->nelem) ++;
#line 1321
  return ((_Bool)1);
}
}
#line 1328 "./regex_internal.c"
static _Bool ( __attribute__((__warn_unused_result__)) re_node_set_insert_last)(re_node_set *set ,
                                                                                Idx elem ) 
{ 
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 1333
  if (set->alloc == set->nelem) {
    {
#line 1336
    set->alloc = (set->alloc + 1L) * 2L;
#line 1337
    tmp = realloc((void *)set->elems, (unsigned long )set->alloc * sizeof(Idx ));
#line 1337
    new_elems = (Idx *)tmp;
#line 1338
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
    }
#line 1338
    if (tmp___0) {
#line 1339
      return ((_Bool)0);
    }
#line 1340
    set->elems = new_elems;
  }
#line 1344
  tmp___1 = set->nelem;
#line 1344
  (set->nelem) ++;
#line 1344
  *(set->elems + tmp___1) = elem;
#line 1345
  return ((_Bool)1);
}
}
#line 1351 "./regex_internal.c"
static _Bool __attribute__((__pure__))  re_node_set_compare(re_node_set const   *set1 ,
                                                            re_node_set const   *set2 ) 
{ 
  Idx i ;

  {
#line 1356
  if ((unsigned long )set1 == (unsigned long )((void *)0)) {
#line 1357
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1356
  if ((unsigned long )set2 == (unsigned long )((void *)0)) {
#line 1357
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1356
  if (set1->nelem != set2->nelem) {
#line 1357
    return ((_Bool __attribute__((__pure__))  )0);
  }
#line 1358
  i = (Idx )set1->nelem;
  {
#line 1358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1358
    i --;
#line 1358
    if (! (i >= 0L)) {
#line 1358
      goto while_break;
    }
#line 1359
    if (*(set1->elems + i) != *(set2->elems + i)) {
#line 1360
      return ((_Bool __attribute__((__pure__))  )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1361
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 1366 "./regex_internal.c"
static Idx __attribute__((__pure__))  re_node_set_contains(re_node_set const   *set ,
                                                           Idx elem ) 
{ 
  __re_size_t idx ;
  __re_size_t right ;
  __re_size_t mid ;
  __re_size_t tmp ;

  {
#line 1371
  if (set->nelem <= 0L) {
#line 1372
    return ((Idx __attribute__((__pure__))  )0);
  }
#line 1375
  idx = (__re_size_t )0;
#line 1376
  right = (__re_size_t )(set->nelem - 1L);
  {
#line 1377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1377
    if (! (idx < right)) {
#line 1377
      goto while_break;
    }
#line 1379
    mid = (idx + right) / 2UL;
#line 1380
    if (*(set->elems + mid) < elem) {
#line 1381
      idx = mid + 1UL;
    } else {
#line 1383
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1385
  if (*(set->elems + idx) == elem) {
#line 1385
    tmp = idx + 1UL;
  } else {
#line 1385
    tmp = (__re_size_t )0;
  }
#line 1385
  return ((Idx __attribute__((__pure__))  )tmp);
}
}
#line 1388 "./regex_internal.c"
static void re_node_set_remove_at(re_node_set *set , Idx idx ) 
{ 


  {
#line 1391
  if (idx < 0L) {
#line 1392
    return;
  } else
#line 1391
  if (idx >= set->nelem) {
#line 1392
    return;
  }
#line 1393
  (set->nelem) --;
  {
#line 1394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1394
    if (! (idx < set->nelem)) {
#line 1394
      goto while_break;
    }
#line 1395
    *(set->elems + idx) = *(set->elems + (idx + 1L));
#line 1394
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1396
  return;
}
}
#line 1402 "./regex_internal.c"
static Idx re_dfa_add_node(re_dfa_t *dfa , re_token_t token ) 
{ 
  size_t new_nodes_alloc ;
  Idx *new_nexts ;
  Idx *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_token_t *new_nodes ;
  size_t max_object_size ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;

  {
  {
#line 1405
  tmp___13 = __builtin_expect((long )(dfa->nodes_len >= dfa->nodes_alloc), 0L);
  }
#line 1405
  if (tmp___13) {
#line 1407
    new_nodes_alloc = dfa->nodes_alloc * 2UL;
#line 1413
    if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1413
      tmp___2 = sizeof(Idx );
    } else {
#line 1413
      tmp___2 = sizeof(re_node_set );
    }
#line 1413
    if (sizeof(re_token_t ) < tmp___2) {
#line 1413
      if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1413
        tmp___0 = sizeof(Idx );
      } else {
#line 1413
        tmp___0 = sizeof(re_node_set );
      }
#line 1413
      tmp___1 = tmp___0;
    } else {
#line 1413
      tmp___1 = sizeof(re_token_t );
    }
#line 1413
    max_object_size = tmp___1;
#line 1416
    if (9223372036854775807UL < 0xffffffffffffffffUL / max_object_size) {
#line 1416
      tmp___3 = 9223372036854775807UL;
    } else {
#line 1416
      tmp___3 = 0xffffffffffffffffUL / max_object_size;
    }
    {
#line 1416
    tmp___4 = __builtin_expect((long )(tmp___3 < new_nodes_alloc), 0L);
    }
#line 1416
    if (tmp___4) {
#line 1418
      return ((Idx )-1);
    }
    {
#line 1420
    tmp___5 = realloc((void *)dfa->nodes, new_nodes_alloc * sizeof(re_token_t ));
#line 1420
    new_nodes = (re_token_t *)tmp___5;
#line 1421
    tmp___6 = __builtin_expect((long )((unsigned long )new_nodes == (unsigned long )((void *)0)),
                               0L);
    }
#line 1421
    if (tmp___6) {
#line 1422
      return ((Idx )-1);
    }
    {
#line 1423
    dfa->nodes = new_nodes;
#line 1424
    tmp___7 = realloc((void *)dfa->nexts, new_nodes_alloc * sizeof(Idx ));
#line 1424
    new_nexts = (Idx *)tmp___7;
#line 1425
    tmp___8 = realloc((void *)dfa->org_indices, new_nodes_alloc * sizeof(Idx ));
#line 1425
    new_indices = (Idx *)tmp___8;
#line 1426
    tmp___9 = realloc((void *)dfa->edests, new_nodes_alloc * sizeof(re_node_set ));
#line 1426
    new_edests = (re_node_set *)tmp___9;
#line 1427
    tmp___10 = realloc((void *)dfa->eclosures, new_nodes_alloc * sizeof(re_node_set ));
#line 1427
    new_eclosures = (re_node_set *)tmp___10;
    }
#line 1428
    if ((unsigned long )new_nexts == (unsigned long )((void *)0)) {
#line 1428
      tmp___11 = 1;
    } else
#line 1428
    if ((unsigned long )new_indices == (unsigned long )((void *)0)) {
#line 1428
      tmp___11 = 1;
    } else
#line 1428
    if ((unsigned long )new_edests == (unsigned long )((void *)0)) {
#line 1428
      tmp___11 = 1;
    } else
#line 1428
    if ((unsigned long )new_eclosures == (unsigned long )((void *)0)) {
#line 1428
      tmp___11 = 1;
    } else {
#line 1428
      tmp___11 = 0;
    }
    {
#line 1428
    tmp___12 = __builtin_expect((long )tmp___11, 0L);
    }
#line 1428
    if (tmp___12) {
      {
#line 1431
      free((void *)new_nexts);
#line 1432
      free((void *)new_indices);
#line 1433
      free((void *)new_edests);
#line 1434
      free((void *)new_eclosures);
      }
#line 1435
      return ((Idx )-1);
    }
#line 1437
    dfa->nexts = new_nexts;
#line 1438
    dfa->org_indices = new_indices;
#line 1439
    dfa->edests = new_edests;
#line 1440
    dfa->eclosures = new_eclosures;
#line 1441
    dfa->nodes_alloc = new_nodes_alloc;
  }
#line 1443
  *(dfa->nodes + dfa->nodes_len) = token;
#line 1444
  (dfa->nodes + dfa->nodes_len)->constraint = 0U;
#line 1446
  if ((unsigned int )token.type == 5U) {
#line 1446
    if (dfa->mb_cur_max > 1) {
#line 1446
      tmp___14 = 1;
    } else {
#line 1446
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1446
  if ((unsigned int )token.type == 6U) {
#line 1446
    tmp___14 = 1;
  } else {
#line 1446
    tmp___14 = 0;
  }
  {
#line 1446
  (dfa->nodes + dfa->nodes_len)->accept_mb = (unsigned int )tmp___14;
#line 1450
  *(dfa->nexts + dfa->nodes_len) = (Idx )-1;
#line 1451
  memset((void *)(dfa->edests + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1452
  memset((void *)(dfa->eclosures + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1453
  tmp___15 = dfa->nodes_len;
#line 1453
  (dfa->nodes_len) ++;
  }
#line 1453
  return ((Idx )tmp___15);
}
}
#line 1456 "./regex_internal.c"
static re_hashval_t calc_state_hash(re_node_set const   *nodes , unsigned int context ) 
{ 
  re_hashval_t hash ;
  Idx i ;

  {
#line 1459
  hash = (re_hashval_t )(nodes->nelem + (Idx const   )context);
#line 1461
  i = (Idx )0;
  {
#line 1461
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1461
    if (! (i < (Idx )nodes->nelem)) {
#line 1461
      goto while_break;
    }
#line 1462
    hash += (re_hashval_t )*(nodes->elems + i);
#line 1461
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1463
  return (hash);
}
}
#line 1475 "./regex_internal.c"
static re_dfastate_t *( __attribute__((__warn_unused_result__)) re_acquire_state)(reg_errcode_t *err ,
                                                                                  re_dfa_t const   *dfa ,
                                                                                  re_node_set const   *nodes ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  long tmp ;
  re_dfastate_t *state ;
  _Bool __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;

  {
  {
#line 1488
  tmp = __builtin_expect((long )(nodes->nelem == 0L), 0L);
  }
#line 1488
  if (tmp) {
#line 1490
    *err = (reg_errcode_t )0;
#line 1491
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1493
  hash = calc_state_hash(nodes, 0U);
#line 1494
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1496
  i = (Idx )0;
  }
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if (! (i < spot->num)) {
#line 1496
      goto while_break;
    }
#line 1498
    state = *(spot->array + i);
#line 1499
    if (hash != state->hash) {
#line 1500
      goto __Cont;
    }
    {
#line 1501
    tmp___0 = re_node_set_compare((re_node_set const   *)(& state->nodes), nodes);
    }
#line 1501
    if (tmp___0) {
#line 1502
      return (state);
    }
    __Cont: /* CIL Label */ 
#line 1496
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1506
  new_state = create_ci_newstate(dfa, nodes, hash);
#line 1507
  tmp___1 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1507
  if (tmp___1) {
#line 1508
    *err = (reg_errcode_t )12;
  }
#line 1510
  return (new_state);
}
}
#line 1523 "./regex_internal.c"
static re_dfastate_t *( __attribute__((__warn_unused_result__)) re_acquire_state_context)(reg_errcode_t *err ,
                                                                                          re_dfa_t const   *dfa ,
                                                                                          re_node_set const   *nodes ,
                                                                                          unsigned int context ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  re_dfastate_t *state ;
  _Bool __attribute__((__pure__))  tmp ;
  long tmp___0 ;

  {
#line 1536
  if (nodes->nelem == 0L) {
#line 1538
    *err = (reg_errcode_t )0;
#line 1539
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1541
  hash = calc_state_hash(nodes, context);
#line 1542
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1544
  i = (Idx )0;
  }
  {
#line 1544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1544
    if (! (i < spot->num)) {
#line 1544
      goto while_break;
    }
#line 1546
    state = *(spot->array + i);
#line 1547
    if (state->hash == hash) {
#line 1547
      if (state->context == context) {
        {
#line 1547
        tmp = re_node_set_compare((re_node_set const   *)state->entrance_nodes, nodes);
        }
#line 1547
        if (tmp) {
#line 1550
          return (state);
        }
      }
    }
#line 1544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1553
  new_state = create_cd_newstate(dfa, nodes, context, hash);
#line 1554
  tmp___0 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1554
  if (tmp___0) {
#line 1555
    *err = (reg_errcode_t )12;
  }
#line 1557
  return (new_state);
}
}
#line 1564 "./regex_internal.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) register_state)(re_dfa_t const   *dfa ,
                                                                               re_dfastate_t *newstate ,
                                                                               re_hashval_t hash ) 
{ 
  struct re_state_table_entry *spot ;
  reg_errcode_t err ;
  Idx i ;
  long tmp ;
  Idx elem ;
  _Bool tmp___0 ;
  Idx new_alloc ;
  re_dfastate_t **new_array ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;

  {
  {
#line 1573
  newstate->hash = hash;
#line 1574
  err = re_node_set_alloc(& newstate->non_eps_nodes, newstate->nodes.nelem);
#line 1575
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1575
  if (tmp) {
#line 1576
    return ((reg_errcode_t )12);
  }
#line 1577
  i = (Idx )0;
  {
#line 1577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1577
    if (! (i < newstate->nodes.nelem)) {
#line 1577
      goto while_break;
    }
#line 1579
    elem = *(newstate->nodes.elems + i);
#line 1580
    if (! ((unsigned int )(dfa->nodes + elem)->type & 8U)) {
      {
#line 1581
      tmp___0 = re_node_set_insert_last(& newstate->non_eps_nodes, elem);
      }
#line 1581
      if (! tmp___0) {
#line 1582
        return ((reg_errcode_t )12);
      }
    }
#line 1577
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1585
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1586
  tmp___3 = __builtin_expect((long )(spot->alloc <= spot->num), 0L);
  }
#line 1586
  if (tmp___3) {
    {
#line 1588
    new_alloc = 2L * spot->num + 2L;
#line 1589
    tmp___1 = realloc((void *)spot->array, (unsigned long )new_alloc * sizeof(re_dfastate_t *));
#line 1589
    new_array = (re_dfastate_t **)tmp___1;
#line 1591
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 1591
    if (tmp___2) {
#line 1592
      return ((reg_errcode_t )12);
    }
#line 1593
    spot->array = new_array;
#line 1594
    spot->alloc = new_alloc;
  }
#line 1596
  tmp___4 = spot->num;
#line 1596
  (spot->num) ++;
#line 1596
  *(spot->array + tmp___4) = newstate;
#line 1597
  return ((reg_errcode_t )0);
}
}
#line 1600 "./regex_internal.c"
static void free_state(re_dfastate_t *state ) 
{ 


  {
  {
#line 1603
  free((void *)state->non_eps_nodes.elems);
#line 1604
  free((void *)state->inveclosure.elems);
  }
#line 1605
  if ((unsigned long )state->entrance_nodes != (unsigned long )(& state->nodes)) {
    {
#line 1607
    free((void *)(state->entrance_nodes)->elems);
#line 1608
    free((void *)state->entrance_nodes);
    }
  }
  {
#line 1610
  free((void *)state->nodes.elems);
#line 1611
  free((void *)state->word_trtable);
#line 1612
  free((void *)state->trtable);
#line 1613
  free((void *)state);
  }
#line 1614
  return;
}
}
#line 1619 "./regex_internal.c"
static re_dfastate_t *( __attribute__((__warn_unused_result__)) create_ci_newstate)(re_dfa_t const   *dfa ,
                                                                                    re_node_set const   *nodes ,
                                                                                    re_hashval_t hash ) 
{ 
  Idx i ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  long tmp___2 ;

  {
  {
#line 1628
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1628
  newstate = (re_dfastate_t *)tmp;
#line 1629
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1629
  if (tmp___0) {
#line 1630
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1631
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1632
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1632
  if (tmp___1) {
    {
#line 1634
    free((void *)newstate);
    }
#line 1635
    return ((re_dfastate_t *)((void *)0));
  }
#line 1638
  newstate->entrance_nodes = & newstate->nodes;
#line 1639
  i = (Idx )0;
  {
#line 1639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1639
    if (! (i < (Idx )nodes->nelem)) {
#line 1639
      goto while_break;
    }
#line 1641
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1642
    type = node->type;
#line 1643
    if ((unsigned int )type == 1U) {
#line 1643
      if (! node->constraint) {
#line 1644
        goto __Cont;
      }
    }
#line 1646
    newstate->accept_mb |= node->accept_mb;
#line 1650
    if ((unsigned int )type == 2U) {
#line 1651
      newstate->halt = 1U;
    } else
#line 1652
    if ((unsigned int )type == 4U) {
#line 1653
      newstate->has_backref = 1U;
    } else
#line 1654
    if ((unsigned int )type == 12U) {
#line 1655
      newstate->has_constraint = 1U;
    } else
#line 1654
    if (node->constraint) {
#line 1655
      newstate->has_constraint = 1U;
    }
    __Cont: /* CIL Label */ 
#line 1639
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1657
  err = register_state(dfa, newstate, hash);
#line 1658
  tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1658
  if (tmp___2) {
    {
#line 1660
    free_state(newstate);
#line 1661
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1663
  return (newstate);
}
}
#line 1669 "./regex_internal.c"
static re_dfastate_t *( __attribute__((__warn_unused_result__)) create_cd_newstate)(re_dfa_t const   *dfa ,
                                                                                    re_node_set const   *nodes ,
                                                                                    unsigned int context ,
                                                                                    re_hashval_t hash ) 
{ 
  Idx i ;
  Idx nctx_nodes ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  re_node_set *entrance_nodes ;
  void *tmp___2 ;
  long tmp___3 ;
  reg_errcode_t tmp___4 ;
  long tmp___5 ;

  {
  {
#line 1674
  nctx_nodes = (Idx )0;
#line 1678
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1678
  newstate = (re_dfastate_t *)tmp;
#line 1679
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
  }
#line 1679
  if (tmp___0) {
#line 1680
    return ((re_dfastate_t *)((void *)0));
  }
  {
#line 1681
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1682
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1682
  if (tmp___1) {
    {
#line 1684
    free((void *)newstate);
    }
#line 1685
    return ((re_dfastate_t *)((void *)0));
  }
#line 1688
  newstate->context = context;
#line 1689
  newstate->entrance_nodes = & newstate->nodes;
#line 1691
  i = (Idx )0;
  {
#line 1691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1691
    if (! (i < (Idx )nodes->nelem)) {
#line 1691
      goto while_break;
    }
#line 1693
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1694
    type = node->type;
#line 1695
    constraint = node->constraint;
#line 1697
    if ((unsigned int )type == 1U) {
#line 1697
      if (! constraint) {
#line 1698
        goto __Cont;
      }
    }
#line 1700
    newstate->accept_mb |= node->accept_mb;
#line 1704
    if ((unsigned int )type == 2U) {
#line 1705
      newstate->halt = 1U;
    } else
#line 1706
    if ((unsigned int )type == 4U) {
#line 1707
      newstate->has_backref = 1U;
    }
#line 1709
    if (constraint) {
#line 1711
      if ((unsigned long )newstate->entrance_nodes == (unsigned long )(& newstate->nodes)) {
        {
#line 1713
        tmp___2 = malloc(sizeof(re_node_set ));
#line 1713
        entrance_nodes = (re_node_set *)tmp___2;
#line 1714
        tmp___3 = __builtin_expect((long )((unsigned long )entrance_nodes == (unsigned long )((void *)0)),
                                   0L);
        }
#line 1714
        if (tmp___3) {
          {
#line 1716
          free_state(newstate);
          }
#line 1717
          return ((re_dfastate_t *)((void *)0));
        }
        {
#line 1719
        newstate->entrance_nodes = entrance_nodes;
#line 1720
        tmp___4 = re_node_set_init_copy(newstate->entrance_nodes, nodes);
        }
#line 1720
        if ((int )tmp___4 != 0) {
          {
#line 1723
          free_state(newstate);
          }
#line 1724
          return ((re_dfastate_t *)((void *)0));
        }
#line 1726
        nctx_nodes = (Idx )0;
#line 1727
        newstate->has_constraint = 1U;
      }
#line 1730
      if (constraint & 1U) {
#line 1730
        if (! (context & 1U)) {
          {
#line 1732
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1733
          nctx_nodes ++;
          }
        } else {
#line 1730
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1730
      if (constraint & 2U) {
#line 1730
        if (context & 1U) {
          {
#line 1732
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1733
          nctx_nodes ++;
          }
        } else {
#line 1730
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1730
      if (constraint & 16U) {
#line 1730
        if (! (context & (unsigned int )(1 << 1))) {
          {
#line 1732
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1733
          nctx_nodes ++;
          }
        } else {
#line 1730
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1730
      if (constraint & 64U) {
#line 1730
        if (! (context & (unsigned int )((1 << 1) << 1))) {
          {
#line 1732
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1733
          nctx_nodes ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1691
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1737
  err = register_state(dfa, newstate, hash);
#line 1738
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1738
  if (tmp___5) {
    {
#line 1740
    free_state(newstate);
#line 1741
    newstate = (re_dfastate_t *)((void *)0);
    }
  }
#line 1743
  return (newstate);
}
}
#line 24 "./regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) ;
#line 26
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) ;
#line 29
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) ;
#line 31
static void free_charset(re_charset_t *cset ) ;
#line 33
static void free_workarea_compile(regex_t *preg ) ;
#line 34
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) ;
#line 36
static void optimize_utf8(re_dfa_t *dfa ) ;
#line 38
static reg_errcode_t analyze(regex_t *preg ) ;
#line 39
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) ;
#line 42
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) ;
#line 45
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) ;
#line 46
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) ;
#line 47
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) ;
#line 49
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) ;
#line 50
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) ;
#line 51
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) ;
#line 52
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) ;
#line 53
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) ;
#line 55
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) ;
#line 56
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) ;
#line 58
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) ;
#line 59
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
#line 61
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 63
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) ;
#line 65
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 68
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 71
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 74
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 77
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 80
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 83
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) ;
#line 89
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) ;
#line 93
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       Idx *equiv_class_alloc , unsigned char const   *name ) ;
#line 97
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     char const   *class_name , reg_syntax_t syntax ) ;
#line 111
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , char const   *class_name ,
                                      char const   *extra , _Bool non_match , reg_errcode_t *err ) ;
#line 116
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) ;
#line 119
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) ;
#line 122
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) ;
#line 123
static void free_token(re_token_t *node ) ;
#line 124
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) ;
#line 125
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) ;
#line 132 "./regcomp.c"
static char const   __re_error_msgid[382]  = 
#line 132
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )',',      (char const   )' ', 
        (char const   )'[',      (char const   )'^',      (char const   )',',      (char const   )' ', 
        (char const   )'[',      (char const   )':',      (char const   )',',      (char const   )' ', 
        (char const   )'[',      (char const   )'.',      (char const   )',',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'[', 
        (char const   )'=',      (char const   )'\000',      (char const   )'U',      (char const   )'n', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'(',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'\\',      (char const   )'(',      (char const   )'\000', 
        (char const   )'U',      (char const   )'n',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'\\',      (char const   )'{', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'\\',      (char const   )'{',      (char const   )'\\',      (char const   )'}', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000',      (char const   )'M', 
        (char const   )'e',      (char const   )'m',      (char const   )'o',      (char const   )'r', 
        (char const   )'y',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'h',      (char const   )'a',      (char const   )'u',      (char const   )'s', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'p',      (char const   )'r',      (char const   )'e',      (char const   )'c', 
        (char const   )'e',      (char const   )'d',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'u',      (char const   )'l',      (char const   )'a', 
        (char const   )'r',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'\000',      (char const   )'P',      (char const   )'r',      (char const   )'e', 
        (char const   )'m',      (char const   )'a',      (char const   )'t',      (char const   )'u', 
        (char const   )'r',      (char const   )'e',      (char const   )' ',      (char const   )'e', 
        (char const   )'n',      (char const   )'d',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'g',      (char const   )'u',      (char const   )'l',      (char const   )'a', 
        (char const   )'r',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'\000',      (char const   )'R',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )'o',      (char const   )' ', 
        (char const   )'b',      (char const   )'i',      (char const   )'g',      (char const   )'\000', 
        (char const   )'U',      (char const   )'n',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )')',      (char const   )' ', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'\\', 
        (char const   )')',      (char const   )'\000'};
#line 186 "./regcomp.c"
static size_t const   __re_error_msgid_idx[17]  = 
#line 186
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [, [^, [:, [., or [=")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
#line 216 "./regcomp.c"
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;
  char *tmp ;

  {
  {
#line 225
  bufp->no_sub = (unsigned int )(! (! (rpl_re_syntax_options & (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))));
#line 228
  bufp->newline_anchor = 1U;
#line 230
  ret = re_compile_internal(bufp, pattern, length, rpl_re_syntax_options);
  }
#line 232
  if (! ret) {
#line 233
    return ((char const   *)((void *)0));
  }
  {
#line 234
  tmp = dcgettext((char const   *)((void *)0), __re_error_msgid + __re_error_msgid_idx[(int )ret],
                  5);
  }
#line 234
  return ((char const   *)tmp);
}
}
#line 253 "./regcomp.c"
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 256
  ret = rpl_re_syntax_options;
#line 258
  rpl_re_syntax_options = syntax;
#line 259
  return (ret);
}
}
#line 263 "./regcomp.c"
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  re_dfa_t *dfa ;
  char *fastmap ;

  {
  {
#line 266
  dfa = bufp->buffer;
#line 267
  fastmap = bufp->fastmap;
#line 269
  memset((void *)fastmap, '\000', sizeof(char ) * 256UL);
#line 270
  re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state, fastmap);
  }
#line 271
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_word) {
    {
#line 272
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_word, fastmap);
    }
  }
#line 273
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_nl) {
    {
#line 274
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_nl, fastmap);
    }
  }
#line 275
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_begbuf) {
    {
#line 276
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_begbuf,
                            fastmap);
    }
  }
#line 277
  bufp->fastmap_accurate = 1U;
#line 278
  return (0);
}
}
#line 282 "./regcomp.c"
__inline static void ( __attribute__((__always_inline__)) re_set_fastmap)(char *fastmap ,
                                                                          _Bool icase ,
                                                                          int ch ) 
{ 
  int __res ;
  __int32_t const   **tmp___0 ;

  {
#line 286
  *(fastmap + ch) = (char)1;
#line 287
  if (icase) {
#line 288
    if (sizeof(ch) > 1UL) {
      {
#line 288
      __res = tolower(ch);
      }
    } else {
      {
#line 288
      tmp___0 = __ctype_tolower_loc();
#line 288
      __res = (int )*(*tmp___0 + ch);
      }
    }
#line 288
    *(fastmap + __res) = (char)1;
  }
#line 289
  return;
}
}
#line 294 "./regcomp.c"
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) 
{ 
  re_dfa_t *dfa ;
  Idx node_cnt ;
  _Bool icase ;
  int tmp ;
  Idx node ;
  re_token_type_t type ;
  unsigned char buf[16] ;
  unsigned char *p ;
  wchar_t wc ;
  mbstate_t state ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  size_t tmp___2 ;
  wint_t tmp___3 ;
  size_t tmp___4 ;
  int i ;
  int ch ;
  int j ;
  bitset_word_t w ;
  re_charset_t *cset ;
  Idx i___0 ;
  unsigned char c ;
  mbstate_t mbs ;
  size_t tmp___5 ;
  char buf___0[256] ;
  mbstate_t state___0 ;
  size_t tmp___6 ;
  wint_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 298
  dfa = bufp->buffer;
#line 300
  if (dfa->mb_cur_max == 1) {
#line 300
    if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 300
      tmp = 1;
    } else {
#line 300
      tmp = 0;
    }
  } else {
#line 300
    tmp = 0;
  }
#line 300
  icase = (_Bool )tmp;
#line 301
  node_cnt = (Idx )0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (node_cnt < (Idx )init_state->nodes.nelem)) {
#line 301
      goto while_break;
    }
#line 303
    node = *(init_state->nodes.elems + node_cnt);
#line 304
    type = (dfa->nodes + node)->type;
#line 306
    if ((unsigned int )type == 1U) {
      {
#line 308
      re_set_fastmap(fastmap, icase, (int )(dfa->nodes + node)->opr.c);
      }
#line 310
      if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 310
        if (dfa->mb_cur_max > 1) {
#line 317
          p = buf;
#line 318
          tmp___0 = p;
#line 318
          p ++;
#line 318
          *tmp___0 = (dfa->nodes + node)->opr.c;
          {
#line 319
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 319
            node ++;
#line 319
            if ((size_t )node < dfa->nodes_len) {
#line 319
              if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 319
                if (! (dfa->nodes + node)->mb_partial) {
#line 319
                  goto while_break___0;
                }
              } else {
#line 319
                goto while_break___0;
              }
            } else {
#line 319
              goto while_break___0;
            }
#line 322
            tmp___1 = p;
#line 322
            p ++;
#line 322
            *tmp___1 = (dfa->nodes + node)->opr.c;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 323
          memset((void *)(& state), '\000', sizeof(state));
#line 324
          tmp___2 = rpl_mbrtowc(& wc, (char const   *)(buf), (size_t )(p - buf), & state);
          }
#line 324
          if (tmp___2 == (size_t )(p - buf)) {
            {
#line 324
            tmp___3 = towlower((wint_t )wc);
#line 324
            tmp___4 = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )tmp___3,
                              (mbstate_t */* __restrict  */)(& state));
            }
#line 324
            if (tmp___4 != 0xffffffffffffffffUL) {
              {
#line 328
              re_set_fastmap(fastmap, (_Bool)0, (int )buf[0]);
              }
            }
          }
        }
      }
    } else
#line 332
    if ((unsigned int )type == 3U) {
#line 335
      i = 0;
#line 335
      ch = 0;
      {
#line 335
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 335
        if (! (i < 4)) {
#line 335
          goto while_break___1;
        }
#line 338
        w = *((dfa->nodes + node)->opr.sbcset + i);
#line 339
        j = 0;
        {
#line 339
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 339
          if (! (j < 64)) {
#line 339
            goto while_break___2;
          }
#line 340
          if (w & (1UL << j)) {
            {
#line 341
            re_set_fastmap(fastmap, icase, ch);
            }
          }
#line 339
          j ++;
#line 339
          ch ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 335
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 345
    if ((unsigned int )type == 6U) {
#line 347
      cset = (dfa->nodes + node)->opr.mbcset;
#line 372
      if (dfa->mb_cur_max > 1) {
#line 372
        if (cset->nchar_classes) {
#line 372
          goto _L___0;
        } else
#line 372
        if (cset->non_match) {
#line 372
          goto _L___0;
        } else
#line 372
        if (cset->nranges) {
          _L___0: /* CIL Label */ 
#line 379
          c = (unsigned char)0;
          {
#line 380
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 383
            memset((void *)(& mbs), 0, sizeof(mbs));
#line 384
            tmp___5 = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)((char *)(& c)),
                                  (size_t )1, & mbs);
            }
#line 384
            if (tmp___5 == 0xfffffffffffffffeUL) {
              {
#line 385
              re_set_fastmap(fastmap, (_Bool)0, (int )c);
              }
            }
#line 380
            c = (unsigned char )((int )c + 1);
#line 380
            if (! ((int )c != 0)) {
#line 380
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 372
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 393
        i___0 = (Idx )0;
        {
#line 393
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 393
          if (! (i___0 < cset->nmbchars)) {
#line 393
            goto while_break___4;
          }
          {
#line 397
          memset((void *)(& state___0), '\000', sizeof(state___0));
#line 398
          tmp___6 = wcrtomb((char */* __restrict  */)(buf___0), *(cset->mbchars + i___0),
                            (mbstate_t */* __restrict  */)(& state___0));
          }
#line 398
          if (tmp___6 != 0xffffffffffffffffUL) {
            {
#line 399
            re_set_fastmap(fastmap, icase, (int )*((unsigned char *)(buf___0)));
            }
          }
#line 400
          if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 400
            if (dfa->mb_cur_max > 1) {
              {
#line 402
              tmp___7 = towlower((wint_t )*(cset->mbchars + i___0));
#line 402
              tmp___8 = wcrtomb((char */* __restrict  */)(buf___0), (wchar_t )tmp___7,
                                (mbstate_t */* __restrict  */)(& state___0));
              }
#line 402
              if (tmp___8 != 0xffffffffffffffffUL) {
                {
#line 404
                re_set_fastmap(fastmap, (_Bool)0, (int )*((unsigned char *)(buf___0)));
                }
              }
            }
          }
#line 393
          i___0 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else
#line 410
    if ((unsigned int )type == 5U) {
#line 410
      goto _L___1;
    } else
#line 410
    if ((unsigned int )type == 7U) {
#line 410
      goto _L___1;
    } else
#line 410
    if ((unsigned int )type == 2U) {
      _L___1: /* CIL Label */ 
      {
#line 416
      memset((void *)fastmap, '\001', sizeof(char ) * 256UL);
      }
#line 417
      if ((unsigned int )type == 2U) {
#line 418
        bufp->can_be_null = 1U;
      }
#line 419
      return;
    }
#line 301
    node_cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return;
}
}
#line 460 "./regcomp.c"
int rpl_regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern ,
                int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
#line 464
  if (cflags & 1) {
#line 464
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 464
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
  {
#line 464
  syntax = tmp;
#line 467
  preg->buffer = (struct re_dfa_t *)((void *)0);
#line 468
  preg->allocated = (__re_long_size_t )0;
#line 469
  preg->used = (__re_long_size_t )0;
#line 472
  tmp___0 = malloc(256UL * sizeof(char ));
#line 472
  preg->fastmap = (char *)tmp___0;
#line 473
  tmp___1 = __builtin_expect((long )((unsigned long )preg->fastmap == (unsigned long )((void *)0)),
                             0L);
  }
#line 473
  if (tmp___1) {
#line 474
    return (12);
  }
#line 476
  if (cflags & (1 << 1)) {
#line 476
    tmp___2 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
#line 476
    tmp___2 = 0UL;
  }
#line 476
  syntax |= tmp___2;
#line 479
  if (cflags & (1 << 2)) {
#line 481
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 482
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 484
    preg->newline_anchor = 1U;
  } else {
#line 487
    preg->newline_anchor = 0U;
  }
  {
#line 488
  preg->no_sub = (unsigned int )(! (! (cflags & (1 << 3))));
#line 489
  preg->translate = (unsigned char *)((void *)0);
#line 491
  tmp___3 = strlen((char const   *)pattern);
#line 491
  ret = re_compile_internal((regex_t *)preg, (char const   *)pattern, tmp___3, syntax);
  }
#line 495
  if ((int )ret == 16) {
#line 496
    ret = (reg_errcode_t )8;
  }
  {
#line 499
  tmp___4 = __builtin_expect((long )((int )ret == 0), 1L);
  }
#line 499
  if (tmp___4) {
    {
#line 502
    rpl_re_compile_fastmap((struct re_pattern_buffer *)preg);
    }
  } else {
    {
#line 506
    free((void *)preg->fastmap);
#line 507
    preg->fastmap = (char *)((void *)0);
    }
  }
#line 510
  return ((int )ret);
}
}
#line 518 "./regcomp.c"
size_t rpl_regerror(int errcode , regex_t const   * __restrict  preg , char * __restrict  errbuf ,
                    size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  int nerrcodes ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t cpy_size ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 524
  nerrcodes = (int )(sizeof(__re_error_msgid_idx) / sizeof(__re_error_msgid_idx[0]));
#line 526
  if (errcode < 0) {
#line 526
    tmp = 1;
  } else
#line 526
  if (errcode >= nerrcodes) {
#line 526
    tmp = 1;
  } else {
#line 526
    tmp = 0;
  }
  {
#line 526
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 526
  if (tmp___0) {
    {
#line 531
    abort();
    }
  }
  {
#line 533
  tmp___1 = dcgettext((char const   *)((void *)0), __re_error_msgid + __re_error_msgid_idx[errcode],
                      5);
#line 533
  msg = (char const   *)tmp___1;
#line 535
  tmp___2 = strlen(msg);
#line 535
  msg_size = tmp___2 + 1UL;
#line 537
  tmp___4 = __builtin_expect((long )(errbuf_size != 0UL), 1L);
  }
#line 537
  if (tmp___4) {
    {
#line 539
    cpy_size = msg_size;
#line 540
    tmp___3 = __builtin_expect((long )(msg_size > errbuf_size), 0L);
    }
#line 540
    if (tmp___3) {
#line 542
      cpy_size = errbuf_size - 1UL;
#line 543
      *(errbuf + cpy_size) = (char )'\000';
    }
    {
#line 545
    memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
           cpy_size);
    }
  }
#line 548
  return (msg_size);
}
}
#line 558 "./regcomp.c"
static bitset_word_t utf8_sb_map[4]  = {      0xffffffffffffffffUL,      0xffffffffffffffffUL};
#line 582 "./regcomp.c"
static void free_dfa_content(re_dfa_t *dfa ) 
{ 
  Idx i ;
  Idx j ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state ;

  {
#line 587
  if (dfa->nodes) {
#line 588
    i = (Idx )0;
    {
#line 588
    while (1) {
      while_continue: /* CIL Label */ ;
#line 588
      if (! ((size_t )i < dfa->nodes_len)) {
#line 588
        goto while_break;
      }
      {
#line 589
      free_token(dfa->nodes + i);
#line 588
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 590
  free((void *)dfa->nexts);
#line 591
  i = (Idx )0;
  }
  {
#line 591
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 591
    if (! ((size_t )i < dfa->nodes_len)) {
#line 591
      goto while_break___0;
    }
#line 593
    if ((unsigned long )dfa->eclosures != (unsigned long )((void *)0)) {
      {
#line 594
      free((void *)(dfa->eclosures + i)->elems);
      }
    }
#line 595
    if ((unsigned long )dfa->inveclosures != (unsigned long )((void *)0)) {
      {
#line 596
      free((void *)(dfa->inveclosures + i)->elems);
      }
    }
#line 597
    if ((unsigned long )dfa->edests != (unsigned long )((void *)0)) {
      {
#line 598
      free((void *)(dfa->edests + i)->elems);
      }
    }
#line 591
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 600
  free((void *)dfa->edests);
#line 601
  free((void *)dfa->eclosures);
#line 602
  free((void *)dfa->inveclosures);
#line 603
  free((void *)dfa->nodes);
  }
#line 605
  if (dfa->state_table) {
#line 606
    i = (Idx )0;
    {
#line 606
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 606
      if (! ((re_hashval_t )i <= dfa->state_hash_mask)) {
#line 606
        goto while_break___1;
      }
#line 608
      entry = dfa->state_table + i;
#line 609
      j = (Idx )0;
      {
#line 609
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 609
        if (! (j < entry->num)) {
#line 609
          goto while_break___2;
        }
        {
#line 611
        state = *(entry->array + j);
#line 612
        free_state(state);
#line 609
        j ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 614
      free((void *)entry->array);
#line 606
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 616
  free((void *)dfa->state_table);
  }
#line 618
  if ((unsigned long )dfa->sb_char != (unsigned long )(utf8_sb_map)) {
    {
#line 619
    free((void *)dfa->sb_char);
    }
  }
  {
#line 621
  free((void *)dfa->subexp_map);
#line 626
  free((void *)dfa);
  }
#line 627
  return;
}
}
#line 632 "./regcomp.c"
void rpl_regfree(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
  {
#line 635
  dfa = preg->buffer;
#line 636
  tmp = __builtin_expect((long )((unsigned long )dfa != (unsigned long )((void *)0)),
                         1L);
  }
#line 636
  if (tmp) {
    {
#line 639
    free_dfa_content(dfa);
    }
  }
  {
#line 641
  preg->buffer = (struct re_dfa_t *)((void *)0);
#line 642
  preg->allocated = (__re_long_size_t )0;
#line 644
  free((void *)preg->fastmap);
#line 645
  preg->fastmap = (char *)((void *)0);
#line 647
  free((void *)preg->translate);
#line 648
  preg->translate = (unsigned char *)((void *)0);
  }
#line 649
  return;
}
}
#line 725 "./regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t regexp ;
  unsigned int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  {
#line 729
  err = (reg_errcode_t )0;
#line 734
  preg->fastmap_accurate = 0U;
#line 735
  preg->syntax = syntax;
#line 736
  tmp = 0U;
#line 736
  preg->not_eol = tmp;
#line 736
  preg->not_bol = tmp;
#line 737
  preg->used = (__re_long_size_t )0;
#line 738
  preg->re_nsub = (size_t )0;
#line 739
  preg->can_be_null = 0U;
#line 740
  preg->regs_allocated = 0U;
#line 743
  dfa = preg->buffer;
#line 744
  tmp___1 = __builtin_expect((long )(preg->allocated < sizeof(re_dfa_t )), 0L);
  }
#line 744
  if (tmp___1) {
    {
#line 750
    tmp___0 = realloc((void *)preg->buffer, sizeof(re_dfa_t ));
#line 750
    dfa = (re_dfa_t *)tmp___0;
    }
#line 751
    if ((unsigned long )dfa == (unsigned long )((void *)0)) {
#line 752
      return ((reg_errcode_t )12);
    }
#line 753
    preg->allocated = sizeof(re_dfa_t );
#line 754
    preg->buffer = dfa;
  }
  {
#line 756
  preg->used = sizeof(re_dfa_t );
#line 758
  err = init_dfa(dfa, length);
  }
#line 759
  if ((int )err == 0) {
#line 759
    tmp___2 = 0;
  } else {
#line 759
    tmp___2 = 0;
  }
  {
#line 759
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 759
  if (tmp___3) {
#line 760
    err = (reg_errcode_t )12;
  }
  {
#line 761
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 761
  if (tmp___4) {
    {
#line 763
    free_dfa_content(dfa);
#line 764
    preg->buffer = (struct re_dfa_t *)((void *)0);
#line 765
    preg->allocated = (__re_long_size_t )0;
    }
#line 766
    return (err);
  }
  {
#line 774
  err = re_string_construct(& regexp, pattern, (Idx )length, preg->translate, (_Bool )((syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                            (re_dfa_t const   *)dfa);
#line 776
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 776
  if (tmp___5) {
    re_compile_internal_free_return: 
    {
#line 779
    free_workarea_compile(preg);
#line 780
    re_string_destruct(& regexp);
#line 782
    free_dfa_content(dfa);
#line 783
    preg->buffer = (struct re_dfa_t *)((void *)0);
#line 784
    preg->allocated = (__re_long_size_t )0;
    }
#line 785
    return (err);
  }
  {
#line 789
  preg->re_nsub = (size_t )0;
#line 790
  dfa->str_tree = parse(& regexp, preg, syntax, & err);
#line 791
  tmp___6 = __builtin_expect((long )((unsigned long )dfa->str_tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 791
  if (tmp___6) {
#line 792
    goto re_compile_internal_free_return;
  }
  {
#line 795
  err = analyze(preg);
#line 796
  tmp___7 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 796
  if (tmp___7) {
#line 797
    goto re_compile_internal_free_return;
  }
#line 801
  if (dfa->is_utf8) {
#line 801
    if (! (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 801
      if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
        {
#line 802
        optimize_utf8(dfa);
        }
      }
    }
  }
  {
#line 806
  err = create_initial_state(dfa);
#line 809
  free_workarea_compile(preg);
#line 810
  re_string_destruct(& regexp);
#line 812
  tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 812
  if (tmp___8) {
    {
#line 815
    free_dfa_content(dfa);
#line 816
    preg->buffer = (struct re_dfa_t *)((void *)0);
#line 817
    preg->allocated = (__re_long_size_t )0;
    }
  }
#line 820
  return (err);
}
}
#line 826 "./regcomp.c"
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) 
{ 
  __re_size_t table_size ;
  char const   *codeset_name ;
  size_t max_i18n_object_size ;
  unsigned long tmp ;
  size_t max_object_size ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  unsigned long tmp___40 ;
  long tmp___41 ;
  void *tmp___42 ;
  void *tmp___43 ;
  size_t tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int i ;
  int j ;
  int ch ;
  void *tmp___47 ;
  long tmp___48 ;
  wint_t wch ;
  wint_t tmp___49 ;
  int tmp___50 ;
  long tmp___51 ;

  {
#line 834
  if (sizeof(wchar_t ) < sizeof(wctype_t )) {
#line 834
    tmp = sizeof(wctype_t );
  } else {
#line 834
    tmp = sizeof(wchar_t );
  }
#line 834
  max_i18n_object_size = tmp;
#line 838
  if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
    tmp___39 = max_i18n_object_size;
  } else {
#line 838
    tmp___39 = sizeof(regmatch_t );
  }
#line 838
  if (sizeof(re_node_set ) < tmp___39) {
#line 838
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
      tmp___37 = max_i18n_object_size;
    } else {
#line 838
      tmp___37 = sizeof(regmatch_t );
    }
#line 838
    tmp___38 = tmp___37;
  } else {
#line 838
    tmp___38 = sizeof(re_node_set );
  }
#line 838
  if (sizeof(re_token_t ) < tmp___38) {
#line 838
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
      tmp___34 = max_i18n_object_size;
    } else {
#line 838
      tmp___34 = sizeof(regmatch_t );
    }
#line 838
    if (sizeof(re_node_set ) < tmp___34) {
#line 838
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
        tmp___32 = max_i18n_object_size;
      } else {
#line 838
        tmp___32 = sizeof(regmatch_t );
      }
#line 838
      tmp___33 = tmp___32;
    } else {
#line 838
      tmp___33 = sizeof(re_node_set );
    }
#line 838
    tmp___35 = tmp___33;
  } else {
#line 838
    tmp___35 = sizeof(re_token_t );
  }
#line 838
  if (sizeof(struct re_state_table_entry ) < tmp___35) {
#line 838
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
      tmp___25 = max_i18n_object_size;
    } else {
#line 838
      tmp___25 = sizeof(regmatch_t );
    }
#line 838
    if (sizeof(re_node_set ) < tmp___25) {
#line 838
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
        tmp___23 = max_i18n_object_size;
      } else {
#line 838
        tmp___23 = sizeof(regmatch_t );
      }
#line 838
      tmp___24 = tmp___23;
    } else {
#line 838
      tmp___24 = sizeof(re_node_set );
    }
#line 838
    if (sizeof(re_token_t ) < tmp___24) {
#line 838
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
        tmp___20 = max_i18n_object_size;
      } else {
#line 838
        tmp___20 = sizeof(regmatch_t );
      }
#line 838
      if (sizeof(re_node_set ) < tmp___20) {
#line 838
        if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 838
          tmp___18 = max_i18n_object_size;
        } else {
#line 838
          tmp___18 = sizeof(regmatch_t );
        }
#line 838
        tmp___19 = tmp___18;
      } else {
#line 838
        tmp___19 = sizeof(re_node_set );
      }
#line 838
      tmp___21 = tmp___19;
    } else {
#line 838
      tmp___21 = sizeof(re_token_t );
    }
#line 838
    tmp___26 = tmp___21;
  } else {
#line 838
    tmp___26 = sizeof(struct re_state_table_entry );
  }
  {
#line 838
  max_object_size = tmp___26;
#line 845
  memset((void *)dfa, '\000', sizeof(re_dfa_t ));
#line 848
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
  }
#line 854
  if (9223372036854775807UL < 0xffffffffffffffffUL / max_object_size) {
#line 854
    tmp___40 = 9223372036854775807UL;
  } else {
#line 854
    tmp___40 = 0xffffffffffffffffUL / max_object_size;
  }
  {
#line 854
  tmp___41 = __builtin_expect((long )(tmp___40 / 2UL <= pat_len), 0L);
  }
#line 854
  if (tmp___41) {
#line 856
    return ((reg_errcode_t )12);
  }
  {
#line 858
  dfa->nodes_alloc = pat_len + 1UL;
#line 859
  tmp___42 = malloc(dfa->nodes_alloc * sizeof(re_token_t ));
#line 859
  dfa->nodes = (re_token_t *)tmp___42;
#line 862
  table_size = (__re_size_t )1;
  }
  {
#line 862
  while (1) {
    while_continue: /* CIL Label */ ;
#line 863
    if (table_size > pat_len) {
#line 864
      goto while_break;
    }
#line 862
    table_size <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 866
  tmp___43 = calloc(sizeof(struct re_state_table_entry ), table_size);
#line 866
  dfa->state_table = (struct re_state_table_entry *)tmp___43;
#line 867
  dfa->state_hash_mask = table_size - 1UL;
#line 869
  tmp___44 = __ctype_get_mb_cur_max();
#line 869
  dfa->mb_cur_max = (int )tmp___44;
#line 877
  tmp___45 = nl_langinfo(14);
#line 877
  codeset_name = (char const   *)tmp___45;
  }
#line 878
  if ((int const   )*(codeset_name + 0) == 85) {
#line 878
    goto _L___1;
  } else
#line 878
  if ((int const   )*(codeset_name + 0) == 117) {
    _L___1: /* CIL Label */ 
#line 878
    if ((int const   )*(codeset_name + 1) == 84) {
#line 878
      goto _L___0;
    } else
#line 878
    if ((int const   )*(codeset_name + 1) == 116) {
      _L___0: /* CIL Label */ 
#line 878
      if ((int const   )*(codeset_name + 2) == 70) {
#line 878
        goto _L;
      } else
#line 878
      if ((int const   )*(codeset_name + 2) == 102) {
        _L: /* CIL Label */ 
        {
#line 878
        tmp___46 = strcmp((codeset_name + 3) + ((int const   )*(codeset_name + 3) == 45),
                          "8");
        }
#line 878
        if (tmp___46 == 0) {
#line 882
          dfa->is_utf8 = 1U;
        }
      }
    }
  }
#line 886
  dfa->map_notascii = 0U;
#line 890
  if (dfa->mb_cur_max > 1) {
#line 892
    if (dfa->is_utf8) {
#line 893
      dfa->sb_char = (re_bitset_ptr_t )(utf8_sb_map);
    } else {
      {
#line 898
      tmp___47 = calloc(sizeof(bitset_t ), (size_t )1);
#line 898
      dfa->sb_char = (re_bitset_ptr_t )tmp___47;
#line 899
      tmp___48 = __builtin_expect((long )((unsigned long )dfa->sb_char == (unsigned long )((void *)0)),
                                  0L);
      }
#line 899
      if (tmp___48) {
#line 900
        return ((reg_errcode_t )12);
      }
#line 903
      i = 0;
#line 903
      ch = 0;
      {
#line 903
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 903
        if (! (i < 4)) {
#line 903
          goto while_break___0;
        }
#line 904
        j = 0;
        {
#line 904
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 904
          if (! (j < 64)) {
#line 904
            goto while_break___1;
          }
          {
#line 906
          tmp___49 = btowc(ch);
#line 906
          wch = tmp___49;
          }
#line 907
          if (wch != 4294967295U) {
#line 908
            *(dfa->sb_char + i) |= 1UL << j;
          }
#line 910
          if ((ch & -128) == 0) {
#line 910
            if (wch != (wint_t )ch) {
#line 911
              dfa->map_notascii = 1U;
            }
          }
#line 904
          j ++;
#line 904
          ch ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 903
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 918
  if ((unsigned long )dfa->nodes == (unsigned long )((void *)0)) {
#line 918
    tmp___50 = 1;
  } else
#line 918
  if ((unsigned long )dfa->state_table == (unsigned long )((void *)0)) {
#line 918
    tmp___50 = 1;
  } else {
#line 918
    tmp___50 = 0;
  }
  {
#line 918
  tmp___51 = __builtin_expect((long )tmp___50, 0L);
  }
#line 918
  if (tmp___51) {
#line 919
    return ((reg_errcode_t )12);
  }
#line 920
  return ((reg_errcode_t )0);
}
}
#line 927 "./regcomp.c"
static void init_word_char(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  int ch ;
  bitset_word_t bits0 ;
  bitset_word_t bits1 ;
  bitset_word_t bits2 ;
  bitset_word_t bits3 ;
  long tmp ;
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 930
  i = 0;
#line 932
  ch = 0;
#line 933
  dfa->word_ops_used = 1U;
#line 934
  tmp___0 = __builtin_expect((long )(dfa->map_notascii == 0U), 1L);
  }
#line 934
  if (tmp___0) {
    {
#line 938
    bits0 = (bitset_word_t )0;
#line 939
    bits1 = (bitset_word_t )67043328;
#line 940
    bits2 = (bitset_word_t )2281701374U;
#line 941
    bits3 = (bitset_word_t )134217726;
#line 945
    dfa->word_char[0] = ((bits1 << 31) << 1) | bits0;
#line 946
    dfa->word_char[1] = ((bits3 << 31) << 1) | bits2;
#line 947
    i = 2;
#line 959
    ch = 128;
#line 961
    tmp = __builtin_expect((long )dfa->is_utf8, 1L);
    }
#line 961
    if (tmp) {
      {
#line 963
      memset((void *)(& dfa->word_char[i]), '\000', (size_t )((256 - ch) / 8));
      }
#line 964
      return;
    }
  }
  {
#line 969
  while (1) {
    while_continue: /* CIL Label */ ;
#line 969
    if (! (i < 4)) {
#line 969
      goto while_break;
    }
#line 970
    j = 0;
    {
#line 970
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 970
      if (! (j < 64)) {
#line 970
        goto while_break___0;
      }
      {
#line 971
      tmp___1 = __ctype_b_loc();
      }
#line 971
      if ((int const   )*(*tmp___1 + ch) & 8) {
#line 972
        dfa->word_char[i] |= 1UL << j;
      } else
#line 971
      if (ch == 95) {
#line 972
        dfa->word_char[i] |= 1UL << j;
      }
#line 970
      j ++;
#line 970
      ch ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 969
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 973
  return;
}
}
#line 977 "./regcomp.c"
static void free_workarea_compile(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_storage_t *storage ;
  bin_tree_storage_t *next ;

  {
#line 980
  dfa = preg->buffer;
#line 982
  storage = dfa->str_tree_storage;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 982
    if (! storage) {
#line 982
      goto while_break;
    }
    {
#line 984
    next = storage->next;
#line 985
    free((void *)storage);
#line 982
    storage = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 987
  dfa->str_tree_storage = (bin_tree_storage_t *)((void *)0);
#line 988
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 989
  dfa->str_tree = (bin_tree_t *)((void *)0);
#line 990
  free((void *)dfa->org_indices);
#line 991
  dfa->org_indices = (Idx *)((void *)0);
  }
#line 992
  return;
}
}
#line 996 "./regcomp.c"
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) 
{ 
  Idx first ;
  Idx i ;
  reg_errcode_t err ;
  re_node_set init_nodes ;
  long tmp ;
  Idx node_idx ;
  re_token_type_t type ;
  Idx clexp_idx ;
  re_token_t *clexp_node ;
  Idx dest_idx ;
  reg_errcode_t merge_err ;
  reg_errcode_t tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  re_dfastate_t *tmp___5 ;
  re_dfastate_t *tmp___6 ;

  {
  {
#line 1005
  first = ((dfa->str_tree)->first)->node_idx;
#line 1006
  dfa->init_node = first;
#line 1007
  err = re_node_set_init_copy(& init_nodes, (re_node_set const   *)(dfa->eclosures + first));
#line 1008
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1008
  if (tmp) {
#line 1009
    return (err);
  }
#line 1015
  if (dfa->nbackref > 0L) {
#line 1016
    i = (Idx )0;
    {
#line 1016
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1016
      if (! (i < init_nodes.nelem)) {
#line 1016
        goto while_break;
      }
#line 1018
      node_idx = *(init_nodes.elems + i);
#line 1019
      type = (dfa->nodes + node_idx)->type;
#line 1022
      if ((unsigned int )type != 4U) {
#line 1023
        goto __Cont;
      }
#line 1024
      clexp_idx = (Idx )0;
      {
#line 1024
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1024
        if (! (clexp_idx < init_nodes.nelem)) {
#line 1024
          goto while_break___0;
        }
#line 1027
        clexp_node = dfa->nodes + *(init_nodes.elems + clexp_idx);
#line 1028
        if ((unsigned int )clexp_node->type == 9U) {
#line 1028
          if (clexp_node->opr.idx == (dfa->nodes + node_idx)->opr.idx) {
#line 1030
            goto while_break___0;
          }
        }
#line 1024
        clexp_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1032
      if (clexp_idx == init_nodes.nelem) {
#line 1033
        goto __Cont;
      }
#line 1035
      if ((unsigned int )type == 4U) {
        {
#line 1037
        dest_idx = *((dfa->edests + node_idx)->elems + 0);
#line 1038
        tmp___1 = re_node_set_contains((re_node_set const   *)(& init_nodes), dest_idx);
        }
#line 1038
        if (! tmp___1) {
          {
#line 1040
          tmp___0 = re_node_set_merge(& init_nodes, (re_node_set const   *)(dfa->eclosures + dest_idx));
#line 1040
          merge_err = tmp___0;
          }
#line 1042
          if ((int )merge_err != 0) {
#line 1043
            return (merge_err);
          }
#line 1044
          i = (Idx )0;
        }
      }
      __Cont: /* CIL Label */ 
#line 1016
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1050
  dfa->init_state = re_acquire_state_context(& err, (re_dfa_t const   *)dfa, (re_node_set const   *)(& init_nodes),
                                             0U);
#line 1052
  tmp___2 = __builtin_expect((long )((unsigned long )dfa->init_state == (unsigned long )((void *)0)),
                             0L);
  }
#line 1052
  if (tmp___2) {
#line 1053
    return (err);
  }
#line 1054
  if ((dfa->init_state)->has_constraint) {
    {
#line 1056
    dfa->init_state_word = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                    (re_node_set const   *)(& init_nodes),
                                                    1U);
#line 1058
    dfa->init_state_nl = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                  (re_node_set const   *)(& init_nodes),
                                                  (unsigned int )(1 << 1));
#line 1060
    dfa->init_state_begbuf = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                      (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )((1 << 1) | ((1 << 1) << 1)));
    }
#line 1064
    if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 1064
      tmp___3 = 1;
    } else
#line 1064
    if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 1064
      tmp___3 = 1;
    } else
#line 1064
    if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 1064
      tmp___3 = 1;
    } else {
#line 1064
      tmp___3 = 0;
    }
    {
#line 1064
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 1064
    if (tmp___4) {
#line 1067
      return (err);
    }
  } else {
#line 1070
    tmp___6 = dfa->init_state;
#line 1070
    dfa->init_state_begbuf = tmp___6;
#line 1070
    tmp___5 = tmp___6;
#line 1070
    dfa->init_state_nl = tmp___5;
#line 1070
    dfa->init_state_word = tmp___5;
  }
  {
#line 1073
  free((void *)init_nodes.elems);
  }
#line 1074
  return ((reg_errcode_t )0);
}
}
#line 1082 "./regcomp.c"
static void optimize_utf8(re_dfa_t *dfa ) 
{ 
  Idx node ;
  int i ;
  _Bool mb_chars ;
  _Bool has_period ;
  int rshift ;
  int tmp ;

  {
#line 1087
  mb_chars = (_Bool)0;
#line 1088
  has_period = (_Bool)0;
#line 1090
  node = (Idx )0;
  {
#line 1090
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1090
    if (! ((size_t )node < dfa->nodes_len)) {
#line 1090
      goto while_break;
    }
    {
#line 1093
    if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 1093
      goto case_1;
    }
#line 1097
    if ((unsigned int )(dfa->nodes + node)->type == 12U) {
#line 1097
      goto case_12;
    }
#line 1112
    if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1112
      goto case_5;
    }
#line 1120
    if ((unsigned int )(dfa->nodes + node)->type == 9U) {
#line 1120
      goto case_9;
    }
#line 1120
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 1120
      goto case_9;
    }
#line 1120
    if ((unsigned int )(dfa->nodes + node)->type == 11U) {
#line 1120
      goto case_9;
    }
#line 1120
    if ((unsigned int )(dfa->nodes + node)->type == 2U) {
#line 1120
      goto case_9;
    }
#line 1120
    if ((unsigned int )(dfa->nodes + node)->type == 10U) {
#line 1120
      goto case_9;
    }
#line 1120
    if ((unsigned int )(dfa->nodes + node)->type == 4U) {
#line 1120
      goto case_9;
    }
#line 1122
    if ((unsigned int )(dfa->nodes + node)->type == 6U) {
#line 1122
      goto case_6;
    }
#line 1124
    if ((unsigned int )(dfa->nodes + node)->type == 3U) {
#line 1124
      goto case_3;
    }
#line 1138
    goto switch_default___0;
    case_1: /* CIL Label */ 
#line 1094
    if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1095
      mb_chars = (_Bool)1;
    }
#line 1096
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1103
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 128U) {
#line 1103
      goto case_128;
    }
#line 1103
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 64U) {
#line 1103
      goto case_128;
    }
#line 1103
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 32U) {
#line 1103
      goto case_128;
    }
#line 1103
    if ((unsigned int )(dfa->nodes + node)->opr.ctx_type == 16U) {
#line 1103
      goto case_128;
    }
#line 1105
    goto switch_default;
    case_128: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_16: /* CIL Label */ 
#line 1104
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1109
    return;
    switch_break___0: /* CIL Label */ ;
    }
#line 1111
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1113
    has_period = (_Bool)1;
#line 1114
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1121
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1123
    return;
    case_3: /* CIL Label */ 
#line 1127
    rshift = 0;
#line 1130
    i = 2;
    {
#line 1130
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1130
      if (! (i < 4)) {
#line 1130
        goto while_break___0;
      }
#line 1132
      if (*((dfa->nodes + node)->opr.sbcset + i) >> rshift != 0UL) {
#line 1133
        return;
      }
#line 1134
      rshift = 0;
#line 1130
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1137
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 1139
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1090
    node ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  if (mb_chars) {
#line 1142
    goto _L___0;
  } else
#line 1142
  if (has_period) {
    _L___0: /* CIL Label */ 
#line 1143
    node = (Idx )0;
    {
#line 1143
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1143
      if (! ((size_t )node < dfa->nodes_len)) {
#line 1143
        goto while_break___1;
      }
#line 1145
      if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 1145
        if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1147
          (dfa->nodes + node)->mb_partial = 0U;
        } else {
#line 1145
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1148
      if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1149
        (dfa->nodes + node)->type = (re_token_type_t )7;
      }
#line 1143
      node ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1153
  dfa->mb_cur_max = 1;
#line 1154
  dfa->is_utf8 = 0U;
#line 1155
  if (dfa->nbackref > 0L) {
#line 1155
    tmp = 1;
  } else
#line 1155
  if (has_period) {
#line 1155
    tmp = 1;
  } else {
#line 1155
    tmp = 0;
  }
#line 1155
  dfa->has_mb_node = (unsigned int )tmp;
#line 1156
  return;
}
}
#line 1162 "./regcomp.c"
static reg_errcode_t analyze(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  reg_errcode_t ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  Idx i ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;

  {
  {
#line 1165
  dfa = preg->buffer;
#line 1169
  tmp = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1169
  dfa->nexts = (Idx *)tmp;
#line 1170
  tmp___0 = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1170
  dfa->org_indices = (Idx *)tmp___0;
#line 1171
  tmp___1 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1171
  dfa->edests = (re_node_set *)tmp___1;
#line 1172
  tmp___2 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1172
  dfa->eclosures = (re_node_set *)tmp___2;
  }
#line 1173
  if ((unsigned long )dfa->nexts == (unsigned long )((void *)0)) {
#line 1173
    tmp___3 = 1;
  } else
#line 1173
  if ((unsigned long )dfa->org_indices == (unsigned long )((void *)0)) {
#line 1173
    tmp___3 = 1;
  } else
#line 1173
  if ((unsigned long )dfa->edests == (unsigned long )((void *)0)) {
#line 1173
    tmp___3 = 1;
  } else
#line 1173
  if ((unsigned long )dfa->eclosures == (unsigned long )((void *)0)) {
#line 1173
    tmp___3 = 1;
  } else {
#line 1173
    tmp___3 = 0;
  }
  {
#line 1173
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 1173
  if (tmp___4) {
#line 1175
    return ((reg_errcode_t )12);
  }
  {
#line 1177
  tmp___5 = malloc(preg->re_nsub * sizeof(Idx ));
#line 1177
  dfa->subexp_map = (Idx *)tmp___5;
  }
#line 1178
  if ((unsigned long )dfa->subexp_map != (unsigned long )((void *)0)) {
#line 1181
    i = (Idx )0;
    {
#line 1181
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1181
      if (! ((size_t )i < preg->re_nsub)) {
#line 1181
        goto while_break;
      }
#line 1182
      *(dfa->subexp_map + i) = i;
#line 1181
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1183
    preorder(dfa->str_tree, & optimize_subexps, (void *)dfa);
#line 1184
    i = (Idx )0;
    }
    {
#line 1184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1184
      if (! ((size_t )i < preg->re_nsub)) {
#line 1184
        goto while_break___0;
      }
#line 1185
      if (*(dfa->subexp_map + i) != i) {
#line 1186
        goto while_break___0;
      }
#line 1184
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1187
    if ((size_t )i == preg->re_nsub) {
      {
#line 1189
      free((void *)dfa->subexp_map);
#line 1190
      dfa->subexp_map = (Idx *)((void *)0);
      }
    }
  }
  {
#line 1194
  ret = postorder(dfa->str_tree, & lower_subexps, (void *)preg);
#line 1195
  tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1195
  if (tmp___6) {
#line 1196
    return (ret);
  }
  {
#line 1197
  ret = postorder(dfa->str_tree, & calc_first, (void *)dfa);
#line 1198
  tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1198
  if (tmp___7) {
#line 1199
    return (ret);
  }
  {
#line 1200
  preorder(dfa->str_tree, & calc_next, (void *)dfa);
#line 1201
  ret = preorder(dfa->str_tree, & link_nfa_nodes, (void *)dfa);
#line 1202
  tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1202
  if (tmp___8) {
#line 1203
    return (ret);
  }
  {
#line 1204
  ret = calc_eclosure(dfa);
#line 1205
  tmp___9 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 1205
  if (tmp___9) {
#line 1206
    return (ret);
  }
#line 1210
  if (! preg->no_sub) {
#line 1210
    if (preg->re_nsub > 0UL) {
#line 1210
      if (dfa->has_plural_match) {
#line 1210
        goto _L;
      } else {
#line 1210
        goto _L___1;
      }
    } else {
#line 1210
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1210
  if (dfa->nbackref) {
    _L: /* CIL Label */ 
    {
#line 1213
    tmp___10 = malloc(dfa->nodes_len * sizeof(re_node_set ));
#line 1213
    dfa->inveclosures = (re_node_set *)tmp___10;
#line 1214
    tmp___11 = __builtin_expect((long )((unsigned long )dfa->inveclosures == (unsigned long )((void *)0)),
                                0L);
    }
#line 1214
    if (tmp___11) {
#line 1215
      return ((reg_errcode_t )12);
    }
    {
#line 1216
    ret = calc_inveclosure(dfa);
    }
  }
#line 1219
  return (ret);
}
}
#line 1225 "./regcomp.c"
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) 
{ 
  bin_tree_t *node ;
  bin_tree_t *prev ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;

  {
#line 1231
  node = root;
  {
#line 1231
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1235
      if (! node->left) {
#line 1235
        if (! node->right) {
#line 1235
          goto while_break___0;
        }
      }
#line 1236
      if (node->left) {
#line 1237
        node = node->left;
      } else {
#line 1239
        node = node->right;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1241
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1243
      tmp = (*fn)(extra, node);
#line 1243
      err = tmp;
#line 1244
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1244
      if (tmp___0) {
#line 1245
        return (err);
      }
#line 1246
      if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 1247
        return ((reg_errcode_t )0);
      }
#line 1248
      prev = node;
#line 1249
      node = node->parent;
#line 1241
      if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1241
        if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1241
          goto while_break___1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1253
    node = node->right;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1257 "./regcomp.c"
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) 
{ 
  bin_tree_t *node ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  bin_tree_t *prev ;

  {
#line 1263
  node = root;
  {
#line 1263
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1265
    tmp = (*fn)(extra, node);
#line 1265
    err = tmp;
#line 1266
    tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1266
    if (tmp___0) {
#line 1267
      return (err);
    }
#line 1270
    if (node->left) {
#line 1271
      node = node->left;
    } else {
#line 1274
      prev = (bin_tree_t *)((void *)0);
      {
#line 1275
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1275
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1275
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1275
            goto while_break___0;
          }
        }
#line 1277
        prev = node;
#line 1278
        node = node->parent;
#line 1279
        if (! node) {
#line 1280
          return ((reg_errcode_t )0);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1282
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1290 "./regcomp.c"
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  int idx ;
  Idx other_idx ;

  {
#line 1293
  dfa = (re_dfa_t *)extra;
#line 1295
  if ((unsigned int )node->token.type == 4U) {
#line 1295
    if (dfa->subexp_map) {
#line 1297
      idx = (int )node->token.opr.idx;
#line 1298
      node->token.opr.idx = *(dfa->subexp_map + idx);
#line 1299
      dfa->used_bkref_map |= (unsigned long )(1 << node->token.opr.idx);
    } else {
#line 1295
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1302
  if ((unsigned int )node->token.type == 17U) {
#line 1302
    if (node->left) {
#line 1302
      if ((unsigned int )(node->left)->token.type == 17U) {
#line 1305
        other_idx = (node->left)->token.opr.idx;
#line 1307
        node->left = (node->left)->left;
#line 1308
        if (node->left) {
#line 1309
          (node->left)->parent = node;
        }
#line 1311
        *(dfa->subexp_map + other_idx) = *(dfa->subexp_map + node->token.opr.idx);
#line 1312
        if (other_idx < 64L) {
#line 1313
          dfa->used_bkref_map &= ~ (1UL << other_idx);
        }
      }
    }
  }
#line 1316
  return ((reg_errcode_t )0);
}
}
#line 1321 "./regcomp.c"
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) 
{ 
  regex_t *preg ;
  reg_errcode_t err ;

  {
#line 1324
  preg = (regex_t *)extra;
#line 1325
  err = (reg_errcode_t )0;
#line 1327
  if (node->left) {
#line 1327
    if ((unsigned int )(node->left)->token.type == 17U) {
      {
#line 1329
      node->left = lower_subexp(& err, preg, node->left);
      }
#line 1330
      if (node->left) {
#line 1331
        (node->left)->parent = node;
      }
    }
  }
#line 1333
  if (node->right) {
#line 1333
    if ((unsigned int )(node->right)->token.type == 17U) {
      {
#line 1335
      node->right = lower_subexp(& err, preg, node->right);
      }
#line 1336
      if (node->right) {
#line 1337
        (node->right)->parent = node;
      }
    }
  }
#line 1340
  return (err);
}
}
#line 1343 "./regcomp.c"
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *body ;
  bin_tree_t *op ;
  bin_tree_t *cls ;
  bin_tree_t *tree1 ;
  bin_tree_t *tree ;
  bin_tree_t *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1346
  dfa = preg->buffer;
#line 1347
  body = node->left;
#line 1350
  if (preg->no_sub) {
#line 1350
    if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1350
      if (node->token.opr.idx >= 64L) {
#line 1359
        return (node->left);
      } else
#line 1350
      if (! (dfa->used_bkref_map & (1UL << node->token.opr.idx))) {
#line 1359
        return (node->left);
      }
    }
  }
  {
#line 1363
  op = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )8);
#line 1364
  cls = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )9);
  }
#line 1365
  if (body) {
    {
#line 1365
    tmp = create_tree(dfa, body, cls, (re_token_type_t )16);
#line 1365
    tree1 = tmp;
    }
  } else {
#line 1365
    tree1 = cls;
  }
  {
#line 1366
  tree = create_tree(dfa, op, tree1, (re_token_type_t )16);
  }
#line 1367
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1367
    tmp___0 = 1;
  } else
#line 1367
  if ((unsigned long )tree1 == (unsigned long )((void *)0)) {
#line 1367
    tmp___0 = 1;
  } else
#line 1367
  if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 1367
    tmp___0 = 1;
  } else
#line 1367
  if ((unsigned long )cls == (unsigned long )((void *)0)) {
#line 1367
    tmp___0 = 1;
  } else {
#line 1367
    tmp___0 = 0;
  }
  {
#line 1367
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 1367
  if (tmp___1) {
#line 1370
    *err = (reg_errcode_t )12;
#line 1371
    return ((bin_tree_t *)((void *)0));
  }
#line 1374
  tmp___2 = node->token.opr.idx;
#line 1374
  cls->token.opr.idx = tmp___2;
#line 1374
  op->token.opr.idx = tmp___2;
#line 1375
  tmp___3 = node->token.opt_subexp;
#line 1375
  cls->token.opt_subexp = tmp___3;
#line 1375
  op->token.opt_subexp = tmp___3;
#line 1376
  return (tree);
}
}
#line 1381 "./regcomp.c"
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
#line 1384
  dfa = (re_dfa_t *)extra;
#line 1385
  if ((unsigned int )node->token.type == 16U) {
#line 1387
    node->first = (node->left)->first;
#line 1388
    node->node_idx = (node->left)->node_idx;
  } else {
    {
#line 1392
    node->first = node;
#line 1393
    node->node_idx = re_dfa_add_node(dfa, node->token);
#line 1394
    tmp = __builtin_expect((long )(node->node_idx == -1L), 0L);
    }
#line 1394
    if (tmp) {
#line 1395
      return ((reg_errcode_t )12);
    }
#line 1396
    if ((unsigned int )node->token.type == 12U) {
#line 1397
      (dfa->nodes + node->node_idx)->constraint = (unsigned int )node->token.opr.ctx_type;
    }
  }
#line 1399
  return ((reg_errcode_t )0);
}
}
#line 1403 "./regcomp.c"
static reg_errcode_t calc_next(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 1408
  if ((unsigned int )node->token.type == 11U) {
#line 1408
    goto case_11;
  }
#line 1411
  if ((unsigned int )node->token.type == 16U) {
#line 1411
    goto case_16;
  }
#line 1415
  goto switch_default;
  case_11: /* CIL Label */ 
#line 1409
  (node->left)->next = node;
#line 1410
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1412
  (node->left)->next = (node->right)->first;
#line 1413
  (node->right)->next = node->next;
#line 1414
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1416
  if (node->left) {
#line 1417
    (node->left)->next = node->next;
  }
#line 1418
  if (node->right) {
#line 1419
    (node->right)->next = node->next;
  }
#line 1420
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1422
  return ((reg_errcode_t )0);
}
}
#line 1426 "./regcomp.c"
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  Idx idx ;
  reg_errcode_t err ;
  Idx left ;
  Idx right ;

  {
#line 1429
  dfa = (re_dfa_t *)extra;
#line 1430
  idx = node->node_idx;
#line 1431
  err = (reg_errcode_t )0;
  {
#line 1435
  if ((unsigned int )node->token.type == 16U) {
#line 1435
    goto case_16;
  }
#line 1438
  if ((unsigned int )node->token.type == 2U) {
#line 1438
    goto case_2;
  }
#line 1443
  if ((unsigned int )node->token.type == 10U) {
#line 1443
    goto case_10;
  }
#line 1443
  if ((unsigned int )node->token.type == 11U) {
#line 1443
    goto case_10;
  }
#line 1463
  if ((unsigned int )node->token.type == 9U) {
#line 1463
    goto case_9;
  }
#line 1463
  if ((unsigned int )node->token.type == 8U) {
#line 1463
    goto case_9;
  }
#line 1463
  if ((unsigned int )node->token.type == 12U) {
#line 1463
    goto case_9;
  }
#line 1467
  if ((unsigned int )node->token.type == 4U) {
#line 1467
    goto case_4;
  }
#line 1473
  goto switch_default;
  case_16: /* CIL Label */ 
#line 1436
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1439
  if (! ((unsigned long )node->next == (unsigned long )((void *)0))) {
    {
#line 1439
    __builtin_unreachable();
    }
  }
#line 1440
  goto switch_break;
  case_10: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 1446
  dfa->has_plural_match = 1U;
#line 1447
  if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1448
    left = ((node->left)->first)->node_idx;
  } else {
#line 1450
    left = (node->next)->node_idx;
  }
#line 1451
  if ((unsigned long )node->right != (unsigned long )((void *)0)) {
#line 1452
    right = ((node->right)->first)->node_idx;
  } else {
#line 1454
    right = (node->next)->node_idx;
  }
#line 1455
  if (! (left > -1L)) {
    {
#line 1455
    __builtin_unreachable();
    }
  }
#line 1456
  if (! (right > -1L)) {
    {
#line 1456
    __builtin_unreachable();
    }
  }
  {
#line 1457
  err = re_node_set_init_2(dfa->edests + idx, left, right);
  }
#line 1459
  goto switch_break;
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_12: /* CIL Label */ 
  {
#line 1464
  err = re_node_set_init_1(dfa->edests + idx, (node->next)->node_idx);
  }
#line 1465
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1468
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1469
  if ((unsigned int )node->token.type == 4U) {
    {
#line 1470
    err = re_node_set_init_1(dfa->edests + idx, *(dfa->nexts + idx));
    }
  }
#line 1471
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1474
  if (! (! ((unsigned int )node->token.type & 8U))) {
    {
#line 1474
    __builtin_unreachable();
    }
  }
#line 1475
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1476
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1479
  return (err);
}
}
#line 1486 "./regcomp.c"
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa , Idx top_org_node , Idx top_clone_node ,
                                            Idx root_node , unsigned int init_constraint ) 
{ 
  Idx org_node ;
  Idx clone_node ;
  _Bool ok ;
  unsigned int constraint ;
  Idx org_dest ;
  Idx clone_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  reg_errcode_t err ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 1492
  constraint = init_constraint;
#line 1493
  org_node = top_org_node;
#line 1493
  clone_node = top_clone_node;
  {
#line 1493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1496
    if ((unsigned int )(dfa->nodes + org_node)->type == 4U) {
      {
#line 1502
      org_dest = *(dfa->nexts + org_node);
#line 1503
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1504
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1505
      tmp = __builtin_expect((long )(clone_dest == -1L), 0L);
      }
#line 1505
      if (tmp) {
#line 1506
        return ((reg_errcode_t )12);
      }
      {
#line 1507
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1508
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1509
      tmp___0 = __builtin_expect((long )(! ok), 0L);
      }
#line 1509
      if (tmp___0) {
#line 1510
        return ((reg_errcode_t )12);
      }
    } else
#line 1512
    if ((dfa->edests + org_node)->nelem == 0L) {
#line 1517
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1518
      goto while_break;
    } else
#line 1520
    if ((dfa->edests + org_node)->nelem == 1L) {
#line 1524
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1525
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1528
      if (org_node == root_node) {
#line 1528
        if (clone_node != org_node) {
          {
#line 1530
          ok = re_node_set_insert(dfa->edests + clone_node, org_dest);
#line 1531
          tmp___1 = __builtin_expect((long )(! ok), 0L);
          }
#line 1531
          if (tmp___1) {
#line 1532
            return ((reg_errcode_t )12);
          }
#line 1533
          goto while_break;
        }
      }
      {
#line 1536
      constraint |= (dfa->nodes + org_node)->constraint;
#line 1537
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1538
      tmp___2 = __builtin_expect((long )(clone_dest == -1L), 0L);
      }
#line 1538
      if (tmp___2) {
#line 1539
        return ((reg_errcode_t )12);
      }
      {
#line 1540
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1541
      tmp___3 = __builtin_expect((long )(! ok), 0L);
      }
#line 1541
      if (tmp___3) {
#line 1542
        return ((reg_errcode_t )12);
      }
    } else {
      {
#line 1548
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1549
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1551
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa, org_dest, constraint);
      }
#line 1552
      if (clone_dest == -1L) {
        {
#line 1556
        clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1557
        tmp___4 = __builtin_expect((long )(clone_dest == -1L), 0L);
        }
#line 1557
        if (tmp___4) {
#line 1558
          return ((reg_errcode_t )12);
        }
        {
#line 1559
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1560
        tmp___5 = __builtin_expect((long )(! ok), 0L);
        }
#line 1560
        if (tmp___5) {
#line 1561
          return ((reg_errcode_t )12);
        }
        {
#line 1562
        err = duplicate_node_closure(dfa, org_dest, clone_dest, root_node, constraint);
#line 1564
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1564
        if (tmp___6) {
#line 1565
          return (err);
        }
      } else {
        {
#line 1571
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1572
        tmp___7 = __builtin_expect((long )(! ok), 0L);
        }
#line 1572
        if (tmp___7) {
#line 1573
          return ((reg_errcode_t )12);
        }
      }
      {
#line 1576
      org_dest = *((dfa->edests + org_node)->elems + 1);
#line 1577
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1578
      tmp___8 = __builtin_expect((long )(clone_dest == -1L), 0L);
      }
#line 1578
      if (tmp___8) {
#line 1579
        return ((reg_errcode_t )12);
      }
      {
#line 1580
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1581
      tmp___9 = __builtin_expect((long )(! ok), 0L);
      }
#line 1581
      if (tmp___9) {
#line 1582
        return ((reg_errcode_t )12);
      }
    }
#line 1584
    org_node = org_dest;
#line 1585
    clone_node = clone_dest;
  }
  while_break: /* CIL Label */ ;
  }
#line 1587
  return ((reg_errcode_t )0);
}
}
#line 1593 "./regcomp.c"
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) 
{ 
  Idx idx ;

  {
#line 1598
  idx = (Idx )(dfa->nodes_len - 1UL);
  {
#line 1598
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1598
    if ((dfa->nodes + idx)->duplicated) {
#line 1598
      if (! (idx > 0L)) {
#line 1598
        goto while_break;
      }
    } else {
#line 1598
      goto while_break;
    }
#line 1600
    if (org_node == *(dfa->org_indices + idx)) {
#line 1600
      if (constraint == (dfa->nodes + idx)->constraint) {
#line 1602
        return (idx);
      }
    }
#line 1598
    idx --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1604
  return ((Idx )-1);
}
}
#line 1611 "./regcomp.c"
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) 
{ 
  Idx dup_idx ;
  Idx tmp ;
  long tmp___0 ;

  {
  {
#line 1614
  tmp = re_dfa_add_node(dfa, *(dfa->nodes + org_idx));
#line 1614
  dup_idx = tmp;
#line 1615
  tmp___0 = __builtin_expect((long )(dup_idx != -1L), 1L);
  }
#line 1615
  if (tmp___0) {
#line 1617
    (dfa->nodes + dup_idx)->constraint = constraint;
#line 1618
    (dfa->nodes + dup_idx)->constraint |= (dfa->nodes + org_idx)->constraint;
#line 1619
    (dfa->nodes + dup_idx)->duplicated = 1U;
#line 1622
    *(dfa->org_indices + dup_idx) = org_idx;
  }
#line 1624
  return (dup_idx);
}
}
#line 1627 "./regcomp.c"
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) 
{ 
  Idx src ;
  Idx idx ;
  _Bool ok ;
  Idx *elems ;
  long tmp ;

  {
#line 1632
  idx = (Idx )0;
  {
#line 1632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1632
    if (! ((size_t )idx < dfa->nodes_len)) {
#line 1632
      goto while_break;
    }
    {
#line 1633
    memset((void *)(dfa->inveclosures + idx), '\000', sizeof(re_node_set ));
#line 1632
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1635
  src = (Idx )0;
  {
#line 1635
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1635
    if (! ((size_t )src < dfa->nodes_len)) {
#line 1635
      goto while_break___0;
    }
#line 1637
    elems = (dfa->eclosures + src)->elems;
#line 1638
    idx = (Idx )0;
    {
#line 1638
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1638
      if (! (idx < (dfa->eclosures + src)->nelem)) {
#line 1638
        goto while_break___1;
      }
      {
#line 1640
      ok = re_node_set_insert_last(dfa->inveclosures + *(elems + idx), src);
#line 1641
      tmp = __builtin_expect((long )(! ok), 0L);
      }
#line 1641
      if (tmp) {
#line 1642
        return ((reg_errcode_t )12);
      }
#line 1638
      idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1635
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1646
  return ((reg_errcode_t )0);
}
}
#line 1651 "./regcomp.c"
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) 
{ 
  Idx node_idx ;
  _Bool incomplete ;
  reg_errcode_t err ;
  re_node_set eclosure_elem ;
  long tmp ;

  {
#line 1656
  if (! (dfa->nodes_len > 0UL)) {
    {
#line 1656
    __builtin_unreachable();
    }
  }
#line 1657
  incomplete = (_Bool)0;
#line 1659
  node_idx = (Idx )0;
  {
#line 1659
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1663
    if ((size_t )node_idx == dfa->nodes_len) {
#line 1665
      if (! incomplete) {
#line 1666
        goto while_break;
      }
#line 1667
      incomplete = (_Bool)0;
#line 1668
      node_idx = (Idx )0;
    }
#line 1671
    if (! ((dfa->eclosures + node_idx)->nelem != -1L)) {
      {
#line 1671
      __builtin_unreachable();
      }
    }
#line 1674
    if ((dfa->eclosures + node_idx)->nelem != 0L) {
#line 1675
      goto __Cont;
    }
    {
#line 1677
    err = calc_eclosure_iter(& eclosure_elem, dfa, node_idx, (_Bool)1);
#line 1678
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1678
    if (tmp) {
#line 1679
      return (err);
    }
#line 1681
    if ((dfa->eclosures + node_idx)->nelem == 0L) {
      {
#line 1683
      incomplete = (_Bool)1;
#line 1684
      free((void *)eclosure_elem.elems);
      }
    }
    __Cont: /* CIL Label */ 
#line 1659
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1687
  return ((reg_errcode_t )0);
}
}
#line 1692 "./regcomp.c"
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  re_node_set eclosure ;
  _Bool ok ;
  _Bool incomplete ;
  long tmp ;
  long tmp___0 ;
  re_node_set eclosure_elem ;
  Idx edest ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 1699
  incomplete = (_Bool)0;
#line 1700
  err = re_node_set_alloc(& eclosure, (dfa->edests + node)->nelem + 1L);
#line 1701
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1701
  if (tmp) {
#line 1702
    return (err);
  }
#line 1706
  (dfa->eclosures + node)->nelem = (Idx )-1;
#line 1710
  if ((dfa->nodes + node)->constraint) {
#line 1710
    if ((dfa->edests + node)->nelem) {
#line 1710
      if (! (dfa->nodes + *((dfa->edests + node)->elems + 0))->duplicated) {
        {
#line 1714
        err = duplicate_node_closure(dfa, node, node, node, (dfa->nodes + node)->constraint);
#line 1716
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1716
        if (tmp___0) {
#line 1717
          return (err);
        }
      }
    }
  }
#line 1721
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
#line 1722
    i = (Idx )0;
    {
#line 1722
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1722
      if (! (i < (dfa->edests + node)->nelem)) {
#line 1722
        goto while_break;
      }
#line 1725
      edest = *((dfa->edests + node)->elems + i);
#line 1728
      if ((dfa->eclosures + edest)->nelem == -1L) {
#line 1730
        incomplete = (_Bool)1;
#line 1731
        goto __Cont;
      }
#line 1735
      if ((dfa->eclosures + edest)->nelem == 0L) {
        {
#line 1737
        err = calc_eclosure_iter(& eclosure_elem, dfa, edest, (_Bool)0);
#line 1738
        tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1738
        if (tmp___1) {
#line 1739
          return (err);
        }
      } else {
#line 1742
        eclosure_elem = *(dfa->eclosures + edest);
      }
      {
#line 1744
      err = re_node_set_merge(& eclosure, (re_node_set const   *)(& eclosure_elem));
#line 1745
      tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1745
      if (tmp___2) {
#line 1746
        return (err);
      }
#line 1749
      if ((dfa->eclosures + edest)->nelem == 0L) {
        {
#line 1751
        incomplete = (_Bool)1;
#line 1752
        free((void *)eclosure_elem.elems);
        }
      }
      __Cont: /* CIL Label */ 
#line 1722
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1757
  ok = re_node_set_insert(& eclosure, node);
#line 1758
  tmp___3 = __builtin_expect((long )(! ok), 0L);
  }
#line 1758
  if (tmp___3) {
#line 1759
    return ((reg_errcode_t )12);
  }
#line 1760
  if (incomplete) {
#line 1760
    if (! root) {
#line 1761
      (dfa->eclosures + node)->nelem = (Idx )0;
    } else {
#line 1763
      *(dfa->eclosures + node) = eclosure;
    }
  } else {
#line 1763
    *(dfa->eclosures + node) = eclosure;
  }
#line 1764
  *new_set = eclosure;
#line 1765
  return ((reg_errcode_t )0);
}
}
#line 1773 "./regcomp.c"
static void fetch_token(re_token_t *result , re_string_t *input , reg_syntax_t syntax ) 
{ 
  int tmp ;

  {
  {
#line 1776
  tmp = peek_token(result, input, syntax);
#line 1776
  input->cur_idx += (Idx )tmp;
  }
#line 1777
  return;
}
}
#line 1782 "./regcomp.c"
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char __attribute__((__pure__))  tmp ;
  wint_t wc ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  wint_t wc___0 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  char prev ;
  re_token_t next ;

  {
#line 1787
  if (input->stop <= input->cur_idx) {
#line 1789
    token->type = (re_token_type_t )2;
#line 1790
    return (0);
  }
#line 1793
  c = *(input->mbs + input->cur_idx);
#line 1794
  token->opr.c = c;
#line 1796
  token->word_char = 0U;
#line 1798
  token->mb_partial = 0U;
#line 1799
  if (input->mb_cur_max > 1) {
#line 1799
    if (! (input->cur_idx == input->valid_len)) {
#line 1799
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 1802
        token->type = (re_token_type_t )1;
#line 1803
        token->mb_partial = 1U;
#line 1804
        return (1);
      }
    }
  }
#line 1807
  if ((int )c == 92) {
#line 1810
    if (input->cur_idx + 1L >= input->len) {
#line 1812
      token->type = (re_token_type_t )36;
#line 1813
      return (1);
    }
    {
#line 1816
    tmp = re_string_peek_byte_case((re_string_t const   *)input, (Idx )1);
#line 1816
    c2 = (unsigned char )tmp;
#line 1817
    token->opr.c = c2;
#line 1818
    token->type = (re_token_type_t )1;
    }
#line 1820
    if (input->mb_cur_max > 1) {
      {
#line 1822
      tmp___0 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx + 1L);
#line 1822
      wc = (wint_t )tmp___0;
#line 1824
      tmp___1 = iswalnum(wc);
      }
#line 1824
      if (tmp___1) {
#line 1824
        tmp___2 = 1;
      } else
#line 1824
      if (wc == 95U) {
#line 1824
        tmp___2 = 1;
      } else {
#line 1824
        tmp___2 = 0;
      }
#line 1824
      token->word_char = (unsigned int )(tmp___2 != 0);
    } else {
      {
#line 1828
      tmp___3 = __ctype_b_loc();
      }
#line 1828
      if ((int const   )*(*tmp___3 + (int )c2) & 8) {
#line 1828
        tmp___4 = 1;
      } else
#line 1828
      if ((int )c2 == 95) {
#line 1828
        tmp___4 = 1;
      } else {
#line 1828
        tmp___4 = 0;
      }
#line 1828
      token->word_char = (unsigned int )(tmp___4 != 0);
    }
    {
#line 1832
    if ((int )c2 == 124) {
#line 1832
      goto case_124;
    }
#line 1837
    if ((int )c2 == 57) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 56) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 55) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 54) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 53) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 52) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 51) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 50) {
#line 1837
      goto case_57;
    }
#line 1837
    if ((int )c2 == 49) {
#line 1837
      goto case_57;
    }
#line 1844
    if ((int )c2 == 60) {
#line 1844
      goto case_60;
    }
#line 1851
    if ((int )c2 == 62) {
#line 1851
      goto case_62;
    }
#line 1858
    if ((int )c2 == 98) {
#line 1858
      goto case_98;
    }
#line 1865
    if ((int )c2 == 66) {
#line 1865
      goto case_66;
    }
#line 1872
    if ((int )c2 == 119) {
#line 1872
      goto case_119;
    }
#line 1876
    if ((int )c2 == 87) {
#line 1876
      goto case_87;
    }
#line 1880
    if ((int )c2 == 115) {
#line 1880
      goto case_115;
    }
#line 1884
    if ((int )c2 == 83) {
#line 1884
      goto case_83;
    }
#line 1888
    if ((int )c2 == 96) {
#line 1888
      goto case_96;
    }
#line 1895
    if ((int )c2 == 39) {
#line 1895
      goto case_39;
    }
#line 1902
    if ((int )c2 == 40) {
#line 1902
      goto case_40;
    }
#line 1906
    if ((int )c2 == 41) {
#line 1906
      goto case_41;
    }
#line 1910
    if ((int )c2 == 43) {
#line 1910
      goto case_43;
    }
#line 1914
    if ((int )c2 == 63) {
#line 1914
      goto case_63;
    }
#line 1918
    if ((int )c2 == 123) {
#line 1918
      goto case_123;
    }
#line 1922
    if ((int )c2 == 125) {
#line 1922
      goto case_125;
    }
#line 1926
    goto switch_default;
    case_124: /* CIL Label */ 
#line 1833
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1833
      if (! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1834
        token->type = (re_token_type_t )10;
      }
    }
#line 1835
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1838
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1840
      token->type = (re_token_type_t )4;
#line 1841
      token->opr.idx = (Idx )((int )c2 - 49);
    }
#line 1843
    goto switch_break;
    case_60: /* CIL Label */ 
#line 1845
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1847
      token->type = (re_token_type_t )12;
#line 1848
      token->opr.ctx_type = (re_context_type )6;
    }
#line 1850
    goto switch_break;
    case_62: /* CIL Label */ 
#line 1852
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1854
      token->type = (re_token_type_t )12;
#line 1855
      token->opr.ctx_type = (re_context_type )9;
    }
#line 1857
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1859
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1861
      token->type = (re_token_type_t )12;
#line 1862
      token->opr.ctx_type = (re_context_type )256;
    }
#line 1864
    goto switch_break;
    case_66: /* CIL Label */ 
#line 1866
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1868
      token->type = (re_token_type_t )12;
#line 1869
      token->opr.ctx_type = (re_context_type )512;
    }
#line 1871
    goto switch_break;
    case_119: /* CIL Label */ 
#line 1873
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1874
      token->type = (re_token_type_t )32;
    }
#line 1875
    goto switch_break;
    case_87: /* CIL Label */ 
#line 1877
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1878
      token->type = (re_token_type_t )33;
    }
#line 1879
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1881
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1882
      token->type = (re_token_type_t )34;
    }
#line 1883
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1885
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1886
      token->type = (re_token_type_t )35;
    }
#line 1887
    goto switch_break;
    case_96: /* CIL Label */ 
#line 1889
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1891
      token->type = (re_token_type_t )12;
#line 1892
      token->opr.ctx_type = (re_context_type )64;
    }
#line 1894
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1896
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1898
      token->type = (re_token_type_t )12;
#line 1899
      token->opr.ctx_type = (re_context_type )128;
    }
#line 1901
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1903
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1904
      token->type = (re_token_type_t )8;
    }
#line 1905
    goto switch_break;
    case_41: /* CIL Label */ 
#line 1907
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1908
      token->type = (re_token_type_t )9;
    }
#line 1909
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1911
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1911
      if (syntax & (1UL << 1)) {
#line 1912
        token->type = (re_token_type_t )18;
      }
    }
#line 1913
    goto switch_break;
    case_63: /* CIL Label */ 
#line 1915
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1915
      if (syntax & (1UL << 1)) {
#line 1916
        token->type = (re_token_type_t )19;
      }
    }
#line 1917
    goto switch_break;
    case_123: /* CIL Label */ 
#line 1919
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1919
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1920
        token->type = (re_token_type_t )23;
      }
    }
#line 1921
    goto switch_break;
    case_125: /* CIL Label */ 
#line 1923
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1923
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1924
        token->type = (re_token_type_t )24;
      }
    }
#line 1925
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1927
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1929
    return (2);
  }
#line 1932
  token->type = (re_token_type_t )1;
#line 1934
  if (input->mb_cur_max > 1) {
    {
#line 1936
    tmp___5 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx);
#line 1936
    wc___0 = (wint_t )tmp___5;
#line 1937
    tmp___6 = iswalnum(wc___0);
    }
#line 1937
    if (tmp___6) {
#line 1937
      tmp___7 = 1;
    } else
#line 1937
    if (wc___0 == 95U) {
#line 1937
      tmp___7 = 1;
    } else {
#line 1937
      tmp___7 = 0;
    }
#line 1937
    token->word_char = (unsigned int )(tmp___7 != 0);
  } else {
    {
#line 1941
    tmp___8 = __ctype_b_loc();
    }
#line 1941
    if ((int const   )*(*tmp___8 + (int )token->opr.c) & 8) {
#line 1941
      tmp___9 = 1;
    } else
#line 1941
    if ((int )token->opr.c == 95) {
#line 1941
      tmp___9 = 1;
    } else {
#line 1941
      tmp___9 = 0;
    }
#line 1941
    token->word_char = (unsigned int )tmp___9;
  }
  {
#line 1945
  if ((int )c == 10) {
#line 1945
    goto case_10;
  }
#line 1949
  if ((int )c == 124) {
#line 1949
    goto case_124___0;
  }
#line 1953
  if ((int )c == 42) {
#line 1953
    goto case_42;
  }
#line 1956
  if ((int )c == 43) {
#line 1956
    goto case_43___0;
  }
#line 1960
  if ((int )c == 63) {
#line 1960
    goto case_63___0;
  }
#line 1964
  if ((int )c == 123) {
#line 1964
    goto case_123___0;
  }
#line 1968
  if ((int )c == 125) {
#line 1968
    goto case_125___0;
  }
#line 1972
  if ((int )c == 40) {
#line 1972
    goto case_40___0;
  }
#line 1976
  if ((int )c == 41) {
#line 1976
    goto case_41___0;
  }
#line 1980
  if ((int )c == 91) {
#line 1980
    goto case_91;
  }
#line 1983
  if ((int )c == 46) {
#line 1983
    goto case_46;
  }
#line 1986
  if ((int )c == 94) {
#line 1986
    goto case_94;
  }
#line 1997
  if ((int )c == 36) {
#line 1997
    goto case_36;
  }
#line 2011
  goto switch_default___0;
  case_10: /* CIL Label */ 
#line 1946
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1947
    token->type = (re_token_type_t )10;
  }
#line 1948
  goto switch_break___0;
  case_124___0: /* CIL Label */ 
#line 1950
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1950
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1951
      token->type = (re_token_type_t )10;
    }
  }
#line 1952
  goto switch_break___0;
  case_42: /* CIL Label */ 
#line 1954
  token->type = (re_token_type_t )11;
#line 1955
  goto switch_break___0;
  case_43___0: /* CIL Label */ 
#line 1957
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1957
    if (! (syntax & (1UL << 1))) {
#line 1958
      token->type = (re_token_type_t )18;
    }
  }
#line 1959
  goto switch_break___0;
  case_63___0: /* CIL Label */ 
#line 1961
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1961
    if (! (syntax & (1UL << 1))) {
#line 1962
      token->type = (re_token_type_t )19;
    }
  }
#line 1963
  goto switch_break___0;
  case_123___0: /* CIL Label */ 
#line 1965
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1965
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1966
      token->type = (re_token_type_t )23;
    }
  }
#line 1967
  goto switch_break___0;
  case_125___0: /* CIL Label */ 
#line 1969
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1969
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1970
      token->type = (re_token_type_t )24;
    }
  }
#line 1971
  goto switch_break___0;
  case_40___0: /* CIL Label */ 
#line 1973
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1974
    token->type = (re_token_type_t )8;
  }
#line 1975
  goto switch_break___0;
  case_41___0: /* CIL Label */ 
#line 1977
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1978
    token->type = (re_token_type_t )9;
  }
#line 1979
  goto switch_break___0;
  case_91: /* CIL Label */ 
#line 1981
  token->type = (re_token_type_t )20;
#line 1982
  goto switch_break___0;
  case_46: /* CIL Label */ 
#line 1984
  token->type = (re_token_type_t )5;
#line 1985
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 1987
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1987
    if (input->cur_idx != 0L) {
#line 1990
      prev = (char )*(input->mbs + (input->cur_idx + -1L));
#line 1991
      if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1992
        goto switch_break___0;
      } else
#line 1991
      if ((int )prev != 10) {
#line 1992
        goto switch_break___0;
      }
    }
  }
#line 1994
  token->type = (re_token_type_t )12;
#line 1995
  token->opr.ctx_type = (re_context_type )16;
#line 1996
  goto switch_break___0;
  case_36: /* CIL Label */ 
#line 1998
  if (! (syntax & (((1UL << 1) << 1) << 1))) {
#line 1998
    if (input->cur_idx + 1L != input->len) {
      {
#line 2002
      (input->cur_idx) ++;
#line 2003
      peek_token(& next, input, syntax);
#line 2004
      (input->cur_idx) --;
      }
#line 2005
      if ((unsigned int )next.type != 10U) {
#line 2005
        if ((unsigned int )next.type != 9U) {
#line 2006
          goto switch_break___0;
        }
      }
    }
  }
#line 2008
  token->type = (re_token_type_t )12;
#line 2009
  token->opr.ctx_type = (re_context_type )32;
#line 2010
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2012
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 2014
  return (1);
}
}
#line 2020 "./regcomp.c"
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
#line 2024
  if (input->stop <= input->cur_idx) {
#line 2026
    token->type = (re_token_type_t )2;
#line 2027
    return (0);
  }
#line 2029
  c = *(input->mbs + input->cur_idx);
#line 2030
  token->opr.c = c;
#line 2033
  if (input->mb_cur_max > 1) {
#line 2033
    if (! (input->cur_idx == input->valid_len)) {
#line 2033
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 2036
        token->type = (re_token_type_t )1;
#line 2037
        return (1);
      }
    }
  }
#line 2041
  if ((int )c == 92) {
#line 2041
    if (syntax & 1UL) {
#line 2041
      if (input->cur_idx + 1L < input->len) {
#line 2046
        (input->cur_idx) ++;
#line 2047
        c2 = *(input->mbs + input->cur_idx);
#line 2048
        token->opr.c = c2;
#line 2049
        token->type = (re_token_type_t )1;
#line 2050
        return (1);
      }
    }
  }
#line 2052
  if ((int )c == 91) {
#line 2056
    if (input->cur_idx + 1L < input->len) {
#line 2057
      c2___0 = *(input->mbs + (input->cur_idx + 1L));
    } else {
#line 2059
      c2___0 = (unsigned char)0;
    }
#line 2060
    token->opr.c = c2___0;
#line 2061
    token_len = 2;
    {
#line 2064
    if ((int )c2___0 == 46) {
#line 2064
      goto case_46;
    }
#line 2068
    if ((int )c2___0 == 61) {
#line 2068
      goto case_61;
    }
#line 2072
    if ((int )c2___0 == 58) {
#line 2072
      goto case_58;
    }
#line 2079
    goto switch_default;
    case_46: /* CIL Label */ 
#line 2065
    token->type = (re_token_type_t )26;
#line 2066
    goto switch_break;
    case_61: /* CIL Label */ 
#line 2069
    token->type = (re_token_type_t )28;
#line 2070
    goto switch_break;
    case_58: /* CIL Label */ 
#line 2073
    if (syntax & ((1UL << 1) << 1)) {
#line 2075
      token->type = (re_token_type_t )30;
#line 2076
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 2080
    token->type = (re_token_type_t )1;
#line 2081
    token->opr.c = c;
#line 2082
    token_len = 1;
#line 2083
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2085
    return (token_len);
  }
  {
#line 2089
  if ((int )c == 45) {
#line 2089
    goto case_45;
  }
#line 2092
  if ((int )c == 93) {
#line 2092
    goto case_93;
  }
#line 2095
  if ((int )c == 94) {
#line 2095
    goto case_94;
  }
#line 2098
  goto switch_default___0;
  case_45: /* CIL Label */ 
#line 2090
  token->type = (re_token_type_t )22;
#line 2091
  goto switch_break___0;
  case_93: /* CIL Label */ 
#line 2093
  token->type = (re_token_type_t )21;
#line 2094
  goto switch_break___0;
  case_94: /* CIL Label */ 
#line 2096
  token->type = (re_token_type_t )25;
#line 2097
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 2099
  token->type = (re_token_type_t )1;
  switch_break___0: /* CIL Label */ ;
  }
#line 2101
  return (1);
}
}
#line 2118 "./regcomp.c"
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 2122
  dfa = preg->buffer;
#line 2125
  dfa->syntax = syntax;
#line 2126
  fetch_token(& current_token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2127
  tree = parse_reg_exp(regexp, preg, & current_token, syntax, (Idx )0, err);
  }
#line 2128
  if ((int )*err != 0) {
#line 2128
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2128
      tmp = 1;
    } else {
#line 2128
      tmp = 0;
    }
  } else {
#line 2128
    tmp = 0;
  }
  {
#line 2128
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2128
  if (tmp___0) {
#line 2129
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2130
  eor = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )2);
  }
#line 2131
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
    {
#line 2132
    root = create_tree(dfa, tree, eor, (re_token_type_t )16);
    }
  } else {
#line 2134
    root = eor;
  }
#line 2135
  if ((unsigned long )eor == (unsigned long )((void *)0)) {
#line 2135
    tmp___1 = 1;
  } else
#line 2135
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 2135
    tmp___1 = 1;
  } else {
#line 2135
    tmp___1 = 0;
  }
  {
#line 2135
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 2135
  if (tmp___2) {
#line 2137
    *err = (reg_errcode_t )12;
#line 2138
    return ((bin_tree_t *)((void *)0));
  }
#line 2140
  return (root);
}
}
#line 2152 "./regcomp.c"
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *branch ;
  bitset_word_t initial_bkref_map ;
  int tmp ;
  long tmp___0 ;
  bitset_word_t accumulated_bkref_map ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2156
  dfa = preg->buffer;
#line 2157
  branch = (bin_tree_t *)((void *)0);
#line 2158
  initial_bkref_map = dfa->completed_bkref_map;
#line 2159
  tree = parse_branch(regexp, preg, token, syntax, nest, err);
  }
#line 2160
  if ((int )*err != 0) {
#line 2160
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2160
      tmp = 1;
    } else {
#line 2160
      tmp = 0;
    }
  } else {
#line 2160
    tmp = 0;
  }
  {
#line 2160
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2160
  if (tmp___0) {
#line 2161
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2163
    if (! ((unsigned int )token->type == 10U)) {
#line 2163
      goto while_break;
    }
    {
#line 2165
    fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
    }
#line 2166
    if ((unsigned int )token->type != 10U) {
#line 2166
      if ((unsigned int )token->type != 2U) {
#line 2166
        if (nest == 0L) {
#line 2166
          goto _L;
        } else
#line 2166
        if ((unsigned int )token->type != 9U) {
          _L: /* CIL Label */ 
          {
#line 2169
          accumulated_bkref_map = dfa->completed_bkref_map;
#line 2170
          dfa->completed_bkref_map = initial_bkref_map;
#line 2171
          branch = parse_branch(regexp, preg, token, syntax, nest, err);
          }
#line 2172
          if ((int )*err != 0) {
#line 2172
            if ((unsigned long )branch == (unsigned long )((void *)0)) {
#line 2172
              tmp___1 = 1;
            } else {
#line 2172
              tmp___1 = 0;
            }
          } else {
#line 2172
            tmp___1 = 0;
          }
          {
#line 2172
          tmp___2 = __builtin_expect((long )tmp___1, 0L);
          }
#line 2172
          if (tmp___2) {
#line 2174
            if ((unsigned long )tree != (unsigned long )((void *)0)) {
              {
#line 2175
              postorder(tree, & free_tree, (void *)0);
              }
            }
#line 2176
            return ((bin_tree_t *)((void *)0));
          }
#line 2178
          dfa->completed_bkref_map |= accumulated_bkref_map;
        } else {
#line 2181
          branch = (bin_tree_t *)((void *)0);
        }
      } else {
#line 2181
        branch = (bin_tree_t *)((void *)0);
      }
    } else {
#line 2181
      branch = (bin_tree_t *)((void *)0);
    }
    {
#line 2182
    tree = create_tree(dfa, tree, branch, (re_token_type_t )10);
#line 2183
    tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 2183
    if (tmp___3) {
#line 2185
      *err = (reg_errcode_t )12;
#line 2186
      return ((bin_tree_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2189
  return (tree);
}
}
#line 2201 "./regcomp.c"
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *expr ;
  re_dfa_t *dfa ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  bin_tree_t *newtree ;
  bin_tree_t *tmp___3 ;

  {
  {
#line 2206
  dfa = preg->buffer;
#line 2207
  tree = parse_expression(regexp, preg, token, syntax, nest, err);
  }
#line 2208
  if ((int )*err != 0) {
#line 2208
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2208
      tmp = 1;
    } else {
#line 2208
      tmp = 0;
    }
  } else {
#line 2208
    tmp = 0;
  }
  {
#line 2208
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2208
  if (tmp___0) {
#line 2209
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2211
    if ((unsigned int )token->type != 10U) {
#line 2211
      if ((unsigned int )token->type != 2U) {
#line 2211
        if (! (nest == 0L)) {
#line 2211
          if (! ((unsigned int )token->type != 9U)) {
#line 2211
            goto while_break;
          }
        }
      } else {
#line 2211
        goto while_break;
      }
    } else {
#line 2211
      goto while_break;
    }
    {
#line 2214
    expr = parse_expression(regexp, preg, token, syntax, nest, err);
    }
#line 2215
    if ((int )*err != 0) {
#line 2215
      if ((unsigned long )expr == (unsigned long )((void *)0)) {
#line 2215
        tmp___1 = 1;
      } else {
#line 2215
        tmp___1 = 0;
      }
    } else {
#line 2215
      tmp___1 = 0;
    }
    {
#line 2215
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 2215
    if (tmp___2) {
#line 2217
      if ((unsigned long )tree != (unsigned long )((void *)0)) {
        {
#line 2218
        postorder(tree, & free_tree, (void *)0);
        }
      }
#line 2219
      return ((bin_tree_t *)((void *)0));
    }
#line 2221
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 2221
      if ((unsigned long )expr != (unsigned long )((void *)0)) {
        {
#line 2223
        tmp___3 = create_tree(dfa, tree, expr, (re_token_type_t )16);
#line 2223
        newtree = tmp___3;
        }
#line 2224
        if ((unsigned long )newtree == (unsigned long )((void *)0)) {
          {
#line 2226
          postorder(expr, & free_tree, (void *)0);
#line 2227
          postorder(tree, & free_tree, (void *)0);
#line 2228
          *err = (reg_errcode_t )12;
          }
#line 2229
          return ((bin_tree_t *)((void *)0));
        }
#line 2231
        tree = newtree;
      } else {
#line 2221
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2233
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2234
      tree = expr;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2237
  return (tree);
}
}
#line 2246 "./regcomp.c"
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  long tmp ;
  bin_tree_t *mbc_remain ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  bin_tree_t *tmp___8 ;
  long tmp___9 ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  bin_tree_t *dup_tree ;
  bin_tree_t *tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;

  {
#line 2250
  dfa = preg->buffer;
  {
#line 2254
  if ((unsigned int )token->type == 1U) {
#line 2254
    goto case_1;
  }
#line 2281
  if ((unsigned int )token->type == 8U) {
#line 2281
    goto case_8;
  }
#line 2287
  if ((unsigned int )token->type == 20U) {
#line 2287
    goto case_20;
  }
#line 2293
  if ((unsigned int )token->type == 4U) {
#line 2293
    goto case_4;
  }
#line 2310
  if ((unsigned int )token->type == 23U) {
#line 2310
    goto case_23;
  }
#line 2319
  if ((unsigned int )token->type == 19U) {
#line 2319
    goto case_19;
  }
#line 2319
  if ((unsigned int )token->type == 18U) {
#line 2319
    goto case_19;
  }
#line 2319
  if ((unsigned int )token->type == 11U) {
#line 2319
    goto case_19;
  }
#line 2331
  if ((unsigned int )token->type == 9U) {
#line 2331
    goto case_9;
  }
#line 2339
  if ((unsigned int )token->type == 24U) {
#line 2339
    goto case_24;
  }
#line 2354
  if ((unsigned int )token->type == 12U) {
#line 2354
    goto case_12;
  }
#line 2400
  if ((unsigned int )token->type == 5U) {
#line 2400
    goto case_5;
  }
#line 2412
  if ((unsigned int )token->type == 33U) {
#line 2412
    goto case_33;
  }
#line 2412
  if ((unsigned int )token->type == 32U) {
#line 2412
    goto case_33;
  }
#line 2422
  if ((unsigned int )token->type == 35U) {
#line 2422
    goto case_35;
  }
#line 2422
  if ((unsigned int )token->type == 34U) {
#line 2422
    goto case_35;
  }
#line 2432
  if ((unsigned int )token->type == 2U) {
#line 2432
    goto case_2;
  }
#line 2432
  if ((unsigned int )token->type == 10U) {
#line 2432
    goto case_2;
  }
#line 2435
  if ((unsigned int )token->type == 36U) {
#line 2435
    goto case_36;
  }
#line 2439
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2255
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2256
  tmp = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                         0L);
  }
#line 2256
  if (tmp) {
#line 2258
    *err = (reg_errcode_t )12;
#line 2259
    return ((bin_tree_t *)((void *)0));
  }
#line 2262
  if (dfa->mb_cur_max > 1) {
    {
#line 2264
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2264
      if (! (regexp->stop <= regexp->cur_idx)) {
#line 2264
        if (regexp->cur_idx == regexp->valid_len) {
#line 2264
          goto while_break;
        } else
#line 2264
        if (*(regexp->wcs + regexp->cur_idx) != 4294967295U) {
#line 2264
          goto while_break;
        }
      } else {
#line 2264
        goto while_break;
      }
      {
#line 2268
      fetch_token(token, regexp, syntax);
#line 2269
      mbc_remain = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2270
      tree = create_tree(dfa, tree, mbc_remain, (re_token_type_t )16);
      }
#line 2271
      if ((unsigned long )mbc_remain == (unsigned long )((void *)0)) {
#line 2271
        tmp___0 = 1;
      } else
#line 2271
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2271
        tmp___0 = 1;
      } else {
#line 2271
        tmp___0 = 0;
      }
      {
#line 2271
      tmp___1 = __builtin_expect((long )tmp___0, 0L);
      }
#line 2271
      if (tmp___1) {
#line 2273
        *err = (reg_errcode_t )12;
#line 2274
        return ((bin_tree_t *)((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2279
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2282
  tree = parse_sub_exp(regexp, preg, token, syntax, nest + 1L, err);
  }
#line 2283
  if ((int )*err != 0) {
#line 2283
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2283
      tmp___2 = 1;
    } else {
#line 2283
      tmp___2 = 0;
    }
  } else {
#line 2283
    tmp___2 = 0;
  }
  {
#line 2283
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
  }
#line 2283
  if (tmp___3) {
#line 2284
    return ((bin_tree_t *)((void *)0));
  }
#line 2285
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2288
  tree = parse_bracket_exp(regexp, dfa, token, syntax, err);
  }
#line 2289
  if ((int )*err != 0) {
#line 2289
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2289
      tmp___4 = 1;
    } else {
#line 2289
      tmp___4 = 0;
    }
  } else {
#line 2289
    tmp___4 = 0;
  }
  {
#line 2289
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
  }
#line 2289
  if (tmp___5) {
#line 2290
    return ((bin_tree_t *)((void *)0));
  }
#line 2291
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2294
  tmp___6 = __builtin_expect((long )(dfa->completed_bkref_map & (unsigned long )(1 << token->opr.idx)),
                             1L);
  }
#line 2294
  if (! tmp___6) {
#line 2296
    *err = (reg_errcode_t )6;
#line 2297
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2299
  dfa->used_bkref_map |= (unsigned long )(1 << token->opr.idx);
#line 2300
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2301
  tmp___7 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2301
  if (tmp___7) {
#line 2303
    *err = (reg_errcode_t )12;
#line 2304
    return ((bin_tree_t *)((void *)0));
  }
#line 2306
  (dfa->nbackref) ++;
#line 2307
  dfa->has_mb_node = 1U;
#line 2308
  goto switch_break;
  case_23: /* CIL Label */ 
#line 2311
  if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2313
    *err = (reg_errcode_t )13;
#line 2314
    return ((bin_tree_t *)((void *)0));
  }
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 2320
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 2322
    *err = (reg_errcode_t )13;
#line 2323
    return ((bin_tree_t *)((void *)0));
  } else
#line 2325
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
    {
#line 2327
    fetch_token(token, regexp, syntax);
#line 2328
    tmp___8 = parse_expression(regexp, preg, token, syntax, nest, err);
    }
#line 2328
    return (tmp___8);
  }
  case_9: /* CIL Label */ 
#line 2332
  if ((unsigned int )token->type == 9U) {
#line 2332
    if (! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2335
      *err = (reg_errcode_t )16;
#line 2336
      return ((bin_tree_t *)((void *)0));
    }
  }
  case_24: /* CIL Label */ 
  {
#line 2343
  token->type = (re_token_type_t )1;
#line 2346
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2347
  tmp___9 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2347
  if (tmp___9) {
#line 2349
    *err = (reg_errcode_t )12;
#line 2350
    return ((bin_tree_t *)((void *)0));
  }
#line 2352
  goto switch_break;
  case_12: /* CIL Label */ 
#line 2355
  if ((unsigned int )token->opr.ctx_type & 783U) {
#line 2355
    if (dfa->word_ops_used == 0U) {
      {
#line 2358
      init_word_char(dfa);
      }
    }
  }
#line 2359
  if ((unsigned int )token->opr.ctx_type == 256U) {
#line 2359
    goto _L;
  } else
#line 2359
  if ((unsigned int )token->opr.ctx_type == 512U) {
    _L: /* CIL Label */ 
#line 2363
    if ((unsigned int )token->opr.ctx_type == 256U) {
      {
#line 2365
      token->opr.ctx_type = (re_context_type )6;
#line 2366
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2367
      token->opr.ctx_type = (re_context_type )9;
      }
    } else {
      {
#line 2371
      token->opr.ctx_type = (re_context_type )5;
#line 2372
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2373
      token->opr.ctx_type = (re_context_type )10;
      }
    }
    {
#line 2375
    tree_last = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)token);
#line 2376
    tree = create_tree(dfa, tree_first, tree_last, (re_token_type_t )10);
    }
#line 2377
    if ((unsigned long )tree_first == (unsigned long )((void *)0)) {
#line 2377
      tmp___10 = 1;
    } else
#line 2377
    if ((unsigned long )tree_last == (unsigned long )((void *)0)) {
#line 2377
      tmp___10 = 1;
    } else
#line 2377
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2377
      tmp___10 = 1;
    } else {
#line 2377
      tmp___10 = 0;
    }
    {
#line 2377
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
    }
#line 2377
    if (tmp___11) {
#line 2380
      *err = (reg_errcode_t )12;
#line 2381
      return ((bin_tree_t *)((void *)0));
    }
  } else {
    {
#line 2386
    tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                             (re_token_t const   *)token);
#line 2387
    tmp___12 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 2387
    if (tmp___12) {
#line 2389
      *err = (reg_errcode_t )12;
#line 2390
      return ((bin_tree_t *)((void *)0));
    }
  }
  {
#line 2397
  fetch_token(token, regexp, syntax);
  }
#line 2398
  return (tree);
  case_5: /* CIL Label */ 
  {
#line 2401
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2402
  tmp___13 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2402
  if (tmp___13) {
#line 2404
    *err = (reg_errcode_t )12;
#line 2405
    return ((bin_tree_t *)((void *)0));
  }
#line 2407
  if (dfa->mb_cur_max > 1) {
#line 2408
    dfa->has_mb_node = 1U;
  }
#line 2409
  goto switch_break;
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  {
#line 2413
  tree = build_charclass_op(dfa, regexp->trans, "alnum", "_", (_Bool )((unsigned int )token->type == 33U),
                            err);
  }
#line 2417
  if ((int )*err != 0) {
#line 2417
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2417
      tmp___14 = 1;
    } else {
#line 2417
      tmp___14 = 0;
    }
  } else {
#line 2417
    tmp___14 = 0;
  }
  {
#line 2417
  tmp___15 = __builtin_expect((long )tmp___14, 0L);
  }
#line 2417
  if (tmp___15) {
#line 2418
    return ((bin_tree_t *)((void *)0));
  }
#line 2419
  goto switch_break;
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  {
#line 2423
  tree = build_charclass_op(dfa, regexp->trans, "space", "", (_Bool )((unsigned int )token->type == 35U),
                            err);
  }
#line 2427
  if ((int )*err != 0) {
#line 2427
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2427
      tmp___16 = 1;
    } else {
#line 2427
      tmp___16 = 0;
    }
  } else {
#line 2427
    tmp___16 = 0;
  }
  {
#line 2427
  tmp___17 = __builtin_expect((long )tmp___16, 0L);
  }
#line 2427
  if (tmp___17) {
#line 2428
    return ((bin_tree_t *)((void *)0));
  }
#line 2429
  goto switch_break;
  case_2: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 2433
  return ((bin_tree_t *)((void *)0));
  case_36: /* CIL Label */ 
#line 2436
  *err = (reg_errcode_t )5;
#line 2437
  return ((bin_tree_t *)((void *)0));
  switch_default: /* CIL Label */ 
  {
#line 2441
  __builtin_unreachable();
  }
#line 2442
  return ((bin_tree_t *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 2444
  fetch_token(token, regexp, syntax);
  }
  {
#line 2446
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2446
    if (! ((unsigned int )token->type == 11U)) {
#line 2446
      if (! ((unsigned int )token->type == 18U)) {
#line 2446
        if (! ((unsigned int )token->type == 19U)) {
#line 2446
          if (! ((unsigned int )token->type == 23U)) {
#line 2446
            goto while_break___0;
          }
        }
      }
    }
    {
#line 2449
    tmp___18 = parse_dup_op(tree, regexp, dfa, token, syntax, err);
#line 2449
    dup_tree = tmp___18;
    }
#line 2451
    if ((int )*err != 0) {
#line 2451
      if ((unsigned long )dup_tree == (unsigned long )((void *)0)) {
#line 2451
        tmp___19 = 1;
      } else {
#line 2451
        tmp___19 = 0;
      }
    } else {
#line 2451
      tmp___19 = 0;
    }
    {
#line 2451
    tmp___20 = __builtin_expect((long )tmp___19, 0L);
    }
#line 2451
    if (tmp___20) {
#line 2453
      if ((unsigned long )tree != (unsigned long )((void *)0)) {
        {
#line 2454
        postorder(tree, & free_tree, (void *)0);
        }
      }
#line 2455
      return ((bin_tree_t *)((void *)0));
    }
#line 2457
    tree = dup_tree;
#line 2459
    if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2459
      if ((unsigned int )token->type == 11U) {
#line 2459
        goto _L___0;
      } else
#line 2459
      if ((unsigned int )token->type == 23U) {
        _L___0: /* CIL Label */ 
#line 2463
        if ((unsigned long )tree != (unsigned long )((void *)0)) {
          {
#line 2464
          postorder(tree, & free_tree, (void *)0);
          }
        }
#line 2465
        *err = (reg_errcode_t )13;
#line 2466
        return ((bin_tree_t *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2470
  return (tree);
}
}
#line 2480 "./regcomp.c"
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  size_t cur_nsub ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  {
#line 2484
  dfa = preg->buffer;
#line 2487
  tmp = preg->re_nsub;
#line 2487
  (preg->re_nsub) ++;
#line 2487
  cur_nsub = tmp;
#line 2489
  fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
#line 2492
  if ((unsigned int )token->type == 9U) {
#line 2493
    tree = (bin_tree_t *)((void *)0);
  } else {
    {
#line 2496
    tree = parse_reg_exp(regexp, preg, token, syntax, nest, err);
    }
#line 2497
    if ((int )*err == 0) {
#line 2497
      if ((unsigned int )token->type != 9U) {
#line 2497
        tmp___0 = 1;
      } else {
#line 2497
        tmp___0 = 0;
      }
    } else {
#line 2497
      tmp___0 = 0;
    }
    {
#line 2497
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
    }
#line 2497
    if (tmp___1) {
#line 2500
      if ((unsigned long )tree != (unsigned long )((void *)0)) {
        {
#line 2501
        postorder(tree, & free_tree, (void *)0);
        }
      }
#line 2502
      *err = (reg_errcode_t )8;
    }
    {
#line 2504
    tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
    }
#line 2504
    if (tmp___2) {
#line 2505
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2508
  if (cur_nsub <= 8UL) {
#line 2509
    dfa->completed_bkref_map |= (unsigned long )(1 << cur_nsub);
  }
  {
#line 2511
  tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )17);
#line 2512
  tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 2512
  if (tmp___3) {
#line 2514
    *err = (reg_errcode_t )12;
#line 2515
    return ((bin_tree_t *)((void *)0));
  }
#line 2517
  tree->token.opr.idx = (Idx )cur_nsub;
#line 2518
  return (tree);
}
}
#line 2523 "./regcomp.c"
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *old_tree ;
  Idx i ;
  Idx start ;
  Idx end ;
  Idx start_idx ;
  re_token_t start_token ;
  Idx tmp ;
  Idx tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  Idx tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  uintptr_t subidx ;
  int tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;

  {
#line 2527
  tree = (bin_tree_t *)((void *)0);
#line 2527
  old_tree = (bin_tree_t *)((void *)0);
#line 2528
  start_idx = regexp->cur_idx;
#line 2529
  start_token = *token;
#line 2531
  if ((unsigned int )token->type == 23U) {
    {
#line 2533
    end = (Idx )0;
#line 2534
    start = fetch_number(regexp, token, syntax);
    }
#line 2535
    if (start == -1L) {
#line 2537
      if ((unsigned int )token->type == 1U) {
#line 2537
        if ((int )token->opr.c == 44) {
#line 2538
          start = (Idx )0;
        } else {
#line 2541
          *err = (reg_errcode_t )10;
#line 2542
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2541
        *err = (reg_errcode_t )10;
#line 2542
        return ((bin_tree_t *)((void *)0));
      }
    }
    {
#line 2545
    tmp___1 = __builtin_expect((long )(start != -2L), 1L);
    }
#line 2545
    if (tmp___1) {
#line 2548
      if ((unsigned int )token->type == 24U) {
#line 2548
        end = start;
      } else {
#line 2548
        if ((unsigned int )token->type == 1U) {
#line 2548
          if ((int )token->opr.c == 44) {
            {
#line 2548
            tmp = fetch_number(regexp, token, syntax);
#line 2548
            tmp___0 = tmp;
            }
          } else {
#line 2548
            tmp___0 = (Idx )-2;
          }
        } else {
#line 2548
          tmp___0 = (Idx )-2;
        }
#line 2548
        end = tmp___0;
      }
    }
#line 2552
    if (start == -2L) {
#line 2552
      tmp___3 = 1;
    } else
#line 2552
    if (end == -2L) {
#line 2552
      tmp___3 = 1;
    } else {
#line 2552
      tmp___3 = 0;
    }
    {
#line 2552
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
    }
#line 2552
    if (tmp___4) {
      {
#line 2555
      tmp___2 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                                 0L);
      }
#line 2555
      if (tmp___2) {
#line 2557
        if ((unsigned int )token->type == 2U) {
#line 2558
          *err = (reg_errcode_t )9;
        } else {
#line 2560
          *err = (reg_errcode_t )10;
        }
#line 2562
        return ((bin_tree_t *)((void *)0));
      }
#line 2566
      regexp->cur_idx = start_idx;
#line 2567
      *token = start_token;
#line 2568
      token->type = (re_token_type_t )1;
#line 2571
      return (elem);
    }
#line 2574
    if (end != -1L) {
#line 2574
      if (start > end) {
#line 2574
        tmp___5 = 1;
      } else {
#line 2574
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2574
    if ((unsigned int )token->type != 24U) {
#line 2574
      tmp___5 = 1;
    } else {
#line 2574
      tmp___5 = 0;
    }
    {
#line 2574
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
    }
#line 2574
    if (tmp___6) {
#line 2578
      *err = (reg_errcode_t )10;
#line 2579
      return ((bin_tree_t *)((void *)0));
    }
#line 2582
    if (end == -1L) {
#line 2582
      tmp___7 = start;
    } else {
#line 2582
      tmp___7 = end;
    }
    {
#line 2582
    tmp___8 = __builtin_expect((long )(32767L < tmp___7), 0L);
    }
#line 2582
    if (tmp___8) {
#line 2584
      *err = (reg_errcode_t )15;
#line 2585
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2590
    if ((unsigned int )token->type == 18U) {
#line 2590
      start = (Idx )1;
    } else {
#line 2590
      start = (Idx )0;
    }
#line 2591
    if ((unsigned int )token->type == 19U) {
#line 2591
      end = (Idx )1;
    } else {
#line 2591
      end = (Idx )-1;
    }
  }
  {
#line 2594
  fetch_token(token, regexp, syntax);
#line 2596
  tmp___9 = __builtin_expect((long )((unsigned long )elem == (unsigned long )((void *)0)),
                             0L);
  }
#line 2596
  if (tmp___9) {
#line 2597
    return ((bin_tree_t *)((void *)0));
  }
#line 2598
  if (start == 0L) {
#line 2598
    if (end == 0L) {
#line 2598
      tmp___10 = 1;
    } else {
#line 2598
      tmp___10 = 0;
    }
  } else {
#line 2598
    tmp___10 = 0;
  }
  {
#line 2598
  tmp___11 = __builtin_expect((long )tmp___10, 0L);
  }
#line 2598
  if (tmp___11) {
    {
#line 2600
    postorder(elem, & free_tree, (void *)0);
    }
#line 2601
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 2605
  tmp___15 = __builtin_expect((long )(start > 0L), 0L);
  }
#line 2605
  if (tmp___15) {
#line 2607
    tree = elem;
#line 2608
    i = (Idx )2;
    {
#line 2608
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2608
      if (! (i <= start)) {
#line 2608
        goto while_break;
      }
      {
#line 2610
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2611
      tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
      }
#line 2612
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2612
        tmp___12 = 1;
      } else
#line 2612
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2612
        tmp___12 = 1;
      } else {
#line 2612
        tmp___12 = 0;
      }
      {
#line 2612
      tmp___13 = __builtin_expect((long )tmp___12, 0L);
      }
#line 2612
      if (tmp___13) {
#line 2613
        goto parse_dup_op_espace;
      }
#line 2608
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2616
    if (start == end) {
#line 2617
      return (tree);
    }
    {
#line 2620
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2621
    tmp___14 = __builtin_expect((long )((unsigned long )elem == (unsigned long )((void *)0)),
                                0L);
    }
#line 2621
    if (tmp___14) {
#line 2622
      goto parse_dup_op_espace;
    }
#line 2623
    old_tree = tree;
  } else {
#line 2626
    old_tree = (bin_tree_t *)((void *)0);
  }
#line 2628
  if ((unsigned int )elem->token.type == 17U) {
    {
#line 2630
    subidx = (uintptr_t )elem->token.opr.idx;
#line 2631
    postorder(elem, & mark_opt_subexp, (void *)subidx);
    }
  }
#line 2634
  if (end == -1L) {
#line 2634
    tmp___16 = 11;
  } else {
#line 2634
    tmp___16 = 10;
  }
  {
#line 2634
  tree = create_tree(dfa, elem, (bin_tree_t *)((void *)0), (re_token_type_t )tmp___16);
#line 2636
  tmp___17 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
  }
#line 2636
  if (tmp___17) {
#line 2637
    goto parse_dup_op_espace;
  }
#line 2643
  i = start + 2L;
  {
#line 2643
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2643
    if (! (i <= end)) {
#line 2643
      goto while_break___0;
    }
    {
#line 2645
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2646
    tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
    }
#line 2647
    if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2647
      tmp___18 = 1;
    } else
#line 2647
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2647
      tmp___18 = 1;
    } else {
#line 2647
      tmp___18 = 0;
    }
    {
#line 2647
    tmp___19 = __builtin_expect((long )tmp___18, 0L);
    }
#line 2647
    if (tmp___19) {
#line 2648
      goto parse_dup_op_espace;
    }
    {
#line 2650
    tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )10);
#line 2651
    tmp___20 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 2651
    if (tmp___20) {
#line 2652
      goto parse_dup_op_espace;
    }
#line 2643
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2655
  if (old_tree) {
    {
#line 2656
    tree = create_tree(dfa, old_tree, tree, (re_token_type_t )16);
    }
  }
#line 2658
  return (tree);
  parse_dup_op_espace: 
#line 2661
  *err = (reg_errcode_t )12;
#line 2662
  return ((bin_tree_t *)((void *)0));
}
}
#line 2675 "./regcomp.c"
static wint_t parse_byte(unsigned char b , re_charset_t *mbcset ) 
{ 
  wint_t tmp ;
  wint_t tmp___0 ;

  {
#line 2678
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 2678
    tmp___0 = (wint_t )b;
  } else {
    {
#line 2678
    tmp = btowc((int )b);
#line 2678
    tmp___0 = tmp;
    }
  }
#line 2678
  return (tmp___0);
}
}
#line 2689 "./regcomp.c"
static reg_errcode_t build_range_exp(reg_syntax_t const   syntax , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *range_alloc , bracket_elem_t const   *start_elem ,
                                     bracket_elem_t const   *end_elem ) 
{ 
  unsigned int start_ch ;
  unsigned int end_ch ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  wchar_t wc ;
  wint_t start_wc ;
  wint_t end_wc ;
  int tmp___5 ;
  int tmp___6 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  wchar_t *new_array_start ;
  wchar_t *new_array_end ;
  Idx new_nranges ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  Idx tmp___16 ;

  {
#line 2706
  if ((unsigned int const   )start_elem->type == 2U) {
#line 2706
    tmp = 1;
  } else
#line 2706
  if ((unsigned int const   )start_elem->type == 4U) {
#line 2706
    tmp = 1;
  } else
#line 2706
  if ((unsigned int const   )end_elem->type == 2U) {
#line 2706
    tmp = 1;
  } else
#line 2706
  if ((unsigned int const   )end_elem->type == 4U) {
#line 2706
    tmp = 1;
  } else {
#line 2706
    tmp = 0;
  }
  {
#line 2706
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 2706
  if (tmp___0) {
#line 2710
    return ((reg_errcode_t )11);
  }
#line 2714
  if ((unsigned int const   )start_elem->type == 3U) {
    {
#line 2714
    tmp___1 = strlen((char const   *)((char *)start_elem->opr.name));
    }
#line 2714
    if (tmp___1 > 1UL) {
#line 2714
      tmp___3 = 1;
    } else {
#line 2714
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2714
  if ((unsigned int const   )end_elem->type == 3U) {
    {
#line 2714
    tmp___2 = strlen((char const   *)((char *)end_elem->opr.name));
    }
#line 2714
    if (tmp___2 > 1UL) {
#line 2714
      tmp___3 = 1;
    } else {
#line 2714
      tmp___3 = 0;
    }
  } else {
#line 2714
    tmp___3 = 0;
  }
  {
#line 2714
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 2714
  if (tmp___4) {
#line 2718
    return ((reg_errcode_t )3);
  }
#line 2726
  if ((unsigned int const   )start_elem->type == 0U) {
#line 2726
    start_ch = (unsigned int )start_elem->opr.ch;
  } else {
#line 2726
    if ((unsigned int const   )start_elem->type == 3U) {
#line 2726
      tmp___5 = (int )*(start_elem->opr.name + 0);
    } else {
#line 2726
      tmp___5 = 0;
    }
#line 2726
    start_ch = (unsigned int )tmp___5;
  }
#line 2729
  if ((unsigned int const   )end_elem->type == 0U) {
#line 2729
    end_ch = (unsigned int )end_elem->opr.ch;
  } else {
#line 2729
    if ((unsigned int const   )end_elem->type == 3U) {
#line 2729
      tmp___6 = (int )*(end_elem->opr.name + 0);
    } else {
#line 2729
      tmp___6 = 0;
    }
#line 2729
    end_ch = (unsigned int )tmp___6;
  }
#line 2732
  if ((unsigned int const   )start_elem->type == 0U) {
    {
#line 2732
    tmp___7 = parse_byte((unsigned char )start_ch, mbcset);
#line 2732
    start_wc = tmp___7;
    }
  } else
#line 2732
  if ((unsigned int const   )start_elem->type == 3U) {
    {
#line 2732
    tmp___7 = parse_byte((unsigned char )start_ch, mbcset);
#line 2732
    start_wc = tmp___7;
    }
  } else {
#line 2732
    start_wc = (wint_t )start_elem->opr.wch;
  }
#line 2734
  if ((unsigned int const   )end_elem->type == 0U) {
    {
#line 2734
    tmp___8 = parse_byte((unsigned char )end_ch, mbcset);
#line 2734
    end_wc = tmp___8;
    }
  } else
#line 2734
  if ((unsigned int const   )end_elem->type == 3U) {
    {
#line 2734
    tmp___8 = parse_byte((unsigned char )end_ch, mbcset);
#line 2734
    end_wc = tmp___8;
    }
  } else {
#line 2734
    end_wc = (wint_t )end_elem->opr.wch;
  }
#line 2736
  if (start_wc == 4294967295U) {
#line 2737
    return ((reg_errcode_t )3);
  } else
#line 2736
  if (end_wc == 4294967295U) {
#line 2737
    return ((reg_errcode_t )3);
  } else {
#line 2738
    if (syntax & (unsigned long const   )((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2738
      if (start_wc > end_wc) {
#line 2738
        tmp___9 = 1;
      } else {
#line 2738
        tmp___9 = 0;
      }
    } else {
#line 2738
      tmp___9 = 0;
    }
    {
#line 2738
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 2738
    if (tmp___10) {
#line 2740
      return ((reg_errcode_t )11);
    }
  }
#line 2747
  if (mbcset) {
    {
#line 2750
    tmp___15 = __builtin_expect((long )(*range_alloc == mbcset->nranges), 0L);
    }
#line 2750
    if (tmp___15) {
      {
#line 2757
      new_nranges = 2L * mbcset->nranges + 1L;
#line 2760
      tmp___11 = realloc((void *)mbcset->range_starts, (unsigned long )new_nranges * sizeof(wchar_t ));
#line 2760
      new_array_start = (wchar_t *)tmp___11;
#line 2762
      tmp___12 = realloc((void *)mbcset->range_ends, (unsigned long )new_nranges * sizeof(wchar_t ));
#line 2762
      new_array_end = (wchar_t *)tmp___12;
      }
#line 2765
      if ((unsigned long )new_array_start == (unsigned long )((void *)0)) {
#line 2765
        tmp___13 = 1;
      } else
#line 2765
      if ((unsigned long )new_array_end == (unsigned long )((void *)0)) {
#line 2765
        tmp___13 = 1;
      } else {
#line 2765
        tmp___13 = 0;
      }
      {
#line 2765
      tmp___14 = __builtin_expect((long )tmp___13, 0L);
      }
#line 2765
      if (tmp___14) {
        {
#line 2768
        free((void *)new_array_start);
#line 2769
        free((void *)new_array_end);
        }
#line 2770
        return ((reg_errcode_t )12);
      }
#line 2773
      mbcset->range_starts = new_array_start;
#line 2774
      mbcset->range_ends = new_array_end;
#line 2775
      *range_alloc = new_nranges;
    }
#line 2778
    *(mbcset->range_starts + mbcset->nranges) = (wchar_t )start_wc;
#line 2779
    tmp___16 = mbcset->nranges;
#line 2779
    (mbcset->nranges) ++;
#line 2779
    *(mbcset->range_ends + tmp___16) = (wchar_t )end_wc;
  }
#line 2783
  wc = 0;
  {
#line 2783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2783
    if (! (wc < 256)) {
#line 2783
      goto while_break;
    }
#line 2785
    if (start_wc <= (wint_t )wc) {
#line 2785
      if ((wint_t )wc <= end_wc) {
        {
#line 2786
        bitset_set(sbcset, (Idx )wc);
        }
      }
    }
#line 2783
    wc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2806
  return ((reg_errcode_t )0);
}
}
#line 2817 "./regcomp.c"
static reg_errcode_t build_collating_symbol(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                            Idx *coll_sym_alloc , unsigned char const   *name ) 
{ 
  size_t name_len ;
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 2825
  tmp = strlen((char const   *)name);
#line 2825
  name_len = tmp;
#line 2826
  tmp___0 = __builtin_expect((long )(name_len != 1UL), 0L);
  }
#line 2826
  if (tmp___0) {
#line 2827
    return ((reg_errcode_t )3);
  } else {
    {
#line 2830
    bitset_set(sbcset, (Idx )*(name + 0));
    }
#line 2831
    return ((reg_errcode_t )0);
  }
}
}
#line 2839 "./regcomp.c"
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx coll_sym_alloc ;
  Idx range_alloc ;
  Idx mbchar_alloc ;
  Idx equiv_class_alloc ;
  Idx char_class_alloc ;
  _Bool non_match ;
  bin_tree_t *work_tree ;
  int token_len ;
  _Bool first_round ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  _Bool is_range_exp ;
  re_token_t token2 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  re_charset_t *tmp___9 ;
  long tmp___10 ;
  wchar_t *new_mbchars ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  Idx tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  bin_tree_t *mbc_tree ;
  int sbc_idx ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
  {
#line 3098
  coll_sym_alloc = (Idx )0;
#line 3098
  range_alloc = (Idx )0;
#line 3098
  mbchar_alloc = (Idx )0;
#line 3099
  equiv_class_alloc = (Idx )0;
#line 3099
  char_class_alloc = (Idx )0;
#line 3101
  non_match = (_Bool)0;
#line 3104
  first_round = (_Bool)1;
#line 3122
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3122
  sbcset = (re_bitset_ptr_t )tmp;
#line 3124
  tmp___0 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3124
  mbcset = (re_charset_t *)tmp___0;
  }
#line 3127
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3127
    tmp___1 = 1;
  } else
#line 3127
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3127
    tmp___1 = 1;
  } else {
#line 3127
    tmp___1 = 0;
  }
  {
#line 3127
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 3127
  if (tmp___2) {
    {
#line 3132
    free((void *)sbcset);
#line 3134
    free((void *)mbcset);
#line 3136
    *err = (reg_errcode_t )12;
    }
#line 3137
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3140
  token_len = peek_token_bracket(token, regexp, syntax);
#line 3141
  tmp___3 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
  }
#line 3141
  if (tmp___3) {
#line 3143
    *err = (reg_errcode_t )2;
#line 3144
    goto parse_bracket_exp_free_return;
  }
#line 3146
  if ((unsigned int )token->type == 25U) {
#line 3149
    mbcset->non_match = 1U;
#line 3151
    non_match = (_Bool)1;
#line 3152
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 3153
      bitset_set((bitset_word_t *)sbcset, (Idx )'\n');
      }
    }
    {
#line 3154
    regexp->cur_idx += (Idx )token_len;
#line 3155
    token_len = peek_token_bracket(token, regexp, syntax);
#line 3156
    tmp___4 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3156
    if (tmp___4) {
#line 3158
      *err = (reg_errcode_t )2;
#line 3159
      goto parse_bracket_exp_free_return;
    }
  }
#line 3164
  if ((unsigned int )token->type == 21U) {
#line 3165
    token->type = (re_token_type_t )1;
  }
  {
#line 3167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3173
    token_len2 = 0;
#line 3174
    is_range_exp = (_Bool)0;
#line 3177
    start_elem.opr.name = start_name_buf;
#line 3178
    start_elem.type = (bracket_elem_type )3;
#line 3179
    ret = parse_bracket_element(& start_elem, regexp, token, token_len, dfa, syntax,
                                first_round);
#line 3181
    tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 3181
    if (tmp___5) {
#line 3183
      *err = ret;
#line 3184
      goto parse_bracket_exp_free_return;
    }
    {
#line 3186
    first_round = (_Bool)0;
#line 3189
    token_len = peek_token_bracket(token, regexp, syntax);
    }
#line 3192
    if ((unsigned int )start_elem.type != 4U) {
#line 3192
      if ((unsigned int )start_elem.type != 2U) {
        {
#line 3194
        tmp___6 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
        }
#line 3194
        if (tmp___6) {
#line 3196
          *err = (reg_errcode_t )7;
#line 3197
          goto parse_bracket_exp_free_return;
        }
#line 3199
        if ((unsigned int )token->type == 22U) {
          {
#line 3201
          regexp->cur_idx += (Idx )token_len;
#line 3202
          token_len2 = peek_token_bracket(& token2, regexp, syntax);
#line 3203
          tmp___7 = __builtin_expect((long )((unsigned int )token2.type == 2U), 0L);
          }
#line 3203
          if (tmp___7) {
#line 3205
            *err = (reg_errcode_t )7;
#line 3206
            goto parse_bracket_exp_free_return;
          }
#line 3208
          if ((unsigned int )token2.type == 21U) {
#line 3211
            regexp->cur_idx += (Idx )(- token_len);
#line 3212
            token->type = (re_token_type_t )1;
          } else {
#line 3215
            is_range_exp = (_Bool)1;
          }
        }
      }
    }
#line 3219
    if ((int )is_range_exp == 1) {
      {
#line 3221
      end_elem.opr.name = end_name_buf;
#line 3222
      end_elem.type = (bracket_elem_type )3;
#line 3223
      ret = parse_bracket_element(& end_elem, regexp, & token2, token_len2, dfa, syntax,
                                  (_Bool)1);
#line 3225
      tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 3225
      if (tmp___8) {
#line 3227
        *err = ret;
#line 3228
        goto parse_bracket_exp_free_return;
      }
      {
#line 3231
      token_len = peek_token_bracket(token, regexp, syntax);
      }
#line 3238
      if (dfa->mb_cur_max > 1) {
#line 3238
        tmp___9 = mbcset;
      } else {
#line 3238
        tmp___9 = (re_charset_t *)((void *)0);
      }
      {
#line 3238
      *err = build_range_exp((reg_syntax_t const   )syntax, (bitset_word_t *)sbcset,
                             tmp___9, & range_alloc, (bracket_elem_t const   *)(& start_elem),
                             (bracket_elem_t const   *)(& end_elem));
#line 3245
      tmp___10 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3245
      if (tmp___10) {
#line 3246
        goto parse_bracket_exp_free_return;
      }
    } else {
      {
#line 3252
      if ((unsigned int )start_elem.type == 0U) {
#line 3252
        goto case_0;
      }
#line 3256
      if ((unsigned int )start_elem.type == 1U) {
#line 3256
        goto case_1;
      }
#line 3274
      if ((unsigned int )start_elem.type == 2U) {
#line 3274
        goto case_2;
      }
#line 3283
      if ((unsigned int )start_elem.type == 3U) {
#line 3283
        goto case_3;
      }
#line 3292
      if ((unsigned int )start_elem.type == 4U) {
#line 3292
        goto case_4;
      }
#line 3302
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 3253
      bitset_set((bitset_word_t *)sbcset, (Idx )start_elem.opr.ch);
      }
#line 3254
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 3258
      tmp___13 = __builtin_expect((long )(mbchar_alloc == mbcset->nmbchars), 0L);
      }
#line 3258
      if (tmp___13) {
        {
#line 3263
        mbchar_alloc = 2L * mbcset->nmbchars + 1L;
#line 3265
        tmp___11 = realloc((void *)mbcset->mbchars, (unsigned long )mbchar_alloc * sizeof(wchar_t ));
#line 3265
        new_mbchars = (wchar_t *)tmp___11;
#line 3267
        tmp___12 = __builtin_expect((long )((unsigned long )new_mbchars == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3267
        if (tmp___12) {
#line 3268
          goto parse_bracket_exp_espace;
        }
#line 3269
        mbcset->mbchars = new_mbchars;
      }
#line 3271
      tmp___14 = mbcset->nmbchars;
#line 3271
      (mbcset->nmbchars) ++;
#line 3271
      *(mbcset->mbchars + tmp___14) = start_elem.opr.wch;
#line 3272
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 3275
      *err = build_equiv_class((bitset_word_t *)sbcset, mbcset, & equiv_class_alloc,
                               (unsigned char const   *)start_elem.opr.name);
#line 3280
      tmp___15 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3280
      if (tmp___15) {
#line 3281
        goto parse_bracket_exp_free_return;
      }
#line 3282
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 3284
      *err = build_collating_symbol((bitset_word_t *)sbcset, mbcset, & coll_sym_alloc,
                                    (unsigned char const   *)start_elem.opr.name);
#line 3289
      tmp___16 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3289
      if (tmp___16) {
#line 3290
        goto parse_bracket_exp_free_return;
      }
#line 3291
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 3293
      *err = build_charclass(regexp->trans, (bitset_word_t *)sbcset, mbcset, & char_class_alloc,
                             (char const   *)start_elem.opr.name, syntax);
#line 3299
      tmp___17 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 3299
      if (tmp___17) {
#line 3300
        goto parse_bracket_exp_free_return;
      }
#line 3301
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3303
      __builtin_unreachable();
      }
#line 3304
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 3307
    tmp___18 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3307
    if (tmp___18) {
#line 3309
      *err = (reg_errcode_t )7;
#line 3310
      goto parse_bracket_exp_free_return;
    }
#line 3312
    if ((unsigned int )token->type == 21U) {
#line 3313
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3316
  regexp->cur_idx += (Idx )token_len;
#line 3319
  if (non_match) {
    {
#line 3320
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3324
  if (dfa->mb_cur_max > 1) {
    {
#line 3325
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa->sb_char);
    }
  }
#line 3327
  if (mbcset->nmbchars) {
#line 3327
    goto _L___1;
  } else
#line 3327
  if (mbcset->ncoll_syms) {
#line 3327
    goto _L___1;
  } else
#line 3327
  if (mbcset->nequiv_classes) {
#line 3327
    goto _L___1;
  } else
#line 3327
  if (mbcset->nranges) {
#line 3327
    goto _L___1;
  } else
#line 3327
  if (dfa->mb_cur_max > 1) {
#line 3327
    if (mbcset->nchar_classes) {
#line 3327
      goto _L___1;
    } else
#line 3327
    if (mbcset->non_match) {
      _L___1: /* CIL Label */ 
      {
#line 3334
      dfa->has_mb_node = 1U;
#line 3335
      br_token.type = (re_token_type_t )6;
#line 3336
      br_token.opr.mbcset = mbcset;
#line 3337
      mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                   (re_token_t const   *)(& br_token));
#line 3338
      tmp___19 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                                  0L);
      }
#line 3338
      if (tmp___19) {
#line 3339
        goto parse_bracket_exp_espace;
      }
#line 3340
      sbc_idx = 0;
      {
#line 3340
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3340
        if (! (sbc_idx < 4)) {
#line 3340
          goto while_break___0;
        }
#line 3341
        if (*(sbcset + sbc_idx)) {
#line 3342
          goto while_break___0;
        }
#line 3340
        sbc_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3345
      if (sbc_idx < 4) {
        {
#line 3348
        br_token.type = (re_token_type_t )3;
#line 3349
        br_token.opr.sbcset = sbcset;
#line 3350
        work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                      (re_token_t const   *)(& br_token));
#line 3351
        tmp___20 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3351
        if (tmp___20) {
#line 3352
          goto parse_bracket_exp_espace;
        }
        {
#line 3355
        work_tree = create_tree(dfa, work_tree, mbc_tree, (re_token_type_t )10);
#line 3356
        tmp___21 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
        }
#line 3356
        if (tmp___21) {
#line 3357
          goto parse_bracket_exp_espace;
        }
      } else {
        {
#line 3361
        free((void *)sbcset);
#line 3362
        work_tree = mbc_tree;
        }
      }
    } else {
#line 3327
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 3369
    free_charset(mbcset);
#line 3372
    br_token.type = (re_token_type_t )3;
#line 3373
    br_token.opr.sbcset = sbcset;
#line 3374
    work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)(& br_token));
#line 3375
    tmp___22 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                0L);
    }
#line 3375
    if (tmp___22) {
#line 3376
      goto parse_bracket_exp_espace;
    }
  }
#line 3378
  return (work_tree);
  parse_bracket_exp_espace: 
#line 3381
  *err = (reg_errcode_t )12;
  parse_bracket_exp_free_return: 
  {
#line 3383
  free((void *)sbcset);
#line 3385
  free_charset(mbcset);
  }
#line 3387
  return ((bin_tree_t *)((void *)0));
}
}
#line 3392 "./regcomp.c"
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) 
{ 
  int cur_char_size ;
  int __attribute__((__pure__))  tmp ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  re_token_t token2 ;
  long tmp___2 ;

  {
  {
#line 3399
  tmp = re_string_char_size_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3399
  cur_char_size = (int )tmp;
  }
#line 3400
  if (cur_char_size > 1) {
    {
#line 3402
    elem->type = (bracket_elem_type )1;
#line 3403
    tmp___0 = re_string_wchar_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3403
    elem->opr.wch = (wchar_t )tmp___0;
#line 3404
    regexp->cur_idx += (Idx )cur_char_size;
    }
#line 3405
    return ((reg_errcode_t )0);
  }
#line 3408
  regexp->cur_idx += (Idx )token_len;
#line 3409
  if ((unsigned int )token->type == 26U) {
    {
#line 3411
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
    }
#line 3411
    return (tmp___1);
  } else
#line 3409
  if ((unsigned int )token->type == 30U) {
    {
#line 3411
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
    }
#line 3411
    return (tmp___1);
  } else
#line 3409
  if ((unsigned int )token->type == 28U) {
    {
#line 3411
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
    }
#line 3411
    return (tmp___1);
  }
  {
#line 3412
  tmp___2 = __builtin_expect((long )((unsigned int )token->type == 22U), 0L);
  }
#line 3412
  if (tmp___2) {
#line 3412
    if (! accept_hyphen) {
      {
#line 3417
      peek_token_bracket(& token2, regexp, syntax);
      }
#line 3418
      if ((unsigned int )token2.type != 21U) {
#line 3421
        return ((reg_errcode_t )11);
      }
    }
  }
#line 3423
  elem->type = (bracket_elem_type )0;
#line 3424
  elem->opr.ch = token->opr.c;
#line 3425
  return ((reg_errcode_t )0);
}
}
#line 3432 "./regcomp.c"
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) 
{ 
  unsigned char ch ;
  unsigned char delim ;
  int i ;
  Idx tmp ;

  {
#line 3436
  delim = token->opr.c;
#line 3437
  i = 0;
#line 3438
  if (regexp->stop <= regexp->cur_idx) {
#line 3439
    return ((reg_errcode_t )7);
  }
  {
#line 3440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3442
    if (i >= 32) {
#line 3443
      return ((reg_errcode_t )7);
    }
#line 3444
    if ((unsigned int )token->type == 30U) {
      {
#line 3445
      ch = re_string_fetch_byte_case(regexp);
      }
    } else {
#line 3447
      tmp = regexp->cur_idx;
#line 3447
      (regexp->cur_idx) ++;
#line 3447
      ch = *(regexp->mbs + tmp);
    }
#line 3448
    if (regexp->stop <= regexp->cur_idx) {
#line 3449
      return ((reg_errcode_t )7);
    }
#line 3450
    if ((int )ch == (int )delim) {
#line 3450
      if ((int )*(regexp->mbs + regexp->cur_idx) == 93) {
#line 3451
        goto while_break;
      }
    }
#line 3452
    *(elem->opr.name + i) = ch;
#line 3440
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3454
  (regexp->cur_idx) ++;
#line 3455
  *(elem->opr.name + i) = (unsigned char )'\000';
  {
#line 3458
  if ((unsigned int )token->type == 26U) {
#line 3458
    goto case_26;
  }
#line 3461
  if ((unsigned int )token->type == 28U) {
#line 3461
    goto case_28;
  }
#line 3464
  if ((unsigned int )token->type == 30U) {
#line 3464
    goto case_30;
  }
#line 3467
  goto switch_default;
  case_26: /* CIL Label */ 
#line 3459
  elem->type = (bracket_elem_type )3;
#line 3460
  goto switch_break;
  case_28: /* CIL Label */ 
#line 3462
  elem->type = (bracket_elem_type )2;
#line 3463
  goto switch_break;
  case_30: /* CIL Label */ 
#line 3465
  elem->type = (bracket_elem_type )4;
#line 3466
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3468
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3470
  return ((reg_errcode_t )0);
}
}
#line 3479 "./regcomp.c"
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                       Idx *equiv_class_alloc , unsigned char const   *name ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  {
#line 3551
  tmp = strlen((char const   *)name);
#line 3551
  tmp___0 = __builtin_expect((long )(tmp != 1UL), 0L);
  }
#line 3551
  if (tmp___0) {
#line 3552
    return ((reg_errcode_t )3);
  }
  {
#line 3553
  bitset_set(sbcset, (Idx )*name);
  }
#line 3555
  return ((reg_errcode_t )0);
}
}
#line 3564 "./regcomp.c"
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     char const   *class_name , reg_syntax_t syntax ) 
{ 
  int i ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  Idx new_char_class_alloc ;
  wctype_t *new_char_classes ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  long tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  long tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  long tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  long tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  long tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  long tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  long tmp___25 ;
  unsigned short const   **tmp___26 ;
  unsigned short const   **tmp___27 ;
  long tmp___28 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  long tmp___31 ;
  unsigned short const   **tmp___32 ;
  unsigned short const   **tmp___33 ;
  long tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  long tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  long tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;

  {
#line 3575
  name = class_name;
#line 3579
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
#line 3579
    tmp = strcmp(name, "upper");
    }
#line 3579
    if (tmp == 0) {
#line 3581
      name = "alpha";
    } else {
      {
#line 3579
      tmp___0 = strcmp(name, "lower");
      }
#line 3579
      if (tmp___0 == 0) {
#line 3581
        name = "alpha";
      }
    }
  }
  {
#line 3585
  tmp___3 = __builtin_expect((long )(*char_class_alloc == mbcset->nchar_classes),
                             0L);
  }
#line 3585
  if (tmp___3) {
    {
#line 3589
    new_char_class_alloc = 2L * mbcset->nchar_classes + 1L;
#line 3591
    tmp___1 = realloc((void *)mbcset->char_classes, (unsigned long )new_char_class_alloc * sizeof(wctype_t ));
#line 3591
    new_char_classes = (wctype_t *)tmp___1;
#line 3593
    tmp___2 = __builtin_expect((long )((unsigned long )new_char_classes == (unsigned long )((void *)0)),
                               0L);
    }
#line 3593
    if (tmp___2) {
#line 3594
      return ((reg_errcode_t )12);
    }
#line 3595
    mbcset->char_classes = new_char_classes;
#line 3596
    *char_class_alloc = new_char_class_alloc;
  }
  {
#line 3598
  tmp___4 = mbcset->nchar_classes;
#line 3598
  (mbcset->nchar_classes) ++;
#line 3598
  *(mbcset->char_classes + tmp___4) = wctype(name);
#line 3617
  tmp___52 = strcmp(name, "alnum");
  }
#line 3617
  if (tmp___52 == 0) {
    {
#line 3618
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 3618
      tmp___7 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                 0L);
      }
#line 3618
      if (tmp___7) {
#line 3618
        i = 0;
        {
#line 3618
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3618
          if (! (i < 256)) {
#line 3618
            goto while_break___0;
          }
          {
#line 3618
          tmp___5 = __ctype_b_loc();
          }
#line 3618
          if ((int const   )*(*tmp___5 + i) & 8) {
            {
#line 3618
            bitset_set(sbcset, (Idx )*(trans + i));
            }
          }
#line 3618
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
#line 3618
        i = 0;
        {
#line 3618
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3618
          if (! (i < 256)) {
#line 3618
            goto while_break___1;
          }
          {
#line 3618
          tmp___6 = __ctype_b_loc();
          }
#line 3618
          if ((int const   )*(*tmp___6 + i) & 8) {
            {
#line 3618
            bitset_set(sbcset, (Idx )i);
            }
          }
#line 3618
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 3618
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 3619
    tmp___51 = strcmp(name, "cntrl");
    }
#line 3619
    if (tmp___51 == 0) {
      {
#line 3620
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 3620
        tmp___10 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                    0L);
        }
#line 3620
        if (tmp___10) {
#line 3620
          i = 0;
          {
#line 3620
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3620
            if (! (i < 256)) {
#line 3620
              goto while_break___3;
            }
            {
#line 3620
            tmp___8 = __ctype_b_loc();
            }
#line 3620
            if ((int const   )*(*tmp___8 + i) & 2) {
              {
#line 3620
              bitset_set(sbcset, (Idx )*(trans + i));
              }
            }
#line 3620
            i ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        } else {
#line 3620
          i = 0;
          {
#line 3620
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3620
            if (! (i < 256)) {
#line 3620
              goto while_break___4;
            }
            {
#line 3620
            tmp___9 = __ctype_b_loc();
            }
#line 3620
            if ((int const   )*(*tmp___9 + i) & 2) {
              {
#line 3620
              bitset_set(sbcset, (Idx )i);
              }
            }
#line 3620
            i ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 3620
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 3621
      tmp___50 = strcmp(name, "lower");
      }
#line 3621
      if (tmp___50 == 0) {
        {
#line 3622
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 3622
          tmp___13 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                      0L);
          }
#line 3622
          if (tmp___13) {
#line 3622
            i = 0;
            {
#line 3622
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 3622
              if (! (i < 256)) {
#line 3622
                goto while_break___6;
              }
              {
#line 3622
              tmp___11 = __ctype_b_loc();
              }
#line 3622
              if ((int const   )*(*tmp___11 + i) & 512) {
                {
#line 3622
                bitset_set(sbcset, (Idx )*(trans + i));
                }
              }
#line 3622
              i ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          } else {
#line 3622
            i = 0;
            {
#line 3622
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 3622
              if (! (i < 256)) {
#line 3622
                goto while_break___7;
              }
              {
#line 3622
              tmp___12 = __ctype_b_loc();
              }
#line 3622
              if ((int const   )*(*tmp___12 + i) & 512) {
                {
#line 3622
                bitset_set(sbcset, (Idx )i);
                }
              }
#line 3622
              i ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          }
#line 3622
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      } else {
        {
#line 3623
        tmp___49 = strcmp(name, "space");
        }
#line 3623
        if (tmp___49 == 0) {
          {
#line 3624
          while (1) {
            while_continue___8: /* CIL Label */ ;
            {
#line 3624
            tmp___16 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                        0L);
            }
#line 3624
            if (tmp___16) {
#line 3624
              i = 0;
              {
#line 3624
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 3624
                if (! (i < 256)) {
#line 3624
                  goto while_break___9;
                }
                {
#line 3624
                tmp___14 = __ctype_b_loc();
                }
#line 3624
                if ((int const   )*(*tmp___14 + i) & 8192) {
                  {
#line 3624
                  bitset_set(sbcset, (Idx )*(trans + i));
                  }
                }
#line 3624
                i ++;
              }
              while_break___9: /* CIL Label */ ;
              }
            } else {
#line 3624
              i = 0;
              {
#line 3624
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 3624
                if (! (i < 256)) {
#line 3624
                  goto while_break___10;
                }
                {
#line 3624
                tmp___15 = __ctype_b_loc();
                }
#line 3624
                if ((int const   )*(*tmp___15 + i) & 8192) {
                  {
#line 3624
                  bitset_set(sbcset, (Idx )i);
                  }
                }
#line 3624
                i ++;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
#line 3624
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
        } else {
          {
#line 3625
          tmp___48 = strcmp(name, "alpha");
          }
#line 3625
          if (tmp___48 == 0) {
            {
#line 3626
            while (1) {
              while_continue___11: /* CIL Label */ ;
              {
#line 3626
              tmp___19 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                          0L);
              }
#line 3626
              if (tmp___19) {
#line 3626
                i = 0;
                {
#line 3626
                while (1) {
                  while_continue___12: /* CIL Label */ ;
#line 3626
                  if (! (i < 256)) {
#line 3626
                    goto while_break___12;
                  }
                  {
#line 3626
                  tmp___17 = __ctype_b_loc();
                  }
#line 3626
                  if ((int const   )*(*tmp___17 + i) & 1024) {
                    {
#line 3626
                    bitset_set(sbcset, (Idx )*(trans + i));
                    }
                  }
#line 3626
                  i ++;
                }
                while_break___12: /* CIL Label */ ;
                }
              } else {
#line 3626
                i = 0;
                {
#line 3626
                while (1) {
                  while_continue___13: /* CIL Label */ ;
#line 3626
                  if (! (i < 256)) {
#line 3626
                    goto while_break___13;
                  }
                  {
#line 3626
                  tmp___18 = __ctype_b_loc();
                  }
#line 3626
                  if ((int const   )*(*tmp___18 + i) & 1024) {
                    {
#line 3626
                    bitset_set(sbcset, (Idx )i);
                    }
                  }
#line 3626
                  i ++;
                }
                while_break___13: /* CIL Label */ ;
                }
              }
#line 3626
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          } else {
            {
#line 3627
            tmp___47 = strcmp(name, "digit");
            }
#line 3627
            if (tmp___47 == 0) {
              {
#line 3628
              while (1) {
                while_continue___14: /* CIL Label */ ;
                {
#line 3628
                tmp___22 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                            0L);
                }
#line 3628
                if (tmp___22) {
#line 3628
                  i = 0;
                  {
#line 3628
                  while (1) {
                    while_continue___15: /* CIL Label */ ;
#line 3628
                    if (! (i < 256)) {
#line 3628
                      goto while_break___15;
                    }
                    {
#line 3628
                    tmp___20 = __ctype_b_loc();
                    }
#line 3628
                    if ((int const   )*(*tmp___20 + i) & 2048) {
                      {
#line 3628
                      bitset_set(sbcset, (Idx )*(trans + i));
                      }
                    }
#line 3628
                    i ++;
                  }
                  while_break___15: /* CIL Label */ ;
                  }
                } else {
#line 3628
                  i = 0;
                  {
#line 3628
                  while (1) {
                    while_continue___16: /* CIL Label */ ;
#line 3628
                    if (! (i < 256)) {
#line 3628
                      goto while_break___16;
                    }
                    {
#line 3628
                    tmp___21 = __ctype_b_loc();
                    }
#line 3628
                    if ((int const   )*(*tmp___21 + i) & 2048) {
                      {
#line 3628
                      bitset_set(sbcset, (Idx )i);
                      }
                    }
#line 3628
                    i ++;
                  }
                  while_break___16: /* CIL Label */ ;
                  }
                }
#line 3628
                goto while_break___14;
              }
              while_break___14: /* CIL Label */ ;
              }
            } else {
              {
#line 3629
              tmp___46 = strcmp(name, "print");
              }
#line 3629
              if (tmp___46 == 0) {
                {
#line 3630
                while (1) {
                  while_continue___17: /* CIL Label */ ;
                  {
#line 3630
                  tmp___25 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                              0L);
                  }
#line 3630
                  if (tmp___25) {
#line 3630
                    i = 0;
                    {
#line 3630
                    while (1) {
                      while_continue___18: /* CIL Label */ ;
#line 3630
                      if (! (i < 256)) {
#line 3630
                        goto while_break___18;
                      }
                      {
#line 3630
                      tmp___23 = __ctype_b_loc();
                      }
#line 3630
                      if ((int const   )*(*tmp___23 + i) & 16384) {
                        {
#line 3630
                        bitset_set(sbcset, (Idx )*(trans + i));
                        }
                      }
#line 3630
                      i ++;
                    }
                    while_break___18: /* CIL Label */ ;
                    }
                  } else {
#line 3630
                    i = 0;
                    {
#line 3630
                    while (1) {
                      while_continue___19: /* CIL Label */ ;
#line 3630
                      if (! (i < 256)) {
#line 3630
                        goto while_break___19;
                      }
                      {
#line 3630
                      tmp___24 = __ctype_b_loc();
                      }
#line 3630
                      if ((int const   )*(*tmp___24 + i) & 16384) {
                        {
#line 3630
                        bitset_set(sbcset, (Idx )i);
                        }
                      }
#line 3630
                      i ++;
                    }
                    while_break___19: /* CIL Label */ ;
                    }
                  }
#line 3630
                  goto while_break___17;
                }
                while_break___17: /* CIL Label */ ;
                }
              } else {
                {
#line 3631
                tmp___45 = strcmp(name, "upper");
                }
#line 3631
                if (tmp___45 == 0) {
                  {
#line 3632
                  while (1) {
                    while_continue___20: /* CIL Label */ ;
                    {
#line 3632
                    tmp___28 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                0L);
                    }
#line 3632
                    if (tmp___28) {
#line 3632
                      i = 0;
                      {
#line 3632
                      while (1) {
                        while_continue___21: /* CIL Label */ ;
#line 3632
                        if (! (i < 256)) {
#line 3632
                          goto while_break___21;
                        }
                        {
#line 3632
                        tmp___26 = __ctype_b_loc();
                        }
#line 3632
                        if ((int const   )*(*tmp___26 + i) & 256) {
                          {
#line 3632
                          bitset_set(sbcset, (Idx )*(trans + i));
                          }
                        }
#line 3632
                        i ++;
                      }
                      while_break___21: /* CIL Label */ ;
                      }
                    } else {
#line 3632
                      i = 0;
                      {
#line 3632
                      while (1) {
                        while_continue___22: /* CIL Label */ ;
#line 3632
                        if (! (i < 256)) {
#line 3632
                          goto while_break___22;
                        }
                        {
#line 3632
                        tmp___27 = __ctype_b_loc();
                        }
#line 3632
                        if ((int const   )*(*tmp___27 + i) & 256) {
                          {
#line 3632
                          bitset_set(sbcset, (Idx )i);
                          }
                        }
#line 3632
                        i ++;
                      }
                      while_break___22: /* CIL Label */ ;
                      }
                    }
#line 3632
                    goto while_break___20;
                  }
                  while_break___20: /* CIL Label */ ;
                  }
                } else {
                  {
#line 3633
                  tmp___44 = strcmp(name, "blank");
                  }
#line 3633
                  if (tmp___44 == 0) {
                    {
#line 3634
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
                      {
#line 3634
                      tmp___31 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                  0L);
                      }
#line 3634
                      if (tmp___31) {
#line 3634
                        i = 0;
                        {
#line 3634
                        while (1) {
                          while_continue___24: /* CIL Label */ ;
#line 3634
                          if (! (i < 256)) {
#line 3634
                            goto while_break___24;
                          }
                          {
#line 3634
                          tmp___29 = __ctype_b_loc();
                          }
#line 3634
                          if ((int const   )*(*tmp___29 + i) & 1) {
                            {
#line 3634
                            bitset_set(sbcset, (Idx )*(trans + i));
                            }
                          }
#line 3634
                          i ++;
                        }
                        while_break___24: /* CIL Label */ ;
                        }
                      } else {
#line 3634
                        i = 0;
                        {
#line 3634
                        while (1) {
                          while_continue___25: /* CIL Label */ ;
#line 3634
                          if (! (i < 256)) {
#line 3634
                            goto while_break___25;
                          }
                          {
#line 3634
                          tmp___30 = __ctype_b_loc();
                          }
#line 3634
                          if ((int const   )*(*tmp___30 + i) & 1) {
                            {
#line 3634
                            bitset_set(sbcset, (Idx )i);
                            }
                          }
#line 3634
                          i ++;
                        }
                        while_break___25: /* CIL Label */ ;
                        }
                      }
#line 3634
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                  } else {
                    {
#line 3635
                    tmp___43 = strcmp(name, "graph");
                    }
#line 3635
                    if (tmp___43 == 0) {
                      {
#line 3636
                      while (1) {
                        while_continue___26: /* CIL Label */ ;
                        {
#line 3636
                        tmp___34 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                    0L);
                        }
#line 3636
                        if (tmp___34) {
#line 3636
                          i = 0;
                          {
#line 3636
                          while (1) {
                            while_continue___27: /* CIL Label */ ;
#line 3636
                            if (! (i < 256)) {
#line 3636
                              goto while_break___27;
                            }
                            {
#line 3636
                            tmp___32 = __ctype_b_loc();
                            }
#line 3636
                            if ((int const   )*(*tmp___32 + i) & 32768) {
                              {
#line 3636
                              bitset_set(sbcset, (Idx )*(trans + i));
                              }
                            }
#line 3636
                            i ++;
                          }
                          while_break___27: /* CIL Label */ ;
                          }
                        } else {
#line 3636
                          i = 0;
                          {
#line 3636
                          while (1) {
                            while_continue___28: /* CIL Label */ ;
#line 3636
                            if (! (i < 256)) {
#line 3636
                              goto while_break___28;
                            }
                            {
#line 3636
                            tmp___33 = __ctype_b_loc();
                            }
#line 3636
                            if ((int const   )*(*tmp___33 + i) & 32768) {
                              {
#line 3636
                              bitset_set(sbcset, (Idx )i);
                              }
                            }
#line 3636
                            i ++;
                          }
                          while_break___28: /* CIL Label */ ;
                          }
                        }
#line 3636
                        goto while_break___26;
                      }
                      while_break___26: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 3637
                      tmp___42 = strcmp(name, "punct");
                      }
#line 3637
                      if (tmp___42 == 0) {
                        {
#line 3638
                        while (1) {
                          while_continue___29: /* CIL Label */ ;
                          {
#line 3638
                          tmp___37 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                      0L);
                          }
#line 3638
                          if (tmp___37) {
#line 3638
                            i = 0;
                            {
#line 3638
                            while (1) {
                              while_continue___30: /* CIL Label */ ;
#line 3638
                              if (! (i < 256)) {
#line 3638
                                goto while_break___30;
                              }
                              {
#line 3638
                              tmp___35 = __ctype_b_loc();
                              }
#line 3638
                              if ((int const   )*(*tmp___35 + i) & 4) {
                                {
#line 3638
                                bitset_set(sbcset, (Idx )*(trans + i));
                                }
                              }
#line 3638
                              i ++;
                            }
                            while_break___30: /* CIL Label */ ;
                            }
                          } else {
#line 3638
                            i = 0;
                            {
#line 3638
                            while (1) {
                              while_continue___31: /* CIL Label */ ;
#line 3638
                              if (! (i < 256)) {
#line 3638
                                goto while_break___31;
                              }
                              {
#line 3638
                              tmp___36 = __ctype_b_loc();
                              }
#line 3638
                              if ((int const   )*(*tmp___36 + i) & 4) {
                                {
#line 3638
                                bitset_set(sbcset, (Idx )i);
                                }
                              }
#line 3638
                              i ++;
                            }
                            while_break___31: /* CIL Label */ ;
                            }
                          }
#line 3638
                          goto while_break___29;
                        }
                        while_break___29: /* CIL Label */ ;
                        }
                      } else {
                        {
#line 3639
                        tmp___41 = strcmp(name, "xdigit");
                        }
#line 3639
                        if (tmp___41 == 0) {
                          {
#line 3640
                          while (1) {
                            while_continue___32: /* CIL Label */ ;
                            {
#line 3640
                            tmp___40 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                        0L);
                            }
#line 3640
                            if (tmp___40) {
#line 3640
                              i = 0;
                              {
#line 3640
                              while (1) {
                                while_continue___33: /* CIL Label */ ;
#line 3640
                                if (! (i < 256)) {
#line 3640
                                  goto while_break___33;
                                }
                                {
#line 3640
                                tmp___38 = __ctype_b_loc();
                                }
#line 3640
                                if ((int const   )*(*tmp___38 + i) & 4096) {
                                  {
#line 3640
                                  bitset_set(sbcset, (Idx )*(trans + i));
                                  }
                                }
#line 3640
                                i ++;
                              }
                              while_break___33: /* CIL Label */ ;
                              }
                            } else {
#line 3640
                              i = 0;
                              {
#line 3640
                              while (1) {
                                while_continue___34: /* CIL Label */ ;
#line 3640
                                if (! (i < 256)) {
#line 3640
                                  goto while_break___34;
                                }
                                {
#line 3640
                                tmp___39 = __ctype_b_loc();
                                }
#line 3640
                                if ((int const   )*(*tmp___39 + i) & 4096) {
                                  {
#line 3640
                                  bitset_set(sbcset, (Idx )i);
                                  }
                                }
#line 3640
                                i ++;
                              }
                              while_break___34: /* CIL Label */ ;
                              }
                            }
#line 3640
                            goto while_break___32;
                          }
                          while_break___32: /* CIL Label */ ;
                          }
                        } else {
#line 3642
                          return ((reg_errcode_t )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3644
  return ((reg_errcode_t )0);
}
}
#line 3647 "./regcomp.c"
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , char const   *class_name ,
                                      char const   *extra , _Bool non_match , reg_errcode_t *err ) 
{ 
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx alloc ;
  reg_errcode_t ret ;
  bin_tree_t *tree ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  re_token_t br_token ;
  long tmp___4 ;
  bin_tree_t *mbc_tree ;
  long tmp___5 ;
  long tmp___6 ;

  {
  {
#line 3656
  alloc = (Idx )0;
#line 3661
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3661
  sbcset = (re_bitset_ptr_t )tmp;
#line 3662
  tmp___0 = __builtin_expect((long )((unsigned long )sbcset == (unsigned long )((void *)0)),
                             0L);
  }
#line 3662
  if (tmp___0) {
#line 3664
    *err = (reg_errcode_t )12;
#line 3665
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3668
  tmp___1 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3668
  mbcset = (re_charset_t *)tmp___1;
#line 3669
  tmp___2 = __builtin_expect((long )((unsigned long )mbcset == (unsigned long )((void *)0)),
                             0L);
  }
#line 3669
  if (tmp___2) {
    {
#line 3671
    free((void *)sbcset);
#line 3672
    *err = (reg_errcode_t )12;
    }
#line 3673
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3675
  mbcset->non_match = (unsigned int )non_match;
#line 3679
  ret = build_charclass(trans, (bitset_word_t *)sbcset, mbcset, & alloc, class_name,
                        (reg_syntax_t )0);
#line 3685
  tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 3685
  if (tmp___3) {
    {
#line 3687
    free((void *)sbcset);
#line 3689
    free_charset(mbcset);
#line 3691
    *err = ret;
    }
#line 3692
    return ((bin_tree_t *)((void *)0));
  }
  {
#line 3695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3695
    if (! *extra) {
#line 3695
      goto while_break;
    }
    {
#line 3696
    bitset_set((bitset_word_t *)sbcset, (Idx )*extra);
#line 3695
    extra ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3699
  if (non_match) {
    {
#line 3700
    bitset_not((bitset_word_t *)sbcset);
    }
  }
#line 3704
  if (dfa->mb_cur_max > 1) {
    {
#line 3705
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t */* const  */)dfa->sb_char);
    }
  }
  {
#line 3709
  br_token.opr.sbcset = sbcset;
#line 3709
  br_token.type = (re_token_type_t )3;
#line 3709
  br_token.constraint = 0U;
#line 3709
  br_token.duplicated = 0U;
#line 3709
  br_token.opt_subexp = 0U;
#line 3709
  br_token.accept_mb = 0U;
#line 3709
  br_token.mb_partial = 0U;
#line 3709
  br_token.word_char = 0U;
#line 3710
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)(& br_token));
#line 3711
  tmp___4 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
  }
#line 3711
  if (tmp___4) {
#line 3712
    goto build_word_op_espace;
  }
#line 3715
  if (dfa->mb_cur_max > 1) {
    {
#line 3719
    br_token.type = (re_token_type_t )6;
#line 3720
    br_token.opr.mbcset = mbcset;
#line 3721
    dfa->has_mb_node = 1U;
#line 3722
    mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                 (re_token_t const   *)(& br_token));
#line 3723
    tmp___5 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                               0L);
    }
#line 3723
    if (tmp___5) {
#line 3724
      goto build_word_op_espace;
    }
    {
#line 3726
    tree = create_tree(dfa, tree, mbc_tree, (re_token_type_t )10);
#line 3727
    tmp___6 = __builtin_expect((long )((unsigned long )mbc_tree != (unsigned long )((void *)0)),
                               1L);
    }
#line 3727
    if (tmp___6) {
#line 3728
      return (tree);
    }
  } else {
    {
#line 3732
    free_charset(mbcset);
    }
#line 3733
    return (tree);
  }
  build_word_op_espace: 
  {
#line 3740
  free((void *)sbcset);
#line 3742
  free_charset(mbcset);
#line 3744
  *err = (reg_errcode_t )12;
  }
#line 3745
  return ((bin_tree_t *)((void *)0));
}
}
#line 3754 "./regcomp.c"
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ 
  Idx num ;
  unsigned char c ;
  long tmp ;
  Idx tmp___0 ;
  Idx tmp___1 ;

  {
#line 3757
  num = (Idx )-1;
  {
#line 3759
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3761
    fetch_token(token, input, syntax);
#line 3762
    c = token->opr.c;
#line 3763
    tmp = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
    }
#line 3763
    if (tmp) {
#line 3764
      return ((Idx )-2);
    }
#line 3765
    if ((unsigned int )token->type == 24U) {
#line 3766
      goto while_break;
    } else
#line 3765
    if ((int )c == 44) {
#line 3766
      goto while_break;
    }
#line 3767
    if ((unsigned int )token->type != 1U) {
#line 3767
      num = (Idx )-2;
    } else
#line 3767
    if ((int )c < 48) {
#line 3767
      num = (Idx )-2;
    } else
#line 3767
    if (57 < (int )c) {
#line 3767
      num = (Idx )-2;
    } else
#line 3767
    if (num == -2L) {
#line 3767
      num = (Idx )-2;
    } else {
#line 3767
      if (num == -1L) {
#line 3767
        tmp___1 = (Idx )((int )c - 48);
      } else {
#line 3767
        if (32768L < (num * 10L + (Idx )c) - 48L) {
#line 3767
          tmp___0 = (Idx )32768;
        } else {
#line 3767
          tmp___0 = (num * 10L + (Idx )c) - 48L;
        }
#line 3767
        tmp___1 = tmp___0;
      }
#line 3767
      num = tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3773
  return (num);
}
}
#line 3777 "./regcomp.c"
static void free_charset(re_charset_t *cset ) 
{ 


  {
  {
#line 3780
  free((void *)cset->mbchars);
#line 3785
  free((void *)cset->range_starts);
#line 3786
  free((void *)cset->range_ends);
#line 3787
  free((void *)cset->char_classes);
#line 3788
  free((void *)cset);
  }
#line 3789
  return;
}
}
#line 3796 "./regcomp.c"
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) 
{ 
  re_token_t t ;
  bin_tree_t *tmp ;

  {
  {
#line 3800
  t.opr.sbcset = (bitset_word_t *)0;
#line 3800
  t.type = type;
#line 3800
  t.constraint = 0U;
#line 3800
  t.duplicated = 0U;
#line 3800
  t.opt_subexp = 0U;
#line 3800
  t.accept_mb = 0U;
#line 3800
  t.mb_partial = 0U;
#line 3800
  t.word_char = 0U;
#line 3801
  tmp = create_token_tree(dfa, left, right, (re_token_t const   *)(& t));
  }
#line 3801
  return (tmp);
}
}
#line 3804 "./regcomp.c"
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) 
{ 
  bin_tree_t *tree ;
  bin_tree_storage_t *storage ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3809
  tmp___0 = __builtin_expect((long )((unsigned long )dfa->str_tree_storage_idx == (1024UL - sizeof(void *)) / sizeof(bin_tree_t )),
                             0L);
  }
#line 3809
  if (tmp___0) {
    {
#line 3811
    tmp = malloc(sizeof(bin_tree_storage_t ));
#line 3811
    storage = (bin_tree_storage_t *)tmp;
    }
#line 3813
    if ((unsigned long )storage == (unsigned long )((void *)0)) {
#line 3814
      return ((bin_tree_t *)((void *)0));
    }
#line 3815
    storage->next = dfa->str_tree_storage;
#line 3816
    dfa->str_tree_storage = storage;
#line 3817
    dfa->str_tree_storage_idx = 0;
  }
#line 3819
  tmp___1 = dfa->str_tree_storage_idx;
#line 3819
  (dfa->str_tree_storage_idx) ++;
#line 3819
  tree = & (dfa->str_tree_storage)->data[tmp___1];
#line 3821
  tree->parent = (struct bin_tree_t *)((void *)0);
#line 3822
  tree->left = left;
#line 3823
  tree->right = right;
#line 3824
  tree->token = (re_token_t )*token;
#line 3825
  tree->token.duplicated = 0U;
#line 3826
  tree->token.opt_subexp = 0U;
#line 3827
  tree->first = (struct bin_tree_t *)((void *)0);
#line 3828
  tree->next = (struct bin_tree_t *)((void *)0);
#line 3829
  tree->node_idx = (Idx )-1;
#line 3831
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 3832
    left->parent = tree;
  }
#line 3833
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 3834
    right->parent = tree;
  }
#line 3835
  return (tree);
}
}
#line 3841 "./regcomp.c"
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) 
{ 
  Idx idx ;

  {
#line 3844
  idx = (Idx )((uintptr_t )extra);
#line 3845
  if ((unsigned int )node->token.type == 17U) {
#line 3845
    if (node->token.opr.idx == idx) {
#line 3846
      node->token.opt_subexp = 1U;
    }
  }
#line 3848
  return ((reg_errcode_t )0);
}
}
#line 3853 "./regcomp.c"
static void free_token(re_token_t *node ) 
{ 


  {
#line 3857
  if ((unsigned int )node->type == 6U) {
#line 3857
    if (node->duplicated == 0U) {
      {
#line 3858
      free_charset(node->opr.mbcset);
      }
    } else {
#line 3857
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3861
  if ((unsigned int )node->type == 3U) {
#line 3861
    if (node->duplicated == 0U) {
      {
#line 3862
      free((void *)node->opr.sbcset);
      }
    }
  }
#line 3863
  return;
}
}
#line 3868 "./regcomp.c"
static reg_errcode_t free_tree(void *extra , bin_tree_t *node ) 
{ 


  {
  {
#line 3871
  free_token(& node->token);
  }
#line 3872
  return ((reg_errcode_t )0);
}
}
#line 3881 "./regcomp.c"
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) 
{ 
  bin_tree_t const   *node ;
  bin_tree_t *dup_root ;
  bin_tree_t **p_new ;
  bin_tree_t *dup_node ;
  bin_tree_t const   *prev ;

  {
#line 3886
  p_new = & dup_root;
#line 3886
  dup_node = (bin_tree_t *)root->parent;
#line 3888
  node = root;
  {
#line 3888
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3891
    *p_new = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               & node->token);
    }
#line 3892
    if ((unsigned long )*p_new == (unsigned long )((void *)0)) {
#line 3893
      return ((bin_tree_t *)((void *)0));
    }
#line 3894
    (*p_new)->parent = dup_node;
#line 3895
    (*p_new)->token.duplicated = 1U;
#line 3896
    dup_node = *p_new;
#line 3899
    if (node->left) {
#line 3901
      node = (bin_tree_t const   *)node->left;
#line 3902
      p_new = & dup_node->left;
    } else {
#line 3906
      prev = (bin_tree_t const   *)((void *)0);
      {
#line 3907
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3907
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 3907
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 3907
            goto while_break___0;
          }
        }
#line 3909
        prev = node;
#line 3910
        node = (bin_tree_t const   *)node->parent;
#line 3911
        dup_node = dup_node->parent;
#line 3912
        if (! node) {
#line 3913
          return (dup_root);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3915
      node = (bin_tree_t const   *)node->right;
#line 3916
      p_new = & dup_node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 20 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) match_ctx_init)(re_match_context_t *mctx ,
                                                                               int eflags ,
                                                                               Idx n ) ;
#line 22
static void match_ctx_clean(re_match_context_t *mctx ) ;
#line 23
static void match_ctx_free(re_match_context_t *mctx ) ;
#line 24
static reg_errcode_t ( __attribute__((__warn_unused_result__)) match_ctx_add_entry)(re_match_context_t *mctx ,
                                                                                    Idx node ,
                                                                                    Idx str_idx ,
                                                                                    Idx from ,
                                                                                    Idx to ) ;
#line 26
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) ;
#line 27
static reg_errcode_t ( __attribute__((__warn_unused_result__)) match_ctx_add_subtop)(re_match_context_t *mctx ,
                                                                                     Idx node ,
                                                                                     Idx str_idx ) ;
#line 29
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) ;
#line 31
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) ;
#line 34
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_search_internal)(regex_t const   *preg ,
                                                                                   char const   *string ,
                                                                                   Idx length ,
                                                                                   Idx start ,
                                                                                   Idx last_start ,
                                                                                   Idx stop ,
                                                                                   size_t nmatch ,
                                                                                   regmatch_t *pmatch ,
                                                                                   int eflags ) ;
#line 39
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) ;
#line 45
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) ;
#line 50
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) ;
#line 52
static reg_errcode_t ( __attribute__((__warn_unused_result__)) prune_impossible_nodes)(re_match_context_t *mctx ) ;
#line 53
static Idx ( __attribute__((__warn_unused_result__)) check_matching)(re_match_context_t *mctx ,
                                                                     _Bool fl_longest_match ,
                                                                     Idx *p_match_first ) ;
#line 55
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    Idx idx ) ;
#line 57
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) ;
#line 60
static reg_errcode_t ( __attribute__((__warn_unused_result__)) push_fail_stack)(struct re_fail_stack_t *fs ,
                                                                                Idx str_idx ,
                                                                                Idx dest_node ,
                                                                                Idx nregs ,
                                                                                regmatch_t *regs ,
                                                                                re_node_set *eps_via_nodes ) ;
#line 64
static reg_errcode_t ( __attribute__((__warn_unused_result__)) set_regs)(regex_t const   *preg ,
                                                                         re_match_context_t const   *mctx ,
                                                                         size_t nmatch ,
                                                                         regmatch_t *pmatch ,
                                                                         _Bool fl_backtrack ) ;
#line 68
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) ;
#line 71
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) ;
#line 75
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) ;
#line 77
static reg_errcode_t ( __attribute__((__warn_unused_result__)) build_sifted_states)(re_match_context_t const   *mctx ,
                                                                                    re_sift_context_t *sctx ,
                                                                                    Idx str_idx ,
                                                                                    re_node_set *cur_dest ) ;
#line 80
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) ;
#line 84
static reg_errcode_t ( __attribute__((__warn_unused_result__)) add_epsilon_src_nodes)(re_dfa_t const   *dfa ,
                                                                                      re_node_set *dest_nodes ,
                                                                                      re_node_set const   *candidates ) ;
#line 87
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) ;
#line 91
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) ;
#line 94
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) ;
#line 98
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) ;
#line 104
static reg_errcode_t ( __attribute__((__warn_unused_result__)) sift_states_bkref)(re_match_context_t const   *mctx ,
                                                                                  re_sift_context_t *sctx ,
                                                                                  Idx str_idx ,
                                                                                  re_node_set const   *candidates ) ;
#line 107
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) ;
#line 110
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) ;
#line 112
static re_dfastate_t *( __attribute__((__warn_unused_result__)) transit_state)(reg_errcode_t *err ,
                                                                               re_match_context_t *mctx ,
                                                                               re_dfastate_t *state ) ;
#line 115
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) ;
#line 118
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) ;
#line 127
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) ;
#line 130
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) ;
#line 132
static reg_errcode_t ( __attribute__((__warn_unused_result__)) get_subexp)(re_match_context_t *mctx ,
                                                                           Idx bkref_node ,
                                                                           Idx bkref_str_idx ) ;
#line 134
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) ;
#line 138
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) ;
#line 140
static reg_errcode_t ( __attribute__((__warn_unused_result__)) check_arrival)(re_match_context_t *mctx ,
                                                                              state_array_t *path ,
                                                                              Idx top_node ,
                                                                              Idx top_str ,
                                                                              Idx last_node ,
                                                                              Idx last_str ,
                                                                              int type ) ;
#line 144
static reg_errcode_t ( __attribute__((__warn_unused_result__)) check_arrival_add_next_nodes)(re_match_context_t *mctx ,
                                                                                             Idx str_idx ,
                                                                                             re_node_set *cur_nodes ,
                                                                                             re_node_set *next_nodes ) ;
#line 148
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) ;
#line 151
static reg_errcode_t ( __attribute__((__warn_unused_result__)) check_arrival_expand_ecl_sub)(re_dfa_t const   *dfa ,
                                                                                             re_node_set *dst_nodes ,
                                                                                             Idx target ,
                                                                                             Idx ex_subexp ,
                                                                                             int type ) ;
#line 155
static reg_errcode_t ( __attribute__((__warn_unused_result__)) expand_bkref_cache)(re_match_context_t *mctx ,
                                                                                   re_node_set *cur_nodes ,
                                                                                   Idx cur_str ,
                                                                                   Idx subexp_num ,
                                                                                   int type ) ;
#line 158
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) ;
#line 160
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) ;
#line 167
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) ;
#line 171
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) ;
#line 173
static reg_errcode_t ( __attribute__((__warn_unused_result__)) extend_buffers)(re_match_context_t *mctx ,
                                                                               int min_len ) ;
#line 191 "./regexec.c"
int rpl_regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
                size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  reg_errcode_t err ;
  Idx start ;
  Idx length ;
  re_dfa_t *dfa ;
  size_t tmp ;

  {
#line 197
  dfa = (re_dfa_t *)preg->buffer;
#line 199
  if (eflags & ~ ((1 | (1 << 1)) | (1 << 2))) {
#line 200
    return (2);
  }
#line 202
  if (eflags & (1 << 2)) {
#line 204
    start = (pmatch + 0)->rm_so;
#line 205
    length = (pmatch + 0)->rm_eo;
  } else {
    {
#line 209
    start = (Idx )0;
#line 210
    tmp = strlen((char const   *)string);
#line 210
    length = (Idx )tmp;
    }
  }
#line 214
  if (preg->no_sub) {
    {
#line 215
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length, length, (size_t )0, (regmatch_t *)((void *)0),
                             eflags);
    }
  } else {
    {
#line 218
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length, length, nmatch, (regmatch_t *)pmatch,
                             eflags);
    }
  }
#line 221
  return ((int )err != 0);
}
}
#line 275 "./regexec.c"
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , regoff_t length ,
                      regoff_t start , struct re_registers *regs ) 
{ 
  regoff_t tmp ;

  {
  {
#line 279
  tmp = re_search_stub(bufp, string, length, start, (regoff_t )0, length, regs, (_Bool)1);
  }
#line 279
  return (tmp);
}
}
#line 285 "./regexec.c"
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , regoff_t length ,
                       regoff_t start , regoff_t range , struct re_registers *regs ) 
{ 
  regoff_t tmp ;

  {
  {
#line 289
  tmp = re_search_stub(bufp, string, length, start, range, length, regs, (_Bool)0);
  }
#line 289
  return (tmp);
}
}
#line 296 "./regexec.c"
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , regoff_t length1 ,
                        char const   *string2 , regoff_t length2 , regoff_t start ,
                        struct re_registers *regs , regoff_t stop ) 
{ 
  regoff_t tmp ;

  {
  {
#line 301
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, (regoff_t )0,
                         regs, stop, (_Bool)1);
  }
#line 301
  return (tmp);
}
}
#line 308 "./regexec.c"
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         regoff_t length1 , char const   *string2 , regoff_t length2 ,
                         regoff_t start , regoff_t range , struct re_registers *regs ,
                         regoff_t stop ) 
{ 
  regoff_t tmp ;

  {
  {
#line 313
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, range, regs,
                         stop, (_Bool)0);
  }
#line 313
  return (tmp);
}
}
#line 331
extern int ( /* missing proto */  __builtin_add_overflow)() ;
#line 320 "./regexec.c"
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) 
{ 
  char const   *str ;
  regoff_t rval ;
  Idx len ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 329
  s = (char *)((void *)0);
#line 331
  if (length1 < 0L) {
#line 331
    tmp___0 = 1;
  } else
#line 331
  if (length2 < 0L) {
#line 331
    tmp___0 = 1;
  } else
#line 331
  if (stop < 0L) {
#line 331
    tmp___0 = 1;
  } else {
    {
#line 331
    tmp = __builtin_add_overflow(length1, length2, & len);
    }
#line 331
    if (tmp) {
#line 331
      tmp___0 = 1;
    } else {
#line 331
      tmp___0 = 0;
    }
  }
  {
#line 331
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 331
  if (tmp___1) {
#line 333
    return ((regoff_t )-2);
  }
#line 336
  if (length2 > 0L) {
#line 337
    if (length1 > 0L) {
      {
#line 339
      tmp___2 = malloc((unsigned long )len * sizeof(char ));
#line 339
      s = (char *)tmp___2;
#line 341
      tmp___3 = __builtin_expect((long )((unsigned long )s == (unsigned long )((void *)0)),
                                 0L);
      }
#line 341
      if (tmp___3) {
#line 342
        return ((regoff_t )-2);
      }
      {
#line 346
      memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)string1,
             (size_t )length1);
#line 347
      memcpy((void */* __restrict  */)(s + length1), (void const   */* __restrict  */)string2,
             (size_t )length2);
#line 349
      str = (char const   *)s;
      }
    } else {
#line 352
      str = string2;
    }
  } else {
#line 354
    str = string1;
  }
  {
#line 356
  rval = re_search_stub(bufp, str, len, start, range, stop, regs, ret_len);
#line 358
  free((void *)s);
  }
#line 359
  return (rval);
}
}
#line 367 "./regexec.c"
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) 
{ 
  reg_errcode_t result ;
  regmatch_t *pmatch ;
  Idx nregs ;
  regoff_t rval ;
  int eflags ;
  re_dfa_t *dfa ;
  Idx last_start ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;

  {
#line 376
  eflags = 0;
#line 377
  dfa = bufp->buffer;
#line 378
  last_start = start + range;
#line 381
  if (start < 0L) {
#line 381
    tmp = 1;
  } else
#line 381
  if (start > length) {
#line 381
    tmp = 1;
  } else {
#line 381
    tmp = 0;
  }
  {
#line 381
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 381
  if (tmp___0) {
#line 382
    return ((regoff_t )-1);
  }
#line 383
  if (length < last_start) {
#line 383
    tmp___3 = 1;
  } else
#line 383
  if (0L <= range) {
#line 383
    if (last_start < start) {
#line 383
      tmp___3 = 1;
    } else {
#line 383
      tmp___3 = 0;
    }
  } else {
#line 383
    tmp___3 = 0;
  }
  {
#line 383
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 383
  if (tmp___4) {
#line 385
    last_start = length;
  } else {
#line 386
    if (last_start < 0L) {
#line 386
      tmp___1 = 1;
    } else
#line 386
    if (range < 0L) {
#line 386
      if (start <= last_start) {
#line 386
        tmp___1 = 1;
      } else {
#line 386
        tmp___1 = 0;
      }
    } else {
#line 386
      tmp___1 = 0;
    }
    {
#line 386
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 386
    if (tmp___2) {
#line 388
      last_start = (Idx )0;
    }
  }
#line 392
  if (bufp->not_bol) {
#line 392
    tmp___5 = 1;
  } else {
#line 392
    tmp___5 = 0;
  }
#line 392
  eflags |= tmp___5;
#line 393
  if (bufp->not_eol) {
#line 393
    tmp___6 = 1 << 1;
  } else {
#line 393
    tmp___6 = 0;
  }
#line 393
  eflags |= tmp___6;
#line 396
  if (start < last_start) {
#line 396
    if ((unsigned long )bufp->fastmap != (unsigned long )((void *)0)) {
#line 396
      if (! bufp->fastmap_accurate) {
        {
#line 397
        rpl_re_compile_fastmap(bufp);
        }
      }
    }
  }
  {
#line 399
  tmp___7 = __builtin_expect((long )bufp->no_sub, 0L);
  }
#line 399
  if (tmp___7) {
#line 400
    regs = (struct re_registers *)((void *)0);
  }
#line 403
  if ((unsigned long )regs == (unsigned long )((void *)0)) {
#line 404
    nregs = (Idx )1;
  } else {
#line 405
    if (bufp->regs_allocated == 2U) {
#line 405
      if (regs->num_regs <= bufp->re_nsub) {
#line 405
        tmp___9 = 1;
      } else {
#line 405
        tmp___9 = 0;
      }
    } else {
#line 405
      tmp___9 = 0;
    }
    {
#line 405
    tmp___10 = __builtin_expect((long )tmp___9, 0L);
    }
#line 405
    if (tmp___10) {
      {
#line 408
      nregs = (Idx )regs->num_regs;
#line 409
      tmp___8 = __builtin_expect((long )(nregs < 1L), 0L);
      }
#line 409
      if (tmp___8) {
#line 412
        regs = (struct re_registers *)((void *)0);
#line 413
        nregs = (Idx )1;
      }
    } else {
#line 417
      nregs = (Idx )(bufp->re_nsub + 1UL);
    }
  }
  {
#line 418
  tmp___11 = malloc((unsigned long )nregs * sizeof(regmatch_t ));
#line 418
  pmatch = (regmatch_t *)tmp___11;
#line 419
  tmp___12 = __builtin_expect((long )((unsigned long )pmatch == (unsigned long )((void *)0)),
                              0L);
  }
#line 419
  if (tmp___12) {
#line 421
    rval = (regoff_t )-2;
#line 422
    goto out;
  }
  {
#line 425
  result = re_search_internal((regex_t const   *)bufp, string, length, start, last_start,
                              stop, (size_t )nregs, pmatch, eflags);
#line 428
  rval = (regoff_t )0;
  }
#line 431
  if ((int )result != 0) {
#line 432
    if ((int )result == 1) {
#line 432
      rval = (regoff_t )-1;
    } else {
#line 432
      rval = (regoff_t )-2;
    }
  } else
#line 433
  if ((unsigned long )regs != (unsigned long )((void *)0)) {
    {
#line 436
    bufp->regs_allocated = re_copy_regs(regs, pmatch, nregs, (int )bufp->regs_allocated);
#line 438
    tmp___13 = __builtin_expect((long )(bufp->regs_allocated == 0U), 0L);
    }
#line 438
    if (tmp___13) {
#line 439
      rval = (regoff_t )-2;
    }
  }
  {
#line 442
  tmp___14 = __builtin_expect((long )(rval == 0L), 1L);
  }
#line 442
  if (tmp___14) {
#line 444
    if (ret_len) {
#line 446
      if (! ((pmatch + 0)->rm_so == start)) {
        {
#line 446
        __builtin_unreachable();
        }
      }
#line 447
      rval = (pmatch + 0)->rm_eo - start;
    } else {
#line 450
      rval = (pmatch + 0)->rm_so;
    }
  }
  {
#line 452
  free((void *)pmatch);
  }
  out: ;
#line 455
  return (rval);
}
}
#line 458 "./regexec.c"
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) 
{ 
  int rval ;
  Idx i ;
  Idx need_regs ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  regoff_t *new_start ;
  void *tmp___3 ;
  regoff_t *new_end ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  regoff_t tmp___8 ;

  {
#line 462
  rval = 1;
#line 464
  need_regs = nregs + 1L;
#line 469
  if (regs_allocated == 0) {
    {
#line 471
    tmp = malloc((unsigned long )need_regs * sizeof(regoff_t ));
#line 471
    regs->start = (regoff_t *)tmp;
#line 472
    tmp___0 = __builtin_expect((long )((unsigned long )regs->start == (unsigned long )((void *)0)),
                               0L);
    }
#line 472
    if (tmp___0) {
#line 473
      return (0U);
    }
    {
#line 474
    tmp___1 = malloc((unsigned long )need_regs * sizeof(regoff_t ));
#line 474
    regs->end = (regoff_t *)tmp___1;
#line 475
    tmp___2 = __builtin_expect((long )((unsigned long )regs->end == (unsigned long )((void *)0)),
                               0L);
    }
#line 475
    if (tmp___2) {
      {
#line 477
      free((void *)regs->start);
      }
#line 478
      return (0U);
    }
#line 480
    regs->num_regs = (__re_size_t )need_regs;
  } else
#line 482
  if (regs_allocated == 1) {
    {
#line 486
    tmp___7 = __builtin_expect((long )((__re_size_t )need_regs > regs->num_regs),
                               0L);
    }
#line 486
    if (tmp___7) {
      {
#line 488
      tmp___3 = realloc((void *)regs->start, (unsigned long )need_regs * sizeof(regoff_t ));
#line 488
      new_start = (regoff_t *)tmp___3;
#line 490
      tmp___4 = __builtin_expect((long )((unsigned long )new_start == (unsigned long )((void *)0)),
                                 0L);
      }
#line 490
      if (tmp___4) {
#line 491
        return (0U);
      }
      {
#line 492
      tmp___5 = realloc((void *)regs->end, (unsigned long )need_regs * sizeof(regoff_t ));
#line 492
      new_end = (regoff_t *)tmp___5;
#line 493
      tmp___6 = __builtin_expect((long )((unsigned long )new_end == (unsigned long )((void *)0)),
                                 0L);
      }
#line 493
      if (tmp___6) {
        {
#line 495
        free((void *)new_start);
        }
#line 496
        return (0U);
      }
#line 498
      regs->start = new_start;
#line 499
      regs->end = new_end;
#line 500
      regs->num_regs = (__re_size_t )need_regs;
    }
  } else {
#line 505
    if (! (regs_allocated == 2)) {
      {
#line 505
      __builtin_unreachable();
      }
    }
#line 507
    if (! ((__re_size_t )nregs <= regs->num_regs)) {
      {
#line 507
      __builtin_unreachable();
      }
    }
#line 508
    rval = 2;
  }
#line 512
  i = (Idx )0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! (i < nregs)) {
#line 512
      goto while_break;
    }
#line 514
    *(regs->start + i) = (pmatch + i)->rm_so;
#line 515
    *(regs->end + i) = (pmatch + i)->rm_eo;
#line 512
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 517
    if (! ((__re_size_t )i < regs->num_regs)) {
#line 517
      goto while_break___0;
    }
#line 518
    tmp___8 = (regoff_t )-1;
#line 518
    *(regs->end + i) = tmp___8;
#line 518
    *(regs->start + i) = tmp___8;
#line 517
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 520
  return ((unsigned int )rval);
}
}
#line 536 "./regexec.c"
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp ;

  {
#line 540
  if (num_regs) {
#line 542
    bufp->regs_allocated = 1U;
#line 543
    regs->num_regs = num_regs;
#line 544
    regs->start = starts;
#line 545
    regs->end = ends;
  } else {
#line 549
    bufp->regs_allocated = 0U;
#line 550
    regs->num_regs = (__re_size_t )0;
#line 551
    tmp = (regoff_t *)((void *)0);
#line 551
    regs->end = tmp;
#line 551
    regs->start = tmp;
  }
#line 553
  return;
}
}
#line 583 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) re_search_internal)(regex_t const   *preg ,
                                                                                   char const   *string ,
                                                                                   Idx length ,
                                                                                   Idx start ,
                                                                                   Idx last_start ,
                                                                                   Idx stop ,
                                                                                   size_t nmatch ,
                                                                                   regmatch_t *pmatch ,
                                                                                   int eflags ) 
{ 
  reg_errcode_t err ;
  re_dfa_t const   *dfa ;
  Idx left_lim ;
  Idx right_lim ;
  int incr ;
  _Bool fl_longest_match ;
  int match_kind ;
  Idx match_first ;
  Idx match_last ;
  Idx extra_nmatch ;
  _Bool sb ;
  int ch ;
  re_match_context_t mctx ;
  char *fastmap ;
  char *tmp ;
  unsigned char *t ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  unsigned long tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  __re_size_t offset ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  Idx *tmp___20 ;
  re_dfastate_t *pstate ;
  long tmp___21 ;
  long tmp___22 ;
  Idx reg_idx ;
  regoff_t tmp___23 ;
  int tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;

  {
#line 590
  dfa = (re_dfa_t const   *)preg->buffer;
#line 596
  match_last = (Idx )-1;
#line 600
  mctx.input.raw_mbs = (unsigned char const   *)0;
#line 600
  mctx.input.mbs = (unsigned char *)0;
#line 600
  mctx.input.wcs = (wint_t *)0;
#line 600
  mctx.input.offsets = (Idx *)0;
#line 600
  mctx.input.cur_state.__count = 0;
#line 600
  mctx.input.cur_state.__value.__wch = 0U;
#line 600
  mctx.input.raw_mbs_idx = 0L;
#line 600
  mctx.input.valid_len = 0L;
#line 600
  mctx.input.valid_raw_len = 0L;
#line 600
  mctx.input.bufs_len = 0L;
#line 600
  mctx.input.cur_idx = 0L;
#line 600
  mctx.input.raw_len = 0L;
#line 600
  mctx.input.len = 0L;
#line 600
  mctx.input.raw_stop = 0L;
#line 600
  mctx.input.stop = 0L;
#line 600
  mctx.input.tip_context = 0U;
#line 600
  mctx.input.trans = (unsigned char *)0;
#line 600
  mctx.input.word_char = (bitset_word_t const   *)0;
#line 600
  mctx.input.icase = (unsigned char)0;
#line 600
  mctx.input.is_utf8 = (unsigned char)0;
#line 600
  mctx.input.map_notascii = (unsigned char)0;
#line 600
  mctx.input.mbs_allocated = (unsigned char)0;
#line 600
  mctx.input.offsets_needed = (unsigned char)0;
#line 600
  mctx.input.newline_anchor = (unsigned char)0;
#line 600
  mctx.input.word_ops_used = (unsigned char)0;
#line 600
  mctx.input.mb_cur_max = 0;
#line 600
  mctx.dfa = dfa;
#line 600
  mctx.eflags = 0;
#line 600
  mctx.match_last = 0L;
#line 600
  mctx.last_node = 0L;
#line 600
  mctx.state_log = (re_dfastate_t **)0;
#line 600
  mctx.state_log_top = 0L;
#line 600
  mctx.nbkref_ents = 0L;
#line 600
  mctx.abkref_ents = 0L;
#line 600
  mctx.bkref_ents = (struct re_backref_cache_entry *)0;
#line 600
  mctx.max_mb_elem_len = 0;
#line 600
  mctx.nsub_tops = 0L;
#line 600
  mctx.asub_tops = 0L;
#line 600
  mctx.sub_tops = (re_sub_match_top_t **)0;
#line 601
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
#line 601
    if (preg->fastmap_accurate) {
#line 601
      if (start != last_start) {
#line 601
        if (! preg->can_be_null) {
#line 601
          tmp = preg->fastmap;
        } else {
#line 601
          tmp = (char */* const  */)((void *)0);
        }
      } else {
#line 601
        tmp = (char */* const  */)((void *)0);
      }
    } else {
#line 601
      tmp = (char */* const  */)((void *)0);
    }
  } else {
#line 601
    tmp = (char */* const  */)((void *)0);
  }
#line 601
  fastmap = (char *)tmp;
#line 604
  t = (unsigned char *)preg->translate;
#line 606
  if (nmatch > (size_t )preg->re_nsub) {
#line 606
    extra_nmatch = (Idx )(nmatch - (size_t )(preg->re_nsub + 1UL));
  } else {
#line 606
    extra_nmatch = (Idx )0;
  }
#line 607
  nmatch -= (size_t )extra_nmatch;
#line 610
  if (preg->used == 0UL) {
#line 610
    tmp___0 = 1;
  } else
#line 610
  if ((unsigned long )dfa->init_state == (unsigned long )((void *)0)) {
#line 610
    tmp___0 = 1;
  } else
#line 610
  if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 610
    tmp___0 = 1;
  } else
#line 610
  if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 610
    tmp___0 = 1;
  } else
#line 610
  if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 610
    tmp___0 = 1;
  } else {
#line 610
    tmp___0 = 0;
  }
  {
#line 610
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 610
  if (tmp___1) {
#line 614
    return ((reg_errcode_t )1);
  }
#line 617
  if (0L <= last_start) {
#line 617
    if (! (last_start <= length)) {
      {
#line 617
      __builtin_unreachable();
      }
    }
  } else {
    {
#line 617
    __builtin_unreachable();
    }
  }
#line 622
  if ((dfa->init_state)->nodes.nelem == 0L) {
#line 622
    if ((dfa->init_state_word)->nodes.nelem == 0L) {
#line 622
      if ((dfa->init_state_nl)->nodes.nelem == 0L) {
#line 622
        goto _L;
      } else
#line 622
      if (! preg->newline_anchor) {
        _L: /* CIL Label */ 
#line 627
        if (start != 0L) {
#line 627
          if (last_start != 0L) {
#line 628
            return ((reg_errcode_t )1);
          }
        }
#line 629
        last_start = (Idx )0;
#line 629
        start = last_start;
      }
    }
  }
#line 633
  if (nmatch != 0UL) {
#line 633
    tmp___2 = 1;
  } else
#line 633
  if (dfa->nbackref) {
#line 633
    tmp___2 = 1;
  } else {
#line 633
    tmp___2 = 0;
  }
  {
#line 633
  fl_longest_match = (_Bool )tmp___2;
#line 635
  err = re_string_allocate(& mctx.input, string, length, (Idx )(dfa->nodes_len + 1UL),
                           (unsigned char *)preg->translate, (_Bool )((preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                           dfa);
#line 638
  tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 638
  if (tmp___3) {
#line 639
    goto free_return;
  }
  {
#line 640
  mctx.input.stop = stop;
#line 641
  mctx.input.raw_stop = stop;
#line 642
  mctx.input.newline_anchor = (unsigned char )preg->newline_anchor;
#line 644
  err = match_ctx_init(& mctx, eflags, (Idx )(dfa->nbackref * 2L));
#line 645
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 645
  if (tmp___4) {
#line 646
    goto free_return;
  }
#line 652
  if (nmatch > 1UL) {
#line 652
    goto _L___0;
  } else
#line 652
  if (dfa->has_mb_node) {
    _L___0: /* CIL Label */ 
#line 655
    if (9223372036854775807UL < 0xffffffffffffffffUL / sizeof(re_dfastate_t *)) {
#line 655
      tmp___5 = 9223372036854775807UL;
    } else {
#line 655
      tmp___5 = 0xffffffffffffffffUL / sizeof(re_dfastate_t *);
    }
    {
#line 655
    tmp___6 = __builtin_expect((long )(tmp___5 <= (unsigned long )mctx.input.bufs_len),
                               0L);
    }
#line 655
    if (tmp___6) {
#line 658
      err = (reg_errcode_t )12;
#line 659
      goto free_return;
    }
    {
#line 662
    tmp___7 = malloc((unsigned long )(mctx.input.bufs_len + 1L) * sizeof(re_dfastate_t *));
#line 662
    mctx.state_log = (re_dfastate_t **)tmp___7;
#line 663
    tmp___8 = __builtin_expect((long )((unsigned long )mctx.state_log == (unsigned long )((void *)0)),
                               0L);
    }
#line 663
    if (tmp___8) {
#line 665
      err = (reg_errcode_t )12;
#line 666
      goto free_return;
    }
  }
#line 670
  match_first = start;
#line 671
  if (eflags & 1) {
#line 671
    mctx.input.tip_context = (unsigned int )((1 << 1) << 1);
  } else {
#line 671
    mctx.input.tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
  }
#line 675
  if (last_start < start) {
#line 675
    incr = -1;
  } else {
#line 675
    incr = 1;
  }
#line 676
  if (last_start < start) {
#line 676
    left_lim = last_start;
  } else {
#line 676
    left_lim = start;
  }
#line 677
  if (last_start < start) {
#line 677
    right_lim = start;
  } else {
#line 677
    right_lim = last_start;
  }
#line 678
  sb = (_Bool )(dfa->mb_cur_max == 1);
#line 679
  if (fastmap) {
#line 679
    if (sb) {
#line 679
      tmp___9 = 4;
    } else
#line 679
    if (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 679
      tmp___9 = 0;
    } else
#line 679
    if (t) {
#line 679
      tmp___9 = 0;
    } else {
#line 679
      tmp___9 = 4;
    }
#line 679
    if (start <= last_start) {
#line 679
      tmp___10 = 2;
    } else {
#line 679
      tmp___10 = 0;
    }
#line 679
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 679
      tmp___11 = 1;
    } else {
#line 679
      tmp___11 = 0;
    }
#line 679
    match_kind = (tmp___9 | tmp___10) | tmp___11;
  } else {
#line 679
    match_kind = 8;
  }
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 688
    err = (reg_errcode_t )1;
#line 689
    if (match_first < left_lim) {
#line 690
      goto free_return;
    } else
#line 689
    if (right_lim < match_first) {
#line 690
      goto free_return;
    }
    {
#line 699
    if (match_kind == 8) {
#line 699
      goto case_8;
    }
#line 703
    if (match_kind == 7) {
#line 703
      goto case_7;
    }
#line 710
    if (match_kind == 6) {
#line 710
      goto case_6;
    }
#line 727
    if (match_kind == 5) {
#line 727
      goto case_5;
    }
#line 727
    if (match_kind == 4) {
#line 727
      goto case_5;
    }
#line 741
    goto switch_default;
    case_8: /* CIL Label */ 
#line 701
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 705
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 705
      tmp___12 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 705
      if (tmp___12) {
#line 705
        if (! (! *(fastmap + *(t + (unsigned char )*(string + match_first))))) {
#line 705
          goto while_break___0;
        }
      } else {
#line 705
        goto while_break___0;
      }
#line 707
      match_first ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 708
    goto forward_match_found_start_or_reached_end;
    case_6: /* CIL Label */ 
    {
#line 712
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 712
      tmp___13 = __builtin_expect((long )(match_first < right_lim), 1L);
      }
#line 712
      if (tmp___13) {
#line 712
        if (! (! *(fastmap + (unsigned char )*(string + match_first)))) {
#line 712
          goto while_break___1;
        }
      } else {
#line 712
        goto while_break___1;
      }
#line 714
      match_first ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    forward_match_found_start_or_reached_end: 
    {
#line 717
    tmp___15 = __builtin_expect((long )(match_first == right_lim), 0L);
    }
#line 717
    if (tmp___15) {
#line 719
      if (match_first >= length) {
#line 719
        ch = 0;
      } else {
#line 719
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 721
      if (t) {
#line 721
        tmp___14 = (int )*(t + ch);
      } else {
#line 721
        tmp___14 = ch;
      }
#line 721
      if (! *(fastmap + tmp___14)) {
#line 722
        goto free_return;
      }
    }
#line 724
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    {
#line 729
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 729
      if (! (match_first >= left_lim)) {
#line 729
        goto while_break___2;
      }
#line 731
      if (match_first >= length) {
#line 731
        ch = 0;
      } else {
#line 731
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 733
      if (t) {
#line 733
        tmp___16 = (int )*(t + ch);
      } else {
#line 733
        tmp___16 = ch;
      }
#line 733
      if (*(fastmap + tmp___16)) {
#line 734
        goto while_break___2;
      }
#line 735
      match_first --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 737
    if (match_first < left_lim) {
#line 738
      goto free_return;
    }
#line 739
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 745
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 749
      offset = (__re_size_t )(match_first - mctx.input.raw_mbs_idx);
#line 750
      tmp___18 = __builtin_expect((long )(offset >= (__re_size_t )mctx.input.valid_raw_len),
                                  0L);
      }
#line 750
      if (tmp___18) {
        {
#line 753
        err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 755
        tmp___17 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 755
        if (tmp___17) {
#line 756
          goto free_return;
        }
#line 758
        offset = (__re_size_t )(match_first - mctx.input.raw_mbs_idx);
      }
#line 762
      if (match_first >= length) {
#line 762
        ch = 0;
      } else {
#line 762
        ch = (int )*(mctx.input.mbs + offset);
      }
#line 764
      if (*(fastmap + ch)) {
#line 765
        goto while_break___3;
      }
#line 766
      match_first += (Idx )incr;
#line 767
      if (match_first < left_lim) {
#line 769
        err = (reg_errcode_t )1;
#line 770
        goto free_return;
      } else
#line 767
      if (match_first > right_lim) {
#line 769
        err = (reg_errcode_t )1;
#line 770
        goto free_return;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 773
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 778
    err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 779
    tmp___19 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 779
    if (tmp___19) {
#line 780
      goto free_return;
    }
#line 785
    if (! sb) {
#line 785
      if (! (0L == mctx.input.valid_len)) {
#line 785
        if (! (*(mctx.input.wcs + 0) != 4294967295U)) {
#line 786
          goto __Cont;
        }
      }
    }
#line 791
    mctx.max_mb_elem_len = 0;
#line 791
    mctx.nbkref_ents = (Idx )mctx.max_mb_elem_len;
#line 791
    mctx.state_log_top = mctx.nbkref_ents;
#line 792
    if (start <= last_start) {
#line 792
      tmp___20 = & match_first;
    } else {
#line 792
      tmp___20 = (Idx *)((void *)0);
    }
    {
#line 792
    match_last = check_matching(& mctx, fl_longest_match, tmp___20);
    }
#line 794
    if (match_last != -1L) {
      {
#line 796
      tmp___22 = __builtin_expect((long )(match_last == -2L), 0L);
      }
#line 796
      if (tmp___22) {
#line 798
        err = (reg_errcode_t )12;
#line 799
        goto free_return;
      } else {
#line 803
        mctx.match_last = match_last;
#line 804
        if (! preg->no_sub) {
#line 804
          if (nmatch > 1UL) {
            {
#line 806
            pstate = *(mctx.state_log + match_last);
#line 807
            mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                      (re_dfastate_t const   *)pstate,
                                                      match_last);
            }
          } else {
#line 804
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 804
        if (dfa->nbackref) {
          {
#line 806
          pstate = *(mctx.state_log + match_last);
#line 807
          mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                    (re_dfastate_t const   *)pstate,
                                                    match_last);
          }
        }
#line 810
        if (! preg->no_sub) {
#line 810
          if (nmatch > 1UL) {
#line 810
            if (dfa->has_plural_match) {
#line 810
              goto _L___2;
            } else {
#line 810
              goto _L___4;
            }
          } else {
#line 810
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 810
        if (dfa->nbackref) {
          _L___2: /* CIL Label */ 
          {
#line 813
          err = prune_impossible_nodes(& mctx);
          }
#line 814
          if ((int )err == 0) {
#line 815
            goto while_break;
          }
          {
#line 816
          tmp___21 = __builtin_expect((long )((int )err != 1), 0L);
          }
#line 816
          if (tmp___21) {
#line 817
            goto free_return;
          }
#line 818
          match_last = (Idx )-1;
        } else {
#line 821
          goto while_break;
        }
      }
    }
    {
#line 825
    match_ctx_clean(& mctx);
    }
    __Cont: /* CIL Label */ 
#line 686
    match_first += (Idx )incr;
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  if (! (match_last != -1L)) {
    {
#line 828
    __builtin_unreachable();
    }
  }
#line 829
  if (! ((int )err == 0)) {
    {
#line 829
    __builtin_unreachable();
    }
  }
#line 832
  if (nmatch > 0UL) {
#line 837
    reg_idx = (Idx )1;
    {
#line 837
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 837
      if (! ((size_t )reg_idx < nmatch)) {
#line 837
        goto while_break___4;
      }
#line 838
      tmp___23 = (regoff_t )-1;
#line 838
      (pmatch + reg_idx)->rm_eo = tmp___23;
#line 838
      (pmatch + reg_idx)->rm_so = tmp___23;
#line 837
      reg_idx ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 841
    (pmatch + 0)->rm_so = (regoff_t )0;
#line 842
    (pmatch + 0)->rm_eo = mctx.match_last;
#line 847
    if (! preg->no_sub) {
#line 847
      if (nmatch > 1UL) {
#line 849
        if (dfa->has_plural_match) {
#line 849
          if (dfa->nbackref > 0L) {
#line 849
            tmp___24 = 1;
          } else {
#line 849
            tmp___24 = 0;
          }
        } else {
#line 849
          tmp___24 = 0;
        }
        {
#line 849
        err = set_regs(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                       (_Bool )tmp___24);
#line 851
        tmp___25 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 851
        if (tmp___25) {
#line 852
          goto free_return;
        }
      }
    }
#line 858
    reg_idx = (Idx )0;
    {
#line 858
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 858
      if (! ((size_t )reg_idx < nmatch)) {
#line 858
        goto while_break___5;
      }
#line 859
      if ((pmatch + reg_idx)->rm_so != -1L) {
        {
#line 862
        tmp___26 = __builtin_expect((long )((int )mctx.input.offsets_needed != 0),
                                    0L);
        }
#line 862
        if (tmp___26) {
#line 864
          if ((pmatch + reg_idx)->rm_so == mctx.input.valid_len) {
#line 864
            (pmatch + reg_idx)->rm_so = mctx.input.valid_raw_len;
          } else {
#line 864
            (pmatch + reg_idx)->rm_so = *(mctx.input.offsets + (pmatch + reg_idx)->rm_so);
          }
#line 868
          if ((pmatch + reg_idx)->rm_eo == mctx.input.valid_len) {
#line 868
            (pmatch + reg_idx)->rm_eo = mctx.input.valid_raw_len;
          } else {
#line 868
            (pmatch + reg_idx)->rm_eo = *(mctx.input.offsets + (pmatch + reg_idx)->rm_eo);
          }
        }
#line 876
        (pmatch + reg_idx)->rm_so += match_first;
#line 877
        (pmatch + reg_idx)->rm_eo += match_first;
      }
#line 858
      reg_idx ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 879
    reg_idx = (Idx )0;
    {
#line 879
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 879
      if (! (reg_idx < extra_nmatch)) {
#line 879
        goto while_break___6;
      }
#line 881
      (pmatch + (nmatch + (size_t )reg_idx))->rm_so = (regoff_t )-1;
#line 882
      (pmatch + (nmatch + (size_t )reg_idx))->rm_eo = (regoff_t )-1;
#line 879
      reg_idx ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 885
    if (dfa->subexp_map) {
#line 886
      reg_idx = (Idx )0;
      {
#line 886
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 886
        if (! ((size_t )(reg_idx + 1L) < nmatch)) {
#line 886
          goto while_break___7;
        }
#line 887
        if (*(dfa->subexp_map + reg_idx) != reg_idx) {
#line 889
          (pmatch + (reg_idx + 1L))->rm_so = (pmatch + (*(dfa->subexp_map + reg_idx) + 1L))->rm_so;
#line 891
          (pmatch + (reg_idx + 1L))->rm_eo = (pmatch + (*(dfa->subexp_map + reg_idx) + 1L))->rm_eo;
        }
#line 886
        reg_idx ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
  free_return: 
  {
#line 897
  free((void *)mctx.state_log);
  }
#line 898
  if (dfa->nbackref) {
    {
#line 899
    match_ctx_free(& mctx);
    }
  }
  {
#line 900
  re_string_destruct(& mctx.input);
  }
#line 901
  return (err);
}
}
#line 904 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) prune_impossible_nodes)(re_match_context_t *mctx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx halt_node ;
  Idx match_last ;
  reg_errcode_t ret ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  unsigned long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 908
  dfa = mctx->dfa;
#line 912
  lim_states = (re_dfastate_t **)((void *)0);
#line 914
  if (! ((unsigned long )mctx->state_log != (unsigned long )((void *)0))) {
    {
#line 914
    __builtin_unreachable();
    }
  }
#line 915
  match_last = mctx->match_last;
#line 916
  halt_node = mctx->last_node;
#line 919
  if (9223372036854775807UL < 0xffffffffffffffffUL / sizeof(re_dfastate_t *)) {
#line 919
    tmp = 9223372036854775807UL;
  } else {
#line 919
    tmp = 0xffffffffffffffffUL / sizeof(re_dfastate_t *);
  }
  {
#line 919
  tmp___0 = __builtin_expect((long )(tmp <= (unsigned long )match_last), 0L);
  }
#line 919
  if (tmp___0) {
#line 921
    return ((reg_errcode_t )12);
  }
  {
#line 923
  tmp___1 = malloc((unsigned long )(match_last + 1L) * sizeof(re_dfastate_t *));
#line 923
  sifted_states = (re_dfastate_t **)tmp___1;
#line 924
  tmp___2 = __builtin_expect((long )((unsigned long )sifted_states == (unsigned long )((void *)0)),
                             0L);
  }
#line 924
  if (tmp___2) {
#line 926
    ret = (reg_errcode_t )12;
#line 927
    goto free_return;
  }
#line 929
  if (dfa->nbackref) {
    {
#line 931
    tmp___3 = malloc((unsigned long )(match_last + 1L) * sizeof(re_dfastate_t *));
#line 931
    lim_states = (re_dfastate_t **)tmp___3;
#line 932
    tmp___4 = __builtin_expect((long )((unsigned long )lim_states == (unsigned long )((void *)0)),
                               0L);
    }
#line 932
    if (tmp___4) {
#line 934
      ret = (reg_errcode_t )12;
#line 935
      goto free_return;
    }
    {
#line 937
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 939
      memset((void *)lim_states, '\000', sizeof(re_dfastate_t *) * (unsigned long )(match_last + 1L));
#line 941
      sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 943
      ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 944
      free((void *)sctx.limits.elems);
#line 945
      tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 945
      if (tmp___5) {
#line 946
        goto free_return;
      }
#line 947
      if ((unsigned long )*(sifted_states + 0) != (unsigned long )((void *)0)) {
#line 948
        goto while_break;
      } else
#line 947
      if ((unsigned long )*(lim_states + 0) != (unsigned long )((void *)0)) {
#line 948
        goto while_break;
      }
      {
#line 949
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 951
        match_last --;
#line 952
        if (match_last < 0L) {
#line 954
          ret = (reg_errcode_t )1;
#line 955
          goto free_return;
        }
#line 949
        if (! ((unsigned long )*(mctx->state_log + match_last) == (unsigned long )((void *)0))) {
#line 949
          if (! (! (*(mctx->state_log + match_last))->halt)) {
#line 949
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 959
      halt_node = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                           match_last);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 963
    ret = merge_state_array(dfa, sifted_states, lim_states, match_last + 1L);
#line 965
    free((void *)lim_states);
#line 966
    lim_states = (re_dfastate_t **)((void *)0);
#line 967
    tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 967
    if (tmp___6) {
#line 968
      goto free_return;
    }
  } else {
    {
#line 972
    sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 973
    ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 974
    free((void *)sctx.limits.elems);
#line 975
    tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
    }
#line 975
    if (tmp___7) {
#line 976
      goto free_return;
    }
#line 977
    if ((unsigned long )*(sifted_states + 0) == (unsigned long )((void *)0)) {
#line 979
      ret = (reg_errcode_t )1;
#line 980
      goto free_return;
    }
  }
  {
#line 983
  free((void *)mctx->state_log);
#line 984
  mctx->state_log = sifted_states;
#line 985
  sifted_states = (re_dfastate_t **)((void *)0);
#line 986
  mctx->last_node = halt_node;
#line 987
  mctx->match_last = match_last;
#line 988
  ret = (reg_errcode_t )0;
  }
  free_return: 
  {
#line 990
  free((void *)sifted_states);
#line 991
  free((void *)lim_states);
  }
#line 992
  return (ret);
}
}
#line 999 "./regexec.c"
__inline static re_dfastate_t *( __attribute__((__always_inline__)) acquire_init_state_context)(reg_errcode_t *err ,
                                                                                                re_match_context_t const   *mctx ,
                                                                                                Idx idx ) 
{ 
  re_dfa_t const   *dfa ;
  unsigned int context ;
  re_dfastate_t *tmp ;

  {
#line 1004
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1005
  if ((dfa->init_state)->has_constraint) {
    {
#line 1008
    context = re_string_context_at(& mctx->input, idx - 1L, (int )mctx->eflags);
    }
#line 1009
    if (context & 1U) {
#line 1010
      return ((re_dfastate_t *)dfa->init_state_word);
    } else
#line 1011
    if (context == 0U) {
#line 1012
      return ((re_dfastate_t *)dfa->init_state);
    } else
#line 1013
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 1013
      if (context & (unsigned int )(1 << 1)) {
#line 1014
        return ((re_dfastate_t *)dfa->init_state_begbuf);
      } else {
#line 1013
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1015
    if (context & (unsigned int )(1 << 1)) {
#line 1016
      return ((re_dfastate_t *)dfa->init_state_nl);
    } else
#line 1017
    if (context & (unsigned int )((1 << 1) << 1)) {
      {
#line 1020
      tmp = re_acquire_state_context(err, dfa, (re_node_set const   *)(dfa->init_state)->entrance_nodes,
                                     context);
      }
#line 1020
      return (tmp);
    } else {
#line 1026
      return ((re_dfastate_t *)dfa->init_state);
    }
  } else {
#line 1029
    return ((re_dfastate_t *)dfa->init_state);
  }
}
}
#line 1041 "./regexec.c"
static Idx ( __attribute__((__warn_unused_result__)) check_matching)(re_match_context_t *mctx ,
                                                                     _Bool fl_longest_match ,
                                                                     Idx *p_match_first ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx match ;
  Idx match_last ;
  Idx cur_str_idx ;
  re_dfastate_t *cur_state ;
  _Bool at_init_state ;
  Idx next_start_idx ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Idx tmp___3 ;
  long tmp___4 ;
  re_dfastate_t *old_state ;
  Idx next_char_idx ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  Idx tmp___10 ;

  {
  {
#line 1046
  dfa = mctx->dfa;
#line 1048
  match = (Idx )0;
#line 1049
  match_last = (Idx )-1;
#line 1050
  cur_str_idx = mctx->input.cur_idx;
#line 1052
  at_init_state = (_Bool )((unsigned long )p_match_first != (unsigned long )((void *)0));
#line 1053
  next_start_idx = cur_str_idx;
#line 1055
  err = (reg_errcode_t )0;
#line 1056
  cur_state = acquire_init_state_context(& err, (re_match_context_t const   *)mctx,
                                         cur_str_idx);
#line 1058
  tmp = __builtin_expect((long )((unsigned long )cur_state == (unsigned long )((void *)0)),
                         0L);
  }
#line 1058
  if (tmp) {
#line 1060
    if (! ((int )err == 12)) {
      {
#line 1060
      __builtin_unreachable();
      }
    }
#line 1061
    return ((Idx )-2);
  }
#line 1064
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 1066
    *(mctx->state_log + cur_str_idx) = cur_state;
#line 1070
    tmp___2 = __builtin_expect((long )dfa->nbackref, 0L);
    }
#line 1070
    if (tmp___2) {
      {
#line 1072
      at_init_state = (_Bool)0;
#line 1073
      err = check_subexp_matching_top(mctx, & cur_state->nodes, (Idx )0);
#line 1074
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1074
      if (tmp___0) {
#line 1075
        return ((Idx )err);
      }
#line 1077
      if (cur_state->has_backref) {
        {
#line 1079
        err = transit_state_bkref(mctx, (re_node_set const   *)(& cur_state->nodes));
#line 1080
        tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1080
        if (tmp___1) {
#line 1081
          return ((Idx )err);
        }
      }
    }
  }
  {
#line 1087
  tmp___4 = __builtin_expect((long )cur_state->halt, 0L);
  }
#line 1087
  if (tmp___4) {
#line 1089
    if (! cur_state->has_constraint) {
#line 1089
      goto _L;
    } else {
      {
#line 1089
      tmp___3 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                         cur_str_idx);
      }
#line 1089
      if (tmp___3) {
        _L: /* CIL Label */ 
#line 1092
        if (! fl_longest_match) {
#line 1093
          return (cur_str_idx);
        } else {
#line 1096
          match_last = cur_str_idx;
#line 1097
          match = (Idx )1;
        }
      }
    }
  }
  {
#line 1102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1102
    if (! (! (mctx->input.stop <= mctx->input.cur_idx))) {
#line 1102
      goto while_break;
    }
    {
#line 1104
    old_state = cur_state;
#line 1105
    next_char_idx = mctx->input.cur_idx + 1L;
#line 1107
    tmp___6 = __builtin_expect((long )(next_char_idx >= mctx->input.bufs_len), 0L);
    }
#line 1107
    if (tmp___6) {
#line 1107
      if (mctx->input.bufs_len < mctx->input.len) {
#line 1107
        goto _L___0;
      } else {
#line 1107
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 1107
      tmp___7 = __builtin_expect((long )(next_char_idx >= mctx->input.valid_len),
                                 0L);
      }
#line 1107
      if (tmp___7) {
#line 1107
        if (mctx->input.valid_len < mctx->input.len) {
          _L___0: /* CIL Label */ 
          {
#line 1112
          err = extend_buffers(mctx, (int )(next_char_idx + 1L));
#line 1113
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 1113
          if (tmp___5) {
#line 1115
            if (! ((int )err == 12)) {
              {
#line 1115
              __builtin_unreachable();
              }
            }
#line 1116
            return ((Idx )-2);
          }
        }
      }
    }
    {
#line 1120
    cur_state = transit_state(& err, mctx, cur_state);
    }
#line 1121
    if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
      {
#line 1122
      cur_state = merge_state_with_log(& err, mctx, cur_state);
      }
    }
#line 1124
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
      {
#line 1129
      tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1129
      if (tmp___8) {
#line 1130
        return ((Idx )-2);
      }
#line 1132
      if ((unsigned long )mctx->state_log == (unsigned long )((void *)0)) {
#line 1135
        goto while_break;
      } else
#line 1132
      if (match) {
#line 1132
        if (! fl_longest_match) {
#line 1135
          goto while_break;
        } else {
#line 1132
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        {
#line 1132
        cur_state = find_recover_state(& err, mctx);
        }
#line 1132
        if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 1135
          goto while_break;
        }
      }
    }
    {
#line 1138
    tmp___9 = __builtin_expect((long )at_init_state, 0L);
    }
#line 1138
    if (tmp___9) {
#line 1140
      if ((unsigned long )old_state == (unsigned long )cur_state) {
#line 1141
        next_start_idx = next_char_idx;
      } else {
#line 1143
        at_init_state = (_Bool)0;
      }
    }
#line 1146
    if (cur_state->halt) {
#line 1150
      if (! cur_state->has_constraint) {
#line 1150
        goto _L___3;
      } else {
        {
#line 1150
        tmp___10 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                            mctx->input.cur_idx);
        }
#line 1150
        if (tmp___10) {
          _L___3: /* CIL Label */ 
#line 1155
          match_last = mctx->input.cur_idx;
#line 1156
          match = (Idx )1;
#line 1159
          p_match_first = (Idx *)((void *)0);
#line 1160
          if (! fl_longest_match) {
#line 1161
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1166
  if (p_match_first) {
#line 1167
    *p_match_first += next_start_idx;
  }
#line 1169
  return (match_last);
}
}
#line 1174 "./regexec.c"
static _Bool check_halt_node_context(re_dfa_t const   *dfa , Idx node , unsigned int context ) 
{ 
  re_token_type_t type ;
  unsigned int constraint ;

  {
#line 1177
  type = (dfa->nodes + node)->type;
#line 1178
  constraint = (dfa->nodes + node)->constraint;
#line 1179
  if ((unsigned int )type != 2U) {
#line 1180
    return ((_Bool)0);
  }
#line 1181
  if (! constraint) {
#line 1182
    return ((_Bool)1);
  }
#line 1183
  if (constraint & 4U) {
#line 1183
    if (! (context & 1U)) {
#line 1184
      return ((_Bool)0);
    } else {
#line 1183
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1183
  if (constraint & 8U) {
#line 1183
    if (context & 1U) {
#line 1184
      return ((_Bool)0);
    } else {
#line 1183
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1183
  if (constraint & 32U) {
#line 1183
    if (! (context & (unsigned int )(1 << 1))) {
#line 1184
      return ((_Bool)0);
    } else {
#line 1183
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1183
  if (constraint & 128U) {
#line 1183
    if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 1184
      return ((_Bool)0);
    }
  }
#line 1185
  return ((_Bool)1);
}
}
#line 1192 "./regexec.c"
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    Idx idx ) 
{ 
  Idx i ;
  unsigned int context ;
  _Bool tmp ;

  {
#line 1198
  if (! state->halt) {
    {
#line 1198
    __builtin_unreachable();
    }
  }
  {
#line 1199
  context = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 1200
  i = (Idx )0;
  }
  {
#line 1200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1200
    if (! (i < (Idx )state->nodes.nelem)) {
#line 1200
      goto while_break;
    }
    {
#line 1201
    tmp = check_halt_node_context((re_dfa_t const   *)mctx->dfa, *(state->nodes.elems + i),
                                  context);
    }
#line 1201
    if (tmp) {
#line 1202
      return (*(state->nodes.elems + i));
    }
#line 1200
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1203
  return ((Idx )0);
}
}
#line 1211 "./regexec.c"
static Idx proceed_next_node(re_match_context_t const   *mctx , Idx nregs , regmatch_t *regs ,
                             Idx *pidx , Idx node , re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) 
{ 
  re_dfa_t const   *dfa ;
  Idx i ;
  _Bool ok ;
  re_node_set *cur_nodes ;
  re_node_set *edests ;
  Idx dest_node ;
  long tmp ;
  Idx candidate ;
  Idx __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx naccepted ;
  re_token_type_t type ;
  int tmp___3 ;
  Idx subexp_idx ;
  char *buf ;
  int tmp___4 ;
  Idx dest_node___0 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  Idx dest_node___1 ;
  Idx __attribute__((__pure__))  tmp___7 ;
  _Bool tmp___8 ;

  {
#line 1216
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1219
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
    {
#line 1221
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
#line 1222
    edests = dfa->edests + node;
#line 1224
    ok = re_node_set_insert(eps_via_nodes, node);
#line 1225
    tmp = __builtin_expect((long )(! ok), 0L);
    }
#line 1225
    if (tmp) {
#line 1226
      return ((Idx )-2);
    }
#line 1229
    dest_node = (Idx )-1;
#line 1229
    i = (Idx )0;
    {
#line 1229
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1229
      if (! (i < edests->nelem)) {
#line 1229
        goto while_break;
      }
      {
#line 1231
      candidate = *(edests->elems + i);
#line 1232
      tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, candidate);
      }
#line 1232
      if (! tmp___0) {
#line 1233
        goto __Cont;
      }
#line 1234
      if (dest_node == -1L) {
#line 1235
        dest_node = candidate;
      } else {
        {
#line 1241
        tmp___2 = re_node_set_contains((re_node_set const   *)eps_via_nodes, dest_node);
        }
#line 1241
        if (tmp___2) {
#line 1242
          return (candidate);
        } else
#line 1245
        if ((unsigned long )fs != (unsigned long )((void *)0)) {
          {
#line 1245
          tmp___1 = push_fail_stack(fs, *pidx, candidate, nregs, regs, eps_via_nodes);
          }
#line 1245
          if (tmp___1) {
#line 1248
            return ((Idx )-2);
          }
        }
#line 1251
        goto while_break;
      }
      __Cont: /* CIL Label */ 
#line 1229
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1254
    return (dest_node);
  } else {
#line 1258
    naccepted = (Idx )0;
#line 1259
    type = (dfa->nodes + node)->type;
#line 1262
    if ((dfa->nodes + node)->accept_mb) {
      {
#line 1263
      tmp___3 = check_node_accept_bytes(dfa, node, & mctx->input, *pidx);
#line 1263
      naccepted = (Idx )tmp___3;
      }
    } else
#line 1266
    if ((unsigned int )type == 4U) {
#line 1268
      subexp_idx = (dfa->nodes + node)->opr.idx + 1L;
#line 1269
      if (subexp_idx < nregs) {
#line 1270
        naccepted = (regs + subexp_idx)->rm_eo - (regs + subexp_idx)->rm_so;
      }
#line 1271
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
#line 1273
        if (subexp_idx >= nregs) {
#line 1276
          return ((Idx )-1);
        } else
#line 1273
        if ((regs + subexp_idx)->rm_so == -1L) {
#line 1276
          return ((Idx )-1);
        } else
#line 1273
        if ((regs + subexp_idx)->rm_eo == -1L) {
#line 1276
          return ((Idx )-1);
        } else
#line 1277
        if (naccepted) {
#line 1279
          buf = (char *)mctx->input.mbs;
#line 1280
          if (mctx->input.valid_len - (Idx const   )*pidx < (Idx const   )naccepted) {
#line 1284
            return ((Idx )-1);
          } else {
            {
#line 1280
            tmp___4 = memcmp((void const   *)(buf + (regs + subexp_idx)->rm_so), (void const   *)(buf + *pidx),
                             (size_t )naccepted);
            }
#line 1280
            if (tmp___4 != 0) {
#line 1284
              return ((Idx )-1);
            }
          }
        }
      }
#line 1288
      if (naccepted == 0L) {
        {
#line 1291
        ok = re_node_set_insert(eps_via_nodes, node);
#line 1292
        tmp___5 = __builtin_expect((long )(! ok), 0L);
        }
#line 1292
        if (tmp___5) {
#line 1293
          return ((Idx )-2);
        }
        {
#line 1294
        dest_node___0 = *((dfa->edests + node)->elems + 0);
#line 1295
        tmp___6 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                       dest_node___0);
        }
#line 1295
        if (tmp___6) {
#line 1297
          return (dest_node___0);
        }
      }
    }
#line 1301
    if (naccepted != 0L) {
#line 1301
      goto _L;
    } else {
      {
#line 1301
      tmp___8 = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + node),
                                  *pidx);
      }
#line 1301
      if (tmp___8) {
        _L: /* CIL Label */ 
#line 1304
        dest_node___1 = *(dfa->nexts + node);
#line 1305
        if (naccepted == 0L) {
#line 1305
          (*pidx) ++;
        } else {
#line 1305
          *pidx += naccepted;
        }
#line 1306
        if (fs) {
#line 1306
          if (*pidx > (Idx )mctx->match_last) {
#line 1309
            return ((Idx )-1);
          } else
#line 1306
          if ((unsigned long )*(mctx->state_log + *pidx) == (unsigned long )((void *)0)) {
#line 1309
            return ((Idx )-1);
          } else {
            {
#line 1306
            tmp___7 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                           dest_node___1);
            }
#line 1306
            if (! tmp___7) {
#line 1309
              return ((Idx )-1);
            }
          }
        }
#line 1310
        eps_via_nodes->nelem = (Idx )0;
#line 1311
        return (dest_node___1);
      }
    }
  }
#line 1314
  return ((Idx )-1);
}
}
#line 1317 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) push_fail_stack)(struct re_fail_stack_t *fs ,
                                                                                Idx str_idx ,
                                                                                Idx dest_node ,
                                                                                Idx nregs ,
                                                                                regmatch_t *regs ,
                                                                                re_node_set *eps_via_nodes ) 
{ 
  reg_errcode_t err ;
  Idx num ;
  Idx tmp ;
  struct re_fail_stack_ent_t *new_array ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1323
  tmp = fs->num;
#line 1323
  (fs->num) ++;
#line 1323
  num = tmp;
#line 1324
  if (fs->num == fs->alloc) {
    {
#line 1327
    tmp___0 = realloc((void *)fs->stack, (unsigned long )(fs->alloc * 2L) * sizeof(struct re_fail_stack_ent_t ));
#line 1327
    new_array = (struct re_fail_stack_ent_t *)tmp___0;
    }
#line 1329
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
#line 1330
      return ((reg_errcode_t )12);
    }
#line 1331
    fs->alloc *= 2L;
#line 1332
    fs->stack = new_array;
  }
  {
#line 1334
  (fs->stack + num)->idx = str_idx;
#line 1335
  (fs->stack + num)->node = dest_node;
#line 1336
  tmp___1 = malloc((unsigned long )nregs * sizeof(regmatch_t ));
#line 1336
  (fs->stack + num)->regs = (regmatch_t *)tmp___1;
  }
#line 1337
  if ((unsigned long )(fs->stack + num)->regs == (unsigned long )((void *)0)) {
#line 1338
    return ((reg_errcode_t )12);
  }
  {
#line 1339
  memcpy((void */* __restrict  */)(fs->stack + num)->regs, (void const   */* __restrict  */)regs,
         sizeof(regmatch_t ) * (unsigned long )nregs);
#line 1340
  err = re_node_set_init_copy(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
  }
#line 1341
  return (err);
}
}
#line 1344 "./regexec.c"
static Idx pop_fail_stack(struct re_fail_stack_t *fs , Idx *pidx , Idx nregs , regmatch_t *regs ,
                          re_node_set *eps_via_nodes ) 
{ 
  Idx num ;

  {
#line 1348
  (fs->num) --;
#line 1348
  num = fs->num;
#line 1349
  if (! (num >= 0L)) {
    {
#line 1349
    __builtin_unreachable();
    }
  }
  {
#line 1350
  *pidx = (fs->stack + num)->idx;
#line 1351
  memcpy((void */* __restrict  */)regs, (void const   */* __restrict  */)(fs->stack + num)->regs,
         sizeof(regmatch_t ) * (unsigned long )nregs);
#line 1352
  free((void *)eps_via_nodes->elems);
#line 1353
  free((void *)(fs->stack + num)->regs);
#line 1354
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
  }
#line 1355
  return ((fs->stack + num)->node);
}
}
#line 1363 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) set_regs)(regex_t const   *preg ,
                                                                         re_match_context_t const   *mctx ,
                                                                         size_t nmatch ,
                                                                         regmatch_t *pmatch ,
                                                                         _Bool fl_backtrack ) 
{ 
  re_dfa_t const   *dfa ;
  Idx idx ;
  Idx cur_node ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  regmatch_t *prev_idx_match ;
  _Bool prev_idx_match_malloced ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Idx reg_idx ;
  reg_errcode_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  reg_errcode_t tmp___5 ;

  {
#line 1368
  dfa = (re_dfa_t const   *)preg->buffer;
#line 1372
  fs_body.num = (Idx )0;
#line 1372
  fs_body.alloc = (Idx )2;
#line 1372
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
#line 1374
  prev_idx_match_malloced = (_Bool)0;
#line 1376
  if (! (nmatch > 1UL)) {
    {
#line 1376
    __builtin_unreachable();
    }
  }
#line 1377
  if (! ((unsigned long )mctx->state_log != (unsigned long )((void *)0))) {
    {
#line 1377
    __builtin_unreachable();
    }
  }
#line 1378
  if (fl_backtrack) {
    {
#line 1380
    fs = & fs_body;
#line 1381
    tmp = malloc((unsigned long )fs->alloc * sizeof(struct re_fail_stack_ent_t ));
#line 1381
    fs->stack = (struct re_fail_stack_ent_t *)tmp;
    }
#line 1382
    if ((unsigned long )fs->stack == (unsigned long )((void *)0)) {
#line 1383
      return ((reg_errcode_t )12);
    }
  } else {
#line 1386
    fs = (struct re_fail_stack_t *)((void *)0);
  }
  {
#line 1388
  cur_node = (Idx )dfa->init_node;
#line 1389
  memset((void *)(& eps_via_nodes), '\000', sizeof(re_node_set ));
  }
#line 1391
  if (nmatch * sizeof(regmatch_t ) < 4032UL) {
    {
#line 1392
    tmp___0 = __builtin_alloca(nmatch * sizeof(regmatch_t ));
#line 1392
    prev_idx_match = (regmatch_t *)tmp___0;
    }
  } else {
    {
#line 1395
    tmp___1 = malloc(nmatch * sizeof(regmatch_t ));
#line 1395
    prev_idx_match = (regmatch_t *)tmp___1;
    }
#line 1396
    if ((unsigned long )prev_idx_match == (unsigned long )((void *)0)) {
      {
#line 1398
      free_fail_stack_return(fs);
      }
#line 1399
      return ((reg_errcode_t )12);
    }
#line 1401
    prev_idx_match_malloced = (_Bool)1;
  }
  {
#line 1403
  memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
         sizeof(regmatch_t ) * nmatch);
#line 1405
  idx = (pmatch + 0)->rm_so;
  }
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1405
    if (! (idx <= (pmatch + 0)->rm_eo)) {
#line 1405
      goto while_break;
    }
    {
#line 1407
    update_regs(dfa, pmatch, prev_idx_match, cur_node, idx, (Idx )nmatch);
    }
#line 1409
    if (idx == (pmatch + 0)->rm_eo) {
#line 1409
      if (cur_node == (Idx )mctx->last_node) {
#line 1412
        if (fs) {
#line 1414
          reg_idx = (Idx )0;
          {
#line 1414
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1414
            if (! ((size_t )reg_idx < nmatch)) {
#line 1414
              goto while_break___0;
            }
#line 1415
            if ((pmatch + reg_idx)->rm_so > -1L) {
#line 1415
              if ((pmatch + reg_idx)->rm_eo == -1L) {
#line 1416
                goto while_break___0;
              }
            }
#line 1414
            reg_idx ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1417
          if ((size_t )reg_idx == nmatch) {
            {
#line 1419
            free((void *)eps_via_nodes.elems);
            }
#line 1420
            if (prev_idx_match_malloced) {
              {
#line 1421
              free((void *)prev_idx_match);
              }
            }
            {
#line 1422
            tmp___2 = free_fail_stack_return(fs);
            }
#line 1422
            return (tmp___2);
          }
          {
#line 1424
          cur_node = pop_fail_stack(fs, & idx, (Idx )nmatch, pmatch, & eps_via_nodes);
          }
        } else {
          {
#line 1429
          free((void *)eps_via_nodes.elems);
          }
#line 1430
          if (prev_idx_match_malloced) {
            {
#line 1431
            free((void *)prev_idx_match);
            }
          }
#line 1432
          return ((reg_errcode_t )0);
        }
      }
    }
    {
#line 1437
    cur_node = proceed_next_node(mctx, (Idx )nmatch, pmatch, & idx, cur_node, & eps_via_nodes,
                                 fs);
#line 1440
    tmp___4 = __builtin_expect((long )(cur_node < 0L), 0L);
    }
#line 1440
    if (tmp___4) {
      {
#line 1442
      tmp___3 = __builtin_expect((long )(cur_node == -2L), 0L);
      }
#line 1442
      if (tmp___3) {
        {
#line 1444
        free((void *)eps_via_nodes.elems);
        }
#line 1445
        if (prev_idx_match_malloced) {
          {
#line 1446
          free((void *)prev_idx_match);
          }
        }
        {
#line 1447
        free_fail_stack_return(fs);
        }
#line 1448
        return ((reg_errcode_t )12);
      }
#line 1450
      if (fs) {
        {
#line 1451
        cur_node = pop_fail_stack(fs, & idx, (Idx )nmatch, pmatch, & eps_via_nodes);
        }
      } else {
        {
#line 1455
        free((void *)eps_via_nodes.elems);
        }
#line 1456
        if (prev_idx_match_malloced) {
          {
#line 1457
          free((void *)prev_idx_match);
          }
        }
#line 1458
        return ((reg_errcode_t )1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1462
  free((void *)eps_via_nodes.elems);
  }
#line 1463
  if (prev_idx_match_malloced) {
    {
#line 1464
    free((void *)prev_idx_match);
    }
  }
  {
#line 1465
  tmp___5 = free_fail_stack_return(fs);
  }
#line 1465
  return (tmp___5);
}
}
#line 1468 "./regexec.c"
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) 
{ 
  Idx fs_idx ;

  {
#line 1471
  if (fs) {
#line 1474
    fs_idx = (Idx )0;
    {
#line 1474
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1474
      if (! (fs_idx < fs->num)) {
#line 1474
        goto while_break;
      }
      {
#line 1476
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
#line 1477
      free((void *)(fs->stack + fs_idx)->regs);
#line 1474
      fs_idx ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1479
    free((void *)fs->stack);
    }
  }
#line 1481
  return ((reg_errcode_t )0);
}
}
#line 1484 "./regexec.c"
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) 
{ 
  int type ;
  Idx reg_num ;
  Idx reg_num___0 ;

  {
#line 1488
  type = (int )(dfa->nodes + cur_node)->type;
#line 1489
  if (type == 8) {
#line 1491
    reg_num = (dfa->nodes + cur_node)->opr.idx + 1L;
#line 1494
    if (reg_num < nmatch) {
#line 1496
      (pmatch + reg_num)->rm_so = cur_idx;
#line 1497
      (pmatch + reg_num)->rm_eo = (regoff_t )-1;
    }
  } else
#line 1500
  if (type == 9) {
#line 1502
    reg_num___0 = (dfa->nodes + cur_node)->opr.idx + 1L;
#line 1503
    if (reg_num___0 < nmatch) {
#line 1506
      if ((pmatch + reg_num___0)->rm_so < cur_idx) {
        {
#line 1508
        (pmatch + reg_num___0)->rm_eo = cur_idx;
#line 1511
        memcpy((void */* __restrict  */)prev_idx_match, (void const   */* __restrict  */)pmatch,
               sizeof(regmatch_t ) * (unsigned long )nmatch);
        }
      } else
#line 1515
      if ((dfa->nodes + cur_node)->opt_subexp) {
#line 1515
        if ((prev_idx_match + reg_num___0)->rm_so != -1L) {
          {
#line 1522
          memcpy((void */* __restrict  */)pmatch, (void const   */* __restrict  */)prev_idx_match,
                 sizeof(regmatch_t ) * (unsigned long )nmatch);
          }
        } else {
#line 1526
          (pmatch + reg_num___0)->rm_eo = cur_idx;
        }
      } else {
#line 1526
        (pmatch + reg_num___0)->rm_eo = cur_idx;
      }
    }
  }
#line 1530
  return;
}
}
#line 1555 "./regexec.c"
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) 
{ 
  reg_errcode_t err ;
  int null_cnt ;
  Idx str_idx ;
  re_node_set cur_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1559
  null_cnt = 0;
#line 1560
  str_idx = sctx->last_str_idx;
#line 1563
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
#line 1563
    if (! ((unsigned long )*(mctx->state_log + str_idx) != (unsigned long )((void *)0))) {
      {
#line 1563
      __builtin_unreachable();
      }
    }
  } else {
    {
#line 1563
    __builtin_unreachable();
    }
  }
  {
#line 1567
  err = re_node_set_init_1(& cur_dest, sctx->last_node);
#line 1568
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1568
  if (tmp) {
#line 1569
    return (err);
  }
  {
#line 1570
  err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1571
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1571
  if (tmp___0) {
#line 1572
    goto free_return;
  }
  {
#line 1575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1575
    if (! (str_idx > 0L)) {
#line 1575
      goto while_break;
    }
#line 1578
    if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
#line 1578
      null_cnt ++;
    } else {
#line 1578
      null_cnt = 0;
    }
#line 1579
    if (null_cnt > (int )mctx->max_mb_elem_len) {
      {
#line 1581
      memset((void *)sctx->sifted_states, '\000', sizeof(re_dfastate_t *) * (unsigned long )str_idx);
#line 1583
      free((void *)cur_dest.elems);
      }
#line 1584
      return ((reg_errcode_t )0);
    }
#line 1586
    cur_dest.nelem = (Idx )0;
#line 1587
    str_idx --;
#line 1589
    if (*(mctx->state_log + str_idx)) {
      {
#line 1591
      err = build_sifted_states(mctx, sctx, str_idx, & cur_dest);
#line 1592
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1592
      if (tmp___1) {
#line 1593
        goto free_return;
      }
    }
    {
#line 1600
    err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1601
    tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1601
    if (tmp___2) {
#line 1602
      goto free_return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1604
  err = (reg_errcode_t )0;
  free_return: 
  {
#line 1606
  free((void *)cur_dest.elems);
  }
#line 1607
  return (err);
}
}
#line 1610 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) build_sifted_states)(re_match_context_t const   *mctx ,
                                                                                    re_sift_context_t *sctx ,
                                                                                    Idx str_idx ,
                                                                                    re_node_set *cur_dest ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *cur_src ;
  Idx i ;
  Idx prev_node ;
  int naccepted ;
  _Bool ok ;
  _Bool tmp ;
  Idx __attribute__((__pure__))  tmp___0 ;
  Idx to_idx ;
  _Bool tmp___1 ;
  long tmp___2 ;

  {
#line 1615
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1616
  cur_src = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->non_eps_nodes);
#line 1626
  i = (Idx )0;
  {
#line 1626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1626
    if (! (i < (Idx )cur_src->nelem)) {
#line 1626
      goto while_break;
    }
#line 1628
    prev_node = *(cur_src->elems + i);
#line 1629
    naccepted = 0;
#line 1631
    if (! (! ((unsigned int )(dfa->nodes + prev_node)->type & 8U))) {
      {
#line 1631
      __builtin_unreachable();
      }
    }
#line 1635
    if ((dfa->nodes + prev_node)->accept_mb) {
      {
#line 1636
      naccepted = sift_states_iter_mb(mctx, sctx, prev_node, str_idx, sctx->last_str_idx);
      }
    }
#line 1642
    if (! naccepted) {
      {
#line 1642
      tmp = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + prev_node),
                              str_idx);
      }
#line 1642
      if (tmp) {
#line 1642
        if ((unsigned long )*(sctx->sifted_states + (str_idx + 1L)) != (unsigned long )((void *)0)) {
          {
#line 1642
          tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1L)))->nodes),
                                         *(dfa->nexts + prev_node));
          }
#line 1642
          if (tmp___0) {
#line 1646
            naccepted = 1;
          }
        }
      }
    }
#line 1648
    if (naccepted == 0) {
#line 1649
      goto __Cont;
    }
#line 1651
    if (sctx->limits.nelem) {
      {
#line 1653
      to_idx = str_idx + (Idx )naccepted;
#line 1654
      tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits), *(dfa->nexts + prev_node),
                                 to_idx, prev_node, str_idx);
      }
#line 1654
      if (tmp___1) {
#line 1657
        goto __Cont;
      }
    }
    {
#line 1659
    ok = re_node_set_insert(cur_dest, prev_node);
#line 1660
    tmp___2 = __builtin_expect((long )(! ok), 0L);
    }
#line 1660
    if (tmp___2) {
#line 1661
      return ((reg_errcode_t )12);
    }
    __Cont: /* CIL Label */ 
#line 1626
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1664
  return ((reg_errcode_t )0);
}
}
#line 1669 "./regexec.c"
static reg_errcode_t clean_state_log_if_needed(re_match_context_t *mctx , Idx next_state_log_idx ) 
{ 
  Idx top ;
  reg_errcode_t err ;
  long tmp ;

  {
#line 1672
  top = mctx->state_log_top;
#line 1674
  if (next_state_log_idx >= mctx->input.bufs_len) {
#line 1674
    if (mctx->input.bufs_len < mctx->input.len) {
#line 1674
      goto _L;
    } else {
#line 1674
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1674
  if (next_state_log_idx >= mctx->input.valid_len) {
#line 1674
    if (mctx->input.valid_len < mctx->input.len) {
      _L: /* CIL Label */ 
      {
#line 1680
      err = extend_buffers(mctx, (int )(next_state_log_idx + 1L));
#line 1681
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1681
      if (tmp) {
#line 1682
        return (err);
      }
    }
  }
#line 1685
  if (top < next_state_log_idx) {
    {
#line 1687
    memset((void *)((mctx->state_log + top) + 1), '\000', sizeof(re_dfastate_t *) * (unsigned long )(next_state_log_idx - top));
#line 1689
    mctx->state_log_top = next_state_log_idx;
    }
  }
#line 1691
  return ((reg_errcode_t )0);
}
}
#line 1694 "./regexec.c"
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) 
{ 
  Idx st_idx ;
  reg_errcode_t err ;
  re_node_set merged_set ;
  long tmp ;
  long tmp___0 ;

  {
#line 1700
  st_idx = (Idx )0;
  {
#line 1700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1700
    if (! (st_idx < num)) {
#line 1700
      goto while_break;
    }
#line 1702
    if ((unsigned long )*(dst + st_idx) == (unsigned long )((void *)0)) {
#line 1703
      *(dst + st_idx) = *(src + st_idx);
    } else
#line 1704
    if ((unsigned long )*(src + st_idx) != (unsigned long )((void *)0)) {
      {
#line 1707
      err = re_node_set_init_union(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                   (re_node_set const   *)(& (*(src + st_idx))->nodes));
#line 1709
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1709
      if (tmp) {
#line 1710
        return (err);
      }
      {
#line 1711
      *(dst + st_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& merged_set));
#line 1712
      free((void *)merged_set.elems);
#line 1713
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1713
      if (tmp___0) {
#line 1714
        return (err);
      }
    }
#line 1700
    st_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1717
  return ((reg_errcode_t )0);
}
}
#line 1720 "./regexec.c"
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  re_node_set const   *candidates ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1725
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1726
  err = (reg_errcode_t )0;
#line 1728
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1728
    candidates = (re_node_set const   *)((void *)0);
  } else {
#line 1728
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
#line 1731
  if (dest_nodes->nelem == 0L) {
#line 1732
    *(sctx->sifted_states + str_idx) = (re_dfastate_t *)((void *)0);
  } else {
#line 1735
    if (candidates) {
      {
#line 1739
      err = add_epsilon_src_nodes(dfa, dest_nodes, candidates);
#line 1740
      tmp = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1740
      if (tmp) {
#line 1741
        return (err);
      }
#line 1744
      if (sctx->limits.nelem) {
        {
#line 1746
        err = check_subexp_limits(dfa, dest_nodes, candidates, & sctx->limits, (struct re_backref_cache_entry *)mctx->bkref_ents,
                                  str_idx);
#line 1748
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 1748
        if (tmp___0) {
#line 1749
          return (err);
        }
      }
    }
    {
#line 1753
    *(sctx->sifted_states + str_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1754
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1754
    if (tmp___1) {
#line 1755
      return (err);
    }
  }
#line 1758
  if (candidates) {
#line 1758
    if ((*(mctx->state_log + str_idx))->has_backref) {
      {
#line 1760
      err = sift_states_bkref(mctx, sctx, str_idx, candidates);
#line 1761
      tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1761
      if (tmp___2) {
#line 1762
        return (err);
      }
    }
  }
#line 1764
  return ((reg_errcode_t )0);
}
}
#line 1767 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) add_epsilon_src_nodes)(re_dfa_t const   *dfa ,
                                                                                      re_node_set *dest_nodes ,
                                                                                      re_node_set const   *candidates ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  re_dfastate_t *state ;
  re_dfastate_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  reg_errcode_t tmp___3 ;

  {
  {
#line 1772
  err = (reg_errcode_t )0;
#line 1775
  tmp = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1775
  state = tmp;
#line 1776
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 1776
  if (tmp___0) {
#line 1777
    return (err);
  }
#line 1779
  if (! state->inveclosure.alloc) {
    {
#line 1781
    err = re_node_set_alloc(& state->inveclosure, dest_nodes->nelem);
#line 1782
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 1782
    if (tmp___1) {
#line 1783
      return ((reg_errcode_t )12);
    }
#line 1784
    i = (Idx )0;
    {
#line 1784
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1784
      if (! (i < dest_nodes->nelem)) {
#line 1784
        goto while_break;
      }
      {
#line 1786
      err = re_node_set_merge(& state->inveclosure, (re_node_set const   *)(dfa->inveclosures + *(dest_nodes->elems + i)));
#line 1788
      tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 1788
      if (tmp___2) {
#line 1789
        return ((reg_errcode_t )12);
      }
#line 1784
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1792
  tmp___3 = re_node_set_add_intersect(dest_nodes, candidates, (re_node_set const   *)(& state->inveclosure));
  }
#line 1792
  return (tmp___3);
}
}
#line 1796 "./regexec.c"
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t const   *dfa , Idx node , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  Idx ecl_idx ;
  reg_errcode_t err ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  Idx cur_node ;
  Idx edst1 ;
  Idx edst2 ;
  Idx tmp ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx __attribute__((__pure__))  tmp___3 ;
  Idx __attribute__((__pure__))  tmp___4 ;
  Idx cur_node___0 ;
  Idx idx ;
  Idx __attribute__((__pure__))  tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;

  {
  {
#line 1802
  inv_eclosure = (re_node_set *)(dfa->inveclosures + node);
#line 1804
  memset((void *)(& except_nodes), '\000', sizeof(re_node_set ));
#line 1805
  ecl_idx = (Idx )0;
  }
  {
#line 1805
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1805
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1805
      goto while_break;
    }
#line 1807
    cur_node = *(inv_eclosure->elems + ecl_idx);
#line 1808
    if (cur_node == node) {
#line 1809
      goto __Cont;
    }
#line 1810
    if ((unsigned int )(dfa->nodes + cur_node)->type & 8U) {
#line 1812
      edst1 = *((dfa->edests + cur_node)->elems + 0);
#line 1813
      if ((dfa->edests + cur_node)->nelem > 1L) {
#line 1813
        tmp = *((dfa->edests + cur_node)->elems + 1);
      } else {
#line 1813
        tmp = (Idx )-1;
      }
      {
#line 1813
      edst2 = tmp;
#line 1815
      tmp___1 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst1);
      }
#line 1815
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 1815
        if (edst2 > 0L) {
          {
#line 1815
          tmp___3 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst2);
          }
#line 1815
          if (! tmp___3) {
            {
#line 1815
            tmp___4 = re_node_set_contains((re_node_set const   *)dest_nodes, edst2);
            }
#line 1815
            if (tmp___4) {
              _L: /* CIL Label */ 
              {
#line 1821
              err = re_node_set_add_intersect(& except_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + cur_node));
#line 1823
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
              }
#line 1823
              if (tmp___0) {
                {
#line 1825
                free((void *)except_nodes.elems);
                }
#line 1826
                return (err);
              }
            }
          }
        }
      } else {
        {
#line 1815
        tmp___2 = re_node_set_contains((re_node_set const   *)dest_nodes, edst1);
        }
#line 1815
        if (tmp___2) {
#line 1815
          goto _L;
        } else {
#line 1815
          goto _L___0;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1805
    ecl_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1831
  ecl_idx = (Idx )0;
  {
#line 1831
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1831
    if (! (ecl_idx < inv_eclosure->nelem)) {
#line 1831
      goto while_break___0;
    }
    {
#line 1833
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
#line 1834
    tmp___6 = re_node_set_contains((re_node_set const   *)(& except_nodes), cur_node___0);
    }
#line 1834
    if (! tmp___6) {
      {
#line 1836
      tmp___5 = re_node_set_contains((re_node_set const   *)dest_nodes, cur_node___0);
#line 1836
      idx = (Idx )(tmp___5 - (Idx __attribute__((__pure__))  )1);
#line 1837
      re_node_set_remove_at(dest_nodes, idx);
      }
    }
#line 1831
    ecl_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1840
  free((void *)except_nodes.elems);
  }
#line 1841
  return ((reg_errcode_t )0);
}
}
#line 1844 "./regexec.c"
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx lim_idx ;
  Idx src_pos ;
  Idx dst_pos ;
  Idx dst_bkref_idx ;
  Idx tmp ;
  Idx src_bkref_idx ;
  Idx tmp___0 ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1848
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1851
  tmp = search_cur_bkref_entry(mctx, dst_idx);
#line 1851
  dst_bkref_idx = tmp;
#line 1852
  tmp___0 = search_cur_bkref_entry(mctx, src_idx);
#line 1852
  src_bkref_idx = tmp___0;
#line 1853
  lim_idx = (Idx )0;
  }
  {
#line 1853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1853
    if (! (lim_idx < (Idx )limits->nelem)) {
#line 1853
      goto while_break;
    }
    {
#line 1857
    ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + *(limits->elems + lim_idx));
#line 1858
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 1860
    tmp___1 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        dst_node, dst_idx, dst_bkref_idx);
#line 1860
    dst_pos = (Idx )tmp___1;
#line 1863
    tmp___2 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        src_node, src_idx, src_bkref_idx);
#line 1863
    src_pos = (Idx )tmp___2;
    }
#line 1871
    if (! (src_pos == dst_pos)) {
#line 1874
      return ((_Bool)1);
    }
#line 1853
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1876
  return ((_Bool)0);
}
}
#line 1879 "./regexec.c"
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *eclosures ;
  Idx node_idx ;
  Idx node ;
  struct re_backref_cache_entry *ent ;
  Idx dst ;
  int cpos ;
  struct re_backref_cache_entry *tmp ;
  int tmp___0 ;

  {
#line 1883
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1884
  eclosures = (re_node_set const   *)(dfa->eclosures + from_node);
#line 1889
  node_idx = (Idx )0;
  {
#line 1889
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1889
    if (! (node_idx < (Idx )eclosures->nelem)) {
#line 1889
      goto while_break;
    }
#line 1891
    node = *(eclosures->elems + node_idx);
    {
#line 1894
    if ((unsigned int )(dfa->nodes + node)->type == 4U) {
#line 1894
      goto case_4;
    }
#line 1942
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 1942
      goto case_8;
    }
#line 1947
    if ((unsigned int )(dfa->nodes + node)->type == 9U) {
#line 1947
      goto case_9;
    }
#line 1952
    goto switch_default;
    case_4: /* CIL Label */ 
#line 1895
    if (bkref_idx != -1L) {
#line 1897
      ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + bkref_idx);
      {
#line 1898
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1903
        if (ent->node != node) {
#line 1904
          goto __Cont;
        }
#line 1906
        if (subexp_idx < 64L) {
#line 1906
          if (! (ent->eps_reachable_subexps_map & (1UL << subexp_idx))) {
#line 1909
            goto __Cont;
          }
        }
#line 1917
        dst = *((dfa->edests + node)->elems + 0);
#line 1918
        if (dst == from_node) {
#line 1920
          if (boundaries & 1) {
#line 1921
            return (-1);
          } else {
#line 1923
            return (0);
          }
        }
        {
#line 1926
        cpos = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, dst, bkref_idx);
        }
#line 1929
        if (cpos == -1) {
#line 1930
          return (-1);
        }
#line 1931
        if (cpos == 0) {
#line 1931
          if (boundaries & 2) {
#line 1932
            return (0);
          }
        }
#line 1934
        if (subexp_idx < 64L) {
#line 1935
          ent->eps_reachable_subexps_map &= ~ (1UL << subexp_idx);
        }
        __Cont: /* CIL Label */ 
#line 1898
        tmp = ent;
#line 1898
        ent ++;
#line 1898
        if (! tmp->more) {
#line 1898
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1940
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1943
    if (boundaries & 1) {
#line 1943
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 1944
        return (-1);
      }
    }
#line 1945
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1948
    if (boundaries & 2) {
#line 1948
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 1949
        return (0);
      }
    }
#line 1950
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1953
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1889
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1957
  if (boundaries & 2) {
#line 1957
    tmp___0 = 1;
  } else {
#line 1957
    tmp___0 = 0;
  }
#line 1957
  return (tmp___0);
}
}
#line 1960 "./regexec.c"
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) 
{ 
  struct re_backref_cache_entry *lim ;
  int boundaries ;
  int tmp ;

  {
#line 1965
  lim = (struct re_backref_cache_entry *)(mctx->bkref_ents + limit);
#line 1969
  if (str_idx < lim->subexp_from) {
#line 1970
    return (-1);
  }
#line 1972
  if (lim->subexp_to < str_idx) {
#line 1973
    return (1);
  }
#line 1976
  boundaries = str_idx == lim->subexp_from;
#line 1977
  boundaries |= (str_idx == lim->subexp_to) << 1;
#line 1978
  if (boundaries == 0) {
#line 1979
    return (0);
  }
  {
#line 1982
  tmp = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, from_node, bkref_idx);
  }
#line 1982
  return (tmp);
}
}
#line 1989 "./regexec.c"
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) 
{ 
  reg_errcode_t err ;
  Idx node_idx ;
  Idx lim_idx ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  Idx ops_node ;
  Idx cls_node ;
  Idx node ;
  re_token_type_t type ;
  long tmp ;
  Idx node___0 ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx node___1 ;
  re_token_type_t type___0 ;
  long tmp___3 ;

  {
#line 1997
  lim_idx = (Idx )0;
  {
#line 1997
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1997
    if (! (lim_idx < limits->nelem)) {
#line 1997
      goto while_break;
    }
#line 2001
    ent = bkref_ents + *(limits->elems + lim_idx);
#line 2003
    if (str_idx <= ent->subexp_from) {
#line 2004
      goto __Cont;
    } else
#line 2003
    if (ent->str_idx < str_idx) {
#line 2004
      goto __Cont;
    }
#line 2006
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 2007
    if (ent->subexp_to == str_idx) {
#line 2009
      ops_node = (Idx )-1;
#line 2010
      cls_node = (Idx )-1;
#line 2011
      node_idx = (Idx )0;
      {
#line 2011
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2011
        if (! (node_idx < dest_nodes->nelem)) {
#line 2011
          goto while_break___0;
        }
#line 2013
        node = *(dest_nodes->elems + node_idx);
#line 2014
        type = (dfa->nodes + node)->type;
#line 2015
        if ((unsigned int )type == 8U) {
#line 2015
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2017
            ops_node = node;
          } else {
#line 2015
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2018
        if ((unsigned int )type == 9U) {
#line 2018
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2020
            cls_node = node;
          }
        }
#line 2011
        node_idx ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2025
      if (ops_node >= 0L) {
        {
#line 2027
        err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes, candidates);
#line 2029
        tmp = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2029
        if (tmp) {
#line 2030
          return (err);
        }
      }
#line 2034
      if (cls_node >= 0L) {
#line 2035
        node_idx = (Idx )0;
        {
#line 2035
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2035
          if (! (node_idx < dest_nodes->nelem)) {
#line 2035
            goto while_break___1;
          }
          {
#line 2037
          node___0 = *(dest_nodes->elems + node_idx);
#line 2038
          tmp___1 = re_node_set_contains((re_node_set const   *)(dfa->inveclosures + node___0),
                                         cls_node);
          }
#line 2038
          if (! tmp___1) {
            {
#line 2038
            tmp___2 = re_node_set_contains((re_node_set const   *)(dfa->eclosures + node___0),
                                           cls_node);
            }
#line 2038
            if (! tmp___2) {
              {
#line 2045
              err = sub_epsilon_src_nodes(dfa, node___0, dest_nodes, candidates);
#line 2047
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
              }
#line 2047
              if (tmp___0) {
#line 2048
                return (err);
              }
#line 2049
              node_idx --;
            }
          }
#line 2035
          node_idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    } else {
#line 2055
      node_idx = (Idx )0;
      {
#line 2055
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2055
        if (! (node_idx < dest_nodes->nelem)) {
#line 2055
          goto while_break___2;
        }
#line 2057
        node___1 = *(dest_nodes->elems + node_idx);
#line 2058
        type___0 = (dfa->nodes + node___1)->type;
#line 2059
        if ((unsigned int )type___0 == 9U) {
#line 2059
          goto _L___0;
        } else
#line 2059
        if ((unsigned int )type___0 == 8U) {
          _L___0: /* CIL Label */ 
#line 2061
          if (subexp_idx != (dfa->nodes + node___1)->opr.idx) {
#line 2062
            goto __Cont___0;
          }
          {
#line 2065
          err = sub_epsilon_src_nodes(dfa, node___1, dest_nodes, candidates);
#line 2067
          tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2067
          if (tmp___3) {
#line 2068
            return (err);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 2055
        node_idx ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1997
    lim_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2073
  return ((reg_errcode_t )0);
}
}
#line 2076 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) sift_states_bkref)(re_match_context_t const   *mctx ,
                                                                                  re_sift_context_t *sctx ,
                                                                                  Idx str_idx ,
                                                                                  re_node_set const   *candidates ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx node_idx ;
  Idx node ;
  re_sift_context_t local_sctx ;
  Idx first_idx ;
  Idx tmp ;
  Idx enabled_idx ;
  re_token_type_t type ;
  struct re_backref_cache_entry *entry ;
  Idx subexp_len ;
  Idx to_idx ;
  Idx dst_node ;
  _Bool ok ;
  re_dfastate_t *cur_state ;
  Idx __attribute__((__pure__))  tmp___0 ;
  _Bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  struct re_backref_cache_entry *tmp___7 ;

  {
  {
#line 2081
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2085
  tmp = search_cur_bkref_entry(mctx, str_idx);
#line 2085
  first_idx = tmp;
  }
#line 2087
  if (first_idx == -1L) {
#line 2088
    return ((reg_errcode_t )0);
  }
#line 2090
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
#line 2092
  node_idx = (Idx )0;
  {
#line 2092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2092
    if (! (node_idx < (Idx )candidates->nelem)) {
#line 2092
      goto while_break;
    }
#line 2097
    node = *(candidates->elems + node_idx);
#line 2098
    type = (dfa->nodes + node)->type;
#line 2100
    if (node == sctx->last_node) {
#line 2100
      if (str_idx == sctx->last_str_idx) {
#line 2101
        goto __Cont;
      }
    }
#line 2102
    if ((unsigned int )type != 4U) {
#line 2103
      goto __Cont;
    }
#line 2105
    entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + first_idx);
#line 2106
    enabled_idx = first_idx;
    {
#line 2107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2115
      if (entry->node != node) {
#line 2116
        goto __Cont___0;
      }
#line 2117
      subexp_len = entry->subexp_to - entry->subexp_from;
#line 2118
      to_idx = str_idx + subexp_len;
#line 2119
      if (subexp_len) {
#line 2119
        dst_node = *(dfa->nexts + node);
      } else {
#line 2119
        dst_node = *((dfa->edests + node)->elems + 0);
      }
#line 2122
      if (to_idx > sctx->last_str_idx) {
#line 2127
        goto __Cont___0;
      } else
#line 2122
      if ((unsigned long )*(sctx->sifted_states + to_idx) == (unsigned long )((void *)0)) {
#line 2127
        goto __Cont___0;
      } else
#line 2122
      if ((unsigned long )*(sctx->sifted_states + to_idx) != (unsigned long )((void *)0)) {
        {
#line 2122
        tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                       dst_node);
        }
#line 2122
        if (tmp___0) {
          {
#line 2122
          tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits),
                                     node, str_idx, dst_node, to_idx);
          }
#line 2122
          if (tmp___1) {
#line 2127
            goto __Cont___0;
          }
        } else {
#line 2127
          goto __Cont___0;
        }
      } else {
#line 2127
        goto __Cont___0;
      }
#line 2129
      if ((unsigned long )local_sctx.sifted_states == (unsigned long )((void *)0)) {
        {
#line 2131
        local_sctx = *sctx;
#line 2132
        err = re_node_set_init_copy(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
#line 2133
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2133
        if (tmp___2) {
#line 2134
          goto free_return;
        }
      }
      {
#line 2136
      local_sctx.last_node = node;
#line 2137
      local_sctx.last_str_idx = str_idx;
#line 2138
      ok = re_node_set_insert(& local_sctx.limits, enabled_idx);
#line 2139
      tmp___3 = __builtin_expect((long )(! ok), 0L);
      }
#line 2139
      if (tmp___3) {
#line 2141
        err = (reg_errcode_t )12;
#line 2142
        goto free_return;
      }
      {
#line 2144
      cur_state = *(local_sctx.sifted_states + str_idx);
#line 2145
      err = sift_states_backward(mctx, & local_sctx);
#line 2146
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2146
      if (tmp___4) {
#line 2147
        goto free_return;
      }
#line 2148
      if ((unsigned long )sctx->limited_states != (unsigned long )((void *)0)) {
        {
#line 2150
        err = merge_state_array(dfa, sctx->limited_states, local_sctx.sifted_states,
                                str_idx + 1L);
#line 2153
        tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2153
        if (tmp___5) {
#line 2154
          goto free_return;
        }
      }
      {
#line 2156
      *(local_sctx.sifted_states + str_idx) = cur_state;
#line 2157
      tmp___6 = re_node_set_contains((re_node_set const   *)(& local_sctx.limits),
                                     enabled_idx);
#line 2157
      re_node_set_remove_at(& local_sctx.limits, (Idx )(tmp___6 - (Idx __attribute__((__pure__))  )1));
#line 2160
      entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + enabled_idx);
      }
      __Cont___0: /* CIL Label */ 
#line 2107
      enabled_idx ++;
#line 2107
      tmp___7 = entry;
#line 2107
      entry ++;
#line 2107
      if (! tmp___7->more) {
#line 2107
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2092
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2164
  err = (reg_errcode_t )0;
  free_return: 
#line 2166
  if ((unsigned long )local_sctx.sifted_states != (unsigned long )((void *)0)) {
    {
#line 2168
    free((void *)local_sctx.limits.elems);
    }
  }
#line 2171
  return (err);
}
}
#line 2176 "./regexec.c"
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  int naccepted ;
  Idx __attribute__((__pure__))  tmp ;

  {
  {
#line 2180
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2183
  naccepted = check_node_accept_bytes(dfa, node_idx, & mctx->input, str_idx);
  }
#line 2184
  if (naccepted > 0) {
#line 2184
    if (str_idx + (Idx )naccepted <= max_str_idx) {
#line 2184
      if ((unsigned long )*(sctx->sifted_states + (str_idx + (Idx )naccepted)) != (unsigned long )((void *)0)) {
        {
#line 2184
        tmp = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + (Idx )naccepted)))->nodes),
                                   *(dfa->nexts + node_idx));
        }
#line 2184
        if (! tmp) {
#line 2190
          naccepted = 0;
        }
      } else {
#line 2190
        naccepted = 0;
      }
    }
  }
#line 2193
  return (naccepted);
}
}
#line 2205 "./regexec.c"
static re_dfastate_t *( __attribute__((__warn_unused_result__)) transit_state)(reg_errcode_t *err ,
                                                                               re_match_context_t *mctx ,
                                                                               re_dfastate_t *state ) 
{ 
  re_dfastate_t **trtable ;
  unsigned char ch ;
  long tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  long tmp___2 ;
  unsigned int context ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 2215
  tmp___0 = __builtin_expect((long )state->accept_mb, 0L);
  }
#line 2215
  if (tmp___0) {
    {
#line 2217
    *err = transit_state_mb(mctx, state);
#line 2218
    tmp = __builtin_expect((long )((int )*err != 0), 0L);
    }
#line 2218
    if (tmp) {
#line 2219
      return ((re_dfastate_t *)((void *)0));
    }
  }
#line 2231
  tmp___1 = mctx->input.cur_idx;
#line 2231
  (mctx->input.cur_idx) ++;
#line 2231
  ch = *(mctx->input.mbs + tmp___1);
  {
#line 2232
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2234
    trtable = state->trtable;
#line 2235
    tmp___2 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2235
    if (tmp___2) {
#line 2236
      return (*(trtable + ch));
    }
    {
#line 2238
    trtable = state->word_trtable;
#line 2239
    tmp___3 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
    }
#line 2239
    if (tmp___3) {
      {
#line 2242
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1L,
                                     mctx->eflags);
      }
#line 2246
      if (context & 1U) {
#line 2247
        return (*(trtable + ((int )ch + 256)));
      } else {
#line 2249
        return (*(trtable + ch));
      }
    }
    {
#line 2252
    tmp___4 = build_trtable(mctx->dfa, state);
    }
#line 2252
    if (! tmp___4) {
#line 2254
      *err = (reg_errcode_t )12;
#line 2255
      return ((re_dfastate_t *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2263 "./regexec.c"
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) 
{ 
  re_dfa_t const   *dfa ;
  Idx cur_idx ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  long tmp ;
  re_dfastate_t *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2267
  dfa = mctx->dfa;
#line 2268
  cur_idx = mctx->input.cur_idx;
#line 2270
  if (cur_idx > mctx->state_log_top) {
#line 2272
    *(mctx->state_log + cur_idx) = next_state;
#line 2273
    mctx->state_log_top = cur_idx;
  } else
#line 2275
  if ((unsigned long )*(mctx->state_log + cur_idx) == (unsigned long )((re_dfastate_t *)0)) {
#line 2277
    *(mctx->state_log + cur_idx) = next_state;
  } else {
#line 2283
    table_nodes = (re_node_set *)((void *)0);
#line 2288
    pstate = *(mctx->state_log + cur_idx);
#line 2289
    log_nodes = pstate->entrance_nodes;
#line 2290
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2292
      table_nodes = next_state->entrance_nodes;
#line 2293
      *err = re_node_set_init_union(& next_nodes, (re_node_set const   *)table_nodes,
                                    (re_node_set const   *)log_nodes);
#line 2295
      tmp = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 2295
      if (tmp) {
#line 2296
        return ((re_dfastate_t *)((void *)0));
      }
    } else {
#line 2299
      next_nodes = *log_nodes;
    }
    {
#line 2303
    context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1L,
                                   mctx->eflags);
#line 2306
    tmp___0 = re_acquire_state_context(err, dfa, (re_node_set const   *)(& next_nodes),
                                       context);
#line 2306
    *(mctx->state_log + cur_idx) = tmp___0;
#line 2306
    next_state = tmp___0;
    }
#line 2311
    if ((unsigned long )table_nodes != (unsigned long )((void *)0)) {
      {
#line 2312
      free((void *)next_nodes.elems);
      }
    }
  }
  {
#line 2315
  tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
  }
#line 2315
  if (tmp___3) {
#line 2315
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
      {
#line 2320
      *err = check_subexp_matching_top(mctx, & next_state->nodes, cur_idx);
#line 2322
      tmp___1 = __builtin_expect((long )((int )*err != 0), 0L);
      }
#line 2322
      if (tmp___1) {
#line 2323
        return ((re_dfastate_t *)((void *)0));
      }
#line 2326
      if (next_state->has_backref) {
        {
#line 2328
        *err = transit_state_bkref(mctx, (re_node_set const   *)(& next_state->nodes));
#line 2329
        tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
        }
#line 2329
        if (tmp___2) {
#line 2330
          return ((re_dfastate_t *)((void *)0));
        }
#line 2331
        next_state = *(mctx->state_log + cur_idx);
      }
    }
  }
#line 2335
  return (next_state);
}
}
#line 2341 "./regexec.c"
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) 
{ 
  re_dfastate_t *cur_state ;
  Idx max ;
  Idx cur_str_idx ;

  {
  {
#line 2345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2347
    max = mctx->state_log_top;
#line 2348
    cur_str_idx = mctx->input.cur_idx;
    {
#line 2350
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2352
      cur_str_idx ++;
#line 2352
      if (cur_str_idx > max) {
#line 2353
        return ((re_dfastate_t *)((void *)0));
      }
#line 2354
      (mctx->input.cur_idx) ++;
#line 2350
      if (! ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0))) {
#line 2350
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2358
    cur_state = merge_state_with_log(err, mctx, (re_dfastate_t *)((void *)0));
    }
#line 2345
    if ((int )*err == 0) {
#line 2345
      if (! ((unsigned long )cur_state == (unsigned long )((void *)0))) {
#line 2345
        goto while_break;
      }
    } else {
#line 2345
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2361
  return (cur_state);
}
}
#line 2371 "./regexec.c"
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx node_idx ;
  reg_errcode_t err ;
  Idx node ;
  long tmp ;

  {
#line 2375
  dfa = mctx->dfa;
#line 2384
  node_idx = (Idx )0;
  {
#line 2384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2384
    if (! (node_idx < cur_nodes->nelem)) {
#line 2384
      goto while_break;
    }
#line 2386
    node = *(cur_nodes->elems + node_idx);
#line 2387
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 2387
      if ((dfa->nodes + node)->opr.idx < 64L) {
#line 2387
        if (dfa->used_bkref_map & (unsigned long const   )(1UL << (dfa->nodes + node)->opr.idx)) {
          {
#line 2392
          err = match_ctx_add_subtop(mctx, node, str_idx);
#line 2393
          tmp = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2393
          if (tmp) {
#line 2394
            return (err);
          }
        }
      }
    }
#line 2384
    node_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2397
  return ((reg_errcode_t )0);
}
}
#line 2443 "./regexec.c"
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  re_node_set dest_nodes ;
  re_node_set *new_nodes ;
  Idx cur_node_idx ;
  int naccepted ;
  Idx dest_idx ;
  unsigned int context ;
  re_dfastate_t *dest_state ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2446
  dfa = mctx->dfa;
#line 2450
  i = (Idx )0;
  {
#line 2450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2450
    if (! (i < pstate->nodes.nelem)) {
#line 2450
      goto while_break;
    }
#line 2453
    cur_node_idx = *(pstate->nodes.elems + i);
#line 2459
    if (! (dfa->nodes + cur_node_idx)->accept_mb) {
#line 2460
      goto __Cont;
    }
#line 2462
    if ((dfa->nodes + cur_node_idx)->constraint) {
      {
#line 2464
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx,
                                     mctx->eflags);
      }
#line 2467
      if ((dfa->nodes + cur_node_idx)->constraint & 4U) {
#line 2467
        if (! (context & 1U)) {
#line 2469
          goto __Cont;
        } else {
#line 2467
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2467
      if ((dfa->nodes + cur_node_idx)->constraint & 8U) {
#line 2467
        if (context & 1U) {
#line 2469
          goto __Cont;
        } else {
#line 2467
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2467
      if ((dfa->nodes + cur_node_idx)->constraint & 32U) {
#line 2467
        if (! (context & (unsigned int )(1 << 1))) {
#line 2469
          goto __Cont;
        } else {
#line 2467
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2467
      if ((dfa->nodes + cur_node_idx)->constraint & 128U) {
#line 2467
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2469
          goto __Cont;
        }
      }
    }
    {
#line 2473
    naccepted = check_node_accept_bytes(dfa, cur_node_idx, (re_string_t const   *)(& mctx->input),
                                        mctx->input.cur_idx);
    }
#line 2475
    if (naccepted == 0) {
#line 2476
      goto __Cont;
    }
#line 2479
    dest_idx = mctx->input.cur_idx + (Idx )naccepted;
#line 2480
    if (mctx->max_mb_elem_len < naccepted) {
#line 2480
      mctx->max_mb_elem_len = naccepted;
    } else {
#line 2480
      mctx->max_mb_elem_len = mctx->max_mb_elem_len;
    }
    {
#line 2482
    err = clean_state_log_if_needed(mctx, dest_idx);
#line 2483
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2483
    if (tmp) {
#line 2484
      return (err);
    }
#line 2485
    if (! (*(dfa->nexts + cur_node_idx) != -1L)) {
      {
#line 2485
      __builtin_unreachable();
      }
    }
#line 2486
    new_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + cur_node_idx));
#line 2488
    dest_state = *(mctx->state_log + dest_idx);
#line 2489
    if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
#line 2490
      dest_nodes = *new_nodes;
    } else {
      {
#line 2493
      err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                   (re_node_set const   *)new_nodes);
#line 2495
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2495
      if (tmp___0) {
#line 2496
        return (err);
      }
    }
    {
#line 2498
    context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_idx - 1L,
                                   mctx->eflags);
#line 2500
    *(mctx->state_log + dest_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                             context);
    }
#line 2502
    if ((unsigned long )dest_state != (unsigned long )((void *)0)) {
      {
#line 2503
      free((void *)dest_nodes.elems);
      }
    }
#line 2504
    if ((unsigned long )*(mctx->state_log + dest_idx) == (unsigned long )((void *)0)) {
#line 2504
      if ((int )err != 0) {
#line 2504
        tmp___1 = 1;
      } else {
#line 2504
        tmp___1 = 0;
      }
    } else {
#line 2504
      tmp___1 = 0;
    }
    {
#line 2504
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
    }
#line 2504
    if (tmp___2) {
#line 2506
      return (err);
    }
    __Cont: /* CIL Label */ 
#line 2450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2508
  return ((reg_errcode_t )0);
}
}
#line 2512 "./regexec.c"
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  Idx cur_str_idx ;
  Idx dest_str_idx ;
  Idx prev_nelem ;
  Idx bkc_idx ;
  Idx node_idx ;
  unsigned int context ;
  re_token_t const   *node ;
  re_node_set *new_dest_nodes ;
  long tmp ;
  Idx subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  int tmp___0 ;
  long tmp___1 ;
  re_node_set dest_nodes ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 2515
  dfa = mctx->dfa;
#line 2518
  cur_str_idx = mctx->input.cur_idx;
#line 2520
  i = (Idx )0;
  {
#line 2520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2520
    if (! (i < (Idx )nodes->nelem)) {
#line 2520
      goto while_break;
    }
#line 2523
    node_idx = *(nodes->elems + i);
#line 2525
    node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 2529
    if ((unsigned int const   )node->type != 4U) {
#line 2530
      goto __Cont;
    }
#line 2532
    if (node->constraint) {
      {
#line 2534
      context = re_string_context_at((re_string_t const   *)(& mctx->input), cur_str_idx,
                                     mctx->eflags);
      }
#line 2536
      if (node->constraint & 4U) {
#line 2536
        if (! (context & 1U)) {
#line 2537
          goto __Cont;
        } else {
#line 2536
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2536
      if (node->constraint & 8U) {
#line 2536
        if (context & 1U) {
#line 2537
          goto __Cont;
        } else {
#line 2536
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2536
      if (node->constraint & 32U) {
#line 2536
        if (! (context & (unsigned int )(1 << 1))) {
#line 2537
          goto __Cont;
        } else {
#line 2536
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2536
      if (node->constraint & 128U) {
#line 2536
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2537
          goto __Cont;
        }
      }
    }
    {
#line 2542
    bkc_idx = mctx->nbkref_ents;
#line 2543
    err = get_subexp(mctx, node_idx, cur_str_idx);
#line 2544
    tmp = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2544
    if (tmp) {
#line 2545
      goto free_return;
    }
#line 2549
    if (! (*(dfa->nexts + node_idx) != -1L)) {
      {
#line 2549
      __builtin_unreachable();
      }
    }
    {
#line 2550
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2550
      if (! (bkc_idx < mctx->nbkref_ents)) {
#line 2550
        goto while_break___0;
      }
#line 2555
      bkref_ent = mctx->bkref_ents + bkc_idx;
#line 2556
      if (bkref_ent->node != node_idx) {
#line 2557
        goto __Cont___0;
      } else
#line 2556
      if (bkref_ent->str_idx != cur_str_idx) {
#line 2557
        goto __Cont___0;
      }
#line 2558
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
#line 2559
      if (subexp_len == 0L) {
#line 2559
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *((dfa->edests + node_idx)->elems + 0));
      } else {
#line 2559
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + node_idx));
      }
      {
#line 2562
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
#line 2564
      context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_str_idx - 1L,
                                     mctx->eflags);
#line 2566
      dest_state = *(mctx->state_log + dest_str_idx);
      }
#line 2567
      if ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0)) {
#line 2567
        prev_nelem = (Idx )0;
      } else {
#line 2567
        prev_nelem = (*(mctx->state_log + cur_str_idx))->nodes.nelem;
      }
#line 2570
      if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
        {
#line 2572
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)new_dest_nodes,
                                                                     context);
        }
#line 2575
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2575
          if ((int )err != 0) {
#line 2575
            tmp___0 = 1;
          } else {
#line 2575
            tmp___0 = 0;
          }
        } else {
#line 2575
          tmp___0 = 0;
        }
        {
#line 2575
        tmp___1 = __builtin_expect((long )tmp___0, 0L);
        }
#line 2575
        if (tmp___1) {
#line 2577
          goto free_return;
        }
      } else {
        {
#line 2582
        err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                     (re_node_set const   *)new_dest_nodes);
#line 2585
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2585
        if (tmp___2) {
          {
#line 2587
          free((void *)dest_nodes.elems);
          }
#line 2588
          goto free_return;
        }
        {
#line 2590
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                                     context);
#line 2592
        free((void *)dest_nodes.elems);
        }
#line 2593
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2593
          if ((int )err != 0) {
#line 2593
            tmp___3 = 1;
          } else {
#line 2593
            tmp___3 = 0;
          }
        } else {
#line 2593
          tmp___3 = 0;
        }
        {
#line 2593
        tmp___4 = __builtin_expect((long )tmp___3, 0L);
        }
#line 2593
        if (tmp___4) {
#line 2595
          goto free_return;
        }
      }
#line 2599
      if (subexp_len == 0L) {
#line 2599
        if ((*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
          {
#line 2602
          err = check_subexp_matching_top(mctx, new_dest_nodes, cur_str_idx);
#line 2604
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2604
          if (tmp___5) {
#line 2605
            goto free_return;
          }
          {
#line 2606
          err = transit_state_bkref(mctx, (re_node_set const   *)new_dest_nodes);
#line 2607
          tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2607
          if (tmp___6) {
#line 2608
            goto free_return;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2550
      bkc_idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2520
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2612
  err = (reg_errcode_t )0;
  free_return: 
#line 2614
  return (err);
}
}
#line 2623 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) get_subexp)(re_match_context_t *mctx ,
                                                                           Idx bkref_node ,
                                                                           Idx bkref_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx subexp_num ;
  Idx sub_top_idx ;
  char const   *buf ;
  Idx cache_idx ;
  Idx tmp ;
  struct re_backref_cache_entry  const  *entry ;
  struct re_backref_cache_entry  const  *tmp___0 ;
  reg_errcode_t err ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  Idx sub_last_idx ;
  Idx sl_str ;
  Idx bkref_str_off ;
  regoff_t sl_str_diff ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  Idx cls_node ;
  regoff_t sl_str_off ;
  re_node_set const   *nodes ;
  long tmp___5 ;
  long tmp___6 ;
  Idx tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;

  {
  {
#line 2627
  dfa = mctx->dfa;
#line 2629
  buf = (char const   *)mctx->input.mbs;
#line 2631
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, bkref_str_idx);
#line 2631
  cache_idx = tmp;
  }
#line 2632
  if (cache_idx != -1L) {
#line 2634
    entry = (struct re_backref_cache_entry  const  *)(mctx->bkref_ents + cache_idx);
    {
#line 2636
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2637
      if (entry->node == (Idx const   )bkref_node) {
#line 2638
        return ((reg_errcode_t )0);
      }
#line 2636
      tmp___0 = entry;
#line 2636
      entry ++;
#line 2636
      if (! tmp___0->more) {
#line 2636
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2642
  subexp_num = (dfa->nodes + bkref_node)->opr.idx;
#line 2645
  sub_top_idx = (Idx )0;
  {
#line 2645
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2645
    if (! (sub_top_idx < mctx->nsub_tops)) {
#line 2645
      goto while_break___0;
    }
#line 2648
    sub_top = *(mctx->sub_tops + sub_top_idx);
#line 2652
    if ((dfa->nodes + sub_top->node)->opr.idx != subexp_num) {
#line 2653
      goto __Cont;
    }
#line 2655
    sl_str = sub_top->str_idx;
#line 2656
    bkref_str_off = bkref_str_idx;
#line 2659
    sub_last_idx = (Idx )0;
    {
#line 2659
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2659
      if (! (sub_last_idx < sub_top->nlasts)) {
#line 2659
        goto while_break___1;
      }
#line 2662
      sub_last = *(sub_top->lasts + sub_last_idx);
#line 2663
      sl_str_diff = sub_last->str_idx - sl_str;
#line 2666
      if (sl_str_diff > 0L) {
        {
#line 2668
        tmp___2 = __builtin_expect((long )(bkref_str_off + sl_str_diff > mctx->input.valid_len),
                                   0L);
        }
#line 2668
        if (tmp___2) {
#line 2672
          if (bkref_str_off + sl_str_diff > mctx->input.len) {
#line 2673
            goto while_break___1;
          }
          {
#line 2675
          err = clean_state_log_if_needed(mctx, bkref_str_off + sl_str_diff);
#line 2678
          tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2678
          if (tmp___1) {
#line 2679
            return (err);
          }
#line 2680
          buf = (char const   *)mctx->input.mbs;
        }
        {
#line 2682
        tmp___3 = memcmp((void const   *)(buf + bkref_str_off), (void const   *)(buf + sl_str),
                         (size_t )sl_str_diff);
        }
#line 2682
        if (tmp___3 != 0) {
#line 2684
          goto while_break___1;
        }
      }
      {
#line 2686
      bkref_str_off += sl_str_diff;
#line 2687
      sl_str += sl_str_diff;
#line 2688
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
#line 2693
      buf = (char const   *)mctx->input.mbs;
      }
#line 2695
      if ((int )err == 1) {
#line 2696
        goto __Cont___0;
      }
      {
#line 2697
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2697
      if (tmp___4) {
#line 2698
        return (err);
      }
      __Cont___0: /* CIL Label */ 
#line 2659
      sub_last_idx ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2701
    if (sub_last_idx < sub_top->nlasts) {
#line 2702
      goto __Cont;
    }
#line 2703
    if (sub_last_idx > 0L) {
#line 2704
      sl_str ++;
    }
    {
#line 2706
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2706
      if (! (sl_str <= bkref_str_idx)) {
#line 2706
        goto while_break___2;
      }
#line 2711
      sl_str_off = sl_str - sub_top->str_idx;
#line 2714
      if (sl_str_off > 0L) {
        {
#line 2716
        tmp___6 = __builtin_expect((long )(bkref_str_off >= mctx->input.valid_len),
                                   0L);
        }
#line 2716
        if (tmp___6) {
#line 2719
          if (bkref_str_off >= mctx->input.len) {
#line 2720
            goto while_break___2;
          }
          {
#line 2722
          err = extend_buffers(mctx, (int )(bkref_str_off + 1L));
#line 2723
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 2723
          if (tmp___5) {
#line 2724
            return (err);
          }
#line 2726
          buf = (char const   *)mctx->input.mbs;
        }
#line 2728
        tmp___7 = bkref_str_off;
#line 2728
        bkref_str_off ++;
#line 2728
        if ((int const   )*(buf + tmp___7) != (int const   )*(buf + (sl_str - 1L))) {
#line 2729
          goto while_break___2;
        }
      }
#line 2732
      if ((unsigned long )*(mctx->state_log + sl_str) == (unsigned long )((void *)0)) {
#line 2733
        goto __Cont___1;
      }
      {
#line 2735
      nodes = (re_node_set const   *)(& (*(mctx->state_log + sl_str))->nodes);
#line 2736
      cls_node = find_subexp_node(dfa, nodes, subexp_num, 9);
      }
#line 2738
      if (cls_node == -1L) {
#line 2739
        goto __Cont___1;
      }
#line 2740
      if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
        {
#line 2742
        tmp___8 = calloc(sizeof(state_array_t ), (size_t )((sl_str - sub_top->str_idx) + 1L));
#line 2742
        sub_top->path = (state_array_t *)tmp___8;
        }
#line 2744
        if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
#line 2745
          return ((reg_errcode_t )12);
        }
      }
      {
#line 2749
      err = check_arrival(mctx, sub_top->path, sub_top->node, sub_top->str_idx, cls_node,
                          sl_str, 9);
      }
#line 2752
      if ((int )err == 1) {
#line 2753
        goto __Cont___1;
      }
      {
#line 2754
      tmp___9 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2754
      if (tmp___9) {
#line 2755
        return (err);
      }
      {
#line 2756
      sub_last = match_ctx_add_sublast(sub_top, cls_node, sl_str);
#line 2757
      tmp___10 = __builtin_expect((long )((unsigned long )sub_last == (unsigned long )((void *)0)),
                                  0L);
      }
#line 2757
      if (tmp___10) {
#line 2758
        return ((reg_errcode_t )12);
      }
      {
#line 2759
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
#line 2761
      buf = (char const   *)mctx->input.mbs;
      }
#line 2762
      if ((int )err == 1) {
#line 2763
        goto __Cont___1;
      }
      {
#line 2764
      tmp___11 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2764
      if (tmp___11) {
#line 2765
        return (err);
      }
      __Cont___1: /* CIL Label */ 
#line 2706
      sl_str ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2645
    sub_top_idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2768
  return ((reg_errcode_t )0);
}
}
#line 2777 "./regexec.c"
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) 
{ 
  reg_errcode_t err ;
  Idx to_idx ;
  long tmp ;
  reg_errcode_t tmp___0 ;

  {
  {
#line 2784
  err = check_arrival(mctx, & sub_last->path, sub_last->node, sub_last->str_idx, bkref_node,
                      bkref_str, 8);
  }
#line 2787
  if ((int )err != 0) {
#line 2788
    return (err);
  }
  {
#line 2789
  err = match_ctx_add_entry(mctx, bkref_node, bkref_str, (Idx )sub_top->str_idx, sub_last->str_idx);
#line 2791
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 2791
  if (tmp) {
#line 2792
    return (err);
  }
  {
#line 2793
  to_idx = (bkref_str + sub_last->str_idx) - (Idx )sub_top->str_idx;
#line 2794
  tmp___0 = clean_state_log_if_needed(mctx, to_idx);
  }
#line 2794
  return (tmp___0);
}
}
#line 2805 "./regexec.c"
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) 
{ 
  Idx cls_idx ;
  Idx cls_node ;
  re_token_t const   *node ;

  {
#line 2810
  cls_idx = (Idx )0;
  {
#line 2810
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2810
    if (! (cls_idx < (Idx )nodes->nelem)) {
#line 2810
      goto while_break;
    }
#line 2812
    cls_node = *(nodes->elems + cls_idx);
#line 2813
    node = (re_token_t const   *)(dfa->nodes + cls_node);
#line 2814
    if ((unsigned int const   )node->type == (unsigned int const   )type) {
#line 2814
      if (node->opr.idx == (Idx const   )subexp_idx) {
#line 2816
        return (cls_node);
      }
    }
#line 2810
    cls_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2818
  return ((Idx )-1);
}
}
#line 2826 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) check_arrival)(re_match_context_t *mctx ,
                                                                              state_array_t *path ,
                                                                              Idx top_node ,
                                                                              Idx top_str ,
                                                                              Idx last_node ,
                                                                              Idx last_str ,
                                                                              int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx subexp_num ;
  Idx backup_cur_idx ;
  Idx str_idx ;
  Idx null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  Idx old_alloc ;
  Idx incr_alloc ;
  Idx new_alloc ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  Idx __attribute__((__pure__))  tmp___16 ;

  {
  {
#line 2831
  dfa = mctx->dfa;
#line 2832
  err = (reg_errcode_t )0;
#line 2834
  cur_state = (re_dfastate_t *)((void *)0);
#line 2839
  subexp_num = (dfa->nodes + top_node)->opr.idx;
#line 2841
  tmp___3 = __builtin_expect((long )(path->alloc < (last_str + (Idx )mctx->max_mb_elem_len) + 1L),
                             0L);
  }
#line 2841
  if (tmp___3) {
    {
#line 2844
    old_alloc = path->alloc;
#line 2845
    incr_alloc = (last_str + (Idx )mctx->max_mb_elem_len) + 1L;
#line 2847
    tmp = __builtin_expect((long )(9223372036854775807L - old_alloc < incr_alloc),
                           0L);
    }
#line 2847
    if (tmp) {
#line 2848
      return ((reg_errcode_t )12);
    }
    {
#line 2849
    new_alloc = old_alloc + incr_alloc;
#line 2850
    tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) < (unsigned long )new_alloc),
                               0L);
    }
#line 2850
    if (tmp___0) {
#line 2851
      return ((reg_errcode_t )12);
    }
    {
#line 2852
    tmp___1 = realloc((void *)path->array, (unsigned long )new_alloc * sizeof(re_dfastate_t *));
#line 2852
    new_array = (re_dfastate_t **)tmp___1;
#line 2853
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 2853
    if (tmp___2) {
#line 2854
      return ((reg_errcode_t )12);
    }
    {
#line 2855
    path->array = new_array;
#line 2856
    path->alloc = new_alloc;
#line 2857
    memset((void *)(new_array + old_alloc), '\000', sizeof(re_dfastate_t *) * (unsigned long )(path->alloc - old_alloc));
    }
  }
#line 2861
  if (path->next_idx) {
#line 2861
    str_idx = path->next_idx;
  } else {
#line 2861
    str_idx = top_str;
  }
  {
#line 2864
  backup_state_log = mctx->state_log;
#line 2865
  backup_cur_idx = mctx->input.cur_idx;
#line 2866
  mctx->state_log = path->array;
#line 2867
  mctx->input.cur_idx = str_idx;
#line 2870
  context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1L,
                                 mctx->eflags);
  }
#line 2871
  if (str_idx == top_str) {
    {
#line 2873
    err = re_node_set_init_1(& next_nodes, top_node);
#line 2874
    tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2874
    if (tmp___4) {
#line 2875
      return (err);
    }
    {
#line 2876
    err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 2877
    tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
    }
#line 2877
    if (tmp___5) {
      {
#line 2879
      free((void *)next_nodes.elems);
      }
#line 2880
      return (err);
    }
  } else {
#line 2885
    cur_state = *(mctx->state_log + str_idx);
#line 2886
    if (cur_state) {
#line 2886
      if (cur_state->has_backref) {
        {
#line 2888
        err = re_node_set_init_copy(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
#line 2889
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2889
        if (tmp___6) {
#line 2890
          return (err);
        }
      } else {
        {
#line 2893
        memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
        }
      }
    } else {
      {
#line 2893
      memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
      }
    }
  }
#line 2895
  if (str_idx == top_str) {
#line 2895
    goto _L;
  } else
#line 2895
  if (cur_state) {
#line 2895
    if (cur_state->has_backref) {
      _L: /* CIL Label */ 
#line 2897
      if (next_nodes.nelem) {
        {
#line 2899
        err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 2901
        tmp___7 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 2901
        if (tmp___7) {
          {
#line 2903
          free((void *)next_nodes.elems);
          }
#line 2904
          return (err);
        }
      }
      {
#line 2907
      cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                           context);
      }
#line 2908
      if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2908
        if ((int )err != 0) {
#line 2908
          tmp___8 = 1;
        } else {
#line 2908
          tmp___8 = 0;
        }
      } else {
#line 2908
        tmp___8 = 0;
      }
      {
#line 2908
      tmp___9 = __builtin_expect((long )tmp___8, 0L);
      }
#line 2908
      if (tmp___9) {
        {
#line 2910
        free((void *)next_nodes.elems);
        }
#line 2911
        return (err);
      }
#line 2913
      *(mctx->state_log + str_idx) = cur_state;
    }
  }
#line 2916
  null_cnt = (Idx )0;
  {
#line 2916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2916
    if (str_idx < last_str) {
#line 2916
      if (! (null_cnt <= (Idx )mctx->max_mb_elem_len)) {
#line 2916
        goto while_break;
      }
    } else {
#line 2916
      goto while_break;
    }
#line 2918
    next_nodes.nelem = (Idx )0;
#line 2919
    if (*(mctx->state_log + (str_idx + 1L))) {
      {
#line 2921
      err = re_node_set_merge(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1L)))->nodes));
#line 2923
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2923
      if (tmp___10) {
        {
#line 2925
        free((void *)next_nodes.elems);
        }
#line 2926
        return (err);
      }
    }
#line 2929
    if (cur_state) {
      {
#line 2931
      err = check_arrival_add_next_nodes(mctx, str_idx, & cur_state->non_eps_nodes,
                                         & next_nodes);
#line 2934
      tmp___11 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2934
      if (tmp___11) {
        {
#line 2936
        free((void *)next_nodes.elems);
        }
#line 2937
        return (err);
      }
    }
#line 2940
    str_idx ++;
#line 2941
    if (next_nodes.nelem) {
      {
#line 2943
      err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 2944
      tmp___12 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2944
      if (tmp___12) {
        {
#line 2946
        free((void *)next_nodes.elems);
        }
#line 2947
        return (err);
      }
      {
#line 2949
      err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 2951
      tmp___13 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 2951
      if (tmp___13) {
        {
#line 2953
        free((void *)next_nodes.elems);
        }
#line 2954
        return (err);
      }
    }
    {
#line 2957
    context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1L,
                                   mctx->eflags);
#line 2958
    cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
    }
#line 2959
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2959
      if ((int )err != 0) {
#line 2959
        tmp___14 = 1;
      } else {
#line 2959
        tmp___14 = 0;
      }
    } else {
#line 2959
      tmp___14 = 0;
    }
    {
#line 2959
    tmp___15 = __builtin_expect((long )tmp___14, 0L);
    }
#line 2959
    if (tmp___15) {
      {
#line 2961
      free((void *)next_nodes.elems);
      }
#line 2962
      return (err);
    }
#line 2964
    *(mctx->state_log + str_idx) = cur_state;
#line 2965
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 2965
      null_cnt ++;
    } else {
#line 2965
      null_cnt = (Idx )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2967
  free((void *)next_nodes.elems);
  }
#line 2968
  if ((unsigned long )*(mctx->state_log + last_str) == (unsigned long )((void *)0)) {
#line 2968
    cur_nodes = (re_node_set *)((void *)0);
  } else {
#line 2968
    cur_nodes = & (*(mctx->state_log + last_str))->nodes;
  }
#line 2970
  path->next_idx = str_idx;
#line 2973
  mctx->state_log = backup_state_log;
#line 2974
  mctx->input.cur_idx = backup_cur_idx;
#line 2977
  if ((unsigned long )cur_nodes != (unsigned long )((void *)0)) {
    {
#line 2977
    tmp___16 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
    }
#line 2977
    if (tmp___16) {
#line 2978
      return ((reg_errcode_t )0);
    }
  }
#line 2980
  return ((reg_errcode_t )1);
}
}
#line 2991 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) check_arrival_add_next_nodes)(re_match_context_t *mctx ,
                                                                                             Idx str_idx ,
                                                                                             re_node_set *cur_nodes ,
                                                                                             re_node_set *next_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  _Bool ok ;
  Idx cur_idx ;
  reg_errcode_t err ;
  re_node_set union_set ;
  int naccepted ;
  Idx cur_node ;
  re_dfastate_t *dest_state ;
  Idx next_node ;
  Idx next_idx ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
  {
#line 2996
  dfa = mctx->dfa;
#line 3000
  err = (reg_errcode_t )0;
#line 3003
  memset((void *)(& union_set), '\000', sizeof(re_node_set ));
#line 3004
  cur_idx = (Idx )0;
  }
  {
#line 3004
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3004
    if (! (cur_idx < cur_nodes->nelem)) {
#line 3004
      goto while_break;
    }
#line 3006
    naccepted = 0;
#line 3007
    cur_node = *(cur_nodes->elems + cur_idx);
#line 3008
    if (! (! ((unsigned int )(dfa->nodes + cur_node)->type & 8U))) {
      {
#line 3008
      __builtin_unreachable();
      }
    }
#line 3012
    if ((dfa->nodes + cur_node)->accept_mb) {
      {
#line 3014
      naccepted = check_node_accept_bytes(dfa, cur_node, (re_string_t const   *)(& mctx->input),
                                          str_idx);
      }
#line 3016
      if (naccepted > 1) {
#line 3019
        next_node = *(dfa->nexts + cur_node);
#line 3020
        next_idx = str_idx + (Idx )naccepted;
#line 3021
        dest_state = *(mctx->state_log + next_idx);
#line 3022
        union_set.nelem = (Idx )0;
#line 3023
        if (dest_state) {
          {
#line 3025
          err = re_node_set_merge(& union_set, (re_node_set const   *)(& dest_state->nodes));
#line 3026
          tmp = __builtin_expect((long )((int )err != 0), 0L);
          }
#line 3026
          if (tmp) {
            {
#line 3028
            free((void *)union_set.elems);
            }
#line 3029
            return (err);
          }
        }
        {
#line 3032
        ok = re_node_set_insert(& union_set, next_node);
#line 3033
        tmp___0 = __builtin_expect((long )(! ok), 0L);
        }
#line 3033
        if (tmp___0) {
          {
#line 3035
          free((void *)union_set.elems);
          }
#line 3036
          return ((reg_errcode_t )12);
        }
        {
#line 3038
        *(mctx->state_log + next_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
        }
#line 3040
        if ((unsigned long )*(mctx->state_log + next_idx) == (unsigned long )((void *)0)) {
#line 3040
          if ((int )err != 0) {
#line 3040
            tmp___1 = 1;
          } else {
#line 3040
            tmp___1 = 0;
          }
        } else {
#line 3040
          tmp___1 = 0;
        }
        {
#line 3040
        tmp___2 = __builtin_expect((long )tmp___1, 0L);
        }
#line 3040
        if (tmp___2) {
          {
#line 3043
          free((void *)union_set.elems);
          }
#line 3044
          return (err);
        }
      }
    }
#line 3049
    if (naccepted) {
#line 3049
      goto _L;
    } else {
      {
#line 3049
      tmp___4 = check_node_accept((re_match_context_t const   *)mctx, (re_token_t const   *)(dfa->nodes + cur_node),
                                  str_idx);
      }
#line 3049
      if (tmp___4) {
        _L: /* CIL Label */ 
        {
#line 3052
        ok = re_node_set_insert(next_nodes, *(dfa->nexts + cur_node));
#line 3053
        tmp___3 = __builtin_expect((long )(! ok), 0L);
        }
#line 3053
        if (tmp___3) {
          {
#line 3055
          free((void *)union_set.elems);
          }
#line 3056
          return ((reg_errcode_t )12);
        }
      }
    }
#line 3004
    cur_idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3060
  free((void *)union_set.elems);
  }
#line 3061
  return ((reg_errcode_t )0);
}
}
#line 3070 "./regexec.c"
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) 
{ 
  reg_errcode_t err ;
  Idx idx ;
  Idx outside_node ;
  re_node_set new_nodes ;
  long tmp ;
  Idx cur_node ;
  re_node_set const   *eclosure ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 3077
  if (! cur_nodes->nelem) {
    {
#line 3077
    __builtin_unreachable();
    }
  }
  {
#line 3078
  err = re_node_set_alloc(& new_nodes, cur_nodes->nelem);
#line 3079
  tmp = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 3079
  if (tmp) {
#line 3080
    return (err);
  }
#line 3084
  idx = (Idx )0;
  {
#line 3084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3084
    if (! (idx < cur_nodes->nelem)) {
#line 3084
      goto while_break;
    }
    {
#line 3086
    cur_node = *(cur_nodes->elems + idx);
#line 3087
    eclosure = (re_node_set const   *)(dfa->eclosures + cur_node);
#line 3088
    outside_node = find_subexp_node(dfa, eclosure, ex_subexp, type);
    }
#line 3089
    if (outside_node == -1L) {
      {
#line 3092
      err = re_node_set_merge(& new_nodes, eclosure);
#line 3093
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3093
      if (tmp___0) {
        {
#line 3095
        free((void *)new_nodes.elems);
        }
#line 3096
        return (err);
      }
    } else {
      {
#line 3102
      err = check_arrival_expand_ecl_sub(dfa, & new_nodes, cur_node, ex_subexp, type);
#line 3104
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3104
      if (tmp___1) {
        {
#line 3106
        free((void *)new_nodes.elems);
        }
#line 3107
        return (err);
      }
    }
#line 3084
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3111
  free((void *)cur_nodes->elems);
#line 3112
  *cur_nodes = new_nodes;
  }
#line 3113
  return ((reg_errcode_t )0);
}
}
#line 3120 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) check_arrival_expand_ecl_sub)(re_dfa_t const   *dfa ,
                                                                                             re_node_set *dst_nodes ,
                                                                                             Idx target ,
                                                                                             Idx ex_subexp ,
                                                                                             int type ) 
{ 
  Idx cur_node ;
  _Bool ok ;
  long tmp ;
  long tmp___0 ;
  reg_errcode_t err ;
  long tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;

  {
#line 3126
  cur_node = target;
  {
#line 3126
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3126
    tmp___2 = re_node_set_contains((re_node_set const   *)dst_nodes, cur_node);
    }
#line 3126
    if (tmp___2) {
#line 3126
      goto while_break;
    }
#line 3130
    if ((unsigned int )(dfa->nodes + cur_node)->type == (unsigned int )type) {
#line 3130
      if ((dfa->nodes + cur_node)->opr.idx == ex_subexp) {
#line 3133
        if (type == 9) {
          {
#line 3135
          ok = re_node_set_insert(dst_nodes, cur_node);
#line 3136
          tmp = __builtin_expect((long )(! ok), 0L);
          }
#line 3136
          if (tmp) {
#line 3137
            return ((reg_errcode_t )12);
          }
        }
#line 3139
        goto while_break;
      }
    }
    {
#line 3141
    ok = re_node_set_insert(dst_nodes, cur_node);
#line 3142
    tmp___0 = __builtin_expect((long )(! ok), 0L);
    }
#line 3142
    if (tmp___0) {
#line 3143
      return ((reg_errcode_t )12);
    }
#line 3144
    if ((dfa->edests + cur_node)->nelem == 0L) {
#line 3145
      goto while_break;
    }
#line 3146
    if ((dfa->edests + cur_node)->nelem == 2L) {
      {
#line 3149
      err = check_arrival_expand_ecl_sub(dfa, dst_nodes, *((dfa->edests + cur_node)->elems + 1),
                                         ex_subexp, type);
#line 3152
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3152
      if (tmp___1) {
#line 3153
        return (err);
      }
    }
#line 3155
    cur_node = *((dfa->edests + cur_node)->elems + 0);
  }
  while_break: /* CIL Label */ ;
  }
#line 3157
  return ((reg_errcode_t )0);
}
}
#line 3165 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) expand_bkref_cache)(re_match_context_t *mctx ,
                                                                                   re_node_set *cur_nodes ,
                                                                                   Idx cur_str ,
                                                                                   Idx subexp_num ,
                                                                                   int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx cache_idx_start ;
  Idx tmp ;
  struct re_backref_cache_entry *ent ;
  Idx to_idx ;
  Idx next_node ;
  Idx __attribute__((__pure__))  tmp___0 ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  re_node_set union_set ;
  _Bool ok ;
  Idx __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  struct re_backref_cache_entry *tmp___11 ;

  {
  {
#line 3170
  dfa = mctx->dfa;
#line 3172
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, cur_str);
#line 3172
  cache_idx_start = tmp;
  }
#line 3175
  if (cache_idx_start == -1L) {
#line 3176
    return ((reg_errcode_t )0);
  }
  restart: 
#line 3179
  ent = mctx->bkref_ents + cache_idx_start;
  {
#line 3180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3185
    tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, ent->node);
    }
#line 3185
    if (! tmp___0) {
#line 3186
      goto __Cont;
    }
#line 3188
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
#line 3191
    if (to_idx == cur_str) {
      {
#line 3197
      next_node = *((dfa->edests + ent->node)->elems + 0);
#line 3198
      tmp___1 = re_node_set_contains((re_node_set const   *)cur_nodes, next_node);
      }
#line 3198
      if (tmp___1) {
#line 3199
        goto __Cont;
      }
      {
#line 3200
      err = re_node_set_init_1(& new_dests, next_node);
#line 3201
      err2 = check_arrival_expand_ecl(dfa, & new_dests, subexp_num, type);
#line 3202
      err3 = re_node_set_merge(cur_nodes, (re_node_set const   *)(& new_dests));
#line 3203
      free((void *)new_dests.elems);
      }
#line 3204
      if ((int )err != 0) {
#line 3204
        tmp___3 = 1;
      } else
#line 3204
      if ((int )err2 != 0) {
#line 3204
        tmp___3 = 1;
      } else
#line 3204
      if ((int )err3 != 0) {
#line 3204
        tmp___3 = 1;
      } else {
#line 3204
        tmp___3 = 0;
      }
      {
#line 3204
      tmp___4 = __builtin_expect((long )tmp___3, 0L);
      }
#line 3204
      if (tmp___4) {
#line 3207
        if ((int )err != 0) {
#line 3207
          err = err;
        } else {
#line 3207
          if ((int )err2 != 0) {
#line 3207
            tmp___2 = (int )err2;
          } else {
#line 3207
            tmp___2 = (int )err3;
          }
#line 3207
          err = (reg_errcode_t )tmp___2;
        }
#line 3209
        return (err);
      }
#line 3212
      goto restart;
    } else {
#line 3217
      next_node = *(dfa->nexts + ent->node);
#line 3218
      if (*(mctx->state_log + to_idx)) {
        {
#line 3221
        tmp___5 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                       next_node);
        }
#line 3221
        if (tmp___5) {
#line 3223
          goto __Cont;
        }
        {
#line 3224
        err = re_node_set_init_copy(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
#line 3226
        ok = re_node_set_insert(& union_set, next_node);
        }
#line 3227
        if ((int )err != 0) {
#line 3227
          tmp___6 = 1;
        } else
#line 3227
        if (! ok) {
#line 3227
          tmp___6 = 1;
        } else {
#line 3227
          tmp___6 = 0;
        }
        {
#line 3227
        tmp___7 = __builtin_expect((long )tmp___6, 0L);
        }
#line 3227
        if (tmp___7) {
          {
#line 3229
          free((void *)union_set.elems);
          }
#line 3230
          if ((int )err != 0) {
#line 3230
            err = err;
          } else {
#line 3230
            err = (reg_errcode_t )12;
          }
#line 3231
          return (err);
        }
      } else {
        {
#line 3236
        err = re_node_set_init_1(& union_set, next_node);
#line 3237
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3237
        if (tmp___8) {
#line 3238
          return (err);
        }
      }
      {
#line 3240
      *(mctx->state_log + to_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
#line 3241
      free((void *)union_set.elems);
      }
#line 3242
      if ((unsigned long )*(mctx->state_log + to_idx) == (unsigned long )((void *)0)) {
#line 3242
        if ((int )err != 0) {
#line 3242
          tmp___9 = 1;
        } else {
#line 3242
          tmp___9 = 0;
        }
      } else {
#line 3242
        tmp___9 = 0;
      }
      {
#line 3242
      tmp___10 = __builtin_expect((long )tmp___9, 0L);
      }
#line 3242
      if (tmp___10) {
#line 3244
        return (err);
      }
    }
    __Cont: /* CIL Label */ 
#line 3180
    tmp___11 = ent;
#line 3180
    ent ++;
#line 3180
    if (! tmp___11->more) {
#line 3180
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3248
  return ((reg_errcode_t )0);
}
}
#line 3254 "./regexec.c"
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  Idx j ;
  int ch ;
  _Bool need_word_trtable ;
  bitset_word_t elem ;
  bitset_word_t mask ;
  _Bool dests_node_malloced ;
  _Bool dest_states_malloced ;
  Idx ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset_t *dests_ch ;
  bitset_t acceptable ;
  struct dests_alloc *dests_alloc ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct re_dfastate_t **tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  size_t ndests_max ;
  long tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  long tmp___10 ;
  Idx next_node ;
  long tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  struct re_dfastate_t **tmp___18 ;
  void *tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  struct re_dfastate_t **tmp___22 ;
  void *tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  long tmp___26 ;
  _Bool tmp___27 ;
  _Bool tmp___28 ;

  {
#line 3260
  need_word_trtable = (_Bool)0;
#line 3262
  dests_node_malloced = (_Bool)0;
#line 3263
  dest_states_malloced = (_Bool)0;
#line 3266
  dest_states = (re_dfastate_t **)((void *)0);
#line 3281
  if (sizeof(struct dests_alloc ) < 4032UL) {
    {
#line 3282
    tmp = __builtin_alloca(sizeof(struct dests_alloc ));
#line 3282
    dests_alloc = (struct dests_alloc *)tmp;
    }
  } else {
    {
#line 3285
    tmp___0 = malloc(sizeof(struct dests_alloc ));
#line 3285
    dests_alloc = (struct dests_alloc *)tmp___0;
#line 3286
    tmp___1 = __builtin_expect((long )((unsigned long )dests_alloc == (unsigned long )((void *)0)),
                               0L);
    }
#line 3286
    if (tmp___1) {
#line 3287
      return ((_Bool)0);
    }
#line 3288
    dests_node_malloced = (_Bool)1;
  }
  {
#line 3290
  dests_node = dests_alloc->dests_node;
#line 3291
  dests_ch = dests_alloc->dests_ch;
#line 3294
  tmp___2 = (struct re_dfastate_t **)((void *)0);
#line 3294
  state->trtable = tmp___2;
#line 3294
  state->word_trtable = tmp___2;
#line 3298
  ndests = group_nodes_into_DFAstates(dfa, (re_dfastate_t const   *)state, dests_node,
                                      dests_ch);
#line 3299
  tmp___5 = __builtin_expect((long )(ndests <= 0L), 0L);
  }
#line 3299
  if (tmp___5) {
#line 3301
    if (dests_node_malloced) {
      {
#line 3302
      free((void *)dests_alloc);
      }
    }
#line 3304
    if (ndests == 0L) {
      {
#line 3306
      tmp___3 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3306
      state->trtable = (re_dfastate_t **)tmp___3;
#line 3308
      tmp___4 = __builtin_expect((long )((unsigned long )state->trtable == (unsigned long )((void *)0)),
                                 0L);
      }
#line 3308
      if (tmp___4) {
#line 3309
        return ((_Bool)0);
      }
#line 3310
      return ((_Bool)1);
    }
#line 3312
    return ((_Bool)0);
  }
  {
#line 3315
  err = re_node_set_alloc(& follows, ndests + 1L);
#line 3316
  tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
  }
#line 3316
  if (tmp___6) {
#line 3317
    goto out_free;
  }
  {
#line 3320
  ndests_max = (0xffffffffffffffffUL - (sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL) / (3UL * sizeof(re_dfastate_t *));
#line 3323
  tmp___7 = __builtin_expect((long )(ndests_max < (size_t )ndests), 0L);
  }
#line 3323
  if (tmp___7) {
#line 3324
    goto out_free;
  }
#line 3326
  if ((sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL + (unsigned long )(ndests * 3L) * sizeof(re_dfastate_t *) < 4032UL) {
    {
#line 3328
    tmp___8 = __builtin_alloca((unsigned long )(ndests * 3L) * sizeof(re_dfastate_t *));
#line 3328
    dest_states = (re_dfastate_t **)tmp___8;
    }
  } else {
    {
#line 3332
    tmp___9 = malloc((unsigned long )(ndests * 3L) * sizeof(re_dfastate_t *));
#line 3332
    dest_states = (re_dfastate_t **)tmp___9;
#line 3333
    tmp___10 = __builtin_expect((long )((unsigned long )dest_states == (unsigned long )((void *)0)),
                                0L);
    }
#line 3333
    if (tmp___10) {
      out_free: 
#line 3336
      if (dest_states_malloced) {
        {
#line 3337
        free((void *)dest_states);
        }
      }
      {
#line 3338
      free((void *)follows.elems);
#line 3339
      i = (Idx )0;
      }
      {
#line 3339
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3339
        if (! (i < ndests)) {
#line 3339
          goto while_break;
        }
        {
#line 3340
        free((void *)(dests_node + i)->elems);
#line 3339
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3341
      if (dests_node_malloced) {
        {
#line 3342
        free((void *)dests_alloc);
        }
      }
#line 3343
      return ((_Bool)0);
    }
#line 3345
    dest_states_malloced = (_Bool)1;
  }
  {
#line 3347
  dest_states_word = dest_states + ndests;
#line 3348
  dest_states_nl = dest_states_word + ndests;
#line 3349
  bitset_empty((bitset_word_t *)(acceptable));
#line 3352
  i = (Idx )0;
  }
  {
#line 3352
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3352
    if (! (i < ndests)) {
#line 3352
      goto while_break___0;
    }
#line 3355
    follows.nelem = (Idx )0;
#line 3357
    j = (Idx )0;
    {
#line 3357
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3357
      if (! (j < (dests_node + i)->nelem)) {
#line 3357
        goto while_break___1;
      }
#line 3359
      next_node = *(dfa->nexts + *((dests_node + i)->elems + j));
#line 3360
      if (next_node != -1L) {
        {
#line 3362
        err = re_node_set_merge(& follows, (re_node_set const   *)(dfa->eclosures + next_node));
#line 3363
        tmp___11 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3363
        if (tmp___11) {
#line 3364
          goto out_free;
        }
      }
#line 3357
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3367
    *(dest_states + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                  0U);
    }
#line 3368
    if ((unsigned long )*(dest_states + i) == (unsigned long )((void *)0)) {
#line 3368
      if ((int )err != 0) {
#line 3368
        tmp___12 = 1;
      } else {
#line 3368
        tmp___12 = 0;
      }
    } else {
#line 3368
      tmp___12 = 0;
    }
    {
#line 3368
    tmp___13 = __builtin_expect((long )tmp___12, 0L);
    }
#line 3368
    if (tmp___13) {
#line 3369
      goto out_free;
    }
#line 3372
    if ((*(dest_states + i))->has_constraint) {
      {
#line 3374
      *(dest_states_word + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                         1U);
      }
#line 3376
      if ((unsigned long )*(dest_states_word + i) == (unsigned long )((void *)0)) {
#line 3376
        if ((int )err != 0) {
#line 3376
          tmp___14 = 1;
        } else {
#line 3376
          tmp___14 = 0;
        }
      } else {
#line 3376
        tmp___14 = 0;
      }
      {
#line 3376
      tmp___15 = __builtin_expect((long )tmp___14, 0L);
      }
#line 3376
      if (tmp___15) {
#line 3378
        goto out_free;
      }
#line 3380
      if ((unsigned long )*(dest_states + i) != (unsigned long )*(dest_states_word + i)) {
#line 3380
        if (dfa->mb_cur_max > 1) {
#line 3381
          need_word_trtable = (_Bool)1;
        }
      }
      {
#line 3383
      *(dest_states_nl + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                       (unsigned int )(1 << 1));
      }
#line 3385
      if ((unsigned long )*(dest_states_nl + i) == (unsigned long )((void *)0)) {
#line 3385
        if ((int )err != 0) {
#line 3385
          tmp___16 = 1;
        } else {
#line 3385
          tmp___16 = 0;
        }
      } else {
#line 3385
        tmp___16 = 0;
      }
      {
#line 3385
      tmp___17 = __builtin_expect((long )tmp___16, 0L);
      }
#line 3385
      if (tmp___17) {
#line 3386
        goto out_free;
      }
    } else {
#line 3390
      *(dest_states_word + i) = *(dest_states + i);
#line 3391
      *(dest_states_nl + i) = *(dest_states + i);
    }
    {
#line 3393
    bitset_merge((bitset_word_t *)(acceptable), (bitset_word_t */* const  */)(*(dests_ch + i)));
#line 3352
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3396
  tmp___26 = __builtin_expect((long )need_word_trtable, 0L);
  }
#line 3396
  if (tmp___26) {
    {
#line 3433
    tmp___23 = calloc(sizeof(re_dfastate_t *), (size_t )512);
#line 3433
    tmp___22 = (re_dfastate_t **)tmp___23;
#line 3433
    state->word_trtable = tmp___22;
#line 3433
    trtable = tmp___22;
#line 3435
    tmp___24 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3435
    if (tmp___24) {
#line 3436
      goto out_free;
    }
#line 3439
    i = (Idx )0;
    {
#line 3439
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3439
      if (! (i < 4L)) {
#line 3439
        goto while_break___2;
      }
#line 3440
      ch = (int )(i * 64L);
#line 3440
      elem = acceptable[i];
#line 3440
      mask = (bitset_word_t )1;
      {
#line 3440
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 3440
        if (! elem) {
#line 3440
          goto while_break___3;
        }
        {
#line 3443
        tmp___25 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3443
        if (tmp___25) {
#line 3447
          j = (Idx )0;
          {
#line 3447
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 3447
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
#line 3447
              goto while_break___4;
            }
#line 3447
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 3451
          *(trtable + ch) = *(dest_states + j);
#line 3452
          *(trtable + (ch + 256)) = *(dest_states_word + j);
        }
#line 3440
        mask <<= 1;
#line 3440
        elem >>= 1;
#line 3440
        ch ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 3439
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 3402
    tmp___19 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3402
    tmp___18 = (re_dfastate_t **)tmp___19;
#line 3402
    state->trtable = tmp___18;
#line 3402
    trtable = tmp___18;
#line 3404
    tmp___20 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
    }
#line 3404
    if (tmp___20) {
#line 3405
      goto out_free;
    }
#line 3408
    i = (Idx )0;
    {
#line 3408
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 3408
      if (! (i < 4L)) {
#line 3408
        goto while_break___5;
      }
#line 3409
      ch = (int )(i * 64L);
#line 3409
      elem = acceptable[i];
#line 3409
      mask = (bitset_word_t )1;
      {
#line 3409
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3409
        if (! elem) {
#line 3409
          goto while_break___6;
        }
        {
#line 3412
        tmp___21 = __builtin_expect((long )(elem & 1UL), 0L);
        }
#line 3412
        if (tmp___21) {
#line 3416
          j = (Idx )0;
          {
#line 3416
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 3416
            if (! (((*(dests_ch + j))[i] & mask) == 0UL)) {
#line 3416
              goto while_break___7;
            }
#line 3416
            j ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 3420
          if (dfa->word_char[i] & mask) {
#line 3421
            *(trtable + ch) = *(dest_states_word + j);
          } else {
#line 3423
            *(trtable + ch) = *(dest_states + j);
          }
        }
#line 3409
        mask <<= 1;
#line 3409
        elem >>= 1;
#line 3409
        ch ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3408
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 3457
  tmp___28 = bitset_contain((bitset_word_t */* const  */)(acceptable), (Idx )'\n');
  }
#line 3457
  if (tmp___28) {
#line 3460
    j = (Idx )0;
    {
#line 3460
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 3460
      if (! (j < ndests)) {
#line 3460
        goto while_break___8;
      }
      {
#line 3461
      tmp___27 = bitset_contain((bitset_word_t */* const  */)(*(dests_ch + j)), (Idx )'\n');
      }
#line 3461
      if (tmp___27) {
#line 3464
        *(trtable + '\n') = *(dest_states_nl + j);
#line 3465
        if (need_word_trtable) {
#line 3466
          *(trtable + 266) = *(dest_states_nl + j);
        }
#line 3469
        goto while_break___8;
      }
#line 3460
      j ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 3473
  if (dest_states_malloced) {
    {
#line 3474
    free((void *)dest_states);
    }
  }
  {
#line 3476
  free((void *)follows.elems);
#line 3477
  i = (Idx )0;
  }
  {
#line 3477
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 3477
    if (! (i < ndests)) {
#line 3477
      goto while_break___9;
    }
    {
#line 3478
    free((void *)(dests_node + i)->elems);
#line 3477
    i ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 3480
  if (dests_node_malloced) {
    {
#line 3481
    free((void *)dests_alloc);
    }
  }
#line 3483
  return ((_Bool)1);
}
}
#line 3491 "./regexec.c"
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) 
{ 
  reg_errcode_t err ;
  _Bool ok ;
  Idx i ;
  Idx j ;
  Idx k ;
  Idx ndests ;
  bitset_t accepts ;
  re_node_set const   *cur_nodes ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  _Bool accepts_newline ;
  _Bool tmp ;
  bitset_word_t any_set ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  bitset_word_t any_set___0 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  bitset_t intersec ;
  bitset_t remains ;
  bitset_word_t has_intersec ;
  bitset_word_t not_subset ;
  bitset_word_t not_consumed ;
  _Bool tmp___4 ;
  bitset_word_t tmp___5 ;
  bitset_word_t tmp___6 ;
  bitset_word_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
  {
#line 3500
  cur_nodes = & state->nodes;
#line 3501
  bitset_empty((bitset_word_t *)(accepts));
#line 3502
  ndests = (Idx )0;
#line 3505
  i = (Idx )0;
  }
  {
#line 3505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3505
    if (! (i < (Idx )cur_nodes->nelem)) {
#line 3505
      goto while_break;
    }
#line 3507
    node = dfa->nodes + *(cur_nodes->elems + i);
#line 3508
    type = node->type;
#line 3509
    constraint = node->constraint;
#line 3512
    if ((unsigned int )type == 1U) {
      {
#line 3513
      bitset_set((bitset_word_t *)(accepts), (Idx )node->opr.c);
      }
    } else
#line 3514
    if ((unsigned int )type == 3U) {
      {
#line 3516
      bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)node->opr.sbcset);
      }
    } else
#line 3518
    if ((unsigned int )type == 5U) {
#line 3521
      if (dfa->mb_cur_max > 1) {
        {
#line 3522
        bitset_merge((bitset_word_t *)(accepts), (bitset_word_t */* const  */)dfa->sb_char);
        }
      } else {
        {
#line 3525
        bitset_set_all((bitset_word_t *)(accepts));
        }
      }
#line 3526
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 3527
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
        }
      }
#line 3528
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 3529
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
        }
      }
    } else
#line 3532
    if ((unsigned int )type == 7U) {
      {
#line 3535
      memset((void *)(accepts), -1, (size_t )16);
      }
#line 3538
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 3539
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
        }
      }
#line 3540
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 3541
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
        }
      }
    } else {
#line 3545
      goto __Cont;
    }
#line 3549
    if (constraint) {
#line 3551
      if (constraint & 32U) {
        {
#line 3553
        tmp = bitset_contain((bitset_word_t */* const  */)(accepts), (Idx )'\n');
#line 3553
        accepts_newline = tmp;
#line 3554
        bitset_empty((bitset_word_t *)(accepts));
        }
#line 3555
        if (accepts_newline) {
          {
#line 3556
          bitset_set((bitset_word_t *)(accepts), (Idx )'\n');
          }
        } else {
#line 3558
          goto __Cont;
        }
      }
#line 3560
      if (constraint & 128U) {
        {
#line 3562
        bitset_empty((bitset_word_t *)(accepts));
        }
#line 3563
        goto __Cont;
      }
#line 3566
      if (constraint & 4U) {
#line 3568
        any_set = (bitset_word_t )0;
#line 3569
        if ((unsigned int )type == 1U) {
#line 3569
          if (! node->word_char) {
            {
#line 3571
            bitset_empty((bitset_word_t *)(accepts));
            }
#line 3572
            goto __Cont;
          }
        }
#line 3575
        if (dfa->mb_cur_max > 1) {
#line 3576
          j = (Idx )0;
          {
#line 3576
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 3576
            if (! (j < 4L)) {
#line 3576
              goto while_break___0;
            }
#line 3577
            tmp___0 = accepts[j] & (dfa->word_char[j] | ~ *(dfa->sb_char + j));
#line 3577
            accepts[j] = tmp___0;
#line 3577
            any_set |= tmp___0;
#line 3576
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 3580
          j = (Idx )0;
          {
#line 3580
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3580
            if (! (j < 4L)) {
#line 3580
              goto while_break___1;
            }
#line 3581
            tmp___1 = accepts[j] & dfa->word_char[j];
#line 3581
            accepts[j] = tmp___1;
#line 3581
            any_set |= tmp___1;
#line 3580
            j ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 3582
        if (! any_set) {
#line 3583
          goto __Cont;
        }
      }
#line 3585
      if (constraint & 8U) {
#line 3587
        any_set___0 = (bitset_word_t )0;
#line 3588
        if ((unsigned int )type == 1U) {
#line 3588
          if (node->word_char) {
            {
#line 3590
            bitset_empty((bitset_word_t *)(accepts));
            }
#line 3591
            goto __Cont;
          }
        }
#line 3594
        if (dfa->mb_cur_max > 1) {
#line 3595
          j = (Idx )0;
          {
#line 3595
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 3595
            if (! (j < 4L)) {
#line 3595
              goto while_break___2;
            }
#line 3596
            tmp___2 = accepts[j] & ~ (dfa->word_char[j] & *(dfa->sb_char + j));
#line 3596
            accepts[j] = tmp___2;
#line 3596
            any_set___0 |= tmp___2;
#line 3595
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else {
#line 3599
          j = (Idx )0;
          {
#line 3599
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 3599
            if (! (j < 4L)) {
#line 3599
              goto while_break___3;
            }
#line 3600
            tmp___3 = accepts[j] & ~ dfa->word_char[j];
#line 3600
            accepts[j] = tmp___3;
#line 3600
            any_set___0 |= tmp___3;
#line 3599
            j ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 3601
        if (! any_set___0) {
#line 3602
          goto __Cont;
        }
      }
    }
#line 3608
    j = (Idx )0;
    {
#line 3608
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3608
      if (! (j < ndests)) {
#line 3608
        goto while_break___4;
      }
#line 3616
      if ((unsigned int )type == 1U) {
        {
#line 3616
        tmp___4 = bitset_contain((bitset_word_t */* const  */)(*(dests_ch + j)), (Idx )node->opr.c);
        }
#line 3616
        if (! tmp___4) {
#line 3617
          goto __Cont___0;
        }
      }
#line 3620
      has_intersec = (bitset_word_t )0;
#line 3621
      k = (Idx )0;
      {
#line 3621
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3621
        if (! (k < 4L)) {
#line 3621
          goto while_break___5;
        }
#line 3622
        tmp___5 = accepts[k] & (*(dests_ch + j))[k];
#line 3622
        intersec[k] = tmp___5;
#line 3622
        has_intersec |= tmp___5;
#line 3621
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 3624
      if (! has_intersec) {
#line 3625
        goto __Cont___0;
      }
#line 3628
      not_consumed = (bitset_word_t )0;
#line 3628
      not_subset = not_consumed;
#line 3629
      k = (Idx )0;
      {
#line 3629
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 3629
        if (! (k < 4L)) {
#line 3629
          goto while_break___6;
        }
#line 3631
        tmp___6 = ~ accepts[k] & (*(dests_ch + j))[k];
#line 3631
        remains[k] = tmp___6;
#line 3631
        not_subset |= tmp___6;
#line 3632
        tmp___7 = accepts[k] & ~ (*(dests_ch + j))[k];
#line 3632
        accepts[k] = tmp___7;
#line 3632
        not_consumed |= tmp___7;
#line 3629
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 3637
      if (not_subset) {
        {
#line 3639
        bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t */* const  */)(remains));
#line 3640
        bitset_copy((bitset_word_t *)(*(dests_ch + j)), (bitset_word_t */* const  */)(intersec));
#line 3641
        err = re_node_set_init_copy(dests_node + ndests, (re_node_set const   *)(dests_node + j));
#line 3642
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
        }
#line 3642
        if (tmp___8) {
#line 3643
          goto error_return;
        }
#line 3644
        ndests ++;
      }
      {
#line 3648
      ok = re_node_set_insert(dests_node + j, *(cur_nodes->elems + i));
#line 3649
      tmp___9 = __builtin_expect((long )(! ok), 0L);
      }
#line 3649
      if (tmp___9) {
#line 3650
        goto error_return;
      }
#line 3653
      if (! not_consumed) {
#line 3654
        goto while_break___4;
      }
      __Cont___0: /* CIL Label */ 
#line 3608
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3657
    if (j == ndests) {
      {
#line 3659
      bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t */* const  */)(accepts));
#line 3660
      err = re_node_set_init_1(dests_node + ndests, *(cur_nodes->elems + i));
#line 3661
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
      }
#line 3661
      if (tmp___10) {
#line 3662
        goto error_return;
      }
      {
#line 3663
      ndests ++;
#line 3664
      bitset_empty((bitset_word_t *)(accepts));
      }
    }
    __Cont: /* CIL Label */ 
#line 3505
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3667
  if (! (ndests <= 256L)) {
    {
#line 3667
    __builtin_unreachable();
    }
  }
#line 3668
  return (ndests);
  error_return: 
#line 3670
  j = (Idx )0;
  {
#line 3670
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 3670
    if (! (j < ndests)) {
#line 3670
      goto while_break___7;
    }
    {
#line 3671
    free((void *)(dests_node + j)->elems);
#line 3670
    j ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 3672
  return ((Idx )-1);
}
}
#line 3688 "./regexec.c"
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) 
{ 
  re_token_t const   *node ;
  int char_len ;
  int elem_len ;
  Idx i ;
  unsigned char c ;
  unsigned char d ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  re_charset_t const   *cset ;
  int match_len ;
  wchar_t wc ;
  wint_t __attribute__((__pure__))  tmp___4 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  wctype_t wt ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 3692
  node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 3696
  tmp___1 = __builtin_expect((long )((unsigned int const   )node->type == 7U), 0L);
  }
#line 3696
  if (tmp___1) {
    {
#line 3698
    c = *(input->mbs + str_idx);
#line 3699
    tmp = __builtin_expect((long )((int )c < 194), 1L);
    }
#line 3699
    if (tmp) {
#line 3700
      return (0);
    }
#line 3702
    if (str_idx + 2L > (Idx )input->len) {
#line 3703
      return (0);
    }
#line 3705
    d = *(input->mbs + (str_idx + 1L));
#line 3706
    if ((int )c < 224) {
#line 3707
      if ((int )d < 128) {
#line 3707
        tmp___0 = 0;
      } else
#line 3707
      if ((int )d > 191) {
#line 3707
        tmp___0 = 0;
      } else {
#line 3707
        tmp___0 = 2;
      }
#line 3707
      return (tmp___0);
    } else
#line 3708
    if ((int )c < 240) {
#line 3710
      char_len = 3;
#line 3711
      if ((int )c == 224) {
#line 3711
        if ((int )d < 160) {
#line 3712
          return (0);
        }
      }
    } else
#line 3714
    if ((int )c < 248) {
#line 3716
      char_len = 4;
#line 3717
      if ((int )c == 240) {
#line 3717
        if ((int )d < 144) {
#line 3718
          return (0);
        }
      }
    } else
#line 3720
    if ((int )c < 252) {
#line 3722
      char_len = 5;
#line 3723
      if ((int )c == 248) {
#line 3723
        if ((int )d < 136) {
#line 3724
          return (0);
        }
      }
    } else
#line 3726
    if ((int )c < 254) {
#line 3728
      char_len = 6;
#line 3729
      if ((int )c == 252) {
#line 3729
        if ((int )d < 132) {
#line 3730
          return (0);
        }
      }
    } else {
#line 3733
      return (0);
    }
#line 3735
    if (str_idx + (Idx )char_len > (Idx )input->len) {
#line 3736
      return (0);
    }
#line 3738
    i = (Idx )1;
    {
#line 3738
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3738
      if (! (i < (Idx )char_len)) {
#line 3738
        goto while_break;
      }
#line 3740
      d = *(input->mbs + (str_idx + i));
#line 3741
      if ((int )d < 128) {
#line 3742
        return (0);
      } else
#line 3741
      if ((int )d > 191) {
#line 3742
        return (0);
      }
#line 3738
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3744
    return (char_len);
  }
  {
#line 3747
  tmp___2 = re_string_char_size_at(input, str_idx);
#line 3747
  char_len = (int )tmp___2;
  }
#line 3748
  if ((unsigned int const   )node->type == 5U) {
#line 3750
    if (char_len <= 1) {
#line 3751
      return (0);
    }
#line 3755
    if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3755
      if ((int )*(input->mbs + str_idx) == 10) {
#line 3759
        return (0);
      } else {
#line 3755
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3755
    if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3755
      if ((int )*(input->mbs + str_idx) == 0) {
#line 3759
        return (0);
      }
    }
#line 3760
    return (char_len);
  }
  {
#line 3763
  tmp___3 = re_string_elem_size_at(input, str_idx);
#line 3763
  elem_len = (int )tmp___3;
  }
#line 3764
  if (elem_len <= 1) {
#line 3764
    if (char_len <= 1) {
#line 3765
      return (0);
    } else {
#line 3764
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3764
  if (char_len == 0) {
#line 3765
    return (0);
  }
#line 3767
  if ((unsigned int const   )node->type == 6U) {
#line 3769
    cset = (re_charset_t const   *)node->opr.mbcset;
#line 3776
    match_len = 0;
#line 3777
    if (cset->nranges) {
      {
#line 3777
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3777
      tmp___5 = tmp___4;
      }
    } else
#line 3777
    if (cset->nchar_classes) {
      {
#line 3777
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3777
      tmp___5 = tmp___4;
      }
    } else
#line 3777
    if (cset->nmbchars) {
      {
#line 3777
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3777
      tmp___5 = tmp___4;
      }
    } else {
#line 3777
      tmp___5 = (wint_t __attribute__((__pure__))  )0;
    }
#line 3777
    wc = (wchar_t )tmp___5;
#line 3781
    i = (Idx )0;
    {
#line 3781
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3781
      if (! (i < (Idx )cset->nmbchars)) {
#line 3781
        goto while_break___0;
      }
#line 3782
      if (wc == *(cset->mbchars + i)) {
#line 3784
        match_len = char_len;
#line 3785
        goto check_node_accept_bytes_match;
      }
#line 3781
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3788
    i = (Idx )0;
    {
#line 3788
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3788
      if (! (i < (Idx )cset->nchar_classes)) {
#line 3788
        goto while_break___1;
      }
      {
#line 3790
      wt = *(cset->char_classes + i);
#line 3791
      tmp___6 = iswctype((wint_t )wc, wt);
      }
#line 3791
      if (tmp___6) {
#line 3793
        match_len = char_len;
#line 3794
        goto check_node_accept_bytes_match;
      }
#line 3788
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3890
    i = (Idx )0;
    {
#line 3890
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3890
      if (! (i < (Idx )cset->nranges)) {
#line 3890
        goto while_break___2;
      }
#line 3892
      if (*(cset->range_starts + i) <= wc) {
#line 3892
        if (wc <= *(cset->range_ends + i)) {
#line 3894
          match_len = char_len;
#line 3895
          goto check_node_accept_bytes_match;
        }
      }
#line 3890
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    check_node_accept_bytes_match: 
#line 3900
    if (! cset->non_match) {
#line 3901
      return (match_len);
    } else
#line 3904
    if (match_len > 0) {
#line 3905
      return (0);
    } else {
#line 3907
      if (elem_len > char_len) {
#line 3907
        tmp___7 = elem_len;
      } else {
#line 3907
        tmp___7 = char_len;
      }
#line 3907
      return (tmp___7);
    }
  }
#line 3910
  return (0);
}
}
#line 3977 "./regexec.c"
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) 
{ 
  unsigned char ch ;
  _Bool tmp ;
  unsigned int context ;
  unsigned int tmp___0 ;

  {
#line 3982
  ch = *(mctx->input.mbs + idx);
  {
#line 3985
  if ((unsigned int const   )node->type == 1U) {
#line 3985
    goto case_1;
  }
#line 3990
  if ((unsigned int const   )node->type == 3U) {
#line 3990
    goto case_3;
  }
#line 3996
  if ((unsigned int const   )node->type == 7U) {
#line 3996
    goto case_7;
  }
#line 4001
  if ((unsigned int const   )node->type == 5U) {
#line 4001
    goto case_5;
  }
#line 4007
  goto switch_default;
  case_1: /* CIL Label */ 
#line 3986
  if ((int const   )node->opr.c != (int const   )ch) {
#line 3987
    return ((_Bool)0);
  }
#line 3988
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 3991
  tmp = bitset_contain((bitset_word_t */* const  */)node->opr.sbcset, (Idx )ch);
  }
#line 3991
  if (! tmp) {
#line 3992
    return ((_Bool)0);
  }
#line 3993
  goto switch_break;
  case_7: /* CIL Label */ 
#line 3997
  if ((int )ch >= 128) {
#line 3998
    return ((_Bool)0);
  }
  case_5: /* CIL Label */ 
#line 4002
  if ((int )ch == 10) {
#line 4002
    if (! ((mctx->dfa)->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4004
      return ((_Bool)0);
    } else {
#line 4002
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4002
  if ((int )ch == 0) {
#line 4002
    if ((mctx->dfa)->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4004
      return ((_Bool)0);
    }
  }
#line 4005
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4008
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
#line 4011
  if (node->constraint) {
    {
#line 4015
    tmp___0 = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 4015
    context = tmp___0;
    }
#line 4017
    if (node->constraint & 4U) {
#line 4017
      if (! (context & 1U)) {
#line 4018
        return ((_Bool)0);
      } else {
#line 4017
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 4017
    if (node->constraint & 8U) {
#line 4017
      if (context & 1U) {
#line 4018
        return ((_Bool)0);
      } else {
#line 4017
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 4017
    if (node->constraint & 32U) {
#line 4017
      if (! (context & (unsigned int )(1 << 1))) {
#line 4018
        return ((_Bool)0);
      } else {
#line 4017
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4017
    if (node->constraint & 128U) {
#line 4017
      if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 4018
        return ((_Bool)0);
      }
    }
  }
#line 4021
  return ((_Bool)1);
}
}
#line 4026 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) extend_buffers)(re_match_context_t *mctx ,
                                                                               int min_len ) 
{ 
  reg_errcode_t ret ;
  re_string_t *pstr ;
  unsigned long tmp ;
  long tmp___0 ;
  Idx tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;
  long tmp___5 ;
  re_dfastate_t **new_array ;
  void *tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
#line 4031
  pstr = & mctx->input;
#line 4034
  if (9223372036854775807UL < 0xffffffffffffffffUL / sizeof(re_dfastate_t *)) {
#line 4034
    tmp = 9223372036854775807UL;
  } else {
#line 4034
    tmp = 0xffffffffffffffffUL / sizeof(re_dfastate_t *);
  }
  {
#line 4034
  tmp___0 = __builtin_expect((long )(tmp / 2UL <= (unsigned long )pstr->bufs_len),
                             0L);
  }
#line 4034
  if (tmp___0) {
#line 4036
    return ((reg_errcode_t )12);
  }
#line 4039
  if (pstr->len < pstr->bufs_len * 2L) {
#line 4039
    tmp___4 = pstr->len;
  } else {
#line 4039
    tmp___4 = pstr->bufs_len * 2L;
  }
#line 4039
  if ((Idx )min_len < tmp___4) {
#line 4039
    if (pstr->len < pstr->bufs_len * 2L) {
#line 4039
      tmp___2 = pstr->len;
    } else {
#line 4039
      tmp___2 = pstr->bufs_len * 2L;
    }
#line 4039
    tmp___3 = tmp___2;
  } else {
#line 4039
    tmp___3 = (Idx )min_len;
  }
  {
#line 4039
  ret = re_string_realloc_buffers(pstr, tmp___3);
#line 4042
  tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
  }
#line 4042
  if (tmp___5) {
#line 4043
    return (ret);
  }
#line 4045
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
    {
#line 4051
    tmp___6 = realloc((void *)mctx->state_log, (unsigned long )(pstr->bufs_len + 1L) * sizeof(re_dfastate_t *));
#line 4051
    new_array = (re_dfastate_t **)tmp___6;
#line 4053
    tmp___7 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4053
    if (tmp___7) {
#line 4054
      return ((reg_errcode_t )12);
    }
#line 4055
    mctx->state_log = new_array;
  }
#line 4059
  if (pstr->icase) {
#line 4062
    if (pstr->mb_cur_max > 1) {
      {
#line 4064
      ret = build_wcs_upper_buffer(pstr);
#line 4065
      tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
      }
#line 4065
      if (tmp___8) {
#line 4066
        return (ret);
      }
    } else {
      {
#line 4070
      build_upper_buffer(pstr);
      }
    }
  } else
#line 4075
  if (pstr->mb_cur_max > 1) {
    {
#line 4076
    build_wcs_buffer(pstr);
    }
  } else
#line 4080
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
    {
#line 4081
    re_string_translate_buffer(pstr);
    }
  }
#line 4084
  return ((reg_errcode_t )0);
}
}
#line 4092 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) match_ctx_init)(re_match_context_t *mctx ,
                                                                               int eflags ,
                                                                               Idx n ) 
{ 
  size_t max_object_size ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
#line 4096
  mctx->eflags = eflags;
#line 4097
  mctx->match_last = (Idx )-1;
#line 4098
  if (n > 0L) {
#line 4101
    if (sizeof(struct re_backref_cache_entry ) < sizeof(re_sub_match_top_t *)) {
#line 4101
      tmp = sizeof(re_sub_match_top_t *);
    } else {
#line 4101
      tmp = sizeof(struct re_backref_cache_entry );
    }
#line 4101
    max_object_size = tmp;
#line 4104
    if (9223372036854775807UL < 0xffffffffffffffffUL / max_object_size) {
#line 4104
      tmp___0 = 9223372036854775807UL;
    } else {
#line 4104
      tmp___0 = 0xffffffffffffffffUL / max_object_size;
    }
    {
#line 4104
    tmp___1 = __builtin_expect((long )(tmp___0 < (unsigned long )n), 0L);
    }
#line 4104
    if (tmp___1) {
#line 4105
      return ((reg_errcode_t )12);
    }
    {
#line 4107
    tmp___2 = malloc((unsigned long )n * sizeof(struct re_backref_cache_entry ));
#line 4107
    mctx->bkref_ents = (struct re_backref_cache_entry *)tmp___2;
#line 4108
    tmp___3 = malloc((unsigned long )n * sizeof(re_sub_match_top_t *));
#line 4108
    mctx->sub_tops = (re_sub_match_top_t **)tmp___3;
    }
#line 4109
    if ((unsigned long )mctx->bkref_ents == (unsigned long )((void *)0)) {
#line 4109
      tmp___4 = 1;
    } else
#line 4109
    if ((unsigned long )mctx->sub_tops == (unsigned long )((void *)0)) {
#line 4109
      tmp___4 = 1;
    } else {
#line 4109
      tmp___4 = 0;
    }
    {
#line 4109
    tmp___5 = __builtin_expect((long )tmp___4, 0L);
    }
#line 4109
    if (tmp___5) {
#line 4110
      return ((reg_errcode_t )12);
    }
  }
#line 4117
  mctx->abkref_ents = n;
#line 4118
  mctx->max_mb_elem_len = 1;
#line 4119
  mctx->asub_tops = n;
#line 4120
  return ((reg_errcode_t )0);
}
}
#line 4127 "./regexec.c"
static void match_ctx_clean(re_match_context_t *mctx ) 
{ 
  Idx st_idx ;
  Idx sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
#line 4131
  st_idx = (Idx )0;
  {
#line 4131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4131
    if (! (st_idx < mctx->nsub_tops)) {
#line 4131
      goto while_break;
    }
#line 4134
    top = *(mctx->sub_tops + st_idx);
#line 4135
    sl_idx = (Idx )0;
    {
#line 4135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4135
      if (! (sl_idx < top->nlasts)) {
#line 4135
        goto while_break___0;
      }
      {
#line 4137
      last = *(top->lasts + sl_idx);
#line 4138
      free((void *)last->path.array);
#line 4139
      free((void *)last);
#line 4135
      sl_idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4141
    free((void *)top->lasts);
    }
#line 4142
    if (top->path) {
      {
#line 4144
      free((void *)(top->path)->array);
#line 4145
      free((void *)top->path);
      }
    }
    {
#line 4147
    free((void *)top);
#line 4131
    st_idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4150
  mctx->nsub_tops = (Idx )0;
#line 4151
  mctx->nbkref_ents = (Idx )0;
#line 4152
  return;
}
}
#line 4156 "./regexec.c"
static void match_ctx_free(re_match_context_t *mctx ) 
{ 


  {
  {
#line 4160
  match_ctx_clean(mctx);
#line 4161
  free((void *)mctx->sub_tops);
#line 4162
  free((void *)mctx->bkref_ents);
  }
#line 4163
  return;
}
}
#line 4170 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) match_ctx_add_entry)(re_match_context_t *mctx ,
                                                                                    Idx node ,
                                                                                    Idx str_idx ,
                                                                                    Idx from ,
                                                                                    Idx to ) 
{ 
  struct re_backref_cache_entry *new_entry ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 4175
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
    {
#line 4178
    tmp = realloc((void *)mctx->bkref_ents, (unsigned long )(mctx->abkref_ents * 2L) * sizeof(struct re_backref_cache_entry ));
#line 4178
    new_entry = (struct re_backref_cache_entry *)tmp;
#line 4180
    tmp___0 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                               0L);
    }
#line 4180
    if (tmp___0) {
      {
#line 4182
      free((void *)mctx->bkref_ents);
      }
#line 4183
      return ((reg_errcode_t )12);
    }
    {
#line 4185
    mctx->bkref_ents = new_entry;
#line 4186
    memset((void *)(mctx->bkref_ents + mctx->nbkref_ents), '\000', sizeof(struct re_backref_cache_entry ) * (unsigned long )mctx->abkref_ents);
#line 4188
    mctx->abkref_ents *= 2L;
    }
  }
#line 4190
  if (mctx->nbkref_ents > 0L) {
#line 4190
    if ((mctx->bkref_ents + (mctx->nbkref_ents - 1L))->str_idx == str_idx) {
#line 4192
      (mctx->bkref_ents + (mctx->nbkref_ents - 1L))->more = (char)1;
    }
  }
#line 4194
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
#line 4195
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
#line 4196
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
#line 4197
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
#line 4207
  if (from == to) {
#line 4207
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (bitset_word_t )-1;
  } else {
#line 4207
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (bitset_word_t )0;
  }
#line 4210
  tmp___1 = mctx->nbkref_ents;
#line 4210
  (mctx->nbkref_ents) ++;
#line 4210
  (mctx->bkref_ents + tmp___1)->more = (char)0;
#line 4211
  if ((Idx )mctx->max_mb_elem_len < to - from) {
#line 4212
    mctx->max_mb_elem_len = (int )(to - from);
  }
#line 4213
  return ((reg_errcode_t )0);
}
}
#line 4219 "./regexec.c"
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) 
{ 
  Idx left ;
  Idx right ;
  Idx mid ;
  Idx last ;

  {
#line 4223
  right = (Idx )mctx->nbkref_ents;
#line 4223
  last = right;
#line 4224
  left = (Idx )0;
  {
#line 4224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4224
    if (! (left < right)) {
#line 4224
      goto while_break;
    }
#line 4226
    mid = (left + right) / 2L;
#line 4227
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
#line 4228
      left = mid + 1L;
    } else {
#line 4230
      right = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4232
  if (left < last) {
#line 4232
    if ((mctx->bkref_ents + left)->str_idx == str_idx) {
#line 4233
      return (left);
    } else {
#line 4235
      return ((Idx )-1);
    }
  } else {
#line 4235
    return ((Idx )-1);
  }
}
}
#line 4241 "./regexec.c"
static reg_errcode_t ( __attribute__((__warn_unused_result__)) match_ctx_add_subtop)(re_match_context_t *mctx ,
                                                                                     Idx node ,
                                                                                     Idx str_idx ) 
{ 
  Idx new_asub_tops ;
  re_sub_match_top_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;

  {
#line 4245
  if (! ((unsigned long )mctx->sub_tops != (unsigned long )((void *)0))) {
    {
#line 4245
    __builtin_unreachable();
    }
  }
#line 4246
  if (! (mctx->asub_tops > 0L)) {
    {
#line 4246
    __builtin_unreachable();
    }
  }
  {
#line 4247
  tmp___1 = __builtin_expect((long )(mctx->nsub_tops == mctx->asub_tops), 0L);
  }
#line 4247
  if (tmp___1) {
    {
#line 4249
    new_asub_tops = mctx->asub_tops * 2L;
#line 4250
    tmp = realloc((void *)mctx->sub_tops, (unsigned long )new_asub_tops * sizeof(re_sub_match_top_t *));
#line 4250
    new_array = (re_sub_match_top_t **)tmp;
#line 4253
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4253
    if (tmp___0) {
#line 4254
      return ((reg_errcode_t )12);
    }
#line 4255
    mctx->sub_tops = new_array;
#line 4256
    mctx->asub_tops = new_asub_tops;
  }
  {
#line 4258
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_top_t ));
#line 4258
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)tmp___2;
#line 4259
  tmp___3 = __builtin_expect((long )((unsigned long )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned long )((void *)0)),
                             0L);
  }
#line 4259
  if (tmp___3) {
#line 4260
    return ((reg_errcode_t )12);
  }
#line 4261
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
#line 4262
  tmp___4 = mctx->nsub_tops;
#line 4262
  (mctx->nsub_tops) ++;
#line 4262
  (*(mctx->sub_tops + tmp___4))->str_idx = str_idx;
#line 4263
  return ((reg_errcode_t )0);
}
}
#line 4269 "./regexec.c"
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) 
{ 
  re_sub_match_last_t *new_entry ;
  Idx new_alasts ;
  re_sub_match_last_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
  {
#line 4273
  tmp___1 = __builtin_expect((long )(subtop->nlasts == subtop->alasts), 0L);
  }
#line 4273
  if (tmp___1) {
    {
#line 4275
    new_alasts = 2L * subtop->alasts + 1L;
#line 4276
    tmp = realloc((void *)subtop->lasts, (unsigned long )new_alasts * sizeof(re_sub_match_last_t *));
#line 4276
    new_array = (re_sub_match_last_t **)tmp;
#line 4279
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
    }
#line 4279
    if (tmp___0) {
#line 4280
      return ((re_sub_match_last_t *)((void *)0));
    }
#line 4281
    subtop->lasts = new_array;
#line 4282
    subtop->alasts = new_alasts;
  }
  {
#line 4284
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_last_t ));
#line 4284
  new_entry = (re_sub_match_last_t *)tmp___2;
#line 4285
  tmp___3 = __builtin_expect((long )((unsigned long )new_entry != (unsigned long )((void *)0)),
                             1L);
  }
#line 4285
  if (tmp___3) {
#line 4287
    *(subtop->lasts + subtop->nlasts) = new_entry;
#line 4288
    new_entry->node = node;
#line 4289
    new_entry->str_idx = str_idx;
#line 4290
    (subtop->nlasts) ++;
  }
#line 4292
  return (new_entry);
}
}
#line 4295 "./regexec.c"
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) 
{ 


  {
  {
#line 4299
  sctx->sifted_states = sifted_sts;
#line 4300
  sctx->limited_states = limited_sts;
#line 4301
  sctx->last_node = last_node;
#line 4302
  sctx->last_str_idx = last_str_idx;
#line 4303
  memset((void *)(& sctx->limits), '\000', sizeof(re_node_set ));
  }
#line 4304
  return;
}
}
#line 31 "./readline.h"
char *readline(char const   *prompt ) ;
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 35 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/readline.c"
char *readline(char const   *prompt ) 
{ 
  char *out ;
  size_t size ;
  __ssize_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 38
  out = (char *)((void *)0);
#line 39
  size = (size_t )0;
#line 41
  if (prompt) {
    {
#line 43
    fputs((char const   */* __restrict  */)prompt, (FILE */* __restrict  */)stdout);
#line 44
    fflush(stdout);
    }
  }
  {
#line 47
  tmp = getline((char **/* __restrict  */)(& out), (size_t */* __restrict  */)(& size),
                (FILE */* __restrict  */)stdin);
  }
#line 47
  if (tmp < 0L) {
#line 48
    return ((char *)((void *)0));
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (*out) {
      {
#line 50
      tmp___1 = strlen((char const   *)out);
      }
#line 50
      if (! ((int )*(out + (tmp___1 - 1UL)) == 13)) {
        {
#line 50
        tmp___2 = strlen((char const   *)out);
        }
#line 50
        if (! ((int )*(out + (tmp___2 - 1UL)) == 10)) {
#line 50
          goto while_break;
        }
      }
    } else {
#line 50
      goto while_break;
    }
    {
#line 52
    tmp___0 = strlen((char const   *)out);
#line 52
    *(out + (tmp___0 - 1UL)) = (char )'\000';
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  return (out);
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 27 "./read-file.h"
char *fread_file(FILE *stream , size_t *length ) ;
#line 29
char *read_file(char const   *filename , size_t *length ) ;
#line 31
char *read_binary_file(char const   *filename , size_t *length ) ;
#line 42 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/read-file.c"
char *fread_file(FILE *stream , size_t *length ) 
{ 
  char *buf ;
  size_t alloc ;
  struct stat st ;
  off_t pos ;
  __off_t tmp ;
  off_t alloc_off ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  size_t size ;
  int save_errno ;
  size_t requested ;
  size_t count ;
  size_t tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *smaller_buf ;
  void *tmp___7 ;
  char *new_buf ;
  int *tmp___8 ;
  void *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 45
  buf = (char *)((void *)0);
#line 46
  alloc = (size_t )8192;
#line 53
  tmp___1 = fileno(stream);
#line 53
  tmp___2 = fstat(tmp___1, & st);
  }
#line 53
  if (tmp___2 >= 0) {
#line 53
    if ((st.st_mode & 61440U) == 32768U) {
      {
#line 55
      tmp = ftello(stream);
#line 55
      pos = tmp;
      }
#line 57
      if (pos >= 0L) {
#line 57
        if (pos < st.st_size) {
#line 59
          alloc_off = st.st_size - pos;
#line 62
          if (0xfffffffffffffffeUL < (unsigned long )alloc_off) {
            {
#line 64
            tmp___0 = __errno_location();
#line 64
            *tmp___0 = 12;
            }
#line 65
            return ((char *)((void *)0));
          }
#line 68
          alloc = (size_t )(alloc_off + 1L);
        }
      }
    }
  }
  {
#line 73
  tmp___3 = malloc(alloc);
#line 73
  buf = (char *)tmp___3;
  }
#line 73
  if (! buf) {
#line 74
    return ((char *)((void *)0));
  }
#line 77
  size = (size_t )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 84
    requested = alloc - size;
#line 85
    tmp___4 = fread((void */* __restrict  */)(buf + size), (size_t )1, requested,
                    (FILE */* __restrict  */)stream);
#line 85
    count = tmp___4;
#line 86
    size += count;
    }
#line 88
    if (count != requested) {
      {
#line 90
      tmp___5 = __errno_location();
#line 90
      save_errno = *tmp___5;
#line 91
      tmp___6 = ferror(stream);
      }
#line 91
      if (tmp___6) {
#line 92
        goto while_break;
      }
#line 95
      if (size < alloc - 1UL) {
        {
#line 97
        tmp___7 = realloc((void *)buf, size + 1UL);
#line 97
        smaller_buf = (char *)tmp___7;
        }
#line 98
        if ((unsigned long )smaller_buf != (unsigned long )((void *)0)) {
#line 99
          buf = smaller_buf;
        }
      }
#line 102
      *(buf + size) = (char )'\000';
#line 103
      *length = size;
#line 104
      return (buf);
    }
#line 110
    if (alloc == 0xffffffffffffffffUL) {
#line 112
      save_errno = 12;
#line 113
      goto while_break;
    }
#line 116
    if (alloc < 0xffffffffffffffffUL - alloc / 2UL) {
#line 117
      alloc += alloc / 2UL;
    } else {
#line 119
      alloc = 0xffffffffffffffffUL;
    }
    {
#line 121
    tmp___9 = realloc((void *)buf, alloc);
#line 121
    new_buf = (char *)tmp___9;
    }
#line 121
    if (! new_buf) {
      {
#line 123
      tmp___8 = __errno_location();
#line 123
      save_errno = *tmp___8;
      }
#line 124
      goto while_break;
    }
#line 127
    buf = new_buf;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  free((void *)buf);
#line 132
  tmp___10 = __errno_location();
#line 132
  *tmp___10 = save_errno;
  }
#line 133
  return ((char *)((void *)0));
}
}
#line 137 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/read-file.c"
static char *internal_read_file(char const   *filename , size_t *length , char const   *mode ) 
{ 
  FILE *stream ;
  FILE *tmp ;
  char *out ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 140
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)mode);
#line 140
  stream = tmp;
  }
#line 144
  if (! stream) {
#line 145
    return ((char *)((void *)0));
  }
  {
#line 147
  out = fread_file(stream, length);
#line 149
  tmp___0 = __errno_location();
#line 149
  save_errno = *tmp___0;
#line 151
  tmp___3 = fclose(stream);
  }
#line 151
  if (tmp___3 != 0) {
#line 153
    if (out) {
      {
#line 155
      tmp___1 = __errno_location();
#line 155
      save_errno = *tmp___1;
#line 156
      free((void *)out);
      }
    }
    {
#line 158
    tmp___2 = __errno_location();
#line 158
    *tmp___2 = save_errno;
    }
#line 159
    return ((char *)((void *)0));
  }
#line 162
  return (out);
}
}
#line 171 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/read-file.c"
char *read_file(char const   *filename , size_t *length ) 
{ 
  char *tmp ;

  {
  {
#line 174
  tmp = internal_read_file(filename, length, "r");
  }
#line 174
  return (tmp);
}
}
#line 184 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/read-file.c"
char *read_binary_file(char const   *filename , size_t *length ) 
{ 
  char *tmp ;

  {
  {
#line 187
  tmp = internal_read_file(filename, length, "rb");
  }
#line 187
  return (tmp);
}
}
#line 267 "./quotearg.h"
char const   * const  quoting_style_args[11] ;
#line 268
enum quoting_style  const  quoting_style_vals[10] ;
#line 278
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 281
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) ;
#line 285
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 294
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 300
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 311
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 326
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 333
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 342
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 352
char *quotearg_n(int n , char const   *arg ) ;
#line 355
char *quotearg(char const   *arg ) ;
#line 360
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 363
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 368
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 373
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 380
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 385
char *quotearg_char(char const   *arg , char ch ) ;
#line 388
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 391
char *quotearg_colon(char const   *arg ) ;
#line 394
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 397
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) ;
#line 403
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 408
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 413
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 418
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 423
void quotearg_free(void) ;
#line 25 "./quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 42 "./c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 168 "./c-ctype.h"
__inline _Bool c_isalnum(int c ) 
{ 


  {
  {
#line 175
  if (c == 90) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 89) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 88) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 87) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 86) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 85) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 84) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 83) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 82) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 81) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 80) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 79) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 78) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 77) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 76) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 75) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 74) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 73) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 72) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 71) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 70) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 69) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 68) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 67) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 66) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 65) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 122) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 121) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 120) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 119) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 118) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 117) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 116) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 115) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 114) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 113) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 112) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 111) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 110) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 109) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 108) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 107) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 106) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 105) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 104) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 103) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 102) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 101) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 100) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 99) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 98) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 97) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 57) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 56) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 55) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 54) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 53) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 52) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 51) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 50) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 49) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 48) {
#line 175
    goto case_90;
  }
#line 177
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 176
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 178
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 182 "./c-ctype.h"
__inline _Bool c_isalpha(int c ) 
{ 


  {
  {
#line 188
  if (c == 90) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 89) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 88) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 87) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 86) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 85) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 84) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 83) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 82) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 81) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 80) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 79) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 78) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 77) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 76) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 75) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 74) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 73) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 72) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 71) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 70) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 69) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 68) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 67) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 66) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 65) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 122) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 121) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 120) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 119) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 118) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 117) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 116) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 115) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 114) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 113) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 112) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 111) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 110) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 109) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 108) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 107) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 106) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 105) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 104) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 103) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 102) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 101) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 100) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 99) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 98) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 97) {
#line 188
    goto case_90;
  }
#line 190
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 189
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 191
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 197 "./c-ctype.h"
__inline _Bool c_isascii(int c ) 
{ 


  {
  {
#line 207
  if (c == 90) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 89) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 88) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 87) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 86) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 85) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 84) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 83) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 82) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 81) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 80) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 79) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 78) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 77) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 76) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 75) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 74) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 73) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 72) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 71) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 70) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 69) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 68) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 67) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 66) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 65) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 126) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 125) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 124) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 123) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 96) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 95) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 94) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 93) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 92) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 91) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 64) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 63) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 62) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 61) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 60) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 59) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 58) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 47) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 46) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 45) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 44) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 43) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 42) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 41) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 40) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 39) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 38) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 37) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 36) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 35) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 34) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 33) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 122) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 121) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 120) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 119) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 118) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 117) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 116) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 115) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 114) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 113) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 112) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 111) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 110) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 109) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 108) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 107) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 106) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 105) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 104) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 103) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 102) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 101) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 100) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 99) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 98) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 97) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 57) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 56) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 55) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 54) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 53) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 52) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 51) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 50) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 49) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 48) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 127) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 31) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 30) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 29) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 28) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 27) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 26) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 25) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 24) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 23) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 22) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 21) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 20) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 19) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 18) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 17) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 16) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 15) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 14) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 6) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 5) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 4) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 3) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 2) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 1) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 0) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 11) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 9) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 13) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 10) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 12) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 8) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 7) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 32) {
#line 207
    goto case_90;
  }
#line 209
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 208
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 210
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 214 "./c-ctype.h"
__inline _Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 217
  if (c == 32) {
#line 217
    tmp = 1;
  } else
#line 217
  if (c == 9) {
#line 217
    tmp = 1;
  } else {
#line 217
    tmp = 0;
  }
#line 217
  return ((_Bool )tmp);
}
}
#line 220 "./c-ctype.h"
__inline _Bool c_iscntrl(int c ) 
{ 


  {
  {
#line 225
  if (c == 127) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 31) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 30) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 29) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 28) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 27) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 26) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 25) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 24) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 23) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 22) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 21) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 20) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 19) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 18) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 17) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 16) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 15) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 14) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 6) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 5) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 4) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 3) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 2) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 1) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 0) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 11) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 9) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 13) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 10) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 12) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 8) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 7) {
#line 225
    goto case_127;
  }
#line 227
  goto switch_default;
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 226
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 228
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 232 "./c-ctype.h"
__inline _Bool c_isdigit(int c ) 
{ 


  {
  {
#line 237
  if (c == 57) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 56) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 55) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 54) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 53) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 52) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 51) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 50) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 49) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 48) {
#line 237
    goto case_57;
  }
#line 239
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 238
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 240
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 244 "./c-ctype.h"
__inline _Bool c_isgraph(int c ) 
{ 


  {
  {
#line 252
  if (c == 90) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 89) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 88) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 87) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 86) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 85) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 84) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 83) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 82) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 81) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 80) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 79) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 78) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 77) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 76) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 75) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 74) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 73) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 72) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 71) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 70) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 69) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 68) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 67) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 66) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 65) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 126) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 125) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 124) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 123) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 96) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 95) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 94) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 93) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 92) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 91) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 64) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 63) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 62) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 61) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 60) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 59) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 58) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 47) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 46) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 45) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 44) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 43) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 42) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 41) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 40) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 39) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 38) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 37) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 36) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 35) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 34) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 33) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 122) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 121) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 120) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 119) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 118) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 117) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 116) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 115) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 114) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 113) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 112) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 111) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 110) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 109) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 108) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 107) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 106) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 105) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 104) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 103) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 102) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 101) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 100) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 99) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 98) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 97) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 57) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 56) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 55) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 54) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 53) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 52) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 51) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 50) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 49) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 48) {
#line 252
    goto case_90;
  }
#line 254
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 253
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 255
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 259 "./c-ctype.h"
__inline _Bool c_islower(int c ) 
{ 


  {
  {
#line 264
  if (c == 122) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 121) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 120) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 119) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 118) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 117) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 116) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 115) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 114) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 113) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 112) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 111) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 110) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 109) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 108) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 107) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 106) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 105) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 104) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 103) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 102) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 101) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 100) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 99) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 98) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 97) {
#line 264
    goto case_122;
  }
#line 266
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 265
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 267
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 271 "./c-ctype.h"
__inline _Bool c_isprint(int c ) 
{ 


  {
  {
#line 280
  if (c == 90) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 89) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 88) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 87) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 86) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 85) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 84) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 83) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 82) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 81) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 80) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 79) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 78) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 77) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 76) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 75) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 74) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 73) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 72) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 71) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 70) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 69) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 68) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 67) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 66) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 65) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 126) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 125) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 124) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 123) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 96) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 95) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 94) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 93) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 92) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 91) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 64) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 63) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 62) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 61) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 60) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 59) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 58) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 47) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 46) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 45) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 44) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 43) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 42) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 41) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 40) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 39) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 38) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 37) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 36) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 35) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 34) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 33) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 122) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 121) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 120) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 119) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 118) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 117) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 116) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 115) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 114) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 113) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 112) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 111) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 110) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 109) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 108) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 107) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 106) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 105) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 104) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 103) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 102) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 101) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 100) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 99) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 98) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 97) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 57) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 56) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 55) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 54) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 53) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 52) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 51) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 50) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 49) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 48) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 32) {
#line 280
    goto case_90;
  }
#line 282
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 281
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 283
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 287 "./c-ctype.h"
__inline _Bool c_ispunct(int c ) 
{ 


  {
  {
#line 292
  if (c == 126) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 125) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 124) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 123) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 96) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 95) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 94) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 93) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 92) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 91) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 64) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 63) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 62) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 61) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 60) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 59) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 58) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 47) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 46) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 45) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 44) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 43) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 42) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 41) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 40) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 39) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 38) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 37) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 36) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 35) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 34) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 33) {
#line 292
    goto case_126;
  }
#line 294
  goto switch_default;
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
#line 293
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 295
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 299 "./c-ctype.h"
__inline _Bool c_isspace(int c ) 
{ 


  {
  {
#line 304
  if (c == 13) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 12) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 11) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 10) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 9) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 32) {
#line 304
    goto case_13;
  }
#line 306
  goto switch_default;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 305
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 307
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 311 "./c-ctype.h"
__inline _Bool c_isupper(int c ) 
{ 


  {
  {
#line 316
  if (c == 90) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 89) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 88) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 87) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 86) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 85) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 84) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 83) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 82) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 81) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 80) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 79) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 78) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 77) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 76) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 75) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 74) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 73) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 72) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 71) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 70) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 69) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 68) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 67) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 66) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 65) {
#line 316
    goto case_90;
  }
#line 318
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 317
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 319
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 323 "./c-ctype.h"
__inline _Bool c_isxdigit(int c ) 
{ 


  {
  {
#line 329
  if (c == 70) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 69) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 68) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 67) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 66) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 65) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 102) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 101) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 100) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 99) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 98) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 97) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 57) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 56) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 55) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 54) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 53) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 52) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 51) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 50) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 49) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 48) {
#line 329
    goto case_70;
  }
#line 331
  goto switch_default;
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 330
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 332
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 336 "./c-ctype.h"
__inline int c_tolower(int c ) 
{ 


  {
  {
#line 341
  if (c == 90) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 89) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 88) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 87) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 86) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 85) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 84) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 83) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 82) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 81) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 80) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 79) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 78) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 77) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 76) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 75) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 74) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 73) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 72) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 71) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 70) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 69) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 68) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 67) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 66) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 65) {
#line 341
    goto case_90;
  }
#line 343
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 342
  return ((c - 65) + 97);
  switch_default: /* CIL Label */ 
#line 344
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "./c-ctype.h"
__inline int c_toupper(int c ) 
{ 


  {
  {
#line 353
  if (c == 122) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 121) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 120) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 119) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 118) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 117) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 116) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 115) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 114) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 113) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 112) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 111) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 110) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 109) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 108) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 107) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 106) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 105) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 104) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 103) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 102) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 101) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 100) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 99) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 98) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 97) {
#line 353
    goto case_122;
  }
#line 355
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 354
  return ((c - 97) + 65);
  switch_default: /* CIL Label */ 
#line 356
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 41 "./c-strcaseeq.h"
__inline static int strcaseeq9(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = c_strcasecmp(s1 + 9, s2 + 9);
  }
#line 44
  return (tmp == 0);
}
}
#line 47 "./c-strcaseeq.h"
__inline static int strcaseeq8(char const   *s1 , char const   *s2 , char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 50
  tmp___2 = c_isupper((int )s28);
  }
#line 50
  if (tmp___2) {
#line 50
    tmp___1 = ((int const   )*(s1 + 8) & -33) == (int const   )s28;
  } else {
#line 50
    tmp___1 = (int const   )*(s1 + 8) == (int const   )s28;
  }
#line 50
  if (tmp___1) {
#line 52
    if ((int )s28 == 0) {
#line 53
      return (1);
    } else {
      {
#line 55
      tmp = strcaseeq9(s1, s2);
      }
#line 55
      return (tmp);
    }
  } else {
#line 58
    return (0);
  }
}
}
#line 61 "./c-strcaseeq.h"
__inline static int strcaseeq7(char const   *s1 , char const   *s2 , char s27 , char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 64
  tmp___2 = c_isupper((int )s27);
  }
#line 64
  if (tmp___2) {
#line 64
    tmp___1 = ((int const   )*(s1 + 7) & -33) == (int const   )s27;
  } else {
#line 64
    tmp___1 = (int const   )*(s1 + 7) == (int const   )s27;
  }
#line 64
  if (tmp___1) {
#line 66
    if ((int )s27 == 0) {
#line 67
      return (1);
    } else {
      {
#line 69
      tmp = strcaseeq8(s1, s2, s28);
      }
#line 69
      return (tmp);
    }
  } else {
#line 72
    return (0);
  }
}
}
#line 75 "./c-strcaseeq.h"
__inline static int strcaseeq6(char const   *s1 , char const   *s2 , char s26 , char s27 ,
                               char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 78
  tmp___2 = c_isupper((int )s26);
  }
#line 78
  if (tmp___2) {
#line 78
    tmp___1 = ((int const   )*(s1 + 6) & -33) == (int const   )s26;
  } else {
#line 78
    tmp___1 = (int const   )*(s1 + 6) == (int const   )s26;
  }
#line 78
  if (tmp___1) {
#line 80
    if ((int )s26 == 0) {
#line 81
      return (1);
    } else {
      {
#line 83
      tmp = strcaseeq7(s1, s2, s27, s28);
      }
#line 83
      return (tmp);
    }
  } else {
#line 86
    return (0);
  }
}
}
#line 89 "./c-strcaseeq.h"
__inline static int strcaseeq5(char const   *s1 , char const   *s2 , char s25 , char s26 ,
                               char s27 , char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 92
  tmp___2 = c_isupper((int )s25);
  }
#line 92
  if (tmp___2) {
#line 92
    tmp___1 = ((int const   )*(s1 + 5) & -33) == (int const   )s25;
  } else {
#line 92
    tmp___1 = (int const   )*(s1 + 5) == (int const   )s25;
  }
#line 92
  if (tmp___1) {
#line 94
    if ((int )s25 == 0) {
#line 95
      return (1);
    } else {
      {
#line 97
      tmp = strcaseeq6(s1, s2, s26, s27, s28);
      }
#line 97
      return (tmp);
    }
  } else {
#line 100
    return (0);
  }
}
}
#line 103 "./c-strcaseeq.h"
__inline static int strcaseeq4(char const   *s1 , char const   *s2 , char s24 , char s25 ,
                               char s26 , char s27 , char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 106
  tmp___2 = c_isupper((int )s24);
  }
#line 106
  if (tmp___2) {
#line 106
    tmp___1 = ((int const   )*(s1 + 4) & -33) == (int const   )s24;
  } else {
#line 106
    tmp___1 = (int const   )*(s1 + 4) == (int const   )s24;
  }
#line 106
  if (tmp___1) {
#line 108
    if ((int )s24 == 0) {
#line 109
      return (1);
    } else {
      {
#line 111
      tmp = strcaseeq5(s1, s2, s25, s26, s27, s28);
      }
#line 111
      return (tmp);
    }
  } else {
#line 114
    return (0);
  }
}
}
#line 117 "./c-strcaseeq.h"
__inline static int strcaseeq3(char const   *s1 , char const   *s2 , char s23 , char s24 ,
                               char s25 , char s26 , char s27 , char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 120
  tmp___2 = c_isupper((int )s23);
  }
#line 120
  if (tmp___2) {
#line 120
    tmp___1 = ((int const   )*(s1 + 3) & -33) == (int const   )s23;
  } else {
#line 120
    tmp___1 = (int const   )*(s1 + 3) == (int const   )s23;
  }
#line 120
  if (tmp___1) {
#line 122
    if ((int )s23 == 0) {
#line 123
      return (1);
    } else {
      {
#line 125
      tmp = strcaseeq4(s1, s2, s24, s25, s26, s27, s28);
      }
#line 125
      return (tmp);
    }
  } else {
#line 128
    return (0);
  }
}
}
#line 131 "./c-strcaseeq.h"
__inline static int strcaseeq2(char const   *s1 , char const   *s2 , char s22 , char s23 ,
                               char s24 , char s25 , char s26 , char s27 , char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 134
  tmp___2 = c_isupper((int )s22);
  }
#line 134
  if (tmp___2) {
#line 134
    tmp___1 = ((int const   )*(s1 + 2) & -33) == (int const   )s22;
  } else {
#line 134
    tmp___1 = (int const   )*(s1 + 2) == (int const   )s22;
  }
#line 134
  if (tmp___1) {
#line 136
    if ((int )s22 == 0) {
#line 137
      return (1);
    } else {
      {
#line 139
      tmp = strcaseeq3(s1, s2, s23, s24, s25, s26, s27, s28);
      }
#line 139
      return (tmp);
    }
  } else {
#line 142
    return (0);
  }
}
}
#line 145 "./c-strcaseeq.h"
__inline static int strcaseeq1(char const   *s1 , char const   *s2 , char s21 , char s22 ,
                               char s23 , char s24 , char s25 , char s26 , char s27 ,
                               char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 148
  tmp___2 = c_isupper((int )s21);
  }
#line 148
  if (tmp___2) {
#line 148
    tmp___1 = ((int const   )*(s1 + 1) & -33) == (int const   )s21;
  } else {
#line 148
    tmp___1 = (int const   )*(s1 + 1) == (int const   )s21;
  }
#line 148
  if (tmp___1) {
#line 150
    if ((int )s21 == 0) {
#line 151
      return (1);
    } else {
      {
#line 153
      tmp = strcaseeq2(s1, s2, s22, s23, s24, s25, s26, s27, s28);
      }
#line 153
      return (tmp);
    }
  } else {
#line 156
    return (0);
  }
}
}
#line 159 "./c-strcaseeq.h"
__inline static int strcaseeq0(char const   *s1 , char const   *s2 , char s20 , char s21 ,
                               char s22 , char s23 , char s24 , char s25 , char s26 ,
                               char s27 , char s28 ) 
{ 
  int tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 162
  tmp___2 = c_isupper((int )s20);
  }
#line 162
  if (tmp___2) {
#line 162
    tmp___1 = ((int const   )*(s1 + 0) & -33) == (int const   )s20;
  } else {
#line 162
    tmp___1 = (int const   )*(s1 + 0) == (int const   )s20;
  }
#line 162
  if (tmp___1) {
#line 164
    if ((int )s20 == 0) {
#line 165
      return (1);
    } else {
      {
#line 167
      tmp = strcaseeq1(s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);
      }
#line 167
      return (tmp);
    }
  } else {
#line 170
    return (0);
  }
}
}
#line 35 "./localcharset.h"
char const   *locale_charset(void) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int iswprint(wint_t __wc ) ;
#line 85 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char const   * const  quoting_style_args[11]  = 
#line 85 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"shell-escape", 
        (char const   */* const  */)"shell-escape-always",      (char const   */* const  */)"c",      (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape", 
        (char const   */* const  */)"locale",      (char const   */* const  */)"clocale",      (char const   */* const  */)0};
#line 101 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[10]  = 
#line 101
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7, 
        (enum quoting_style  const  )8,      (enum quoting_style  const  )9};
#line 116 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 121 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 124
  tmp = __errno_location();
#line 124
  e = *tmp;
  }
#line 125
  if (o) {
#line 125
    tmp___0 = o;
  } else {
#line 125
    tmp___0 = & default_quoting_options;
  }
  {
#line 125
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 125
  p = (struct quoting_options *)tmp___1;
#line 127
  tmp___2 = __errno_location();
#line 127
  *tmp___2 = e;
  }
#line 128
  return (p);
}
}
#line 132 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *tmp ;

  {
#line 135
  if (o) {
#line 135
    tmp = o;
  } else {
#line 135
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 135
  return ((enum quoting_style )tmp->style);
}
}
#line 140 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 143
  if (o) {
#line 143
    tmp = o;
  } else {
#line 143
    tmp = & default_quoting_options;
  }
#line 143
  tmp->style = s;
#line 144
  return;
}
}
#line 151 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 154
  uc = (unsigned char )c;
#line 155
  if (o) {
#line 155
    tmp = o;
  } else {
#line 155
    tmp = & default_quoting_options;
  }
#line 155
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 157
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 158
  r = (int )((*p >> shift) & 1U);
#line 159
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 160
  return (r);
}
}
#line 167 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 171
  if (! o) {
#line 172
    o = & default_quoting_options;
  }
#line 173
  r = o->flags;
#line 174
  o->flags = i;
#line 175
  return (r);
}
}
#line 178 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 182
  if (! o) {
#line 183
    o = & default_quoting_options;
  }
#line 184
  o->style = (enum quoting_style )10;
#line 185
  if (! left_quote) {
    {
#line 186
    abort();
    }
  } else
#line 185
  if (! right_quote) {
    {
#line 186
    abort();
    }
  }
#line 187
  o->left_quote = left_quote;
#line 188
  o->right_quote = right_quote;
#line 189
  return;
}
}
#line 192 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 195
  o.style = (enum quoting_style )0;
#line 195
  o.flags = 0;
#line 195
  o.quote_these_too[0] = 0U;
#line 195
  tmp = 1U;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (tmp >= 8U) {
#line 195
      goto while_break;
    }
#line 195
    o.quote_these_too[tmp] = 0U;
#line 195
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  o.left_quote = (char const   *)((void *)0);
#line 195
  o.right_quote = (char const   *)((void *)0);
#line 196
  if ((unsigned int )style == 10U) {
    {
#line 197
    abort();
    }
  }
#line 198
  o.style = style;
#line 199
  return (o);
}
}
#line 206 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 209
  tmp = dcgettext((char const   *)((void *)0), msgid, 5);
#line 209
  translation = (char const   *)tmp;
  }
#line 212
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 213
    return (translation);
  }
  {
#line 233
  locale_code = locale_charset();
#line 234
  tmp___1 = strcaseeq0(locale_code, "UTF-8", (char )'U', (char )'T', (char )'F', (char )'-',
                       (char )'8', (char)0, (char)0, (char)0, (char)0);
  }
#line 234
  if (tmp___1) {
#line 235
    if ((int const   )*(msgid + 0) == 96) {
#line 235
      tmp___0 = "\342\200\230";
    } else {
#line 235
      tmp___0 = "\342\200\231";
    }
#line 235
    return (tmp___0);
  }
  {
#line 236
  tmp___3 = strcaseeq0(locale_code, "GB18030", (char )'G', (char )'B', (char )'1',
                       (char )'8', (char )'0', (char )'3', (char )'0', (char)0, (char)0);
  }
#line 236
  if (tmp___3) {
#line 237
    if ((int const   )*(msgid + 0) == 96) {
#line 237
      tmp___2 = "\241\ae";
    } else {
#line 237
      tmp___2 = "\241\257";
    }
#line 237
    return (tmp___2);
  }
#line 239
  if ((unsigned int )s == 9U) {
#line 239
    tmp___4 = "\"";
  } else {
#line 239
    tmp___4 = "\'";
  }
#line 239
  return (tmp___4);
}
}
#line 255 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  size_t orig_buffersize ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  _Bool pending_shell_escape_end ;
  _Bool encountered_single_quote ;
  _Bool all_c_and_shell_quote_compat ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  _Bool escaping ;
  _Bool c_and_shell_quote_compat ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 264
  len = (size_t )0;
#line 265
  orig_buffersize = (size_t )0;
#line 266
  quote_string = (char const   *)0;
#line 267
  quote_string_len = (size_t )0;
#line 268
  backslash_escapes = (_Bool)0;
#line 269
  tmp = __ctype_get_mb_cur_max();
#line 269
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 270
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 271
  pending_shell_escape_end = (_Bool)0;
#line 272
  encountered_single_quote = (_Bool)0;
#line 273
  all_c_and_shell_quote_compat = (_Bool)1;
  }
  process_input: 
  {
#line 318
  if ((unsigned int )quoting_style == 6U) {
#line 318
    goto case_6;
  }
#line 322
  if ((unsigned int )quoting_style == 5U) {
#line 322
    goto case_5;
  }
#line 330
  if ((unsigned int )quoting_style == 7U) {
#line 330
    goto case_7;
  }
#line 337
  if ((unsigned int )quoting_style == 10U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 9U) {
#line 337
    goto case_10;
  }
#line 337
  if ((unsigned int )quoting_style == 8U) {
#line 337
    goto case_10;
  }
#line 374
  if ((unsigned int )quoting_style == 3U) {
#line 374
    goto case_3;
  }
#line 377
  if ((unsigned int )quoting_style == 1U) {
#line 377
    goto case_1;
  }
#line 380
  if ((unsigned int )quoting_style == 4U) {
#line 380
    goto case_4;
  }
#line 384
  if ((unsigned int )quoting_style == 2U) {
#line 384
    goto case_2;
  }
#line 392
  if ((unsigned int )quoting_style == 0U) {
#line 392
    goto case_0;
  }
#line 396
  goto switch_default;
  case_6: /* CIL Label */ 
#line 319
  quoting_style = (enum quoting_style )5;
#line 320
  elide_outer_quotes = (_Bool)1;
  case_5: /* CIL Label */ 
#line 323
  if (! elide_outer_quotes) {
    {
#line 324
    while (1) {
      while_continue: /* CIL Label */ ;
#line 324
      if (len < buffersize) {
#line 324
        *(buffer + len) = (char )'\"';
      }
#line 324
      len ++;
#line 324
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 325
  backslash_escapes = (_Bool)1;
#line 326
  quote_string = "\"";
#line 327
  quote_string_len = (size_t )1;
#line 328
  goto switch_break;
  case_7: /* CIL Label */ 
#line 331
  backslash_escapes = (_Bool)1;
#line 332
  elide_outer_quotes = (_Bool)0;
#line 333
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 339
  if ((unsigned int )quoting_style != 10U) {
    {
#line 362
    left_quote = gettext_quote("`", quoting_style);
#line 363
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 365
  if (! elide_outer_quotes) {
#line 366
    quote_string = left_quote;
    {
#line 366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 366
      if (! *quote_string) {
#line 366
        goto while_break___0;
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 367
        if (len < buffersize) {
#line 367
          *(buffer + len) = (char )*quote_string;
        }
#line 367
        len ++;
#line 367
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 368
  backslash_escapes = (_Bool)1;
#line 369
  quote_string = right_quote;
#line 370
  quote_string_len = strlen(quote_string);
  }
#line 372
  goto switch_break;
  case_3: /* CIL Label */ 
#line 375
  backslash_escapes = (_Bool)1;
  case_1: /* CIL Label */ 
#line 378
  elide_outer_quotes = (_Bool)1;
  case_4: /* CIL Label */ 
#line 381
  if (! elide_outer_quotes) {
#line 382
    backslash_escapes = (_Bool)1;
  }
  case_2: /* CIL Label */ 
#line 385
  quoting_style = (enum quoting_style )2;
#line 386
  if (! elide_outer_quotes) {
    {
#line 387
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 387
      if (len < buffersize) {
#line 387
        *(buffer + len) = (char )'\'';
      }
#line 387
      len ++;
#line 387
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 388
  quote_string = "\'";
#line 389
  quote_string_len = (size_t )1;
#line 390
  goto switch_break;
  case_0: /* CIL Label */ 
#line 393
  elide_outer_quotes = (_Bool)0;
#line 394
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 397
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 400
  i = (size_t )0;
  {
#line 400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 400
    if (argsize == 0xffffffffffffffffUL) {
#line 400
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 400
      tmp___7 = i == argsize;
    }
#line 400
    if (tmp___7) {
#line 400
      goto while_break___3;
    }
#line 404
    is_right_quote = (_Bool)0;
#line 405
    escaping = (_Bool)0;
#line 406
    c_and_shell_quote_compat = (_Bool)0;
#line 408
    if (backslash_escapes) {
#line 408
      if ((unsigned int )quoting_style != 2U) {
#line 408
        if (quote_string_len) {
#line 408
          if (argsize == 0xffffffffffffffffUL) {
#line 408
            if (1UL < quote_string_len) {
              {
#line 408
              argsize = strlen(arg);
#line 408
              tmp___0 = argsize;
              }
            } else {
#line 408
              tmp___0 = argsize;
            }
          } else {
#line 408
            tmp___0 = argsize;
          }
#line 408
          if (i + quote_string_len <= tmp___0) {
            {
#line 408
            tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                             quote_string_len);
            }
#line 408
            if (tmp___1 == 0) {
#line 419
              if (elide_outer_quotes) {
#line 420
                goto force_outer_quoting_style;
              }
#line 421
              is_right_quote = (_Bool)1;
            }
          }
        }
      }
    }
#line 424
    c = (unsigned char )*(arg + i);
    {
#line 427
    if ((int )c == 0) {
#line 427
      goto case_0___0;
    }
#line 453
    if ((int )c == 63) {
#line 453
      goto case_63;
    }
#line 491
    if ((int )c == 7) {
#line 491
      goto case_7___0;
    }
#line 492
    if ((int )c == 8) {
#line 492
      goto case_8___0;
    }
#line 493
    if ((int )c == 12) {
#line 493
      goto case_12;
    }
#line 494
    if ((int )c == 10) {
#line 494
      goto case_10___0;
    }
#line 495
    if ((int )c == 13) {
#line 495
      goto case_13;
    }
#line 496
    if ((int )c == 9) {
#line 496
      goto case_9___0;
    }
#line 497
    if ((int )c == 11) {
#line 497
      goto case_11;
    }
#line 498
    if ((int )c == 92) {
#line 498
      goto case_92;
    }
#line 525
    if ((int )c == 125) {
#line 525
      goto case_125;
    }
#line 525
    if ((int )c == 123) {
#line 525
      goto case_125;
    }
#line 529
    if ((int )c == 126) {
#line 529
      goto case_126;
    }
#line 529
    if ((int )c == 35) {
#line 529
      goto case_126;
    }
#line 533
    if ((int )c == 32) {
#line 533
      goto case_32;
    }
#line 543
    if ((int )c == 124) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 96) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 94) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 91) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 62) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 61) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 60) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 59) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 42) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 41) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 40) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 38) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 36) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 34) {
#line 543
      goto case_124;
    }
#line 543
    if ((int )c == 33) {
#line 543
      goto case_124;
    }
#line 553
    if ((int )c == 39) {
#line 553
      goto case_39___0;
    }
#line 588
    if ((int )c == 122) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 121) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 120) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 119) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 118) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 117) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 116) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 115) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 114) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 113) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 112) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 111) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 110) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 109) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 108) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 107) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 106) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 105) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 104) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 103) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 102) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 101) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 100) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 99) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 98) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 97) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 95) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 93) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 90) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 89) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 88) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 87) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 86) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 85) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 84) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 83) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 82) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 81) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 80) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 79) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 78) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 77) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 76) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 75) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 74) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 73) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 72) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 71) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 70) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 69) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 68) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 67) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 66) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 65) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 58) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 57) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 56) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 55) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 54) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 53) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 52) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 51) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 50) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 49) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 48) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 47) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 46) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 45) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 44) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 43) {
#line 588
      goto case_122;
    }
#line 588
    if ((int )c == 37) {
#line 588
      goto case_122;
    }
#line 602
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 428
    if (backslash_escapes) {
      {
#line 430
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 430
        if (elide_outer_quotes) {
#line 430
          goto force_outer_quoting_style;
        }
#line 430
        escaping = (_Bool)1;
#line 430
        if ((unsigned int )quoting_style == 2U) {
#line 430
          if (! pending_shell_escape_end) {
            {
#line 430
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer + len) = (char )'$';
              }
#line 430
              len ++;
#line 430
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 430
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 430
              if (len < buffersize) {
#line 430
                *(buffer + len) = (char )'\'';
              }
#line 430
              len ++;
#line 430
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 430
            pending_shell_escape_end = (_Bool)1;
          }
        }
        {
#line 430
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 430
          if (len < buffersize) {
#line 430
            *(buffer + len) = (char )'\\';
          }
#line 430
          len ++;
#line 430
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 430
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 437
      if ((unsigned int )quoting_style != 2U) {
#line 437
        if (i + 1UL < argsize) {
#line 437
          if (48 <= (int )*(arg + (i + 1UL))) {
#line 437
            if ((int const   )*(arg + (i + 1UL)) <= 57) {
              {
#line 440
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 440
                if (len < buffersize) {
#line 440
                  *(buffer + len) = (char )'0';
                }
#line 440
                len ++;
#line 440
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 441
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 441
                if (len < buffersize) {
#line 441
                  *(buffer + len) = (char )'0';
                }
#line 441
                len ++;
#line 441
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 443
      c = (unsigned char )'0';
    } else
#line 449
    if (flags & 1) {
#line 450
      goto __Cont;
    }
#line 451
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 456
    if ((unsigned int )quoting_style == 2U) {
#line 456
      goto case_2___0;
    }
#line 461
    if ((unsigned int )quoting_style == 5U) {
#line 461
      goto case_5___0;
    }
#line 486
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 457
    if (elide_outer_quotes) {
#line 458
      goto force_outer_quoting_style;
    }
#line 459
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 462
    if (flags & 4) {
#line 462
      if (i + 2UL < argsize) {
#line 462
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 468
            goto case_62;
          }
#line 468
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 468
            goto case_62;
          }
#line 481
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 471
          if (elide_outer_quotes) {
#line 472
            goto force_outer_quoting_style;
          }
#line 473
          c = (unsigned char )*(arg + (i + 2UL));
#line 474
          i += 2UL;
          {
#line 475
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 475
            if (len < buffersize) {
#line 475
              *(buffer + len) = (char )'?';
            }
#line 475
            len ++;
#line 475
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 476
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 476
            if (len < buffersize) {
#line 476
              *(buffer + len) = (char )'\"';
            }
#line 476
            len ++;
#line 476
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 477
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 477
            if (len < buffersize) {
#line 477
              *(buffer + len) = (char )'\"';
            }
#line 477
            len ++;
#line 477
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 478
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 478
            if (len < buffersize) {
#line 478
              *(buffer + len) = (char )'?';
            }
#line 478
            len ++;
#line 478
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 479
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 482
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 484
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 487
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 489
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 491
    esc = (unsigned char )'a';
#line 491
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 492
    esc = (unsigned char )'b';
#line 492
    goto c_escape;
    case_12: /* CIL Label */ 
#line 493
    esc = (unsigned char )'f';
#line 493
    goto c_escape;
    case_10___0: /* CIL Label */ 
#line 494
    esc = (unsigned char )'n';
#line 494
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 495
    esc = (unsigned char )'r';
#line 495
    goto c_and_shell_escape;
    case_9___0: /* CIL Label */ 
#line 496
    esc = (unsigned char )'t';
#line 496
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 497
    esc = (unsigned char )'v';
#line 497
    goto c_escape;
    case_92: /* CIL Label */ 
#line 498
    esc = c;
#line 500
    if ((unsigned int )quoting_style == 2U) {
#line 502
      if (elide_outer_quotes) {
#line 503
        goto force_outer_quoting_style;
      }
#line 504
      goto store_c;
    }
#line 509
    if (backslash_escapes) {
#line 509
      if (elide_outer_quotes) {
#line 509
        if (quote_string_len) {
#line 510
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 513
    if ((unsigned int )quoting_style == 2U) {
#line 513
      if (elide_outer_quotes) {
#line 515
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 518
    if (backslash_escapes) {
#line 520
      c = esc;
#line 521
      goto store_escape;
    }
#line 523
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 526
    if (argsize == 0xffffffffffffffffUL) {
#line 526
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 526
      tmp___2 = argsize == 1UL;
    }
#line 526
    if (! tmp___2) {
#line 527
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 530
    if (i != 0UL) {
#line 531
      goto switch_break___0;
    }
    case_32: /* CIL Label */ 
#line 534
    c_and_shell_quote_compat = (_Bool)1;
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 548
    if ((unsigned int )quoting_style == 2U) {
#line 548
      if (elide_outer_quotes) {
#line 550
        goto force_outer_quoting_style;
      }
    }
#line 551
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 554
    encountered_single_quote = (_Bool)1;
#line 555
    c_and_shell_quote_compat = (_Bool)1;
#line 556
    if ((unsigned int )quoting_style == 2U) {
#line 558
      if (elide_outer_quotes) {
#line 559
        goto force_outer_quoting_style;
      }
#line 561
      if (buffersize) {
#line 561
        if (! orig_buffersize) {
#line 566
          orig_buffersize = buffersize;
#line 567
          buffersize = (size_t )0;
        }
      }
      {
#line 570
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 570
        if (len < buffersize) {
#line 570
          *(buffer + len) = (char )'\'';
        }
#line 570
        len ++;
#line 570
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 571
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 571
        if (len < buffersize) {
#line 571
          *(buffer + len) = (char )'\\';
        }
#line 571
        len ++;
#line 571
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 572
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 572
        if (len < buffersize) {
#line 572
          *(buffer + len) = (char )'\'';
        }
#line 572
        len ++;
#line 572
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 573
      pending_shell_escape_end = (_Bool)0;
    }
#line 575
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 599
    c_and_shell_quote_compat = (_Bool)1;
#line 600
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 614
    if (unibyte_locale) {
      {
#line 616
      m = (size_t )1;
#line 617
      tmp___3 = __ctype_b_loc();
#line 617
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 622
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 624
      m = (size_t )0;
#line 625
      printable = (_Bool)1;
      }
#line 626
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 627
        argsize = strlen(arg);
        }
      }
      {
#line 629
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 632
        tmp___4 = rpl_mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 632
        bytes = tmp___4;
        }
#line 634
        if (bytes == 0UL) {
#line 635
          goto while_break___18;
        } else
#line 636
        if (bytes == 0xffffffffffffffffUL) {
#line 638
          printable = (_Bool)0;
#line 639
          goto while_break___18;
        } else
#line 641
        if (bytes == 0xfffffffffffffffeUL) {
#line 643
          printable = (_Bool)0;
          {
#line 644
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 644
            if (i + m < argsize) {
#line 644
              if (! *(arg + (i + m))) {
#line 644
                goto while_break___19;
              }
            } else {
#line 644
              goto while_break___19;
            }
#line 645
            m ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 646
          goto while_break___18;
        } else {
#line 654
          if (elide_outer_quotes) {
#line 654
            if ((unsigned int )quoting_style == 2U) {
#line 658
              j = (size_t )1;
              {
#line 658
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 658
                if (! (j < bytes)) {
#line 658
                  goto while_break___20;
                }
                {
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 662
                  goto case_124___0;
                }
#line 662
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 662
                  goto case_124___0;
                }
#line 665
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 663
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 666
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 658
                j ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
          {
#line 670
          tmp___5 = iswprint((wint_t )w);
          }
#line 670
          if (! tmp___5) {
#line 671
            printable = (_Bool)0;
          }
#line 672
          m += bytes;
        }
        {
#line 629
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 629
        if (tmp___6) {
#line 629
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 678
    c_and_shell_quote_compat = printable;
#line 680
    if (1UL < m) {
#line 680
      goto _L___0;
    } else
#line 680
    if (backslash_escapes) {
#line 680
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 684
        ilim = i + m;
        {
#line 686
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 688
          if (backslash_escapes) {
#line 688
            if (! printable) {
              {
#line 690
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 690
                if (elide_outer_quotes) {
#line 690
                  goto force_outer_quoting_style;
                }
#line 690
                escaping = (_Bool)1;
#line 690
                if ((unsigned int )quoting_style == 2U) {
#line 690
                  if (! pending_shell_escape_end) {
                    {
#line 690
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer + len) = (char )'$';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                    {
#line 690
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 690
                      if (len < buffersize) {
#line 690
                        *(buffer + len) = (char )'\'';
                      }
#line 690
                      len ++;
#line 690
                      goto while_break___25;
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 690
                    pending_shell_escape_end = (_Bool)1;
                  }
                }
                {
#line 690
                while (1) {
                  while_continue___26: /* CIL Label */ ;
#line 690
                  if (len < buffersize) {
#line 690
                    *(buffer + len) = (char )'\\';
                  }
#line 690
                  len ++;
#line 690
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
#line 690
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 691
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 691
                if (len < buffersize) {
#line 691
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 691
                len ++;
#line 691
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 692
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 692
                if (len < buffersize) {
#line 692
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 692
                len ++;
#line 692
                goto while_break___28;
              }
              while_break___28: /* CIL Label */ ;
              }
#line 693
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 688
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 695
          if (is_right_quote) {
            {
#line 697
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 697
              if (len < buffersize) {
#line 697
                *(buffer + len) = (char )'\\';
              }
#line 697
              len ++;
#line 697
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 698
            is_right_quote = (_Bool)0;
          }
#line 700
          if (ilim <= i + 1UL) {
#line 701
            goto while_break___21;
          }
          {
#line 702
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 702
            if (pending_shell_escape_end) {
#line 702
              if (! escaping) {
                {
#line 702
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
                {
#line 702
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 702
                  if (len < buffersize) {
#line 702
                    *(buffer + len) = (char )'\'';
                  }
#line 702
                  len ++;
#line 702
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 702
                pending_shell_escape_end = (_Bool)0;
              }
            }
#line 702
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 703
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 703
            if (len < buffersize) {
#line 703
              *(buffer + len) = (char )c;
            }
#line 703
            len ++;
#line 703
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 704
          i ++;
#line 704
          c = (unsigned char )*(arg + i);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 707
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 712
    if (backslash_escapes) {
#line 712
      if ((unsigned int )quoting_style != 2U) {
#line 712
        goto _L___3;
      } else {
#line 712
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 712
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 712
      if (quote_these_too) {
#line 712
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 712
          goto _L___2;
        }
      } else {
#line 712
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 712
    if (! is_right_quote) {
#line 717
      goto store_c;
    }
    store_escape: 
    {
#line 720
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 720
      if (elide_outer_quotes) {
#line 720
        goto force_outer_quoting_style;
      }
#line 720
      escaping = (_Bool)1;
#line 720
      if ((unsigned int )quoting_style == 2U) {
#line 720
        if (! pending_shell_escape_end) {
          {
#line 720
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer + len) = (char )'$';
            }
#line 720
            len ++;
#line 720
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
#line 720
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 720
            if (len < buffersize) {
#line 720
              *(buffer + len) = (char )'\'';
            }
#line 720
            len ++;
#line 720
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 720
          pending_shell_escape_end = (_Bool)1;
        }
      }
      {
#line 720
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 720
        if (len < buffersize) {
#line 720
          *(buffer + len) = (char )'\\';
        }
#line 720
        len ++;
#line 720
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 720
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    store_c: 
    {
#line 723
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 723
      if (pending_shell_escape_end) {
#line 723
        if (! escaping) {
          {
#line 723
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
#line 723
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 723
            if (len < buffersize) {
#line 723
              *(buffer + len) = (char )'\'';
            }
#line 723
            len ++;
#line 723
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 723
          pending_shell_escape_end = (_Bool)0;
        }
      }
#line 723
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 724
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 724
      if (len < buffersize) {
#line 724
        *(buffer + len) = (char )c;
      }
#line 724
      len ++;
#line 724
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 726
    if (! c_and_shell_quote_compat) {
#line 727
      all_c_and_shell_quote_compat = (_Bool)0;
    }
    __Cont: /* CIL Label */ 
#line 400
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 730
  if (len == 0UL) {
#line 730
    if ((unsigned int )quoting_style == 2U) {
#line 730
      if (elide_outer_quotes) {
#line 732
        goto force_outer_quoting_style;
      }
    }
  }
#line 738
  if ((unsigned int )quoting_style == 2U) {
#line 738
    if (! elide_outer_quotes) {
#line 738
      if (encountered_single_quote) {
#line 741
        if (all_c_and_shell_quote_compat) {
          {
#line 742
          tmp___8 = quotearg_buffer_restyled(buffer, orig_buffersize, arg, argsize,
                                             (enum quoting_style )5, flags, quote_these_too,
                                             left_quote, right_quote);
          }
#line 742
          return (tmp___8);
        } else
#line 746
        if (! buffersize) {
#line 746
          if (orig_buffersize) {
#line 749
            buffersize = orig_buffersize;
#line 750
            len = (size_t )0;
#line 751
            goto process_input;
          }
        }
      }
    }
  }
#line 755
  if (quote_string) {
#line 755
    if (! elide_outer_quotes) {
      {
#line 756
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 756
        if (! *quote_string) {
#line 756
          goto while_break___43;
        }
        {
#line 757
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 757
          if (len < buffersize) {
#line 757
            *(buffer + len) = (char )*quote_string;
          }
#line 757
          len ++;
#line 757
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 756
        quote_string ++;
      }
      while_break___43: /* CIL Label */ ;
      }
    }
  }
#line 759
  if (len < buffersize) {
#line 760
    *(buffer + len) = (char )'\000';
  }
#line 761
  return (len);
  force_outer_quoting_style: 
#line 766
  if ((unsigned int )quoting_style == 2U) {
#line 766
    if (backslash_escapes) {
#line 767
      quoting_style = (enum quoting_style )4;
    }
  }
  {
#line 768
  tmp___9 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 768
  return (tmp___9);
}
}
#line 783 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 788
  if (o) {
#line 788
    tmp = o;
  } else {
#line 788
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 788
  p = tmp;
#line 789
  tmp___0 = __errno_location();
#line 789
  e = *tmp___0;
#line 790
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 790
  r = tmp___1;
#line 793
  tmp___2 = __errno_location();
#line 793
  *tmp___2 = e;
  }
#line 794
  return (r);
}
}
#line 798 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 802
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 802
  return (tmp);
}
}
#line 811 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 815
  if (o) {
#line 815
    tmp = o;
  } else {
#line 815
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 815
  p = tmp;
#line 816
  tmp___0 = __errno_location();
#line 816
  e = *tmp___0;
  }
#line 818
  if (size) {
#line 818
    tmp___1 = 0;
  } else {
#line 818
    tmp___1 = 1;
  }
  {
#line 818
  flags = (int )(p->flags | (int const   )tmp___1);
#line 819
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 819
  bufsize = tmp___2 + 1UL;
#line 823
  tmp___3 = xcharalloc(bufsize);
#line 823
  buf = tmp___3;
#line 824
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 827
  tmp___4 = __errno_location();
#line 827
  *tmp___4 = e;
  }
#line 828
  if (size) {
#line 829
    *size = bufsize - 1UL;
  }
#line 830
  return (buf);
}
}
#line 842 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static char slot0[256]  ;
#line 843 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static int nslots  =    1;
#line 844 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 845 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 847 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  int i ;

  {
#line 850
  sv = slotvec;
#line 852
  i = 1;
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! (i < nslots)) {
#line 852
      goto while_break;
    }
    {
#line 853
    free((void *)(sv + i)->val);
#line 852
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 856
    free((void *)(sv + 0)->val);
#line 857
    slotvec0.size = sizeof(slot0);
#line 858
    slotvec0.val = slot0;
    }
  }
#line 860
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 862
    free((void *)sv);
#line 863
    slotvec = & slotvec0;
    }
  }
#line 865
  nslots = 1;
#line 866
  return;
}
}
#line 876 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  struct slotvec *sv ;
  _Bool preallocated ;
  int nmax ;
  unsigned long tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 880
  tmp = __errno_location();
#line 880
  e = *tmp;
#line 882
  sv = slotvec;
  }
#line 884
  if (n < 0) {
    {
#line 885
    abort();
    }
  }
#line 887
  if (nslots <= n) {
#line 889
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 890
    if (2147483647UL < 9223372036854775807UL / sizeof(*sv)) {
#line 890
      tmp___0 = 2147483647UL;
    } else {
#line 890
      tmp___0 = 9223372036854775807UL / sizeof(*sv);
    }
#line 890
    nmax = (int )(tmp___0 - 1UL);
#line 892
    if (nmax < n) {
      {
#line 893
      xalloc_die();
      }
    }
#line 895
    if (preallocated) {
#line 895
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 895
      tmp___1 = sv;
    }
    {
#line 895
    tmp___2 = xrealloc((void *)tmp___1, (unsigned long )(n + 1) * sizeof(*sv));
#line 895
    sv = (struct slotvec *)tmp___2;
#line 895
    slotvec = sv;
    }
#line 896
    if (preallocated) {
#line 897
      *sv = slotvec0;
    }
    {
#line 898
    memset((void *)(sv + nslots), 0, (unsigned long )((n + 1) - nslots) * sizeof(*sv));
#line 899
    nslots = n + 1;
    }
  }
  {
#line 903
  size = (sv + n)->size;
#line 904
  val = (sv + n)->val;
#line 906
  flags = (int )(options->flags | 1);
#line 907
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 907
  qsize = tmp___3;
  }
#line 913
  if (size <= qsize) {
#line 915
    size = qsize + 1UL;
#line 915
    (sv + n)->size = size;
#line 916
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 917
      free((void *)val);
      }
    }
    {
#line 918
    val = xcharalloc(size);
#line 918
    (sv + n)->val = val;
#line 919
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 925
  tmp___4 = __errno_location();
#line 925
  *tmp___4 = e;
  }
#line 926
  return (val);
}
}
#line 930 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 933
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 933
  return (tmp);
}
}
#line 936 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 939
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 939
  return (tmp);
}
}
#line 942 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 945
  tmp = quotearg_n(0, arg);
  }
#line 945
  return (tmp);
}
}
#line 948 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 951
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 951
  return (tmp);
}
}
#line 954 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 957
  tmp = quoting_options_from_style(s);
#line 957
  o = tmp;
#line 958
  tmp___0 = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& o));
  }
#line 958
  return (tmp___0);
}
}
#line 961 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 965
  tmp = quoting_options_from_style(s);
#line 965
  o = tmp;
#line 966
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 966
  return (tmp___0);
}
}
#line 969 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 972
  tmp = quotearg_n_style(0, s, arg);
  }
#line 972
  return (tmp);
}
}
#line 975 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 978
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 978
  return (tmp);
}
}
#line 981 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 985
  options = default_quoting_options;
#line 986
  set_char_quoting(& options, ch, 1);
#line 987
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 987
  return (tmp);
}
}
#line 990 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 993
  tmp = quotearg_char_mem(arg, 0xffffffffffffffffUL, ch);
  }
#line 993
  return (tmp);
}
}
#line 996 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 999
  tmp = quotearg_char(arg, (char )':');
  }
#line 999
  return (tmp);
}
}
#line 1002 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1005
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 1005
  return (tmp);
}
}
#line 1008 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 1012
  options = quoting_options_from_style(s);
#line 1013
  set_char_quoting(& options, (char )':', 1);
#line 1014
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& options));
  }
#line 1014
  return (tmp);
}
}
#line 1017 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1021
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, 0xffffffffffffffffUL);
  }
#line 1021
  return (tmp);
}
}
#line 1025 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 1030
  o = default_quoting_options;
#line 1031
  set_custom_quoting(& o, left_quote, right_quote);
#line 1032
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 1032
  return (tmp);
}
}
#line 1035 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1039
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 1039
  return (tmp);
}
}
#line 1042 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1046
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 1046
  return (tmp);
}
}
#line 1052 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )8, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 1060 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1063
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 1063
  return ((char const   *)tmp);
}
}
#line 1066 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 1069
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 1069
  return (tmp);
}
}
#line 1072 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1075
  tmp = quote_n_mem(n, arg, 0xffffffffffffffffUL);
  }
#line 1075
  return (tmp);
}
}
#line 1078 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/quotearg.c"
char const   *quote(char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1081
  tmp = quote_n(0, arg);
  }
#line 1081
  return (tmp);
}
}
#line 300 "./acl-internal.h"
void free_permission_context(struct permission_context *ctx ) ;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/qset-acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ 
  struct permission_context ctx ;
  int ret ;

  {
  {
#line 44
  memset((void *)(& ctx), 0, sizeof(ctx));
#line 45
  ctx.mode = mode;
#line 46
  ret = set_permissions(& ctx, name, desc);
#line 47
  free_permission_context(& ctx);
  }
#line 48
  return (ret);
}
}
#line 31 "./acl.h"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) ;
#line 298 "./acl-internal.h"
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) ;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/qcopy-acl.c"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) 
{ 
  struct permission_context ctx ;
  int ret ;

  {
  {
#line 45
  ret = get_permissions(src_name, source_desc, mode, & ctx);
  }
#line 46
  if (ret != 0) {
#line 47
    return (-2);
  }
  {
#line 48
  ret = set_permissions(& ctx, dst_name, dest_desc);
#line 49
  free_permission_context(& ctx);
  }
#line 50
  return (ret);
}
}
#line 32 "./progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 33 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 82 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *tmp ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___2 ;
  size_t __attribute__((__pure__))  tmp___3 ;
  size_t tmp___4 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___10 ;
  size_t __attribute__((__pure__))  tmp___11 ;
  size_t tmp___12 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )7;
#line 94
  d->dir = d->direct_alloc_dir;
#line 96
  a->count = (size_t )0;
#line 97
  a_allocated = (size_t )7;
#line 98
  a->arg = a->direct_alloc_arg;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((int const   )*cp != 0)) {
#line 134
      goto while_break;
    }
#line 136
    tmp = cp;
#line 136
    cp ++;
#line 136
    c = (char )*tmp;
#line 137
    if ((int )c == 37) {
#line 139
      arg_index = ~ ((size_t )0);
#line 140
      dp = d->dir + d->count;
#line 143
      dp->dir_start = cp - 1;
#line 144
      dp->flags = 0;
#line 145
      dp->width_start = (char const   *)((void *)0);
#line 146
      dp->width_end = (char const   *)((void *)0);
#line 147
      dp->width_arg_index = ~ ((size_t )0);
#line 148
      dp->precision_start = (char const   *)((void *)0);
#line 149
      dp->precision_end = (char const   *)((void *)0);
#line 150
      dp->precision_arg_index = ~ ((size_t )0);
#line 151
      dp->arg_index = ~ ((size_t )0);
#line 154
      if ((int const   )*cp >= 48) {
#line 154
        if ((int const   )*cp <= 57) {
#line 158
          np = cp;
          {
#line 158
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 158
            if ((int const   )*np >= 48) {
#line 158
              if (! ((int const   )*np <= 57)) {
#line 158
                goto while_break___0;
              }
            } else {
#line 158
              goto while_break___0;
            }
#line 158
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 160
          if ((int const   )*np == 36) {
#line 162
            n = (size_t )0;
#line 164
            np = cp;
            {
#line 164
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 164
              if ((int const   )*np >= 48) {
#line 164
                if (! ((int const   )*np <= 57)) {
#line 164
                  goto while_break___1;
                }
              } else {
#line 164
                goto while_break___1;
              }
#line 165
              if (n <= 1844674407370955161UL) {
#line 165
                tmp___0 = n * 10UL;
              } else {
#line 165
                tmp___0 = 0xffffffffffffffffUL;
              }
              {
#line 165
              tmp___1 = xsum(tmp___0, (size_t )((int const   )*np - 48));
#line 165
              n = (size_t )tmp___1;
#line 164
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 166
            if (n == 0UL) {
#line 168
              goto error;
            }
#line 169
            if (n == 0xffffffffffffffffUL) {
#line 171
              goto error;
            }
#line 172
            arg_index = n - 1UL;
#line 173
            cp = np + 1;
          }
        }
      }
      {
#line 178
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 180
        if ((int const   )*cp == 39) {
#line 182
          dp->flags |= 1;
#line 183
          cp ++;
        } else
#line 185
        if ((int const   )*cp == 45) {
#line 187
          dp->flags |= 2;
#line 188
          cp ++;
        } else
#line 190
        if ((int const   )*cp == 43) {
#line 192
          dp->flags |= 4;
#line 193
          cp ++;
        } else
#line 195
        if ((int const   )*cp == 32) {
#line 197
          dp->flags |= 8;
#line 198
          cp ++;
        } else
#line 200
        if ((int const   )*cp == 35) {
#line 202
          dp->flags |= 16;
#line 203
          cp ++;
        } else
#line 205
        if ((int const   )*cp == 48) {
#line 207
          dp->flags |= 32;
#line 208
          cp ++;
        } else
#line 211
        if ((int const   )*cp == 73) {
#line 213
          dp->flags |= 64;
#line 214
          cp ++;
        } else {
#line 218
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 222
      if ((int const   )*cp == 42) {
#line 224
        dp->width_start = cp;
#line 225
        cp ++;
#line 226
        dp->width_end = cp;
#line 227
        if (max_width_length < 1UL) {
#line 228
          max_width_length = (size_t )1;
        }
#line 231
        if ((int const   )*cp >= 48) {
#line 231
          if ((int const   )*cp <= 57) {
#line 235
            np___0 = cp;
            {
#line 235
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 235
              if ((int const   )*np___0 >= 48) {
#line 235
                if (! ((int const   )*np___0 <= 57)) {
#line 235
                  goto while_break___3;
                }
              } else {
#line 235
                goto while_break___3;
              }
#line 235
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 237
            if ((int const   )*np___0 == 36) {
#line 239
              n___0 = (size_t )0;
#line 241
              np___0 = cp;
              {
#line 241
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 241
                if ((int const   )*np___0 >= 48) {
#line 241
                  if (! ((int const   )*np___0 <= 57)) {
#line 241
                    goto while_break___4;
                  }
                } else {
#line 241
                  goto while_break___4;
                }
#line 242
                if (n___0 <= 1844674407370955161UL) {
#line 242
                  tmp___2 = n___0 * 10UL;
                } else {
#line 242
                  tmp___2 = 0xffffffffffffffffUL;
                }
                {
#line 242
                tmp___3 = xsum(tmp___2, (size_t )((int const   )*np___0 - 48));
#line 242
                n___0 = (size_t )tmp___3;
#line 241
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 243
              if (n___0 == 0UL) {
#line 245
                goto error;
              }
#line 246
              if (n___0 == 0xffffffffffffffffUL) {
#line 248
                goto error;
              }
#line 249
              dp->width_arg_index = n___0 - 1UL;
#line 250
              cp = np___0 + 1;
            }
          }
        }
#line 253
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 255
          tmp___4 = arg_posn;
#line 255
          arg_posn ++;
#line 255
          dp->width_arg_index = tmp___4;
#line 256
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 258
            goto error;
          }
        }
#line 260
        n___1 = dp->width_arg_index;
#line 260
        if (n___1 >= a_allocated) {
#line 260
          if (a_allocated <= 9223372036854775807UL) {
#line 260
            a_allocated *= 2UL;
          } else {
#line 260
            a_allocated = 0xffffffffffffffffUL;
          }
#line 260
          if (a_allocated <= n___1) {
            {
#line 260
            tmp___5 = xsum(n___1, (size_t )1);
#line 260
            a_allocated = (size_t )tmp___5;
            }
          }
#line 260
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 260
            memory_size = a_allocated * sizeof(argument );
          } else {
#line 260
            memory_size = 0xffffffffffffffffUL;
          }
#line 260
          if (memory_size == 0xffffffffffffffffUL) {
#line 260
            goto out_of_memory;
          }
#line 260
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 260
            tmp___6 = realloc((void *)a->arg, memory_size);
#line 260
            tmp___8 = tmp___6;
            }
          } else {
            {
#line 260
            tmp___7 = malloc(memory_size);
#line 260
            tmp___8 = tmp___7;
            }
          }
#line 260
          memory = (argument *)tmp___8;
#line 260
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 260
            goto out_of_memory;
          }
#line 260
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 260
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)a->arg,
                   a->count * sizeof(argument ));
            }
          }
#line 260
          a->arg = memory;
        }
        {
#line 260
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 260
          if (! (a->count <= n___1)) {
#line 260
            goto while_break___5;
          }
#line 260
          tmp___9 = a->count;
#line 260
          (a->count) ++;
#line 260
          (a->arg + tmp___9)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 260
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 260
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 260
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 260
          goto error;
        }
      } else
#line 262
      if ((int const   )*cp >= 48) {
#line 262
        if ((int const   )*cp <= 57) {
#line 266
          dp->width_start = cp;
          {
#line 267
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 267
            if ((int const   )*cp >= 48) {
#line 267
              if (! ((int const   )*cp <= 57)) {
#line 267
                goto while_break___6;
              }
            } else {
#line 267
              goto while_break___6;
            }
#line 267
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 269
          dp->width_end = cp;
#line 270
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 271
          if (max_width_length < width_length) {
#line 272
            max_width_length = width_length;
          }
        }
      }
#line 276
      if ((int const   )*cp == 46) {
#line 278
        cp ++;
#line 279
        if ((int const   )*cp == 42) {
#line 281
          dp->precision_start = cp - 1;
#line 282
          cp ++;
#line 283
          dp->precision_end = cp;
#line 284
          if (max_precision_length < 2UL) {
#line 285
            max_precision_length = (size_t )2;
          }
#line 288
          if ((int const   )*cp >= 48) {
#line 288
            if ((int const   )*cp <= 57) {
#line 292
              np___1 = cp;
              {
#line 292
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 292
                if ((int const   )*np___1 >= 48) {
#line 292
                  if (! ((int const   )*np___1 <= 57)) {
#line 292
                    goto while_break___7;
                  }
                } else {
#line 292
                  goto while_break___7;
                }
#line 292
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 294
              if ((int const   )*np___1 == 36) {
#line 296
                n___2 = (size_t )0;
#line 298
                np___1 = cp;
                {
#line 298
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 298
                  if ((int const   )*np___1 >= 48) {
#line 298
                    if (! ((int const   )*np___1 <= 57)) {
#line 298
                      goto while_break___8;
                    }
                  } else {
#line 298
                    goto while_break___8;
                  }
#line 299
                  if (n___2 <= 1844674407370955161UL) {
#line 299
                    tmp___10 = n___2 * 10UL;
                  } else {
#line 299
                    tmp___10 = 0xffffffffffffffffUL;
                  }
                  {
#line 299
                  tmp___11 = xsum(tmp___10, (size_t )((int const   )*np___1 - 48));
#line 299
                  n___2 = (size_t )tmp___11;
#line 298
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 300
                if (n___2 == 0UL) {
#line 302
                  goto error;
                }
#line 303
                if (n___2 == 0xffffffffffffffffUL) {
#line 306
                  goto error;
                }
#line 307
                dp->precision_arg_index = n___2 - 1UL;
#line 308
                cp = np___1 + 1;
              }
            }
          }
#line 311
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 313
            tmp___12 = arg_posn;
#line 313
            arg_posn ++;
#line 313
            dp->precision_arg_index = tmp___12;
#line 314
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 316
              goto error;
            }
          }
#line 318
          n___3 = dp->precision_arg_index;
#line 318
          if (n___3 >= a_allocated) {
#line 318
            if (a_allocated <= 9223372036854775807UL) {
#line 318
              a_allocated *= 2UL;
            } else {
#line 318
              a_allocated = 0xffffffffffffffffUL;
            }
#line 318
            if (a_allocated <= n___3) {
              {
#line 318
              tmp___13 = xsum(n___3, (size_t )1);
#line 318
              a_allocated = (size_t )tmp___13;
              }
            }
#line 318
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 318
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
#line 318
              memory_size___0 = 0xffffffffffffffffUL;
            }
#line 318
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 318
              goto out_of_memory;
            }
#line 318
            if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
              {
#line 318
              tmp___14 = realloc((void *)a->arg, memory_size___0);
#line 318
              tmp___16 = tmp___14;
              }
            } else {
              {
#line 318
              tmp___15 = malloc(memory_size___0);
#line 318
              tmp___16 = tmp___15;
              }
            }
#line 318
            memory___0 = (argument *)tmp___16;
#line 318
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 318
              goto out_of_memory;
            }
#line 318
            if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
              {
#line 318
              memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)a->arg,
                     a->count * sizeof(argument ));
              }
            }
#line 318
            a->arg = memory___0;
          }
          {
#line 318
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 318
            if (! (a->count <= n___3)) {
#line 318
              goto while_break___9;
            }
#line 318
            tmp___17 = a->count;
#line 318
            (a->count) ++;
#line 318
            (a->arg + tmp___17)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 318
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 318
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 318
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 318
            goto error;
          }
        } else {
#line 324
          dp->precision_start = cp - 1;
          {
#line 325
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 325
            if ((int const   )*cp >= 48) {
#line 325
              if (! ((int const   )*cp <= 57)) {
#line 325
                goto while_break___10;
              }
            } else {
#line 325
              goto while_break___10;
            }
#line 325
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 327
          dp->precision_end = cp;
#line 328
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 329
          if (max_precision_length < precision_length) {
#line 330
            max_precision_length = precision_length;
          }
        }
      }
#line 339
      flags = 0;
      {
#line 341
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 343
        if ((int const   )*cp == 104) {
#line 345
          flags |= 1 << (flags & 1);
#line 346
          cp ++;
        } else
#line 348
        if ((int const   )*cp == 76) {
#line 350
          flags |= 4;
#line 351
          cp ++;
        } else
#line 353
        if ((int const   )*cp == 108) {
#line 355
          flags += 8;
#line 356
          cp ++;
        } else
#line 358
        if ((int const   )*cp == 106) {
#line 360
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 363
            flags += 16;
          } else
#line 365
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 368
            flags += 8;
          }
#line 370
          cp ++;
        } else
#line 372
        if ((int const   )*cp == 122) {
#line 372
          goto _L;
        } else
#line 372
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 377
          if (sizeof(size_t ) > sizeof(long )) {
#line 380
            flags += 16;
          } else
#line 382
          if (sizeof(size_t ) > sizeof(int )) {
#line 385
            flags += 8;
          }
#line 387
          cp ++;
        } else
#line 389
        if ((int const   )*cp == 116) {
#line 391
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 394
            flags += 16;
          } else
#line 396
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 399
            flags += 8;
          }
#line 401
          cp ++;
        } else {
#line 442
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 446
      tmp___18 = cp;
#line 446
      cp ++;
#line 446
      c = (char )*tmp___18;
      {
#line 449
      if ((int )c == 105) {
#line 449
        goto case_105;
      }
#line 449
      if ((int )c == 100) {
#line 449
        goto case_105;
      }
#line 465
      if ((int )c == 88) {
#line 465
        goto case_88;
      }
#line 465
      if ((int )c == 120) {
#line 465
        goto case_88;
      }
#line 465
      if ((int )c == 117) {
#line 465
        goto case_88;
      }
#line 465
      if ((int )c == 111) {
#line 465
        goto case_88;
      }
#line 482
      if ((int )c == 65) {
#line 482
        goto case_65;
      }
#line 482
      if ((int )c == 97) {
#line 482
        goto case_65;
      }
#line 482
      if ((int )c == 71) {
#line 482
        goto case_65;
      }
#line 482
      if ((int )c == 103) {
#line 482
        goto case_65;
      }
#line 482
      if ((int )c == 69) {
#line 482
        goto case_65;
      }
#line 482
      if ((int )c == 101) {
#line 482
        goto case_65;
      }
#line 482
      if ((int )c == 70) {
#line 482
        goto case_65;
      }
#line 482
      if ((int )c == 102) {
#line 482
        goto case_65;
      }
#line 488
      if ((int )c == 99) {
#line 488
        goto case_99;
      }
#line 499
      if ((int )c == 67) {
#line 499
        goto case_67;
      }
#line 504
      if ((int )c == 115) {
#line 504
        goto case_115;
      }
#line 515
      if ((int )c == 83) {
#line 515
        goto case_83;
      }
#line 520
      if ((int )c == 112) {
#line 520
        goto case_112;
      }
#line 523
      if ((int )c == 110) {
#line 523
        goto case_110;
      }
#line 550
      if ((int )c == 37) {
#line 550
        goto case_37;
      }
#line 553
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 451
      if (flags >= 16) {
#line 452
        type = (arg_type )9;
      } else
#line 451
      if (flags & 4) {
#line 452
        type = (arg_type )9;
      } else
#line 456
      if (flags >= 8) {
#line 457
        type = (arg_type )7;
      } else
#line 458
      if (flags & 2) {
#line 459
        type = (arg_type )1;
      } else
#line 460
      if (flags & 1) {
#line 461
        type = (arg_type )3;
      } else {
#line 463
        type = (arg_type )5;
      }
#line 464
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 467
      if (flags >= 16) {
#line 468
        type = (arg_type )10;
      } else
#line 467
      if (flags & 4) {
#line 468
        type = (arg_type )10;
      } else
#line 472
      if (flags >= 8) {
#line 473
        type = (arg_type )8;
      } else
#line 474
      if (flags & 2) {
#line 475
        type = (arg_type )2;
      } else
#line 476
      if (flags & 1) {
#line 477
        type = (arg_type )4;
      } else {
#line 479
        type = (arg_type )6;
      }
#line 480
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 483
      if (flags >= 16) {
#line 484
        type = (arg_type )12;
      } else
#line 483
      if (flags & 4) {
#line 484
        type = (arg_type )12;
      } else {
#line 486
        type = (arg_type )11;
      }
#line 487
      goto switch_break;
      case_99: /* CIL Label */ 
#line 489
      if (flags >= 8) {
#line 491
        type = (arg_type )14;
      } else {
#line 496
        type = (arg_type )13;
      }
#line 497
      goto switch_break;
      case_67: /* CIL Label */ 
#line 500
      type = (arg_type )14;
#line 501
      c = (char )'c';
#line 502
      goto switch_break;
      case_115: /* CIL Label */ 
#line 505
      if (flags >= 8) {
#line 507
        type = (arg_type )16;
      } else {
#line 512
        type = (arg_type )15;
      }
#line 513
      goto switch_break;
      case_83: /* CIL Label */ 
#line 516
      type = (arg_type )16;
#line 517
      c = (char )'s';
#line 518
      goto switch_break;
      case_112: /* CIL Label */ 
#line 521
      type = (arg_type )17;
#line 522
      goto switch_break;
      case_110: /* CIL Label */ 
#line 525
      if (flags >= 16) {
#line 526
        type = (arg_type )22;
      } else
#line 525
      if (flags & 4) {
#line 526
        type = (arg_type )22;
      } else
#line 530
      if (flags >= 8) {
#line 531
        type = (arg_type )21;
      } else
#line 532
      if (flags & 2) {
#line 533
        type = (arg_type )18;
      } else
#line 534
      if (flags & 1) {
#line 535
        type = (arg_type )19;
      } else {
#line 537
        type = (arg_type )20;
      }
#line 538
      goto switch_break;
      case_37: /* CIL Label */ 
#line 551
      type = (arg_type )0;
#line 552
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 555
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 559
      if ((unsigned int )type != 0U) {
#line 561
        dp->arg_index = arg_index;
#line 562
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 564
          tmp___19 = arg_posn;
#line 564
          arg_posn ++;
#line 564
          dp->arg_index = tmp___19;
#line 565
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 567
            goto error;
          }
        }
#line 569
        n___4 = dp->arg_index;
#line 569
        if (n___4 >= a_allocated) {
#line 569
          if (a_allocated <= 9223372036854775807UL) {
#line 569
            a_allocated *= 2UL;
          } else {
#line 569
            a_allocated = 0xffffffffffffffffUL;
          }
#line 569
          if (a_allocated <= n___4) {
            {
#line 569
            tmp___20 = xsum(n___4, (size_t )1);
#line 569
            a_allocated = (size_t )tmp___20;
            }
          }
#line 569
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 569
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
#line 569
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 569
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 569
            goto out_of_memory;
          }
#line 569
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 569
            tmp___21 = realloc((void *)a->arg, memory_size___1);
#line 569
            tmp___23 = tmp___21;
            }
          } else {
            {
#line 569
            tmp___22 = malloc(memory_size___1);
#line 569
            tmp___23 = tmp___22;
            }
          }
#line 569
          memory___1 = (argument *)tmp___23;
#line 569
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 569
            goto out_of_memory;
          }
#line 569
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 569
            memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)a->arg,
                   a->count * sizeof(argument ));
            }
          }
#line 569
          a->arg = memory___1;
        }
        {
#line 569
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 569
          if (! (a->count <= n___4)) {
#line 569
            goto while_break___12;
          }
#line 569
          tmp___24 = a->count;
#line 569
          (a->count) ++;
#line 569
          (a->arg + tmp___24)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 569
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 569
          (a->arg + n___4)->type = type;
        } else
#line 569
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 569
          goto error;
        }
      }
#line 571
      dp->conversion = c;
#line 572
      dp->dir_end = cp;
#line 575
      (d->count) ++;
#line 576
      if (d->count >= d_allocated) {
#line 581
        if (d_allocated <= 9223372036854775807UL) {
#line 581
          d_allocated *= 2UL;
        } else {
#line 581
          d_allocated = 0xffffffffffffffffUL;
        }
#line 582
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 582
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
#line 582
          memory_size___2 = 0xffffffffffffffffUL;
        }
#line 583
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 585
          goto out_of_memory;
        }
#line 586
        if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
          {
#line 586
          tmp___25 = realloc((void *)d->dir, memory_size___2);
#line 586
          tmp___27 = tmp___25;
          }
        } else {
          {
#line 586
          tmp___26 = malloc(memory_size___2);
#line 586
          tmp___27 = tmp___26;
          }
        }
#line 586
        memory___2 = (char_directive *)tmp___27;
#line 589
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 591
          goto out_of_memory;
        }
#line 592
        if ((unsigned long )d->dir == (unsigned long )(d->direct_alloc_dir)) {
          {
#line 593
          memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)d->dir,
                 d->count * sizeof(char_directive ));
          }
        }
#line 594
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  (d->dir + d->count)->dir_start = cp;
#line 607
  d->max_width_length = max_width_length;
#line 608
  d->max_precision_length = max_precision_length;
#line 609
  return (0);
  error: 
#line 612
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 613
    free((void *)a->arg);
    }
  }
#line 614
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 615
    free((void *)d->dir);
    }
  }
  {
#line 616
  tmp___28 = __errno_location();
#line 616
  *tmp___28 = 22;
  }
#line 617
  return (-1);
  out_of_memory: 
#line 620
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 621
    free((void *)a->arg);
    }
  }
#line 622
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 623
    free((void *)d->dir);
    }
  }
  {
#line 624
  tmp___29 = __errno_location();
#line 624
  *tmp___29 = 12;
  }
#line 625
  return (-1);
}
}
#line 23 "./printf-frexpl.h"
long double printf_frexpl(long double x , int *expptr ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 66 "./printf-frexp.c"
long double printf_frexpl(long double x , int *expptr ) 
{ 
  int exponent ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  fpucw_t _ncw___0 ;

  {
  {
#line 72
  __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 72
  oldcw = _cw;
#line 72
  _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 72
  __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 76
  x = frexpl(x, & exponent);
#line 78
  x += x;
#line 79
  exponent --;
  }
#line 81
  if (exponent < -16382) {
    {
#line 83
    x = ldexpl(x, exponent - -16382);
#line 84
    exponent = -16382;
    }
  }
#line 186
  _ncw___0 = oldcw;
#line 186
  __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
#line 188
  *expptr = exponent;
#line 189
  return (x);
}
}
#line 23 "./printf-frexp.h"
double printf_frexp(double x , int *expptr ) ;
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 66 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/printf-frexp.c"
double printf_frexp(double x , int *expptr ) 
{ 
  int exponent ;

  {
  {
#line 76
  x = frexp(x, & exponent);
#line 78
  x += x;
#line 79
  exponent --;
  }
#line 81
  if (exponent < -1022) {
    {
#line 83
    x = ldexp(x, exponent - -1022);
#line 84
    exponent = -1022;
    }
  }
#line 188
  *expptr = exponent;
#line 189
  return (x);
}
}
#line 110 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 35 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/printf-args.c"
int printf_fetchargs(va_list___0 args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;

  {
#line 41
  i = (size_t )0;
#line 41
  ap = a->arg + 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < a->count)) {
#line 41
      goto while_break;
    }
    {
#line 44
    if ((unsigned int )ap->type == 1U) {
#line 44
      goto case_1;
    }
#line 47
    if ((unsigned int )ap->type == 2U) {
#line 47
      goto case_2;
    }
#line 50
    if ((unsigned int )ap->type == 3U) {
#line 50
      goto case_3;
    }
#line 53
    if ((unsigned int )ap->type == 4U) {
#line 53
      goto case_4;
    }
#line 56
    if ((unsigned int )ap->type == 5U) {
#line 56
      goto case_5;
    }
#line 59
    if ((unsigned int )ap->type == 6U) {
#line 59
      goto case_6;
    }
#line 62
    if ((unsigned int )ap->type == 7U) {
#line 62
      goto case_7;
    }
#line 65
    if ((unsigned int )ap->type == 8U) {
#line 65
      goto case_8;
    }
#line 68
    if ((unsigned int )ap->type == 9U) {
#line 68
      goto case_9;
    }
#line 71
    if ((unsigned int )ap->type == 10U) {
#line 71
      goto case_10;
    }
#line 74
    if ((unsigned int )ap->type == 11U) {
#line 74
      goto case_11;
    }
#line 77
    if ((unsigned int )ap->type == 12U) {
#line 77
      goto case_12;
    }
#line 80
    if ((unsigned int )ap->type == 13U) {
#line 80
      goto case_13;
    }
#line 84
    if ((unsigned int )ap->type == 14U) {
#line 84
      goto case_14;
    }
#line 94
    if ((unsigned int )ap->type == 15U) {
#line 94
      goto case_15;
    }
#line 103
    if ((unsigned int )ap->type == 16U) {
#line 103
      goto case_16;
    }
#line 121
    if ((unsigned int )ap->type == 17U) {
#line 121
      goto case_17;
    }
#line 124
    if ((unsigned int )ap->type == 18U) {
#line 124
      goto case_18;
    }
#line 127
    if ((unsigned int )ap->type == 19U) {
#line 127
      goto case_19;
    }
#line 130
    if ((unsigned int )ap->type == 20U) {
#line 130
      goto case_20;
    }
#line 133
    if ((unsigned int )ap->type == 21U) {
#line 133
      goto case_21;
    }
#line 136
    if ((unsigned int )ap->type == 22U) {
#line 136
      goto case_22;
    }
#line 178
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 45
    tmp = __builtin_va_arg(args, int );
#line 45
    ap->a.a_schar = tmp;
    }
#line 46
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 48
    tmp___0 = __builtin_va_arg(args, int );
#line 48
    ap->a.a_uchar = tmp___0;
    }
#line 49
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 51
    tmp___1 = __builtin_va_arg(args, int );
#line 51
    ap->a.a_short = tmp___1;
    }
#line 52
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 54
    tmp___2 = __builtin_va_arg(args, int );
#line 54
    ap->a.a_ushort = tmp___2;
    }
#line 55
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 57
    tmp___3 = __builtin_va_arg(args, int );
#line 57
    ap->a.a_int = tmp___3;
    }
#line 58
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 60
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 60
    ap->a.a_uint = tmp___4;
    }
#line 61
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 63
    tmp___5 = __builtin_va_arg(args, long );
#line 63
    ap->a.a_longint = tmp___5;
    }
#line 64
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 66
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 66
    ap->a.a_ulongint = tmp___6;
    }
#line 67
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 69
    tmp___7 = __builtin_va_arg(args, long long );
#line 69
    ap->a.a_longlongint = tmp___7;
    }
#line 70
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 72
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 72
    ap->a.a_ulonglongint = tmp___8;
    }
#line 73
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 75
    tmp___9 = __builtin_va_arg(args, double );
#line 75
    ap->a.a_double = tmp___9;
    }
#line 76
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 78
    tmp___10 = __builtin_va_arg(args, long double );
#line 78
    ap->a.a_longdouble = tmp___10;
    }
#line 79
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 81
    tmp___11 = __builtin_va_arg(args, int );
#line 81
    ap->a.a_char = tmp___11;
    }
#line 82
    goto switch_break;
    case_14: /* CIL Label */ 
#line 88
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 88
      tmp___13 = __builtin_va_arg(args, int );
#line 88
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 88
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 88
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 92
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 95
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 95
    ap->a.a_string = tmp___16;
    }
#line 99
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 100
      ap->a.a_string = "(NULL)";
    }
#line 101
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 104
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 104
    ap->a.a_wide_string = tmp___17;
    }
#line 108
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 117
      ap->a.a_wide_string = wide_null_string;
    }
#line 119
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 122
    tmp___18 = __builtin_va_arg(args, void *);
#line 122
    ap->a.a_pointer = tmp___18;
    }
#line 123
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 125
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 125
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 126
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 128
    tmp___20 = __builtin_va_arg(args, short *);
#line 128
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 129
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 131
    tmp___21 = __builtin_va_arg(args, int *);
#line 131
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 132
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 134
    tmp___22 = __builtin_va_arg(args, long *);
#line 134
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 135
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 137
    tmp___23 = __builtin_va_arg(args, long long *);
#line 137
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 138
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 180
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 41
    i ++;
#line 41
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 22 "./parse-datetime.h"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 28
_Bool parse_datetime2(struct timespec *result , char const   *p , struct timespec  const  *now ,
                      unsigned int flags , timezone_t tzdefault , char const   *tzstring ) ;
#line 28 "./strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 timezone_t tz , int ns ) ;
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
#line 318
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
#line 323
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
#line 323 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  {
#line 327
  tmp = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (tmp);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
#line 335
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
#line 335 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  {
#line 339
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (tmp);
}
}
#line 342
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
#line 347
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
#line 347 "/usr/include/inttypes.h"
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  {
#line 351
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (tmp);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
#line 361 "/usr/include/inttypes.h"
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  {
#line 365
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (tmp);
}
}
#line 517 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 837 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 124 "parse-datetime.y"
static _Bool time_overflow(intmax_t n ) 
{ 
  int tmp ;

  {
#line 127
  if (~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) <= n) {
#line 127
    if (n <= ((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) {
#line 127
      tmp = 0;
    } else {
#line 127
      tmp = 1;
    }
  } else {
#line 127
    tmp = 1;
  }
#line 127
  return ((_Bool )tmp);
}
}
#line 134 "parse-datetime.y"
static unsigned char to_uchar(char ch ) 
{ 


  {
#line 134
  return ((unsigned char )ch);
}
}
#line 136 "parse-datetime.y"
static void ( /* format attribute */  dbg_printf)(char const   *msg  , ...) 
{ 
  va_list___0 args ;

  {
  {
#line 141
  fputs((char const   */* __restrict  */)"date: ", (FILE */* __restrict  */)stderr);
#line 143
  __builtin_va_start(args, msg);
#line 144
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           args);
#line 145
  __builtin_va_end(args);
  }
#line 146
  return;
}
}
#line 255
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 256
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 257
static _Bool time_zone_hhmm(parser_control *pc , textint s , intmax_t mm ) ;
#line 262 "parse-datetime.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 


  {
#line 265
  if (pc->dates_seen) {
#line 265
    if (! pc->year.digits) {
#line 265
      if (! pc->rels_seen) {
#line 265
        if (pc->times_seen) {
#line 268
          pc->year_seen = (_Bool)1;
#line 269
          pc->year = text_int;
        } else
#line 265
        if (2L < text_int.digits) {
#line 268
          pc->year_seen = (_Bool)1;
#line 269
          pc->year = text_int;
        } else {
#line 265
          goto _L___1;
        }
      } else {
#line 265
        goto _L___1;
      }
    } else {
#line 265
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 273
  if (4L < text_int.digits) {
#line 275
    (pc->dates_seen) ++;
#line 276
    pc->day = text_int.value % 100L;
#line 277
    pc->month = (text_int.value / 100L) % 100L;
#line 278
    pc->year.value = text_int.value / 10000L;
#line 279
    pc->year.digits = text_int.digits - 4L;
  } else {
#line 283
    (pc->times_seen) ++;
#line 284
    if (text_int.digits <= 2L) {
#line 286
      pc->hour = text_int.value;
#line 287
      pc->minutes = (intmax_t )0;
    } else {
#line 291
      pc->hour = text_int.value / 100L;
#line 292
      pc->minutes = text_int.value % 100L;
    }
#line 294
    pc->seconds.tv_sec = (__time_t )0;
#line 295
    pc->seconds.tv_nsec = (__syscall_slong_t )0;
#line 296
    pc->meridian = 2;
  }
#line 299
  return;
}
}
#line 306
extern int ( /* missing proto */  __builtin_sub_overflow)() ;
#line 303 "parse-datetime.y"
static _Bool apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 306
  if (factor < 0) {
    {
#line 306
    tmp = __builtin_sub_overflow(pc->rel.ns, rel.ns, & pc->rel.ns);
#line 306
    tmp___0 = __builtin_sub_overflow(pc->rel.seconds, rel.seconds, & pc->rel.seconds);
#line 306
    tmp___1 = __builtin_sub_overflow(pc->rel.minutes, rel.minutes, & pc->rel.minutes);
#line 306
    tmp___2 = __builtin_sub_overflow(pc->rel.hour, rel.hour, & pc->rel.hour);
#line 306
    tmp___3 = __builtin_sub_overflow(pc->rel.day, rel.day, & pc->rel.day);
#line 306
    tmp___4 = __builtin_sub_overflow(pc->rel.month, rel.month, & pc->rel.month);
#line 306
    tmp___5 = __builtin_sub_overflow(pc->rel.year, rel.year, & pc->rel.year);
#line 306
    tmp___13 = (((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5;
    }
  } else {
    {
#line 306
    tmp___6 = __builtin_add_overflow(pc->rel.ns, rel.ns, & pc->rel.ns);
#line 306
    tmp___7 = __builtin_add_overflow(pc->rel.seconds, rel.seconds, & pc->rel.seconds);
#line 306
    tmp___8 = __builtin_add_overflow(pc->rel.minutes, rel.minutes, & pc->rel.minutes);
#line 306
    tmp___9 = __builtin_add_overflow(pc->rel.hour, rel.hour, & pc->rel.hour);
#line 306
    tmp___10 = __builtin_add_overflow(pc->rel.day, rel.day, & pc->rel.day);
#line 306
    tmp___11 = __builtin_add_overflow(pc->rel.month, rel.month, & pc->rel.month);
#line 306
    tmp___12 = __builtin_add_overflow(pc->rel.year, rel.year, & pc->rel.year);
#line 306
    tmp___13 = (((((tmp___6 | tmp___7) | tmp___8) | tmp___9) | tmp___10) | tmp___11) | tmp___12;
    }
  }
#line 306
  if (tmp___13) {
#line 321
    return ((_Bool)0);
  }
#line 322
  pc->rels_seen = (_Bool)1;
#line 323
  return ((_Bool)1);
}
}
#line 327 "parse-datetime.y"
static void set_hhmmss(parser_control *pc , intmax_t hour , intmax_t minutes , time_t sec ,
                       int nsec ) 
{ 


  {
#line 331
  pc->hour = hour;
#line 332
  pc->minutes = minutes;
#line 333
  pc->seconds.tv_sec = sec;
#line 334
  pc->seconds.tv_nsec = (__syscall_slong_t )nsec;
#line 335
  return;
}
}
#line 343
static char const   *str_days(parser_control *pc , char *buffer , int n ) ;
#line 343 "parse-datetime.y"
static char const   ordinal_values[14][11]  = 
#line 343
  { {        (char const   )'l',        (char const   )'a',        (char const   )'s',        (char const   )'t', 
            (char const   )'\000'}, 
   {        (char const   )'t',        (char const   )'h',        (char const   )'i',        (char const   )'s', 
            (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'e',        (char const   )'x',        (char const   )'t', 
            (char const   )'/',        (char const   )'f',        (char const   )'i',        (char const   )'r', 
            (char const   )'s',        (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'(',        (char const   )'S',        (char const   )'E',        (char const   )'C', 
            (char const   )'O',        (char const   )'N',        (char const   )'D',        (char const   )')', 
            (char const   )'\000'}, 
   {        (char const   )'t',        (char const   )'h',        (char const   )'i',        (char const   )'r', 
            (char const   )'d',        (char const   )'\000'}, 
   {        (char const   )'f',        (char const   )'o',        (char const   )'u',        (char const   )'r', 
            (char const   )'t',        (char const   )'h',        (char const   )'\000'}, 
   {        (char const   )'f',        (char const   )'i',        (char const   )'f',        (char const   )'t', 
            (char const   )'h',        (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'i',        (char const   )'x',        (char const   )'t', 
            (char const   )'h',        (char const   )'\000'}, 
   {        (char const   )'s',        (char const   )'e',        (char const   )'v',        (char const   )'e', 
            (char const   )'n',        (char const   )'t',        (char const   )'h',        (char const   )'\000'}, 
   {        (char const   )'e',        (char const   )'i',        (char const   )'g',        (char const   )'h', 
            (char const   )'t',        (char const   )'\000'}, 
   {        (char const   )'n',        (char const   )'i',        (char const   )'n',        (char const   )'t', 
            (char const   )'h',        (char const   )'\000'}, 
   {        (char const   )'t',        (char const   )'e',        (char const   )'n',        (char const   )'t', 
            (char const   )'h',        (char const   )'\000'}, 
   {        (char const   )'e',        (char const   )'l',        (char const   )'e',        (char const   )'v', 
            (char const   )'e',        (char const   )'n',        (char const   )'t',        (char const   )'h', 
            (char const   )'\000'}, 
   {        (char const   )'t',        (char const   )'w',        (char const   )'e',        (char const   )'l', 
            (char const   )'f',        (char const   )'t',        (char const   )'h',        (char const   )'\000'}};
#line 360 "parse-datetime.y"
static char const   days_values[7][4]  = { {        (char const   )'S',        (char const   )'u',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'M',        (char const   )'o',        (char const   )'n',        (char const   )'\000'}, 
   {        (char const   )'T',        (char const   )'u',        (char const   )'e',        (char const   )'\000'}, 
   {        (char const   )'W',        (char const   )'e',        (char const   )'d',        (char const   )'\000'}, 
   {        (char const   )'T',        (char const   )'h',        (char const   )'u',        (char const   )'\000'}, 
   {        (char const   )'F',        (char const   )'r',        (char const   )'i',        (char const   )'\000'}, 
   {        (char const   )'S',        (char const   )'a',        (char const   )'t',        (char const   )'\000'}};
#line 339 "parse-datetime.y"
static char const   *str_days(parser_control *pc , char *buffer , int n ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 374
  if (pc->debug_ordinal_day_seen) {
#line 377
    if (-1L <= pc->day_ordinal) {
#line 377
      if (pc->day_ordinal <= 12L) {
        {
#line 377
        tmp = snprintf((char */* __restrict  */)buffer, (size_t )n, (char const   */* __restrict  */)"%s",
                       ordinal_values[pc->day_ordinal + 1L]);
#line 377
        len = tmp;
        }
      } else {
        {
#line 377
        tmp___0 = snprintf((char */* __restrict  */)buffer, (size_t )n, (char const   */* __restrict  */)"%ld",
                           pc->day_ordinal);
#line 377
        len = tmp___0;
        }
      }
    } else {
      {
#line 377
      tmp___0 = snprintf((char */* __restrict  */)buffer, (size_t )n, (char const   */* __restrict  */)"%ld",
                         pc->day_ordinal);
#line 377
      len = tmp___0;
      }
    }
  } else {
#line 383
    *(buffer + 0) = (char )'\000';
#line 384
    len = 0;
  }
#line 388
  if (0 <= pc->day_number) {
#line 388
    if (pc->day_number <= 6) {
#line 388
      if (0 <= len) {
#line 388
        if (len < n) {
          {
#line 389
          snprintf((char */* __restrict  */)(buffer + len), (size_t )(n - len), (char const   */* __restrict  */)(" %s" + (len == 0)),
                   days_values[pc->day_number]);
          }
        }
      }
    }
  }
#line 395
  return ((char const   *)buffer);
}
}
#line 402 "parse-datetime.y"
static char const   *time_zone_str(int time_zone , char *time_zone_buf ) 
{ 
  char *p ;
  char sign ;
  int tmp ;
  int hour ;
  int tmp___0 ;
  int tmp___1 ;
  int offset_from_hour ;
  int tmp___2 ;
  int mm ;
  int ss ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 405
  p = (char *)time_zone_buf;
#line 406
  if (time_zone < 0) {
#line 406
    tmp = '-';
  } else {
#line 406
    tmp = '+';
  }
  {
#line 406
  sign = (char )tmp;
#line 407
  tmp___0 = abs(time_zone / 3600);
#line 407
  hour = tmp___0;
#line 408
  tmp___1 = sprintf((char */* __restrict  */)time_zone_buf, (char const   */* __restrict  */)"%c%02d",
                    (int )sign, hour);
#line 408
  p += tmp___1;
#line 409
  tmp___2 = abs(time_zone % 3600);
#line 409
  offset_from_hour = tmp___2;
  }
#line 410
  if (offset_from_hour != 0) {
#line 412
    mm = offset_from_hour / 60;
#line 413
    ss = offset_from_hour % 60;
#line 414
    tmp___3 = p;
#line 414
    p ++;
#line 414
    *tmp___3 = (char )':';
#line 415
    tmp___4 = p;
#line 415
    p ++;
#line 415
    *tmp___4 = (char )(48 + mm / 10);
#line 416
    tmp___5 = p;
#line 416
    p ++;
#line 416
    *tmp___5 = (char )(48 + mm % 10);
#line 417
    if (ss) {
#line 419
      tmp___6 = p;
#line 419
      p ++;
#line 419
      *tmp___6 = (char )':';
#line 420
      tmp___7 = p;
#line 420
      p ++;
#line 420
      *tmp___7 = (char )(48 + ss / 10);
#line 421
      tmp___8 = p;
#line 421
      p ++;
#line 421
      *tmp___8 = (char )(48 + ss % 10);
    }
#line 423
    *p = (char )'\000';
  }
#line 425
  return ((char const   *)time_zone_buf);
}
}
#line 431 "parse-datetime.y"
static void debug_print_current_time(char const   *item , parser_control *pc ) 
{ 
  _Bool space ;
  char *tmp ;
  char *tmp___0 ;
  intmax_t sec ;
  int nsec ;
  char tmp___1[100] ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char time_zone_buf[27] ;
  char const   *tmp___5 ;
  intmax_t sec___0 ;
  char *tmp___6 ;

  {
#line 434
  space = (_Bool)0;
#line 436
  if (! pc->parse_datetime_debug) {
#line 437
    return;
  }
  {
#line 440
  tmp = dcgettext((char const   *)((void *)0), "parsed %s part: ", 5);
#line 440
  dbg_printf((char const   *)tmp, item);
  }
#line 442
  if (pc->dates_seen) {
#line 442
    if (! pc->debug_dates_seen) {
      {
#line 445
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"(Y-M-D) %04ld-%02ld-%02ld",
              pc->year.value, pc->month, pc->day);
#line 447
      pc->debug_dates_seen = (_Bool)1;
#line 448
      space = (_Bool)1;
      }
    }
  }
#line 451
  if ((int )pc->year_seen != (int )pc->debug_year_seen) {
#line 453
    if (space) {
      {
#line 454
      fputc(' ', stderr);
      }
    }
    {
#line 455
    tmp___0 = dcgettext((char const   *)((void *)0), "year: %04ld", 5);
#line 455
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            pc->year.value);
#line 457
    pc->debug_year_seen = pc->year_seen;
#line 458
    space = (_Bool)1;
    }
  }
#line 461
  if (pc->times_seen) {
#line 461
    if (! pc->debug_times_seen) {
      {
#line 463
      sec = pc->seconds.tv_sec;
#line 464
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(" %02ld:%02ld:%02ld" + ! space),
              pc->hour, pc->minutes, sec);
      }
#line 466
      if (pc->seconds.tv_nsec != 0L) {
        {
#line 468
        nsec = (int )pc->seconds.tv_nsec;
#line 469
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".%09d",
                nsec);
        }
      }
#line 471
      if (pc->meridian == 1) {
        {
#line 472
        fputs((char const   */* __restrict  */)"pm", (FILE */* __restrict  */)stderr);
        }
      }
#line 474
      pc->debug_times_seen = (_Bool)1;
#line 475
      space = (_Bool)1;
    }
  }
#line 478
  if (pc->days_seen) {
#line 478
    if (! pc->debug_days_seen) {
#line 480
      if (space) {
        {
#line 481
        fputc(' ', stderr);
        }
      }
      {
#line 483
      tmp___2 = str_days(pc, tmp___1, (int )sizeof(tmp___1));
#line 483
      tmp___3 = dcgettext((char const   *)((void *)0), "%s (day ordinal=%ld number=%d)",
                          5);
#line 483
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
              tmp___2, pc->day_ordinal, pc->day_number);
#line 486
      pc->debug_days_seen = (_Bool)1;
#line 487
      space = (_Bool)1;
      }
    }
  }
#line 492
  if (pc->local_zones_seen) {
#line 492
    if (! pc->debug_local_zones_seen) {
#line 494
      if (pc->dsts_seen) {
#line 494
        tmp___4 = " DST";
      } else {
#line 494
        tmp___4 = "";
      }
      {
#line 494
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(" isdst=%d%s" + ! space),
              pc->local_isdst, tmp___4);
#line 496
      pc->debug_local_zones_seen = (_Bool)1;
#line 497
      space = (_Bool)1;
      }
    }
  }
#line 500
  if (pc->zones_seen) {
#line 500
    if (! pc->debug_zones_seen) {
      {
#line 503
      tmp___5 = time_zone_str(pc->time_zone, (char *)(time_zone_buf));
#line 503
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(" UTC%s" + ! space),
              tmp___5);
#line 505
      pc->debug_zones_seen = (_Bool)1;
#line 506
      space = (_Bool)1;
      }
    }
  }
#line 509
  if (pc->timespec_seen) {
#line 511
    sec___0 = pc->seconds.tv_sec;
#line 512
    if (space) {
      {
#line 513
      fputc(' ', stderr);
      }
    }
    {
#line 514
    tmp___6 = dcgettext((char const   *)((void *)0), "number of seconds: %ld", 5);
#line 514
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
            sec___0);
    }
  }
  {
#line 517
  fputc('\n', stderr);
  }
#line 518
  return;
}
}
#line 522 "parse-datetime.y"
static _Bool print_rel_part(_Bool space , intmax_t val , char const   *name ) 
{ 


  {
#line 525
  if (val == 0L) {
#line 526
    return (space);
  }
  {
#line 527
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(" %+ld %s" + ! space),
          val, name);
  }
#line 528
  return ((_Bool)1);
}
}
#line 531 "parse-datetime.y"
static void debug_print_relative_time(char const   *item , parser_control const   *pc ) 
{ 
  _Bool space ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 534
  space = (_Bool)0;
#line 536
  if (! pc->parse_datetime_debug) {
#line 537
    return;
  }
  {
#line 540
  tmp = dcgettext((char const   *)((void *)0), "parsed %s part: ", 5);
#line 540
  dbg_printf((char const   *)tmp, item);
  }
#line 542
  if (pc->rel.year == 0L) {
#line 542
    if (pc->rel.month == 0L) {
#line 542
      if (pc->rel.day == 0L) {
#line 542
        if (pc->rel.hour == 0L) {
#line 542
          if (pc->rel.minutes == 0L) {
#line 542
            if (pc->rel.seconds == 0L) {
#line 542
              if (pc->rel.ns == 0) {
                {
#line 547
                tmp___0 = dcgettext((char const   *)((void *)0), "today/this/now\n",
                                    5);
#line 547
                fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
                }
#line 548
                return;
              }
            }
          }
        }
      }
    }
  }
  {
#line 551
  space = print_rel_part(space, (intmax_t )pc->rel.year, "year(s)");
#line 552
  space = print_rel_part(space, (intmax_t )pc->rel.month, "month(s)");
#line 553
  space = print_rel_part(space, (intmax_t )pc->rel.day, "day(s)");
#line 554
  space = print_rel_part(space, (intmax_t )pc->rel.hour, "hour(s)");
#line 555
  space = print_rel_part(space, (intmax_t )pc->rel.minutes, "minutes");
#line 556
  space = print_rel_part(space, (intmax_t )pc->rel.seconds, "seconds");
#line 557
  print_rel_part(space, (intmax_t )pc->rel.ns, "nanoseconds");
#line 559
  fputc('\n', stderr);
  }
#line 560
  return;
}
}
#line 710 "parse-datetime.tab.c"
int yyparse(parser_control *pc ) ;
#line 979 "parse-datetime.tab.c"
static yytype_uint8 const   yytranslate[278]  = 
#line 979
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )25,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 1069 "parse-datetime.tab.c"
static yytype_int8 const   yypact[114]  = 
#line 1069
  {      (yytype_int8 const   )38,      (yytype_int8 const   )27,      (yytype_int8 const   )77,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )62,      (yytype_int8 const   )-93,      (yytype_int8 const   )82,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )66,      (yytype_int8 const   )3,      (yytype_int8 const   )74,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )75,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-93,      (yytype_int8 const   )93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )78,      (yytype_int8 const   )72,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )25, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )21, 
        (yytype_int8 const   )19,      (yytype_int8 const   )79,      (yytype_int8 const   )80,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )81,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )85, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-6,      (yytype_int8 const   )76, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )87,      (yytype_int8 const   )69,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )88,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )18,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )69,      (yytype_int8 const   )91};
#line 1088 "parse-datetime.tab.c"
static yytype_uint8 const   yydefact[114]  = 
#line 1088
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )85,      (yytype_uint8 const   )87,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )4,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )73,      (yytype_uint8 const   )62,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )35,      (yytype_uint8 const   )28,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )16,      (yytype_uint8 const   )8,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )13,      (yytype_uint8 const   )52,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )39,      (yytype_uint8 const   )36,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )77,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )64,      (yytype_uint8 const   )67,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )18,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )51,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )43,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )46,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25};
#line 1105 "parse-datetime.tab.c"
static yytype_int8 const   yypgoto[26]  = 
#line 1105
  {      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-68,      (yytype_int8 const   )-27,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )60,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-92,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )43};
#line 1113 "parse-datetime.tab.c"
static yytype_int8 const   yydefgoto[26]  = 
#line 1113
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )35,      (yytype_int8 const   )103,      (yytype_int8 const   )104,      (yytype_int8 const   )36, 
        (yytype_int8 const   )37,      (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )40, 
        (yytype_int8 const   )41,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )45, 
        (yytype_int8 const   )46,      (yytype_int8 const   )93};
#line 1123 "parse-datetime.tab.c"
static yytype_uint8 const   yytable[113]  = 
#line 1123
  {      (yytype_uint8 const   )79,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )100,      (yytype_uint8 const   )107,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )101,      (yytype_uint8 const   )110,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )77,      (yytype_uint8 const   )59,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )92,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )106,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )111,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )88,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )1,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )79,      (yytype_uint8 const   )30,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )12,      (yytype_uint8 const   )57,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )60,      (yytype_uint8 const   )48,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )6,      (yytype_uint8 const   )83,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )26,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )89,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )88};
#line 1139 "parse-datetime.tab.c"
static yytype_int8 const   yycheck[113]  = 
#line 1139
  {      (yytype_int8 const   )27,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4, 
        (yytype_int8 const   )12,      (yytype_int8 const   )15,      (yytype_int8 const   )102,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )19,      (yytype_int8 const   )15,      (yytype_int8 const   )19, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )25, 
        (yytype_int8 const   )112,      (yytype_int8 const   )25,      (yytype_int8 const   )19,      (yytype_int8 const   )27, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )107, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )25,      (yytype_int8 const   )25, 
        (yytype_int8 const   )25,      (yytype_int8 const   )113,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )25,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )23,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )96,      (yytype_int8 const   )24,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )0,      (yytype_int8 const   )12,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )4,      (yytype_int8 const   )27, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )30,      (yytype_int8 const   )22, 
        (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )19,      (yytype_int8 const   )24, 
        (yytype_int8 const   )3,      (yytype_int8 const   )19,      (yytype_int8 const   )26,      (yytype_int8 const   )20, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )59,      (yytype_int8 const   )27, 
        (yytype_int8 const   )84,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )25};
#line 1157 "parse-datetime.tab.c"
static yytype_uint8 const   yystos[114]  = 
#line 1157
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )27,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )53,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )53,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )36,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )50};
#line 1174 "parse-datetime.tab.c"
static yytype_uint8 const   yyr1[92]  = 
#line 1174
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )53};
#line 1189 "parse-datetime.tab.c"
static yytype_uint8 const   yyr2[92]  = 
#line 1189
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2};
#line 1613 "parse-datetime.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 


  {
#line 1618
  if (! yymsg) {
#line 1619
    yymsg = "Deleting";
  }
#line 1625
  return;
}
}
#line 1644 "parse-datetime.tab.c"
static YYSTYPE yyval_default  ;
#line 1634 "parse-datetime.tab.c"
int yyparse(parser_control *pc ) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  char *tmp___12 ;
  _Bool tmp___13 ;
  char *tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  intmax_t digits ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  _Bool tmp___24 ;
  _Bool tmp___25 ;
  _Bool tmp___26 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  int tmp___41 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___99 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___157 ;
  int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___167 ;
  int tmp___168 ;
  int tmp___169 ;
  int tmp___170 ;
  int tmp___171 ;
  int tmp___215 ;
  int tmp___221 ;
  int tmp___222 ;
  int tmp___223 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___273 ;
  int tmp___279 ;
  int tmp___280 ;
  int tmp___281 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  relative_time __constr_expr_7 ;
  int tmp___335 ;
  int tmp___341 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___347 ;
  int tmp___348 ;
  int tmp___349 ;
  int tmp___393 ;
  int tmp___399 ;
  int tmp___400 ;
  int tmp___401 ;
  int tmp___403 ;
  int tmp___404 ;
  int tmp___405 ;
  int tmp___406 ;
  int tmp___407 ;
  int tmp___451 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___461 ;
  int tmp___462 ;
  int tmp___463 ;
  int tmp___464 ;
  int tmp___465 ;
  int tmp___509 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___517 ;
  int tmp___519 ;
  int tmp___520 ;
  int tmp___521 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___567 ;
  int tmp___573 ;
  int tmp___574 ;
  int tmp___575 ;
  int tmp___577 ;
  int tmp___578 ;
  int tmp___579 ;
  int tmp___580 ;
  int tmp___581 ;
  int tmp___611 ;
  int tmp___612 ;
  int tmp___613 ;
  int tmp___614 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  int tmp___629 ;
  int tmp___635 ;
  int tmp___636 ;
  int tmp___637 ;
  int tmp___639 ;
  int tmp___640 ;
  int tmp___641 ;
  int tmp___642 ;
  int tmp___643 ;
  int tmp___687 ;
  int tmp___693 ;
  int tmp___694 ;
  int tmp___695 ;
  int tmp___697 ;
  int tmp___698 ;
  int tmp___699 ;
  int tmp___700 ;
  int tmp___701 ;
  int tmp___745 ;
  int tmp___751 ;
  int tmp___752 ;
  int tmp___753 ;
  int tmp___755 ;
  int tmp___756 ;
  int tmp___757 ;
  int tmp___758 ;
  int tmp___759 ;
  int tmp___803 ;
  int tmp___809 ;
  int tmp___810 ;
  int tmp___811 ;
  int tmp___813 ;
  int tmp___814 ;
  int tmp___815 ;
  int tmp___816 ;
  int tmp___817 ;
  int tmp___861 ;
  int tmp___867 ;
  int tmp___868 ;
  int tmp___869 ;
  int tmp___871 ;
  int tmp___872 ;
  int tmp___873 ;
  int tmp___874 ;
  int tmp___875 ;
  int tmp___905 ;
  int tmp___906 ;
  int tmp___907 ;
  int tmp___908 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;
  _Bool tmp___909 ;
  _Bool tmp___910 ;
  _Bool tmp___911 ;
  int tmp___912 ;

  {
#line 1645
  yylval = yyval_default;
#line 1676
  yytoken = 0;
#line 1692
  yylen = 0;
#line 1694
  yyss = yyssa;
#line 1694
  yyssp = yyss;
#line 1695
  yyvs = yyvsa;
#line 1695
  yyvsp = yyvs;
#line 1696
  yystacksize = 20UL;
#line 1700
  yystate = 0;
#line 1701
  yyerrstatus = 0;
#line 1702
  yynerrs = 0;
#line 1703
  yychar = -2;
#line 1704
  goto yysetstate;
  yynewstate: 
#line 1712
  yyssp ++;
  yysetstate: 
#line 1715
  *yyssp = (yytype_int16 )yystate;
#line 1717
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1720
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1747
    if (20UL <= yystacksize) {
#line 1748
      goto yyexhaustedlab;
    }
#line 1749
    yystacksize *= 2UL;
#line 1750
    if (20UL < yystacksize) {
#line 1751
      yystacksize = 20UL;
    }
    {
#line 1754
    yyss1 = yyss;
#line 1755
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1755
    yyptr = (union yyalloc *)tmp;
    }
#line 1757
    if (! yyptr) {
#line 1758
      goto yyexhaustedlab;
    }
    {
#line 1759
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1759
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1759
      yyss = & yyptr->yyss_alloc;
#line 1759
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1759
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1759
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1760
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1760
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1760
      yyvs = & yyptr->yyvs_alloc;
#line 1760
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1760
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1760
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1762
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1763
      free((void *)yyss1);
      }
    }
#line 1768
    yyssp = (yyss + yysize) - 1;
#line 1769
    yyvsp = (yyvs + yysize) - 1;
#line 1774
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1775
      goto yyabortlab;
    }
  }
#line 1780
  if (yystate == 12) {
#line 1781
    goto yyacceptlab;
  }
#line 1783
  goto yybackup;
  yybackup: 
#line 1794
  yyn = (int )yypact[yystate];
#line 1795
  if (! (! (yyn == -93))) {
#line 1796
    goto yydefault;
  }
#line 1801
  if (yychar == -2) {
    {
#line 1804
    yychar = yylex(& yylval, pc);
    }
  }
#line 1807
  if (yychar <= 0) {
#line 1809
    yytoken = 0;
#line 1809
    yychar = yytoken;
  } else
#line 1814
  if ((unsigned int )yychar <= 277U) {
#line 1814
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1814
    yytoken = 2;
  }
#line 1820
  yyn += yytoken;
#line 1821
  if (yyn < 0) {
#line 1822
    goto yydefault;
  } else
#line 1821
  if (112 < yyn) {
#line 1822
    goto yydefault;
  } else
#line 1821
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1822
    goto yydefault;
  }
#line 1823
  yyn = (int )yytable[yyn];
#line 1824
  if (yyn <= 0) {
#line 1828
    yyn = - yyn;
#line 1829
    goto yyreduce;
  }
#line 1834
  if (yyerrstatus) {
#line 1835
    yyerrstatus --;
  }
#line 1841
  yychar = -2;
#line 1843
  yystate = yyn;
#line 1845
  yyvsp ++;
#line 1845
  *yyvsp = yylval;
#line 1848
  goto yynewstate;
  yydefault: 
#line 1855
  yyn = (int )yydefact[yystate];
#line 1856
  if (yyn == 0) {
#line 1857
    goto yyerrlab;
  }
#line 1858
  goto yyreduce;
  yyreduce: 
#line 1866
  yylen = (int )yyr2[yyn];
#line 1876
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1882
  if (yyn == 4) {
#line 1882
    goto case_4;
  }
#line 1892
  if (yyn == 7) {
#line 1892
    goto case_7;
  }
#line 1901
  if (yyn == 8) {
#line 1901
    goto case_8;
  }
#line 1910
  if (yyn == 9) {
#line 1910
    goto case_9;
  }
#line 1919
  if (yyn == 10) {
#line 1919
    goto case_10;
  }
#line 1928
  if (yyn == 11) {
#line 1928
    goto case_11;
  }
#line 1937
  if (yyn == 12) {
#line 1937
    goto case_12;
  }
#line 1946
  if (yyn == 13) {
#line 1946
    goto case_13;
  }
#line 1954
  if (yyn == 14) {
#line 1954
    goto case_14;
  }
#line 1962
  if (yyn == 15) {
#line 1962
    goto case_15;
  }
#line 1970
  if (yyn == 18) {
#line 1970
    goto case_18;
  }
#line 1979
  if (yyn == 19) {
#line 1979
    goto case_19;
  }
#line 1988
  if (yyn == 20) {
#line 1988
    goto case_20;
  }
#line 1997
  if (yyn == 22) {
#line 1997
    goto case_22;
  }
#line 2006
  if (yyn == 23) {
#line 2006
    goto case_23;
  }
#line 2015
  if (yyn == 24) {
#line 2015
    goto case_24;
  }
#line 2024
  if (yyn == 27) {
#line 2024
    goto case_27;
  }
#line 2033
  if (yyn == 28) {
#line 2033
    goto case_28;
  }
#line 2039
  if (yyn == 29) {
#line 2039
    goto case_29;
  }
#line 2048
  if (yyn == 30) {
#line 2048
    goto case_30;
  }
#line 2054
  if (yyn == 31) {
#line 2054
    goto case_31;
  }
#line 2060
  if (yyn == 32) {
#line 2060
    goto case_32;
  }
#line 2069
  if (yyn == 33) {
#line 2069
    goto case_33;
  }
#line 2078
  if (yyn == 34) {
#line 2078
    goto case_34;
  }
#line 2085
  if (yyn == 35) {
#line 2085
    goto case_35;
  }
#line 2091
  if (yyn == 36) {
#line 2091
    goto case_36;
  }
#line 2097
  if (yyn == 37) {
#line 2097
    goto case_37;
  }
#line 2106
  if (yyn == 38) {
#line 2106
    goto case_38;
  }
#line 2115
  if (yyn == 39) {
#line 2115
    goto case_39;
  }
#line 2125
  if (yyn == 40) {
#line 2125
    goto case_40;
  }
#line 2135
  if (yyn == 41) {
#line 2135
    goto case_41;
  }
#line 2144
  if (yyn == 42) {
#line 2144
    goto case_42;
  }
#line 2181
  if (yyn == 43) {
#line 2181
    goto case_43;
  }
#line 2193
  if (yyn == 44) {
#line 2193
    goto case_44;
  }
#line 2205
  if (yyn == 45) {
#line 2205
    goto case_45;
  }
#line 2214
  if (yyn == 46) {
#line 2214
    goto case_46;
  }
#line 2224
  if (yyn == 47) {
#line 2224
    goto case_47;
  }
#line 2233
  if (yyn == 48) {
#line 2233
    goto case_48;
  }
#line 2243
  if (yyn == 50) {
#line 2243
    goto case_50;
  }
#line 2254
  if (yyn == 51) {
#line 2254
    goto case_51;
  }
#line 2260
  if (yyn == 52) {
#line 2260
    goto case_52;
  }
#line 2266
  if (yyn == 53) {
#line 2266
    goto case_53;
  }
#line 2272
  if (yyn == 54) {
#line 2272
    goto case_54;
  }
#line 2278
  if (yyn == 55) {
#line 2278
    goto case_55;
  }
#line 2284
  if (yyn == 56) {
#line 2284
    goto case_56;
  }
#line 2290
  if (yyn == 57) {
#line 2290
    goto case_57;
  }
#line 2296
  if (yyn == 58) {
#line 2296
    goto case_58;
  }
#line 2302
  if (yyn == 59) {
#line 2302
    goto case_59;
  }
#line 2308
  if (yyn == 60) {
#line 2308
    goto case_60;
  }
#line 2315
  if (yyn == 61) {
#line 2315
    goto case_61;
  }
#line 2322
  if (yyn == 62) {
#line 2322
    goto case_62;
  }
#line 2328
  if (yyn == 63) {
#line 2328
    goto case_63;
  }
#line 2334
  if (yyn == 64) {
#line 2334
    goto case_64;
  }
#line 2340
  if (yyn == 65) {
#line 2340
    goto case_65;
  }
#line 2346
  if (yyn == 66) {
#line 2346
    goto case_66;
  }
#line 2352
  if (yyn == 67) {
#line 2352
    goto case_67;
  }
#line 2358
  if (yyn == 68) {
#line 2358
    goto case_68;
  }
#line 2364
  if (yyn == 69) {
#line 2364
    goto case_69;
  }
#line 2370
  if (yyn == 70) {
#line 2370
    goto case_70;
  }
#line 2376
  if (yyn == 71) {
#line 2376
    goto case_71;
  }
#line 2382
  if (yyn == 72) {
#line 2382
    goto case_72;
  }
#line 2388
  if (yyn == 73) {
#line 2388
    goto case_73;
  }
#line 2394
  if (yyn == 75) {
#line 2394
    goto case_75;
  }
#line 2400
  if (yyn == 76) {
#line 2400
    goto case_76;
  }
#line 2406
  if (yyn == 77) {
#line 2406
    goto case_77;
  }
#line 2413
  if (yyn == 78) {
#line 2413
    goto case_78;
  }
#line 2419
  if (yyn == 79) {
#line 2419
    goto case_79;
  }
#line 2425
  if (yyn == 80) {
#line 2425
    goto case_80;
  }
#line 2431
  if (yyn == 81) {
#line 2431
    goto case_81;
  }
#line 2437
  if (yyn == 85) {
#line 2437
    goto case_85;
  }
#line 2444
  if (yyn == 87) {
#line 2444
    goto case_87;
  }
#line 2451
  if (yyn == 88) {
#line 2451
    goto case_88;
  }
#line 2457
  if (yyn == 89) {
#line 2457
    goto case_89;
  }
#line 2468
  if (yyn == 90) {
#line 2468
    goto case_90;
  }
#line 2474
  if (yyn == 91) {
#line 2474
    goto case_91;
  }
#line 2482
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 610 "parse-datetime.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 611
  pc->timespec_seen = (_Bool)1;
#line 612
  tmp___0 = dcgettext((char const   *)((void *)0), "number of seconds", 5);
#line 612
  debug_print_current_time((char const   *)tmp___0, pc);
  }
#line 1890 "parse-datetime.tab.c"
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 624 "parse-datetime.y"
  (pc->times_seen) ++;
#line 624
  (pc->dates_seen) ++;
#line 625
  tmp___1 = dcgettext((char const   *)((void *)0), "datetime", 5);
#line 625
  debug_print_current_time((char const   *)tmp___1, pc);
  }
#line 1899 "parse-datetime.tab.c"
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 629 "parse-datetime.y"
  (pc->times_seen) ++;
#line 630
  tmp___2 = dcgettext((char const   *)((void *)0), "time", 5);
#line 630
  debug_print_current_time((char const   *)tmp___2, pc);
  }
#line 1908 "parse-datetime.tab.c"
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 634 "parse-datetime.y"
  (pc->local_zones_seen) ++;
#line 635
  tmp___3 = dcgettext((char const   *)((void *)0), "local_zone", 5);
#line 635
  debug_print_current_time((char const   *)tmp___3, pc);
  }
#line 1917 "parse-datetime.tab.c"
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 639 "parse-datetime.y"
  (pc->zones_seen) ++;
#line 640
  tmp___4 = dcgettext((char const   *)((void *)0), "zone", 5);
#line 640
  debug_print_current_time((char const   *)tmp___4, pc);
  }
#line 1926 "parse-datetime.tab.c"
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 644 "parse-datetime.y"
  (pc->dates_seen) ++;
#line 645
  tmp___5 = dcgettext((char const   *)((void *)0), "date", 5);
#line 645
  debug_print_current_time((char const   *)tmp___5, pc);
  }
#line 1935 "parse-datetime.tab.c"
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 649 "parse-datetime.y"
  (pc->days_seen) ++;
#line 650
  tmp___6 = dcgettext((char const   *)((void *)0), "day", 5);
#line 650
  debug_print_current_time((char const   *)tmp___6, pc);
  }
#line 1944 "parse-datetime.tab.c"
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 654 "parse-datetime.y"
  tmp___7 = dcgettext((char const   *)((void *)0), "relative", 5);
#line 654
  debug_print_relative_time((char const   *)tmp___7, (parser_control const   *)pc);
  }
#line 1952 "parse-datetime.tab.c"
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 658 "parse-datetime.y"
  tmp___8 = dcgettext((char const   *)((void *)0), "number", 5);
#line 658
  debug_print_current_time((char const   *)tmp___8, pc);
  }
#line 1960 "parse-datetime.tab.c"
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 662 "parse-datetime.y"
  tmp___9 = dcgettext((char const   *)((void *)0), "hybrid", 5);
#line 662
  debug_print_relative_time((char const   *)tmp___9, (parser_control const   *)pc);
  }
#line 1968 "parse-datetime.tab.c"
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 677 "parse-datetime.y"
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, (intmax_t )0, (time_t )0, 0);
#line 678
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 1977 "parse-datetime.tab.c"
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 682 "parse-datetime.y"
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0);
#line 683
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 1986 "parse-datetime.tab.c"
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 687 "parse-datetime.y"
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (int )(yyvsp + -1)->timespec.tv_nsec);
#line 688
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 1995 "parse-datetime.tab.c"
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 696 "parse-datetime.y"
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, (intmax_t )0, (time_t )0, 0);
#line 697
  pc->meridian = 2;
  }
#line 2004 "parse-datetime.tab.c"
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 701 "parse-datetime.y"
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0);
#line 702
  pc->meridian = 2;
  }
#line 2013 "parse-datetime.tab.c"
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 706 "parse-datetime.y"
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (int )(yyvsp + -1)->timespec.tv_nsec);
#line 707
  pc->meridian = 2;
  }
#line 2022 "parse-datetime.tab.c"
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 719 "parse-datetime.y"
  (pc->zones_seen) ++;
#line 720
  tmp___10 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 720
  if (! tmp___10) {
#line 720
    goto yyabortlab;
  }
#line 2031 "parse-datetime.tab.c"
  goto switch_break;
  case_28: /* CIL Label */ 
#line 743 "parse-datetime.y"
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 2037 "parse-datetime.tab.c"
  goto switch_break;
  case_29: /* CIL Label */ 
#line 746 "parse-datetime.y"
  pc->local_isdst = 1;
#line 747
  (pc->dsts_seen) ++;
#line 2046 "parse-datetime.tab.c"
  goto switch_break;
  case_30: /* CIL Label */ 
#line 755 "parse-datetime.y"
  pc->time_zone = (int )(yyvsp + 0)->intval;
#line 2052 "parse-datetime.tab.c"
  goto switch_break;
  case_31: /* CIL Label */ 
#line 757 "parse-datetime.y"
  pc->time_zone = -25200;
#line 2058 "parse-datetime.tab.c"
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 759 "parse-datetime.y"
  pc->time_zone = (int )(yyvsp + -1)->intval;
#line 760
  tmp___11 = apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 760
  if (! tmp___11) {
#line 760
    goto yyabortlab;
  }
  {
#line 761
  tmp___12 = dcgettext((char const   *)((void *)0), "relative", 5);
#line 761
  debug_print_relative_time((char const   *)tmp___12, (parser_control const   *)pc);
  }
#line 2067 "parse-datetime.tab.c"
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 764 "parse-datetime.y"
  pc->time_zone = -25200;
#line 765
  tmp___13 = apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 765
  if (! tmp___13) {
#line 765
    goto yyabortlab;
  }
  {
#line 766
  tmp___14 = dcgettext((char const   *)((void *)0), "relative", 5);
#line 766
  debug_print_relative_time((char const   *)tmp___14, (parser_control const   *)pc);
  }
#line 2076 "parse-datetime.tab.c"
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 769 "parse-datetime.y"
  tmp___15 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 769
  if (! tmp___15) {
#line 769
    goto yyabortlab;
  }
  {
#line 770
  tmp___16 = __builtin_add_overflow(pc->time_zone, (yyvsp + -2)->intval, & pc->time_zone);
  }
#line 770
  if (tmp___16) {
#line 770
    goto yyabortlab;
  }
#line 2083 "parse-datetime.tab.c"
  goto switch_break;
  case_35: /* CIL Label */ 
#line 772 "parse-datetime.y"
  pc->time_zone = (int )((yyvsp + 0)->intval + 3600L);
#line 2089 "parse-datetime.tab.c"
  goto switch_break;
  case_36: /* CIL Label */ 
#line 774 "parse-datetime.y"
  pc->time_zone = (int )((yyvsp + -1)->intval + 3600L);
#line 2095 "parse-datetime.tab.c"
  goto switch_break;
  case_37: /* CIL Label */ 
#line 780 "parse-datetime.y"
  pc->day_ordinal = (intmax_t )0;
#line 781
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 2104 "parse-datetime.tab.c"
  goto switch_break;
  case_38: /* CIL Label */ 
#line 785 "parse-datetime.y"
  pc->day_ordinal = (intmax_t )0;
#line 786
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 2113 "parse-datetime.tab.c"
  goto switch_break;
  case_39: /* CIL Label */ 
#line 790 "parse-datetime.y"
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 791
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 792
  pc->debug_ordinal_day_seen = (_Bool)1;
#line 2123 "parse-datetime.tab.c"
  goto switch_break;
  case_40: /* CIL Label */ 
#line 796 "parse-datetime.y"
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 797
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 798
  pc->debug_ordinal_day_seen = (_Bool)1;
#line 2133 "parse-datetime.tab.c"
  goto switch_break;
  case_41: /* CIL Label */ 
#line 805 "parse-datetime.y"
  pc->month = (yyvsp + -2)->textintval.value;
#line 806
  pc->day = (yyvsp + 0)->textintval.value;
#line 2142 "parse-datetime.tab.c"
  goto switch_break;
  case_42: /* CIL Label */ 
#line 815
  if (4L <= (yyvsp + -4)->textintval.digits) {
#line 817
    if (pc->parse_datetime_debug) {
      {
#line 819
      digits = (yyvsp + -4)->textintval.digits;
#line 820
      tmp___17 = dcgettext((char const   *)((void *)0), "warning: value %ld has %ld digits. Assuming YYYY/MM/DD\n",
                           5);
#line 820
      dbg_printf((char const   *)tmp___17, (yyvsp + -4)->textintval.value, digits);
      }
    }
#line 825
    pc->year = (yyvsp + -4)->textintval;
#line 826
    pc->month = (yyvsp + -2)->textintval.value;
#line 827
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 831
    if (pc->parse_datetime_debug) {
      {
#line 832 "parse-datetime.y"
      tmp___18 = dcgettext((char const   *)((void *)0), "warning: value %ld has less than 4 digits. Assuming MM/DD/YY[YY]\n",
                           5);
#line 832
      dbg_printf((char const   *)tmp___18, (yyvsp + -4)->textintval.value);
      }
    }
#line 836
    pc->month = (yyvsp + -4)->textintval.value;
#line 837
    pc->day = (yyvsp + -2)->textintval.value;
#line 838
    pc->year = (yyvsp + 0)->textintval;
  }
#line 2179 "parse-datetime.tab.c"
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 844 "parse-datetime.y"
  pc->day = (yyvsp + -2)->textintval.value;
#line 845
  pc->month = (yyvsp + -1)->intval;
#line 846
  tmp___19 = __builtin_sub_overflow(0, (yyvsp + 0)->textintval.value, & pc->year.value);
  }
#line 846
  if (tmp___19) {
#line 846
    goto yyabortlab;
  }
#line 847
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 2191 "parse-datetime.tab.c"
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 852 "parse-datetime.y"
  pc->month = (yyvsp + -2)->intval;
#line 853
  tmp___20 = __builtin_sub_overflow(0, (yyvsp + -1)->textintval.value, & pc->day);
  }
#line 853
  if (tmp___20) {
#line 853
    goto yyabortlab;
  }
  {
#line 854
  tmp___21 = __builtin_sub_overflow(0, (yyvsp + 0)->textintval.value, & pc->year.value);
  }
#line 854
  if (tmp___21) {
#line 854
    goto yyabortlab;
  }
#line 855
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 2203 "parse-datetime.tab.c"
  goto switch_break;
  case_45: /* CIL Label */ 
#line 859 "parse-datetime.y"
  pc->month = (yyvsp + -1)->intval;
#line 860
  pc->day = (yyvsp + 0)->textintval.value;
#line 2212 "parse-datetime.tab.c"
  goto switch_break;
  case_46: /* CIL Label */ 
#line 864 "parse-datetime.y"
  pc->month = (yyvsp + -3)->intval;
#line 865
  pc->day = (yyvsp + -2)->textintval.value;
#line 866
  pc->year = (yyvsp + 0)->textintval;
#line 2222 "parse-datetime.tab.c"
  goto switch_break;
  case_47: /* CIL Label */ 
#line 870 "parse-datetime.y"
  pc->day = (yyvsp + -1)->textintval.value;
#line 871
  pc->month = (yyvsp + 0)->intval;
#line 2231 "parse-datetime.tab.c"
  goto switch_break;
  case_48: /* CIL Label */ 
#line 875 "parse-datetime.y"
  pc->day = (yyvsp + -2)->textintval.value;
#line 876
  pc->month = (yyvsp + -1)->intval;
#line 877
  pc->year = (yyvsp + 0)->textintval;
#line 2241 "parse-datetime.tab.c"
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 886 "parse-datetime.y"
  pc->year = (yyvsp + -2)->textintval;
#line 887
  tmp___22 = __builtin_sub_overflow(0, (yyvsp + -1)->textintval.value, & pc->month);
  }
#line 887
  if (tmp___22) {
#line 887
    goto yyabortlab;
  }
  {
#line 888
  tmp___23 = __builtin_sub_overflow(0, (yyvsp + 0)->textintval.value, & pc->day);
  }
#line 888
  if (tmp___23) {
#line 888
    goto yyabortlab;
  }
#line 2252 "parse-datetime.tab.c"
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 894 "parse-datetime.y"
  tmp___24 = apply_relative_time(pc, (yyvsp + -1)->rel, (int )(yyvsp + 0)->intval);
  }
#line 894
  if (! tmp___24) {
#line 894
    goto yyabortlab;
  }
#line 2258 "parse-datetime.tab.c"
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 896 "parse-datetime.y"
  tmp___25 = apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 896
  if (! tmp___25) {
#line 896
    goto yyabortlab;
  }
#line 2264 "parse-datetime.tab.c"
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 898 "parse-datetime.y"
  tmp___26 = apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 898
  if (! tmp___26) {
#line 898
    goto yyabortlab;
  }
#line 2270 "parse-datetime.tab.c"
  goto switch_break;
  case_54: /* CIL Label */ 
#line 903 "parse-datetime.y"
  __constr_expr_0.year = (intmax_t )0;
#line 903
  __constr_expr_0.month = (intmax_t )0;
#line 903
  __constr_expr_0.day = (intmax_t )0;
#line 903
  __constr_expr_0.hour = (intmax_t )0;
#line 903
  __constr_expr_0.minutes = (intmax_t )0;
#line 903
  __constr_expr_0.seconds = (intmax_t )0;
#line 903
  __constr_expr_0.ns = 0;
#line 903
  yyval.rel = __constr_expr_0;
#line 903
  yyval.rel.year = (yyvsp + -1)->intval;
#line 2276 "parse-datetime.tab.c"
  goto switch_break;
  case_55: /* CIL Label */ 
#line 905 "parse-datetime.y"
  __constr_expr_1.year = (intmax_t )0;
#line 905
  __constr_expr_1.month = (intmax_t )0;
#line 905
  __constr_expr_1.day = (intmax_t )0;
#line 905
  __constr_expr_1.hour = (intmax_t )0;
#line 905
  __constr_expr_1.minutes = (intmax_t )0;
#line 905
  __constr_expr_1.seconds = (intmax_t )0;
#line 905
  __constr_expr_1.ns = 0;
#line 905
  yyval.rel = __constr_expr_1;
#line 905
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 2282 "parse-datetime.tab.c"
  goto switch_break;
  case_56: /* CIL Label */ 
#line 907 "parse-datetime.y"
  __constr_expr_2.year = (intmax_t )0;
#line 907
  __constr_expr_2.month = (intmax_t )0;
#line 907
  __constr_expr_2.day = (intmax_t )0;
#line 907
  __constr_expr_2.hour = (intmax_t )0;
#line 907
  __constr_expr_2.minutes = (intmax_t )0;
#line 907
  __constr_expr_2.seconds = (intmax_t )0;
#line 907
  __constr_expr_2.ns = 0;
#line 907
  yyval.rel = __constr_expr_2;
#line 907
  yyval.rel.year = (intmax_t )1;
#line 2288 "parse-datetime.tab.c"
  goto switch_break;
  case_57: /* CIL Label */ 
#line 909 "parse-datetime.y"
  __constr_expr_3.year = (intmax_t )0;
#line 909
  __constr_expr_3.month = (intmax_t )0;
#line 909
  __constr_expr_3.day = (intmax_t )0;
#line 909
  __constr_expr_3.hour = (intmax_t )0;
#line 909
  __constr_expr_3.minutes = (intmax_t )0;
#line 909
  __constr_expr_3.seconds = (intmax_t )0;
#line 909
  __constr_expr_3.ns = 0;
#line 909
  yyval.rel = __constr_expr_3;
#line 909
  yyval.rel.month = (yyvsp + -1)->intval;
#line 2294 "parse-datetime.tab.c"
  goto switch_break;
  case_58: /* CIL Label */ 
#line 911 "parse-datetime.y"
  __constr_expr_4.year = (intmax_t )0;
#line 911
  __constr_expr_4.month = (intmax_t )0;
#line 911
  __constr_expr_4.day = (intmax_t )0;
#line 911
  __constr_expr_4.hour = (intmax_t )0;
#line 911
  __constr_expr_4.minutes = (intmax_t )0;
#line 911
  __constr_expr_4.seconds = (intmax_t )0;
#line 911
  __constr_expr_4.ns = 0;
#line 911
  yyval.rel = __constr_expr_4;
#line 911
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 2300 "parse-datetime.tab.c"
  goto switch_break;
  case_59: /* CIL Label */ 
#line 913 "parse-datetime.y"
  __constr_expr_5.year = (intmax_t )0;
#line 913
  __constr_expr_5.month = (intmax_t )0;
#line 913
  __constr_expr_5.day = (intmax_t )0;
#line 913
  __constr_expr_5.hour = (intmax_t )0;
#line 913
  __constr_expr_5.minutes = (intmax_t )0;
#line 913
  __constr_expr_5.seconds = (intmax_t )0;
#line 913
  __constr_expr_5.ns = 0;
#line 913
  yyval.rel = __constr_expr_5;
#line 913
  yyval.rel.month = (intmax_t )1;
#line 2306 "parse-datetime.tab.c"
  goto switch_break;
  case_60: /* CIL Label */ 
#line 915 "parse-datetime.y"
  __constr_expr_6.year = (intmax_t )0;
#line 915
  __constr_expr_6.month = (intmax_t )0;
#line 915
  __constr_expr_6.day = (intmax_t )0;
#line 915
  __constr_expr_6.hour = (intmax_t )0;
#line 915
  __constr_expr_6.minutes = (intmax_t )0;
#line 915
  __constr_expr_6.seconds = (intmax_t )0;
#line 915
  __constr_expr_6.ns = 0;
#line 915
  yyval.rel = __constr_expr_6;
#line 916
  if (sizeof(yyval.rel.day) == sizeof(signed char )) {
#line 916
    if ((yyvsp + 0)->intval < 0L) {
#line 916
      if ((yyvsp + -1)->intval < 0L) {
#line 916
        tmp___49 = (yyvsp + -1)->intval < 127L / (yyvsp + 0)->intval;
      } else {
#line 916
        if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
          tmp___48 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
        } else {
#line 916
          tmp___48 = 0;
        }
#line 916
        if (tmp___48) {
#line 916
          if ((yyvsp + 0)->intval == -1L) {
#line 916
            tmp___47 = 0L < (yyvsp + -1)->intval + -128L;
          } else {
#line 916
            tmp___47 = -128L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
          }
        } else {
#line 916
          tmp___47 = -128L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
        }
#line 916
        tmp___49 = tmp___47;
      }
#line 916
      tmp___55 = tmp___49;
    } else {
#line 916
      if ((yyvsp + 0)->intval == 0L) {
#line 916
        tmp___54 = 0;
      } else {
#line 916
        if ((yyvsp + -1)->intval < 0L) {
#line 916
          if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
            tmp___52 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 916
            tmp___52 = 0;
          }
#line 916
          if (tmp___52) {
#line 916
            if ((yyvsp + -1)->intval == -1L) {
#line 916
              tmp___51 = 0L < (yyvsp + 0)->intval + -128L;
            } else {
#line 916
              tmp___51 = -128L / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
            }
          } else {
#line 916
            tmp___51 = -128L / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
          }
#line 916
          tmp___53 = tmp___51;
        } else {
#line 916
          tmp___53 = 127L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
        }
#line 916
        tmp___54 = tmp___53;
      }
#line 916
      tmp___55 = tmp___54;
    }
#line 916
    if (tmp___55) {
#line 916
      yyval.rel.day = (intmax_t )((signed char )((unsigned int )(yyvsp + -1)->intval * (unsigned int )(yyvsp + 0)->intval));
#line 916
      tmp___41 = 1;
    } else {
#line 916
      yyval.rel.day = (intmax_t )((signed char )((unsigned int )(yyvsp + -1)->intval * (unsigned int )(yyvsp + 0)->intval));
#line 916
      tmp___41 = 0;
    }
#line 916
    tmp___320 = tmp___41;
  } else {
#line 916
    if (sizeof(yyval.rel.day) == sizeof(short )) {
#line 916
      if ((yyvsp + 0)->intval < 0L) {
#line 916
        if ((yyvsp + -1)->intval < 0L) {
#line 916
          tmp___107 = (yyvsp + -1)->intval < 32767L / (yyvsp + 0)->intval;
        } else {
#line 916
          if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
            tmp___106 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 916
            tmp___106 = 0;
          }
#line 916
          if (tmp___106) {
#line 916
            if ((yyvsp + 0)->intval == -1L) {
#line 916
              tmp___105 = 0L < (yyvsp + -1)->intval + -32768L;
            } else {
#line 916
              tmp___105 = -32768L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
            }
          } else {
#line 916
            tmp___105 = -32768L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
          }
#line 916
          tmp___107 = tmp___105;
        }
#line 916
        tmp___113 = tmp___107;
      } else {
#line 916
        if ((yyvsp + 0)->intval == 0L) {
#line 916
          tmp___112 = 0;
        } else {
#line 916
          if ((yyvsp + -1)->intval < 0L) {
#line 916
            if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
              tmp___110 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 916
              tmp___110 = 0;
            }
#line 916
            if (tmp___110) {
#line 916
              if ((yyvsp + -1)->intval == -1L) {
#line 916
                tmp___109 = 0L < (yyvsp + 0)->intval + -32768L;
              } else {
#line 916
                tmp___109 = -32768L / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
              }
            } else {
#line 916
              tmp___109 = -32768L / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
            }
#line 916
            tmp___111 = tmp___109;
          } else {
#line 916
            tmp___111 = 32767L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
          }
#line 916
          tmp___112 = tmp___111;
        }
#line 916
        tmp___113 = tmp___112;
      }
#line 916
      if (tmp___113) {
#line 916
        yyval.rel.day = (intmax_t )((short )((unsigned int )(yyvsp + -1)->intval * (unsigned int )(yyvsp + 0)->intval));
#line 916
        tmp___99 = 1;
      } else {
#line 916
        yyval.rel.day = (intmax_t )((short )((unsigned int )(yyvsp + -1)->intval * (unsigned int )(yyvsp + 0)->intval));
#line 916
        tmp___99 = 0;
      }
#line 916
      tmp___319 = tmp___99;
    } else {
#line 916
      if (sizeof(yyval.rel.day) == sizeof(int )) {
#line 916
        if ((yyvsp + 0)->intval < 0L) {
#line 916
          if ((yyvsp + -1)->intval < 0L) {
#line 916
            tmp___165 = (yyvsp + -1)->intval < 2147483647L / (yyvsp + 0)->intval;
          } else {
#line 916
            if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
              tmp___164 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 916
              tmp___164 = 0;
            }
#line 916
            if (tmp___164) {
#line 916
              if ((yyvsp + 0)->intval == -1L) {
#line 916
                tmp___163 = 0L < (yyvsp + -1)->intval + (-0x7FFFFFFF-1);
              } else {
#line 916
                tmp___163 = (-0x7FFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
              }
            } else {
#line 916
              tmp___163 = (-0x7FFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
            }
#line 916
            tmp___165 = tmp___163;
          }
#line 916
          tmp___171 = tmp___165;
        } else {
#line 916
          if ((yyvsp + 0)->intval == 0L) {
#line 916
            tmp___170 = 0;
          } else {
#line 916
            if ((yyvsp + -1)->intval < 0L) {
#line 916
              if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
                tmp___168 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 916
                tmp___168 = 0;
              }
#line 916
              if (tmp___168) {
#line 916
                if ((yyvsp + -1)->intval == -1L) {
#line 916
                  tmp___167 = 0L < (yyvsp + 0)->intval + (-0x7FFFFFFF-1);
                } else {
#line 916
                  tmp___167 = (-0x7FFFFFFF-1) / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
                }
              } else {
#line 916
                tmp___167 = (-0x7FFFFFFF-1) / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
              }
#line 916
              tmp___169 = tmp___167;
            } else {
#line 916
              tmp___169 = 2147483647L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
            }
#line 916
            tmp___170 = tmp___169;
          }
#line 916
          tmp___171 = tmp___170;
        }
#line 916
        if (tmp___171) {
#line 916
          yyval.rel.day = (intmax_t )((int )((unsigned int )(yyvsp + -1)->intval * (unsigned int )(yyvsp + 0)->intval));
#line 916
          tmp___157 = 1;
        } else {
#line 916
          yyval.rel.day = (intmax_t )((int )((unsigned int )(yyvsp + -1)->intval * (unsigned int )(yyvsp + 0)->intval));
#line 916
          tmp___157 = 0;
        }
#line 916
        tmp___318 = tmp___157;
      } else {
#line 916
        if (sizeof(yyval.rel.day) == sizeof(long )) {
#line 916
          if ((yyvsp + 0)->intval < 0L) {
#line 916
            if ((yyvsp + -1)->intval < 0L) {
#line 916
              tmp___223 = (yyvsp + -1)->intval < 9223372036854775807L / (yyvsp + 0)->intval;
            } else {
#line 916
              if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
                tmp___222 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 916
                tmp___222 = 0;
              }
#line 916
              if (tmp___222) {
#line 916
                if ((yyvsp + 0)->intval == -1L) {
#line 916
                  tmp___221 = 0L < (yyvsp + -1)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                } else {
#line 916
                  tmp___221 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
                }
              } else {
#line 916
                tmp___221 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
              }
#line 916
              tmp___223 = tmp___221;
            }
#line 916
            tmp___229 = tmp___223;
          } else {
#line 916
            if ((yyvsp + 0)->intval == 0L) {
#line 916
              tmp___228 = 0;
            } else {
#line 916
              if ((yyvsp + -1)->intval < 0L) {
#line 916
                if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 916
                  tmp___226 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                } else {
#line 916
                  tmp___226 = 0;
                }
#line 916
                if (tmp___226) {
#line 916
                  if ((yyvsp + -1)->intval == -1L) {
#line 916
                    tmp___225 = 0L < (yyvsp + 0)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                  } else {
#line 916
                    tmp___225 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
                  }
                } else {
#line 916
                  tmp___225 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + -1)->intval < (yyvsp + 0)->intval;
                }
#line 916
                tmp___227 = tmp___225;
              } else {
#line 916
                tmp___227 = 9223372036854775807L / (yyvsp + 0)->intval < (yyvsp + -1)->intval;
              }
#line 916
              tmp___228 = tmp___227;
            }
#line 916
            tmp___229 = tmp___228;
          }
#line 916
          if (tmp___229) {
#line 916
            yyval.rel.day = (long )((unsigned long )(yyvsp + -1)->intval * (unsigned long )(yyvsp + 0)->intval);
#line 916
            tmp___215 = 1;
          } else {
#line 916
            yyval.rel.day = (long )((unsigned long )(yyvsp + -1)->intval * (unsigned long )(yyvsp + 0)->intval);
#line 916
            tmp___215 = 0;
          }
#line 916
          tmp___317 = tmp___215;
        } else {
#line 916
          if ((yyvsp + 0)->intval < 0L) {
#line 916
            if ((yyvsp + -1)->intval < 0L) {
#line 916
              tmp___281 = (long long )(yyvsp + -1)->intval < 9223372036854775807LL / (long long )(yyvsp + 0)->intval;
            } else {
#line 916
              if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 916
                tmp___280 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
              } else {
#line 916
                tmp___280 = 0;
              }
#line 916
              if (tmp___280) {
#line 916
                if ((yyvsp + 0)->intval == -1L) {
#line 916
                  tmp___279 = 0LL < (long long )(yyvsp + -1)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                } else {
#line 916
                  tmp___279 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->intval;
                }
              } else {
#line 916
                tmp___279 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->intval;
              }
#line 916
              tmp___281 = tmp___279;
            }
#line 916
            tmp___287 = tmp___281;
          } else {
#line 916
            if ((yyvsp + 0)->intval == 0L) {
#line 916
              tmp___286 = 0;
            } else {
#line 916
              if ((yyvsp + -1)->intval < 0L) {
#line 916
                if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 916
                  tmp___284 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                } else {
#line 916
                  tmp___284 = 0;
                }
#line 916
                if (tmp___284) {
#line 916
                  if ((yyvsp + -1)->intval == -1L) {
#line 916
                    tmp___283 = 0LL < (long long )(yyvsp + 0)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                  } else {
#line 916
                    tmp___283 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + -1)->intval < (long long )(yyvsp + 0)->intval;
                  }
                } else {
#line 916
                  tmp___283 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + -1)->intval < (long long )(yyvsp + 0)->intval;
                }
#line 916
                tmp___285 = tmp___283;
              } else {
#line 916
                tmp___285 = 9223372036854775807LL / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->intval;
              }
#line 916
              tmp___286 = tmp___285;
            }
#line 916
            tmp___287 = tmp___286;
          }
#line 916
          if (tmp___287) {
#line 916
            yyval.rel.day = (intmax_t )((long long )((unsigned long long )(yyvsp + -1)->intval * (unsigned long long )(yyvsp + 0)->intval));
#line 916
            tmp___273 = 1;
          } else {
#line 916
            yyval.rel.day = (intmax_t )((long long )((unsigned long long )(yyvsp + -1)->intval * (unsigned long long )(yyvsp + 0)->intval));
#line 916
            tmp___273 = 0;
          }
#line 916
          tmp___317 = tmp___273;
        }
#line 916
        tmp___318 = tmp___317;
      }
#line 916
      tmp___319 = tmp___318;
    }
#line 916
    tmp___320 = tmp___319;
  }
#line 916
  if (tmp___320) {
#line 916
    goto yyabortlab;
  }
#line 2313 "parse-datetime.tab.c"
  goto switch_break;
  case_61: /* CIL Label */ 
#line 918 "parse-datetime.y"
  __constr_expr_7.year = (intmax_t )0;
#line 918
  __constr_expr_7.month = (intmax_t )0;
#line 918
  __constr_expr_7.day = (intmax_t )0;
#line 918
  __constr_expr_7.hour = (intmax_t )0;
#line 918
  __constr_expr_7.minutes = (intmax_t )0;
#line 918
  __constr_expr_7.seconds = (intmax_t )0;
#line 918
  __constr_expr_7.ns = 0;
#line 918
  yyval.rel = __constr_expr_7;
#line 919
  if (sizeof(yyval.rel.day) == sizeof(signed char )) {
#line 919
    if ((yyvsp + 0)->intval < 0L) {
#line 919
      if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
        tmp___343 = (yyvsp + -1)->textintval.value < 127L / (yyvsp + 0)->intval;
      } else {
#line 919
        if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
          tmp___342 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
        } else {
#line 919
          tmp___342 = 0;
        }
#line 919
        if (tmp___342) {
#line 919
          if ((yyvsp + 0)->intval == -1L) {
#line 919
            tmp___341 = 0L < (yyvsp + -1)->textintval.value + -128L;
          } else {
#line 919
            tmp___341 = -128L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
          }
        } else {
#line 919
          tmp___341 = -128L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
        }
#line 919
        tmp___343 = tmp___341;
      }
#line 919
      tmp___349 = tmp___343;
    } else {
#line 919
      if ((yyvsp + 0)->intval == 0L) {
#line 919
        tmp___348 = 0;
      } else {
#line 919
        if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
          if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
            tmp___346 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 919
            tmp___346 = 0;
          }
#line 919
          if (tmp___346) {
#line 919
            if ((yyvsp + -1)->textintval.value == -1L) {
#line 919
              tmp___345 = 0L < (yyvsp + 0)->intval + -128L;
            } else {
#line 919
              tmp___345 = -128L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
            }
          } else {
#line 919
            tmp___345 = -128L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
          }
#line 919
          tmp___347 = tmp___345;
        } else {
#line 919
          tmp___347 = 127L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
        }
#line 919
        tmp___348 = tmp___347;
      }
#line 919
      tmp___349 = tmp___348;
    }
#line 919
    if (tmp___349) {
#line 919
      yyval.rel.day = (intmax_t )((signed char )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 919
      tmp___335 = 1;
    } else {
#line 919
      yyval.rel.day = (intmax_t )((signed char )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 919
      tmp___335 = 0;
    }
#line 919
    tmp___614 = tmp___335;
  } else {
#line 919
    if (sizeof(yyval.rel.day) == sizeof(short )) {
#line 919
      if ((yyvsp + 0)->intval < 0L) {
#line 919
        if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
          tmp___401 = (yyvsp + -1)->textintval.value < 32767L / (yyvsp + 0)->intval;
        } else {
#line 919
          if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
            tmp___400 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 919
            tmp___400 = 0;
          }
#line 919
          if (tmp___400) {
#line 919
            if ((yyvsp + 0)->intval == -1L) {
#line 919
              tmp___399 = 0L < (yyvsp + -1)->textintval.value + -32768L;
            } else {
#line 919
              tmp___399 = -32768L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
            }
          } else {
#line 919
            tmp___399 = -32768L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
          }
#line 919
          tmp___401 = tmp___399;
        }
#line 919
        tmp___407 = tmp___401;
      } else {
#line 919
        if ((yyvsp + 0)->intval == 0L) {
#line 919
          tmp___406 = 0;
        } else {
#line 919
          if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
            if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
              tmp___404 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 919
              tmp___404 = 0;
            }
#line 919
            if (tmp___404) {
#line 919
              if ((yyvsp + -1)->textintval.value == -1L) {
#line 919
                tmp___403 = 0L < (yyvsp + 0)->intval + -32768L;
              } else {
#line 919
                tmp___403 = -32768L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
              }
            } else {
#line 919
              tmp___403 = -32768L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
            }
#line 919
            tmp___405 = tmp___403;
          } else {
#line 919
            tmp___405 = 32767L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
          }
#line 919
          tmp___406 = tmp___405;
        }
#line 919
        tmp___407 = tmp___406;
      }
#line 919
      if (tmp___407) {
#line 919
        yyval.rel.day = (intmax_t )((short )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 919
        tmp___393 = 1;
      } else {
#line 919
        yyval.rel.day = (intmax_t )((short )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 919
        tmp___393 = 0;
      }
#line 919
      tmp___613 = tmp___393;
    } else {
#line 919
      if (sizeof(yyval.rel.day) == sizeof(int )) {
#line 919
        if ((yyvsp + 0)->intval < 0L) {
#line 919
          if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
            tmp___459 = (yyvsp + -1)->textintval.value < 2147483647L / (yyvsp + 0)->intval;
          } else {
#line 919
            if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
              tmp___458 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 919
              tmp___458 = 0;
            }
#line 919
            if (tmp___458) {
#line 919
              if ((yyvsp + 0)->intval == -1L) {
#line 919
                tmp___457 = 0L < (yyvsp + -1)->textintval.value + (-0x7FFFFFFF-1);
              } else {
#line 919
                tmp___457 = (-0x7FFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
              }
            } else {
#line 919
              tmp___457 = (-0x7FFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
            }
#line 919
            tmp___459 = tmp___457;
          }
#line 919
          tmp___465 = tmp___459;
        } else {
#line 919
          if ((yyvsp + 0)->intval == 0L) {
#line 919
            tmp___464 = 0;
          } else {
#line 919
            if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
              if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
                tmp___462 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 919
                tmp___462 = 0;
              }
#line 919
              if (tmp___462) {
#line 919
                if ((yyvsp + -1)->textintval.value == -1L) {
#line 919
                  tmp___461 = 0L < (yyvsp + 0)->intval + (-0x7FFFFFFF-1);
                } else {
#line 919
                  tmp___461 = (-0x7FFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
                }
              } else {
#line 919
                tmp___461 = (-0x7FFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
              }
#line 919
              tmp___463 = tmp___461;
            } else {
#line 919
              tmp___463 = 2147483647L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
            }
#line 919
            tmp___464 = tmp___463;
          }
#line 919
          tmp___465 = tmp___464;
        }
#line 919
        if (tmp___465) {
#line 919
          yyval.rel.day = (intmax_t )((int )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 919
          tmp___451 = 1;
        } else {
#line 919
          yyval.rel.day = (intmax_t )((int )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 919
          tmp___451 = 0;
        }
#line 919
        tmp___612 = tmp___451;
      } else {
#line 919
        if (sizeof(yyval.rel.day) == sizeof(long )) {
#line 919
          if ((yyvsp + 0)->intval < 0L) {
#line 919
            if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
              tmp___517 = (yyvsp + -1)->textintval.value < 9223372036854775807L / (yyvsp + 0)->intval;
            } else {
#line 919
              if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
                tmp___516 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 919
                tmp___516 = 0;
              }
#line 919
              if (tmp___516) {
#line 919
                if ((yyvsp + 0)->intval == -1L) {
#line 919
                  tmp___515 = 0L < (yyvsp + -1)->textintval.value + (-0x7FFFFFFFFFFFFFFF-1);
                } else {
#line 919
                  tmp___515 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
                }
              } else {
#line 919
                tmp___515 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
              }
#line 919
              tmp___517 = tmp___515;
            }
#line 919
            tmp___523 = tmp___517;
          } else {
#line 919
            if ((yyvsp + 0)->intval == 0L) {
#line 919
              tmp___522 = 0;
            } else {
#line 919
              if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
                if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 919
                  tmp___520 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                } else {
#line 919
                  tmp___520 = 0;
                }
#line 919
                if (tmp___520) {
#line 919
                  if ((yyvsp + -1)->textintval.value == -1L) {
#line 919
                    tmp___519 = 0L < (yyvsp + 0)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                  } else {
#line 919
                    tmp___519 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
                  }
                } else {
#line 919
                  tmp___519 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
                }
#line 919
                tmp___521 = tmp___519;
              } else {
#line 919
                tmp___521 = 9223372036854775807L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
              }
#line 919
              tmp___522 = tmp___521;
            }
#line 919
            tmp___523 = tmp___522;
          }
#line 919
          if (tmp___523) {
#line 919
            yyval.rel.day = (long )((unsigned long )(yyvsp + -1)->textintval.value * (unsigned long )(yyvsp + 0)->intval);
#line 919
            tmp___509 = 1;
          } else {
#line 919
            yyval.rel.day = (long )((unsigned long )(yyvsp + -1)->textintval.value * (unsigned long )(yyvsp + 0)->intval);
#line 919
            tmp___509 = 0;
          }
#line 919
          tmp___611 = tmp___509;
        } else {
#line 919
          if ((yyvsp + 0)->intval < 0L) {
#line 919
            if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
              tmp___575 = (long long )(yyvsp + -1)->textintval.value < 9223372036854775807LL / (long long )(yyvsp + 0)->intval;
            } else {
#line 919
              if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 919
                tmp___574 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
              } else {
#line 919
                tmp___574 = 0;
              }
#line 919
              if (tmp___574) {
#line 919
                if ((yyvsp + 0)->intval == -1L) {
#line 919
                  tmp___573 = 0LL < (long long )(yyvsp + -1)->textintval.value + (-0x7FFFFFFFFFFFFFFF-1);
                } else {
#line 919
                  tmp___573 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->textintval.value;
                }
              } else {
#line 919
                tmp___573 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->textintval.value;
              }
#line 919
              tmp___575 = tmp___573;
            }
#line 919
            tmp___581 = tmp___575;
          } else {
#line 919
            if ((yyvsp + 0)->intval == 0L) {
#line 919
              tmp___580 = 0;
            } else {
#line 919
              if ((yyvsp + -1)->textintval.value < 0L) {
#line 919
                if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 919
                  tmp___578 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                } else {
#line 919
                  tmp___578 = 0;
                }
#line 919
                if (tmp___578) {
#line 919
                  if ((yyvsp + -1)->textintval.value == -1L) {
#line 919
                    tmp___577 = 0LL < (long long )(yyvsp + 0)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                  } else {
#line 919
                    tmp___577 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + -1)->textintval.value < (long long )(yyvsp + 0)->intval;
                  }
                } else {
#line 919
                  tmp___577 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + -1)->textintval.value < (long long )(yyvsp + 0)->intval;
                }
#line 919
                tmp___579 = tmp___577;
              } else {
#line 919
                tmp___579 = 9223372036854775807LL / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->textintval.value;
              }
#line 919
              tmp___580 = tmp___579;
            }
#line 919
            tmp___581 = tmp___580;
          }
#line 919
          if (tmp___581) {
#line 919
            yyval.rel.day = (intmax_t )((long long )((unsigned long long )(yyvsp + -1)->textintval.value * (unsigned long long )(yyvsp + 0)->intval));
#line 919
            tmp___567 = 1;
          } else {
#line 919
            yyval.rel.day = (intmax_t )((long long )((unsigned long long )(yyvsp + -1)->textintval.value * (unsigned long long )(yyvsp + 0)->intval));
#line 919
            tmp___567 = 0;
          }
#line 919
          tmp___611 = tmp___567;
        }
#line 919
        tmp___612 = tmp___611;
      }
#line 919
      tmp___613 = tmp___612;
    }
#line 919
    tmp___614 = tmp___613;
  }
#line 919
  if (tmp___614) {
#line 919
    goto yyabortlab;
  }
#line 2320 "parse-datetime.tab.c"
  goto switch_break;
  case_62: /* CIL Label */ 
#line 921 "parse-datetime.y"
  __constr_expr_8.year = (intmax_t )0;
#line 921
  __constr_expr_8.month = (intmax_t )0;
#line 921
  __constr_expr_8.day = (intmax_t )0;
#line 921
  __constr_expr_8.hour = (intmax_t )0;
#line 921
  __constr_expr_8.minutes = (intmax_t )0;
#line 921
  __constr_expr_8.seconds = (intmax_t )0;
#line 921
  __constr_expr_8.ns = 0;
#line 921
  yyval.rel = __constr_expr_8;
#line 921
  yyval.rel.day = (yyvsp + 0)->intval;
#line 2326 "parse-datetime.tab.c"
  goto switch_break;
  case_63: /* CIL Label */ 
#line 923 "parse-datetime.y"
  __constr_expr_9.year = (intmax_t )0;
#line 923
  __constr_expr_9.month = (intmax_t )0;
#line 923
  __constr_expr_9.day = (intmax_t )0;
#line 923
  __constr_expr_9.hour = (intmax_t )0;
#line 923
  __constr_expr_9.minutes = (intmax_t )0;
#line 923
  __constr_expr_9.seconds = (intmax_t )0;
#line 923
  __constr_expr_9.ns = 0;
#line 923
  yyval.rel = __constr_expr_9;
#line 923
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 2332 "parse-datetime.tab.c"
  goto switch_break;
  case_64: /* CIL Label */ 
#line 925 "parse-datetime.y"
  __constr_expr_10.year = (intmax_t )0;
#line 925
  __constr_expr_10.month = (intmax_t )0;
#line 925
  __constr_expr_10.day = (intmax_t )0;
#line 925
  __constr_expr_10.hour = (intmax_t )0;
#line 925
  __constr_expr_10.minutes = (intmax_t )0;
#line 925
  __constr_expr_10.seconds = (intmax_t )0;
#line 925
  __constr_expr_10.ns = 0;
#line 925
  yyval.rel = __constr_expr_10;
#line 925
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 2338 "parse-datetime.tab.c"
  goto switch_break;
  case_65: /* CIL Label */ 
#line 927 "parse-datetime.y"
  __constr_expr_11.year = (intmax_t )0;
#line 927
  __constr_expr_11.month = (intmax_t )0;
#line 927
  __constr_expr_11.day = (intmax_t )0;
#line 927
  __constr_expr_11.hour = (intmax_t )0;
#line 927
  __constr_expr_11.minutes = (intmax_t )0;
#line 927
  __constr_expr_11.seconds = (intmax_t )0;
#line 927
  __constr_expr_11.ns = 0;
#line 927
  yyval.rel = __constr_expr_11;
#line 927
  yyval.rel.hour = (intmax_t )1;
#line 2344 "parse-datetime.tab.c"
  goto switch_break;
  case_66: /* CIL Label */ 
#line 929 "parse-datetime.y"
  __constr_expr_12.year = (intmax_t )0;
#line 929
  __constr_expr_12.month = (intmax_t )0;
#line 929
  __constr_expr_12.day = (intmax_t )0;
#line 929
  __constr_expr_12.hour = (intmax_t )0;
#line 929
  __constr_expr_12.minutes = (intmax_t )0;
#line 929
  __constr_expr_12.seconds = (intmax_t )0;
#line 929
  __constr_expr_12.ns = 0;
#line 929
  yyval.rel = __constr_expr_12;
#line 929
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 2350 "parse-datetime.tab.c"
  goto switch_break;
  case_67: /* CIL Label */ 
#line 931 "parse-datetime.y"
  __constr_expr_13.year = (intmax_t )0;
#line 931
  __constr_expr_13.month = (intmax_t )0;
#line 931
  __constr_expr_13.day = (intmax_t )0;
#line 931
  __constr_expr_13.hour = (intmax_t )0;
#line 931
  __constr_expr_13.minutes = (intmax_t )0;
#line 931
  __constr_expr_13.seconds = (intmax_t )0;
#line 931
  __constr_expr_13.ns = 0;
#line 931
  yyval.rel = __constr_expr_13;
#line 931
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 2356 "parse-datetime.tab.c"
  goto switch_break;
  case_68: /* CIL Label */ 
#line 933 "parse-datetime.y"
  __constr_expr_14.year = (intmax_t )0;
#line 933
  __constr_expr_14.month = (intmax_t )0;
#line 933
  __constr_expr_14.day = (intmax_t )0;
#line 933
  __constr_expr_14.hour = (intmax_t )0;
#line 933
  __constr_expr_14.minutes = (intmax_t )0;
#line 933
  __constr_expr_14.seconds = (intmax_t )0;
#line 933
  __constr_expr_14.ns = 0;
#line 933
  yyval.rel = __constr_expr_14;
#line 933
  yyval.rel.minutes = (intmax_t )1;
#line 2362 "parse-datetime.tab.c"
  goto switch_break;
  case_69: /* CIL Label */ 
#line 935 "parse-datetime.y"
  __constr_expr_15.year = (intmax_t )0;
#line 935
  __constr_expr_15.month = (intmax_t )0;
#line 935
  __constr_expr_15.day = (intmax_t )0;
#line 935
  __constr_expr_15.hour = (intmax_t )0;
#line 935
  __constr_expr_15.minutes = (intmax_t )0;
#line 935
  __constr_expr_15.seconds = (intmax_t )0;
#line 935
  __constr_expr_15.ns = 0;
#line 935
  yyval.rel = __constr_expr_15;
#line 935
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 2368 "parse-datetime.tab.c"
  goto switch_break;
  case_70: /* CIL Label */ 
#line 937 "parse-datetime.y"
  __constr_expr_16.year = (intmax_t )0;
#line 937
  __constr_expr_16.month = (intmax_t )0;
#line 937
  __constr_expr_16.day = (intmax_t )0;
#line 937
  __constr_expr_16.hour = (intmax_t )0;
#line 937
  __constr_expr_16.minutes = (intmax_t )0;
#line 937
  __constr_expr_16.seconds = (intmax_t )0;
#line 937
  __constr_expr_16.ns = 0;
#line 937
  yyval.rel = __constr_expr_16;
#line 937
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 2374 "parse-datetime.tab.c"
  goto switch_break;
  case_71: /* CIL Label */ 
#line 939 "parse-datetime.y"
  __constr_expr_17.year = (intmax_t )0;
#line 939
  __constr_expr_17.month = (intmax_t )0;
#line 939
  __constr_expr_17.day = (intmax_t )0;
#line 939
  __constr_expr_17.hour = (intmax_t )0;
#line 939
  __constr_expr_17.minutes = (intmax_t )0;
#line 939
  __constr_expr_17.seconds = (intmax_t )0;
#line 939
  __constr_expr_17.ns = 0;
#line 939
  yyval.rel = __constr_expr_17;
#line 939
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 939
  yyval.rel.ns = (int )(yyvsp + -1)->timespec.tv_nsec;
#line 2380 "parse-datetime.tab.c"
  goto switch_break;
  case_72: /* CIL Label */ 
#line 941 "parse-datetime.y"
  __constr_expr_18.year = (intmax_t )0;
#line 941
  __constr_expr_18.month = (intmax_t )0;
#line 941
  __constr_expr_18.day = (intmax_t )0;
#line 941
  __constr_expr_18.hour = (intmax_t )0;
#line 941
  __constr_expr_18.minutes = (intmax_t )0;
#line 941
  __constr_expr_18.seconds = (intmax_t )0;
#line 941
  __constr_expr_18.ns = 0;
#line 941
  yyval.rel = __constr_expr_18;
#line 941
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 941
  yyval.rel.ns = (int )(yyvsp + -1)->timespec.tv_nsec;
#line 2386 "parse-datetime.tab.c"
  goto switch_break;
  case_73: /* CIL Label */ 
#line 943 "parse-datetime.y"
  __constr_expr_19.year = (intmax_t )0;
#line 943
  __constr_expr_19.month = (intmax_t )0;
#line 943
  __constr_expr_19.day = (intmax_t )0;
#line 943
  __constr_expr_19.hour = (intmax_t )0;
#line 943
  __constr_expr_19.minutes = (intmax_t )0;
#line 943
  __constr_expr_19.seconds = (intmax_t )0;
#line 943
  __constr_expr_19.ns = 0;
#line 943
  yyval.rel = __constr_expr_19;
#line 943
  yyval.rel.seconds = (intmax_t )1;
#line 2392 "parse-datetime.tab.c"
  goto switch_break;
  case_75: /* CIL Label */ 
#line 949 "parse-datetime.y"
  __constr_expr_20.year = (intmax_t )0;
#line 949
  __constr_expr_20.month = (intmax_t )0;
#line 949
  __constr_expr_20.day = (intmax_t )0;
#line 949
  __constr_expr_20.hour = (intmax_t )0;
#line 949
  __constr_expr_20.minutes = (intmax_t )0;
#line 949
  __constr_expr_20.seconds = (intmax_t )0;
#line 949
  __constr_expr_20.ns = 0;
#line 949
  yyval.rel = __constr_expr_20;
#line 949
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 2398 "parse-datetime.tab.c"
  goto switch_break;
  case_76: /* CIL Label */ 
#line 951 "parse-datetime.y"
  __constr_expr_21.year = (intmax_t )0;
#line 951
  __constr_expr_21.month = (intmax_t )0;
#line 951
  __constr_expr_21.day = (intmax_t )0;
#line 951
  __constr_expr_21.hour = (intmax_t )0;
#line 951
  __constr_expr_21.minutes = (intmax_t )0;
#line 951
  __constr_expr_21.seconds = (intmax_t )0;
#line 951
  __constr_expr_21.ns = 0;
#line 951
  yyval.rel = __constr_expr_21;
#line 951
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 2404 "parse-datetime.tab.c"
  goto switch_break;
  case_77: /* CIL Label */ 
#line 953 "parse-datetime.y"
  __constr_expr_22.year = (intmax_t )0;
#line 953
  __constr_expr_22.month = (intmax_t )0;
#line 953
  __constr_expr_22.day = (intmax_t )0;
#line 953
  __constr_expr_22.hour = (intmax_t )0;
#line 953
  __constr_expr_22.minutes = (intmax_t )0;
#line 953
  __constr_expr_22.seconds = (intmax_t )0;
#line 953
  __constr_expr_22.ns = 0;
#line 953
  yyval.rel = __constr_expr_22;
#line 954
  if (sizeof(yyval.rel.day) == sizeof(signed char )) {
#line 954
    if ((yyvsp + 0)->intval < 0L) {
#line 954
      if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
        tmp___637 = (yyvsp + -1)->textintval.value < 127L / (yyvsp + 0)->intval;
      } else {
#line 954
        if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
          tmp___636 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
        } else {
#line 954
          tmp___636 = 0;
        }
#line 954
        if (tmp___636) {
#line 954
          if ((yyvsp + 0)->intval == -1L) {
#line 954
            tmp___635 = 0L < (yyvsp + -1)->textintval.value + -128L;
          } else {
#line 954
            tmp___635 = -128L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
          }
        } else {
#line 954
          tmp___635 = -128L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
        }
#line 954
        tmp___637 = tmp___635;
      }
#line 954
      tmp___643 = tmp___637;
    } else {
#line 954
      if ((yyvsp + 0)->intval == 0L) {
#line 954
        tmp___642 = 0;
      } else {
#line 954
        if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
          if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
            tmp___640 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 954
            tmp___640 = 0;
          }
#line 954
          if (tmp___640) {
#line 954
            if ((yyvsp + -1)->textintval.value == -1L) {
#line 954
              tmp___639 = 0L < (yyvsp + 0)->intval + -128L;
            } else {
#line 954
              tmp___639 = -128L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
            }
          } else {
#line 954
            tmp___639 = -128L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
          }
#line 954
          tmp___641 = tmp___639;
        } else {
#line 954
          tmp___641 = 127L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
        }
#line 954
        tmp___642 = tmp___641;
      }
#line 954
      tmp___643 = tmp___642;
    }
#line 954
    if (tmp___643) {
#line 954
      yyval.rel.day = (intmax_t )((signed char )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 954
      tmp___629 = 1;
    } else {
#line 954
      yyval.rel.day = (intmax_t )((signed char )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 954
      tmp___629 = 0;
    }
#line 954
    tmp___908 = tmp___629;
  } else {
#line 954
    if (sizeof(yyval.rel.day) == sizeof(short )) {
#line 954
      if ((yyvsp + 0)->intval < 0L) {
#line 954
        if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
          tmp___695 = (yyvsp + -1)->textintval.value < 32767L / (yyvsp + 0)->intval;
        } else {
#line 954
          if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
            tmp___694 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 954
            tmp___694 = 0;
          }
#line 954
          if (tmp___694) {
#line 954
            if ((yyvsp + 0)->intval == -1L) {
#line 954
              tmp___693 = 0L < (yyvsp + -1)->textintval.value + -32768L;
            } else {
#line 954
              tmp___693 = -32768L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
            }
          } else {
#line 954
            tmp___693 = -32768L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
          }
#line 954
          tmp___695 = tmp___693;
        }
#line 954
        tmp___701 = tmp___695;
      } else {
#line 954
        if ((yyvsp + 0)->intval == 0L) {
#line 954
          tmp___700 = 0;
        } else {
#line 954
          if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
            if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
              tmp___698 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 954
              tmp___698 = 0;
            }
#line 954
            if (tmp___698) {
#line 954
              if ((yyvsp + -1)->textintval.value == -1L) {
#line 954
                tmp___697 = 0L < (yyvsp + 0)->intval + -32768L;
              } else {
#line 954
                tmp___697 = -32768L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
              }
            } else {
#line 954
              tmp___697 = -32768L / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
            }
#line 954
            tmp___699 = tmp___697;
          } else {
#line 954
            tmp___699 = 32767L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
          }
#line 954
          tmp___700 = tmp___699;
        }
#line 954
        tmp___701 = tmp___700;
      }
#line 954
      if (tmp___701) {
#line 954
        yyval.rel.day = (intmax_t )((short )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 954
        tmp___687 = 1;
      } else {
#line 954
        yyval.rel.day = (intmax_t )((short )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 954
        tmp___687 = 0;
      }
#line 954
      tmp___907 = tmp___687;
    } else {
#line 954
      if (sizeof(yyval.rel.day) == sizeof(int )) {
#line 954
        if ((yyvsp + 0)->intval < 0L) {
#line 954
          if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
            tmp___753 = (yyvsp + -1)->textintval.value < 2147483647L / (yyvsp + 0)->intval;
          } else {
#line 954
            if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
              tmp___752 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 954
              tmp___752 = 0;
            }
#line 954
            if (tmp___752) {
#line 954
              if ((yyvsp + 0)->intval == -1L) {
#line 954
                tmp___751 = 0L < (yyvsp + -1)->textintval.value + (-0x7FFFFFFF-1);
              } else {
#line 954
                tmp___751 = (-0x7FFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
              }
            } else {
#line 954
              tmp___751 = (-0x7FFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
            }
#line 954
            tmp___753 = tmp___751;
          }
#line 954
          tmp___759 = tmp___753;
        } else {
#line 954
          if ((yyvsp + 0)->intval == 0L) {
#line 954
            tmp___758 = 0;
          } else {
#line 954
            if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
              if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
                tmp___756 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 954
                tmp___756 = 0;
              }
#line 954
              if (tmp___756) {
#line 954
                if ((yyvsp + -1)->textintval.value == -1L) {
#line 954
                  tmp___755 = 0L < (yyvsp + 0)->intval + (-0x7FFFFFFF-1);
                } else {
#line 954
                  tmp___755 = (-0x7FFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
                }
              } else {
#line 954
                tmp___755 = (-0x7FFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
              }
#line 954
              tmp___757 = tmp___755;
            } else {
#line 954
              tmp___757 = 2147483647L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
            }
#line 954
            tmp___758 = tmp___757;
          }
#line 954
          tmp___759 = tmp___758;
        }
#line 954
        if (tmp___759) {
#line 954
          yyval.rel.day = (intmax_t )((int )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 954
          tmp___745 = 1;
        } else {
#line 954
          yyval.rel.day = (intmax_t )((int )((unsigned int )(yyvsp + -1)->textintval.value * (unsigned int )(yyvsp + 0)->intval));
#line 954
          tmp___745 = 0;
        }
#line 954
        tmp___906 = tmp___745;
      } else {
#line 954
        if (sizeof(yyval.rel.day) == sizeof(long )) {
#line 954
          if ((yyvsp + 0)->intval < 0L) {
#line 954
            if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
              tmp___811 = (yyvsp + -1)->textintval.value < 9223372036854775807L / (yyvsp + 0)->intval;
            } else {
#line 954
              if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
                tmp___810 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 954
                tmp___810 = 0;
              }
#line 954
              if (tmp___810) {
#line 954
                if ((yyvsp + 0)->intval == -1L) {
#line 954
                  tmp___809 = 0L < (yyvsp + -1)->textintval.value + (-0x7FFFFFFFFFFFFFFF-1);
                } else {
#line 954
                  tmp___809 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
                }
              } else {
#line 954
                tmp___809 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
              }
#line 954
              tmp___811 = tmp___809;
            }
#line 954
            tmp___817 = tmp___811;
          } else {
#line 954
            if ((yyvsp + 0)->intval == 0L) {
#line 954
              tmp___816 = 0;
            } else {
#line 954
              if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
                if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 954
                  tmp___814 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                } else {
#line 954
                  tmp___814 = 0;
                }
#line 954
                if (tmp___814) {
#line 954
                  if ((yyvsp + -1)->textintval.value == -1L) {
#line 954
                    tmp___813 = 0L < (yyvsp + 0)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                  } else {
#line 954
                    tmp___813 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
                  }
                } else {
#line 954
                  tmp___813 = (-0x7FFFFFFFFFFFFFFF-1) / (yyvsp + -1)->textintval.value < (yyvsp + 0)->intval;
                }
#line 954
                tmp___815 = tmp___813;
              } else {
#line 954
                tmp___815 = 9223372036854775807L / (yyvsp + 0)->intval < (yyvsp + -1)->textintval.value;
              }
#line 954
              tmp___816 = tmp___815;
            }
#line 954
            tmp___817 = tmp___816;
          }
#line 954
          if (tmp___817) {
#line 954
            yyval.rel.day = (long )((unsigned long )(yyvsp + -1)->textintval.value * (unsigned long )(yyvsp + 0)->intval);
#line 954
            tmp___803 = 1;
          } else {
#line 954
            yyval.rel.day = (long )((unsigned long )(yyvsp + -1)->textintval.value * (unsigned long )(yyvsp + 0)->intval);
#line 954
            tmp___803 = 0;
          }
#line 954
          tmp___905 = tmp___803;
        } else {
#line 954
          if ((yyvsp + 0)->intval < 0L) {
#line 954
            if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
              tmp___869 = (long long )(yyvsp + -1)->textintval.value < 9223372036854775807LL / (long long )(yyvsp + 0)->intval;
            } else {
#line 954
              if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 954
                tmp___868 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
              } else {
#line 954
                tmp___868 = 0;
              }
#line 954
              if (tmp___868) {
#line 954
                if ((yyvsp + 0)->intval == -1L) {
#line 954
                  tmp___867 = 0LL < (long long )(yyvsp + -1)->textintval.value + (-0x7FFFFFFFFFFFFFFF-1);
                } else {
#line 954
                  tmp___867 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->textintval.value;
                }
              } else {
#line 954
                tmp___867 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->textintval.value;
              }
#line 954
              tmp___869 = tmp___867;
            }
#line 954
            tmp___875 = tmp___869;
          } else {
#line 954
            if ((yyvsp + 0)->intval == 0L) {
#line 954
              tmp___874 = 0;
            } else {
#line 954
              if ((yyvsp + -1)->textintval.value < 0L) {
#line 954
                if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 954
                  tmp___872 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                } else {
#line 954
                  tmp___872 = 0;
                }
#line 954
                if (tmp___872) {
#line 954
                  if ((yyvsp + -1)->textintval.value == -1L) {
#line 954
                    tmp___871 = 0LL < (long long )(yyvsp + 0)->intval + (-0x7FFFFFFFFFFFFFFF-1);
                  } else {
#line 954
                    tmp___871 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + -1)->textintval.value < (long long )(yyvsp + 0)->intval;
                  }
                } else {
#line 954
                  tmp___871 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(yyvsp + -1)->textintval.value < (long long )(yyvsp + 0)->intval;
                }
#line 954
                tmp___873 = tmp___871;
              } else {
#line 954
                tmp___873 = 9223372036854775807LL / (long long )(yyvsp + 0)->intval < (long long )(yyvsp + -1)->textintval.value;
              }
#line 954
              tmp___874 = tmp___873;
            }
#line 954
            tmp___875 = tmp___874;
          }
#line 954
          if (tmp___875) {
#line 954
            yyval.rel.day = (intmax_t )((long long )((unsigned long long )(yyvsp + -1)->textintval.value * (unsigned long long )(yyvsp + 0)->intval));
#line 954
            tmp___861 = 1;
          } else {
#line 954
            yyval.rel.day = (intmax_t )((long long )((unsigned long long )(yyvsp + -1)->textintval.value * (unsigned long long )(yyvsp + 0)->intval));
#line 954
            tmp___861 = 0;
          }
#line 954
          tmp___905 = tmp___861;
        }
#line 954
        tmp___906 = tmp___905;
      }
#line 954
      tmp___907 = tmp___906;
    }
#line 954
    tmp___908 = tmp___907;
  }
#line 954
  if (tmp___908) {
#line 954
    goto yyabortlab;
  }
#line 2411 "parse-datetime.tab.c"
  goto switch_break;
  case_78: /* CIL Label */ 
#line 956 "parse-datetime.y"
  __constr_expr_23.year = (intmax_t )0;
#line 956
  __constr_expr_23.month = (intmax_t )0;
#line 956
  __constr_expr_23.day = (intmax_t )0;
#line 956
  __constr_expr_23.hour = (intmax_t )0;
#line 956
  __constr_expr_23.minutes = (intmax_t )0;
#line 956
  __constr_expr_23.seconds = (intmax_t )0;
#line 956
  __constr_expr_23.ns = 0;
#line 956
  yyval.rel = __constr_expr_23;
#line 956
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 2417 "parse-datetime.tab.c"
  goto switch_break;
  case_79: /* CIL Label */ 
#line 958 "parse-datetime.y"
  __constr_expr_24.year = (intmax_t )0;
#line 958
  __constr_expr_24.month = (intmax_t )0;
#line 958
  __constr_expr_24.day = (intmax_t )0;
#line 958
  __constr_expr_24.hour = (intmax_t )0;
#line 958
  __constr_expr_24.minutes = (intmax_t )0;
#line 958
  __constr_expr_24.seconds = (intmax_t )0;
#line 958
  __constr_expr_24.ns = 0;
#line 958
  yyval.rel = __constr_expr_24;
#line 958
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 2423 "parse-datetime.tab.c"
  goto switch_break;
  case_80: /* CIL Label */ 
#line 960 "parse-datetime.y"
  __constr_expr_25.year = (intmax_t )0;
#line 960
  __constr_expr_25.month = (intmax_t )0;
#line 960
  __constr_expr_25.day = (intmax_t )0;
#line 960
  __constr_expr_25.hour = (intmax_t )0;
#line 960
  __constr_expr_25.minutes = (intmax_t )0;
#line 960
  __constr_expr_25.seconds = (intmax_t )0;
#line 960
  __constr_expr_25.ns = 0;
#line 960
  yyval.rel = __constr_expr_25;
#line 960
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 2429 "parse-datetime.tab.c"
  goto switch_break;
  case_81: /* CIL Label */ 
#line 965 "parse-datetime.y"
  __constr_expr_26.year = (intmax_t )0;
#line 965
  __constr_expr_26.month = (intmax_t )0;
#line 965
  __constr_expr_26.day = (intmax_t )0;
#line 965
  __constr_expr_26.hour = (intmax_t )0;
#line 965
  __constr_expr_26.minutes = (intmax_t )0;
#line 965
  __constr_expr_26.seconds = (intmax_t )0;
#line 965
  __constr_expr_26.ns = 0;
#line 965
  yyval.rel = __constr_expr_26;
#line 965
  yyval.rel.day = (yyvsp + 0)->intval;
#line 2435 "parse-datetime.tab.c"
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 973 "parse-datetime.y"
  tmp___909 = time_overflow((yyvsp + 0)->textintval.value);
  }
#line 973
  if (tmp___909) {
#line 973
    goto yyabortlab;
  }
#line 974
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 974
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 2442 "parse-datetime.tab.c"
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 980 "parse-datetime.y"
  tmp___910 = time_overflow((yyvsp + 0)->textintval.value);
  }
#line 980
  if (tmp___910) {
#line 980
    goto yyabortlab;
  }
#line 981
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 981
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 2449 "parse-datetime.tab.c"
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 986 "parse-datetime.y"
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  }
#line 2455 "parse-datetime.tab.c"
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 994 "parse-datetime.y"
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 995
  tmp___911 = apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 995
  if (! tmp___911) {
#line 995
    goto yyabortlab;
  }
#line 2466 "parse-datetime.tab.c"
  goto switch_break;
  case_90: /* CIL Label */ 
#line 1001 "parse-datetime.y"
  yyval.intval = (intmax_t )-1;
#line 2472 "parse-datetime.tab.c"
  goto switch_break;
  case_91: /* CIL Label */ 
#line 1003 "parse-datetime.y"
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 2478 "parse-datetime.tab.c"
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2482
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2497
  yyvsp -= yylen;
#line 2497
  yyssp -= yylen;
#line 2498
  yylen = 0;
#line 2501
  yyvsp ++;
#line 2501
  *yyvsp = yyval;
#line 2507
  yyn = (int )yyr1[yyn];
#line 2509
  yystate = (int )((int const   )yypgoto[yyn - 28] + (int const   )*yyssp);
#line 2510
  if (0 <= yystate) {
#line 2510
    if (yystate <= 112) {
#line 2510
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2511
        yystate = (int )yytable[yystate];
      } else {
#line 2513
        yystate = (int )yydefgoto[yyn - 28];
      }
    } else {
#line 2513
      yystate = (int )yydefgoto[yyn - 28];
    }
  } else {
#line 2513
    yystate = (int )yydefgoto[yyn - 28];
  }
#line 2515
  goto yynewstate;
  yyerrlab: 
#line 2524
  if (yychar == -2) {
#line 2524
    yytoken = -2;
  } else {
#line 2524
    if ((unsigned int )yychar <= 277U) {
#line 2524
      tmp___912 = (int const   )yytranslate[yychar];
    } else {
#line 2524
      tmp___912 = (int const   )2;
    }
#line 2524
    yytoken = (int )tmp___912;
  }
#line 2527
  if (! yyerrstatus) {
    {
#line 2529
    yynerrs ++;
#line 2531
    yyerror((parser_control const   *)pc, "syntax error");
    }
  }
#line 2568
  if (yyerrstatus == 3) {
#line 2573
    if (yychar <= 0) {
#line 2576
      if (yychar == 0) {
#line 2577
        goto yyabortlab;
      }
    } else {
      {
#line 2581
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2583
      yychar = -2;
      }
    }
  }
#line 2589
  goto yyerrlab1;
#line 2605
  yyvsp -= yylen;
#line 2605
  yyssp -= yylen;
#line 2606
  yylen = 0;
#line 2608
  yystate = (int )*yyssp;
#line 2609
  goto yyerrlab1;
  yyerrlab1: 
#line 2616
  yyerrstatus = 3;
  {
#line 2618
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2620
    yyn = (int )yypact[yystate];
#line 2621
    if (! (! (! (yyn == -93)))) {
#line 2623
      yyn ++;
#line 2624
      if (0 <= yyn) {
#line 2624
        if (yyn <= 112) {
#line 2624
          if ((int const   )yycheck[yyn] == 1) {
#line 2626
            yyn = (int )yytable[yyn];
#line 2627
            if (0 < yyn) {
#line 2628
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2633
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2634
      goto yyabortlab;
    }
    {
#line 2637
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2639
    yyvsp --;
#line 2639
    yyssp --;
#line 2640
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2645
  yyvsp ++;
#line 2645
  *yyvsp = yylval;
#line 2652
  yystate = yyn;
#line 2653
  goto yynewstate;
  yyacceptlab: 
#line 2660
  yyresult = 0;
#line 2661
  goto yyreturn;
  yyabortlab: 
#line 2667
  yyresult = 1;
#line 2668
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2675
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2676
  yyresult = 2;
  }
  yyreturn: 
#line 2681
  if (yychar != -2) {
#line 2685
    if ((unsigned int )yychar <= 277U) {
#line 2685
      yytoken = (int )yytranslate[yychar];
    } else {
#line 2685
      yytoken = 2;
    }
    {
#line 2686
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
    }
  }
#line 2691
  yyvsp -= yylen;
#line 2691
  yyssp -= yylen;
  {
#line 2693
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2693
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2693
      goto while_break___2;
    }
    {
#line 2695
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2697
    yyvsp --;
#line 2697
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2700
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2701
    free((void *)yyss);
    }
  }
#line 2707
  return (yyresult);
}
}
#line 1008 "parse-datetime.y"
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1017 "parse-datetime.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 1022 "parse-datetime.y"
static table const   month_and_day_table[25]  = 
#line 1022
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1051 "parse-datetime.y"
static table const   time_units_table[11]  = 
#line 1051
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1067 "parse-datetime.y"
static table const   relative_time_table[21]  = 
#line 1067
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, -1}, 
        {"HENCE", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1096 "parse-datetime.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1109 "parse-datetime.y"
static table const   time_zone_table[48]  = 
#line 1109
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -10800}, 
        {"BRT", 273, -10800}, 
        {"BRST", 268, -10800}, 
        {"NST", 273, -12600}, 
        {"NDT", 268, -12600}, 
        {"AST", 273, -14400}, 
        {"ADT", 268, -14400}, 
        {"CLT", 273, -14400}, 
        {"CLST", 268, -14400}, 
        {"EST", 273, -18000}, 
        {"EDT", 268, -18000}, 
        {"CST", 273, -21600}, 
        {"CDT", 268, -21600}, 
        {"MST", 273, -25200}, 
        {"MDT", 268, -25200}, 
        {"PST", 273, -28800}, 
        {"PDT", 268, -28800}, 
        {"AKST", 273, -32400}, 
        {"AKDT", 268, -32400}, 
        {"HST", 273, -36000}, 
        {"HAST", 273, -36000}, 
        {"HADT", 268, -36000}, 
        {"SST", 273, -43200}, 
        {"WAT", 273, 3600}, 
        {"CET", 273, 3600}, 
        {"CEST", 268, 3600}, 
        {"MET", 273, 3600}, 
        {"MEZ", 273, 3600}, 
        {"MEST", 268, 3600}, 
        {"MESZ", 268, 3600}, 
        {"EET", 273, 7200}, 
        {"EEST", 268, 7200}, 
        {"CAT", 273, 7200}, 
        {"SAST", 273, 7200}, 
        {"EAT", 273, 10800}, 
        {"MSK", 273, 10800}, 
        {"MSD", 268, 10800}, 
        {"IST", 273, 19800}, 
        {"SGT", 273, 28800}, 
        {"KST", 273, 32400}, 
        {"JST", 273, 32400}, 
        {"GST", 273, 36000}, 
        {"NZST", 273, 43200}, 
        {"NZDT", 268, 43200}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1168 "parse-datetime.y"
static table const   military_table[26]  = 
#line 1168
  {      {"A", 273, 3600}, 
        {"B", 273, 7200}, 
        {"C", 273, 10800}, 
        {"D", 273, 14400}, 
        {"E", 273, 18000}, 
        {"F", 273, 21600}, 
        {"G", 273, 25200}, 
        {"H", 273, 28800}, 
        {"I", 273, 32400}, 
        {"K", 273, 36000}, 
        {"L", 273, 39600}, 
        {"M", 273, 43200}, 
        {"N", 273, -3600}, 
        {"O", 273, -7200}, 
        {"P", 273, -10800}, 
        {"Q", 273, -14400}, 
        {"R", 273, -18000}, 
        {"S", 273, -21600}, 
        {"T", 'T', 0}, 
        {"U", 273, -28800}, 
        {"V", 273, -32400}, 
        {"W", 273, -36000}, 
        {"X", 273, -39600}, 
        {"Y", 273, -43200}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 1207 "parse-datetime.y"
static _Bool time_zone_hhmm(parser_control *pc , textint s , intmax_t mm ) 
{ 
  intmax_t n_minutes ;
  _Bool overflow ;
  int tmp___11 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___61 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___111 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___161 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___211 ;
  int tmp___221 ;
  int tmp___222 ;
  int tmp___223 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___253 ;
  int tmp___254 ;
  int tmp___255 ;

  {
#line 1211
  overflow = (_Bool)0;
#line 1215
  if (s.digits <= 2L) {
#line 1215
    if (mm < 0L) {
#line 1216
      s.value *= 100L;
    }
  }
#line 1218
  if (mm < 0L) {
#line 1219
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 1222
    if (sizeof(n_minutes) == sizeof(signed char )) {
#line 1222
      if (s.value < 0L) {
#line 1222
        if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1222
          tmp___22 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
        } else {
#line 1222
          tmp___22 = 0;
        }
#line 1222
        if (tmp___22) {
#line 1222
          if (s.value == -1L) {
#line 1222
            tmp___21 = 0;
          } else {
#line 1222
            tmp___21 = -128L / s.value < 60L;
          }
        } else {
#line 1222
          tmp___21 = -128L / s.value < 60L;
        }
#line 1222
        tmp___23 = tmp___21;
      } else {
#line 1222
        tmp___23 = 2L < s.value;
      }
#line 1222
      if (tmp___23) {
#line 1222
        n_minutes = (intmax_t )((signed char )((unsigned int )s.value * 60U));
#line 1222
        tmp___11 = 1;
      } else {
#line 1222
        n_minutes = (intmax_t )((signed char )((unsigned int )s.value * 60U));
#line 1222
        tmp___11 = 0;
      }
#line 1222
      tmp___252 = tmp___11;
    } else {
#line 1222
      if (sizeof(n_minutes) == sizeof(short )) {
#line 1222
        if (s.value < 0L) {
#line 1222
          if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1222
            tmp___72 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 1222
            tmp___72 = 0;
          }
#line 1222
          if (tmp___72) {
#line 1222
            if (s.value == -1L) {
#line 1222
              tmp___71 = 0;
            } else {
#line 1222
              tmp___71 = -32768L / s.value < 60L;
            }
          } else {
#line 1222
            tmp___71 = -32768L / s.value < 60L;
          }
#line 1222
          tmp___73 = tmp___71;
        } else {
#line 1222
          tmp___73 = 546L < s.value;
        }
#line 1222
        if (tmp___73) {
#line 1222
          n_minutes = (intmax_t )((short )((unsigned int )s.value * 60U));
#line 1222
          tmp___61 = 1;
        } else {
#line 1222
          n_minutes = (intmax_t )((short )((unsigned int )s.value * 60U));
#line 1222
          tmp___61 = 0;
        }
#line 1222
        tmp___251 = tmp___61;
      } else {
#line 1222
        if (sizeof(n_minutes) == sizeof(int )) {
#line 1222
          if (s.value < 0L) {
#line 1222
            if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1222
              tmp___122 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 1222
              tmp___122 = 0;
            }
#line 1222
            if (tmp___122) {
#line 1222
              if (s.value == -1L) {
#line 1222
                tmp___121 = 0;
              } else {
#line 1222
                tmp___121 = (-0x7FFFFFFF-1) / s.value < 60L;
              }
            } else {
#line 1222
              tmp___121 = (-0x7FFFFFFF-1) / s.value < 60L;
            }
#line 1222
            tmp___123 = tmp___121;
          } else {
#line 1222
            tmp___123 = 35791394L < s.value;
          }
#line 1222
          if (tmp___123) {
#line 1222
            n_minutes = (intmax_t )((int )((unsigned int )s.value * 60U));
#line 1222
            tmp___111 = 1;
          } else {
#line 1222
            n_minutes = (intmax_t )((int )((unsigned int )s.value * 60U));
#line 1222
            tmp___111 = 0;
          }
#line 1222
          tmp___250 = tmp___111;
        } else {
#line 1222
          if (sizeof(n_minutes) == sizeof(long )) {
#line 1222
            if (s.value < 0L) {
#line 1222
              if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1222
                tmp___172 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 1222
                tmp___172 = 0;
              }
#line 1222
              if (tmp___172) {
#line 1222
                if (s.value == -1L) {
#line 1222
                  tmp___171 = 0;
                } else {
#line 1222
                  tmp___171 = (-0x7FFFFFFFFFFFFFFF-1) / s.value < 60L;
                }
              } else {
#line 1222
                tmp___171 = (-0x7FFFFFFFFFFFFFFF-1) / s.value < 60L;
              }
#line 1222
              tmp___173 = tmp___171;
            } else {
#line 1222
              tmp___173 = 153722867280912930L < s.value;
            }
#line 1222
            if (tmp___173) {
#line 1222
              n_minutes = (long )((unsigned long )s.value * 60UL);
#line 1222
              tmp___161 = 1;
            } else {
#line 1222
              n_minutes = (long )((unsigned long )s.value * 60UL);
#line 1222
              tmp___161 = 0;
            }
#line 1222
            tmp___249 = tmp___161;
          } else {
#line 1222
            if (s.value < 0L) {
#line 1222
              if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 1222
                tmp___222 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
              } else {
#line 1222
                tmp___222 = 0;
              }
#line 1222
              if (tmp___222) {
#line 1222
                if (s.value == -1L) {
#line 1222
                  tmp___221 = 0;
                } else {
#line 1222
                  tmp___221 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )s.value < 60LL;
                }
              } else {
#line 1222
                tmp___221 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )s.value < 60LL;
              }
#line 1222
              tmp___223 = tmp___221;
            } else {
#line 1222
              tmp___223 = 153722867280912930LL < (long long )s.value;
            }
#line 1222
            if (tmp___223) {
#line 1222
              n_minutes = (intmax_t )((long long )((unsigned long long )s.value * 60ULL));
#line 1222
              tmp___211 = 1;
            } else {
#line 1222
              n_minutes = (intmax_t )((long long )((unsigned long long )s.value * 60ULL));
#line 1222
              tmp___211 = 0;
            }
#line 1222
            tmp___249 = tmp___211;
          }
#line 1222
          tmp___250 = tmp___249;
        }
#line 1222
        tmp___251 = tmp___250;
      }
#line 1222
      tmp___252 = tmp___251;
    }
#line 1222
    overflow = (_Bool )((int )overflow | tmp___252);
#line 1223
    if (s.negative) {
      {
#line 1223
      tmp___253 = __builtin_sub_overflow(n_minutes, mm, & n_minutes);
#line 1223
      tmp___255 = tmp___253;
      }
    } else {
      {
#line 1223
      tmp___254 = __builtin_add_overflow(n_minutes, mm, & n_minutes);
#line 1223
      tmp___255 = tmp___254;
      }
    }
#line 1223
    overflow = (_Bool )((int )overflow | tmp___255);
  }
#line 1228
  if (overflow) {
#line 1229
    return ((_Bool)0);
  } else
#line 1228
  if (-1440L <= n_minutes) {
#line 1228
    if (! (n_minutes <= 1440L)) {
#line 1229
      return ((_Bool)0);
    }
  } else {
#line 1229
    return ((_Bool)0);
  }
#line 1230
  pc->time_zone = (int )(n_minutes * 60L);
#line 1231
  return ((_Bool)1);
}
}
#line 1234 "parse-datetime.y"
static int to_hour(intmax_t hours , int meridian ) 
{ 
  intmax_t tmp ;
  int tmp___0 ;
  intmax_t tmp___1 ;
  int tmp___2 ;
  intmax_t tmp___3 ;

  {
  {
#line 1242
  if (meridian == 0) {
#line 1242
    goto case_0;
  }
#line 1244
  if (meridian == 1) {
#line 1244
    goto case_1;
  }
#line 1239
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1241
  if (0L <= hours) {
#line 1241
    if (hours < 24L) {
#line 1241
      tmp = hours;
    } else {
#line 1241
      tmp = (intmax_t )-1;
    }
  } else {
#line 1241
    tmp = (intmax_t )-1;
  }
#line 1241
  return ((int )tmp);
  case_0: /* CIL Label */ 
#line 1243
  if (0L < hours) {
#line 1243
    if (hours < 12L) {
#line 1243
      tmp___1 = hours;
    } else {
#line 1243
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1243
    if (hours == 12L) {
#line 1243
      tmp___0 = 0;
    } else {
#line 1243
      tmp___0 = -1;
    }
#line 1243
    tmp___1 = (intmax_t )tmp___0;
  }
#line 1243
  return ((int )tmp___1);
  case_1: /* CIL Label */ 
#line 1245
  if (0L < hours) {
#line 1245
    if (hours < 12L) {
#line 1245
      tmp___3 = hours + 12L;
    } else {
#line 1245
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 1245
    if (hours == 12L) {
#line 1245
      tmp___2 = 12;
    } else {
#line 1245
      tmp___2 = -1;
    }
#line 1245
    tmp___3 = (intmax_t )tmp___2;
  }
#line 1245
  return ((int )tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1255 "parse-datetime.y"
static char const   *tm_year_str(int tm_year , char *buf ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1259
  tmp = abs(tm_year % 100);
#line 1259
  tmp___0 = abs(tm_year / 100 + 19);
#line 1259
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)("-%02d%02d" + (-1900 <= tm_year)),
          tmp___0, tmp);
  }
#line 1262
  return ((char const   *)buf);
}
}
#line 1268 "parse-datetime.y"
static _Bool to_tm_year(textint textyear , _Bool debug , int *tm_year ) 
{ 
  intmax_t year ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1271
  year = textyear.value;
#line 1275
  if (0L <= year) {
#line 1275
    if (textyear.digits == 2L) {
#line 1277
      if (year < 69L) {
#line 1277
        tmp = 2000;
      } else {
#line 1277
        tmp = 1900;
      }
#line 1277
      year += (intmax_t )tmp;
#line 1278
      if (debug) {
        {
#line 1279
        tmp___0 = dcgettext((char const   *)((void *)0), "warning: adjusting year value %ld to %ld\n",
                            5);
#line 1279
        dbg_printf((char const   *)tmp___0, textyear.value, year);
        }
      }
    }
  }
#line 1284
  if (year < 0L) {
    {
#line 1284
    tmp___2 = __builtin_sub_overflow(-1900, year, tm_year);
#line 1284
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 1284
    tmp___3 = __builtin_sub_overflow(year, 1900, tm_year);
#line 1284
    tmp___4 = tmp___3;
    }
  }
#line 1284
  if (tmp___4) {
#line 1288
    if (debug) {
      {
#line 1289
      tmp___1 = dcgettext((char const   *)((void *)0), "error: out-of-range year %ld\n",
                          5);
#line 1289
      dbg_printf((char const   *)tmp___1, year);
      }
    }
#line 1290
    return ((_Bool)0);
  }
#line 1293
  return ((_Bool)1);
}
}
#line 1296 "parse-datetime.y"
static table const   * __attribute__((__pure__)) lookup_zone(parser_control const   *pc ,
                                                             char const   *name ) 
{ 
  table const   *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1301
  tp = universal_time_zone_table;
  {
#line 1301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1301
    if (! tp->name) {
#line 1301
      goto while_break;
    }
    {
#line 1302
    tmp = strcmp(name, (char const   *)tp->name);
    }
#line 1302
    if (tmp == 0) {
#line 1303
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 1301
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1307
  tp = (table const   *)(pc->local_time_zone_table);
  {
#line 1307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1307
    if (! tp->name) {
#line 1307
      goto while_break___0;
    }
    {
#line 1308
    tmp___0 = strcmp(name, (char const   *)tp->name);
    }
#line 1308
    if (tmp___0 == 0) {
#line 1309
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 1307
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1311
  tp = time_zone_table;
  {
#line 1311
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1311
    if (! tp->name) {
#line 1311
      goto while_break___1;
    }
    {
#line 1312
    tmp___1 = strcmp(name, (char const   *)tp->name);
    }
#line 1312
    if (tmp___1 == 0) {
#line 1313
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 1311
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1315
  return ((table const   */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 1345 "parse-datetime.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  ptrdiff_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  table const   * __attribute__((__pure__)) tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char tmp___12 ;
  table const   * __attribute__((__pure__)) tmp___13 ;

  {
#line 1356
  p = word;
  {
#line 1356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1356
    if (! *p) {
#line 1356
      goto while_break;
    }
    {
#line 1357
    tmp = to_uchar(*p);
#line 1357
    tmp___0 = c_toupper((int )tmp);
#line 1357
    *p = (char )tmp___0;
#line 1356
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1359
  tp = meridian_table;
  {
#line 1359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1359
    if (! tp->name) {
#line 1359
      goto while_break___0;
    }
    {
#line 1360
    tmp___1 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 1360
    if (tmp___1 == 0) {
#line 1361
      return (tp);
    }
#line 1359
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1364
  tmp___2 = strlen((char const   *)word);
#line 1364
  wordlen = (ptrdiff_t )tmp___2;
  }
#line 1365
  if (wordlen == 3L) {
#line 1365
    tmp___3 = 1;
  } else
#line 1365
  if (wordlen == 4L) {
#line 1365
    if ((int )*(word + 3) == 46) {
#line 1365
      tmp___3 = 1;
    } else {
#line 1365
      tmp___3 = 0;
    }
  } else {
#line 1365
    tmp___3 = 0;
  }
#line 1365
  abbrev = (_Bool )tmp___3;
#line 1367
  tp = month_and_day_table;
  {
#line 1367
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1367
    if (! tp->name) {
#line 1367
      goto while_break___1;
    }
#line 1368
    if (abbrev) {
      {
#line 1368
      tmp___4 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 1368
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 1368
      tmp___5 = strcmp((char const   *)word, (char const   *)tp->name);
#line 1368
      tmp___6 = tmp___5;
      }
    }
#line 1368
    if (tmp___6 == 0) {
#line 1369
      return (tp);
    }
#line 1367
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1371
  tmp___7 = lookup_zone(pc, (char const   *)word);
#line 1371
  tp = (table const   *)tmp___7;
  }
#line 1371
  if (tp) {
#line 1372
    return (tp);
  }
  {
#line 1374
  tmp___8 = strcmp((char const   *)word, (char const   *)dst_table[0].name);
  }
#line 1374
  if (tmp___8 == 0) {
#line 1375
    return (dst_table);
  }
#line 1377
  tp = time_units_table;
  {
#line 1377
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1377
    if (! tp->name) {
#line 1377
      goto while_break___2;
    }
    {
#line 1378
    tmp___9 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 1378
    if (tmp___9 == 0) {
#line 1379
      return (tp);
    }
#line 1377
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1382
  if ((int )*(word + (wordlen - 1L)) == 83) {
#line 1384
    *(word + (wordlen - 1L)) = (char )'\000';
#line 1385
    tp = time_units_table;
    {
#line 1385
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1385
      if (! tp->name) {
#line 1385
        goto while_break___3;
      }
      {
#line 1386
      tmp___10 = strcmp((char const   *)word, (char const   *)tp->name);
      }
#line 1386
      if (tmp___10 == 0) {
#line 1387
        return (tp);
      }
#line 1385
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1388
    *(word + (wordlen - 1L)) = (char )'S';
  }
#line 1391
  tp = relative_time_table;
  {
#line 1391
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1391
    if (! tp->name) {
#line 1391
      goto while_break___4;
    }
    {
#line 1392
    tmp___11 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 1392
    if (tmp___11 == 0) {
#line 1393
      return (tp);
    }
#line 1391
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1396
  if (wordlen == 1L) {
#line 1397
    tp = military_table;
    {
#line 1397
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1397
      if (! tp->name) {
#line 1397
        goto while_break___5;
      }
#line 1398
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 1399
        return (tp);
      }
#line 1397
      tp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1402
  period_found = (_Bool)0;
#line 1402
  q = word;
#line 1402
  p = q;
  {
#line 1402
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1402
    tmp___12 = *q;
#line 1402
    *p = tmp___12;
#line 1402
    if (! tmp___12) {
#line 1402
      goto while_break___6;
    }
#line 1403
    if ((int )*q == 46) {
#line 1404
      period_found = (_Bool)1;
    } else {
#line 1406
      p ++;
    }
#line 1402
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1407
  if (period_found) {
    {
#line 1407
    tmp___13 = lookup_zone(pc, (char const   *)word);
#line 1407
    tp = (table const   *)tmp___13;
    }
#line 1407
    if (tp) {
#line 1408
      return (tp);
    }
  }
#line 1410
  return ((table const   *)((void *)0));
}
}
#line 1413 "parse-datetime.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  _Bool tmp ;
  char const   *p ;
  int sign ;
  intmax_t value___0 ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___14 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___64 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___114 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___164 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___176 ;
  int tmp___214 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___252 ;
  int tmp___253 ;
  int tmp___254 ;
  int tmp___255 ;
  int tmp___256 ;
  int tmp___257 ;
  _Bool tmp___258 ;
  time_t s ;
  int ns ;
  int digits ;
  _Bool tmp___259 ;
  char const   *tmp___260 ;
  char const   *tmp___261 ;
  _Bool tmp___262 ;
  _Bool tmp___263 ;
  _Bool tmp___264 ;
  int tmp___265 ;
  int tmp___266 ;
  _Bool tmp___267 ;
  _Bool tmp___268 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___269 ;
  _Bool tmp___270 ;
  char *tmp___271 ;
  _Bool tmp___272 ;
  char const   *tmp___273 ;
  unsigned char tmp___274 ;
  ptrdiff_t count ;
  char const   *tmp___275 ;

  {
  {
#line 1418
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1420
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1420
      c = (unsigned char )*(pc->input);
#line 1420
      tmp = c_isspace((int )c);
      }
#line 1420
      if (! tmp) {
#line 1420
        goto while_break___0;
      }
#line 1421
      (pc->input) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1423
    tmp___268 = c_isdigit((int )c);
    }
#line 1423
    if (tmp___268) {
#line 1423
      goto _L___2;
    } else
#line 1423
    if ((int )c == 45) {
#line 1423
      goto _L___2;
    } else
#line 1423
    if ((int )c == 43) {
      _L___2: /* CIL Label */ 
#line 1427
      value___0 = (intmax_t )0;
#line 1428
      if ((int )c == 45) {
#line 1428
        goto _L;
      } else
#line 1428
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 1430
        if ((int )c == 45) {
#line 1430
          sign = -1;
        } else {
#line 1430
          sign = 1;
        }
        {
#line 1431
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1431
          (pc->input) ++;
#line 1431
          c = (unsigned char )*(pc->input);
#line 1431
          tmp___0 = c_isspace((int )c);
          }
#line 1431
          if (! tmp___0) {
#line 1431
            goto while_break___1;
          }
#line 1432
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1433
        tmp___1 = c_isdigit((int )c);
        }
#line 1433
        if (! tmp___1) {
#line 1435
          goto __Cont;
        }
      } else {
#line 1438
        sign = 0;
      }
#line 1439
      p = pc->input;
      {
#line 1441
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1443
        if (sizeof(value___0) == sizeof(signed char )) {
#line 1443
          if (value___0 < 0L) {
#line 1443
            if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1443
              tmp___25 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 1443
              tmp___25 = 0;
            }
#line 1443
            if (tmp___25) {
#line 1443
              if (value___0 == -1L) {
#line 1443
                tmp___24 = 0;
              } else {
#line 1443
                tmp___24 = -128L / value___0 < 10L;
              }
            } else {
#line 1443
              tmp___24 = -128L / value___0 < 10L;
            }
#line 1443
            tmp___26 = tmp___24;
          } else {
#line 1443
            tmp___26 = 12L < value___0;
          }
#line 1443
          if (tmp___26) {
#line 1443
            value___0 = (intmax_t )((signed char )((unsigned int )value___0 * 10U));
#line 1443
            tmp___14 = 1;
          } else {
#line 1443
            value___0 = (intmax_t )((signed char )((unsigned int )value___0 * 10U));
#line 1443
            tmp___14 = 0;
          }
#line 1443
          tmp___255 = tmp___14;
        } else {
#line 1443
          if (sizeof(value___0) == sizeof(short )) {
#line 1443
            if (value___0 < 0L) {
#line 1443
              if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1443
                tmp___75 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 1443
                tmp___75 = 0;
              }
#line 1443
              if (tmp___75) {
#line 1443
                if (value___0 == -1L) {
#line 1443
                  tmp___74 = 0;
                } else {
#line 1443
                  tmp___74 = -32768L / value___0 < 10L;
                }
              } else {
#line 1443
                tmp___74 = -32768L / value___0 < 10L;
              }
#line 1443
              tmp___76 = tmp___74;
            } else {
#line 1443
              tmp___76 = 3276L < value___0;
            }
#line 1443
            if (tmp___76) {
#line 1443
              value___0 = (intmax_t )((short )((unsigned int )value___0 * 10U));
#line 1443
              tmp___64 = 1;
            } else {
#line 1443
              value___0 = (intmax_t )((short )((unsigned int )value___0 * 10U));
#line 1443
              tmp___64 = 0;
            }
#line 1443
            tmp___254 = tmp___64;
          } else {
#line 1443
            if (sizeof(value___0) == sizeof(int )) {
#line 1443
              if (value___0 < 0L) {
#line 1443
                if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1443
                  tmp___125 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                } else {
#line 1443
                  tmp___125 = 0;
                }
#line 1443
                if (tmp___125) {
#line 1443
                  if (value___0 == -1L) {
#line 1443
                    tmp___124 = 0;
                  } else {
#line 1443
                    tmp___124 = (-0x7FFFFFFF-1) / value___0 < 10L;
                  }
                } else {
#line 1443
                  tmp___124 = (-0x7FFFFFFF-1) / value___0 < 10L;
                }
#line 1443
                tmp___126 = tmp___124;
              } else {
#line 1443
                tmp___126 = 214748364L < value___0;
              }
#line 1443
              if (tmp___126) {
#line 1443
                value___0 = (intmax_t )((int )((unsigned int )value___0 * 10U));
#line 1443
                tmp___114 = 1;
              } else {
#line 1443
                value___0 = (intmax_t )((int )((unsigned int )value___0 * 10U));
#line 1443
                tmp___114 = 0;
              }
#line 1443
              tmp___253 = tmp___114;
            } else {
#line 1443
              if (sizeof(value___0) == sizeof(long )) {
#line 1443
                if (value___0 < 0L) {
#line 1443
                  if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 1443
                    tmp___175 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                  } else {
#line 1443
                    tmp___175 = 0;
                  }
#line 1443
                  if (tmp___175) {
#line 1443
                    if (value___0 == -1L) {
#line 1443
                      tmp___174 = 0;
                    } else {
#line 1443
                      tmp___174 = (-0x7FFFFFFFFFFFFFFF-1) / value___0 < 10L;
                    }
                  } else {
#line 1443
                    tmp___174 = (-0x7FFFFFFFFFFFFFFF-1) / value___0 < 10L;
                  }
#line 1443
                  tmp___176 = tmp___174;
                } else {
#line 1443
                  tmp___176 = 922337203685477580L < value___0;
                }
#line 1443
                if (tmp___176) {
#line 1443
                  value___0 = (long )((unsigned long )value___0 * 10UL);
#line 1443
                  tmp___164 = 1;
                } else {
#line 1443
                  value___0 = (long )((unsigned long )value___0 * 10UL);
#line 1443
                  tmp___164 = 0;
                }
#line 1443
                tmp___252 = tmp___164;
              } else {
#line 1443
                if (value___0 < 0L) {
#line 1443
                  if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 1443
                    tmp___225 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                  } else {
#line 1443
                    tmp___225 = 0;
                  }
#line 1443
                  if (tmp___225) {
#line 1443
                    if (value___0 == -1L) {
#line 1443
                      tmp___224 = 0;
                    } else {
#line 1443
                      tmp___224 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )value___0 < 10LL;
                    }
                  } else {
#line 1443
                    tmp___224 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )value___0 < 10LL;
                  }
#line 1443
                  tmp___226 = tmp___224;
                } else {
#line 1443
                  tmp___226 = 922337203685477580LL < (long long )value___0;
                }
#line 1443
                if (tmp___226) {
#line 1443
                  value___0 = (intmax_t )((long long )((unsigned long long )value___0 * 10ULL));
#line 1443
                  tmp___214 = 1;
                } else {
#line 1443
                  value___0 = (intmax_t )((long long )((unsigned long long )value___0 * 10ULL));
#line 1443
                  tmp___214 = 0;
                }
#line 1443
                tmp___252 = tmp___214;
              }
#line 1443
              tmp___253 = tmp___252;
            }
#line 1443
            tmp___254 = tmp___253;
          }
#line 1443
          tmp___255 = tmp___254;
        }
#line 1443
        if (tmp___255) {
#line 1444
          return ('?');
        }
#line 1445
        if (sign < 0) {
#line 1445
          tmp___256 = 48 - (int )c;
        } else {
#line 1445
          tmp___256 = (int )c - 48;
        }
        {
#line 1445
        tmp___257 = __builtin_add_overflow(value___0, tmp___256, & value___0);
        }
#line 1445
        if (tmp___257) {
#line 1446
          return ('?');
        }
        {
#line 1447
        p ++;
#line 1447
        c = (unsigned char )*p;
#line 1441
        tmp___258 = c_isdigit((int )c);
        }
#line 1441
        if (! tmp___258) {
#line 1441
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1451
      if ((int )c == 46) {
#line 1451
        goto _L___1;
      } else
#line 1451
      if ((int )c == 44) {
        _L___1: /* CIL Label */ 
        {
#line 1451
        tmp___267 = c_isdigit((int )*(p + 1));
        }
#line 1451
        if (tmp___267) {
          {
#line 1457
          tmp___259 = time_overflow(value___0);
          }
#line 1457
          if (tmp___259) {
#line 1458
            return ('?');
          }
#line 1459
          s = value___0;
#line 1462
          p ++;
#line 1463
          tmp___260 = p;
#line 1463
          p ++;
#line 1463
          ns = (int )((int const   )*tmp___260 - 48);
#line 1464
          digits = 2;
          {
#line 1464
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1464
            if (! (digits <= 9)) {
#line 1464
              goto while_break___3;
            }
            {
#line 1466
            ns *= 10;
#line 1467
            tmp___262 = c_isdigit((int )*p);
            }
#line 1467
            if (tmp___262) {
#line 1468
              tmp___261 = p;
#line 1468
              p ++;
#line 1468
              ns += (int )((int const   )*tmp___261 - 48);
            }
#line 1464
            digits ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1472
          if (sign < 0) {
            {
#line 1473
            while (1) {
              while_continue___4: /* CIL Label */ ;
              {
#line 1473
              tmp___263 = c_isdigit((int )*p);
              }
#line 1473
              if (! tmp___263) {
#line 1473
                goto while_break___4;
              }
#line 1474
              if ((int const   )*p != 48) {
#line 1476
                ns ++;
#line 1477
                goto while_break___4;
              }
#line 1473
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 1479
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 1479
            tmp___264 = c_isdigit((int )*p);
            }
#line 1479
            if (! tmp___264) {
#line 1479
              goto while_break___5;
            }
#line 1480
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1485
          if (sign < 0) {
#line 1485
            if (ns) {
#line 1487
              if (s == ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) {
#line 1488
                return ('?');
              }
#line 1489
              s --;
#line 1490
              ns = 1000000000 - ns;
            }
          }
#line 1493
          lvalp->timespec.tv_sec = s;
#line 1494
          lvalp->timespec.tv_nsec = (__syscall_slong_t )ns;
#line 1495
          pc->input = p;
#line 1496
          if (sign) {
#line 1496
            tmp___265 = 276;
          } else {
#line 1496
            tmp___265 = 277;
          }
#line 1496
          return (tmp___265);
        } else {
#line 1451
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1500
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1501
        lvalp->textintval.value = value___0;
#line 1502
        lvalp->textintval.digits = p - pc->input;
#line 1503
        pc->input = p;
#line 1504
        if (sign) {
#line 1504
          tmp___266 = 274;
        } else {
#line 1504
          tmp___266 = 275;
        }
#line 1504
        return (tmp___266);
      }
    }
    {
#line 1508
    tmp___272 = c_isalpha((int )c);
    }
#line 1508
    if (tmp___272) {
#line 1511
      p___0 = buff;
      {
#line 1514
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1516
        if ((unsigned long )p___0 < (unsigned long )((buff + sizeof(buff)) - 1)) {
#line 1517
          tmp___269 = p___0;
#line 1517
          p___0 ++;
#line 1517
          *tmp___269 = (char )c;
        }
        {
#line 1518
        (pc->input) ++;
#line 1518
        c = (unsigned char )*(pc->input);
#line 1514
        tmp___270 = c_isalpha((int )c);
        }
#line 1514
        if (! tmp___270) {
#line 1514
          if (! ((int )c == 46)) {
#line 1514
            goto while_break___6;
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1522
      *p___0 = (char )'\000';
#line 1523
      tp = lookup_word((parser_control const   *)pc, buff);
      }
#line 1524
      if (! tp) {
#line 1526
        if (pc->parse_datetime_debug) {
          {
#line 1527
          tmp___271 = dcgettext((char const   *)((void *)0), "error: unknown word \'%s\'\n",
                                5);
#line 1527
          dbg_printf((char const   *)tmp___271, buff);
          }
        }
#line 1528
        return ('?');
      }
#line 1530
      lvalp->intval = (intmax_t )tp->value;
#line 1531
      return ((int )tp->type);
    }
#line 1534
    if ((int )c != 40) {
      {
#line 1535
      tmp___273 = pc->input;
#line 1535
      (pc->input) ++;
#line 1535
      tmp___274 = to_uchar((char )*tmp___273);
      }
#line 1535
      return ((int )tmp___274);
    }
#line 1537
    count = (ptrdiff_t )0;
    {
#line 1538
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1540
      tmp___275 = pc->input;
#line 1540
      (pc->input) ++;
#line 1540
      c = (unsigned char )*tmp___275;
#line 1541
      if ((int )c == 0) {
#line 1542
        return ((int )c);
      }
#line 1543
      if ((int )c == 40) {
#line 1544
        count ++;
      } else
#line 1545
      if ((int )c == 41) {
#line 1546
        count --;
      }
#line 1538
      if (! (count != 0L)) {
#line 1538
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1553 "parse-datetime.y"
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 


  {
#line 1557
  return (0);
}
}
#line 1566 "parse-datetime.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 ) 
{ 


  {
#line 1569
  if (tm1->tm_wday < 0) {
#line 1570
    return ((_Bool)0);
  }
#line 1572
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1582 "parse-datetime.y"
static char const   *debug_strfdatetime(struct tm  const  *tm , parser_control const   *pc ,
                                        char *buf , int n ) 
{ 
  int m ;
  size_t tmp ;
  int tz ;
  char time_zone_buf[27] ;
  char const   *tmp___0 ;

  {
  {
#line 1609
  tmp = nstrftime(buf, (size_t )n, "(Y-M-D) %Y-%m-%d %H:%M:%S", tm, (timezone_t )0,
                  0);
#line 1609
  m = (int )tmp;
  }
#line 1613
  if (pc) {
#line 1613
    if (m < n) {
#line 1613
      if (pc->zones_seen) {
#line 1615
        tz = (int )pc->time_zone;
#line 1618
        if (pc->local_zones_seen) {
#line 1618
          if (! pc->zones_seen) {
#line 1618
            if (0 < (int )pc->local_isdst) {
#line 1619
              tz += 3600;
            }
          }
        }
        {
#line 1622
        tmp___0 = time_zone_str(tz, (char *)(time_zone_buf));
#line 1622
        snprintf((char */* __restrict  */)(buf + m), (size_t )(n - m), (char const   */* __restrict  */)" TZ=%s",
                 tmp___0);
        }
      }
    }
  }
#line 1624
  return ((char const   *)buf);
}
}
#line 1627 "parse-datetime.y"
static char const   *debug_strfdate(struct tm  const  *tm , char *buf , int n ) 
{ 
  char tm_year_buf[13] ;
  char const   *tmp ;

  {
  {
#line 1631
  tmp = tm_year_str((int )tm->tm_year, (char *)(tm_year_buf));
#line 1631
  snprintf((char */* __restrict  */)buf, (size_t )n, (char const   */* __restrict  */)"(Y-M-D) %s-%02d-%02d",
           tmp, tm->tm_mon + 1, tm->tm_mday);
  }
#line 1634
  return ((char const   *)buf);
}
}
#line 1637 "parse-datetime.y"
static char const   *debug_strftime(struct tm  const  *tm , char *buf , int n ) 
{ 


  {
  {
#line 1640
  snprintf((char */* __restrict  */)buf, (size_t )n, (char const   */* __restrict  */)"%02d:%02d:%02d",
           tm->tm_hour, tm->tm_min, tm->tm_sec);
  }
#line 1641
  return ((char const   *)buf);
}
}
#line 1656 "parse-datetime.y"
static void debug_mktime_not_ok(struct tm  const  *tm0 , struct tm  const  *tm1 ,
                                parser_control const   *pc , _Bool time_zone_seen ) 
{ 
  char tmp[100] ;
  int i ;
  _Bool eq_sec ;
  _Bool eq_min ;
  _Bool eq_hour ;
  _Bool eq_mday ;
  _Bool eq_month ;
  _Bool eq_year ;
  _Bool dst_shift ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 1663
  eq_sec = (_Bool )(tm0->tm_sec == tm1->tm_sec);
#line 1664
  eq_min = (_Bool )(tm0->tm_min == tm1->tm_min);
#line 1665
  eq_hour = (_Bool )(tm0->tm_hour == tm1->tm_hour);
#line 1666
  eq_mday = (_Bool )(tm0->tm_mday == tm1->tm_mday);
#line 1667
  eq_month = (_Bool )(tm0->tm_mon == tm1->tm_mon);
#line 1668
  eq_year = (_Bool )(tm0->tm_year == tm1->tm_year);
#line 1670
  if (eq_sec) {
#line 1670
    if (eq_min) {
#line 1670
      if (! eq_hour) {
#line 1670
        if (eq_mday) {
#line 1670
          if (eq_month) {
#line 1670
            if (eq_year) {
#line 1670
              tmp___0 = 1;
            } else {
#line 1670
              tmp___0 = 0;
            }
          } else {
#line 1670
            tmp___0 = 0;
          }
        } else {
#line 1670
          tmp___0 = 0;
        }
      } else {
#line 1670
        tmp___0 = 0;
      }
    } else {
#line 1670
      tmp___0 = 0;
    }
  } else {
#line 1670
    tmp___0 = 0;
  }
#line 1670
  dst_shift = (_Bool )tmp___0;
#line 1673
  if (! pc->parse_datetime_debug) {
#line 1674
    return;
  }
  {
#line 1676
  tmp___1 = dcgettext((char const   *)((void *)0), "error: invalid date/time value:\n",
                      5);
#line 1676
  dbg_printf((char const   *)tmp___1);
#line 1677
  tmp___2 = debug_strfdatetime(tm0, pc, tmp, (int )sizeof(tmp));
#line 1677
  tmp___3 = dcgettext((char const   *)((void *)0), "    user provided time: \'%s\'\n",
                      5);
#line 1677
  dbg_printf((char const   *)tmp___3, tmp___2);
#line 1679
  tmp___4 = debug_strfdatetime(tm1, pc, tmp, (int )sizeof(tmp));
#line 1679
  tmp___5 = dcgettext((char const   *)((void *)0), "       normalized time: \'%s\'\n",
                      5);
#line 1679
  dbg_printf((char const   *)tmp___5, tmp___4);
  }
#line 1683
  if (eq_sec) {
#line 1683
    tmp___6 = "";
  } else {
#line 1683
    tmp___6 = "--";
  }
#line 1683
  if (eq_min) {
#line 1683
    tmp___7 = "";
  } else {
#line 1683
    tmp___7 = "--";
  }
#line 1683
  if (eq_hour) {
#line 1683
    tmp___8 = "";
  } else {
#line 1683
    tmp___8 = "--";
  }
#line 1683
  if (eq_mday) {
#line 1683
    tmp___9 = "";
  } else {
#line 1683
    tmp___9 = "--";
  }
#line 1683
  if (eq_month) {
#line 1683
    tmp___10 = "";
  } else {
#line 1683
    tmp___10 = "--";
  }
#line 1683
  if (eq_year) {
#line 1683
    tmp___11 = "";
  } else {
#line 1683
    tmp___11 = "----";
  }
  {
#line 1683
  i = snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"                                 %4s %2s %2s %2s %2s %2s",
               tmp___11, tmp___10, tmp___9, tmp___8, tmp___7, tmp___6);
  }
#line 1692
  if (0 <= i) {
#line 1694
    if (sizeof(tmp) - 1UL < (unsigned long )i) {
#line 1695
      i = (int )(sizeof(tmp) - 1UL);
    }
    {
#line 1696
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1696
      if (0 < i) {
#line 1696
        if (! ((int )tmp[i - 1] == 32)) {
#line 1696
          goto while_break;
        }
      } else {
#line 1696
        goto while_break;
      }
#line 1697
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1698
    tmp[i] = (char )'\000';
  }
  {
#line 1700
  dbg_printf("%s\n", tmp);
#line 1702
  tmp___12 = dcgettext((char const   *)((void *)0), "     possible reasons:\n", 5);
#line 1702
  dbg_printf((char const   *)tmp___12);
  }
#line 1703
  if (dst_shift) {
    {
#line 1704
    tmp___13 = dcgettext((char const   *)((void *)0), "       non-existing due to daylight-saving time;\n",
                         5);
#line 1704
    dbg_printf((char const   *)tmp___13);
    }
  }
#line 1705
  if (! eq_mday) {
#line 1705
    if (! eq_month) {
      {
#line 1706
      tmp___14 = dcgettext((char const   *)((void *)0), "       invalid day/month combination;\n",
                           5);
#line 1706
      dbg_printf((char const   *)tmp___14);
      }
    }
  }
  {
#line 1707
  tmp___15 = dcgettext((char const   *)((void *)0), "       numeric values overflow;\n",
                       5);
#line 1707
  dbg_printf((char const   *)tmp___15);
  }
#line 1708
  if (time_zone_seen) {
    {
#line 1708
    tmp___16 = dcgettext((char const   *)((void *)0), "incorrect timezone", 5);
#line 1708
    tmp___18 = tmp___16;
    }
  } else {
    {
#line 1708
    tmp___17 = dcgettext((char const   *)((void *)0), "missing timezone", 5);
#line 1708
    tmp___18 = tmp___17;
    }
  }
  {
#line 1708
  dbg_printf("       %s\n", tmp___18);
  }
#line 1710
  return;
}
}
#line 1713 "parse-datetime.y"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ 
  char const   *tzstring ;
  char *tmp ;
  timezone_t tz ;
  timezone_t tmp___0 ;
  _Bool ok ;
  _Bool tmp___1 ;

  {
  {
#line 1717
  tmp = getenv("TZ");
#line 1717
  tzstring = (char const   *)tmp;
#line 1718
  tmp___0 = tzalloc(tzstring);
#line 1718
  tz = tmp___0;
  }
#line 1719
  if (! tz) {
#line 1720
    return ((_Bool)0);
  }
  {
#line 1721
  tmp___1 = parse_datetime2(result, p, now, 0U, tz, tzstring);
#line 1721
  ok = tmp___1;
#line 1722
  tzfree(tz);
  }
#line 1723
  return (ok);
}
}
#line 1731 "parse-datetime.y"
_Bool parse_datetime2(struct timespec *result , char const   *p , struct timespec  const  *now ,
                      unsigned int flags , timezone_t tzdefault , char const   *tzstring ) 
{ 
  struct tm tm ;
  struct tm tm0 ;
  char time_zone_buf[27] ;
  char dbg_tm[100] ;
  _Bool ok ;
  char const   *input_sentinel ;
  size_t tmp ;
  char *tz1alloc ;
  char tz1buf[100] ;
  struct timespec gettime_buffer ;
  time_t Start ;
  int Start_ns ;
  unsigned char c ;
  _Bool tmp___0 ;
  timezone_t tz ;
  relative_time rel_time_0 ;
  char const   *tzbase ;
  ptrdiff_t tzsize ;
  char const   *s ;
  timezone_t tz1 ;
  char *tz1string ;
  char *z ;
  void *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  struct tm tmp___5 ;
  struct tm *tmp___6 ;
  parser_control pc ;
  char *tmp___7 ;
  int tmp___8 ;
  int quarter ;
  intmax_t iprobe ;
  int tmp___9 ;
  _Bool tmp___10 ;
  time_t probe ;
  struct tm probe_tm ;
  struct tm *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  _Bool tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char const   *mrd ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  char const   *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  _Bool repaired ;
  _Bool time_zone_seen ;
  char tz2buf[(sizeof("XXX") - 1UL) + 27UL] ;
  timezone_t tz2 ;
  timezone_t tmp___37 ;
  char *tmp___38 ;
  _Bool tmp___39 ;
  char dbg_ord[100] ;
  intmax_t dayincr ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___100 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___133 ;
  int tmp___134 ;
  int tmp___145 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  int tmp___211 ;
  int tmp___212 ;
  int tmp___213 ;
  int tmp___215 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___230 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___260 ;
  int tmp___265 ;
  int tmp___266 ;
  int tmp___267 ;
  int tmp___268 ;
  int tmp___269 ;
  int tmp___270 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___331 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___376 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___385 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___446 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___460 ;
  int tmp___461 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___491 ;
  int tmp___496 ;
  int tmp___497 ;
  int tmp___498 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___558 ;
  int tmp___559 ;
  int tmp___560 ;
  int tmp___562 ;
  int tmp___573 ;
  int tmp___574 ;
  int tmp___575 ;
  int tmp___576 ;
  int tmp___577 ;
  int tmp___595 ;
  int tmp___596 ;
  int tmp___607 ;
  int tmp___612 ;
  int tmp___613 ;
  int tmp___614 ;
  int tmp___615 ;
  int tmp___616 ;
  int tmp___673 ;
  int tmp___674 ;
  int tmp___675 ;
  unsigned int tmp___679 ;
  int tmp___680 ;
  int tmp___681 ;
  int tmp___688 ;
  int tmp___689 ;
  int tmp___690 ;
  int tmp___691 ;
  int tmp___692 ;
  int tmp___710 ;
  int tmp___711 ;
  int tmp___722 ;
  int tmp___727 ;
  int tmp___728 ;
  int tmp___729 ;
  int tmp___730 ;
  int tmp___731 ;
  int tmp___732 ;
  int tmp___789 ;
  int tmp___790 ;
  int tmp___791 ;
  int tmp___793 ;
  int tmp___804 ;
  int tmp___805 ;
  int tmp___806 ;
  int tmp___807 ;
  int tmp___808 ;
  int tmp___826 ;
  int tmp___827 ;
  int tmp___838 ;
  int tmp___843 ;
  int tmp___844 ;
  int tmp___845 ;
  int tmp___846 ;
  int tmp___847 ;
  int tmp___904 ;
  int tmp___905 ;
  int tmp___906 ;
  unsigned long tmp___910 ;
  int tmp___911 ;
  int tmp___912 ;
  int tmp___919 ;
  int tmp___920 ;
  int tmp___921 ;
  int tmp___922 ;
  int tmp___923 ;
  int tmp___941 ;
  int tmp___942 ;
  int tmp___953 ;
  int tmp___958 ;
  int tmp___959 ;
  int tmp___960 ;
  int tmp___961 ;
  int tmp___962 ;
  int tmp___963 ;
  int tmp___1020 ;
  int tmp___1021 ;
  int tmp___1022 ;
  int tmp___1024 ;
  int tmp___1035 ;
  int tmp___1036 ;
  int tmp___1037 ;
  int tmp___1038 ;
  int tmp___1039 ;
  int tmp___1057 ;
  int tmp___1058 ;
  int tmp___1069 ;
  int tmp___1074 ;
  int tmp___1075 ;
  int tmp___1076 ;
  int tmp___1077 ;
  int tmp___1078 ;
  int tmp___1135 ;
  int tmp___1136 ;
  int tmp___1137 ;
  unsigned long long tmp___1141 ;
  int tmp___1142 ;
  int tmp___1143 ;
  int tmp___1150 ;
  int tmp___1151 ;
  int tmp___1152 ;
  int tmp___1153 ;
  int tmp___1154 ;
  int tmp___1172 ;
  int tmp___1173 ;
  int tmp___1184 ;
  int tmp___1189 ;
  int tmp___1190 ;
  int tmp___1191 ;
  int tmp___1192 ;
  int tmp___1193 ;
  int tmp___1194 ;
  int tmp___1195 ;
  int tmp___1196 ;
  int tmp___1197 ;
  int tmp___1198 ;
  int tmp___1199 ;
  int tmp___1200 ;
  char const   *tmp___1201 ;
  char const   *tmp___1202 ;
  char *tmp___1203 ;
  char const   *tmp___1204 ;
  char const   *tmp___1205 ;
  char *tmp___1206 ;
  char const   *tmp___1207 ;
  char *tmp___1208 ;
  char const   *tmp___1209 ;
  char *tmp___1210 ;
  char const   *tmp___1211 ;
  char *tmp___1212 ;
  char *tmp___1213 ;
  char *tmp___1214 ;
  int year ;
  int month ;
  int day ;
  char *tmp___1215 ;
  int tmp___1216 ;
  int tmp___1217 ;
  int tmp___1218 ;
  char const   *tmp___1219 ;
  char *tmp___1220 ;
  char *tmp___1221 ;
  char const   *tmp___1222 ;
  char *tmp___1223 ;
  char *tmp___1224 ;
  char *tmp___1225 ;
  char tm_year_buf[13] ;
  char const   *tmp___1226 ;
  char *tmp___1227 ;
  char const   *tmp___1228 ;
  char *tmp___1229 ;
  intmax_t delta ;
  intmax_t t1 ;
  _Bool overflow ;
  long utcoff ;
  int tmp___1230 ;
  int tmp___1231 ;
  char *tmp___1232 ;
  _Bool tmp___1233 ;
  intmax_t Starti ;
  char const   *tmp___1234 ;
  char *tmp___1235 ;
  intmax_t orig_ns ;
  intmax_t sum_ns ;
  int normalized_ns ;
  int d4 ;
  intmax_t d1 ;
  intmax_t t1___0 ;
  intmax_t d2 ;
  intmax_t t2 ;
  intmax_t t3 ;
  intmax_t t4 ;
  char *tmp___1236 ;
  int tmp___1249 ;
  int tmp___1259 ;
  int tmp___1260 ;
  int tmp___1261 ;
  int tmp___1299 ;
  int tmp___1309 ;
  int tmp___1310 ;
  int tmp___1311 ;
  int tmp___1349 ;
  int tmp___1359 ;
  int tmp___1360 ;
  int tmp___1361 ;
  int tmp___1399 ;
  int tmp___1409 ;
  int tmp___1410 ;
  int tmp___1411 ;
  int tmp___1449 ;
  int tmp___1459 ;
  int tmp___1460 ;
  int tmp___1461 ;
  int tmp___1487 ;
  int tmp___1488 ;
  int tmp___1489 ;
  int tmp___1490 ;
  int tmp___1491 ;
  int tmp___1504 ;
  int tmp___1514 ;
  int tmp___1515 ;
  int tmp___1516 ;
  int tmp___1554 ;
  int tmp___1564 ;
  int tmp___1565 ;
  int tmp___1566 ;
  int tmp___1604 ;
  int tmp___1614 ;
  int tmp___1615 ;
  int tmp___1616 ;
  int tmp___1654 ;
  int tmp___1664 ;
  int tmp___1665 ;
  int tmp___1666 ;
  int tmp___1704 ;
  int tmp___1714 ;
  int tmp___1715 ;
  int tmp___1716 ;
  int tmp___1742 ;
  int tmp___1743 ;
  int tmp___1744 ;
  int tmp___1745 ;
  int tmp___1746 ;
  int tmp___1747 ;
  int tmp___1748 ;
  _Bool tmp___1749 ;
  char *tmp___1750 ;
  char *tmp___1751 ;
  struct tm lmt ;
  char *tmp___1752 ;
  struct tm *tmp___1753 ;
  char *tmp___1754 ;
  char *tmp___1755 ;
  char *tmp___1756 ;
  int tmp___1757 ;
  intmax_t sec ;
  int nsec ;
  char *tmp___1758 ;
  struct tm gmt ;
  struct tm lmt___0 ;
  _Bool got_utc ;
  struct tm *tmp___1759 ;
  int tmp___1760 ;
  char const   *tmp___1761 ;
  char *tmp___1762 ;
  _Bool got_utcoff ;
  long utcoff___0 ;
  char const   *tmp___1763 ;
  char const   *tmp___1764 ;
  char *tmp___1765 ;
  char const   *tmp___1766 ;
  char *tmp___1767 ;
  struct tm *tmp___1768 ;

  {
  {
#line 1740
  ok = (_Bool)0;
#line 1741
  tmp = strlen(p);
#line 1741
  input_sentinel = p + tmp;
#line 1742
  tz1alloc = (char *)((void *)0);
  }
#line 1750
  if (! now) {
    {
#line 1752
    gettime(& gettime_buffer);
#line 1753
    now = (struct timespec  const  *)(& gettime_buffer);
    }
  }
#line 1756
  Start = (time_t )now->tv_sec;
#line 1757
  Start_ns = (int )now->tv_nsec;
  {
#line 1760
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1760
    c = (unsigned char )*p;
#line 1760
    tmp___0 = c_isspace((int )c);
    }
#line 1760
    if (! tmp___0) {
#line 1760
      goto while_break;
    }
#line 1761
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1763
  tz = tzdefault;
#line 1768
  rel_time_0.year = (intmax_t )0;
#line 1768
  rel_time_0.month = (intmax_t )0;
#line 1768
  rel_time_0.day = (intmax_t )0;
#line 1768
  rel_time_0.hour = (intmax_t )0;
#line 1768
  rel_time_0.minutes = (intmax_t )0;
#line 1768
  rel_time_0.seconds = (intmax_t )0;
#line 1768
  rel_time_0.ns = 0;
#line 1770
  tmp___4 = strncmp(p, "TZ=\"", (size_t )4);
  }
#line 1770
  if (tmp___4 == 0) {
#line 1772
    tzbase = p + 4;
#line 1773
    tzsize = (ptrdiff_t )1;
#line 1776
    s = tzbase;
    {
#line 1776
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1776
      if (! *s) {
#line 1776
        goto while_break___0;
      }
#line 1777
      if ((int const   )*s == 92) {
#line 1779
        s ++;
#line 1780
        if (! ((int const   )*s == 92)) {
#line 1780
          if (! ((int const   )*s == 34)) {
#line 1781
            goto while_break___0;
          }
        }
      } else
#line 1783
      if ((int const   )*s == 34) {
#line 1786
        tz1string = tz1buf;
#line 1788
        if (100L < tzsize) {
          {
#line 1790
          tmp___1 = malloc((size_t )tzsize);
#line 1790
          tz1alloc = (char *)tmp___1;
          }
#line 1791
          if (! tz1alloc) {
#line 1792
            goto fail;
          }
#line 1793
          tz1string = tz1alloc;
        }
#line 1795
        z = tz1string;
#line 1796
        s = tzbase;
        {
#line 1796
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1796
          if (! ((int const   )*s != 34)) {
#line 1796
            goto while_break___1;
          }
#line 1797
          tmp___2 = z;
#line 1797
          z ++;
#line 1797
          s += (int const   )*s == 92;
#line 1797
          *tmp___2 = (char )*s;
#line 1796
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1798
        *z = (char )'\000';
#line 1799
        tz1 = tzalloc((char const   *)tz1string);
        }
#line 1800
        if (! tz1) {
#line 1801
          goto fail;
        }
#line 1802
        tz = tz1;
#line 1803
        tzstring = (char const   *)tz1string;
#line 1805
        p = s + 1;
        {
#line 1806
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1806
          c = (unsigned char )*p;
#line 1806
          tmp___3 = c_isspace((int )c);
          }
#line 1806
          if (! tmp___3) {
#line 1806
            goto while_break___2;
          }
#line 1807
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1809
        goto while_break___0;
      }
#line 1776
      s ++;
#line 1776
      tzsize ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1814
  tmp___6 = localtime_rz(tz, (time_t const   */* __restrict  */)(& now->tv_sec), (struct tm */* __restrict  */)(& tmp___5));
  }
#line 1814
  if (! tmp___6) {
#line 1815
    goto fail;
  }
#line 1820
  if ((int const   )*p == 0) {
#line 1821
    p = "0";
  }
  {
#line 1824
  pc.input = p;
#line 1825
  pc.parse_datetime_debug = (_Bool )((flags & 1U) != 0U);
#line 1826
  tmp___8 = __builtin_add_overflow(tmp___5.tm_year, 1900, & pc.year.value);
  }
#line 1826
  if (tmp___8) {
#line 1828
    if (pc.parse_datetime_debug) {
      {
#line 1829
      tmp___7 = dcgettext((char const   *)((void *)0), "error: initial year out of range\n",
                          5);
#line 1829
      dbg_printf((char const   *)tmp___7);
      }
    }
#line 1830
    goto fail;
  }
#line 1832
  pc.year.digits = (ptrdiff_t )0;
#line 1833
  pc.month = (intmax_t )(tmp___5.tm_mon + 1);
#line 1834
  pc.day = (intmax_t )tmp___5.tm_mday;
#line 1835
  pc.hour = (intmax_t )tmp___5.tm_hour;
#line 1836
  pc.minutes = (intmax_t )tmp___5.tm_min;
#line 1837
  pc.seconds.tv_sec = (__time_t )tmp___5.tm_sec;
#line 1838
  pc.seconds.tv_nsec = (__syscall_slong_t )Start_ns;
#line 1839
  tm.tm_isdst = tmp___5.tm_isdst;
#line 1841
  pc.meridian = 2;
#line 1842
  pc.rel = rel_time_0;
#line 1843
  pc.timespec_seen = (_Bool)0;
#line 1844
  pc.rels_seen = (_Bool)0;
#line 1845
  pc.dates_seen = (ptrdiff_t )0;
#line 1846
  pc.days_seen = (ptrdiff_t )0;
#line 1847
  pc.times_seen = (ptrdiff_t )0;
#line 1848
  pc.local_zones_seen = (ptrdiff_t )0;
#line 1849
  pc.dsts_seen = (ptrdiff_t )0;
#line 1850
  pc.zones_seen = (ptrdiff_t )0;
#line 1851
  pc.year_seen = (_Bool)0;
#line 1852
  pc.debug_dates_seen = (_Bool)0;
#line 1853
  pc.debug_days_seen = (_Bool)0;
#line 1854
  pc.debug_times_seen = (_Bool)0;
#line 1855
  pc.debug_local_zones_seen = (_Bool)0;
#line 1856
  pc.debug_zones_seen = (_Bool)0;
#line 1857
  pc.debug_year_seen = (_Bool)0;
#line 1858
  pc.debug_ordinal_day_seen = (_Bool)0;
#line 1861
  pc.local_time_zone_table[0].name = tmp___5.tm_zone;
#line 1862
  pc.local_time_zone_table[0].type = 269;
#line 1863
  pc.local_time_zone_table[0].value = tmp___5.tm_isdst;
#line 1864
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1870
  quarter = 1;
  {
#line 1870
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1870
    if (! (quarter <= 3)) {
#line 1870
      goto while_break___3;
    }
    {
#line 1873
    tmp___9 = __builtin_add_overflow(Start, quarter * 7776000, & iprobe);
    }
#line 1873
    if (tmp___9) {
#line 1875
      goto while_break___3;
    } else {
      {
#line 1873
      tmp___10 = time_overflow(iprobe);
      }
#line 1873
      if (tmp___10) {
#line 1875
        goto while_break___3;
      }
    }
    {
#line 1876
    probe = iprobe;
#line 1878
    tmp___11 = localtime_rz(tz, (time_t const   */* __restrict  */)(& probe), (struct tm */* __restrict  */)(& probe_tm));
    }
#line 1878
    if (tmp___11) {
#line 1878
      if (probe_tm.tm_zone) {
#line 1878
        if (probe_tm.tm_isdst != pc.local_time_zone_table[0].value) {
#line 1882
          pc.local_time_zone_table[1].name = probe_tm.tm_zone;
#line 1883
          pc.local_time_zone_table[1].type = 269;
#line 1884
          pc.local_time_zone_table[1].value = probe_tm.tm_isdst;
#line 1885
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1887
          goto while_break___3;
        }
      }
    }
#line 1870
    quarter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1911
  if (pc.local_time_zone_table[0].name) {
#line 1911
    if (pc.local_time_zone_table[1].name) {
      {
#line 1911
      tmp___12 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
      }
#line 1911
      if (! tmp___12) {
#line 1918
        pc.local_time_zone_table[0].value = -1;
#line 1919
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
  {
#line 1922
  tmp___16 = yyparse(& pc);
  }
#line 1922
  if (tmp___16 != 0) {
#line 1924
    if (pc.parse_datetime_debug) {
#line 1925
      if ((unsigned long )input_sentinel <= (unsigned long )pc.input) {
        {
#line 1925
        tmp___13 = dcgettext((char const   *)((void *)0), "error: parsing failed\n",
                             5);
#line 1925
        tmp___15 = tmp___13;
        }
      } else {
        {
#line 1925
        tmp___14 = dcgettext((char const   *)((void *)0), "error: parsing failed, stopped at \'%s\'\n",
                             5);
#line 1925
        tmp___15 = tmp___14;
        }
      }
      {
#line 1925
      dbg_printf((char const   *)tmp___15, pc.input);
      }
    }
#line 1929
    goto fail;
  }
#line 1935
  if (pc.parse_datetime_debug) {
    {
#line 1937
    tmp___17 = dcgettext((char const   *)((void *)0), "input timezone: ", 5);
#line 1937
    dbg_printf((char const   *)tmp___17);
    }
#line 1939
    if (pc.timespec_seen) {
      {
#line 1940
      tmp___18 = dcgettext((char const   *)((void *)0), "\'@timespec\' - always UTC",
                           5);
#line 1940
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___18);
      }
    } else
#line 1941
    if (pc.zones_seen) {
      {
#line 1942
      tmp___19 = dcgettext((char const   *)((void *)0), "parsed date/time string",
                           5);
#line 1942
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___19);
      }
    } else
#line 1943
    if (tzstring) {
#line 1945
      if ((unsigned long )tz != (unsigned long )tzdefault) {
        {
#line 1946
        tmp___20 = dcgettext((char const   *)((void *)0), "TZ=\"%s\" in date string",
                             5);
#line 1946
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___20,
                tzstring);
        }
      } else {
        {
#line 1947
        tmp___23 = strcmp(tzstring, "UTC0");
        }
#line 1947
        if (tmp___23 == 0) {
          {
#line 1950
          tmp___21 = dcgettext((char const   *)((void *)0), "TZ=\"UTC0\" environment value or -u",
                               5);
#line 1950
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___21);
          }
        } else {
          {
#line 1953
          tmp___22 = dcgettext((char const   *)((void *)0), "TZ=\"%s\" environment value",
                               5);
#line 1953
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
                  tzstring);
          }
        }
      }
    } else {
      {
#line 1956
      tmp___24 = dcgettext((char const   *)((void *)0), "system default", 5);
#line 1956
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___24);
      }
    }
#line 1961
    if (pc.local_zones_seen) {
#line 1961
      if (! pc.zones_seen) {
#line 1961
        if (0 < pc.local_isdst) {
          {
#line 1962
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", dst");
          }
        }
      }
    }
#line 1964
    if (pc.zones_seen) {
      {
#line 1965
      tmp___25 = time_zone_str(pc.time_zone, (char *)(time_zone_buf));
#line 1965
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%s)",
              tmp___25);
      }
    }
    {
#line 1967
    fputc('\n', stderr);
    }
  }
#line 1970
  if (pc.timespec_seen) {
#line 1971
    *result = pc.seconds;
  } else {
#line 1974
    if (1L < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1977
      if (pc.parse_datetime_debug) {
#line 1979
        if (pc.times_seen > 1L) {
          {
#line 1980
          dbg_printf("error: seen multiple time parts\n");
          }
        }
#line 1981
        if (pc.dates_seen > 1L) {
          {
#line 1982
          dbg_printf("error: seen multiple date parts\n");
          }
        }
#line 1983
        if (pc.days_seen > 1L) {
          {
#line 1984
          dbg_printf("error: seen multiple days parts\n");
          }
        }
#line 1985
        if (pc.dsts_seen > 1L) {
          {
#line 1986
          dbg_printf("error: seen multiple daylight-saving parts\n");
          }
        }
#line 1987
        if (pc.local_zones_seen + pc.zones_seen > 1L) {
          {
#line 1988
          dbg_printf("error: seen multiple time-zone parts\n");
          }
        }
      }
#line 1990
      goto fail;
    }
    {
#line 1993
    tmp___27 = to_tm_year(pc.year, pc.parse_datetime_debug, & tm.tm_year);
    }
#line 1993
    if (tmp___27) {
      {
#line 1993
      tmp___28 = __builtin_add_overflow(pc.month, -1, & tm.tm_mon);
      }
#line 1993
      if (tmp___28) {
#line 1993
        goto _L;
      } else {
        {
#line 1993
        tmp___29 = __builtin_add_overflow(pc.day, 0, & tm.tm_mday);
        }
#line 1993
        if (tmp___29) {
          _L: /* CIL Label */ 
#line 1997
          if (pc.parse_datetime_debug) {
            {
#line 1998
            tmp___26 = dcgettext((char const   *)((void *)0), "error: year, month, or day overflow\n",
                                 5);
#line 1998
            dbg_printf((char const   *)tmp___26);
            }
          }
#line 1999
          goto fail;
        }
      }
    } else {
#line 1993
      goto _L;
    }
#line 2001
    if (pc.times_seen) {
#line 2001
      goto _L___0;
    } else
#line 2001
    if (pc.rels_seen) {
#line 2001
      if (! pc.dates_seen) {
#line 2001
        if (! pc.days_seen) {
          _L___0: /* CIL Label */ 
          {
#line 2003
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
          }
#line 2004
          if (tm.tm_hour < 0) {
#line 2006
            if (pc.meridian == 0) {
#line 2006
              tmp___31 = "am";
            } else {
#line 2006
              if (pc.meridian == 1) {
#line 2006
                tmp___30 = "pm";
              } else {
#line 2006
                tmp___30 = "";
              }
#line 2006
              tmp___31 = tmp___30;
            }
#line 2006
            mrd = tmp___31;
#line 2008
            if (pc.parse_datetime_debug) {
              {
#line 2009
              tmp___32 = dcgettext((char const   *)((void *)0), "error: invalid hour %ld%s\n",
                                   5);
#line 2009
              dbg_printf((char const   *)tmp___32, pc.hour, mrd);
              }
            }
#line 2011
            goto fail;
          }
#line 2013
          tm.tm_min = (int )pc.minutes;
#line 2014
          tm.tm_sec = (int )pc.seconds.tv_sec;
#line 2015
          if (pc.parse_datetime_debug) {
            {
#line 2016
            tmp___33 = debug_strftime((struct tm  const  *)(& tm), dbg_tm, (int )sizeof(dbg_tm));
            }
#line 2016
            if (pc.times_seen) {
              {
#line 2016
              tmp___34 = dcgettext((char const   *)((void *)0), "using specified time as starting value: \'%s\'\n",
                                   5);
#line 2016
              tmp___36 = tmp___34;
              }
            } else {
              {
#line 2016
              tmp___35 = dcgettext((char const   *)((void *)0), "using current time as starting value: \'%s\'\n",
                                   5);
#line 2016
              tmp___36 = tmp___35;
              }
            }
            {
#line 2016
            dbg_printf((char const   *)tmp___36, tmp___33);
            }
          }
        } else {
#line 2001
          goto _L___2;
        }
      } else {
#line 2001
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 2023
      tm.tm_sec = 0;
#line 2023
      tm.tm_min = tm.tm_sec;
#line 2023
      tm.tm_hour = tm.tm_min;
#line 2024
      pc.seconds.tv_nsec = (__syscall_slong_t )0;
#line 2025
      if (pc.parse_datetime_debug) {
        {
#line 2026
        dbg_printf("warning: using midnight as starting time: 00:00:00\n");
        }
      }
    }
#line 2030
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 2031
      tm.tm_isdst = -1;
    }
#line 2035
    if (pc.local_zones_seen) {
#line 2036
      tm.tm_isdst = pc.local_isdst;
    }
    {
#line 2038
    tm0.tm_sec = tm.tm_sec;
#line 2039
    tm0.tm_min = tm.tm_min;
#line 2040
    tm0.tm_hour = tm.tm_hour;
#line 2041
    tm0.tm_mday = tm.tm_mday;
#line 2042
    tm0.tm_mon = tm.tm_mon;
#line 2043
    tm0.tm_year = tm.tm_year;
#line 2044
    tm0.tm_isdst = tm.tm_isdst;
#line 2045
    tm.tm_wday = -1;
#line 2047
    Start = mktime_z(tz, (struct tm */* __restrict  */)(& tm));
#line 2049
    tmp___39 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm));
    }
#line 2049
    if (! tmp___39) {
#line 2051
      repaired = (_Bool)0;
#line 2052
      time_zone_seen = (_Bool )(pc.zones_seen != 0L);
#line 2053
      if (time_zone_seen) {
        {
#line 2066
        tz2buf[2] = (char )'X';
#line 2066
        tz2buf[1] = tz2buf[2];
#line 2066
        tz2buf[0] = tz2buf[1];
#line 2067
        time_zone_str(pc.time_zone, (char *)(& tz2buf[3]));
#line 2068
        tmp___37 = tzalloc((char const   *)(tz2buf));
#line 2068
        tz2 = tmp___37;
        }
#line 2069
        if (! tz2) {
#line 2071
          if (pc.parse_datetime_debug) {
            {
#line 2072
            tmp___38 = dcgettext((char const   *)((void *)0), "error: tzalloc (\"%s\") failed\n",
                                 5);
#line 2072
            dbg_printf((char const   *)tmp___38, tz2buf);
            }
          }
#line 2073
          goto fail;
        }
        {
#line 2075
        tm.tm_sec = tm0.tm_sec;
#line 2076
        tm.tm_min = tm0.tm_min;
#line 2077
        tm.tm_hour = tm0.tm_hour;
#line 2078
        tm.tm_mday = tm0.tm_mday;
#line 2079
        tm.tm_mon = tm0.tm_mon;
#line 2080
        tm.tm_year = tm0.tm_year;
#line 2081
        tm.tm_isdst = tm0.tm_isdst;
#line 2082
        tm.tm_wday = -1;
#line 2083
        Start = mktime_z(tz2, (struct tm */* __restrict  */)(& tm));
#line 2084
        repaired = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm));
#line 2085
        tzfree(tz2);
        }
      }
#line 2088
      if (! repaired) {
        {
#line 2090
        debug_mktime_not_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                            (parser_control const   *)(& pc), time_zone_seen);
        }
#line 2091
        goto fail;
      }
    }
#line 2097
    if (pc.days_seen) {
#line 2097
      if (! pc.dates_seen) {
#line 2100
        if (sizeof(dayincr) == sizeof(signed char )) {
#line 2100
          if (1) {
#line 2100
            if (0) {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___115 = 1;
                } else {
#line 2100
                  tmp___115 = 0;
                }
              } else {
#line 2100
                tmp___115 = 0;
              }
#line 2100
              if (pc.day_ordinal - (intmax_t )tmp___115 < 0L) {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___100 = 1;
                  } else {
#line 2100
                    tmp___100 = 0;
                  }
                } else {
#line 2100
                  tmp___100 = 0;
                }
#line 2100
                tmp___114 = pc.day_ordinal - (intmax_t )tmp___100 < 18L;
              } else {
#line 2100
                if (~ (((1 << (sizeof(-128) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                  tmp___113 = -128 < - (((1 << (sizeof(-128) * 8UL - 2UL)) - 1) * 2 + 1);
                } else {
#line 2100
                  tmp___113 = 0;
                }
#line 2100
                if (tmp___113) {
#line 2100
                  goto _L___5;
                } else {
                  _L___5: /* CIL Label */ 
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___111 = 1;
                    } else {
#line 2100
                      tmp___111 = 0;
                    }
                  } else {
#line 2100
                    tmp___111 = 0;
                  }
#line 2100
                  tmp___112 = -18L < pc.day_ordinal - (intmax_t )tmp___111;
                }
#line 2100
                tmp___114 = tmp___112;
              }
#line 2100
              tmp___154 = tmp___114;
            } else {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___153 = 1;
                } else {
#line 2100
                  tmp___153 = 0;
                }
              } else {
#line 2100
                tmp___153 = 0;
              }
#line 2100
              if (pc.day_ordinal - (intmax_t )tmp___153 < 0L) {
#line 2100
                if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                  tmp___145 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
                } else {
#line 2100
                  tmp___145 = 0;
                }
#line 2100
                if (tmp___145) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___150 = 1;
                    } else {
#line 2100
                      tmp___150 = 0;
                    }
                  } else {
#line 2100
                    tmp___150 = 0;
                  }
#line 2100
                  if (pc.day_ordinal - (intmax_t )tmp___150 == -1L) {
#line 2100
                    tmp___134 = 0;
                  } else {
#line 2100
                    goto _L___6;
                  }
                } else {
                  _L___6: /* CIL Label */ 
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___133 = 1;
                    } else {
#line 2100
                      tmp___133 = 0;
                    }
                  } else {
#line 2100
                    tmp___133 = 0;
                  }
#line 2100
                  tmp___134 = -128L / (pc.day_ordinal - (intmax_t )tmp___133) < 7L;
                }
#line 2100
                tmp___152 = tmp___134;
              } else {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___151 = 1;
                  } else {
#line 2100
                    tmp___151 = 0;
                  }
                } else {
#line 2100
                  tmp___151 = 0;
                }
#line 2100
                tmp___152 = 18L < pc.day_ordinal - (intmax_t )tmp___151;
              }
#line 2100
              tmp___154 = tmp___152;
            }
#line 2100
            if (tmp___154) {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___96 = 1;
                } else {
#line 2100
                  tmp___96 = 0;
                }
              } else {
#line 2100
                tmp___96 = 0;
              }
#line 2100
              dayincr = (intmax_t )((signed char )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___96) * 7U));
#line 2100
              tmp___98 = 1;
            } else {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___97 = 1;
                } else {
#line 2100
                  tmp___97 = 0;
                }
              } else {
#line 2100
                tmp___97 = 0;
              }
#line 2100
              dayincr = (intmax_t )((signed char )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___97) * 7U));
#line 2100
              tmp___98 = 0;
            }
#line 2100
            tmp___270 = tmp___98;
          } else {
#line 2100
            if (0) {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___230 = 1;
                } else {
#line 2100
                  tmp___230 = 0;
                }
              } else {
#line 2100
                tmp___230 = 0;
              }
#line 2100
              if (pc.day_ordinal - (intmax_t )tmp___230 < 0L) {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___215 = 1;
                  } else {
#line 2100
                    tmp___215 = 0;
                  }
                } else {
#line 2100
                  tmp___215 = 0;
                }
#line 2100
                tmp___229 = pc.day_ordinal - (intmax_t )tmp___215 < 36L;
              } else {
#line 2100
                if (~ (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                  tmp___228 = 0 < - (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1);
                } else {
#line 2100
                  tmp___228 = 0;
                }
#line 2100
                if (tmp___228) {
#line 2100
                  goto _L___9;
                } else {
                  _L___9: /* CIL Label */ 
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___226 = 1;
                    } else {
#line 2100
                      tmp___226 = 0;
                    }
                  } else {
#line 2100
                    tmp___226 = 0;
                  }
#line 2100
                  tmp___227 = 0L < pc.day_ordinal - (intmax_t )tmp___226;
                }
#line 2100
                tmp___229 = tmp___227;
              }
#line 2100
              tmp___269 = tmp___229;
            } else {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___268 = 1;
                } else {
#line 2100
                  tmp___268 = 0;
                }
              } else {
#line 2100
                tmp___268 = 0;
              }
#line 2100
              if (pc.day_ordinal - (intmax_t )tmp___268 < 0L) {
#line 2100
                if (~ (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                  tmp___260 = 0L < - (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L);
                } else {
#line 2100
                  tmp___260 = 0;
                }
#line 2100
                if (tmp___260) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___265 = 1;
                    } else {
#line 2100
                      tmp___265 = 0;
                    }
                  } else {
#line 2100
                    tmp___265 = 0;
                  }
#line 2100
                  if (pc.day_ordinal - (intmax_t )tmp___265 == -1L) {
#line 2100
                    tmp___249 = 1;
                  } else {
#line 2100
                    goto _L___10;
                  }
                } else {
                  _L___10: /* CIL Label */ 
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___248 = 1;
                    } else {
#line 2100
                      tmp___248 = 0;
                    }
                  } else {
#line 2100
                    tmp___248 = 0;
                  }
#line 2100
                  tmp___249 = 0L / (pc.day_ordinal - (intmax_t )tmp___248) < 7L;
                }
#line 2100
                tmp___267 = tmp___249;
              } else {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___266 = 1;
                  } else {
#line 2100
                    tmp___266 = 0;
                  }
                } else {
#line 2100
                  tmp___266 = 0;
                }
#line 2100
                tmp___267 = 36L < pc.day_ordinal - (intmax_t )tmp___266;
              }
#line 2100
              tmp___269 = tmp___267;
            }
#line 2100
            if (tmp___269) {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___211 = 1;
                } else {
#line 2100
                  tmp___211 = 0;
                }
              } else {
#line 2100
                tmp___211 = 0;
              }
#line 2100
              dayincr = (intmax_t )((unsigned char )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___211) * 7U));
#line 2100
              tmp___213 = 1;
            } else {
#line 2100
              if (0L < pc.day_ordinal) {
#line 2100
                if (tm.tm_wday != pc.day_number) {
#line 2100
                  tmp___212 = 1;
                } else {
#line 2100
                  tmp___212 = 0;
                }
              } else {
#line 2100
                tmp___212 = 0;
              }
#line 2100
              dayincr = (intmax_t )((unsigned char )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___212) * 7U));
#line 2100
              tmp___213 = 0;
            }
#line 2100
            tmp___270 = tmp___213;
          }
#line 2100
          tmp___1198 = tmp___270;
        } else {
#line 2100
          if (sizeof(dayincr) == sizeof(short )) {
#line 2100
            if (1) {
#line 2100
              if (0) {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___346 = 1;
                  } else {
#line 2100
                    tmp___346 = 0;
                  }
                } else {
#line 2100
                  tmp___346 = 0;
                }
#line 2100
                if (pc.day_ordinal - (intmax_t )tmp___346 < 0L) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___331 = 1;
                    } else {
#line 2100
                      tmp___331 = 0;
                    }
                  } else {
#line 2100
                    tmp___331 = 0;
                  }
#line 2100
                  tmp___345 = pc.day_ordinal - (intmax_t )tmp___331 < 4681L;
                } else {
#line 2100
                  if (~ (((1 << (sizeof(-32768) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                    tmp___344 = -32768 < - (((1 << (sizeof(-32768) * 8UL - 2UL)) - 1) * 2 + 1);
                  } else {
#line 2100
                    tmp___344 = 0;
                  }
#line 2100
                  if (tmp___344) {
#line 2100
                    goto _L___13;
                  } else {
                    _L___13: /* CIL Label */ 
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___342 = 1;
                      } else {
#line 2100
                        tmp___342 = 0;
                      }
                    } else {
#line 2100
                      tmp___342 = 0;
                    }
#line 2100
                    tmp___343 = -4681L < pc.day_ordinal - (intmax_t )tmp___342;
                  }
#line 2100
                  tmp___345 = tmp___343;
                }
#line 2100
                tmp___385 = tmp___345;
              } else {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___384 = 1;
                  } else {
#line 2100
                    tmp___384 = 0;
                  }
                } else {
#line 2100
                  tmp___384 = 0;
                }
#line 2100
                if (pc.day_ordinal - (intmax_t )tmp___384 < 0L) {
#line 2100
                  if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                    tmp___376 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
                  } else {
#line 2100
                    tmp___376 = 0;
                  }
#line 2100
                  if (tmp___376) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___381 = 1;
                      } else {
#line 2100
                        tmp___381 = 0;
                      }
                    } else {
#line 2100
                      tmp___381 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___381 == -1L) {
#line 2100
                      tmp___365 = 0;
                    } else {
#line 2100
                      goto _L___14;
                    }
                  } else {
                    _L___14: /* CIL Label */ 
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___364 = 1;
                      } else {
#line 2100
                        tmp___364 = 0;
                      }
                    } else {
#line 2100
                      tmp___364 = 0;
                    }
#line 2100
                    tmp___365 = -32768L / (pc.day_ordinal - (intmax_t )tmp___364) < 7L;
                  }
#line 2100
                  tmp___383 = tmp___365;
                } else {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___382 = 1;
                    } else {
#line 2100
                      tmp___382 = 0;
                    }
                  } else {
#line 2100
                    tmp___382 = 0;
                  }
#line 2100
                  tmp___383 = 4681L < pc.day_ordinal - (intmax_t )tmp___382;
                }
#line 2100
                tmp___385 = tmp___383;
              }
#line 2100
              if (tmp___385) {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___327 = 1;
                  } else {
#line 2100
                    tmp___327 = 0;
                  }
                } else {
#line 2100
                  tmp___327 = 0;
                }
#line 2100
                dayincr = (intmax_t )((short )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___327) * 7U));
#line 2100
                tmp___329 = 1;
              } else {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___328 = 1;
                  } else {
#line 2100
                    tmp___328 = 0;
                  }
                } else {
#line 2100
                  tmp___328 = 0;
                }
#line 2100
                dayincr = (intmax_t )((short )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___328) * 7U));
#line 2100
                tmp___329 = 0;
              }
#line 2100
              tmp___501 = tmp___329;
            } else {
#line 2100
              if (0) {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___461 = 1;
                  } else {
#line 2100
                    tmp___461 = 0;
                  }
                } else {
#line 2100
                  tmp___461 = 0;
                }
#line 2100
                if (pc.day_ordinal - (intmax_t )tmp___461 < 0L) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___446 = 1;
                    } else {
#line 2100
                      tmp___446 = 0;
                    }
                  } else {
#line 2100
                    tmp___446 = 0;
                  }
#line 2100
                  tmp___460 = pc.day_ordinal - (intmax_t )tmp___446 < 9362L;
                } else {
#line 2100
                  if (~ (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                    tmp___459 = 0 < - (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1);
                  } else {
#line 2100
                    tmp___459 = 0;
                  }
#line 2100
                  if (tmp___459) {
#line 2100
                    goto _L___17;
                  } else {
                    _L___17: /* CIL Label */ 
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___457 = 1;
                      } else {
#line 2100
                        tmp___457 = 0;
                      }
                    } else {
#line 2100
                      tmp___457 = 0;
                    }
#line 2100
                    tmp___458 = 0L < pc.day_ordinal - (intmax_t )tmp___457;
                  }
#line 2100
                  tmp___460 = tmp___458;
                }
#line 2100
                tmp___500 = tmp___460;
              } else {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___499 = 1;
                  } else {
#line 2100
                    tmp___499 = 0;
                  }
                } else {
#line 2100
                  tmp___499 = 0;
                }
#line 2100
                if (pc.day_ordinal - (intmax_t )tmp___499 < 0L) {
#line 2100
                  if (~ (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                    tmp___491 = 0L < - (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L);
                  } else {
#line 2100
                    tmp___491 = 0;
                  }
#line 2100
                  if (tmp___491) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___496 = 1;
                      } else {
#line 2100
                        tmp___496 = 0;
                      }
                    } else {
#line 2100
                      tmp___496 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___496 == -1L) {
#line 2100
                      tmp___480 = 1;
                    } else {
#line 2100
                      goto _L___18;
                    }
                  } else {
                    _L___18: /* CIL Label */ 
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___479 = 1;
                      } else {
#line 2100
                        tmp___479 = 0;
                      }
                    } else {
#line 2100
                      tmp___479 = 0;
                    }
#line 2100
                    tmp___480 = 0L / (pc.day_ordinal - (intmax_t )tmp___479) < 7L;
                  }
#line 2100
                  tmp___498 = tmp___480;
                } else {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___497 = 1;
                    } else {
#line 2100
                      tmp___497 = 0;
                    }
                  } else {
#line 2100
                    tmp___497 = 0;
                  }
#line 2100
                  tmp___498 = 9362L < pc.day_ordinal - (intmax_t )tmp___497;
                }
#line 2100
                tmp___500 = tmp___498;
              }
#line 2100
              if (tmp___500) {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___442 = 1;
                  } else {
#line 2100
                    tmp___442 = 0;
                  }
                } else {
#line 2100
                  tmp___442 = 0;
                }
#line 2100
                dayincr = (intmax_t )((unsigned short )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___442) * 7U));
#line 2100
                tmp___444 = 1;
              } else {
#line 2100
                if (0L < pc.day_ordinal) {
#line 2100
                  if (tm.tm_wday != pc.day_number) {
#line 2100
                    tmp___443 = 1;
                  } else {
#line 2100
                    tmp___443 = 0;
                  }
                } else {
#line 2100
                  tmp___443 = 0;
                }
#line 2100
                dayincr = (intmax_t )((unsigned short )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___443) * 7U));
#line 2100
                tmp___444 = 0;
              }
#line 2100
              tmp___501 = tmp___444;
            }
#line 2100
            tmp___1197 = tmp___501;
          } else {
#line 2100
            if (sizeof(dayincr) == sizeof(int )) {
#line 2100
              if (1) {
#line 2100
                if (0) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___577 = 1;
                    } else {
#line 2100
                      tmp___577 = 0;
                    }
                  } else {
#line 2100
                    tmp___577 = 0;
                  }
#line 2100
                  if (pc.day_ordinal - (intmax_t )tmp___577 < 0L) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___562 = 1;
                      } else {
#line 2100
                        tmp___562 = 0;
                      }
                    } else {
#line 2100
                      tmp___562 = 0;
                    }
#line 2100
                    tmp___576 = pc.day_ordinal - (intmax_t )tmp___562 < 306783378L;
                  } else {
#line 2100
                    if (~ (((1 << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                      tmp___575 = (-0x7FFFFFFF-1) < - (((1 << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1) * 2 + 1);
                    } else {
#line 2100
                      tmp___575 = 0;
                    }
#line 2100
                    if (tmp___575) {
#line 2100
                      goto _L___21;
                    } else {
                      _L___21: /* CIL Label */ 
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___573 = 1;
                        } else {
#line 2100
                          tmp___573 = 0;
                        }
                      } else {
#line 2100
                        tmp___573 = 0;
                      }
#line 2100
                      tmp___574 = -306783378L < pc.day_ordinal - (intmax_t )tmp___573;
                    }
#line 2100
                    tmp___576 = tmp___574;
                  }
#line 2100
                  tmp___616 = tmp___576;
                } else {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___615 = 1;
                    } else {
#line 2100
                      tmp___615 = 0;
                    }
                  } else {
#line 2100
                    tmp___615 = 0;
                  }
#line 2100
                  if (pc.day_ordinal - (intmax_t )tmp___615 < 0L) {
#line 2100
                    if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                      tmp___607 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                    } else {
#line 2100
                      tmp___607 = 0;
                    }
#line 2100
                    if (tmp___607) {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___612 = 1;
                        } else {
#line 2100
                          tmp___612 = 0;
                        }
                      } else {
#line 2100
                        tmp___612 = 0;
                      }
#line 2100
                      if (pc.day_ordinal - (intmax_t )tmp___612 == -1L) {
#line 2100
                        tmp___596 = 0;
                      } else {
#line 2100
                        goto _L___22;
                      }
                    } else {
                      _L___22: /* CIL Label */ 
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___595 = 1;
                        } else {
#line 2100
                          tmp___595 = 0;
                        }
                      } else {
#line 2100
                        tmp___595 = 0;
                      }
#line 2100
                      tmp___596 = (-0x7FFFFFFF-1) / (pc.day_ordinal - (intmax_t )tmp___595) < 7L;
                    }
#line 2100
                    tmp___614 = tmp___596;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___613 = 1;
                      } else {
#line 2100
                        tmp___613 = 0;
                      }
                    } else {
#line 2100
                      tmp___613 = 0;
                    }
#line 2100
                    tmp___614 = 306783378L < pc.day_ordinal - (intmax_t )tmp___613;
                  }
#line 2100
                  tmp___616 = tmp___614;
                }
#line 2100
                if (tmp___616) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___558 = 1;
                    } else {
#line 2100
                      tmp___558 = 0;
                    }
                  } else {
#line 2100
                    tmp___558 = 0;
                  }
#line 2100
                  dayincr = (intmax_t )((int )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___558) * 7U));
#line 2100
                  tmp___560 = 1;
                } else {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___559 = 1;
                    } else {
#line 2100
                      tmp___559 = 0;
                    }
                  } else {
#line 2100
                    tmp___559 = 0;
                  }
#line 2100
                  dayincr = (intmax_t )((int )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___559) * 7U));
#line 2100
                  tmp___560 = 0;
                }
#line 2100
                tmp___732 = tmp___560;
              } else {
#line 2100
                if (0) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___692 = 1;
                    } else {
#line 2100
                      tmp___692 = 0;
                    }
                  } else {
#line 2100
                    tmp___692 = 0;
                  }
#line 2100
                  if (pc.day_ordinal - (intmax_t )tmp___692 < 0L) {
#line 2100
                    if (~ (((1 << (sizeof(7) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                      tmp___680 = 7 < - (((1 << (sizeof(7) * 8UL - 2UL)) - 1) * 2 + 1);
                    } else {
#line 2100
                      tmp___680 = 1;
                    }
#line 2100
                    if (tmp___680) {
#line 2100
                      tmp___679 = 4294967295U >> (sizeof(7) * 8UL - 1UL);
                    } else {
#line 2100
                      tmp___679 = 1U;
                    }
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___681 = 1;
                      } else {
#line 2100
                        tmp___681 = 0;
                      }
                    } else {
#line 2100
                      tmp___681 = 0;
                    }
#line 2100
                    tmp___691 = (intmax_t )tmp___679 <= -1L - (pc.day_ordinal - (intmax_t )tmp___681);
                  } else {
#line 2100
                    if (~ (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                      tmp___690 = 0 < - (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1);
                    } else {
#line 2100
                      tmp___690 = 0;
                    }
#line 2100
                    if (tmp___690) {
#line 2100
                      goto _L___25;
                    } else {
                      _L___25: /* CIL Label */ 
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___688 = 1;
                        } else {
#line 2100
                          tmp___688 = 0;
                        }
                      } else {
#line 2100
                        tmp___688 = 0;
                      }
#line 2100
                      tmp___689 = 0L < pc.day_ordinal - (intmax_t )tmp___688;
                    }
#line 2100
                    tmp___691 = tmp___689;
                  }
#line 2100
                  tmp___731 = tmp___691;
                } else {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___730 = 1;
                    } else {
#line 2100
                      tmp___730 = 0;
                    }
                  } else {
#line 2100
                    tmp___730 = 0;
                  }
#line 2100
                  if (pc.day_ordinal - (intmax_t )tmp___730 < 0L) {
#line 2100
                    if (~ (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                      tmp___722 = 0L < - (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L);
                    } else {
#line 2100
                      tmp___722 = 0;
                    }
#line 2100
                    if (tmp___722) {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___727 = 1;
                        } else {
#line 2100
                          tmp___727 = 0;
                        }
                      } else {
#line 2100
                        tmp___727 = 0;
                      }
#line 2100
                      if (pc.day_ordinal - (intmax_t )tmp___727 == -1L) {
#line 2100
                        tmp___711 = 1;
                      } else {
#line 2100
                        goto _L___26;
                      }
                    } else {
                      _L___26: /* CIL Label */ 
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___710 = 1;
                        } else {
#line 2100
                          tmp___710 = 0;
                        }
                      } else {
#line 2100
                        tmp___710 = 0;
                      }
#line 2100
                      tmp___711 = 0L / (pc.day_ordinal - (intmax_t )tmp___710) < 7L;
                    }
#line 2100
                    tmp___729 = tmp___711;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___728 = 1;
                      } else {
#line 2100
                        tmp___728 = 0;
                      }
                    } else {
#line 2100
                      tmp___728 = 0;
                    }
#line 2100
                    tmp___729 = 613566756L < pc.day_ordinal - (intmax_t )tmp___728;
                  }
#line 2100
                  tmp___731 = tmp___729;
                }
#line 2100
                if (tmp___731) {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___673 = 1;
                    } else {
#line 2100
                      tmp___673 = 0;
                    }
                  } else {
#line 2100
                    tmp___673 = 0;
                  }
#line 2100
                  dayincr = (intmax_t )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___673) * 7U);
#line 2100
                  tmp___675 = 1;
                } else {
#line 2100
                  if (0L < pc.day_ordinal) {
#line 2100
                    if (tm.tm_wday != pc.day_number) {
#line 2100
                      tmp___674 = 1;
                    } else {
#line 2100
                      tmp___674 = 0;
                    }
                  } else {
#line 2100
                    tmp___674 = 0;
                  }
#line 2100
                  dayincr = (intmax_t )((unsigned int )(pc.day_ordinal - (intmax_t )tmp___674) * 7U);
#line 2100
                  tmp___675 = 0;
                }
#line 2100
                tmp___732 = tmp___675;
              }
#line 2100
              tmp___1196 = tmp___732;
            } else {
#line 2100
              if (sizeof(dayincr) == sizeof(long )) {
#line 2100
                if (1) {
#line 2100
                  if (0) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___808 = 1;
                      } else {
#line 2100
                        tmp___808 = 0;
                      }
                    } else {
#line 2100
                      tmp___808 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___808 < 0L) {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___793 = 1;
                        } else {
#line 2100
                          tmp___793 = 0;
                        }
                      } else {
#line 2100
                        tmp___793 = 0;
                      }
#line 2100
                      tmp___807 = pc.day_ordinal - (intmax_t )tmp___793 < 1317624576693539401L;
                    } else {
#line 2100
                      if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                        tmp___806 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                      } else {
#line 2100
                        tmp___806 = 0;
                      }
#line 2100
                      if (tmp___806) {
#line 2100
                        goto _L___29;
                      } else {
                        _L___29: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___804 = 1;
                          } else {
#line 2100
                            tmp___804 = 0;
                          }
                        } else {
#line 2100
                          tmp___804 = 0;
                        }
#line 2100
                        tmp___805 = -1317624576693539401L < pc.day_ordinal - (intmax_t )tmp___804;
                      }
#line 2100
                      tmp___807 = tmp___805;
                    }
#line 2100
                    tmp___847 = tmp___807;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___846 = 1;
                      } else {
#line 2100
                        tmp___846 = 0;
                      }
                    } else {
#line 2100
                      tmp___846 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___846 < 0L) {
#line 2100
                      if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                        tmp___838 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                      } else {
#line 2100
                        tmp___838 = 0;
                      }
#line 2100
                      if (tmp___838) {
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___843 = 1;
                          } else {
#line 2100
                            tmp___843 = 0;
                          }
                        } else {
#line 2100
                          tmp___843 = 0;
                        }
#line 2100
                        if (pc.day_ordinal - (intmax_t )tmp___843 == -1L) {
#line 2100
                          tmp___827 = 0;
                        } else {
#line 2100
                          goto _L___30;
                        }
                      } else {
                        _L___30: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___826 = 1;
                          } else {
#line 2100
                            tmp___826 = 0;
                          }
                        } else {
#line 2100
                          tmp___826 = 0;
                        }
#line 2100
                        tmp___827 = (-0x7FFFFFFFFFFFFFFF-1) / (pc.day_ordinal - (intmax_t )tmp___826) < 7L;
                      }
#line 2100
                      tmp___845 = tmp___827;
                    } else {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___844 = 1;
                        } else {
#line 2100
                          tmp___844 = 0;
                        }
                      } else {
#line 2100
                        tmp___844 = 0;
                      }
#line 2100
                      tmp___845 = 1317624576693539401L < pc.day_ordinal - (intmax_t )tmp___844;
                    }
#line 2100
                    tmp___847 = tmp___845;
                  }
#line 2100
                  if (tmp___847) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___789 = 1;
                      } else {
#line 2100
                        tmp___789 = 0;
                      }
                    } else {
#line 2100
                      tmp___789 = 0;
                    }
#line 2100
                    dayincr = (long )((unsigned long )(pc.day_ordinal - (intmax_t )tmp___789) * 7UL);
#line 2100
                    tmp___791 = 1;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___790 = 1;
                      } else {
#line 2100
                        tmp___790 = 0;
                      }
                    } else {
#line 2100
                      tmp___790 = 0;
                    }
#line 2100
                    dayincr = (long )((unsigned long )(pc.day_ordinal - (intmax_t )tmp___790) * 7UL);
#line 2100
                    tmp___791 = 0;
                  }
#line 2100
                  tmp___963 = tmp___791;
                } else {
#line 2100
                  if (0) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___923 = 1;
                      } else {
#line 2100
                        tmp___923 = 0;
                      }
                    } else {
#line 2100
                      tmp___923 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___923 < 0L) {
#line 2100
                      if (~ (((1 << (sizeof(7) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                        tmp___911 = 7 < - (((1 << (sizeof(7) * 8UL - 2UL)) - 1) * 2 + 1);
                      } else {
#line 2100
                        tmp___911 = 1;
                      }
#line 2100
                      if (tmp___911) {
#line 2100
                        tmp___910 = 0xffffffffffffffffUL >> (sizeof(7) * 8UL - 1UL);
                      } else {
#line 2100
                        tmp___910 = 1UL;
                      }
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___912 = 1;
                        } else {
#line 2100
                          tmp___912 = 0;
                        }
                      } else {
#line 2100
                        tmp___912 = 0;
                      }
#line 2100
                      tmp___922 = tmp___910 <= (unsigned long )(-1L - (pc.day_ordinal - (intmax_t )tmp___912));
                    } else {
#line 2100
                      if (~ (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                        tmp___921 = 0 < - (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1);
                      } else {
#line 2100
                        tmp___921 = 0;
                      }
#line 2100
                      if (tmp___921) {
#line 2100
                        goto _L___33;
                      } else {
                        _L___33: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___919 = 1;
                          } else {
#line 2100
                            tmp___919 = 0;
                          }
                        } else {
#line 2100
                          tmp___919 = 0;
                        }
#line 2100
                        tmp___920 = 0L < pc.day_ordinal - (intmax_t )tmp___919;
                      }
#line 2100
                      tmp___922 = tmp___920;
                    }
#line 2100
                    tmp___962 = tmp___922;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___961 = 1;
                      } else {
#line 2100
                        tmp___961 = 0;
                      }
                    } else {
#line 2100
                      tmp___961 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___961 < 0L) {
#line 2100
                      if (~ (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                        tmp___953 = 0L < - (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L);
                      } else {
#line 2100
                        tmp___953 = 0;
                      }
#line 2100
                      if (tmp___953) {
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___958 = 1;
                          } else {
#line 2100
                            tmp___958 = 0;
                          }
                        } else {
#line 2100
                          tmp___958 = 0;
                        }
#line 2100
                        if (pc.day_ordinal - (intmax_t )tmp___958 == -1L) {
#line 2100
                          tmp___942 = 1;
                        } else {
#line 2100
                          goto _L___34;
                        }
                      } else {
                        _L___34: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___941 = 1;
                          } else {
#line 2100
                            tmp___941 = 0;
                          }
                        } else {
#line 2100
                          tmp___941 = 0;
                        }
#line 2100
                        tmp___942 = 0L / (pc.day_ordinal - (intmax_t )tmp___941) < 7L;
                      }
#line 2100
                      tmp___960 = tmp___942;
                    } else {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___959 = 1;
                        } else {
#line 2100
                          tmp___959 = 0;
                        }
                      } else {
#line 2100
                        tmp___959 = 0;
                      }
#line 2100
                      tmp___960 = 2635249153387078802UL < (unsigned long )(pc.day_ordinal - (intmax_t )tmp___959);
                    }
#line 2100
                    tmp___962 = tmp___960;
                  }
#line 2100
                  if (tmp___962) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___904 = 1;
                      } else {
#line 2100
                        tmp___904 = 0;
                      }
                    } else {
#line 2100
                      tmp___904 = 0;
                    }
#line 2100
                    dayincr = (intmax_t )((unsigned long )(pc.day_ordinal - (intmax_t )tmp___904) * 7UL);
#line 2100
                    tmp___906 = 1;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___905 = 1;
                      } else {
#line 2100
                        tmp___905 = 0;
                      }
                    } else {
#line 2100
                      tmp___905 = 0;
                    }
#line 2100
                    dayincr = (intmax_t )((unsigned long )(pc.day_ordinal - (intmax_t )tmp___905) * 7UL);
#line 2100
                    tmp___906 = 0;
                  }
#line 2100
                  tmp___963 = tmp___906;
                }
#line 2100
                tmp___1195 = tmp___963;
              } else {
#line 2100
                if (1) {
#line 2100
                  if (0) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1039 = 1;
                      } else {
#line 2100
                        tmp___1039 = 0;
                      }
                    } else {
#line 2100
                      tmp___1039 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___1039 < 0L) {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___1024 = 1;
                        } else {
#line 2100
                          tmp___1024 = 0;
                        }
                      } else {
#line 2100
                        tmp___1024 = 0;
                      }
#line 2100
                      tmp___1038 = (long long )(pc.day_ordinal - (intmax_t )tmp___1024) < 1317624576693539401LL;
                    } else {
#line 2100
                      if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 2100
                        tmp___1037 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                      } else {
#line 2100
                        tmp___1037 = 0;
                      }
#line 2100
                      if (tmp___1037) {
#line 2100
                        goto _L___37;
                      } else {
                        _L___37: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___1035 = 1;
                          } else {
#line 2100
                            tmp___1035 = 0;
                          }
                        } else {
#line 2100
                          tmp___1035 = 0;
                        }
#line 2100
                        tmp___1036 = -1317624576693539401LL < (long long )(pc.day_ordinal - (intmax_t )tmp___1035);
                      }
#line 2100
                      tmp___1038 = tmp___1036;
                    }
#line 2100
                    tmp___1078 = tmp___1038;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1077 = 1;
                      } else {
#line 2100
                        tmp___1077 = 0;
                      }
                    } else {
#line 2100
                      tmp___1077 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___1077 < 0L) {
#line 2100
                      if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 2100
                        tmp___1069 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                      } else {
#line 2100
                        tmp___1069 = 0;
                      }
#line 2100
                      if (tmp___1069) {
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___1074 = 1;
                          } else {
#line 2100
                            tmp___1074 = 0;
                          }
                        } else {
#line 2100
                          tmp___1074 = 0;
                        }
#line 2100
                        if (pc.day_ordinal - (intmax_t )tmp___1074 == -1L) {
#line 2100
                          tmp___1058 = 0;
                        } else {
#line 2100
                          goto _L___38;
                        }
                      } else {
                        _L___38: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___1057 = 1;
                          } else {
#line 2100
                            tmp___1057 = 0;
                          }
                        } else {
#line 2100
                          tmp___1057 = 0;
                        }
#line 2100
                        tmp___1058 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )(pc.day_ordinal - (intmax_t )tmp___1057) < 7LL;
                      }
#line 2100
                      tmp___1076 = tmp___1058;
                    } else {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___1075 = 1;
                        } else {
#line 2100
                          tmp___1075 = 0;
                        }
                      } else {
#line 2100
                        tmp___1075 = 0;
                      }
#line 2100
                      tmp___1076 = 1317624576693539401LL < (long long )(pc.day_ordinal - (intmax_t )tmp___1075);
                    }
#line 2100
                    tmp___1078 = tmp___1076;
                  }
#line 2100
                  if (tmp___1078) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1020 = 1;
                      } else {
#line 2100
                        tmp___1020 = 0;
                      }
                    } else {
#line 2100
                      tmp___1020 = 0;
                    }
#line 2100
                    dayincr = (intmax_t )((long long )((unsigned long long )(pc.day_ordinal - (intmax_t )tmp___1020) * 7ULL));
#line 2100
                    tmp___1022 = 1;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1021 = 1;
                      } else {
#line 2100
                        tmp___1021 = 0;
                      }
                    } else {
#line 2100
                      tmp___1021 = 0;
                    }
#line 2100
                    dayincr = (intmax_t )((long long )((unsigned long long )(pc.day_ordinal - (intmax_t )tmp___1021) * 7ULL));
#line 2100
                    tmp___1022 = 0;
                  }
#line 2100
                  tmp___1194 = tmp___1022;
                } else {
#line 2100
                  if (0) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1154 = 1;
                      } else {
#line 2100
                        tmp___1154 = 0;
                      }
                    } else {
#line 2100
                      tmp___1154 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___1154 < 0L) {
#line 2100
                      if (~ (((1 << (sizeof(7) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                        tmp___1142 = 7 < - (((1 << (sizeof(7) * 8UL - 2UL)) - 1) * 2 + 1);
                      } else {
#line 2100
                        tmp___1142 = 1;
                      }
#line 2100
                      if (tmp___1142) {
#line 2100
                        tmp___1141 = 0xffffffffffffffffULL >> (sizeof(7) * 8UL - 1UL);
                      } else {
#line 2100
                        tmp___1141 = 1ULL;
                      }
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___1143 = 1;
                        } else {
#line 2100
                          tmp___1143 = 0;
                        }
                      } else {
#line 2100
                        tmp___1143 = 0;
                      }
#line 2100
                      tmp___1153 = tmp___1141 <= (unsigned long long )(-1L - (pc.day_ordinal - (intmax_t )tmp___1143));
                    } else {
#line 2100
                      if (~ (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 2100
                        tmp___1152 = 0 < - (((1 << (sizeof(0) * 8UL - 2UL)) - 1) * 2 + 1);
                      } else {
#line 2100
                        tmp___1152 = 0;
                      }
#line 2100
                      if (tmp___1152) {
#line 2100
                        goto _L___41;
                      } else {
                        _L___41: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___1150 = 1;
                          } else {
#line 2100
                            tmp___1150 = 0;
                          }
                        } else {
#line 2100
                          tmp___1150 = 0;
                        }
#line 2100
                        tmp___1151 = 0L < pc.day_ordinal - (intmax_t )tmp___1150;
                      }
#line 2100
                      tmp___1153 = tmp___1151;
                    }
#line 2100
                    tmp___1193 = tmp___1153;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1192 = 1;
                      } else {
#line 2100
                        tmp___1192 = 0;
                      }
                    } else {
#line 2100
                      tmp___1192 = 0;
                    }
#line 2100
                    if (pc.day_ordinal - (intmax_t )tmp___1192 < 0L) {
#line 2100
                      if (~ (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2100
                        tmp___1184 = 0L < - (((1L << (sizeof(0L) * 8UL - 2UL)) - 1L) * 2L + 1L);
                      } else {
#line 2100
                        tmp___1184 = 0;
                      }
#line 2100
                      if (tmp___1184) {
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___1189 = 1;
                          } else {
#line 2100
                            tmp___1189 = 0;
                          }
                        } else {
#line 2100
                          tmp___1189 = 0;
                        }
#line 2100
                        if (pc.day_ordinal - (intmax_t )tmp___1189 == -1L) {
#line 2100
                          tmp___1173 = 1;
                        } else {
#line 2100
                          goto _L___42;
                        }
                      } else {
                        _L___42: /* CIL Label */ 
#line 2100
                        if (0L < pc.day_ordinal) {
#line 2100
                          if (tm.tm_wday != pc.day_number) {
#line 2100
                            tmp___1172 = 1;
                          } else {
#line 2100
                            tmp___1172 = 0;
                          }
                        } else {
#line 2100
                          tmp___1172 = 0;
                        }
#line 2100
                        tmp___1173 = 0L / (pc.day_ordinal - (intmax_t )tmp___1172) < 7L;
                      }
#line 2100
                      tmp___1191 = tmp___1173;
                    } else {
#line 2100
                      if (0L < pc.day_ordinal) {
#line 2100
                        if (tm.tm_wday != pc.day_number) {
#line 2100
                          tmp___1190 = 1;
                        } else {
#line 2100
                          tmp___1190 = 0;
                        }
                      } else {
#line 2100
                        tmp___1190 = 0;
                      }
#line 2100
                      tmp___1191 = 2635249153387078802ULL < (unsigned long long )(pc.day_ordinal - (intmax_t )tmp___1190);
                    }
#line 2100
                    tmp___1193 = tmp___1191;
                  }
#line 2100
                  if (tmp___1193) {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1135 = 1;
                      } else {
#line 2100
                        tmp___1135 = 0;
                      }
                    } else {
#line 2100
                      tmp___1135 = 0;
                    }
#line 2100
                    dayincr = (intmax_t )((unsigned long long )(pc.day_ordinal - (intmax_t )tmp___1135) * 7ULL);
#line 2100
                    tmp___1137 = 1;
                  } else {
#line 2100
                    if (0L < pc.day_ordinal) {
#line 2100
                      if (tm.tm_wday != pc.day_number) {
#line 2100
                        tmp___1136 = 1;
                      } else {
#line 2100
                        tmp___1136 = 0;
                      }
                    } else {
#line 2100
                      tmp___1136 = 0;
                    }
#line 2100
                    dayincr = (intmax_t )((unsigned long long )(pc.day_ordinal - (intmax_t )tmp___1136) * 7ULL);
#line 2100
                    tmp___1137 = 0;
                  }
#line 2100
                  tmp___1194 = tmp___1137;
                }
#line 2100
                tmp___1195 = tmp___1194;
              }
#line 2100
              tmp___1196 = tmp___1195;
            }
#line 2100
            tmp___1197 = tmp___1196;
          }
#line 2100
          tmp___1198 = tmp___1197;
        }
#line 2100
        if (tmp___1198) {
#line 2107
          Start = (time_t )-1;
        } else {
          {
#line 2100
          tmp___1199 = __builtin_add_overflow(((pc.day_number - tm.tm_wday) + 7) % 7,
                                              dayincr, & dayincr);
          }
#line 2100
          if (tmp___1199) {
#line 2107
            Start = (time_t )-1;
          } else {
            {
#line 2100
            tmp___1200 = __builtin_add_overflow(dayincr, tm.tm_mday, & tm.tm_mday);
            }
#line 2100
            if (tmp___1200) {
#line 2107
              Start = (time_t )-1;
            } else {
              {
#line 2110
              tm.tm_isdst = -1;
#line 2111
              Start = mktime_z(tz, (struct tm */* __restrict  */)(& tm));
              }
            }
          }
        }
#line 2114
        if (Start == -1L) {
#line 2116
          if (pc.parse_datetime_debug) {
            {
#line 2117
            tmp___1201 = debug_strfdatetime((struct tm  const  *)(& tm), (parser_control const   *)(& pc),
                                            dbg_tm, (int )sizeof(dbg_tm));
#line 2117
            tmp___1202 = str_days(& pc, dbg_ord, (int )sizeof(dbg_ord));
#line 2117
            tmp___1203 = dcgettext((char const   *)((void *)0), "error: day \'%s\' (day ordinal=%ld number=%d) resulted in an invalid date: \'%s\'\n",
                                   5);
#line 2117
            dbg_printf((char const   *)tmp___1203, tmp___1202, pc.day_ordinal, pc.day_number,
                       tmp___1201);
            }
          }
#line 2124
          goto fail;
        }
#line 2127
        if (pc.parse_datetime_debug) {
          {
#line 2128
          tmp___1204 = debug_strfdatetime((struct tm  const  *)(& tm), (parser_control const   *)(& pc),
                                          dbg_tm, (int )sizeof(dbg_tm));
#line 2128
          tmp___1205 = str_days(& pc, dbg_ord, (int )sizeof(dbg_ord));
#line 2128
          tmp___1206 = dcgettext((char const   *)((void *)0), "new start date: \'%s\' is \'%s\'\n",
                                 5);
#line 2128
          dbg_printf((char const   *)tmp___1206, tmp___1205, tmp___1204);
          }
        }
      }
    }
#line 2134
    if (pc.parse_datetime_debug) {
#line 2136
      if (! pc.dates_seen) {
#line 2136
        if (! pc.days_seen) {
          {
#line 2137
          tmp___1207 = debug_strfdate((struct tm  const  *)(& tm), dbg_tm, (int )sizeof(dbg_tm));
#line 2137
          tmp___1208 = dcgettext((char const   *)((void *)0), "using current date as starting value: \'%s\'\n",
                                 5);
#line 2137
          dbg_printf((char const   *)tmp___1208, tmp___1207);
          }
        }
      }
#line 2140
      if (pc.days_seen) {
#line 2140
        if (pc.dates_seen) {
          {
#line 2141
          tmp___1209 = str_days(& pc, dbg_ord, (int )sizeof(dbg_ord));
#line 2141
          tmp___1210 = dcgettext((char const   *)((void *)0), "warning: day (%s) ignored when explicit dates are given\n",
                                 5);
#line 2141
          dbg_printf((char const   *)tmp___1210, tmp___1209);
          }
        }
      }
      {
#line 2145
      tmp___1211 = debug_strfdatetime((struct tm  const  *)(& tm), (parser_control const   *)(& pc),
                                      dbg_tm, (int )sizeof(dbg_tm));
#line 2145
      tmp___1212 = dcgettext((char const   *)((void *)0), "starting date/time: \'%s\'\n",
                             5);
#line 2145
      dbg_printf((char const   *)tmp___1212, tmp___1211);
      }
    }
#line 2150
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 2152
      if (pc.parse_datetime_debug) {
#line 2154
        if (pc.rel.year != 0L) {
#line 2154
          goto _L___43;
        } else
#line 2154
        if (pc.rel.month != 0L) {
          _L___43: /* CIL Label */ 
#line 2154
          if (tm.tm_mday != 15) {
            {
#line 2155
            tmp___1213 = dcgettext((char const   *)((void *)0), "warning: when adding relative months/years, it is recommended to specify the 15th of the months\n",
                                   5);
#line 2155
            dbg_printf((char const   *)tmp___1213);
            }
          }
        }
#line 2159
        if (pc.rel.day != 0L) {
#line 2159
          if (tm.tm_hour != 12) {
            {
#line 2160
            tmp___1214 = dcgettext((char const   *)((void *)0), "warning: when adding relative days, it is recommended to specify noon\n",
                                   5);
#line 2160
            dbg_printf((char const   *)tmp___1214);
            }
          }
        }
      }
      {
#line 2165
      tmp___1216 = __builtin_add_overflow(tm.tm_year, pc.rel.year, & year);
      }
#line 2165
      if (tmp___1216) {
#line 2165
        goto _L___44;
      } else {
        {
#line 2165
        tmp___1217 = __builtin_add_overflow(tm.tm_mon, pc.rel.month, & month);
        }
#line 2165
        if (tmp___1217) {
#line 2165
          goto _L___44;
        } else {
          {
#line 2165
          tmp___1218 = __builtin_add_overflow(tm.tm_mday, pc.rel.day, & day);
          }
#line 2165
          if (tmp___1218) {
            _L___44: /* CIL Label */ 
#line 2169
            if (pc.parse_datetime_debug) {
              {
#line 2170
              tmp___1215 = dcgettext((char const   *)((void *)0), "error: %s:%d\n",
                                     5);
#line 2170
              dbg_printf((char const   *)tmp___1215, "parse-datetime.y", 2170);
              }
            }
#line 2171
            goto fail;
          }
        }
      }
      {
#line 2173
      tm.tm_year = year;
#line 2174
      tm.tm_mon = month;
#line 2175
      tm.tm_mday = day;
#line 2176
      tm.tm_hour = tm0.tm_hour;
#line 2177
      tm.tm_min = tm0.tm_min;
#line 2178
      tm.tm_sec = tm0.tm_sec;
#line 2179
      tm.tm_isdst = tm0.tm_isdst;
#line 2180
      Start = mktime_z(tz, (struct tm */* __restrict  */)(& tm));
      }
#line 2181
      if (Start == -1L) {
#line 2183
        if (pc.parse_datetime_debug) {
          {
#line 2184
          tmp___1219 = debug_strfdatetime((struct tm  const  *)(& tm), (parser_control const   *)(& pc),
                                          dbg_tm, (int )sizeof(dbg_tm));
#line 2184
          tmp___1220 = dcgettext((char const   *)((void *)0), "error: adding relative date resulted in an invalid date: \'%s\'\n",
                                 5);
#line 2184
          dbg_printf((char const   *)tmp___1220, tmp___1219);
          }
        }
#line 2188
        goto fail;
      }
#line 2191
      if (pc.parse_datetime_debug) {
        {
#line 2193
        tmp___1221 = dcgettext((char const   *)((void *)0), "after date adjustment (%+ld years, %+ld months, %+ld days),\n",
                               5);
#line 2193
        dbg_printf((char const   *)tmp___1221, pc.rel.year, pc.rel.month, pc.rel.day);
#line 2197
        tmp___1222 = debug_strfdatetime((struct tm  const  *)(& tm), (parser_control const   *)(& pc),
                                        dbg_tm, (int )sizeof(dbg_tm));
#line 2197
        tmp___1223 = dcgettext((char const   *)((void *)0), "    new date/time = \'%s\'\n",
                               5);
#line 2197
        dbg_printf((char const   *)tmp___1223, tmp___1222);
        }
#line 2215
        if (tm0.tm_isdst != -1) {
#line 2215
          if (tm.tm_isdst != tm0.tm_isdst) {
            {
#line 2216
            tmp___1224 = dcgettext((char const   *)((void *)0), "warning: daylight saving time changed after date adjustment\n",
                                   5);
#line 2216
            dbg_printf((char const   *)tmp___1224);
            }
          }
        }
#line 2231
        if (pc.rel.day == 0L) {
#line 2231
          if (tm.tm_mday != day) {
#line 2231
            goto _L___45;
          } else
#line 2231
          if (pc.rel.month == 0L) {
#line 2231
            if (tm.tm_mon != month) {
              _L___45: /* CIL Label */ 
              {
#line 2235
              tmp___1225 = dcgettext((char const   *)((void *)0), "warning: month/year adjustment resulted in shifted dates:\n",
                                     5);
#line 2235
              dbg_printf((char const   *)tmp___1225);
#line 2238
              tmp___1226 = tm_year_str(year, (char *)(tm_year_buf));
#line 2238
              tmp___1227 = dcgettext((char const   *)((void *)0), "     adjusted Y M D: %s %02d %02d\n",
                                     5);
#line 2238
              dbg_printf((char const   *)tmp___1227, tmp___1226, month + 1, day);
#line 2240
              tmp___1228 = tm_year_str(tm.tm_year, (char *)(tm_year_buf));
#line 2240
              tmp___1229 = dcgettext((char const   *)((void *)0), "   normalized Y M D: %s %02d %02d\n",
                                     5);
#line 2240
              dbg_printf((char const   *)tmp___1229, tmp___1228, tm.tm_mon + 1, tm.tm_mday);
              }
            }
          }
        }
      }
    }
#line 2250
    if (pc.zones_seen) {
      {
#line 2252
      delta = (intmax_t )pc.time_zone;
#line 2253
      overflow = (_Bool)0;
#line 2255
      utcoff = tm.tm_gmtoff;
#line 2263
      tmp___1230 = __builtin_sub_overflow(delta, utcoff, & delta);
#line 2263
      overflow = (_Bool )((int )overflow | tmp___1230);
#line 2264
      tmp___1231 = __builtin_sub_overflow(Start, delta, & t1);
#line 2264
      overflow = (_Bool )((int )overflow | tmp___1231);
      }
#line 2265
      if (overflow) {
#line 2265
        goto _L___46;
      } else {
        {
#line 2265
        tmp___1233 = time_overflow(t1);
        }
#line 2265
        if (tmp___1233) {
          _L___46: /* CIL Label */ 
#line 2267
          if (pc.parse_datetime_debug) {
            {
#line 2268
            tmp___1232 = dcgettext((char const   *)((void *)0), "error: timezone %d caused time_t overflow\n",
                                   5);
#line 2268
            dbg_printf((char const   *)tmp___1232, pc.time_zone);
            }
          }
#line 2270
          goto fail;
        }
      }
#line 2272
      Start = t1;
    }
#line 2275
    if (pc.parse_datetime_debug) {
      {
#line 2277
      Starti = Start;
#line 2278
      tmp___1234 = debug_strfdatetime((struct tm  const  *)(& tm), (parser_control const   *)(& pc),
                                      dbg_tm, (int )sizeof(dbg_tm));
#line 2278
      tmp___1235 = dcgettext((char const   *)((void *)0), "\'%s\' = %ld epoch-seconds\n",
                             5);
#line 2278
      dbg_printf((char const   *)tmp___1235, tmp___1234, Starti);
      }
    }
#line 2292
    orig_ns = pc.seconds.tv_nsec;
#line 2293
    sum_ns = orig_ns + (intmax_t )pc.rel.ns;
#line 2294
    normalized_ns = (int )((sum_ns % 1000000000L + 1000000000L) % 1000000000L);
#line 2295
    d4 = (int )((sum_ns - (intmax_t )normalized_ns) / 1000000000L);
#line 2297
    if (sizeof(d1) == sizeof(signed char )) {
#line 2297
      if (pc.rel.hour < 0L) {
#line 2297
        if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
          tmp___1260 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
        } else {
#line 2297
          tmp___1260 = 0;
        }
#line 2297
        if (tmp___1260) {
#line 2297
          if (pc.rel.hour == -1L) {
#line 2297
            tmp___1259 = 1;
          } else {
#line 2297
            tmp___1259 = -128L / pc.rel.hour < 3600L;
          }
        } else {
#line 2297
          tmp___1259 = -128L / pc.rel.hour < 3600L;
        }
#line 2297
        tmp___1261 = tmp___1259;
      } else {
#line 2297
        tmp___1261 = 0L < pc.rel.hour;
      }
#line 2297
      if (tmp___1261) {
#line 2297
        d1 = (intmax_t )((signed char )((unsigned int )pc.rel.hour * 3600U));
#line 2297
        tmp___1249 = 1;
      } else {
#line 2297
        d1 = (intmax_t )((signed char )((unsigned int )pc.rel.hour * 3600U));
#line 2297
        tmp___1249 = 0;
      }
#line 2297
      tmp___1490 = tmp___1249;
    } else {
#line 2297
      if (sizeof(d1) == sizeof(short )) {
#line 2297
        if (pc.rel.hour < 0L) {
#line 2297
          if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
            tmp___1310 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
          } else {
#line 2297
            tmp___1310 = 0;
          }
#line 2297
          if (tmp___1310) {
#line 2297
            if (pc.rel.hour == -1L) {
#line 2297
              tmp___1309 = 0;
            } else {
#line 2297
              tmp___1309 = -32768L / pc.rel.hour < 3600L;
            }
          } else {
#line 2297
            tmp___1309 = -32768L / pc.rel.hour < 3600L;
          }
#line 2297
          tmp___1311 = tmp___1309;
        } else {
#line 2297
          tmp___1311 = 9L < pc.rel.hour;
        }
#line 2297
        if (tmp___1311) {
#line 2297
          d1 = (intmax_t )((short )((unsigned int )pc.rel.hour * 3600U));
#line 2297
          tmp___1299 = 1;
        } else {
#line 2297
          d1 = (intmax_t )((short )((unsigned int )pc.rel.hour * 3600U));
#line 2297
          tmp___1299 = 0;
        }
#line 2297
        tmp___1489 = tmp___1299;
      } else {
#line 2297
        if (sizeof(d1) == sizeof(int )) {
#line 2297
          if (pc.rel.hour < 0L) {
#line 2297
            if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
              tmp___1360 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 2297
              tmp___1360 = 0;
            }
#line 2297
            if (tmp___1360) {
#line 2297
              if (pc.rel.hour == -1L) {
#line 2297
                tmp___1359 = 0;
              } else {
#line 2297
                tmp___1359 = (-0x7FFFFFFF-1) / pc.rel.hour < 3600L;
              }
            } else {
#line 2297
              tmp___1359 = (-0x7FFFFFFF-1) / pc.rel.hour < 3600L;
            }
#line 2297
            tmp___1361 = tmp___1359;
          } else {
#line 2297
            tmp___1361 = 596523L < pc.rel.hour;
          }
#line 2297
          if (tmp___1361) {
#line 2297
            d1 = (intmax_t )((int )((unsigned int )pc.rel.hour * 3600U));
#line 2297
            tmp___1349 = 1;
          } else {
#line 2297
            d1 = (intmax_t )((int )((unsigned int )pc.rel.hour * 3600U));
#line 2297
            tmp___1349 = 0;
          }
#line 2297
          tmp___1488 = tmp___1349;
        } else {
#line 2297
          if (sizeof(d1) == sizeof(long )) {
#line 2297
            if (pc.rel.hour < 0L) {
#line 2297
              if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
                tmp___1410 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 2297
                tmp___1410 = 0;
              }
#line 2297
              if (tmp___1410) {
#line 2297
                if (pc.rel.hour == -1L) {
#line 2297
                  tmp___1409 = 0;
                } else {
#line 2297
                  tmp___1409 = (-0x7FFFFFFFFFFFFFFF-1) / pc.rel.hour < 3600L;
                }
              } else {
#line 2297
                tmp___1409 = (-0x7FFFFFFFFFFFFFFF-1) / pc.rel.hour < 3600L;
              }
#line 2297
              tmp___1411 = tmp___1409;
            } else {
#line 2297
              tmp___1411 = 2562047788015215L < pc.rel.hour;
            }
#line 2297
            if (tmp___1411) {
#line 2297
              d1 = (long )((unsigned long )pc.rel.hour * 3600UL);
#line 2297
              tmp___1399 = 1;
            } else {
#line 2297
              d1 = (long )((unsigned long )pc.rel.hour * 3600UL);
#line 2297
              tmp___1399 = 0;
            }
#line 2297
            tmp___1487 = tmp___1399;
          } else {
#line 2297
            if (pc.rel.hour < 0L) {
#line 2297
              if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 2297
                tmp___1460 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
              } else {
#line 2297
                tmp___1460 = 0;
              }
#line 2297
              if (tmp___1460) {
#line 2297
                if (pc.rel.hour == -1L) {
#line 2297
                  tmp___1459 = 0;
                } else {
#line 2297
                  tmp___1459 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )pc.rel.hour < 3600LL;
                }
              } else {
#line 2297
                tmp___1459 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )pc.rel.hour < 3600LL;
              }
#line 2297
              tmp___1461 = tmp___1459;
            } else {
#line 2297
              tmp___1461 = 2562047788015215LL < (long long )pc.rel.hour;
            }
#line 2297
            if (tmp___1461) {
#line 2297
              d1 = (intmax_t )((long long )((unsigned long long )pc.rel.hour * 3600ULL));
#line 2297
              tmp___1449 = 1;
            } else {
#line 2297
              d1 = (intmax_t )((long long )((unsigned long long )pc.rel.hour * 3600ULL));
#line 2297
              tmp___1449 = 0;
            }
#line 2297
            tmp___1487 = tmp___1449;
          }
#line 2297
          tmp___1488 = tmp___1487;
        }
#line 2297
        tmp___1489 = tmp___1488;
      }
#line 2297
      tmp___1490 = tmp___1489;
    }
#line 2297
    if (tmp___1490) {
#line 2297
      goto _L___47;
    } else {
      {
#line 2297
      tmp___1491 = __builtin_add_overflow(Start, d1, & t1___0);
      }
#line 2297
      if (tmp___1491) {
#line 2297
        goto _L___47;
      } else {
#line 2297
        if (sizeof(d2) == sizeof(signed char )) {
#line 2297
          if (pc.rel.minutes < 0L) {
#line 2297
            if (~ (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
              tmp___1515 = -128L < - (((1L << (sizeof(-128L) * 8UL - 2UL)) - 1L) * 2L + 1L);
            } else {
#line 2297
              tmp___1515 = 0;
            }
#line 2297
            if (tmp___1515) {
#line 2297
              if (pc.rel.minutes == -1L) {
#line 2297
                tmp___1514 = 0;
              } else {
#line 2297
                tmp___1514 = -128L / pc.rel.minutes < 60L;
              }
            } else {
#line 2297
              tmp___1514 = -128L / pc.rel.minutes < 60L;
            }
#line 2297
            tmp___1516 = tmp___1514;
          } else {
#line 2297
            tmp___1516 = 2L < pc.rel.minutes;
          }
#line 2297
          if (tmp___1516) {
#line 2297
            d2 = (intmax_t )((signed char )((unsigned int )pc.rel.minutes * 60U));
#line 2297
            tmp___1504 = 1;
          } else {
#line 2297
            d2 = (intmax_t )((signed char )((unsigned int )pc.rel.minutes * 60U));
#line 2297
            tmp___1504 = 0;
          }
#line 2297
          tmp___1745 = tmp___1504;
        } else {
#line 2297
          if (sizeof(d2) == sizeof(short )) {
#line 2297
            if (pc.rel.minutes < 0L) {
#line 2297
              if (~ (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
                tmp___1565 = -32768L < - (((1L << (sizeof(-32768L) * 8UL - 2UL)) - 1L) * 2L + 1L);
              } else {
#line 2297
                tmp___1565 = 0;
              }
#line 2297
              if (tmp___1565) {
#line 2297
                if (pc.rel.minutes == -1L) {
#line 2297
                  tmp___1564 = 0;
                } else {
#line 2297
                  tmp___1564 = -32768L / pc.rel.minutes < 60L;
                }
              } else {
#line 2297
                tmp___1564 = -32768L / pc.rel.minutes < 60L;
              }
#line 2297
              tmp___1566 = tmp___1564;
            } else {
#line 2297
              tmp___1566 = 546L < pc.rel.minutes;
            }
#line 2297
            if (tmp___1566) {
#line 2297
              d2 = (intmax_t )((short )((unsigned int )pc.rel.minutes * 60U));
#line 2297
              tmp___1554 = 1;
            } else {
#line 2297
              d2 = (intmax_t )((short )((unsigned int )pc.rel.minutes * 60U));
#line 2297
              tmp___1554 = 0;
            }
#line 2297
            tmp___1744 = tmp___1554;
          } else {
#line 2297
            if (sizeof(d2) == sizeof(int )) {
#line 2297
              if (pc.rel.minutes < 0L) {
#line 2297
                if (~ (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
                  tmp___1615 = (-0x7FFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                } else {
#line 2297
                  tmp___1615 = 0;
                }
#line 2297
                if (tmp___1615) {
#line 2297
                  if (pc.rel.minutes == -1L) {
#line 2297
                    tmp___1614 = 0;
                  } else {
#line 2297
                    tmp___1614 = (-0x7FFFFFFF-1) / pc.rel.minutes < 60L;
                  }
                } else {
#line 2297
                  tmp___1614 = (-0x7FFFFFFF-1) / pc.rel.minutes < 60L;
                }
#line 2297
                tmp___1616 = tmp___1614;
              } else {
#line 2297
                tmp___1616 = 35791394L < pc.rel.minutes;
              }
#line 2297
              if (tmp___1616) {
#line 2297
                d2 = (intmax_t )((int )((unsigned int )pc.rel.minutes * 60U));
#line 2297
                tmp___1604 = 1;
              } else {
#line 2297
                d2 = (intmax_t )((int )((unsigned int )pc.rel.minutes * 60U));
#line 2297
                tmp___1604 = 0;
              }
#line 2297
              tmp___1743 = tmp___1604;
            } else {
#line 2297
              if (sizeof(d2) == sizeof(long )) {
#line 2297
                if (pc.rel.minutes < 0L) {
#line 2297
                  if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 2297
                    tmp___1665 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                  } else {
#line 2297
                    tmp___1665 = 0;
                  }
#line 2297
                  if (tmp___1665) {
#line 2297
                    if (pc.rel.minutes == -1L) {
#line 2297
                      tmp___1664 = 0;
                    } else {
#line 2297
                      tmp___1664 = (-0x7FFFFFFFFFFFFFFF-1) / pc.rel.minutes < 60L;
                    }
                  } else {
#line 2297
                    tmp___1664 = (-0x7FFFFFFFFFFFFFFF-1) / pc.rel.minutes < 60L;
                  }
#line 2297
                  tmp___1666 = tmp___1664;
                } else {
#line 2297
                  tmp___1666 = 153722867280912930L < pc.rel.minutes;
                }
#line 2297
                if (tmp___1666) {
#line 2297
                  d2 = (long )((unsigned long )pc.rel.minutes * 60UL);
#line 2297
                  tmp___1654 = 1;
                } else {
#line 2297
                  d2 = (long )((unsigned long )pc.rel.minutes * 60UL);
#line 2297
                  tmp___1654 = 0;
                }
#line 2297
                tmp___1742 = tmp___1654;
              } else {
#line 2297
                if (pc.rel.minutes < 0L) {
#line 2297
                  if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 2297
                    tmp___1715 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                  } else {
#line 2297
                    tmp___1715 = 0;
                  }
#line 2297
                  if (tmp___1715) {
#line 2297
                    if (pc.rel.minutes == -1L) {
#line 2297
                      tmp___1714 = 0;
                    } else {
#line 2297
                      tmp___1714 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )pc.rel.minutes < 60LL;
                    }
                  } else {
#line 2297
                    tmp___1714 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )pc.rel.minutes < 60LL;
                  }
#line 2297
                  tmp___1716 = tmp___1714;
                } else {
#line 2297
                  tmp___1716 = 153722867280912930LL < (long long )pc.rel.minutes;
                }
#line 2297
                if (tmp___1716) {
#line 2297
                  d2 = (intmax_t )((long long )((unsigned long long )pc.rel.minutes * 60ULL));
#line 2297
                  tmp___1704 = 1;
                } else {
#line 2297
                  d2 = (intmax_t )((long long )((unsigned long long )pc.rel.minutes * 60ULL));
#line 2297
                  tmp___1704 = 0;
                }
#line 2297
                tmp___1742 = tmp___1704;
              }
#line 2297
              tmp___1743 = tmp___1742;
            }
#line 2297
            tmp___1744 = tmp___1743;
          }
#line 2297
          tmp___1745 = tmp___1744;
        }
#line 2297
        if (tmp___1745) {
#line 2297
          goto _L___47;
        } else {
          {
#line 2297
          tmp___1746 = __builtin_add_overflow(t1___0, d2, & t2);
          }
#line 2297
          if (tmp___1746) {
#line 2297
            goto _L___47;
          } else {
            {
#line 2297
            tmp___1747 = __builtin_add_overflow(t2, pc.rel.seconds, & t3);
            }
#line 2297
            if (tmp___1747) {
#line 2297
              goto _L___47;
            } else {
              {
#line 2297
              tmp___1748 = __builtin_add_overflow(t3, d4, & t4);
              }
#line 2297
              if (tmp___1748) {
#line 2297
                goto _L___47;
              } else {
                {
#line 2297
                tmp___1749 = time_overflow(t4);
                }
#line 2297
                if (tmp___1749) {
                  _L___47: /* CIL Label */ 
#line 2305
                  if (pc.parse_datetime_debug) {
                    {
#line 2306
                    tmp___1236 = dcgettext((char const   *)((void *)0), "error: adding relative time caused an overflow\n",
                                           5);
#line 2306
                    dbg_printf((char const   *)tmp___1236);
                    }
                  }
#line 2308
                  goto fail;
                }
              }
            }
          }
        }
      }
    }
#line 2311
    result->tv_sec = t4;
#line 2312
    result->tv_nsec = (__syscall_slong_t )normalized_ns;
#line 2314
    if (pc.parse_datetime_debug) {
#line 2314
      if (((pc.rel.hour | pc.rel.minutes) | pc.rel.seconds) | (long )pc.rel.ns) {
        {
#line 2317
        tmp___1750 = dcgettext((char const   *)((void *)0), "after time adjustment (%+ld hours, %+ld minutes, %+ld seconds, %+d ns),\n",
                               5);
#line 2317
        dbg_printf((char const   *)tmp___1750, pc.rel.hour, pc.rel.minutes, pc.rel.seconds,
                   pc.rel.ns);
#line 2322
        tmp___1751 = dcgettext((char const   *)((void *)0), "    new time = %ld epoch-seconds\n",
                               5);
#line 2322
        dbg_printf((char const   *)tmp___1751, t4);
        }
#line 2336
        if (tm.tm_isdst != -1) {
          {
#line 2336
          tmp___1753 = localtime_rz(tz, (time_t const   */* __restrict  */)(& result->tv_sec),
                                    (struct tm */* __restrict  */)(& lmt));
          }
#line 2336
          if (tmp___1753) {
#line 2336
            if (tm.tm_isdst != lmt.tm_isdst) {
              {
#line 2338
              tmp___1752 = dcgettext((char const   *)((void *)0), "warning: daylight saving time changed after time adjustment\n",
                                     5);
#line 2338
              dbg_printf((char const   *)tmp___1752);
              }
            }
          }
        }
      }
    }
  }
#line 2344
  if (pc.parse_datetime_debug) {
#line 2347
    if (! tzstring) {
      {
#line 2348
      tmp___1754 = dcgettext((char const   *)((void *)0), "timezone: system default\n",
                             5);
#line 2348
      dbg_printf((char const   *)tmp___1754);
      }
    } else {
      {
#line 2349
      tmp___1757 = strcmp(tzstring, "UTC0");
      }
#line 2349
      if (tmp___1757 == 0) {
        {
#line 2350
        tmp___1755 = dcgettext((char const   *)((void *)0), "timezone: Universal Time\n",
                               5);
#line 2350
        dbg_printf((char const   *)tmp___1755);
        }
      } else {
        {
#line 2352
        tmp___1756 = dcgettext((char const   *)((void *)0), "timezone: TZ=\"%s\" environment value\n",
                               5);
#line 2352
        dbg_printf((char const   *)tmp___1756, tzstring);
        }
      }
    }
    {
#line 2354
    sec = result->tv_sec;
#line 2355
    nsec = (int )result->tv_nsec;
#line 2356
    tmp___1758 = dcgettext((char const   *)((void *)0), "final: %ld.%09d (epoch-seconds)\n",
                           5);
#line 2356
    dbg_printf((char const   *)tmp___1758, sec, nsec);
#line 2360
    tmp___1759 = gmtime_r((time_t const   */* __restrict  */)(& result->tv_sec), (struct tm */* __restrict  */)(& gmt));
    }
#line 2360
    if (tmp___1759) {
#line 2360
      tmp___1760 = 1;
    } else {
#line 2360
      tmp___1760 = 0;
    }
#line 2360
    got_utc = (_Bool )tmp___1760;
#line 2361
    if (got_utc) {
      {
#line 2362
      tmp___1761 = debug_strfdatetime((struct tm  const  *)(& gmt), (parser_control const   *)((void *)0),
                                      dbg_tm, (int )sizeof(dbg_tm));
#line 2362
      tmp___1762 = dcgettext((char const   *)((void *)0), "final: %s (UTC)\n", 5);
#line 2362
      dbg_printf((char const   *)tmp___1762, tmp___1761);
      }
    }
    {
#line 2365
    tmp___1768 = localtime_rz(tz, (time_t const   */* __restrict  */)(& result->tv_sec),
                              (struct tm */* __restrict  */)(& lmt___0));
    }
#line 2365
    if (tmp___1768) {
#line 2368
      got_utcoff = (_Bool)1;
#line 2369
      utcoff___0 = lmt___0.tm_gmtoff;
#line 2376
      if (got_utcoff) {
        {
#line 2377
        tmp___1763 = time_zone_str((int )utcoff___0, (char *)(time_zone_buf));
#line 2377
        tmp___1764 = debug_strfdatetime((struct tm  const  *)(& lmt___0), (parser_control const   *)((void *)0),
                                        dbg_tm, (int )sizeof(dbg_tm));
#line 2377
        tmp___1765 = dcgettext((char const   *)((void *)0), "final: %s (UTC%s)\n",
                               5);
#line 2377
        dbg_printf((char const   *)tmp___1765, tmp___1764, tmp___1763);
        }
      } else {
        {
#line 2381
        tmp___1766 = debug_strfdatetime((struct tm  const  *)(& lmt___0), (parser_control const   *)((void *)0),
                                        dbg_tm, (int )sizeof(dbg_tm));
#line 2381
        tmp___1767 = dcgettext((char const   *)((void *)0), "final: %s (unknown time zone offset)\n",
                               5);
#line 2381
        dbg_printf((char const   *)tmp___1767, tmp___1766);
        }
      }
    }
  }
#line 2386
  ok = (_Bool)1;
  fail: 
#line 2389
  if ((unsigned long )tz != (unsigned long )tzdefault) {
    {
#line 2390
    tzfree(tz);
    }
  }
  {
#line 2391
  free((void *)tz1alloc);
  }
#line 2392
  return (ok);
}
}
#line 213 "./obstack.h"
void _obstack_newchunk(struct obstack *h , size_t length ) ;
#line 214
void _obstack_free(struct obstack *h , void *obj ) ;
#line 215
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) ;
#line 218
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) ;
#line 222
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 230
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 83 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
static void *call_chunkfun(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
static void call_freefun(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
static int _obstack_begin_worker(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 149 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) 
{ 
  int tmp ;

  {
  {
#line 155
  h->chunkfun.plain = chunkfun;
#line 156
  h->freefun.plain = freefun;
#line 157
  h->use_extra_arg = 0U;
#line 158
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 158
  return (tmp);
}
}
#line 161 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) 
{ 
  int tmp ;

  {
  {
#line 168
  h->chunkfun.extra = chunkfun;
#line 169
  h->freefun.extra = freefun;
#line 170
  h->extra_arg = arg;
#line 171
  h->use_extra_arg = 1U;
#line 172
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 172
  return (tmp);
}
}
#line 181 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
void _obstack_newchunk(struct obstack *h , size_t length ) 
{ 
  struct _obstack_chunk *old_chunk ;
  struct _obstack_chunk *new_chunk ;
  size_t obj_size ;
  char *object_base ;
  size_t sum1 ;
  size_t sum2 ;
  size_t new_size ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 184
  old_chunk = h->chunk;
#line 185
  new_chunk = (struct _obstack_chunk *)0;
#line 186
  obj_size = (size_t )(h->next_free - h->object_base);
#line 190
  sum1 = obj_size + length;
#line 191
  sum2 = sum1 + h->alignment_mask;
#line 192
  new_size = (sum2 + (obj_size >> 3)) + 100UL;
#line 193
  if (new_size < sum2) {
#line 194
    new_size = sum2;
  }
#line 195
  if (new_size < h->chunk_size) {
#line 196
    new_size = h->chunk_size;
  }
#line 199
  if (obj_size <= sum1) {
#line 199
    if (sum1 <= sum2) {
      {
#line 200
      tmp = call_chunkfun(h, new_size);
#line 200
      new_chunk = (struct _obstack_chunk *)tmp;
      }
    }
  }
#line 201
  if (! new_chunk) {
    {
#line 202
    (*obstack_alloc_failed_handler)();
    }
  }
#line 203
  h->chunk = new_chunk;
#line 204
  new_chunk->prev = old_chunk;
#line 205
  tmp___0 = (char *)new_chunk + new_size;
#line 205
  h->chunk_limit = tmp___0;
#line 205
  new_chunk->limit = tmp___0;
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___1 = (char *)new_chunk;
  } else {
#line 208
    tmp___1 = (char *)0;
  }
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___2 = (char *)new_chunk;
  } else {
#line 208
    tmp___2 = (char *)0;
  }
  {
#line 208
  object_base = tmp___1 + (((size_t )(new_chunk->contents - tmp___2) + h->alignment_mask) & ~ h->alignment_mask);
#line 212
  memcpy((void */* __restrict  */)object_base, (void const   */* __restrict  */)h->object_base,
         obj_size);
  }
#line 217
  if (! h->maybe_empty_object) {
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___3 = (char *)old_chunk;
    } else {
#line 217
      tmp___3 = (char *)0;
    }
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___4 = (char *)old_chunk;
    } else {
#line 217
      tmp___4 = (char *)0;
    }
#line 217
    if ((unsigned long )h->object_base == (unsigned long )(tmp___3 + (((size_t )(old_chunk->contents - tmp___4) + h->alignment_mask) & ~ h->alignment_mask))) {
      {
#line 222
      new_chunk->prev = old_chunk->prev;
#line 223
      call_freefun(h, (void *)old_chunk);
      }
    }
  }
#line 226
  h->object_base = object_base;
#line 227
  h->next_free = h->object_base + obj_size;
#line 229
  h->maybe_empty_object = 0U;
#line 230
  return;
}
}
#line 238
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;

  {
#line 246
  lp = h->chunk;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 250
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 250
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 250
          goto while_break;
        }
      }
    } else {
#line 250
      goto while_break;
    }
#line 252
    plp = lp->prev;
#line 253
    lp = plp;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0));
}
}
#line 261 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
void _obstack_free(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;
  char *tmp ;

  {
#line 267
  lp = h->chunk;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 271
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 271
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 271
          goto while_break;
        }
      }
    } else {
#line 271
      goto while_break;
    }
    {
#line 273
    plp = lp->prev;
#line 274
    call_freefun(h, (void *)lp);
#line 275
    lp = plp;
#line 278
    h->maybe_empty_object = 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (lp) {
#line 282
    tmp = (char *)obj;
#line 282
    h->next_free = tmp;
#line 282
    h->object_base = tmp;
#line 283
    h->chunk_limit = lp->limit;
#line 284
    h->chunk = lp;
  } else
#line 286
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
    {
#line 288
    abort();
    }
  }
#line 289
  return;
}
}
#line 291
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 291 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
size_t _obstack_memory_used(struct obstack *h ) 
{ 
  struct _obstack_chunk *lp ;
  size_t nbytes ;

  {
#line 295
  nbytes = (size_t )0;
#line 297
  lp = h->chunk;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0))) {
#line 297
      goto while_break;
    }
#line 299
    nbytes += (size_t )(lp->limit - (char *)lp);
#line 297
    lp = lp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (nbytes);
}
}
#line 329 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
static void print_and_abort(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = dcgettext((char const   *)((void *)0), "memory exhausted", 5);
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 351 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/obstack.c"
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void)  =    & print_and_abort;
#line 88 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 314 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/nstrftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) ;
#line 317 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/nstrftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ 
  int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    tmp___1 = len;
#line 320
    len --;
#line 320
    if (! (tmp___1 > 0UL)) {
#line 320
      goto while_break;
    }
#line 321
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
      {
#line 321
      __res = tolower((int )((unsigned char )*(src + len)));
      }
    } else {
      {
#line 321
      tmp___0 = __ctype_tolower_loc();
#line 321
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
      }
    }
#line 321
    *(dest + len) = (char )__res;
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  return (dest);
}
}
#line 325
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) ;
#line 328 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/nstrftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ 
  int __res ;
  __int32_t const   **tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    tmp___1 = len;
#line 331
    len --;
#line 331
    if (! (tmp___1 > 0UL)) {
#line 331
      goto while_break;
    }
#line 332
    if (sizeof((unsigned char )*(src + len)) > 1UL) {
      {
#line 332
      __res = toupper((int )((unsigned char )*(src + len)));
      }
    } else {
      {
#line 332
      tmp___0 = __ctype_toupper_loc();
#line 332
      __res = (int )*(*tmp___0 + (int )((unsigned char )*(src + len)));
      }
    }
#line 332
    *(dest + len) = (char )__res;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return (dest);
}
}
#line 374
__inline static int iso_week_days(int yday , int wday ) ;
#line 376 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/nstrftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 382
  big_enough_multiple_of_7 = 378;
#line 383
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 417
static size_t __strftime_internal(char *s , size_t maxsize , char const   *format ,
                                  struct tm  const  *tp , _Bool upcase , int yr_spec ,
                                  int width , _Bool *tzset_called , timezone_t tz ,
                                  int ns ) ;
#line 428 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/nstrftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 timezone_t tz , int ns ) 
{ 
  _Bool tzset_called ;
  size_t tmp ;

  {
  {
#line 433
  tzset_called = (_Bool)0;
#line 434
  tmp = __strftime_internal(s, maxsize, format, tp, (_Bool)0, 0, -1, & tzset_called,
                            tz, ns);
  }
#line 434
  return (tmp);
}
}
#line 445 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/nstrftime.c"
static size_t __strftime_internal(char *s , size_t maxsize , char const   *format ,
                                  struct tm  const  *tp , _Bool upcase , int yr_spec ,
                                  int width , _Bool *tzset_called , timezone_t tz ,
                                  int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char *bufp ;
  char buf[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)] ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int subwidth ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  int tmp___13 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___63 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___113 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___163 ;
  int tmp___173 ;
  int tmp___174 ;
  int tmp___175 ;
  int tmp___213 ;
  int tmp___223 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___253 ;
  int tmp___254 ;
  int tmp___255 ;
  char const   *tmp___256 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___257 ;
  size_t _incr___0 ;
  size_t tmp___258 ;
  size_t _delta___0 ;
  size_t len ;
  size_t tmp___259 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___260 ;
  size_t _incr___1 ;
  size_t tmp___261 ;
  size_t _delta___1 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___262 ;
  char *tmp___263 ;
  char *tmp___264 ;
  char *tmp___265 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___266 ;
  size_t _incr___2 ;
  size_t tmp___267 ;
  size_t _delta___2 ;
  _Bool negative_year ;
  _Bool zero_thru_1899 ;
  int century ;
  int tmp___268 ;
  int tmp___269 ;
  char sign_char ;
  int tmp___270 ;
  int tmp___271 ;
  int numlen ;
  int shortage ;
  int padding ;
  int tmp___272 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___273 ;
  size_t _incr___3 ;
  size_t tmp___274 ;
  size_t _delta___3 ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___275 ;
  size_t _incr___4 ;
  size_t tmp___276 ;
  size_t _delta___4 ;
  int n ;
  int ns_digits ;
  int ndigs ;
  int j ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___277 ;
  size_t _incr___5 ;
  size_t tmp___278 ;
  size_t _delta___5 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___279 ;
  size_t _incr___6 ;
  size_t tmp___280 ;
  size_t _delta___6 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___281 ;
  size_t _incr___7 ;
  size_t tmp___282 ;
  size_t _delta___7 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___283 ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___284 ;
  size_t _incr___8 ;
  size_t tmp___285 ;
  size_t _delta___8 ;
  int year ;
  int tmp___286 ;
  int year_adjust ;
  int days ;
  int tmp___287 ;
  int tmp___288 ;
  int d___0 ;
  int tmp___289 ;
  int tmp___290 ;
  int yy ;
  int tmp___291 ;
  int yy___0 ;
  size_t _n___9 ;
  size_t tmp___292 ;
  size_t _w___9 ;
  int tmp___293 ;
  size_t _incr___9 ;
  size_t tmp___294 ;
  size_t _delta___9 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int tmp___295 ;
  int flen ;
  size_t _n___10 ;
  size_t _w___10 ;
  int tmp___296 ;
  size_t _incr___10 ;
  size_t tmp___297 ;
  size_t _delta___10 ;

  {
#line 459
  hour12 = (int )tp->tm_hour;
#line 498
  i = (size_t )0;
#line 499
  p = s;
#line 514
  zone = (char const   *)((void *)0);
#line 522
  zone = (char const   *)tp->tm_zone;
#line 552
  if (! zone) {
#line 553
    zone = "";
  }
#line 555
  if (hour12 > 12) {
#line 556
    hour12 -= 12;
  } else
#line 558
  if (hour12 == 0) {
#line 559
    hour12 = 12;
  }
#line 561
  f = format;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! ((int const   )*f != 0)) {
#line 561
      goto while_break;
    }
#line 563
    pad = 0;
#line 565
    digits = 0;
#line 578
    to_lowcase = (_Bool)0;
#line 579
    to_uppcase = upcase;
#line 581
    change_case = (_Bool)0;
#line 665
    if ((int const   )*f != 37) {
      {
#line 667
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 667
        _n = (size_t )1;
#line 667
        if (pad == 45) {
#line 667
          tmp = 0;
        } else
#line 667
        if (width < 0) {
#line 667
          tmp = 0;
        } else {
#line 667
          tmp = width;
        }
#line 667
        _w = (size_t )tmp;
#line 667
        if (_n < _w) {
#line 667
          tmp___0 = _w;
        } else {
#line 667
          tmp___0 = _n;
        }
#line 667
        _incr = tmp___0;
#line 667
        if (_incr >= maxsize - i) {
#line 667
          return ((size_t )0);
        }
#line 667
        if (p) {
#line 667
          if (_n < _w) {
#line 667
            _delta = _w - _n;
#line 667
            if (pad == 48) {
              {
#line 667
              memset((void *)p, '0', _delta);
#line 667
              p += _delta;
              }
            } else
#line 667
            if (pad == 43) {
              {
#line 667
              memset((void *)p, '0', _delta);
#line 667
              p += _delta;
              }
            } else {
              {
#line 667
              memset((void *)p, ' ', _delta);
#line 667
              p += _delta;
              }
            }
          }
#line 667
          *p = (char )*f;
#line 667
          p += _n;
        }
#line 667
        i += _incr;
#line 667
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 668
      goto __Cont;
    }
    {
#line 674
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 676
      f ++;
      {
#line 682
      if ((int const   )*f == 48) {
#line 682
        goto case_48;
      }
#line 682
      if ((int const   )*f == 43) {
#line 682
        goto case_48;
      }
#line 682
      if ((int const   )*f == 45) {
#line 682
        goto case_48;
      }
#line 682
      if ((int const   )*f == 95) {
#line 682
        goto case_48;
      }
#line 687
      if ((int const   )*f == 94) {
#line 687
        goto case_94;
      }
#line 690
      if ((int const   )*f == 35) {
#line 690
        goto case_35;
      }
#line 694
      goto switch_default;
      case_48: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 683
      pad = (int )*f;
#line 684
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 688
      to_uppcase = (_Bool)1;
#line 689
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 691
      change_case = (_Bool)1;
#line 692
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 695
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 697
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 700
    if ((unsigned int )*f - 48U <= 9U) {
#line 702
      width = 0;
      {
#line 703
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 705
        if (sizeof(width) == sizeof(signed char )) {
#line 705
          if (width < 0) {
#line 705
            if (~ (((1 << (sizeof(-128) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 705
              tmp___24 = -128 < - (((1 << (sizeof(-128) * 8UL - 2UL)) - 1) * 2 + 1);
            } else {
#line 705
              tmp___24 = 0;
            }
#line 705
            if (tmp___24) {
#line 705
              if (width == -1) {
#line 705
                tmp___23 = 0;
              } else {
#line 705
                tmp___23 = -128 / width < 10;
              }
            } else {
#line 705
              tmp___23 = -128 / width < 10;
            }
#line 705
            tmp___25 = tmp___23;
          } else {
#line 705
            tmp___25 = 12 < width;
          }
#line 705
          if (tmp___25) {
#line 705
            width = (int )((signed char )((unsigned int )width * 10U));
#line 705
            tmp___13 = 1;
          } else {
#line 705
            width = (int )((signed char )((unsigned int )width * 10U));
#line 705
            tmp___13 = 0;
          }
#line 705
          tmp___254 = tmp___13;
        } else {
#line 705
          if (sizeof(width) == sizeof(short )) {
#line 705
            if (width < 0) {
#line 705
              if (~ (((1 << (sizeof(-32768) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 705
                tmp___74 = -32768 < - (((1 << (sizeof(-32768) * 8UL - 2UL)) - 1) * 2 + 1);
              } else {
#line 705
                tmp___74 = 0;
              }
#line 705
              if (tmp___74) {
#line 705
                if (width == -1) {
#line 705
                  tmp___73 = 0;
                } else {
#line 705
                  tmp___73 = -32768 / width < 10;
                }
              } else {
#line 705
                tmp___73 = -32768 / width < 10;
              }
#line 705
              tmp___75 = tmp___73;
            } else {
#line 705
              tmp___75 = 3276 < width;
            }
#line 705
            if (tmp___75) {
#line 705
              width = (int )((short )((unsigned int )width * 10U));
#line 705
              tmp___63 = 1;
            } else {
#line 705
              width = (int )((short )((unsigned int )width * 10U));
#line 705
              tmp___63 = 0;
            }
#line 705
            tmp___253 = tmp___63;
          } else {
#line 705
            if (sizeof(width) == sizeof(int )) {
#line 705
              if (width < 0) {
#line 705
                if (~ (((1 << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 705
                  tmp___124 = (-0x7FFFFFFF-1) < - (((1 << (sizeof((-0x7FFFFFFF-1)) * 8UL - 2UL)) - 1) * 2 + 1);
                } else {
#line 705
                  tmp___124 = 0;
                }
#line 705
                if (tmp___124) {
#line 705
                  if (width == -1) {
#line 705
                    tmp___123 = 0;
                  } else {
#line 705
                    tmp___123 = (-0x7FFFFFFF-1) / width < 10;
                  }
                } else {
#line 705
                  tmp___123 = (-0x7FFFFFFF-1) / width < 10;
                }
#line 705
                tmp___125 = tmp___123;
              } else {
#line 705
                tmp___125 = 214748364 < width;
              }
#line 705
              if (tmp___125) {
#line 705
                width = (int )((unsigned int )width * 10U);
#line 705
                tmp___113 = 1;
              } else {
#line 705
                width = (int )((unsigned int )width * 10U);
#line 705
                tmp___113 = 0;
              }
#line 705
              tmp___252 = tmp___113;
            } else {
#line 705
              if (sizeof(width) == sizeof(long )) {
#line 705
                if (width < 0) {
#line 705
                  if (~ (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 705
                    tmp___174 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1L << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1L) * 2L + 1L);
                  } else {
#line 705
                    tmp___174 = 0;
                  }
#line 705
                  if (tmp___174) {
#line 705
                    if (width == -1) {
#line 705
                      tmp___173 = 0;
                    } else {
#line 705
                      tmp___173 = (-0x7FFFFFFFFFFFFFFF-1) / (long )width < 10L;
                    }
                  } else {
#line 705
                    tmp___173 = (-0x7FFFFFFFFFFFFFFF-1) / (long )width < 10L;
                  }
#line 705
                  tmp___175 = tmp___173;
                } else {
#line 705
                  tmp___175 = 922337203685477580L < (long )width;
                }
#line 705
                if (tmp___175) {
#line 705
                  width = (int )((long )((unsigned long )width * 10UL));
#line 705
                  tmp___163 = 1;
                } else {
#line 705
                  width = (int )((long )((unsigned long )width * 10UL));
#line 705
                  tmp___163 = 0;
                }
#line 705
                tmp___251 = tmp___163;
              } else {
#line 705
                if (width < 0) {
#line 705
                  if (~ (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 705
                    tmp___224 = (-0x7FFFFFFFFFFFFFFF-1) < - (((1LL << (sizeof((-0x7FFFFFFFFFFFFFFF-1)) * 8UL - 2UL)) - 1LL) * 2LL + 1LL);
                  } else {
#line 705
                    tmp___224 = 0;
                  }
#line 705
                  if (tmp___224) {
#line 705
                    if (width == -1) {
#line 705
                      tmp___223 = 0;
                    } else {
#line 705
                      tmp___223 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )width < 10LL;
                    }
                  } else {
#line 705
                    tmp___223 = (-0x7FFFFFFFFFFFFFFF-1) / (long long )width < 10LL;
                  }
#line 705
                  tmp___225 = tmp___223;
                } else {
#line 705
                  tmp___225 = 922337203685477580LL < (long long )width;
                }
#line 705
                if (tmp___225) {
#line 705
                  width = (int )((long long )((unsigned long long )width * 10ULL));
#line 705
                  tmp___213 = 1;
                } else {
#line 705
                  width = (int )((long long )((unsigned long long )width * 10ULL));
#line 705
                  tmp___213 = 0;
                }
#line 705
                tmp___251 = tmp___213;
              }
#line 705
              tmp___252 = tmp___251;
            }
#line 705
            tmp___253 = tmp___252;
          }
#line 705
          tmp___254 = tmp___253;
        }
#line 705
        if (tmp___254) {
#line 707
          width = 2147483647;
        } else {
          {
#line 705
          tmp___255 = __builtin_add_overflow(width, (int const   )*f - 48, & width);
          }
#line 705
          if (tmp___255) {
#line 707
            width = 2147483647;
          }
        }
#line 708
        f ++;
#line 703
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 703
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 717
    if ((int const   )*f == 79) {
#line 717
      goto case_79;
    }
#line 717
    if ((int const   )*f == 69) {
#line 717
      goto case_79;
    }
#line 721
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 718
    tmp___256 = f;
#line 718
    f ++;
#line 718
    modifier = (int )*tmp___256;
#line 719
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 722
    modifier = 0;
#line 723
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 727
    format_char = (int )*f;
    {
#line 773
    if (format_char == 37) {
#line 773
      goto case_37;
    }
#line 779
    if (format_char == 97) {
#line 779
      goto case_97;
    }
#line 794
    if (format_char == 65) {
#line 794
      goto case_65;
    }
#line 810
    if (format_char == 104) {
#line 810
      goto case_104;
    }
#line 810
    if (format_char == 98) {
#line 810
      goto case_104;
    }
#line 828
    if (format_char == 66) {
#line 828
      goto case_66;
    }
#line 846
    if (format_char == 99) {
#line 846
      goto case_99;
    }
#line 908
    if (format_char == 67) {
#line 908
      goto case_67;
    }
#line 937
    if (format_char == 120) {
#line 937
      goto case_120;
    }
#line 950
    if (format_char == 68) {
#line 950
      goto case_68;
    }
#line 956
    if (format_char == 100) {
#line 956
      goto case_100;
    }
#line 962
    if (format_char == 101) {
#line 962
      goto case_101;
    }
#line 1073
    if (format_char == 70) {
#line 1073
      goto case_70;
    }
#line 1090
    if (format_char == 72) {
#line 1090
      goto case_72;
    }
#line 1096
    if (format_char == 73) {
#line 1096
      goto case_73;
    }
#line 1102
    if (format_char == 107) {
#line 1102
      goto case_107;
    }
#line 1108
    if (format_char == 108) {
#line 1108
      goto case_108;
    }
#line 1114
    if (format_char == 106) {
#line 1114
      goto case_106;
    }
#line 1120
    if (format_char == 77) {
#line 1120
      goto case_77;
    }
#line 1126
    if (format_char == 109) {
#line 1126
      goto case_109;
    }
#line 1133
    if (format_char == 78) {
#line 1133
      goto case_78;
    }
#line 1153
    if (format_char == 110) {
#line 1153
      goto case_110;
    }
#line 1157
    if (format_char == 80) {
#line 1157
      goto case_80;
    }
#line 1163
    if (format_char == 112) {
#line 1163
      goto case_112;
    }
#line 1176
    if (format_char == 113) {
#line 1176
      goto case_113;
    }
#line 1180
    if (format_char == 82) {
#line 1180
      goto case_82;
    }
#line 1184
    if (format_char == 114) {
#line 1184
      goto case_114;
    }
#line 1195
    if (format_char == 83) {
#line 1195
      goto case_83;
    }
#line 1201
    if (format_char == 115) {
#line 1201
      goto case_115;
    }
#line 1228
    if (format_char == 88) {
#line 1228
      goto case_88;
    }
#line 1241
    if (format_char == 84) {
#line 1241
      goto case_84;
    }
#line 1245
    if (format_char == 116) {
#line 1245
      goto case_116;
    }
#line 1249
    if (format_char == 117) {
#line 1249
      goto case_117;
    }
#line 1252
    if (format_char == 85) {
#line 1252
      goto case_85;
    }
#line 1260
    if (format_char == 71) {
#line 1260
      goto case_71;
    }
#line 1260
    if (format_char == 103) {
#line 1260
      goto case_71;
    }
#line 1260
    if (format_char == 86) {
#line 1260
      goto case_71;
    }
#line 1317
    if (format_char == 87) {
#line 1317
      goto case_87;
    }
#line 1323
    if (format_char == 119) {
#line 1323
      goto case_119;
    }
#line 1329
    if (format_char == 89) {
#line 1329
      goto case_89;
    }
#line 1355
    if (format_char == 121) {
#line 1355
      goto case_121;
    }
#line 1380
    if (format_char == 90) {
#line 1380
      goto case_90;
    }
#line 1401
    if (format_char == 58) {
#line 1401
      goto case_58;
    }
#line 1411
    if (format_char == 122) {
#line 1411
      goto case_122;
    }
#line 1482
    if (format_char == 0) {
#line 1482
      goto case_0___0;
    }
#line 1485
    goto bad_format;
    case_37: /* CIL Label */ 
#line 774
    if (modifier != 0) {
#line 775
      goto bad_format;
    }
    {
#line 776
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 776
      _n___0 = (size_t )1;
#line 776
      if (pad == 45) {
#line 776
        tmp___257 = 0;
      } else
#line 776
      if (width < 0) {
#line 776
        tmp___257 = 0;
      } else {
#line 776
        tmp___257 = width;
      }
#line 776
      _w___0 = (size_t )tmp___257;
#line 776
      if (_n___0 < _w___0) {
#line 776
        tmp___258 = _w___0;
      } else {
#line 776
        tmp___258 = _n___0;
      }
#line 776
      _incr___0 = tmp___258;
#line 776
      if (_incr___0 >= maxsize - i) {
#line 776
        return ((size_t )0);
      }
#line 776
      if (p) {
#line 776
        if (_n___0 < _w___0) {
#line 776
          _delta___0 = _w___0 - _n___0;
#line 776
          if (pad == 48) {
            {
#line 776
            memset((void *)p, '0', _delta___0);
#line 776
            p += _delta___0;
            }
          } else
#line 776
          if (pad == 43) {
            {
#line 776
            memset((void *)p, '0', _delta___0);
#line 776
            p += _delta___0;
            }
          } else {
            {
#line 776
            memset((void *)p, ' ', _delta___0);
#line 776
            p += _delta___0;
            }
          }
        }
#line 776
        *p = (char )*f;
#line 776
        p += _n___0;
      }
#line 776
      i += _incr___0;
#line 776
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 777
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 780
    if (modifier != 0) {
#line 781
      goto bad_format;
    }
#line 782
    if (change_case) {
#line 784
      to_uppcase = (_Bool)1;
#line 785
      to_lowcase = (_Bool)0;
    }
#line 791
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 795
    if (modifier != 0) {
#line 796
      goto bad_format;
    }
#line 797
    if (change_case) {
#line 799
      to_uppcase = (_Bool)1;
#line 800
      to_lowcase = (_Bool)0;
    }
#line 806
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 811
    if (change_case) {
#line 813
      to_uppcase = (_Bool)1;
#line 814
      to_lowcase = (_Bool)0;
    }
#line 816
    if (modifier == 69) {
#line 817
      goto bad_format;
    }
#line 825
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 829
    if (modifier == 69) {
#line 830
      goto bad_format;
    }
#line 831
    if (change_case) {
#line 833
      to_uppcase = (_Bool)1;
#line 834
      to_lowcase = (_Bool)0;
    }
#line 843
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 847
    if (modifier == 79) {
#line 848
      goto bad_format;
    }
#line 857
    goto underlying_strftime;
    subformat: 
#line 861
    subwidth = -1;
    subformat_width: 
    {
#line 864
    tmp___259 = __strftime_internal((char *)((void *)0), (size_t )-1, subfmt, tp,
                                    to_uppcase, pad, subwidth, tzset_called, tz, ns);
#line 864
    len = tmp___259;
    }
    {
#line 868
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 868
      _n___1 = len;
#line 868
      if (pad == 45) {
#line 868
        tmp___260 = 0;
      } else
#line 868
      if (width < 0) {
#line 868
        tmp___260 = 0;
      } else {
#line 868
        tmp___260 = width;
      }
#line 868
      _w___1 = (size_t )tmp___260;
#line 868
      if (_n___1 < _w___1) {
#line 868
        tmp___261 = _w___1;
      } else {
#line 868
        tmp___261 = _n___1;
      }
#line 868
      _incr___1 = tmp___261;
#line 868
      if (_incr___1 >= maxsize - i) {
#line 868
        return ((size_t )0);
      }
#line 868
      if (p) {
#line 868
        if (_n___1 < _w___1) {
#line 868
          _delta___1 = _w___1 - _n___1;
#line 868
          if (pad == 48) {
            {
#line 868
            memset((void *)p, '0', _delta___1);
#line 868
            p += _delta___1;
            }
          } else
#line 868
          if (pad == 43) {
            {
#line 868
            memset((void *)p, '0', _delta___1);
#line 868
            p += _delta___1;
            }
          } else {
            {
#line 868
            memset((void *)p, ' ', _delta___1);
#line 868
            p += _delta___1;
            }
          }
        }
        {
#line 868
        __strftime_internal(p, maxsize - i, subfmt, tp, to_uppcase, pad, subwidth,
                            tzset_called, tz, ns);
#line 868
        p += _n___1;
        }
      }
#line 868
      i += _incr___1;
#line 868
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 874
    goto switch_break___1;
    underlying_strftime: 
#line 882
    u = ufmt;
#line 895
    tmp___262 = u;
#line 895
    u ++;
#line 895
    *tmp___262 = (char )' ';
#line 896
    tmp___263 = u;
#line 896
    u ++;
#line 896
    *tmp___263 = (char )'%';
#line 897
    if (modifier != 0) {
#line 898
      tmp___264 = u;
#line 898
      u ++;
#line 898
      *tmp___264 = (char )modifier;
    }
    {
#line 899
    tmp___265 = u;
#line 899
    u ++;
#line 899
    *tmp___265 = (char )format_char;
#line 900
    *u = (char )'\000';
#line 901
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 902
    if (len___0 != 0UL) {
      {
#line 903
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 903
        _n___2 = len___0 - 1UL;
#line 903
        if (pad == 45) {
#line 903
          tmp___266 = 0;
        } else
#line 903
        if (width < 0) {
#line 903
          tmp___266 = 0;
        } else {
#line 903
          tmp___266 = width;
        }
#line 903
        _w___2 = (size_t )tmp___266;
#line 903
        if (_n___2 < _w___2) {
#line 903
          tmp___267 = _w___2;
        } else {
#line 903
          tmp___267 = _n___2;
        }
#line 903
        _incr___2 = tmp___267;
#line 903
        if (_incr___2 >= maxsize - i) {
#line 903
          return ((size_t )0);
        }
#line 903
        if (p) {
#line 903
          if (_n___2 < _w___2) {
#line 903
            _delta___2 = _w___2 - _n___2;
#line 903
            if (pad == 48) {
              {
#line 903
              memset((void *)p, '0', _delta___2);
#line 903
              p += _delta___2;
              }
            } else
#line 903
            if (pad == 43) {
              {
#line 903
              memset((void *)p, '0', _delta___2);
#line 903
              p += _delta___2;
              }
            } else {
              {
#line 903
              memset((void *)p, ' ', _delta___2);
#line 903
              p += _delta___2;
              }
            }
          }
#line 903
          if (to_lowcase) {
            {
#line 903
            memcpy_lowcase(p, (char const   *)(ubuf + 1), _n___2);
            }
          } else
#line 903
          if (to_uppcase) {
            {
#line 903
            memcpy_uppcase(p, (char const   *)(ubuf + 1), _n___2);
            }
          } else {
            {
#line 903
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   _n___2);
            }
          }
#line 903
          p += _n___2;
        }
#line 903
        i += _incr___2;
#line 903
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 905
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 909
    if (modifier == 69) {
#line 925
      goto underlying_strftime;
    }
#line 930
    negative_year = (_Bool )(tp->tm_year < -1900);
#line 931
    zero_thru_1899 = (_Bool )(! negative_year & (tp->tm_year < 0));
#line 932
    century = (int )((tp->tm_year - (int const   )(99 * (int )zero_thru_1899)) / 100 + 19);
    {
#line 934
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 934
      digits = 2;
#line 934
      negative_number = negative_year;
#line 934
      u_number_value = (unsigned int )century;
#line 934
      goto do_yearish;
#line 934
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    case_120: /* CIL Label */ 
#line 938
    if (modifier == 79) {
#line 939
      goto bad_format;
    }
#line 948
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 951
    if (modifier != 0) {
#line 952
      goto bad_format;
    }
#line 953
    subfmt = "%m/%d/%y";
#line 954
    goto subformat;
    case_100: /* CIL Label */ 
#line 957
    if (modifier == 69) {
#line 958
      goto bad_format;
    }
    {
#line 960
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 960
      digits = 2;
#line 960
      number_value = (int )tp->tm_mday;
#line 960
      goto do_number;
#line 960
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    case_101: /* CIL Label */ 
#line 963
    if (modifier == 69) {
#line 964
      goto bad_format;
    }
    {
#line 966
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 966
      digits = 2;
#line 966
      number_value = (int )tp->tm_mday;
#line 966
      goto do_number_spacepad;
#line 966
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    do_tz_offset: 
#line 972
    always_output_a_sign = (_Bool)1;
#line 973
    goto do_number_body;
    do_yearish: 
#line 976
    if (pad == 0) {
#line 977
      pad = yr_spec;
    }
#line 978
    if (pad == 43) {
#line 978
      if (digits == 2) {
#line 978
        tmp___268 = 99;
      } else {
#line 978
        tmp___268 = 9999;
      }
#line 978
      if ((unsigned int )tmp___268 < u_number_value) {
#line 978
        tmp___269 = 1;
      } else
#line 978
      if (digits < width) {
#line 978
        tmp___269 = 1;
      } else {
#line 978
        tmp___269 = 0;
      }
    } else {
#line 978
      tmp___269 = 0;
    }
#line 978
    always_output_a_sign = (_Bool )tmp___269;
#line 982
    goto do_maybe_signed_number;
    do_number_spacepad: 
#line 985
    if (pad == 0) {
#line 986
      pad = '_';
    }
    do_number: 
#line 990
    negative_number = (_Bool )(number_value < 0);
#line 991
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 994
    always_output_a_sign = (_Bool)0;
    do_maybe_signed_number: 
#line 997
    tz_colon_mask = 0;
    do_number_body: 
#line 1005
    if (modifier == 79) {
#line 1005
      if (! negative_number) {
#line 1023
        goto underlying_strftime;
      }
    }
#line 1027
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 1029
    if (negative_number) {
#line 1030
      u_number_value = - u_number_value;
    }
    {
#line 1032
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1034
      if (tz_colon_mask & 1) {
#line 1035
        bufp --;
#line 1035
        *bufp = (char )':';
      }
#line 1036
      tz_colon_mask >>= 1;
#line 1037
      bufp --;
#line 1037
      *bufp = (char )(u_number_value % 10U + 48U);
#line 1038
      u_number_value /= 10U;
#line 1032
      if (! (u_number_value != 0U)) {
#line 1032
        if (! (tz_colon_mask != 0)) {
#line 1032
          goto while_break___9;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 1043
    if (pad == 0) {
#line 1044
      pad = '0';
    }
#line 1045
    if (width < 0) {
#line 1046
      width = digits;
    }
#line 1049
    if (negative_number) {
#line 1049
      tmp___271 = '-';
    } else {
#line 1049
      if (always_output_a_sign) {
#line 1049
        tmp___270 = '+';
      } else {
#line 1049
        tmp___270 = 0;
      }
#line 1049
      tmp___271 = tmp___270;
    }
#line 1049
    sign_char = (char )tmp___271;
#line 1052
    numlen = (int )((buf + sizeof(buf) / sizeof(buf[0])) - bufp);
#line 1053
    shortage = (width - ! (! sign_char)) - numlen;
#line 1054
    if (pad == 45) {
#line 1054
      tmp___272 = 0;
    } else
#line 1054
    if (shortage <= 0) {
#line 1054
      tmp___272 = 0;
    } else {
#line 1054
      tmp___272 = shortage;
    }
#line 1054
    padding = tmp___272;
#line 1056
    if (sign_char) {
#line 1058
      if (pad == 95) {
#line 1060
        if (p) {
          {
#line 1061
          memset((void *)p, ' ', (size_t )padding);
#line 1061
          p += padding;
          }
        }
#line 1062
        i += (size_t )padding;
#line 1063
        width -= padding;
      }
      {
#line 1065
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1065
        _n___3 = (size_t )1;
#line 1065
        if (pad == 45) {
#line 1065
          tmp___273 = 0;
        } else {
#line 1065
          tmp___273 = 0;
        }
#line 1065
        _w___3 = (size_t )tmp___273;
#line 1065
        if (_n___3 < _w___3) {
#line 1065
          tmp___274 = _w___3;
        } else {
#line 1065
          tmp___274 = _n___3;
        }
#line 1065
        _incr___3 = tmp___274;
#line 1065
        if (_incr___3 >= maxsize - i) {
#line 1065
          return ((size_t )0);
        }
#line 1065
        if (p) {
#line 1065
          if (_n___3 < _w___3) {
#line 1065
            _delta___3 = _w___3 - _n___3;
#line 1065
            if (pad == 48) {
              {
#line 1065
              memset((void *)p, '0', _delta___3);
#line 1065
              p += _delta___3;
              }
            } else
#line 1065
            if (pad == 43) {
              {
#line 1065
              memset((void *)p, '0', _delta___3);
#line 1065
              p += _delta___3;
              }
            } else {
              {
#line 1065
              memset((void *)p, ' ', _delta___3);
#line 1065
              p += _delta___3;
              }
            }
          }
#line 1065
          *p = sign_char;
#line 1065
          p += _n___3;
        }
#line 1065
        i += _incr___3;
#line 1065
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1066
      width --;
    }
    {
#line 1069
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1069
      _n___4 = (size_t )numlen;
#line 1069
      if (pad == 45) {
#line 1069
        tmp___275 = 0;
      } else
#line 1069
      if (width < 0) {
#line 1069
        tmp___275 = 0;
      } else {
#line 1069
        tmp___275 = width;
      }
#line 1069
      _w___4 = (size_t )tmp___275;
#line 1069
      if (_n___4 < _w___4) {
#line 1069
        tmp___276 = _w___4;
      } else {
#line 1069
        tmp___276 = _n___4;
      }
#line 1069
      _incr___4 = tmp___276;
#line 1069
      if (_incr___4 >= maxsize - i) {
#line 1069
        return ((size_t )0);
      }
#line 1069
      if (p) {
#line 1069
        if (_n___4 < _w___4) {
#line 1069
          _delta___4 = _w___4 - _n___4;
#line 1069
          if (pad == 48) {
            {
#line 1069
            memset((void *)p, '0', _delta___4);
#line 1069
            p += _delta___4;
            }
          } else
#line 1069
          if (pad == 43) {
            {
#line 1069
            memset((void *)p, '0', _delta___4);
#line 1069
            p += _delta___4;
            }
          } else {
            {
#line 1069
            memset((void *)p, ' ', _delta___4);
#line 1069
            p += _delta___4;
            }
          }
        }
#line 1069
        if (to_lowcase) {
          {
#line 1069
          memcpy_lowcase(p, (char const   *)bufp, _n___4);
          }
        } else
#line 1069
        if (to_uppcase) {
          {
#line 1069
          memcpy_uppcase(p, (char const   *)bufp, _n___4);
          }
        } else {
          {
#line 1069
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 _n___4);
          }
        }
#line 1069
        p += _n___4;
      }
#line 1069
      i += _incr___4;
#line 1069
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1071
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 1074
    if (modifier != 0) {
#line 1075
      goto bad_format;
    }
#line 1076
    if (pad == 0) {
#line 1076
      if (width < 0) {
#line 1078
        pad = '+';
#line 1079
        subwidth = 4;
      } else {
#line 1076
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1083
      subwidth = width - 6;
#line 1084
      if (subwidth < 0) {
#line 1085
        subwidth = 0;
      }
    }
#line 1087
    subfmt = "%Y-%m-%d";
#line 1088
    goto subformat_width;
    case_72: /* CIL Label */ 
#line 1091
    if (modifier == 69) {
#line 1092
      goto bad_format;
    }
    {
#line 1094
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1094
      digits = 2;
#line 1094
      number_value = (int )tp->tm_hour;
#line 1094
      goto do_number;
#line 1094
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    case_73: /* CIL Label */ 
#line 1097
    if (modifier == 69) {
#line 1098
      goto bad_format;
    }
    {
#line 1100
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1100
      digits = 2;
#line 1100
      number_value = hour12;
#line 1100
      goto do_number;
#line 1100
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    case_107: /* CIL Label */ 
#line 1103
    if (modifier == 69) {
#line 1104
      goto bad_format;
    }
    {
#line 1106
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1106
      digits = 2;
#line 1106
      number_value = (int )tp->tm_hour;
#line 1106
      goto do_number_spacepad;
#line 1106
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    case_108: /* CIL Label */ 
#line 1109
    if (modifier == 69) {
#line 1110
      goto bad_format;
    }
    {
#line 1112
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1112
      digits = 2;
#line 1112
      number_value = hour12;
#line 1112
      goto do_number_spacepad;
#line 1112
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    case_106: /* CIL Label */ 
#line 1115
    if (modifier == 69) {
#line 1116
      goto bad_format;
    }
    {
#line 1118
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1118
      digits = 3;
#line 1118
      negative_number = (_Bool )(tp->tm_yday < -1);
#line 1118
      u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1118
      goto do_signed_number;
#line 1118
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    case_77: /* CIL Label */ 
#line 1121
    if (modifier == 69) {
#line 1122
      goto bad_format;
    }
    {
#line 1124
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1124
      digits = 2;
#line 1124
      number_value = (int )tp->tm_min;
#line 1124
      goto do_number;
#line 1124
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    case_109: /* CIL Label */ 
#line 1127
    if (modifier == 69) {
#line 1128
      goto bad_format;
    }
    {
#line 1130
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1130
      digits = 2;
#line 1130
      negative_number = (_Bool )(tp->tm_mon < -1);
#line 1130
      u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1130
      goto do_signed_number;
#line 1130
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    case_78: /* CIL Label */ 
#line 1134
    if (modifier == 69) {
#line 1135
      goto bad_format;
    }
#line 1137
    n = ns;
#line 1137
    ns_digits = 9;
#line 1138
    if (width <= 0) {
#line 1139
      width = ns_digits;
    }
#line 1140
    ndigs = ns_digits;
    {
#line 1141
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1141
      if (! (width < ndigs)) {
#line 1141
        if (1 < ndigs) {
#line 1141
          if (! (n % 10 == 0)) {
#line 1141
            goto while_break___19;
          }
        } else {
#line 1141
          goto while_break___19;
        }
      }
#line 1142
      ndigs --;
#line 1142
      n /= 10;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1143
    j = ndigs;
    {
#line 1143
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1143
      if (! (0 < j)) {
#line 1143
        goto while_break___20;
      }
#line 1144
      buf[j - 1] = (char )(n % 10 + 48);
#line 1144
      n /= 10;
#line 1143
      j --;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 1145
    if (! pad) {
#line 1146
      pad = '0';
    }
    {
#line 1147
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1147
      _n___5 = (size_t )ndigs;
#line 1147
      if (pad == 45) {
#line 1147
        tmp___277 = 0;
      } else {
#line 1147
        tmp___277 = 0;
      }
#line 1147
      _w___5 = (size_t )tmp___277;
#line 1147
      if (_n___5 < _w___5) {
#line 1147
        tmp___278 = _w___5;
      } else {
#line 1147
        tmp___278 = _n___5;
      }
#line 1147
      _incr___5 = tmp___278;
#line 1147
      if (_incr___5 >= maxsize - i) {
#line 1147
        return ((size_t )0);
      }
#line 1147
      if (p) {
#line 1147
        if (_n___5 < _w___5) {
#line 1147
          _delta___5 = _w___5 - _n___5;
#line 1147
          if (pad == 48) {
            {
#line 1147
            memset((void *)p, '0', _delta___5);
#line 1147
            p += _delta___5;
            }
          } else
#line 1147
          if (pad == 43) {
            {
#line 1147
            memset((void *)p, '0', _delta___5);
#line 1147
            p += _delta___5;
            }
          } else {
            {
#line 1147
            memset((void *)p, ' ', _delta___5);
#line 1147
            p += _delta___5;
            }
          }
        }
#line 1147
        if (to_lowcase) {
          {
#line 1147
          memcpy_lowcase(p, (char const   *)(buf), _n___5);
          }
        } else
#line 1147
        if (to_uppcase) {
          {
#line 1147
          memcpy_uppcase(p, (char const   *)(buf), _n___5);
          }
        } else {
          {
#line 1147
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(buf)),
                 _n___5);
          }
        }
#line 1147
        p += _n___5;
      }
#line 1147
      i += _incr___5;
#line 1147
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 1148
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1148
      _n___6 = (size_t )0;
#line 1148
      if (pad == 45) {
#line 1148
        tmp___279 = 0;
      } else
#line 1148
      if (width - ndigs < 0) {
#line 1148
        tmp___279 = 0;
      } else {
#line 1148
        tmp___279 = width - ndigs;
      }
#line 1148
      _w___6 = (size_t )tmp___279;
#line 1148
      if (_n___6 < _w___6) {
#line 1148
        tmp___280 = _w___6;
      } else {
#line 1148
        tmp___280 = _n___6;
      }
#line 1148
      _incr___6 = tmp___280;
#line 1148
      if (_incr___6 >= maxsize - i) {
#line 1148
        return ((size_t )0);
      }
#line 1148
      if (p) {
#line 1148
        if (_n___6 < _w___6) {
#line 1148
          _delta___6 = _w___6 - _n___6;
#line 1148
          if (pad == 48) {
            {
#line 1148
            memset((void *)p, '0', _delta___6);
#line 1148
            p += _delta___6;
            }
          } else
#line 1148
          if (pad == 43) {
            {
#line 1148
            memset((void *)p, '0', _delta___6);
#line 1148
            p += _delta___6;
            }
          } else {
            {
#line 1148
            memset((void *)p, ' ', _delta___6);
#line 1148
            p += _delta___6;
            }
          }
        }
#line 1148
        p += _n___6;
      }
#line 1148
      i += _incr___6;
#line 1148
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 1150
    goto switch_break___1;
    case_110: /* CIL Label */ 
    {
#line 1154
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1154
      _n___7 = (size_t )1;
#line 1154
      if (pad == 45) {
#line 1154
        tmp___281 = 0;
      } else
#line 1154
      if (width < 0) {
#line 1154
        tmp___281 = 0;
      } else {
#line 1154
        tmp___281 = width;
      }
#line 1154
      _w___7 = (size_t )tmp___281;
#line 1154
      if (_n___7 < _w___7) {
#line 1154
        tmp___282 = _w___7;
      } else {
#line 1154
        tmp___282 = _n___7;
      }
#line 1154
      _incr___7 = tmp___282;
#line 1154
      if (_incr___7 >= maxsize - i) {
#line 1154
        return ((size_t )0);
      }
#line 1154
      if (p) {
#line 1154
        if (_n___7 < _w___7) {
#line 1154
          _delta___7 = _w___7 - _n___7;
#line 1154
          if (pad == 48) {
            {
#line 1154
            memset((void *)p, '0', _delta___7);
#line 1154
            p += _delta___7;
            }
          } else
#line 1154
          if (pad == 43) {
            {
#line 1154
            memset((void *)p, '0', _delta___7);
#line 1154
            p += _delta___7;
            }
          } else {
            {
#line 1154
            memset((void *)p, ' ', _delta___7);
#line 1154
            p += _delta___7;
            }
          }
        }
#line 1154
        *p = (char )'\n';
#line 1154
        p += _n___7;
      }
#line 1154
      i += _incr___7;
#line 1154
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
#line 1155
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1158
    to_lowcase = (_Bool)1;
#line 1160
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1164
    if (change_case) {
#line 1166
      to_uppcase = (_Bool)0;
#line 1167
      to_lowcase = (_Bool)1;
    }
#line 1173
    goto underlying_strftime;
    case_113: /* CIL Label */ 
    {
#line 1177
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 1177
      digits = 1;
#line 1177
      negative_number = (_Bool)0;
#line 1177
      u_number_value = (unsigned int )((tp->tm_mon * 11 >> 5) + 1);
#line 1177
      goto do_signed_number;
#line 1177
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 1178
    goto switch_break___1;
    case_82: /* CIL Label */ 
#line 1181
    subfmt = "%H:%M";
#line 1182
    goto subformat;
    case_114: /* CIL Label */ 
#line 1192
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1196
    if (modifier == 69) {
#line 1197
      goto bad_format;
    }
    {
#line 1199
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 1199
      digits = 2;
#line 1199
      number_value = (int )tp->tm_sec;
#line 1199
      goto do_number;
#line 1199
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    case_115: /* CIL Label */ 
    {
#line 1206
    ltm = (struct tm )*tp;
#line 1207
    t = mktime_z(tz, (struct tm */* __restrict  */)(& ltm));
#line 1212
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 1213
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1215
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 1217
      d = (int )(t % 10L);
#line 1218
      t /= 10L;
#line 1219
      bufp --;
#line 1219
      if (negative_number) {
#line 1219
        tmp___283 = - d;
      } else {
#line 1219
        tmp___283 = d;
      }
#line 1219
      *bufp = (char )(tmp___283 + 48);
#line 1215
      if (! (t != 0L)) {
#line 1215
        goto while_break___26;
      }
    }
    while_break___26: /* CIL Label */ ;
    }
#line 1223
    digits = 1;
#line 1224
    always_output_a_sign = (_Bool)0;
#line 1225
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1229
    if (modifier == 79) {
#line 1230
      goto bad_format;
    }
#line 1239
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1242
    subfmt = "%H:%M:%S";
#line 1243
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1246
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 1246
      _n___8 = (size_t )1;
#line 1246
      if (pad == 45) {
#line 1246
        tmp___284 = 0;
      } else
#line 1246
      if (width < 0) {
#line 1246
        tmp___284 = 0;
      } else {
#line 1246
        tmp___284 = width;
      }
#line 1246
      _w___8 = (size_t )tmp___284;
#line 1246
      if (_n___8 < _w___8) {
#line 1246
        tmp___285 = _w___8;
      } else {
#line 1246
        tmp___285 = _n___8;
      }
#line 1246
      _incr___8 = tmp___285;
#line 1246
      if (_incr___8 >= maxsize - i) {
#line 1246
        return ((size_t )0);
      }
#line 1246
      if (p) {
#line 1246
        if (_n___8 < _w___8) {
#line 1246
          _delta___8 = _w___8 - _n___8;
#line 1246
          if (pad == 48) {
            {
#line 1246
            memset((void *)p, '0', _delta___8);
#line 1246
            p += _delta___8;
            }
          } else
#line 1246
          if (pad == 43) {
            {
#line 1246
            memset((void *)p, '0', _delta___8);
#line 1246
            p += _delta___8;
            }
          } else {
            {
#line 1246
            memset((void *)p, ' ', _delta___8);
#line 1246
            p += _delta___8;
            }
          }
        }
#line 1246
        *p = (char )'\t';
#line 1246
        p += _n___8;
      }
#line 1246
      i += _incr___8;
#line 1246
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 1247
    goto switch_break___1;
    case_117: /* CIL Label */ 
    {
#line 1250
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1250
      digits = 1;
#line 1250
      number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1250
      goto do_number;
#line 1250
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    case_85: /* CIL Label */ 
#line 1253
    if (modifier == 69) {
#line 1254
      goto bad_format;
    }
    {
#line 1256
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 1256
      digits = 2;
#line 1256
      number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1256
      goto do_number;
#line 1256
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1261
    if (modifier == 69) {
#line 1262
      goto bad_format;
    }
#line 1268
    if (tp->tm_year < 0) {
#line 1268
      tmp___286 = 300;
    } else {
#line 1268
      tmp___286 = -100;
    }
    {
#line 1268
    year = (int )(tp->tm_year + (int const   )tmp___286);
#line 1272
    year_adjust = 0;
#line 1273
    tmp___287 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1273
    days = tmp___287;
    }
#line 1275
    if (days < 0) {
#line 1278
      year_adjust = -1;
#line 1279
      if ((year - 1) % 4 == 0) {
#line 1279
        if ((year - 1) % 100 != 0) {
#line 1279
          tmp___288 = 1;
        } else
#line 1279
        if ((year - 1) % 400 == 0) {
#line 1279
          tmp___288 = 1;
        } else {
#line 1279
          tmp___288 = 0;
        }
      } else {
#line 1279
        tmp___288 = 0;
      }
      {
#line 1279
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___288)),
                           (int )tp->tm_wday);
      }
    } else {
#line 1284
      if (year % 4 == 0) {
#line 1284
        if (year % 100 != 0) {
#line 1284
          tmp___289 = 1;
        } else
#line 1284
        if (year % 400 == 0) {
#line 1284
          tmp___289 = 1;
        } else {
#line 1284
          tmp___289 = 0;
        }
      } else {
#line 1284
        tmp___289 = 0;
      }
      {
#line 1284
      tmp___290 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___289)),
                                (int )tp->tm_wday);
#line 1284
      d___0 = tmp___290;
      }
#line 1286
      if (0 <= d___0) {
#line 1289
        year_adjust = 1;
#line 1290
        days = d___0;
      }
    }
    {
#line 1296
    if ((int const   )*f == 103) {
#line 1296
      goto case_103___0;
    }
#line 1307
    if ((int const   )*f == 71) {
#line 1307
      goto case_71___0;
    }
#line 1312
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1298
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
    {
#line 1299
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 1299
      digits = 2;
#line 1299
      negative_number = (_Bool)0;
#line 1299
      if (0 <= yy) {
#line 1299
        u_number_value = (unsigned int )yy;
      } else {
#line 1299
        if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1299
          tmp___291 = - yy;
        } else {
#line 1299
          tmp___291 = yy + 100;
        }
#line 1299
        u_number_value = (unsigned int )tmp___291;
      }
#line 1299
      goto do_yearish;
#line 1299
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    case_71___0: /* CIL Label */ 
    {
#line 1308
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1308
      digits = 4;
#line 1308
      negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1308
      u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1308
      goto do_yearish;
#line 1308
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    switch_default___1: /* CIL Label */ 
    {
#line 1313
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 1313
      digits = 2;
#line 1313
      number_value = days / 7 + 1;
#line 1313
      goto do_number;
#line 1313
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1318
    if (modifier == 69) {
#line 1319
      goto bad_format;
    }
    {
#line 1321
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 1321
      digits = 2;
#line 1321
      number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1321
      goto do_number;
#line 1321
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    case_119: /* CIL Label */ 
#line 1324
    if (modifier == 69) {
#line 1325
      goto bad_format;
    }
    {
#line 1327
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 1327
      digits = 1;
#line 1327
      number_value = (int )tp->tm_wday;
#line 1327
      goto do_number;
#line 1327
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    case_89: /* CIL Label */ 
#line 1330
    if (modifier == 69) {
#line 1346
      goto underlying_strftime;
    }
#line 1349
    if (modifier == 79) {
#line 1350
      goto bad_format;
    }
    {
#line 1352
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 1352
      digits = 4;
#line 1352
      negative_number = (_Bool )(tp->tm_year < -1900);
#line 1352
      u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1352
      goto do_yearish;
#line 1352
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    case_121: /* CIL Label */ 
#line 1356
    if (modifier == 69) {
#line 1369
      goto underlying_strftime;
    }
#line 1374
    yy___0 = (int )(tp->tm_year % 100);
#line 1375
    if (yy___0 < 0) {
#line 1376
      if (tp->tm_year < -1900) {
#line 1376
        yy___0 = - yy___0;
      } else {
#line 1376
        yy___0 += 100;
      }
    }
    {
#line 1377
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 1377
      digits = 2;
#line 1377
      negative_number = (_Bool)0;
#line 1377
      u_number_value = (unsigned int )yy___0;
#line 1377
      goto do_yearish;
#line 1377
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    case_90: /* CIL Label */ 
#line 1381
    if (change_case) {
#line 1383
      to_uppcase = (_Bool)0;
#line 1384
      to_lowcase = (_Bool)1;
    }
    {
#line 1397
    while (1) {
      while_continue___37: /* CIL Label */ ;
      {
#line 1397
      tmp___292 = strlen(zone);
#line 1397
      _n___9 = tmp___292;
      }
#line 1397
      if (pad == 45) {
#line 1397
        tmp___293 = 0;
      } else
#line 1397
      if (width < 0) {
#line 1397
        tmp___293 = 0;
      } else {
#line 1397
        tmp___293 = width;
      }
#line 1397
      _w___9 = (size_t )tmp___293;
#line 1397
      if (_n___9 < _w___9) {
#line 1397
        tmp___294 = _w___9;
      } else {
#line 1397
        tmp___294 = _n___9;
      }
#line 1397
      _incr___9 = tmp___294;
#line 1397
      if (_incr___9 >= maxsize - i) {
#line 1397
        return ((size_t )0);
      }
#line 1397
      if (p) {
#line 1397
        if (_n___9 < _w___9) {
#line 1397
          _delta___9 = _w___9 - _n___9;
#line 1397
          if (pad == 48) {
            {
#line 1397
            memset((void *)p, '0', _delta___9);
#line 1397
            p += _delta___9;
            }
          } else
#line 1397
          if (pad == 43) {
            {
#line 1397
            memset((void *)p, '0', _delta___9);
#line 1397
            p += _delta___9;
            }
          } else {
            {
#line 1397
            memset((void *)p, ' ', _delta___9);
#line 1397
            p += _delta___9;
            }
          }
        }
#line 1397
        if (to_lowcase) {
          {
#line 1397
          memcpy_lowcase(p, zone, _n___9);
          }
        } else
#line 1397
        if (to_uppcase) {
          {
#line 1397
          memcpy_uppcase(p, zone, _n___9);
          }
        } else {
          {
#line 1397
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 _n___9);
          }
        }
#line 1397
        p += _n___9;
      }
#line 1397
      i += _incr___9;
#line 1397
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
#line 1399
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1404
    colons = (size_t )1;
    {
#line 1404
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 1404
      if (! ((int const   )*(f + colons) == 58)) {
#line 1404
        goto while_break___38;
      }
#line 1405
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1404
      colons ++;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 1406
    if ((int const   )*(f + colons) != 122) {
#line 1407
      goto bad_format;
    }
#line 1408
    f += colons;
#line 1409
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1412
    colons = (size_t )0;
    do_z_conversion: 
#line 1415
    if (tp->tm_isdst < 0) {
#line 1416
      goto switch_break___1;
    }
#line 1424
    diff = (int )tp->tm_gmtoff;
#line 1453
    if (diff < 0) {
#line 1453
      tmp___295 = 1;
    } else
#line 1453
    if (diff == 0) {
#line 1453
      if ((int const   )*zone == 45) {
#line 1453
        tmp___295 = 1;
      } else {
#line 1453
        tmp___295 = 0;
      }
    } else {
#line 1453
      tmp___295 = 0;
    }
#line 1453
    negative_number = (_Bool )tmp___295;
#line 1454
    hour_diff = (diff / 60) / 60;
#line 1455
    min_diff = (diff / 60) % 60;
#line 1456
    sec_diff = diff % 60;
    {
#line 1460
    if (colons == 0UL) {
#line 1460
      goto case_0;
    }
#line 1463
    if (colons == 1UL) {
#line 1463
      goto tz_hh_mm;
    }
#line 1466
    if (colons == 2UL) {
#line 1466
      goto tz_hh_mm_ss;
    }
#line 1470
    if (colons == 3UL) {
#line 1470
      goto case_3;
    }
#line 1477
    goto switch_default___2;
    case_0: /* CIL Label */ 
    {
#line 1461
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 1461
      digits = 5;
#line 1461
      tz_colon_mask = 0;
#line 1461
      u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1461
      goto do_tz_offset;
#line 1461
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    tz_hh_mm: 
    case_1: /* CIL Label */ 
    {
#line 1464
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 1464
      digits = 6;
#line 1464
      tz_colon_mask = 4;
#line 1464
      u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1464
      goto do_tz_offset;
#line 1464
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
    {
#line 1467
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 1467
      digits = 9;
#line 1467
      tz_colon_mask = 20;
#line 1467
      u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1467
      goto do_tz_offset;
#line 1467
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    case_3: /* CIL Label */ 
#line 1471
    if (sec_diff != 0) {
#line 1472
      goto tz_hh_mm_ss;
    }
#line 1473
    if (min_diff != 0) {
#line 1474
      goto tz_hh_mm;
    }
    {
#line 1475
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 1475
      digits = 3;
#line 1475
      tz_colon_mask = 0;
#line 1475
      u_number_value = (unsigned int )hour_diff;
#line 1475
      goto do_tz_offset;
#line 1475
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    switch_default___2: /* CIL Label */ 
#line 1478
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1483
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1492
    flen = 1;
    {
#line 1492
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 1492
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1492
        goto while_break___43;
      }
#line 1493
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1492
      flen ++;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 1494
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 1494
      _n___10 = (size_t )flen;
#line 1494
      if (pad == 45) {
#line 1494
        tmp___296 = 0;
      } else
#line 1494
      if (width < 0) {
#line 1494
        tmp___296 = 0;
      } else {
#line 1494
        tmp___296 = width;
      }
#line 1494
      _w___10 = (size_t )tmp___296;
#line 1494
      if (_n___10 < _w___10) {
#line 1494
        tmp___297 = _w___10;
      } else {
#line 1494
        tmp___297 = _n___10;
      }
#line 1494
      _incr___10 = tmp___297;
#line 1494
      if (_incr___10 >= maxsize - i) {
#line 1494
        return ((size_t )0);
      }
#line 1494
      if (p) {
#line 1494
        if (_n___10 < _w___10) {
#line 1494
          _delta___10 = _w___10 - _n___10;
#line 1494
          if (pad == 48) {
            {
#line 1494
            memset((void *)p, '0', _delta___10);
#line 1494
            p += _delta___10;
            }
          } else
#line 1494
          if (pad == 43) {
            {
#line 1494
            memset((void *)p, '0', _delta___10);
#line 1494
            p += _delta___10;
            }
          } else {
            {
#line 1494
            memset((void *)p, ' ', _delta___10);
#line 1494
            p += _delta___10;
            }
          }
        }
#line 1494
        if (to_lowcase) {
          {
#line 1494
          memcpy_lowcase(p, f + (1 - flen), _n___10);
          }
        } else
#line 1494
        if (to_uppcase) {
          {
#line 1494
          memcpy_uppcase(p, f + (1 - flen), _n___10);
          }
        } else {
          {
#line 1494
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 _n___10);
          }
        }
#line 1494
        p += _n___10;
      }
#line 1494
      i += _incr___10;
#line 1494
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
#line 1496
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 561
    width = -1;
#line 561
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1501
  if (p) {
#line 1501
    if (maxsize != 0UL) {
#line 1502
      *p = (char )'\000';
    }
  }
#line 1505
  return (i);
}
}
#line 76 "./mktime-internal.h"
time_t mktime_internal(struct tm *tp , struct tm *(*convert)(time_t const   * , struct tm * ) ,
                       mktime_offset_t *offset ) ;
#line 138 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static long_int shr(long_int a , int b ) 
{ 
  long_int one ;
  long_int tmp ;

  {
#line 141
  one = (long_int )1;
#line 142
  if (- one >> 1 == -1L) {
#line 142
    tmp = a >> b;
  } else {
#line 142
    tmp = (a + (long_int )(a < 0L)) / (one << b) - (long_int )(a < 0L);
  }
#line 142
  return (tmp);
}
}
#line 149 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static long const   mktime_min  =    (long_int const   )(~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
#line 153 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static long const   mktime_max  =    (long_int const   )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 162 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static _Bool leapyear(long_int year ) 
{ 
  int tmp ;

  {
#line 167
  if ((year & 3L) == 0L) {
#line 167
    if (year % 100L != 0L) {
#line 167
      tmp = 1;
    } else
#line 167
    if ((year / 100L & 3L) == 1L) {
#line 167
      tmp = 1;
    } else {
#line 167
      tmp = 0;
    }
  } else {
#line 167
    tmp = 0;
  }
#line 167
  return ((_Bool )tmp);
}
}
#line 175 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static unsigned short const   __mon_yday[2][13]  = { {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )59,        (unsigned short const   )90, 
            (unsigned short const   )120,        (unsigned short const   )151,        (unsigned short const   )181,        (unsigned short const   )212, 
            (unsigned short const   )243,        (unsigned short const   )273,        (unsigned short const   )304,        (unsigned short const   )334, 
            (unsigned short const   )365}, 
   {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )60,        (unsigned short const   )91, 
            (unsigned short const   )121,        (unsigned short const   )152,        (unsigned short const   )182,        (unsigned short const   )213, 
            (unsigned short const   )244,        (unsigned short const   )274,        (unsigned short const   )305,        (unsigned short const   )335, 
            (unsigned short const   )366}};
#line 188 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static _Bool isdst_differ___0(int a , int b ) 
{ 
  int tmp ;

  {
#line 191
  if (! a != ! b) {
#line 191
    if (0 <= a) {
#line 191
      if (0 <= b) {
#line 191
        tmp = 1;
      } else {
#line 191
        tmp = 0;
      }
    } else {
#line 191
      tmp = 0;
    }
  } else {
#line 191
    tmp = 0;
  }
#line 191
  return ((_Bool )tmp);
}
}
#line 204 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static long_int ydhms_diff(long_int year1 , long_int yday1 , int hour1 , int min1 ,
                           int sec1 , int year0 , int yday0 , int hour0 , int min0 ,
                           int sec0 ) 
{ 
  int a4 ;
  long_int tmp ;
  long_int tmp___0 ;
  int b4 ;
  long_int tmp___1 ;
  long_int tmp___2 ;
  int a100 ;
  int b100 ;
  int a400 ;
  long_int tmp___3 ;
  int b400 ;
  long_int tmp___4 ;
  int intervening_leap_days ;
  long_int years ;
  long_int days ;
  long_int hours ;
  long_int minutes ;
  long_int seconds ;

  {
  {
#line 212
  tmp = shr(year1, 2);
#line 212
  tmp___0 = shr((long_int )1900, 2);
#line 212
  a4 = (int )((tmp + tmp___0) - (long_int )(! (year1 & 3L)));
#line 213
  tmp___1 = shr((long_int )year0, 2);
#line 213
  tmp___2 = shr((long_int )1900, 2);
#line 213
  b4 = (int )((tmp___1 + tmp___2) - (long_int )(! (year0 & 3)));
#line 214
  a100 = (a4 + (a4 < 0)) / 25 - (a4 < 0);
#line 215
  b100 = (b4 + (b4 < 0)) / 25 - (b4 < 0);
#line 216
  tmp___3 = shr((long_int )a100, 2);
#line 216
  a400 = (int )tmp___3;
#line 217
  tmp___4 = shr((long_int )b100, 2);
#line 217
  b400 = (int )tmp___4;
#line 218
  intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
#line 221
  years = year1 - (long_int )year0;
#line 222
  days = ((365L * years + yday1) - (long_int )yday0) + (long_int )intervening_leap_days;
#line 223
  hours = (24L * days + (long_int )hour1) - (long_int )hour0;
#line 224
  minutes = (60L * hours + (long_int )min1) - (long_int )min0;
#line 225
  seconds = (60L * minutes + (long_int )sec1) - (long_int )sec0;
  }
#line 226
  return (seconds);
}
}
#line 231 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static long_int long_int_avg(long_int a , long_int b ) 
{ 
  long_int tmp ;
  long_int tmp___0 ;

  {
  {
#line 234
  tmp = shr(a, 1);
#line 234
  tmp___0 = shr(b, 1);
  }
#line 234
  return ((tmp + tmp___0) + ((a | b) & 1L));
}
}
#line 244 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static long_int tm_diff(long_int year , long_int yday , int hour , int min , int sec ,
                        struct tm  const  *tp ) 
{ 
  long_int tmp ;

  {
  {
#line 248
  tmp = ydhms_diff(year, yday, hour, min, sec, (int )tp->tm_year, (int )tp->tm_yday,
                   (int )tp->tm_hour, (int )tp->tm_min, (int )tp->tm_sec);
  }
#line 248
  return (tmp);
}
}
#line 256 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static struct tm *convert_time(struct tm *(*convert)(time_t const   * , struct tm * ) ,
                               long_int t , struct tm *tm ) 
{ 
  time_t x ;
  struct tm *tmp ;

  {
  {
#line 260
  x = t;
#line 261
  tmp = (*convert)((time_t const   *)(& x), tm);
  }
#line 261
  return (tmp);
}
}
#line 269 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
static struct tm *ranged_convert(struct tm *(*convert)(time_t const   * , struct tm * ) ,
                                 long_int *t , struct tm *tp ) 
{ 
  long_int t1 ;
  long_int tmp ;
  long tmp___0 ;
  struct tm *r ;
  struct tm *tmp___1 ;
  int *tmp___2 ;
  long_int bad ;
  long_int ok ;
  struct tm oktm ;
  long_int mid ;
  long_int tmp___3 ;
  int *tmp___4 ;
  struct tm *tmp___5 ;

  {
#line 273
  if (*t < (long_int )mktime_min) {
#line 273
    tmp___0 = mktime_min;
  } else {
#line 273
    if (*t <= (long_int )mktime_max) {
#line 273
      tmp = *t;
    } else {
#line 273
      tmp = (long_int )mktime_max;
    }
#line 273
    tmp___0 = (long const   )tmp;
  }
  {
#line 273
  t1 = (long_int )tmp___0;
#line 275
  tmp___1 = convert_time(convert, t1, tp);
#line 275
  r = tmp___1;
  }
#line 276
  if (r) {
#line 278
    *t = t1;
#line 279
    return (r);
  }
  {
#line 281
  tmp___2 = __errno_location();
  }
#line 281
  if (*tmp___2 != 75) {
#line 282
    return ((struct tm *)((void *)0));
  }
#line 284
  bad = t1;
#line 285
  ok = (long_int )0;
#line 286
  oktm.tm_sec = -1;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    tmp___3 = long_int_avg(ok, bad);
#line 293
    mid = tmp___3;
    }
#line 294
    if (mid == ok) {
#line 295
      goto while_break;
    } else
#line 294
    if (mid == bad) {
#line 295
      goto while_break;
    }
    {
#line 296
    tmp___5 = convert_time(convert, mid, tp);
    }
#line 296
    if (tmp___5) {
#line 297
      ok = mid;
#line 297
      oktm = *tp;
    } else {
      {
#line 298
      tmp___4 = __errno_location();
      }
#line 298
      if (*tmp___4 != 75) {
#line 299
        return ((struct tm *)((void *)0));
      } else {
#line 301
        bad = mid;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  if (oktm.tm_sec < 0) {
#line 305
    return ((struct tm *)((void *)0));
  }
#line 306
  *t = ok;
#line 307
  *tp = oktm;
#line 308
  return (tp);
}
}
#line 320 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mktime.c"
time_t mktime_internal(struct tm *tp , struct tm *(*convert)(time_t const   * , struct tm * ) ,
                       mktime_offset_t *offset ) 
{ 
  struct tm tm ;
  int remaining_probes ;
  int sec ;
  int min ;
  int hour ;
  int mday ;
  int mon ;
  int year_requested ;
  int isdst ;
  int dst2 ;
  int mon_remainder ;
  int negative_mon_remainder ;
  int mon_years ;
  long_int lyear_requested ;
  long_int year ;
  int mon_yday ;
  _Bool tmp ;
  long_int lmday ;
  long_int yday ;
  mktime_offset_t off ;
  int negative_offset_guess ;
  int sec_requested ;
  long_int t0 ;
  long_int tmp___0 ;
  long_int t ;
  long_int t1 ;
  long_int t2 ;
  struct tm *tmp___1 ;
  long_int dt ;
  long_int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int stride ;
  int duration_max ;
  int delta_bound ;
  int delta ;
  int direction ;
  long_int ot ;
  struct tm otm ;
  struct tm *tmp___5 ;
  long_int gt ;
  long_int tmp___6 ;
  struct tm *tmp___7 ;
  int *tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  _Bool tmp___12 ;
  long_int sec_adjustment ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  struct tm *tmp___16 ;

  {
  {
#line 331
  remaining_probes = 6;
#line 335
  sec = tp->tm_sec;
#line 336
  min = tp->tm_min;
#line 337
  hour = tp->tm_hour;
#line 338
  mday = tp->tm_mday;
#line 339
  mon = tp->tm_mon;
#line 340
  year_requested = tp->tm_year;
#line 341
  isdst = tp->tm_isdst;
#line 344
  dst2 = 0;
#line 347
  mon_remainder = mon % 12;
#line 348
  negative_mon_remainder = mon_remainder < 0;
#line 349
  mon_years = mon / 12 - negative_mon_remainder;
#line 350
  lyear_requested = (long_int )year_requested;
#line 351
  year = lyear_requested + (long_int )mon_years;
#line 358
  tmp = leapyear(year);
#line 358
  mon_yday = (int )((int const   )__mon_yday[tmp][mon_remainder + 12 * negative_mon_remainder] - 1);
#line 361
  lmday = (long_int )mday;
#line 362
  yday = (long_int )mon_yday + lmday;
#line 364
  off = *offset;
#line 367
  sec_requested = sec;
  }
#line 373
  if (sec < 0) {
#line 374
    sec = 0;
  }
#line 375
  if (59 < sec) {
#line 376
    sec = 59;
  }
  {
#line 382
  __builtin_sub_overflow(0, off, & negative_offset_guess);
#line 383
  tmp___0 = ydhms_diff(year, yday, hour, min, sec, 70, 0, 0, 0, negative_offset_guess);
#line 383
  t0 = tmp___0;
#line 386
  t = t0;
#line 386
  t1 = t0;
#line 386
  t2 = t0;
  }
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 392
    tmp___1 = ranged_convert(convert, & t, & tm);
    }
#line 392
    if (! tmp___1) {
#line 393
      return ((time_t )-1);
    }
    {
#line 394
    tmp___2 = tm_diff(year, yday, hour, min, sec, (struct tm  const  *)(& tm));
#line 394
    dt = tmp___2;
    }
#line 395
    if (dt == 0L) {
#line 396
      goto while_break;
    }
#line 398
    if (t == t1) {
#line 398
      if (t != t2) {
#line 398
        if (tm.tm_isdst < 0) {
#line 412
          goto offset_found;
        } else {
#line 398
          if (isdst < 0) {
#line 398
            tmp___3 = dst2 <= (tm.tm_isdst != 0);
          } else {
#line 398
            tmp___3 = (isdst != 0) != (tm.tm_isdst != 0);
          }
#line 398
          if (tmp___3) {
#line 412
            goto offset_found;
          }
        }
      }
    }
#line 414
    remaining_probes --;
#line 415
    if (remaining_probes == 0) {
      {
#line 417
      tmp___4 = __errno_location();
#line 417
      *tmp___4 = 75;
      }
#line 418
      return ((time_t )-1);
    }
#line 421
    t1 = t2;
#line 421
    t2 = t;
#line 421
    t += dt;
#line 421
    dst2 = tm.tm_isdst != 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 426
  tmp___12 = isdst_differ___0(isdst, tm.tm_isdst);
  }
#line 426
  if (tmp___12) {
#line 442
    stride = 601200;
#line 449
    duration_max = 536454000;
#line 453
    delta_bound = duration_max / 2 + stride;
#line 457
    delta = stride;
    {
#line 457
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 457
      if (! (delta < delta_bound)) {
#line 457
        goto while_break___0;
      }
#line 458
      direction = -1;
      {
#line 458
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 458
        if (! (direction <= 1)) {
#line 458
          goto while_break___1;
        }
        {
#line 461
        tmp___10 = __builtin_add_overflow(t, delta * direction, & ot);
        }
#line 461
        if (! tmp___10) {
          {
#line 464
          tmp___5 = ranged_convert(convert, & ot, & otm);
          }
#line 464
          if (! tmp___5) {
#line 465
            return ((time_t )-1);
          }
          {
#line 466
          tmp___9 = isdst_differ___0(isdst, otm.tm_isdst);
          }
#line 466
          if (! tmp___9) {
            {
#line 470
            tmp___6 = tm_diff(year, yday, hour, min, sec, (struct tm  const  *)(& otm));
#line 470
            gt = ot + tmp___6;
            }
#line 472
            if (mktime_min <= (long const   )gt) {
#line 472
              if (gt <= (long_int )mktime_max) {
                {
#line 474
                tmp___7 = convert_time(convert, gt, & tm);
                }
#line 474
                if (tmp___7) {
#line 476
                  t = gt;
#line 477
                  goto offset_found;
                }
                {
#line 479
                tmp___8 = __errno_location();
                }
#line 479
                if (*tmp___8 != 75) {
#line 480
                  return ((time_t )-1);
                }
              }
            }
          }
        }
#line 458
        direction += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 457
      delta += stride;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 486
    tmp___11 = __errno_location();
#line 486
    *tmp___11 = 75;
    }
#line 487
    return ((time_t )-1);
  }
  offset_found: 
  {
#line 494
  __builtin_sub_overflow(t, t0, offset);
#line 495
  __builtin_sub_overflow(*offset, negative_offset_guess, offset);
  }
#line 497
  if (sec_requested != tm.tm_sec) {
#line 501
    if (sec == 0) {
#line 501
      if (tm.tm_sec == 60) {
#line 501
        tmp___13 = 1;
      } else {
#line 501
        tmp___13 = 0;
      }
    } else {
#line 501
      tmp___13 = 0;
    }
    {
#line 501
    sec_adjustment = (long_int )tmp___13;
#line 502
    sec_adjustment -= (long_int )sec;
#line 503
    sec_adjustment += (long_int )sec_requested;
#line 504
    tmp___15 = __builtin_add_overflow(t, sec_adjustment, & t);
    }
#line 504
    if (tmp___15) {
      {
#line 507
      tmp___14 = __errno_location();
#line 507
      *tmp___14 = 75;
      }
#line 508
      return ((time_t )-1);
    } else
#line 504
    if (mktime_min <= (long const   )t) {
#line 504
      if (! (t <= (long_int )mktime_max)) {
        {
#line 507
        tmp___14 = __errno_location();
#line 507
        *tmp___14 = 75;
        }
#line 508
        return ((time_t )-1);
      }
    } else {
      {
#line 507
      tmp___14 = __errno_location();
#line 507
      *tmp___14 = 75;
      }
#line 508
      return ((time_t )-1);
    }
    {
#line 510
    tmp___16 = convert_time(convert, t, & tm);
    }
#line 510
    if (! tmp___16) {
#line 511
      return ((time_t )-1);
    }
  }
#line 514
  *tp = tm;
#line 515
  return (t);
}
}
#line 26 "./hard-locale.h"
_Bool hard_locale(int category ) ;
#line 85 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mbrtowc.c"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t ret ;
  wchar_t wc ;
  unsigned char uc ;
  _Bool tmp ;

  {
#line 105
  if (! pwc) {
#line 106
    pwc = & wc;
  }
  {
#line 145
  ret = mbrtowc((wchar_t */* __restrict  */)pwc, (char const   */* __restrict  */)s,
                n, (mbstate_t */* __restrict  */)ps);
  }
#line 154
  if (0xfffffffffffffffeUL <= ret) {
#line 154
    if (n != 0UL) {
      {
#line 154
      tmp = hard_locale(0);
      }
#line 154
      if (! tmp) {
#line 156
        uc = (unsigned char )*s;
#line 157
        *pwc = (wchar_t )uc;
#line 158
        return ((size_t )1);
      }
    }
  }
#line 162
  return (ret);
}
}
#line 751 "./wchar.h"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) ;
#line 24 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mbrlen.c"
static mbstate_t internal_state  ;
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/mbrlen.c"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t tmp ;

  {
#line 29
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 30
    ps = & internal_state;
  }
  {
#line 31
  tmp = rpl_mbrtowc((wchar_t *)((void *)0), s, n, ps);
  }
#line 31
  return (tmp);
}
}
#line 68 "./malloca.h"
void *mmalloca(size_t n ) ;
#line 72
void freea(void *p ) ;
#line 42 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *mem ;
  void *tmp ;
  char *p ;

  {
#line 48
  nplus = ((n + sizeof(small_t )) + 32UL) - 1UL;
#line 50
  if (nplus >= n) {
    {
#line 52
    tmp = malloc(nplus);
#line 52
    mem = (char *)tmp;
    }
#line 54
    if ((unsigned long )mem != (unsigned long )((void *)0)) {
#line 56
      p = (char *)((((((uintptr_t )mem + sizeof(small_t )) + 16UL) - 1UL) & 0xffffffffffffffe0UL) + 16UL);
#line 65
      *((small_t *)p + -1) = (small_t )(p - mem);
#line 67
      return ((void *)p);
    }
  }
#line 71
  return ((void *)0);
}
}
#line 82 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/malloca.c"
void freea(void *p ) 
{ 
  void *mem ;

  {
#line 86
  if ((uintptr_t )p & 15UL) {
    {
#line 89
    abort();
    }
  }
#line 92
  if ((uintptr_t )p & 16UL) {
    {
#line 94
    mem = (void *)((char *)p - (int )*((small_t *)p + -1));
#line 95
    free(mem);
    }
  }
#line 97
  return;
}
}
#line 750 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
#line 807
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
#line 811
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
#line 834
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_settype)(pthread_mutexattr_t *__attr ,
                                                                                                      int __kind ) ;
#line 889
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_init)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                                                pthread_rwlockattr_t const   * __restrict  __attr ) ;
#line 935
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlockattr_init)(pthread_rwlockattr_t *__attr ) ;
#line 939
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlockattr_destroy)(pthread_rwlockattr_t *__attr ) ;
#line 960
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlockattr_setkind_np)(pthread_rwlockattr_t *__attr ,
                                                                                                          int __pref ) ;
#line 242 "./glthread/lock.h"
#pragma weak pthread_mutex_init
#line 243
#pragma weak pthread_mutex_lock
#line 244
#pragma weak pthread_mutex_unlock
#line 245
#pragma weak pthread_mutex_destroy
#line 246
#pragma weak pthread_rwlock_init
#line 247
#pragma weak pthread_rwlock_rdlock
#line 248
#pragma weak pthread_rwlock_wrlock
#line 249
#pragma weak pthread_rwlock_unlock
#line 250
#pragma weak pthread_rwlock_destroy
#line 251
#pragma weak pthread_once
#line 252
#pragma weak pthread_cond_init
#line 253
#pragma weak pthread_cond_wait
#line 254
#pragma weak pthread_cond_signal
#line 255
#pragma weak pthread_cond_broadcast
#line 256
#pragma weak pthread_cond_destroy
#line 257
#pragma weak pthread_mutexattr_init
#line 258
#pragma weak pthread_mutexattr_settype
#line 259
#pragma weak pthread_mutexattr_destroy
#line 260
#pragma weak pthread_rwlockattr_init
#line 262
#pragma weak pthread_rwlockattr_setkind_np
#line 264
#pragma weak pthread_rwlockattr_destroy
#line 266
#pragma weak pthread_self
#line 276
#pragma weak pthread_mutexattr_gettype
#line 333
int glthread_rwlock_init_for_glibc(pthread_rwlock_t *lock ) ;
#line 438
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) ;
#line 521
int glthread_once_singlethreaded(pthread_once_t *once_control ) ;
#line 262 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/glthread/lock.c"
int glthread_rwlock_init_for_glibc(pthread_rwlock_t *lock ) 
{ 
  pthread_rwlockattr_t attributes ;
  int err ;

  {
  {
#line 268
  err = pthread_rwlockattr_init(& attributes);
  }
#line 269
  if (err != 0) {
#line 270
    return (err);
  }
  {
#line 275
  err = pthread_rwlockattr_setkind_np(& attributes, 2);
  }
#line 277
  if (err == 0) {
    {
#line 278
    err = pthread_rwlock_init((pthread_rwlock_t */* __restrict  */)lock, (pthread_rwlockattr_t const   */* __restrict  */)(& attributes));
    }
  }
  {
#line 281
  pthread_rwlockattr_destroy(& attributes);
  }
#line 282
  return (err);
}
}
#line 532 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/glthread/lock.c"
int glthread_recursive_lock_init_multithreaded(gl_recursive_lock_t *lock ) 
{ 
  pthread_mutexattr_t attributes ;
  int err ;

  {
  {
#line 538
  err = pthread_mutexattr_init(& attributes);
  }
#line 539
  if (err != 0) {
#line 540
    return (err);
  }
  {
#line 541
  err = pthread_mutexattr_settype(& attributes, 1);
  }
#line 542
  if (err != 0) {
    {
#line 544
    pthread_mutexattr_destroy(& attributes);
    }
#line 545
    return (err);
  }
  {
#line 547
  err = pthread_mutex_init(lock, (pthread_mutexattr_t const   *)(& attributes));
  }
#line 548
  if (err != 0) {
    {
#line 550
    pthread_mutexattr_destroy(& attributes);
    }
#line 551
    return (err);
  }
  {
#line 553
  err = pthread_mutexattr_destroy(& attributes);
  }
#line 554
  if (err != 0) {
#line 555
    return (err);
  }
#line 556
  return (0);
}
}
#line 703 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/glthread/lock.c"
static int const   fresh_once  =    (pthread_once_t const   )0;
#line 705 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/glthread/lock.c"
int glthread_once_singlethreaded(pthread_once_t *once_control ) 
{ 
  char *firstbyte ;

  {
#line 710
  firstbyte = (char *)once_control;
#line 711
  if ((int )*firstbyte == (int )*((char const   *)(& fresh_once))) {
#line 714
    *firstbyte = (char )(~ ((int const   )*((char const   *)(& fresh_once))));
#line 715
    return (1);
  } else {
#line 718
    return (0);
  }
}
}
#line 830 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char *tmp ;

  {
  {
#line 847
  tmp = nl_langinfo(14);
#line 847
  codeset = (char const   *)tmp;
  }
#line 911
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 913
    codeset = "";
  }
#line 1070
  if ((int const   )*(codeset + 0) == 0) {
#line 1071
    codeset = "ASCII";
  }
#line 1158
  return (codeset);
}
}
#line 24 "./isnan.c"
int rpl_isnanl(long double x )  __attribute__((__const__)) ;
#line 93
int rpl_isnanl(long double x )  __attribute__((__const__)) ;
#line 93 "./isnan.c"
int rpl_isnanl(long double x ) 
{ 
  memory_double m ;
  unsigned int exponent ;

  {
#line 109
  m.value = x;
#line 110
  exponent = m.word[2] & 32767U;
#line 121
  if (exponent == 0U) {
#line 122
    return ((int )(m.word[1] >> 31));
  } else
#line 123
  if (exponent == 32767U) {
#line 124
    return (((m.word[1] ^ 2147483648U) | m.word[0]) != 0U);
  } else {
#line 126
    return ((int )((m.word[1] >> 31) ^ 1U));
  }
}
}
#line 30
int rpl_isnanf(float x ) ;
#line 147 "./isnan.c"
static memory_double___0 nan  =    {0.0f / 0.0f};
#line 148 "./isnan.c"
static float plus_inf  =    1.0f / 0.0f;
#line 149 "./isnan.c"
static float minus_inf  =    - 1.0f / 0.0f;
#line 93 "./isnan.c"
int rpl_isnanf(float x ) 
{ 
  memory_double___0 m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 156
  m.value = x;
#line 157
  if (((m.word[0] ^ nan.word[0]) & (unsigned int )(255 << 23)) == 0U) {
    {
#line 160
    tmp = memcmp((void const   *)(& m.value), (void const   *)(& plus_inf), (size_t )4);
    }
#line 160
    if (tmp != 0) {
      {
#line 160
      tmp___0 = memcmp((void const   *)(& m.value), (void const   *)(& minus_inf),
                       (size_t )4);
      }
#line 160
      if (tmp___0 != 0) {
#line 160
        tmp___1 = 1;
      } else {
#line 160
        tmp___1 = 0;
      }
    } else {
#line 160
      tmp___1 = 0;
    }
#line 160
    return (tmp___1);
  } else {
#line 163
    return (0);
  }
}
}
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  char locale[257] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 31
  tmp = setlocale_null_r(category, locale, sizeof(locale));
  }
#line 31
  if (tmp) {
#line 32
    return ((_Bool)0);
  }
  {
#line 34
  tmp___0 = strcmp((char const   *)(locale), "C");
  }
#line 34
  if (tmp___0 == 0) {
#line 34
    tmp___2 = 0;
  } else {
    {
#line 34
    tmp___1 = strcmp((char const   *)(locale), "POSIX");
    }
#line 34
    if (tmp___1 == 0) {
#line 34
      tmp___2 = 0;
    } else {
#line 34
      tmp___2 = 1;
    }
  }
#line 34
  return ((_Bool )tmp___2);
}
}
#line 557 "./gl_list.h"
__inline gl_list_t gl_list_nx_create_empty(gl_list_implementation_t implementation ,
                                           _Bool (*equals_fn)(void const   *elt1 ,
                                                              void const   *elt2 ) ,
                                           size_t (*hashcode_fn)(void const   *elt ) ,
                                           void (*dispose_fn)(void const   *elt ) ,
                                           _Bool allow_duplicates ) 
{ 
  gl_list_t tmp ;

  {
  {
#line 564
  tmp = (*(implementation->nx_create_empty))(implementation, equals_fn, hashcode_fn,
                                             dispose_fn, allow_duplicates);
  }
#line 564
  return (tmp);
}
}
#line 569 "./gl_list.h"
__inline gl_list_t gl_list_nx_create(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                                  void const   *elt2 ) ,
                                     size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                                     _Bool allow_duplicates , size_t count , void const   **contents ) 
{ 
  gl_list_t tmp ;

  {
  {
#line 577
  tmp = (*(implementation->nx_create))(implementation, equals_fn, hashcode_fn, dispose_fn,
                                       allow_duplicates, count, contents);
  }
#line 577
  return (tmp);
}
}
#line 582 "./gl_list.h"
__inline size_t gl_list_size(gl_list_t list ) 
{ 
  size_t tmp ;

  {
  {
#line 585
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->size))(list);
  }
#line 585
  return (tmp);
}
}
#line 589 "./gl_list.h"
__inline void const   *gl_list_node_value(gl_list_t list , gl_list_node_t node ) 
{ 
  void const   *tmp ;

  {
  {
#line 592
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->node_value))(list,
                                                                              node);
  }
#line 592
  return (tmp);
}
}
#line 596 "./gl_list.h"
__inline int ( __attribute__((__warn_unused_result__)) gl_list_node_nx_set_value)(gl_list_t list ,
                                                                                  gl_list_node_t node ,
                                                                                  void const   *elt ) 
{ 
  int tmp ;

  {
  {
#line 603
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->node_nx_set_value))(list,
                                                                                     node,
                                                                                     elt);
  }
#line 603
  return (tmp);
}
}
#line 607 "./gl_list.h"
__inline gl_list_node_t gl_list_next_node(gl_list_t list , gl_list_node_t node ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 610
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->next_node))(list,
                                                                             node);
  }
#line 610
  return (tmp);
}
}
#line 614 "./gl_list.h"
__inline gl_list_node_t gl_list_previous_node(gl_list_t list , gl_list_node_t node ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 617
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->previous_node))(list,
                                                                                 node);
  }
#line 617
  return (tmp);
}
}
#line 621 "./gl_list.h"
__inline void const   *gl_list_get_at(gl_list_t list , size_t position ) 
{ 
  void const   *tmp ;

  {
  {
#line 624
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->get_at))(list, position);
  }
#line 624
  return (tmp);
}
}
#line 628 "./gl_list.h"
__inline gl_list_node_t ( __attribute__((__warn_unused_result__)) gl_list_nx_set_at)(gl_list_t list ,
                                                                                     size_t position ,
                                                                                     void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 634
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->nx_set_at))(list,
                                                                             position,
                                                                             elt);
  }
#line 634
  return (tmp);
}
}
#line 638 "./gl_list.h"
__inline gl_list_node_t gl_list_search(gl_list_t list , void const   *elt ) 
{ 
  size_t size ;
  size_t tmp ;
  gl_list_node_t tmp___0 ;

  {
  {
#line 641
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->size))(list);
#line 641
  size = tmp;
#line 642
  tmp___0 = (*((((struct gl_list_impl_base  const  *)list)->vtable)->search_from_to))(list,
                                                                                      (size_t )0,
                                                                                      size,
                                                                                      elt);
  }
#line 642
  return (tmp___0);
}
}
#line 646 "./gl_list.h"
__inline gl_list_node_t gl_list_search_from(gl_list_t list , size_t start_index ,
                                            void const   *elt ) 
{ 
  size_t size ;
  size_t tmp ;
  gl_list_node_t tmp___0 ;

  {
  {
#line 649
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->size))(list);
#line 649
  size = tmp;
#line 650
  tmp___0 = (*((((struct gl_list_impl_base  const  *)list)->vtable)->search_from_to))(list,
                                                                                      start_index,
                                                                                      size,
                                                                                      elt);
  }
#line 650
  return (tmp___0);
}
}
#line 654 "./gl_list.h"
__inline gl_list_node_t gl_list_search_from_to(gl_list_t list , size_t start_index ,
                                               size_t end_index , void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 658
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->search_from_to))(list,
                                                                                  start_index,
                                                                                  end_index,
                                                                                  elt);
  }
#line 658
  return (tmp);
}
}
#line 662 "./gl_list.h"
__inline size_t gl_list_indexof(gl_list_t list , void const   *elt ) 
{ 
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 665
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->size))(list);
#line 665
  size = tmp;
#line 666
  tmp___0 = (*((((struct gl_list_impl_base  const  *)list)->vtable)->indexof_from_to))(list,
                                                                                       (size_t )0,
                                                                                       size,
                                                                                       elt);
  }
#line 666
  return (tmp___0);
}
}
#line 670 "./gl_list.h"
__inline size_t gl_list_indexof_from(gl_list_t list , size_t start_index , void const   *elt ) 
{ 
  size_t size ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 673
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->size))(list);
#line 673
  size = tmp;
#line 674
  tmp___0 = (*((((struct gl_list_impl_base  const  *)list)->vtable)->indexof_from_to))(list,
                                                                                       start_index,
                                                                                       size,
                                                                                       elt);
  }
#line 674
  return (tmp___0);
}
}
#line 678 "./gl_list.h"
__inline size_t gl_list_indexof_from_to(gl_list_t list , size_t start_index , size_t end_index ,
                                        void const   *elt ) 
{ 
  size_t tmp ;

  {
  {
#line 682
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->indexof_from_to))(list,
                                                                                   start_index,
                                                                                   end_index,
                                                                                   elt);
  }
#line 682
  return (tmp);
}
}
#line 686 "./gl_list.h"
__inline gl_list_node_t ( __attribute__((__warn_unused_result__)) gl_list_nx_add_first)(gl_list_t list ,
                                                                                        void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 692
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->nx_add_first))(list,
                                                                                elt);
  }
#line 692
  return (tmp);
}
}
#line 696 "./gl_list.h"
__inline gl_list_node_t ( __attribute__((__warn_unused_result__)) gl_list_nx_add_last)(gl_list_t list ,
                                                                                       void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 702
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->nx_add_last))(list,
                                                                               elt);
  }
#line 702
  return (tmp);
}
}
#line 706 "./gl_list.h"
__inline gl_list_node_t ( __attribute__((__warn_unused_result__)) gl_list_nx_add_before)(gl_list_t list ,
                                                                                         gl_list_node_t node ,
                                                                                         void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 712
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->nx_add_before))(list,
                                                                                 node,
                                                                                 elt);
  }
#line 712
  return (tmp);
}
}
#line 716 "./gl_list.h"
__inline gl_list_node_t ( __attribute__((__warn_unused_result__)) gl_list_nx_add_after)(gl_list_t list ,
                                                                                        gl_list_node_t node ,
                                                                                        void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 722
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->nx_add_after))(list,
                                                                                node,
                                                                                elt);
  }
#line 722
  return (tmp);
}
}
#line 726 "./gl_list.h"
__inline gl_list_node_t ( __attribute__((__warn_unused_result__)) gl_list_nx_add_at)(gl_list_t list ,
                                                                                     size_t position ,
                                                                                     void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 732
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->nx_add_at))(list,
                                                                             position,
                                                                             elt);
  }
#line 732
  return (tmp);
}
}
#line 736 "./gl_list.h"
__inline _Bool gl_list_remove_node(gl_list_t list , gl_list_node_t node ) 
{ 
  _Bool tmp ;

  {
  {
#line 739
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->remove_node))(list,
                                                                               node);
  }
#line 739
  return (tmp);
}
}
#line 743 "./gl_list.h"
__inline _Bool gl_list_remove_at(gl_list_t list , size_t position ) 
{ 
  _Bool tmp ;

  {
  {
#line 746
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->remove_at))(list,
                                                                             position);
  }
#line 746
  return (tmp);
}
}
#line 750 "./gl_list.h"
__inline _Bool gl_list_remove(gl_list_t list , void const   *elt ) 
{ 
  _Bool tmp ;

  {
  {
#line 753
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->remove_elt))(list,
                                                                              elt);
  }
#line 753
  return (tmp);
}
}
#line 757 "./gl_list.h"
__inline void gl_list_free(gl_list_t list ) 
{ 


  {
  {
#line 760
  (*((((struct gl_list_impl_base  const  *)list)->vtable)->list_free))(list);
  }
#line 761
  return;
}
}
#line 763 "./gl_list.h"
__inline gl_list_iterator_t gl_list_iterator(gl_list_t list ) 
{ 
  gl_list_iterator_t tmp ;

  {
  {
#line 766
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->iterator))(list);
  }
#line 766
  return (tmp);
}
}
#line 770 "./gl_list.h"
__inline gl_list_iterator_t gl_list_iterator_from_to(gl_list_t list , size_t start_index ,
                                                     size_t end_index ) 
{ 
  gl_list_iterator_t tmp ;

  {
  {
#line 773
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->iterator_from_to))(list,
                                                                                    start_index,
                                                                                    end_index);
  }
#line 773
  return (tmp);
}
}
#line 777 "./gl_list.h"
__inline _Bool gl_list_iterator_next(gl_list_iterator_t *iterator , void const   **eltp ,
                                     gl_list_node_t *nodep ) 
{ 
  _Bool tmp ;

  {
  {
#line 781
  tmp = (*((iterator->vtable)->iterator_next))(iterator, eltp, nodep);
  }
#line 781
  return (tmp);
}
}
#line 784 "./gl_list.h"
__inline void gl_list_iterator_free(gl_list_iterator_t *iterator ) 
{ 


  {
  {
#line 787
  (*((iterator->vtable)->iterator_free))(iterator);
  }
#line 788
  return;
}
}
#line 790 "./gl_list.h"
__inline gl_list_node_t gl_sortedlist_search(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                            void const   *elt2 ) ,
                                             void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 793
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->sortedlist_search))(list,
                                                                                     compar,
                                                                                     elt);
  }
#line 793
  return (tmp);
}
}
#line 797 "./gl_list.h"
__inline gl_list_node_t gl_sortedlist_search_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                    void const   *elt2 ) ,
                                                     size_t start_index , size_t end_index ,
                                                     void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 800
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->sortedlist_search_from_to))(list,
                                                                                             compar,
                                                                                             start_index,
                                                                                             end_index,
                                                                                             elt);
  }
#line 800
  return (tmp);
}
}
#line 805 "./gl_list.h"
__inline size_t gl_sortedlist_indexof(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                     void const   *elt2 ) ,
                                      void const   *elt ) 
{ 
  size_t tmp ;

  {
  {
#line 808
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->sortedlist_indexof))(list,
                                                                                      compar,
                                                                                      elt);
  }
#line 808
  return (tmp);
}
}
#line 812 "./gl_list.h"
__inline size_t gl_sortedlist_indexof_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                             void const   *elt2 ) ,
                                              size_t start_index , size_t end_index ,
                                              void const   *elt ) 
{ 
  size_t tmp ;

  {
  {
#line 815
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->sortedlist_indexof_from_to))(list,
                                                                                              compar,
                                                                                              start_index,
                                                                                              end_index,
                                                                                              elt);
  }
#line 815
  return (tmp);
}
}
#line 820 "./gl_list.h"
__inline gl_list_node_t ( __attribute__((__warn_unused_result__)) gl_sortedlist_nx_add)(gl_list_t list ,
                                                                                        int (*compar)(void const   *elt1 ,
                                                                                                      void const   *elt2 ) ,
                                                                                        void const   *elt ) 
{ 
  gl_list_node_t tmp ;

  {
  {
#line 826
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->sortedlist_nx_add))(list,
                                                                                     compar,
                                                                                     elt);
  }
#line 826
  return (tmp);
}
}
#line 830 "./gl_list.h"
__inline _Bool gl_sortedlist_remove(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                   void const   *elt2 ) ,
                                    void const   *elt ) 
{ 
  _Bool tmp ;

  {
  {
#line 833
  tmp = (*((((struct gl_list_impl_base  const  *)list)->vtable)->sortedlist_remove))(list,
                                                                                     compar,
                                                                                     elt);
  }
#line 833
  return (tmp);
}
}
#line 27 "./gl_array_list.h"
struct gl_list_implementation  const  gl_array_list_implementation ;
#line 49 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_t gl_array_nx_create_empty(gl_list_implementation_t implementation ,
                                          _Bool (*equals_fn)(void const   *elt1 ,
                                                             void const   *elt2 ) ,
                                          size_t (*hashcode_fn)(void const   *elt ) ,
                                          void (*dispose_fn)(void const   *elt ) ,
                                          _Bool allow_duplicates ) 
{ 
  struct gl_list_impl *list ;
  void *tmp ;

  {
  {
#line 56
  tmp = malloc(sizeof(struct gl_list_impl ));
#line 56
  list = (struct gl_list_impl *)tmp;
  }
#line 59
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 60
    return ((gl_list_t )((void *)0));
  }
#line 62
  list->base.vtable = implementation;
#line 63
  list->base.equals_fn = equals_fn;
#line 64
  list->base.hashcode_fn = hashcode_fn;
#line 65
  list->base.dispose_fn = dispose_fn;
#line 66
  list->base.allow_duplicates = allow_duplicates;
#line 67
  list->elements = (void const   **)((void *)0);
#line 68
  list->count = (size_t )0;
#line 69
  list->allocated = (size_t )0;
#line 71
  return (list);
}
}
#line 74 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_t gl_array_nx_create(gl_list_implementation_t implementation , _Bool (*equals_fn)(void const   *elt1 ,
                                                                                                 void const   *elt2 ) ,
                                    size_t (*hashcode_fn)(void const   *elt ) , void (*dispose_fn)(void const   *elt ) ,
                                    _Bool allow_duplicates , size_t count , void const   **contents ) 
{ 
  struct gl_list_impl *list ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 82
  tmp = malloc(sizeof(struct gl_list_impl ));
#line 82
  list = (struct gl_list_impl *)tmp;
  }
#line 85
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 86
    return ((gl_list_t )((void *)0));
  }
#line 88
  list->base.vtable = implementation;
#line 89
  list->base.equals_fn = equals_fn;
#line 90
  list->base.hashcode_fn = hashcode_fn;
#line 91
  list->base.dispose_fn = dispose_fn;
#line 92
  list->base.allow_duplicates = allow_duplicates;
#line 93
  if (count > 0UL) {
#line 95
    if (count <= 0xffffffffffffffffUL / sizeof(void const   *)) {
#line 95
      tmp___0 = count * sizeof(void const   *);
    } else {
#line 95
      tmp___0 = 0xffffffffffffffffUL;
    }
#line 95
    if (tmp___0 == 0xffffffffffffffffUL) {
#line 96
      goto fail;
    }
    {
#line 97
    tmp___1 = malloc(count * sizeof(void const   *));
#line 97
    list->elements = (void const   **)tmp___1;
    }
#line 98
    if ((unsigned long )list->elements == (unsigned long )((void *)0)) {
#line 99
      goto fail;
    }
    {
#line 100
    memcpy((void */* __restrict  */)list->elements, (void const   */* __restrict  */)contents,
           count * sizeof(void const   *));
    }
  } else {
#line 103
    list->elements = (void const   **)((void *)0);
  }
#line 104
  list->count = count;
#line 105
  list->allocated = count;
#line 107
  return (list);
  fail: 
  {
#line 110
  free((void *)list);
  }
#line 111
  return ((gl_list_t )((void *)0));
}
}
#line 114 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static size_t gl_array_size(gl_list_t list ) 
{ 


  {
#line 117
  return (list->count);
}
}
#line 120 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static void const   * __attribute__((__pure__)) gl_array_node_value(gl_list_t list ,
                                                                    gl_list_node_t node ) 
{ 
  uintptr_t index___0 ;

  {
#line 123
  index___0 = (uintptr_t )node - 1UL;
#line 124
  if (! (index___0 < list->count)) {
    {
#line 126
    abort();
    }
  }
#line 127
  return ((void const   */* __attribute__((__pure__)) */)*(list->elements + index___0));
}
}
#line 130 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static int gl_array_node_nx_set_value(gl_list_t list , gl_list_node_t node , void const   *elt ) 
{ 
  uintptr_t index___0 ;

  {
#line 134
  index___0 = (uintptr_t )node - 1UL;
#line 135
  if (! (index___0 < list->count)) {
    {
#line 137
    abort();
    }
  }
#line 138
  *(list->elements + index___0) = elt;
#line 139
  return (0);
}
}
#line 142 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t __attribute__((__pure__))  gl_array_next_node(gl_list_t list ,
                                                                    gl_list_node_t node ) 
{ 
  uintptr_t index___0 ;

  {
#line 145
  index___0 = (uintptr_t )node - 1UL;
#line 146
  if (! (index___0 < list->count)) {
    {
#line 148
    abort();
    }
  }
#line 149
  index___0 ++;
#line 150
  if (index___0 < list->count) {
#line 151
    return ((gl_list_node_t __attribute__((__pure__))  )((gl_list_node_t )(index___0 + 1UL)));
  } else {
#line 153
    return ((gl_list_node_t __attribute__((__pure__))  )((void *)0));
  }
}
}
#line 156 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t __attribute__((__pure__))  gl_array_previous_node(gl_list_t list ,
                                                                        gl_list_node_t node ) 
{ 
  uintptr_t index___0 ;

  {
#line 159
  index___0 = (uintptr_t )node - 1UL;
#line 160
  if (! (index___0 < list->count)) {
    {
#line 162
    abort();
    }
  }
#line 163
  if (index___0 > 0UL) {
#line 164
    return ((gl_list_node_t __attribute__((__pure__))  )((gl_list_node_t )((index___0 - 1UL) + 1UL)));
  } else {
#line 166
    return ((gl_list_node_t __attribute__((__pure__))  )((void *)0));
  }
}
}
#line 169 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static void const   * __attribute__((__pure__)) gl_array_get_at(gl_list_t list , size_t position ) 
{ 
  size_t count ;

  {
#line 172
  count = list->count;
#line 174
  if (! (position < count)) {
    {
#line 176
    abort();
    }
  }
#line 177
  return ((void const   */* __attribute__((__pure__)) */)*(list->elements + position));
}
}
#line 180 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_nx_set_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count ;

  {
#line 183
  count = list->count;
#line 185
  if (! (position < count)) {
    {
#line 187
    abort();
    }
  }
#line 188
  *(list->elements + position) = elt;
#line 189
  return ((gl_list_node_t )(position + 1UL));
}
}
#line 192 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static size_t gl_array_indexof_from_to(gl_list_t list , size_t start_index , size_t end_index ,
                                       void const   *elt ) 
{ 
  size_t count ;
  _Bool (*equals)(void const   *elt1 , void const   *elt2 ) ;
  size_t i ;
  _Bool tmp ;
  size_t i___0 ;

  {
#line 196
  count = list->count;
#line 198
  if (start_index <= end_index) {
#line 198
    if (! (end_index <= count)) {
      {
#line 200
      abort();
      }
    }
  } else {
    {
#line 200
    abort();
    }
  }
#line 202
  if (start_index < end_index) {
#line 204
    equals = list->base.equals_fn;
#line 205
    if ((unsigned long )equals != (unsigned long )((void *)0)) {
#line 209
      i = start_index;
      {
#line 209
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 211
        tmp = (*equals)(elt, *(list->elements + i));
        }
#line 211
        if (tmp) {
#line 212
          return (i);
        }
#line 213
        i ++;
#line 214
        if (i == end_index) {
#line 215
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 222
      i___0 = start_index;
      {
#line 222
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 224
        if ((unsigned long )elt == (unsigned long )*(list->elements + i___0)) {
#line 225
          return (i___0);
        }
#line 226
        i___0 ++;
#line 227
        if (i___0 == end_index) {
#line 228
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 232
  return ((size_t )-1);
}
}
#line 235 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_search_from_to(gl_list_t list , size_t start_index ,
                                              size_t end_index , void const   *elt ) 
{ 
  size_t index___0 ;
  size_t tmp ;

  {
  {
#line 239
  tmp = gl_array_indexof_from_to(list, start_index, end_index, elt);
#line 239
  index___0 = tmp;
  }
#line 240
  return ((gl_list_node_t )(index___0 + 1UL));
}
}
#line 245 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static int grow(gl_list_t list ) 
{ 
  size_t new_allocated ;
  size_t memory_size ;
  void const   **memory ;
  size_t __attribute__((__pure__))  tmp ;
  void *tmp___0 ;

  {
#line 252
  if (list->allocated <= 9223372036854775807UL) {
#line 252
    new_allocated = list->allocated * 2UL;
  } else {
#line 252
    new_allocated = 0xffffffffffffffffUL;
  }
  {
#line 253
  tmp = xsum(new_allocated, (size_t )1);
#line 253
  new_allocated = (size_t )tmp;
  }
#line 254
  if (new_allocated <= 0xffffffffffffffffUL / sizeof(void const   *)) {
#line 254
    memory_size = new_allocated * sizeof(void const   *);
  } else {
#line 254
    memory_size = 0xffffffffffffffffUL;
  }
#line 255
  if (memory_size == 0xffffffffffffffffUL) {
#line 257
    return (-1);
  }
  {
#line 258
  tmp___0 = realloc((void *)list->elements, memory_size);
#line 258
  memory = (void const   **)tmp___0;
  }
#line 259
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 261
    return (-1);
  }
#line 262
  list->elements = memory;
#line 263
  list->allocated = new_allocated;
#line 264
  return (0);
}
}
#line 267 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_nx_add_first(gl_list_t list , void const   *elt ) 
{ 
  size_t count ;
  void const   **elements ;
  size_t i ;
  int tmp ;

  {
#line 270
  count = list->count;
#line 274
  if (count == list->allocated) {
    {
#line 275
    tmp = grow(list);
    }
#line 275
    if (tmp < 0) {
#line 276
      return ((gl_list_node_t )((void *)0));
    }
  }
#line 277
  elements = list->elements;
#line 278
  i = count;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i > 0UL)) {
#line 278
      goto while_break;
    }
#line 279
    *(elements + i) = *(elements + (i - 1UL));
#line 278
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  *(elements + 0) = elt;
#line 281
  list->count = count + 1UL;
#line 282
  return ((gl_list_node_t )((size_t )1));
}
}
#line 285 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_nx_add_last(gl_list_t list , void const   *elt ) 
{ 
  size_t count ;
  int tmp ;

  {
#line 288
  count = list->count;
#line 290
  if (count == list->allocated) {
    {
#line 291
    tmp = grow(list);
    }
#line 291
    if (tmp < 0) {
#line 292
      return ((gl_list_node_t )((void *)0));
    }
  }
#line 293
  *(list->elements + count) = elt;
#line 294
  list->count = count + 1UL;
#line 295
  return ((gl_list_node_t )(count + 1UL));
}
}
#line 298 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_nx_add_before(gl_list_t list , gl_list_node_t node ,
                                             void const   *elt ) 
{ 
  size_t count ;
  uintptr_t index___0 ;
  size_t position ;
  void const   **elements ;
  size_t i ;
  int tmp ;

  {
#line 301
  count = list->count;
#line 302
  index___0 = (uintptr_t )node - 1UL;
#line 307
  if (! (index___0 < count)) {
    {
#line 309
    abort();
    }
  }
#line 310
  position = index___0;
#line 311
  if (count == list->allocated) {
    {
#line 312
    tmp = grow(list);
    }
#line 312
    if (tmp < 0) {
#line 313
      return ((gl_list_node_t )((void *)0));
    }
  }
#line 314
  elements = list->elements;
#line 315
  i = count;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i > position)) {
#line 315
      goto while_break;
    }
#line 316
    *(elements + i) = *(elements + (i - 1UL));
#line 315
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  *(elements + position) = elt;
#line 318
  list->count = count + 1UL;
#line 319
  return ((gl_list_node_t )(position + 1UL));
}
}
#line 322 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_nx_add_after(gl_list_t list , gl_list_node_t node ,
                                            void const   *elt ) 
{ 
  size_t count ;
  uintptr_t index___0 ;
  size_t position ;
  void const   **elements ;
  size_t i ;
  int tmp ;

  {
#line 325
  count = list->count;
#line 326
  index___0 = (uintptr_t )node - 1UL;
#line 331
  if (! (index___0 < count)) {
    {
#line 333
    abort();
    }
  }
#line 334
  position = index___0 + 1UL;
#line 335
  if (count == list->allocated) {
    {
#line 336
    tmp = grow(list);
    }
#line 336
    if (tmp < 0) {
#line 337
      return ((gl_list_node_t )((void *)0));
    }
  }
#line 338
  elements = list->elements;
#line 339
  i = count;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i > position)) {
#line 339
      goto while_break;
    }
#line 340
    *(elements + i) = *(elements + (i - 1UL));
#line 339
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  *(elements + position) = elt;
#line 342
  list->count = count + 1UL;
#line 343
  return ((gl_list_node_t )(position + 1UL));
}
}
#line 346 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_nx_add_at(gl_list_t list , size_t position , void const   *elt ) 
{ 
  size_t count ;
  void const   **elements ;
  size_t i ;
  int tmp ;

  {
#line 349
  count = list->count;
#line 353
  if (! (position <= count)) {
    {
#line 355
    abort();
    }
  }
#line 356
  if (count == list->allocated) {
    {
#line 357
    tmp = grow(list);
    }
#line 357
    if (tmp < 0) {
#line 358
      return ((gl_list_node_t )((void *)0));
    }
  }
#line 359
  elements = list->elements;
#line 360
  i = count;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i > position)) {
#line 360
      goto while_break;
    }
#line 361
    *(elements + i) = *(elements + (i - 1UL));
#line 360
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  *(elements + position) = elt;
#line 363
  list->count = count + 1UL;
#line 364
  return ((gl_list_node_t )(position + 1UL));
}
}
#line 367 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static _Bool gl_array_remove_node(gl_list_t list , gl_list_node_t node ) 
{ 
  size_t count ;
  uintptr_t index___0 ;
  size_t position ;
  void const   **elements ;
  size_t i ;

  {
#line 370
  count = list->count;
#line 371
  index___0 = (uintptr_t )node - 1UL;
#line 376
  if (! (index___0 < count)) {
    {
#line 378
    abort();
    }
  }
#line 379
  position = index___0;
#line 380
  elements = list->elements;
#line 381
  if ((unsigned long )list->base.dispose_fn != (unsigned long )((void *)0)) {
    {
#line 382
    (*(list->base.dispose_fn))(*(elements + position));
    }
  }
#line 383
  i = position + 1UL;
  {
#line 383
  while (1) {
    while_continue: /* CIL Label */ ;
#line 383
    if (! (i < count)) {
#line 383
      goto while_break;
    }
#line 384
    *(elements + (i - 1UL)) = *(elements + i);
#line 383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  list->count = count - 1UL;
#line 386
  return ((_Bool)1);
}
}
#line 389 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static _Bool gl_array_remove_at(gl_list_t list , size_t position ) 
{ 
  size_t count ;
  void const   **elements ;
  size_t i ;

  {
#line 392
  count = list->count;
#line 396
  if (! (position < count)) {
    {
#line 398
    abort();
    }
  }
#line 399
  elements = list->elements;
#line 400
  if ((unsigned long )list->base.dispose_fn != (unsigned long )((void *)0)) {
    {
#line 401
    (*(list->base.dispose_fn))(*(elements + position));
    }
  }
#line 402
  i = position + 1UL;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (i < count)) {
#line 402
      goto while_break;
    }
#line 403
    *(elements + (i - 1UL)) = *(elements + i);
#line 402
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  list->count = count - 1UL;
#line 405
  return ((_Bool)1);
}
}
#line 408 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static _Bool gl_array_remove(gl_list_t list , void const   *elt ) 
{ 
  size_t position ;
  size_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 411
  tmp = gl_array_indexof_from_to(list, (size_t )0, list->count, elt);
#line 411
  position = tmp;
  }
#line 412
  if (position == 0xffffffffffffffffUL) {
#line 413
    return ((_Bool)0);
  } else {
    {
#line 415
    tmp___0 = gl_array_remove_at(list, position);
    }
#line 415
    return (tmp___0);
  }
}
}
#line 418 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static void gl_array_list_free(gl_list_t list ) 
{ 
  size_t count ;
  void (*dispose)(void const   *elt ) ;
  void const   **elements ;
  void const   **tmp ;

  {
#line 421
  if ((unsigned long )list->elements != (unsigned long )((void *)0)) {
#line 423
    if ((unsigned long )list->base.dispose_fn != (unsigned long )((void *)0)) {
#line 425
      count = list->count;
#line 427
      if (count > 0UL) {
#line 429
        dispose = list->base.dispose_fn;
#line 430
        elements = list->elements;
        {
#line 432
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 433
          tmp = elements;
#line 433
          elements ++;
#line 433
          (*dispose)(*tmp);
#line 432
          count --;
          }
#line 432
          if (! (count > 0UL)) {
#line 432
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 437
    free((void *)list->elements);
    }
  }
  {
#line 439
  free((void *)list);
  }
#line 440
  return;
}
}
#line 444 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_iterator_t gl_array_iterator(gl_list_t list ) 
{ 
  gl_list_iterator_t result ;

  {
#line 449
  result.vtable = list->base.vtable;
#line 450
  result.list = list;
#line 451
  result.count = list->count;
#line 452
  result.p = (void *)(list->elements + 0);
#line 453
  result.q = (void *)(list->elements + list->count);
#line 459
  return (result);
}
}
#line 462 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_iterator_t gl_array_iterator_from_to(gl_list_t list , size_t start_index ,
                                                    size_t end_index ) 
{ 
  gl_list_iterator_t result ;

  {
#line 467
  if (start_index <= end_index) {
#line 467
    if (! (end_index <= list->count)) {
      {
#line 469
      abort();
      }
    }
  } else {
    {
#line 469
    abort();
    }
  }
#line 470
  result.vtable = list->base.vtable;
#line 471
  result.list = list;
#line 472
  result.count = list->count;
#line 473
  result.p = (void *)(list->elements + start_index);
#line 474
  result.q = (void *)(list->elements + end_index);
#line 480
  return (result);
}
}
#line 483 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static _Bool gl_array_iterator_next(gl_list_iterator_t *iterator , void const   **eltp ,
                                    gl_list_node_t *nodep ) 
{ 
  gl_list_t list ;
  void const   **p ;

  {
#line 487
  list = iterator->list;
#line 488
  if (iterator->count != list->count) {
#line 490
    if (iterator->count != list->count + 1UL) {
      {
#line 492
      abort();
      }
    }
#line 494
    (iterator->count) --;
#line 495
    iterator->p = (void *)((void const   **)iterator->p - 1);
#line 496
    iterator->q = (void *)((void const   **)iterator->q - 1);
  }
#line 498
  if ((unsigned long )iterator->p < (unsigned long )iterator->q) {
#line 500
    p = (void const   **)iterator->p;
#line 501
    *eltp = *p;
#line 502
    if ((unsigned long )nodep != (unsigned long )((void *)0)) {
#line 503
      *nodep = (gl_list_node_t )((size_t )((p - list->elements) + 1L));
    }
#line 504
    iterator->p = (void *)(p + 1);
#line 505
    return ((_Bool)1);
  } else {
#line 508
    return ((_Bool)0);
  }
}
}
#line 511 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static void gl_array_iterator_free(gl_list_iterator_t *iterator  __attribute__((__unused__)) ) 
{ 


  {
#line 514
  return;
}
}
#line 518 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static size_t gl_array_sortedlist_indexof_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                 void const   *elt2 ) ,
                                                  size_t low , size_t high , void const   *elt ) 
{ 
  size_t mid ;
  int cmp ;
  int tmp ;
  size_t mid2 ;
  int cmp2 ;
  int tmp___0 ;

  {
#line 524
  if (low <= high) {
#line 524
    if (! (high <= list->count)) {
      {
#line 526
      abort();
      }
    }
  } else {
    {
#line 526
    abort();
    }
  }
#line 527
  if (low < high) {
    {
#line 533
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 535
      mid = low + (high - low) / 2UL;
#line 536
      tmp = (*compar)(*(list->elements + mid), elt);
#line 536
      cmp = tmp;
      }
#line 538
      if (cmp < 0) {
#line 539
        low = mid + 1UL;
      } else
#line 540
      if (cmp > 0) {
#line 541
        high = mid;
      } else {
#line 546
        high = mid;
        {
#line 551
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 551
          if (! (low < high)) {
#line 551
            goto while_break___0;
          }
          {
#line 553
          mid2 = low + (high - low) / 2UL;
#line 554
          tmp___0 = (*compar)(*(list->elements + mid2), elt);
#line 554
          cmp2 = tmp___0;
          }
#line 556
          if (cmp2 < 0) {
#line 557
            low = mid2 + 1UL;
          } else
#line 558
          if (cmp2 > 0) {
            {
#line 560
            abort();
            }
          } else {
#line 563
            if (mid2 == low) {
#line 564
              goto while_break___0;
            }
#line 565
            high = mid2 - 1UL;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 568
        return (low);
      }
#line 533
      if (! (low < high)) {
#line 533
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 574
  return ((size_t )-1);
}
}
#line 577 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static size_t gl_array_sortedlist_indexof(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                         void const   *elt2 ) ,
                                          void const   *elt ) 
{ 
  size_t tmp ;

  {
  {
#line 581
  tmp = gl_array_sortedlist_indexof_from_to(list, compar, (size_t )0, list->count,
                                            elt);
  }
#line 581
  return (tmp);
}
}
#line 585 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_sortedlist_search_from_to(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                        void const   *elt2 ) ,
                                                         size_t low , size_t high ,
                                                         void const   *elt ) 
{ 
  size_t index___0 ;
  size_t tmp ;

  {
  {
#line 591
  tmp = gl_array_sortedlist_indexof_from_to(list, compar, low, high, elt);
#line 591
  index___0 = tmp;
  }
#line 593
  return ((gl_list_node_t )(index___0 + 1UL));
}
}
#line 596 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_sortedlist_search(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                void const   *elt2 ) ,
                                                 void const   *elt ) 
{ 
  size_t index___0 ;
  size_t tmp ;

  {
  {
#line 600
  tmp = gl_array_sortedlist_indexof_from_to(list, compar, (size_t )0, list->count,
                                            elt);
#line 600
  index___0 = tmp;
  }
#line 602
  return ((gl_list_node_t )(index___0 + 1UL));
}
}
#line 605 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static gl_list_node_t gl_array_sortedlist_nx_add(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                                void const   *elt2 ) ,
                                                 void const   *elt ) 
{ 
  size_t count ;
  size_t low ;
  size_t high ;
  size_t mid ;
  int cmp ;
  int tmp ;
  gl_list_node_t tmp___0 ;

  {
#line 609
  count = list->count;
#line 610
  low = (size_t )0;
#line 611
  high = count;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (low < high)) {
#line 615
      goto while_break;
    }
    {
#line 617
    mid = low + (high - low) / 2UL;
#line 618
    tmp = (*compar)(*(list->elements + mid), elt);
#line 618
    cmp = tmp;
    }
#line 620
    if (cmp < 0) {
#line 621
      low = mid + 1UL;
    } else
#line 622
    if (cmp > 0) {
#line 623
      high = mid;
    } else {
#line 626
      low = mid;
#line 627
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 630
  tmp___0 = gl_array_nx_add_at(list, low, elt);
  }
#line 630
  return (tmp___0);
}
}
#line 633 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
static _Bool gl_array_sortedlist_remove(gl_list_t list , int (*compar)(void const   *elt1 ,
                                                                       void const   *elt2 ) ,
                                        void const   *elt ) 
{ 
  size_t index___0 ;
  size_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 637
  tmp = gl_array_sortedlist_indexof(list, compar, elt);
#line 637
  index___0 = tmp;
  }
#line 638
  if (index___0 == 0xffffffffffffffffUL) {
#line 639
    return ((_Bool)0);
  } else {
    {
#line 641
    tmp___0 = gl_array_remove_at(list, index___0);
    }
#line 641
    return (tmp___0);
  }
}
}
#line 645 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gl_array_list.c"
struct gl_list_implementation  const  gl_array_list_implementation  = 
#line 645
     {& gl_array_nx_create_empty, & gl_array_nx_create, & gl_array_size, (void const   *(*)(gl_list_t list ,
                                                                                          gl_list_node_t node ))(& gl_array_node_value),
    & gl_array_node_nx_set_value, (gl_list_node_t (*)(gl_list_t list , gl_list_node_t node ))(& gl_array_next_node),
    (gl_list_node_t (*)(gl_list_t list , gl_list_node_t node ))(& gl_array_previous_node),
    (void const   *(*)(gl_list_t list , size_t position ))(& gl_array_get_at), & gl_array_nx_set_at,
    & gl_array_search_from_to, & gl_array_indexof_from_to, & gl_array_nx_add_first,
    & gl_array_nx_add_last, & gl_array_nx_add_before, & gl_array_nx_add_after, & gl_array_nx_add_at,
    & gl_array_remove_node, & gl_array_remove_at, & gl_array_remove, & gl_array_list_free,
    & gl_array_iterator, & gl_array_iterator_from_to, & gl_array_iterator_next, & gl_array_iterator_free,
    & gl_array_sortedlist_search, & gl_array_sortedlist_search_from_to, & gl_array_sortedlist_indexof,
    & gl_array_sortedlist_indexof_from_to, & gl_array_sortedlist_nx_add, & gl_array_sortedlist_remove};
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 126 "./timespec.h"
struct timespec current_timespec(void) ;
#line 28 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gettime.c"
void ( __attribute__((__nonnull__(1))) gettime)(struct timespec *ts ) 
{ 


  {
  {
#line 32
  clock_gettime(0, ts);
  }
#line 39
  return;
}
}
#line 43 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/gettime.c"
struct timespec current_timespec(void) 
{ 
  struct timespec ts ;

  {
  {
#line 47
  gettime(& ts);
  }
#line 48
  return (ts);
}
}
#line 29 "./getprogname.h"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 57 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/getprogname.c"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 57 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/getprogname.c"
char const   *getprogname(void) 
{ 


  {
#line 62
  return ((char const   *)program_invocation_short_name);
}
}
#line 32 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/get-permissions.c"
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) 
{ 


  {
  {
#line 36
  memset((void *)ctx, 0, sizeof(*ctx));
#line 37
  ctx->mode = mode;
  }
#line 289
  return (0);
}
}
#line 29 "./full-write.h"
size_t full_write(int fd , void const   *buf , size_t count ) ;
#line 57 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/full-write.c"
size_t full_write(int fd , void const   *buf , size_t count ) 
{ 
  size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 60
  total = (size_t )0;
#line 61
  ptr = (char const   *)buf;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (count > 0UL)) {
#line 63
      goto while_break;
    }
    {
#line 65
    tmp = safe_write(fd, (void const   *)ptr, count);
#line 65
    n_rw = tmp;
    }
#line 66
    if (n_rw == 0xffffffffffffffffUL) {
#line 67
      goto while_break;
    }
#line 68
    if (n_rw == 0UL) {
      {
#line 70
      tmp___0 = __errno_location();
#line 70
      *tmp___0 = 28;
      }
#line 71
      goto while_break;
    }
#line 73
    total += n_rw;
#line 74
    ptr += n_rw;
#line 75
    count -= n_rw;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (total);
}
}
#line 37 "./fseterr.h"
void fseterr(FILE *fp ) ;
#line 29 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fseterr.c"
void fseterr(FILE *fp ) 
{ 


  {
#line 37
  fp->_flags |= 32;
#line 84
  return;
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 591 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 173 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fcntl.c"
static int rpl_fcntl_DUPFD(int fd , int target ) ;
#line 175
static int rpl_fcntl_DUPFD_CLOEXEC(int fd , int target ) ;
#line 201 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list___0 arg ;
  int result ;
  int target ;
  int tmp___0 ;
  int target___0 ;
  int tmp___2 ;
  int x ;
  int tmp___4 ;
  void *p ;
  void *tmp___6 ;

  {
  {
#line 209
  result = -1;
#line 210
  __builtin_va_start(arg, action);
  }
  {
#line 213
  if (action == 0) {
#line 213
    goto case_0;
  }
#line 220
  if (action == 1030) {
#line 220
    goto case_1030;
  }
#line 256
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 215
  tmp___0 = __builtin_va_arg(arg, int );
#line 215
  target = tmp___0;
#line 216
  result = rpl_fcntl_DUPFD(fd, target);
  }
#line 217
  goto switch_break;
  case_1030: /* CIL Label */ 
  {
#line 222
  tmp___2 = __builtin_va_arg(arg, int );
#line 222
  target___0 = tmp___2;
#line 223
  result = rpl_fcntl_DUPFD_CLOEXEC(fd, target___0);
  }
#line 224
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 313
  if (action == 11) {
#line 313
    goto case_11;
  }
#line 313
  if (action == 1034) {
#line 313
    goto case_11;
  }
#line 313
  if (action == 1032) {
#line 313
    goto case_11;
  }
#line 313
  if (action == 9) {
#line 313
    goto case_11;
  }
#line 313
  if (action == 1025) {
#line 313
    goto case_11;
  }
#line 313
  if (action == 3) {
#line 313
    goto case_11;
  }
#line 313
  if (action == 1) {
#line 313
    goto case_11;
  }
#line 416
  if (action == 10) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 1031) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 8) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 1024) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 4) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 2) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 1026) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 1030) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 0) {
#line 416
    goto case_10;
  }
#line 416
  if (action == 1033) {
#line 416
    goto case_10;
  }
#line 428
  goto switch_default___0;
  case_11: /* CIL Label */ 
  case_1034: /* CIL Label */ 
  case_1032: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_1025: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 328
  result = fcntl(fd, action);
  }
#line 329
  goto switch_break___0;
  case_10: /* CIL Label */ 
  case_1031: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_1024: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1026: /* CIL Label */ 
  case_1030___0: /* CIL Label */ 
  case_0___0: /* CIL Label */ 
  case_1033: /* CIL Label */ 
  {
#line 423
  tmp___4 = __builtin_va_arg(arg, int );
#line 423
  x = tmp___4;
#line 424
  result = fcntl(fd, action, x);
  }
#line 426
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 431
  tmp___6 = __builtin_va_arg(arg, void *);
#line 431
  p = tmp___6;
#line 432
  result = fcntl(fd, action, p);
  }
#line 434
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 439
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 442
  __builtin_va_end(arg);
  }
#line 443
  return (result);
}
}
#line 446 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fcntl.c"
static int rpl_fcntl_DUPFD(int fd , int target ) 
{ 
  int result ;

  {
  {
#line 482
  result = fcntl(fd, 0, target);
  }
#line 484
  return (result);
}
}
#line 507 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 487 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fcntl.c"
static int rpl_fcntl_DUPFD_CLOEXEC(int fd , int target ) 
{ 
  int result ;
  int *tmp ;
  int flags ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 508
  if (0 <= have_dupfd_cloexec) {
    {
#line 510
    result = fcntl(fd, 1030, target);
    }
#line 511
    if (0 <= result) {
#line 513
      have_dupfd_cloexec = 1;
    } else {
      {
#line 511
      tmp = __errno_location();
      }
#line 511
      if (*tmp != 22) {
#line 513
        have_dupfd_cloexec = 1;
      } else {
        {
#line 521
        result = rpl_fcntl_DUPFD(fd, target);
        }
#line 522
        if (result >= 0) {
#line 523
          have_dupfd_cloexec = -1;
        }
      }
    }
  } else {
    {
#line 528
    result = rpl_fcntl_DUPFD(fd, target);
    }
  }
#line 529
  if (0 <= result) {
#line 529
    if (have_dupfd_cloexec == -1) {
      {
#line 531
      tmp___0 = fcntl(result, 1);
#line 531
      flags = tmp___0;
      }
#line 532
      if (flags < 0) {
#line 532
        goto _L;
      } else {
        {
#line 532
        tmp___3 = fcntl(result, 2, flags | 1);
        }
#line 532
        if (tmp___3 == -1) {
          _L: /* CIL Label */ 
          {
#line 534
          tmp___1 = __errno_location();
#line 534
          saved_errno = *tmp___1;
#line 535
          close(result);
#line 536
          tmp___2 = __errno_location();
#line 536
          *tmp___2 = saved_errno;
#line 537
          result = -1;
          }
        }
      }
    }
  }
#line 541
  return (result);
}
}
#line 69 "./fatal-signal.h"
void block_fatal_signals(void) ;
#line 72
void unblock_fatal_signals(void) ;
#line 78
unsigned int get_fatal_signals(int *signals ) ;
#line 123 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 196
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 202
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
#line 229
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 240
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 51 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static int fatal_signals[7]  = {      2,      15,      1,      13, 
        24,      25,      0};
#line 88
static void init_fatal_signals(void) ;
#line 88 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static _Bool fatal_signals_initialized  =    (_Bool)0;
#line 85 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static void init_fatal_signals(void) 
{ 
  size_t i ;
  struct sigaction action ;
  int tmp ;
  sa_handler_t __attribute__((__pure__))  tmp___0 ;

  {
#line 89
  if (! fatal_signals_initialized) {
#line 93
    i = (size_t )0;
    {
#line 93
    while (1) {
      while_continue: /* CIL Label */ ;
#line 93
      if (! (i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 93
        goto while_break;
      }
      {
#line 97
      tmp = sigaction(fatal_signals[i], (struct sigaction  const  */* __restrict  */)((void *)0),
                      (struct sigaction */* __restrict  */)(& action));
      }
#line 97
      if (tmp >= 0) {
        {
#line 97
        tmp___0 = get_handler((struct sigaction  const  *)(& action));
        }
#line 97
        if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))1)) {
#line 99
          fatal_signals[i] = -1;
        }
      }
#line 93
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 102
    fatal_signals_initialized = (_Bool)1;
  }
#line 104
  return;
}
}
#line 122 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static actions_entry_t static_actions[32]  ;
#line 123 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static actions_entry_t * volatile  actions  =    (actions_entry_t */* volatile  */)(static_actions);
#line 124 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static int volatile   actions_count  =    (sig_atomic_t volatile   )0;
#line 125 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static size_t actions_allocated  =    sizeof(static_actions) / sizeof(static_actions[0]);
#line 130 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static struct sigaction saved_sigactions[64]  ;
#line 134 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static void uninstall_handlers(void) 
{ 
  size_t i ;
  int sig ;

  {
#line 139
  i = (size_t )0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 139
      goto while_break;
    }
#line 140
    if (fatal_signals[i] >= 0) {
#line 142
      sig = fatal_signals[i];
#line 143
      if ((unsigned long )saved_sigactions[sig].__sigaction_handler.sa_handler == (unsigned long )((void (*)(int  ))1)) {
#line 144
        saved_sigactions[sig].__sigaction_handler.sa_handler = (void (*)(int  ))0;
      }
      {
#line 145
      sigaction(sig, (struct sigaction  const  */* __restrict  */)(& saved_sigactions[sig]),
                (struct sigaction */* __restrict  */)((void *)0));
      }
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  return;
}
}
#line 151 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static void fatal_signal_handler(int sig ) 
{ 
  void (*action)(int sig ) ;
  size_t n ;

  {
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    n = (size_t )actions_count;
#line 159
    if (n == 0UL) {
#line 160
      goto while_break;
    }
    {
#line 161
    n --;
#line 162
    actions_count = (int volatile   )n;
#line 163
    action = (void (*)(int sig ))(actions + n)->action;
#line 165
    (*action)(sig);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  uninstall_handlers();
#line 174
  raise(sig);
  }
#line 175
  return;
}
}
#line 179 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static void install_handlers(void) 
{ 
  size_t i ;
  struct sigaction action ;
  int sig ;

  {
  {
#line 185
  action.__sigaction_handler.sa_handler = & fatal_signal_handler;
#line 189
  action.sa_flags = 1073741824;
#line 190
  sigemptyset(& action.sa_mask);
#line 191
  i = (size_t )0;
  }
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 191
      goto while_break;
    }
#line 192
    if (fatal_signals[i] >= 0) {
#line 194
      sig = fatal_signals[i];
#line 196
      if (! ((unsigned long )sig < sizeof(saved_sigactions) / sizeof(saved_sigactions[0]))) {
        {
#line 197
        abort();
        }
      }
      {
#line 198
      sigaction(sig, (struct sigaction  const  */* __restrict  */)(& action), (struct sigaction */* __restrict  */)(& saved_sigactions[sig]));
      }
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 208 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static _Bool cleanup_initialized  =    (_Bool)0;
#line 205 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
void at_fatal_signal(void (*action)(int sig ) ) 
{ 
  actions_entry_t *old_actions ;
  size_t old_actions_allocated ;
  size_t new_actions_allocated ;
  actions_entry_t *new_actions ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t k ;

  {
#line 209
  if (! cleanup_initialized) {
    {
#line 211
    init_fatal_signals();
#line 212
    install_handlers();
#line 213
    cleanup_initialized = (_Bool)1;
    }
  }
#line 216
  if ((size_t )actions_count == actions_allocated) {
#line 221
    old_actions = (actions_entry_t *)actions;
#line 222
    old_actions_allocated = actions_allocated;
#line 223
    new_actions_allocated = 2UL * actions_allocated;
#line 224
    if (sizeof(actions_entry_t ) == 1UL) {
      {
#line 224
      tmp = xmalloc(new_actions_allocated);
#line 224
      tmp___1 = tmp;
      }
    } else {
      {
#line 224
      tmp___0 = xnmalloc(new_actions_allocated, sizeof(actions_entry_t ));
#line 224
      tmp___1 = tmp___0;
      }
    }
#line 224
    new_actions = (actions_entry_t *)tmp___1;
#line 231
    k = (size_t )0;
    {
#line 231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 231
      if (! (k < old_actions_allocated)) {
#line 231
        goto while_break;
      }
#line 232
      *(new_actions + k) = *(old_actions + k);
#line 231
      k ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 233
    actions = (actions_entry_t */* volatile  */)new_actions;
#line 234
    actions_allocated = new_actions_allocated;
#line 236
    if ((unsigned long )old_actions != (unsigned long )(static_actions)) {
      {
#line 237
      free((void *)old_actions);
      }
    }
  }
#line 243
  (actions + actions_count)->action = (void (*/* volatile  */)(int sig ))action;
#line 244
  actions_count += (int volatile   )1;
#line 245
  return;
}
}
#line 251 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static sigset_t fatal_signal_set  ;
#line 256
static void init_fatal_signal_set(void) ;
#line 256 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static _Bool fatal_signal_set_initialized  =    (_Bool)0;
#line 253 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
static void init_fatal_signal_set(void) 
{ 
  size_t i ;

  {
#line 257
  if (! fatal_signal_set_initialized) {
    {
#line 261
    init_fatal_signals();
#line 263
    sigemptyset(& fatal_signal_set);
#line 264
    i = (size_t )0;
    }
    {
#line 264
    while (1) {
      while_continue: /* CIL Label */ ;
#line 264
      if (! (i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 264
        goto while_break;
      }
#line 265
      if (fatal_signals[i] >= 0) {
        {
#line 266
        sigaddset(& fatal_signal_set, fatal_signals[i]);
        }
      }
#line 264
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 268
    fatal_signal_set_initialized = (_Bool)1;
  }
#line 270
  return;
}
}
#line 273 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
void block_fatal_signals(void) 
{ 


  {
  {
#line 276
  init_fatal_signal_set();
#line 277
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& fatal_signal_set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 278
  return;
}
}
#line 281 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
void unblock_fatal_signals(void) 
{ 


  {
  {
#line 284
  init_fatal_signal_set();
#line 285
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& fatal_signal_set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 286
  return;
}
}
#line 289 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/fatal-signal.c"
unsigned int get_fatal_signals(int *signals ) 
{ 
  int *p ;
  size_t i ;
  int *tmp ;

  {
  {
#line 292
  init_fatal_signal_set();
#line 295
  p = (int *)signals;
#line 298
  i = (size_t )0;
  }
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i < sizeof(fatal_signals) / sizeof(fatal_signals[0]) - 1UL)) {
#line 298
      goto while_break;
    }
#line 299
    if (fatal_signals[i] >= 0) {
#line 300
      tmp = p;
#line 300
      p ++;
#line 300
      *tmp = fatal_signals[i];
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return ((unsigned int )(p - (int *)signals));
}
}
#line 24 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 37 "./execute.h"
int execute(char const   *progname , char const   *prog_path , char **prog_argv ,
            _Bool ignore_sigpipe , _Bool null_stdin , _Bool null_stdout , _Bool null_stderr ,
            _Bool slave_process , _Bool exit_on_error , int *termsigp ) ;
#line 548 "/usr/include/unistd.h"
extern char **environ ;
#line 84 "/usr/include/spawn.h"
extern int posix_spawnp(pid_t *__pid , char const   *__file , posix_spawn_file_actions_t const   *__file_actions ,
                        posix_spawnattr_t const   *__attrp , char * const  *__argv ,
                        char * const  *__envp ) ;
#line 91
extern  __attribute__((__nothrow__)) int posix_spawnattr_init(posix_spawnattr_t *__attr ) ;
#line 94
extern  __attribute__((__nothrow__)) int posix_spawnattr_destroy(posix_spawnattr_t *__attr ) ;
#line 115
extern  __attribute__((__nothrow__)) int posix_spawnattr_setsigmask(posix_spawnattr_t * __restrict  __attr ,
                                                                    sigset_t const   * __restrict  __sigmask ) ;
#line 125
extern  __attribute__((__nothrow__)) int posix_spawnattr_setflags(posix_spawnattr_t *_attr ,
                                                                  short __flags ) ;
#line 160
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_init(posix_spawn_file_actions_t *__file_actions ) ;
#line 164
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *__file_actions ) ;
#line 169
extern  __attribute__((__nothrow__)) int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t * __restrict  __file_actions ,
                                                                          int __fd ,
                                                                          char const   * __restrict  __path ,
                                                                          int __oflag ,
                                                                          mode_t __mode ) ;
#line 95 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/execute.c"
int execute(char const   *progname , char const   *prog_path , char **prog_argv ,
            _Bool ignore_sigpipe , _Bool null_stdin , _Bool null_stdout , _Bool null_stderr ,
            _Bool slave_process , _Bool exit_on_error , int *termsigp ) 
{ 
  sigset_t blocked_signals ;
  posix_spawn_file_actions_t actions___0 ;
  _Bool actions_allocated___0 ;
  posix_spawnattr_t attrs ;
  _Bool attrs_allocated ;
  int err ;
  pid_t child ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  posix_spawnattr_t *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 207
  if (slave_process) {
    {
#line 209
    sigprocmask(2, (sigset_t const   */* __restrict  */)((void *)0), (sigset_t */* __restrict  */)(& blocked_signals));
#line 210
    block_fatal_signals();
    }
  }
  {
#line 212
  actions_allocated___0 = (_Bool)0;
#line 213
  attrs_allocated = (_Bool)0;
#line 214
  err = posix_spawn_file_actions_init(& actions___0);
  }
#line 214
  if (err != 0) {
#line 214
    goto _L___4;
  } else {
#line 214
    actions_allocated___0 = (_Bool)1;
#line 214
    if (null_stdin) {
      {
#line 214
      err = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t */* __restrict  */)(& actions___0),
                                             0, (char const   */* __restrict  */)"/dev/null",
                                             0, (mode_t )0);
      }
#line 214
      if (err != 0) {
#line 214
        tmp___3 = 1;
      } else {
#line 214
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 214
    if (null_stdout) {
      {
#line 214
      err = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t */* __restrict  */)(& actions___0),
                                             1, (char const   */* __restrict  */)"/dev/null",
                                             2, (mode_t )0);
      }
#line 214
      if (err != 0) {
#line 214
        tmp___3 = 1;
      } else {
#line 214
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 214
    if (null_stderr) {
      {
#line 214
      err = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t */* __restrict  */)(& actions___0),
                                             2, (char const   */* __restrict  */)"/dev/null",
                                             2, (mode_t )0);
      }
#line 214
      if (err != 0) {
#line 214
        tmp___3 = 1;
      } else {
#line 214
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 214
    if (slave_process) {
      {
#line 214
      err = posix_spawnattr_init(& attrs);
      }
#line 214
      if (err != 0) {
#line 214
        tmp___3 = 1;
      } else {
        {
#line 214
        attrs_allocated = (_Bool)1;
#line 214
        err = posix_spawnattr_setsigmask((posix_spawnattr_t */* __restrict  */)(& attrs),
                                         (sigset_t const   */* __restrict  */)(& blocked_signals));
        }
#line 214
        if (err != 0) {
#line 214
          tmp___1 = 1;
        } else {
          {
#line 214
          err = posix_spawnattr_setflags(& attrs, (short)8);
          }
#line 214
          if (err != 0) {
#line 214
            tmp___1 = 1;
          } else {
#line 214
            tmp___1 = 0;
          }
        }
#line 214
        if (tmp___1) {
#line 214
          tmp___3 = 1;
        } else {
#line 214
          goto _L___0;
        }
      }
    } else {
      _L___0: /* CIL Label */ 
#line 214
      if (attrs_allocated) {
#line 214
        tmp___2 = & attrs;
      } else {
#line 214
        tmp___2 = (posix_spawnattr_t *)((void *)0);
      }
      {
#line 214
      err = posix_spawnp(& child, prog_path, (posix_spawn_file_actions_t const   *)(& actions___0),
                         (posix_spawnattr_t const   *)tmp___2, (char * const  *)prog_argv,
                         (char * const  *)environ);
      }
#line 214
      if (err != 0) {
#line 214
        tmp___3 = 1;
      } else {
#line 214
        tmp___3 = 0;
      }
    }
#line 214
    if (tmp___3) {
      _L___4: /* CIL Label */ 
#line 248
      if (actions_allocated___0) {
        {
#line 249
        posix_spawn_file_actions_destroy(& actions___0);
        }
      }
#line 250
      if (attrs_allocated) {
        {
#line 251
        posix_spawnattr_destroy(& attrs);
        }
      }
#line 252
      if (slave_process) {
        {
#line 253
        unblock_fatal_signals();
        }
      }
#line 254
      if ((unsigned long )termsigp != (unsigned long )((void *)0)) {
#line 255
        *termsigp = 0;
      }
#line 256
      if (exit_on_error) {
#line 256
        goto _L;
      } else
#line 256
      if (! null_stderr) {
        _L: /* CIL Label */ 
        {
#line 257
        tmp = dcgettext((char const   *)((void *)0), "%s subprocess failed", 5);
        }
#line 257
        if (exit_on_error) {
#line 257
          tmp___0 = 1;
        } else {
#line 257
          tmp___0 = 0;
        }
        {
#line 257
        error(tmp___0, err, (char const   *)tmp, progname);
        }
      }
#line 259
      return (127);
    }
  }
  {
#line 261
  posix_spawn_file_actions_destroy(& actions___0);
  }
#line 262
  if (attrs_allocated) {
    {
#line 263
    posix_spawnattr_destroy(& attrs);
    }
  }
#line 264
  if (slave_process) {
    {
#line 266
    register_slave_subprocess(child);
#line 267
    unblock_fatal_signals();
    }
  }
  {
#line 270
  tmp___4 = wait_subprocess(child, progname, ignore_sigpipe, null_stderr, slave_process,
                            exit_on_error, termsigp);
  }
#line 270
  return (tmp___4);
}
}
#line 43 "./dirname.h"
char *mdir_name(char const   *file ) ;
#line 45
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 26 "./crc.h"
uint32_t crc32(char const   *buf , size_t len ) ;
#line 31
uint32_t crc32_update(uint32_t crc , char const   *buf , size_t len ) ;
#line 37
uint32_t crc32_no_xor(char const   *buf , size_t len ) ;
#line 44
uint32_t crc32_update_no_xor(uint32_t crc , char const   *buf , size_t len ) ;
#line 25 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/crc.c"
static uint32_t const   crc32_table[256]  = 
#line 25 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/crc.c"
  {      (uint32_t const   )0,      (uint32_t const   )1996959894,      (uint32_t const   )3993919788U,      (uint32_t const   )2567524794U, 
        (uint32_t const   )124634137,      (uint32_t const   )1886057615,      (uint32_t const   )3915621685U,      (uint32_t const   )2657392035U, 
        (uint32_t const   )249268274,      (uint32_t const   )2044508324,      (uint32_t const   )3772115230U,      (uint32_t const   )2547177864U, 
        (uint32_t const   )162941995,      (uint32_t const   )2125561021,      (uint32_t const   )3887607047U,      (uint32_t const   )2428444049U, 
        (uint32_t const   )498536548,      (uint32_t const   )1789927666,      (uint32_t const   )4089016648U,      (uint32_t const   )2227061214U, 
        (uint32_t const   )450548861,      (uint32_t const   )1843258603,      (uint32_t const   )4107580753U,      (uint32_t const   )2211677639U, 
        (uint32_t const   )325883990,      (uint32_t const   )1684777152,      (uint32_t const   )4251122042U,      (uint32_t const   )2321926636U, 
        (uint32_t const   )335633487,      (uint32_t const   )1661365465,      (uint32_t const   )4195302755U,      (uint32_t const   )2366115317U, 
        (uint32_t const   )997073096,      (uint32_t const   )1281953886,      (uint32_t const   )3579855332U,      (uint32_t const   )2724688242U, 
        (uint32_t const   )1006888145,      (uint32_t const   )1258607687,      (uint32_t const   )3524101629U,      (uint32_t const   )2768942443U, 
        (uint32_t const   )901097722,      (uint32_t const   )1119000684,      (uint32_t const   )3686517206U,      (uint32_t const   )2898065728U, 
        (uint32_t const   )853044451,      (uint32_t const   )1172266101,      (uint32_t const   )3705015759U,      (uint32_t const   )2882616665U, 
        (uint32_t const   )651767980,      (uint32_t const   )1373503546,      (uint32_t const   )3369554304U,      (uint32_t const   )3218104598U, 
        (uint32_t const   )565507253,      (uint32_t const   )1454621731,      (uint32_t const   )3485111705U,      (uint32_t const   )3099436303U, 
        (uint32_t const   )671266974,      (uint32_t const   )1594198024,      (uint32_t const   )3322730930U,      (uint32_t const   )2970347812U, 
        (uint32_t const   )795835527,      (uint32_t const   )1483230225,      (uint32_t const   )3244367275U,      (uint32_t const   )3060149565U, 
        (uint32_t const   )1994146192,      (uint32_t const   )31158534,      (uint32_t const   )2563907772U,      (uint32_t const   )4023717930U, 
        (uint32_t const   )1907459465,      (uint32_t const   )112637215,      (uint32_t const   )2680153253U,      (uint32_t const   )3904427059U, 
        (uint32_t const   )2013776290,      (uint32_t const   )251722036,      (uint32_t const   )2517215374U,      (uint32_t const   )3775830040U, 
        (uint32_t const   )2137656763,      (uint32_t const   )141376813,      (uint32_t const   )2439277719U,      (uint32_t const   )3865271297U, 
        (uint32_t const   )1802195444,      (uint32_t const   )476864866,      (uint32_t const   )2238001368U,      (uint32_t const   )4066508878U, 
        (uint32_t const   )1812370925,      (uint32_t const   )453092731,      (uint32_t const   )2181625025U,      (uint32_t const   )4111451223U, 
        (uint32_t const   )1706088902,      (uint32_t const   )314042704,      (uint32_t const   )2344532202U,      (uint32_t const   )4240017532U, 
        (uint32_t const   )1658658271,      (uint32_t const   )366619977,      (uint32_t const   )2362670323U,      (uint32_t const   )4224994405U, 
        (uint32_t const   )1303535960,      (uint32_t const   )984961486,      (uint32_t const   )2747007092U,      (uint32_t const   )3569037538U, 
        (uint32_t const   )1256170817,      (uint32_t const   )1037604311,      (uint32_t const   )2765210733U,      (uint32_t const   )3554079995U, 
        (uint32_t const   )1131014506,      (uint32_t const   )879679996,      (uint32_t const   )2909243462U,      (uint32_t const   )3663771856U, 
        (uint32_t const   )1141124467,      (uint32_t const   )855842277,      (uint32_t const   )2852801631U,      (uint32_t const   )3708648649U, 
        (uint32_t const   )1342533948,      (uint32_t const   )654459306,      (uint32_t const   )3188396048U,      (uint32_t const   )3373015174U, 
        (uint32_t const   )1466479909,      (uint32_t const   )544179635,      (uint32_t const   )3110523913U,      (uint32_t const   )3462522015U, 
        (uint32_t const   )1591671054,      (uint32_t const   )702138776,      (uint32_t const   )2966460450U,      (uint32_t const   )3352799412U, 
        (uint32_t const   )1504918807,      (uint32_t const   )783551873,      (uint32_t const   )3082640443U,      (uint32_t const   )3233442989U, 
        (uint32_t const   )3988292384U,      (uint32_t const   )2596254646U,      (uint32_t const   )62317068,      (uint32_t const   )1957810842, 
        (uint32_t const   )3939845945U,      (uint32_t const   )2647816111U,      (uint32_t const   )81470997,      (uint32_t const   )1943803523, 
        (uint32_t const   )3814918930U,      (uint32_t const   )2489596804U,      (uint32_t const   )225274430,      (uint32_t const   )2053790376, 
        (uint32_t const   )3826175755U,      (uint32_t const   )2466906013U,      (uint32_t const   )167816743,      (uint32_t const   )2097651377, 
        (uint32_t const   )4027552580U,      (uint32_t const   )2265490386U,      (uint32_t const   )503444072,      (uint32_t const   )1762050814, 
        (uint32_t const   )4150417245U,      (uint32_t const   )2154129355U,      (uint32_t const   )426522225,      (uint32_t const   )1852507879, 
        (uint32_t const   )4275313526U,      (uint32_t const   )2312317920U,      (uint32_t const   )282753626,      (uint32_t const   )1742555852, 
        (uint32_t const   )4189708143U,      (uint32_t const   )2394877945U,      (uint32_t const   )397917763,      (uint32_t const   )1622183637, 
        (uint32_t const   )3604390888U,      (uint32_t const   )2714866558U,      (uint32_t const   )953729732,      (uint32_t const   )1340076626, 
        (uint32_t const   )3518719985U,      (uint32_t const   )2797360999U,      (uint32_t const   )1068828381,      (uint32_t const   )1219638859, 
        (uint32_t const   )3624741850U,      (uint32_t const   )2936675148U,      (uint32_t const   )906185462,      (uint32_t const   )1090812512, 
        (uint32_t const   )3747672003U,      (uint32_t const   )2825379669U,      (uint32_t const   )829329135,      (uint32_t const   )1181335161, 
        (uint32_t const   )3412177804U,      (uint32_t const   )3160834842U,      (uint32_t const   )628085408,      (uint32_t const   )1382605366, 
        (uint32_t const   )3423369109U,      (uint32_t const   )3138078467U,      (uint32_t const   )570562233,      (uint32_t const   )1426400815, 
        (uint32_t const   )3317316542U,      (uint32_t const   )2998733608U,      (uint32_t const   )733239954,      (uint32_t const   )1555261956, 
        (uint32_t const   )3268935591U,      (uint32_t const   )3050360625U,      (uint32_t const   )752459403,      (uint32_t const   )1541320221, 
        (uint32_t const   )2607071920U,      (uint32_t const   )3965973030U,      (uint32_t const   )1969922972,      (uint32_t const   )40735498, 
        (uint32_t const   )2617837225U,      (uint32_t const   )3943577151U,      (uint32_t const   )1913087877,      (uint32_t const   )83908371, 
        (uint32_t const   )2512341634U,      (uint32_t const   )3803740692U,      (uint32_t const   )2075208622,      (uint32_t const   )213261112, 
        (uint32_t const   )2463272603U,      (uint32_t const   )3855990285U,      (uint32_t const   )2094854071,      (uint32_t const   )198958881, 
        (uint32_t const   )2262029012U,      (uint32_t const   )4057260610U,      (uint32_t const   )1759359992,      (uint32_t const   )534414190, 
        (uint32_t const   )2176718541U,      (uint32_t const   )4139329115U,      (uint32_t const   )1873836001,      (uint32_t const   )414664567, 
        (uint32_t const   )2282248934U,      (uint32_t const   )4279200368U,      (uint32_t const   )1711684554,      (uint32_t const   )285281116, 
        (uint32_t const   )2405801727U,      (uint32_t const   )4167216745U,      (uint32_t const   )1634467795,      (uint32_t const   )376229701, 
        (uint32_t const   )2685067896U,      (uint32_t const   )3608007406U,      (uint32_t const   )1308918612,      (uint32_t const   )956543938, 
        (uint32_t const   )2808555105U,      (uint32_t const   )3495958263U,      (uint32_t const   )1231636301,      (uint32_t const   )1047427035, 
        (uint32_t const   )2932959818U,      (uint32_t const   )3654703836U,      (uint32_t const   )1088359270,      (uint32_t const   )936918000, 
        (uint32_t const   )2847714899U,      (uint32_t const   )3736837829U,      (uint32_t const   )1202900863,      (uint32_t const   )817233897, 
        (uint32_t const   )3183342108U,      (uint32_t const   )3401237130U,      (uint32_t const   )1404277552,      (uint32_t const   )615818150, 
        (uint32_t const   )3134207493U,      (uint32_t const   )3453421203U,      (uint32_t const   )1423857449,      (uint32_t const   )601450431, 
        (uint32_t const   )3009837614U,      (uint32_t const   )3294710456U,      (uint32_t const   )1567103746,      (uint32_t const   )711928724, 
        (uint32_t const   )3020668471U,      (uint32_t const   )3272380065U,      (uint32_t const   )1510334235,      (uint32_t const   )755167117};
#line 76 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/crc.c"
uint32_t crc32_update_no_xor(uint32_t crc , char const   *buf , size_t len ) 
{ 
  size_t n ;

  {
#line 81
  n = (size_t )0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (n < len)) {
#line 81
      goto while_break;
    }
#line 82
    crc = (uint32_t )(crc32_table[(crc ^ (unsigned int )*(buf + n)) & 255U] ^ (unsigned int const   )(crc >> 8));
#line 81
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (crc);
}
}
#line 87 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/crc.c"
uint32_t crc32_no_xor(char const   *buf , size_t len ) 
{ 
  uint32_t tmp ;

  {
  {
#line 90
  tmp = crc32_update_no_xor((uint32_t )0L, buf, len);
  }
#line 90
  return (tmp);
}
}
#line 93 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/crc.c"
uint32_t crc32_update(uint32_t crc , char const   *buf , size_t len ) 
{ 
  uint32_t tmp ;

  {
  {
#line 96
  tmp = crc32_update_no_xor(crc ^ 4294967295U, buf, len);
  }
#line 96
  return (tmp ^ 4294967295U);
}
}
#line 99 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/crc.c"
uint32_t crc32(char const   *buf , size_t len ) 
{ 
  uint32_t tmp ;

  {
  {
#line 102
  tmp = crc32_update((uint32_t )0L, buf, len);
  }
#line 102
  return (tmp);
}
}
#line 42 "./copy-file.h"
int qcopy_file_preserving(char const   *src_filename , char const   *dest_filename ) ;
#line 49
void copy_file_preserving(char const   *src_filename , char const   *dest_filename ) ;
#line 476 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
#line 1110
extern ssize_t copy_file_range(int __infd , __off64_t *__pinoff , int __outfd , __off64_t *__poutoff ,
                               size_t __length , unsigned int __flags ) ;
#line 49 "./binary-io.h"
__inline int __gl_setmode(int fd  __attribute__((__unused__)) , int mode  __attribute__((__unused__)) ) 
{ 


  {
#line 52
  return (0);
}
}
#line 65 "./binary-io.h"
__inline int set_binary_mode(int fd , int mode ) 
{ 
  int tmp ;

  {
  {
#line 68
  tmp = __gl_setmode(fd, mode);
  }
#line 68
  return (tmp);
}
}
#line 46 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/copy-file.c"
int qcopy_file_preserving(char const   *src_filename , char const   *dest_filename ) 
{ 
  int err ;
  int src_fd ;
  struct stat statbuf ;
  int mode ;
  int dest_fd ;
  int tmp ;
  off_t inbytes ;
  __off_t tmp___0 ;
  _Bool empty_regular_file ;
  size_t copy_max ;
  size_t len ;
  size_t tmp___1 ;
  ssize_t copied ;
  ssize_t tmp___2 ;
  char smallbuf[1024] ;
  int bufsize ;
  char *buf ;
  void *tmp___3 ;
  size_t n_read ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct timespec ts[2] ;
  struct timespec  __attribute__((__pure__)) tmp___8 ;
  struct timespec  __attribute__((__pure__)) tmp___9 ;
  int __x ;
  int tmp___10 ;

  {
  {
#line 49
  err = 0;
#line 55
  src_fd = open(src_filename, 0);
  }
#line 56
  if (src_fd < 0) {
#line 57
    return (-1);
  }
  {
#line 58
  tmp = fstat(src_fd, & statbuf);
  }
#line 58
  if (tmp < 0) {
#line 60
    err = -1;
#line 61
    goto error_src;
  }
#line 64
  mode = (int )(statbuf.st_mode & 4095U);
#line 65
  if ((statbuf.st_mode & 61440U) == 32768U) {
#line 65
    tmp___0 = statbuf.st_size;
  } else {
#line 65
    tmp___0 = (__off_t )-1;
  }
  {
#line 65
  inbytes = tmp___0;
#line 66
  empty_regular_file = (_Bool )(inbytes == 0L);
#line 68
  dest_fd = open(dest_filename, 577, 384);
  }
#line 69
  if (dest_fd < 0) {
#line 71
    err = -2;
#line 72
    goto error_src;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (0L < inbytes)) {
#line 76
      goto while_break;
    }
#line 78
    copy_max = (size_t )-1;
#line 79
    copy_max -= copy_max % 32768UL;
#line 80
    if ((size_t )inbytes < copy_max) {
#line 80
      tmp___1 = (size_t )inbytes;
    } else {
#line 80
      tmp___1 = copy_max;
    }
    {
#line 80
    len = tmp___1;
#line 81
    tmp___2 = copy_file_range(src_fd, (__off64_t *)((void *)0), dest_fd, (__off64_t *)((void *)0),
                              len, 0U);
#line 81
    copied = tmp___2;
    }
#line 82
    if (copied <= 0L) {
#line 83
      goto while_break;
    }
#line 84
    inbytes -= copied;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  if (inbytes != 0L) {
#line 92
    goto _L;
  } else
#line 92
  if (empty_regular_file) {
    _L: /* CIL Label */ 
    {
#line 95
    bufsize = 32768;
#line 96
    tmp___3 = malloc((size_t )bufsize);
#line 96
    buf = (char *)tmp___3;
    }
#line 97
    if (! buf) {
#line 98
      buf = smallbuf;
#line 98
      bufsize = (int )sizeof(smallbuf);
    }
    {
#line 100
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 102
      tmp___4 = safe_read(src_fd, (void *)buf, (size_t )bufsize);
#line 102
      n_read = tmp___4;
      }
#line 103
      if (n_read == 0UL) {
#line 104
        goto while_break___0;
      }
#line 105
      if (n_read == 0xffffffffffffffffUL) {
#line 107
        err = -3;
#line 108
        goto while_break___0;
      }
      {
#line 110
      tmp___5 = full_write(dest_fd, (void const   *)buf, n_read);
      }
#line 110
      if (tmp___5 < n_read) {
#line 112
        err = -4;
#line 113
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 117
    if ((unsigned long )buf != (unsigned long )(smallbuf)) {
      {
#line 118
      free((void *)buf);
      }
    }
#line 119
    if (err) {
#line 120
      goto error_src_dest;
    }
  }
  {
#line 124
  tmp___6 = close(dest_fd);
  }
#line 124
  if (tmp___6 < 0) {
#line 126
    err = -4;
#line 127
    goto error_src;
  }
  {
#line 129
  tmp___7 = close(src_fd);
  }
#line 129
  if (tmp___7 < 0) {
#line 130
    return (-5);
  }
  {
#line 137
  tmp___8 = get_stat_atime((struct stat  const  *)(& statbuf));
#line 137
  ts[0] = (struct timespec )tmp___8;
#line 138
  tmp___9 = get_stat_mtime((struct stat  const  *)(& statbuf));
#line 138
  ts[1] = (struct timespec )tmp___9;
#line 139
  utimens(dest_filename, (struct timespec  const  *)(ts));
#line 144
  tmp___10 = chown(dest_filename, statbuf.st_uid, statbuf.st_gid);
#line 144
  __x = tmp___10;
#line 159
  chmod(dest_filename, (__mode_t )mode);
  }
#line 172
  return (0);
  error_src_dest: 
  {
#line 175
  close(dest_fd);
  }
  error_src: 
  {
#line 177
  close(src_fd);
  }
#line 178
  return (err);
}
}
#line 181 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/copy-file.c"
void copy_file_preserving(char const   *src_filename , char const   *dest_filename ) 
{ 
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  char const   *tmp___15 ;
  int *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;

  {
  {
#line 184
  tmp = qcopy_file_preserving(src_filename, dest_filename);
  }
  {
#line 186
  if (tmp == 0) {
#line 186
    goto case_0;
  }
#line 189
  if (tmp == -1) {
#line 189
    goto case_neg_1;
  }
#line 193
  if (tmp == -2) {
#line 193
    goto case_neg_2;
  }
#line 197
  if (tmp == -3) {
#line 197
    goto case_neg_3;
  }
#line 201
  if (tmp == -4) {
#line 201
    goto case_neg_4;
  }
#line 205
  if (tmp == -5) {
#line 205
    goto case_neg_5;
  }
#line 209
  if (tmp == -6) {
#line 209
    goto case_neg_6;
  }
#line 212
  if (tmp == -7) {
#line 212
    goto case_neg_7;
  }
#line 216
  goto switch_default;
  case_0: /* CIL Label */ 
#line 187
  return;
  case_neg_1: /* CIL Label */ 
  {
#line 190
  tmp___0 = quote(src_filename);
#line 190
  tmp___1 = dcgettext((char const   *)((void *)0), "error while opening %s for reading",
                      5);
#line 190
  tmp___2 = __errno_location();
#line 190
  error(1, *tmp___2, (char const   *)tmp___1, tmp___0);
  }
  case_neg_2: /* CIL Label */ 
  {
#line 194
  tmp___3 = quote(dest_filename);
#line 194
  tmp___4 = dcgettext((char const   *)((void *)0), "cannot open backup file %s for writing",
                      5);
#line 194
  tmp___5 = __errno_location();
#line 194
  error(1, *tmp___5, (char const   *)tmp___4, tmp___3);
  }
  case_neg_3: /* CIL Label */ 
  {
#line 198
  tmp___6 = quote(src_filename);
#line 198
  tmp___7 = dcgettext((char const   *)((void *)0), "error reading %s", 5);
#line 198
  tmp___8 = __errno_location();
#line 198
  error(1, *tmp___8, (char const   *)tmp___7, tmp___6);
  }
  case_neg_4: /* CIL Label */ 
  {
#line 202
  tmp___9 = quote(dest_filename);
#line 202
  tmp___10 = dcgettext((char const   *)((void *)0), "error writing %s", 5);
#line 202
  tmp___11 = __errno_location();
#line 202
  error(1, *tmp___11, (char const   *)tmp___10, tmp___9);
  }
  case_neg_5: /* CIL Label */ 
  {
#line 206
  tmp___12 = quote(src_filename);
#line 206
  tmp___13 = dcgettext((char const   *)((void *)0), "error after reading %s", 5);
#line 206
  tmp___14 = __errno_location();
#line 206
  error(1, *tmp___14, (char const   *)tmp___13, tmp___12);
  }
  case_neg_6: /* CIL Label */ 
  {
#line 210
  tmp___15 = quote(src_filename);
#line 210
  tmp___16 = __errno_location();
#line 210
  error(1, *tmp___16, "%s", tmp___15);
  }
  case_neg_7: /* CIL Label */ 
  {
#line 213
  tmp___17 = quote(dest_filename);
#line 213
  tmp___18 = dcgettext((char const   *)((void *)0), "preserving permissions for %s",
                       5);
#line 213
  tmp___19 = __errno_location();
#line 213
  error(1, *tmp___19, (char const   *)tmp___18, tmp___17);
  }
  switch_default: /* CIL Label */ 
  {
#line 217
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 32 "./acl.h"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 42 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/copy-acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 46
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
#line 46
  ret = tmp;
  }
  {
#line 49
  if (ret == -2) {
#line 49
    goto case_neg_2;
  }
#line 53
  if (ret == -1) {
#line 53
    goto case_neg_1;
  }
#line 57
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 50
  tmp___0 = quote(src_name);
#line 50
  tmp___1 = __errno_location();
#line 50
  error(0, *tmp___1, "%s", tmp___0);
  }
#line 51
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 54
  tmp___2 = quote(dst_name);
#line 54
  tmp___3 = dcgettext((char const   *)((void *)0), "preserving permissions for %s",
                      5);
#line 54
  tmp___4 = __errno_location();
#line 54
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
  }
#line 55
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 58
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 60
  return (ret);
}
}
#line 28 "./closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 2 "./close-stream.h"
int close_stream(FILE *stream ) ;
#line 46 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/closeout.c"
static char const   *file_name  ;
#line 50 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 53
  file_name = file;
#line 54
  return;
}
}
#line 56 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 87 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 90
  ignore_EPIPE = ignore;
#line 91
  return;
}
}
#line 116 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 119
  tmp___3 = close_stream(stdout);
  }
#line 119
  if (tmp___3 != 0) {
#line 119
    if (ignore_EPIPE) {
      {
#line 119
      tmp___4 = __errno_location();
      }
#line 119
      if (! (*tmp___4 == 32)) {
#line 119
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 122
      tmp = dcgettext((char const   *)((void *)0), "write error", 5);
#line 122
      write_error = (char const   *)tmp;
      }
#line 123
      if (file_name) {
        {
#line 124
        tmp___0 = quotearg_colon(file_name);
#line 124
        tmp___1 = __errno_location();
#line 124
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 127
        tmp___2 = __errno_location();
#line 127
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 129
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 134
  tmp___5 = close_stream(stderr);
  }
#line 134
  if (tmp___5 != 0) {
    {
#line 135
    _exit((int )exit_failure);
    }
  }
#line 136
  return;
}
}
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t __fpending(FILE *__fp ) ;
#line 55 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 32 "./cloexec.h"
int set_cloexec_flag(int desc , _Bool value___0 ) ;
#line 38
int dup_cloexec(int fd ) ;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value___0 ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
  }
#line 45
  if (0 <= flags) {
#line 47
    if (value___0) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
      {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/cloexec.c"
int dup_cloexec(int fd ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
  }
#line 82
  return (tmp);
}
}
#line 47 "./c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 29 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 41 "./base64.h"
_Bool isbase64(char ch )  __attribute__((__const__)) ;
#line 43
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) ;
#line 46
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) ;
#line 48
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
#line 50
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) ;
#line 54
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
#line 56 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
static unsigned char to_uchar___0(char ch ) 
{ 


  {
#line 59
  return ((unsigned char )ch);
}
}
#line 62 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
static char const   b64c[64]  = 
#line 62
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 68 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
static void base64_encode_fast(char const   * __restrict  in , size_t inlen , char * __restrict  out ) 
{ 
  char * __restrict  tmp ;
  unsigned char tmp___0 ;
  char * __restrict  tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  char * __restrict  tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  char * __restrict  tmp___7 ;
  unsigned char tmp___8 ;

  {
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! inlen) {
#line 71
      goto while_break;
    }
    {
#line 73
    tmp = out;
#line 73
    out ++;
#line 73
    tmp___0 = to_uchar___0((char )*(in + 0));
#line 73
    *tmp = (char )b64c[((int )tmp___0 >> 2) & 63];
#line 74
    tmp___1 = out;
#line 74
    out ++;
#line 74
    tmp___2 = to_uchar___0((char )*(in + 0));
#line 74
    tmp___3 = to_uchar___0((char )*(in + 1));
#line 74
    *tmp___1 = (char )b64c[(((int )tmp___2 << 4) + ((int )tmp___3 >> 4)) & 63];
#line 75
    tmp___4 = out;
#line 75
    out ++;
#line 75
    tmp___5 = to_uchar___0((char )*(in + 1));
#line 75
    tmp___6 = to_uchar___0((char )*(in + 2));
#line 75
    *tmp___4 = (char )b64c[(((int )tmp___5 << 2) + ((int )tmp___6 >> 6)) & 63];
#line 76
    tmp___7 = out;
#line 76
    out ++;
#line 76
    tmp___8 = to_uchar___0((char )*(in + 2));
#line 76
    *tmp___7 = (char )b64c[(int )tmp___8 & 63];
#line 78
    inlen -= 3UL;
#line 79
    in += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 87 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) 
{ 
  char * __restrict  tmp ;
  unsigned char tmp___0 ;
  char * __restrict  tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  int tmp___4 ;
  char * __restrict  tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  char * __restrict  tmp___9 ;
  unsigned char tmp___10 ;

  {
#line 98
  if (outlen % 4UL == 0UL) {
#line 98
    if (inlen == (outlen / 4UL) * 3UL) {
      {
#line 100
      base64_encode_fast(in, inlen, out);
      }
#line 101
      return;
    }
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (inlen) {
#line 104
      if (! outlen) {
#line 104
        goto while_break;
      }
    } else {
#line 104
      goto while_break;
    }
    {
#line 106
    tmp = out;
#line 106
    out ++;
#line 106
    tmp___0 = to_uchar___0((char )*(in + 0));
#line 106
    *tmp = (char )b64c[((int )tmp___0 >> 2) & 63];
#line 107
    outlen --;
    }
#line 107
    if (! outlen) {
#line 108
      goto while_break;
    }
    {
#line 109
    tmp___1 = out;
#line 109
    out ++;
#line 109
    tmp___2 = to_uchar___0((char )*(in + 0));
#line 109
    inlen --;
    }
#line 109
    if (inlen) {
      {
#line 109
      tmp___3 = to_uchar___0((char )*(in + 1));
#line 109
      tmp___4 = (int )tmp___3 >> 4;
      }
    } else {
#line 109
      tmp___4 = 0;
    }
#line 109
    *tmp___1 = (char )b64c[(((int )tmp___2 << 4) + tmp___4) & 63];
#line 112
    outlen --;
#line 112
    if (! outlen) {
#line 113
      goto while_break;
    }
#line 114
    tmp___5 = out;
#line 114
    out ++;
#line 114
    if (inlen) {
      {
#line 114
      tmp___6 = to_uchar___0((char )*(in + 1));
#line 114
      inlen --;
      }
#line 114
      if (inlen) {
        {
#line 114
        tmp___7 = to_uchar___0((char )*(in + 2));
#line 114
        tmp___8 = (int )tmp___7 >> 6;
        }
      } else {
#line 114
        tmp___8 = 0;
      }
#line 114
      *tmp___5 = (char )b64c[(((int )tmp___6 << 2) + tmp___8) & 63];
    } else {
#line 114
      *tmp___5 = (char )'=';
    }
#line 120
    outlen --;
#line 120
    if (! outlen) {
#line 121
      goto while_break;
    }
#line 122
    tmp___9 = out;
#line 122
    out ++;
#line 122
    if (inlen) {
      {
#line 122
      tmp___10 = to_uchar___0((char )*(in + 2));
#line 122
      *tmp___9 = (char )b64c[(int )tmp___10 & 63];
      }
    } else {
#line 122
      *tmp___9 = (char )'=';
    }
#line 123
    outlen --;
#line 123
    if (! outlen) {
#line 124
      goto while_break;
    }
#line 125
    if (inlen) {
#line 126
      inlen --;
    }
#line 127
    if (inlen) {
#line 128
      in += 3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (outlen) {
#line 132
    *out = (char )'\000';
  }
#line 133
  return;
}
}
#line 144 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) 
{ 
  size_t outlen ;
  void *tmp ;

  {
#line 147
  outlen = 1UL + ((inlen + 2UL) / 3UL) * 4UL;
#line 161
  if (inlen > outlen) {
#line 163
    *out = (char *)((void *)0);
#line 164
    return ((size_t )0);
  }
  {
#line 167
  tmp = malloc(outlen);
#line 167
  *out = (char *)tmp;
  }
#line 168
  if (! *out) {
#line 169
    return (outlen);
  }
  {
#line 171
  base64_encode((char const   */* __restrict  */)in, inlen, (char */* __restrict  */)*out,
                outlen);
  }
#line 173
  return (outlen - 1UL);
}
}
#line 252 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
static signed char const   b64[256]  = 
#line 252
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 328
_Bool isbase64(char ch )  __attribute__((__const__)) ;
#line 328 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
_Bool isbase64(char ch ) 
{ 
  unsigned char tmp ;

  {
  {
#line 331
  tmp = to_uchar___0(ch);
  }
#line 331
  return ((_Bool )(0 <= (int )b64[tmp]));
}
}
#line 335 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
void base64_decode_ctx_init(struct base64_decode_context *ctx ) 
{ 


  {
#line 338
  ctx->i = 0U;
#line 339
  return;
}
}
#line 348 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
static char *get_4(struct base64_decode_context *ctx , char const   * __restrict  *in ,
                   char const   * __restrict  in_end , size_t *n_non_newline ) 
{ 
  char const   *t ;
  void *tmp ;
  char const   *p ;
  char c ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 353
  if (ctx->i == 4U) {
#line 354
    ctx->i = 0U;
  }
#line 356
  if (ctx->i == 0U) {
#line 358
    t = (char const   *)*in;
#line 359
    if (4L <= in_end - *in) {
      {
#line 359
      tmp = memchr((void const   *)t, '\n', (size_t )4);
      }
#line 359
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 362
        *in += 4;
#line 363
        *n_non_newline = (size_t )4;
#line 364
        return ((char *)t);
      }
    }
  }
#line 370
  p = (char const   *)*in;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! ((unsigned long )p < (unsigned long )in_end)) {
#line 371
      goto while_break;
    }
#line 373
    tmp___0 = p;
#line 373
    p ++;
#line 373
    c = (char )*tmp___0;
#line 374
    if ((int )c != 10) {
#line 376
      tmp___1 = ctx->i;
#line 376
      (ctx->i) ++;
#line 376
      ctx->buf[tmp___1] = c;
#line 377
      if (ctx->i == 4U) {
#line 378
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  *in = (char const   */* __restrict  */)p;
#line 383
  *n_non_newline = (size_t )ctx->i;
#line 384
  return (ctx->buf);
}
}
#line 402 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
static _Bool decode_4(char const   * __restrict  in , size_t inlen , char * __restrict  *outp ,
                      size_t *outleft ) 
{ 
  char *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
#line 406
  out = (char *)*outp;
#line 407
  if (inlen < 2UL) {
#line 408
    return ((_Bool)0);
  }
  {
#line 410
  tmp = isbase64((char )*(in + 0));
  }
#line 410
  if (tmp) {
    {
#line 410
    tmp___0 = isbase64((char )*(in + 1));
    }
#line 410
    if (! tmp___0) {
#line 411
      return ((_Bool)0);
    }
  } else {
#line 411
    return ((_Bool)0);
  }
#line 413
  if (*outleft) {
    {
#line 415
    tmp___1 = out;
#line 415
    out ++;
#line 415
    tmp___2 = to_uchar___0((char )*(in + 0));
#line 415
    tmp___3 = to_uchar___0((char )*(in + 1));
#line 415
    *tmp___1 = (char )(((int const   )b64[tmp___2] << 2) | ((int const   )b64[tmp___3] >> 4));
#line 417
    (*outleft) --;
    }
  }
#line 420
  if (inlen == 2UL) {
    {
#line 421
    while (1) {
      while_continue: /* CIL Label */ ;
#line 421
      *outp = (char */* __restrict  */)out;
#line 421
      return ((_Bool)0);
#line 421
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 423
  if ((int const   )*(in + 2) == 61) {
#line 425
    if (inlen != 4UL) {
      {
#line 426
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 426
        *outp = (char */* __restrict  */)out;
#line 426
        return ((_Bool)0);
#line 426
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 428
    if ((int const   )*(in + 3) != 61) {
      {
#line 429
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 429
        *outp = (char */* __restrict  */)out;
#line 429
        return ((_Bool)0);
#line 429
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 433
    tmp___4 = isbase64((char )*(in + 2));
    }
#line 433
    if (! tmp___4) {
      {
#line 434
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 434
        *outp = (char */* __restrict  */)out;
#line 434
        return ((_Bool)0);
#line 434
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 436
    if (*outleft) {
      {
#line 438
      tmp___5 = out;
#line 438
      out ++;
#line 438
      tmp___6 = to_uchar___0((char )*(in + 1));
#line 438
      tmp___7 = to_uchar___0((char )*(in + 2));
#line 438
      *tmp___5 = (char )((((int const   )b64[tmp___6] << 4) & 240) | ((int const   )b64[tmp___7] >> 2));
#line 440
      (*outleft) --;
      }
    }
#line 443
    if (inlen == 3UL) {
      {
#line 444
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 444
        *outp = (char */* __restrict  */)out;
#line 444
        return ((_Bool)0);
#line 444
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 446
    if ((int const   )*(in + 3) == 61) {
#line 448
      if (inlen != 4UL) {
        {
#line 449
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 449
          *outp = (char */* __restrict  */)out;
#line 449
          return ((_Bool)0);
#line 449
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 453
      tmp___8 = isbase64((char )*(in + 3));
      }
#line 453
      if (! tmp___8) {
        {
#line 454
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 454
          *outp = (char */* __restrict  */)out;
#line 454
          return ((_Bool)0);
#line 454
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 456
      if (*outleft) {
        {
#line 458
        tmp___9 = out;
#line 458
        out ++;
#line 458
        tmp___10 = to_uchar___0((char )*(in + 2));
#line 458
        tmp___11 = to_uchar___0((char )*(in + 3));
#line 458
        *tmp___9 = (char )((((int const   )b64[tmp___10] << 6) & 192) | (int const   )b64[tmp___11]);
#line 460
        (*outleft) --;
        }
      }
    }
  }
#line 465
  *outp = (char */* __restrict  */)out;
#line 466
  return ((_Bool)1);
}
}
#line 487 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) 
{ 
  size_t outleft ;
  _Bool ignore_newlines ;
  _Bool flush_ctx ;
  unsigned int ctx_i ;
  size_t outleft_save ;
  _Bool tmp ;
  char const   *in_end ;
  char const   *non_nl ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 492
  outleft = *outlen;
#line 493
  ignore_newlines = (_Bool )((unsigned long )ctx != (unsigned long )((void *)0));
#line 494
  flush_ctx = (_Bool)0;
#line 495
  ctx_i = 0U;
#line 497
  if (ignore_newlines) {
#line 499
    ctx_i = ctx->i;
#line 500
    flush_ctx = (_Bool )(inlen == 0UL);
  }
  {
#line 504
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    outleft_save = outleft;
#line 507
    if (ctx_i == 0U) {
#line 507
      if (! flush_ctx) {
        {
#line 509
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 513
          outleft_save = outleft;
#line 514
          tmp = decode_4(in, inlen, & out, & outleft);
          }
#line 514
          if (! tmp) {
#line 515
            goto while_break___0;
          }
#line 517
          in += 4;
#line 518
          inlen -= 4UL;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 522
    if (inlen == 0UL) {
#line 522
      if (! flush_ctx) {
#line 523
        goto while_break;
      }
    }
#line 527
    if (inlen) {
#line 527
      if ((int const   )*in == 10) {
#line 527
        if (ignore_newlines) {
#line 529
          in ++;
#line 530
          inlen --;
#line 531
          goto while_continue;
        }
      }
    }
#line 535
    out -= outleft_save - outleft;
#line 536
    outleft = outleft_save;
#line 539
    in_end = (char const   *)(in + inlen);
#line 542
    if (ignore_newlines) {
      {
#line 543
      tmp___0 = get_4(ctx, & in, (char const   */* __restrict  */)in_end, & inlen);
#line 543
      non_nl = (char const   *)tmp___0;
      }
    } else {
#line 545
      non_nl = (char const   *)in;
    }
#line 550
    if (inlen == 0UL) {
#line 552
      inlen = (size_t )0;
#line 553
      goto while_break;
    } else
#line 550
    if (inlen < 4UL) {
#line 550
      if (! flush_ctx) {
#line 550
        if (ignore_newlines) {
#line 552
          inlen = (size_t )0;
#line 553
          goto while_break;
        }
      }
    }
    {
#line 555
    tmp___1 = decode_4((char const   */* __restrict  */)non_nl, inlen, & out, & outleft);
    }
#line 555
    if (! tmp___1) {
#line 556
      goto while_break;
    }
#line 558
    inlen = (size_t )(in_end - (char const   *)in);
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  *outlen -= outleft;
#line 564
  return ((_Bool )(inlen == 0UL));
}
}
#line 578 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/base64.c"
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) 
{ 
  size_t needlen ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 588
  needlen = 3UL * (inlen / 4UL) + 3UL;
#line 590
  tmp = malloc(needlen);
#line 590
  *out = (char *)tmp;
  }
#line 591
  if (! *out) {
#line 592
    return ((_Bool)1);
  }
  {
#line 594
  tmp___0 = base64_decode_ctx(ctx, (char const   */* __restrict  */)in, inlen, (char */* __restrict  */)*out,
                              & needlen);
  }
#line 594
  if (! tmp___0) {
    {
#line 596
    free((void *)*out);
#line 597
    *out = (char *)((void *)0);
    }
#line 598
    return ((_Bool)0);
  }
#line 601
  if (outlen) {
#line 602
    *outlen = needlen;
  }
#line 604
  return ((_Bool)1);
}
}
#line 70 "./vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 24 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list___0 args ;
  char *result ;

  {
  {
#line 30
  __builtin_va_start(args, format);
#line 31
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 32
  __builtin_va_end(args);
  }
#line 33
  return (result);
}
}
#line 478 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/acl-internal.c"
void free_permission_context(struct permission_context *ctx ) 
{ 


  {
#line 507
  return;
}
}
#line 27 "./acl.h"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/tmp/gnuchess-6.2.5/recutils-1.8.90/lib/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum ) 
{ 


  {
  {
#line 36
  if (errnum == 16) {
#line 36
    goto case_16;
  }
#line 37
  if (errnum == 22) {
#line 37
    goto case_22;
  }
#line 41
  if (errnum == 38) {
#line 41
    goto case_38;
  }
#line 49
  if (errnum == 95) {
#line 49
    goto case_95;
  }
#line 50
  goto switch_default;
  case_16: /* CIL Label */ 
#line 36
  return ((_Bool)0);
  case_22: /* CIL Label */ 
#line 37
  return ((_Bool)0);
  case_38: /* CIL Label */ 
#line 41
  return ((_Bool)0);
  case_95: /* CIL Label */ 
#line 49
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 50
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2155 "./rec.h"
_Bool rec_encrypt(char *in , size_t in_size , char const   *password , char **out ,
                  size_t *out_size ) ;
#line 2165
_Bool rec_encrypt_field(rec_field_t field , char const   *password ) ;
#line 2174
_Bool rec_encrypt_record(rec_rset_t rset , rec_record_t record , char const   *password ) ;
#line 2184
_Bool rec_decrypt(char *in , size_t in_size , char const   *password , char **out ,
                  size_t *out_size ) ;
#line 2193
_Bool rec_decrypt_field(rec_field_t field , char const   *password ) ;
#line 2202
_Bool rec_decrypt_record(rec_rset_t rset , rec_record_t record , char const   *password ) ;
#line 30 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-crypt-dummy.c"
_Bool rec_encrypt(char *in , size_t in_size , char const   *password , char **out ,
                  size_t *out_size ) 
{ 


  {
#line 37
  return ((_Bool)0);
}
}
#line 40 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-crypt-dummy.c"
_Bool rec_decrypt(char *in , size_t in_size , char const   *password , char **out ,
                  size_t *out_size ) 
{ 


  {
#line 47
  return ((_Bool)0);
}
}
#line 50 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-crypt-dummy.c"
_Bool rec_encrypt_record(rec_rset_t rset , rec_record_t record , char const   *password ) 
{ 


  {
#line 55
  return ((_Bool)0);
}
}
#line 58 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-crypt-dummy.c"
_Bool rec_encrypt_field(rec_field_t field , char const   *password ) 
{ 


  {
#line 62
  return ((_Bool)0);
}
}
#line 65 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-crypt-dummy.c"
_Bool rec_decrypt_field(rec_field_t field , char const   *password ) 
{ 


  {
#line 69
  return ((_Bool)0);
}
}
#line 72 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-crypt-dummy.c"
_Bool rec_decrypt_record(rec_rset_t rset , rec_record_t record , char const   *password ) 
{ 


  {
#line 77
  return ((_Bool)0);
}
}
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 358 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 241 "./rec.h"
rec_mset_iterator_t rec_mset_iterator(rec_mset_t mset ) ;
#line 249
_Bool rec_mset_iterator_next(rec_mset_iterator_t *iterator , rec_mset_type_t type ,
                             void const   **data , rec_mset_elem_t *elem ) ;
#line 256
void rec_mset_iterator_free(rec_mset_iterator_t *iterator ) ;
#line 417
_Bool rec_field_name_equal_p(char const   *name1 , char const   *name2 ) ;
#line 751
char const   *rec_field_name(rec_field_t field ) ;
#line 762
char const   *rec_field_value(rec_field_t field ) ;
#line 898
rec_mset_t rec_record_mset(rec_record_t record ) ;
#line 996
size_t rec_record_get_num_fields_by_name(rec_record_t record , char const   *field_name ) ;
#line 1109
rec_mset_t rec_rset_mset(rec_rset_t rset ) ;
#line 2239
rec_aggregate_reg_t rec_aggregate_reg_new(void) ;
#line 2243
void rec_aggregate_reg_destroy(rec_aggregate_reg_t func_reg ) ;
#line 2254
_Bool rec_aggregate_reg_add(rec_aggregate_reg_t func_reg , char const   *name , char *(*function)(rec_rset_t rset ,
                                                                                                  rec_record_t record ,
                                                                                                  char const   *field_name ) ) ;
#line 2260
rec_aggregate_t rec_aggregate_reg_get(rec_aggregate_reg_t func_reg , char const   *name ) ;
#line 2265
void rec_aggregate_reg_add_standard(rec_aggregate_reg_t func_reg ) ;
#line 2270
_Bool rec_aggregate_std_p(char const   *name ) ;
#line 57 "./rec-utils.h"
_Bool rec_atod(char const   *str , double *number ) ;
#line 58 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static char *rec_aggregate_std_count(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
#line 62
static char *rec_aggregate_std_avg(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
#line 65
static double rec_aggregate_std_avg_record(rec_record_t record , char const   *field_name ) ;
#line 68
static char *rec_aggregate_std_sum(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
#line 71
static double rec_aggregate_std_sum_record(rec_record_t record , char const   *field_name ) ;
#line 74
static char *rec_aggregate_std_min(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
#line 77
static double rec_aggregate_std_min_record(rec_record_t record , char const   *field_name ) ;
#line 80
static char *rec_aggregate_std_max(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
#line 83
static double rec_aggregate_std_max_record(rec_record_t record , char const   *field_name ) ;
#line 102 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static struct rec_aggregate_descriptor_s std_aggregates[5]  = {      {"count", & rec_aggregate_std_count}, 
        {"avg", & rec_aggregate_std_avg}, 
        {"sum", & rec_aggregate_std_sum}, 
        {"min", & rec_aggregate_std_min}, 
        {"max", & rec_aggregate_std_max}};
#line 113 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
rec_aggregate_reg_t rec_aggregate_reg_new(void) 
{ 
  rec_aggregate_reg_t new ;
  void *tmp ;

  {
  {
#line 118
  tmp = malloc(sizeof(struct rec_aggregate_reg_s ));
#line 118
  new = (rec_aggregate_reg_t )tmp;
  }
#line 119
  if (new) {
#line 120
    new->num_functions = (size_t )0;
  }
#line 122
  return (new);
}
}
#line 125 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
void rec_aggregate_reg_destroy(rec_aggregate_reg_t func_reg ) 
{ 
  size_t i ;

  {
#line 128
  if (func_reg) {
#line 130
    i = (size_t )0;
#line 132
    i = (size_t )0;
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (! (i < func_reg->num_functions)) {
#line 132
        goto while_break;
      }
      {
#line 133
      free((void *)func_reg->functions[i].name);
#line 132
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 134
    free((void *)func_reg);
    }
  }
#line 136
  return;
}
}
#line 138 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
_Bool rec_aggregate_reg_add(rec_aggregate_reg_t func_reg , char const   *name , char *(*function)(rec_rset_t rset ,
                                                                                                  rec_record_t record ,
                                                                                                  char const   *field_name ) ) 
{ 
  _Bool function_replaced ;
  size_t i ;
  int tmp ;

  {
#line 143
  function_replaced = (_Bool)0;
#line 144
  i = (size_t )0;
#line 146
  i = (size_t )0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < func_reg->num_functions)) {
#line 146
      goto while_break;
    }
    {
#line 147
    tmp = strcmp(name, (char const   *)func_reg->functions[i].name);
    }
#line 147
    if (tmp == 0) {
#line 150
      func_reg->functions[i].function = function;
#line 151
      function_replaced = (_Bool)1;
#line 152
      goto while_break;
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if (! function_replaced) {
#line 159
    if (func_reg->num_functions == 40UL) {
#line 161
      return ((_Bool)0);
    }
    {
#line 163
    func_reg->functions[func_reg->num_functions].name = strdup(name);
#line 164
    func_reg->functions[func_reg->num_functions].function = function;
#line 165
    (func_reg->num_functions) ++;
    }
  }
#line 168
  return ((_Bool)1);
}
}
#line 171 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
rec_aggregate_t rec_aggregate_reg_get(rec_aggregate_reg_t func_reg , char const   *name ) 
{ 
  size_t i ;
  char *(*res)(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
  int tmp ;

  {
#line 175
  i = (size_t )0;
#line 176
  res = (char *(*)(rec_rset_t rset , rec_record_t record , char const   *field_name ))((void *)0);
#line 178
  i = (size_t )0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < func_reg->num_functions)) {
#line 178
      goto while_break;
    }
    {
#line 179
    tmp = strcasecmp((char const   *)func_reg->functions[i].name, name);
    }
#line 179
    if (tmp == 0) {
#line 181
      res = func_reg->functions[i].function;
#line 182
      goto while_break;
    }
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return (res);
}
}
#line 188 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
void rec_aggregate_reg_add_standard(rec_aggregate_reg_t func_reg ) 
{ 
  size_t i ;

  {
#line 191
  i = (size_t )0;
#line 193
  i = (size_t )0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (i < 5UL)) {
#line 193
      goto while_break;
    }
    {
#line 194
    rec_aggregate_reg_add(func_reg, std_aggregates[i].name, std_aggregates[i].func);
#line 193
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  return;
}
}
#line 197 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
_Bool rec_aggregate_std_p(char const   *name ) 
{ 
  _Bool found ;
  size_t i ;
  int tmp ;

  {
#line 200
  found = (_Bool)0;
#line 201
  i = (size_t )0;
#line 203
  i = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! (i < 5UL)) {
#line 203
      goto while_break;
    }
    {
#line 204
    tmp = strcasecmp(name, std_aggregates[i].name);
    }
#line 204
    if (tmp == 0) {
#line 206
      found = (_Bool)1;
#line 207
      goto while_break;
    }
#line 203
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (found);
}
}
#line 217 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static char *rec_aggregate_std_count(rec_rset_t rset , rec_record_t record , char const   *field_name ) 
{ 
  char *result ;
  size_t count ;
  rec_record_t rec ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  size_t tmp___1 ;
  _Bool tmp___2 ;

  {
#line 222
  result = (char *)((void *)0);
#line 223
  count = (size_t )0;
#line 225
  if (record) {
    {
#line 226
    count = rec_record_get_num_fields_by_name(record, field_name);
    }
  } else
#line 227
  if (rset) {
    {
#line 229
    rec = (rec_record_t )((void *)0);
#line 230
    tmp = rec_rset_mset(rset);
#line 230
    tmp___0 = rec_mset_iterator(tmp);
#line 230
    iter = tmp___0;
    }
    {
#line 232
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 232
      tmp___2 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& rec)),
                                       (rec_mset_elem_t *)((void *)0));
      }
#line 232
      if (! tmp___2) {
#line 232
        goto while_break;
      }
      {
#line 233
      tmp___1 = rec_record_get_num_fields_by_name(rec, field_name);
#line 233
      count += tmp___1;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 234
    rec_mset_iterator_free(& iter);
    }
  }
  {
#line 241
  asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"%zu",
           count);
  }
#line 242
  return (result);
}
}
#line 245 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static char *rec_aggregate_std_avg(rec_rset_t rset , rec_record_t record , char const   *field_name ) 
{ 
  char *result ;
  double avg ;
  size_t num_records ;
  rec_record_t rec ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  double tmp___1 ;
  _Bool tmp___2 ;

  {
#line 250
  result = (char *)((void *)0);
#line 251
  avg = (double )0;
#line 253
  if (record) {
    {
#line 254
    avg = rec_aggregate_std_avg_record(record, field_name);
    }
  } else
#line 255
  if (rset) {
    {
#line 257
    num_records = (size_t )0;
#line 258
    rec = (rec_record_t )((void *)0);
#line 259
    tmp = rec_rset_mset(rset);
#line 259
    tmp___0 = rec_mset_iterator(tmp);
#line 259
    iter = tmp___0;
    }
    {
#line 261
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 261
      tmp___2 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& rec)),
                                       (rec_mset_elem_t *)((void *)0));
      }
#line 261
      if (! tmp___2) {
#line 261
        goto while_break;
      }
      {
#line 263
      tmp___1 = rec_aggregate_std_avg_record(rec, field_name);
#line 263
      avg += tmp___1;
#line 264
      num_records ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 266
    rec_mset_iterator_free(& iter);
    }
#line 268
    if (num_records != 0UL) {
#line 269
      avg /= (double )num_records;
    }
  }
  {
#line 275
  asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"%g",
           avg);
  }
#line 277
  return (result);
}
}
#line 280 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static double rec_aggregate_std_avg_record(rec_record_t record , char const   *field_name ) 
{ 
  double avg ;
  rec_field_t field ;
  size_t num_fields ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  double field_value_double ;
  char const   *field_value ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 284
  avg = (double )0;
#line 286
  num_fields = (size_t )0;
#line 287
  tmp = rec_record_mset(record);
#line 287
  tmp___0 = rec_mset_iterator(tmp);
#line 287
  iter = tmp___0;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 289
    tmp___5 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& field)),
                                     (rec_mset_elem_t *)((void *)0));
    }
#line 289
    if (! tmp___5) {
#line 289
      goto while_break;
    }
    {
#line 291
    field_value_double = (double )0;
#line 292
    tmp___1 = rec_field_value(field);
#line 292
    field_value = tmp___1;
#line 294
    tmp___2 = rec_field_name(field);
#line 294
    tmp___3 = rec_field_name_equal_p(tmp___2, field_name);
    }
#line 294
    if (tmp___3) {
      {
#line 294
      tmp___4 = rec_atod(field_value, & field_value_double);
      }
#line 294
      if (tmp___4) {
#line 297
        avg += field_value_double;
#line 298
        num_fields ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  rec_mset_iterator_free(& iter);
  }
#line 303
  if (num_fields != 0UL) {
#line 304
    avg /= (double )num_fields;
  }
#line 306
  return (avg);
}
}
#line 366 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
__inline static double op_sum(double op1 , double op2 ) 
{ 


  {
#line 369
  return (op1 + op2);
}
}
#line 372 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static char *rec_aggregate_std_sum(rec_rset_t rset , rec_record_t record , char const   *field_name ) 
{ 
  char *result ;
  double val ;
  rec_record_t rec ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  double tmp___1 ;
  _Bool tmp___2 ;

  {
#line 372
  result = (char *)((void *)0);
#line 372
  val = (double )0;
#line 372
  if (record) {
    {
#line 372
    val = rec_aggregate_std_sum_record(record, field_name);
    }
  } else
#line 372
  if (rset) {
    {
#line 372
    rec = (rec_record_t )((void *)0);
#line 372
    tmp = rec_rset_mset(rset);
#line 372
    tmp___0 = rec_mset_iterator(tmp);
#line 372
    iter = tmp___0;
    }
    {
#line 372
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 372
      tmp___2 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& rec)),
                                       (rec_mset_elem_t *)((void *)0));
      }
#line 372
      if (! tmp___2) {
#line 372
        goto while_break;
      }
      {
#line 372
      tmp___1 = rec_aggregate_std_sum_record(rec, field_name);
#line 372
      val = op_sum(val, tmp___1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    rec_mset_iterator_free(& iter);
    }
  }
  {
#line 372
  asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"%g",
           val);
  }
#line 372
  return (result);
}
}
#line 372 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static double rec_aggregate_std_sum_record(rec_record_t record , char const   *field_name ) 
{ 
  double val ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  char const   *field_value ;
  char const   *tmp___1 ;
  double field_value_double ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 372
  val = (double )0;
#line 372
  tmp = rec_record_mset(record);
#line 372
  tmp___0 = rec_mset_iterator(tmp);
#line 372
  iter = tmp___0;
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 372
    tmp___5 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& field)),
                                     (rec_mset_elem_t *)((void *)0));
    }
#line 372
    if (! tmp___5) {
#line 372
      goto while_break;
    }
    {
#line 372
    tmp___1 = rec_field_value(field);
#line 372
    field_value = tmp___1;
#line 372
    field_value_double = (double )0;
#line 372
    tmp___2 = rec_field_name(field);
#line 372
    tmp___3 = rec_field_name_equal_p(tmp___2, field_name);
    }
#line 372
    if (tmp___3) {
      {
#line 372
      tmp___4 = rec_atod(field_value, & field_value_double);
      }
#line 372
      if (tmp___4) {
        {
#line 372
        val = op_sum(val, field_value_double);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 372
  rec_mset_iterator_free(& iter);
  }
#line 372
  return (val);
}
}
#line 379 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static char *rec_aggregate_std_min(rec_rset_t rset , rec_record_t record , char const   *field_name ) 
{ 
  char *result ;
  double val ;
  rec_record_t rec ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  double tmp___2 ;
  double tmp___3 ;
  _Bool tmp___4 ;

  {
#line 379
  result = (char *)((void *)0);
#line 379
  val = 1.7976931348623157e+308;
#line 379
  if (record) {
    {
#line 379
    val = rec_aggregate_std_min_record(record, field_name);
    }
  } else
#line 379
  if (rset) {
    {
#line 379
    rec = (rec_record_t )((void *)0);
#line 379
    tmp = rec_rset_mset(rset);
#line 379
    tmp___0 = rec_mset_iterator(tmp);
#line 379
    iter = tmp___0;
    }
    {
#line 379
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 379
      tmp___4 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& rec)),
                                       (rec_mset_elem_t *)((void *)0));
      }
#line 379
      if (! tmp___4) {
#line 379
        goto while_break;
      }
      {
#line 379
      tmp___3 = rec_aggregate_std_min_record(rec, field_name);
      }
#line 379
      if (val < tmp___3) {
#line 379
        val = val;
      } else {
        {
#line 379
        tmp___2 = rec_aggregate_std_min_record(rec, field_name);
#line 379
        val = tmp___2;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 379
    rec_mset_iterator_free(& iter);
    }
  }
  {
#line 379
  asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"%g",
           val);
  }
#line 379
  return (result);
}
}
#line 379 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static double rec_aggregate_std_min_record(rec_record_t record , char const   *field_name ) 
{ 
  double val ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  char const   *field_value ;
  char const   *tmp___1 ;
  double field_value_double ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 379
  val = 1.7976931348623157e+308;
#line 379
  tmp = rec_record_mset(record);
#line 379
  tmp___0 = rec_mset_iterator(tmp);
#line 379
  iter = tmp___0;
  }
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 379
    tmp___5 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& field)),
                                     (rec_mset_elem_t *)((void *)0));
    }
#line 379
    if (! tmp___5) {
#line 379
      goto while_break;
    }
    {
#line 379
    tmp___1 = rec_field_value(field);
#line 379
    field_value = tmp___1;
#line 379
    field_value_double = (double )0;
#line 379
    tmp___2 = rec_field_name(field);
#line 379
    tmp___3 = rec_field_name_equal_p(tmp___2, field_name);
    }
#line 379
    if (tmp___3) {
      {
#line 379
      tmp___4 = rec_atod(field_value, & field_value_double);
      }
#line 379
      if (tmp___4) {
#line 379
        if (val < field_value_double) {
#line 379
          val = val;
        } else {
#line 379
          val = field_value_double;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 379
  rec_mset_iterator_free(& iter);
  }
#line 379
  return (val);
}
}
#line 380 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static char *rec_aggregate_std_max(rec_rset_t rset , rec_record_t record , char const   *field_name ) 
{ 
  char *result ;
  double val ;
  rec_record_t rec ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  double tmp___2 ;
  double tmp___3 ;
  _Bool tmp___4 ;

  {
#line 380
  result = (char *)((void *)0);
#line 380
  val = 2.2250738585072014e-308;
#line 380
  if (record) {
    {
#line 380
    val = rec_aggregate_std_max_record(record, field_name);
    }
  } else
#line 380
  if (rset) {
    {
#line 380
    rec = (rec_record_t )((void *)0);
#line 380
    tmp = rec_rset_mset(rset);
#line 380
    tmp___0 = rec_mset_iterator(tmp);
#line 380
    iter = tmp___0;
    }
    {
#line 380
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 380
      tmp___4 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& rec)),
                                       (rec_mset_elem_t *)((void *)0));
      }
#line 380
      if (! tmp___4) {
#line 380
        goto while_break;
      }
      {
#line 380
      tmp___3 = rec_aggregate_std_max_record(rec, field_name);
      }
#line 380
      if (val > tmp___3) {
#line 380
        val = val;
      } else {
        {
#line 380
        tmp___2 = rec_aggregate_std_max_record(rec, field_name);
#line 380
        val = tmp___2;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 380
    rec_mset_iterator_free(& iter);
    }
  }
  {
#line 380
  asprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)"%g",
           val);
  }
#line 380
  return (result);
}
}
#line 380 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-aggregate.c"
static double rec_aggregate_std_max_record(rec_record_t record , char const   *field_name ) 
{ 
  double val ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_mset_iterator_t tmp___0 ;
  char const   *field_value ;
  char const   *tmp___1 ;
  double field_value_double ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 380
  val = 2.2250738585072014e-308;
#line 380
  tmp = rec_record_mset(record);
#line 380
  tmp___0 = rec_mset_iterator(tmp);
#line 380
  iter = tmp___0;
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    tmp___5 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& field)),
                                     (rec_mset_elem_t *)((void *)0));
    }
#line 380
    if (! tmp___5) {
#line 380
      goto while_break;
    }
    {
#line 380
    tmp___1 = rec_field_value(field);
#line 380
    field_value = tmp___1;
#line 380
    field_value_double = (double )0;
#line 380
    tmp___2 = rec_field_name(field);
#line 380
    tmp___3 = rec_field_name_equal_p(tmp___2, field_name);
    }
#line 380
    if (tmp___3) {
      {
#line 380
      tmp___4 = rec_atod(field_value, & field_value_double);
      }
#line 380
      if (tmp___4) {
#line 380
        if (val > field_value_double) {
#line 380
          val = val;
        } else {
#line 380
          val = field_value_double;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 380
  rec_mset_iterator_free(& iter);
  }
#line 380
  return (val);
}
}
#line 322 "./rec.h"
rec_buf_t rec_buf_new(char **data , size_t *size ) ;
#line 323
void rec_buf_close(rec_buf_t buf ) ;
#line 327
int rec_buf_putc(int c , rec_buf_t buf ) ;
#line 330
int rec_buf_puts(char const   *str , rec_buf_t buf ) ;
#line 332
void rec_buf_rewind(rec_buf_t buf , int n ) ;
#line 51 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-buf.c"
rec_buf_t rec_buf_new(char **data , size_t *size ) 
{ 
  rec_buf_t new ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 56
  tmp = malloc(sizeof(struct rec_buf_s ));
#line 56
  new = (rec_buf_t )tmp;
  }
#line 57
  if (new) {
    {
#line 59
    new->data_pointer = data;
#line 60
    new->size_pointer = size;
#line 62
    tmp___0 = malloc((size_t )512);
#line 62
    new->data = (char *)tmp___0;
#line 63
    new->size = (size_t )512;
#line 64
    new->used = (size_t )0;
    }
#line 66
    if (! new->data) {
      {
#line 68
      free((void *)new);
#line 69
      new = (rec_buf_t )((void *)0);
      }
    }
  }
#line 73
  return (new);
}
}
#line 76 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-buf.c"
void rec_buf_close(rec_buf_t buf ) 
{ 
  void *tmp ;

  {
#line 80
  if (buf->used > 0UL) {
    {
#line 81
    tmp = realloc((void *)buf->data, buf->used + 1UL);
#line 81
    buf->data = (char *)tmp;
    }
  }
  {
#line 82
  *(buf->data + buf->used) = (char )'\000';
#line 85
  *(buf->data_pointer) = buf->data;
#line 86
  *(buf->size_pointer) = buf->used;
#line 89
  free((void *)buf);
  }
#line 90
  return;
}
}
#line 92 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-buf.c"
void rec_buf_rewind(rec_buf_t buf , int n ) 
{ 


  {
#line 95
  if (buf->used - (size_t )n >= 0UL) {
#line 96
    buf->used -= (size_t )n;
  }
#line 97
  return;
}
}
#line 99 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-buf.c"
int rec_buf_putc(int c , rec_buf_t buf ) 
{ 
  unsigned int ret ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 104
  if (c == -1) {
#line 105
    return (-1);
  }
#line 107
  ret = (unsigned int )c;
#line 108
  if (buf->used + 1UL > buf->size) {
    {
#line 111
    buf->size += 512UL;
#line 112
    tmp = realloc((void *)buf->data, buf->size);
#line 112
    buf->data = (char *)tmp;
    }
#line 114
    if (! buf->data) {
#line 117
      ret = 4294967295U;
    }
  }
#line 120
  if (ret != 4294967295U) {
#line 122
    tmp___0 = buf->used;
#line 122
    (buf->used) ++;
#line 122
    *(buf->data + tmp___0) = (char )c;
  }
#line 124
  return ((int )ret);
}
}
#line 127 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-buf.c"
int rec_buf_puts(char const   *str , rec_buf_t buf ) 
{ 
  int ret ;
  char const   *p ;
  int tmp ;

  {
#line 133
  ret = 0;
#line 134
  p = str;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((int const   )*p != 0)) {
#line 135
      goto while_break;
    }
    {
#line 137
    tmp = rec_buf_putc((int )*p, buf);
    }
#line 137
    if (tmp == -1) {
#line 140
      ret = -1;
#line 141
      goto while_break;
    }
#line 144
    ret ++;
#line 145
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (ret);
}
}
#line 610 "./rec.h"
rec_type_t rec_type_new(char const   *str ) ;
#line 613
void rec_type_destroy(rec_type_t type ) ;
#line 616
_Bool rec_type_descr_p(char const   *str ) ;
#line 620
enum rec_type_kind_e rec_type_kind(rec_type_t type ) ;
#line 621
char *rec_type_kind_str(rec_type_t type ) ;
#line 625
int rec_type_min(rec_type_t type ) ;
#line 626
int rec_type_max(rec_type_t type ) ;
#line 630
char const   *rec_type_rec(rec_type_t type ) ;
#line 635
char const   *rec_type_name(rec_type_t type ) ;
#line 636
void rec_type_set_name(rec_type_t type , char const   *name ) ;
#line 663
_Bool rec_type_equal_p(rec_type_t type1 , rec_type_t type2 ) ;
#line 668
_Bool rec_type_check(rec_type_t type , char const   *str , char **error_str ) ;
#line 676
int rec_type_values_cmp(rec_type_t type , char const   *val1 , char const   *val2 ) ;
#line 690
rec_type_reg_t rec_type_reg_new(void) ;
#line 693
void rec_type_reg_destroy(rec_type_reg_t reg ) ;
#line 697
void rec_type_reg_add(rec_type_reg_t reg , rec_type_t type ) ;
#line 702
void rec_type_reg_add_synonym(rec_type_reg_t reg , char const   *type_name , char const   *to_type ) ;
#line 707
rec_type_t rec_type_reg_get(rec_type_reg_t reg , char const   *type_name ) ;
#line 56 "./rec-utils.h"
_Bool rec_atoi(char const   *str , int *number ) ;
#line 69
_Bool rec_match(char const   *str , char const   *reg ) ;
#line 73
_Bool rec_blank_p(char c ) ;
#line 74
_Bool rec_digit_p(char c ) ;
#line 75
_Bool rec_letter_p(char c ) ;
#line 76
_Bool rec_parse_int(char const   **str , int *num ) ;
#line 77
void rec_skip_blanks(char const   **str ) ;
#line 78
_Bool rec_parse_regexp(char const   **str , char const   *re , char **result ) ;
#line 84
int rec_timespec_subtract(struct timespec *result , struct timespec *x , struct timespec *y ) ;
#line 271 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static enum rec_type_kind_e rec_type_parse_type_kind(char *str ) ;
#line 273
static _Bool rec_type_check_int(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 274
static _Bool rec_type_check_bool(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 275
static _Bool rec_type_check_range(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 276
static _Bool rec_type_check_real(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 277
static _Bool rec_type_check_size(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 278
static _Bool rec_type_check_line(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 279
static _Bool rec_type_check_regexp(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 280
static _Bool rec_type_check_date(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 281
static _Bool rec_type_check_email(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 282
static _Bool rec_type_check_enum(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 283
static _Bool rec_type_check_field(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 284
static _Bool rec_type_check_rec(rec_type_t type , char const   *str , rec_buf_t errors ) ;
#line 292
static char const   *rec_type_parse_size(char const   *str , rec_type_t type ) ;
#line 293
static char const   *rec_type_parse_enum(char const   *str , rec_type_t type ) ;
#line 294
static char const   *rec_type_parse_regexp_type(char const   *str , rec_type_t type ) ;
#line 295
static char const   *rec_type_parse_range(char const   *str , rec_type_t type ) ;
#line 296
static char const   *rec_type_parse_rec(char const   *str , rec_type_t type ) ;
#line 302 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
_Bool rec_type_descr_p(char const   *str ) 
{ 
  _Bool ret ;
  rec_type_t aux_type ;

  {
  {
#line 308
  ret = (_Bool)0;
#line 310
  aux_type = rec_type_new(str);
  }
#line 311
  if (aux_type) {
    {
#line 313
    ret = (_Bool)1;
#line 314
    rec_type_destroy(aux_type);
    }
  }
#line 317
  return (ret);
}
}
#line 320 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
char *rec_type_descr_type(char *str ) 
{ 
  char *result ;
  char *name ;
  char const   *p ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 323
  result = (char *)((void *)0);
#line 327
  tmp___0 = rec_type_descr_p((char const   *)str);
  }
#line 327
  if (tmp___0) {
    {
#line 329
    p = (char const   *)str;
#line 332
    rec_skip_blanks(& p);
#line 335
    tmp = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*(,[a-zA-Z%][a-zA-Z0-9_]*)*",
                           & name);
    }
#line 335
    if (tmp) {
      {
#line 338
      free((void *)name);
      }
    }
    {
#line 342
    rec_skip_blanks(& p);
#line 345
    result = strdup(p);
    }
  }
#line 348
  return (result);
}
}
#line 351 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
rec_type_t rec_type_new(char const   *str ) 
{ 
  rec_type_t new ;
  char const   *p ;
  char *type_kind_str ;
  void *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 356
  type_kind_str = (char *)((void *)0);
#line 358
  p = str;
#line 359
  tmp = malloc(sizeof(struct rec_type_s ));
#line 359
  new = (rec_type_t )tmp;
  }
#line 360
  if (! new) {
#line 362
    goto exit;
  }
  {
#line 364
  new->name = (char *)((void *)0);
#line 365
  new->size = (size_t )0;
#line 367
  rec_skip_blanks(& p);
#line 370
  tmp___0 = rec_parse_regexp(& p, "^(int|range|real|size|line|regexp|date|enum|email|bool|field|rec)",
                             & type_kind_str);
  }
#line 370
  if (! tmp___0) {
    {
#line 372
    free((void *)new);
#line 373
    new = (rec_type_t )((void *)0);
    }
#line 374
    goto exit;
  }
  {
#line 378
  new->kind = rec_type_parse_type_kind(type_kind_str);
  }
  {
#line 381
  if ((unsigned int )new->kind == 5U) {
#line 381
    goto case_5;
  }
#line 391
  if ((unsigned int )new->kind == 9U) {
#line 391
    goto case_9;
  }
#line 401
  if ((unsigned int )new->kind == 7U) {
#line 401
    goto case_7;
  }
#line 411
  if ((unsigned int )new->kind == 3U) {
#line 411
    goto case_3;
  }
#line 421
  if ((unsigned int )new->kind == 13U) {
#line 421
    goto case_13;
  }
#line 437
  if ((unsigned int )new->kind == 11U) {
#line 437
    goto case_11;
  }
#line 437
  if ((unsigned int )new->kind == 8U) {
#line 437
    goto case_11;
  }
#line 437
  if ((unsigned int )new->kind == 10U) {
#line 437
    goto case_11;
  }
#line 437
  if ((unsigned int )new->kind == 6U) {
#line 437
    goto case_11;
  }
#line 437
  if ((unsigned int )new->kind == 4U) {
#line 437
    goto case_11;
  }
#line 437
  if ((unsigned int )new->kind == 2U) {
#line 437
    goto case_11;
  }
#line 437
  if ((unsigned int )new->kind == 1U) {
#line 437
    goto case_11;
  }
#line 445
  if ((unsigned int )new->kind == 0U) {
#line 445
    goto case_0;
  }
#line 379
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 383
  p = rec_type_parse_size(p, new);
  }
#line 384
  if (! p) {
    {
#line 386
    free((void *)new);
#line 387
    new = (rec_type_t )((void *)0);
    }
  }
#line 389
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 393
  p = rec_type_parse_enum(p, new);
  }
#line 394
  if (! p) {
    {
#line 396
    free((void *)new);
#line 397
    new = (rec_type_t )((void *)0);
    }
  }
#line 399
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 403
  p = rec_type_parse_regexp_type(p, new);
  }
#line 404
  if (! p) {
    {
#line 406
    free((void *)new);
#line 407
    new = (rec_type_t )((void *)0);
    }
  }
#line 409
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 413
  p = rec_type_parse_range(p, new);
  }
#line 414
  if (! p) {
    {
#line 416
    free((void *)new);
#line 417
    new = (rec_type_t )((void *)0);
    }
  }
#line 419
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 423
  p = rec_type_parse_rec(p, new);
  }
#line 424
  if (! p) {
    {
#line 426
    free((void *)new);
#line 427
    new = (rec_type_t )((void *)0);
    }
  }
#line 429
  goto switch_break;
  case_11: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 443
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 448
  tmp___1 = dcgettext("recutils", "internal error: rec-types: got REC_TYPE_NONE from rec_type_parse_type_kind() in rec_type_new().\n",
                      5);
#line 448
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1);
#line 450
  exit(1);
  }
#line 451
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 455
  if (new) {
    {
#line 459
    while (1) {
      while_continue: /* CIL Label */ ;
#line 459
      if (! ((int const   )*p != 0)) {
#line 459
        goto while_break;
      }
      {
#line 461
      tmp___2 = rec_blank_p((char )*p);
      }
#line 461
      if (! tmp___2) {
        {
#line 463
        rec_type_destroy(new);
#line 464
        new = (rec_type_t )((void *)0);
        }
#line 465
        goto while_break;
      }
#line 468
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  exit: 
  {
#line 474
  free((void *)type_kind_str);
  }
#line 476
  return (new);
}
}
#line 479 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
enum rec_type_kind_e rec_type_kind(rec_type_t type ) 
{ 


  {
#line 482
  return (type->kind);
}
}
#line 485 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
char *rec_type_kind_str(rec_type_t type ) 
{ 
  char *res ;

  {
  {
#line 492
  if ((unsigned int )type->kind == 0U) {
#line 492
    goto case_0;
  }
#line 497
  if ((unsigned int )type->kind == 1U) {
#line 497
    goto case_1;
  }
#line 502
  if ((unsigned int )type->kind == 2U) {
#line 502
    goto case_2;
  }
#line 507
  if ((unsigned int )type->kind == 3U) {
#line 507
    goto case_3;
  }
#line 512
  if ((unsigned int )type->kind == 4U) {
#line 512
    goto case_4;
  }
#line 517
  if ((unsigned int )type->kind == 5U) {
#line 517
    goto case_5;
  }
#line 522
  if ((unsigned int )type->kind == 6U) {
#line 522
    goto case_6;
  }
#line 527
  if ((unsigned int )type->kind == 7U) {
#line 527
    goto case_7;
  }
#line 532
  if ((unsigned int )type->kind == 8U) {
#line 532
    goto case_8;
  }
#line 537
  if ((unsigned int )type->kind == 11U) {
#line 537
    goto case_11;
  }
#line 542
  if ((unsigned int )type->kind == 9U) {
#line 542
    goto case_9;
  }
#line 547
  if ((unsigned int )type->kind == 10U) {
#line 547
    goto case_10;
  }
#line 552
  if ((unsigned int )type->kind == 13U) {
#line 552
    goto case_13;
  }
#line 564
  goto switch_default;
  case_0: /* CIL Label */ 
#line 494
  res = (char *)"";
#line 495
  goto switch_break;
  case_1: /* CIL Label */ 
#line 499
  res = (char *)"int";
#line 500
  goto switch_break;
  case_2: /* CIL Label */ 
#line 504
  res = (char *)"bool";
#line 505
  goto switch_break;
  case_3: /* CIL Label */ 
#line 509
  res = (char *)"range";
#line 510
  goto switch_break;
  case_4: /* CIL Label */ 
#line 514
  res = (char *)"real";
#line 515
  goto switch_break;
  case_5: /* CIL Label */ 
#line 519
  res = (char *)"size";
#line 520
  goto switch_break;
  case_6: /* CIL Label */ 
#line 524
  res = (char *)"line";
#line 525
  goto switch_break;
  case_7: /* CIL Label */ 
#line 529
  res = (char *)"regexp";
#line 530
  goto switch_break;
  case_8: /* CIL Label */ 
#line 534
  res = (char *)"date";
#line 535
  goto switch_break;
  case_11: /* CIL Label */ 
#line 539
  res = (char *)"email";
#line 540
  goto switch_break;
  case_9: /* CIL Label */ 
#line 544
  res = (char *)"enum";
#line 545
  goto switch_break;
  case_10: /* CIL Label */ 
#line 549
  res = (char *)"field";
#line 550
  goto switch_break;
  case_13: /* CIL Label */ 
#line 554
  res = (char *)"rec";
#line 555
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 566
  res = (char *)0;
#line 567
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 571
  return (res);
}
}
#line 574 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
_Bool rec_type_check(rec_type_t type , char const   *str , char **error_str ) 
{ 
  _Bool res ;
  rec_buf_t errors ;
  char *err_str ;
  size_t errors_size ;

  {
  {
#line 584
  errors = rec_buf_new(& err_str, & errors_size);
#line 586
  res = (_Bool)0;
  }
  {
#line 589
  if ((unsigned int )type->kind == 0U) {
#line 589
    goto case_0;
  }
#line 594
  if ((unsigned int )type->kind == 1U) {
#line 594
    goto case_1;
  }
#line 599
  if ((unsigned int )type->kind == 2U) {
#line 599
    goto case_2;
  }
#line 604
  if ((unsigned int )type->kind == 3U) {
#line 604
    goto case_3;
  }
#line 609
  if ((unsigned int )type->kind == 4U) {
#line 609
    goto case_4;
  }
#line 614
  if ((unsigned int )type->kind == 5U) {
#line 614
    goto case_5;
  }
#line 619
  if ((unsigned int )type->kind == 6U) {
#line 619
    goto case_6;
  }
#line 624
  if ((unsigned int )type->kind == 7U) {
#line 624
    goto case_7;
  }
#line 629
  if ((unsigned int )type->kind == 8U) {
#line 629
    goto case_8;
  }
#line 634
  if ((unsigned int )type->kind == 11U) {
#line 634
    goto case_11;
  }
#line 639
  if ((unsigned int )type->kind == 9U) {
#line 639
    goto case_9;
  }
#line 644
  if ((unsigned int )type->kind == 10U) {
#line 644
    goto case_10;
  }
#line 649
  if ((unsigned int )type->kind == 13U) {
#line 649
    goto case_13;
  }
#line 587
  goto switch_break;
  case_0: /* CIL Label */ 
#line 591
  res = (_Bool)1;
#line 592
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 596
  res = rec_type_check_int(type, str, errors);
  }
#line 597
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 601
  res = rec_type_check_bool(type, str, errors);
  }
#line 602
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 606
  res = rec_type_check_range(type, str, errors);
  }
#line 607
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 611
  res = rec_type_check_real(type, str, errors);
  }
#line 612
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 616
  res = rec_type_check_size(type, str, errors);
  }
#line 617
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 621
  res = rec_type_check_line(type, str, errors);
  }
#line 622
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 626
  res = rec_type_check_regexp(type, str, errors);
  }
#line 627
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 631
  res = rec_type_check_date(type, str, errors);
  }
#line 632
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 636
  res = rec_type_check_email(type, str, errors);
  }
#line 637
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 641
  res = rec_type_check_enum(type, str, errors);
  }
#line 642
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 646
  res = rec_type_check_field(type, str, errors);
  }
#line 647
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 651
  res = rec_type_check_rec(type, str, errors);
  }
#line 652
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 664
  rec_buf_close(errors);
  }
#line 667
  if (error_str) {
#line 669
    *error_str = err_str;
  } else {
    {
#line 673
    free((void *)err_str);
    }
  }
#line 676
  return (res);
}
}
#line 679 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
void rec_type_destroy(rec_type_t type ) 
{ 
  int i ;

  {
#line 684
  if (type) {
#line 686
    if ((unsigned int )type->kind == 9U) {
#line 688
      i = 0;
      {
#line 688
      while (1) {
        while_continue: /* CIL Label */ ;
#line 688
        if (! ((size_t )i < type->size)) {
#line 688
          goto while_break;
        }
        {
#line 690
        free((void *)*(type->data.names + i));
#line 688
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else
#line 693
    if ((unsigned int )type->kind == 7U) {
      {
#line 695
      rpl_regfree(& type->data.regexp);
      }
    }
    {
#line 698
    free((void *)type->name);
#line 699
    free((void *)type);
    }
  }
#line 701
  return;
}
}
#line 703 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
rec_type_reg_t rec_type_reg_new(void) 
{ 
  rec_type_reg_t new ;
  void *tmp ;

  {
  {
#line 708
  tmp = malloc(sizeof(struct rec_type_reg_s ));
#line 708
  new = (rec_type_reg_t )tmp;
  }
#line 709
  if (new) {
#line 711
    new->num_types = (size_t )0;
#line 712
    new->types = (struct rec_type_reg_entry_s *)((void *)0);
  }
#line 715
  return (new);
}
}
#line 718 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
void rec_type_reg_destroy(rec_type_reg_t reg ) 
{ 
  size_t i ;

  {
#line 723
  i = (size_t )0;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! (i < reg->num_types)) {
#line 723
      goto while_break;
    }
#line 725
    if ((reg->types + i)->type) {
      {
#line 727
      rec_type_destroy((reg->types + i)->type);
      }
    }
    {
#line 729
    free((void *)(reg->types + i)->type_name);
#line 730
    free((void *)(reg->types + i)->to_type);
#line 723
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 732
  free((void *)reg->types);
#line 733
  free((void *)reg);
  }
#line 734
  return;
}
}
#line 736 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
void rec_type_reg_add(rec_type_reg_t reg , rec_type_t type ) 
{ 
  size_t i ;
  char const   *type_name ;
  int tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 741
  type_name = (char const   *)((void *)0);
#line 743
  type_name = rec_type_name(type);
  }
#line 744
  if (! type_name) {
#line 747
    return;
  }
#line 750
  i = (size_t )0;
  {
#line 750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 750
    if (! (i < reg->num_types)) {
#line 750
      goto while_break;
    }
    {
#line 752
    tmp = strcmp((char const   *)(reg->types + i)->type_name, type_name);
    }
#line 752
    if (tmp == 0) {
#line 755
      if ((reg->types + i)->type) {
        {
#line 757
        rec_type_destroy((reg->types + i)->type);
        }
      }
      {
#line 759
      free((void *)(reg->types + i)->type_name);
#line 760
      free((void *)(reg->types + i)->to_type);
      }
#line 761
      goto while_break;
    }
#line 750
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 767
  if (i == reg->num_types) {
    {
#line 769
    tmp___0 = realloc((void *)reg->types, (i / 100UL + 1UL) * (sizeof(struct rec_type_reg_entry_s *) * 100UL));
#line 769
    reg->types = (struct rec_type_reg_entry_s *)tmp___0;
#line 772
    (reg->num_types) ++;
    }
  }
  {
#line 775
  tmp___1 = rec_type_name(type);
#line 775
  (reg->types + i)->type_name = strdup(tmp___1);
#line 776
  (reg->types + i)->type = type;
#line 777
  (reg->types + i)->to_type = (char *)((void *)0);
#line 778
  (reg->types + i)->visited_p = (_Bool)0;
  }
#line 779
  return;
}
}
#line 781 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
void rec_type_reg_add_synonym(rec_type_reg_t reg , char const   *type_name , char const   *to_type ) 
{ 
  size_t i ;
  int tmp ;
  void *tmp___0 ;

  {
#line 788
  i = (size_t )0;
  {
#line 788
  while (1) {
    while_continue: /* CIL Label */ ;
#line 788
    if (! (i < reg->num_types)) {
#line 788
      goto while_break;
    }
    {
#line 790
    tmp = strcmp((char const   *)(reg->types + i)->type_name, type_name);
    }
#line 790
    if (tmp == 0) {
#line 793
      if ((reg->types + i)->type) {
        {
#line 795
        rec_type_destroy((reg->types + i)->type);
        }
      }
      {
#line 797
      free((void *)(reg->types + i)->type_name);
#line 798
      free((void *)(reg->types + i)->to_type);
      }
#line 799
      goto while_break;
    }
#line 788
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 806
  if (i == reg->num_types) {
    {
#line 808
    tmp___0 = realloc((void *)reg->types, (i / 100UL + 1UL) * (sizeof(struct rec_type_reg_entry_s *) * 100UL));
#line 808
    reg->types = (struct rec_type_reg_entry_s *)tmp___0;
#line 811
    (reg->num_types) ++;
    }
  }
  {
#line 814
  (reg->types + i)->type_name = strdup(type_name);
#line 815
  (reg->types + i)->to_type = strdup(to_type);
#line 816
  (reg->types + i)->type = (rec_type_t )((void *)0);
#line 817
  (reg->types + i)->visited_p = (_Bool)0;
  }
#line 818
  return;
}
}
#line 820 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
rec_type_t rec_type_reg_get(rec_type_reg_t reg , char const   *type_name ) 
{ 
  size_t i ;
  rec_type_t type ;
  int tmp ;

  {
#line 825
  type = (rec_type_t )((void *)0);
#line 827
  i = (size_t )0;
  {
#line 827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 827
    if (! (i < reg->num_types)) {
#line 827
      goto while_break;
    }
    {
#line 829
    tmp = strcmp((char const   *)(reg->types + i)->type_name, type_name);
    }
#line 829
    if (tmp == 0) {
#line 831
      if ((reg->types + i)->type) {
#line 834
        type = (reg->types + i)->type;
#line 835
        goto while_break;
      } else {
#line 840
        if ((reg->types + i)->visited_p) {
#line 842
          goto while_break;
        }
        {
#line 846
        (reg->types + i)->visited_p = (_Bool)1;
#line 847
        type = rec_type_reg_get(reg, (char const   *)(reg->types + i)->to_type);
        }
      }
    }
#line 827
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 853
  i = (size_t )0;
  {
#line 853
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 853
    if (! (i < reg->num_types)) {
#line 853
      goto while_break___0;
    }
#line 855
    (reg->types + i)->visited_p = (_Bool)0;
#line 853
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 858
  return (type);
}
}
#line 861 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
char const   *rec_type_name(rec_type_t type ) 
{ 


  {
#line 864
  return ((char const   *)type->name);
}
}
#line 867 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
void rec_type_set_name(rec_type_t type , char const   *name ) 
{ 


  {
  {
#line 870
  type->name = strdup(name);
  }
#line 871
  return;
}
}
#line 873 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
_Bool rec_type_equal_p(rec_type_t type1 , rec_type_t type2 ) 
{ 
  _Bool ret ;
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 880
  ret = (_Bool)1;
#line 882
  if ((unsigned int )type1->kind != (unsigned int )type2->kind) {
#line 884
    ret = (_Bool)0;
  } else
#line 888
  if ((unsigned int )type1->kind == 5U) {
#line 890
    ret = (_Bool )(type1->data.max_size == type2->data.max_size);
  } else
#line 892
  if ((unsigned int )type1->kind == 3U) {
#line 894
    if (type1->data.range[0] == type2->data.range[0]) {
#line 894
      if (type1->data.range[1] == type2->data.range[1]) {
#line 894
        tmp = 1;
      } else {
#line 894
        tmp = 0;
      }
    } else {
#line 894
      tmp = 0;
    }
#line 894
    ret = (_Bool )tmp;
  } else
#line 897
  if ((unsigned int )type1->kind == 9U) {
#line 899
    i = (size_t )0;
    {
#line 899
    while (1) {
      while_continue: /* CIL Label */ ;
#line 899
      if (! (i < type1->size)) {
#line 899
        goto while_break;
      }
#line 901
      if (i < type2->size) {
        {
#line 901
        tmp___0 = strcmp((char const   *)*(type1->data.names + i), (char const   *)*(type2->data.names + i));
        }
#line 901
        if (tmp___0 == 0) {
#line 901
          tmp___1 = 1;
        } else {
#line 901
          tmp___1 = 0;
        }
      } else {
#line 901
        tmp___1 = 0;
      }
#line 901
      ret = (_Bool )tmp___1;
#line 899
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 906
  if ((unsigned int )type1->kind == 7U) {
#line 910
    ret = (_Bool)0;
  }
#line 914
  return (ret);
}
}
#line 917 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
int rec_type_min(rec_type_t type ) 
{ 
  int res ;

  {
#line 922
  if ((unsigned int )type->kind != 3U) {
#line 924
    res = -1;
  } else {
#line 928
    res = type->data.range[0];
  }
#line 931
  return (res);
}
}
#line 934 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
int rec_type_max(rec_type_t type ) 
{ 
  int res ;

  {
#line 939
  if ((unsigned int )type->kind != 3U) {
#line 941
    res = -1;
  } else {
#line 945
    res = type->data.range[1];
  }
#line 948
  return (res);
}
}
#line 951 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
char const   *rec_type_rec(rec_type_t type ) 
{ 
  char const   *res ;

  {
#line 954
  res = (char const   *)((void *)0);
#line 956
  if ((unsigned int )type->kind == 13U) {
#line 958
    res = (char const   *)type->data.recname;
  }
#line 961
  return (res);
}
}
#line 964 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
int rec_type_values_cmp(rec_type_t type , char const   *val1 , char const   *val2 ) 
{ 
  int type_comparison ;
  enum rec_type_kind_e kind ;
  int int1 ;
  int int2 ;
  _Bool tmp ;
  _Bool tmp___0 ;
  double real1 ;
  double real2 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool bool1 ;
  _Bool bool2 ;
  struct timespec op1 ;
  struct timespec op2 ;
  struct timespec diff ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
#line 970
  kind = (enum rec_type_kind_e )0;
#line 972
  if (type) {
#line 974
    kind = type->kind;
  }
  {
#line 980
  if ((unsigned int )kind == 3U) {
#line 980
    goto case_3;
  }
#line 980
  if ((unsigned int )kind == 1U) {
#line 980
    goto case_3;
  }
#line 1004
  if ((unsigned int )kind == 4U) {
#line 1004
    goto case_4;
  }
#line 1028
  if ((unsigned int )kind == 2U) {
#line 1028
    goto case_2;
  }
#line 1054
  if ((unsigned int )kind == 8U) {
#line 1054
    goto case_8;
  }
#line 1088
  goto lexi;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 982
  int2 = 0;
#line 984
  tmp = rec_atoi(val1, & int1);
  }
#line 984
  if (tmp) {
    {
#line 984
    tmp___0 = rec_atoi(val2, & int2);
    }
#line 984
    if (! tmp___0) {
#line 986
      goto lexi;
    }
  } else {
#line 986
    goto lexi;
  }
#line 989
  if (int1 < int2) {
#line 991
    type_comparison = -1;
  } else
#line 993
  if (int1 > int2) {
#line 995
    type_comparison = 1;
  } else {
#line 999
    type_comparison = 0;
  }
#line 1002
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1006
  real2 = (double )0;
#line 1008
  tmp___1 = rec_atod(val1, & real1);
  }
#line 1008
  if (tmp___1) {
    {
#line 1008
    tmp___2 = rec_atod(val2, & real2);
    }
#line 1008
    if (! tmp___2) {
#line 1010
      goto lexi;
    }
  } else {
#line 1010
    goto lexi;
  }
#line 1013
  if (real1 < real2) {
#line 1015
    type_comparison = -1;
  } else
#line 1017
  if (real1 > real2) {
#line 1019
    type_comparison = 1;
  } else {
#line 1023
    type_comparison = 0;
  }
#line 1026
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1030
  bool2 = (_Bool)0;
#line 1034
  bool1 = rec_match(val1, "[ \t\n]*(1|yes|true)[ \t\n]*");
#line 1036
  bool2 = rec_match(val2, "[ \t\n]*(1|yes|true)[ \t\n]*");
  }
#line 1039
  if (! bool1) {
#line 1039
    if (bool2) {
#line 1041
      type_comparison = -1;
    } else {
#line 1039
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1043
  if ((int )bool1 == (int )bool2) {
#line 1045
    type_comparison = 0;
  } else {
#line 1049
    type_comparison = 1;
  }
#line 1052
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1060
  tmp___4 = parse_datetime(& op1, val1, (struct timespec  const  *)((void *)0));
  }
#line 1060
  if (tmp___4) {
    {
#line 1060
    tmp___5 = parse_datetime(& op2, val2, (struct timespec  const  *)((void *)0));
    }
#line 1060
    if (tmp___5) {
#line 1063
      if (op1.tv_sec == op2.tv_sec) {
#line 1063
        if (op1.tv_nsec == op2.tv_nsec) {
#line 1067
          type_comparison = 0;
        } else {
#line 1063
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1069
        tmp___3 = rec_timespec_subtract(& diff, & op1, & op2);
        }
#line 1069
        if (tmp___3) {
#line 1072
          type_comparison = -1;
        } else {
#line 1077
          type_comparison = 1;
        }
      }
    } else {
#line 1083
      goto lexi;
    }
  } else {
#line 1083
    goto lexi;
  }
#line 1086
  goto switch_break;
  lexi: 
  switch_default: /* CIL Label */ 
  {
#line 1092
  type_comparison = strcmp(val1, val2);
  }
#line 1093
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1097
  return (type_comparison);
}
}
#line 1104 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static enum rec_type_kind_e rec_type_parse_type_kind(char *str ) 
{ 
  enum rec_type_kind_e res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1109
  res = (enum rec_type_kind_e )0;
#line 1111
  tmp = strcmp((char const   *)str, "int");
  }
#line 1111
  if (tmp == 0) {
#line 1113
    res = (enum rec_type_kind_e )1;
  }
  {
#line 1115
  tmp___0 = strcmp((char const   *)str, "bool");
  }
#line 1115
  if (tmp___0 == 0) {
#line 1117
    res = (enum rec_type_kind_e )2;
  }
  {
#line 1119
  tmp___1 = strcmp((char const   *)str, "range");
  }
#line 1119
  if (tmp___1 == 0) {
#line 1121
    res = (enum rec_type_kind_e )3;
  }
  {
#line 1123
  tmp___2 = strcmp((char const   *)str, "real");
  }
#line 1123
  if (tmp___2 == 0) {
#line 1125
    res = (enum rec_type_kind_e )4;
  }
  {
#line 1127
  tmp___3 = strcmp((char const   *)str, "size");
  }
#line 1127
  if (tmp___3 == 0) {
#line 1129
    res = (enum rec_type_kind_e )5;
  }
  {
#line 1131
  tmp___4 = strcmp((char const   *)str, "line");
  }
#line 1131
  if (tmp___4 == 0) {
#line 1133
    res = (enum rec_type_kind_e )6;
  }
  {
#line 1135
  tmp___5 = strcmp((char const   *)str, "regexp");
  }
#line 1135
  if (tmp___5 == 0) {
#line 1137
    res = (enum rec_type_kind_e )7;
  }
  {
#line 1139
  tmp___6 = strcmp((char const   *)str, "date");
  }
#line 1139
  if (tmp___6 == 0) {
#line 1141
    res = (enum rec_type_kind_e )8;
  }
  {
#line 1143
  tmp___7 = strcmp((char const   *)str, "email");
  }
#line 1143
  if (tmp___7 == 0) {
#line 1145
    res = (enum rec_type_kind_e )11;
  }
  {
#line 1147
  tmp___8 = strcmp((char const   *)str, "enum");
  }
#line 1147
  if (tmp___8 == 0) {
#line 1149
    res = (enum rec_type_kind_e )9;
  }
  {
#line 1151
  tmp___9 = strcmp((char const   *)str, "field");
  }
#line 1151
  if (tmp___9 == 0) {
#line 1153
    res = (enum rec_type_kind_e )10;
  }
  {
#line 1155
  tmp___10 = strcmp((char const   *)str, "rec");
  }
#line 1155
  if (tmp___10 == 0) {
#line 1157
    res = (enum rec_type_kind_e )13;
  }
#line 1166
  return (res);
}
}
#line 1169 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_int(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char *tmp ;

  {
  {
#line 1176
  ret = rec_match(str, "^[ \t\n]*-?((0x[0-9a-fA-F]+)|[0-9]+)[ \t\n]*$");
  }
#line 1177
  if (! ret) {
#line 1177
    if (errors) {
      {
#line 1179
      tmp = dcgettext("recutils", "invalid integer.", 5);
#line 1179
      rec_buf_puts((char const   *)tmp, errors);
      }
    }
  }
#line 1182
  return (ret);
}
}
#line 1185 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_rec(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 


  {
#line 1196
  return ((_Bool)1);
}
}
#line 1199 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_field(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char *tmp ;

  {
  {
#line 1206
  ret = rec_match(str, "^[ \t\n]*[a-zA-Z%][a-zA-Z0-9_]*[ \t\n]*$");
  }
#line 1207
  if (! ret) {
#line 1207
    if (errors) {
      {
#line 1209
      tmp = dcgettext("recutils", "invalid \'field\' value.", 5);
#line 1209
      rec_buf_puts((char const   *)tmp, errors);
      }
    }
  }
#line 1212
  return (ret);
}
}
#line 1240 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_bool(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char *tmp ;

  {
  {
#line 1247
  ret = rec_match(str, "^[ \t\n]*(1|yes|true|0|no|false)[ \t\n]*$");
  }
#line 1248
  if (! ret) {
#line 1248
    if (errors) {
      {
#line 1250
      tmp = dcgettext("recutils", "invalid \'bool\' value.", 5);
#line 1250
      rec_buf_puts((char const   *)tmp, errors);
      }
    }
  }
#line 1253
  return (ret);
}
}
#line 1256 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_range(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char const   *p ;
  int num ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1266
  p = str;
#line 1268
  rec_skip_blanks(& p);
#line 1269
  tmp___1 = rec_parse_int(& p, & num);
  }
#line 1269
  if (! tmp___1) {
#line 1271
    if (errors) {
      {
#line 1273
      tmp___0 = dcgettext("recutils", "invalid \'range\' value.", 5);
#line 1273
      rec_buf_puts((char const   *)tmp___0, errors);
      }
    }
#line 1275
    return ((_Bool)0);
  }
#line 1278
  if (num >= type->data.range[0]) {
#line 1278
    if (num <= type->data.range[1]) {
#line 1278
      tmp___2 = 1;
    } else {
#line 1278
      tmp___2 = 0;
    }
  } else {
#line 1278
    tmp___2 = 0;
  }
#line 1278
  ret = (_Bool )tmp___2;
#line 1280
  if (! ret) {
#line 1280
    if (errors) {
      {
#line 1282
      tmp___3 = dcgettext("recutils", "expected an integer between %d and %d.", 5);
#line 1282
      tmp___4 = asprintf((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)tmp___3,
                         type->data.range[0], type->data.range[1]);
      }
#line 1282
      if (tmp___4 != -1) {
        {
#line 1285
        rec_buf_puts((char const   *)tmp, errors);
#line 1286
        free((void *)tmp);
        }
      }
    }
  }
#line 1290
  return (ret);
}
}
#line 1293 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_real(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char *tmp ;

  {
  {
#line 1300
  ret = rec_match(str, "^[ \t\n]*-?([0-9]+)?(\\.[0-9]+)?[ \t\n]*$");
  }
#line 1301
  if (! ret) {
#line 1301
    if (errors) {
      {
#line 1303
      tmp = dcgettext("recutils", "invalid \'real\' value.", 5);
#line 1303
      rec_buf_puts((char const   *)tmp, errors);
      }
    }
  }
#line 1306
  return (ret);
}
}
#line 1309 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_size(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1317
  tmp___0 = strlen(str);
#line 1317
  ret = (_Bool )(tmp___0 <= type->data.max_size);
  }
#line 1318
  if (! ret) {
#line 1318
    if (errors) {
      {
#line 1320
      tmp___1 = dcgettext("recutils", "value too large.  Expected a size <= %zu.",
                          5);
#line 1320
      tmp___2 = asprintf((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)tmp___1,
                         type->data.max_size);
      }
#line 1320
      if (tmp___2 != -1) {
        {
#line 1324
        rec_buf_puts((char const   *)tmp, errors);
#line 1325
        free((void *)tmp);
        }
      }
    }
  }
  {
#line 1329
  tmp___3 = strlen(str);
  }
#line 1329
  return ((_Bool )(tmp___3 <= type->data.max_size));
}
}
#line 1332 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_line(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char *tmp ;

  {
  {
#line 1339
  ret = rec_match(str, "^[^\n]*$");
  }
#line 1340
  if (! ret) {
#line 1340
    if (errors) {
      {
#line 1342
      tmp = dcgettext("recutils", "invalid \'line\' value.", 5);
#line 1342
      rec_buf_puts((char const   *)tmp, errors);
      }
    }
  }
#line 1345
  return (ret);
}
}
#line 1348 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_regexp(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1354
  tmp = rpl_regexec((regex_t const   */* __restrict  */)(& type->data.regexp), (char const   */* __restrict  */)str,
                    (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 1354
  ret = (_Bool )(tmp == 0);
  }
#line 1359
  if (! ret) {
#line 1359
    if (errors) {
      {
#line 1361
      tmp___0 = dcgettext("recutils", "value does not match the regexp.", 5);
#line 1361
      rec_buf_puts((char const   *)tmp___0, errors);
      }
    }
  }
#line 1364
  return (ret);
}
}
#line 1367 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_date(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  struct timespec tm ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1375
  tmp = strcmp(str, "");
  }
#line 1375
  if (tmp == 0) {
#line 1378
    return ((_Bool)0);
  }
  {
#line 1381
  ret = parse_datetime(& tm, str, (struct timespec  const  *)((void *)0));
  }
#line 1382
  if (! ret) {
#line 1382
    if (errors) {
      {
#line 1384
      tmp___0 = dcgettext("recutils", "invalid date.", 5);
#line 1384
      rec_buf_puts((char const   *)tmp___0, errors);
      }
    }
  }
#line 1387
  return (ret);
}
}
#line 1390 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_email(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  _Bool ret ;
  char *tmp ;

  {
  {
#line 1397
  ret = rec_match(str, "^[ \n\t]*[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}[ \n\t]*$");
  }
#line 1398
  if (! ret) {
#line 1398
    if (errors) {
      {
#line 1400
      tmp = dcgettext("recutils", "invalid email.", 5);
#line 1400
      rec_buf_puts((char const   *)tmp, errors);
      }
    }
  }
#line 1403
  return (ret);
}
}
#line 1406 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_check_enum(rec_type_t type , char const   *str , rec_buf_t errors ) 
{ 
  size_t i ;
  char const   *p ;
  char const   *b ;
  char name[100] ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1415
  tmp___4 = rec_match(str, "^[ \t\n]*[a-zA-Z0-9][a-zA-Z0-9_-]*[ \t\n]*$");
  }
#line 1415
  if (tmp___4) {
#line 1418
    p = str;
    {
#line 1420
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1420
      if (p) {
        {
#line 1420
        tmp = rec_blank_p((char )*p);
        }
#line 1420
        if (! tmp) {
#line 1420
          goto while_break;
        }
      } else {
#line 1420
        goto while_break;
      }
#line 1422
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1425
    b = p;
    {
#line 1426
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1426
      if (p) {
        {
#line 1426
        tmp___0 = rec_letter_p((char )*p);
        }
#line 1426
        if (! tmp___0) {
          {
#line 1426
          tmp___1 = rec_letter_p((char )*p);
          }
#line 1426
          if (! tmp___1) {
            {
#line 1426
            tmp___2 = rec_digit_p((char )*p);
            }
#line 1426
            if (! tmp___2) {
#line 1426
              if (! ((int const   )*p == 95)) {
#line 1426
                if (! ((int const   )*p == 45)) {
#line 1426
                  goto while_break___0;
                }
              }
            }
          }
        }
      } else {
#line 1426
        goto while_break___0;
      }
#line 1432
      name[p - b] = (char )*p;
#line 1433
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1435
    name[p - b] = (char )'\000';
#line 1438
    i = (size_t )0;
    {
#line 1438
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1438
      if (! (i < type->size)) {
#line 1438
        goto while_break___1;
      }
      {
#line 1439
      tmp___3 = strcmp((char const   *)(name), (char const   *)*(type->data.names + i));
      }
#line 1439
      if (tmp___3 == 0) {
#line 1440
        return ((_Bool)1);
      }
#line 1438
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1443
  if (errors) {
    {
#line 1445
    tmp___5 = dcgettext("recutils", "invalid enum value.", 5);
#line 1445
    rec_buf_puts((char const   *)tmp___5, errors);
    }
  }
#line 1448
  return ((_Bool)0);
}
}
#line 1451 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static char const   *rec_type_parse_size(char const   *str , rec_type_t type ) 
{ 
  char const   *p ;
  int size ;
  _Bool tmp ;

  {
  {
#line 1457
  p = str;
#line 1460
  rec_skip_blanks(& p);
#line 1463
  tmp = rec_parse_int(& p, & size);
  }
#line 1463
  if (tmp) {
#line 1463
    if (size >= 0) {
#line 1466
      type->data.max_size = (size_t )size;
    } else {
#line 1470
      p = (char const   *)((void *)0);
    }
  } else {
#line 1470
    p = (char const   *)((void *)0);
  }
#line 1473
  return (p);
}
}
#line 1476 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static char const   *rec_type_parse_enum(char const   *str , rec_type_t type ) 
{ 
  char const   *p ;
  size_t i ;
  void *tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1482
  p = str;
#line 1484
  type->size = (size_t )0;
#line 1485
  type->data.names = (char **)((void *)0);
  {
#line 1487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1487
    if (! *p) {
#line 1487
      goto while_break;
    }
#line 1490
    if (type->size % 50UL == 0UL) {
      {
#line 1491
      tmp = realloc((void *)type->data.names, (type->size / 50UL + 1UL) * (sizeof(char *) * 50UL));
#line 1491
      type->data.names = (char **)tmp;
      }
    }
    {
#line 1495
    rec_skip_blanks(& p);
    }
#line 1497
    if ((int const   )*p == 40) {
#line 1500
      p ++;
      {
#line 1501
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1501
        if (*p) {
#line 1501
          if ((int const   )*p != 41) {
#line 1501
            if (! ((int const   )*p != 40)) {
#line 1501
              goto while_break___0;
            }
          } else {
#line 1501
            goto while_break___0;
          }
        } else {
#line 1501
          goto while_break___0;
        }
#line 1503
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1505
      if ((int const   )*p == 41) {
#line 1507
        p ++;
      } else {
#line 1512
        p = (char const   *)((void *)0);
#line 1513
        goto while_break;
      }
    } else
#line 1516
    if (*p) {
      {
#line 1519
      tmp___0 = type->size;
#line 1519
      (type->size) ++;
#line 1519
      tmp___1 = rec_parse_regexp(& p, "^[a-zA-Z0-9][a-zA-Z0-9_-]*", type->data.names + tmp___0);
      }
#line 1519
      if (! tmp___1) {
#line 1523
        p = (char const   *)((void *)0);
#line 1524
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1529
  if (type->size == 0UL) {
#line 1533
    return ((char const   *)((void *)0));
  }
#line 1536
  if (! p) {
#line 1539
    i = (size_t )0;
    {
#line 1539
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1539
      if (! (i < type->size)) {
#line 1539
        goto while_break___1;
      }
      {
#line 1541
      free((void *)*(type->data.names + i));
#line 1539
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1545
  return (p);
}
}
#line 1548 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static char const   *rec_type_parse_regexp_type(char const   *str , rec_type_t type ) 
{ 
  char const   *p ;
  char re[200] ;
  _Bool end_regexp ;
  size_t i ;
  char delim_char ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1557
  p = str;
#line 1569
  rec_skip_blanks(& p);
#line 1571
  end_regexp = (_Bool)0;
#line 1572
  delim_char = (char )*p;
#line 1573
  p ++;
#line 1575
  i = (size_t )0;
  }
  {
#line 1576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1576
    if (! *p) {
#line 1576
      goto while_break;
    }
#line 1578
    if ((int const   )*p == (int const   )delim_char) {
#line 1580
      if ((int const   )*(p + 1) == (int const   )delim_char) {
#line 1582
        tmp = i;
#line 1582
        i ++;
#line 1582
        re[tmp] = delim_char;
#line 1583
        p ++;
      } else {
#line 1588
        p ++;
#line 1589
        end_regexp = (_Bool)1;
#line 1590
        goto while_break;
      }
    } else {
#line 1595
      tmp___0 = i;
#line 1595
      i ++;
#line 1595
      re[tmp___0] = (char )*p;
    }
#line 1598
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1600
  re[i] = (char )'\000';
#line 1602
  if (! end_regexp) {
#line 1605
    p = (char const   *)((void *)0);
  } else {
    {
#line 1610
    tmp___1 = rpl_regcomp((regex_t */* __restrict  */)(& type->data.regexp), (char const   */* __restrict  */)(re),
                          1);
    }
#line 1610
    if (tmp___1 != 0) {
#line 1613
      p = (char const   *)((void *)0);
    }
  }
#line 1617
  return (p);
}
}
#line 1620 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static char const   *rec_type_parse_rec(char const   *str , rec_type_t type ) 
{ 
  char const   *p ;
  _Bool tmp ;

  {
  {
#line 1623
  p = str;
#line 1626
  rec_skip_blanks(& p);
#line 1627
  tmp = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*", & type->data.recname);
  }
#line 1627
  if (! tmp) {
#line 1631
    return ((char const   *)((void *)0));
  }
#line 1634
  return (p);
}
}
#line 1637 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static _Bool rec_type_parse_range_point(char const   **str , int *num ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 1640
  tmp___1 = rec_match(*str, "^MIN");
  }
#line 1640
  if (tmp___1) {
#line 1642
    *num = (-0x7FFFFFFF-1);
#line 1643
    *str += 3;
  } else {
    {
#line 1645
    tmp___0 = rec_match(*str, "^MAX");
    }
#line 1645
    if (tmp___0) {
#line 1647
      *num = 2147483647;
#line 1648
      *str += 3;
    } else {
      {
#line 1650
      tmp = rec_parse_int(str, num);
      }
#line 1650
      if (! tmp) {
#line 1652
        return ((_Bool)0);
      }
    }
  }
#line 1655
  return ((_Bool)1);
}
}
#line 1658 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-types.c"
static char const   *rec_type_parse_range(char const   *str , rec_type_t type ) 
{ 
  char const   *p ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1663
  p = str;
#line 1665
  rec_skip_blanks(& p);
#line 1667
  tmp = rec_type_parse_range_point(& p, & type->data.range[0]);
  }
#line 1667
  if (! tmp) {
#line 1669
    return ((char const   *)((void *)0));
  }
  {
#line 1672
  rec_skip_blanks(& p);
  }
#line 1674
  if ((int const   )*p == 0) {
#line 1678
    type->data.range[1] = type->data.range[0];
#line 1679
    type->data.range[0] = 0;
  } else {
    {
#line 1683
    tmp___0 = rec_type_parse_range_point(& p, & type->data.range[1]);
    }
#line 1683
    if (! tmp___0) {
#line 1685
      return ((char const   *)((void *)0));
    }
  }
#line 1689
  return (p);
}
}
#line 439 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
#line 473 "./rec.h"
rec_fex_t rec_fex_new(char const   *str , enum rec_fex_kind_e kind ) ;
#line 477
void rec_fex_destroy(rec_fex_t fex ) ;
#line 483
rec_fex_t rec_fex_dup(rec_fex_t fex ) ;
#line 489
size_t rec_fex_size(rec_fex_t fex ) ;
#line 494
_Bool rec_fex_member_p(rec_fex_t fex , char const   *fname , int min , int max ) ;
#line 499
rec_fex_elem_t rec_fex_get(rec_fex_t fex , size_t position ) ;
#line 505
rec_fex_elem_t rec_fex_append(rec_fex_t fex , char const   *fname , int min , int max ) ;
#line 511
_Bool rec_fex_all_calls_p(rec_fex_t fex ) ;
#line 518
char const   *rec_fex_elem_field_name(rec_fex_elem_t elem ) ;
#line 524
_Bool rec_fex_elem_set_field_name(rec_fex_elem_t elem , char const   *fname ) ;
#line 529
int rec_fex_elem_min(rec_fex_elem_t elem ) ;
#line 535
int rec_fex_elem_max(rec_fex_elem_t elem ) ;
#line 541
char const   *rec_fex_elem_rewrite_to(rec_fex_elem_t elem ) ;
#line 546
char const   *rec_fex_elem_function_name(rec_fex_elem_t elem ) ;
#line 551
void **rec_fex_elem_function_data(rec_fex_elem_t elem ) ;
#line 558
_Bool rec_fex_check(char const   *str , enum rec_fex_kind_e kind ) ;
#line 563
void rec_fex_sort(rec_fex_t fex ) ;
#line 568
char *rec_fex_str(rec_fex_t fex , enum rec_fex_kind_e kind ) ;
#line 81 "./rec-utils.h"
char *rec_concat_strings(char const   *str1 , char const   *str2 , char const   *str3 ) ;
#line 67 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
static void rec_fex_init(rec_fex_t fex ) ;
#line 69
static _Bool rec_fex_parse_str_simple(rec_fex_t new , char const   *str , char const   *sep ) ;
#line 70
static _Bool rec_fex_parse_str_subscripts(rec_fex_t new , char const   *str ) ;
#line 71
static _Bool rec_fex_parse_elem(rec_fex_elem_t elem , char const   *str ) ;
#line 77 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
rec_fex_t rec_fex_new(char const   *str , enum rec_fex_kind_e kind ) 
{ 
  rec_fex_t new ;
  int i ;
  void *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 84
  tmp = malloc(sizeof(struct rec_fex_s ));
#line 84
  new = (rec_fex_t )tmp;
  }
#line 85
  if (new) {
    {
#line 87
    rec_fex_init(new);
#line 89
    new->num_elems = 0;
#line 90
    new->str = (char *)((void *)0);
#line 91
    i = 0;
    }
    {
#line 91
    while (1) {
      while_continue: /* CIL Label */ ;
#line 91
      if (! (i < 256)) {
#line 91
        goto while_break;
      }
#line 93
      new->elems[i] = (rec_fex_elem_t )0;
#line 91
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 96
    if ((unsigned long )str != (unsigned long )((void *)0)) {
#line 102
      if ((unsigned int )kind == 2U) {
        {
#line 104
        tmp___0 = rec_fex_parse_str_subscripts(new, str);
        }
#line 104
        if (! tmp___0) {
          {
#line 107
          free((void *)new);
          }
#line 108
          return ((rec_fex_t )((void *)0));
        }
      } else
#line 111
      if ((unsigned int )kind == 0U) {
        {
#line 113
        tmp___1 = rec_fex_parse_str_simple(new, str, " \t\n");
        }
#line 113
        if (! tmp___1) {
          {
#line 116
          free((void *)new);
          }
#line 117
          return ((rec_fex_t )((void *)0));
        }
      } else {
        {
#line 122
        tmp___2 = rec_fex_parse_str_simple(new, str, ",");
        }
#line 122
        if (! tmp___2) {
          {
#line 125
          free((void *)new);
          }
#line 126
          return ((rec_fex_t )((void *)0));
        }
      }
    }
  }
#line 132
  return (new);
}
}
#line 135 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
void rec_fex_destroy(rec_fex_t fex ) 
{ 
  int i ;

  {
#line 140
  if (fex) {
#line 142
    i = 0;
    {
#line 142
    while (1) {
      while_continue: /* CIL Label */ ;
#line 142
      if (! (i < fex->num_elems)) {
#line 142
        goto while_break;
      }
      {
#line 144
      free((void *)(fex->elems[i])->rewrite_to);
#line 145
      free((void *)(fex->elems[i])->field_name);
#line 146
      free((void *)(fex->elems[i])->str);
#line 147
      free((void *)fex->elems[i]);
#line 142
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 150
    free((void *)fex->str);
#line 151
    free((void *)fex);
    }
  }
#line 153
  return;
}
}
#line 155 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
rec_fex_t rec_fex_dup(rec_fex_t fex ) 
{ 
  rec_fex_t copy ;
  size_t i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 158
  copy = (rec_fex_t )((void *)0);
#line 159
  i = (size_t )0;
#line 161
  tmp = malloc(sizeof(struct rec_fex_s ));
#line 161
  copy = (rec_fex_t )tmp;
  }
#line 162
  if (copy) {
    {
#line 164
    rec_fex_init(copy);
#line 166
    copy->num_elems = fex->num_elems;
#line 167
    copy->str = strdup((char const   *)fex->str);
    }
#line 168
    if (! copy->str) {
      {
#line 171
      rec_fex_destroy(copy);
      }
#line 172
      return ((rec_fex_t )((void *)0));
    }
#line 175
    i = (size_t )0;
    {
#line 175
    while (1) {
      while_continue: /* CIL Label */ ;
#line 175
      if (! (i < (size_t )fex->num_elems)) {
#line 175
        goto while_break;
      }
#line 177
      if ((unsigned long )fex->elems[i] == (unsigned long )((void *)0)) {
#line 179
        copy->elems[i] = (rec_fex_elem_t )((void *)0);
#line 180
        goto __Cont;
      }
      {
#line 183
      tmp___0 = malloc(sizeof(struct rec_fex_elem_s ));
#line 183
      copy->elems[i] = (rec_fex_elem_t )tmp___0;
      }
#line 184
      if (! copy->elems[i]) {
        {
#line 187
        rec_fex_destroy(copy);
        }
#line 188
        return ((rec_fex_t )((void *)0));
      }
#line 191
      (copy->elems[i])->max = (fex->elems[i])->max;
#line 192
      (copy->elems[i])->min = (fex->elems[i])->min;
      {
#line 213
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 213
        if (! (fex->elems[i])->str) {
#line 213
          (copy->elems[i])->str = (char *)((void *)0);
        } else {
          {
#line 213
          (copy->elems[i])->str = strdup((char const   *)(fex->elems[i])->str);
          }
#line 213
          if (! (copy->elems[i])->str) {
            {
#line 213
            rec_fex_destroy(copy);
            }
#line 213
            return ((rec_fex_t )((void *)0));
          }
        }
#line 213
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 214
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 214
        if (! (fex->elems[i])->field_name) {
#line 214
          (copy->elems[i])->field_name = (char *)((void *)0);
        } else {
          {
#line 214
          (copy->elems[i])->field_name = strdup((char const   *)(fex->elems[i])->field_name);
          }
#line 214
          if (! (copy->elems[i])->field_name) {
            {
#line 214
            rec_fex_destroy(copy);
            }
#line 214
            return ((rec_fex_t )((void *)0));
          }
        }
#line 214
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 215
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 215
        if (! (fex->elems[i])->rewrite_to) {
#line 215
          (copy->elems[i])->rewrite_to = (char *)((void *)0);
        } else {
          {
#line 215
          (copy->elems[i])->rewrite_to = strdup((char const   *)(fex->elems[i])->rewrite_to);
          }
#line 215
          if (! (copy->elems[i])->rewrite_to) {
            {
#line 215
            rec_fex_destroy(copy);
            }
#line 215
            return ((rec_fex_t )((void *)0));
          }
        }
#line 215
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 216
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 216
        if (! (fex->elems[i])->function_name) {
#line 216
          (copy->elems[i])->function_name = (char *)((void *)0);
        } else {
          {
#line 216
          (copy->elems[i])->function_name = strdup((char const   *)(fex->elems[i])->function_name);
          }
#line 216
          if (! (copy->elems[i])->function_name) {
            {
#line 216
            rec_fex_destroy(copy);
            }
#line 216
            return ((rec_fex_t )((void *)0));
          }
        }
#line 216
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 175
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 220
  return (copy);
}
}
#line 223 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
_Bool rec_fex_check(char const   *str , enum rec_fex_kind_e kind ) 
{ 
  char *regexp_str ;
  _Bool tmp ;

  {
  {
#line 230
  if ((unsigned int )kind == 0U) {
#line 230
    goto case_0;
  }
#line 235
  if ((unsigned int )kind == 1U) {
#line 235
    goto case_1;
  }
#line 240
  if ((unsigned int )kind == 2U) {
#line 240
    goto case_2;
  }
#line 245
  goto switch_default;
  case_0: /* CIL Label */ 
#line 232
  regexp_str = (char *)"^[a-zA-Z%][a-zA-Z0-9_]*([ \n\t]+[a-zA-Z%][a-zA-Z0-9_]*)*$";
#line 233
  goto switch_break;
  case_1: /* CIL Label */ 
#line 237
  regexp_str = (char *)"^[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?(,[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?)*$";
#line 238
  goto switch_break;
  case_2: /* CIL Label */ 
#line 242
  regexp_str = (char *)"^([a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?(\\[[0-9]+(-[0-9]+)?\\])?|[a-zA-Z_][a-zA-Z0-9_]*\\([a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?\\))(:[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?)?(,([a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?(\\[[0-9]+(-[0-9]+)?\\])?|[a-zA-Z_][a-zA-Z0-9_]*\\([a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?\\))(:[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?)?)*$";
#line 243
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 247
  regexp_str = (char *)((void *)0);
#line 248
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 252
  tmp = rec_match(str, (char const   *)regexp_str);
  }
#line 252
  return (tmp);
}
}
#line 255 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
size_t rec_fex_size(rec_fex_t fex ) 
{ 


  {
#line 258
  return ((size_t )fex->num_elems);
}
}
#line 261 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
rec_fex_elem_t rec_fex_get(rec_fex_t fex , size_t position ) 
{ 


  {
#line 265
  if (position < 0UL) {
#line 267
    return ((rec_fex_elem_t )((void *)0));
  } else
#line 265
  if (position >= (size_t )fex->num_elems) {
#line 267
    return ((rec_fex_elem_t )((void *)0));
  }
#line 270
  return (fex->elems[position]);
}
}
#line 273 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
char const   *rec_fex_elem_field_name(rec_fex_elem_t elem ) 
{ 


  {
#line 276
  return ((char const   *)elem->field_name);
}
}
#line 279 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
_Bool rec_fex_elem_set_field_name(rec_fex_elem_t elem , char const   *fname ) 
{ 


  {
  {
#line 283
  free((void *)elem->field_name);
#line 284
  elem->field_name = strdup(fname);
  }
#line 285
  return ((_Bool )((unsigned long )elem->field_name != (unsigned long )((void *)0)));
}
}
#line 288 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
int rec_fex_elem_min(rec_fex_elem_t elem ) 
{ 


  {
#line 291
  return (elem->min);
}
}
#line 294 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
int rec_fex_elem_max(rec_fex_elem_t elem ) 
{ 


  {
#line 297
  return (elem->max);
}
}
#line 300 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
char const   *rec_fex_elem_rewrite_to(rec_fex_elem_t elem ) 
{ 


  {
#line 303
  return ((char const   *)elem->rewrite_to);
}
}
#line 306 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
void rec_fex_sort(rec_fex_t fex ) 
{ 
  _Bool done ;
  rec_fex_elem_t aux ;
  int i ;
  int j ;

  {
#line 315
  i = 1;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! (i < fex->num_elems)) {
#line 315
      goto while_break;
    }
#line 317
    aux = fex->elems[i];
#line 318
    j = i - 1;
#line 319
    done = (_Bool)0;
    {
#line 321
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 321
      if (! (! done)) {
#line 321
        goto while_break___0;
      }
#line 324
      if ((fex->elems[j])->min == -1) {
#line 324
        goto _L;
      } else
#line 324
      if ((fex->elems[j])->min > aux->min) {
        _L: /* CIL Label */ 
#line 326
        fex->elems[j + 1] = fex->elems[j];
#line 327
        j --;
#line 328
        if (j < 0) {
#line 330
          done = (_Bool)1;
        }
      } else {
#line 335
        done = (_Bool)1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 339
    fex->elems[j + 1] = aux;
#line 315
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return;
}
}
#line 343 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
char *rec_fex_str(rec_fex_t fex , enum rec_fex_kind_e kind ) 
{ 
  char *result ;
  size_t result_size ;
  rec_buf_t buf ;
  size_t i ;
  char *tmp ;
  char *field_str ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 353
  result = (char *)((void *)0);
#line 354
  buf = rec_buf_new(& result, & result_size);
  }
#line 355
  if (buf) {
#line 357
    field_str = (char *)((void *)0);
#line 359
    i = (size_t )0;
    {
#line 359
    while (1) {
      while_continue: /* CIL Label */ ;
#line 359
      if (! (i < (size_t )fex->num_elems)) {
#line 359
        goto while_break;
      }
#line 361
      if (i != 0UL) {
#line 363
        if ((unsigned int )kind == 0U) {
          {
#line 365
          rec_buf_putc(' ', buf);
          }
        } else {
          {
#line 369
          rec_buf_putc(',', buf);
          }
        }
      }
      {
#line 373
      field_str = strdup((char const   *)(fex->elems[i])->field_name);
      }
#line 374
      if (! field_str) {
        {
#line 376
        rec_buf_close(buf);
#line 377
        free((void *)result);
        }
#line 378
        return ((char *)((void *)0));
      }
      {
#line 381
      rec_buf_puts((char const   *)field_str, buf);
#line 382
      free((void *)field_str);
      }
#line 384
      if ((unsigned int )kind == 2U) {
#line 386
        if ((fex->elems[i])->min != -1) {
#line 386
          goto _L;
        } else
#line 386
        if ((fex->elems[i])->max != -1) {
          _L: /* CIL Label */ 
          {
#line 389
          rec_buf_putc('[', buf);
          }
#line 390
          if ((fex->elems[i])->min != -1) {
            {
#line 392
            tmp___0 = asprintf((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)"%d",
                               (fex->elems[i])->min);
            }
#line 392
            if (tmp___0 != -1) {
              {
#line 394
              rec_buf_puts((char const   *)tmp, buf);
#line 395
              free((void *)tmp);
              }
            }
          }
#line 398
          if ((fex->elems[i])->max != -1) {
            {
#line 400
            tmp___1 = asprintf((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)"-%d",
                               (fex->elems[i])->max);
            }
#line 400
            if (tmp___1 != -1) {
              {
#line 402
              rec_buf_puts((char const   *)tmp, buf);
#line 403
              free((void *)tmp);
              }
            }
          }
          {
#line 407
          rec_buf_putc(']', buf);
          }
        }
      }
#line 359
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 413
  rec_buf_close(buf);
  }
#line 415
  return (result);
}
}
#line 418 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
_Bool rec_fex_member_p(rec_fex_t fex , char const   *fname , int min , int max ) 
{ 
  _Bool res ;
  int i ;
  _Bool tmp ;

  {
#line 424
  res = (_Bool)0;
#line 427
  i = 0;
  {
#line 427
  while (1) {
    while_continue: /* CIL Label */ ;
#line 427
    if (! (i < fex->num_elems)) {
#line 427
      goto while_break;
    }
    {
#line 429
    tmp = rec_field_name_equal_p(fname, (char const   *)(fex->elems[i])->field_name);
    }
#line 429
    if (tmp) {
#line 429
      if (min == -1) {
#line 429
        goto _L;
      } else
#line 429
      if ((fex->elems[i])->min == min) {
        _L: /* CIL Label */ 
#line 429
        if (max == -1) {
#line 434
          res = (_Bool)1;
#line 435
          goto while_break;
        } else
#line 429
        if ((fex->elems[i])->max == max) {
#line 434
          res = (_Bool)1;
#line 435
          goto while_break;
        }
      }
    }
#line 427
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 439
  return (res);
}
}
#line 442 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
rec_fex_elem_t rec_fex_append(rec_fex_t fex , char const   *fname , int min , int max ) 
{ 
  rec_fex_elem_t new_elem ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 450
  if (fex->num_elems >= 256) {
    {
#line 452
    tmp = dcgettext("recutils", "internal error: REC_FEX_MAX_ELEMS exceeded.  Please report this.\n",
                    5);
#line 452
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 453
    return ((rec_fex_elem_t )((void *)0));
  }
  {
#line 456
  tmp___0 = malloc(sizeof(struct rec_fex_elem_s ));
#line 456
  new_elem = (rec_fex_elem_t )tmp___0;
  }
#line 457
  if (new_elem) {
    {
#line 459
    memset((void *)new_elem, 0, sizeof(*new_elem));
#line 460
    new_elem->field_name = strdup(fname);
    }
#line 461
    if (! new_elem->field_name) {
      {
#line 464
      free((void *)new_elem);
      }
#line 465
      return ((rec_fex_elem_t )((void *)0));
    }
    {
#line 468
    new_elem->str = strdup(fname);
    }
#line 469
    if (! new_elem->str) {
      {
#line 472
      free((void *)new_elem->field_name);
#line 473
      free((void *)new_elem);
      }
#line 474
      return ((rec_fex_elem_t )((void *)0));
    }
#line 477
    new_elem->min = min;
#line 478
    new_elem->max = max;
#line 479
    tmp___1 = fex->num_elems;
#line 479
    (fex->num_elems) ++;
#line 479
    fex->elems[tmp___1] = new_elem;
  }
#line 482
  return (new_elem);
}
}
#line 485 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
char const   *rec_fex_elem_function_name(rec_fex_elem_t elem ) 
{ 


  {
#line 488
  return ((char const   *)elem->function_name);
}
}
#line 491 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
void **rec_fex_elem_function_data(rec_fex_elem_t elem ) 
{ 


  {
#line 494
  return ((void **)elem->function_data);
}
}
#line 497 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
_Bool rec_fex_all_calls_p(rec_fex_t fex ) 
{ 
  _Bool result ;
  size_t i ;

  {
#line 500
  result = (_Bool)1;
#line 501
  i = (size_t )0;
#line 503
  i = (size_t )0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (i < (size_t )fex->num_elems)) {
#line 503
      goto while_break;
    }
#line 505
    if ((unsigned long )(fex->elems[i])->function_name == (unsigned long )((void *)0)) {
#line 507
      result = (_Bool)0;
#line 508
      goto while_break;
    }
#line 503
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  return (result);
}
}
#line 519 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
static void rec_fex_init(rec_fex_t fex ) 
{ 


  {
  {
#line 526
  memset((void *)fex, 0, sizeof(struct rec_fex_s ));
  }
#line 527
  return;
}
}
#line 529 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
static _Bool rec_fex_parse_str_simple(rec_fex_t new , char const   *str , char const   *sep ) 
{ 
  _Bool res ;
  rec_fex_elem_t elem ;
  char *fex_str ;
  char *fex_str_orig ;
  char *elem_str ;
  size_t i ;
  char const   *p ;
  _Bool tmp ;
  char *subname ;
  _Bool tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;

  {
#line 540
  if (! str) {
#line 542
    return ((_Bool)0);
  }
  {
#line 545
  fex_str = strdup(str);
  }
#line 546
  if (! fex_str) {
#line 548
    return ((_Bool)0);
  }
  {
#line 550
  fex_str_orig = fex_str;
#line 552
  res = (_Bool)1;
#line 554
  elem_str = strsep((char **/* __restrict  */)(& fex_str), (char const   */* __restrict  */)sep);
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 557
    tmp___3 = strlen((char const   *)elem_str);
    }
#line 557
    if (tmp___3 > 0UL) {
      {
#line 559
      tmp___2 = malloc(sizeof(struct rec_fex_elem_s ));
#line 559
      elem = (rec_fex_elem_t )tmp___2;
      }
#line 559
      if (elem) {
        {
#line 561
        p = (char const   *)elem_str;
#line 565
        tmp = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*", & elem->field_name);
        }
#line 565
        if (! tmp) {
          {
#line 570
          free((void *)elem);
#line 571
          res = (_Bool)0;
          }
#line 572
          goto while_break;
        }
#line 578
        if ((int const   )*p == 46) {
          {
#line 580
          subname = (char *)((void *)0);
#line 582
          p ++;
#line 583
          tmp___0 = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*", & subname);
          }
#line 583
          if (! tmp___0) {
            {
#line 588
            free((void *)elem->field_name);
#line 589
            free((void *)elem);
#line 590
            res = (_Bool)0;
            }
#line 591
            goto while_break;
          }
          {
#line 595
          elem->field_name = rec_concat_strings((char const   *)elem->field_name,
                                                "_", (char const   *)subname);
          }
        }
#line 601
        if ((int const   )*p != 0) {
          {
#line 603
          free((void *)elem->field_name);
#line 604
          free((void *)elem);
#line 605
          res = (_Bool)0;
          }
#line 606
          goto while_break;
        }
        {
#line 611
        elem->function_name = (char *)((void *)0);
#line 612
        elem->function_data = (void *)0;
#line 613
        elem->rewrite_to = (char *)((void *)0);
#line 614
        elem->str = strdup((char const   *)elem_str);
#line 615
        elem->min = -1;
#line 616
        elem->max = -1;
#line 617
        tmp___1 = new->num_elems;
#line 617
        (new->num_elems) ++;
#line 617
        new->elems[tmp___1] = elem;
        }
      } else {
#line 621
        res = (_Bool)0;
#line 622
        goto while_break;
      }
    }
    {
#line 555
    elem_str = strsep((char **/* __restrict  */)(& fex_str), (char const   */* __restrict  */)sep);
    }
#line 555
    if (! elem_str) {
#line 555
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 628
  if (new->num_elems == 0) {
#line 631
    res = (_Bool)0;
  }
#line 634
  if (res) {
    {
#line 636
    new->str = strdup(str);
    }
  } else {
#line 641
    i = (size_t )0;
    {
#line 641
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 641
      if (! (i < (size_t )new->num_elems)) {
#line 641
        goto while_break___0;
      }
      {
#line 643
      free((void *)(new->elems[i])->rewrite_to);
#line 644
      free((void *)(new->elems[i])->field_name);
#line 645
      free((void *)(new->elems[i])->str);
#line 646
      free((void *)new->elems[i]);
#line 641
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 650
  free((void *)fex_str_orig);
  }
#line 651
  return (res);
}
}
#line 654 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
static _Bool rec_fex_parse_str_subscripts(rec_fex_t new , char const   *str ) 
{ 
  _Bool res ;
  char *elem_str ;
  char *fex_str ;
  char *fex_str_orig ;
  rec_fex_elem_t elem ;
  int i ;
  void *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 664
  res = (_Bool)1;
#line 666
  fex_str = strdup(str);
  }
#line 667
  if (! fex_str) {
#line 669
    return ((_Bool)0);
  }
  {
#line 671
  fex_str_orig = fex_str;
#line 673
  elem_str = strsep((char **/* __restrict  */)(& fex_str), (char const   */* __restrict  */)",");
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 676
    tmp = malloc(sizeof(struct rec_fex_elem_s ));
#line 676
    elem = (rec_fex_elem_t )tmp;
    }
#line 677
    if (! elem) {
#line 680
      res = (_Bool)0;
#line 681
      goto while_break;
    }
    {
#line 684
    tmp___0 = rec_fex_parse_elem(elem, (char const   *)elem_str);
    }
#line 684
    if (! tmp___0) {
#line 687
      i = 0;
      {
#line 687
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 687
        if (! (i < new->num_elems)) {
#line 687
          goto while_break___0;
        }
        {
#line 689
        free((void *)(new->elems[i])->field_name);
#line 690
        free((void *)(new->elems[i])->str);
#line 691
        free((void *)new->elems[i]);
#line 687
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 694
      free((void *)elem);
#line 695
      res = (_Bool)0;
      }
#line 696
      goto while_break;
    }
    {
#line 700
    tmp___1 = new->num_elems;
#line 700
    (new->num_elems) ++;
#line 700
    new->elems[tmp___1] = elem;
#line 674
    elem_str = strsep((char **/* __restrict  */)(& fex_str), (char const   */* __restrict  */)",");
    }
#line 674
    if (! elem_str) {
#line 674
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  if (res) {
    {
#line 706
    new->str = strdup(str);
    }
  }
  {
#line 709
  free((void *)fex_str_orig);
  }
#line 710
  return (res);
}
}
#line 713 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-fex.c"
static _Bool rec_fex_parse_elem(rec_fex_elem_t elem , char const   *str ) 
{ 
  _Bool ret ;
  char const   *p ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char *subname ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 720
  ret = (_Bool)1;
#line 721
  p = str;
#line 724
  elem->field_name = (char *)((void *)0);
#line 725
  elem->function_name = (char *)((void *)0);
#line 726
  elem->function_data = (void *)0;
#line 727
  elem->str = (char *)((void *)0);
#line 728
  elem->rewrite_to = (char *)((void *)0);
#line 729
  elem->min = -1;
#line 730
  elem->max = -1;
#line 734
  elem->str = strdup(str);
#line 739
  tmp___0 = rec_match(p, "^[a-zA-Z_][a-zA-Z0-9_]*\\([a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?\\)");
  }
#line 739
  if (tmp___0) {
    {
#line 744
    tmp = rec_parse_regexp(& p, "^[a-zA-Z_][a-zA-Z0-9_]*", & elem->function_name);
    }
#line 744
    if (! tmp) {
      {
#line 749
      free((void *)elem->str);
      }
#line 750
      return ((_Bool)0);
    }
#line 753
    p ++;
  }
  {
#line 758
  tmp___1 = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*", & elem->field_name);
  }
#line 758
  if (! tmp___1) {
    {
#line 763
    free((void *)elem->str);
    }
#line 764
    return ((_Bool)0);
  }
#line 770
  if ((int const   )*p == 46) {
    {
#line 772
    subname = (char *)((void *)0);
#line 774
    p ++;
#line 775
    tmp___2 = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*", & subname);
    }
#line 775
    if (! tmp___2) {
      {
#line 780
      free((void *)elem->str);
      }
#line 781
      return ((_Bool)0);
    }
    {
#line 785
    elem->field_name = rec_concat_strings((char const   *)elem->field_name, "_", (char const   *)subname);
    }
  }
#line 789
  if ((int const   )*p == 91) {
    {
#line 791
    p ++;
#line 793
    tmp___3 = rec_parse_int(& p, & elem->min);
    }
#line 793
    if (! tmp___3) {
      {
#line 796
      free((void *)elem->str);
#line 797
      free((void *)elem->field_name);
      }
#line 798
      return ((_Bool)0);
    }
#line 801
    if ((int const   )*p == 45) {
      {
#line 803
      p ++;
#line 805
      tmp___4 = rec_parse_int(& p, & elem->max);
      }
#line 805
      if (! tmp___4) {
        {
#line 808
        free((void *)elem->str);
#line 809
        free((void *)elem->field_name);
        }
#line 810
        return ((_Bool)0);
      }
    }
#line 814
    if ((int const   )*p != 93) {
      {
#line 817
      free((void *)elem->str);
#line 818
      free((void *)elem->field_name);
      }
#line 819
      return ((_Bool)0);
    }
#line 821
    p ++;
  }
#line 824
  if (elem->function_name) {
#line 826
    p ++;
  }
#line 830
  if ((int const   )*p == 58) {
    {
#line 832
    p ++;
#line 833
    tmp___5 = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*", & elem->rewrite_to);
    }
#line 833
    if (! tmp___5) {
      {
#line 838
      free((void *)elem->str);
#line 839
      free((void *)elem->field_name);
      }
#line 840
      return ((_Bool)0);
    }
  }
#line 844
  if ((int const   )*p != 0) {
    {
#line 846
    free((void *)elem->str);
#line 847
    free((void *)elem->field_name);
#line 848
    free((void *)elem->rewrite_to);
    }
#line 849
    return ((_Bool)0);
  }
#line 852
  return (ret);
}
}
#line 199 "./rec.h"
rec_mset_elem_t rec_mset_append(rec_mset_t mset , rec_mset_type_t elem_type , void *data ,
                                rec_mset_type_t type ) ;
#line 736
rec_field_t rec_field_dup(rec_field_t field ) ;
#line 869
void rec_record_destroy(rec_record_t record ) ;
#line 876
rec_record_t rec_record_dup(rec_record_t record ) ;
#line 1002
rec_field_t rec_record_get_field_by_name(rec_record_t record , char const   *field_name ,
                                         size_t n ) ;
#line 1009
void rec_record_remove_field_by_name(rec_record_t record , char const   *field_name ,
                                     size_t n ) ;
#line 1047
void rec_record_reset_marks(rec_record_t record ) ;
#line 1053
_Bool rec_record_mark_field(rec_record_t record , rec_field_t field , int mark ) ;
#line 1058
int rec_record_field_mark(rec_record_t record , rec_field_t field ) ;
#line 2102
rec_sex_t rec_sex_new(_Bool case_insensitive ) ;
#line 2106
void rec_sex_destroy(rec_sex_t sex ) ;
#line 2113
_Bool rec_sex_compile(rec_sex_t sex , char const   *expr ) ;
#line 2119
_Bool rec_sex_eval(rec_sex_t sex , rec_record_t record , _Bool *status ) ;
#line 2124
char *rec_sex_eval_str(rec_sex_t sex , rec_record_t record ) ;
#line 2131
void rec_sex_print_ast(rec_sex_t sex ) ;
#line 70 "./rec-utils.h"
_Bool rec_match_insensitive(char const   *str , char const   *reg ) ;
#line 80 "./rec-sex-ast.h"
void rec_sex_ast_destroy(rec_sex_ast_t ast ) ;
#line 85
rec_sex_ast_node_t rec_sex_ast_top(rec_sex_ast_t ast ) ;
#line 92
enum rec_sex_ast_node_type_e rec_sex_ast_node_type(rec_sex_ast_node_t node ) ;
#line 96
int rec_sex_ast_node_int(rec_sex_ast_node_t node ) ;
#line 98
double rec_sex_ast_node_real(rec_sex_ast_node_t node ) ;
#line 100
char *rec_sex_ast_node_str(rec_sex_ast_node_t node ) ;
#line 102
char const   *rec_sex_ast_node_name(rec_sex_ast_node_t node ) ;
#line 103
char const   *rec_sex_ast_node_subname(rec_sex_ast_node_t node ) ;
#line 108
rec_sex_ast_node_t rec_sex_ast_node_child(rec_sex_ast_node_t node , int n ) ;
#line 115
int rec_sex_ast_node_index(rec_sex_ast_node_t node ) ;
#line 121
void rec_sex_ast_node_fix(rec_sex_ast_node_t node , char *val ) ;
#line 122
void rec_sex_ast_node_unfix(rec_sex_ast_node_t node ) ;
#line 123
_Bool rec_sex_ast_node_fixed(rec_sex_ast_node_t node ) ;
#line 124
char *rec_sex_ast_node_fixed_val(rec_sex_ast_node_t node ) ;
#line 128
_Bool rec_sex_ast_name_p(rec_sex_ast_t ast , char const   *name , size_t idx ) ;
#line 133
_Bool rec_sex_ast_hash_name_p(rec_sex_ast_t ast , char const   *name ) ;
#line 43 "./rec-sex-parser.h"
rec_sex_parser_t rec_sex_parser_new(void) ;
#line 44
void rec_sex_parser_destroy(rec_sex_parser_t parser ) ;
#line 46
_Bool rec_sex_parser_case_insensitive(rec_sex_parser_t parser ) ;
#line 47
void rec_sex_parser_set_case_insensitive(rec_sex_parser_t parser , _Bool case_insensitive ) ;
#line 52
rec_sex_ast_t rec_sex_parser_ast(rec_sex_parser_t parser ) ;
#line 54
_Bool rec_sex_parser_run(rec_sex_parser_t parser , char const   *expr ) ;
#line 57
void rec_sex_parser_print_ast(rec_sex_parser_t parser ) ;
#line 64 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
static struct rec_sex_val_s rec_sex_eval_node(rec_sex_t sex , rec_record_t record ,
                                              rec_sex_ast_node_t node , _Bool *status ) ;
#line 68
static _Bool rec_sex_op_real_p(struct rec_sex_val_s op1 , struct rec_sex_val_s op2 ) ;
#line 75 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
rec_sex_t rec_sex_new(_Bool case_insensitive ) 
{ 
  rec_sex_t new ;
  void *tmp ;

  {
  {
#line 80
  tmp = malloc(sizeof(struct rec_sex_s ));
#line 80
  new = (rec_sex_t )tmp;
  }
#line 81
  if (new) {
    {
#line 84
    new->parser = rec_sex_parser_new();
#line 85
    rec_sex_parser_set_case_insensitive(new->parser, case_insensitive);
#line 89
    new->ast = (rec_sex_ast_t )((void *)0);
    }
  }
#line 92
  return (new);
}
}
#line 95 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
void rec_sex_destroy(rec_sex_t sex ) 
{ 


  {
#line 98
  if (sex) {
#line 100
    if (sex->parser) {
      {
#line 102
      rec_sex_parser_destroy(sex->parser);
      }
    }
#line 105
    if (sex->ast) {
      {
#line 107
      rec_sex_ast_destroy(sex->ast);
      }
    }
    {
#line 110
    free((void *)sex);
    }
  }
#line 112
  return;
}
}
#line 114 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
_Bool rec_sex_compile(rec_sex_t sex , char const   *expr ) 
{ 
  _Bool res ;

  {
  {
#line 120
  res = rec_sex_parser_run(sex->parser, expr);
  }
#line 121
  if (res) {
    {
#line 123
    sex->ast = rec_sex_parser_ast(sex->parser);
    }
  }
#line 125
  return (res);
}
}
#line 153 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
char *rec_sex_eval_str(rec_sex_t sex , rec_record_t record ) 
{ 
  char *res ;
  struct rec_sex_val_s val ;
  _Bool status ;
  rec_sex_ast_node_t tmp ;
  rec_sex_ast_node_t tmp___0 ;

  {
  {
#line 161
  tmp = rec_sex_ast_top(sex->ast);
#line 161
  rec_sex_ast_node_unfix(tmp);
#line 162
  tmp___0 = rec_sex_ast_top(sex->ast);
#line 162
  val = rec_sex_eval_node(sex, record, tmp___0, & status);
  }
#line 167
  if (! status) {
#line 170
    return ((char *)((void *)0));
  }
#line 173
  res = (char *)((void *)0);
  {
#line 176
  if (val.type == 0) {
#line 176
    goto case_0;
  }
#line 181
  if (val.type == 1) {
#line 181
    goto case_1;
  }
#line 186
  if (val.type == 2) {
#line 186
    goto case_2;
  }
#line 174
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 178
  asprintf((char **/* __restrict  */)(& res), (char const   */* __restrict  */)"%d",
           val.int_val);
  }
#line 179
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 183
  asprintf((char **/* __restrict  */)(& res), (char const   */* __restrict  */)"%f",
           val.real_val);
  }
#line 184
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 188
  res = strdup((char const   *)val.str_val);
  }
#line 189
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 193
  return (res);
}
}
#line 196 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
_Bool rec_sex_eval(rec_sex_t sex , rec_record_t record , _Bool *status ) 
{ 
  _Bool res ;
  rec_field_t field ;
  rec_field_t wfield ;
  rec_record_t wrec ;
  rec_mset_iterator_t iter ;
  int j ;
  int nf ;
  struct rec_sex_val_s val ;
  rec_sex_ast_node_t tmp ;
  rec_sex_ast_node_t tmp___0 ;
  rec_mset_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  rec_field_t tmp___6 ;
  rec_mset_t tmp___7 ;
  rec_sex_ast_node_t tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  _Bool tmp___11 ;
  char const   *tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;

  {
  {
#line 209
  res = (_Bool)0;
#line 210
  wrec = (rec_record_t )((void *)0);
#line 212
  tmp = rec_sex_ast_top(sex->ast);
#line 212
  rec_sex_ast_node_unfix(tmp);
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp___0 = rec_sex_ast_top(sex->ast);
#line 213
    val = rec_sex_eval_node(sex, record, tmp___0, status);
    }
    {
#line 213
    if (val.type == 0) {
#line 213
      goto case_0;
    }
#line 213
    if (val.type == 2) {
#line 213
      goto case_2;
    }
#line 213
    if (val.type == 1) {
#line 213
      goto case_2;
    }
#line 213
    goto switch_break;
    case_0: /* CIL Label */ 
#line 213
    res = (_Bool )(val.int_val != 0);
#line 213
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 213
    res = (_Bool)0;
#line 213
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 213
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  if (res) {
#line 216
    goto exit;
  }
  {
#line 219
  rec_record_reset_marks(record);
#line 221
  tmp___1 = rec_record_mset(record);
#line 221
  iter = rec_mset_iterator(tmp___1);
  }
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 222
    tmp___14 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 222
    if (! tmp___14) {
#line 222
      goto while_break___0;
    }
    {
#line 224
    tmp___2 = rec_field_name(field);
#line 224
    tmp___3 = rec_record_get_num_fields_by_name(record, tmp___2);
#line 224
    nf = (int )tmp___3;
    }
#line 225
    if (nf > 1) {
      {
#line 225
      tmp___9 = rec_record_field_mark(record, field);
      }
#line 225
      if (tmp___9 == 0) {
        {
#line 225
        tmp___10 = rec_field_name(field);
#line 225
        tmp___11 = rec_sex_ast_name_p(sex->ast, tmp___10, (size_t )nf);
        }
#line 225
        if (tmp___11) {
          {
#line 225
          tmp___12 = rec_field_name(field);
#line 225
          tmp___13 = rec_sex_ast_hash_name_p(sex->ast, tmp___12);
          }
#line 225
          if (! tmp___13) {
#line 230
            j = 0;
            {
#line 230
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 230
              if (! (j < nf)) {
#line 230
                goto while_break___1;
              }
              {
#line 232
              tmp___4 = rec_field_name(field);
#line 232
              wfield = rec_record_get_field_by_name(record, tmp___4, (size_t )j);
              }
#line 235
              if (wrec) {
                {
#line 237
                rec_record_destroy(wrec);
                }
              }
              {
#line 240
              rec_record_mark_field(record, wfield, 1);
#line 242
              wrec = rec_record_dup(record);
#line 243
              tmp___5 = rec_field_name(field);
#line 243
              rec_record_remove_field_by_name(wrec, tmp___5, (size_t )-1);
#line 246
              tmp___6 = rec_field_dup(wfield);
#line 246
              tmp___7 = rec_record_mset(wrec);
#line 246
              rec_mset_append(tmp___7, 1, (void *)tmp___6, 0);
              }
              {
#line 248
              while (1) {
                while_continue___2: /* CIL Label */ ;
                {
#line 248
                tmp___8 = rec_sex_ast_top(sex->ast);
#line 248
                val = rec_sex_eval_node(sex, wrec, tmp___8, status);
                }
                {
#line 248
                if (val.type == 0) {
#line 248
                  goto case_0___0;
                }
#line 248
                if (val.type == 2) {
#line 248
                  goto case_2___0;
                }
#line 248
                if (val.type == 1) {
#line 248
                  goto case_2___0;
                }
#line 248
                goto switch_break___0;
                case_0___0: /* CIL Label */ 
#line 248
                res = (_Bool )(val.int_val != 0);
#line 248
                goto switch_break___0;
                case_2___0: /* CIL Label */ 
                case_1___0: /* CIL Label */ 
#line 248
                res = (_Bool)0;
#line 248
                goto switch_break___0;
                switch_break___0: /* CIL Label */ ;
                }
#line 248
                goto while_break___2;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 250
              if (res) {
                {
#line 252
                rec_record_destroy(wrec);
                }
#line 253
                goto exit;
              }
#line 230
              j ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 259
  rec_mset_iterator_free(& iter);
  }
  exit: 
#line 263
  if (! *status) {
#line 265
    res = (_Bool)0;
  }
#line 268
  return (res);
}
}
#line 271 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
void rec_sex_print_ast(rec_sex_t sex ) 
{ 


  {
  {
#line 274
  rec_sex_parser_print_ast(sex->parser);
  }
#line 275
  return;
}
}
#line 392 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
static struct rec_sex_val_s rec_sex_eval_node(rec_sex_t sex , rec_record_t record ,
                                              rec_sex_ast_node_t node , _Bool *status ) 
{ 
  struct rec_sex_val_s res ;
  struct rec_sex_val_s child_val1 ;
  struct rec_sex_val_s child_val2 ;
  struct rec_sex_val_s child_val3 ;
  enum rec_sex_ast_node_type_e tmp ;
  int op1 ;
  int op2 ;
  double op1_real ;
  double op2_real ;
  rec_sex_ast_node_t tmp___0 ;
  rec_sex_ast_node_t tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;
  int op1___0 ;
  int op2___0 ;
  double op1_real___0 ;
  double op2_real___0 ;
  rec_sex_ast_node_t tmp___11 ;
  rec_sex_ast_node_t tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  _Bool tmp___21 ;
  int op1___1 ;
  int op2___1 ;
  double op1_real___1 ;
  double op2_real___1 ;
  rec_sex_ast_node_t tmp___22 ;
  rec_sex_ast_node_t tmp___23 ;
  _Bool tmp___24 ;
  int tmp___25 ;
  _Bool tmp___26 ;
  int tmp___27 ;
  _Bool tmp___28 ;
  int tmp___29 ;
  _Bool tmp___30 ;
  int tmp___31 ;
  _Bool tmp___32 ;
  int op1___2 ;
  int op2___2 ;
  double op1_real___2 ;
  double op2_real___2 ;
  rec_sex_ast_node_t tmp___33 ;
  rec_sex_ast_node_t tmp___34 ;
  _Bool tmp___35 ;
  int tmp___36 ;
  _Bool tmp___37 ;
  int tmp___38 ;
  _Bool tmp___39 ;
  int tmp___40 ;
  _Bool tmp___41 ;
  int tmp___42 ;
  _Bool tmp___43 ;
  int op1___3 ;
  int op2___3 ;
  rec_sex_ast_node_t tmp___44 ;
  rec_sex_ast_node_t tmp___45 ;
  _Bool tmp___46 ;
  int tmp___47 ;
  _Bool tmp___48 ;
  int tmp___49 ;
  int op1___4 ;
  int op2___4 ;
  double op1_real___3 ;
  double op2_real___3 ;
  rec_sex_ast_node_t tmp___50 ;
  rec_sex_ast_node_t tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  _Bool tmp___54 ;
  _Bool tmp___55 ;
  int tmp___56 ;
  _Bool tmp___57 ;
  int tmp___58 ;
  _Bool tmp___59 ;
  int tmp___60 ;
  _Bool tmp___61 ;
  int tmp___62 ;
  _Bool tmp___63 ;
  int op1___5 ;
  int op2___5 ;
  double op1_real___4 ;
  double op2_real___4 ;
  rec_sex_ast_node_t tmp___64 ;
  rec_sex_ast_node_t tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  _Bool tmp___68 ;
  _Bool tmp___69 ;
  int tmp___70 ;
  _Bool tmp___71 ;
  int tmp___72 ;
  _Bool tmp___73 ;
  int tmp___74 ;
  _Bool tmp___75 ;
  int tmp___76 ;
  _Bool tmp___77 ;
  rec_sex_ast_node_t tmp___78 ;
  rec_sex_ast_node_t tmp___79 ;
  _Bool tmp___80 ;
  _Bool tmp___81 ;
  _Bool tmp___82 ;
  struct timespec op1___6 ;
  struct timespec op2___6 ;
  struct timespec diff ;
  rec_sex_ast_node_t tmp___83 ;
  rec_sex_ast_node_t tmp___84 ;
  _Bool tmp___85 ;
  _Bool tmp___86 ;
  struct timespec op1___7 ;
  struct timespec op2___7 ;
  struct timespec diff___0 ;
  rec_sex_ast_node_t tmp___87 ;
  rec_sex_ast_node_t tmp___88 ;
  _Bool tmp___89 ;
  _Bool tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  struct timespec op1___8 ;
  struct timespec op2___8 ;
  struct timespec diff___1 ;
  rec_sex_ast_node_t tmp___93 ;
  rec_sex_ast_node_t tmp___94 ;
  _Bool tmp___95 ;
  _Bool tmp___96 ;
  int tmp___97 ;
  int op1___9 ;
  int op2___9 ;
  rec_sex_ast_node_t tmp___98 ;
  rec_sex_ast_node_t tmp___99 ;
  _Bool tmp___100 ;
  int tmp___101 ;
  _Bool tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int op1___10 ;
  int op2___10 ;
  double op1_real___5 ;
  double op2_real___5 ;
  rec_sex_ast_node_t tmp___105 ;
  rec_sex_ast_node_t tmp___106 ;
  _Bool tmp___107 ;
  int tmp___108 ;
  _Bool tmp___109 ;
  int tmp___110 ;
  enum rec_sex_ast_node_type_e tmp___111 ;
  _Bool tmp___112 ;
  int tmp___113 ;
  _Bool tmp___114 ;
  int tmp___115 ;
  enum rec_sex_ast_node_type_e tmp___116 ;
  _Bool tmp___117 ;
  int op1___11 ;
  int op2___11 ;
  double op1_real___6 ;
  double op2_real___6 ;
  rec_sex_ast_node_t tmp___118 ;
  rec_sex_ast_node_t tmp___119 ;
  _Bool tmp___120 ;
  int tmp___121 ;
  _Bool tmp___122 ;
  int tmp___123 ;
  enum rec_sex_ast_node_type_e tmp___124 ;
  _Bool tmp___125 ;
  int tmp___126 ;
  _Bool tmp___127 ;
  int tmp___128 ;
  enum rec_sex_ast_node_type_e tmp___129 ;
  _Bool tmp___130 ;
  int op1___12 ;
  int op2___12 ;
  rec_sex_ast_node_t tmp___131 ;
  rec_sex_ast_node_t tmp___132 ;
  _Bool tmp___133 ;
  int tmp___134 ;
  _Bool tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int op1___13 ;
  int op2___13 ;
  rec_sex_ast_node_t tmp___138 ;
  rec_sex_ast_node_t tmp___139 ;
  _Bool tmp___140 ;
  int tmp___141 ;
  _Bool tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  size_t str1_size ;
  size_t str2_size ;
  rec_sex_ast_node_t tmp___145 ;
  rec_sex_ast_node_t tmp___146 ;
  void *tmp___147 ;
  int op ;
  rec_sex_ast_node_t tmp___148 ;
  _Bool tmp___149 ;
  int tmp___150 ;
  int n ;
  char const   *field_name ;
  char const   *field_subname ;
  rec_sex_ast_node_t child ;
  rec_sex_ast_node_t tmp___151 ;
  enum rec_sex_ast_node_type_e tmp___152 ;
  char *effective_name ;
  char *tmp___153 ;
  size_t tmp___154 ;
  size_t tmp___155 ;
  int op1___14 ;
  rec_sex_ast_node_t tmp___156 ;
  rec_sex_ast_node_t tmp___157 ;
  rec_sex_ast_node_t tmp___158 ;
  _Bool tmp___159 ;
  int tmp___160 ;
  rec_field_t field ;
  char const   *field_name___0 ;
  char const   *field_subname___0 ;
  int index___0 ;
  _Bool tofix ;
  char *effective_field_name ;
  size_t tmp___161 ;
  size_t tmp___162 ;
  void *tmp___163 ;
  size_t tmp___164 ;
  size_t tmp___165 ;
  size_t tmp___166 ;
  size_t tmp___167 ;
  char const   *tmp___168 ;
  _Bool tmp___169 ;

  {
  {
#line 398
  res.type = 0;
#line 398
  res.int_val = 0;
#line 398
  res.real_val = (double )0;
#line 398
  res.str_val = (char *)((void *)0);
#line 399
  child_val1.type = 0;
#line 399
  child_val1.int_val = 0;
#line 399
  child_val1.real_val = (double )0;
#line 399
  child_val1.str_val = (char *)((void *)0);
#line 400
  child_val2.type = 0;
#line 400
  child_val2.int_val = 0;
#line 400
  child_val2.real_val = (double )0;
#line 400
  child_val2.str_val = (char *)((void *)0);
#line 401
  child_val3.type = 0;
#line 401
  child_val3.int_val = 0;
#line 401
  child_val3.real_val = (double )0;
#line 401
  child_val3.str_val = (char *)((void *)0);
#line 403
  *status = (_Bool)1;
#line 405
  tmp = rec_sex_ast_node_type(node);
  }
  {
#line 407
  if ((unsigned int )tmp == 0U) {
#line 407
    goto case_0;
  }
#line 415
  if ((unsigned int )tmp == 2U) {
#line 415
    goto case_2;
  }
#line 415
  if ((unsigned int )tmp == 1U) {
#line 415
    goto case_2;
  }
#line 446
  if ((unsigned int )tmp == 3U) {
#line 446
    goto case_3;
  }
#line 478
  if ((unsigned int )tmp == 4U) {
#line 478
    goto case_4;
  }
#line 509
  if ((unsigned int )tmp == 5U) {
#line 509
    goto case_5;
  }
#line 550
  if ((unsigned int )tmp == 6U) {
#line 550
    goto case_6;
  }
#line 577
  if ((unsigned int )tmp == 7U) {
#line 577
    goto case_7;
  }
#line 628
  if ((unsigned int )tmp == 8U) {
#line 628
    goto case_8;
  }
#line 679
  if ((unsigned int )tmp == 9U) {
#line 679
    goto case_9;
  }
#line 710
  if ((unsigned int )tmp == 20U) {
#line 710
    goto case_20;
  }
#line 726
  if ((unsigned int )tmp == 21U) {
#line 726
    goto case_21;
  }
#line 743
  if ((unsigned int )tmp == 18U) {
#line 743
    goto case_18;
  }
#line 761
  if ((unsigned int )tmp == 19U) {
#line 761
    goto case_19;
  }
#line 778
  if ((unsigned int )tmp == 12U) {
#line 778
    goto case_12;
  }
#line 778
  if ((unsigned int )tmp == 10U) {
#line 778
    goto case_12;
  }
#line 826
  if ((unsigned int )tmp == 13U) {
#line 826
    goto case_13;
  }
#line 826
  if ((unsigned int )tmp == 11U) {
#line 826
    goto case_13;
  }
#line 873
  if ((unsigned int )tmp == 14U) {
#line 873
    goto case_14;
  }
#line 889
  if ((unsigned int )tmp == 15U) {
#line 889
    goto case_15;
  }
#line 905
  if ((unsigned int )tmp == 23U) {
#line 905
    goto case_23;
  }
#line 933
  if ((unsigned int )tmp == 16U) {
#line 933
    goto case_16;
  }
#line 945
  if ((unsigned int )tmp == 17U) {
#line 945
    goto case_17;
  }
#line 985
  if ((unsigned int )tmp == 22U) {
#line 985
    goto case_22;
  }
#line 1010
  if ((unsigned int )tmp == 24U) {
#line 1010
    goto case_24;
  }
#line 1016
  if ((unsigned int )tmp == 25U) {
#line 1016
    goto case_25;
  }
#line 1022
  if ((unsigned int )tmp == 26U) {
#line 1022
    goto case_26;
  }
#line 1028
  if ((unsigned int )tmp == 27U) {
#line 1028
    goto case_27;
  }
#line 405
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 409
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Application bug: REC_SEX_NOVAL node found.\nPlease report this!\n");
#line 410
  exit(1);
  }
#line 411
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 422
    tmp___0 = rec_sex_ast_node_child(node, 0);
#line 422
    child_val1 = rec_sex_eval_node(sex, record, tmp___0, status);
    }
#line 422
    if (! *status) {
#line 422
      return (res);
    }
#line 422
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 423
    tmp___1 = rec_sex_ast_node_child(node, 1);
#line 423
    child_val2 = rec_sex_eval_node(sex, record, tmp___1, status);
    }
#line 423
    if (! *status) {
#line 423
      return (res);
    }
#line 423
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 425
  tmp___10 = rec_sex_op_real_p(child_val1, child_val2);
  }
#line 425
  if (tmp___10) {
    {
#line 428
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 428
      if (child_val1.type == 1) {
#line 428
        goto case_1___0;
      }
#line 428
      if (child_val1.type == 0) {
#line 428
        goto case_0___0;
      }
#line 428
      if (child_val1.type == 2) {
#line 428
        goto case_2___0;
      }
#line 428
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 428
      op1_real = child_val1.real_val;
#line 428
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 428
      op1_real = (double )child_val1.int_val;
#line 428
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 428
      tmp___3 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 428
      if (tmp___3 == 0) {
#line 428
        op1_real = 0.0;
      } else {
        {
#line 428
        tmp___2 = rec_atod((char const   *)child_val1.str_val, & op1_real);
        }
#line 428
        if (! tmp___2) {
#line 428
          *status = (_Bool)0;
#line 428
          return (res);
        }
      }
#line 428
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 428
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 429
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 429
      if (child_val2.type == 1) {
#line 429
        goto case_1___1;
      }
#line 429
      if (child_val2.type == 0) {
#line 429
        goto case_0___1;
      }
#line 429
      if (child_val2.type == 2) {
#line 429
        goto case_2___1;
      }
#line 429
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
#line 429
      op2_real = child_val2.real_val;
#line 429
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
#line 429
      op2_real = (double )child_val2.int_val;
#line 429
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 429
      tmp___5 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 429
      if (tmp___5 == 0) {
#line 429
        op2_real = 0.0;
      } else {
        {
#line 429
        tmp___4 = rec_atod((char const   *)child_val2.str_val, & op2_real);
        }
#line 429
        if (! tmp___4) {
#line 429
          *status = (_Bool)0;
#line 429
          return (res);
        }
      }
#line 429
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 429
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 431
    res.type = 1;
#line 432
    res.real_val = op1_real + op2_real;
  } else {
    {
#line 437
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 437
      if (child_val1.type == 0) {
#line 437
        goto case_0___2;
      }
#line 437
      if (child_val1.type == 2) {
#line 437
        goto case_2___2;
      }
#line 437
      goto switch_break___2;
      case_0___2: /* CIL Label */ 
#line 437
      op1 = child_val1.int_val;
#line 437
      goto switch_break___2;
      case_2___2: /* CIL Label */ 
      {
#line 437
      tmp___7 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 437
      if (tmp___7 == 0) {
#line 437
        op1 = 0;
      } else {
        {
#line 437
        tmp___6 = rec_atoi((char const   *)child_val1.str_val, & op1);
        }
#line 437
        if (! tmp___6) {
#line 437
          *status = (_Bool)0;
#line 437
          return (res);
        }
      }
#line 437
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 437
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 438
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 438
      if (child_val2.type == 0) {
#line 438
        goto case_0___3;
      }
#line 438
      if (child_val2.type == 2) {
#line 438
        goto case_2___3;
      }
#line 438
      goto switch_break___3;
      case_0___3: /* CIL Label */ 
#line 438
      op2 = child_val2.int_val;
#line 438
      goto switch_break___3;
      case_2___3: /* CIL Label */ 
      {
#line 438
      tmp___9 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 438
      if (tmp___9 == 0) {
#line 438
        op2 = 0;
      } else {
        {
#line 438
        tmp___8 = rec_atoi((char const   *)child_val2.str_val, & op2);
        }
#line 438
        if (! tmp___8) {
#line 438
          *status = (_Bool)0;
#line 438
          return (res);
        }
      }
#line 438
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
#line 438
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 440
    res.type = 0;
#line 441
    res.int_val = op1 + op2;
  }
#line 444
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 453
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 453
    tmp___11 = rec_sex_ast_node_child(node, 0);
#line 453
    child_val1 = rec_sex_eval_node(sex, record, tmp___11, status);
    }
#line 453
    if (! *status) {
#line 453
      return (res);
    }
#line 453
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 454
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 454
    tmp___12 = rec_sex_ast_node_child(node, 1);
#line 454
    child_val2 = rec_sex_eval_node(sex, record, tmp___12, status);
    }
#line 454
    if (! *status) {
#line 454
      return (res);
    }
#line 454
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 456
  tmp___21 = rec_sex_op_real_p(child_val1, child_val2);
  }
#line 456
  if (tmp___21) {
    {
#line 459
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 459
      if (child_val1.type == 1) {
#line 459
        goto case_1___2;
      }
#line 459
      if (child_val1.type == 0) {
#line 459
        goto case_0___4;
      }
#line 459
      if (child_val1.type == 2) {
#line 459
        goto case_2___4;
      }
#line 459
      goto switch_break___4;
      case_1___2: /* CIL Label */ 
#line 459
      op1_real___0 = child_val1.real_val;
#line 459
      goto switch_break___4;
      case_0___4: /* CIL Label */ 
#line 459
      op1_real___0 = (double )child_val1.int_val;
#line 459
      goto switch_break___4;
      case_2___4: /* CIL Label */ 
      {
#line 459
      tmp___14 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 459
      if (tmp___14 == 0) {
#line 459
        op1_real___0 = 0.0;
      } else {
        {
#line 459
        tmp___13 = rec_atod((char const   *)child_val1.str_val, & op1_real___0);
        }
#line 459
        if (! tmp___13) {
#line 459
          *status = (_Bool)0;
#line 459
          return (res);
        }
      }
#line 459
      goto switch_break___4;
      switch_break___4: /* CIL Label */ ;
      }
#line 459
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 460
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 460
      if (child_val2.type == 1) {
#line 460
        goto case_1___3;
      }
#line 460
      if (child_val2.type == 0) {
#line 460
        goto case_0___5;
      }
#line 460
      if (child_val2.type == 2) {
#line 460
        goto case_2___5;
      }
#line 460
      goto switch_break___5;
      case_1___3: /* CIL Label */ 
#line 460
      op2_real___0 = child_val2.real_val;
#line 460
      goto switch_break___5;
      case_0___5: /* CIL Label */ 
#line 460
      op2_real___0 = (double )child_val2.int_val;
#line 460
      goto switch_break___5;
      case_2___5: /* CIL Label */ 
      {
#line 460
      tmp___16 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 460
      if (tmp___16 == 0) {
#line 460
        op2_real___0 = 0.0;
      } else {
        {
#line 460
        tmp___15 = rec_atod((char const   *)child_val2.str_val, & op2_real___0);
        }
#line 460
        if (! tmp___15) {
#line 460
          *status = (_Bool)0;
#line 460
          return (res);
        }
      }
#line 460
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
#line 460
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 462
    res.type = 1;
#line 463
    res.real_val = (double )(op1___0 - op2___0);
  } else {
    {
#line 469
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 469
      if (child_val1.type == 0) {
#line 469
        goto case_0___6;
      }
#line 469
      if (child_val1.type == 2) {
#line 469
        goto case_2___6;
      }
#line 469
      goto switch_break___6;
      case_0___6: /* CIL Label */ 
#line 469
      op1___0 = child_val1.int_val;
#line 469
      goto switch_break___6;
      case_2___6: /* CIL Label */ 
      {
#line 469
      tmp___18 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 469
      if (tmp___18 == 0) {
#line 469
        op1___0 = 0;
      } else {
        {
#line 469
        tmp___17 = rec_atoi((char const   *)child_val1.str_val, & op1___0);
        }
#line 469
        if (! tmp___17) {
#line 469
          *status = (_Bool)0;
#line 469
          return (res);
        }
      }
#line 469
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
#line 469
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 470
    while (1) {
      while_continue___10: /* CIL Label */ ;
      {
#line 470
      if (child_val2.type == 0) {
#line 470
        goto case_0___7;
      }
#line 470
      if (child_val2.type == 2) {
#line 470
        goto case_2___7;
      }
#line 470
      goto switch_break___7;
      case_0___7: /* CIL Label */ 
#line 470
      op2___0 = child_val2.int_val;
#line 470
      goto switch_break___7;
      case_2___7: /* CIL Label */ 
      {
#line 470
      tmp___20 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 470
      if (tmp___20 == 0) {
#line 470
        op2___0 = 0;
      } else {
        {
#line 470
        tmp___19 = rec_atoi((char const   *)child_val2.str_val, & op2___0);
        }
#line 470
        if (! tmp___19) {
#line 470
          *status = (_Bool)0;
#line 470
          return (res);
        }
      }
#line 470
      goto switch_break___7;
      switch_break___7: /* CIL Label */ ;
      }
#line 470
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 472
    res.type = 0;
#line 473
    res.int_val = op1___0 - op2___0;
  }
#line 476
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 485
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 485
    tmp___22 = rec_sex_ast_node_child(node, 0);
#line 485
    child_val1 = rec_sex_eval_node(sex, record, tmp___22, status);
    }
#line 485
    if (! *status) {
#line 485
      return (res);
    }
#line 485
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 486
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 486
    tmp___23 = rec_sex_ast_node_child(node, 1);
#line 486
    child_val2 = rec_sex_eval_node(sex, record, tmp___23, status);
    }
#line 486
    if (! *status) {
#line 486
      return (res);
    }
#line 486
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
  {
#line 488
  tmp___32 = rec_sex_op_real_p(child_val1, child_val2);
  }
#line 488
  if (tmp___32) {
    {
#line 491
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 491
      if (child_val1.type == 1) {
#line 491
        goto case_1___4;
      }
#line 491
      if (child_val1.type == 0) {
#line 491
        goto case_0___8;
      }
#line 491
      if (child_val1.type == 2) {
#line 491
        goto case_2___8;
      }
#line 491
      goto switch_break___8;
      case_1___4: /* CIL Label */ 
#line 491
      op1_real___1 = child_val1.real_val;
#line 491
      goto switch_break___8;
      case_0___8: /* CIL Label */ 
#line 491
      op1_real___1 = (double )child_val1.int_val;
#line 491
      goto switch_break___8;
      case_2___8: /* CIL Label */ 
      {
#line 491
      tmp___25 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 491
      if (tmp___25 == 0) {
#line 491
        op1_real___1 = 0.0;
      } else {
        {
#line 491
        tmp___24 = rec_atod((char const   *)child_val1.str_val, & op1_real___1);
        }
#line 491
        if (! tmp___24) {
#line 491
          *status = (_Bool)0;
#line 491
          return (res);
        }
      }
#line 491
      goto switch_break___8;
      switch_break___8: /* CIL Label */ ;
      }
#line 491
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 492
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 492
      if (child_val2.type == 1) {
#line 492
        goto case_1___5;
      }
#line 492
      if (child_val2.type == 0) {
#line 492
        goto case_0___9;
      }
#line 492
      if (child_val2.type == 2) {
#line 492
        goto case_2___9;
      }
#line 492
      goto switch_break___9;
      case_1___5: /* CIL Label */ 
#line 492
      op2_real___1 = child_val2.real_val;
#line 492
      goto switch_break___9;
      case_0___9: /* CIL Label */ 
#line 492
      op2_real___1 = (double )child_val2.int_val;
#line 492
      goto switch_break___9;
      case_2___9: /* CIL Label */ 
      {
#line 492
      tmp___27 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 492
      if (tmp___27 == 0) {
#line 492
        op2_real___1 = 0.0;
      } else {
        {
#line 492
        tmp___26 = rec_atod((char const   *)child_val2.str_val, & op2_real___1);
        }
#line 492
        if (! tmp___26) {
#line 492
          *status = (_Bool)0;
#line 492
          return (res);
        }
      }
#line 492
      goto switch_break___9;
      switch_break___9: /* CIL Label */ ;
      }
#line 492
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 494
    res.type = 1;
#line 495
    res.real_val = op1_real___1 * op2_real___1;
  } else {
    {
#line 500
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 500
      if (child_val1.type == 0) {
#line 500
        goto case_0___10;
      }
#line 500
      if (child_val1.type == 2) {
#line 500
        goto case_2___10;
      }
#line 500
      goto switch_break___10;
      case_0___10: /* CIL Label */ 
#line 500
      op1___1 = child_val1.int_val;
#line 500
      goto switch_break___10;
      case_2___10: /* CIL Label */ 
      {
#line 500
      tmp___29 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 500
      if (tmp___29 == 0) {
#line 500
        op1___1 = 0;
      } else {
        {
#line 500
        tmp___28 = rec_atoi((char const   *)child_val1.str_val, & op1___1);
        }
#line 500
        if (! tmp___28) {
#line 500
          *status = (_Bool)0;
#line 500
          return (res);
        }
      }
#line 500
      goto switch_break___10;
      switch_break___10: /* CIL Label */ ;
      }
#line 500
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 501
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 501
      if (child_val2.type == 0) {
#line 501
        goto case_0___11;
      }
#line 501
      if (child_val2.type == 2) {
#line 501
        goto case_2___11;
      }
#line 501
      goto switch_break___11;
      case_0___11: /* CIL Label */ 
#line 501
      op2___1 = child_val2.int_val;
#line 501
      goto switch_break___11;
      case_2___11: /* CIL Label */ 
      {
#line 501
      tmp___31 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 501
      if (tmp___31 == 0) {
#line 501
        op2___1 = 0;
      } else {
        {
#line 501
        tmp___30 = rec_atoi((char const   *)child_val2.str_val, & op2___1);
        }
#line 501
        if (! tmp___30) {
#line 501
          *status = (_Bool)0;
#line 501
          return (res);
        }
      }
#line 501
      goto switch_break___11;
      switch_break___11: /* CIL Label */ ;
      }
#line 501
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 503
    res.type = 0;
#line 504
    res.int_val = op1___1 * op2___1;
  }
#line 507
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 516
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 516
    tmp___33 = rec_sex_ast_node_child(node, 0);
#line 516
    child_val1 = rec_sex_eval_node(sex, record, tmp___33, status);
    }
#line 516
    if (! *status) {
#line 516
      return (res);
    }
#line 516
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 517
  while (1) {
    while_continue___18: /* CIL Label */ ;
    {
#line 517
    tmp___34 = rec_sex_ast_node_child(node, 1);
#line 517
    child_val2 = rec_sex_eval_node(sex, record, tmp___34, status);
    }
#line 517
    if (! *status) {
#line 517
      return (res);
    }
#line 517
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
  {
#line 519
  tmp___43 = rec_sex_op_real_p(child_val1, child_val2);
  }
#line 519
  if (tmp___43) {
    {
#line 522
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 522
      if (child_val1.type == 1) {
#line 522
        goto case_1___6;
      }
#line 522
      if (child_val1.type == 0) {
#line 522
        goto case_0___12;
      }
#line 522
      if (child_val1.type == 2) {
#line 522
        goto case_2___12;
      }
#line 522
      goto switch_break___12;
      case_1___6: /* CIL Label */ 
#line 522
      op1_real___2 = child_val1.real_val;
#line 522
      goto switch_break___12;
      case_0___12: /* CIL Label */ 
#line 522
      op1_real___2 = (double )child_val1.int_val;
#line 522
      goto switch_break___12;
      case_2___12: /* CIL Label */ 
      {
#line 522
      tmp___36 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 522
      if (tmp___36 == 0) {
#line 522
        op1_real___2 = 0.0;
      } else {
        {
#line 522
        tmp___35 = rec_atod((char const   *)child_val1.str_val, & op1_real___2);
        }
#line 522
        if (! tmp___35) {
#line 522
          *status = (_Bool)0;
#line 522
          return (res);
        }
      }
#line 522
      goto switch_break___12;
      switch_break___12: /* CIL Label */ ;
      }
#line 522
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 523
    while (1) {
      while_continue___20: /* CIL Label */ ;
      {
#line 523
      if (child_val2.type == 1) {
#line 523
        goto case_1___7;
      }
#line 523
      if (child_val2.type == 0) {
#line 523
        goto case_0___13;
      }
#line 523
      if (child_val2.type == 2) {
#line 523
        goto case_2___13;
      }
#line 523
      goto switch_break___13;
      case_1___7: /* CIL Label */ 
#line 523
      op2_real___2 = child_val2.real_val;
#line 523
      goto switch_break___13;
      case_0___13: /* CIL Label */ 
#line 523
      op2_real___2 = (double )child_val2.int_val;
#line 523
      goto switch_break___13;
      case_2___13: /* CIL Label */ 
      {
#line 523
      tmp___38 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 523
      if (tmp___38 == 0) {
#line 523
        op2_real___2 = 0.0;
      } else {
        {
#line 523
        tmp___37 = rec_atod((char const   *)child_val2.str_val, & op2_real___2);
        }
#line 523
        if (! tmp___37) {
#line 523
          *status = (_Bool)0;
#line 523
          return (res);
        }
      }
#line 523
      goto switch_break___13;
      switch_break___13: /* CIL Label */ ;
      }
#line 523
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 525
    res.type = 1;
#line 526
    res.real_val = op1_real___2 / op2_real___2;
  } else {
    {
#line 531
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 531
      if (child_val1.type == 0) {
#line 531
        goto case_0___14;
      }
#line 531
      if (child_val1.type == 2) {
#line 531
        goto case_2___14;
      }
#line 531
      goto switch_break___14;
      case_0___14: /* CIL Label */ 
#line 531
      op1___2 = child_val1.int_val;
#line 531
      goto switch_break___14;
      case_2___14: /* CIL Label */ 
      {
#line 531
      tmp___40 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 531
      if (tmp___40 == 0) {
#line 531
        op1___2 = 0;
      } else {
        {
#line 531
        tmp___39 = rec_atoi((char const   *)child_val1.str_val, & op1___2);
        }
#line 531
        if (! tmp___39) {
#line 531
          *status = (_Bool)0;
#line 531
          return (res);
        }
      }
#line 531
      goto switch_break___14;
      switch_break___14: /* CIL Label */ ;
      }
#line 531
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 532
    while (1) {
      while_continue___22: /* CIL Label */ ;
      {
#line 532
      if (child_val2.type == 0) {
#line 532
        goto case_0___15;
      }
#line 532
      if (child_val2.type == 2) {
#line 532
        goto case_2___15;
      }
#line 532
      goto switch_break___15;
      case_0___15: /* CIL Label */ 
#line 532
      op2___2 = child_val2.int_val;
#line 532
      goto switch_break___15;
      case_2___15: /* CIL Label */ 
      {
#line 532
      tmp___42 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 532
      if (tmp___42 == 0) {
#line 532
        op2___2 = 0;
      } else {
        {
#line 532
        tmp___41 = rec_atoi((char const   *)child_val2.str_val, & op2___2);
        }
#line 532
        if (! tmp___41) {
#line 532
          *status = (_Bool)0;
#line 532
          return (res);
        }
      }
#line 532
      goto switch_break___15;
      switch_break___15: /* CIL Label */ ;
      }
#line 532
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 534
    res.type = 0;
#line 536
    if (op2___2 != 0) {
#line 538
      res.int_val = op1___2 / op2___2;
    } else {
#line 543
      *status = (_Bool)0;
#line 544
      return (res);
    }
  }
#line 548
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 555
  while (1) {
    while_continue___23: /* CIL Label */ ;
    {
#line 555
    tmp___44 = rec_sex_ast_node_child(node, 0);
#line 555
    child_val1 = rec_sex_eval_node(sex, record, tmp___44, status);
    }
#line 555
    if (! *status) {
#line 555
      return (res);
    }
#line 555
    goto while_break___23;
  }
  while_break___23: /* CIL Label */ ;
  }
  {
#line 556
  while (1) {
    while_continue___24: /* CIL Label */ ;
    {
#line 556
    tmp___45 = rec_sex_ast_node_child(node, 1);
#line 556
    child_val2 = rec_sex_eval_node(sex, record, tmp___45, status);
    }
#line 556
    if (! *status) {
#line 556
      return (res);
    }
#line 556
    goto while_break___24;
  }
  while_break___24: /* CIL Label */ ;
  }
  {
#line 559
  while (1) {
    while_continue___25: /* CIL Label */ ;
    {
#line 559
    if (child_val1.type == 0) {
#line 559
      goto case_0___16;
    }
#line 559
    if (child_val1.type == 2) {
#line 559
      goto case_2___16;
    }
#line 559
    goto switch_break___16;
    case_0___16: /* CIL Label */ 
#line 559
    op1___3 = child_val1.int_val;
#line 559
    goto switch_break___16;
    case_2___16: /* CIL Label */ 
    {
#line 559
    tmp___47 = strcmp((char const   *)child_val1.str_val, "");
    }
#line 559
    if (tmp___47 == 0) {
#line 559
      op1___3 = 0;
    } else {
      {
#line 559
      tmp___46 = rec_atoi((char const   *)child_val1.str_val, & op1___3);
      }
#line 559
      if (! tmp___46) {
#line 559
        *status = (_Bool)0;
#line 559
        return (res);
      }
    }
#line 559
    goto switch_break___16;
    switch_break___16: /* CIL Label */ ;
    }
#line 559
    goto while_break___25;
  }
  while_break___25: /* CIL Label */ ;
  }
  {
#line 560
  while (1) {
    while_continue___26: /* CIL Label */ ;
    {
#line 560
    if (child_val2.type == 0) {
#line 560
      goto case_0___17;
    }
#line 560
    if (child_val2.type == 2) {
#line 560
      goto case_2___17;
    }
#line 560
    goto switch_break___17;
    case_0___17: /* CIL Label */ 
#line 560
    op2___3 = child_val2.int_val;
#line 560
    goto switch_break___17;
    case_2___17: /* CIL Label */ 
    {
#line 560
    tmp___49 = strcmp((char const   *)child_val2.str_val, "");
    }
#line 560
    if (tmp___49 == 0) {
#line 560
      op2___3 = 0;
    } else {
      {
#line 560
      tmp___48 = rec_atoi((char const   *)child_val2.str_val, & op2___3);
      }
#line 560
      if (! tmp___48) {
#line 560
        *status = (_Bool)0;
#line 560
        return (res);
      }
    }
#line 560
    goto switch_break___17;
    switch_break___17: /* CIL Label */ ;
    }
#line 560
    goto while_break___26;
  }
  while_break___26: /* CIL Label */ ;
  }
#line 562
  res.type = 0;
#line 564
  if (op2___3 != 0) {
#line 566
    res.int_val = op1___3 % op2___3;
  } else {
#line 571
    *status = (_Bool)0;
#line 572
    return (res);
  }
#line 575
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 584
  while (1) {
    while_continue___27: /* CIL Label */ ;
    {
#line 584
    tmp___50 = rec_sex_ast_node_child(node, 0);
#line 584
    child_val1 = rec_sex_eval_node(sex, record, tmp___50, status);
    }
#line 584
    if (! *status) {
#line 584
      return (res);
    }
#line 584
    goto while_break___27;
  }
  while_break___27: /* CIL Label */ ;
  }
  {
#line 585
  while (1) {
    while_continue___28: /* CIL Label */ ;
    {
#line 585
    tmp___51 = rec_sex_ast_node_child(node, 1);
#line 585
    child_val2 = rec_sex_eval_node(sex, record, tmp___51, status);
    }
#line 585
    if (! *status) {
#line 585
      return (res);
    }
#line 585
    goto while_break___28;
  }
  while_break___28: /* CIL Label */ ;
  }
#line 587
  if (child_val1.type == 2) {
#line 587
    if (child_val2.type == 2) {
      {
#line 591
      res.type = 0;
#line 593
      tmp___54 = rec_sex_parser_case_insensitive(sex->parser);
      }
#line 593
      if (tmp___54) {
        {
#line 595
        tmp___52 = strcasecmp((char const   *)child_val1.str_val, (char const   *)child_val2.str_val);
#line 595
        res.int_val = tmp___52 == 0;
        }
      } else {
        {
#line 600
        tmp___53 = strcmp((char const   *)child_val1.str_val, (char const   *)child_val2.str_val);
#line 600
        res.int_val = tmp___53 == 0;
        }
      }
    } else {
#line 587
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 606
    tmp___63 = rec_sex_op_real_p(child_val1, child_val2);
    }
#line 606
    if (tmp___63) {
      {
#line 609
      while (1) {
        while_continue___29: /* CIL Label */ ;
        {
#line 609
        if (child_val1.type == 1) {
#line 609
          goto case_1___8;
        }
#line 609
        if (child_val1.type == 0) {
#line 609
          goto case_0___18;
        }
#line 609
        if (child_val1.type == 2) {
#line 609
          goto case_2___18;
        }
#line 609
        goto switch_break___18;
        case_1___8: /* CIL Label */ 
#line 609
        op1_real___3 = child_val1.real_val;
#line 609
        goto switch_break___18;
        case_0___18: /* CIL Label */ 
#line 609
        op1_real___3 = (double )child_val1.int_val;
#line 609
        goto switch_break___18;
        case_2___18: /* CIL Label */ 
        {
#line 609
        tmp___56 = strcmp((char const   *)child_val1.str_val, "");
        }
#line 609
        if (tmp___56 == 0) {
#line 609
          op1_real___3 = 0.0;
        } else {
          {
#line 609
          tmp___55 = rec_atod((char const   *)child_val1.str_val, & op1_real___3);
          }
#line 609
          if (! tmp___55) {
#line 609
            *status = (_Bool)0;
#line 609
            return (res);
          }
        }
#line 609
        goto switch_break___18;
        switch_break___18: /* CIL Label */ ;
        }
#line 609
        goto while_break___29;
      }
      while_break___29: /* CIL Label */ ;
      }
      {
#line 610
      while (1) {
        while_continue___30: /* CIL Label */ ;
        {
#line 610
        if (child_val2.type == 1) {
#line 610
          goto case_1___9;
        }
#line 610
        if (child_val2.type == 0) {
#line 610
          goto case_0___19;
        }
#line 610
        if (child_val2.type == 2) {
#line 610
          goto case_2___19;
        }
#line 610
        goto switch_break___19;
        case_1___9: /* CIL Label */ 
#line 610
        op2_real___3 = child_val2.real_val;
#line 610
        goto switch_break___19;
        case_0___19: /* CIL Label */ 
#line 610
        op2_real___3 = (double )child_val2.int_val;
#line 610
        goto switch_break___19;
        case_2___19: /* CIL Label */ 
        {
#line 610
        tmp___58 = strcmp((char const   *)child_val2.str_val, "");
        }
#line 610
        if (tmp___58 == 0) {
#line 610
          op2_real___3 = 0.0;
        } else {
          {
#line 610
          tmp___57 = rec_atod((char const   *)child_val2.str_val, & op2_real___3);
          }
#line 610
          if (! tmp___57) {
#line 610
            *status = (_Bool)0;
#line 610
            return (res);
          }
        }
#line 610
        goto switch_break___19;
        switch_break___19: /* CIL Label */ ;
        }
#line 610
        goto while_break___30;
      }
      while_break___30: /* CIL Label */ ;
      }
#line 612
      res.type = 0;
#line 613
      res.int_val = op1_real___3 == op2_real___3;
    } else {
      {
#line 618
      while (1) {
        while_continue___31: /* CIL Label */ ;
        {
#line 618
        if (child_val1.type == 0) {
#line 618
          goto case_0___20;
        }
#line 618
        if (child_val1.type == 2) {
#line 618
          goto case_2___20;
        }
#line 618
        goto switch_break___20;
        case_0___20: /* CIL Label */ 
#line 618
        op1___4 = child_val1.int_val;
#line 618
        goto switch_break___20;
        case_2___20: /* CIL Label */ 
        {
#line 618
        tmp___60 = strcmp((char const   *)child_val1.str_val, "");
        }
#line 618
        if (tmp___60 == 0) {
#line 618
          op1___4 = 0;
        } else {
          {
#line 618
          tmp___59 = rec_atoi((char const   *)child_val1.str_val, & op1___4);
          }
#line 618
          if (! tmp___59) {
#line 618
            *status = (_Bool)0;
#line 618
            return (res);
          }
        }
#line 618
        goto switch_break___20;
        switch_break___20: /* CIL Label */ ;
        }
#line 618
        goto while_break___31;
      }
      while_break___31: /* CIL Label */ ;
      }
      {
#line 619
      while (1) {
        while_continue___32: /* CIL Label */ ;
        {
#line 619
        if (child_val2.type == 0) {
#line 619
          goto case_0___21;
        }
#line 619
        if (child_val2.type == 2) {
#line 619
          goto case_2___21;
        }
#line 619
        goto switch_break___21;
        case_0___21: /* CIL Label */ 
#line 619
        op2___4 = child_val2.int_val;
#line 619
        goto switch_break___21;
        case_2___21: /* CIL Label */ 
        {
#line 619
        tmp___62 = strcmp((char const   *)child_val2.str_val, "");
        }
#line 619
        if (tmp___62 == 0) {
#line 619
          op2___4 = 0;
        } else {
          {
#line 619
          tmp___61 = rec_atoi((char const   *)child_val2.str_val, & op2___4);
          }
#line 619
          if (! tmp___61) {
#line 619
            *status = (_Bool)0;
#line 619
            return (res);
          }
        }
#line 619
        goto switch_break___21;
        switch_break___21: /* CIL Label */ ;
        }
#line 619
        goto while_break___32;
      }
      while_break___32: /* CIL Label */ ;
      }
#line 621
      res.type = 0;
#line 622
      res.int_val = op1___4 == op2___4;
    }
  }
#line 626
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 635
  while (1) {
    while_continue___33: /* CIL Label */ ;
    {
#line 635
    tmp___64 = rec_sex_ast_node_child(node, 0);
#line 635
    child_val1 = rec_sex_eval_node(sex, record, tmp___64, status);
    }
#line 635
    if (! *status) {
#line 635
      return (res);
    }
#line 635
    goto while_break___33;
  }
  while_break___33: /* CIL Label */ ;
  }
  {
#line 636
  while (1) {
    while_continue___34: /* CIL Label */ ;
    {
#line 636
    tmp___65 = rec_sex_ast_node_child(node, 1);
#line 636
    child_val2 = rec_sex_eval_node(sex, record, tmp___65, status);
    }
#line 636
    if (! *status) {
#line 636
      return (res);
    }
#line 636
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
#line 638
  if (child_val1.type == 2) {
#line 638
    if (child_val2.type == 2) {
      {
#line 642
      res.type = 0;
#line 644
      tmp___68 = rec_sex_parser_case_insensitive(sex->parser);
      }
#line 644
      if (tmp___68) {
        {
#line 646
        tmp___66 = strcasecmp((char const   *)child_val1.str_val, (char const   *)child_val2.str_val);
#line 646
        res.int_val = tmp___66 != 0;
        }
      } else {
        {
#line 651
        tmp___67 = strcmp((char const   *)child_val1.str_val, (char const   *)child_val2.str_val);
#line 651
        res.int_val = tmp___67 != 0;
        }
      }
    } else {
#line 638
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 657
    tmp___77 = rec_sex_op_real_p(child_val1, child_val2);
    }
#line 657
    if (tmp___77) {
      {
#line 660
      while (1) {
        while_continue___35: /* CIL Label */ ;
        {
#line 660
        if (child_val1.type == 1) {
#line 660
          goto case_1___10;
        }
#line 660
        if (child_val1.type == 0) {
#line 660
          goto case_0___22;
        }
#line 660
        if (child_val1.type == 2) {
#line 660
          goto case_2___22;
        }
#line 660
        goto switch_break___22;
        case_1___10: /* CIL Label */ 
#line 660
        op1_real___4 = child_val1.real_val;
#line 660
        goto switch_break___22;
        case_0___22: /* CIL Label */ 
#line 660
        op1_real___4 = (double )child_val1.int_val;
#line 660
        goto switch_break___22;
        case_2___22: /* CIL Label */ 
        {
#line 660
        tmp___70 = strcmp((char const   *)child_val1.str_val, "");
        }
#line 660
        if (tmp___70 == 0) {
#line 660
          op1_real___4 = 0.0;
        } else {
          {
#line 660
          tmp___69 = rec_atod((char const   *)child_val1.str_val, & op1_real___4);
          }
#line 660
          if (! tmp___69) {
#line 660
            *status = (_Bool)0;
#line 660
            return (res);
          }
        }
#line 660
        goto switch_break___22;
        switch_break___22: /* CIL Label */ ;
        }
#line 660
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
      {
#line 661
      while (1) {
        while_continue___36: /* CIL Label */ ;
        {
#line 661
        if (child_val2.type == 1) {
#line 661
          goto case_1___11;
        }
#line 661
        if (child_val2.type == 0) {
#line 661
          goto case_0___23;
        }
#line 661
        if (child_val2.type == 2) {
#line 661
          goto case_2___23;
        }
#line 661
        goto switch_break___23;
        case_1___11: /* CIL Label */ 
#line 661
        op2_real___4 = child_val2.real_val;
#line 661
        goto switch_break___23;
        case_0___23: /* CIL Label */ 
#line 661
        op2_real___4 = (double )child_val2.int_val;
#line 661
        goto switch_break___23;
        case_2___23: /* CIL Label */ 
        {
#line 661
        tmp___72 = strcmp((char const   *)child_val2.str_val, "");
        }
#line 661
        if (tmp___72 == 0) {
#line 661
          op2_real___4 = 0.0;
        } else {
          {
#line 661
          tmp___71 = rec_atod((char const   *)child_val2.str_val, & op2_real___4);
          }
#line 661
          if (! tmp___71) {
#line 661
            *status = (_Bool)0;
#line 661
            return (res);
          }
        }
#line 661
        goto switch_break___23;
        switch_break___23: /* CIL Label */ ;
        }
#line 661
        goto while_break___36;
      }
      while_break___36: /* CIL Label */ ;
      }
#line 663
      res.type = 0;
#line 664
      res.int_val = op1_real___4 != op2_real___4;
    } else {
      {
#line 669
      while (1) {
        while_continue___37: /* CIL Label */ ;
        {
#line 669
        if (child_val1.type == 0) {
#line 669
          goto case_0___24;
        }
#line 669
        if (child_val1.type == 2) {
#line 669
          goto case_2___24;
        }
#line 669
        goto switch_break___24;
        case_0___24: /* CIL Label */ 
#line 669
        op1___5 = child_val1.int_val;
#line 669
        goto switch_break___24;
        case_2___24: /* CIL Label */ 
        {
#line 669
        tmp___74 = strcmp((char const   *)child_val1.str_val, "");
        }
#line 669
        if (tmp___74 == 0) {
#line 669
          op1___5 = 0;
        } else {
          {
#line 669
          tmp___73 = rec_atoi((char const   *)child_val1.str_val, & op1___5);
          }
#line 669
          if (! tmp___73) {
#line 669
            *status = (_Bool)0;
#line 669
            return (res);
          }
        }
#line 669
        goto switch_break___24;
        switch_break___24: /* CIL Label */ ;
        }
#line 669
        goto while_break___37;
      }
      while_break___37: /* CIL Label */ ;
      }
      {
#line 670
      while (1) {
        while_continue___38: /* CIL Label */ ;
        {
#line 670
        if (child_val2.type == 0) {
#line 670
          goto case_0___25;
        }
#line 670
        if (child_val2.type == 2) {
#line 670
          goto case_2___25;
        }
#line 670
        goto switch_break___25;
        case_0___25: /* CIL Label */ 
#line 670
        op2___5 = child_val2.int_val;
#line 670
        goto switch_break___25;
        case_2___25: /* CIL Label */ 
        {
#line 670
        tmp___76 = strcmp((char const   *)child_val2.str_val, "");
        }
#line 670
        if (tmp___76 == 0) {
#line 670
          op2___5 = 0;
        } else {
          {
#line 670
          tmp___75 = rec_atoi((char const   *)child_val2.str_val, & op2___5);
          }
#line 670
          if (! tmp___75) {
#line 670
            *status = (_Bool)0;
#line 670
            return (res);
          }
        }
#line 670
        goto switch_break___25;
        switch_break___25: /* CIL Label */ ;
        }
#line 670
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 672
      res.type = 0;
#line 673
      res.int_val = op1___5 != op2___5;
    }
  }
#line 677
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 681
  while (1) {
    while_continue___39: /* CIL Label */ ;
    {
#line 681
    tmp___78 = rec_sex_ast_node_child(node, 0);
#line 681
    child_val1 = rec_sex_eval_node(sex, record, tmp___78, status);
    }
#line 681
    if (! *status) {
#line 681
      return (res);
    }
#line 681
    goto while_break___39;
  }
  while_break___39: /* CIL Label */ ;
  }
  {
#line 682
  while (1) {
    while_continue___40: /* CIL Label */ ;
    {
#line 682
    tmp___79 = rec_sex_ast_node_child(node, 1);
#line 682
    child_val2 = rec_sex_eval_node(sex, record, tmp___79, status);
    }
#line 682
    if (! *status) {
#line 682
      return (res);
    }
#line 682
    goto while_break___40;
  }
  while_break___40: /* CIL Label */ ;
  }
#line 684
  if (child_val1.type == 2) {
#line 684
    if (child_val2.type == 2) {
      {
#line 688
      res.type = 0;
#line 690
      tmp___82 = rec_sex_parser_case_insensitive(sex->parser);
      }
#line 690
      if (tmp___82) {
        {
#line 692
        tmp___80 = rec_match_insensitive((char const   *)child_val1.str_val, (char const   *)child_val2.str_val);
#line 692
        res.int_val = (int )tmp___80;
        }
      } else {
        {
#line 697
        tmp___81 = rec_match((char const   *)child_val1.str_val, (char const   *)child_val2.str_val);
#line 697
        res.int_val = (int )tmp___81;
        }
      }
    } else {
#line 704
      *status = (_Bool)0;
#line 705
      return (res);
    }
  } else {
#line 704
    *status = (_Bool)0;
#line 705
    return (res);
  }
#line 708
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 716
  while (1) {
    while_continue___41: /* CIL Label */ ;
    {
#line 716
    tmp___83 = rec_sex_ast_node_child(node, 0);
#line 716
    child_val1 = rec_sex_eval_node(sex, record, tmp___83, status);
    }
#line 716
    if (! *status) {
#line 716
      return (res);
    }
#line 716
    goto while_break___41;
  }
  while_break___41: /* CIL Label */ ;
  }
  {
#line 717
  while (1) {
    while_continue___42: /* CIL Label */ ;
    {
#line 717
    tmp___84 = rec_sex_ast_node_child(node, 1);
#line 717
    child_val2 = rec_sex_eval_node(sex, record, tmp___84, status);
    }
#line 717
    if (! *status) {
#line 717
      return (res);
    }
#line 717
    goto while_break___42;
  }
  while_break___42: /* CIL Label */ ;
  }
  {
#line 719
  while (1) {
    while_continue___43: /* CIL Label */ ;
    {
#line 719
    if (child_val1.type == 1) {
#line 719
      goto case_1___12;
    }
#line 719
    if (child_val1.type == 0) {
#line 719
      goto case_0___26;
    }
#line 719
    if (child_val1.type == 2) {
#line 719
      goto case_2___26;
    }
#line 719
    goto switch_break___26;
    case_1___12: /* CIL Label */ 
#line 719
    *status = (_Bool)0;
#line 719
    return (res);
#line 719
    goto switch_break___26;
    case_0___26: /* CIL Label */ 
#line 719
    *status = (_Bool)0;
#line 719
    return (res);
#line 719
    goto switch_break___26;
    case_2___26: /* CIL Label */ 
    {
#line 719
    tmp___85 = parse_datetime(& op1___6, (char const   *)child_val1.str_val, (struct timespec  const  *)((void *)0));
    }
#line 719
    if (! tmp___85) {
#line 719
      *status = (_Bool)0;
#line 719
      return (res);
    }
#line 719
    goto switch_break___26;
    switch_break___26: /* CIL Label */ ;
    }
#line 719
    goto while_break___43;
  }
  while_break___43: /* CIL Label */ ;
  }
  {
#line 720
  while (1) {
    while_continue___44: /* CIL Label */ ;
    {
#line 720
    if (child_val2.type == 1) {
#line 720
      goto case_1___13;
    }
#line 720
    if (child_val2.type == 0) {
#line 720
      goto case_0___27;
    }
#line 720
    if (child_val2.type == 2) {
#line 720
      goto case_2___27;
    }
#line 720
    goto switch_break___27;
    case_1___13: /* CIL Label */ 
#line 720
    *status = (_Bool)0;
#line 720
    return (res);
#line 720
    goto switch_break___27;
    case_0___27: /* CIL Label */ 
#line 720
    *status = (_Bool)0;
#line 720
    return (res);
#line 720
    goto switch_break___27;
    case_2___27: /* CIL Label */ 
    {
#line 720
    tmp___86 = parse_datetime(& op2___6, (char const   *)child_val2.str_val, (struct timespec  const  *)((void *)0));
    }
#line 720
    if (! tmp___86) {
#line 720
      *status = (_Bool)0;
#line 720
      return (res);
    }
#line 720
    goto switch_break___27;
    switch_break___27: /* CIL Label */ ;
    }
#line 720
    goto while_break___44;
  }
  while_break___44: /* CIL Label */ ;
  }
  {
#line 722
  res.type = 0;
#line 723
  res.int_val = rec_timespec_subtract(& diff, & op1___6, & op2___6);
  }
#line 724
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 732
  while (1) {
    while_continue___45: /* CIL Label */ ;
    {
#line 732
    tmp___87 = rec_sex_ast_node_child(node, 0);
#line 732
    child_val1 = rec_sex_eval_node(sex, record, tmp___87, status);
    }
#line 732
    if (! *status) {
#line 732
      return (res);
    }
#line 732
    goto while_break___45;
  }
  while_break___45: /* CIL Label */ ;
  }
  {
#line 733
  while (1) {
    while_continue___46: /* CIL Label */ ;
    {
#line 733
    tmp___88 = rec_sex_ast_node_child(node, 1);
#line 733
    child_val2 = rec_sex_eval_node(sex, record, tmp___88, status);
    }
#line 733
    if (! *status) {
#line 733
      return (res);
    }
#line 733
    goto while_break___46;
  }
  while_break___46: /* CIL Label */ ;
  }
  {
#line 735
  while (1) {
    while_continue___47: /* CIL Label */ ;
    {
#line 735
    if (child_val1.type == 1) {
#line 735
      goto case_1___14;
    }
#line 735
    if (child_val1.type == 0) {
#line 735
      goto case_0___28;
    }
#line 735
    if (child_val1.type == 2) {
#line 735
      goto case_2___28;
    }
#line 735
    goto switch_break___28;
    case_1___14: /* CIL Label */ 
#line 735
    *status = (_Bool)0;
#line 735
    return (res);
#line 735
    goto switch_break___28;
    case_0___28: /* CIL Label */ 
#line 735
    *status = (_Bool)0;
#line 735
    return (res);
#line 735
    goto switch_break___28;
    case_2___28: /* CIL Label */ 
    {
#line 735
    tmp___89 = parse_datetime(& op1___7, (char const   *)child_val1.str_val, (struct timespec  const  *)((void *)0));
    }
#line 735
    if (! tmp___89) {
#line 735
      *status = (_Bool)0;
#line 735
      return (res);
    }
#line 735
    goto switch_break___28;
    switch_break___28: /* CIL Label */ ;
    }
#line 735
    goto while_break___47;
  }
  while_break___47: /* CIL Label */ ;
  }
  {
#line 736
  while (1) {
    while_continue___48: /* CIL Label */ ;
    {
#line 736
    if (child_val2.type == 1) {
#line 736
      goto case_1___15;
    }
#line 736
    if (child_val2.type == 0) {
#line 736
      goto case_0___29;
    }
#line 736
    if (child_val2.type == 2) {
#line 736
      goto case_2___29;
    }
#line 736
    goto switch_break___29;
    case_1___15: /* CIL Label */ 
#line 736
    *status = (_Bool)0;
#line 736
    return (res);
#line 736
    goto switch_break___29;
    case_0___29: /* CIL Label */ 
#line 736
    *status = (_Bool)0;
#line 736
    return (res);
#line 736
    goto switch_break___29;
    case_2___29: /* CIL Label */ 
    {
#line 736
    tmp___90 = parse_datetime(& op2___7, (char const   *)child_val2.str_val, (struct timespec  const  *)((void *)0));
    }
#line 736
    if (! tmp___90) {
#line 736
      *status = (_Bool)0;
#line 736
      return (res);
    }
#line 736
    goto switch_break___29;
    switch_break___29: /* CIL Label */ ;
    }
#line 736
    goto while_break___48;
  }
  while_break___48: /* CIL Label */ ;
  }
  {
#line 738
  res.type = 0;
#line 739
  tmp___91 = rec_timespec_subtract(& diff___0, & op1___7, & op2___7);
  }
#line 739
  if (tmp___91) {
#line 739
    tmp___92 = 0;
  } else
#line 739
  if (diff___0.tv_sec != 0L) {
#line 739
    tmp___92 = 1;
  } else
#line 739
  if (diff___0.tv_nsec != 0L) {
#line 739
    tmp___92 = 1;
  } else {
#line 739
    tmp___92 = 0;
  }
#line 739
  res.int_val = tmp___92;
#line 741
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 749
  while (1) {
    while_continue___49: /* CIL Label */ ;
    {
#line 749
    tmp___93 = rec_sex_ast_node_child(node, 0);
#line 749
    child_val1 = rec_sex_eval_node(sex, record, tmp___93, status);
    }
#line 749
    if (! *status) {
#line 749
      return (res);
    }
#line 749
    goto while_break___49;
  }
  while_break___49: /* CIL Label */ ;
  }
  {
#line 750
  while (1) {
    while_continue___50: /* CIL Label */ ;
    {
#line 750
    tmp___94 = rec_sex_ast_node_child(node, 1);
#line 750
    child_val2 = rec_sex_eval_node(sex, record, tmp___94, status);
    }
#line 750
    if (! *status) {
#line 750
      return (res);
    }
#line 750
    goto while_break___50;
  }
  while_break___50: /* CIL Label */ ;
  }
  {
#line 752
  while (1) {
    while_continue___51: /* CIL Label */ ;
    {
#line 752
    if (child_val1.type == 1) {
#line 752
      goto case_1___16;
    }
#line 752
    if (child_val1.type == 0) {
#line 752
      goto case_0___30;
    }
#line 752
    if (child_val1.type == 2) {
#line 752
      goto case_2___30;
    }
#line 752
    goto switch_break___30;
    case_1___16: /* CIL Label */ 
#line 752
    *status = (_Bool)0;
#line 752
    return (res);
#line 752
    goto switch_break___30;
    case_0___30: /* CIL Label */ 
#line 752
    *status = (_Bool)0;
#line 752
    return (res);
#line 752
    goto switch_break___30;
    case_2___30: /* CIL Label */ 
    {
#line 752
    tmp___95 = parse_datetime(& op1___8, (char const   *)child_val1.str_val, (struct timespec  const  *)((void *)0));
    }
#line 752
    if (! tmp___95) {
#line 752
      *status = (_Bool)0;
#line 752
      return (res);
    }
#line 752
    goto switch_break___30;
    switch_break___30: /* CIL Label */ ;
    }
#line 752
    goto while_break___51;
  }
  while_break___51: /* CIL Label */ ;
  }
  {
#line 753
  while (1) {
    while_continue___52: /* CIL Label */ ;
    {
#line 753
    if (child_val2.type == 1) {
#line 753
      goto case_1___17;
    }
#line 753
    if (child_val2.type == 0) {
#line 753
      goto case_0___31;
    }
#line 753
    if (child_val2.type == 2) {
#line 753
      goto case_2___31;
    }
#line 753
    goto switch_break___31;
    case_1___17: /* CIL Label */ 
#line 753
    *status = (_Bool)0;
#line 753
    return (res);
#line 753
    goto switch_break___31;
    case_0___31: /* CIL Label */ 
#line 753
    *status = (_Bool)0;
#line 753
    return (res);
#line 753
    goto switch_break___31;
    case_2___31: /* CIL Label */ 
    {
#line 753
    tmp___96 = parse_datetime(& op2___8, (char const   *)child_val2.str_val, (struct timespec  const  *)((void *)0));
    }
#line 753
    if (! tmp___96) {
#line 753
      *status = (_Bool)0;
#line 753
      return (res);
    }
#line 753
    goto switch_break___31;
    switch_break___31: /* CIL Label */ ;
    }
#line 753
    goto while_break___52;
  }
  while_break___52: /* CIL Label */ ;
  }
  {
#line 755
  rec_timespec_subtract(& diff___1, & op1___8, & op2___8);
#line 757
  res.type = 0;
  }
#line 758
  if (diff___1.tv_sec == 0L) {
#line 758
    if (diff___1.tv_nsec == 0L) {
#line 758
      tmp___97 = 1;
    } else {
#line 758
      tmp___97 = 0;
    }
  } else {
#line 758
    tmp___97 = 0;
  }
#line 758
  res.int_val = tmp___97;
#line 759
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 766
  while (1) {
    while_continue___53: /* CIL Label */ ;
    {
#line 766
    tmp___98 = rec_sex_ast_node_child(node, 0);
#line 766
    child_val1 = rec_sex_eval_node(sex, record, tmp___98, status);
    }
#line 766
    if (! *status) {
#line 766
      return (res);
    }
#line 766
    goto while_break___53;
  }
  while_break___53: /* CIL Label */ ;
  }
  {
#line 767
  while (1) {
    while_continue___54: /* CIL Label */ ;
    {
#line 767
    tmp___99 = rec_sex_ast_node_child(node, 1);
#line 767
    child_val2 = rec_sex_eval_node(sex, record, tmp___99, status);
    }
#line 767
    if (! *status) {
#line 767
      return (res);
    }
#line 767
    goto while_break___54;
  }
  while_break___54: /* CIL Label */ ;
  }
  {
#line 769
  while (1) {
    while_continue___55: /* CIL Label */ ;
    {
#line 769
    if (child_val1.type == 0) {
#line 769
      goto case_0___32;
    }
#line 769
    if (child_val1.type == 2) {
#line 769
      goto case_2___32;
    }
#line 769
    goto switch_break___32;
    case_0___32: /* CIL Label */ 
#line 769
    op1___9 = child_val1.int_val;
#line 769
    goto switch_break___32;
    case_2___32: /* CIL Label */ 
    {
#line 769
    tmp___101 = strcmp((char const   *)child_val1.str_val, "");
    }
#line 769
    if (tmp___101 == 0) {
#line 769
      op1___9 = 0;
    } else {
      {
#line 769
      tmp___100 = rec_atoi((char const   *)child_val1.str_val, & op1___9);
      }
#line 769
      if (! tmp___100) {
#line 769
        *status = (_Bool)0;
#line 769
        return (res);
      }
    }
#line 769
    goto switch_break___32;
    switch_break___32: /* CIL Label */ ;
    }
#line 769
    goto while_break___55;
  }
  while_break___55: /* CIL Label */ ;
  }
  {
#line 770
  while (1) {
    while_continue___56: /* CIL Label */ ;
    {
#line 770
    if (child_val2.type == 0) {
#line 770
      goto case_0___33;
    }
#line 770
    if (child_val2.type == 2) {
#line 770
      goto case_2___33;
    }
#line 770
    goto switch_break___33;
    case_0___33: /* CIL Label */ 
#line 770
    op2___9 = child_val2.int_val;
#line 770
    goto switch_break___33;
    case_2___33: /* CIL Label */ 
    {
#line 770
    tmp___103 = strcmp((char const   *)child_val2.str_val, "");
    }
#line 770
    if (tmp___103 == 0) {
#line 770
      op2___9 = 0;
    } else {
      {
#line 770
      tmp___102 = rec_atoi((char const   *)child_val2.str_val, & op2___9);
      }
#line 770
      if (! tmp___102) {
#line 770
        *status = (_Bool)0;
#line 770
        return (res);
      }
    }
#line 770
    goto switch_break___33;
    switch_break___33: /* CIL Label */ ;
    }
#line 770
    goto while_break___56;
  }
  while_break___56: /* CIL Label */ ;
  }
#line 772
  res.type = 0;
#line 773
  if (! op1___9) {
#line 773
    tmp___104 = 1;
  } else
#line 773
  if (op1___9) {
#line 773
    if (op2___9) {
#line 773
      tmp___104 = 1;
    } else {
#line 773
      tmp___104 = 0;
    }
  } else {
#line 773
    tmp___104 = 0;
  }
#line 773
  res.int_val = tmp___104;
#line 775
  goto switch_break;
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
#line 785
  while (1) {
    while_continue___57: /* CIL Label */ ;
    {
#line 785
    tmp___105 = rec_sex_ast_node_child(node, 0);
#line 785
    child_val1 = rec_sex_eval_node(sex, record, tmp___105, status);
    }
#line 785
    if (! *status) {
#line 785
      return (res);
    }
#line 785
    goto while_break___57;
  }
  while_break___57: /* CIL Label */ ;
  }
  {
#line 786
  while (1) {
    while_continue___58: /* CIL Label */ ;
    {
#line 786
    tmp___106 = rec_sex_ast_node_child(node, 1);
#line 786
    child_val2 = rec_sex_eval_node(sex, record, tmp___106, status);
    }
#line 786
    if (! *status) {
#line 786
      return (res);
    }
#line 786
    goto while_break___58;
  }
  while_break___58: /* CIL Label */ ;
  }
  {
#line 788
  tmp___117 = rec_sex_op_real_p(child_val1, child_val2);
  }
#line 788
  if (tmp___117) {
    {
#line 791
    while (1) {
      while_continue___59: /* CIL Label */ ;
      {
#line 791
      if (child_val1.type == 1) {
#line 791
        goto case_1___18;
      }
#line 791
      if (child_val1.type == 0) {
#line 791
        goto case_0___34;
      }
#line 791
      if (child_val1.type == 2) {
#line 791
        goto case_2___34;
      }
#line 791
      goto switch_break___34;
      case_1___18: /* CIL Label */ 
#line 791
      op1_real___5 = child_val1.real_val;
#line 791
      goto switch_break___34;
      case_0___34: /* CIL Label */ 
#line 791
      op1_real___5 = (double )child_val1.int_val;
#line 791
      goto switch_break___34;
      case_2___34: /* CIL Label */ 
      {
#line 791
      tmp___108 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 791
      if (tmp___108 == 0) {
#line 791
        op1_real___5 = 0.0;
      } else {
        {
#line 791
        tmp___107 = rec_atod((char const   *)child_val1.str_val, & op1_real___5);
        }
#line 791
        if (! tmp___107) {
#line 791
          *status = (_Bool)0;
#line 791
          return (res);
        }
      }
#line 791
      goto switch_break___34;
      switch_break___34: /* CIL Label */ ;
      }
#line 791
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 792
    while (1) {
      while_continue___60: /* CIL Label */ ;
      {
#line 792
      if (child_val2.type == 1) {
#line 792
        goto case_1___19;
      }
#line 792
      if (child_val2.type == 0) {
#line 792
        goto case_0___35;
      }
#line 792
      if (child_val2.type == 2) {
#line 792
        goto case_2___35;
      }
#line 792
      goto switch_break___35;
      case_1___19: /* CIL Label */ 
#line 792
      op2_real___5 = child_val2.real_val;
#line 792
      goto switch_break___35;
      case_0___35: /* CIL Label */ 
#line 792
      op2_real___5 = (double )child_val2.int_val;
#line 792
      goto switch_break___35;
      case_2___35: /* CIL Label */ 
      {
#line 792
      tmp___110 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 792
      if (tmp___110 == 0) {
#line 792
        op2_real___5 = 0.0;
      } else {
        {
#line 792
        tmp___109 = rec_atod((char const   *)child_val2.str_val, & op2_real___5);
        }
#line 792
        if (! tmp___109) {
#line 792
          *status = (_Bool)0;
#line 792
          return (res);
        }
      }
#line 792
      goto switch_break___35;
      switch_break___35: /* CIL Label */ ;
      }
#line 792
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 794
    res.type = 0;
#line 796
    tmp___111 = rec_sex_ast_node_type(node);
    }
#line 796
    if ((unsigned int )tmp___111 == 10U) {
#line 798
      res.int_val = op1_real___5 < op2_real___5;
    } else {
#line 802
      res.int_val = op1_real___5 <= op2_real___5;
    }
  } else {
    {
#line 808
    while (1) {
      while_continue___61: /* CIL Label */ ;
      {
#line 808
      if (child_val1.type == 0) {
#line 808
        goto case_0___36;
      }
#line 808
      if (child_val1.type == 2) {
#line 808
        goto case_2___36;
      }
#line 808
      goto switch_break___36;
      case_0___36: /* CIL Label */ 
#line 808
      op1___10 = child_val1.int_val;
#line 808
      goto switch_break___36;
      case_2___36: /* CIL Label */ 
      {
#line 808
      tmp___113 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 808
      if (tmp___113 == 0) {
#line 808
        op1___10 = 0;
      } else {
        {
#line 808
        tmp___112 = rec_atoi((char const   *)child_val1.str_val, & op1___10);
        }
#line 808
        if (! tmp___112) {
#line 808
          *status = (_Bool)0;
#line 808
          return (res);
        }
      }
#line 808
      goto switch_break___36;
      switch_break___36: /* CIL Label */ ;
      }
#line 808
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 809
    while (1) {
      while_continue___62: /* CIL Label */ ;
      {
#line 809
      if (child_val2.type == 0) {
#line 809
        goto case_0___37;
      }
#line 809
      if (child_val2.type == 2) {
#line 809
        goto case_2___37;
      }
#line 809
      goto switch_break___37;
      case_0___37: /* CIL Label */ 
#line 809
      op2___10 = child_val2.int_val;
#line 809
      goto switch_break___37;
      case_2___37: /* CIL Label */ 
      {
#line 809
      tmp___115 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 809
      if (tmp___115 == 0) {
#line 809
        op2___10 = 0;
      } else {
        {
#line 809
        tmp___114 = rec_atoi((char const   *)child_val2.str_val, & op2___10);
        }
#line 809
        if (! tmp___114) {
#line 809
          *status = (_Bool)0;
#line 809
          return (res);
        }
      }
#line 809
      goto switch_break___37;
      switch_break___37: /* CIL Label */ ;
      }
#line 809
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 811
    res.type = 0;
#line 813
    tmp___116 = rec_sex_ast_node_type(node);
    }
#line 813
    if ((unsigned int )tmp___116 == 10U) {
#line 815
      res.int_val = op1___10 < op2___10;
    } else {
#line 819
      res.int_val = op1___10 <= op2___10;
    }
  }
#line 823
  goto switch_break;
  case_13: /* CIL Label */ 
  case_11: /* CIL Label */ 
  {
#line 833
  while (1) {
    while_continue___63: /* CIL Label */ ;
    {
#line 833
    tmp___118 = rec_sex_ast_node_child(node, 0);
#line 833
    child_val1 = rec_sex_eval_node(sex, record, tmp___118, status);
    }
#line 833
    if (! *status) {
#line 833
      return (res);
    }
#line 833
    goto while_break___63;
  }
  while_break___63: /* CIL Label */ ;
  }
  {
#line 834
  while (1) {
    while_continue___64: /* CIL Label */ ;
    {
#line 834
    tmp___119 = rec_sex_ast_node_child(node, 1);
#line 834
    child_val2 = rec_sex_eval_node(sex, record, tmp___119, status);
    }
#line 834
    if (! *status) {
#line 834
      return (res);
    }
#line 834
    goto while_break___64;
  }
  while_break___64: /* CIL Label */ ;
  }
  {
#line 836
  tmp___130 = rec_sex_op_real_p(child_val1, child_val2);
  }
#line 836
  if (tmp___130) {
    {
#line 839
    while (1) {
      while_continue___65: /* CIL Label */ ;
      {
#line 839
      if (child_val1.type == 1) {
#line 839
        goto case_1___20;
      }
#line 839
      if (child_val1.type == 0) {
#line 839
        goto case_0___38;
      }
#line 839
      if (child_val1.type == 2) {
#line 839
        goto case_2___38;
      }
#line 839
      goto switch_break___38;
      case_1___20: /* CIL Label */ 
#line 839
      op1_real___6 = child_val1.real_val;
#line 839
      goto switch_break___38;
      case_0___38: /* CIL Label */ 
#line 839
      op1_real___6 = (double )child_val1.int_val;
#line 839
      goto switch_break___38;
      case_2___38: /* CIL Label */ 
      {
#line 839
      tmp___121 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 839
      if (tmp___121 == 0) {
#line 839
        op1_real___6 = 0.0;
      } else {
        {
#line 839
        tmp___120 = rec_atod((char const   *)child_val1.str_val, & op1_real___6);
        }
#line 839
        if (! tmp___120) {
#line 839
          *status = (_Bool)0;
#line 839
          return (res);
        }
      }
#line 839
      goto switch_break___38;
      switch_break___38: /* CIL Label */ ;
      }
#line 839
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
    {
#line 840
    while (1) {
      while_continue___66: /* CIL Label */ ;
      {
#line 840
      if (child_val2.type == 1) {
#line 840
        goto case_1___21;
      }
#line 840
      if (child_val2.type == 0) {
#line 840
        goto case_0___39;
      }
#line 840
      if (child_val2.type == 2) {
#line 840
        goto case_2___39;
      }
#line 840
      goto switch_break___39;
      case_1___21: /* CIL Label */ 
#line 840
      op2_real___6 = child_val2.real_val;
#line 840
      goto switch_break___39;
      case_0___39: /* CIL Label */ 
#line 840
      op2_real___6 = (double )child_val2.int_val;
#line 840
      goto switch_break___39;
      case_2___39: /* CIL Label */ 
      {
#line 840
      tmp___123 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 840
      if (tmp___123 == 0) {
#line 840
        op2_real___6 = 0.0;
      } else {
        {
#line 840
        tmp___122 = rec_atod((char const   *)child_val2.str_val, & op2_real___6);
        }
#line 840
        if (! tmp___122) {
#line 840
          *status = (_Bool)0;
#line 840
          return (res);
        }
      }
#line 840
      goto switch_break___39;
      switch_break___39: /* CIL Label */ ;
      }
#line 840
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
    {
#line 842
    res.type = 0;
#line 844
    tmp___124 = rec_sex_ast_node_type(node);
    }
#line 844
    if ((unsigned int )tmp___124 == 11U) {
#line 846
      res.int_val = op1_real___6 > op2_real___6;
    } else {
#line 850
      res.int_val = op1_real___6 >= op2_real___6;
    }
  } else {
    {
#line 856
    while (1) {
      while_continue___67: /* CIL Label */ ;
      {
#line 856
      if (child_val1.type == 0) {
#line 856
        goto case_0___40;
      }
#line 856
      if (child_val1.type == 2) {
#line 856
        goto case_2___40;
      }
#line 856
      goto switch_break___40;
      case_0___40: /* CIL Label */ 
#line 856
      op1___11 = child_val1.int_val;
#line 856
      goto switch_break___40;
      case_2___40: /* CIL Label */ 
      {
#line 856
      tmp___126 = strcmp((char const   *)child_val1.str_val, "");
      }
#line 856
      if (tmp___126 == 0) {
#line 856
        op1___11 = 0;
      } else {
        {
#line 856
        tmp___125 = rec_atoi((char const   *)child_val1.str_val, & op1___11);
        }
#line 856
        if (! tmp___125) {
#line 856
          *status = (_Bool)0;
#line 856
          return (res);
        }
      }
#line 856
      goto switch_break___40;
      switch_break___40: /* CIL Label */ ;
      }
#line 856
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
    {
#line 857
    while (1) {
      while_continue___68: /* CIL Label */ ;
      {
#line 857
      if (child_val2.type == 0) {
#line 857
        goto case_0___41;
      }
#line 857
      if (child_val2.type == 2) {
#line 857
        goto case_2___41;
      }
#line 857
      goto switch_break___41;
      case_0___41: /* CIL Label */ 
#line 857
      op2___11 = child_val2.int_val;
#line 857
      goto switch_break___41;
      case_2___41: /* CIL Label */ 
      {
#line 857
      tmp___128 = strcmp((char const   *)child_val2.str_val, "");
      }
#line 857
      if (tmp___128 == 0) {
#line 857
        op2___11 = 0;
      } else {
        {
#line 857
        tmp___127 = rec_atoi((char const   *)child_val2.str_val, & op2___11);
        }
#line 857
        if (! tmp___127) {
#line 857
          *status = (_Bool)0;
#line 857
          return (res);
        }
      }
#line 857
      goto switch_break___41;
      switch_break___41: /* CIL Label */ ;
      }
#line 857
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
    {
#line 859
    res.type = 0;
#line 861
    tmp___129 = rec_sex_ast_node_type(node);
    }
#line 861
    if ((unsigned int )tmp___129 == 11U) {
#line 863
      res.int_val = op1___11 > op2___11;
    } else {
#line 867
      res.int_val = op1___11 >= op2___11;
    }
  }
#line 871
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 878
  while (1) {
    while_continue___69: /* CIL Label */ ;
    {
#line 878
    tmp___131 = rec_sex_ast_node_child(node, 0);
#line 878
    child_val1 = rec_sex_eval_node(sex, record, tmp___131, status);
    }
#line 878
    if (! *status) {
#line 878
      return (res);
    }
#line 878
    goto while_break___69;
  }
  while_break___69: /* CIL Label */ ;
  }
  {
#line 879
  while (1) {
    while_continue___70: /* CIL Label */ ;
    {
#line 879
    tmp___132 = rec_sex_ast_node_child(node, 1);
#line 879
    child_val2 = rec_sex_eval_node(sex, record, tmp___132, status);
    }
#line 879
    if (! *status) {
#line 879
      return (res);
    }
#line 879
    goto while_break___70;
  }
  while_break___70: /* CIL Label */ ;
  }
  {
#line 881
  while (1) {
    while_continue___71: /* CIL Label */ ;
    {
#line 881
    if (child_val1.type == 0) {
#line 881
      goto case_0___42;
    }
#line 881
    if (child_val1.type == 2) {
#line 881
      goto case_2___42;
    }
#line 881
    goto switch_break___42;
    case_0___42: /* CIL Label */ 
#line 881
    op1___12 = child_val1.int_val;
#line 881
    goto switch_break___42;
    case_2___42: /* CIL Label */ 
    {
#line 881
    tmp___134 = strcmp((char const   *)child_val1.str_val, "");
    }
#line 881
    if (tmp___134 == 0) {
#line 881
      op1___12 = 0;
    } else {
      {
#line 881
      tmp___133 = rec_atoi((char const   *)child_val1.str_val, & op1___12);
      }
#line 881
      if (! tmp___133) {
#line 881
        *status = (_Bool)0;
#line 881
        return (res);
      }
    }
#line 881
    goto switch_break___42;
    switch_break___42: /* CIL Label */ ;
    }
#line 881
    goto while_break___71;
  }
  while_break___71: /* CIL Label */ ;
  }
  {
#line 882
  while (1) {
    while_continue___72: /* CIL Label */ ;
    {
#line 882
    if (child_val2.type == 0) {
#line 882
      goto case_0___43;
    }
#line 882
    if (child_val2.type == 2) {
#line 882
      goto case_2___43;
    }
#line 882
    goto switch_break___43;
    case_0___43: /* CIL Label */ 
#line 882
    op2___12 = child_val2.int_val;
#line 882
    goto switch_break___43;
    case_2___43: /* CIL Label */ 
    {
#line 882
    tmp___136 = strcmp((char const   *)child_val2.str_val, "");
    }
#line 882
    if (tmp___136 == 0) {
#line 882
      op2___12 = 0;
    } else {
      {
#line 882
      tmp___135 = rec_atoi((char const   *)child_val2.str_val, & op2___12);
      }
#line 882
      if (! tmp___135) {
#line 882
        *status = (_Bool)0;
#line 882
        return (res);
      }
    }
#line 882
    goto switch_break___43;
    switch_break___43: /* CIL Label */ ;
    }
#line 882
    goto while_break___72;
  }
  while_break___72: /* CIL Label */ ;
  }
#line 884
  res.type = 0;
#line 885
  if (op1___12) {
#line 885
    if (op2___12) {
#line 885
      tmp___137 = 1;
    } else {
#line 885
      tmp___137 = 0;
    }
  } else {
#line 885
    tmp___137 = 0;
  }
#line 885
  res.int_val = tmp___137;
#line 887
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 894
  while (1) {
    while_continue___73: /* CIL Label */ ;
    {
#line 894
    tmp___138 = rec_sex_ast_node_child(node, 0);
#line 894
    child_val1 = rec_sex_eval_node(sex, record, tmp___138, status);
    }
#line 894
    if (! *status) {
#line 894
      return (res);
    }
#line 894
    goto while_break___73;
  }
  while_break___73: /* CIL Label */ ;
  }
  {
#line 895
  while (1) {
    while_continue___74: /* CIL Label */ ;
    {
#line 895
    tmp___139 = rec_sex_ast_node_child(node, 1);
#line 895
    child_val2 = rec_sex_eval_node(sex, record, tmp___139, status);
    }
#line 895
    if (! *status) {
#line 895
      return (res);
    }
#line 895
    goto while_break___74;
  }
  while_break___74: /* CIL Label */ ;
  }
  {
#line 897
  while (1) {
    while_continue___75: /* CIL Label */ ;
    {
#line 897
    if (child_val1.type == 0) {
#line 897
      goto case_0___44;
    }
#line 897
    if (child_val1.type == 2) {
#line 897
      goto case_2___44;
    }
#line 897
    goto switch_break___44;
    case_0___44: /* CIL Label */ 
#line 897
    op1___13 = child_val1.int_val;
#line 897
    goto switch_break___44;
    case_2___44: /* CIL Label */ 
    {
#line 897
    tmp___141 = strcmp((char const   *)child_val1.str_val, "");
    }
#line 897
    if (tmp___141 == 0) {
#line 897
      op1___13 = 0;
    } else {
      {
#line 897
      tmp___140 = rec_atoi((char const   *)child_val1.str_val, & op1___13);
      }
#line 897
      if (! tmp___140) {
#line 897
        *status = (_Bool)0;
#line 897
        return (res);
      }
    }
#line 897
    goto switch_break___44;
    switch_break___44: /* CIL Label */ ;
    }
#line 897
    goto while_break___75;
  }
  while_break___75: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue___76: /* CIL Label */ ;
    {
#line 898
    if (child_val2.type == 0) {
#line 898
      goto case_0___45;
    }
#line 898
    if (child_val2.type == 2) {
#line 898
      goto case_2___45;
    }
#line 898
    goto switch_break___45;
    case_0___45: /* CIL Label */ 
#line 898
    op2___13 = child_val2.int_val;
#line 898
    goto switch_break___45;
    case_2___45: /* CIL Label */ 
    {
#line 898
    tmp___143 = strcmp((char const   *)child_val2.str_val, "");
    }
#line 898
    if (tmp___143 == 0) {
#line 898
      op2___13 = 0;
    } else {
      {
#line 898
      tmp___142 = rec_atoi((char const   *)child_val2.str_val, & op2___13);
      }
#line 898
      if (! tmp___142) {
#line 898
        *status = (_Bool)0;
#line 898
        return (res);
      }
    }
#line 898
    goto switch_break___45;
    switch_break___45: /* CIL Label */ ;
    }
#line 898
    goto while_break___76;
  }
  while_break___76: /* CIL Label */ ;
  }
#line 900
  res.type = 0;
#line 901
  if (op1___13) {
#line 901
    tmp___144 = 1;
  } else
#line 901
  if (op2___13) {
#line 901
    tmp___144 = 1;
  } else {
#line 901
    tmp___144 = 0;
  }
#line 901
  res.int_val = tmp___144;
#line 903
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 910
  while (1) {
    while_continue___77: /* CIL Label */ ;
    {
#line 910
    tmp___145 = rec_sex_ast_node_child(node, 0);
#line 910
    child_val1 = rec_sex_eval_node(sex, record, tmp___145, status);
    }
#line 910
    if (! *status) {
#line 910
      return (res);
    }
#line 910
    goto while_break___77;
  }
  while_break___77: /* CIL Label */ ;
  }
  {
#line 911
  while (1) {
    while_continue___78: /* CIL Label */ ;
    {
#line 911
    tmp___146 = rec_sex_ast_node_child(node, 1);
#line 911
    child_val2 = rec_sex_eval_node(sex, record, tmp___146, status);
    }
#line 911
    if (! *status) {
#line 911
      return (res);
    }
#line 911
    goto while_break___78;
  }
  while_break___78: /* CIL Label */ ;
  }
#line 913
  if (child_val1.type == 2) {
#line 913
    if (child_val2.type == 2) {
      {
#line 916
      str1_size = strlen((char const   *)child_val1.str_val);
#line 917
      str2_size = strlen((char const   *)child_val2.str_val);
#line 919
      res.type = 2;
#line 920
      tmp___147 = malloc((str1_size + str2_size) + 1UL);
#line 920
      res.str_val = (char *)tmp___147;
#line 921
      memcpy((void */* __restrict  */)res.str_val, (void const   */* __restrict  */)child_val1.str_val,
             str1_size);
#line 922
      memcpy((void */* __restrict  */)(res.str_val + str1_size), (void const   */* __restrict  */)child_val2.str_val,
             str2_size);
#line 923
      *(res.str_val + (str1_size + str2_size)) = (char )'\000';
      }
    } else {
#line 927
      *status = (_Bool)0;
#line 928
      return (res);
    }
  } else {
#line 927
    *status = (_Bool)0;
#line 928
    return (res);
  }
#line 931
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 937
  while (1) {
    while_continue___79: /* CIL Label */ ;
    {
#line 937
    tmp___148 = rec_sex_ast_node_child(node, 0);
#line 937
    child_val1 = rec_sex_eval_node(sex, record, tmp___148, status);
    }
#line 937
    if (! *status) {
#line 937
      return (res);
    }
#line 937
    goto while_break___79;
  }
  while_break___79: /* CIL Label */ ;
  }
  {
#line 938
  while (1) {
    while_continue___80: /* CIL Label */ ;
    {
#line 938
    if (child_val1.type == 0) {
#line 938
      goto case_0___46;
    }
#line 938
    if (child_val1.type == 2) {
#line 938
      goto case_2___46;
    }
#line 938
    goto switch_break___46;
    case_0___46: /* CIL Label */ 
#line 938
    op = child_val1.int_val;
#line 938
    goto switch_break___46;
    case_2___46: /* CIL Label */ 
    {
#line 938
    tmp___150 = strcmp((char const   *)child_val1.str_val, "");
    }
#line 938
    if (tmp___150 == 0) {
#line 938
      op = 0;
    } else {
      {
#line 938
      tmp___149 = rec_atoi((char const   *)child_val1.str_val, & op);
      }
#line 938
      if (! tmp___149) {
#line 938
        *status = (_Bool)0;
#line 938
        return (res);
      }
    }
#line 938
    goto switch_break___46;
    switch_break___46: /* CIL Label */ ;
    }
#line 938
    goto while_break___80;
  }
  while_break___80: /* CIL Label */ ;
  }
#line 940
  res.type = 0;
#line 941
  res.int_val = ! op;
#line 943
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 948
  field_name = (char const   *)((void *)0);
#line 949
  field_subname = (char const   *)((void *)0);
#line 953
  child = rec_sex_ast_node_child(node, 0);
#line 954
  tmp___151 = rec_sex_ast_node_child(node, 0);
#line 954
  tmp___152 = rec_sex_ast_node_type(tmp___151);
  }
#line 954
  if ((unsigned int )tmp___152 != 27U) {
#line 957
    *status = (_Bool)0;
#line 958
    return (res);
  }
  {
#line 961
  field_name = rec_sex_ast_node_name(child);
#line 962
  field_subname = rec_sex_ast_node_subname(child);
  }
#line 964
  if (field_subname) {
    {
#line 969
    tmp___153 = rec_concat_strings(field_name, "_", field_subname);
#line 969
    effective_name = tmp___153;
#line 972
    tmp___154 = rec_record_get_num_fields_by_name(record, (char const   *)effective_name);
#line 972
    n = (int )tmp___154;
#line 974
    free((void *)effective_name);
    }
  } else {
    {
#line 978
    tmp___155 = rec_record_get_num_fields_by_name(record, field_name);
#line 978
    n = (int )tmp___155;
    }
  }
#line 981
  res.type = 0;
#line 982
  res.int_val = n;
#line 983
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 989
  while (1) {
    while_continue___81: /* CIL Label */ ;
    {
#line 989
    tmp___156 = rec_sex_ast_node_child(node, 0);
#line 989
    child_val1 = rec_sex_eval_node(sex, record, tmp___156, status);
    }
#line 989
    if (! *status) {
#line 989
      return (res);
    }
#line 989
    goto while_break___81;
  }
  while_break___81: /* CIL Label */ ;
  }
  {
#line 990
  while (1) {
    while_continue___82: /* CIL Label */ ;
    {
#line 990
    tmp___157 = rec_sex_ast_node_child(node, 1);
#line 990
    child_val2 = rec_sex_eval_node(sex, record, tmp___157, status);
    }
#line 990
    if (! *status) {
#line 990
      return (res);
    }
#line 990
    goto while_break___82;
  }
  while_break___82: /* CIL Label */ ;
  }
  {
#line 991
  while (1) {
    while_continue___83: /* CIL Label */ ;
    {
#line 991
    tmp___158 = rec_sex_ast_node_child(node, 2);
#line 991
    child_val3 = rec_sex_eval_node(sex, record, tmp___158, status);
    }
#line 991
    if (! *status) {
#line 991
      return (res);
    }
#line 991
    goto while_break___83;
  }
  while_break___83: /* CIL Label */ ;
  }
  {
#line 994
  while (1) {
    while_continue___84: /* CIL Label */ ;
    {
#line 994
    if (child_val1.type == 0) {
#line 994
      goto case_0___47;
    }
#line 994
    if (child_val1.type == 2) {
#line 994
      goto case_2___47;
    }
#line 994
    goto switch_break___47;
    case_0___47: /* CIL Label */ 
#line 994
    op1___14 = child_val1.int_val;
#line 994
    goto switch_break___47;
    case_2___47: /* CIL Label */ 
    {
#line 994
    tmp___160 = strcmp((char const   *)child_val1.str_val, "");
    }
#line 994
    if (tmp___160 == 0) {
#line 994
      op1___14 = 0;
    } else {
      {
#line 994
      tmp___159 = rec_atoi((char const   *)child_val1.str_val, & op1___14);
      }
#line 994
      if (! tmp___159) {
#line 994
        *status = (_Bool)0;
#line 994
        return (res);
      }
    }
#line 994
    goto switch_break___47;
    switch_break___47: /* CIL Label */ ;
    }
#line 994
    goto while_break___84;
  }
  while_break___84: /* CIL Label */ ;
  }
#line 998
  if (op1___14) {
#line 1000
    res = child_val2;
  } else {
#line 1004
    res = child_val3;
  }
#line 1007
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 1012
  res.type = 0;
#line 1013
  res.int_val = rec_sex_ast_node_int(node);
  }
#line 1014
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 1018
  res.type = 1;
#line 1019
  res.real_val = rec_sex_ast_node_real(node);
  }
#line 1020
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 1024
  res.type = 2;
#line 1025
  res.str_val = rec_sex_ast_node_str(node);
  }
#line 1026
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 1036
  tmp___169 = rec_sex_ast_node_fixed(node);
  }
#line 1036
  if (tmp___169) {
    {
#line 1038
    res.type = 2;
#line 1039
    res.str_val = rec_sex_ast_node_fixed_val(node);
    }
  } else {
    {
#line 1043
    field_name___0 = rec_sex_ast_node_name(node);
#line 1044
    field_subname___0 = rec_sex_ast_node_subname(node);
#line 1045
    index___0 = rec_sex_ast_node_index(node);
#line 1046
    tofix = (_Bool )(index___0 != -1);
    }
#line 1047
    if (index___0 == -1) {
#line 1049
      index___0 = 0;
    }
#line 1057
    if (field_subname___0) {
      {
#line 1059
      tmp___161 = strlen(field_name___0);
#line 1059
      tmp___162 = strlen(field_subname___0);
#line 1059
      tmp___163 = malloc(sizeof(char ) * ((tmp___161 + tmp___162) + 2UL));
#line 1059
      effective_field_name = (char *)tmp___163;
#line 1061
      tmp___164 = strlen(field_name___0);
#line 1061
      memcpy((void */* __restrict  */)effective_field_name, (void const   */* __restrict  */)field_name___0,
             tmp___164);
#line 1062
      tmp___165 = strlen(field_name___0);
#line 1062
      *(effective_field_name + tmp___165) = (char )'_';
#line 1063
      tmp___166 = strlen(field_subname___0);
#line 1063
      tmp___167 = strlen(field_name___0);
#line 1063
      memcpy((void */* __restrict  */)((effective_field_name + tmp___167) + 1), (void const   */* __restrict  */)field_subname___0,
             tmp___166 + 1UL);
#line 1065
      field = rec_record_get_field_by_name(record, (char const   *)effective_field_name,
                                           (size_t )index___0);
      }
    } else {
      {
#line 1069
      field = rec_record_get_field_by_name(record, field_name___0, (size_t )index___0);
      }
    }
#line 1073
    res.type = 2;
#line 1074
    if (field) {
      {
#line 1076
      tmp___168 = rec_field_value(field);
#line 1076
      res.str_val = strdup(tmp___168);
      }
    } else {
#line 1081
      res.str_val = (char *)"";
    }
#line 1084
    if (tofix) {
      {
#line 1087
      rec_sex_ast_node_fix(node, res.str_val);
      }
    }
  }
#line 1091
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1095
  return (res);
}
}
#line 1098 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex.c"
static _Bool rec_sex_op_real_p(struct rec_sex_val_s op1 , struct rec_sex_val_s op2 ) 
{ 
  _Bool ret ;
  int integer ;
  double real ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
#line 1106
  ret = (_Bool)1;
#line 1108
  if (op1.type == 0) {
#line 1108
    goto _L;
  } else
#line 1108
  if (op1.type == 2) {
    {
#line 1108
    tmp___2 = rec_atoi((char const   *)op1.str_val, & integer);
    }
#line 1108
    if (tmp___2) {
      _L: /* CIL Label */ 
      {
#line 1115
      if (op2.type == 0) {
#line 1115
        goto case_0;
      }
#line 1120
      if (op2.type == 1) {
#line 1120
        goto case_1;
      }
#line 1125
      if (op2.type == 2) {
#line 1125
        goto case_2;
      }
#line 1131
      goto switch_default;
      case_0: /* CIL Label */ 
#line 1117
      ret = (_Bool)0;
#line 1118
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1122
      ret = (_Bool)1;
#line 1123
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1127
      tmp = rec_atod((char const   *)op2.str_val, & real);
      }
#line 1127
      if (tmp) {
        {
#line 1127
        tmp___0 = rec_atoi((char const   *)op2.str_val, & integer);
        }
#line 1127
        if (tmp___0) {
#line 1127
          tmp___1 = 0;
        } else {
#line 1127
          tmp___1 = 1;
        }
      } else {
#line 1127
        tmp___1 = 0;
      }
#line 1127
      ret = (_Bool )tmp___1;
#line 1129
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1133
      ret = (_Bool)0;
#line 1134
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 1139
  if (op1.type == 1) {
#line 1139
    goto _L___0;
  } else
#line 1139
  if (op1.type == 2) {
    {
#line 1139
    tmp___3 = rec_atod((char const   *)op1.str_val, & real);
    }
#line 1139
    if (tmp___3) {
      {
#line 1139
      tmp___4 = rec_atoi((char const   *)op1.str_val, & integer);
      }
#line 1139
      if (! tmp___4) {
        _L___0: /* CIL Label */ 
        {
#line 1147
        if (op2.type == 0) {
#line 1147
          goto case_0___0;
        }
#line 1152
        if (op2.type == 1) {
#line 1152
          goto case_1___0;
        }
#line 1157
        if (op2.type == 2) {
#line 1157
          goto case_2___0;
        }
#line 1162
        goto switch_default___0;
        case_0___0: /* CIL Label */ 
#line 1149
        ret = (_Bool)1;
#line 1150
        goto switch_break___0;
        case_1___0: /* CIL Label */ 
#line 1154
        ret = (_Bool)1;
#line 1155
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        {
#line 1159
        ret = rec_atod((char const   *)op2.str_val, & real);
        }
#line 1160
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 1164
        ret = (_Bool)0;
#line 1165
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 1170
  return (ret);
}
}
#line 652 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 565 "rec-sex-lex.c"
void sexrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 566
void sex_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 567
YY_BUFFER_STATE sex_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 568
void sex_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 569
void sex_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 570
void sexpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 571
void sexpop_buffer_state(yyscan_t yyscanner ) ;
#line 573
static void sexensure_buffer_stack(yyscan_t yyscanner ) ;
#line 574
static void sex_load_buffer_state(yyscan_t yyscanner ) ;
#line 575
static void sex_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 578
YY_BUFFER_STATE sex_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 579
YY_BUFFER_STATE sex_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 580
YY_BUFFER_STATE sex_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 584
void *sexalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 585
void *sexrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 586
void sexfree(void *ptr , yyscan_t yyscanner ) ;
#line 626
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) ;
#line 627
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 628
static int yy_get_next_buffer(yyscan_t yyscanner ) ;
#line 629
static  __attribute__((__noreturn__)) void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) ;
#line 654 "rec-sex-lex.c"
static flex_int16_t const   yy_accept[64]  = 
#line 654
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )33, 
        (flex_int16_t const   )31,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )17, 
        (flex_int16_t const   )31,      (flex_int16_t const   )25,      (flex_int16_t const   )7,      (flex_int16_t const   )28, 
        (flex_int16_t const   )31,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )14, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )31,      (flex_int16_t const   )6, 
        (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )27,      (flex_int16_t const   )20, 
        (flex_int16_t const   )15,      (flex_int16_t const   )19,      (flex_int16_t const   )26,      (flex_int16_t const   )29, 
        (flex_int16_t const   )31,      (flex_int16_t const   )18,      (flex_int16_t const   )16,      (flex_int16_t const   )0, 
        (flex_int16_t const   )30,      (flex_int16_t const   )0,      (flex_int16_t const   )23,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )3, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )11,      (flex_int16_t const   )8, 
        (flex_int16_t const   )0,      (flex_int16_t const   )29,      (flex_int16_t const   )0,      (flex_int16_t const   )24, 
        (flex_int16_t const   )0,      (flex_int16_t const   )30,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )30,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )29, 
        (flex_int16_t const   )0,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )0};
#line 665 "rec-sex-lex.c"
static YY_CHAR const   yy_ec[256]  = 
#line 665
  {      (YY_CHAR const   )0,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )2,      (YY_CHAR const   )3,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )2,      (YY_CHAR const   )4,      (YY_CHAR const   )5,      (YY_CHAR const   )6, 
        (YY_CHAR const   )1,      (YY_CHAR const   )7,      (YY_CHAR const   )8,      (YY_CHAR const   )9, 
        (YY_CHAR const   )10,      (YY_CHAR const   )11,      (YY_CHAR const   )12,      (YY_CHAR const   )13, 
        (YY_CHAR const   )1,      (YY_CHAR const   )14,      (YY_CHAR const   )15,      (YY_CHAR const   )16, 
        (YY_CHAR const   )17,      (YY_CHAR const   )18,      (YY_CHAR const   )18,      (YY_CHAR const   )18, 
        (YY_CHAR const   )18,      (YY_CHAR const   )18,      (YY_CHAR const   )18,      (YY_CHAR const   )18, 
        (YY_CHAR const   )18,      (YY_CHAR const   )18,      (YY_CHAR const   )19,      (YY_CHAR const   )1, 
        (YY_CHAR const   )20,      (YY_CHAR const   )21,      (YY_CHAR const   )22,      (YY_CHAR const   )23, 
        (YY_CHAR const   )1,      (YY_CHAR const   )24,      (YY_CHAR const   )24,      (YY_CHAR const   )24, 
        (YY_CHAR const   )24,      (YY_CHAR const   )24,      (YY_CHAR const   )24,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )26, 
        (YY_CHAR const   )27,      (YY_CHAR const   )28,      (YY_CHAR const   )1,      (YY_CHAR const   )29, 
        (YY_CHAR const   )1,      (YY_CHAR const   )24,      (YY_CHAR const   )24,      (YY_CHAR const   )24, 
        (YY_CHAR const   )24,      (YY_CHAR const   )24,      (YY_CHAR const   )24,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25, 
        (YY_CHAR const   )30,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )1, 
        (YY_CHAR const   )31,      (YY_CHAR const   )1,      (YY_CHAR const   )32,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1};
#line 697 "rec-sex-lex.c"
static YY_CHAR const   yy_meta[33]  = 
#line 697
  {      (YY_CHAR const   )0,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )2, 
        (YY_CHAR const   )1,      (YY_CHAR const   )3,      (YY_CHAR const   )3,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1, 
        (YY_CHAR const   )3,      (YY_CHAR const   )3,      (YY_CHAR const   )3,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1,      (YY_CHAR const   )3,      (YY_CHAR const   )3,      (YY_CHAR const   )1, 
        (YY_CHAR const   )1};
#line 705 "rec-sex-lex.c"
static flex_int16_t const   yy_base[70]  = 
#line 705
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )105, 
        (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )83, 
        (flex_int16_t const   )28,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )94, 
        (flex_int16_t const   )25,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )127,      (flex_int16_t const   )20,      (flex_int16_t const   )22,      (flex_int16_t const   )127, 
        (flex_int16_t const   )26,      (flex_int16_t const   )30,      (flex_int16_t const   )127,      (flex_int16_t const   )29, 
        (flex_int16_t const   )32,      (flex_int16_t const   )36,      (flex_int16_t const   )127,      (flex_int16_t const   )36, 
        (flex_int16_t const   )69,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )37, 
        (flex_int16_t const   )127,      (flex_int16_t const   )41,      (flex_int16_t const   )127,      (flex_int16_t const   )50, 
        (flex_int16_t const   )51,      (flex_int16_t const   )48,      (flex_int16_t const   )52,      (flex_int16_t const   )56, 
        (flex_int16_t const   )58,      (flex_int16_t const   )62,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )59,      (flex_int16_t const   )46,      (flex_int16_t const   )70,      (flex_int16_t const   )127, 
        (flex_int16_t const   )58,      (flex_int16_t const   )76,      (flex_int16_t const   )85,      (flex_int16_t const   )82, 
        (flex_int16_t const   )83,      (flex_int16_t const   )84,      (flex_int16_t const   )77,      (flex_int16_t const   )73, 
        (flex_int16_t const   )79,      (flex_int16_t const   )72,      (flex_int16_t const   )127,      (flex_int16_t const   )127, 
        (flex_int16_t const   )112,      (flex_int16_t const   )115,      (flex_int16_t const   )117,      (flex_int16_t const   )120, 
        (flex_int16_t const   )123,      (flex_int16_t const   )33};
#line 716 "rec-sex-lex.c"
static flex_int16_t const   yy_def[70]  = 
#line 716
  {      (flex_int16_t const   )0,      (flex_int16_t const   )63,      (flex_int16_t const   )1,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )64,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )65,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )66, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )64, 
        (flex_int16_t const   )63,      (flex_int16_t const   )67,      (flex_int16_t const   )63,      (flex_int16_t const   )65, 
        (flex_int16_t const   )68,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )66,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )64,      (flex_int16_t const   )64,      (flex_int16_t const   )67,      (flex_int16_t const   )65, 
        (flex_int16_t const   )65,      (flex_int16_t const   )68,      (flex_int16_t const   )63,      (flex_int16_t const   )69, 
        (flex_int16_t const   )63,      (flex_int16_t const   )69,      (flex_int16_t const   )63,      (flex_int16_t const   )0, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63};
#line 727 "rec-sex-lex.c"
static flex_int16_t const   yy_nxt[160]  = 
#line 727
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22, 
        (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )4,      (flex_int16_t const   )4, 
        (flex_int16_t const   )4,      (flex_int16_t const   )4,      (flex_int16_t const   )27,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )32,      (flex_int16_t const   )32,      (flex_int16_t const   )37, 
        (flex_int16_t const   )61,      (flex_int16_t const   )38,      (flex_int16_t const   )39,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )37,      (flex_int16_t const   )32,      (flex_int16_t const   )39, 
        (flex_int16_t const   )39,      (flex_int16_t const   )37,      (flex_int16_t const   )53,      (flex_int16_t const   )39, 
        (flex_int16_t const   )39,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )48, 
        (flex_int16_t const   )36,      (flex_int16_t const   )44,      (flex_int16_t const   )45,      (flex_int16_t const   )33, 
        (flex_int16_t const   )41,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )32, 
        (flex_int16_t const   )56,      (flex_int16_t const   )48,      (flex_int16_t const   )50,      (flex_int16_t const   )32, 
        (flex_int16_t const   )33,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )37, 
        (flex_int16_t const   )54,      (flex_int16_t const   )39,      (flex_int16_t const   )39,      (flex_int16_t const   )37, 
        (flex_int16_t const   )50,      (flex_int16_t const   )39,      (flex_int16_t const   )39,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )36,      (flex_int16_t const   )57,      (flex_int16_t const   )58, 
        (flex_int16_t const   )58,      (flex_int16_t const   )32,      (flex_int16_t const   )41,      (flex_int16_t const   )59, 
        (flex_int16_t const   )59,      (flex_int16_t const   )33,      (flex_int16_t const   )58,      (flex_int16_t const   )60, 
        (flex_int16_t const   )60,      (flex_int16_t const   )59,      (flex_int16_t const   )53,      (flex_int16_t const   )32, 
        (flex_int16_t const   )32,      (flex_int16_t const   )56,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )50,      (flex_int16_t const   )50, 
        (flex_int16_t const   )51,      (flex_int16_t const   )58,      (flex_int16_t const   )34,      (flex_int16_t const   )33, 
        (flex_int16_t const   )30,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )62, 
        (flex_int16_t const   )63,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )57, 
        (flex_int16_t const   )54,      (flex_int16_t const   )31,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )35,      (flex_int16_t const   )49, 
        (flex_int16_t const   )49,      (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )52, 
        (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )55,      (flex_int16_t const   )3, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63};
#line 748 "rec-sex-lex.c"
static flex_int16_t const   yy_chk[160]  = 
#line 748
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )8,      (flex_int16_t const   )12,      (flex_int16_t const   )17, 
        (flex_int16_t const   )69,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )20,      (flex_int16_t const   )31,      (flex_int16_t const   )20, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )33,      (flex_int16_t const   )21, 
        (flex_int16_t const   )21,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )27, 
        (flex_int16_t const   )12,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )8, 
        (flex_int16_t const   )20,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )35, 
        (flex_int16_t const   )36,      (flex_int16_t const   )49,      (flex_int16_t const   )27,      (flex_int16_t const   )52, 
        (flex_int16_t const   )31,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )38, 
        (flex_int16_t const   )33,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )39, 
        (flex_int16_t const   )49,      (flex_int16_t const   )39,      (flex_int16_t const   )39,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )35,      (flex_int16_t const   )36,      (flex_int16_t const   )41, 
        (flex_int16_t const   )41,      (flex_int16_t const   )53,      (flex_int16_t const   )38,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )52,      (flex_int16_t const   )41,      (flex_int16_t const   )50, 
        (flex_int16_t const   )50,      (flex_int16_t const   )48,      (flex_int16_t const   )54,      (flex_int16_t const   )55, 
        (flex_int16_t const   )56,      (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )61,      (flex_int16_t const   )59, 
        (flex_int16_t const   )28,      (flex_int16_t const   )58,      (flex_int16_t const   )11,      (flex_int16_t const   )53, 
        (flex_int16_t const   )7,      (flex_int16_t const   )3,      (flex_int16_t const   )0,      (flex_int16_t const   )60, 
        (flex_int16_t const   )0,      (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )54,      (flex_int16_t const   )64,      (flex_int16_t const   )64,      (flex_int16_t const   )64, 
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63, 
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63};
#line 769 "rec-sex-lex.c"
static flex_int16_t const   yy_rule_linenum[32]  = 
#line 769
  {      (flex_int16_t const   )0,      (flex_int16_t const   )83,      (flex_int16_t const   )85,      (flex_int16_t const   )98, 
        (flex_int16_t const   )111,      (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )114, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )117,      (flex_int16_t const   )118, 
        (flex_int16_t const   )119,      (flex_int16_t const   )120,      (flex_int16_t const   )121,      (flex_int16_t const   )122, 
        (flex_int16_t const   )123,      (flex_int16_t const   )124,      (flex_int16_t const   )125,      (flex_int16_t const   )126, 
        (flex_int16_t const   )127,      (flex_int16_t const   )128,      (flex_int16_t const   )129,      (flex_int16_t const   )130, 
        (flex_int16_t const   )131,      (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )134, 
        (flex_int16_t const   )135,      (flex_int16_t const   )137,      (flex_int16_t const   )160,      (flex_int16_t const   )174};
#line 89 "./rec-sex-ast.h"
rec_sex_ast_node_t rec_sex_ast_node_new(void) ;
#line 97
void rec_sex_ast_node_set_int(rec_sex_ast_node_t node , int num ) ;
#line 99
void rec_sex_ast_node_set_real(rec_sex_ast_node_t node , double num ) ;
#line 101
void rec_sex_ast_node_set_str(rec_sex_ast_node_t node , char *str ) ;
#line 104
void rec_sex_ast_node_set_name(rec_sex_ast_node_t node , char const   *name , char const   *subname ) ;
#line 116
void rec_sex_ast_node_set_index(rec_sex_ast_node_t node , int index___0 ) ;
#line 51 "./rec-sex-parser.h"
int rec_sex_parser_getc(rec_sex_parser_t parser ) ;
#line 66 "../../src/rec-sex-lex.l"
char *rec_sex_lex_extract_name(char *str ) ;
#line 67
char *rec_sex_lex_extract_subname(char *str ) ;
#line 68
_Bool rec_sex_lex_extract_index(char *str , int *num ) ;
#line 782 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 898 "rec-sex-lex.c"
static int yy_init_globals(yyscan_t yyscanner ) ;
#line 908
int sexlex_init(yyscan_t *ptr_yy_globals ) ;
#line 910
int sexlex_init_extra(void *yy_user_defined , yyscan_t *ptr_yy_globals ) ;
#line 919
int sexlex_destroy(yyscan_t yyscanner ) ;
#line 921
int sexget_debug(yyscan_t yyscanner ) ;
#line 923
void sexset_debug(int _bdebug , yyscan_t yyscanner ) ;
#line 925
void *sexget_extra(yyscan_t yyscanner ) ;
#line 927
void sexset_extra(void *user_defined , yyscan_t yyscanner ) ;
#line 929
FILE *sexget_in(yyscan_t yyscanner ) ;
#line 931
void sexset_in(FILE *_in_str , yyscan_t yyscanner ) ;
#line 933
FILE *sexget_out(yyscan_t yyscanner ) ;
#line 935
void sexset_out(FILE *_out_str , yyscan_t yyscanner ) ;
#line 937
int sexget_leng(yyscan_t yyscanner ) ;
#line 939
char *sexget_text(yyscan_t yyscanner ) ;
#line 941
int sexget_lineno(yyscan_t yyscanner ) ;
#line 943
void sexset_lineno(int _line_number , yyscan_t yyscanner ) ;
#line 945
int sexget_column(yyscan_t yyscanner ) ;
#line 947
void sexset_column(int _column_no , yyscan_t yyscanner ) ;
#line 951
YYSTYPE___0 *sexget_lval(yyscan_t yyscanner ) ;
#line 953
void sexset_lval(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) ;
#line 1103
int sexlex(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) ;
#line 1132 "rec-sex-lex.c"
int sexlex(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) 
{ 
  yy_state_type yy_current_state ;
  char *yy_cp ;
  char *yy_bp ;
  int yy_act ;
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_CHAR yy_c ;
  double real_value ;
  int integer_value ;
  int res ;
  char *match ;
  char *name ;
  char *subname ;
  int index___0 ;
  size_t tmp___0 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___1 ;

  {
#line 1137
  yyg = (struct yyguts_t *)yyscanner;
#line 1139
  yyg->yylval_r = yylval_param;
#line 1141
  if (! yyg->yy_init) {
#line 1143
    yyg->yy_init = 1;
#line 1149
    if (! yyg->yy_start) {
#line 1150
      yyg->yy_start = 1;
    }
#line 1152
    if (! yyg->yyin_r) {
#line 1154
      yyg->yyin_r = stdin;
    }
#line 1159
    if (! yyg->yyout_r) {
#line 1161
      yyg->yyout_r = stdout;
    }
#line 1166
    if (yyg->yy_buffer_stack) {
#line 1166
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 1166
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1166
    if (! tmp) {
      {
#line 1167
      sexensure_buffer_stack(yyscanner);
#line 1168
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = sex_create_buffer(yyg->yyin_r,
                                                                             16384,
                                                                             yyscanner);
      }
    }
    {
#line 1172
    sex_load_buffer_state(yyscanner);
    }
  }
  {
#line 1182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1185
    yy_cp = yyg->yy_c_buf_p;
#line 1188
    *yy_cp = yyg->yy_hold_char;
#line 1193
    yy_bp = yy_cp;
#line 1196
    yy_current_state = yyg->yy_start;
    yy_match: 
    {
#line 1198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1200
      yy_c = (YY_CHAR )yy_ec[(YY_CHAR )*yy_cp];
#line 1201
      if (yy_accept[yy_current_state]) {
#line 1203
        yyg->yy_last_accepting_state = yy_current_state;
#line 1204
        yyg->yy_last_accepting_cpos = yy_cp;
      }
      {
#line 1206
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1206
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1206
          goto while_break___1;
        }
#line 1208
        yy_current_state = (int )yy_def[yy_current_state];
#line 1209
        if (yy_current_state >= 64) {
#line 1210
          yy_c = (YY_CHAR )yy_meta[yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1212
      yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
#line 1213
      yy_cp ++;
#line 1198
      if (! ((int const   )yy_base[yy_current_state] != 127)) {
#line 1198
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1219
    yy_act = (int )yy_accept[yy_current_state];
#line 1220
    if (yy_act == 0) {
#line 1222
      yy_cp = yyg->yy_last_accepting_cpos;
#line 1223
      yy_current_state = yyg->yy_last_accepting_state;
#line 1224
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 1227
    yyg->yytext_r = yy_bp;
#line 1227
    yyg->yyleng_r = (int )(yy_cp - yy_bp);
#line 1227
    yyg->yy_hold_char = *yy_cp;
#line 1227
    *yy_cp = (char )'\000';
#line 1227
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
#line 1234
    if (yyg->yy_flex_debug_r) {
#line 1236
      if (yy_act == 0) {
        {
#line 1237
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--scanner backing up\n");
        }
      } else
#line 1238
      if (yy_act < 32) {
        {
#line 1239
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting rule at line %ld (\"%s\")\n",
                (long )yy_rule_linenum[yy_act], yyg->yytext_r);
        }
      } else
#line 1241
      if (yy_act == 32) {
        {
#line 1242
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--accepting default rule (\"%s\")\n",
                yyg->yytext_r);
        }
      } else
#line 1244
      if (yy_act == 33) {
        {
#line 1245
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--(end of buffer or a NUL)\n");
        }
      } else {
        {
#line 1247
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"--EOF (start condition %d)\n",
                (yyg->yy_start - 1) / 2);
        }
      }
    }
    {
#line 1253
    if (yy_act == 0) {
#line 1253
      goto case_0;
    }
#line 1260
    if (yy_act == 1) {
#line 1260
      goto case_1;
    }
#line 85
    if (yy_act == 2) {
#line 85 "../../src/rec-sex-lex.l"
      goto case_2;
    }
#line 98
    if (yy_act == 3) {
#line 98
      goto case_3;
    }
#line 111
    if (yy_act == 4) {
#line 111
      goto case_4;
    }
#line 113
    if (yy_act == 5) {
#line 113
      goto case_5;
    }
#line 114
    if (yy_act == 6) {
#line 114
      goto case_6;
    }
#line 115
    if (yy_act == 7) {
#line 115
      goto case_7;
    }
#line 116
    if (yy_act == 8) {
#line 116
      goto case_8;
    }
#line 117
    if (yy_act == 9) {
#line 117
      goto case_9;
    }
#line 118
    if (yy_act == 10) {
#line 118
      goto case_10;
    }
#line 119
    if (yy_act == 11) {
#line 119
      goto case_11;
    }
#line 120
    if (yy_act == 12) {
#line 120
      goto case_12;
    }
#line 121
    if (yy_act == 13) {
#line 121
      goto case_13;
    }
#line 122
    if (yy_act == 14) {
#line 122
      goto case_14;
    }
#line 123
    if (yy_act == 15) {
#line 123
      goto case_15;
    }
#line 124
    if (yy_act == 16) {
#line 124
      goto case_16;
    }
#line 125
    if (yy_act == 17) {
#line 125
      goto case_17;
    }
#line 126
    if (yy_act == 18) {
#line 126
      goto case_18;
    }
#line 127
    if (yy_act == 19) {
#line 127
      goto case_19;
    }
#line 128
    if (yy_act == 20) {
#line 128
      goto case_20;
    }
#line 129
    if (yy_act == 21) {
#line 129
      goto case_21;
    }
#line 130
    if (yy_act == 22) {
#line 130
      goto case_22;
    }
#line 131
    if (yy_act == 23) {
#line 131
      goto case_23;
    }
#line 132
    if (yy_act == 24) {
#line 132
      goto case_24;
    }
#line 133
    if (yy_act == 25) {
#line 133
      goto case_25;
    }
#line 134
    if (yy_act == 26) {
#line 134
      goto case_26;
    }
#line 135
    if (yy_act == 27) {
#line 135
      goto case_27;
    }
#line 136
    if (yy_act == 28) {
#line 136
      goto case_28;
    }
#line 137
    if (yy_act == 29) {
#line 137
      goto case_29;
    }
#line 160
    if (yy_act == 30) {
#line 160
      goto case_30;
    }
#line 174
    if (yy_act == 31) {
#line 174
      goto case_31;
    }
#line 176
    if (yy_act == 32) {
#line 176
      goto case_32;
    }
#line 1478
    if (yy_act == 34) {
#line 1478 "rec-sex-lex.c"
      goto case_34;
    }
#line 1481
    if (yy_act == 33) {
#line 1481
      goto case_33;
    }
#line 1608
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1255
    *yy_cp = yyg->yy_hold_char;
#line 1256
    yy_cp = yyg->yy_last_accepting_cpos;
#line 1257
    yy_current_state = yyg->yy_last_accepting_state;
#line 1258
    goto yy_find_action;
    case_1: /* CIL Label */ ;
#line 84 "../../src/rec-sex-lex.l"
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 91
    (yyg->yylval_r)->node = rec_sex_ast_node_new();
#line 92
    rec_atod((char const   *)yyg->yytext_r, & real_value);
#line 93
    rec_sex_ast_node_set_real((yyg->yylval_r)->node, real_value);
    }
#line 95
    return (259);
#line 97
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 104
    (yyg->yylval_r)->node = rec_sex_ast_node_new();
#line 105
    rec_atoi((char const   *)yyg->yytext_r, & integer_value);
#line 106
    rec_sex_ast_node_set_int((yyg->yylval_r)->node, integer_value);
    }
#line 108
    return (258);
#line 110
    goto switch_break;
    case_4: /* CIL Label */ 
#line 111
    return (277);
#line 112
    goto switch_break;
    case_5: /* CIL Label */ 
#line 112
    return (276);
#line 113
    goto switch_break;
    case_6: /* CIL Label */ 
#line 113
    return (279);
#line 114
    goto switch_break;
    case_7: /* CIL Label */ 
#line 114
    return (280);
#line 115
    goto switch_break;
    case_8: /* CIL Label */ 
#line 115
    return (274);
#line 116
    goto switch_break;
    case_9: /* CIL Label */ 
#line 116
    return (275);
#line 117
    goto switch_break;
    case_10: /* CIL Label */ 
#line 117
    return (271);
#line 118
    goto switch_break;
    case_11: /* CIL Label */ 
#line 118
    return (272);
#line 119
    goto switch_break;
    case_12: /* CIL Label */ 
#line 119
    return (273);
#line 120
    goto switch_break;
    case_13: /* CIL Label */ 
#line 120
    return (264);
#line 121
    goto switch_break;
    case_14: /* CIL Label */ 
#line 121
    return (278);
#line 122
    goto switch_break;
    case_15: /* CIL Label */ 
#line 122
    return (267);
#line 123
    goto switch_break;
    case_16: /* CIL Label */ 
#line 123
    return (268);
#line 124
    goto switch_break;
    case_17: /* CIL Label */ 
#line 124
    return (285);
#line 125
    goto switch_break;
    case_18: /* CIL Label */ 
#line 125
    return (281);
#line 126
    goto switch_break;
    case_19: /* CIL Label */ 
#line 126
    return (270);
#line 127
    goto switch_break;
    case_20: /* CIL Label */ 
#line 127
    return (269);
#line 128
    goto switch_break;
    case_21: /* CIL Label */ 
#line 128
    return (286);
#line 129
    goto switch_break;
    case_22: /* CIL Label */ 
#line 129
    return (287);
#line 130
    goto switch_break;
    case_23: /* CIL Label */ 
#line 130
    return (265);
#line 131
    goto switch_break;
    case_24: /* CIL Label */ 
#line 131
    return (266);
#line 132
    goto switch_break;
    case_25: /* CIL Label */ 
#line 132
    return (289);
#line 133
    goto switch_break;
    case_26: /* CIL Label */ 
#line 133
    return (263);
#line 134
    goto switch_break;
    case_27: /* CIL Label */ 
#line 134
    return (262);
#line 135
    goto switch_break;
    case_28: /* CIL Label */ 
#line 135
    return (282);
#line 136
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 141
    index___0 = -1;
#line 143
    match = strdup((char const   *)yyg->yytext_r);
#line 144
    rec_sex_lex_extract_index(match, & index___0);
#line 145
    name = rec_sex_lex_extract_name(match);
#line 146
    subname = rec_sex_lex_extract_subname(match);
#line 149
    (yyg->yylval_r)->node = rec_sex_ast_node_new();
#line 150
    rec_sex_ast_node_set_name((yyg->yylval_r)->node, (char const   *)name, (char const   *)subname);
#line 151
    rec_sex_ast_node_set_index((yyg->yylval_r)->node, index___0);
#line 152
    res = 261;
#line 154
    free((void *)name);
#line 155
    free((void *)match);
    }
#line 157
    return (res);
#line 159
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 166
    tmp___0 = strlen((char const   *)yyg->yytext_r);
#line 166
    *(yyg->yytext_r + (tmp___0 - 1UL)) = (char)0;
#line 168
    (yyg->yylval_r)->node = rec_sex_ast_node_new();
#line 169
    rec_sex_ast_node_set_str((yyg->yylval_r)->node, yyg->yytext_r + 1);
    }
#line 171
    return (260);
#line 173
    goto switch_break;
    case_31: /* CIL Label */ 
#line 174
    return (288);
#line 175
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 176
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 176
      fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
             (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
      }
#line 176
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 177
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1479 "rec-sex-lex.c"
    return (0);
    case_33: /* CIL Label */ 
#line 1484
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 1487
    *yy_cp = yyg->yy_hold_char;
#line 1490
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1501
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 1503
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 1507
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1517
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 1521
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1523
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1534
      yy_next_state = yy_try_NUL_trans(yy_current_state, yyscanner);
#line 1536
      yy_bp = yyg->yytext_r + 0;
      }
#line 1538
      if (yy_next_state) {
#line 1541
        (yyg->yy_c_buf_p) ++;
#line 1541
        yy_cp = yyg->yy_c_buf_p;
#line 1542
        yy_current_state = yy_next_state;
#line 1543
        goto yy_match;
      } else {
#line 1549
        yy_cp = yyg->yy_c_buf_p;
#line 1550
        goto yy_find_action;
      }
    } else {
      {
#line 1554
      tmp___1 = yy_get_next_buffer(yyscanner);
      }
      {
#line 1556
      if (tmp___1 == 1) {
#line 1556
        goto case_1___0;
      }
#line 1585
      if (tmp___1 == 0) {
#line 1585
        goto case_0___0;
      }
#line 1595
      if (tmp___1 == 2) {
#line 1595
        goto case_2___0;
      }
#line 1554
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1558
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 1571
      yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 1573
      yy_act = (33 + (yyg->yy_start - 1) / 2) + 1;
#line 1574
      goto do_action;
#line 1582
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1586
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1589
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1591
      yy_cp = yyg->yy_c_buf_p;
#line 1592
      yy_bp = yyg->yytext_r + 0;
      }
#line 1593
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1596
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 1599
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1601
      yy_cp = yyg->yy_c_buf_p;
#line 1602
      yy_bp = yyg->yytext_r + 0;
      }
#line 1603
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1605
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1609
    yy_fatal_error("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1631 "rec-sex-lex.c"
static int yy_get_next_buffer(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  char *dest ;
  char *source ;
  int number_to_move ;
  int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int ci ;
  int new_size___0 ;
  void *tmp___3 ;

  {
#line 1636
  yyg = (struct yyguts_t *)yyscanner;
#line 1637
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 1638
  source = yyg->yytext_r;
#line 1642
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 1643
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed", yyscanner);
    }
  }
#line 1646
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1648
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 1653
      return (1);
    } else {
#line 1661
      return (2);
    }
  }
#line 1668
  number_to_move = (int )((yyg->yy_c_buf_p - yyg->yytext_r) - 1L);
#line 1670
  i = 0;
  {
#line 1670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1670
    if (! (i < number_to_move)) {
#line 1670
      goto while_break;
    }
#line 1671
    tmp = dest;
#line 1671
    dest ++;
#line 1671
    tmp___0 = source;
#line 1671
    source ++;
#line 1671
    *tmp = *tmp___0;
#line 1670
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1673
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1677
    tmp___1 = 0;
#line 1677
    yyg->yy_n_chars = tmp___1;
#line 1677
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 1681
    num_to_read = ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - number_to_move) - 1;
    {
#line 1684
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1684
      if (! (num_to_read <= 0)) {
#line 1684
        goto while_break___0;
      }
#line 1688
      b = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
#line 1690
      yy_c_buf_p_offset = (int )(yyg->yy_c_buf_p - b->yy_ch_buf);
#line 1693
      if (b->yy_is_our_buffer) {
#line 1695
        new_size = b->yy_buf_size * 2;
#line 1697
        if (new_size <= 0) {
#line 1698
          b->yy_buf_size += b->yy_buf_size / 8;
        } else {
#line 1700
          b->yy_buf_size *= 2;
        }
        {
#line 1702
        tmp___2 = sexrealloc((void *)b->yy_ch_buf, (yy_size_t )(b->yy_buf_size + 2),
                             yyscanner);
#line 1702
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1709
        b->yy_ch_buf = (char *)((void *)0);
      }
#line 1711
      if (! b->yy_ch_buf) {
        {
#line 1712
        yy_fatal_error("fatal error - scanner input buffer overflow", yyscanner);
        }
      }
#line 1715
      yyg->yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1717
      num_to_read = ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - number_to_move) - 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1722
    if (num_to_read > 8192) {
#line 1723
      num_to_read = 8192;
    }
    {
#line 1726
    ci = rec_sex_parser_getc((rec_sex_parser_t )yyg->yyextra_r);
    }
#line 1726
    if (ci == -1) {
#line 1726
      yyg->yy_n_chars = 0;
    } else {
#line 1726
      *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + 0) = (char )ci;
#line 1726
      yyg->yy_n_chars = 1;
    }
#line 1729
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 1732
  if (yyg->yy_n_chars == 0) {
#line 1734
    if (number_to_move == 0) {
      {
#line 1736
      ret_val = 1;
#line 1737
      sexrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 1742
      ret_val = 2;
#line 1743
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1749
    ret_val = 0;
  }
#line 1751
  if (yyg->yy_n_chars + number_to_move > (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1753
    new_size___0 = (yyg->yy_n_chars + number_to_move) + (yyg->yy_n_chars >> 1);
#line 1754
    tmp___3 = sexrealloc((void *)(*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf,
                         (yy_size_t )new_size___0, yyscanner);
#line 1754
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___3;
    }
#line 1756
    if (! (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1757
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()", yyscanner);
      }
    }
#line 1759
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size = new_size___0 - 2;
  }
#line 1762
  yyg->yy_n_chars += number_to_move;
#line 1763
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 1764
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 1766
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1768
  return (ret_val);
}
}
#line 1775 "rec-sex-lex.c"
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) 
{ 
  yy_state_type yy_current_state ;
  char *yy_cp ;
  struct yyguts_t *yyg ;
  YY_CHAR yy_c ;
  int tmp ;

  {
#line 1782
  yyg = (struct yyguts_t *)yyscanner;
#line 1785
  yy_current_state = yyg->yy_start;
#line 1787
  yy_cp = yyg->yytext_r + 0;
  {
#line 1787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1787
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 1787
      goto while_break;
    }
#line 1790
    if (*yy_cp) {
#line 1790
      tmp = (int const   )yy_ec[(YY_CHAR )*yy_cp];
    } else {
#line 1790
      tmp = (int const   )1;
    }
#line 1790
    yy_c = (YY_CHAR )tmp;
#line 1791
    if (yy_accept[yy_current_state]) {
#line 1793
      yyg->yy_last_accepting_state = yy_current_state;
#line 1794
      yyg->yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1796
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1796
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1796
        goto while_break___0;
      }
#line 1798
      yy_current_state = (int )yy_def[yy_current_state];
#line 1799
      if (yy_current_state >= 64) {
#line 1800
        yy_c = (YY_CHAR )yy_meta[yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1802
    yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
#line 1787
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1805
  return (yy_current_state);
}
}
#line 1814 "rec-sex-lex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  int yy_is_jam ;
  struct yyguts_t *yyg ;
  char *yy_cp ;
  YY_CHAR yy_c ;
  int tmp ;

  {
#line 1820
  yyg = (struct yyguts_t *)yyscanner;
#line 1822
  yy_cp = yyg->yy_c_buf_p;
#line 1824
  yy_c = (YY_CHAR )1;
#line 1825
  if (yy_accept[yy_current_state]) {
#line 1827
    yyg->yy_last_accepting_state = yy_current_state;
#line 1828
    yyg->yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1830
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1830
      goto while_break;
    }
#line 1832
    yy_current_state = (int )yy_def[yy_current_state];
#line 1833
    if (yy_current_state >= 64) {
#line 1834
      yy_c = (YY_CHAR )yy_meta[yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1836
  yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
#line 1837
  yy_is_jam = yy_current_state == 63;
#line 1840
  if (yy_is_jam) {
#line 1840
    tmp = 0;
  } else {
#line 1840
    tmp = yy_current_state;
  }
#line 1840
  return (tmp);
}
}
#line 1938 "rec-sex-lex.c"
void sexrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1943
  yyg = (struct yyguts_t *)yyscanner;
#line 1945
  if (yyg->yy_buffer_stack) {
#line 1945
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1945
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1945
  if (! tmp) {
    {
#line 1946
    sexensure_buffer_stack(yyscanner);
#line 1947
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = sex_create_buffer(yyg->yyin_r,
                                                                           16384,
                                                                           yyscanner);
    }
  }
#line 1951
  if (yyg->yy_buffer_stack) {
#line 1951
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1951
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1951
  sex_init_buffer(tmp___0, input_file, yyscanner);
#line 1952
  sex_load_buffer_state(yyscanner);
  }
#line 1953
  return;
}
}
#line 1963 "rec-sex-lex.c"
void sex_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1968
  yyg = (struct yyguts_t *)yyscanner;
#line 1975
  sexensure_buffer_stack(yyscanner);
  }
#line 1976
  if (yyg->yy_buffer_stack) {
#line 1976
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1976
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1976
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1977
    return;
  }
#line 1979
  if (yyg->yy_buffer_stack) {
#line 1979
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1979
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1979
  if (tmp___0) {
#line 1982
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 1983
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 1984
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 1987
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 1988
  sex_load_buffer_state(yyscanner);
#line 1995
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 1996
  return;
}
}
#line 1999 "rec-sex-lex.c"
static void sex_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  char *tmp ;

  {
#line 2004
  yyg = (struct yyguts_t *)yyscanner;
#line 2005
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2006
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 2006
  yyg->yy_c_buf_p = tmp;
#line 2006
  yyg->yytext_r = tmp;
#line 2008
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 2012
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 2013
  return;
}
}
#line 2022 "rec-sex-lex.c"
YY_BUFFER_STATE sex_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2029
  tmp = sexalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 2029
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2030
  if (! b) {
    {
#line 2031
    yy_fatal_error("out of dynamic memory in yy_create_buffer()", yyscanner);
    }
  }
  {
#line 2033
  b->yy_buf_size = size;
#line 2038
  tmp___0 = sexalloc((yy_size_t )(b->yy_buf_size + 2), yyscanner);
#line 2038
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2039
  if (! b->yy_ch_buf) {
    {
#line 2040
    yy_fatal_error("out of dynamic memory in yy_create_buffer()", yyscanner);
    }
  }
  {
#line 2042
  b->yy_is_our_buffer = 1;
#line 2044
  sex_init_buffer(b, file, yyscanner);
  }
#line 2046
  return (b);
}
}
#line 2057 "rec-sex-lex.c"
void sex_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2062
  yyg = (struct yyguts_t *)yyscanner;
#line 2064
  if (! b) {
#line 2065
    return;
  }
#line 2067
  if (yyg->yy_buffer_stack) {
#line 2067
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2067
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2067
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2068
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2070
  if (b->yy_is_our_buffer) {
    {
#line 2071
    sexfree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 2073
  sexfree((void *)b, yyscanner);
  }
#line 2074
  return;
}
}
#line 2081 "rec-sex-lex.c"
static void sex_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2087
  tmp = __errno_location();
#line 2087
  oerrno = *tmp;
#line 2088
  yyg = (struct yyguts_t *)yyscanner;
#line 2090
  sex_flush_buffer(b, yyscanner);
#line 2093
  b->yy_input_file = file;
#line 2097
  b->yy_fill_buffer = 1;
  }
#line 2103
  if (yyg->yy_buffer_stack) {
#line 2103
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2103
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2103
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2104
    b->yy_bs_lineno = 1;
#line 2105
    b->yy_bs_column = 0;
  }
#line 2110
  if (file) {
    {
#line 2110
    tmp___1 = fileno(file);
#line 2110
    tmp___2 = isatty(tmp___1);
#line 2110
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 2110
    b->yy_is_interactive = 0;
  }
  {
#line 2115
  tmp___3 = __errno_location();
#line 2115
  *tmp___3 = oerrno;
  }
#line 2116
  return;
}
}
#line 2123 "rec-sex-lex.c"
void sex_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2128
  yyg = (struct yyguts_t *)yyscanner;
#line 2129
  if (! b) {
#line 2130
    return;
  }
#line 2132
  b->yy_n_chars = 0;
#line 2138
  *(b->yy_ch_buf + 0) = (char)0;
#line 2139
  *(b->yy_ch_buf + 1) = (char)0;
#line 2141
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2143
  b->yy_at_bol = 1;
#line 2144
  b->yy_buffer_status = 0;
#line 2146
  if (yyg->yy_buffer_stack) {
#line 2146
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2146
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2146
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2147
    sex_load_buffer_state(yyscanner);
    }
  }
#line 2148
  return;
}
}
#line 2158 "rec-sex-lex.c"
void sexpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2163
  yyg = (struct yyguts_t *)yyscanner;
#line 2164
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2165
    return;
  }
  {
#line 2167
  sexensure_buffer_stack(yyscanner);
  }
#line 2170
  if (yyg->yy_buffer_stack) {
#line 2170
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2170
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2170
  if (tmp) {
#line 2173
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2174
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2175
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2179
  if (yyg->yy_buffer_stack) {
#line 2179
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2179
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2179
  if (tmp___0) {
#line 2180
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 2181
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2184
  sex_load_buffer_state(yyscanner);
#line 2185
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2186
  return;
}
}
#line 2195 "rec-sex-lex.c"
void sexpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2200
  yyg = (struct yyguts_t *)yyscanner;
#line 2201
  if (yyg->yy_buffer_stack) {
#line 2201
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2201
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2201
  if (! tmp) {
#line 2202
    return;
  }
#line 2204
  if (yyg->yy_buffer_stack) {
#line 2204
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2204
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2204
  sex_delete_buffer(tmp___0, yyscanner);
#line 2205
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2206
  if (yyg->yy_buffer_stack_top > 0UL) {
#line 2207
    (yyg->yy_buffer_stack_top) --;
  }
#line 2209
  if (yyg->yy_buffer_stack) {
#line 2209
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2209
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2209
  if (tmp___1) {
    {
#line 2210
    sex_load_buffer_state(yyscanner);
#line 2211
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2213
  return;
}
}
#line 2221 "rec-sex-lex.c"
static void sexensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  yy_size_t num_to_alloc ;
  struct yyguts_t *yyg ;
  void *tmp ;
  yy_size_t grow_size ;
  void *tmp___0 ;

  {
#line 2227
  yyg = (struct yyguts_t *)yyscanner;
#line 2229
  if (! yyg->yy_buffer_stack) {
    {
#line 2235
    num_to_alloc = (yy_size_t )1;
#line 2236
    tmp = sexalloc(num_to_alloc * sizeof(struct yy_buffer_state *), yyscanner);
#line 2236
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2239
    if (! yyg->yy_buffer_stack) {
      {
#line 2240
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2242
    memset((void *)yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2244
    yyg->yy_buffer_stack_max = num_to_alloc;
#line 2245
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 2246
    return;
  }
#line 2249
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1UL) {
    {
#line 2252
    grow_size = (yy_size_t )8;
#line 2254
    num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
#line 2255
    tmp___0 = sexrealloc((void *)yyg->yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *),
                         yyscanner);
#line 2255
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2259
    if (! yyg->yy_buffer_stack) {
      {
#line 2260
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2263
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state *));
#line 2264
    yyg->yy_buffer_stack_max = num_to_alloc;
    }
  }
#line 2266
  return;
}
}
#line 2276 "rec-sex-lex.c"
YY_BUFFER_STATE sex_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2280
  if (size < 2UL) {
#line 2284
    return ((YY_BUFFER_STATE )((void *)0));
  } else
#line 2280
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2284
    return ((YY_BUFFER_STATE )((void *)0));
  } else
#line 2280
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2284
    return ((YY_BUFFER_STATE )((void *)0));
  }
  {
#line 2286
  tmp = sexalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 2286
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2287
  if (! b) {
    {
#line 2288
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()", yyscanner);
    }
  }
  {
#line 2290
  b->yy_buf_size = (int )(size - 2UL);
#line 2291
  tmp___0 = base;
#line 2291
  b->yy_ch_buf = tmp___0;
#line 2291
  b->yy_buf_pos = tmp___0;
#line 2292
  b->yy_is_our_buffer = 0;
#line 2293
  b->yy_input_file = (FILE *)((void *)0);
#line 2294
  b->yy_n_chars = b->yy_buf_size;
#line 2295
  b->yy_is_interactive = 0;
#line 2296
  b->yy_at_bol = 1;
#line 2297
  b->yy_fill_buffer = 0;
#line 2298
  b->yy_buffer_status = 0;
#line 2300
  sex_switch_to_buffer(b, yyscanner);
  }
#line 2302
  return (b);
}
}
#line 2315 "rec-sex-lex.c"
YY_BUFFER_STATE sex_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2318
  tmp = strlen(yystr);
#line 2318
  tmp___0 = sex_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 2318
  return (tmp___0);
}
}
#line 2330 "rec-sex-lex.c"
YY_BUFFER_STATE sex_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2338
  n = (yy_size_t )(_yybytes_len + 2);
#line 2339
  tmp = sexalloc(n, yyscanner);
#line 2339
  buf = (char *)tmp;
  }
#line 2340
  if (! buf) {
    {
#line 2341
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()", yyscanner);
    }
  }
#line 2343
  i = 0;
  {
#line 2343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2343
    if (! (i < _yybytes_len)) {
#line 2343
      goto while_break;
    }
#line 2344
    *(buf + i) = (char )*(yybytes + i);
#line 2343
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2346
  tmp___0 = (char)0;
#line 2346
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2346
  *(buf + _yybytes_len) = tmp___0;
#line 2348
  b = sex_scan_buffer(buf, n, yyscanner);
  }
#line 2349
  if (! b) {
    {
#line 2350
    yy_fatal_error("bad buffer in yy_scan_bytes()", yyscanner);
    }
  }
#line 2355
  b->yy_is_our_buffer = 1;
#line 2357
  return (b);
}
}
#line 2366
static  __attribute__((__noreturn__)) void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) ;
#line 2366 "rec-sex-lex.c"
static void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
  {
#line 2368
  yyg = (struct yyguts_t *)yyscanner;
#line 2370
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2371
  exit(2);
  }
}
}
#line 2402 "rec-sex-lex.c"
void *sexget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2404
  yyg = (struct yyguts_t *)yyscanner;
#line 2405
  return (yyg->yyextra_r);
}
}
#line 2413 "rec-sex-lex.c"
int sexget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2415
  yyg = (struct yyguts_t *)yyscanner;
#line 2417
  if (yyg->yy_buffer_stack) {
#line 2417
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2417
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2417
  if (! tmp) {
#line 2418
    return (0);
  }
#line 2420
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 2426 "rec-sex-lex.c"
int sexget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2428
  yyg = (struct yyguts_t *)yyscanner;
#line 2430
  if (yyg->yy_buffer_stack) {
#line 2430
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2430
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2430
  if (! tmp) {
#line 2431
    return (0);
  }
#line 2433
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 2439 "rec-sex-lex.c"
FILE *sexget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2441
  yyg = (struct yyguts_t *)yyscanner;
#line 2442
  return (yyg->yyin_r);
}
}
#line 2448 "rec-sex-lex.c"
FILE *sexget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2450
  yyg = (struct yyguts_t *)yyscanner;
#line 2451
  return (yyg->yyout_r);
}
}
#line 2457 "rec-sex-lex.c"
int sexget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2459
  yyg = (struct yyguts_t *)yyscanner;
#line 2460
  return (yyg->yyleng_r);
}
}
#line 2467 "rec-sex-lex.c"
char *sexget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2469
  yyg = (struct yyguts_t *)yyscanner;
#line 2470
  return (yyg->yytext_r);
}
}
#line 2479 "rec-sex-lex.c"
void sexset_extra(void *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2481
  yyg = (struct yyguts_t *)yyscanner;
#line 2482
  yyg->yyextra_r = user_defined;
#line 2483
  return;
}
}
#line 2491 "rec-sex-lex.c"
void sexset_lineno(int _line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2493
  yyg = (struct yyguts_t *)yyscanner;
#line 2496
  if (yyg->yy_buffer_stack) {
#line 2496
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2496
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2496
  if (! tmp) {
    {
#line 2497
    yy_fatal_error("yyset_lineno called with no buffer", yyscanner);
    }
  }
#line 2499
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = _line_number;
#line 2500
  return;
}
}
#line 2506 "rec-sex-lex.c"
void sexset_column(int _column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2508
  yyg = (struct yyguts_t *)yyscanner;
#line 2511
  if (yyg->yy_buffer_stack) {
#line 2511
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2511
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2511
  if (! tmp) {
    {
#line 2512
    yy_fatal_error("yyset_column called with no buffer", yyscanner);
    }
  }
#line 2514
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = _column_no;
#line 2515
  return;
}
}
#line 2523 "rec-sex-lex.c"
void sexset_in(FILE *_in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2525
  yyg = (struct yyguts_t *)yyscanner;
#line 2526
  yyg->yyin_r = _in_str;
#line 2527
  return;
}
}
#line 2529 "rec-sex-lex.c"
void sexset_out(FILE *_out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2531
  yyg = (struct yyguts_t *)yyscanner;
#line 2532
  yyg->yyout_r = _out_str;
#line 2533
  return;
}
}
#line 2535 "rec-sex-lex.c"
int sexget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2537
  yyg = (struct yyguts_t *)yyscanner;
#line 2538
  return (yyg->yy_flex_debug_r);
}
}
#line 2541 "rec-sex-lex.c"
void sexset_debug(int _bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2543
  yyg = (struct yyguts_t *)yyscanner;
#line 2544
  yyg->yy_flex_debug_r = _bdebug;
#line 2545
  return;
}
}
#line 2554 "rec-sex-lex.c"
YYSTYPE___0 *sexget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2556
  yyg = (struct yyguts_t *)yyscanner;
#line 2557
  return (yyg->yylval_r);
}
}
#line 2560 "rec-sex-lex.c"
void sexset_lval(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2562
  yyg = (struct yyguts_t *)yyscanner;
#line 2563
  yyg->yylval_r = yylval_param;
#line 2564
  return;
}
}
#line 2574 "rec-sex-lex.c"
int sexlex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2576
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2577
    tmp = __errno_location();
#line 2577
    *tmp = 22;
    }
#line 2578
    return (1);
  }
  {
#line 2581
  tmp___0 = sexalloc(sizeof(struct yyguts_t ), (void *)0);
#line 2581
  *ptr_yy_globals = tmp___0;
  }
#line 2583
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2584
    tmp___1 = __errno_location();
#line 2584
    *tmp___1 = 12;
    }
#line 2585
    return (1);
  }
  {
#line 2589
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t ));
#line 2591
  tmp___2 = yy_init_globals(*ptr_yy_globals);
  }
#line 2591
  return (tmp___2);
}
}
#line 2601 "rec-sex-lex.c"
int sexlex_init_extra(void *yy_user_defined , yyscan_t *ptr_yy_globals ) 
{ 
  struct yyguts_t dummy_yyguts ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2605
  sexset_extra(yy_user_defined, (yyscan_t )(& dummy_yyguts));
  }
#line 2607
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2608
    tmp = __errno_location();
#line 2608
    *tmp = 22;
    }
#line 2609
    return (1);
  }
  {
#line 2612
  tmp___0 = sexalloc(sizeof(struct yyguts_t ), (yyscan_t )(& dummy_yyguts));
#line 2612
  *ptr_yy_globals = tmp___0;
  }
#line 2614
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2615
    tmp___1 = __errno_location();
#line 2615
    *tmp___1 = 12;
    }
#line 2616
    return (1);
  }
  {
#line 2621
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t ));
#line 2623
  sexset_extra(yy_user_defined, *ptr_yy_globals);
#line 2625
  tmp___2 = yy_init_globals(*ptr_yy_globals);
  }
#line 2625
  return (tmp___2);
}
}
#line 2631 "rec-sex-lex.c"
static int yy_init_globals(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2633
  yyg = (struct yyguts_t *)yyscanner;
#line 2638
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2639
  yyg->yy_buffer_stack_top = (size_t )0;
#line 2640
  yyg->yy_buffer_stack_max = (size_t )0;
#line 2641
  yyg->yy_c_buf_p = (char *)((void *)0);
#line 2642
  yyg->yy_init = 0;
#line 2643
  yyg->yy_start = 0;
#line 2645
  yyg->yy_start_stack_ptr = 0;
#line 2646
  yyg->yy_start_stack_depth = 0;
#line 2647
  yyg->yy_start_stack = (int *)((void *)0);
#line 2654
  yyg->yyin_r = (FILE *)((void *)0);
#line 2655
  yyg->yyout_r = (FILE *)((void *)0);
#line 2661
  return (0);
}
}
#line 2667 "rec-sex-lex.c"
int sexlex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2669
  yyg = (struct yyguts_t *)yyscanner;
  {
#line 2672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2672
    if (yyg->yy_buffer_stack) {
#line 2672
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2672
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2672
    if (! tmp___0) {
#line 2672
      goto while_break;
    }
#line 2673
    if (yyg->yy_buffer_stack) {
#line 2673
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2673
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2673
    sex_delete_buffer(tmp, yyscanner);
#line 2674
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2675
    sexpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2679
  sexfree((void *)yyg->yy_buffer_stack, yyscanner);
#line 2680
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2683
  sexfree((void *)yyg->yy_start_stack, yyscanner);
#line 2684
  yyg->yy_start_stack = (int *)((void *)0);
#line 2688
  yy_init_globals(yyscanner);
#line 2692
  sexfree(yyscanner, yyscanner);
#line 2693
  yyscanner = (void *)0;
  }
#line 2695
  return (0);
}
}
#line 2726 "rec-sex-lex.c"
void *sexalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  void *tmp ;

  {
  {
#line 2728
  yyg = (struct yyguts_t *)yyscanner;
#line 2730
  tmp = malloc(size);
  }
#line 2730
  return (tmp);
}
}
#line 2733 "rec-sex-lex.c"
void *sexrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  void *tmp ;

  {
  {
#line 2735
  yyg = (struct yyguts_t *)yyscanner;
#line 2745
  tmp = realloc(ptr, size);
  }
#line 2745
  return (tmp);
}
}
#line 2748 "rec-sex-lex.c"
void sexfree(void *ptr , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
  {
#line 2750
  yyg = (struct yyguts_t *)yyscanner;
#line 2752
  free((void *)((char *)ptr));
  }
#line 2753
  return;
}
}
#line 178 "../../src/rec-sex-lex.l"
char *rec_sex_lex_extract_name(char *str ) 
{ 
  size_t size ;
  char *res ;
  char *p ;
  void *tmp ;

  {
#line 185
  p = str;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if ((int )*p != 91) {
#line 186
      if ((int )*p != 46) {
#line 186
        if (! ((int )*p != 0)) {
#line 186
          goto while_break;
        }
      } else {
#line 186
        goto while_break;
      }
    } else {
#line 186
      goto while_break;
    }
#line 188
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  size = (size_t )(p - str);
#line 192
  tmp = malloc(size + 1UL);
#line 192
  res = (char *)tmp;
#line 193
  memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)str, size);
#line 194
  *(res + size) = (char)0;
  }
#line 196
  return (res);
}
}
#line 199 "../../src/rec-sex-lex.l"
char *rec_sex_lex_extract_subname(char *str ) 
{ 
  char *p ;
  char *tmp ;

  {
#line 207
  p = str;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if ((int )*p != 46) {
#line 208
      if (! ((int )*p != 0)) {
#line 208
        goto while_break;
      }
    } else {
#line 208
      goto while_break;
    }
#line 210
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  if ((int )*p == 0) {
#line 216
    return ((char *)((void *)0));
  }
  {
#line 219
  p ++;
#line 221
  tmp = rec_sex_lex_extract_name(p);
  }
#line 221
  return (tmp);
}
}
#line 224 "../../src/rec-sex-lex.l"
_Bool rec_sex_lex_extract_index(char *str , int *num ) 
{ 
  _Bool res ;
  char *p ;
  char aux[100] ;
  int aux_size ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 236
  aux_size = 0;
#line 237
  p = str;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if ((int )*p != 0) {
#line 238
      if (! ((int )*p != 91)) {
#line 238
        goto while_break;
      }
    } else {
#line 238
      goto while_break;
    }
#line 240
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 243
  if ((int )*p == 0) {
#line 245
    res = (_Bool)0;
  } else {
#line 249
    p ++;
    {
#line 250
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 250
      if (! ((int )*p != 93)) {
#line 250
        goto while_break___0;
      }
#line 252
      tmp = aux_size;
#line 252
      aux_size ++;
#line 252
      aux[tmp] = *p;
#line 253
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 255
    aux[aux_size] = (char)0;
#line 257
    tmp___0 = rec_atoi((char const   *)(aux), num);
    }
#line 257
    if (! tmp___0) {
#line 259
      res = (_Bool)0;
    }
#line 262
    res = (_Bool)1;
  }
#line 265
  return (res);
}
}
#line 79 "./rec-sex-ast.h"
rec_sex_ast_t rec_sex_ast_new(void) ;
#line 86
void rec_sex_ast_set_top(rec_sex_ast_t ast , rec_sex_ast_node_t node ) ;
#line 90
void rec_sex_ast_node_destroy(rec_sex_ast_node_t node ) ;
#line 93
void rec_sex_ast_node_set_type(rec_sex_ast_node_t node , enum rec_sex_ast_node_type_e type ) ;
#line 111
void rec_sex_ast_node_link(rec_sex_ast_node_t parent , rec_sex_ast_node_t child ) ;
#line 53 "./rec-sex-parser.h"
void rec_sex_parser_set_ast(rec_sex_parser_t parser , rec_sex_ast_t ast ) ;
#line 55
void *rec_sex_parser_scanner(rec_sex_parser_t parser ) ;
#line 103 "rec-sex-tab.h"
int sexparse(rec_sex_parser_t sex_parser ) ;
#line 45 "../../src/rec-sex-tab.y"
void sexerror(rec_sex_parser_t context , char const   *err ) 
{ 


  {
#line 48
  return;
}
}
#line 491 "rec-sex-tab.c"
static yytype_uint8 const   yytranslate___0[290]  = 
#line 491 "rec-sex-tab.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34};
#line 577 "rec-sex-tab.c"
static yytype_int16 const   yypact___0[57]  = 
#line 577
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )-20,      (yytype_int16 const   )-20,      (yytype_int16 const   )-20, 
        (yytype_int16 const   )-20,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )0, 
        (yytype_int16 const   )7,      (yytype_int16 const   )89,      (yytype_int16 const   )-20,      (yytype_int16 const   )43, 
        (yytype_int16 const   )-20,      (yytype_int16 const   )-20,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-20,      (yytype_int16 const   )69, 
        (yytype_int16 const   )108,      (yytype_int16 const   )22,      (yytype_int16 const   )22,      (yytype_int16 const   )118, 
        (yytype_int16 const   )118,      (yytype_int16 const   )118,      (yytype_int16 const   )118,      (yytype_int16 const   )118, 
        (yytype_int16 const   )118,      (yytype_int16 const   )125,      (yytype_int16 const   )125,      (yytype_int16 const   )125, 
        (yytype_int16 const   )130,      (yytype_int16 const   )130,      (yytype_int16 const   )-19,      (yytype_int16 const   )-19, 
        (yytype_int16 const   )-19,      (yytype_int16 const   )-19,      (yytype_int16 const   )-20,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )89};
#line 590 "rec-sex-tab.c"
static yytype_uint8 const   yydefact___0[57]  = 
#line 590
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )24,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )29,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )17,      (yytype_uint8 const   )16,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )22,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )11,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )10,      (yytype_uint8 const   )27,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )7};
#line 601 "rec-sex-tab.c"
static yytype_int8 const   yypgoto___0[3]  = {      (yytype_int8 const   )-20,      (yytype_int8 const   )-20,      (yytype_int8 const   )-5};
#line 607 "rec-sex-tab.c"
static yytype_int8 const   yydefgoto___0[3]  = {      (yytype_int8 const   )-1,      (yytype_int8 const   )8,      (yytype_int8 const   )9};
#line 615 "rec-sex-tab.c"
static yytype_uint8 const   yytable___0[158]  = 
#line 615
  {      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )56,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33};
#line 635 "rec-sex-tab.c"
static yytype_int8 const   yycheck___0[158]  = 
#line 635
  {      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )6,      (yytype_int8 const   )0, 
        (yytype_int8 const   )27,      (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16, 
        (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )24, 
        (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )28, 
        (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32, 
        (yytype_int8 const   )33,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )34,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25, 
        (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )55,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12, 
        (yytype_int8 const   )13,      (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16, 
        (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )24, 
        (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )32, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )14, 
        (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22, 
        (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26, 
        (yytype_int8 const   )27,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )14, 
        (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22, 
        (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26, 
        (yytype_int8 const   )27,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11, 
        (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )14,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23, 
        (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25, 
        (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )21,      (yytype_int8 const   )22, 
        (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26, 
        (yytype_int8 const   )27,      (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25, 
        (yytype_int8 const   )26,      (yytype_int8 const   )27};
#line 657 "rec-sex-tab.c"
static yytype_uint8 const   yystos___0[57]  = 
#line 657
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )32,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )37};
#line 668 "rec-sex-tab.c"
static yytype_uint8 const   yyr1___0[30]  = 
#line 668
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37};
#line 676 "rec-sex-tab.c"
static yytype_uint8 const   yyr2___0[30]  = 
#line 676
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3};
#line 1093 "rec-sex-tab.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSTYPE___0 *yyvaluep ,
                           rec_sex_parser_t sex_parser ) 
{ 


  {
#line 1098
  if (! yymsg) {
#line 1099
    yymsg = "Deleting";
  }
#line 1105
  return;
}
}
#line 1124 "rec-sex-tab.c"
static YYSTYPE___0 yyval_default___0  ;
#line 1114 "rec-sex-tab.c"
int sexparse(rec_sex_parser_t sex_parser ) 
{ 
  int yychar ;
  YYSTYPE___0 yylval ;
  int sexnerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE___0 yyvsa[200] ;
  YYSTYPE___0 *yyvs ;
  YYSTYPE___0 *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE___0 yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc___0 *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  void *tmp___0 ;
  rec_sex_ast_t ast ;
  enum rec_sex_ast_node_type_e tmp___1 ;
  enum rec_sex_ast_node_type_e tmp___2 ;
  int tmp___3 ;

  {
#line 1125
  yylval = yyval_default___0;
#line 1156
  yytoken = 0;
#line 1172
  yylen = 0;
#line 1174
  yyss = yyssa;
#line 1174
  yyssp = yyss;
#line 1175
  yyvs = yyvsa;
#line 1175
  yyvsp = yyvs;
#line 1176
  yystacksize = 200UL;
#line 1180
  yystate = 0;
#line 1181
  yyerrstatus = 0;
#line 1182
  sexnerrs = 0;
#line 1183
  yychar = -2;
#line 1184
  goto yysetstate;
  yynewstate: 
#line 1192
  yyssp ++;
  yysetstate: 
#line 1195
  *yyssp = (yytype_int16 )yystate;
#line 1197
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1200
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1227
    if (10000UL <= yystacksize) {
#line 1228
      goto yyexhaustedlab;
    }
#line 1229
    yystacksize *= 2UL;
#line 1230
    if (10000UL < yystacksize) {
#line 1231
      yystacksize = 10000UL;
    }
    {
#line 1234
    yyss1 = yyss;
#line 1235
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE___0 )) + (sizeof(union yyalloc___0 ) - 1UL));
#line 1235
    yyptr = (union yyalloc___0 *)tmp;
    }
#line 1237
    if (! yyptr) {
#line 1238
      goto yyexhaustedlab;
    }
    {
#line 1239
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1239
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1239
      yyss = & yyptr->yyss_alloc;
#line 1239
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1239
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1239
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1240
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1240
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1240
      yyvs = & yyptr->yyvs_alloc;
#line 1240
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1240
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1240
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1242
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1243
      free((void *)yyss1);
      }
    }
#line 1248
    yyssp = (yyss + yysize) - 1;
#line 1249
    yyvsp = (yyvs + yysize) - 1;
#line 1254
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1255
      goto yyabortlab;
    }
  }
#line 1260
  if (yystate == 13) {
#line 1261
    goto yyacceptlab;
  }
#line 1263
  goto yybackup;
  yybackup: 
#line 1274
  yyn = (int )yypact___0[yystate];
#line 1275
  if (! (! (yyn == -20))) {
#line 1276
    goto yydefault;
  }
#line 1281
  if (yychar == -2) {
    {
#line 1284
    tmp___0 = rec_sex_parser_scanner(sex_parser);
#line 1284
    yychar = sexlex(& yylval, tmp___0);
    }
  }
#line 1287
  if (yychar <= 0) {
#line 1289
    yytoken = 0;
#line 1289
    yychar = yytoken;
  } else
#line 1294
  if ((unsigned int )yychar <= 289U) {
#line 1294
    yytoken = (int )yytranslate___0[yychar];
  } else {
#line 1294
    yytoken = 2;
  }
#line 1300
  yyn += yytoken;
#line 1301
  if (yyn < 0) {
#line 1302
    goto yydefault;
  } else
#line 1301
  if (157 < yyn) {
#line 1302
    goto yydefault;
  } else
#line 1301
  if ((int const   )yycheck___0[yyn] != (int const   )yytoken) {
#line 1302
    goto yydefault;
  }
#line 1303
  yyn = (int )yytable___0[yyn];
#line 1304
  if (yyn <= 0) {
#line 1308
    yyn = - yyn;
#line 1309
    goto yyreduce;
  }
#line 1314
  if (yyerrstatus) {
#line 1315
    yyerrstatus --;
  }
#line 1321
  yychar = -2;
#line 1323
  yystate = yyn;
#line 1325
  yyvsp ++;
#line 1325
  *yyvsp = yylval;
#line 1328
  goto yynewstate;
  yydefault: 
#line 1335
  yyn = (int )yydefact___0[yystate];
#line 1336
  if (yyn == 0) {
#line 1337
    goto yyerrlab;
  }
#line 1338
  goto yyreduce;
  yyreduce: 
#line 1346
  yylen = (int )yyr2___0[yyn];
#line 1356
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1362
  if (yyn == 2) {
#line 1362
    goto case_2;
  }
#line 1374
  if (yyn == 3) {
#line 1374
    goto case_3;
  }
#line 1380
  if (yyn == 4) {
#line 1380
    goto case_4;
  }
#line 1386
  if (yyn == 5) {
#line 1386
    goto case_5;
  }
#line 1392
  if (yyn == 6) {
#line 1392
    goto case_6;
  }
#line 1398
  if (yyn == 7) {
#line 1398
    goto case_7;
  }
#line 1404
  if (yyn == 8) {
#line 1404
    goto case_8;
  }
#line 1410
  if (yyn == 9) {
#line 1410
    goto case_9;
  }
#line 1416
  if (yyn == 10) {
#line 1416
    goto case_10;
  }
#line 1432
  if (yyn == 11) {
#line 1432
    goto case_11;
  }
#line 1438
  if (yyn == 12) {
#line 1438
    goto case_12;
  }
#line 1444
  if (yyn == 13) {
#line 1444
    goto case_13;
  }
#line 1450
  if (yyn == 14) {
#line 1450
    goto case_14;
  }
#line 1456
  if (yyn == 15) {
#line 1456
    goto case_15;
  }
#line 1462
  if (yyn == 16) {
#line 1462
    goto case_16;
  }
#line 1468
  if (yyn == 17) {
#line 1468
    goto case_17;
  }
#line 1474
  if (yyn == 18) {
#line 1474
    goto case_18;
  }
#line 1480
  if (yyn == 19) {
#line 1480
    goto case_19;
  }
#line 1486
  if (yyn == 20) {
#line 1486
    goto case_20;
  }
#line 1492
  if (yyn == 21) {
#line 1492
    goto case_21;
  }
#line 1498
  if (yyn == 22) {
#line 1498
    goto case_22;
  }
#line 1504
  if (yyn == 23) {
#line 1504
    goto case_23;
  }
#line 1510
  if (yyn == 24) {
#line 1510
    goto case_24;
  }
#line 1516
  if (yyn == 25) {
#line 1516
    goto case_25;
  }
#line 1522
  if (yyn == 26) {
#line 1522
    goto case_26;
  }
#line 1528
  if (yyn == 27) {
#line 1528
    goto case_27;
  }
#line 1534
  if (yyn == 28) {
#line 1534
    goto case_28;
  }
#line 1540
  if (yyn == 29) {
#line 1540
    goto case_29;
  }
#line 1548
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 129 "../../src/rec-sex-tab.y"
  ast = rec_sex_ast_new();
#line 130
  rec_sex_ast_set_top(ast, (yyvsp + 0)->node);
#line 131
  rec_sex_parser_set_ast(sex_parser, ast);
  }
#line 1372 "rec-sex-tab.c"
  goto switch_break;
  case_3: /* CIL Label */ 
#line 135 "../../src/rec-sex-tab.y"
  yyval.node = (yyvsp + 0)->node;
#line 1378 "rec-sex-tab.c"
  goto switch_break;
  case_4: /* CIL Label */ 
#line 136 "../../src/rec-sex-tab.y"
  yyval.node = (yyvsp + 0)->node;
#line 1384 "rec-sex-tab.c"
  goto switch_break;
  case_5: /* CIL Label */ 
#line 137 "../../src/rec-sex-tab.y"
  yyval.node = (yyvsp + 0)->node;
#line 1390 "rec-sex-tab.c"
  goto switch_break;
  case_6: /* CIL Label */ 
#line 138 "../../src/rec-sex-tab.y"
  yyval.node = (yyvsp + 0)->node;
#line 1396 "rec-sex-tab.c"
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 140 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 140
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )22);
#line 140
    rec_sex_ast_node_link(yyval.node, (yyvsp + -4)->node);
#line 140
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 140
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 140
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1402 "rec-sex-tab.c"
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 141 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 141
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )7);
#line 141
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 141
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 141
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1408 "rec-sex-tab.c"
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 142
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 142 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 142
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )8);
#line 142
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 142
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 142
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1414 "rec-sex-tab.c"
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 145 "../../src/rec-sex-tab.y"
  tmp___1 = rec_sex_ast_node_type((yyvsp + -2)->node);
  }
#line 145
  if ((unsigned int )tmp___1 == 24U) {
    {
#line 148
    rec_sex_ast_node_destroy((yyvsp + -2)->node);
#line 149
    rec_sex_ast_node_destroy((yyvsp + 0)->node);
    }
#line 150
    goto yyabortlab;
  } else {
    {
#line 145
    tmp___2 = rec_sex_ast_node_type((yyvsp + 0)->node);
    }
#line 145
    if ((unsigned int )tmp___2 == 24U) {
      {
#line 148
      rec_sex_ast_node_destroy((yyvsp + -2)->node);
#line 149
      rec_sex_ast_node_destroy((yyvsp + 0)->node);
      }
#line 150
      goto yyabortlab;
    }
  }
  {
#line 153
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 153
    yyval.node = rec_sex_ast_node_new();
#line 153
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )9);
#line 153
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 153
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 153
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1430 "rec-sex-tab.c"
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 155
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 155 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 155
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )2);
#line 155
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 155
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 155
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1436 "rec-sex-tab.c"
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 156
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 156 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 156
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )3);
#line 156
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 156
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 156
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1442 "rec-sex-tab.c"
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 157
  while (1) {
    while_continue___7: /* CIL Label */ ;
    {
#line 157 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 157
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )4);
#line 157
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 157
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 157
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1448 "rec-sex-tab.c"
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 158
  while (1) {
    while_continue___8: /* CIL Label */ ;
    {
#line 158 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 158
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )5);
#line 158
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 158
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 158
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1454 "rec-sex-tab.c"
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 159
  while (1) {
    while_continue___9: /* CIL Label */ ;
    {
#line 159 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 159
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )6);
#line 159
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 159
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 159
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1460 "rec-sex-tab.c"
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 160
  while (1) {
    while_continue___10: /* CIL Label */ ;
    {
#line 160 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 160
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )11);
#line 160
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 160
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 160
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1466 "rec-sex-tab.c"
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 161
  while (1) {
    while_continue___11: /* CIL Label */ ;
    {
#line 161 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 161
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )10);
#line 161
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 161
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 161
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1472 "rec-sex-tab.c"
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 162
  while (1) {
    while_continue___12: /* CIL Label */ ;
    {
#line 162 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 162
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )13);
#line 162
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 162
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 162
    goto while_break___12;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1478 "rec-sex-tab.c"
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 163
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 163 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 163
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )12);
#line 163
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 163
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 163
    goto while_break___13;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1484 "rec-sex-tab.c"
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 164
  while (1) {
    while_continue___14: /* CIL Label */ ;
    {
#line 164 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 164
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )21);
#line 164
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 164
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 164
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 1490 "rec-sex-tab.c"
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 165
  while (1) {
    while_continue___15: /* CIL Label */ ;
    {
#line 165 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 165
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )20);
#line 165
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 165
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 165
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 1496 "rec-sex-tab.c"
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 166
  while (1) {
    while_continue___16: /* CIL Label */ ;
    {
#line 166 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 166
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )18);
#line 166
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 166
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 166
    goto while_break___16;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 1502 "rec-sex-tab.c"
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 167
  while (1) {
    while_continue___17: /* CIL Label */ ;
    {
#line 167 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 167
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )19);
#line 167
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 167
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 167
    goto while_break___17;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 1508 "rec-sex-tab.c"
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 168
  while (1) {
    while_continue___18: /* CIL Label */ ;
    {
#line 168 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 168
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )16);
#line 168
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 168
    goto while_break___18;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 1514 "rec-sex-tab.c"
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 169
  while (1) {
    while_continue___19: /* CIL Label */ ;
    {
#line 169 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 169
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )14);
#line 169
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 169
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 169
    goto while_break___19;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 1520 "rec-sex-tab.c"
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 170
  while (1) {
    while_continue___20: /* CIL Label */ ;
    {
#line 170 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 170
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )15);
#line 170
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 170
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 170
    goto while_break___20;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 1526 "rec-sex-tab.c"
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 171
  while (1) {
    while_continue___21: /* CIL Label */ ;
    {
#line 171 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 171
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )23);
#line 171
    rec_sex_ast_node_link(yyval.node, (yyvsp + -2)->node);
#line 171
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 171
    goto while_break___21;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 1532 "rec-sex-tab.c"
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 172
  while (1) {
    while_continue___22: /* CIL Label */ ;
    {
#line 172 "../../src/rec-sex-tab.y"
    yyval.node = rec_sex_ast_node_new();
#line 172
    rec_sex_ast_node_set_type(yyval.node, (enum rec_sex_ast_node_type_e )17);
#line 172
    rec_sex_ast_node_link(yyval.node, (yyvsp + 0)->node);
    }
#line 172
    goto while_break___22;
  }
  while_break___22: /* CIL Label */ ;
  }
#line 1538 "rec-sex-tab.c"
  goto switch_break;
  case_29: /* CIL Label */ 
#line 173 "../../src/rec-sex-tab.y"
  yyval.node = (yyvsp + -1)->node;
#line 1544 "rec-sex-tab.c"
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1548
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1563
  yyvsp -= yylen;
#line 1563
  yyssp -= yylen;
#line 1564
  yylen = 0;
#line 1567
  yyvsp ++;
#line 1567
  *yyvsp = yyval;
#line 1573
  yyn = (int )yyr1___0[yyn];
#line 1575
  yystate = (int )((int const   )yypgoto___0[yyn - 35] + (int const   )*yyssp);
#line 1576
  if (0 <= yystate) {
#line 1576
    if (yystate <= 157) {
#line 1576
      if ((int const   )yycheck___0[yystate] == (int const   )*yyssp) {
#line 1577
        yystate = (int )yytable___0[yystate];
      } else {
#line 1579
        yystate = (int )yydefgoto___0[yyn - 35];
      }
    } else {
#line 1579
      yystate = (int )yydefgoto___0[yyn - 35];
    }
  } else {
#line 1579
    yystate = (int )yydefgoto___0[yyn - 35];
  }
#line 1581
  goto yynewstate;
  yyerrlab: 
#line 1590
  if (yychar == -2) {
#line 1590
    yytoken = -2;
  } else {
#line 1590
    if ((unsigned int )yychar <= 289U) {
#line 1590
      tmp___3 = (int const   )yytranslate___0[yychar];
    } else {
#line 1590
      tmp___3 = (int const   )2;
    }
#line 1590
    yytoken = (int )tmp___3;
  }
#line 1593
  if (! yyerrstatus) {
    {
#line 1595
    sexnerrs ++;
#line 1597
    sexerror(sex_parser, "syntax error");
    }
  }
#line 1634
  if (yyerrstatus == 3) {
#line 1639
    if (yychar <= 0) {
#line 1642
      if (yychar == 0) {
#line 1643
        goto yyabortlab;
      }
    } else {
      {
#line 1647
      yydestruct___0("Error: discarding", yytoken, & yylval, sex_parser);
#line 1649
      yychar = -2;
      }
    }
  }
#line 1655
  goto yyerrlab1;
#line 1671
  yyvsp -= yylen;
#line 1671
  yyssp -= yylen;
#line 1672
  yylen = 0;
#line 1674
  yystate = (int )*yyssp;
#line 1675
  goto yyerrlab1;
  yyerrlab1: 
#line 1682
  yyerrstatus = 3;
  {
#line 1684
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 1686
    yyn = (int )yypact___0[yystate];
#line 1687
    if (! (! (! (yyn == -20)))) {
#line 1689
      yyn ++;
#line 1690
      if (0 <= yyn) {
#line 1690
        if (yyn <= 157) {
#line 1690
          if ((int const   )yycheck___0[yyn] == 1) {
#line 1692
            yyn = (int )yytable___0[yyn];
#line 1693
            if (0 < yyn) {
#line 1694
              goto while_break___23;
            }
          }
        }
      }
    }
#line 1699
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 1700
      goto yyabortlab;
    }
    {
#line 1703
    yydestruct___0("Error: popping", (int )yystos___0[yystate], yyvsp, sex_parser);
#line 1705
    yyvsp --;
#line 1705
    yyssp --;
#line 1706
    yystate = (int )*yyssp;
    }
  }
  while_break___23: /* CIL Label */ ;
  }
#line 1711
  yyvsp ++;
#line 1711
  *yyvsp = yylval;
#line 1718
  yystate = yyn;
#line 1719
  goto yynewstate;
  yyacceptlab: 
#line 1726
  yyresult = 0;
#line 1727
  goto yyreturn;
  yyabortlab: 
#line 1733
  yyresult = 1;
#line 1734
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 1741
  sexerror(sex_parser, "memory exhausted");
#line 1742
  yyresult = 2;
  }
  yyreturn: 
#line 1747
  if (yychar != -2) {
#line 1751
    if ((unsigned int )yychar <= 289U) {
#line 1751
      yytoken = (int )yytranslate___0[yychar];
    } else {
#line 1751
      yytoken = 2;
    }
    {
#line 1752
    yydestruct___0("Cleanup: discarding lookahead", yytoken, & yylval, sex_parser);
    }
  }
#line 1757
  yyvsp -= yylen;
#line 1757
  yyssp -= yylen;
  {
#line 1759
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 1759
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 1759
      goto while_break___24;
    }
    {
#line 1761
    yydestruct___0("Cleanup: popping", (int )yystos___0[*yyssp], yyvsp, sex_parser);
#line 1763
    yyvsp --;
#line 1763
    yyssp --;
    }
  }
  while_break___24: /* CIL Label */ ;
  }
#line 1766
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 1767
    free((void *)yyss);
    }
  }
#line 1773
  return (yyresult);
}
}
#line 106 "./rec-sex-ast.h"
int rec_sex_ast_node_num_children(rec_sex_ast_node_t node ) ;
#line 114
void rec_sex_ast_node_reset(rec_sex_ast_node_t node ) ;
#line 119
void rec_sex_ast_print(rec_sex_ast_t ast ) ;
#line 67 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
rec_sex_ast_t rec_sex_ast_new(void) 
{ 
  rec_sex_ast_t new ;
  void *tmp ;

  {
  {
#line 72
  tmp = malloc(sizeof(struct rec_sex_ast_s ));
#line 72
  new = (rec_sex_ast_t )tmp;
  }
#line 73
  if (new) {
#line 75
    new->top = (rec_sex_ast_node_t )((void *)0);
  }
#line 78
  return (new);
}
}
#line 81 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_destroy(rec_sex_ast_t ast ) 
{ 


  {
#line 84
  if (ast->top) {
    {
#line 86
    rec_sex_ast_node_destroy(ast->top);
    }
  }
  {
#line 89
  free((void *)ast);
  }
#line 90
  return;
}
}
#line 92 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
rec_sex_ast_node_t rec_sex_ast_node_new(void) 
{ 
  rec_sex_ast_node_t new ;
  void *tmp ;

  {
  {
#line 97
  tmp = malloc(sizeof(struct rec_sex_ast_node_s ));
#line 97
  new = (rec_sex_ast_node_t )tmp;
  }
#line 98
  if (new) {
#line 100
    new->type = (enum rec_sex_ast_node_type_e )0;
#line 101
    new->num_children = (size_t )0;
#line 102
    new->index = -1;
#line 103
    new->fixed = (_Bool)0;
#line 104
    new->fixed_val = (char *)((void *)0);
  }
#line 107
  return (new);
}
}
#line 110 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_destroy(rec_sex_ast_node_t node ) 
{ 
  size_t i ;

  {
#line 116
  i = (size_t )0;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (i < node->num_children)) {
#line 116
      goto while_break;
    }
    {
#line 118
    rec_sex_ast_node_destroy(node->children[i]);
#line 116
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 122
  if ((unsigned int )node->type == 26U) {
    {
#line 124
    free((void *)node->val.string);
    }
  } else
#line 126
  if ((unsigned int )node->type == 27U) {
    {
#line 128
    free((void *)node->val.name[0]);
#line 129
    free((void *)node->val.name[1]);
    }
  }
  {
#line 132
  free((void *)node->fixed_val);
#line 133
  free((void *)node);
  }
#line 134
  return;
}
}
#line 136 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
enum rec_sex_ast_node_type_e rec_sex_ast_node_type(rec_sex_ast_node_t node ) 
{ 


  {
#line 139
  return (node->type);
}
}
#line 142 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_set_type(rec_sex_ast_node_t node , enum rec_sex_ast_node_type_e type ) 
{ 


  {
#line 146
  node->type = type;
#line 147
  return;
}
}
#line 149 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
int rec_sex_ast_node_int(rec_sex_ast_node_t node ) 
{ 


  {
#line 152
  return (node->val.integer);
}
}
#line 155 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_set_int(rec_sex_ast_node_t node , int num ) 
{ 


  {
#line 159
  node->type = (enum rec_sex_ast_node_type_e )24;
#line 160
  node->val.integer = num;
#line 161
  return;
}
}
#line 163 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
double rec_sex_ast_node_real(rec_sex_ast_node_t node ) 
{ 


  {
#line 166
  return (node->val.real);
}
}
#line 169 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_set_real(rec_sex_ast_node_t node , double num ) 
{ 


  {
#line 173
  node->type = (enum rec_sex_ast_node_type_e )25;
#line 174
  node->val.real = num;
#line 175
  return;
}
}
#line 177 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
char *rec_sex_ast_node_str(rec_sex_ast_node_t node ) 
{ 


  {
#line 180
  return (node->val.string);
}
}
#line 183 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_set_str(rec_sex_ast_node_t node , char *str ) 
{ 


  {
#line 187
  if ((unsigned int )node->type == 26U) {
    {
#line 189
    free((void *)node->val.string);
    }
  }
  {
#line 192
  node->type = (enum rec_sex_ast_node_type_e )26;
#line 193
  node->val.string = strdup((char const   *)str);
  }
#line 194
  return;
}
}
#line 196 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
char const   *rec_sex_ast_node_name(rec_sex_ast_node_t node ) 
{ 


  {
#line 199
  return ((char const   *)node->val.name[0]);
}
}
#line 202 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
char const   *rec_sex_ast_node_subname(rec_sex_ast_node_t node ) 
{ 


  {
#line 205
  return ((char const   *)node->val.name[1]);
}
}
#line 208 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_set_name(rec_sex_ast_node_t node , char const   *name , char const   *subname ) 
{ 


  {
#line 213
  if ((unsigned int )node->type == 27U) {
    {
#line 215
    free((void *)node->val.name[0]);
#line 216
    free((void *)node->val.name[1]);
    }
  }
  {
#line 219
  node->type = (enum rec_sex_ast_node_type_e )27;
#line 220
  node->val.name[0] = strdup(name);
#line 221
  node->val.name[1] = (char *)((void *)0);
  }
#line 222
  if (subname) {
    {
#line 224
    node->val.name[1] = strdup(subname);
    }
  }
#line 226
  return;
}
}
#line 228 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_link(rec_sex_ast_node_t parent , rec_sex_ast_node_t child ) 
{ 
  size_t tmp ;

  {
#line 232
  if (parent->num_children < 3UL) {
#line 234
    tmp = parent->num_children;
#line 234
    (parent->num_children) ++;
#line 234
    parent->children[tmp] = child;
  }
#line 236
  return;
}
}
#line 238 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
rec_sex_ast_node_t rec_sex_ast_top(rec_sex_ast_t ast ) 
{ 


  {
#line 241
  return (ast->top);
}
}
#line 244 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_set_top(rec_sex_ast_t ast , rec_sex_ast_node_t node ) 
{ 


  {
#line 248
  ast->top = node;
#line 249
  return;
}
}
#line 251 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_print_node(rec_sex_ast_node_t node ) 
{ 
  int i ;

  {
#line 256
  i = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! ((size_t )i < node->num_children)) {
#line 256
      goto while_break;
    }
    {
#line 258
    rec_sex_ast_print_node(node->children[i]);
#line 256
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 261
  printf((char const   */* __restrict  */)"------- node\n");
#line 262
  printf((char const   */* __restrict  */)"type: %d\n", (unsigned int )node->type);
  }
#line 263
  if ((unsigned int )node->type == 24U) {
    {
#line 265
    printf((char const   */* __restrict  */)"value: %d\n", node->val.integer);
    }
  }
#line 267
  if ((unsigned int )node->type == 27U) {
    {
#line 269
    printf((char const   */* __restrict  */)"value: %s\n", node->val.name[0]);
    }
  }
#line 271
  if ((unsigned int )node->type == 26U) {
    {
#line 273
    printf((char const   */* __restrict  */)"value: %s\n", node->val.string);
    }
  }
  {
#line 276
  printf((char const   */* __restrict  */)"\n");
  }
#line 277
  return;
}
}
#line 279 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
int rec_sex_ast_node_num_children(rec_sex_ast_node_t node ) 
{ 


  {
#line 282
  return ((int )node->num_children);
}
}
#line 285 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
rec_sex_ast_node_t rec_sex_ast_node_child(rec_sex_ast_node_t node , int n ) 
{ 
  rec_sex_ast_node_t res ;

  {
#line 291
  res = (rec_sex_ast_node_t )((void *)0);
#line 292
  if ((size_t )n < node->num_children) {
#line 294
    res = node->children[n];
  }
#line 297
  return (res);
}
}
#line 300 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_reset(rec_sex_ast_node_t node ) 
{ 
  int i ;

  {
#line 305
  i = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! ((size_t )i < node->num_children)) {
#line 305
      goto while_break;
    }
    {
#line 307
    rec_sex_ast_node_reset(node->children[i]);
#line 305
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  node->index = 0;
#line 311
  return;
}
}
#line 313 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_fix(rec_sex_ast_node_t node , char *val ) 
{ 


  {
  {
#line 317
  free((void *)node->fixed_val);
#line 318
  node->fixed = (_Bool)1;
#line 319
  node->fixed_val = strdup((char const   *)val);
  }
#line 320
  return;
}
}
#line 322 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_unfix(rec_sex_ast_node_t node ) 
{ 
  int i ;

  {
#line 327
  i = 0;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! ((size_t )i < node->num_children)) {
#line 327
      goto while_break;
    }
    {
#line 329
    rec_sex_ast_node_unfix(node->children[i]);
#line 327
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  node->fixed = (_Bool)0;
#line 333
  return;
}
}
#line 335 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
_Bool rec_sex_ast_node_fixed(rec_sex_ast_node_t node ) 
{ 


  {
#line 338
  return (node->fixed);
}
}
#line 341 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
char *rec_sex_ast_node_fixed_val(rec_sex_ast_node_t node ) 
{ 


  {
#line 344
  return (node->fixed_val);
}
}
#line 347 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
int rec_sex_ast_node_index(rec_sex_ast_node_t node ) 
{ 


  {
#line 350
  return (node->index);
}
}
#line 353 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_node_set_index(rec_sex_ast_node_t node , int index___0 ) 
{ 


  {
#line 357
  node->index = index___0;
#line 358
  return;
}
}
#line 360 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
void rec_sex_ast_print(rec_sex_ast_t ast ) 
{ 


  {
  {
#line 363
  rec_sex_ast_print_node(ast->top);
  }
#line 364
  return;
}
}
#line 366 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
_Bool rec_sex_ast_name_p_1(rec_sex_ast_node_t node , char const   *name , size_t idx ) 
{ 
  size_t i ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 371
  i = (size_t )0;
#line 373
  if (node) {
#line 375
    if ((unsigned int )node->type == 27U) {
#line 375
      if (node->index == -1) {
#line 375
        goto _L;
      } else
#line 375
      if ((size_t )node->index < idx) {
        _L: /* CIL Label */ 
        {
#line 375
        tmp = strcmp(name, (char const   *)node->val.name[0]);
        }
#line 375
        if (tmp == 0) {
#line 379
          return ((_Bool)1);
        }
      }
    }
#line 382
    i = (size_t )0;
    {
#line 382
    while (1) {
      while_continue: /* CIL Label */ ;
#line 382
      if (! (i < node->num_children)) {
#line 382
        goto while_break;
      }
      {
#line 384
      tmp___0 = rec_sex_ast_name_p_1(node->children[i], name, idx);
      }
#line 384
      if (tmp___0) {
#line 386
        return ((_Bool)1);
      }
#line 382
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 391
  return ((_Bool)0);
}
}
#line 394 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
_Bool rec_sex_ast_name_p(rec_sex_ast_t ast , char const   *name , size_t idx ) 
{ 
  _Bool tmp ;

  {
  {
#line 402
  tmp = rec_sex_ast_name_p_1(ast->top, name, idx);
  }
#line 402
  return (tmp);
}
}
#line 407 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
static _Bool rec_sex_ast_hash_name_p_1(rec_sex_ast_node_t node , char const   *name ) 
{ 
  size_t i ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 411
  if (node) {
#line 413
    i = (size_t )0;
#line 415
    if ((unsigned int )node->type == 17U) {
#line 415
      if (node->num_children == 1UL) {
#line 415
        if ((unsigned int )(node->children[0])->type == 27U) {
          {
#line 415
          tmp = strcmp(name, (char const   *)(node->children[0])->val.name[0]);
          }
#line 415
          if (tmp == 0) {
#line 419
            return ((_Bool)1);
          }
        }
      }
    }
#line 421
    i = (size_t )0;
    {
#line 421
    while (1) {
      while_continue: /* CIL Label */ ;
#line 421
      if (! (i < node->num_children)) {
#line 421
        goto while_break;
      }
      {
#line 422
      tmp___0 = rec_sex_ast_hash_name_p_1(node->children[i], name);
      }
#line 422
      if (tmp___0) {
#line 423
        return ((_Bool)1);
      }
#line 421
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 426
  return ((_Bool)0);
}
}
#line 429 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-ast.c"
_Bool rec_sex_ast_hash_name_p(rec_sex_ast_t ast , char const   *name ) 
{ 
  _Bool tmp ;

  {
  {
#line 435
  tmp = rec_sex_ast_hash_name_p_1(ast->top, name);
  }
#line 435
  return (tmp);
}
}
#line 49 "./rec-sex-parser.h"
void rec_sex_parser_set_in(rec_sex_parser_t parser , char const   *str ) ;
#line 55 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
rec_sex_parser_t rec_sex_parser_new(void) 
{ 
  rec_sex_parser_t new ;
  void *tmp ;

  {
  {
#line 60
  tmp = malloc(sizeof(struct rec_sex_parser_s ));
#line 60
  new = (rec_sex_parser_t )tmp;
  }
#line 61
  if (new) {
    {
#line 63
    new->in = (char *)((void *)0);
#line 64
    new->index = (size_t )0;
#line 65
    new->case_insensitive = (_Bool)0;
#line 68
    sexlex_init(& new->scanner);
#line 69
    sexset_extra(new, new->scanner);
    }
  }
#line 72
  return (new);
}
}
#line 75 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
void *rec_sex_parser_scanner(rec_sex_parser_t parser ) 
{ 


  {
#line 78
  return (parser->scanner);
}
}
#line 81 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
void rec_sex_parser_destroy(rec_sex_parser_t parser ) 
{ 


  {
#line 84
  if (parser->scanner) {
    {
#line 86
    sexlex_destroy(parser->scanner);
    }
  }
  {
#line 89
  free((void *)parser->in);
#line 90
  free((void *)parser);
  }
#line 91
  return;
}
}
#line 93 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
rec_sex_ast_t rec_sex_parser_ast(rec_sex_parser_t parser ) 
{ 


  {
#line 96
  return (parser->ast);
}
}
#line 99 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
void rec_sex_parser_set_ast(rec_sex_parser_t parser , rec_sex_ast_t ast ) 
{ 


  {
#line 103
  parser->ast = ast;
#line 104
  return;
}
}
#line 106 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
_Bool rec_sex_parser_case_insensitive(rec_sex_parser_t parser ) 
{ 


  {
#line 109
  return (parser->case_insensitive);
}
}
#line 112 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
void rec_sex_parser_set_case_insensitive(rec_sex_parser_t parser , _Bool case_insensitive ) 
{ 


  {
#line 116
  parser->case_insensitive = case_insensitive;
#line 117
  return;
}
}
#line 119 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
void rec_sex_parser_set_in(rec_sex_parser_t parser , char const   *str ) 
{ 


  {
#line 123
  if (parser->in) {
    {
#line 125
    free((void *)parser->in);
#line 126
    parser->in = (char *)((void *)0);
    }
  }
  {
#line 129
  parser->in = strdup(str);
#line 130
  parser->index = (size_t )0;
  }
#line 131
  return;
}
}
#line 133 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
int rec_sex_parser_getc(rec_sex_parser_t parser ) 
{ 
  int res ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 138
  res = -1;
#line 139
  if (parser->in) {
    {
#line 139
    tmp___0 = strlen((char const   *)parser->in);
    }
#line 139
    if (parser->index < tmp___0) {
#line 142
      tmp = parser->index;
#line 142
      (parser->index) ++;
#line 142
      res = (int )*(parser->in + tmp);
    }
  }
#line 145
  return (res);
}
}
#line 148 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
_Bool rec_sex_parser_run(rec_sex_parser_t parser , char const   *expr ) 
{ 
  int res ;
  int tmp ;

  {
  {
#line 154
  rec_sex_parser_set_in(parser, expr);
#line 155
  tmp = sexparse(parser);
  }
#line 155
  if (tmp) {
#line 162
    res = 0;
  } else {
#line 157
    res = 1;
  }
#line 165
  return ((_Bool )res);
}
}
#line 168 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-sex-parser.c"
void rec_sex_parser_print_ast(rec_sex_parser_t parser ) 
{ 


  {
  {
#line 171
  rec_sex_ast_print(parser->ast);
  }
#line 172
  return;
}
}
#line 144 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 432 "./rec.h"
char const   *rec_std_field_name(enum rec_std_field_e std_field ) ;
#line 775
char const   *rec_field_source(rec_field_t field ) ;
#line 795
char const   *rec_field_location_str(rec_field_t field ) ;
#line 918
char *rec_record_source(rec_record_t record ) ;
#line 937
char *rec_record_location_str(rec_record_t record ) ;
#line 975
size_t rec_record_get_field_index_by_name(rec_record_t record , rec_field_t field ) ;
#line 1118
size_t rec_rset_num_records(rec_rset_t rset ) ;
#line 1130
rec_record_t rec_rset_descriptor(rec_rset_t rset ) ;
#line 1139
void rec_rset_set_descriptor(rec_rset_t rset , rec_record_t record ) ;
#line 1164
char *rec_rset_type(rec_rset_t rset ) ;
#line 1178
rec_type_reg_t rec_rset_get_type_reg(rec_rset_t rset ) ;
#line 1184
rec_type_t rec_rset_get_field_type(rec_rset_t rset , char const   *field_name ) ;
#line 1193
size_t rec_rset_min_records(rec_rset_t rset ) ;
#line 1199
size_t rec_rset_max_records(rec_rset_t rset ) ;
#line 1207
size_t rec_rset_num_sex_constraints(rec_rset_t rset ) ;
#line 1213
rec_sex_t rec_rset_sex_constraint(rec_rset_t rset , size_t index___0 ) ;
#line 1235
char const   *rec_rset_key(rec_rset_t rset ) ;
#line 1252
char *rec_rset_source(rec_rset_t rset ) ;
#line 1323
void rec_db_destroy(rec_db_t db ) ;
#line 1330
size_t rec_db_size(rec_db_t db ) ;
#line 1338
rec_rset_t rec_db_get_rset(rec_db_t db , size_t position ) ;
#line 1367
rec_rset_t rec_db_get_rset_by_type(rec_db_t db , char const   *type ) ;
#line 1807
int rec_int_check_db(rec_db_t db , _Bool check_descriptors_p , _Bool remote_descriptors_p ,
                     rec_buf_t errors ) ;
#line 1816
int rec_int_check_rset(rec_db_t db , rec_rset_t rset , _Bool check_descriptor_p ,
                       _Bool remote_descriptor_p , rec_buf_t errors ) ;
#line 1826
int rec_int_check_record(rec_db_t db , rec_rset_t rset , rec_record_t orig_record ,
                         rec_record_t record , rec_buf_t errors ) ;
#line 1836
_Bool rec_int_check_field_type(rec_db_t db , rec_rset_t rset , rec_field_t field ,
                               rec_buf_t errors ) ;
#line 1858
rec_parser_t rec_parser_new(FILE *in , char const   *source ) ;
#line 1877
void rec_parser_destroy(rec_parser_t parser ) ;
#line 1890
char *rec_parse_field_name_str(char const   *str ) ;
#line 1920
_Bool rec_parse_db(rec_parser_t parser , rec_db_t *db ) ;
#line 60 "./rec-utils.h"
char *rec_extract_url(char const   *str ) ;
#line 61
char *rec_extract_file(char const   *str ) ;
#line 62
char *rec_extract_type(char const   *str ) ;
#line 48 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_descriptor(rec_rset_t rset , rec_buf_t errors ) ;
#line 49
static int rec_int_check_record_key(rec_rset_t rset , rec_record_t orig_record , rec_record_t record ,
                                    rec_buf_t errors ) ;
#line 52
static int rec_int_check_record_types(rec_db_t db , rec_rset_t rset , rec_record_t record ,
                                      rec_buf_t errors ) ;
#line 56
static int rec_int_check_record_mandatory(rec_rset_t rset , rec_record_t record ,
                                          rec_buf_t errors ) ;
#line 58
static int rec_int_check_record_unique(rec_rset_t rset , rec_record_t record , rec_buf_t errors ) ;
#line 60
static int rec_int_check_record_prohibit(rec_rset_t rset , rec_record_t record , rec_buf_t errors ) ;
#line 62
static int rec_int_check_record_sex_constraints(rec_rset_t rset , rec_record_t record ,
                                                rec_buf_t errors ) ;
#line 64
static int rec_int_check_record_allowed(rec_rset_t rset , rec_record_t record , rec_buf_t errors ) ;
#line 72
static int rec_int_merge_remote(rec_rset_t rset , rec_buf_t errors ) ;
#line 73
static _Bool rec_int_rec_type_p(char const   *str ) ;
#line 96 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
int rec_int_check_db(rec_db_t db , _Bool check_descriptors_p , _Bool remote_descriptors_p ,
                     rec_buf_t errors ) 
{ 
  int ret ;
  size_t db_size ;
  size_t n_rset ;
  rec_rset_t rset ;
  int tmp ;

  {
  {
#line 107
  ret = 0;
#line 109
  db_size = rec_db_size(db);
#line 110
  n_rset = (size_t )0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (n_rset < db_size)) {
#line 110
      goto while_break;
    }
    {
#line 112
    rset = rec_db_get_rset(db, n_rset);
#line 113
    tmp = rec_int_check_rset(db, rset, check_descriptors_p, remote_descriptors_p,
                             errors);
#line 113
    ret += tmp;
#line 110
    n_rset ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return (ret);
}
}
#line 123 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
int rec_int_check_rset(rec_db_t db , rec_rset_t rset , _Bool check_descriptor_p ,
                       _Bool remote_descriptor_p , rec_buf_t errors ) 
{ 
  int res ;
  rec_mset_iterator_t iter ;
  rec_record_t record ;
  rec_record_t descriptor ;
  size_t num_records ;
  size_t min_records ;
  size_t max_records ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  rec_mset_t tmp___19 ;
  int tmp___20 ;
  _Bool tmp___21 ;

  {
#line 136
  res = 0;
#line 138
  if (remote_descriptor_p) {
    {
#line 138
    descriptor = rec_rset_descriptor(rset);
    }
#line 138
    if (descriptor) {
      {
#line 143
      descriptor = rec_record_dup(descriptor);
#line 148
      res = rec_int_merge_remote(rset, errors);
      }
#line 149
      if (res > 0) {
#line 151
        return (res);
      }
    }
  }
#line 155
  if (check_descriptor_p) {
    {
#line 157
    tmp = rec_int_check_descriptor(rset, errors);
#line 157
    res += tmp;
    }
  }
#line 160
  if (res > 0) {
#line 164
    return (res);
  }
  {
#line 168
  num_records = rec_rset_num_records(rset);
#line 169
  min_records = rec_rset_min_records(rset);
#line 170
  max_records = rec_rset_max_records(rset);
  }
#line 172
  if (min_records == max_records) {
#line 174
    if (num_records != min_records) {
      {
#line 176
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 176
        tmp___0 = (char *)((void *)0);
#line 176
        tmp___1 = rec_rset_type(rset);
#line 176
        tmp___2 = rec_rset_source(rset);
#line 176
        tmp___3 = dcgettext("recutils", "%s: error: the number of records of type %s should be %zd.\n",
                            5);
#line 176
        tmp___4 = asprintf((char **/* __restrict  */)(& tmp___0), (char const   */* __restrict  */)tmp___3,
                           tmp___2, tmp___1, min_records);
        }
#line 176
        if (tmp___4 != -1) {
          {
#line 176
          rec_buf_puts((char const   *)tmp___0, errors);
#line 176
          free((void *)tmp___0);
          }
        }
#line 176
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 179
      res ++;
    }
  } else {
    {
#line 184
    tmp___11 = rec_rset_max_records(rset);
    }
#line 184
    if (num_records > tmp___11) {
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 186
        tmp___5 = (char *)((void *)0);
#line 186
        tmp___6 = rec_rset_max_records(rset);
#line 186
        tmp___7 = rec_rset_type(rset);
#line 186
        tmp___8 = rec_rset_source(rset);
#line 186
        tmp___9 = dcgettext("recutils", "%s: error: too many records of type %s. Maximum allowed are %zd.\n",
                            5);
#line 186
        tmp___10 = asprintf((char **/* __restrict  */)(& tmp___5), (char const   */* __restrict  */)tmp___9,
                            tmp___8, tmp___7, tmp___6);
        }
#line 186
        if (tmp___10 != -1) {
          {
#line 186
          rec_buf_puts((char const   *)tmp___5, errors);
#line 186
          free((void *)tmp___5);
          }
        }
#line 186
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      res ++;
    }
    {
#line 191
    tmp___18 = rec_rset_min_records(rset);
    }
#line 191
    if (num_records < tmp___18) {
      {
#line 193
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 193
        tmp___12 = (char *)((void *)0);
#line 193
        tmp___13 = rec_rset_min_records(rset);
#line 193
        tmp___14 = rec_rset_type(rset);
#line 193
        tmp___15 = rec_rset_source(rset);
#line 193
        tmp___16 = dcgettext("recutils", "%s: error: too few records of type %s. Minimum allowed are %zd.\n",
                             5);
#line 193
        tmp___17 = asprintf((char **/* __restrict  */)(& tmp___12), (char const   */* __restrict  */)tmp___16,
                            tmp___15, tmp___14, tmp___13);
        }
#line 193
        if (tmp___17 != -1) {
          {
#line 193
          rec_buf_puts((char const   *)tmp___12, errors);
#line 193
          free((void *)tmp___12);
          }
        }
#line 193
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 196
      res ++;
    }
  }
  {
#line 200
  tmp___19 = rec_rset_mset(rset);
#line 200
  iter = rec_mset_iterator(tmp___19);
  }
  {
#line 201
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 201
    tmp___21 = rec_mset_iterator_next(& iter, 1, (void const   **)(& record), (rec_mset_elem_t *)((void *)0));
    }
#line 201
    if (! tmp___21) {
#line 201
      goto while_break___2;
    }
    {
#line 203
    tmp___20 = rec_int_check_record(db, rset, record, record, errors);
#line 203
    res += tmp___20;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 209
  rec_mset_iterator_free(& iter);
  }
#line 211
  if (remote_descriptor_p) {
    {
#line 214
    rec_rset_set_descriptor(rset, descriptor);
    }
  }
#line 217
  return (res);
}
}
#line 220 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
int rec_int_check_record(rec_db_t db , rec_rset_t rset , rec_record_t orig_record ,
                         rec_record_t record , rec_buf_t errors ) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 229
  tmp = rec_int_check_record_key(rset, orig_record, record, errors);
#line 229
  tmp___0 = rec_int_check_record_types(db, rset, record, errors);
#line 229
  tmp___1 = rec_int_check_record_mandatory(rset, record, errors);
#line 229
  tmp___2 = rec_int_check_record_unique(rset, record, errors);
#line 229
  tmp___3 = rec_int_check_record_prohibit(rset, record, errors);
#line 229
  tmp___4 = rec_int_check_record_sex_constraints(rset, record, errors);
#line 229
  tmp___5 = rec_int_check_record_allowed(rset, record, errors);
#line 229
  res = (((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + tmp___4) + tmp___5;
  }
#line 241
  return (res);
}
}
#line 244 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
_Bool rec_int_check_field_type(rec_db_t db , rec_rset_t rset , rec_field_t field ,
                               rec_buf_t errors ) 
{ 
  _Bool res ;
  rec_type_t type ;
  char *errors_str ;
  char const   *tmp ;
  char const   *rset_type ;
  char const   *tmp___0 ;
  rec_rset_t rset___0 ;
  rec_rset_t tmp___1 ;
  char const   *key ;
  char const   *tmp___2 ;
  rec_type_t key_type ;
  rec_type_t tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  _Bool tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  _Bool tmp___15 ;
  enum rec_type_kind_e tmp___16 ;

  {
  {
#line 250
  res = (_Bool)1;
#line 254
  res = (_Bool)1;
#line 260
  tmp = rec_field_name(field);
#line 260
  type = rec_rset_get_field_type(rset, tmp);
  }
#line 269
  if (type) {
    {
#line 271
    tmp___16 = rec_type_kind(type);
    }
#line 271
    if ((unsigned int )tmp___16 == 13U) {
      {
#line 281
      tmp___0 = rec_type_rec(type);
#line 281
      rset_type = tmp___0;
#line 282
      tmp___1 = rec_db_get_rset_by_type(db, rset_type);
#line 282
      rset___0 = tmp___1;
      }
#line 284
      if (rset___0) {
        {
#line 286
        tmp___2 = rec_rset_key(rset___0);
#line 286
        key = tmp___2;
#line 287
        tmp___3 = rec_rset_get_field_type(rset___0, key);
#line 287
        key_type = tmp___3;
        }
#line 289
        if (key_type) {
          {
#line 291
          tmp___8 = rec_field_value(field);
#line 291
          tmp___9 = rec_type_check(key_type, tmp___8, & errors_str);
          }
#line 291
          if (! tmp___9) {
#line 293
            if (errors) {
              {
#line 295
              while (1) {
                while_continue: /* CIL Label */ ;
                {
#line 295
                tmp___4 = (char *)((void *)0);
#line 295
                tmp___5 = rec_field_location_str(field);
#line 295
                tmp___6 = rec_field_source(field);
#line 295
                tmp___7 = asprintf((char **/* __restrict  */)(& tmp___4), (char const   */* __restrict  */)"%s:%s: error: %s\n",
                                   tmp___6, tmp___5, errors_str);
                }
#line 295
                if (tmp___7 != -1) {
                  {
#line 295
                  rec_buf_puts((char const   *)tmp___4, errors);
#line 295
                  free((void *)tmp___4);
                  }
                }
#line 295
                goto while_break;
              }
              while_break: /* CIL Label */ ;
              }
            }
            {
#line 300
            free((void *)errors_str);
#line 301
            res = (_Bool)0;
            }
          }
        }
      }
    } else {
      {
#line 308
      tmp___14 = rec_field_value(field);
#line 308
      tmp___15 = rec_type_check(type, tmp___14, & errors_str);
      }
#line 308
      if (! tmp___15) {
#line 310
        if (errors) {
          {
#line 312
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 312
            tmp___10 = (char *)((void *)0);
#line 312
            tmp___11 = rec_field_location_str(field);
#line 312
            tmp___12 = rec_field_source(field);
#line 312
            tmp___13 = asprintf((char **/* __restrict  */)(& tmp___10), (char const   */* __restrict  */)"%s:%s: error: %s\n",
                                tmp___12, tmp___11, errors_str);
            }
#line 312
            if (tmp___13 != -1) {
              {
#line 312
              rec_buf_puts((char const   *)tmp___10, errors);
#line 312
              free((void *)tmp___10);
              }
            }
#line 312
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
        {
#line 317
        free((void *)errors_str);
#line 318
        res = (_Bool)0;
        }
      }
    }
  }
#line 323
  return (res);
}
}
#line 330 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static rec_fex_t rec_int_collect_field_list(rec_record_t record , char const   *fname ) 
{ 
  size_t i ;
  size_t j ;
  size_t num_fields ;
  size_t tmp ;
  rec_fex_t res ;
  rec_fex_t tmp___0 ;
  rec_field_t field ;
  rec_field_t tmp___1 ;
  rec_fex_t fex ;
  char const   *tmp___2 ;
  rec_fex_t tmp___3 ;
  rec_fex_elem_t elem ;
  rec_fex_elem_t tmp___4 ;
  char *field_name ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  rec_fex_elem_t tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 334
  j = (size_t )0;
#line 335
  tmp = rec_record_get_num_fields_by_name(record, fname);
#line 335
  num_fields = tmp;
#line 336
  tmp___0 = rec_fex_new((char const   *)((void *)0), (enum rec_fex_kind_e )0);
#line 336
  res = tmp___0;
  }
#line 338
  if (! res) {
#line 339
    return ((rec_fex_t )((void *)0));
  }
#line 341
  i = (size_t )0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (i < num_fields)) {
#line 341
      goto while_break;
    }
    {
#line 343
    tmp___1 = rec_record_get_field_by_name(record, fname, i);
#line 343
    field = tmp___1;
#line 344
    tmp___2 = rec_field_value(field);
#line 344
    tmp___3 = rec_fex_new(tmp___2, (enum rec_fex_kind_e )0);
#line 344
    fex = tmp___3;
    }
#line 345
    if (! fex) {
#line 347
      goto __Cont;
    }
#line 349
    j = (size_t )0;
    {
#line 349
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 349
      tmp___10 = rec_fex_size(fex);
      }
#line 349
      if (! (j < tmp___10)) {
#line 349
        goto while_break___0;
      }
      {
#line 351
      tmp___4 = rec_fex_get(fex, j);
#line 351
      elem = tmp___4;
#line 352
      tmp___5 = rec_fex_elem_field_name(elem);
#line 352
      tmp___6 = strdup(tmp___5);
#line 352
      field_name = tmp___6;
      }
#line 354
      if (! field_name) {
#line 360
        return ((rec_fex_t )((void *)0));
      } else {
        {
#line 354
        tmp___7 = rec_fex_elem_max(elem);
#line 354
        tmp___8 = rec_fex_elem_min(elem);
#line 354
        tmp___9 = rec_fex_append(res, (char const   *)field_name, tmp___8, tmp___7);
        }
#line 354
        if (! tmp___9) {
#line 360
          return ((rec_fex_t )((void *)0));
        }
      }
#line 349
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 362
    rec_fex_destroy(fex);
    }
    __Cont: /* CIL Label */ 
#line 341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return (res);
}
}
#line 368 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_record_types(rec_db_t db , rec_rset_t rset , rec_record_t record ,
                                      rec_buf_t errors ) 
{ 
  int res ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 378
  res = 0;
#line 380
  tmp = rec_record_mset(record);
#line 380
  iter = rec_mset_iterator(tmp);
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 381
    tmp___1 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 381
    if (! tmp___1) {
#line 381
      goto while_break;
    }
    {
#line 384
    tmp___0 = rec_int_check_field_type(db, rset, field, errors);
    }
#line 384
    if (! tmp___0) {
#line 386
      res ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 390
  rec_mset_iterator_free(& iter);
  }
#line 392
  return (res);
}
}
#line 395 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_record_mandatory(rec_rset_t rset , rec_record_t record ,
                                          rec_buf_t errors ) 
{ 
  rec_fex_t fex_mandatory ;
  int res ;
  size_t i ;
  rec_record_t descriptor ;
  rec_record_t tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *fname ;
  rec_fex_elem_t tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 400
  fex_mandatory = (rec_fex_t )((void *)0);
#line 401
  res = 0;
#line 404
  tmp = rec_rset_descriptor(rset);
#line 404
  descriptor = tmp;
  }
#line 405
  if (descriptor) {
    {
#line 407
    tmp___0 = rec_std_field_name((enum rec_std_field_e )3);
#line 407
    fex_mandatory = rec_int_collect_field_list(descriptor, tmp___0);
    }
#line 408
    if (! fex_mandatory) {
      {
#line 410
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 410
        tmp___1 = (char *)((void *)0);
#line 410
        tmp___2 = dcgettext("recutils", "out of memory\n", 5);
#line 410
        tmp___3 = asprintf((char **/* __restrict  */)(& tmp___1), (char const   */* __restrict  */)tmp___2,
                           "");
        }
#line 410
        if (tmp___3 != -1) {
          {
#line 410
          rec_buf_puts((char const   *)tmp___1, errors);
#line 410
          free((void *)tmp___1);
          }
        }
#line 410
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      res = 1;
#line 412
      goto cleanup;
    }
#line 418
    i = (size_t )0;
    {
#line 418
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 418
      tmp___12 = rec_fex_size(fex_mandatory);
      }
#line 418
      if (! (i < tmp___12)) {
#line 418
        goto while_break___0;
      }
      {
#line 420
      tmp___4 = rec_fex_get(fex_mandatory, i);
#line 420
      tmp___5 = rec_fex_elem_field_name(tmp___4);
#line 420
      fname = tmp___5;
#line 421
      tmp___11 = rec_record_get_num_fields_by_name(record, fname);
      }
#line 421
      if (tmp___11 == 0UL) {
        {
#line 424
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 424
          tmp___6 = (char *)((void *)0);
#line 424
          tmp___7 = rec_record_location_str(record);
#line 424
          tmp___8 = rec_record_source(record);
#line 424
          tmp___9 = dcgettext("recutils", "%s:%s: error: mandatory field \'%s\' not found in record\n",
                              5);
#line 424
          tmp___10 = asprintf((char **/* __restrict  */)(& tmp___6), (char const   */* __restrict  */)tmp___9,
                              tmp___8, tmp___7, fname);
          }
#line 424
          if (tmp___10 != -1) {
            {
#line 424
            rec_buf_puts((char const   *)tmp___6, errors);
#line 424
            free((void *)tmp___6);
            }
          }
#line 424
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 429
        res ++;
      }
#line 418
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  cleanup: 
  {
#line 436
  rec_fex_destroy(fex_mandatory);
  }
#line 437
  return (res);
}
}
#line 440 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_record_allowed(rec_rset_t rset , rec_record_t record , rec_buf_t errors ) 
{ 
  rec_fex_t fex_allowed ;
  rec_fex_t fex_mandatory ;
  rec_fex_t fex_key ;
  int res ;
  rec_record_t descriptor ;
  rec_record_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp___7 ;
  rec_mset_iterator_t tmp___8 ;
  char const   *field_name ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;

  {
  {
#line 449
  fex_allowed = (rec_fex_t )((void *)0);
#line 450
  fex_mandatory = (rec_fex_t )((void *)0);
#line 451
  fex_key = (rec_fex_t )((void *)0);
#line 453
  res = 0;
#line 454
  tmp = rec_rset_descriptor(rset);
#line 454
  descriptor = tmp;
  }
#line 456
  if (descriptor) {
    {
#line 458
    tmp___0 = rec_std_field_name((enum rec_std_field_e )12);
#line 458
    fex_allowed = rec_int_collect_field_list(descriptor, tmp___0);
#line 459
    tmp___1 = rec_std_field_name((enum rec_std_field_e )3);
#line 459
    fex_mandatory = rec_int_collect_field_list(descriptor, tmp___1);
#line 460
    tmp___2 = rec_std_field_name((enum rec_std_field_e )2);
#line 460
    fex_key = rec_int_collect_field_list(descriptor, tmp___2);
    }
#line 462
    if (! fex_allowed) {
#line 462
      goto _L;
    } else
#line 462
    if (! fex_mandatory) {
#line 462
      goto _L;
    } else
#line 462
    if (! fex_key) {
      _L: /* CIL Label */ 
      {
#line 464
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 464
        tmp___3 = (char *)((void *)0);
#line 464
        tmp___4 = dcgettext("recutils", "out of memory\n", 5);
#line 464
        tmp___5 = asprintf((char **/* __restrict  */)(& tmp___3), (char const   */* __restrict  */)tmp___4,
                           "");
        }
#line 464
        if (tmp___5 != -1) {
          {
#line 464
          rec_buf_puts((char const   *)tmp___3, errors);
#line 464
          free((void *)tmp___3);
          }
        }
#line 464
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 465
      res = 1;
#line 466
      goto cleanup;
    }
    {
#line 470
    tmp___6 = rec_fex_size(fex_allowed);
    }
#line 470
    if (tmp___6 == 0UL) {
#line 472
      goto cleanup;
    }
    {
#line 477
    field = (rec_field_t )((void *)0);
#line 478
    tmp___7 = rec_record_mset(record);
#line 478
    tmp___8 = rec_mset_iterator(tmp___7);
#line 478
    iter = tmp___8;
    }
    {
#line 479
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 479
      tmp___18 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
      }
#line 479
      if (! tmp___18) {
#line 479
        goto while_break___0;
      }
      {
#line 481
      tmp___9 = rec_field_name(field);
#line 481
      field_name = tmp___9;
#line 482
      tmp___15 = rec_fex_member_p(fex_allowed, field_name, -1, -1);
      }
#line 482
      if (! tmp___15) {
        {
#line 482
        tmp___16 = rec_fex_member_p(fex_mandatory, field_name, -1, -1);
        }
#line 482
        if (! tmp___16) {
          {
#line 482
          tmp___17 = rec_fex_member_p(fex_key, field_name, -1, -1);
          }
#line 482
          if (! tmp___17) {
            {
#line 487
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 487
              tmp___10 = (char *)((void *)0);
#line 487
              tmp___11 = rec_record_location_str(record);
#line 487
              tmp___12 = rec_record_source(record);
#line 487
              tmp___13 = dcgettext("recutils", "%s:%s: error: field \'%s\' not allowed in this record set\n",
                                   5);
#line 487
              tmp___14 = asprintf((char **/* __restrict  */)(& tmp___10), (char const   */* __restrict  */)tmp___13,
                                  tmp___12, tmp___11, field_name);
              }
#line 487
              if (tmp___14 != -1) {
                {
#line 487
                rec_buf_puts((char const   *)tmp___10, errors);
#line 487
                free((void *)tmp___10);
                }
              }
#line 487
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 492
            res ++;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 495
    rec_mset_iterator_free(& iter);
    }
  }
  cleanup: 
  {
#line 500
  rec_fex_destroy(fex_allowed);
#line 501
  rec_fex_destroy(fex_mandatory);
#line 502
  rec_fex_destroy(fex_key);
  }
#line 503
  return (res);
}
}
#line 506 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_record_unique(rec_rset_t rset , rec_record_t record , rec_buf_t errors ) 
{ 
  rec_fex_t fex_unique ;
  int res ;
  size_t i ;
  rec_record_t descriptor ;
  rec_record_t tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *fname ;
  rec_fex_elem_t tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 511
  fex_unique = (rec_fex_t )((void *)0);
#line 512
  res = 0;
#line 515
  tmp = rec_rset_descriptor(rset);
#line 515
  descriptor = tmp;
  }
#line 516
  if (descriptor) {
    {
#line 518
    tmp___0 = rec_std_field_name((enum rec_std_field_e )10);
#line 518
    fex_unique = rec_int_collect_field_list(descriptor, tmp___0);
    }
#line 519
    if (! fex_unique) {
      {
#line 521
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 521
        tmp___1 = (char *)((void *)0);
#line 521
        tmp___2 = dcgettext("recutils", "out of memory\n", 5);
#line 521
        tmp___3 = asprintf((char **/* __restrict  */)(& tmp___1), (char const   */* __restrict  */)tmp___2,
                           "");
        }
#line 521
        if (tmp___3 != -1) {
          {
#line 521
          rec_buf_puts((char const   *)tmp___1, errors);
#line 521
          free((void *)tmp___1);
          }
        }
#line 521
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 522
      res = 1;
#line 523
      goto cleanup;
    }
#line 529
    i = (size_t )0;
    {
#line 529
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 529
      tmp___12 = rec_fex_size(fex_unique);
      }
#line 529
      if (! (i < tmp___12)) {
#line 529
        goto while_break___0;
      }
      {
#line 531
      tmp___4 = rec_fex_get(fex_unique, i);
#line 531
      tmp___5 = rec_fex_elem_field_name(tmp___4);
#line 531
      fname = tmp___5;
#line 532
      tmp___11 = rec_record_get_num_fields_by_name(record, fname);
      }
#line 532
      if (tmp___11 > 1UL) {
        {
#line 534
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 534
          tmp___6 = (char *)((void *)0);
#line 534
          tmp___7 = rec_record_location_str(record);
#line 534
          tmp___8 = rec_record_source(record);
#line 534
          tmp___9 = dcgettext("recutils", "%s:%s: error: field \'%s\' should be unique in this record\n",
                              5);
#line 534
          tmp___10 = asprintf((char **/* __restrict  */)(& tmp___6), (char const   */* __restrict  */)tmp___9,
                              tmp___8, tmp___7, fname);
          }
#line 534
          if (tmp___10 != -1) {
            {
#line 534
            rec_buf_puts((char const   *)tmp___6, errors);
#line 534
            free((void *)tmp___6);
            }
          }
#line 534
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 539
        res ++;
      }
#line 529
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  cleanup: 
  {
#line 546
  rec_fex_destroy(fex_unique);
  }
#line 547
  return (res);
}
}
#line 550 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_record_prohibit(rec_rset_t rset , rec_record_t record , rec_buf_t errors ) 
{ 
  rec_fex_t fex_prohibit ;
  int res ;
  size_t i ;
  rec_record_t descriptor ;
  rec_record_t tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *fname ;
  rec_fex_elem_t tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 555
  fex_prohibit = (rec_fex_t )((void *)0);
#line 556
  res = 0;
#line 559
  tmp = rec_rset_descriptor(rset);
#line 559
  descriptor = tmp;
  }
#line 560
  if (descriptor) {
    {
#line 562
    tmp___0 = rec_std_field_name((enum rec_std_field_e )4);
#line 562
    fex_prohibit = rec_int_collect_field_list(descriptor, tmp___0);
    }
#line 563
    if (! fex_prohibit) {
      {
#line 565
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 565
        tmp___1 = (char *)((void *)0);
#line 565
        tmp___2 = dcgettext("recutils", "out of memory\n", 5);
#line 565
        tmp___3 = asprintf((char **/* __restrict  */)(& tmp___1), (char const   */* __restrict  */)tmp___2,
                           "");
        }
#line 565
        if (tmp___3 != -1) {
          {
#line 565
          rec_buf_puts((char const   *)tmp___1, errors);
#line 565
          free((void *)tmp___1);
          }
        }
#line 565
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 566
      res = 1;
#line 567
      goto cleanup;
    }
#line 573
    i = (size_t )0;
    {
#line 573
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 573
      tmp___12 = rec_fex_size(fex_prohibit);
      }
#line 573
      if (! (i < tmp___12)) {
#line 573
        goto while_break___0;
      }
      {
#line 575
      tmp___4 = rec_fex_get(fex_prohibit, i);
#line 575
      tmp___5 = rec_fex_elem_field_name(tmp___4);
#line 575
      fname = tmp___5;
#line 576
      tmp___11 = rec_record_get_num_fields_by_name(record, fname);
      }
#line 576
      if (tmp___11 > 0UL) {
        {
#line 578
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 578
          tmp___6 = (char *)((void *)0);
#line 578
          tmp___7 = rec_record_location_str(record);
#line 578
          tmp___8 = rec_record_source(record);
#line 578
          tmp___9 = dcgettext("recutils", "%s:%s: error: prohibited field \'%s\' found in record\n",
                              5);
#line 578
          tmp___10 = asprintf((char **/* __restrict  */)(& tmp___6), (char const   */* __restrict  */)tmp___9,
                              tmp___8, tmp___7, fname);
          }
#line 578
          if (tmp___10 != -1) {
            {
#line 578
            rec_buf_puts((char const   *)tmp___6, errors);
#line 578
            free((void *)tmp___6);
            }
          }
#line 578
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 583
        res ++;
      }
#line 573
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  cleanup: 
  {
#line 590
  rec_fex_destroy(fex_prohibit);
  }
#line 591
  return (res);
}
}
#line 594 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_record_sex_constraints(rec_rset_t rset , rec_record_t record ,
                                                rec_buf_t errors ) 
{ 
  int res ;
  size_t i ;
  size_t num_constraints ;
  size_t tmp ;
  _Bool status ;
  rec_sex_t sex ;
  rec_sex_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
  {
#line 599
  res = 0;
#line 600
  i = (size_t )0;
#line 601
  tmp = rec_rset_num_sex_constraints(rset);
#line 601
  num_constraints = tmp;
#line 603
  i = (size_t )0;
  }
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (i < num_constraints)) {
#line 603
      goto while_break;
    }
    {
#line 605
    status = (_Bool)0;
#line 606
    tmp___0 = rec_rset_sex_constraint(rset, i);
#line 606
    sex = tmp___0;
#line 608
    tmp___6 = rec_sex_eval(sex, record, & status);
    }
#line 608
    if (! tmp___6) {
      {
#line 610
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 610
        tmp___1 = (char *)((void *)0);
#line 610
        tmp___2 = rec_record_location_str(record);
#line 610
        tmp___3 = rec_record_source(record);
#line 610
        tmp___4 = dcgettext("recutils", "%s:%s: error: %%constraint[%d] violated in record\n",
                            5);
#line 610
        tmp___5 = asprintf((char **/* __restrict  */)(& tmp___1), (char const   */* __restrict  */)tmp___4,
                           tmp___3, tmp___2, i);
        }
#line 610
        if (tmp___5 != -1) {
          {
#line 610
          rec_buf_puts((char const   *)tmp___1, errors);
#line 610
          free((void *)tmp___1);
          }
        }
#line 610
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 615
      res ++;
    }
#line 603
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return (res);
}
}
#line 662 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_record_key(rec_rset_t rset , rec_record_t orig_record , rec_record_t record ,
                                    rec_buf_t errors ) 
{ 
  int res ;
  rec_record_t descriptor ;
  rec_record_t other_record ;
  rec_mset_iterator_t iter ;
  char *key_field_name ;
  rec_field_t field ;
  rec_field_t key ;
  rec_field_t other_key ;
  _Bool duplicated_key ;
  size_t i ;
  size_t num_fields ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  rec_mset_t tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char const   *tmp___24 ;
  size_t tmp___25 ;

  {
  {
#line 680
  res = 0;
#line 682
  descriptor = rec_rset_descriptor(rset);
  }
#line 683
  if (descriptor) {
#line 685
    i = (size_t )0;
    {
#line 685
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 685
      tmp___24 = rec_std_field_name((enum rec_std_field_e )2);
#line 685
      tmp___25 = rec_record_get_num_fields_by_name(descriptor, tmp___24);
      }
#line 685
      if (! (i < tmp___25)) {
#line 685
        goto while_break;
      }
      {
#line 689
      tmp = rec_std_field_name((enum rec_std_field_e )2);
#line 689
      field = rec_record_get_field_by_name(descriptor, tmp, i);
#line 692
      tmp___0 = rec_field_value(field);
#line 692
      key_field_name = rec_parse_field_name_str(tmp___0);
      }
#line 693
      if (key_field_name) {
        {
#line 695
        num_fields = rec_record_get_num_fields_by_name(record, (char const   *)key_field_name);
        }
#line 697
        if (num_fields == 0UL) {
          {
#line 699
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 699
            tmp___1 = (char *)((void *)0);
#line 699
            tmp___2 = rec_field_value(field);
#line 699
            tmp___3 = rec_record_location_str(record);
#line 699
            tmp___4 = rec_record_source(record);
#line 699
            tmp___5 = dcgettext("recutils", "%s:%s: error: key field \'%s\' not found in record\n",
                                5);
#line 699
            tmp___6 = asprintf((char **/* __restrict  */)(& tmp___1), (char const   */* __restrict  */)tmp___5,
                               tmp___4, tmp___3, tmp___2);
            }
#line 699
            if (tmp___6 != -1) {
              {
#line 699
              rec_buf_puts((char const   *)tmp___1, errors);
#line 699
              free((void *)tmp___1);
              }
            }
#line 699
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 704
          res ++;
        } else
#line 706
        if (num_fields > 1UL) {
          {
#line 708
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 708
            tmp___7 = (char *)((void *)0);
#line 708
            tmp___8 = rec_field_value(field);
#line 708
            tmp___9 = rec_record_location_str(record);
#line 708
            tmp___10 = rec_record_source(record);
#line 708
            tmp___11 = dcgettext("recutils", "%s:%s: error: multiple key fields \'%s\' in record\n",
                                 5);
#line 708
            tmp___12 = asprintf((char **/* __restrict  */)(& tmp___7), (char const   */* __restrict  */)tmp___11,
                                tmp___10, tmp___9, tmp___8);
            }
#line 708
            if (tmp___12 != -1) {
              {
#line 708
              rec_buf_puts((char const   *)tmp___7, errors);
#line 708
              free((void *)tmp___7);
              }
            }
#line 708
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 713
          res ++;
        } else {
          {
#line 719
          key = rec_record_get_field_by_name(record, (char const   *)key_field_name,
                                             (size_t )0);
#line 722
          duplicated_key = (_Bool)0;
#line 724
          tmp___13 = rec_rset_mset(rset);
#line 724
          iter = rec_mset_iterator(tmp___13);
          }
          {
#line 725
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 725
            tmp___17 = rec_mset_iterator_next(& iter, 1, (void const   **)(& other_record),
                                              (rec_mset_elem_t *)((void *)0));
            }
#line 725
            if (! tmp___17) {
#line 725
              goto while_break___2;
            }
#line 727
            if ((unsigned long )other_record != (unsigned long )orig_record) {
              {
#line 730
              other_key = rec_record_get_field_by_name(other_record, (char const   *)key_field_name,
                                                       (size_t )0);
              }
#line 733
              if (other_key) {
                {
#line 735
                tmp___14 = rec_field_value(key);
#line 735
                tmp___15 = rec_field_value(other_key);
#line 735
                tmp___16 = strcmp(tmp___15, tmp___14);
                }
#line 735
                if (tmp___16 == 0) {
#line 740
                  duplicated_key = (_Bool)1;
#line 741
                  goto while_break___2;
                }
              }
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 747
          rec_mset_iterator_free(& iter);
          }
#line 749
          if (duplicated_key) {
            {
#line 751
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 751
              tmp___18 = (char *)((void *)0);
#line 751
              tmp___19 = rec_field_name(key);
#line 751
              tmp___20 = rec_record_location_str(orig_record);
#line 751
              tmp___21 = rec_record_source(orig_record);
#line 751
              tmp___22 = dcgettext("recutils", "%s:%s: error: duplicated key value in field \'%s\' in record\n",
                                   5);
#line 751
              tmp___23 = asprintf((char **/* __restrict  */)(& tmp___18), (char const   */* __restrict  */)tmp___22,
                                  tmp___21, tmp___20, tmp___19);
              }
#line 751
              if (tmp___23 != -1) {
                {
#line 751
                rec_buf_puts((char const   *)tmp___18, errors);
#line 751
                free((void *)tmp___18);
                }
              }
#line 751
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 756
            res ++;
#line 757
            goto while_break;
          }
        }
        {
#line 761
        free((void *)key_field_name);
        }
      }
#line 685
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 766
  return (res);
}
}
#line 769 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_check_descriptor(rec_rset_t rset , rec_buf_t errors ) 
{ 
  int res ;
  rec_record_t descriptor ;
  rec_mset_iterator_t iter ;
  rec_field_t field ;
  char const   *field_name ;
  char const   *field_value ;
  rec_fex_t fex ;
  char const   *auto_field_name ;
  size_t i ;
  rec_type_t type ;
  char *type_name ;
  char const   *p ;
  char const   *q ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  _Bool tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  size_t tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  size_t tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  char const   *tmp___41 ;
  size_t tmp___42 ;
  rec_mset_t tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  char const   *tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  _Bool tmp___49 ;
  char *tmp___50 ;
  char const   *tmp___51 ;
  char const   *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  rec_type_reg_t tmp___55 ;
  rec_type_t tmp___56 ;
  char *tmp___57 ;
  char const   *tmp___58 ;
  char const   *tmp___59 ;
  char *tmp___60 ;
  int tmp___61 ;
  _Bool tmp___62 ;
  _Bool tmp___63 ;
  char *tmp___64 ;
  char const   *tmp___65 ;
  char const   *tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  _Bool tmp___69 ;
  char *tmp___70 ;
  char const   *tmp___71 ;
  char const   *tmp___72 ;
  char *tmp___73 ;
  int tmp___74 ;
  rec_type_reg_t tmp___75 ;
  rec_type_t tmp___76 ;
  char *tmp___77 ;
  char const   *tmp___78 ;
  char const   *tmp___79 ;
  char *tmp___80 ;
  int tmp___81 ;
  _Bool tmp___82 ;
  _Bool tmp___83 ;
  rec_sex_t sex ;
  rec_sex_t tmp___84 ;
  char *tmp___85 ;
  size_t tmp___86 ;
  char const   *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  int tmp___91 ;
  _Bool tmp___92 ;
  char *tmp___93 ;
  size_t tmp___94 ;
  char const   *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  int tmp___99 ;
  char *tmp___100 ;
  char const   *tmp___101 ;
  char const   *tmp___102 ;
  char *tmp___103 ;
  int tmp___104 ;
  _Bool tmp___105 ;
  char const   *tmp___106 ;
  _Bool tmp___107 ;
  char const   *tmp___108 ;
  _Bool tmp___109 ;
  char const   *tmp___110 ;
  _Bool tmp___111 ;
  char const   *tmp___112 ;
  _Bool tmp___113 ;
  char const   *tmp___114 ;
  _Bool tmp___115 ;
  char const   *tmp___116 ;
  _Bool tmp___117 ;
  char const   *tmp___118 ;
  _Bool tmp___119 ;
  char const   *tmp___120 ;
  _Bool tmp___121 ;
  char const   *tmp___122 ;
  _Bool tmp___123 ;
  char const   *tmp___124 ;
  _Bool tmp___125 ;
  rec_fex_elem_t tmp___126 ;
  char *tmp___127 ;
  char *tmp___128 ;
  char *tmp___129 ;
  char *tmp___130 ;
  int tmp___131 ;
  enum rec_type_kind_e tmp___132 ;
  enum rec_type_kind_e tmp___133 ;
  enum rec_type_kind_e tmp___134 ;
  size_t tmp___135 ;
  char const   *tmp___136 ;
  _Bool tmp___137 ;
  _Bool tmp___138 ;

  {
  {
#line 783
  type_name = (char *)((void *)0);
#line 784
  q = (char const   *)((void *)0);
#line 786
  res = 0;
#line 788
  descriptor = rec_rset_descriptor(rset);
  }
#line 789
  if (descriptor) {
    {
#line 797
    tmp___11 = rec_std_field_name((enum rec_std_field_e )5);
#line 797
    tmp___12 = rec_record_get_num_fields_by_name(descriptor, tmp___11);
    }
#line 797
    if (tmp___12 == 0UL) {
      {
#line 799
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 799
        tmp = (char *)((void *)0);
#line 799
        tmp___0 = rec_record_location_str(descriptor);
#line 799
        tmp___1 = rec_record_source(descriptor);
#line 799
        tmp___2 = dcgettext("recutils", "%s:%s: error: missing %%rec field in record descriptor\n",
                            5);
#line 799
        tmp___3 = asprintf((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)tmp___2,
                           tmp___1, tmp___0);
        }
#line 799
        if (tmp___3 != -1) {
          {
#line 799
          rec_buf_puts((char const   *)tmp, errors);
#line 799
          free((void *)tmp);
          }
        }
#line 799
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 803
      res ++;
    } else {
      {
#line 805
      tmp___9 = rec_std_field_name((enum rec_std_field_e )5);
#line 805
      tmp___10 = rec_record_get_num_fields_by_name(descriptor, tmp___9);
      }
#line 805
      if (tmp___10 > 1UL) {
        {
#line 807
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 807
          tmp___4 = (char *)((void *)0);
#line 807
          tmp___5 = rec_record_location_str(descriptor);
#line 807
          tmp___6 = rec_record_source(descriptor);
#line 807
          tmp___7 = dcgettext("recutils", "%s:%s: error: too many %%rec fields in record descriptor\n",
                              5);
#line 807
          tmp___8 = asprintf((char **/* __restrict  */)(& tmp___4), (char const   */* __restrict  */)tmp___7,
                             tmp___6, tmp___5);
          }
#line 807
          if (tmp___8 != -1) {
            {
#line 807
            rec_buf_puts((char const   *)tmp___4, errors);
#line 807
            free((void *)tmp___4);
            }
          }
#line 807
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 811
        res ++;
      }
    }
    {
#line 814
    tmp___13 = rec_std_field_name((enum rec_std_field_e )5);
#line 814
    field = rec_record_get_field_by_name(descriptor, tmp___13, (size_t )0);
#line 815
    tmp___20 = rec_field_value(field);
#line 815
    tmp___21 = rec_int_rec_type_p(tmp___20);
    }
#line 815
    if (! tmp___21) {
      {
#line 817
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 817
        tmp___14 = (char *)((void *)0);
#line 817
        tmp___15 = rec_field_value(field);
#line 817
        tmp___16 = rec_field_location_str(field);
#line 817
        tmp___17 = rec_field_source(field);
#line 817
        tmp___18 = dcgettext("recutils", "%s:%s: error: invalid record type %s\n",
                             5);
#line 817
        tmp___19 = asprintf((char **/* __restrict  */)(& tmp___14), (char const   */* __restrict  */)tmp___18,
                            tmp___17, tmp___16, tmp___15);
        }
#line 817
        if (tmp___19 != -1) {
          {
#line 817
          rec_buf_puts((char const   *)tmp___14, errors);
#line 817
          free((void *)tmp___14);
          }
        }
#line 817
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 822
      res ++;
    }
    {
#line 826
    tmp___27 = rec_std_field_name((enum rec_std_field_e )2);
#line 826
    tmp___28 = rec_record_get_num_fields_by_name(descriptor, tmp___27);
    }
#line 826
    if (tmp___28 > 1UL) {
      {
#line 828
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 828
        tmp___22 = (char *)((void *)0);
#line 828
        tmp___23 = rec_record_location_str(descriptor);
#line 828
        tmp___24 = rec_record_source(descriptor);
#line 828
        tmp___25 = dcgettext("recutils", "%s:%s: error: only one %%key field is allowed in a record descriptor\n",
                             5);
#line 828
        tmp___26 = asprintf((char **/* __restrict  */)(& tmp___22), (char const   */* __restrict  */)tmp___25,
                            tmp___24, tmp___23);
        }
#line 828
        if (tmp___26 != -1) {
          {
#line 828
          rec_buf_puts((char const   *)tmp___22, errors);
#line 828
          free((void *)tmp___22);
          }
        }
#line 828
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 832
      res ++;
    }
    {
#line 836
    tmp___34 = rec_std_field_name((enum rec_std_field_e )6);
#line 836
    tmp___35 = rec_record_get_num_fields_by_name(descriptor, tmp___34);
    }
#line 836
    if (tmp___35 > 1UL) {
      {
#line 838
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 838
        tmp___29 = (char *)((void *)0);
#line 838
        tmp___30 = rec_record_location_str(descriptor);
#line 838
        tmp___31 = rec_record_source(descriptor);
#line 838
        tmp___32 = dcgettext("recutils", "%s:%s: error: only one %%size field is allowed in a record descriptor\n",
                             5);
#line 838
        tmp___33 = asprintf((char **/* __restrict  */)(& tmp___29), (char const   */* __restrict  */)tmp___32,
                            tmp___31, tmp___30);
        }
#line 838
        if (tmp___33 != -1) {
          {
#line 838
          rec_buf_puts((char const   *)tmp___29, errors);
#line 838
          free((void *)tmp___29);
          }
        }
#line 838
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 842
      res ++;
    }
    {
#line 846
    tmp___41 = rec_std_field_name((enum rec_std_field_e )7);
#line 846
    tmp___42 = rec_record_get_num_fields_by_name(descriptor, tmp___41);
    }
#line 846
    if (tmp___42 > 1UL) {
      {
#line 848
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 848
        tmp___36 = (char *)((void *)0);
#line 848
        tmp___37 = rec_record_location_str(descriptor);
#line 848
        tmp___38 = rec_record_source(descriptor);
#line 848
        tmp___39 = dcgettext("recutils", "%s:%s: error: only one %%sort field is allowed in a record descriptor\n",
                             5);
#line 848
        tmp___40 = asprintf((char **/* __restrict  */)(& tmp___36), (char const   */* __restrict  */)tmp___39,
                            tmp___38, tmp___37);
        }
#line 848
        if (tmp___40 != -1) {
          {
#line 848
          rec_buf_puts((char const   *)tmp___36, errors);
#line 848
          free((void *)tmp___36);
          }
        }
#line 848
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 852
      res ++;
    }
    {
#line 857
    tmp___43 = rec_record_mset(descriptor);
#line 857
    iter = rec_mset_iterator(tmp___43);
    }
    {
#line 858
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 858
      tmp___138 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
      }
#line 858
      if (! tmp___138) {
#line 858
        goto while_break___5;
      }
      {
#line 860
      field_name = rec_field_name(field);
#line 861
      field_value = rec_field_value(field);
#line 863
      tmp___124 = rec_std_field_name((enum rec_std_field_e )8);
#line 863
      tmp___125 = rec_field_name_equal_p(field_name, tmp___124);
      }
#line 863
      if (tmp___125) {
        {
#line 866
        p = field_value;
#line 867
        rec_skip_blanks(& p);
#line 868
        tmp___49 = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*(,[a-zA-Z%][a-zA-Z0-9_]*)*",
                                    (char **)((void *)0));
        }
#line 868
        if (! tmp___49) {
          {
#line 871
          while (1) {
            while_continue___6: /* CIL Label */ ;
            {
#line 871
            tmp___44 = (char *)((void *)0);
#line 871
            tmp___45 = rec_field_location_str(field);
#line 871
            tmp___46 = rec_field_source(field);
#line 871
            tmp___47 = dcgettext("recutils", "%s:%s: error: expected a comma-separated list of fields before the type specification\n",
                                 5);
#line 871
            tmp___48 = asprintf((char **/* __restrict  */)(& tmp___44), (char const   */* __restrict  */)tmp___47,
                                tmp___46, tmp___45);
            }
#line 871
            if (tmp___48 != -1) {
              {
#line 871
              rec_buf_puts((char const   *)tmp___44, errors);
#line 871
              free((void *)tmp___44);
              }
            }
#line 871
            goto while_break___6;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 876
          res ++;
        }
        {
#line 881
        rec_skip_blanks(& p);
#line 882
        tmp___63 = rec_type_descr_p(p);
        }
#line 882
        if (! tmp___63) {
          {
#line 884
          q = p;
#line 885
          tmp___62 = rec_parse_regexp(& q, "^[a-zA-Z][a-zA-Z0-9_-]*[ \t\n]*$", (char **)((void *)0));
          }
#line 885
          if (tmp___62) {
            {
#line 894
            rec_parse_regexp(& p, "^[a-zA-Z][a-zA-Z0-9_-]*", & type_name);
#line 895
            tmp___55 = rec_rset_get_type_reg(rset);
#line 895
            tmp___56 = rec_type_reg_get(tmp___55, (char const   *)type_name);
            }
#line 895
            if (! tmp___56) {
              {
#line 897
              while (1) {
                while_continue___7: /* CIL Label */ ;
                {
#line 897
                tmp___50 = (char *)((void *)0);
#line 897
                tmp___51 = rec_field_location_str(field);
#line 897
                tmp___52 = rec_field_source(field);
#line 897
                tmp___53 = dcgettext("recutils", "%s:%s: error: the referred type %s does not exist\n",
                                     5);
#line 897
                tmp___54 = asprintf((char **/* __restrict  */)(& tmp___50), (char const   */* __restrict  */)tmp___53,
                                    tmp___52, tmp___51, type_name);
                }
#line 897
                if (tmp___54 != -1) {
                  {
#line 897
                  rec_buf_puts((char const   *)tmp___50, errors);
#line 897
                  free((void *)tmp___50);
                  }
                }
#line 897
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 903
              res ++;
            }
          } else {
            {
#line 909
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 909
              tmp___57 = (char *)((void *)0);
#line 909
              tmp___58 = rec_field_location_str(field);
#line 909
              tmp___59 = rec_field_source(field);
#line 909
              tmp___60 = dcgettext("recutils", "%s:%s: error: invalid type specification\n",
                                   5);
#line 909
              tmp___61 = asprintf((char **/* __restrict  */)(& tmp___57), (char const   */* __restrict  */)tmp___60,
                                  tmp___59, tmp___58);
              }
#line 909
              if (tmp___61 != -1) {
                {
#line 909
                rec_buf_puts((char const   *)tmp___57, errors);
#line 909
                free((void *)tmp___57);
                }
              }
#line 909
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 913
            res ++;
          }
        }
      } else {
        {
#line 917
        tmp___122 = rec_std_field_name((enum rec_std_field_e )9);
#line 917
        tmp___123 = rec_field_name_equal_p(field_name, tmp___122);
        }
#line 917
        if (tmp___123) {
          {
#line 920
          p = field_value;
#line 921
          rec_skip_blanks(& p);
#line 922
          tmp___69 = rec_parse_regexp(& p, "^[a-zA-Z][a-zA-Z0-9_-]*", (char **)((void *)0));
          }
#line 922
          if (! tmp___69) {
            {
#line 924
            while (1) {
              while_continue___9: /* CIL Label */ ;
              {
#line 924
              tmp___64 = (char *)((void *)0);
#line 924
              tmp___65 = rec_field_location_str(field);
#line 924
              tmp___66 = rec_field_source(field);
#line 924
              tmp___67 = dcgettext("recutils", "%s:%s: error: expected a type name before the type specification\n",
                                   5);
#line 924
              tmp___68 = asprintf((char **/* __restrict  */)(& tmp___64), (char const   */* __restrict  */)tmp___67,
                                  tmp___66, tmp___65);
              }
#line 924
              if (tmp___68 != -1) {
                {
#line 924
                rec_buf_puts((char const   *)tmp___64, errors);
#line 924
                free((void *)tmp___64);
                }
              }
#line 924
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 929
            res ++;
          }
          {
#line 934
          rec_skip_blanks(& p);
#line 935
          tmp___83 = rec_type_descr_p(p);
          }
#line 935
          if (! tmp___83) {
            {
#line 937
            q = p;
#line 938
            tmp___82 = rec_parse_regexp(& q, "^[a-zA-Z][a-zA-Z0-9_-]*[ \t\n]*$", (char **)((void *)0));
            }
#line 938
            if (tmp___82) {
              {
#line 947
              rec_parse_regexp(& p, "^[a-zA-Z][a-zA-Z0-9_-]*", & type_name);
#line 948
              tmp___75 = rec_rset_get_type_reg(rset);
#line 948
              tmp___76 = rec_type_reg_get(tmp___75, (char const   *)type_name);
              }
#line 948
              if (! tmp___76) {
                {
#line 950
                while (1) {
                  while_continue___10: /* CIL Label */ ;
                  {
#line 950
                  tmp___70 = (char *)((void *)0);
#line 950
                  tmp___71 = rec_field_location_str(field);
#line 950
                  tmp___72 = rec_field_source(field);
#line 950
                  tmp___73 = dcgettext("recutils", "%s:%s: error: the referred type %s does not exist\n",
                                       5);
#line 950
                  tmp___74 = asprintf((char **/* __restrict  */)(& tmp___70), (char const   */* __restrict  */)tmp___73,
                                      tmp___72, tmp___71, type_name);
                  }
#line 950
                  if (tmp___74 != -1) {
                    {
#line 950
                    rec_buf_puts((char const   *)tmp___70, errors);
#line 950
                    free((void *)tmp___70);
                    }
                  }
#line 950
                  goto while_break___10;
                }
                while_break___10: /* CIL Label */ ;
                }
#line 956
                res ++;
              }
            } else {
              {
#line 962
              while (1) {
                while_continue___11: /* CIL Label */ ;
                {
#line 962
                tmp___77 = (char *)((void *)0);
#line 962
                tmp___78 = rec_field_location_str(field);
#line 962
                tmp___79 = rec_field_source(field);
#line 962
                tmp___80 = dcgettext("recutils", "%s:%s: error: invalid typedef specification\n",
                                     5);
#line 962
                tmp___81 = asprintf((char **/* __restrict  */)(& tmp___77), (char const   */* __restrict  */)tmp___80,
                                    tmp___79, tmp___78);
                }
#line 962
                if (tmp___81 != -1) {
                  {
#line 962
                  rec_buf_puts((char const   *)tmp___77, errors);
#line 962
                  free((void *)tmp___77);
                  }
                }
#line 962
                goto while_break___11;
              }
              while_break___11: /* CIL Label */ ;
              }
#line 966
              res ++;
            }
          }
        } else {
          {
#line 970
          tmp___120 = rec_std_field_name((enum rec_std_field_e )11);
#line 970
          tmp___121 = rec_field_name_equal_p(field_name, tmp___120);
          }
#line 970
          if (tmp___121) {
            {
#line 975
            tmp___84 = rec_sex_new((_Bool)0);
#line 975
            sex = tmp___84;
            }
#line 976
            if (sex) {
              {
#line 978
              tmp___92 = rec_sex_compile(sex, field_value);
              }
#line 978
              if (tmp___92) {
                {
#line 980
                rec_sex_destroy(sex);
                }
              } else {
                {
#line 984
                while (1) {
                  while_continue___12: /* CIL Label */ ;
                  {
#line 984
                  tmp___85 = (char *)((void *)0);
#line 984
                  tmp___86 = rec_record_get_field_index_by_name(descriptor, field);
#line 984
                  tmp___87 = rec_field_name(field);
#line 984
                  tmp___88 = rec_record_location_str(descriptor);
#line 984
                  tmp___89 = rec_record_source(descriptor);
#line 984
                  tmp___90 = dcgettext("recutils", "%s:%s: error: value for %s[%zd] is not a valid selection expression\n",
                                       5);
#line 984
                  tmp___91 = asprintf((char **/* __restrict  */)(& tmp___85), (char const   */* __restrict  */)tmp___90,
                                      tmp___89, tmp___88, tmp___87, tmp___86);
                  }
#line 984
                  if (tmp___91 != -1) {
                    {
#line 984
                    rec_buf_puts((char const   *)tmp___85, errors);
#line 984
                    free((void *)tmp___85);
                    }
                  }
#line 984
                  goto while_break___12;
                }
                while_break___12: /* CIL Label */ ;
                }
#line 990
                res ++;
              }
            } else {
#line 996
              res ++;
            }
          } else {
            {
#line 999
            tmp___108 = rec_std_field_name((enum rec_std_field_e )3);
#line 999
            tmp___109 = rec_field_name_equal_p(field_name, tmp___108);
            }
#line 999
            if (tmp___109) {
#line 999
              goto _L;
            } else {
              {
#line 999
              tmp___110 = rec_std_field_name((enum rec_std_field_e )10);
#line 999
              tmp___111 = rec_field_name_equal_p(field_name, tmp___110);
              }
#line 999
              if (tmp___111) {
#line 999
                goto _L;
              } else {
                {
#line 999
                tmp___112 = rec_std_field_name((enum rec_std_field_e )4);
#line 999
                tmp___113 = rec_field_name_equal_p(field_name, tmp___112);
                }
#line 999
                if (tmp___113) {
#line 999
                  goto _L;
                } else {
                  {
#line 999
                  tmp___114 = rec_std_field_name((enum rec_std_field_e )0);
#line 999
                  tmp___115 = rec_field_name_equal_p(field_name, tmp___114);
                  }
#line 999
                  if (tmp___115) {
#line 999
                    goto _L;
                  } else {
                    {
#line 999
                    tmp___116 = rec_std_field_name((enum rec_std_field_e )7);
#line 999
                    tmp___117 = rec_field_name_equal_p(field_name, tmp___116);
                    }
#line 999
                    if (tmp___117) {
#line 999
                      goto _L;
                    } else {
                      {
#line 999
                      tmp___118 = rec_std_field_name((enum rec_std_field_e )12);
#line 999
                      tmp___119 = rec_field_name_equal_p(field_name, tmp___118);
                      }
#line 999
                      if (tmp___119) {
                        _L: /* CIL Label */ 
                        {
#line 1008
                        fex = rec_fex_new(field_value, (enum rec_fex_kind_e )0);
                        }
#line 1009
                        if (fex) {
                          {
#line 1011
                          rec_fex_destroy(fex);
                          }
                        } else {
                          {
#line 1015
                          while (1) {
                            while_continue___13: /* CIL Label */ ;
                            {
#line 1015
                            tmp___93 = (char *)((void *)0);
#line 1015
                            tmp___94 = rec_record_get_field_index_by_name(descriptor,
                                                                          field);
#line 1015
                            tmp___95 = rec_field_name(field);
#line 1015
                            tmp___96 = rec_record_location_str(descriptor);
#line 1015
                            tmp___97 = rec_record_source(descriptor);
#line 1015
                            tmp___98 = dcgettext("recutils", "%s:%s: error: value for %s[%zd] is not a list of field names\n",
                                                 5);
#line 1015
                            tmp___99 = asprintf((char **/* __restrict  */)(& tmp___93),
                                                (char const   */* __restrict  */)tmp___98,
                                                tmp___97, tmp___96, tmp___95, tmp___94);
                            }
#line 1015
                            if (tmp___99 != -1) {
                              {
#line 1015
                              rec_buf_puts((char const   *)tmp___93, errors);
#line 1015
                              free((void *)tmp___93);
                              }
                            }
#line 1015
                            goto while_break___13;
                          }
                          while_break___13: /* CIL Label */ ;
                          }
#line 1021
                          res ++;
                        }
                      } else {
                        {
#line 1024
                        tmp___106 = rec_std_field_name((enum rec_std_field_e )6);
#line 1024
                        tmp___107 = rec_field_name_equal_p(field_name, tmp___106);
                        }
#line 1024
                        if (tmp___107) {
                          {
#line 1026
                          tmp___105 = rec_match(field_value, "^[ \t\n]*(>|<|>=|<=)?[ \t\n]*-?((0x[0-9a-fA-F]+)|[0-9]+)[ \t\n]*$");
                          }
#line 1026
                          if (! tmp___105) {
                            {
#line 1028
                            while (1) {
                              while_continue___14: /* CIL Label */ ;
                              {
#line 1028
                              tmp___100 = (char *)((void *)0);
#line 1028
                              tmp___101 = rec_field_location_str(field);
#line 1028
                              tmp___102 = rec_field_source(field);
#line 1028
                              tmp___103 = dcgettext("recutils", "%s:%s: error: value for %s should be a number optionally preceded by >, <, >= or <=.\n",
                                                    5);
#line 1028
                              tmp___104 = asprintf((char **/* __restrict  */)(& tmp___100),
                                                   (char const   */* __restrict  */)tmp___103,
                                                   tmp___102, tmp___101, field_name);
                              }
#line 1028
                              if (tmp___104 != -1) {
                                {
#line 1028
                                rec_buf_puts((char const   *)tmp___100, errors);
#line 1028
                                free((void *)tmp___100);
                                }
                              }
#line 1028
                              goto while_break___14;
                            }
                            while_break___14: /* CIL Label */ ;
                            }
#line 1033
                            res ++;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      {
#line 1054
      tmp___136 = rec_std_field_name((enum rec_std_field_e )0);
#line 1054
      tmp___137 = rec_field_name_equal_p(field_name, tmp___136);
      }
#line 1054
      if (tmp___137) {
        {
#line 1054
        fex = rec_fex_new(field_value, (enum rec_fex_kind_e )0);
        }
#line 1054
        if (fex) {
#line 1059
          i = (size_t )0;
          {
#line 1059
          while (1) {
            while_continue___15: /* CIL Label */ ;
            {
#line 1059
            tmp___135 = rec_fex_size(fex);
            }
#line 1059
            if (! (i < tmp___135)) {
#line 1059
              goto while_break___15;
            }
            {
#line 1061
            tmp___126 = rec_fex_get(fex, i);
#line 1061
            auto_field_name = rec_fex_elem_field_name(tmp___126);
#line 1062
            type = rec_rset_get_field_type(rset, auto_field_name);
            }
#line 1063
            if (! type) {
#line 1063
              goto _L___0;
            } else {
              {
#line 1063
              tmp___132 = rec_type_kind(type);
              }
#line 1063
              if (! ((unsigned int )tmp___132 == 1U)) {
                {
#line 1063
                tmp___133 = rec_type_kind(type);
                }
#line 1063
                if (! ((unsigned int )tmp___133 == 3U)) {
                  {
#line 1063
                  tmp___134 = rec_type_kind(type);
                  }
#line 1063
                  if (! ((unsigned int )tmp___134 == 8U)) {
                    _L___0: /* CIL Label */ 
                    {
#line 1071
                    while (1) {
                      while_continue___16: /* CIL Label */ ;
                      {
#line 1071
                      tmp___127 = (char *)((void *)0);
#line 1071
                      tmp___128 = rec_record_location_str(descriptor);
#line 1071
                      tmp___129 = rec_record_source(descriptor);
#line 1071
                      tmp___130 = dcgettext("recutils", "%s:%s: error: auto-incremented field %s should be of type int, range or date\n",
                                            5);
#line 1071
                      tmp___131 = asprintf((char **/* __restrict  */)(& tmp___127),
                                           (char const   */* __restrict  */)tmp___130,
                                           tmp___129, tmp___128, auto_field_name);
                      }
#line 1071
                      if (tmp___131 != -1) {
                        {
#line 1071
                        rec_buf_puts((char const   *)tmp___127, errors);
#line 1071
                        free((void *)tmp___127);
                        }
                      }
#line 1071
                      goto while_break___16;
                    }
                    while_break___16: /* CIL Label */ ;
                    }
#line 1080
                    res ++;
                  }
                }
              }
            }
#line 1059
            i ++;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1086
    rec_mset_iterator_free(& iter);
    }
  }
#line 1089
  return (res);
}
}
#line 1092 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static int rec_int_merge_remote(rec_rset_t rset , rec_buf_t errors ) 
{ 
  int res ;
  rec_parser_t parser ;
  rec_record_t descriptor ;
  rec_db_t remote_db ;
  rec_rset_t remote_rset ;
  rec_field_t remote_field ;
  rec_mset_iterator_t iter ;
  rec_record_t remote_descriptor ;
  rec_field_t rec_field ;
  char *rec_type ;
  char *rec_url ;
  char *rec_file ;
  char *rec_source ;
  FILE *external_file ;
  char tmpfile_name[14] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  rec_mset_t tmp___21 ;
  rec_field_t tmp___22 ;
  rec_mset_t tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;
  rec_record_t tmp___28 ;

  {
  {
#line 1106
  rec_url = (char *)((void *)0);
#line 1107
  rec_file = (char *)((void *)0);
#line 1108
  rec_source = (char *)((void *)0);
#line 1112
  res = 0;
#line 1114
  tmpfile_name[0] = (char )'\000';
#line 1119
  descriptor = rec_rset_descriptor(rset);
  }
#line 1120
  if (descriptor) {
    {
#line 1123
    tmp = rec_std_field_name((enum rec_std_field_e )5);
#line 1123
    rec_field = rec_record_get_field_by_name(descriptor, tmp, (size_t )0);
#line 1125
    tmp___0 = rec_field_value(rec_field);
#line 1125
    tmp___1 = rec_int_rec_type_p(tmp___0);
    }
#line 1125
    if (! tmp___1) {
#line 1127
      return (0);
    }
    {
#line 1130
    tmp___2 = rec_field_value(rec_field);
#line 1130
    rec_type = rec_extract_type(tmp___2);
#line 1131
    tmp___3 = rec_field_value(rec_field);
#line 1131
    rec_file = rec_extract_file(tmp___3);
#line 1132
    tmp___4 = rec_field_value(rec_field);
#line 1132
    rec_url = rec_extract_url(tmp___4);
    }
#line 1134
    if (rec_file) {
#line 1134
      goto _L;
    } else
#line 1134
    if (rec_url) {
      _L: /* CIL Label */ 
#line 1136
      if (rec_url) {
#line 1167
        goto exit;
      } else {
        {
#line 1173
        external_file = fopen((char const   */* __restrict  */)rec_file, (char const   */* __restrict  */)"r");
        }
#line 1174
        if (! external_file) {
          {
#line 1176
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 1176
            tmp___5 = (char *)((void *)0);
#line 1176
            tmp___6 = rec_field_location_str(rec_field);
#line 1176
            tmp___7 = rec_field_source(rec_field);
#line 1176
            tmp___8 = dcgettext("recutils", "%s:%s: error: could not read external descriptor from file %s.\n",
                                5);
#line 1176
            tmp___9 = asprintf((char **/* __restrict  */)(& tmp___5), (char const   */* __restrict  */)tmp___8,
                               tmp___7, tmp___6, rec_file);
            }
#line 1176
            if (tmp___9 != -1) {
              {
#line 1176
              rec_buf_puts((char const   *)tmp___5, errors);
#line 1176
              free((void *)tmp___5);
              }
            }
#line 1176
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
#line 1180
          res ++;
#line 1181
          goto exit;
        }
#line 1183
        rec_source = rec_file;
      }
      {
#line 1187
      fseek(external_file, 0L, 0);
#line 1188
      parser = rec_parser_new(external_file, (char const   *)rec_source);
#line 1189
      tmp___15 = rec_parse_db(parser, & remote_db);
      }
#line 1189
      if (! tmp___15) {
        {
#line 1191
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1191
          tmp___10 = (char *)((void *)0);
#line 1191
          tmp___11 = rec_field_location_str(rec_field);
#line 1191
          tmp___12 = rec_field_source(rec_field);
#line 1191
          tmp___13 = dcgettext("recutils", "%s:%s: error: %s does not contain valid rec data.\n",
                               5);
#line 1191
          tmp___14 = asprintf((char **/* __restrict  */)(& tmp___10), (char const   */* __restrict  */)tmp___13,
                              tmp___12, tmp___11, rec_source);
          }
#line 1191
          if (tmp___14 != -1) {
            {
#line 1191
            rec_buf_puts((char const   *)tmp___10, errors);
#line 1191
            free((void *)tmp___10);
            }
          }
#line 1191
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1195
        res ++;
#line 1196
        goto exit;
      }
      {
#line 1198
      rec_parser_destroy(parser);
#line 1202
      remote_rset = rec_db_get_rset_by_type(remote_db, (char const   *)rec_type);
      }
#line 1203
      if (! remote_rset) {
        {
#line 1205
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1205
          tmp___16 = (char *)((void *)0);
#line 1205
          tmp___17 = rec_field_location_str(rec_field);
#line 1205
          tmp___18 = rec_field_source(rec_field);
#line 1205
          tmp___19 = dcgettext("recutils", "%s:%s: error: %s does not contain information for type %s.\n",
                               5);
#line 1205
          tmp___20 = asprintf((char **/* __restrict  */)(& tmp___16), (char const   */* __restrict  */)tmp___19,
                              tmp___18, tmp___17, rec_source, rec_type);
          }
#line 1205
          if (tmp___20 != -1) {
            {
#line 1205
            rec_buf_puts((char const   *)tmp___16, errors);
#line 1205
            free((void *)tmp___16);
            }
          }
#line 1205
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1209
        res ++;
#line 1210
        goto exit;
      }
      {
#line 1212
      remote_descriptor = rec_rset_descriptor(remote_rset);
      }
#line 1213
      if (! remote_descriptor) {
#line 1216
        goto exit;
      }
      {
#line 1219
      tmp___21 = rec_record_mset(remote_descriptor);
#line 1219
      iter = rec_mset_iterator(tmp___21);
      }
      {
#line 1220
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1220
        tmp___27 = rec_mset_iterator_next(& iter, 1, (void const   **)(& remote_field),
                                          (rec_mset_elem_t *)((void *)0));
        }
#line 1220
        if (! tmp___27) {
#line 1220
          goto while_break___2;
        }
        {
#line 1225
        tmp___24 = rec_std_field_name((enum rec_std_field_e )5);
#line 1225
        tmp___25 = rec_field_name(remote_field);
#line 1225
        tmp___26 = rec_field_name_equal_p(tmp___25, tmp___24);
        }
#line 1225
        if (! tmp___26) {
          {
#line 1227
          tmp___22 = rec_field_dup(remote_field);
#line 1227
          tmp___23 = rec_record_mset(descriptor);
#line 1227
          rec_mset_append(tmp___23, 1, (void *)tmp___22, 0);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1231
      rec_mset_iterator_free(& iter);
#line 1235
      tmp___28 = rec_record_dup(descriptor);
#line 1235
      rec_rset_set_descriptor(rset, tmp___28);
#line 1237
      rec_db_destroy(remote_db);
#line 1238
      fclose(external_file);
      }
    }
  }
  exit: 
#line 1244
  if (rec_url) {
#line 1244
    if ((int )tmpfile_name[0] != 0) {
      {
#line 1246
      remove((char const   *)(tmpfile_name));
      }
    }
  }
  {
#line 1249
  free((void *)rec_url);
#line 1250
  free((void *)rec_file);
  }
#line 1252
  return (res);
}
}
#line 1255 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-int.c"
static _Bool rec_int_rec_type_p(char const   *str ) 
{ 
  _Bool tmp ;

  {
  {
#line 1258
  tmp = rec_match(str, "^[ \t]*[a-zA-Z%][a-zA-Z0-9_]*[ \n\t]*(((file|http|ftp|https)://[^ \t]+)|((/?[^/ \t\n]+)+)[ \t]*)?$");
  }
#line 1258
  return (tmp);
}
}
#line 264 "./rec.h"
int rec_mset_elem_type(rec_mset_elem_t elem ) ;
#line 360
char *rec_comment_text(rec_comment_t comment ) ;
#line 815
char const   *rec_field_char_location_str(rec_field_t field ) ;
#line 903
size_t rec_record_num_elems(rec_record_t record ) ;
#line 907
size_t rec_record_num_fields(rec_record_t record ) ;
#line 956
char *rec_record_char_location_str(rec_record_t record ) ;
#line 1114
size_t rec_rset_num_elems(rec_rset_t rset ) ;
#line 1146
size_t rec_rset_descriptor_pos(rec_rset_t rset ) ;
#line 1989
rec_writer_t rec_writer_new(FILE *file_out ) ;
#line 1994
rec_writer_t rec_writer_new_str(char **str , size_t *str_size ) ;
#line 2000
void rec_writer_destroy(rec_writer_t writer ) ;
#line 2007
void rec_writer_set_collapse(rec_writer_t writer , _Bool value___0 ) ;
#line 2012
void rec_writer_set_skip_comments(rec_writer_t writer , _Bool value___0 ) ;
#line 2018
void rec_writer_set_mode(rec_writer_t writer , enum rec_writer_mode_e mode ) ;
#line 2032
_Bool rec_write_string(rec_writer_t writer , char const   *str ) ;
#line 2037
_Bool rec_write_comment(rec_writer_t writer , rec_comment_t comment ) ;
#line 2042
_Bool rec_write_field_name(rec_writer_t writer , char const   *field_name ) ;
#line 2048
_Bool rec_write_field(rec_writer_t writer , rec_field_t field ) ;
#line 2053
_Bool rec_write_record(rec_writer_t writer , rec_record_t record ) ;
#line 2058
_Bool rec_write_rset(rec_writer_t writer , rec_rset_t rset ) ;
#line 2063
_Bool rec_write_db(rec_writer_t writer , rec_db_t db ) ;
#line 2069
char *rec_write_field_name_str(char const   *field_name , rec_writer_mode_t mode ) ;
#line 2075
char *rec_write_field_str(rec_field_t field , rec_writer_mode_t mode ) ;
#line 2081
char *rec_write_comment_str(rec_comment_t comment , rec_writer_mode_t mode ) ;
#line 40 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
static _Bool rec_writer_putc(rec_writer_t writer , char c ) ;
#line 41
static _Bool rec_writer_puts(rec_writer_t writer , char const   *s ) ;
#line 67 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
static void rec_writer_new_common(rec_writer_t writer ) 
{ 


  {
#line 70
  writer->file_out = (FILE *)((void *)0);
#line 71
  writer->buf_out = (rec_buf_t )((void *)0);
#line 72
  writer->line = 1;
#line 73
  writer->eof = (_Bool)0;
#line 74
  writer->collapse_p = (_Bool)0;
#line 75
  writer->skip_comments_p = (_Bool)0;
#line 76
  writer->mode = (enum rec_writer_mode_e )0;
#line 77
  return;
}
}
#line 79 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
rec_writer_t rec_writer_new(FILE *file_out ) 
{ 
  rec_writer_t new ;
  void *tmp ;

  {
  {
#line 84
  tmp = malloc(sizeof(struct rec_writer_s ));
#line 84
  new = (rec_writer_t )tmp;
  }
#line 85
  if (new) {
    {
#line 87
    rec_writer_new_common(new);
#line 88
    new->file_out = file_out;
    }
  }
#line 91
  return (new);
}
}
#line 94 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
rec_writer_t rec_writer_new_str(char **str , size_t *str_size ) 
{ 
  rec_writer_t new ;
  void *tmp ;

  {
  {
#line 99
  tmp = malloc(sizeof(struct rec_writer_s ));
#line 99
  new = (rec_writer_t )tmp;
  }
#line 100
  if (new) {
    {
#line 102
    rec_writer_new_common(new);
#line 103
    new->buf_out = rec_buf_new(str, str_size);
    }
  }
#line 106
  return (new);
}
}
#line 109 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
void rec_writer_destroy(rec_writer_t writer ) 
{ 


  {
#line 112
  if (writer) {
#line 114
    if (writer->file_out) {
      {
#line 116
      fflush(writer->file_out);
      }
    }
#line 118
    if (writer->buf_out) {
      {
#line 120
      rec_buf_close(writer->buf_out);
      }
    }
    {
#line 123
    free((void *)writer);
    }
  }
#line 125
  return;
}
}
#line 127 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
_Bool rec_write_comment(rec_writer_t writer , rec_comment_t comment ) 
{ 
  char *line ;
  char *str ;
  char *orig_str ;
  size_t i ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  _Bool tmp___4 ;
  _Bool first ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
#line 136
  if ((unsigned int )writer->mode == 3U) {
    {
#line 138
    tmp = rec_writer_puts(writer, "(comment ");
    }
#line 138
    if (! tmp) {
#line 140
      return ((_Bool)0);
    }
    {
#line 142
    tmp___0 = rec_writer_putc(writer, (char )'\"');
    }
#line 142
    if (! tmp___0) {
#line 144
      return ((_Bool)0);
    }
    {
#line 147
    str = rec_comment_text(comment);
#line 148
    i = (size_t )0;
    }
    {
#line 148
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 148
      tmp___3 = strlen((char const   *)str);
      }
#line 148
      if (! (i < tmp___3)) {
#line 148
        goto while_break;
      }
#line 150
      if ((int )*(str + i) == 10) {
        {
#line 152
        tmp___1 = rec_writer_puts(writer, "\\n");
        }
#line 152
        if (! tmp___1) {
#line 154
          return ((_Bool)0);
        }
      } else {
        {
#line 159
        tmp___2 = rec_writer_putc(writer, *(str + i));
        }
#line 159
        if (! tmp___2) {
#line 161
          return ((_Bool)0);
        }
      }
#line 148
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 166
    tmp___4 = rec_writer_puts(writer, "\")");
    }
#line 166
    if (! tmp___4) {
#line 168
      return ((_Bool)0);
    }
  } else {
    {
#line 177
    first = (_Bool)1;
#line 179
    tmp___5 = rec_comment_text(comment);
#line 179
    str = strdup((char const   *)tmp___5);
#line 180
    orig_str = str;
#line 183
    line = strsep((char **/* __restrict  */)(& str), (char const   */* __restrict  */)"\n");
    }
    {
#line 184
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (! first) {
        {
#line 188
        tmp___6 = rec_writer_putc(writer, (char )'\n');
        }
#line 188
        if (! tmp___6) {
#line 190
          return ((_Bool)0);
        }
      }
      {
#line 194
      tmp___7 = rec_writer_putc(writer, (char )'#');
      }
#line 194
      if (tmp___7) {
        {
#line 194
        tmp___8 = rec_writer_puts(writer, (char const   *)line);
        }
#line 194
        if (! tmp___8) {
#line 197
          return ((_Bool)0);
        }
      } else {
#line 197
        return ((_Bool)0);
      }
      {
#line 200
      first = (_Bool)0;
#line 184
      line = strsep((char **/* __restrict  */)(& str), (char const   */* __restrict  */)"\n");
      }
#line 184
      if (! line) {
#line 184
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 204
    free((void *)orig_str);
    }
  }
#line 207
  return ((_Bool)1);
}
}
#line 210 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
_Bool rec_write_field(rec_writer_t writer , rec_field_t field ) 
{ 
  size_t pos ;
  char const   *fname ;
  char const   *fvalue ;
  enum rec_writer_mode_e mode ;
  _Bool tmp ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  size_t tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;

  {
#line 217
  mode = writer->mode;
#line 219
  if ((unsigned int )mode == 3U) {
    {
#line 221
    tmp = rec_writer_puts(writer, "(field ");
    }
#line 221
    if (! tmp) {
#line 223
      return ((_Bool)0);
    }
    {
#line 225
    tmp___0 = rec_field_char_location_str(field);
#line 225
    tmp___1 = rec_writer_puts(writer, tmp___0);
    }
#line 225
    if (! tmp___1) {
#line 227
      return ((_Bool)0);
    }
    {
#line 229
    tmp___2 = rec_writer_putc(writer, (char )' ');
    }
#line 229
    if (! tmp___2) {
#line 231
      return ((_Bool)0);
    }
  }
#line 235
  if ((unsigned int )mode != 1U) {
#line 235
    if ((unsigned int )mode != 2U) {
      {
#line 237
      fname = rec_field_name(field);
#line 238
      tmp___3 = rec_write_field_name(writer, fname);
      }
#line 238
      if (! tmp___3) {
#line 240
        return ((_Bool)0);
      }
    }
  }
#line 245
  if ((unsigned int )mode == 3U) {
    {
#line 247
    tmp___4 = rec_writer_putc(writer, (char )' ');
    }
#line 247
    if (! tmp___4) {
#line 249
      return ((_Bool)0);
    }
    {
#line 252
    tmp___5 = rec_writer_putc(writer, (char )'\"');
    }
#line 252
    if (! tmp___5) {
#line 254
      return ((_Bool)0);
    }
  }
  {
#line 258
  fvalue = rec_field_value(field);
#line 260
  tmp___7 = strlen(fvalue);
  }
#line 260
  if (tmp___7 > 0UL) {
#line 260
    if ((unsigned int )mode == 0U) {
      {
#line 262
      tmp___6 = rec_writer_putc(writer, (char )' ');
      }
#line 262
      if (! tmp___6) {
#line 264
        return ((_Bool)0);
      }
    }
  }
#line 268
  pos = (size_t )0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 268
    tmp___14 = strlen(fvalue);
    }
#line 268
    if (! (pos < tmp___14)) {
#line 268
      goto while_break;
    }
#line 270
    if ((int const   )*(fvalue + pos) == 10) {
#line 272
      if ((unsigned int )mode == 3U) {
        {
#line 274
        tmp___8 = rec_writer_puts(writer, "\\n");
        }
#line 274
        if (! tmp___8) {
#line 276
          return ((_Bool)0);
        }
      } else
#line 279
      if ((unsigned int )mode == 0U) {
        {
#line 281
        tmp___9 = rec_writer_puts(writer, "\n+ ");
        }
#line 281
        if (! tmp___9) {
#line 283
          return ((_Bool)0);
        }
      } else {
        {
#line 288
        tmp___10 = rec_writer_putc(writer, (char )'\n');
        }
#line 288
        if (! tmp___10) {
#line 290
          return ((_Bool)0);
        }
      }
    } else
#line 294
    if ((int const   )*(fvalue + pos) == 34) {
#line 294
      goto _L___0;
    } else
#line 294
    if ((int const   )*(fvalue + pos) == 92) {
      _L___0: /* CIL Label */ 
#line 294
      if ((unsigned int )mode == 3U) {
        {
#line 296
        tmp___11 = rec_writer_putc(writer, (char )'\\');
        }
#line 296
        if (tmp___11) {
          {
#line 296
          tmp___12 = rec_writer_putc(writer, (char )*(fvalue + pos));
          }
#line 296
          if (! tmp___12) {
#line 299
            return ((_Bool)0);
          }
        } else {
#line 299
          return ((_Bool)0);
        }
      } else {
#line 294
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 304
      tmp___13 = rec_writer_putc(writer, (char )*(fvalue + pos));
      }
#line 304
      if (! tmp___13) {
#line 307
        return ((_Bool)0);
      }
    }
#line 268
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  if ((unsigned int )mode == 3U) {
    {
#line 314
    tmp___15 = rec_writer_putc(writer, (char )'\"');
    }
#line 314
    if (! tmp___15) {
#line 316
      return ((_Bool)0);
    }
  }
#line 320
  if ((unsigned int )mode == 3U) {
    {
#line 322
    tmp___16 = rec_writer_puts(writer, ")");
    }
#line 322
    if (! tmp___16) {
#line 324
      return ((_Bool)0);
    }
  }
#line 328
  return ((_Bool)1);
}
}
#line 331 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
_Bool rec_write_field_name(rec_writer_t writer , char const   *field_name ) 
{ 
  enum rec_writer_mode_e mode ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 344
  mode = writer->mode;
#line 346
  if ((unsigned int )mode == 3U) {
    {
#line 348
    tmp = rec_writer_putc(writer, (char )'\"');
    }
#line 348
    if (! tmp) {
#line 350
      return ((_Bool)0);
    }
  }
  {
#line 354
  tmp___0 = rec_writer_puts(writer, field_name);
  }
#line 354
  if (! tmp___0) {
#line 356
    return ((_Bool)0);
  }
#line 359
  if ((unsigned int )mode == 3U) {
    {
#line 361
    tmp___1 = rec_writer_putc(writer, (char )'\"');
    }
#line 361
    if (! tmp___1) {
#line 363
      return ((_Bool)0);
    }
  } else {
    {
#line 368
    tmp___2 = rec_writer_putc(writer, (char )':');
    }
#line 368
    if (! tmp___2) {
#line 370
      return ((_Bool)0);
    }
  }
#line 374
  return ((_Bool)1);
}
}
#line 377 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
_Bool rec_write_record(rec_writer_t writer , rec_record_t record ) 
{ 
  _Bool ret ;
  rec_mset_iterator_t iter ;
  rec_mset_elem_t elem ;
  char *data ;
  size_t num_field ;
  size_t num_elem ;
  size_t num_fields ;
  size_t num_elems ;
  enum rec_writer_mode_e mode ;
  _Bool tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  rec_mset_t tmp___3 ;
  rec_field_t field ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  rec_comment_t comment ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  rec_mset_type_t tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;

  {
#line 386
  mode = writer->mode;
#line 388
  ret = (_Bool)1;
#line 390
  if ((unsigned int )mode == 3U) {
    {
#line 392
    tmp = rec_writer_puts(writer, "(record ");
    }
#line 392
    if (! tmp) {
#line 393
      return ((_Bool)0);
    }
    {
#line 394
    tmp___0 = rec_record_char_location_str(record);
#line 394
    tmp___1 = rec_writer_puts(writer, (char const   *)tmp___0);
    }
#line 394
    if (! tmp___1) {
#line 395
      return ((_Bool)0);
    }
    {
#line 396
    tmp___2 = rec_writer_puts(writer, " (\n");
    }
#line 396
    if (! tmp___2) {
#line 397
      return ((_Bool)0);
    }
  }
  {
#line 400
  num_elems = rec_record_num_elems(record);
#line 401
  num_fields = rec_record_num_fields(record);
#line 402
  num_field = (size_t )0;
#line 403
  num_elem = (size_t )0;
#line 404
  tmp___3 = rec_record_mset(record);
#line 404
  iter = rec_mset_iterator(tmp___3);
  }
  {
#line 405
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 405
    tmp___10 = rec_mset_iterator_next(& iter, 0, (void const   **)(& data), & elem);
    }
#line 405
    if (! tmp___10) {
#line 405
      goto while_break;
    }
    {
#line 407
    tmp___9 = rec_mset_elem_type(elem);
    }
#line 407
    if (tmp___9 == 1) {
      {
#line 410
      field = (rec_field_t )data;
#line 412
      tmp___4 = rec_write_field(writer, field);
      }
#line 412
      if (! tmp___4) {
#line 414
        ret = (_Bool)0;
#line 415
        goto while_break;
      }
#line 420
      if ((unsigned int )mode == 2U) {
#line 420
        if (num_field != num_fields - 1UL) {
#line 423
          if ((unsigned int )mode == 2U) {
            {
#line 425
            tmp___5 = rec_writer_putc(writer, (char )' ');
            }
#line 425
            if (! tmp___5) {
#line 426
              return ((_Bool)0);
            }
          }
        } else {
#line 420
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 429
      if (writer->skip_comments_p) {
#line 429
        if (num_field != num_fields - 1UL) {
#line 429
          goto _L;
        } else {
#line 429
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 429
      if (! writer->skip_comments_p) {
#line 429
        if (num_elem != num_elems - 1UL) {
          _L: /* CIL Label */ 
          {
#line 432
          tmp___6 = rec_writer_putc(writer, (char )'\n');
          }
#line 432
          if (! tmp___6) {
#line 433
            return ((_Bool)0);
          }
        }
      }
#line 436
      num_field ++;
    } else
#line 438
    if (! writer->skip_comments_p) {
#line 442
      comment = data;
#line 444
      if ((unsigned int )mode != 1U) {
#line 444
        if ((unsigned int )mode != 2U) {
          {
#line 446
          tmp___7 = rec_write_comment(writer, comment);
          }
#line 446
          if (! tmp___7) {
#line 448
            ret = (_Bool)0;
#line 449
            goto while_break;
          }
#line 452
          if (num_elem != num_elems - 1UL) {
            {
#line 454
            tmp___8 = rec_writer_putc(writer, (char )'\n');
            }
#line 454
            if (! tmp___8) {
#line 455
              return ((_Bool)0);
            }
          }
        }
      }
    }
#line 460
    num_elem ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 463
  rec_mset_iterator_free(& iter);
  }
#line 465
  if ((unsigned int )mode == 3U) {
    {
#line 467
    tmp___11 = rec_writer_puts(writer, "))");
    }
#line 467
    if (! tmp___11) {
#line 469
      return ((_Bool)0);
    }
  }
#line 473
  return (ret);
}
}
#line 476 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
_Bool rec_write_rset(rec_writer_t writer , rec_rset_t rset ) 
{ 
  _Bool ret ;
  rec_record_t descriptor ;
  _Bool wrote_descriptor ;
  size_t position ;
  size_t descriptor_pos ;
  rec_mset_iterator_t iter ;
  rec_mset_elem_t elem ;
  void *data ;
  enum rec_writer_mode_e mode ;
  rec_record_t tmp ;
  size_t tmp___0 ;
  rec_mset_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  rec_record_t tmp___4 ;
  rec_mset_type_t tmp___5 ;
  _Bool tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  rec_record_t tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  size_t tmp___13 ;
  rec_record_t tmp___14 ;

  {
  {
#line 488
  mode = writer->mode;
#line 490
  ret = (_Bool)1;
#line 491
  wrote_descriptor = (_Bool)0;
#line 492
  position = (size_t )0;
#line 493
  descriptor_pos = rec_rset_descriptor_pos(rset);
#line 494
  descriptor = rec_rset_descriptor(rset);
#line 498
  tmp___0 = rec_rset_num_elems(rset);
  }
#line 498
  if (tmp___0 == 0UL) {
#line 498
    if (descriptor) {
      {
#line 500
      tmp = rec_rset_descriptor(rset);
#line 500
      rec_write_record(writer, tmp);
#line 502
      rec_writer_putc(writer, (char )'\n');
      }
#line 504
      return ((_Bool)1);
    }
  }
  {
#line 507
  tmp___1 = rec_rset_mset(rset);
#line 507
  iter = rec_mset_iterator(tmp___1);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 508
    tmp___8 = rec_mset_iterator_next(& iter, 0, (void const   **)(& data), & elem);
    }
#line 508
    if (! tmp___8) {
#line 508
      goto while_break;
    }
#line 510
    if (position != 0UL) {
      {
#line 512
      tmp___2 = rec_writer_putc(writer, (char )'\n');
      }
#line 512
      if (! tmp___2) {
#line 514
        ret = (_Bool)0;
      }
    }
#line 518
    if (position == descriptor_pos) {
#line 520
      if (descriptor) {
        {
#line 520
        tmp___4 = rec_rset_descriptor(rset);
#line 520
        wrote_descriptor = rec_write_record(writer, tmp___4);
        }
#line 520
        if (wrote_descriptor) {
#line 520
          goto _L;
        } else {
#line 524
          ret = (_Bool)0;
        }
      } else
      _L: /* CIL Label */ 
#line 528
      if (wrote_descriptor) {
        {
#line 530
        tmp___3 = rec_writer_puts(writer, "\n\n");
        }
#line 530
        if (! tmp___3) {
#line 532
          ret = (_Bool)0;
        }
      }
    }
    {
#line 538
    tmp___5 = rec_mset_elem_type(elem);
    }
#line 538
    if (tmp___5 == 1) {
      {
#line 540
      ret = rec_write_record(writer, (rec_record_t )data);
      }
    } else
#line 542
    if (! writer->skip_comments_p) {
      {
#line 544
      ret = rec_write_comment(writer, (rec_comment_t )data);
      }
    }
#line 547
    if (! writer->collapse_p) {
#line 547
      goto _L___0;
    } else {
      {
#line 547
      tmp___7 = rec_rset_num_elems(rset);
      }
#line 547
      if (position == tmp___7 - 1UL) {
        _L___0: /* CIL Label */ 
        {
#line 549
        tmp___6 = rec_writer_putc(writer, (char )'\n');
        }
#line 549
        if (! tmp___6) {
#line 551
          ret = (_Bool)0;
        }
      }
    }
#line 555
    if (! ret) {
#line 557
      goto while_break;
    }
#line 560
    position ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 563
  rec_mset_iterator_free(& iter);
  }
#line 573
  if (! wrote_descriptor) {
    {
#line 573
    tmp___13 = rec_rset_num_elems(rset);
    }
#line 573
    if (descriptor_pos >= tmp___13) {
      {
#line 573
      tmp___14 = rec_rset_descriptor(rset);
      }
#line 573
      if (tmp___14) {
        {
#line 577
        tmp___9 = rec_writer_putc(writer, (char )'\n');
        }
#line 577
        if (! tmp___9) {
#line 579
          ret = (_Bool)0;
        }
        {
#line 581
        tmp___10 = rec_rset_descriptor(rset);
#line 581
        tmp___11 = rec_write_record(writer, tmp___10);
        }
#line 581
        if (! tmp___11) {
#line 583
          ret = (_Bool)0;
        }
        {
#line 585
        tmp___12 = rec_writer_putc(writer, (char )'\n');
        }
#line 585
        if (! tmp___12) {
#line 587
          ret = (_Bool)0;
        }
      }
    }
  }
#line 591
  return (ret);
}
}
#line 594 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
_Bool rec_write_db(rec_writer_t writer , rec_db_t db ) 
{ 
  _Bool ret ;
  int i ;
  rec_rset_t rset ;
  rec_rset_t tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  size_t tmp___2 ;

  {
#line 601
  ret = (_Bool)1;
#line 602
  i = 0;
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 602
    tmp___2 = rec_db_size(db);
    }
#line 602
    if (! ((size_t )i < tmp___2)) {
#line 602
      goto while_break;
    }
    {
#line 604
    tmp = rec_db_get_rset(db, (size_t )i);
#line 604
    rset = tmp;
    }
#line 606
    if (i != 0) {
      {
#line 608
      tmp___0 = rec_writer_putc(writer, (char )'\n');
      }
#line 608
      if (! tmp___0) {
#line 610
        ret = (_Bool)0;
#line 611
        goto while_break;
      }
    }
    {
#line 615
    tmp___1 = rec_write_rset(writer, rset);
    }
#line 615
    if (! tmp___1) {
#line 617
      ret = (_Bool)0;
#line 618
      goto while_break;
    }
#line 602
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  return (ret);
}
}
#line 625 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
char *rec_write_field_str(rec_field_t field , rec_writer_mode_t mode ) 
{ 
  rec_writer_t writer ;
  char *result ;
  size_t result_size ;

  {
  {
#line 633
  result = (char *)((void *)0);
#line 634
  writer = rec_writer_new_str(& result, & result_size);
  }
#line 635
  if (writer) {
    {
#line 637
    rec_writer_set_mode(writer, mode);
#line 638
    rec_write_field(writer, field);
#line 639
    rec_writer_destroy(writer);
    }
  }
#line 642
  return (result);
}
}
#line 645 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
char *rec_write_field_name_str(char const   *field_name , rec_writer_mode_t mode ) 
{ 
  rec_writer_t writer ;
  char *result ;
  size_t result_size ;

  {
  {
#line 653
  result = (char *)((void *)0);
#line 654
  writer = rec_writer_new_str(& result, & result_size);
  }
#line 655
  if (writer) {
    {
#line 657
    rec_writer_set_mode(writer, mode);
#line 658
    rec_write_field_name(writer, field_name);
#line 659
    rec_writer_destroy(writer);
    }
  }
#line 662
  return (result);
}
}
#line 665 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
char *rec_write_comment_str(rec_comment_t comment , rec_writer_mode_t mode ) 
{ 
  rec_writer_t writer ;
  char *result ;
  size_t result_size ;

  {
  {
#line 673
  result = (char *)((void *)0);
#line 674
  writer = rec_writer_new_str(& result, & result_size);
  }
#line 675
  if (writer) {
    {
#line 677
    rec_writer_set_mode(writer, mode);
#line 678
    rec_write_comment(writer, comment);
#line 679
    rec_writer_destroy(writer);
    }
  }
#line 682
  return (result);
}
}
#line 685 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
_Bool rec_write_string(rec_writer_t writer , char const   *str ) 
{ 
  _Bool tmp ;

  {
  {
#line 689
  tmp = rec_writer_puts(writer, str);
  }
#line 689
  return (tmp);
}
}
#line 692 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
void rec_writer_set_collapse(rec_writer_t writer , _Bool value___0 ) 
{ 


  {
#line 696
  writer->collapse_p = value___0;
#line 697
  return;
}
}
#line 699 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
void rec_writer_set_skip_comments(rec_writer_t writer , _Bool value___0 ) 
{ 


  {
#line 703
  writer->skip_comments_p = value___0;
#line 704
  return;
}
}
#line 706 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
void rec_writer_set_mode(rec_writer_t writer , enum rec_writer_mode_e mode ) 
{ 


  {
#line 710
  writer->mode = mode;
#line 711
  return;
}
}
#line 717 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
static _Bool rec_writer_putc(rec_writer_t writer , char c ) 
{ 
  _Bool ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 722
  ret = (_Bool)0;
#line 723
  if (writer->file_out) {
    {
#line 725
    tmp = fputc((int )c, writer->file_out);
#line 725
    ret = (_Bool )(tmp != -1);
    }
  }
#line 727
  if (writer->buf_out) {
    {
#line 729
    tmp___0 = rec_buf_putc((int )c, writer->buf_out);
#line 729
    ret = (_Bool )(tmp___0 != -1);
    }
  }
#line 732
  return (ret);
}
}
#line 735 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-writer.c"
static _Bool rec_writer_puts(rec_writer_t writer , char const   *s ) 
{ 
  _Bool ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 740
  ret = (_Bool)0;
#line 741
  if (writer->file_out) {
    {
#line 743
    tmp = fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)writer->file_out);
#line 743
    ret = (_Bool )(tmp != -1);
    }
  }
#line 745
  if (writer->buf_out) {
    {
#line 747
    tmp___0 = rec_buf_puts(s, writer->buf_out);
#line 747
    ret = (_Bool )(tmp___0 != -1);
    }
  }
#line 750
  return (ret);
}
}
#line 639 "/usr/include/stdio.h"
extern int ungetc(int __c , FILE *__stream ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 347 "./rec.h"
rec_comment_t rec_comment_new(char *text ) ;
#line 724
rec_field_t rec_field_new(char const   *name , char const   *value___0 ) ;
#line 782
_Bool rec_field_set_source(rec_field_t field , char const   *source ) ;
#line 801
_Bool rec_field_set_location(rec_field_t field , size_t location ) ;
#line 822
_Bool rec_field_set_char_location(rec_field_t field , size_t location ) ;
#line 863
rec_record_t rec_record_new(void) ;
#line 924
void rec_record_set_source(rec_record_t record , char *source ) ;
#line 942
void rec_record_set_location(rec_record_t record , size_t location ) ;
#line 961
void rec_record_set_char_location(rec_record_t record , size_t location ) ;
#line 991
_Bool rec_record_field_p(rec_record_t record , char const   *field_name ) ;
#line 1022
void rec_record_set_container(rec_record_t record , void *container ) ;
#line 1089
rec_rset_t rec_rset_new(void) ;
#line 1095
void rec_rset_destroy(rec_rset_t rset ) ;
#line 1152
void rec_rset_set_descriptor_pos(rec_rset_t rset , size_t position ) ;
#line 1318
rec_db_t rec_db_new(void) ;
#line 1347
_Bool rec_db_insert_rset(rec_db_t db , rec_rset_t rset , size_t position ) ;
#line 1865
rec_parser_t rec_parser_new_mem(char const   *buffer , size_t size , char const   *source ) ;
#line 1871
rec_parser_t rec_parser_new_str(char const   *buffer , char const   *source ) ;
#line 1885
_Bool rec_parse_field_name(rec_parser_t parser , char **fname ) ;
#line 1896
_Bool rec_parse_field(rec_parser_t parser , rec_field_t *field ) ;
#line 1902
_Bool rec_parse_record(rec_parser_t parser , rec_record_t *record ) ;
#line 1908
rec_record_t rec_parse_record_str(char const   *str ) ;
#line 1914
_Bool rec_parse_rset(rec_parser_t parser , rec_rset_t *rset ) ;
#line 1927
_Bool rec_parser_eof(rec_parser_t parser ) ;
#line 1933
_Bool rec_parser_error(rec_parser_t parser ) ;
#line 1937
void rec_parser_reset(rec_parser_t parser ) ;
#line 1947
void rec_parser_perror(rec_parser_t parser , char const   *fmt  , ...) ;
#line 1954
_Bool rec_parser_seek(rec_parser_t parser , size_t line_number , size_t position ) ;
#line 1957
long rec_parser_tell(rec_parser_t parser ) ;
#line 42 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static int rec_parser_getc(rec_parser_t parser ) ;
#line 43
static int rec_parser_ungetc(rec_parser_t parser , int ci ) ;
#line 45
static _Bool rec_expect(rec_parser_t parser , char const   *str ) ;
#line 47
static _Bool rec_parse_field_value(rec_parser_t parser , char **str ) ;
#line 49
static _Bool rec_parse_comment(rec_parser_t parser , rec_comment_t *comment ) ;
#line 51
static _Bool rec_parser_digit_p(char c ) ;
#line 52
static _Bool rec_parser_letter_p(char c ) ;
#line 53
static _Bool rec_parser_init_common(rec_parser_t parser , char const   *source ) ;
#line 91 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
char const   *rec_parser_error_strings[10]  = 
#line 91
  {      "no error (unused)",      "unknown error",      "unreading a character",      "expected a field name", 
        "out of memory",      "too much parts in field name",      "expected a comment",      "expected a field", 
        "expected a record",      (char const   *)((void *)0)};
#line 114 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
rec_parser_t rec_parser_new(FILE *in , char const   *source ) 
{ 
  rec_parser_t parser ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 120
  tmp = malloc(sizeof(struct rec_parser_s ));
#line 120
  parser = (rec_parser_t )tmp;
  }
#line 121
  if ((unsigned long )parser != (unsigned long )((void *)0)) {
    {
#line 123
    parser->in_file = in;
#line 124
    parser->in_buffer = (char const   *)((void *)0);
#line 125
    parser->in_size = (size_t )0;
#line 127
    tmp___0 = rec_parser_init_common(parser, source);
    }
#line 127
    if (! tmp___0) {
      {
#line 129
      free((void *)parser);
#line 130
      parser = (rec_parser_t )((void *)0);
      }
    }
  }
#line 134
  return (parser);
}
}
#line 137 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
rec_parser_t rec_parser_new_str(char const   *buffer , char const   *source ) 
{ 
  size_t tmp ;
  rec_parser_t tmp___0 ;

  {
  {
#line 141
  tmp = strlen(buffer);
#line 141
  tmp___0 = rec_parser_new_mem(buffer, tmp, source);
  }
#line 141
  return (tmp___0);
}
}
#line 144 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
rec_parser_t rec_parser_new_mem(char const   *buffer , size_t size , char const   *source ) 
{ 
  rec_parser_t parser ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 151
  tmp = malloc(sizeof(struct rec_parser_s ));
#line 151
  parser = (rec_parser_t )tmp;
  }
#line 152
  if ((unsigned long )parser != (unsigned long )((void *)0)) {
    {
#line 154
    parser->in_buffer = buffer;
#line 155
    parser->in_size = size;
#line 156
    parser->in_file = (FILE *)((void *)0);
#line 158
    tmp___0 = rec_parser_init_common(parser, source);
    }
#line 158
    if (! tmp___0) {
      {
#line 160
      free((void *)parser);
#line 161
      parser = (rec_parser_t )((void *)0);
      }
    }
  }
#line 165
  return (parser);
}
}
#line 168 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
void rec_parser_destroy(rec_parser_t parser ) 
{ 


  {
#line 171
  if (parser) {
    {
#line 173
    free((void *)parser->source);
#line 174
    free((void *)parser);
    }
  }
#line 176
  return;
}
}
#line 178 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parser_eof(rec_parser_t parser ) 
{ 


  {
#line 181
  return (parser->eof);
}
}
#line 184 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parser_error(rec_parser_t parser ) 
{ 


  {
#line 187
  return ((_Bool )((unsigned int )parser->error != 0U));
}
}
#line 190 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
void rec_parser_perror(rec_parser_t parser , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;
  char *number_str ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 198
  __builtin_va_start(ap, fmt);
#line 199
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 200
  fputs((char const   */* __restrict  */)": ", (FILE */* __restrict  */)stderr);
#line 201
  number_str = (char *)((void *)0);
#line 202
  tmp = asprintf((char **/* __restrict  */)(& number_str), (char const   */* __restrict  */)"%zu",
                 parser->line);
  }
#line 202
  if (tmp != -1) {
    {
#line 204
    fputs((char const   */* __restrict  */)number_str, (FILE */* __restrict  */)stderr);
#line 205
    free((void *)number_str);
    }
  }
  {
#line 207
  fputs((char const   */* __restrict  */)": error: ", (FILE */* __restrict  */)stderr);
#line 208
  tmp___0 = dcgettext((char const   *)((void *)0), rec_parser_error_strings[parser->error],
                      5);
#line 208
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stderr);
#line 209
  fputc('\n', stderr);
#line 211
  __builtin_va_end(ap);
  }
#line 212
  return;
}
}
#line 214 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parse_field_name(rec_parser_t parser , char **fname ) 
{ 
  _Bool ret ;
  int ci ;
  size_t str_size ;
  char c ;
  rec_buf_t buf ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 218
  ret = (_Bool)1;
#line 225
  tmp = rec_parser_eof(parser);
  }
#line 225
  if (tmp) {
#line 227
    return ((_Bool)0);
  } else {
    {
#line 225
    tmp___0 = rec_parser_error(parser);
    }
#line 225
    if (tmp___0) {
#line 227
      return ((_Bool)0);
    }
  }
  {
#line 229
  buf = rec_buf_new(fname, & str_size);
  }
#line 230
  if (! buf) {
#line 233
    parser->error = (enum rec_parser_error_e )4;
#line 234
    return ((_Bool)0);
  }
  {
#line 243
  ci = rec_parser_getc(parser);
  }
#line 244
  if (ci == -1) {
#line 245
    ret = (_Bool)0;
  } else {
    {
#line 248
    c = (char )ci;
#line 250
    tmp___2 = rec_parser_letter_p(c);
    }
#line 250
    if (tmp___2) {
#line 250
      goto _L;
    } else
#line 250
    if ((int )c == 37) {
      _L: /* CIL Label */ 
      {
#line 253
      tmp___1 = rec_buf_putc((int )c, buf);
      }
#line 253
      if (tmp___1 == -1) {
#line 256
        parser->error = (enum rec_parser_error_e )4;
#line 257
        return ((_Bool)0);
      }
    } else {
#line 263
      parser->error = (enum rec_parser_error_e )3;
#line 264
      ret = (_Bool)0;
    }
  }
#line 269
  if (ret) {
    {
#line 271
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 271
      ci = rec_parser_getc(parser);
      }
#line 271
      if (! (ci != -1)) {
#line 271
        goto while_break;
      }
      {
#line 273
      c = (char )ci;
#line 275
      tmp___4 = rec_parser_letter_p(c);
      }
#line 275
      if (tmp___4) {
#line 275
        goto _L___0;
      } else {
        {
#line 275
        tmp___5 = rec_parser_digit_p(c);
        }
#line 275
        if (tmp___5) {
#line 275
          goto _L___0;
        } else
#line 275
        if ((int )c == 95) {
          _L___0: /* CIL Label */ 
          {
#line 279
          tmp___3 = rec_buf_putc((int )c, buf);
          }
#line 279
          if (tmp___3 == -1) {
#line 282
            parser->error = (enum rec_parser_error_e )4;
#line 283
            return ((_Bool)0);
          }
#line 285
          if ((unsigned int )parser->error > 0U) {
#line 286
            goto while_break;
          }
        } else
#line 288
        if ((int )c == 58) {
#line 290
          goto while_break;
        } else {
#line 294
          parser->error = (enum rec_parser_error_e )3;
#line 295
          ret = (_Bool)0;
#line 296
          goto while_break;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 300
    if (parser->eof) {
#line 302
      parser->error = (enum rec_parser_error_e )3;
#line 303
      ret = (_Bool)0;
    }
  }
  {
#line 307
  rec_buf_close(buf);
  }
#line 309
  if (! ret) {
    {
#line 310
    free((void *)*fname);
    }
  } else {
    {
#line 325
    ci = rec_parser_getc(parser);
    }
#line 326
    if (ci != -1) {
#line 328
      c = (char )ci;
#line 329
      if ((int )c == 32) {
#line 330
        parser->error = (enum rec_parser_error_e )0;
      } else
#line 329
      if ((int )c == 9) {
#line 330
        parser->error = (enum rec_parser_error_e )0;
      } else
#line 331
      if ((int )c == 10) {
        {
#line 333
        parser->error = (enum rec_parser_error_e )0;
#line 334
        rec_parser_ungetc(parser, (int )c);
        }
      } else {
        {
#line 337
        rec_parser_ungetc(parser, (int )c);
        }
      }
    }
  }
#line 341
  return (ret);
}
}
#line 344 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
void rec_parser_reset(rec_parser_t parser ) 
{ 


  {
#line 347
  parser->eof = (_Bool)0;
#line 348
  parser->error = (enum rec_parser_error_e )0;
#line 349
  parser->p = parser->in_buffer;
#line 350
  return;
}
}
#line 352 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parse_field(rec_parser_t parser , rec_field_t *field ) 
{ 
  _Bool ret ;
  rec_field_t new ;
  char *field_name ;
  char *field_value ;
  size_t location ;
  size_t char_location ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 364
  tmp = rec_parser_eof(parser);
  }
#line 364
  if (tmp) {
#line 366
    return ((_Bool)0);
  } else {
    {
#line 364
    tmp___0 = rec_parser_error(parser);
    }
#line 364
    if (tmp___0) {
#line 366
      return ((_Bool)0);
    }
  }
#line 368
  location = parser->line;
#line 369
  char_location = parser->character;
#line 370
  if (char_location != 0UL) {
#line 371
    char_location ++;
  }
  {
#line 373
  ret = rec_parse_field_name(parser, & field_name);
  }
#line 374
  if (ret) {
    {
#line 376
    ret = rec_parse_field_value(parser, & field_value);
    }
#line 378
    if (ret) {
      {
#line 380
      new = rec_field_new((char const   *)field_name, (char const   *)field_value);
      }
#line 382
      if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 383
        return ((_Bool)0);
      }
      {
#line 385
      rec_field_set_source(new, (char const   *)parser->source);
#line 386
      rec_field_set_location(new, location);
#line 387
      rec_field_set_char_location(new, char_location);
#line 388
      *field = new;
#line 390
      free((void *)field_value);
      }
    }
    {
#line 393
    free((void *)field_name);
    }
  }
#line 396
  return (ret);
}
}
#line 399 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parse_record(rec_parser_t parser , rec_record_t *record ) 
{ 
  rec_record_t new ;
  rec_field_t field ;
  _Bool ret ;
  int ci ;
  char c ;
  rec_comment_t comment ;
  size_t char_location ;
  _Bool tmp ;
  _Bool tmp___0 ;
  rec_mset_t tmp___1 ;
  _Bool tmp___2 ;
  rec_mset_t tmp___3 ;
  _Bool tmp___4 ;
  rec_mset_t tmp___5 ;
  _Bool tmp___6 ;

  {
  {
#line 412
  tmp = rec_parser_eof(parser);
  }
#line 412
  if (tmp) {
#line 414
    return ((_Bool)0);
  } else {
    {
#line 412
    tmp___0 = rec_parser_error(parser);
    }
#line 412
    if (tmp___0) {
#line 414
      return ((_Bool)0);
    }
  }
  {
#line 416
  new = rec_record_new();
  }
#line 417
  if (! new) {
#line 419
    parser->error = (enum rec_parser_error_e )4;
#line 420
    return ((_Bool)0);
  }
  {
#line 424
  rec_record_set_source(new, parser->source);
#line 425
  rec_record_set_location(new, parser->line);
#line 426
  char_location = parser->character;
  }
#line 428
  if (char_location != 0UL) {
#line 429
    char_location ++;
  }
  {
#line 430
  rec_record_set_char_location(new, char_location);
#line 437
  tmp___2 = rec_parse_field(parser, & field);
  }
#line 437
  if (tmp___2) {
    {
#line 439
    tmp___1 = rec_record_mset(new);
#line 439
    rec_mset_append(tmp___1, 1, (void *)field, 0);
    }
  } else {
    {
#line 443
    parser->error = (enum rec_parser_error_e )7;
#line 444
    rec_record_destroy(new);
#line 445
    *record = (rec_record_t )((void *)0);
    }
#line 446
    return ((_Bool)0);
  }
#line 449
  ret = (_Bool)1;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 450
    ci = rec_parser_getc(parser);
    }
#line 450
    if (! (ci != -1)) {
#line 450
      goto while_break;
    }
#line 452
    c = (char )ci;
#line 454
    if ((int )c == 35) {
      {
#line 456
      rec_parser_ungetc(parser, ci);
#line 457
      tmp___4 = rec_parse_comment(parser, & comment);
      }
#line 457
      if (tmp___4) {
        {
#line 459
        tmp___3 = rec_record_mset(new);
#line 459
        rec_mset_append(tmp___3, 2, (void *)comment, 0);
        }
      }
    } else
#line 461
    if ((int )c == 32) {
#line 461
      goto _L;
    } else
#line 461
    if ((int )c == 9) {
      _L: /* CIL Label */ 
      {
#line 466
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 466
        if (ci != -1) {
#line 466
          if (! ((int )c == 32)) {
#line 466
            if (! ((int )c == 9)) {
#line 466
              goto while_break___0;
            }
          }
        } else {
#line 466
          goto while_break___0;
        }
        {
#line 468
        ci = rec_parser_getc(parser);
#line 469
        c = (char )ci;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 472
      if (ci == -1) {
#line 474
        goto while_break;
      } else
#line 472
      if ((int )c == 10) {
#line 474
        goto while_break;
      } else {
#line 478
        parser->error = (enum rec_parser_error_e )7;
#line 479
        ret = (_Bool)0;
#line 480
        goto while_break;
      }
    } else
#line 483
    if ((int )c == 10) {
#line 485
      goto while_break;
    } else {
      {
#line 489
      rec_parser_ungetc(parser, ci);
#line 490
      tmp___6 = rec_parse_field(parser, & field);
      }
#line 490
      if (tmp___6) {
        {
#line 492
        tmp___5 = rec_record_mset(new);
#line 492
        rec_mset_append(tmp___5, 1, (void *)field, 0);
        }
      } else {
#line 496
        parser->error = (enum rec_parser_error_e )7;
#line 497
        ret = (_Bool)0;
#line 498
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  if (ret) {
#line 504
    *record = new;
  } else {
    {
#line 507
    rec_record_destroy(new);
#line 508
    *record = (rec_record_t )((void *)0);
    }
  }
#line 511
  return (ret);
}
}
#line 514 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parse_rset(rec_parser_t parser , rec_rset_t *rset ) 
{ 
  _Bool ret ;
  int ci ;
  char c ;
  rec_rset_t new ;
  rec_record_t record ;
  rec_comment_t comment ;
  size_t comments_added ;
  rec_mset_t tmp ;
  size_t tmp___0 ;
  rec_record_t tmp___1 ;
  rec_mset_t tmp___2 ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  rec_record_t tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 524
  comments_added = (size_t )0;
#line 526
  ret = (_Bool)0;
#line 528
  new = rec_rset_new();
  }
#line 528
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 531
    parser->error = (enum rec_parser_error_e )4;
#line 532
    return ((_Bool)0);
  }
  {
#line 536
  rec_rset_set_descriptor(new, parser->prev_descriptor);
#line 537
  parser->prev_descriptor = (rec_record_t )((void *)0);
  }
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 539
    ci = rec_parser_getc(parser);
    }
#line 539
    if (! (ci != -1)) {
#line 539
      goto while_break;
    }
#line 541
    c = (char )ci;
#line 544
    if ((int )c == 10) {
#line 545
      goto while_continue;
    } else
#line 544
    if ((int )c == 32) {
#line 545
      goto while_continue;
    } else
#line 544
    if ((int )c == 9) {
#line 545
      goto while_continue;
    } else
#line 547
    if ((int )c == 35) {
      {
#line 549
      rec_parser_ungetc(parser, (int )c);
#line 550
      rec_parse_comment(parser, & comment);
#line 553
      tmp = rec_rset_mset(new);
#line 553
      rec_mset_append(tmp, 2, (void *)comment, 0);
#line 555
      comments_added ++;
      }
    } else {
      {
#line 560
      rec_parser_ungetc(parser, (int )c);
#line 561
      tmp___5 = rec_parse_record(parser, & record);
      }
#line 561
      if (tmp___5) {
        {
#line 572
        tmp___3 = rec_std_field_name((enum rec_std_field_e )5);
#line 572
        tmp___4 = rec_record_field_p(record, tmp___3);
        }
#line 572
        if (tmp___4) {
          {
#line 574
          tmp___0 = rec_rset_num_records(new);
          }
#line 574
          if (tmp___0 == 0UL) {
            {
#line 574
            tmp___1 = rec_rset_descriptor(new);
            }
#line 574
            if (tmp___1) {
#line 584
              parser->prev_descriptor = record;
#line 585
              ret = (_Bool)1;
#line 586
              goto while_break;
            } else {
              {
#line 579
              rec_rset_set_descriptor(new, record);
#line 580
              rec_rset_set_descriptor_pos(new, comments_added);
              }
            }
          } else {
#line 584
            parser->prev_descriptor = record;
#line 585
            ret = (_Bool)1;
#line 586
            goto while_break;
          }
        } else {
          {
#line 591
          rec_record_set_container(record, (void *)new);
#line 592
          tmp___2 = rec_rset_mset(new);
#line 592
          rec_mset_append(tmp___2, 1, (void *)record, 0);
          }
        }
      } else {
#line 598
        parser->error = (enum rec_parser_error_e )8;
#line 599
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 604
  if ((unsigned int )parser->error == 0U) {
    {
#line 604
    tmp___6 = rec_rset_descriptor(new);
    }
#line 604
    if (tmp___6) {
#line 607
      ret = (_Bool)1;
    } else {
      {
#line 604
      tmp___7 = rec_rset_num_records(new);
      }
#line 604
      if (tmp___7 > 0UL) {
#line 607
        ret = (_Bool)1;
      }
    }
  }
#line 609
  if (ret) {
#line 610
    *rset = new;
  } else {
    {
#line 613
    rec_rset_destroy(new);
#line 614
    *rset = (rec_rset_t )((void *)0);
    }
  }
#line 617
  return (ret);
}
}
#line 620 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parse_db(rec_parser_t parser , rec_db_t *db ) 
{ 
  _Bool ret ;
  rec_rset_t rset ;
  rec_db_t new ;
  size_t tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 628
  ret = (_Bool)1;
#line 630
  new = rec_db_new();
  }
#line 631
  if (! new) {
#line 633
    return ((_Bool)0);
  }
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 635
    tmp___1 = rec_parse_rset(parser, & rset);
    }
#line 635
    if (! tmp___1) {
#line 635
      goto while_break;
    }
    {
#line 638
    tmp = rec_db_size(new);
#line 638
    tmp___0 = rec_db_insert_rset(new, rset, tmp);
    }
#line 638
    if (! tmp___0) {
#line 643
      parser->error = (enum rec_parser_error_e )4;
#line 644
      ret = (_Bool)0;
#line 645
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 649
  tmp___2 = rec_parser_eof(parser);
  }
#line 649
  if (! tmp___2) {
#line 650
    ret = (_Bool)0;
  }
#line 652
  if (ret) {
#line 653
    *db = new;
  }
#line 655
  return (ret);
}
}
#line 658 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
char *rec_parse_field_name_str(char const   *str ) 
{ 
  rec_parser_t parser ;
  char *field_name ;
  char *str2 ;
  size_t str_size ;
  void *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 662
  field_name = (char *)((void *)0);
#line 667
  str_size = strlen(str);
#line 668
  tmp = malloc(str_size + 2UL);
#line 668
  str2 = (char *)tmp;
  }
#line 669
  if (! str2) {
#line 671
    return ((char *)((void *)0));
  }
  {
#line 673
  memcpy((void */* __restrict  */)str2, (void const   */* __restrict  */)str, str_size);
  }
#line 674
  if (str_size > 0UL) {
#line 674
    if ((int )*(str2 + (str_size - 1UL)) == 58) {
#line 675
      *(str2 + str_size) = (char )'\000';
    } else {
#line 678
      *(str2 + str_size) = (char )':';
#line 679
      *(str2 + (str_size + 1UL)) = (char )'\000';
    }
  } else {
#line 678
    *(str2 + str_size) = (char )':';
#line 679
    *(str2 + (str_size + 1UL)) = (char )'\000';
  }
  {
#line 682
  parser = rec_parser_new_str((char const   *)str2, "dummy");
#line 683
  tmp___0 = rec_parse_field_name(parser, & field_name);
  }
#line 683
  if (! tmp___0) {
#line 684
    field_name = (char *)((void *)0);
  }
  {
#line 686
  tmp___1 = rec_parser_eof(parser);
  }
#line 686
  if (! tmp___1) {
    {
#line 689
    free((void *)field_name);
#line 690
    field_name = (char *)((void *)0);
    }
  }
  {
#line 693
  rec_parser_destroy(parser);
#line 694
  free((void *)str2);
  }
#line 696
  return (field_name);
}
}
#line 699 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
rec_record_t rec_parse_record_str(char const   *str ) 
{ 
  rec_parser_t parser ;
  rec_record_t record ;
  _Bool tmp ;

  {
  {
#line 705
  record = (rec_record_t )((void *)0);
#line 706
  parser = rec_parser_new_str(str, "dummy");
  }
#line 707
  if (parser) {
    {
#line 709
    tmp = rec_parse_record(parser, & record);
    }
#line 709
    if (! tmp) {
#line 710
      record = (rec_record_t )((void *)0);
    }
    {
#line 711
    rec_parser_destroy(parser);
    }
  }
#line 714
  return (record);
}
}
#line 717 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
_Bool rec_parser_seek(rec_parser_t parser , size_t line_number , size_t position ) 
{ 
  int tmp ;

  {
#line 722
  if (parser->in_file) {
    {
#line 724
    tmp = fseek(parser->in_file, (long )position, 0);
    }
#line 724
    if (tmp) {
#line 725
      return ((_Bool)0);
    }
  } else
#line 727
  if (parser->in_buffer) {
#line 729
    if (position > parser->in_size) {
#line 730
      return ((_Bool)0);
    }
#line 731
    parser->p = parser->in_buffer + position;
  } else {
    {
#line 736
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rec_parser_seek: no backend in parser. This is a bug.  Please report it.");
    }
#line 738
    return ((_Bool)0);
  }
#line 740
  parser->line = line_number;
#line 741
  parser->character = position;
#line 742
  return ((_Bool)1);
}
}
#line 745 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
long rec_parser_tell(rec_parser_t parser ) 
{ 
  long tmp ;

  {
#line 748
  if (parser->in_file) {
    {
#line 749
    tmp = ftell(parser->in_file);
    }
#line 749
    return (tmp);
  } else
#line 750
  if (parser->in_buffer) {
#line 751
    return (parser->p - parser->in_buffer);
  } else {
    {
#line 755
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rec_parser_seek: no backend in parser. This is a bug.  Please report it.");
    }
#line 757
    return (-1L);
  }
}
}
#line 765 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static int rec_parser_getc(rec_parser_t parser ) 
{ 
  int ci ;

  {
#line 772
  if (parser->in_file) {
    {
#line 773
    ci = _IO_getc(parser->in_file);
    }
  } else
#line 774
  if (parser->in_buffer) {
#line 776
    if ((unsigned long )parser->p == (unsigned long )(parser->in_buffer + parser->in_size)) {
#line 777
      ci = -1;
    } else {
#line 780
      ci = (int )*(parser->p);
#line 781
      (parser->p) ++;
    }
  } else {
    {
#line 787
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rec_parser_getc: no backend in parser. This is a bug.  Please report it.");
    }
#line 789
    return (-1);
  }
#line 794
  if (ci == -1) {
#line 795
    parser->eof = (_Bool)1;
  } else {
#line 798
    (parser->character) ++;
#line 799
    if ((int )((char )ci) == 10) {
#line 800
      (parser->line) ++;
    }
  }
#line 803
  return (ci);
}
}
#line 806 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static int rec_parser_ungetc(rec_parser_t parser , int ci ) 
{ 
  int res ;

  {
#line 814
  (parser->character) --;
#line 815
  if ((int )((char )ci) == 10) {
#line 816
    (parser->line) --;
  }
#line 821
  if (parser->in_file) {
    {
#line 823
    res = ungetc(ci, parser->in_file);
    }
#line 824
    if (res != ci) {
#line 825
      parser->error = (enum rec_parser_error_e )2;
    }
  } else
#line 827
  if (parser->in_buffer) {
#line 829
    if ((unsigned long )parser->p > (unsigned long )parser->in_buffer) {
#line 831
      res = ci;
#line 832
      (parser->p) --;
    } else {
#line 836
      res = -1;
#line 837
      parser->error = (enum rec_parser_error_e )2;
    }
  } else {
    {
#line 844
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rec_parser_ungetc: no backend in parser. This is a bug.  Please report it.");
    }
#line 846
    return (-1);
  }
#line 849
  return (res);
}
}
#line 852 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static _Bool rec_parser_digit_p(char c ) 
{ 
  int tmp ;

  {
#line 855
  if ((int )c >= 48) {
#line 855
    if ((int )c <= 57) {
#line 855
      tmp = 1;
    } else {
#line 855
      tmp = 0;
    }
  } else {
#line 855
    tmp = 0;
  }
#line 855
  return ((_Bool )tmp);
}
}
#line 858 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static _Bool rec_parser_letter_p(char c ) 
{ 
  int tmp ;

  {
#line 861
  if ((int )c >= 65) {
#line 861
    if ((int )c <= 90) {
#line 861
      tmp = 1;
    } else {
#line 861
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 861
  if ((int )c >= 97) {
#line 861
    if ((int )c <= 122) {
#line 861
      tmp = 1;
    } else {
#line 861
      tmp = 0;
    }
  } else {
#line 861
    tmp = 0;
  }
#line 861
  return ((_Bool )tmp);
}
}
#line 865 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static _Bool rec_expect(rec_parser_t parser , char const   *str ) 
{ 
  size_t str_size ;
  size_t counter ;
  _Bool found ;
  int ci ;
  char c ;

  {
  {
#line 875
  found = (_Bool)1;
#line 876
  str_size = strlen(str);
#line 878
  counter = (size_t )0;
  }
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (! (counter < str_size)) {
#line 878
      goto while_break;
    }
    {
#line 882
    ci = rec_parser_getc(parser);
    }
#line 883
    if (ci == -1) {
#line 886
      found = (_Bool)0;
#line 887
      parser->eof = (_Bool)1;
#line 888
      goto while_break;
    } else {
#line 892
      c = (char )ci;
#line 893
      if ((int )c != (int )*(str + counter)) {
        {
#line 896
        rec_parser_ungetc(parser, ci);
#line 897
        found = (_Bool)0;
        }
#line 898
        goto while_break;
      }
    }
#line 878
    counter ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  return (found);
}
}
#line 906 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static _Bool rec_parse_field_value(rec_parser_t parser , char **str ) 
{ 
  _Bool ret ;
  int ci ;
  int ci2 ;
  char c ;
  char c2 ;
  size_t str_size ;
  _Bool prev_newline ;
  rec_buf_t buf ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 918
  tmp = rec_parser_eof(parser);
  }
#line 918
  if (tmp) {
#line 920
    return ((_Bool)0);
  } else {
    {
#line 918
    tmp___0 = rec_parser_error(parser);
    }
#line 918
    if (tmp___0) {
#line 920
      return ((_Bool)0);
    }
  }
  {
#line 922
  c = (char )'\000';
#line 923
  prev_newline = (_Bool)0;
#line 924
  ret = (_Bool)1;
#line 925
  buf = rec_buf_new(str, & str_size);
  }
#line 926
  if (! buf) {
#line 929
    parser->error = (enum rec_parser_error_e )4;
#line 930
    return ((_Bool)0);
  }
  {
#line 939
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 939
    ci = rec_parser_getc(parser);
    }
#line 939
    if (! (ci != -1)) {
#line 939
      goto while_break;
    }
#line 941
    c = (char )ci;
#line 943
    if (prev_newline) {
#line 943
      if ((int )c != 43) {
        {
#line 946
        rec_parser_ungetc(parser, ci);
#line 947
        rec_buf_rewind(buf, 1);
        }
#line 948
        goto while_break;
      }
    }
#line 951
    if ((int )c == 92) {
      {
#line 953
      ci2 = rec_parser_getc(parser);
      }
#line 954
      if (ci2 == -1) {
#line 956
        parser->eof = (_Bool)1;
#line 957
        ret = (_Bool)0;
#line 958
        goto while_break;
      } else {
#line 962
        c2 = (char )ci2;
#line 963
        if (! ((int )c2 == 10)) {
          {
#line 971
          tmp___1 = rec_buf_putc((int )c, buf);
          }
#line 971
          if (tmp___1 == -1) {
#line 974
            parser->error = (enum rec_parser_error_e )4;
#line 975
            return ((_Bool)0);
          }
#line 978
          if ((unsigned int )parser->error > 0U) {
#line 980
            goto while_break;
          }
          {
#line 983
          tmp___2 = rec_parser_ungetc(parser, ci2);
          }
#line 983
          if (tmp___2 != ci2) {
#line 986
            ret = (_Bool)0;
#line 987
            goto while_break;
          }
        }
      }
#line 992
      prev_newline = (_Bool)0;
    } else
#line 994
    if ((int )c == 43) {
#line 996
      if (prev_newline) {
        {
#line 999
        ci2 = rec_parser_getc(parser);
        }
#line 1001
        if (ci2 == -1) {
#line 1003
          parser->eof = (_Bool)1;
#line 1004
          ret = (_Bool)0;
#line 1005
          goto while_break;
        } else {
#line 1009
          c2 = (char )ci2;
#line 1013
          if ((int )c2 != 32) {
            {
#line 1015
            tmp___3 = rec_parser_ungetc(parser, ci2);
            }
#line 1015
            if (tmp___3 != ci2) {
#line 1017
              ret = (_Bool)0;
#line 1018
              goto while_break;
            }
          }
        }
      } else {
        {
#line 1025
        tmp___4 = rec_buf_putc((int )c, buf);
        }
#line 1025
        if (tmp___4 == -1) {
#line 1028
          parser->error = (enum rec_parser_error_e )4;
#line 1029
          return ((_Bool)0);
        }
#line 1032
        if ((unsigned int )parser->error > 0U) {
#line 1033
          goto while_break;
        }
      }
#line 1036
      prev_newline = (_Bool)0;
    } else
#line 1038
    if ((int )c == 10) {
      {
#line 1040
      tmp___5 = rec_buf_putc((int )c, buf);
      }
#line 1040
      if (tmp___5 == -1) {
#line 1043
        parser->error = (enum rec_parser_error_e )4;
#line 1044
        return ((_Bool)0);
      }
#line 1047
      if ((unsigned int )parser->error > 0U) {
#line 1048
        goto while_break;
      }
#line 1049
      prev_newline = (_Bool)1;
    } else {
      {
#line 1053
      tmp___6 = rec_buf_putc((int )c, buf);
      }
#line 1053
      if (tmp___6 == -1) {
#line 1056
        parser->error = (enum rec_parser_error_e )4;
#line 1057
        return ((_Bool)0);
      }
#line 1060
      if ((unsigned int )parser->error > 0U) {
#line 1061
        goto while_break;
      }
#line 1062
      prev_newline = (_Bool)0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1066
  if (ret) {
    {
#line 1068
    tmp___7 = rec_parser_eof(parser);
    }
#line 1068
    if (tmp___7) {
#line 1068
      if ((int )c == 10) {
        {
#line 1070
        rec_buf_rewind(buf, 1);
        }
      }
    }
  }
  {
#line 1073
  rec_buf_close(buf);
  }
#line 1075
  if (! ret) {
    {
#line 1076
    free((void *)*str);
    }
  }
#line 1078
  return (ret);
}
}
#line 1081 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static _Bool rec_parse_comment(rec_parser_t parser , rec_comment_t *comment ) 
{ 
  _Bool ret ;
  rec_buf_t buf ;
  char *str ;
  size_t str_size ;
  int ci ;
  char c ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1091
  ret = (_Bool)0;
#line 1092
  buf = rec_buf_new(& str, & str_size);
#line 1097
  tmp___0 = rec_expect(parser, "#");
  }
#line 1097
  if (tmp___0) {
    {
#line 1099
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1099
      ci = rec_parser_getc(parser);
      }
#line 1099
      if (! (ci != -1)) {
#line 1099
        goto while_break;
      }
#line 1101
      c = (char )ci;
#line 1103
      if ((int )c == 10) {
        {
#line 1105
        ci = rec_parser_getc(parser);
        }
#line 1105
        if (ci == -1) {
#line 1106
          goto while_break;
        }
#line 1107
        c = (char )ci;
#line 1109
        if ((int )c != 35) {
          {
#line 1111
          rec_parser_ungetc(parser, ci);
          }
#line 1112
          goto while_break;
        } else {
#line 1115
          c = (char )'\n';
        }
      }
      {
#line 1118
      tmp = rec_buf_putc((int )c, buf);
      }
#line 1118
      if (tmp == -1) {
#line 1121
        parser->error = (enum rec_parser_error_e )4;
#line 1122
        return ((_Bool)0);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1126
    ret = (_Bool)1;
  }
  {
#line 1129
  rec_buf_close(buf);
  }
#line 1131
  if (ret) {
    {
#line 1132
    *comment = rec_comment_new(str);
    }
  } else {
#line 1134
    *comment = (rec_comment_t )((void *)0);
  }
  {
#line 1136
  free((void *)str);
  }
#line 1137
  return (ret);
}
}
#line 1140 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-parser.c"
static _Bool rec_parser_init_common(rec_parser_t parser , char const   *source ) 
{ 


  {
#line 1144
  if (source) {
    {
#line 1146
    parser->source = strdup(source);
    }
#line 1147
    if (! parser->source) {
#line 1148
      return ((_Bool)0);
    }
  } else {
#line 1151
    parser->source = (char *)((void *)0);
  }
#line 1153
  parser->eof = (_Bool)0;
#line 1154
  parser->error = (enum rec_parser_error_e )0;
#line 1155
  parser->line = (size_t )1;
#line 1156
  parser->character = (size_t )0;
#line 1157
  parser->prev_descriptor = (rec_record_t )((void *)0);
#line 1158
  parser->p = parser->in_buffer;
#line 1160
  return ((_Bool)1);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 434 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) random_r)(struct random_data * __restrict  __buf ,
                                                                                       int32_t * __restrict  __result ) ;
#line 440
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) initstate_r)(unsigned int __seed ,
                                                                                          char * __restrict  __statebuf ,
                                                                                          size_t __statelen ,
                                                                                          struct random_data * __restrict  __buf ) ;
#line 75 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 168 "./rec.h"
void *rec_mset_get_at(rec_mset_t mset , rec_mset_type_t type , size_t position ) ;
#line 179
rec_mset_elem_t rec_mset_insert_at(rec_mset_t mset , rec_mset_type_t type , void *data ,
                                   size_t position ) ;
#line 188
rec_mset_elem_t rec_mset_insert_after(rec_mset_t mset , rec_mset_type_t type , void *data ,
                                      rec_mset_elem_t elem ) ;
#line 226
_Bool rec_mset_remove_elem(rec_mset_t mset , rec_mset_elem_t elem ) ;
#line 232
rec_mset_elem_t rec_mset_search(rec_mset_t mset , void *data ) ;
#line 269
void rec_mset_elem_set_type(rec_mset_elem_t elem , rec_mset_type_t type ) ;
#line 281
void rec_mset_elem_set_data(rec_mset_elem_t elem , void *data ) ;
#line 729
void rec_field_destroy(rec_field_t field ) ;
#line 756
_Bool rec_field_set_name(rec_field_t field , char const   *name ) ;
#line 768
_Bool rec_field_set_value(rec_field_t field , char const   *value___0 ) ;
#line 836
rec_comment_t rec_field_to_comment(rec_field_t field ) ;
#line 931
size_t rec_record_location(rec_record_t record ) ;
#line 950
size_t rec_record_char_location(rec_record_t record ) ;
#line 967
size_t rec_record_get_field_index(rec_record_t record , rec_field_t field ) ;
#line 981
_Bool rec_record_contains_value(rec_record_t record , char const   *str , _Bool case_insensitive ) ;
#line 1030
rec_comment_t rec_record_to_comment(rec_record_t record ) ;
#line 1035
void rec_record_uniq(rec_record_t record ) ;
#line 1171
void rec_rset_set_type(rec_rset_t rset , char const   *type ) ;
#line 1223
void rec_rset_rename_field(rec_rset_t rset , char const   *field_name , char const   *new_field_name ) ;
#line 1275
rec_rset_t rec_rset_sort(rec_rset_t rset , rec_fex_t sort_by ) ;
#line 1285
rec_rset_t rec_rset_group(rec_rset_t rset , rec_fex_t group_by ) ;
#line 1295
rec_rset_t rec_rset_add_auto_fields(rec_rset_t rset , rec_record_t record ) ;
#line 1357
_Bool rec_db_remove_rset(rec_db_t db , size_t position ) ;
#line 1362
_Bool rec_db_type_p(rec_db_t db , char const   *type ) ;
#line 1373
rec_aggregate_reg_t rec_db_aggregates(rec_db_t db ) ;
#line 1487
rec_rset_t rec_db_query(rec_db_t db , char const   *type , char const   *join , size_t *index___0 ,
                        rec_sex_t sex , char const   *fast_string , size_t random___0 ,
                        rec_fex_t fex , char const   *password , rec_fex_t group_by ,
                        rec_fex_t sort_by , int flags ) ;
#line 1586
_Bool rec_db_insert(rec_db_t db , char const   *type , size_t *index___0 , rec_sex_t sex ,
                    char const   *fast_string , size_t random___0 , char const   *password ,
                    rec_record_t record , int flags ) ;
#line 1664
_Bool rec_db_delete(rec_db_t db , char const   *type , size_t *index___0 , rec_sex_t sex ,
                    char const   *fast_string , size_t random___0 , int flags ) ;
#line 1787
_Bool rec_db_set(rec_db_t db , char const   *type , size_t *index___0 , rec_sex_t sex ,
                 char const   *fast_string , size_t random___0 , rec_fex_t fex , int action ,
                 char const   *action_arg , int flags ) ;
#line 52 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_rset_equals_fn(void const   *elt1 , void const   *elt2 ) ;
#line 54
static void rec_db_rset_dispose_fn(void const   *elt ) ;
#line 56
static rec_record_t rec_db_process_fex(rec_db_t db , rec_rset_t rset , rec_record_t record ,
                                       rec_fex_t fex ) ;
#line 61
static _Bool rec_db_record_selected_p(size_t num_record , rec_record_t record , size_t *index___0 ,
                                      rec_sex_t sex , char const   *fast_string ,
                                      _Bool case_insensitive_p ) ;
#line 67
static void rec_db_add_random_indexes(size_t **index___0 , size_t num , size_t limit ) ;
#line 68
static _Bool rec_db_index_p(size_t *index___0 , size_t num ) ;
#line 70
static _Bool rec_db_set_act_rename(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                   _Bool rename_descriptor , char const   *arg ) ;
#line 71
static _Bool rec_db_set_act_set(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                _Bool add_p , char const   *arg ) ;
#line 72
static _Bool rec_db_set_act_add(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                char const   *arg ) ;
#line 73
static _Bool rec_db_set_act_delete(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                   _Bool comment_out ) ;
#line 75
static rec_rset_t rec_db_join(rec_db_t db , char const   *type1 , char const   *field ,
                              char const   *type2 ) ;
#line 76
static rec_record_t rec_db_merge_records(rec_record_t record1 , rec_record_t record2 ,
                                         char const   *prefix ) ;
#line 82 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
rec_db_t rec_db_new(void) 
{ 
  rec_db_t new ;
  void *tmp ;

  {
  {
#line 87
  tmp = malloc(sizeof(struct rec_db_s ));
#line 87
  new = (rec_db_t )tmp;
  }
#line 88
  if (new) {
    {
#line 90
    new->size = (size_t )0;
#line 91
    new->rset_list = gl_list_nx_create_empty(& gl_array_list_implementation, & rec_db_rset_equals_fn,
                                             (size_t (*)(void const   *elt ))((void *)0),
                                             & rec_db_rset_dispose_fn, (_Bool)1);
    }
#line 97
    if ((unsigned long )new->rset_list == (unsigned long )((void *)0)) {
      {
#line 100
      free((void *)new);
#line 101
      new = (rec_db_t )((void *)0);
      }
    }
    {
#line 107
    new->aggregates = rec_aggregate_reg_new();
    }
#line 108
    if (! new->aggregates) {
      {
#line 111
      free((void *)new);
      }
#line 112
      return ((rec_db_t )((void *)0));
    }
    {
#line 114
    rec_aggregate_reg_add_standard(new->aggregates);
    }
  }
#line 117
  return (new);
}
}
#line 120 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
void rec_db_destroy(rec_db_t db ) 
{ 


  {
#line 123
  if (db) {
    {
#line 125
    rec_aggregate_reg_destroy(db->aggregates);
#line 126
    gl_list_free(db->rset_list);
#line 127
    free((void *)db);
    }
  }
#line 129
  return;
}
}
#line 131 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
size_t rec_db_size(rec_db_t db ) 
{ 


  {
#line 134
  return (db->size);
}
}
#line 137 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
rec_rset_t rec_db_get_rset(rec_db_t db , size_t position ) 
{ 
  rec_rset_t rset ;
  void const   *tmp ;

  {
#line 143
  rset = (rec_rset_t )((void *)0);
#line 145
  if (db->size > 0UL) {
#line 147
    if (position >= db->size) {
#line 149
      position = db->size - 1UL;
    }
    {
#line 152
    tmp = gl_list_get_at(db->rset_list, position);
#line 152
    rset = (rec_rset_t )tmp;
    }
  }
#line 155
  return (rset);
}
}
#line 158 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
_Bool rec_db_insert_rset(rec_db_t db , rec_rset_t rset , size_t position ) 
{ 
  gl_list_node_t node ;

  {
#line 165
  node = (gl_list_node_t )((void *)0);
#line 167
  if (position == 0UL) {
    {
#line 169
    node = gl_list_nx_add_first(db->rset_list, (void const   *)((void *)rset));
    }
  } else
#line 172
  if (position >= db->size) {
    {
#line 174
    node = gl_list_nx_add_last(db->rset_list, (void const   *)((void *)rset));
    }
  } else {
    {
#line 179
    node = gl_list_nx_add_at(db->rset_list, position, (void const   *)((void *)rset));
    }
  }
#line 184
  if ((unsigned long )node != (unsigned long )((void *)0)) {
#line 186
    (db->size) ++;
#line 187
    return ((_Bool)1);
  }
#line 190
  return ((_Bool)0);
}
}
#line 193 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
_Bool rec_db_remove_rset(rec_db_t db , size_t position ) 
{ 
  _Bool removed ;
  _Bool tmp ;

  {
#line 198
  removed = (_Bool)0;
#line 200
  if (db->size > 0UL) {
#line 202
    if (position >= db->size) {
#line 204
      position = db->size - 1UL;
    }
    {
#line 207
    tmp = gl_list_remove_at(db->rset_list, position);
    }
#line 207
    if (tmp) {
#line 210
      (db->size) --;
#line 211
      removed = (_Bool)1;
    }
  }
#line 215
  return (removed);
}
}
#line 218 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
_Bool rec_db_type_p(rec_db_t db , char const   *type ) 
{ 
  rec_rset_t tmp ;

  {
  {
#line 222
  tmp = rec_db_get_rset_by_type(db, type);
  }
#line 222
  return ((_Bool )((unsigned long )tmp != (unsigned long )((void *)0)));
}
}
#line 225 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
rec_rset_t rec_db_get_rset_by_type(rec_db_t db , char const   *type ) 
{ 
  int i ;
  rec_rset_t rset ;
  _Bool found ;
  char *rtype ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 234
  found = (_Bool)0;
#line 235
  i = 0;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 235
    tmp___0 = rec_db_size(db);
    }
#line 235
    if (! ((size_t )i < tmp___0)) {
#line 235
      goto while_break;
    }
    {
#line 237
    rset = rec_db_get_rset(db, (size_t )i);
#line 238
    rtype = rec_rset_type(rset);
    }
#line 239
    if ((unsigned long )rtype == (unsigned long )((void *)0)) {
#line 241
      if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 244
        found = (_Bool)1;
#line 245
        goto while_break;
      }
    } else
#line 250
    if ((unsigned long )type != (unsigned long )((void *)0)) {
      {
#line 250
      tmp = strcmp((char const   *)rtype, type);
      }
#line 250
      if (tmp == 0) {
#line 253
        found = (_Bool)1;
#line 254
        goto while_break;
      }
    }
#line 235
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  if (! found) {
#line 261
    rset = (rec_rset_t )((void *)0);
  }
#line 264
  return (rset);
}
}
#line 267 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
rec_rset_t rec_db_query(rec_db_t db , char const   *type , char const   *join , size_t *index___0 ,
                        rec_sex_t sex , char const   *fast_string , size_t random___0 ,
                        rec_fex_t fex , char const   *password , rec_fex_t group_by ,
                        rec_fex_t sort_by , int flags ) 
{ 
  rec_rset_t res ;
  rec_rset_t rset ;
  size_t tmp ;
  rec_type_t ref_type ;
  rec_type_t tmp___0 ;
  char const   *referred_type ;
  char const   *tmp___1 ;
  rec_rset_t tmp___2 ;
  enum rec_type_kind_e tmp___3 ;
  rec_record_t descriptor ;
  rec_record_t tmp___4 ;
  size_t tmp___5 ;
  rec_record_t record ;
  rec_record_t tmp___6 ;
  rec_mset_t tmp___7 ;
  rec_mset_elem_t tmp___8 ;
  rec_record_t record___0 ;
  size_t num_rec ;
  rec_rset_t tmp___9 ;
  rec_rset_t tmp___10 ;
  rec_rset_t tmp___11 ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp___12 ;
  rec_mset_iterator_t tmp___13 ;
  rec_record_t res_record ;
  _Bool tmp___14 ;
  size_t tmp___15 ;
  rec_mset_t tmp___16 ;
  rec_mset_elem_t tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;

  {
  {
#line 281
  res = (rec_rset_t )((void *)0);
#line 282
  rset = (rec_rset_t )((void *)0);
#line 287
  res = rec_rset_new();
  }
#line 288
  if (! res) {
#line 291
    return ((rec_rset_t )((void *)0));
  }
  {
#line 299
  rset = rec_db_get_rset_by_type(db, type);
  }
#line 300
  if (! rset) {
#line 306
    if (! type) {
      {
#line 306
      tmp = rec_db_size(db);
      }
#line 306
      if (tmp == 1UL) {
        {
#line 308
        rset = rec_db_get_rset(db, (size_t )0);
        }
      } else {
#line 313
        return (res);
      }
    } else {
#line 313
      return (res);
    }
  } else
#line 318
  if (join) {
    {
#line 328
    tmp___0 = rec_rset_get_field_type(rset, join);
#line 328
    ref_type = tmp___0;
    }
#line 329
    if (ref_type) {
      {
#line 329
      tmp___3 = rec_type_kind(ref_type);
      }
#line 329
      if ((unsigned int )tmp___3 == 13U) {
        {
#line 331
        tmp___1 = rec_type_rec(ref_type);
#line 331
        referred_type = tmp___1;
#line 333
        tmp___2 = rec_db_get_rset_by_type(db, referred_type);
        }
#line 333
        if (tmp___2) {
          {
#line 335
          rset = rec_db_join(db, type, join, referred_type);
          }
#line 336
          if (! rset) {
#line 339
            return ((rec_rset_t )((void *)0));
          }
        }
      }
    }
  }
#line 350
  if (flags & 1) {
    {
#line 352
    tmp___4 = rec_rset_descriptor(rset);
#line 352
    descriptor = tmp___4;
    }
#line 353
    if (descriptor) {
      {
#line 355
      descriptor = rec_record_dup(descriptor);
      }
#line 356
      if (! descriptor) {
        {
#line 359
        free((void *)res);
        }
#line 360
        return ((rec_rset_t )((void *)0));
      }
    }
    {
#line 364
    rec_rset_set_descriptor(res, descriptor);
    }
  }
#line 371
  if (random___0 > 0UL) {
    {
#line 373
    tmp___5 = rec_rset_num_records(rset);
#line 373
    rec_db_add_random_indexes(& index___0, random___0, tmp___5);
    }
#line 374
    if (! index___0) {
#line 377
      return ((rec_rset_t )((void *)0));
    }
  }
#line 381
  if (fex) {
#line 381
    if (! group_by) {
      {
#line 381
      tmp___19 = rec_fex_all_calls_p(fex);
      }
#line 381
      if (tmp___19) {
        {
#line 389
        tmp___6 = rec_db_process_fex(db, rset, (rec_record_t )((void *)0), fex);
#line 389
        record = tmp___6;
        }
#line 390
        if (record) {
          {
#line 392
          rec_record_set_container(record, (void *)res);
#line 393
          tmp___7 = rec_rset_mset(res);
#line 393
          tmp___8 = rec_mset_append(tmp___7, 1, (void *)record, 1);
          }
#line 393
          if (! tmp___8) {
#line 399
            return ((rec_rset_t )((void *)0));
          }
        }
      } else {
#line 381
        goto _L___0;
      }
    } else {
#line 381
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 410
    record___0 = (rec_record_t )((void *)0);
#line 411
    num_rec = (size_t )-1;
#line 413
    if (group_by) {
      {
#line 415
      tmp___9 = rec_rset_sort(rset, group_by);
      }
#line 415
      if (! tmp___9) {
#line 418
        return ((rec_rset_t )((void *)0));
      }
      {
#line 421
      tmp___10 = rec_rset_group(rset, group_by);
      }
#line 421
      if (! tmp___10) {
#line 424
        return ((rec_rset_t )((void *)0));
      }
    }
    {
#line 428
    tmp___11 = rec_rset_sort(rset, sort_by);
    }
#line 428
    if (! tmp___11) {
#line 431
      return ((rec_rset_t )((void *)0));
    }
    {
#line 434
    tmp___12 = rec_rset_mset(rset);
#line 434
    tmp___13 = rec_mset_iterator(tmp___12);
#line 434
    iter = tmp___13;
    }
    {
#line 435
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 435
      tmp___18 = rec_mset_iterator_next(& iter, 1, (void const   **)(& record___0),
                                        (rec_mset_elem_t *)((void *)0));
      }
#line 435
      if (! tmp___18) {
#line 435
        goto while_break;
      }
      {
#line 438
      num_rec ++;
#line 442
      tmp___14 = rec_db_record_selected_p(num_rec, record___0, index___0, sex, fast_string,
                                          (_Bool )(flags & 2));
      }
#line 442
      if (! tmp___14) {
#line 449
        goto while_continue;
      }
      {
#line 457
      res_record = rec_db_process_fex(db, rset, record___0, fex);
      }
#line 460
      if (! res_record) {
#line 463
        return ((rec_rset_t )((void *)0));
      }
      {
#line 468
      tmp___15 = rec_record_num_elems(res_record);
      }
#line 468
      if (tmp___15 == 0UL) {
#line 470
        goto while_continue;
      }
#line 493
      if (flags & 4) {
        {
#line 495
        rec_record_uniq(res_record);
        }
      }
      {
#line 500
      rec_record_set_container(res_record, (void *)res);
#line 501
      tmp___16 = rec_rset_mset(res);
#line 501
      tmp___17 = rec_mset_append(tmp___16, 1, (void *)res_record, 1);
      }
#line 501
      if (! tmp___17) {
#line 507
        return ((rec_rset_t )((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 511
    rec_mset_iterator_free(& iter);
    }
  }
#line 514
  return (res);
}
}
#line 517 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
_Bool rec_db_insert(rec_db_t db , char const   *type , size_t *index___0 , rec_sex_t sex ,
                    char const   *fast_string , size_t random___0 , char const   *password ,
                    rec_record_t record , int flags ) 
{ 
  size_t tmp ;
  rec_rset_t rset ;
  rec_rset_t tmp___0 ;
  size_t num_rec ;
  size_t tmp___1 ;
  rec_rset_t tmp___2 ;
  rec_record_t rset_record ;
  rec_mset_elem_t elem ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp___3 ;
  rec_mset_iterator_t tmp___4 ;
  _Bool tmp___5 ;
  rec_record_t tmp___6 ;
  _Bool tmp___7 ;
  rec_rset_t rset___0 ;
  rec_rset_t tmp___8 ;
  rec_rset_t tmp___9 ;
  size_t tmp___10 ;
  rec_mset_t tmp___11 ;
  rec_mset_t mset ;
  rec_mset_t tmp___12 ;
  rec_record_t last_record ;
  size_t tmp___13 ;
  void *tmp___14 ;
  rec_mset_elem_t tmp___15 ;
  rec_mset_elem_t tmp___16 ;
  size_t tmp___17 ;
  rec_mset_t tmp___18 ;
  rec_mset_elem_t tmp___19 ;
  size_t tmp___20 ;

  {
#line 530
  if (! record) {
#line 532
    return ((_Bool)1);
  } else {
    {
#line 530
    tmp = rec_record_num_fields(record);
    }
#line 530
    if (tmp == 0UL) {
#line 532
      return ((_Bool)1);
    }
  }
#line 537
  if (index___0) {
#line 537
    goto _L;
  } else
#line 537
  if (sex) {
#line 537
    goto _L;
  } else
#line 537
  if (fast_string) {
#line 537
    goto _L;
  } else
#line 537
  if (random___0 > 0UL) {
    _L: /* CIL Label */ 
    {
#line 541
    tmp___0 = rec_db_get_rset_by_type(db, type);
#line 541
    rset = tmp___0;
    }
#line 542
    if (rset) {
#line 544
      num_rec = (size_t )-1;
#line 549
      if (random___0 > 0UL) {
        {
#line 551
        tmp___1 = rec_rset_num_records(rset);
#line 551
        rec_db_add_random_indexes(& index___0, random___0, tmp___1);
        }
#line 552
        if (! index___0) {
#line 555
          return ((_Bool)0);
        }
      }
#line 562
      if (! (flags & 8)) {
        {
#line 564
        tmp___2 = rec_rset_add_auto_fields(rset, record);
        }
#line 564
        if (! tmp___2) {
#line 567
          return ((_Bool)0);
        }
      }
      {
#line 590
      rset_record = (rec_record_t )((void *)0);
#line 592
      tmp___3 = rec_rset_mset(rset);
#line 592
      tmp___4 = rec_mset_iterator(tmp___3);
#line 592
      iter = tmp___4;
      }
      {
#line 594
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 594
        tmp___7 = rec_mset_iterator_next(& iter, 1, (void const   **)(& rset_record),
                                         & elem);
        }
#line 594
        if (! tmp___7) {
#line 594
          goto while_break;
        }
        {
#line 596
        num_rec ++;
#line 600
        tmp___5 = rec_db_record_selected_p(num_rec, rset_record, index___0, sex, fast_string,
                                           (_Bool )(flags & 2));
        }
#line 600
        if (! tmp___5) {
#line 607
          goto while_continue;
        }
        {
#line 612
        rec_record_set_container(record, (void *)rset);
#line 613
        tmp___6 = rec_record_dup(record);
#line 613
        rec_mset_elem_set_data(elem, (void *)tmp___6);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 616
      rec_mset_iterator_free(& iter);
      }
    }
  } else {
    {
#line 624
    tmp___8 = rec_db_get_rset_by_type(db, type);
#line 624
    rset___0 = tmp___8;
    }
#line 626
    if (rset___0) {
      {
#line 628
      rec_record_set_container(record, (void *)rset___0);
      }
#line 633
      if (! (flags & 8)) {
        {
#line 635
        tmp___9 = rec_rset_add_auto_fields(rset___0, record);
        }
#line 635
        if (! tmp___9) {
#line 638
          return ((_Bool)0);
        }
      }
      {
#line 656
      tmp___17 = rec_rset_num_records(rset___0);
      }
#line 656
      if (tmp___17 == 0UL) {
        {
#line 661
        tmp___10 = rec_rset_descriptor_pos(rset___0);
#line 661
        tmp___11 = rec_rset_mset(rset___0);
#line 661
        rec_mset_insert_at(tmp___11, 1, (void *)record, tmp___10);
        }
      } else {
        {
#line 671
        tmp___12 = rec_rset_mset(rset___0);
#line 671
        mset = tmp___12;
#line 672
        tmp___13 = rec_rset_num_records(rset___0);
#line 672
        tmp___14 = rec_mset_get_at(mset, 1, tmp___13 - 1UL);
#line 672
        last_record = (rec_record_t )tmp___14;
#line 677
        tmp___15 = rec_mset_search(mset, (void *)last_record);
#line 677
        tmp___16 = rec_mset_insert_after(mset, 1, (void *)record, tmp___15);
        }
#line 677
        if (! tmp___16) {
#line 683
          return ((_Bool )((void *)0));
        }
      }
    } else {
      {
#line 691
      rset___0 = rec_rset_new();
      }
#line 692
      if (! rset___0) {
#line 695
        return ((_Bool)0);
      }
      {
#line 698
      rec_rset_set_type(rset___0, type);
#line 699
      rec_record_set_container(record, (void *)rset___0);
#line 700
      tmp___18 = rec_rset_mset(rset___0);
#line 700
      tmp___19 = rec_mset_append(tmp___18, 1, (void *)record, 0);
      }
#line 700
      if (! tmp___19) {
#line 706
        return ((_Bool)0);
      }
#line 709
      if (type) {
        {
#line 711
        tmp___20 = rec_db_size(db);
#line 711
        rec_db_insert_rset(db, rset___0, tmp___20);
        }
      } else {
        {
#line 718
        rec_db_insert_rset(db, rset___0, (size_t )0);
        }
      }
    }
  }
#line 723
  return ((_Bool)1);
}
}
#line 726 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
_Bool rec_db_delete(rec_db_t db , char const   *type , size_t *index___0 , rec_sex_t sex ,
                    char const   *fast_string , size_t random___0 , int flags ) 
{ 
  rec_rset_t rset ;
  rec_rset_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  rec_record_t record ;
  rec_mset_elem_t elem ;
  size_t num_rec ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp___3 ;
  rec_mset_iterator_t tmp___4 ;
  _Bool tmp___5 ;
  rec_comment_t comment ;
  rec_comment_t tmp___6 ;
  rec_mset_t tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 739
  tmp = rec_db_get_rset_by_type(db, type);
#line 739
  rset = tmp;
  }
#line 740
  if (! type) {
#line 740
    if (! rset) {
      {
#line 740
      tmp___0 = rec_db_size(db);
      }
#line 740
      if (tmp___0 == 1UL) {
        {
#line 742
        rset = rec_db_get_rset(db, (size_t )0);
        }
      }
    }
  }
  {
#line 747
  tmp___1 = rec_rset_num_records(rset);
  }
#line 747
  if (tmp___1 == 0UL) {
#line 749
    return ((_Bool)1);
  }
#line 755
  if (random___0 > 0UL) {
    {
#line 757
    tmp___2 = rec_rset_num_records(rset);
#line 757
    rec_db_add_random_indexes(& index___0, random___0, tmp___2);
    }
#line 758
    if (! index___0) {
#line 761
      return ((_Bool)0);
    }
  }
  {
#line 769
  record = (rec_record_t )((void *)0);
#line 771
  num_rec = (size_t )-1;
#line 772
  tmp___3 = rec_rset_mset(rset);
#line 772
  tmp___4 = rec_mset_iterator(tmp___3);
#line 772
  iter = tmp___4;
  }
  {
#line 774
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 774
    tmp___8 = rec_mset_iterator_next(& iter, 1, (void const   **)(& record), & elem);
    }
#line 774
    if (! tmp___8) {
#line 774
      goto while_break;
    }
    {
#line 776
    num_rec ++;
#line 778
    tmp___5 = rec_db_record_selected_p(num_rec, record, index___0, sex, fast_string,
                                       (_Bool )(flags & 2));
    }
#line 778
    if (! tmp___5) {
#line 785
      goto while_continue;
    }
#line 788
    if (flags & 16) {
      {
#line 793
      tmp___6 = rec_record_to_comment(record);
#line 793
      comment = tmp___6;
      }
#line 794
      if (! comment) {
#line 797
        return ((_Bool)0);
      }
      {
#line 800
      rec_record_destroy(record);
#line 801
      rec_mset_elem_set_data(elem, (void *)comment);
#line 802
      rec_mset_elem_set_type(elem, 2);
      }
    } else {
      {
#line 809
      tmp___7 = rec_rset_mset(rset);
#line 809
      rec_mset_remove_elem(tmp___7, elem);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 812
  rec_mset_iterator_free(& iter);
  }
#line 815
  return ((_Bool)1);
}
}
#line 818 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
_Bool rec_db_set(rec_db_t db , char const   *type , size_t *index___0 , rec_sex_t sex ,
                 char const   *fast_string , size_t random___0 , rec_fex_t fex , int action ,
                 char const   *action_arg , int flags ) 
{ 
  rec_rset_t rset ;
  rec_rset_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  rec_record_t record ;
  size_t num_rec ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp___3 ;
  rec_mset_iterator_t tmp___4 ;
  _Bool descriptor_renamed ;
  _Bool tmp___5 ;
  _Bool rename_descriptor ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;

  {
  {
#line 833
  tmp = rec_db_get_rset_by_type(db, type);
#line 833
  rset = tmp;
  }
#line 834
  if (! type) {
#line 834
    if (! rset) {
      {
#line 834
      tmp___0 = rec_db_size(db);
      }
#line 834
      if (tmp___0 == 1UL) {
        {
#line 836
        rset = rec_db_get_rset(db, (size_t )0);
        }
      }
    }
  }
  {
#line 841
  tmp___1 = rec_rset_num_records(rset);
  }
#line 841
  if (tmp___1 == 0UL) {
#line 843
    return ((_Bool)1);
  }
#line 849
  if (random___0 > 0UL) {
    {
#line 851
    tmp___2 = rec_rset_num_records(rset);
#line 851
    rec_db_add_random_indexes(& index___0, random___0, tmp___2);
    }
#line 852
    if (! index___0) {
#line 855
      return ((_Bool)0);
    }
  }
  {
#line 862
  record = (rec_record_t )((void *)0);
#line 863
  num_rec = (size_t )-1;
#line 864
  tmp___3 = rec_rset_mset(rset);
#line 864
  tmp___4 = rec_mset_iterator(tmp___3);
#line 864
  iter = tmp___4;
#line 865
  descriptor_renamed = (_Bool)0;
  }
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 867
    tmp___12 = rec_mset_iterator_next(& iter, 1, (void const   **)(& record), (rec_mset_elem_t *)((void *)0));
    }
#line 867
    if (! tmp___12) {
#line 867
      goto while_break;
    }
    {
#line 869
    num_rec ++;
#line 871
    tmp___5 = rec_db_record_selected_p(num_rec, record, index___0, sex, fast_string,
                                       (_Bool )(flags & 2));
    }
#line 871
    if (! tmp___5) {
#line 878
      goto while_continue;
    }
    {
#line 883
    if (action == 1) {
#line 883
      goto case_1;
    }
#line 905
    if (action == 2) {
#line 905
      goto case_2;
    }
#line 914
    if (action == 3) {
#line 914
      goto case_3;
    }
#line 923
    if (action == 4) {
#line 923
      goto case_4;
    }
#line 932
    if (action == 5) {
#line 932
      goto case_5;
    }
#line 941
    if (action == 6) {
#line 941
      goto case_6;
    }
#line 950
    goto switch_default;
    case_1: /* CIL Label */ 
#line 889
    rename_descriptor = (_Bool)0;
#line 890
    if (! descriptor_renamed) {
#line 890
      if ((unsigned long )sex == (unsigned long )((void *)0)) {
#line 890
        if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 890
          if (random___0 == 0UL) {
#line 890
            if ((unsigned long )fast_string == (unsigned long )((void *)0)) {
#line 893
              rename_descriptor = (_Bool)1;
#line 894
              descriptor_renamed = (_Bool)1;
            }
          }
        }
      }
    }
    {
#line 897
    tmp___6 = rec_db_set_act_rename(rset, record, fex, rename_descriptor, action_arg);
    }
#line 897
    if (! tmp___6) {
#line 900
      return ((_Bool)0);
    }
#line 903
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 907
    tmp___7 = rec_db_set_act_set(rset, record, fex, (_Bool)0, action_arg);
    }
#line 907
    if (! tmp___7) {
#line 910
      return ((_Bool)0);
    }
#line 912
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 916
    tmp___8 = rec_db_set_act_add(rset, record, fex, action_arg);
    }
#line 916
    if (! tmp___8) {
#line 919
      return ((_Bool)0);
    }
#line 921
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 925
    tmp___9 = rec_db_set_act_set(rset, record, fex, (_Bool)1, action_arg);
    }
#line 925
    if (! tmp___9) {
#line 928
      return ((_Bool)0);
    }
#line 930
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 934
    tmp___10 = rec_db_set_act_delete(rset, record, fex, (_Bool)0);
    }
#line 934
    if (! tmp___10) {
#line 937
      return ((_Bool)0);
    }
#line 939
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 943
    tmp___11 = rec_db_set_act_delete(rset, record, fex, (_Bool)1);
    }
#line 943
    if (! tmp___11) {
#line 946
      return ((_Bool)0);
    }
#line 948
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 953
    return ((_Bool)1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 957
  rec_mset_iterator_free(& iter);
  }
#line 960
  return ((_Bool)1);
}
}
#line 963 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
rec_aggregate_reg_t rec_db_aggregates(rec_db_t db ) 
{ 


  {
#line 966
  return (db->aggregates);
}
}
#line 973 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static rec_record_t rec_db_merge_records(rec_record_t record1 , rec_record_t record2 ,
                                         char const   *prefix ) 
{ 
  rec_mset_iterator_t iter ;
  rec_field_t field ;
  rec_record_t merge ;
  rec_mset_t tmp ;
  rec_field_t new_field ;
  rec_field_t tmp___0 ;
  char const   *field_name ;
  char const   *tmp___1 ;
  char *new_name ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  _Bool tmp___9 ;
  rec_mset_t tmp___10 ;
  rec_mset_elem_t tmp___11 ;
  _Bool tmp___12 ;

  {
  {
#line 980
  merge = (rec_record_t )((void *)0);
#line 982
  merge = rec_record_dup(record1);
  }
#line 983
  if (! merge) {
#line 985
    return ((rec_record_t )((void *)0));
  }
  {
#line 992
  tmp = rec_record_mset(record2);
#line 992
  iter = rec_mset_iterator(tmp);
  }
  {
#line 993
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 993
    tmp___12 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 993
    if (! tmp___12) {
#line 993
      goto while_break;
    }
    {
#line 995
    tmp___0 = rec_field_dup(field);
#line 995
    new_field = tmp___0;
    }
#line 996
    if (! new_field) {
#line 999
      return ((rec_record_t )((void *)0));
    }
    {
#line 1004
    tmp___1 = rec_field_name(new_field);
#line 1004
    field_name = tmp___1;
#line 1005
    tmp___2 = strlen(field_name);
#line 1005
    tmp___3 = strlen(prefix);
#line 1005
    tmp___4 = malloc((tmp___2 + tmp___3) + 2UL);
#line 1005
    new_name = (char *)tmp___4;
    }
#line 1006
    if (! new_name) {
#line 1009
      return ((rec_record_t )((void *)0));
    }
    {
#line 1012
    tmp___5 = strlen(prefix);
#line 1012
    memcpy((void */* __restrict  */)new_name, (void const   */* __restrict  */)prefix,
           tmp___5);
#line 1013
    tmp___6 = strlen(prefix);
#line 1013
    *(new_name + tmp___6) = (char )'_';
#line 1014
    tmp___7 = strlen(field_name);
#line 1014
    tmp___8 = strlen(prefix);
#line 1014
    memcpy((void */* __restrict  */)((new_name + tmp___8) + 1), (void const   */* __restrict  */)field_name,
           tmp___7 + 1UL);
#line 1016
    tmp___9 = rec_field_set_name(new_field, (char const   *)new_name);
    }
#line 1016
    if (! tmp___9) {
#line 1019
      return ((rec_record_t )((void *)0));
    }
    {
#line 1022
    free((void *)new_name);
#line 1025
    tmp___10 = rec_record_mset(merge);
#line 1025
    tmp___11 = rec_mset_append(tmp___10, 1, (void *)new_field, 0);
    }
#line 1025
    if (! tmp___11) {
#line 1031
      return ((rec_record_t )((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1034
  rec_mset_iterator_free(& iter);
  }
#line 1036
  return (merge);
}
}
#line 1039 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static rec_rset_t rec_db_join(rec_db_t db , char const   *type1 , char const   *field ,
                              char const   *type2 ) 
{ 
  char const   *key ;
  rec_rset_t join ;
  rec_rset_t rset1 ;
  rec_rset_t tmp ;
  rec_rset_t rset2 ;
  rec_rset_t tmp___0 ;
  rec_record_t record1 ;
  rec_mset_iterator_t iter1 ;
  rec_mset_t tmp___1 ;
  rec_mset_iterator_t tmp___2 ;
  size_t num_foreign_keys ;
  size_t tmp___3 ;
  size_t num_foreign_key ;
  rec_record_t record2 ;
  rec_mset_iterator_t iter2 ;
  rec_mset_t tmp___4 ;
  rec_mset_iterator_t tmp___5 ;
  _Bool found ;
  size_t i ;
  rec_field_t key_field ;
  rec_field_t tmp___6 ;
  rec_field_t tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  rec_record_t record ;
  rec_record_t tmp___12 ;
  size_t tmp___13 ;
  rec_mset_t tmp___14 ;
  rec_mset_elem_t tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  rec_record_t new_descriptor ;
  rec_record_t tmp___18 ;
  rec_field_t new_field ;
  char *new_rset_type ;
  char *tmp___19 ;
  char const   *tmp___20 ;
  rec_mset_t tmp___21 ;
  rec_mset_elem_t tmp___22 ;

  {
  {
#line 1052
  key = (char const   *)((void *)0);
#line 1053
  join = (rec_rset_t )((void *)0);
#line 1054
  tmp = rec_db_get_rset_by_type(db, type1);
#line 1054
  rset1 = tmp;
#line 1055
  tmp___0 = rec_db_get_rset_by_type(db, type2);
#line 1055
  rset2 = tmp___0;
  }
#line 1058
  if (! rset1) {
#line 1060
    return ((rec_rset_t )((void *)0));
  } else
#line 1058
  if (! rset2) {
#line 1060
    return ((rec_rset_t )((void *)0));
  }
  {
#line 1064
  key = rec_rset_key(rset2);
  }
#line 1065
  if (! key) {
#line 1067
    return ((rec_rset_t )((void *)0));
  }
  {
#line 1072
  join = rec_rset_new();
  }
#line 1073
  if (! join) {
#line 1076
    return ((rec_rset_t )((void *)0));
  } else {
    {
#line 1080
    record1 = (rec_record_t )((void *)0);
#line 1081
    tmp___1 = rec_rset_mset(rset1);
#line 1081
    tmp___2 = rec_mset_iterator(tmp___1);
#line 1081
    iter1 = tmp___2;
    }
    {
#line 1082
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1082
      tmp___17 = rec_mset_iterator_next(& iter1, 1, (void const   **)(& record1),
                                        (rec_mset_elem_t *)((void *)0));
      }
#line 1082
      if (! tmp___17) {
#line 1082
        goto while_break;
      }
      {
#line 1088
      tmp___3 = rec_record_get_num_fields_by_name(record1, field);
#line 1088
      num_foreign_keys = tmp___3;
#line 1089
      num_foreign_key = (size_t )0;
#line 1091
      num_foreign_key = (size_t )0;
      }
      {
#line 1091
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1091
        if (! (num_foreign_key < num_foreign_keys)) {
#line 1091
          goto while_break___0;
        }
        {
#line 1093
        record2 = (rec_record_t )((void *)0);
#line 1094
        tmp___4 = rec_rset_mset(rset2);
#line 1094
        tmp___5 = rec_mset_iterator(tmp___4);
#line 1094
        iter2 = tmp___5;
        }
        {
#line 1096
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1096
          tmp___16 = rec_mset_iterator_next(& iter2, 1, (void const   **)(& record2),
                                            (rec_mset_elem_t *)((void *)0));
          }
#line 1096
          if (! tmp___16) {
#line 1096
            goto while_break___1;
          }
          {
#line 1102
          found = (_Bool)0;
#line 1103
          i = (size_t )0;
#line 1105
          tmp___6 = rec_record_get_field_by_name(record2, key, num_foreign_key);
#line 1105
          key_field = tmp___6;
          }
#line 1106
          if (! key_field) {
#line 1110
            goto while_break___1;
          }
#line 1113
          found = (_Bool)0;
#line 1114
          i = (size_t )0;
          {
#line 1114
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1114
            tmp___11 = rec_record_get_num_fields_by_name(record1, field);
            }
#line 1114
            if (! (i < tmp___11)) {
#line 1114
              goto while_break___2;
            }
            {
#line 1116
            tmp___7 = rec_record_get_field_by_name(record1, field, i);
#line 1116
            tmp___8 = rec_field_value(tmp___7);
#line 1116
            tmp___9 = rec_field_value(key_field);
#line 1116
            tmp___10 = strcmp(tmp___9, tmp___8);
            }
#line 1116
            if (tmp___10 == 0) {
#line 1119
              found = (_Bool)1;
#line 1120
              goto while_break___2;
            }
#line 1114
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1124
          if (! found) {
#line 1127
            goto while_continue___1;
          }
          {
#line 1132
          tmp___12 = rec_db_merge_records(record1, record2, field);
#line 1132
          record = tmp___12;
          }
#line 1133
          if (! record) {
#line 1136
            return ((rec_rset_t )((void *)0));
          }
          {
#line 1142
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 1142
            tmp___13 = rec_record_get_num_fields_by_name(record, field);
            }
#line 1142
            if (! (tmp___13 > 0UL)) {
#line 1142
              goto while_break___3;
            }
            {
#line 1144
            rec_record_remove_field_by_name(record, field, (size_t )0);
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 1149
          rec_record_set_container(record, (void *)join);
#line 1150
          tmp___14 = rec_rset_mset(join);
#line 1150
          tmp___15 = rec_mset_append(tmp___14, 1, (void *)record, 0);
          }
#line 1150
          if (! tmp___15) {
#line 1153
            return ((rec_rset_t )((void *)0));
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1156
        rec_mset_iterator_free(& iter2);
#line 1091
        num_foreign_key ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1159
    rec_mset_iterator_free(& iter1);
    }
  }
  {
#line 1168
  tmp___18 = rec_record_new();
#line 1168
  new_descriptor = tmp___18;
  }
#line 1169
  if (! new_descriptor) {
#line 1172
    return ((rec_rset_t )((void *)0));
  }
  {
#line 1178
  new_field = (rec_field_t )((void *)0);
#line 1179
  tmp___19 = rec_concat_strings(type1, "_", field);
#line 1179
  new_rset_type = tmp___19;
  }
#line 1180
  if (! new_rset_type) {
#line 1183
    return ((rec_rset_t )((void *)0));
  }
  {
#line 1186
  tmp___20 = rec_std_field_name((enum rec_std_field_e )5);
#line 1186
  new_field = rec_field_new(tmp___20, (char const   *)new_rset_type);
#line 1188
  tmp___21 = rec_record_mset(new_descriptor);
#line 1188
  tmp___22 = rec_mset_append(tmp___21, 1, (void *)new_field, 0);
  }
#line 1188
  if (! tmp___22) {
#line 1194
    return ((rec_rset_t )((void *)0));
  }
  {
#line 1198
  rec_rset_set_descriptor(join, new_descriptor);
  }
#line 1201
  return (join);
}
}
#line 1204 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_set_act_rename(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                   _Bool rename_descriptor , char const   *arg ) 
{ 
  size_t j ;
  size_t min ;
  size_t max ;
  size_t renamed ;
  size_t num_fields ;
  rec_fex_elem_t fex_elem ;
  rec_field_t field ;
  char const   *field_name ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1220
  fex_elem = rec_fex_get(fex, (size_t )0);
#line 1221
  field_name = rec_fex_elem_field_name(fex_elem);
#line 1222
  tmp = rec_fex_elem_min(fex_elem);
#line 1222
  min = (size_t )tmp;
#line 1223
  tmp___0 = rec_fex_elem_max(fex_elem);
#line 1223
  max = (size_t )tmp___0;
#line 1225
  num_fields = rec_record_get_num_fields_by_name(record, field_name);
  }
#line 1227
  if (min == 0xffffffffffffffffUL) {
#line 1230
    min = (size_t )0;
#line 1231
    max = num_fields - 1UL;
  }
#line 1233
  if (max == 0xffffffffffffffffUL) {
#line 1235
    max = min;
  }
#line 1238
  renamed = (size_t )0;
#line 1239
  j = (size_t )0;
  {
#line 1239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1239
    if (! (j < num_fields)) {
#line 1239
      goto while_break;
    }
#line 1241
    if (j >= min) {
#line 1241
      if (j <= max) {
        {
#line 1245
        field = rec_record_get_field_by_name(record, field_name, j - renamed);
        }
#line 1248
        if (field) {
          {
#line 1250
          rec_field_set_name(field, arg);
#line 1251
          renamed ++;
          }
        }
#line 1254
        if (rename_descriptor) {
          {
#line 1257
          rec_rset_rename_field(rset, field_name, arg);
          }
        }
      }
    }
#line 1239
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1264
  return ((_Bool)1);
}
}
#line 1268 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_set_act_set(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                _Bool add_p , char const   *arg ) 
{ 
  size_t i ;
  size_t j ;
  size_t min ;
  size_t max ;
  size_t num_fields ;
  rec_fex_elem_t fex_elem ;
  rec_field_t field ;
  char const   *field_name ;
  int tmp ;
  int tmp___0 ;
  rec_mset_t tmp___1 ;
  rec_mset_elem_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 1281
  i = (size_t )0;
  {
#line 1281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1281
    tmp___3 = rec_fex_size(fex);
    }
#line 1281
    if (! (i < tmp___3)) {
#line 1281
      goto while_break;
    }
    {
#line 1283
    fex_elem = rec_fex_get(fex, i);
#line 1284
    field_name = rec_fex_elem_field_name(fex_elem);
#line 1285
    tmp = rec_fex_elem_min(fex_elem);
#line 1285
    min = (size_t )tmp;
#line 1286
    tmp___0 = rec_fex_elem_max(fex_elem);
#line 1286
    max = (size_t )tmp___0;
#line 1288
    num_fields = rec_record_get_num_fields_by_name(record, field_name);
    }
#line 1290
    if (min == 0xffffffffffffffffUL) {
#line 1293
      min = (size_t )0;
#line 1294
      max = num_fields - 1UL;
    }
#line 1296
    if (max == 0xffffffffffffffffUL) {
#line 1298
      max = min;
    }
#line 1301
    j = (size_t )0;
    {
#line 1301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1301
      if (! (j < num_fields)) {
#line 1301
        goto while_break___0;
      }
#line 1303
      if (j >= min) {
#line 1303
        if (j <= max) {
          {
#line 1307
          field = rec_record_get_field_by_name(record, field_name, j);
          }
#line 1310
          if (field) {
            {
#line 1312
            rec_field_set_value(field, arg);
            }
          }
        }
      }
#line 1301
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1317
    if (add_p) {
#line 1317
      if (num_fields == 0UL) {
        {
#line 1320
        field = rec_field_new(field_name, arg);
#line 1321
        tmp___1 = rec_record_mset(record);
#line 1321
        tmp___2 = rec_mset_append(tmp___1, 1, (void *)field, 0);
        }
#line 1321
        if (! tmp___2) {
#line 1324
          return ((_Bool)0);
        }
      }
    }
#line 1281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1329
  return ((_Bool)1);
}
}
#line 1332 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_set_act_add(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                char const   *arg ) 
{ 
  size_t i ;
  rec_fex_elem_t fex_elem ;
  rec_fex_elem_t tmp ;
  char const   *field_name ;
  char const   *tmp___0 ;
  rec_field_t field ;
  rec_field_t tmp___1 ;
  rec_mset_t tmp___2 ;
  rec_mset_elem_t tmp___3 ;
  size_t tmp___4 ;

  {
#line 1341
  i = (size_t )0;
  {
#line 1341
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1341
    tmp___4 = rec_fex_size(fex);
    }
#line 1341
    if (! (i < tmp___4)) {
#line 1341
      goto while_break;
    }
    {
#line 1343
    tmp = rec_fex_get(fex, i);
#line 1343
    fex_elem = tmp;
#line 1344
    tmp___0 = rec_fex_elem_field_name(fex_elem);
#line 1344
    field_name = tmp___0;
#line 1345
    tmp___1 = rec_field_new(field_name, arg);
#line 1345
    field = tmp___1;
    }
#line 1346
    if (! field) {
#line 1349
      return ((_Bool)0);
    }
    {
#line 1352
    tmp___2 = rec_record_mset(record);
#line 1352
    tmp___3 = rec_mset_append(tmp___2, 1, (void *)field, 0);
    }
#line 1352
    if (! tmp___3) {
#line 1355
      return ((_Bool)0);
    }
#line 1341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1359
  return ((_Bool)1);
}
}
#line 1362 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_set_act_delete(rec_rset_t rset , rec_record_t record , rec_fex_t fex ,
                                   _Bool comment_out ) 
{ 
  size_t i ;
  size_t j ;
  size_t num_fields ;
  _Bool *deletion_mask ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_elem_t elem ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  rec_fex_elem_t fex_elem ;
  rec_fex_elem_t tmp___2 ;
  char const   *field_name ;
  char const   *tmp___3 ;
  size_t min ;
  int tmp___4 ;
  size_t max ;
  int tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  rec_mset_t tmp___9 ;
  rec_comment_t comment ;
  rec_comment_t tmp___10 ;
  rec_mset_t tmp___11 ;
  _Bool tmp___12 ;

  {
  {
#line 1376
  tmp = rec_record_num_fields(record);
#line 1376
  tmp___0 = malloc(sizeof(_Bool ) * tmp);
#line 1376
  deletion_mask = (_Bool *)tmp___0;
  }
#line 1377
  if (! deletion_mask) {
#line 1380
    return ((_Bool)0);
  }
#line 1383
  i = (size_t )0;
  {
#line 1383
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1383
    tmp___1 = rec_record_num_fields(record);
    }
#line 1383
    if (! (i < tmp___1)) {
#line 1383
      goto while_break;
    }
#line 1385
    *(deletion_mask + i) = (_Bool)0;
#line 1383
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1389
  i = (size_t )0;
  {
#line 1389
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1389
    tmp___8 = rec_fex_size(fex);
    }
#line 1389
    if (! (i < tmp___8)) {
#line 1389
      goto while_break___0;
    }
    {
#line 1391
    tmp___2 = rec_fex_get(fex, i);
#line 1391
    fex_elem = tmp___2;
#line 1392
    tmp___3 = rec_fex_elem_field_name(fex_elem);
#line 1392
    field_name = tmp___3;
#line 1393
    tmp___4 = rec_fex_elem_min(fex_elem);
#line 1393
    min = (size_t )tmp___4;
#line 1394
    tmp___5 = rec_fex_elem_max(fex_elem);
#line 1394
    max = (size_t )tmp___5;
#line 1396
    num_fields = rec_record_get_num_fields_by_name(record, field_name);
    }
#line 1398
    if (min == 0xffffffffffffffffUL) {
#line 1401
      min = (size_t )0;
#line 1402
      max = num_fields - 1UL;
    }
#line 1404
    if (max == 0xffffffffffffffffUL) {
#line 1406
      max = min;
    }
#line 1409
    j = (size_t )0;
    {
#line 1409
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1409
      if (! (j < num_fields)) {
#line 1409
        goto while_break___1;
      }
#line 1411
      if (j >= min) {
#line 1411
        if (j <= max) {
          {
#line 1414
          tmp___6 = rec_fex_elem_field_name(fex_elem);
#line 1414
          field = rec_record_get_field_by_name(record, tmp___6, j);
#line 1417
          tmp___7 = rec_record_get_field_index(record, field);
#line 1417
          *(deletion_mask + tmp___7) = (_Bool)1;
          }
        }
      }
#line 1409
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1389
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1423
  i = (size_t )0;
#line 1425
  tmp___9 = rec_record_mset(record);
#line 1425
  iter = rec_mset_iterator(tmp___9);
  }
  {
#line 1426
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1426
    tmp___12 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), & elem);
    }
#line 1426
    if (! tmp___12) {
#line 1426
      goto while_break___2;
    }
#line 1428
    if (*(deletion_mask + i)) {
#line 1430
      if (comment_out) {
        {
#line 1434
        tmp___10 = rec_field_to_comment(field);
#line 1434
        comment = tmp___10;
        }
#line 1435
        if (! comment) {
#line 1438
          return ((_Bool)0);
        }
        {
#line 1441
        rec_field_destroy(field);
#line 1442
        rec_mset_elem_set_data(elem, (void *)comment);
#line 1443
        rec_mset_elem_set_type(elem, 2);
        }
      } else {
        {
#line 1449
        tmp___11 = rec_record_mset(record);
#line 1449
        rec_mset_remove_elem(tmp___11, elem);
        }
      }
    }
#line 1453
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1455
  rec_mset_iterator_free(& iter);
  }
#line 1457
  return ((_Bool)1);
}
}
#line 1460 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_index_p(size_t *index___0 , size_t num ) 
{ 
  _Bool found ;
  size_t min ;
  size_t max ;
  int tmp ;

  {
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1464
    if (! (*(index___0 + 0) != 0xffffffffffffffffUL)) {
#line 1464
      if (! (*(index___0 + 1) != 0xffffffffffffffffUL)) {
#line 1464
        goto while_break;
      }
    }
#line 1466
    found = (_Bool)0;
#line 1467
    min = *(index___0 + 0);
#line 1468
    max = *(index___0 + 1);
#line 1470
    if (max == 0xffffffffffffffffUL) {
#line 1472
      found = (_Bool )(num == min);
    } else {
#line 1476
      if (num >= min) {
#line 1476
        if (num <= max) {
#line 1476
          tmp = 1;
        } else {
#line 1476
          tmp = 0;
        }
      } else {
#line 1476
        tmp = 0;
      }
#line 1476
      found = (_Bool )tmp;
    }
#line 1479
    if (found) {
#line 1481
      return ((_Bool)1);
    }
#line 1484
    index___0 += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  return ((_Bool)0);
}
}
#line 1490 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static void rec_db_add_random_indexes(size_t **index___0 , size_t num , size_t limit ) 
{ 
  size_t i ;
  char random_state[128] ;
  struct random_data random_data ;
  void *tmp ;
  time_t tmp___0 ;
  size_t random_value ;
  size_t i___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 1503
  tmp = malloc(sizeof(size_t ) * ((num + 1UL) * 2UL));
#line 1503
  *index___0 = (size_t *)tmp;
  }
#line 1504
  if ((unsigned long )*index___0 == (unsigned long )((void *)0)) {
#line 1507
    return;
  }
#line 1510
  i = (size_t )0;
  {
#line 1510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1510
    if (! (i < (num + 1UL) * 2UL)) {
#line 1510
      goto while_break;
    }
#line 1512
    *(*index___0 + i) = (size_t )-1;
#line 1510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1517
  memset((void *)(& random_data), 0, sizeof(random_data));
#line 1518
  tmp___0 = time((time_t *)((void *)0));
#line 1518
  initstate_r((unsigned int )tmp___0, (char */* __restrict  */)((char *)(& random_state)),
              (size_t )128, (struct random_data */* __restrict  */)(& random_data));
#line 1519
  i = (size_t )0;
  }
  {
#line 1519
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1519
    if (! (i < num * 2UL)) {
#line 1519
      goto while_break___0;
    }
    {
#line 1521
    random_value = (size_t )0;
#line 1523
    random_r((struct random_data */* __restrict  */)(& random_data), (int32_t */* __restrict  */)((int32_t *)(& random_value)));
#line 1524
    random_value %= limit;
#line 1528
    tmp___2 = rec_db_index_p(*index___0, random_value);
    }
#line 1528
    if (tmp___2) {
#line 1533
      i___0 = (size_t )0;
      {
#line 1533
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1533
        if (! (i___0 < limit)) {
#line 1533
          goto while_break___1;
        }
        {
#line 1535
        tmp___1 = rec_db_index_p(*index___0, i___0);
        }
#line 1535
        if (! tmp___1) {
#line 1537
          random_value = i___0;
#line 1538
          goto while_break___1;
        }
#line 1533
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1543
    *(*index___0 + i) = random_value;
#line 1544
    *(*index___0 + (i + 1UL)) = (size_t )-1;
#line 1519
    i += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1546
  return;
}
}
#line 1548 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_record_selected_p(size_t num_record , rec_record_t record , size_t *index___0 ,
                                      rec_sex_t sex , char const   *fast_string ,
                                      _Bool case_insensitive_p ) 
{ 
  _Bool tmp ;
  _Bool eval_status ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1563
  if (fast_string) {
    {
#line 1565
    tmp = rec_record_contains_value(record, fast_string, case_insensitive_p);
    }
#line 1565
    return (tmp);
  }
#line 1574
  if (sex) {
    {
#line 1577
    tmp___0 = rec_sex_eval(sex, record, & eval_status);
    }
#line 1577
    return (tmp___0);
  }
#line 1585
  if (index___0) {
    {
#line 1587
    tmp___1 = rec_db_index_p(index___0, num_record);
    }
#line 1587
    return (tmp___1);
  }
#line 1590
  return ((_Bool)1);
}
}
#line 1593 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static rec_record_t rec_db_process_fex(rec_db_t db , rec_rset_t rset , rec_record_t record ,
                                       rec_fex_t fex ) 
{ 
  rec_record_t res ;
  size_t fex_size ;
  size_t i ;
  size_t j ;
  rec_record_t tmp ;
  rec_fex_elem_t elem ;
  rec_fex_elem_t tmp___0 ;
  char const   *field_name ;
  char const   *tmp___1 ;
  char const   *alias ;
  char const   *tmp___2 ;
  char const   *function_name ;
  char const   *tmp___3 ;
  size_t min ;
  int tmp___4 ;
  size_t max ;
  int tmp___5 ;
  char *(*func)(rec_rset_t rset , rec_record_t record , char const   *field_name ) ;
  rec_aggregate_reg_t tmp___6 ;
  rec_aggregate_t tmp___7 ;
  char *func_res ;
  char *tmp___8 ;
  rec_field_t agg_field ;
  char *agg_field_name ;
  char *agg_field_value ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  rec_mset_t tmp___13 ;
  rec_mset_elem_t tmp___14 ;
  rec_field_t res_field ;
  rec_field_t field ;
  rec_field_t tmp___15 ;
  _Bool tmp___16 ;
  rec_mset_t tmp___17 ;
  rec_mset_elem_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;

  {
#line 1599
  res = (rec_record_t )((void *)0);
#line 1600
  j = (size_t )0;
#line 1605
  if (! fex) {
    {
#line 1607
    tmp = rec_record_dup(record);
    }
#line 1607
    return (tmp);
  }
  {
#line 1610
  res = rec_record_new();
  }
#line 1611
  if (! res) {
#line 1614
    return ((rec_record_t )((void *)0));
  }
  {
#line 1623
  fex_size = rec_fex_size(fex);
#line 1624
  i = (size_t )0;
  }
  {
#line 1624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1624
    if (! (i < fex_size)) {
#line 1624
      goto while_break;
    }
    {
#line 1626
    tmp___0 = rec_fex_get(fex, i);
#line 1626
    elem = tmp___0;
#line 1627
    tmp___1 = rec_fex_elem_field_name(elem);
#line 1627
    field_name = tmp___1;
#line 1628
    tmp___2 = rec_fex_elem_rewrite_to(elem);
#line 1628
    alias = tmp___2;
#line 1629
    tmp___3 = rec_fex_elem_function_name(elem);
#line 1629
    function_name = tmp___3;
#line 1630
    tmp___4 = rec_fex_elem_min(elem);
#line 1630
    min = (size_t )tmp___4;
#line 1631
    tmp___5 = rec_fex_elem_max(elem);
#line 1631
    max = (size_t )tmp___5;
    }
#line 1633
    if (function_name) {
      {
#line 1643
      tmp___6 = rec_db_aggregates(db);
#line 1643
      tmp___7 = rec_aggregate_reg_get(tmp___6, function_name);
#line 1643
      func = tmp___7;
      }
#line 1644
      if (func) {
        {
#line 1646
        tmp___8 = (*func)(rset, record, field_name);
#line 1646
        func_res = tmp___8;
        }
#line 1647
        if (func_res) {
#line 1652
          agg_field = (rec_field_t )((void *)0);
#line 1653
          agg_field_name = (char *)((void *)0);
#line 1654
          agg_field_value = func_res;
#line 1661
          if (alias) {
            {
#line 1663
            agg_field_name = strdup(alias);
            }
#line 1664
            if (! agg_field_name) {
#line 1667
              return ((rec_record_t )((void *)0));
            }
          } else {
            {
#line 1672
            tmp___9 = strlen(function_name);
#line 1672
            tmp___10 = strlen(field_name);
#line 1672
            tmp___11 = malloc(((tmp___9 + 1UL) + tmp___10) + 1UL);
#line 1672
            agg_field_name = (char *)tmp___11;
            }
#line 1673
            if (! agg_field_name) {
#line 1676
              return ((rec_record_t )((void *)0));
            }
            {
#line 1679
            tmp___12 = strlen(function_name);
#line 1679
            memcpy((void */* __restrict  */)agg_field_name, (void const   */* __restrict  */)function_name,
                   tmp___12 + 1UL);
#line 1680
            strcat((char */* __restrict  */)agg_field_name, (char const   */* __restrict  */)"_");
#line 1681
            strcat((char */* __restrict  */)agg_field_name, (char const   */* __restrict  */)field_name);
            }
          }
          {
#line 1684
          agg_field = rec_field_new((char const   *)agg_field_name, (char const   *)agg_field_value);
          }
#line 1685
          if (! agg_field) {
#line 1688
            return ((rec_record_t )((void *)0));
          }
          {
#line 1691
          tmp___13 = rec_record_mset(res);
#line 1691
          tmp___14 = rec_mset_append(tmp___13, 1, (void *)agg_field, 1);
          }
#line 1691
          if (! tmp___14) {
#line 1697
            return ((rec_record_t )((void *)0));
          }
          {
#line 1700
          free((void *)agg_field_name);
#line 1701
          free((void *)func_res);
          }
        }
      }
    } else {
#line 1707
      if (min == 0xffffffffffffffffUL) {
#line 1707
        if (max == 0xffffffffffffffffUL) {
          {
#line 1710
          min = (size_t )0;
#line 1711
          max = rec_record_get_num_fields_by_name(record, field_name);
          }
        } else {
#line 1707
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1713
      if (max == 0xffffffffffffffffUL) {
#line 1716
        max = min + 1UL;
      } else {
#line 1721
        max ++;
      }
#line 1726
      j = min;
      {
#line 1726
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1726
        if (! (j < max)) {
#line 1726
          goto while_break___0;
        }
        {
#line 1728
        res_field = (rec_field_t )((void *)0);
#line 1729
        tmp___15 = rec_record_get_field_by_name(record, field_name, j);
#line 1729
        field = tmp___15;
        }
#line 1732
        if (! field) {
#line 1734
          goto __Cont;
        }
        {
#line 1741
        res_field = rec_field_dup(field);
        }
#line 1742
        if (alias) {
          {
#line 1744
          tmp___16 = rec_field_set_name(res_field, alias);
          }
#line 1744
          if (! tmp___16) {
#line 1747
            return ((rec_record_t )((void *)0));
          }
        }
        {
#line 1751
        tmp___17 = rec_record_mset(res);
#line 1751
        tmp___18 = rec_mset_append(tmp___17, 1, (void *)res_field, 1);
        }
#line 1751
        if (! tmp___18) {
#line 1757
          return ((rec_record_t )((void *)0));
        }
        __Cont: /* CIL Label */ 
#line 1726
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1624
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1767
  if (record) {
    {
#line 1769
    tmp___19 = rec_record_location(record);
#line 1769
    rec_record_set_location(res, tmp___19);
#line 1770
    tmp___20 = rec_record_char_location(record);
#line 1770
    rec_record_set_char_location(res, tmp___20);
    }
  }
#line 1773
  return (res);
}
}
#line 1776 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static _Bool rec_db_rset_equals_fn(void const   *elt1 , void const   *elt2 ) 
{ 


  {
#line 1780
  return ((_Bool)0);
}
}
#line 1783 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-db.c"
static void rec_db_rset_dispose_fn(void const   *elt ) 
{ 
  rec_rset_t rset ;

  {
  {
#line 1788
  rset = (rec_rset_t )elt;
#line 1789
  rec_rset_destroy(rset);
  }
#line 1790
  return;
}
}
#line 123 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 116 "./rec.h"
rec_mset_t rec_mset_new(void) ;
#line 122
void rec_mset_destroy(rec_mset_t mset ) ;
#line 129
rec_mset_t rec_mset_dup(rec_mset_t mset ) ;
#line 146
rec_mset_type_t rec_mset_register_type(rec_mset_t mset , char *name , void (*disp_fn)(void *data ) ,
                                       _Bool (*equal_fn)(void *data1 , void *data2 ) ,
                                       void *(*dup_fn)(void *data ) , int (*compare_fn)(void *data1 ,
                                                                                        void *data2 ,
                                                                                        int type2 ) ) ;
#line 159
size_t rec_mset_count(rec_mset_t mset , rec_mset_type_t type ) ;
#line 304
rec_mset_t rec_mset_sort(rec_mset_t mset ) ;
#line 351
void rec_comment_destroy(rec_comment_t comment ) ;
#line 356
rec_comment_t rec_comment_dup(rec_comment_t comment ) ;
#line 1017
void *rec_record_container(rec_record_t record ) ;
#line 1102
rec_rset_t rec_rset_dup(rec_rset_t rset ) ;
#line 1122
size_t rec_rset_num_comments(rec_rset_t rset ) ;
#line 1159
char *rec_rset_url(rec_rset_t rset ) ;
#line 1230
rec_fex_t rec_rset_auto(rec_rset_t rset ) ;
#line 1261
_Bool rec_rset_set_order_by_fields(rec_rset_t rset , rec_fex_t field_names ) ;
#line 1265
rec_fex_t rec_rset_order_by_fields(rec_rset_t rset ) ;
#line 65 "./rec-utils.h"
size_t rec_extract_size(char const   *str ) ;
#line 66
enum rec_size_condition_e rec_extract_size_condition(char const   *str ) ;
#line 108 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_init(rec_rset_t rset ) ;
#line 110
static void rec_rset_update_types(rec_rset_t rset ) ;
#line 111
static void rec_rset_update_field_props(rec_rset_t rset ) ;
#line 112
static void rec_rset_update_size_constraints(rec_rset_t rset ) ;
#line 113
static void rec_rset_update_sex_constraints(rec_rset_t rset ) ;
#line 115
static _Bool rec_rset_record_equal_fn(void *data1 , void *data2 ) ;
#line 116
static void rec_rset_record_disp_fn(void *data ) ;
#line 117
static void *rec_rset_record_dup_fn(void *data ) ;
#line 118
static int rec_rset_record_compare_fn(void *data1 , void *data2 , int type2 ) ;
#line 120
static _Bool rec_rset_comment_equal_fn(void *data1 , void *data2 ) ;
#line 121
static void rec_rset_comment_disp_fn(void *data ) ;
#line 122
static void *rec_rset_comment_dup_fn(void *data ) ;
#line 123
static int rec_rset_comment_compare_fn(void *data1 , void *data2 , int type2 ) ;
#line 125
static _Bool rec_rset_type_field_p(char const   *str ) ;
#line 126
static rec_fex_t rec_rset_type_field_fex(char const   *str ) ;
#line 127
static char *rec_rset_type_field_type(char const   *str ) ;
#line 129
static rec_rset_fprops_t rec_rset_get_props(rec_rset_t rset , char const   *fname ,
                                            _Bool create_p ) ;
#line 133
static _Bool rec_rset_add_auto_field_int(rec_rset_t rset , char const   *field_name ,
                                         rec_record_t record ) ;
#line 136
static _Bool rec_rset_add_auto_field_date(rec_rset_t rset , char const   *field_name ,
                                          rec_record_t record ) ;
#line 146
static rec_record_t rec_rset_merge_records(rec_record_t to_record , rec_record_t from_record ,
                                           rec_fex_t group_by_fields ) ;
#line 150
static int rec_rset_compare_typed_records(rec_rset_t rset , rec_record_t record1 ,
                                          rec_record_t record2 , rec_fex_t fields ) ;
#line 165 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_rset_t rec_rset_new(void) 
{ 
  rec_rset_t rset ;
  void *tmp ;

  {
  {
#line 170
  tmp = malloc(sizeof(struct rec_rset_s ));
#line 170
  rset = (rec_rset_t )tmp;
  }
#line 171
  if (rset) {
    {
#line 173
    rec_rset_init(rset);
#line 176
    rset->mset = rec_mset_new();
    }
#line 177
    if (rset->mset) {
      {
#line 180
      rset->descriptor = (rec_record_t )((void *)0);
#line 181
      rset->descriptor_pos = (size_t )0;
#line 182
      rset->min_size = (size_t )0;
#line 183
      rset->max_size = 0xffffffffffffffffUL;
#line 184
      rset->constraints = (rec_sex_t *)((void *)0);
#line 185
      rset->num_constraints = (size_t )0;
#line 188
      rset->type_reg = rec_type_reg_new();
      }
#line 189
      if (! rset->type_reg) {
        {
#line 192
        rec_rset_destroy(rset);
        }
#line 193
        return ((rec_rset_t )((void *)0));
      }
      {
#line 197
      rset->field_props = (rec_rset_fprops_t )((void *)0);
#line 200
      rset->order_by_fields = (rec_fex_t )((void *)0);
#line 205
      rset->record_type = rec_mset_register_type(rset->mset, (char *)"record", & rec_rset_record_disp_fn,
                                                 & rec_rset_record_equal_fn, & rec_rset_record_dup_fn,
                                                 & rec_rset_record_compare_fn);
#line 211
      rset->comment_type = rec_mset_register_type(rset->mset, (char *)"comment", & rec_rset_comment_disp_fn,
                                                  & rec_rset_comment_equal_fn, & rec_rset_comment_dup_fn,
                                                  & rec_rset_comment_compare_fn);
      }
    } else {
      {
#line 222
      rec_rset_destroy(rset);
#line 223
      rset = (rec_rset_t )((void *)0);
      }
    }
  }
#line 227
  return (rset);
}
}
#line 230 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
void rec_rset_destroy(rec_rset_t rset ) 
{ 
  rec_rset_fprops_t props ;
  rec_rset_fprops_t aux ;
  size_t i ;

  {
#line 233
  aux = (rec_rset_fprops_t )((void *)0);
#line 234
  i = (size_t )0;
#line 236
  if (rset) {
    {
#line 238
    rec_record_destroy(rset->descriptor);
#line 239
    rec_type_reg_destroy(rset->type_reg);
#line 241
    i = (size_t )0;
    }
    {
#line 241
    while (1) {
      while_continue: /* CIL Label */ ;
#line 241
      if (! (i < rset->num_constraints)) {
#line 241
        goto while_break;
      }
      {
#line 243
      rec_sex_destroy(*(rset->constraints + i));
#line 241
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 245
    free((void *)rset->constraints);
#line 247
    props = rset->field_props;
    }
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      if (! props) {
#line 248
        goto while_break___0;
      }
#line 250
      aux = props;
#line 252
      if (aux->type) {
        {
#line 254
        rec_type_destroy(aux->type);
        }
      }
      {
#line 256
      free((void *)aux->fname);
#line 257
      free((void *)aux->type_name);
#line 258
      props = props->next;
#line 259
      free((void *)aux);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 262
    rec_fex_destroy(rset->order_by_fields);
#line 264
    rec_mset_destroy(rset->mset);
#line 265
    free((void *)rset);
    }
  }
#line 267
  return;
}
}
#line 269 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_rset_t rec_rset_dup(rec_rset_t rset ) 
{ 
  rec_rset_t new ;
  void *tmp ;

  {
  {
#line 272
  new = (rec_rset_t )((void *)0);
#line 274
  tmp = malloc(sizeof(struct rec_rset_s ));
#line 274
  new = (rec_rset_t )tmp;
  }
#line 275
  if (new) {
    {
#line 277
    rec_rset_init(new);
#line 279
    new->record_type = rset->record_type;
#line 280
    new->comment_type = rset->comment_type;
#line 281
    new->mset = (rec_mset_t )((void *)0);
#line 282
    new->min_size = rset->min_size;
#line 283
    new->max_size = rset->max_size;
#line 285
    new->type_reg = (rec_type_reg_t )((void *)0);
#line 286
    new->field_props = (rec_rset_fprops_t )((void *)0);
#line 287
    new->constraints = (rec_sex_t *)((void *)0);
#line 288
    new->num_constraints = (size_t )0;
    }
#line 290
    if (rset->order_by_fields) {
      {
#line 292
      new->order_by_fields = rec_fex_dup(rset->order_by_fields);
      }
#line 293
      if (! new->order_by_fields) {
        {
#line 296
        rec_rset_destroy(new);
        }
#line 297
        return ((rec_rset_t )((void *)0));
      }
    }
  }
  {
#line 302
  new->mset = rec_mset_dup(rset->mset);
  }
#line 303
  if (! new->mset) {
    {
#line 306
    rec_rset_destroy(new);
    }
#line 307
    return ((rec_rset_t )((void *)0));
  }
#line 310
  return (new);
}
}
#line 313 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_mset_t rec_rset_mset(rec_rset_t rset ) 
{ 


  {
#line 316
  return (rset->mset);
}
}
#line 319 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
size_t rec_rset_num_elems(rec_rset_t rset ) 
{ 
  size_t tmp ;

  {
  {
#line 322
  tmp = rec_mset_count(rset->mset, 0);
  }
#line 322
  return (tmp);
}
}
#line 325 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
size_t rec_rset_num_records(rec_rset_t rset ) 
{ 
  size_t tmp ;

  {
  {
#line 328
  tmp = rec_mset_count(rset->mset, rset->record_type);
  }
#line 328
  return (tmp);
}
}
#line 331 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
size_t rec_rset_num_comments(rec_rset_t rset ) 
{ 
  size_t tmp ;

  {
  {
#line 334
  tmp = rec_mset_count(rset->mset, rset->comment_type);
  }
#line 334
  return (tmp);
}
}
#line 337 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_record_t rec_rset_descriptor(rec_rset_t rset ) 
{ 


  {
#line 340
  return (rset->descriptor);
}
}
#line 343 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
void rec_rset_set_descriptor(rec_rset_t rset , rec_record_t record ) 
{ 


  {
#line 346
  if (rset->descriptor) {
    {
#line 348
    rec_record_destroy(rset->descriptor);
#line 349
    rset->descriptor = (rec_record_t )((void *)0);
    }
  }
  {
#line 351
  rset->descriptor = record;
#line 354
  rec_rset_update_types(rset);
#line 355
  rec_rset_update_field_props(rset);
#line 356
  rec_rset_update_size_constraints(rset);
#line 357
  rec_rset_update_sex_constraints(rset);
  }
#line 358
  return;
}
}
#line 360 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
size_t rec_rset_descriptor_pos(rec_rset_t rset ) 
{ 


  {
#line 363
  return (rset->descriptor_pos);
}
}
#line 366 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
void rec_rset_set_descriptor_pos(rec_rset_t rset , size_t position ) 
{ 


  {
#line 370
  rset->descriptor_pos = position;
#line 371
  return;
}
}
#line 373 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
void rec_rset_set_type(rec_rset_t rset , char const   *type ) 
{ 
  rec_field_t rec_field ;
  char const   *tmp ;
  char const   *tmp___0 ;
  rec_mset_t tmp___1 ;

  {
#line 379
  if (! type) {
#line 382
    return;
  }
#line 385
  if (! rset->descriptor) {
    {
#line 388
    rset->descriptor = rec_record_new();
    }
  }
  {
#line 392
  tmp = rec_std_field_name((enum rec_std_field_e )5);
#line 392
  rec_field = rec_record_get_field_by_name(rset->descriptor, tmp, (size_t )0);
  }
#line 396
  if (rec_field) {
    {
#line 398
    rec_field_set_value(rec_field, type);
    }
  } else {
    {
#line 402
    tmp___0 = rec_std_field_name((enum rec_std_field_e )5);
#line 402
    rec_field = rec_field_new(tmp___0, type);
#line 403
    tmp___1 = rec_record_mset(rset->descriptor);
#line 403
    rec_mset_append(tmp___1, 1, (void *)rec_field, 1);
    }
  }
#line 405
  return;
}
}
#line 407 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
char *rec_rset_type(rec_rset_t rset ) 
{ 
  char *res ;
  rec_field_t field ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 413
  res = (char *)((void *)0);
#line 414
  if (rset->descriptor) {
    {
#line 416
    tmp = rec_std_field_name((enum rec_std_field_e )5);
#line 416
    field = rec_record_get_field_by_name(rset->descriptor, tmp, (size_t )0);
    }
#line 419
    if (field) {
      {
#line 421
      tmp___0 = rec_field_value(field);
#line 421
      res = rec_extract_type(tmp___0);
      }
    }
  }
#line 425
  return (res);
}
}
#line 428 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
char *rec_rset_url(rec_rset_t rset ) 
{ 
  char *res ;
  rec_field_t field ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 434
  res = (char *)((void *)0);
#line 435
  if (rset->descriptor) {
    {
#line 437
    tmp = rec_std_field_name((enum rec_std_field_e )5);
#line 437
    field = rec_record_get_field_by_name(rset->descriptor, tmp, (size_t )0);
    }
#line 440
    if (field) {
      {
#line 442
      tmp___0 = rec_field_value(field);
#line 442
      res = rec_extract_url(tmp___0);
      }
    }
  }
#line 446
  return (res);
}
}
#line 449 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_type_reg_t rec_rset_get_type_reg(rec_rset_t rset ) 
{ 


  {
#line 452
  return (rset->type_reg);
}
}
#line 455 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
void rec_rset_rename_field(rec_rset_t rset , char const   *field_name , char const   *new_field_name ) 
{ 
  size_t j ;
  rec_record_t descriptor ;
  rec_fex_t fex ;
  char *fex_str ;
  char *type_str ;
  rec_buf_t buf ;
  char *result ;
  size_t result_size ;
  rec_fex_elem_t fex_elem ;
  char const   *fex_fname ;
  rec_mset_t descriptor_mset ;
  rec_mset_t tmp ;
  rec_mset_iterator_t iter ;
  rec_mset_iterator_t tmp___0 ;
  rec_field_t field ;
  char const   *tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  _Bool tmp___4 ;
  size_t tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  _Bool tmp___8 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  _Bool tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  _Bool tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  _Bool tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  _Bool tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  _Bool tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  _Bool tmp___27 ;
  _Bool tmp___28 ;

  {
  {
#line 471
  descriptor = rec_rset_descriptor(rset);
  }
#line 472
  if (descriptor) {
    {
#line 474
    tmp = rec_record_mset(descriptor);
#line 474
    descriptor_mset = tmp;
#line 475
    tmp___0 = rec_mset_iterator(descriptor_mset);
#line 475
    iter = tmp___0;
    }
    {
#line 478
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 478
      tmp___28 = rec_mset_iterator_next(& iter, 1, (void const   **)((void *)(& field)),
                                        (rec_mset_elem_t *)((void *)0));
      }
#line 478
      if (! tmp___28) {
#line 478
        goto while_break;
      }
      {
#line 480
      tmp___25 = rec_std_field_name((enum rec_std_field_e )8);
#line 480
      tmp___26 = rec_field_name(field);
#line 480
      tmp___27 = rec_field_name_equal_p(tmp___26, tmp___25);
      }
#line 480
      if (tmp___27) {
        {
#line 484
        tmp___1 = rec_field_value(field);
#line 484
        tmp___2 = rec_rset_type_field_p(tmp___1);
        }
#line 484
        if (! tmp___2) {
#line 486
          goto while_continue;
        }
        {
#line 489
        tmp___3 = rec_field_value(field);
#line 489
        fex = rec_rset_type_field_fex(tmp___3);
        }
#line 490
        if (fex) {
#line 492
          j = (size_t )0;
          {
#line 492
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 492
            tmp___5 = rec_fex_size(fex);
            }
#line 492
            if (! (j < tmp___5)) {
#line 492
              goto while_break___0;
            }
            {
#line 494
            fex_elem = rec_fex_get(fex, j);
#line 495
            fex_fname = rec_fex_elem_field_name(fex_elem);
#line 496
            tmp___4 = rec_field_name_equal_p(field_name, fex_fname);
            }
#line 496
            if (tmp___4) {
              {
#line 499
              rec_fex_elem_set_field_name(fex_elem, new_field_name);
              }
            }
#line 492
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 503
          fex_str = rec_fex_str(fex, (enum rec_fex_kind_e )1);
#line 504
          tmp___6 = rec_field_value(field);
#line 504
          type_str = rec_rset_type_field_type(tmp___6);
#line 506
          buf = rec_buf_new(& result, & result_size);
#line 507
          rec_buf_puts((char const   *)fex_str, buf);
#line 508
          rec_buf_putc(' ', buf);
#line 509
          rec_buf_puts((char const   *)type_str, buf);
#line 510
          rec_buf_close(buf);
#line 512
          rec_field_set_value(field, (char const   *)result);
#line 514
          free((void *)fex_str);
#line 515
          free((void *)type_str);
#line 516
          rec_fex_destroy(fex);
          }
        }
      } else {
        {
#line 519
        tmp___10 = rec_std_field_name((enum rec_std_field_e )2);
#line 519
        tmp___11 = rec_field_name(field);
#line 519
        tmp___12 = rec_field_name_equal_p(tmp___11, tmp___10);
        }
#line 519
        if (tmp___12) {
#line 519
          goto _L;
        } else {
          {
#line 519
          tmp___13 = rec_std_field_name((enum rec_std_field_e )3);
#line 519
          tmp___14 = rec_field_name(field);
#line 519
          tmp___15 = rec_field_name_equal_p(tmp___14, tmp___13);
          }
#line 519
          if (tmp___15) {
#line 519
            goto _L;
          } else {
            {
#line 519
            tmp___16 = rec_std_field_name((enum rec_std_field_e )10);
#line 519
            tmp___17 = rec_field_name(field);
#line 519
            tmp___18 = rec_field_name_equal_p(tmp___17, tmp___16);
            }
#line 519
            if (tmp___18) {
#line 519
              goto _L;
            } else {
              {
#line 519
              tmp___19 = rec_std_field_name((enum rec_std_field_e )4);
#line 519
              tmp___20 = rec_field_name(field);
#line 519
              tmp___21 = rec_field_name_equal_p(tmp___20, tmp___19);
              }
#line 519
              if (tmp___21) {
#line 519
                goto _L;
              } else {
                {
#line 519
                tmp___22 = rec_std_field_name((enum rec_std_field_e )7);
#line 519
                tmp___23 = rec_field_name(field);
#line 519
                tmp___24 = rec_field_name_equal_p(tmp___23, tmp___22);
                }
#line 519
                if (tmp___24) {
                  _L: /* CIL Label */ 
                  {
#line 530
                  tmp___7 = rec_field_value(field);
#line 530
                  fex = rec_fex_new(tmp___7, (enum rec_fex_kind_e )0);
                  }
#line 531
                  if (fex) {
#line 533
                    j = (size_t )0;
                    {
#line 533
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
                      {
#line 533
                      tmp___9 = rec_fex_size(fex);
                      }
#line 533
                      if (! (j < tmp___9)) {
#line 533
                        goto while_break___1;
                      }
                      {
#line 535
                      fex_elem = rec_fex_get(fex, j);
#line 537
                      fex_fname = rec_fex_elem_field_name(fex_elem);
#line 538
                      tmp___8 = rec_field_name_equal_p(field_name, fex_fname);
                      }
#line 538
                      if (tmp___8) {
                        {
#line 541
                        rec_fex_elem_set_field_name(fex_elem, new_field_name);
                        }
                      }
#line 533
                      j ++;
                    }
                    while_break___1: /* CIL Label */ ;
                    }
                    {
#line 545
                    fex_str = rec_fex_str(fex, (enum rec_fex_kind_e )0);
#line 546
                    rec_field_set_value(field, (char const   *)fex_str);
#line 547
                    free((void *)fex_str);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 552
    rec_mset_iterator_free(& iter);
    }
  }
  {
#line 556
  rec_rset_update_field_props(rset);
  }
#line 557
  return;
}
}
#line 559 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
char const   *rec_rset_key(rec_rset_t rset ) 
{ 
  char const   *key ;
  rec_rset_fprops_t props ;

  {
#line 562
  key = (char const   *)((void *)0);
#line 563
  props = rset->field_props;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! props) {
#line 565
      goto while_break;
    }
#line 567
    if (props->key_p) {
#line 570
      key = (char const   *)props->fname;
#line 571
      goto while_break;
    }
#line 573
    props = props->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return (key);
}
}
#line 579 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_fex_t rec_rset_auto(rec_rset_t rset ) 
{ 
  rec_fex_t fex ;
  rec_rset_fprops_t props ;

  {
  {
#line 585
  fex = rec_fex_new((char const   *)((void *)0), (enum rec_fex_kind_e )0);
#line 587
  props = rset->field_props;
  }
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (! props) {
#line 588
      goto while_break;
    }
#line 590
    if (props->auto_p) {
      {
#line 592
      rec_fex_append(fex, (char const   *)props->fname, -1, -1);
      }
    }
#line 596
    props = props->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 599
  return (fex);
}
}
#line 656 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_type_t rec_rset_get_field_type(rec_rset_t rset , char const   *field_name ) 
{ 
  rec_type_t type ;
  rec_rset_fprops_t props ;

  {
  {
#line 660
  type = (rec_type_t )((void *)0);
#line 661
  props = (rec_rset_fprops_t )((void *)0);
#line 663
  props = rec_rset_get_props(rset, field_name, (_Bool)0);
  }
#line 664
  if (props) {
#line 666
    type = props->type;
#line 667
    if (! type) {
#line 667
      if (props->type_name) {
        {
#line 669
        type = rec_type_reg_get(rset->type_reg, (char const   *)props->type_name);
        }
      }
    }
  }
#line 673
  return (type);
}
}
#line 676 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
size_t rec_rset_min_records(rec_rset_t rset ) 
{ 


  {
#line 679
  return (rset->min_size);
}
}
#line 682 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
size_t rec_rset_max_records(rec_rset_t rset ) 
{ 


  {
#line 685
  return (rset->max_size);
}
}
#line 688 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
char *rec_rset_source(rec_rset_t rset ) 
{ 
  rec_record_t record ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 696
  record = rec_rset_descriptor(rset);
  }
#line 697
  if (! record) {
    {
#line 699
    tmp = rec_mset_get_at(rset->mset, 1, (size_t )0);
#line 699
    record = (rec_record_t )tmp;
    }
  }
  {
#line 702
  tmp___0 = rec_record_source(record);
  }
#line 702
  return (tmp___0);
}
}
#line 706 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
_Bool rec_rset_set_order_by_fields(rec_rset_t rset , rec_fex_t field_names ) 
{ 


  {
  {
#line 710
  rec_fex_destroy(rset->order_by_fields);
#line 711
  rset->order_by_fields = rec_fex_dup(field_names);
  }
#line 712
  return ((_Bool )((unsigned long )rset->order_by_fields != (unsigned long )((void *)0)));
}
}
#line 715 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_fex_t rec_rset_order_by_fields(rec_rset_t rset ) 
{ 


  {
#line 718
  return (rset->order_by_fields);
}
}
#line 721 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_rset_t rec_rset_sort(rec_rset_t rset , rec_fex_t sort_by ) 
{ 
  rec_mset_t tmp ;

  {
#line 725
  if (sort_by) {
    {
#line 727
    rec_rset_set_order_by_fields(rset, sort_by);
    }
  }
#line 730
  if (rset->order_by_fields) {
    {
#line 735
    tmp = rec_mset_sort(rset->mset);
    }
#line 735
    if (! tmp) {
#line 738
      return ((rec_rset_t )((void *)0));
    }
    {
#line 744
    rec_rset_update_field_props(rset);
    }
  }
#line 747
  return (rset);
}
}
#line 750 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_rset_t rec_rset_group(rec_rset_t rset , rec_fex_t group_by ) 
{ 
  rec_mset_iterator_t iter ;
  rec_record_t record ;
  rec_mset_elem_t elem ;
  size_t map_size ;
  _Bool *deletion_map ;
  size_t num_record ;
  size_t tmp ;
  void *tmp___0 ;
  rec_mset_t tmp___1 ;
  size_t num_record_2 ;
  rec_mset_iterator_t iter2 ;
  rec_record_t record2 ;
  rec_record_t tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  rec_mset_t tmp___6 ;
  rec_mset_t tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 763
  tmp = rec_rset_num_records(rset);
#line 763
  map_size = sizeof(_Bool ) * tmp;
#line 764
  tmp___0 = malloc(map_size);
#line 764
  deletion_map = (_Bool *)tmp___0;
  }
#line 765
  if (! deletion_map) {
#line 768
    return ((rec_rset_t )((void *)0));
  }
  {
#line 771
  memset((void *)deletion_map, 0, map_size);
#line 776
  num_record = (size_t )0;
#line 777
  tmp___1 = rec_rset_mset(rset);
#line 777
  iter = rec_mset_iterator(tmp___1);
  }
  {
#line 778
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 778
    tmp___5 = rec_mset_iterator_next(& iter, 1, (void const   **)(& record), (rec_mset_elem_t *)((void *)0));
    }
#line 778
    if (! tmp___5) {
#line 778
      goto while_break;
    }
#line 780
    if (! *(deletion_map + num_record)) {
#line 782
      num_record_2 = num_record;
#line 783
      iter2 = iter;
      {
#line 786
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 786
        tmp___4 = rec_mset_iterator_next(& iter2, 1, (void const   **)(& record2),
                                         (rec_mset_elem_t *)((void *)0));
        }
#line 786
        if (! tmp___4) {
#line 786
          goto while_break___0;
        }
        {
#line 788
        num_record_2 ++;
#line 790
        tmp___3 = rec_rset_compare_typed_records(rset, record, record2, group_by);
        }
#line 790
        if (tmp___3 != 0) {
#line 792
          goto while_break___0;
        } else {
          {
#line 801
          tmp___2 = rec_rset_merge_records(record, record2, group_by);
          }
#line 801
          if (! tmp___2) {
#line 806
            return ((rec_rset_t )((void *)0));
          }
#line 810
          *(deletion_map + num_record_2) = (_Bool)1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 815
    num_record ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 817
  rec_mset_iterator_free(& iter);
#line 821
  num_record = (size_t )0;
#line 822
  tmp___6 = rec_rset_mset(rset);
#line 822
  iter = rec_mset_iterator(tmp___6);
  }
  {
#line 823
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 823
    tmp___8 = rec_mset_iterator_next(& iter, 1, (void const   **)(& record), & elem);
    }
#line 823
    if (! tmp___8) {
#line 823
      goto while_break___1;
    }
#line 825
    if (*(deletion_map + num_record)) {
      {
#line 827
      tmp___7 = rec_rset_mset(rset);
#line 827
      rec_mset_remove_elem(tmp___7, elem);
      }
    }
#line 830
    num_record ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 832
  rec_mset_iterator_free(& iter);
#line 834
  free((void *)deletion_map);
  }
#line 836
  return (rset);
}
}
#line 839 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_rset_t rec_rset_add_auto_fields(rec_rset_t rset , rec_record_t record ) 
{ 
  rec_fex_t auto_fields ;
  rec_type_t type ;
  size_t i ;
  size_t num_auto_fields ;
  size_t tmp ;
  char const   *auto_field_name ;
  rec_fex_elem_t tmp___0 ;
  char const   *tmp___1 ;
  enum rec_type_kind_e tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 847
  auto_fields = rec_rset_auto(rset);
  }
#line 847
  if (auto_fields) {
    {
#line 849
    tmp = rec_fex_size(auto_fields);
#line 849
    num_auto_fields = tmp;
#line 851
    i = (size_t )0;
    }
    {
#line 851
    while (1) {
      while_continue: /* CIL Label */ ;
#line 851
      if (! (i < num_auto_fields)) {
#line 851
        goto while_break;
      }
      {
#line 853
      tmp___0 = rec_fex_get(auto_fields, i);
#line 853
      tmp___1 = rec_fex_elem_field_name(tmp___0);
#line 853
      auto_field_name = tmp___1;
#line 856
      tmp___5 = rec_record_field_p(record, auto_field_name);
      }
#line 856
      if (! tmp___5) {
        {
#line 864
        type = rec_rset_get_field_type(rset, auto_field_name);
        }
#line 865
        if (type) {
          {
#line 867
          tmp___2 = rec_type_kind(type);
          }
          {
#line 870
          if ((unsigned int )tmp___2 == 3U) {
#line 870
            goto case_3;
          }
#line 870
          if ((unsigned int )tmp___2 == 1U) {
#line 870
            goto case_3;
          }
#line 880
          if ((unsigned int )tmp___2 == 8U) {
#line 880
            goto case_8;
          }
#line 902
          goto switch_default;
          case_3: /* CIL Label */ 
          case_1: /* CIL Label */ 
          {
#line 872
          tmp___3 = rec_rset_add_auto_field_int(rset, auto_field_name, record);
          }
#line 872
          if (! tmp___3) {
#line 875
            return ((rec_rset_t )((void *)0));
          }
#line 878
          goto switch_break;
          case_8: /* CIL Label */ 
          {
#line 882
          tmp___4 = rec_rset_add_auto_field_date(rset, auto_field_name, record);
          }
#line 882
          if (! tmp___4) {
#line 885
            return ((rec_rset_t )((void *)0));
          }
#line 888
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 905
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
#line 851
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 913
  return (rset);
}
}
#line 916 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
size_t rec_rset_num_sex_constraints(rec_rset_t rset ) 
{ 


  {
#line 919
  return (rset->num_constraints);
}
}
#line 922 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
rec_sex_t rec_rset_sex_constraint(rec_rset_t rset , size_t index___0 ) 
{ 


  {
#line 926
  return (*(rset->constraints + index___0));
}
}
#line 933 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_init(rec_rset_t rset ) 
{ 


  {
  {
#line 940
  memset((void *)rset, 0, sizeof(struct rec_rset_s ));
  }
#line 941
  return;
}
}
#line 943 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_record_disp_fn(void *data ) 
{ 
  rec_record_t record ;

  {
  {
#line 946
  record = (rec_record_t )data;
#line 947
  rec_record_destroy(record);
  }
#line 948
  return;
}
}
#line 950 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static _Bool rec_rset_record_equal_fn(void *data1 , void *data2 ) 
{ 


  {
#line 954
  return ((_Bool )((unsigned long )data1 == (unsigned long )data2));
}
}
#line 959 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void *rec_rset_record_dup_fn(void *data ) 
{ 
  rec_record_t record ;
  rec_record_t new ;
  rec_record_t tmp ;

  {
  {
#line 962
  record = (rec_record_t )data;
#line 963
  tmp = rec_record_dup(record);
#line 963
  new = tmp;
  }
#line 965
  return ((void *)new);
}
}
#line 968 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static int rec_rset_record_compare_fn(void *data1 , void *data2 , int type2 ) 
{ 
  rec_rset_t rset ;
  rec_record_t record1 ;
  rec_record_t record2 ;
  int type_comparison ;
  void *tmp ;

  {
#line 993
  rset = (rec_rset_t )((void *)0);
#line 994
  record1 = (rec_record_t )((void *)0);
#line 995
  record2 = (rec_record_t )((void *)0);
#line 996
  type_comparison = 0;
#line 999
  if (type2 == 2) {
#line 1001
    return (1);
  }
  {
#line 1005
  record1 = (rec_record_t )data1;
#line 1006
  record2 = (rec_record_t )data2;
#line 1007
  tmp = rec_record_container(record1);
#line 1007
  rset = (rec_rset_t )tmp;
#line 1012
  type_comparison = rec_rset_compare_typed_records(rset, record1, record2, rset->order_by_fields);
  }
#line 1020
  if (type_comparison == 0) {
#line 1022
    type_comparison = -1;
  }
#line 1025
  return (type_comparison);
}
}
#line 1028 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_comment_disp_fn(void *data ) 
{ 
  rec_comment_t comment ;

  {
  {
#line 1031
  comment = (rec_comment_t )data;
#line 1032
  rec_comment_destroy(comment);
  }
#line 1033
  return;
}
}
#line 1035 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static _Bool rec_rset_comment_equal_fn(void *data1 , void *data2 ) 
{ 


  {
#line 1039
  return ((_Bool )((unsigned long )data1 == (unsigned long )data2));
}
}
#line 1044 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void *rec_rset_comment_dup_fn(void *data ) 
{ 
  rec_comment_t comment ;
  rec_comment_t new ;
  rec_comment_t tmp ;

  {
  {
#line 1047
  comment = (rec_comment_t )data;
#line 1048
  tmp = rec_comment_dup(comment);
#line 1048
  new = tmp;
  }
#line 1049
  return ((void *)new);
}
}
#line 1052 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static int rec_rset_comment_compare_fn(void *data1 , void *data2 , int type2 ) 
{ 


  {
#line 1060
  return (-1);
}
}
#line 1063 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_update_sex_constraints(rec_rset_t rset ) 
{ 
  size_t i ;
  size_t num_constraints ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp___2 ;
  char const   *field_name ;
  char const   *tmp___3 ;
  char const   *field_value ;
  char const   *tmp___4 ;
  rec_sex_t sex ;
  rec_sex_t tmp___5 ;
  size_t tmp___6 ;
  _Bool tmp___7 ;
  char const   *tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
#line 1069
  i = (size_t )0;
#line 1071
  i = (size_t )0;
  {
#line 1071
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1071
    if (! (i < rset->num_constraints)) {
#line 1071
      goto while_break;
    }
    {
#line 1073
    rec_sex_destroy(*(rset->constraints + i));
#line 1071
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1075
  rset->num_constraints = (size_t )0;
#line 1081
  if (! rset->descriptor) {
#line 1083
    return;
  }
  {
#line 1090
  tmp = rec_std_field_name((enum rec_std_field_e )11);
#line 1090
  tmp___0 = rec_record_get_num_fields_by_name(rset->descriptor, tmp);
#line 1090
  num_constraints = tmp___0;
#line 1092
  tmp___1 = malloc(num_constraints * sizeof(rec_sex_t ));
#line 1092
  rset->constraints = (rec_sex_t *)tmp___1;
  }
#line 1094
  if (! rset->constraints) {
#line 1096
    return;
  }
  {
#line 1105
  field = (rec_field_t )((void *)0);
#line 1108
  tmp___2 = rec_record_mset(rset->descriptor);
#line 1108
  iter = rec_mset_iterator(tmp___2);
  }
  {
#line 1109
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1109
    tmp___10 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 1109
    if (! tmp___10) {
#line 1109
      goto while_break___0;
    }
    {
#line 1111
    tmp___3 = rec_field_name(field);
#line 1111
    field_name = tmp___3;
#line 1112
    tmp___4 = rec_field_value(field);
#line 1112
    field_value = tmp___4;
#line 1114
    tmp___8 = rec_std_field_name((enum rec_std_field_e )11);
#line 1114
    tmp___9 = rec_field_name_equal_p(field_name, tmp___8);
    }
#line 1114
    if (tmp___9) {
      {
#line 1116
      tmp___5 = rec_sex_new((_Bool)0);
#line 1116
      sex = tmp___5;
      }
#line 1117
      if (! sex) {
#line 1119
        return;
      }
      {
#line 1122
      tmp___7 = rec_sex_compile(sex, field_value);
      }
#line 1122
      if (tmp___7) {
#line 1124
        tmp___6 = rset->num_constraints;
#line 1124
        (rset->num_constraints) ++;
#line 1124
        *(rset->constraints + tmp___6) = sex;
      } else {
        {
#line 1128
        rec_sex_destroy(sex);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1132
  rec_mset_iterator_free(& iter);
  }
#line 1134
  return;
}
}
#line 1136 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_update_size_constraints(rec_rset_t rset ) 
{ 
  rec_field_t field ;
  enum rec_size_condition_e condition ;
  size_t size ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;

  {
#line 1141
  size = (size_t )0;
#line 1144
  rset->min_size = (size_t )0;
#line 1145
  rset->max_size = 0xffffffffffffffffUL;
#line 1149
  if (rset->descriptor) {
    {
#line 1151
    tmp = rec_std_field_name((enum rec_std_field_e )6);
#line 1151
    field = rec_record_get_field_by_name(rset->descriptor, tmp, (size_t )0);
    }
#line 1155
    if (field) {
      {
#line 1155
      tmp___2 = rec_field_value(field);
#line 1155
      tmp___3 = rec_match(tmp___2, "^[ \t\n]*(>|<|>=|<=)?[ \t\n]*-?((0x[0-9a-fA-F]+)|[0-9]+)[ \t\n]*$");
      }
#line 1155
      if (tmp___3) {
        {
#line 1159
        tmp___0 = rec_field_value(field);
#line 1159
        condition = rec_extract_size_condition(tmp___0);
#line 1160
        tmp___1 = rec_field_value(field);
#line 1160
        size = rec_extract_size(tmp___1);
        }
        {
#line 1166
        if ((unsigned int )condition == 0U) {
#line 1166
          goto case_0;
        }
#line 1172
        if ((unsigned int )condition == 1U) {
#line 1172
          goto case_1;
        }
#line 1177
        if ((unsigned int )condition == 2U) {
#line 1177
          goto case_2;
        }
#line 1182
        if ((unsigned int )condition == 3U) {
#line 1182
          goto case_3;
        }
#line 1187
        if ((unsigned int )condition == 4U) {
#line 1187
          goto case_4;
        }
#line 1164
        goto switch_break;
        case_0: /* CIL Label */ 
#line 1168
        rset->min_size = size;
#line 1169
        rset->max_size = size;
#line 1170
        goto switch_break;
        case_1: /* CIL Label */ 
#line 1174
        rset->max_size = size - 1UL;
#line 1175
        goto switch_break;
        case_2: /* CIL Label */ 
#line 1179
        rset->max_size = size;
#line 1180
        goto switch_break;
        case_3: /* CIL Label */ 
#line 1184
        rset->min_size = size + 1UL;
#line 1185
        goto switch_break;
        case_4: /* CIL Label */ 
#line 1189
        rset->min_size = size;
#line 1190
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 1195
  return;
}
}
#line 1197 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_update_field_props(rec_rset_t rset ) 
{ 
  rec_rset_fprops_t props ;
  char *type_name ;
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  char const   *field_name ;
  char const   *tmp___0 ;
  char const   *field_value ;
  char const   *tmp___1 ;
  size_t i ;
  rec_fex_t fex ;
  rec_fex_t tmp___2 ;
  char *field_type ;
  char *tmp___3 ;
  rec_type_t type ;
  rec_type_t tmp___4 ;
  char const   *p ;
  rec_fex_elem_t tmp___5 ;
  char const   *tmp___6 ;
  rec_fex_elem_t tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  char const   *tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  char const   *field_value___0 ;
  char const   *tmp___13 ;
  char *type_name___0 ;
  char const   *tmp___14 ;
  _Bool tmp___15 ;
  rec_fex_t fex___0 ;
  char const   *tmp___16 ;
  rec_fex_t tmp___17 ;
  size_t i___0 ;
  char const   *auto_field_name ;
  rec_fex_elem_t tmp___18 ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  char const   *tmp___21 ;
  _Bool tmp___22 ;
  char const   *field_value___1 ;
  char const   *tmp___23 ;
  rec_fex_t fex___1 ;
  rec_fex_t tmp___24 ;
  char const   *tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;

  {
#line 1200
  props = (rec_rset_fprops_t )((void *)0);
#line 1204
  type_name = (char *)((void *)0);
#line 1207
  props = rset->field_props;
  {
#line 1208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1208
    if (! props) {
#line 1208
      goto while_break;
    }
#line 1210
    props->key_p = (_Bool)0;
#line 1211
    props->auto_p = (_Bool)0;
#line 1212
    if (props->type) {
      {
#line 1214
      rec_type_destroy(props->type);
#line 1215
      props->type = (rec_type_t )((void *)0);
      }
    }
#line 1218
    props = props->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1221
  if (rset->descriptor) {
    {
#line 1229
    tmp = rec_record_mset(rset->descriptor);
#line 1229
    iter = rec_mset_iterator(tmp);
    }
    {
#line 1230
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1230
      tmp___27 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
      }
#line 1230
      if (! tmp___27) {
#line 1230
        goto while_break___0;
      }
      {
#line 1232
      tmp___0 = rec_field_name(field);
#line 1232
      field_name = tmp___0;
#line 1233
      tmp___1 = rec_field_value(field);
#line 1233
      field_value = tmp___1;
#line 1238
      tmp___10 = rec_std_field_name((enum rec_std_field_e )8);
#line 1238
      tmp___11 = rec_field_name_equal_p(field_name, tmp___10);
      }
#line 1238
      if (tmp___11) {
        {
#line 1238
        tmp___12 = rec_rset_type_field_p(field_value);
        }
#line 1238
        if (tmp___12) {
          {
#line 1242
          tmp___2 = rec_rset_type_field_fex(field_value);
#line 1242
          fex = tmp___2;
#line 1244
          i = (size_t )0;
          }
          {
#line 1244
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 1244
            tmp___9 = rec_fex_size(fex);
            }
#line 1244
            if (! (i < tmp___9)) {
#line 1244
              goto while_break___1;
            }
            {
#line 1246
            tmp___3 = rec_rset_type_field_type(field_value);
#line 1246
            field_type = tmp___3;
#line 1247
            tmp___4 = rec_type_new((char const   *)field_type);
#line 1247
            type = tmp___4;
            }
#line 1249
            if (! type) {
              {
#line 1256
              p = (char const   *)field_type;
#line 1257
              rec_parse_regexp(& p, "^[a-zA-Z][a-zA-Z0-9_-]*", & type_name);
#line 1258
              tmp___5 = rec_fex_get(fex, i);
#line 1258
              tmp___6 = rec_fex_elem_field_name(tmp___5);
#line 1258
              props = rec_rset_get_props(rset, tmp___6, (_Bool)1);
              }
#line 1261
              if (props->type) {
                {
#line 1263
                rec_type_destroy(props->type);
#line 1264
                props->type = (rec_type_t )((void *)0);
                }
              }
              {
#line 1266
              free((void *)props->type_name);
#line 1267
              props->type_name = type_name;
              }
            } else {
              {
#line 1276
              tmp___7 = rec_fex_get(fex, i);
#line 1276
              tmp___8 = rec_fex_elem_field_name(tmp___7);
#line 1276
              props = rec_rset_get_props(rset, tmp___8, (_Bool)1);
              }
#line 1279
              if (props->type) {
                {
#line 1281
                rec_type_destroy(props->type);
                }
              }
              {
#line 1283
              free((void *)props->type_name);
#line 1284
              props->type_name = (char *)((void *)0);
#line 1285
              props->type = type;
              }
            }
            {
#line 1288
            free((void *)field_type);
#line 1244
            i ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 1291
          rec_fex_destroy(fex);
          }
        }
      }
      {
#line 1295
      tmp___14 = rec_std_field_name((enum rec_std_field_e )2);
#line 1295
      tmp___15 = rec_field_name_equal_p(field_name, tmp___14);
      }
#line 1295
      if (tmp___15) {
        {
#line 1300
        tmp___13 = rec_field_value(field);
#line 1300
        field_value___0 = tmp___13;
#line 1301
        type_name___0 = (char *)((void *)0);
#line 1303
        rec_skip_blanks(& field_value___0);
#line 1304
        rec_parse_regexp(& field_value___0, "^[a-zA-Z%][a-zA-Z0-9_]*", & type_name___0);
#line 1305
        props = rec_rset_get_props(rset, (char const   *)type_name___0, (_Bool)1);
#line 1306
        props->key_p = (_Bool)1;
#line 1307
        free((void *)type_name___0);
        }
      }
      {
#line 1311
      tmp___21 = rec_std_field_name((enum rec_std_field_e )0);
#line 1311
      tmp___22 = rec_field_name_equal_p(field_name, tmp___21);
      }
#line 1311
      if (tmp___22) {
        {
#line 1316
        tmp___16 = rec_field_value(field);
#line 1316
        tmp___17 = rec_fex_new(tmp___16, (enum rec_fex_kind_e )0);
#line 1316
        fex___0 = tmp___17;
        }
#line 1317
        if (fex___0) {
#line 1321
          i___0 = (size_t )0;
          {
#line 1321
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 1321
            tmp___20 = rec_fex_size(fex___0);
            }
#line 1321
            if (! (i___0 < tmp___20)) {
#line 1321
              goto while_break___2;
            }
            {
#line 1323
            tmp___18 = rec_fex_get(fex___0, i___0);
#line 1323
            tmp___19 = rec_fex_elem_field_name(tmp___18);
#line 1323
            auto_field_name = tmp___19;
#line 1325
            props = rec_rset_get_props(rset, auto_field_name, (_Bool)1);
#line 1326
            props->auto_p = (_Bool)1;
#line 1321
            i___0 ++;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
      {
#line 1332
      tmp___25 = rec_std_field_name((enum rec_std_field_e )7);
#line 1332
      tmp___26 = rec_field_name_equal_p(field_name, tmp___25);
      }
#line 1332
      if (tmp___26) {
        {
#line 1337
        tmp___23 = rec_field_value(field);
#line 1337
        field_value___1 = tmp___23;
#line 1339
        tmp___24 = rec_fex_new(field_value___1, (enum rec_fex_kind_e )0);
#line 1339
        fex___1 = tmp___24;
        }
#line 1340
        if (fex___1) {
          {
#line 1342
          rec_fex_destroy(rset->order_by_fields);
#line 1343
          rset->order_by_fields = fex___1;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1372
    rec_mset_iterator_free(& iter);
    }
  }
#line 1377
  props = rset->field_props;
  {
#line 1378
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1378
    if (! props) {
#line 1378
      goto while_break___3;
    }
#line 1383
    if (props->auto_p) {
#line 1383
      if (! props->type) {
#line 1383
        if (! props->type_name) {
          {
#line 1385
          props->type = rec_type_new("int");
          }
        }
      }
    }
#line 1388
    props = props->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1390
  return;
}
}
#line 1392 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static void rec_rset_update_types(rec_rset_t rset ) 
{ 
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  char const   *p ;
  char const   *q ;
  rec_type_t type ;
  char *type_name ;
  char *to_type ;
  rec_mset_t tmp ;
  char const   *field_name ;
  char const   *tmp___0 ;
  char const   *field_value ;
  char const   *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char const   *tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;

  {
#line 1397
  q = (char const   *)((void *)0);
#line 1399
  to_type = (char *)((void *)0);
#line 1404
  if (rset->descriptor) {
    {
#line 1408
    rec_type_reg_destroy(rset->type_reg);
#line 1409
    rset->type_reg = rec_type_reg_new();
#line 1413
    tmp = rec_record_mset(rset->descriptor);
#line 1413
    iter = rec_mset_iterator(tmp);
    }
    {
#line 1414
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1414
      tmp___6 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
      }
#line 1414
      if (! tmp___6) {
#line 1414
        goto while_break;
      }
      {
#line 1416
      tmp___0 = rec_field_name(field);
#line 1416
      field_name = tmp___0;
#line 1417
      tmp___1 = rec_field_value(field);
#line 1417
      field_value = tmp___1;
#line 1419
      tmp___4 = rec_std_field_name((enum rec_std_field_e )9);
#line 1419
      tmp___5 = rec_field_name_equal_p(field_name, tmp___4);
      }
#line 1419
      if (tmp___5) {
        {
#line 1421
        p = field_value;
#line 1422
        rec_skip_blanks(& p);
#line 1425
        tmp___3 = rec_parse_regexp(& p, "^[a-zA-Z][a-zA-Z0-9_-]*", & type_name);
        }
#line 1425
        if (tmp___3) {
          {
#line 1428
          type = rec_type_new(p);
          }
#line 1429
          if (type) {
            {
#line 1432
            rec_type_set_name(type, (char const   *)type_name);
#line 1436
            rec_type_reg_add(rset->type_reg, type);
            }
          } else {
            {
#line 1443
            rec_skip_blanks(& p);
#line 1444
            q = p;
#line 1445
            tmp___2 = rec_parse_regexp(& q, "^[a-zA-Z][a-zA-Z0-9_-]*[ \t\n]*", (char **)((void *)0));
            }
#line 1445
            if (tmp___2) {
              {
#line 1449
              rec_parse_regexp(& p, "^[a-zA-Z][a-zA-Z0-9_-]*", & to_type);
#line 1450
              rec_type_reg_add_synonym(rset->type_reg, (char const   *)type_name,
                                       (char const   *)to_type);
              }
            }
          }
          {
#line 1456
          free((void *)type_name);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1461
    rec_mset_iterator_free(& iter);
    }
  }
#line 1463
  return;
}
}
#line 1465 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static _Bool rec_rset_type_field_p(char const   *str ) 
{ 
  char const   *p ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1468
  p = str;
#line 1472
  rec_skip_blanks(& p);
#line 1473
  tmp = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?(,[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?)*",
                         (char **)((void *)0));
  }
#line 1473
  if (! tmp) {
#line 1477
    return ((_Bool)0);
  }
  {
#line 1479
  rec_skip_blanks(& p);
#line 1483
  tmp___0 = rec_type_descr_p(p);
  }
#line 1483
  if (tmp___0) {
#line 1483
    tmp___2 = 1;
  } else {
    {
#line 1483
    tmp___1 = rec_parse_regexp(& p, "^[a-zA-Z][a-zA-Z0-9_-]*[ \t\n]*$", (char **)((void *)0));
    }
#line 1483
    if (tmp___1) {
#line 1483
      tmp___2 = 1;
    } else {
#line 1483
      tmp___2 = 0;
    }
  }
#line 1483
  return ((_Bool )tmp___2);
}
}
#line 1487 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static rec_fex_t rec_rset_type_field_fex(char const   *str ) 
{ 
  rec_fex_t fex ;
  char const   *p ;
  char *name ;
  _Bool tmp ;

  {
  {
#line 1490
  fex = (rec_fex_t )((void *)0);
#line 1494
  p = str;
#line 1496
  tmp = rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?(,[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?)*",
                         & name);
  }
#line 1496
  if (tmp) {
    {
#line 1500
    fex = rec_fex_new((char const   *)name, (enum rec_fex_kind_e )1);
#line 1501
    free((void *)name);
    }
  }
#line 1504
  return (fex);
}
}
#line 1507 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static char *rec_rset_type_field_type(char const   *str ) 
{ 
  char *result ;
  char const   *p ;
  _Bool tmp ;

  {
  {
#line 1510
  result = (char *)((void *)0);
#line 1513
  tmp = rec_rset_type_field_p(str);
  }
#line 1513
  if (tmp) {
    {
#line 1515
    p = str;
#line 1517
    rec_skip_blanks(& p);
#line 1518
    rec_parse_regexp(& p, "^[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?(,[a-zA-Z%][a-zA-Z0-9_]*(\\.[a-zA-Z%][a-zA-Z0-9_]*)?)*",
                     (char **)((void *)0));
#line 1519
    rec_skip_blanks(& p);
#line 1522
    result = strdup(p);
    }
  }
#line 1525
  return (result);
}
}
#line 1528 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static rec_rset_fprops_t rec_rset_get_props(rec_rset_t rset , char const   *fname ,
                                            _Bool create_p ) 
{ 
  rec_rset_fprops_t props ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 1533
  props = (rec_rset_fprops_t )((void *)0);
#line 1535
  props = rset->field_props;
  {
#line 1536
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1536
    if (! props) {
#line 1536
      goto while_break;
    }
    {
#line 1538
    tmp = rec_field_name_equal_p(fname, (char const   *)props->fname);
    }
#line 1538
    if (tmp) {
#line 1540
      goto while_break;
    }
#line 1543
    props = props->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1546
  if (! props) {
#line 1546
    if (create_p) {
      {
#line 1550
      tmp___0 = malloc(sizeof(struct rec_rset_fprops_s ));
#line 1550
      props = (rec_rset_fprops_t )tmp___0;
      }
#line 1551
      if (props) {
        {
#line 1553
        props->fname = strdup(fname);
#line 1554
        props->auto_p = (_Bool)0;
#line 1555
        props->key_p = (_Bool)0;
#line 1561
        props->type = (rec_type_t )((void *)0);
#line 1562
        props->type_name = (char *)((void *)0);
#line 1565
        props->next = rset->field_props;
#line 1566
        rset->field_props = props;
        }
      }
    }
  }
#line 1570
  return (props);
}
}
#line 1573 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static _Bool rec_rset_add_auto_field_int(rec_rset_t rset , char const   *field_name ,
                                         rec_record_t record ) 
{ 
  rec_mset_iterator_t iter ;
  rec_record_t rec ;
  rec_field_t field ;
  size_t num_fields ;
  size_t i ;
  int auto_value ;
  int field_value ;
  char *end ;
  char *auto_value_str ;
  rec_mset_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  long tmp___2 ;
  int *tmp___3 ;
  _Bool tmp___4 ;
  rec_mset_t tmp___5 ;
  rec_mset_elem_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1588
  auto_value = 0;
#line 1590
  tmp = rec_rset_mset(rset);
#line 1590
  iter = rec_mset_iterator(tmp);
  }
  {
#line 1591
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1591
    tmp___4 = rec_mset_iterator_next(& iter, 1, (void const   **)(& rec), (rec_mset_elem_t *)((void *)0));
    }
#line 1591
    if (! tmp___4) {
#line 1591
      goto while_break;
    }
    {
#line 1593
    num_fields = rec_record_get_num_fields_by_name(rec, field_name);
#line 1594
    i = (size_t )0;
    }
    {
#line 1594
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1594
      if (! (i < num_fields)) {
#line 1594
        goto while_break___0;
      }
      {
#line 1596
      field = rec_record_get_field_by_name(rec, field_name, i);
#line 1600
      tmp___0 = __errno_location();
#line 1600
      *tmp___0 = 0;
#line 1601
      tmp___1 = rec_field_value(field);
#line 1601
      tmp___2 = strtol((char const   */* __restrict  */)tmp___1, (char **/* __restrict  */)(& end),
                       10);
#line 1601
      field_value = (int )tmp___2;
#line 1602
      tmp___3 = __errno_location();
      }
#line 1602
      if (*tmp___3 == 0) {
#line 1602
        if ((int )*end == 0) {
#line 1604
          if (auto_value <= field_value) {
#line 1606
            auto_value = field_value + 1;
          }
        }
      }
#line 1594
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1612
  rec_mset_iterator_free(& iter);
#line 1616
  tmp___7 = asprintf((char **/* __restrict  */)(& auto_value_str), (char const   */* __restrict  */)"%d",
                     auto_value);
  }
#line 1616
  if (tmp___7 != -1) {
    {
#line 1618
    field = rec_field_new(field_name, (char const   *)auto_value_str);
    }
#line 1619
    if (! field) {
      {
#line 1622
      free((void *)auto_value_str);
      }
#line 1623
      return ((_Bool)0);
    }
    {
#line 1626
    tmp___5 = rec_record_mset(record);
#line 1626
    tmp___6 = rec_mset_insert_at(tmp___5, 1, (void *)field, (size_t )0);
    }
#line 1626
    if (! tmp___6) {
      {
#line 1629
      free((void *)auto_value_str);
      }
#line 1630
      return ((_Bool)0);
    }
    {
#line 1633
    free((void *)auto_value_str);
    }
  }
#line 1636
  return ((_Bool)1);
}
}
#line 1639 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static _Bool rec_rset_add_auto_field_date(rec_rset_t rset , char const   *field_name ,
                                          rec_record_t record ) 
{ 
  rec_field_t auto_field ;
  time_t t ;
  char outstr[200] ;
  struct tm *tmp ;
  rec_mset_t tmp___0 ;
  rec_mset_elem_t tmp___1 ;

  {
  {
#line 1649
  t = time((time_t *)((void *)0));
#line 1650
  tmp = localtime((time_t const   *)(& t));
#line 1652
  setlocale(2, "C");
#line 1654
  strftime((char */* __restrict  */)(outstr), sizeof(outstr), (char const   */* __restrict  */)"%a, %d %b %Y %T %z",
           (struct tm  const  */* __restrict  */)tmp);
#line 1655
  setlocale(2, "");
#line 1658
  auto_field = rec_field_new(field_name, (char const   *)(outstr));
  }
#line 1659
  if (! auto_field) {
#line 1662
    return ((_Bool)0);
  }
  {
#line 1665
  tmp___0 = rec_record_mset(record);
#line 1665
  tmp___1 = rec_mset_insert_at(tmp___0, 1, (void *)auto_field, (size_t )0);
  }
#line 1665
  if (! tmp___1) {
#line 1668
    return ((_Bool)0);
  }
#line 1671
  return ((_Bool)1);
}
}
#line 1709 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static rec_record_t rec_rset_merge_records(rec_record_t to_record , rec_record_t from_record ,
                                           rec_fex_t group_by_fields ) 
{ 
  rec_mset_elem_t elem ;
  void *data ;
  rec_mset_iterator_t iter ;
  rec_mset_t tmp ;
  rec_field_t field ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;
  rec_field_t tmp___2 ;
  rec_mset_t tmp___3 ;
  rec_mset_elem_t tmp___4 ;
  rec_comment_t comment ;
  rec_comment_t tmp___5 ;
  rec_mset_t tmp___6 ;
  rec_mset_type_t tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 1718
  tmp = rec_record_mset(from_record);
#line 1718
  iter = rec_mset_iterator(tmp);
  }
  {
#line 1719
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1719
    tmp___8 = rec_mset_iterator_next(& iter, 0, (void const   **)(& data), & elem);
    }
#line 1719
    if (! tmp___8) {
#line 1719
      goto while_break;
    }
    {
#line 1721
    tmp___7 = rec_mset_elem_type(elem);
    }
#line 1721
    if (tmp___7 == 1) {
      {
#line 1723
      field = (rec_field_t )data;
#line 1728
      tmp___0 = rec_field_name(field);
#line 1728
      tmp___1 = rec_fex_member_p(group_by_fields, tmp___0, -1, -1);
      }
#line 1728
      if (tmp___1) {
#line 1730
        goto while_continue;
      }
      {
#line 1747
      tmp___2 = rec_field_dup(field);
#line 1747
      tmp___3 = rec_record_mset(to_record);
#line 1747
      tmp___4 = rec_mset_append(tmp___3, 1, (void *)tmp___2, 0);
      }
#line 1747
      if (! tmp___4) {
#line 1753
        return ((rec_record_t )((void *)0));
      }
    } else {
      {
#line 1758
      comment = (rec_comment_t )data;
#line 1759
      tmp___5 = rec_comment_dup(comment);
#line 1759
      tmp___6 = rec_record_mset(to_record);
#line 1759
      rec_mset_append(tmp___6, 2, (void *)tmp___5, 0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1765
  rec_mset_iterator_free(& iter);
  }
#line 1767
  return (to_record);
}
}
#line 1770 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-rset.c"
static int rec_rset_compare_typed_records(rec_rset_t rset , rec_record_t record1 ,
                                          rec_record_t record2 , rec_fex_t fields ) 
{ 
  int result ;
  size_t i ;
  size_t num_fields ;
  size_t tmp ;
  rec_fex_elem_t elem ;
  rec_fex_elem_t tmp___0 ;
  char const   *field_name ;
  char const   *tmp___1 ;
  rec_field_t field1 ;
  rec_field_t tmp___2 ;
  rec_field_t field2 ;
  rec_field_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  rec_type_t tmp___6 ;

  {
  {
#line 1776
  result = 0;
#line 1777
  i = (size_t )0;
#line 1778
  tmp = rec_fex_size(fields);
#line 1778
  num_fields = tmp;
#line 1780
  i = (size_t )0;
  }
  {
#line 1780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1780
    if (! (i < num_fields)) {
#line 1780
      goto while_break;
    }
    {
#line 1782
    tmp___0 = rec_fex_get(fields, i);
#line 1782
    elem = tmp___0;
#line 1783
    tmp___1 = rec_fex_elem_field_name(elem);
#line 1783
    field_name = tmp___1;
#line 1784
    tmp___2 = rec_record_get_field_by_name(record1, field_name, (size_t )0);
#line 1784
    field1 = tmp___2;
#line 1785
    tmp___3 = rec_record_get_field_by_name(record2, field_name, (size_t )0);
#line 1785
    field2 = tmp___3;
    }
#line 1791
    if (field1) {
#line 1791
      if (! field2) {
#line 1793
        result = 1;
#line 1794
        goto while_break;
      } else {
#line 1791
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1796
    if (! field1) {
#line 1796
      if (field2) {
#line 1798
        result = -1;
#line 1799
        goto while_break;
      } else {
#line 1796
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1801
    if (! field1) {
#line 1801
      if (! field2) {
#line 1803
        result = -1;
#line 1804
        goto while_break;
      }
    }
    {
#line 1810
    tmp___4 = rec_field_value(field2);
#line 1810
    tmp___5 = rec_field_value(field1);
#line 1810
    tmp___6 = rec_rset_get_field_type(rset, field_name);
#line 1810
    result = rec_type_values_cmp(tmp___6, tmp___5, tmp___4);
    }
#line 1814
    if (result != 0) {
#line 1819
      goto while_break;
    }
#line 1780
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1823
  return (result);
}
}
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcasestr)(char const   *__haystack ,
                                                                                           char const   *__needle )  __attribute__((__pure__)) ;
#line 287 "./rec.h"
_Bool rec_mset_elem_equal_p(rec_mset_elem_t elem1 , rec_mset_elem_t elem2 ) ;
#line 743
_Bool rec_field_equal_p(rec_field_t field1 , rec_field_t field2 ) ;
#line 827
void rec_field_set_mark(rec_field_t field , int mark ) ;
#line 828
int rec_field_mark(rec_field_t field ) ;
#line 885
_Bool rec_record_subset_p(rec_record_t record1 , rec_record_t record2 ) ;
#line 891
_Bool rec_record_equal_p(rec_record_t record1 , rec_record_t record2 ) ;
#line 911
size_t rec_record_num_comments(rec_record_t record ) ;
#line 986
_Bool rec_record_contains_field(rec_record_t record , char const   *field_name , char const   *field_value ) ;
#line 1040
void rec_record_append(rec_record_t dest_record , rec_record_t src_record ) ;
#line 65 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static void rec_record_init(rec_record_t record ) ;
#line 66
static void rec_record_field_disp_fn(void *data ) ;
#line 67
static _Bool rec_record_field_equal_fn(void *data1 , void *data2 ) ;
#line 68
static void *rec_record_field_dup_fn(void *data ) ;
#line 69
static void rec_record_comment_disp_fn(void *data ) ;
#line 70
static _Bool rec_record_comment_equal_fn(void *data1 , void *data2 ) ;
#line 71
static void *rec_record_comment_dup_fn(void *data ) ;
#line 77 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
rec_record_t rec_record_new(void) 
{ 
  rec_record_t record ;
  void *tmp ;

  {
  {
#line 82
  tmp = malloc(sizeof(struct rec_record_s ));
#line 82
  record = (rec_record_t )tmp;
  }
#line 84
  if (record) {
    {
#line 86
    rec_record_init(record);
#line 90
    record->container = (void *)0;
#line 95
    record->source = (char *)((void *)0);
#line 96
    record->location = (size_t )0;
#line 97
    record->location_str = (char *)((void *)0);
#line 98
    record->char_location = (size_t )0;
#line 99
    record->char_location_str = (char *)((void *)0);
#line 107
    record->mset = rec_mset_new();
    }
#line 108
    if (record->mset) {
      {
#line 110
      record->field_type = rec_mset_register_type(record->mset, (char *)"field", & rec_record_field_disp_fn,
                                                  & rec_record_field_equal_fn, & rec_record_field_dup_fn,
                                                  (int (*)(void *data1 , void *data2 ,
                                                           int type2 ))((void *)0));
#line 117
      record->comment_type = rec_mset_register_type(record->mset, (char *)"comment",
                                                    & rec_record_comment_disp_fn,
                                                    & rec_record_comment_equal_fn,
                                                    & rec_record_comment_dup_fn, (int (*)(void *data1 ,
                                                                                          void *data2 ,
                                                                                          int type2 ))((void *)0));
      }
    } else {
      {
#line 128
      rec_record_destroy(record);
#line 129
      record = (rec_record_t )((void *)0);
      }
    }
  }
#line 133
  return (record);
}
}
#line 136 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_destroy(rec_record_t record ) 
{ 


  {
#line 139
  if (record) {
    {
#line 141
    free((void *)record->source);
#line 142
    free((void *)record->location_str);
#line 143
    free((void *)record->char_location_str);
#line 144
    rec_mset_destroy(record->mset);
#line 145
    free((void *)record);
    }
  }
#line 147
  return;
}
}
#line 149 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
rec_record_t rec_record_dup(rec_record_t record ) 
{ 
  rec_record_t new ;
  void *tmp ;

  {
  {
#line 154
  tmp = malloc(sizeof(struct rec_record_s ));
#line 154
  new = (rec_record_t )tmp;
  }
#line 155
  if (new) {
    {
#line 157
    rec_record_init(new);
#line 159
    new->field_type = record->field_type;
#line 160
    new->comment_type = record->comment_type;
#line 161
    new->mset = rec_mset_dup(record->mset);
    }
#line 162
    if (! new->mset) {
      {
#line 164
      rec_record_destroy(new);
      }
#line 165
      return ((rec_record_t )((void *)0));
    }
#line 168
    new->source = (char *)((void *)0);
#line 169
    if (record->source) {
      {
#line 171
      new->source = strdup((char const   *)record->source);
      }
#line 172
      if (! new->source) {
        {
#line 174
        rec_record_destroy(new);
        }
#line 175
        return ((rec_record_t )((void *)0));
      }
    }
#line 179
    new->location = record->location;
#line 180
    new->char_location = record->char_location;
#line 182
    new->location_str = (char *)((void *)0);
#line 183
    if (record->location_str) {
      {
#line 185
      new->location_str = strdup((char const   *)record->location_str);
      }
#line 186
      if (! new->location_str) {
        {
#line 188
        rec_record_destroy(new);
        }
#line 189
        return ((rec_record_t )((void *)0));
      }
    }
#line 193
    new->char_location_str = (char *)((void *)0);
#line 194
    if (record->char_location_str) {
      {
#line 196
      new->char_location_str = strdup((char const   *)record->char_location_str);
      }
#line 197
      if (! new->char_location_str) {
        {
#line 199
        rec_record_destroy(new);
        }
#line 200
        return ((rec_record_t )((void *)0));
      }
    }
#line 204
    new->container = record->container;
  }
#line 207
  return (new);
}
}
#line 210 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
_Bool rec_record_subset_p(rec_record_t record1 , rec_record_t record2 ) 
{ 
  _Bool result ;
  rec_mset_iterator_t iter1 ;
  rec_mset_elem_t elem1 ;
  void const   *data ;
  _Bool elem_found ;
  rec_mset_elem_t elem2 ;
  rec_mset_iterator_t iter2 ;
  rec_mset_iterator_t tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 219
  result = (_Bool)1;
#line 224
  iter1 = rec_mset_iterator(record1->mset);
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    tmp___2 = rec_mset_iterator_next(& iter1, 0, & data, & elem1);
    }
#line 225
    if (! tmp___2) {
#line 225
      goto while_break;
    }
    {
#line 227
    elem_found = (_Bool)0;
#line 229
    tmp = rec_mset_iterator(record2->mset);
#line 229
    iter2 = tmp;
    }
    {
#line 231
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 231
      tmp___1 = rec_mset_iterator_next(& iter2, 0, & data, & elem2);
      }
#line 231
      if (! tmp___1) {
#line 231
        goto while_break___0;
      }
      {
#line 233
      tmp___0 = rec_mset_elem_equal_p(elem1, elem2);
      }
#line 233
      if (tmp___0) {
#line 235
        elem_found = (_Bool)1;
#line 236
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 240
    if (! elem_found) {
#line 242
      result = (_Bool)0;
#line 243
      goto while_break;
    }
    {
#line 246
    rec_mset_iterator_free(& iter2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  rec_mset_iterator_free(& iter1);
  }
#line 252
  return (result);
}
}
#line 255 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
_Bool rec_record_equal_p(rec_record_t record1 , rec_record_t record2 ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 259
  tmp = rec_record_subset_p(record1, record2);
  }
#line 259
  if (tmp) {
    {
#line 259
    tmp___0 = rec_record_subset_p(record2, record1);
    }
#line 259
    if (tmp___0) {
#line 259
      tmp___1 = 1;
    } else {
#line 259
      tmp___1 = 0;
    }
  } else {
#line 259
    tmp___1 = 0;
  }
#line 259
  return ((_Bool )tmp___1);
}
}
#line 263 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
rec_mset_t rec_record_mset(rec_record_t record ) 
{ 


  {
#line 266
  return (record->mset);
}
}
#line 269 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_num_elems(rec_record_t record ) 
{ 
  size_t tmp ;

  {
  {
#line 272
  tmp = rec_mset_count(record->mset, 0);
  }
#line 272
  return (tmp);
}
}
#line 275 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_num_fields(rec_record_t record ) 
{ 
  size_t tmp ;

  {
  {
#line 278
  tmp = rec_mset_count(record->mset, record->field_type);
  }
#line 278
  return (tmp);
}
}
#line 281 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_num_comments(rec_record_t record ) 
{ 
  size_t tmp ;

  {
  {
#line 284
  tmp = rec_mset_count(record->mset, record->comment_type);
  }
#line 284
  return (tmp);
}
}
#line 287 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_get_field_index(rec_record_t record , rec_field_t field ) 
{ 
  size_t res ;
  rec_mset_iterator_t iter ;
  rec_field_t list_field ;
  _Bool tmp ;

  {
  {
#line 291
  res = (size_t )0;
#line 295
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    tmp = rec_mset_iterator_next(& iter, 1, (void const   **)(& list_field), (rec_mset_elem_t *)((void *)0));
    }
#line 296
    if (! tmp) {
#line 296
      goto while_break;
    }
#line 298
    if ((unsigned long )field == (unsigned long )list_field) {
#line 300
      goto while_break;
    }
#line 303
    res ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  rec_mset_iterator_free(& iter);
  }
#line 308
  return (res);
}
}
#line 311 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
_Bool rec_record_field_p(rec_record_t record , char const   *field_name ) 
{ 
  size_t tmp ;

  {
  {
#line 315
  tmp = rec_record_get_num_fields_by_name(record, field_name);
  }
#line 315
  return ((_Bool )(tmp > 0UL));
}
}
#line 318 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_get_num_fields_by_name(rec_record_t record , char const   *field_name ) 
{ 
  rec_mset_iterator_t iter ;
  rec_field_t field ;
  int num_fields ;
  char const   *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 324
  num_fields = 0;
#line 326
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 327
    tmp___1 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 327
    if (! tmp___1) {
#line 327
      goto while_break;
    }
    {
#line 329
    tmp = rec_field_name(field);
#line 329
    tmp___0 = rec_field_name_equal_p(tmp, field_name);
    }
#line 329
    if (tmp___0) {
#line 331
      num_fields ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 334
  rec_mset_iterator_free(& iter);
  }
#line 336
  return ((size_t )num_fields);
}
}
#line 339 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
rec_field_t rec_record_get_field_by_name(rec_record_t record , char const   *field_name ,
                                         size_t n ) 
{ 
  size_t num_fields ;
  rec_field_t field ;
  rec_field_t result ;
  rec_mset_iterator_t iter ;
  char const   *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 344
  num_fields = (size_t )0;
#line 345
  field = (rec_field_t )((void *)0);
#line 346
  result = (rec_field_t )((void *)0);
#line 350
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 351
    tmp___1 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 351
    if (! tmp___1) {
#line 351
      goto while_break;
    }
    {
#line 353
    tmp = rec_field_name(field);
#line 353
    tmp___0 = rec_field_name_equal_p(tmp, field_name);
    }
#line 353
    if (tmp___0) {
#line 355
      if (n == num_fields) {
#line 357
        result = field;
#line 358
        goto while_break;
      }
#line 361
      num_fields ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  rec_mset_iterator_free(& iter);
  }
#line 366
  return (result);
}
}
#line 369 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_remove_field_by_name(rec_record_t record , char const   *field_name ,
                                     size_t n ) 
{ 
  rec_field_t field ;
  rec_mset_iterator_t iter ;
  rec_mset_elem_t elem ;
  int num_fields ;
  char const   *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 377
  num_fields = 0;
#line 379
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 380
    tmp___1 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), & elem);
    }
#line 380
    if (! tmp___1) {
#line 380
      goto while_break;
    }
    {
#line 382
    tmp = rec_field_name(field);
#line 382
    tmp___0 = rec_field_name_equal_p(tmp, field_name);
    }
#line 382
    if (tmp___0) {
#line 384
      if (n == 0xffffffffffffffffUL) {
        {
#line 386
        rec_mset_remove_elem(record->mset, elem);
        }
      } else
#line 384
      if (n == (size_t )num_fields) {
        {
#line 386
        rec_mset_remove_elem(record->mset, elem);
        }
      }
#line 389
      num_fields ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 392
  rec_mset_iterator_free(& iter);
  }
#line 393
  return;
}
}
#line 395 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_get_field_index_by_name(rec_record_t record , rec_field_t field ) 
{ 
  size_t res ;
  rec_mset_iterator_t iter ;
  rec_field_t list_field ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 399
  res = (size_t )0;
#line 403
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 404
    tmp___0 = rec_mset_iterator_next(& iter, 1, (void const   **)(& list_field), (rec_mset_elem_t *)((void *)0));
    }
#line 404
    if (! tmp___0) {
#line 404
      goto while_break;
    }
#line 406
    if ((unsigned long )field == (unsigned long )list_field) {
#line 408
      goto while_break;
    }
    {
#line 411
    tmp = rec_field_equal_p(field, list_field);
    }
#line 411
    if (tmp) {
#line 413
      res ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 417
  rec_mset_iterator_free(& iter);
  }
#line 419
  return (res);
}
}
#line 422 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
rec_comment_t rec_record_to_comment(rec_record_t record ) 
{ 
  rec_buf_t buf ;
  rec_comment_t res ;
  char *comment_str ;
  size_t comment_str_size ;
  rec_mset_iterator_t iter ;
  rec_mset_elem_t elem ;
  void const   *data ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  rec_mset_type_t tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 433
  buf = rec_buf_new(& comment_str, & comment_str_size);
#line 435
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 436
    tmp___3 = rec_mset_iterator_next(& iter, 0, & data, & elem);
    }
#line 436
    if (! tmp___3) {
#line 436
      goto while_break;
    }
    {
#line 438
    tmp___2 = rec_mset_elem_type(elem);
    }
#line 438
    if (tmp___2 == 1) {
      {
#line 440
      tmp = rec_write_field_str((rec_field_t )data, (rec_writer_mode_t )0);
#line 440
      rec_buf_puts((char const   *)tmp, buf);
#line 443
      rec_buf_putc('\n', buf);
      }
    } else {
      {
#line 448
      tmp___0 = rec_comment_text((rec_comment_t )data);
#line 448
      tmp___1 = rec_write_comment_str(tmp___0, (rec_writer_mode_t )0);
#line 448
      rec_buf_puts((char const   *)tmp___1, buf);
#line 451
      rec_buf_putc('\n', buf);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 455
  rec_mset_iterator_free(& iter);
#line 457
  rec_buf_close(buf);
  }
#line 460
  if ((int )*(comment_str + (comment_str_size - 1UL)) == 10) {
#line 462
    *(comment_str + (comment_str_size - 1UL)) = (char )'\000';
  }
  {
#line 465
  res = rec_comment_new(comment_str);
#line 466
  free((void *)comment_str);
  }
#line 468
  return (res);
}
}
#line 471 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
char *rec_record_source(rec_record_t record ) 
{ 
  char *res ;

  {
#line 476
  if (record->source) {
#line 478
    res = record->source;
  } else {
#line 482
    res = (char *)"";
  }
#line 485
  return (res);
}
}
#line 488 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_set_source(rec_record_t record , char *source ) 
{ 


  {
#line 492
  if (record->source) {
    {
#line 494
    free((void *)record->source);
#line 495
    record->source = (char *)((void *)0);
    }
  }
  {
#line 498
  record->source = strdup((char const   *)source);
  }
#line 499
  return;
}
}
#line 501 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_location(rec_record_t record ) 
{ 


  {
#line 504
  return (record->location);
}
}
#line 507 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
char *rec_record_location_str(rec_record_t record ) 
{ 
  char *res ;

  {
#line 512
  if (record->location_str) {
#line 514
    res = record->location_str;
  } else {
#line 518
    res = (char *)"";
  }
#line 521
  return (res);
}
}
#line 524 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_set_location(rec_record_t record , size_t location ) 
{ 


  {
#line 528
  record->location = location;
#line 530
  if (record->location_str) {
    {
#line 532
    free((void *)record->location_str);
#line 533
    record->location_str = (char *)((void *)0);
    }
  }
  {
#line 536
  asprintf((char **/* __restrict  */)(& record->location_str), (char const   */* __restrict  */)"%zu",
           record->location);
  }
#line 537
  return;
}
}
#line 539 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
size_t rec_record_char_location(rec_record_t record ) 
{ 


  {
#line 542
  return (record->char_location);
}
}
#line 545 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
char *rec_record_char_location_str(rec_record_t record ) 
{ 
  char *res ;

  {
#line 550
  if (record->char_location_str) {
#line 552
    res = record->char_location_str;
  } else {
#line 556
    res = (char *)"";
  }
#line 559
  return (res);
}
}
#line 562 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_set_char_location(rec_record_t record , size_t location ) 
{ 


  {
#line 566
  record->char_location = location;
#line 568
  if (record->char_location_str) {
    {
#line 570
    free((void *)record->char_location_str);
#line 571
    record->char_location_str = (char *)((void *)0);
    }
  }
  {
#line 574
  asprintf((char **/* __restrict  */)(& record->char_location_str), (char const   */* __restrict  */)"%zu",
           record->char_location);
  }
#line 575
  return;
}
}
#line 577 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
_Bool rec_record_contains_value(rec_record_t record , char const   *str , _Bool case_insensitive ) 
{ 
  _Bool res ;
  rec_mset_iterator_t iter ;
  rec_field_t field ;
  char const   *field_value ;
  char *occur ;
  _Bool tmp ;

  {
  {
#line 582
  res = (_Bool)0;
#line 588
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 589
    tmp = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 589
    if (! tmp) {
#line 589
      goto while_break;
    }
    {
#line 591
    field_value = rec_field_value(field);
    }
#line 593
    if (case_insensitive) {
      {
#line 595
      occur = strcasestr(field_value, str);
      }
    } else {
      {
#line 599
      occur = strstr(field_value, str);
      }
    }
#line 602
    res = (_Bool )((unsigned long )occur != (unsigned long )((void *)0));
#line 603
    if (res) {
#line 605
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 609
  rec_mset_iterator_free(& iter);
  }
#line 611
  return (res);
}
}
#line 614 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
_Bool rec_record_contains_field(rec_record_t record , char const   *field_name , char const   *field_value ) 
{ 
  _Bool res ;
  rec_mset_iterator_t iter ;
  rec_field_t field ;
  char const   *tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 619
  res = (_Bool)0;
#line 623
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 624
    tmp___3 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 624
    if (! tmp___3) {
#line 624
      goto while_break;
    }
    {
#line 626
    tmp = rec_field_name(field);
#line 626
    tmp___0 = rec_field_name_equal_p(field_name, tmp);
    }
#line 626
    if (tmp___0) {
      {
#line 626
      tmp___1 = rec_field_value(field);
#line 626
      tmp___2 = strcmp(field_value, tmp___1);
      }
#line 626
      if (tmp___2 == 0) {
#line 630
        res = (_Bool)1;
#line 631
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  rec_mset_iterator_free(& iter);
  }
#line 636
  return (res);
}
}
#line 639 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void *rec_record_container(rec_record_t record ) 
{ 


  {
#line 642
  return (record->container);
}
}
#line 645 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_set_container(rec_record_t record , void *container ) 
{ 


  {
#line 648
  record->container = container;
#line 649
  return;
}
}
#line 651 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_uniq(rec_record_t record ) 
{ 
  rec_mset_iterator_t iter1 ;
  rec_mset_iterator_t iter2 ;
  rec_mset_elem_t elem1 ;
  rec_field_t field1 ;
  rec_field_t field2 ;
  _Bool *to_remove ;
  size_t num_fields ;
  size_t i ;
  size_t j ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 663
  num_fields = rec_record_num_fields(record);
#line 664
  tmp = malloc(sizeof(_Bool ) * num_fields);
#line 664
  to_remove = (_Bool *)tmp;
#line 665
  memset((void *)to_remove, 0, num_fields);
#line 670
  i = (size_t )0;
#line 671
  iter1 = rec_mset_iterator(record->mset);
  }
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 672
    tmp___7 = rec_mset_iterator_next(& iter1, 1, (void const   **)(& field1), (rec_mset_elem_t *)((void *)0));
    }
#line 672
    if (! tmp___7) {
#line 672
      goto while_break;
    }
#line 674
    if (! *(to_remove + i)) {
      {
#line 679
      j = (size_t )0;
#line 680
      iter2 = rec_mset_iterator(record->mset);
      }
      {
#line 681
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 681
        tmp___6 = rec_mset_iterator_next(& iter2, 1, (void const   **)(& field2),
                                         (rec_mset_elem_t *)((void *)0));
        }
#line 681
        if (! tmp___6) {
#line 681
          goto while_break___0;
        }
#line 683
        if (j != i) {
          {
#line 683
          tmp___0 = rec_field_name(field2);
#line 683
          tmp___1 = rec_field_name(field1);
#line 683
          tmp___2 = rec_field_name_equal_p(tmp___1, tmp___0);
          }
#line 683
          if (tmp___2) {
            {
#line 683
            tmp___3 = rec_field_value(field2);
#line 683
            tmp___4 = rec_field_value(field1);
#line 683
            tmp___5 = rec_field_name_equal_p(tmp___4, tmp___3);
            }
#line 683
            if (tmp___5) {
#line 687
              *(to_remove + j) = (_Bool)1;
            }
          }
        }
#line 690
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 692
      rec_mset_iterator_free(& iter2);
      }
    }
#line 695
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 697
  rec_mset_iterator_free(& iter1);
#line 702
  i = (size_t )0;
#line 703
  iter1 = rec_mset_iterator(record->mset);
  }
  {
#line 704
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 704
    tmp___8 = rec_mset_iterator_next(& iter1, 1, (void const   **)(& field1), & elem1);
    }
#line 704
    if (! tmp___8) {
#line 704
      goto while_break___1;
    }
#line 706
    if (*(to_remove + i)) {
      {
#line 708
      rec_mset_remove_elem(record->mset, elem1);
      }
    }
#line 711
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 716
  free((void *)to_remove);
  }
#line 717
  return;
}
}
#line 719 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_append(rec_record_t dest_record , rec_record_t src_record ) 
{ 
  rec_mset_iterator_t iter ;
  rec_field_t field ;
  rec_field_t tmp ;
  rec_mset_t tmp___0 ;
  rec_mset_elem_t tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 726
  iter = rec_mset_iterator(src_record->mset);
  }
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 727
    tmp___2 = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 727
    if (! tmp___2) {
#line 727
      goto while_break;
    }
    {
#line 729
    tmp = rec_field_dup(field);
#line 729
    tmp___0 = rec_record_mset(dest_record);
#line 729
    tmp___1 = rec_mset_append(tmp___0, 1, (void *)tmp, 1);
    }
#line 729
    if (! tmp___1) {
#line 735
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 738
  rec_mset_iterator_free(& iter);
  }
#line 739
  return;
}
}
#line 741 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
void rec_record_reset_marks(rec_record_t record ) 
{ 
  rec_mset_iterator_t iter ;
  rec_field_t field ;
  _Bool tmp ;

  {
  {
#line 747
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 748
    tmp = rec_mset_iterator_next(& iter, 1, (void const   **)(& field), (rec_mset_elem_t *)((void *)0));
    }
#line 748
    if (! tmp) {
#line 748
      goto while_break;
    }
    {
#line 750
    rec_field_set_mark(field, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 752
  rec_mset_iterator_free(& iter);
  }
#line 753
  return;
}
}
#line 755 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
_Bool rec_record_mark_field(rec_record_t record , rec_field_t field , int mark ) 
{ 
  rec_mset_iterator_t iter ;
  rec_field_t iter_field ;
  _Bool tmp ;

  {
  {
#line 763
  iter = rec_mset_iterator(record->mset);
  }
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 764
    tmp = rec_mset_iterator_next(& iter, 1, (void const   **)(& iter_field), (rec_mset_elem_t *)((void *)0));
    }
#line 764
    if (! tmp) {
#line 764
      goto while_break;
    }
#line 766
    if ((unsigned long )field == (unsigned long )iter_field) {
      {
#line 768
      rec_field_set_mark(field, mark);
#line 769
      rec_mset_iterator_free(& iter);
      }
#line 770
      return ((_Bool)1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 773
  rec_mset_iterator_free(& iter);
  }
#line 775
  return ((_Bool)0);
}
}
#line 778 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
int rec_record_field_mark(rec_record_t record , rec_field_t field ) 
{ 
  int tmp ;

  {
  {
#line 782
  tmp = rec_field_mark(field);
  }
#line 782
  return (tmp);
}
}
#line 789 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static void rec_record_init(rec_record_t record ) 
{ 


  {
  {
#line 796
  memset((void *)record, 0, sizeof(struct rec_record_s ));
  }
#line 797
  return;
}
}
#line 799 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static void rec_record_field_disp_fn(void *data ) 
{ 


  {
  {
#line 802
  rec_field_destroy((rec_field_t )data);
  }
#line 803
  return;
}
}
#line 805 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static _Bool rec_record_field_equal_fn(void *data1 , void *data2 ) 
{ 


  {
#line 809
  return ((_Bool )((unsigned long )data1 == (unsigned long )data2));
}
}
#line 814 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static void *rec_record_field_dup_fn(void *data ) 
{ 
  rec_field_t copy ;

  {
  {
#line 819
  copy = rec_field_dup((rec_field_t )data);
  }
#line 820
  return ((void *)copy);
}
}
#line 823 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static void rec_record_comment_disp_fn(void *data ) 
{ 


  {
  {
#line 826
  rec_comment_destroy((rec_comment_t )data);
  }
#line 827
  return;
}
}
#line 829 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static _Bool rec_record_comment_equal_fn(void *data1 , void *data2 ) 
{ 


  {
#line 833
  return ((_Bool )((unsigned long )data1 == (unsigned long )data2));
}
}
#line 838 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-record.c"
static void *rec_record_comment_dup_fn(void *data ) 
{ 
  rec_comment_t copy ;

  {
  {
#line 843
  copy = rec_comment_dup((rec_comment_t )data);
  }
#line 844
  return ((void *)copy);
}
}
#line 789 "./rec.h"
size_t rec_field_location(rec_field_t field ) ;
#line 809
size_t rec_field_char_location(rec_field_t field ) ;
#line 63 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
static void rec_field_init(rec_field_t field ) ;
#line 69 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
char const   *rec_field_name(rec_field_t field ) 
{ 


  {
#line 72
  return ((char const   *)field->name);
}
}
#line 75 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
_Bool rec_field_set_name(rec_field_t field , char const   *name ) 
{ 


  {
  {
#line 78
  free((void *)field->name);
#line 79
  field->name = strdup(name);
  }
#line 80
  return ((_Bool )((unsigned long )field->name != (unsigned long )((void *)0)));
}
}
#line 83 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
char const   *rec_field_value(rec_field_t field ) 
{ 


  {
#line 86
  return ((char const   *)field->value);
}
}
#line 89 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
_Bool rec_field_set_value(rec_field_t field , char const   *value___0 ) 
{ 


  {
  {
#line 93
  free((void *)field->value);
#line 94
  field->value = strdup(value___0);
  }
#line 95
  return ((_Bool )((unsigned long )field->value != (unsigned long )((void *)0)));
}
}
#line 98 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
rec_field_t rec_field_new(char const   *name , char const   *value___0 ) 
{ 
  rec_field_t field ;
  void *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 104
  tmp = malloc(sizeof(struct rec_field_s ));
#line 104
  field = (rec_field_t )tmp;
  }
#line 106
  if ((unsigned long )field != (unsigned long )((void *)0)) {
    {
#line 108
    rec_field_init(field);
#line 110
    tmp___0 = rec_field_set_name(field, name);
    }
#line 110
    if (! tmp___0) {
      {
#line 113
      rec_field_destroy(field);
      }
#line 114
      return ((rec_field_t )((void *)0));
    }
    {
#line 117
    tmp___1 = rec_field_set_value(field, value___0);
    }
#line 117
    if (! tmp___1) {
      {
#line 120
      rec_field_destroy(field);
      }
#line 121
      return ((rec_field_t )((void *)0));
    }
  }
#line 125
  return (field);
}
}
#line 128 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
rec_field_t rec_field_dup(rec_field_t field ) 
{ 
  rec_field_t new_field ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 133
  tmp = rec_field_value(field);
#line 133
  tmp___0 = rec_field_name(field);
#line 133
  new_field = rec_field_new(tmp___0, tmp);
  }
#line 135
  if (new_field) {
#line 137
    new_field->location = field->location;
#line 138
    new_field->char_location = field->char_location;
#line 139
    new_field->mark = field->mark;
#line 141
    if (field->source) {
      {
#line 143
      new_field->source = strdup((char const   *)field->source);
      }
#line 144
      if (! new_field->source) {
        {
#line 147
        rec_field_destroy(new_field);
        }
#line 148
        return ((rec_field_t )((void *)0));
      }
    }
#line 152
    if (field->location_str) {
      {
#line 154
      new_field->location_str = strdup((char const   *)field->location_str);
      }
#line 155
      if (! new_field->location_str) {
        {
#line 158
        rec_field_destroy(new_field);
        }
#line 159
        return ((rec_field_t )((void *)0));
      }
    }
#line 163
    if (field->char_location_str) {
      {
#line 165
      new_field->char_location_str = strdup((char const   *)field->char_location_str);
      }
#line 166
      if (! new_field->char_location_str) {
        {
#line 169
        rec_field_destroy(new_field);
        }
#line 170
        return ((rec_field_t )((void *)0));
      }
    }
  }
#line 175
  return (new_field);
}
}
#line 178 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
_Bool rec_field_equal_p(rec_field_t field1 , rec_field_t field2 ) 
{ 
  int tmp ;

  {
  {
#line 182
  tmp = strcmp((char const   *)field1->name, (char const   *)field2->name);
  }
#line 182
  return ((_Bool )(tmp == 0));
}
}
#line 185 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
void rec_field_destroy(rec_field_t field ) 
{ 


  {
#line 188
  if (field) {
    {
#line 190
    free((void *)field->name);
#line 191
    free((void *)field->value);
#line 192
    free((void *)field->source);
#line 193
    free((void *)field->location_str);
#line 194
    free((void *)field->char_location_str);
#line 195
    free((void *)field);
    }
  }
#line 197
  return;
}
}
#line 199 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
rec_comment_t rec_field_to_comment(rec_field_t field ) 
{ 
  rec_comment_t res ;
  char *comment_str ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 205
  comment_str = rec_write_field_str(field, (rec_writer_mode_t )0);
  }
#line 207
  if (! comment_str) {
#line 209
    return ((rec_comment_t )((void *)0));
  }
  {
#line 215
  tmp___0 = strlen((char const   *)comment_str);
  }
#line 215
  if ((int )*(comment_str + (tmp___0 - 1UL)) == 10) {
    {
#line 217
    tmp = strlen((char const   *)comment_str);
#line 217
    *(comment_str + (tmp - 1UL)) = (char )'\000';
    }
  }
  {
#line 220
  res = rec_comment_new(comment_str);
#line 221
  free((void *)comment_str);
  }
#line 223
  return (res);
}
}
#line 226 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
char const   *rec_field_source(rec_field_t field ) 
{ 


  {
#line 229
  return ((char const   *)field->source);
}
}
#line 232 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
_Bool rec_field_set_source(rec_field_t field , char const   *source ) 
{ 


  {
  {
#line 236
  free((void *)field->source);
#line 237
  field->source = strdup(source);
  }
#line 238
  return ((_Bool )((unsigned long )field->source != (unsigned long )((void *)0)));
}
}
#line 241 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
size_t rec_field_location(rec_field_t field ) 
{ 


  {
#line 244
  return (field->location);
}
}
#line 247 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
_Bool rec_field_set_location(rec_field_t field , size_t location ) 
{ 
  int tmp ;

  {
  {
#line 251
  field->location = location;
#line 252
  free((void *)field->location_str);
#line 253
  tmp = asprintf((char **/* __restrict  */)(& field->location_str), (char const   */* __restrict  */)"%zu",
                 field->location);
  }
#line 253
  return ((_Bool )(tmp != -1));
}
}
#line 257 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
char const   *rec_field_location_str(rec_field_t field ) 
{ 
  char *res ;

  {
#line 262
  if (field->location_str) {
#line 264
    res = field->location_str;
  } else {
#line 268
    res = (char *)"";
  }
#line 271
  return ((char const   *)res);
}
}
#line 274 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
size_t rec_field_char_location(rec_field_t field ) 
{ 


  {
#line 277
  return (field->char_location);
}
}
#line 280 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
_Bool rec_field_set_char_location(rec_field_t field , size_t location ) 
{ 
  int tmp ;

  {
  {
#line 284
  field->char_location = location;
#line 285
  free((void *)field->char_location_str);
#line 286
  tmp = asprintf((char **/* __restrict  */)(& field->char_location_str), (char const   */* __restrict  */)"%zu",
                 field->char_location);
  }
#line 286
  return ((_Bool )(tmp != -1));
}
}
#line 290 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
char const   *rec_field_char_location_str(rec_field_t field ) 
{ 
  char *res ;

  {
#line 295
  if (field->char_location_str) {
#line 297
    res = field->char_location_str;
  } else {
#line 301
    res = (char *)"";
  }
#line 304
  return ((char const   *)res);
}
}
#line 307 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
void rec_field_set_mark(rec_field_t field , int mark ) 
{ 


  {
#line 310
  field->mark = mark;
#line 311
  return;
}
}
#line 313 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
int rec_field_mark(rec_field_t field ) 
{ 


  {
#line 316
  return (field->mark);
}
}
#line 323 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field.c"
static void rec_field_init(rec_field_t field ) 
{ 


  {
  {
#line 330
  memset((void *)field, 0, sizeof(struct rec_field_s ));
  }
#line 331
  return;
}
}
#line 421 "./rec.h"
_Bool rec_field_name_p(char const   *str ) ;
#line 427
char *rec_field_name_normalise(char const   *str ) ;
#line 46 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field-name.c"
static char const   *fnames[13]  = 
#line 46 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field-name.c"
  {      "%auto",      "%confidential",      "%key",      "%mandatory", 
        "%prohibit",      "%rec",      "%size",      "%sort", 
        "%type",      "%typedef",      "%unique",      "%constraint", 
        "%allowed"};
#line 63 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field-name.c"
char const   *rec_std_field_name(enum rec_std_field_e std_field ) 
{ 


  {
#line 66
  return (*(fnames + (unsigned int )std_field));
}
}
#line 69 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field-name.c"
_Bool rec_field_name_p(char const   *str ) 
{ 
  _Bool tmp ;

  {
  {
#line 72
  tmp = rec_match(str, "^[a-zA-Z%][a-zA-Z0-9_]*$");
  }
#line 72
  return (tmp);
}
}
#line 75 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field-name.c"
char *rec_field_name_normalise(char const   *str ) 
{ 
  char *normalised_name ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 81
  tmp = strlen(str);
#line 81
  tmp___0 = malloc(tmp + 1UL);
#line 81
  normalised_name = (char *)tmp___0;
  }
#line 82
  if (normalised_name) {
    {
#line 84
    tmp___1 = strlen(str);
#line 84
    memcpy((void */* __restrict  */)normalised_name, (void const   */* __restrict  */)str,
           tmp___1);
#line 85
    tmp___2 = strlen(str);
#line 85
    *(normalised_name + tmp___2) = (char )'\000';
#line 87
    i = 0;
    }
    {
#line 87
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 87
      tmp___4 = strlen((char const   *)normalised_name);
      }
#line 87
      if (! ((size_t )i < tmp___4)) {
#line 87
        goto while_break;
      }
      {
#line 89
      tmp___3 = __ctype_b_loc();
      }
#line 89
      if (! ((int const   )*(*tmp___3 + (int )*(normalised_name + i)) & 8)) {
#line 89
        if (! ((int )*(normalised_name + i) == 95)) {
#line 89
          if (! ((int )*(normalised_name + i) == 45)) {
#line 89
            if (! ((int )*(normalised_name + i) == 37)) {
#line 94
              *(normalised_name + i) = (char )'_';
            }
          }
        }
      }
#line 87
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 101
  if (normalised_name) {
    {
#line 103
    tmp___5 = rec_field_name_p((char const   *)normalised_name);
    }
#line 103
    if (! tmp___5) {
      {
#line 105
      free((void *)normalised_name);
#line 106
      normalised_name = (char *)((void *)0);
      }
    }
  }
#line 110
  return (normalised_name);
}
}
#line 113 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-field-name.c"
_Bool rec_field_name_equal_p(char const   *name1 , char const   *name2 ) 
{ 
  int tmp ;

  {
  {
#line 118
  tmp = strcmp(name1, name2);
  }
#line 118
  return ((_Bool )(tmp == 0));
}
}
#line 365 "./rec.h"
void rec_comment_set_text(rec_comment_t *comment , char *text ) ;
#line 370
_Bool rec_comment_equal_p(rec_comment_t comment1 , rec_comment_t comment2 ) ;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-comment.c"
rec_comment_t rec_comment_new(char *text ) 
{ 
  char *tmp ;

  {
#line 41
  if (! text) {
#line 42
    return ((rec_comment_t )((void *)0));
  }
  {
#line 44
  tmp = strdup((char const   *)text);
  }
#line 44
  return (tmp);
}
}
#line 47 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-comment.c"
void rec_comment_destroy(rec_comment_t comment ) 
{ 


  {
  {
#line 50
  free((void *)comment);
  }
#line 51
  return;
}
}
#line 53 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-comment.c"
rec_comment_t rec_comment_dup(rec_comment_t comment ) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = strdup((char const   *)comment);
  }
#line 56
  return (tmp);
}
}
#line 59 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-comment.c"
char *rec_comment_text(rec_comment_t comment ) 
{ 


  {
#line 62
  return (comment);
}
}
#line 65 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-comment.c"
void rec_comment_set_text(rec_comment_t *comment , char *text ) 
{ 


  {
  {
#line 69
  free((void *)*comment);
#line 70
  *comment = strdup((char const   *)text);
  }
#line 71
  return;
}
}
#line 73 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-comment.c"
_Bool rec_comment_equal_p(rec_comment_t comment1 , rec_comment_t comment2 ) 
{ 
  int tmp ;

  {
  {
#line 77
  tmp = strcmp((char const   *)comment1, (char const   *)comment2);
  }
#line 77
  return ((_Bool )(tmp == 0));
}
}
#line 88 "./rec-utils.h"
uint32_t rec_endian_swap(uint32_t number ) ;
#line 38 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_atoi(char const   *str , int *number ) 
{ 
  _Bool res ;
  long li ;
  char *end ;
  int base ;

  {
  {
#line 45
  base = 0;
#line 47
  res = (_Bool)0;
#line 49
  li = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& end),
              base);
  }
#line 50
  if ((int const   )*str != 0) {
#line 50
    if ((int )*end == 0) {
#line 53
      res = (_Bool)1;
#line 54
      *number = (int )li;
    }
  }
#line 57
  return (res);
}
}
#line 60 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_atod(char const   *str , double *number ) 
{ 
  _Bool res ;
  char *end ;

  {
  {
#line 67
  res = (_Bool)0;
#line 69
  setlocale(1, "C");
#line 71
  *number = strtod((char const   */* __restrict  */)str, (char **/* __restrict  */)(& end));
#line 72
  setlocale(1, "");
  }
#line 75
  if ((int const   )*str != 0) {
#line 75
    if ((int )*end == 0) {
#line 78
      res = (_Bool)1;
    }
  }
#line 81
  return (res);
}
}
#line 84 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
char *rec_extract_file(char const   *str ) 
{ 
  regex_t regexp ;
  regmatch_t matches ;
  char *rec_file ;
  size_t rec_file_length ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 89
  rec_file = (char *)((void *)0);
#line 90
  rec_file_length = (size_t )0;
#line 92
  tmp___0 = rpl_regcomp((regex_t */* __restrict  */)(& regexp), (char const   */* __restrict  */)"[ \n\t](/?[^/ \t\n]+)+",
                        1);
  }
#line 92
  if (tmp___0 != 0) {
    {
#line 94
    tmp = dcgettext("recutils", "internal error: rec_int_rec_extract_file: error compiling regexp.\n",
                    5);
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 95
    return ((char *)((void *)0));
  }
  {
#line 98
  tmp___2 = rpl_regexec((regex_t const   */* __restrict  */)(& regexp), (char const   */* __restrict  */)str,
                        (size_t )1, (regmatch_t */* __restrict  */)(& matches), 0);
  }
#line 98
  if (tmp___2 == 0) {
#line 98
    if (matches.rm_so != -1L) {
      {
#line 102
      rec_file_length = (size_t )(matches.rm_eo - matches.rm_so);
#line 103
      tmp___1 = malloc(rec_file_length + 1UL);
#line 103
      rec_file = (char *)tmp___1;
#line 104
      memcpy((void */* __restrict  */)rec_file, (void const   */* __restrict  */)((str + matches.rm_so) + 1),
             rec_file_length - 1UL);
#line 105
      *(rec_file + (rec_file_length - 1UL)) = (char )'\000';
      }
    }
  }
  {
#line 108
  rpl_regfree(& regexp);
  }
#line 109
  return (rec_file);
}
}
#line 112 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
char *rec_extract_url(char const   *str ) 
{ 
  regex_t regexp ;
  regmatch_t matches ;
  char *rec_url ;
  size_t rec_url_length ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 117
  rec_url = (char *)((void *)0);
#line 118
  rec_url_length = (size_t )0;
#line 120
  tmp___0 = rpl_regcomp((regex_t */* __restrict  */)(& regexp), (char const   */* __restrict  */)"(file|http|ftp|https)://[^ \t]+",
                        1);
  }
#line 120
  if (tmp___0 != 0) {
    {
#line 122
    tmp = dcgettext("recutils", "internal error: rec_int_rec_extract_url: error compiling regexp.\n",
                    5);
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 123
    return ((char *)((void *)0));
  }
  {
#line 126
  tmp___2 = rpl_regexec((regex_t const   */* __restrict  */)(& regexp), (char const   */* __restrict  */)str,
                        (size_t )1, (regmatch_t */* __restrict  */)(& matches), 0);
  }
#line 126
  if (tmp___2 == 0) {
#line 126
    if (matches.rm_so != -1L) {
      {
#line 130
      rec_url_length = (size_t )(matches.rm_eo - matches.rm_so);
#line 131
      tmp___1 = malloc(rec_url_length + 1UL);
#line 131
      rec_url = (char *)tmp___1;
#line 132
      memcpy((void */* __restrict  */)rec_url, (void const   */* __restrict  */)(str + matches.rm_so),
             rec_url_length);
#line 133
      *(rec_url + rec_url_length) = (char )'\000';
      }
    }
  }
  {
#line 136
  rpl_regfree(& regexp);
  }
#line 137
  return (rec_url);
}
}
#line 140 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
char *rec_extract_type(char const   *str ) 
{ 
  regex_t regexp ;
  regmatch_t matches ;
  char *rec_type ;
  size_t rec_type_length ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 145
  rec_type = (char *)((void *)0);
#line 146
  rec_type_length = (size_t )0;
#line 149
  tmp___0 = rpl_regcomp((regex_t */* __restrict  */)(& regexp), (char const   */* __restrict  */)"[a-zA-Z%][a-zA-Z0-9_]*",
                        1);
  }
#line 149
  if (tmp___0 != 0) {
    {
#line 151
    tmp = dcgettext("recutils", "internal error: rec_int_rec_extract_url: error compiling regexp.\n",
                    5);
#line 151
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 152
    return ((char *)((void *)0));
  }
  {
#line 155
  tmp___2 = rpl_regexec((regex_t const   */* __restrict  */)(& regexp), (char const   */* __restrict  */)str,
                        (size_t )1, (regmatch_t */* __restrict  */)(& matches), 0);
  }
#line 155
  if (tmp___2 == 0) {
#line 155
    if (matches.rm_so != -1L) {
      {
#line 159
      rec_type_length = (size_t )(matches.rm_eo - matches.rm_so);
#line 160
      tmp___1 = malloc(rec_type_length + 1UL);
#line 160
      rec_type = (char *)tmp___1;
#line 161
      memcpy((void */* __restrict  */)rec_type, (void const   */* __restrict  */)(str + matches.rm_so),
             rec_type_length);
#line 162
      *(rec_type + rec_type_length) = (char )'\000';
      }
    }
  }
  {
#line 165
  rpl_regfree(& regexp);
  }
#line 166
  return (rec_type);
}
}
#line 169 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_parse_int(char const   **str , int *num ) 
{ 
  _Bool ret ;
  char const   *p ;
  char const   *b ;
  char number[30] ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 176
  ret = (_Bool)1;
#line 177
  p = *str;
#line 179
  b = p;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    tmp = rec_digit_p((char )*p);
    }
#line 180
    if (! tmp) {
#line 180
      if ((unsigned long )p == (unsigned long )b) {
#line 180
        if (! ((int const   )*p == 45)) {
#line 180
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 180
      if ((int const   )*p >= 97) {
#line 180
        if (! ((int const   )*p <= 102)) {
#line 180
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 180
      if ((int const   )*p >= 65) {
#line 180
        if (! ((int const   )*p <= 70)) {
#line 180
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 180
      if (! ((int const   )*p == 120)) {
#line 180
        if (! ((int const   )*p == 88)) {
#line 180
          goto while_break;
        }
      }
    }
#line 187
    number[p - b] = (char )*p;
#line 188
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  number[p - b] = (char )'\000';
#line 192
  tmp___0 = rec_atoi((char const   *)(number), num);
  }
#line 192
  if (! tmp___0) {
#line 194
    ret = (_Bool)0;
  }
#line 197
  if (ret) {
#line 199
    *str = p;
  }
#line 202
  return (ret);
}
}
#line 205 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_parse_regexp(char const   **str , char const   *re , char **result ) 
{ 
  _Bool ret ;
  char const   *p ;
  regex_t regexp ;
  regmatch_t pm ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 213
  ret = (_Bool)1;
#line 214
  p = *str;
#line 217
  tmp = rpl_regcomp((regex_t */* __restrict  */)(& regexp), (char const   */* __restrict  */)re,
                    1);
  }
#line 217
  if (tmp != 0) {
#line 219
    ret = (_Bool)0;
  }
#line 222
  if (ret) {
    {
#line 225
    tmp___1 = rpl_regexec((regex_t const   */* __restrict  */)(& regexp), (char const   */* __restrict  */)p,
                          (size_t )1, (regmatch_t */* __restrict  */)(& pm), 0);
    }
#line 225
    if (tmp___1 == 0) {
#line 227
      if (result) {
        {
#line 232
        tmp___0 = malloc((size_t )(pm.rm_eo + 1L));
#line 232
        *result = (char *)tmp___0;
#line 233
        memcpy((void */* __restrict  */)*result, (void const   */* __restrict  */)p,
               (size_t )pm.rm_eo);
#line 234
        *(*result + pm.rm_eo) = (char )'\000';
        }
      }
#line 238
      p += pm.rm_eo;
    } else {
#line 242
      ret = (_Bool)0;
#line 243
      if (result) {
#line 245
        *result = (char *)((void *)0);
      }
    }
    {
#line 249
    rpl_regfree(& regexp);
    }
  }
#line 252
  if (ret) {
#line 254
    *str = p;
  }
#line 257
  return (ret);
}
}
#line 260 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
void rec_skip_blanks(char const   **str ) 
{ 
  char const   *p ;
  _Bool tmp ;

  {
#line 265
  p = *str;
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 266
    tmp = rec_blank_p((char )*p);
    }
#line 266
    if (! tmp) {
#line 266
      goto while_break;
    }
#line 268
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  *str = p;
#line 272
  return;
}
}
#line 274 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_blank_p(char c ) 
{ 
  int tmp ;

  {
#line 277
  if ((int )c == 32) {
#line 277
    tmp = 1;
  } else
#line 277
  if ((int )c == 10) {
#line 277
    tmp = 1;
  } else
#line 277
  if ((int )c == 9) {
#line 277
    tmp = 1;
  } else {
#line 277
    tmp = 0;
  }
#line 277
  return ((_Bool )tmp);
}
}
#line 282 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_digit_p(char c ) 
{ 
  int tmp ;

  {
#line 285
  if ((int )c >= 48) {
#line 285
    if ((int )c <= 57) {
#line 285
      tmp = 1;
    } else {
#line 285
      tmp = 0;
    }
  } else {
#line 285
    tmp = 0;
  }
#line 285
  return ((_Bool )tmp);
}
}
#line 288 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_letter_p(char c ) 
{ 
  int tmp ;

  {
#line 291
  if ((int )c >= 97) {
#line 291
    if ((int )c <= 122) {
#line 291
      tmp = 1;
    } else {
#line 291
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 291
  if ((int )c >= 65) {
#line 291
    if ((int )c <= 90) {
#line 291
      tmp = 1;
    } else {
#line 291
      tmp = 0;
    }
  } else {
#line 291
    tmp = 0;
  }
#line 291
  return ((_Bool )tmp);
}
}
#line 295 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
static _Bool rec_match_int(char const   *str , char const   *reg , int flags ) 
{ 
  _Bool ret ;
  regex_t regexp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 303
  tmp___0 = rpl_regcomp((regex_t */* __restrict  */)(& regexp), (char const   */* __restrict  */)reg,
                        flags);
  }
#line 303
  if (tmp___0 != 0) {
    {
#line 305
    tmp = dcgettext("recutils", "internal error: rec_match: error compiling regexp.\n",
                    5);
#line 305
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp);
    }
#line 306
    return ((_Bool)0);
  }
  {
#line 309
  tmp___1 = rpl_regexec((regex_t const   */* __restrict  */)(& regexp), (char const   */* __restrict  */)str,
                        (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 309
  ret = (_Bool )(tmp___1 == 0);
#line 310
  rpl_regfree(& regexp);
  }
#line 312
  return (ret);
}
}
#line 315 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_match(char const   *str , char const   *reg ) 
{ 
  _Bool tmp ;

  {
  {
#line 319
  tmp = rec_match_int(str, reg, 1);
  }
#line 319
  return (tmp);
}
}
#line 322 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
_Bool rec_match_insensitive(char const   *str , char const   *reg ) 
{ 
  _Bool tmp ;

  {
  {
#line 326
  tmp = rec_match_int(str, reg, 1 | (1 << 1));
  }
#line 326
  return (tmp);
}
}
#line 329 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
size_t rec_extract_size(char const   *str ) 
{ 
  char const   *p ;
  char *condition_str ;
  int res ;
  _Bool tmp ;

  {
  {
#line 336
  tmp = rec_match(str, "^[ \t\n]*(>|<|>=|<=)?[ \t\n]*-?((0x[0-9a-fA-F]+)|[0-9]+)[ \t\n]*$");
  }
#line 336
  if (! tmp) {
#line 338
    return ((size_t )0);
  }
  {
#line 341
  p = str;
#line 342
  rec_skip_blanks(& p);
#line 343
  rec_parse_regexp(& p, "^[><]=?", & condition_str);
#line 344
  rec_skip_blanks(& p);
#line 345
  rec_parse_int(& p, & res);
  }
#line 347
  return ((size_t )res);
}
}
#line 350 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
enum rec_size_condition_e rec_extract_size_condition(char const   *str ) 
{ 
  char const   *p ;
  char *condition_str ;
  enum rec_size_condition_e condition ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 354
  condition_str = (char *)((void *)0);
#line 357
  tmp = rec_match(str, "^[ \t\n]*(>|<|>=|<=)?[ \t\n]*-?((0x[0-9a-fA-F]+)|[0-9]+)[ \t\n]*$");
  }
#line 357
  if (! tmp) {
#line 359
    return ((enum rec_size_condition_e )0);
  }
  {
#line 362
  p = str;
#line 363
  rec_skip_blanks(& p);
#line 364
  rec_parse_regexp(& p, "^[><]=?", & condition_str);
  }
#line 366
  if (condition_str) {
    {
#line 368
    tmp___3 = strcmp((char const   *)condition_str, ">");
    }
#line 368
    if (tmp___3 == 0) {
#line 370
      condition = (enum rec_size_condition_e )3;
    } else {
      {
#line 372
      tmp___2 = strcmp((char const   *)condition_str, ">=");
      }
#line 372
      if (tmp___2 == 0) {
#line 374
        condition = (enum rec_size_condition_e )4;
      } else {
        {
#line 376
        tmp___1 = strcmp((char const   *)condition_str, "<");
        }
#line 376
        if (tmp___1 == 0) {
#line 378
          condition = (enum rec_size_condition_e )1;
        } else {
          {
#line 380
          tmp___0 = strcmp((char const   *)condition_str, "<=");
          }
#line 380
          if (tmp___0 == 0) {
#line 382
            condition = (enum rec_size_condition_e )2;
          } else {
            {
#line 386
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"internal error: rec_extract_size_condition: invalid condition.\n");
            }
#line 387
            return ((enum rec_size_condition_e )0);
          }
        }
      }
    }
    {
#line 390
    free((void *)condition_str);
    }
  } else {
#line 394
    condition = (enum rec_size_condition_e )0;
  }
#line 397
  return (condition);
}
}
#line 400 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
int rec_timespec_subtract(struct timespec *result , struct timespec *x , struct timespec *y ) 
{ 


  {
#line 405
  result->tv_sec = x->tv_sec - y->tv_sec;
#line 406
  result->tv_nsec = x->tv_nsec - y->tv_nsec;
#line 407
  if (result->tv_nsec < 0L) {
#line 410
    (result->tv_sec) --;
#line 411
    result->tv_nsec += 1000000000L;
  }
#line 415
  return (result->tv_sec < 0L);
}
}
#line 418 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
uint32_t rec_endian_swap(uint32_t number ) 
{ 
  uint32_t res ;

  {
#line 423
  res = (((number >> 24) | ((number << 8) & 16711680U)) | ((number >> 8) & 65280U)) | (number << 24);
#line 428
  return (res);
}
}
#line 431 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-utils.c"
char *rec_concat_strings(char const   *str1 , char const   *str2 , char const   *str3 ) 
{ 
  char *res ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 436
  tmp = strlen(str1);
#line 436
  tmp___0 = strlen(str2);
#line 436
  tmp___1 = strlen(str3);
#line 436
  tmp___2 = malloc(((tmp + tmp___0) + tmp___1) + 1UL);
#line 436
  res = (char *)tmp___2;
  }
#line 438
  if (res) {
    {
#line 440
    tmp___3 = strlen(str1);
#line 440
    memcpy((void */* __restrict  */)res, (void const   */* __restrict  */)str1, tmp___3);
#line 441
    tmp___4 = strlen(str2);
#line 441
    tmp___5 = strlen(str1);
#line 441
    memcpy((void */* __restrict  */)(res + tmp___5), (void const   */* __restrict  */)str2,
           tmp___4);
#line 442
    tmp___6 = strlen(str3);
#line 442
    tmp___7 = strlen(str1);
#line 442
    tmp___8 = strlen(str2);
#line 442
    memcpy((void */* __restrict  */)((res + tmp___7) + tmp___8), (void const   */* __restrict  */)str3,
           tmp___6 + 1UL);
    }
  }
#line 445
  return (res);
}
}
#line 137 "./rec.h"
_Bool rec_mset_type_p(rec_mset_t mset , rec_mset_type_t type ) ;
#line 210
rec_mset_elem_t rec_mset_add_sorted(rec_mset_t mset , rec_mset_type_t type , void *data ) ;
#line 219
_Bool rec_mset_remove_at(rec_mset_t mset , rec_mset_type_t type , size_t position ) ;
#line 275
void *rec_mset_elem_data(rec_mset_elem_t elem ) ;
#line 294
void *rec_mset_elem_dup_data(rec_mset_elem_t elem ) ;
#line 311
void rec_mset_dump(rec_mset_t mset ) ;
#line 76 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static void rec_mset_init(rec_mset_t mset ) ;
#line 78
static _Bool rec_mset_elem_equal_fn(void const   *e1 , void const   *e2 ) ;
#line 80
static void rec_mset_elem_dispose_fn(void const   *e ) ;
#line 81
static int rec_mset_elem_compare_fn(void const   *e1 , void const   *e2 ) ;
#line 83
static rec_mset_list_iter_t rec_mset_iter_gl2mset(gl_list_iterator_t list_iter ) ;
#line 84
static gl_list_iterator_t rec_mset_iter_mset2gl(rec_mset_list_iter_t mset_iter ) ;
#line 90
static rec_mset_elem_t rec_mset_elem_new(rec_mset_t mset , rec_mset_type_t type ,
                                         void *data ) ;
#line 98
static void rec_mset_elem_destroy(rec_mset_elem_t elem ) ;
#line 104 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_t rec_mset_new(void) 
{ 
  rec_mset_t new ;
  int i ;
  void *tmp ;

  {
  {
#line 110
  tmp = malloc(sizeof(struct rec_mset_s ));
#line 110
  new = (rec_mset_t )tmp;
  }
#line 111
  if (new) {
    {
#line 113
    rec_mset_init(new);
#line 115
    new->ntypes = 1;
#line 117
    i = 0;
    }
    {
#line 117
    while (1) {
      while_continue: /* CIL Label */ ;
#line 117
      if (! (i < 4)) {
#line 117
        goto while_break;
      }
#line 119
      new->count[i] = (size_t )0;
#line 120
      new->name[i] = (char *)((void *)0);
#line 121
      new->equal_fn[i] = (rec_mset_equal_fn_t )((void *)0);
#line 122
      new->disp_fn[i] = (rec_mset_disp_fn_t )((void *)0);
#line 123
      new->dup_fn[i] = (rec_mset_dup_fn_t )((void *)0);
#line 124
      new->compare_fn[i] = (rec_mset_compare_fn_t )((void *)0);
#line 117
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 127
    new->elem_list = gl_list_nx_create_empty(& gl_array_list_implementation, & rec_mset_elem_equal_fn,
                                             (size_t (*)(void const   *elt ))((void *)0),
                                             & rec_mset_elem_dispose_fn, (_Bool)1);
    }
#line 133
    if ((unsigned long )new->elem_list == (unsigned long )((void *)0)) {
      {
#line 136
      rec_mset_destroy(new);
#line 137
      new = (rec_mset_t )((void *)0);
      }
    }
  }
#line 141
  return (new);
}
}
#line 144 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void rec_mset_destroy(rec_mset_t mset ) 
{ 
  int i ;

  {
#line 147
  if (mset) {
#line 151
    i = 0;
    {
#line 151
    while (1) {
      while_continue: /* CIL Label */ ;
#line 151
      if (! (i < mset->ntypes)) {
#line 151
        goto while_break;
      }
      {
#line 152
      free((void *)mset->name[i]);
#line 151
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 153
    gl_list_free(mset->elem_list);
#line 154
    free((void *)mset);
    }
  }
#line 156
  return;
}
}
#line 158 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_t rec_mset_dup(rec_mset_t mset ) 
{ 
  rec_mset_t new ;
  rec_mset_elem_t elem ;
  gl_list_iterator_t iter ;
  int i ;
  void *data ;
  _Bool tmp ;

  {
  {
#line 166
  new = rec_mset_new();
  }
#line 168
  if (new) {
#line 171
    new->ntypes = mset->ntypes;
#line 172
    i = 0;
    {
#line 172
    while (1) {
      while_continue: /* CIL Label */ ;
#line 172
      if (! (i < new->ntypes)) {
#line 172
        goto while_break;
      }
#line 174
      new->count[i] = (size_t )0;
#line 175
      if (mset->name[i]) {
        {
#line 177
        new->name[i] = strdup((char const   *)mset->name[i]);
        }
#line 178
        if (! new->name[i]) {
          {
#line 181
          rec_mset_destroy(new);
          }
#line 182
          return ((rec_mset_t )((void *)0));
        }
      }
#line 185
      new->disp_fn[i] = mset->disp_fn[i];
#line 186
      new->equal_fn[i] = mset->equal_fn[i];
#line 187
      new->dup_fn[i] = mset->dup_fn[i];
#line 188
      new->compare_fn[i] = mset->compare_fn[i];
#line 172
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 193
    iter = gl_list_iterator(mset->elem_list);
    }
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 194
      tmp = gl_list_iterator_next(& iter, (void const   **)(& elem), (gl_list_node_t *)((void *)0));
      }
#line 194
      if (! tmp) {
#line 194
        goto while_break___0;
      }
#line 196
      data = (void *)0;
#line 199
      if (new->dup_fn[elem->type]) {
        {
#line 201
        data = (*(new->dup_fn[elem->type]))(elem->data);
        }
#line 202
        if (! data) {
          {
#line 205
          rec_mset_destroy(new);
          }
#line 206
          return ((rec_mset_t )((void *)0));
        }
      } else {
#line 211
        data = elem->data;
      }
      {
#line 216
      rec_mset_append(new, elem->type, data, 0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 219
    gl_list_iterator_free(& iter);
    }
  }
#line 222
  return (new);
}
}
#line 225 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_t rec_mset_sort(rec_mset_t mset ) 
{ 
  rec_mset_elem_t elem ;
  gl_list_iterator_t iter ;
  gl_list_t list ;
  rec_mset_elem_t tmp ;
  _Bool tmp___0 ;

  {
  {
#line 235
  list = mset->elem_list;
#line 236
  mset->elem_list = gl_list_nx_create_empty(& gl_array_list_implementation, & rec_mset_elem_equal_fn,
                                            (size_t (*)(void const   *elt ))((void *)0),
                                            & rec_mset_elem_dispose_fn, (_Bool)1);
  }
#line 241
  if (! mset->elem_list) {
#line 244
    return ((rec_mset_t )((void *)0));
  }
  {
#line 250
  iter = gl_list_iterator(list);
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 251
    tmp___0 = gl_list_iterator_next(& iter, (void const   **)(& elem), (gl_list_node_t *)((void *)0));
    }
#line 251
    if (! tmp___0) {
#line 251
      goto while_break;
    }
    {
#line 257
    tmp = rec_mset_add_sorted(mset, elem->type, elem->data);
    }
#line 257
    if (! tmp) {
      {
#line 262
      gl_list_free(mset->elem_list);
#line 263
      mset->elem_list = list;
      }
#line 264
      return ((rec_mset_t )((void *)0));
    }
#line 272
    elem->data = (void *)0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  gl_list_iterator_free(& iter);
#line 280
  gl_list_free(list);
  }
#line 282
  return (mset);
}
}
#line 285 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
_Bool rec_mset_type_p(rec_mset_t mset , rec_mset_type_t type ) 
{ 


  {
#line 289
  return ((_Bool )(type < mset->ntypes));
}
}
#line 292 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_type_t rec_mset_register_type(rec_mset_t mset , char *name , void (*disp_fn)(void *data ) ,
                                       _Bool (*equal_fn)(void *data1 , void *data2 ) ,
                                       void *(*dup_fn)(void *data ) , int (*compare_fn)(void *data1 ,
                                                                                        void *data2 ,
                                                                                        int type2 ) ) 
{ 
  rec_mset_type_t new_type ;
  int tmp ;

  {
  {
#line 302
  tmp = mset->ntypes;
#line 302
  (mset->ntypes) ++;
#line 302
  new_type = tmp;
#line 303
  mset->count[new_type] = (size_t )0;
#line 304
  mset->name[new_type] = strdup((char const   *)name);
#line 305
  mset->disp_fn[new_type] = disp_fn;
#line 306
  mset->equal_fn[new_type] = equal_fn;
#line 307
  mset->dup_fn[new_type] = dup_fn;
#line 308
  mset->compare_fn[new_type] = compare_fn;
  }
#line 310
  return (new_type);
}
}
#line 313 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
size_t rec_mset_count(rec_mset_t mset , rec_mset_type_t type ) 
{ 


  {
#line 317
  return (mset->count[type]);
}
}
#line 320 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void *rec_mset_get_at(rec_mset_t mset , rec_mset_type_t type , size_t position ) 
{ 
  void *result ;
  rec_mset_elem_t elem ;
  void const   *tmp ;
  rec_mset_elem_t cur_elem ;
  gl_list_node_t node ;
  gl_list_iterator_t iter ;
  int count[4] ;
  int i ;
  _Bool tmp___0 ;

  {
#line 328
  if (position < 0UL) {
#line 331
    return ((void *)0);
  } else
#line 328
  if (position >= mset->count[type]) {
#line 331
    return ((void *)0);
  }
#line 334
  if (type == 0) {
    {
#line 340
    tmp = gl_list_get_at(mset->elem_list, position);
#line 340
    elem = (rec_mset_elem_t )tmp;
    }
  } else {
#line 353
    i = 0;
#line 355
    elem = (rec_mset_elem_t )((void *)0);
#line 356
    i = 0;
    {
#line 356
    while (1) {
      while_continue: /* CIL Label */ ;
#line 356
      if (! (i < 4)) {
#line 356
        goto while_break;
      }
#line 358
      count[i] = 0;
#line 356
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 361
    iter = gl_list_iterator(mset->elem_list);
    }
    {
#line 362
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 362
      tmp___0 = gl_list_iterator_next(& iter, (void const   **)(& cur_elem), & node);
      }
#line 362
      if (! tmp___0) {
#line 362
        goto while_break___0;
      }
#line 364
      if (type == 0) {
#line 367
        elem = cur_elem;
#line 368
        goto while_break___0;
      } else
#line 364
      if (type == cur_elem->type) {
#line 364
        if ((size_t )count[cur_elem->type] == position) {
#line 367
          elem = cur_elem;
#line 368
          goto while_break___0;
        } else {
#line 372
          (count[cur_elem->type]) ++;
#line 373
          (count[0]) ++;
        }
      } else {
#line 372
        (count[cur_elem->type]) ++;
#line 373
        (count[0]) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 378
  if (elem) {
#line 380
    result = elem->data;
  } else {
#line 384
    result = (void *)0;
  }
#line 387
  return (result);
}
}
#line 390 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
_Bool rec_mset_remove_at(rec_mset_t mset , rec_mset_type_t type , size_t position ) 
{ 
  rec_mset_elem_t elem ;
  void *data ;
  _Bool removed ;
  _Bool tmp ;

  {
#line 397
  removed = (_Bool)0;
#line 399
  if (mset->count[type] > 0UL) {
#line 401
    if (position < 0UL) {
#line 403
      position = (size_t )0;
    }
#line 405
    if (position >= mset->count[type]) {
#line 407
      position = mset->count[type] - 1UL;
    }
    {
#line 410
    data = rec_mset_get_at(mset, type, position);
#line 411
    elem = rec_mset_search(mset, data);
#line 412
    tmp = rec_mset_remove_elem(mset, elem);
    }
#line 412
    if (tmp) {
#line 414
      removed = (_Bool)1;
    }
  }
#line 418
  return (removed);
}
}
#line 421 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_elem_t rec_mset_insert_at(rec_mset_t mset , rec_mset_type_t type , void *data ,
                                   size_t position ) 
{ 
  rec_mset_elem_t elem ;
  gl_list_node_t node ;

  {
  {
#line 427
  elem = (rec_mset_elem_t )((void *)0);
#line 430
  node = (gl_list_node_t )((void *)0);
#line 435
  elem = rec_mset_elem_new(mset, type, data);
  }
#line 436
  if (! elem) {
#line 438
    return ((rec_mset_elem_t )((void *)0));
  }
#line 443
  if (position < 0UL) {
    {
#line 445
    node = gl_list_nx_add_first(mset->elem_list, (void const   *)((void *)elem));
    }
  } else
#line 448
  if (position >= mset->count[0]) {
    {
#line 450
    node = gl_list_nx_add_last(mset->elem_list, (void const   *)((void *)elem));
    }
  } else {
    {
#line 455
    node = gl_list_nx_add_at(mset->elem_list, position, (void const   *)((void *)elem));
    }
  }
#line 460
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 462
    rec_mset_elem_destroy(elem);
#line 463
    elem = (rec_mset_elem_t )((void *)0);
    }
  } else {
#line 467
    elem->list_node = node;
#line 469
    (mset->count[0]) ++;
#line 470
    if (elem->type != 0) {
#line 472
      (mset->count[elem->type]) ++;
    }
  }
#line 476
  return (elem);
}
}
#line 479 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_elem_t rec_mset_append(rec_mset_t mset , rec_mset_type_t elem_type , void *data ,
                                rec_mset_type_t type ) 
{ 
  size_t tmp ;
  rec_mset_elem_t tmp___0 ;

  {
  {
#line 485
  tmp = rec_mset_count(mset, type);
#line 485
  tmp___0 = rec_mset_insert_at(mset, elem_type, data, tmp);
  }
#line 485
  return (tmp___0);
}
}
#line 491 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
_Bool rec_mset_remove_elem(rec_mset_t mset , rec_mset_elem_t elem ) 
{ 
  rec_mset_type_t type ;
  _Bool res ;
  _Bool tmp ;

  {
  {
#line 495
  type = elem->type;
#line 496
  tmp = gl_list_remove_node(mset->elem_list, elem->list_node);
#line 496
  res = tmp;
  }
#line 497
  if (res) {
#line 501
    (mset->count[type]) --;
#line 502
    if (type != 0) {
#line 504
      (mset->count[0]) --;
    }
  }
#line 508
  return (res);
}
}
#line 511 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_elem_t rec_mset_insert_after(rec_mset_t mset , rec_mset_type_t type , void *data ,
                                      rec_mset_elem_t elem ) 
{ 
  rec_mset_elem_t new_elem ;
  gl_list_node_t node ;

  {
  {
#line 523
  new_elem = rec_mset_elem_new(mset, type, data);
  }
#line 524
  if (! new_elem) {
#line 526
    return ((rec_mset_elem_t )((void *)0));
  }
  {
#line 533
  node = gl_list_search(mset->elem_list, (void const   *)((void *)elem));
  }
#line 534
  if (node) {
    {
#line 536
    node = gl_list_nx_add_after(mset->elem_list, node, (void const   *)((void *)new_elem));
    }
#line 539
    if (! node) {
      {
#line 542
      rec_mset_elem_destroy(new_elem);
      }
#line 543
      return ((rec_mset_elem_t )((void *)0));
    }
#line 546
    new_elem->list_node = node;
#line 548
    (mset->count[0]) ++;
#line 549
    if (new_elem->type != 0) {
#line 551
      (mset->count[new_elem->type]) ++;
    }
  } else {
    {
#line 556
    node = gl_list_nx_add_last(mset->elem_list, (void const   *)((void *)elem));
    }
#line 557
    if (! node) {
      {
#line 560
      rec_mset_elem_destroy(new_elem);
      }
#line 561
      return ((rec_mset_elem_t )((void *)0));
    }
#line 564
    new_elem->list_node = node;
  }
#line 567
  return (new_elem);
}
}
#line 570 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_elem_t rec_mset_search(rec_mset_t mset , void *data ) 
{ 
  rec_mset_elem_t result ;
  rec_mset_elem_t elem ;
  gl_list_iterator_t iter ;
  _Bool tmp ;

  {
  {
#line 574
  result = (rec_mset_elem_t )((void *)0);
#line 578
  iter = gl_list_iterator(mset->elem_list);
  }
  {
#line 579
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 579
    tmp = gl_list_iterator_next(& iter, (void const   **)(& elem), (gl_list_node_t *)((void *)0));
    }
#line 579
    if (! tmp) {
#line 579
      goto while_break;
    }
#line 581
    if ((unsigned long )elem->data == (unsigned long )data) {
#line 583
      result = elem;
#line 584
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 588
  gl_list_iterator_free(& iter);
  }
#line 590
  return (result);
}
}
#line 593 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_iterator_t rec_mset_iterator(rec_mset_t mset ) 
{ 
  gl_list_iterator_t list_iter ;
  rec_mset_iterator_t mset_iter ;

  {
  {
#line 603
  mset_iter.mset = mset;
#line 605
  list_iter = gl_list_iterator(mset->elem_list);
#line 606
  mset_iter.list_iter = rec_mset_iter_gl2mset(list_iter);
  }
#line 608
  return (mset_iter);
}
}
#line 611 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
_Bool rec_mset_iterator_next(rec_mset_iterator_t *iterator , rec_mset_type_t type ,
                             void const   **data , rec_mset_elem_t *elem ) 
{ 
  _Bool found ;
  rec_mset_elem_t mset_elem ;
  gl_list_iterator_t list_iter ;
  gl_list_node_t list_node ;

  {
  {
#line 617
  found = (_Bool)1;
#line 624
  list_iter = rec_mset_iter_mset2gl(iterator->list_iter);
  }
  {
#line 629
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 629
    found = gl_list_iterator_next(& list_iter, (void const   **)(& mset_elem), & list_node);
    }
#line 629
    if (found) {
#line 629
      if (type != 0) {
#line 629
        if (! (mset_elem->type != type)) {
#line 629
          goto while_break;
        }
      } else {
#line 629
        goto while_break;
      }
    } else {
#line 629
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  if (found) {
    {
#line 636
    iterator->list_iter = rec_mset_iter_gl2mset(list_iter);
    }
#line 637
    if (data) {
#line 638
      *data = (void const   *)mset_elem->data;
    }
#line 639
    if (elem) {
#line 641
      mset_elem->list_node = list_node;
#line 642
      *elem = mset_elem;
    }
  }
#line 646
  return (found);
}
}
#line 649 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void rec_mset_iterator_free(rec_mset_iterator_t *iterator ) 
{ 
  gl_list_iterator_t list_iter ;

  {
  {
#line 657
  list_iter = rec_mset_iter_mset2gl(iterator->list_iter);
#line 658
  gl_list_iterator_free(& list_iter);
#line 659
  iterator->list_iter = rec_mset_iter_gl2mset(list_iter);
  }
#line 660
  return;
}
}
#line 662 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
int rec_mset_elem_type(rec_mset_elem_t elem ) 
{ 


  {
#line 665
  return (elem->type);
}
}
#line 668 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void rec_mset_elem_set_type(rec_mset_elem_t elem , rec_mset_type_t type ) 
{ 


  {
#line 672
  ((elem->mset)->count[elem->type]) --;
#line 673
  elem->type = type;
#line 674
  ((elem->mset)->count[type]) ++;
#line 675
  return;
}
}
#line 677 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void *rec_mset_elem_data(rec_mset_elem_t elem ) 
{ 


  {
#line 680
  return (elem->data);
}
}
#line 683 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void rec_mset_elem_set_data(rec_mset_elem_t elem , void *data ) 
{ 


  {
#line 687
  elem->data = data;
#line 688
  return;
}
}
#line 690 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
_Bool rec_mset_elem_equal_p(rec_mset_elem_t elem1 , rec_mset_elem_t elem2 ) 
{ 
  _Bool tmp ;

  {
  {
#line 694
  tmp = rec_mset_elem_equal_fn((void const   *)((void *)elem1), (void const   *)((void *)elem2));
  }
#line 694
  return (tmp);
}
}
#line 698 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void *rec_mset_elem_dup_data(rec_mset_elem_t elem ) 
{ 
  void *tmp ;

  {
  {
#line 701
  tmp = (*((elem->mset)->dup_fn[elem->type]))(elem->data);
  }
#line 701
  return (tmp);
}
}
#line 704 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
void rec_mset_dump(rec_mset_t mset ) 
{ 
  gl_list_iterator_t iter ;
  gl_list_node_t node ;
  rec_mset_elem_t elem ;
  int i ;
  _Bool tmp ;

  {
  {
#line 712
  printf((char const   */* __restrict  */)"MSET:\n");
#line 713
  printf((char const   */* __restrict  */)"  ntypes: %d\n", mset->ntypes);
#line 715
  i = 0;
  }
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 715
    if (! (i < mset->ntypes)) {
#line 715
      goto while_break;
    }
    {
#line 717
    printf((char const   */* __restrict  */)"  type %d:\n", i);
#line 718
    printf((char const   */* __restrict  */)"    count:     %zd\n", mset->count[i]);
#line 719
    printf((char const   */* __restrict  */)"    disp_fn:   %p\n", mset->disp_fn[i]);
#line 720
    printf((char const   */* __restrict  */)"    equal_fn:  %p\n", mset->equal_fn[i]);
#line 721
    printf((char const   */* __restrict  */)"    dup_fn:    %p\n", mset->dup_fn[i]);
#line 715
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 724
  printf((char const   */* __restrict  */)"  nodes:\n");
#line 725
  iter = gl_list_iterator(mset->elem_list);
  }
  {
#line 726
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 726
    tmp = gl_list_iterator_next(& iter, (void const   **)(& elem), & node);
    }
#line 726
    if (! tmp) {
#line 726
      goto while_break___0;
    }
    {
#line 728
    printf((char const   */* __restrict  */)"    node=%p elem=%p elem->type=%d elem->data=%p contained=%p\n",
           node, elem, elem->type, elem->data, elem->mset);
#line 730
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 733
  printf((char const   */* __restrict  */)"END MSET\n");
  }
#line 734
  return;
}
}
#line 736 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
rec_mset_elem_t rec_mset_add_sorted(rec_mset_t mset , rec_mset_type_t type , void *data ) 
{ 
  rec_mset_elem_t elem ;
  gl_list_node_t node ;

  {
  {
#line 747
  elem = rec_mset_elem_new(mset, type, data);
  }
#line 748
  if (! elem) {
#line 750
    return ((rec_mset_elem_t )((void *)0));
  }
  {
#line 755
  node = gl_sortedlist_nx_add(mset->elem_list, & rec_mset_elem_compare_fn, (void const   *)((void *)elem));
  }
#line 758
  if (! node) {
    {
#line 760
    rec_mset_elem_destroy(elem);
    }
#line 761
    return ((rec_mset_elem_t )((void *)0));
  }
#line 764
  elem->list_node = node;
#line 766
  (mset->count[0]) ++;
#line 767
  if (elem->type != 0) {
#line 769
    (mset->count[elem->type]) ++;
  }
#line 772
  return (elem);
}
}
#line 779 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static void rec_mset_init(rec_mset_t mset ) 
{ 


  {
  {
#line 786
  memset((void *)mset, 0, sizeof(struct rec_mset_s ));
  }
#line 787
  return;
}
}
#line 789 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static _Bool rec_mset_elem_equal_fn(void const   *e1 , void const   *e2 ) 
{ 
  rec_mset_elem_t elem1 ;
  rec_mset_elem_t elem2 ;
  _Bool tmp ;

  {
#line 796
  elem1 = (rec_mset_elem_t )e1;
#line 797
  elem2 = (rec_mset_elem_t )e2;
#line 799
  if ((unsigned long )elem1->mset != (unsigned long )elem2->mset) {
#line 802
    return ((_Bool)0);
  } else
#line 799
  if (elem1->type != elem2->type) {
#line 802
    return ((_Bool)0);
  }
  {
#line 805
  tmp = (*((elem1->mset)->equal_fn[elem1->type]))(elem1->data, elem2->data);
  }
#line 805
  return (tmp);
}
}
#line 809 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static void rec_mset_elem_dispose_fn(void const   *e ) 
{ 
  rec_mset_elem_t elem ;

  {
  {
#line 814
  elem = (rec_mset_elem_t )e;
#line 815
  rec_mset_elem_destroy(elem);
  }
#line 816
  return;
}
}
#line 818 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static int rec_mset_elem_compare_fn(void const   *e1 , void const   *e2 ) 
{ 
  int result ;
  rec_mset_elem_t elem1 ;
  rec_mset_elem_t elem2 ;

  {
#line 822
  result = 0;
#line 826
  elem1 = (rec_mset_elem_t )e1;
#line 827
  elem2 = (rec_mset_elem_t )e2;
#line 829
  if ((elem1->mset)->compare_fn) {
    {
#line 831
    result = (*((elem1->mset)->compare_fn[elem1->type]))(elem1->data, elem2->data,
                                                         elem2->type);
    }
  }
#line 836
  return (result);
}
}
#line 839 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static rec_mset_list_iter_t rec_mset_iter_gl2mset(gl_list_iterator_t list_iter ) 
{ 
  rec_mset_list_iter_t mset_iter ;

  {
#line 844
  mset_iter.vtable = (void *)list_iter.vtable;
#line 845
  mset_iter.list = (void *)list_iter.list;
#line 846
  mset_iter.count = list_iter.count;
#line 847
  mset_iter.p = list_iter.p;
#line 848
  mset_iter.q = list_iter.q;
#line 849
  mset_iter.i = list_iter.i;
#line 850
  mset_iter.j = list_iter.j;
#line 852
  return (mset_iter);
}
}
#line 855 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static gl_list_iterator_t rec_mset_iter_mset2gl(rec_mset_list_iter_t mset_iter ) 
{ 
  gl_list_iterator_t list_iter ;

  {
#line 860
  list_iter.vtable = (struct gl_list_implementation  const  *)mset_iter.vtable;
#line 861
  list_iter.list = (gl_list_t )mset_iter.list;
#line 862
  list_iter.count = mset_iter.count;
#line 863
  list_iter.p = mset_iter.p;
#line 864
  list_iter.q = mset_iter.q;
#line 865
  list_iter.i = mset_iter.i;
#line 866
  list_iter.j = mset_iter.j;
#line 868
  return (list_iter);
}
}
#line 871 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static rec_mset_elem_t rec_mset_elem_new(rec_mset_t mset , rec_mset_type_t type ,
                                         void *data ) 
{ 
  rec_mset_elem_t new ;
  void *tmp ;

  {
#line 878
  if (type >= mset->ntypes) {
#line 880
    return ((rec_mset_elem_t )((void *)0));
  }
  {
#line 883
  tmp = malloc(sizeof(struct rec_mset_elem_s ));
#line 883
  new = (rec_mset_elem_t )tmp;
  }
#line 884
  if (new) {
#line 886
    new->type = type;
#line 887
    new->data = data;
#line 888
    new->mset = mset;
#line 889
    new->list_node = (gl_list_node_t )((void *)0);
  }
#line 892
  return (new);
}
}
#line 895 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec-mset.c"
static void rec_mset_elem_destroy(rec_mset_elem_t elem ) 
{ 


  {
#line 898
  if (elem) {
#line 904
    if (elem->data) {
#line 904
      if ((elem->mset)->disp_fn[elem->type]) {
        {
#line 906
        (*((elem->mset)->disp_fn[elem->type]))(elem->data);
        }
      }
    }
    {
#line 909
    free((void *)elem);
    }
  }
#line 911
  return;
}
}
#line 86 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 46 "./rec.h"
void rec_init(void) ;
#line 47
void rec_fini(void) ;
#line 37 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec.c"
void rec_init(void) 
{ 


  {
  {
#line 40
  bindtextdomain("recutils", "/usr/local/share/locale");
  }
#line 44
  return;
}
}
#line 46 "/tmp/gnuchess-6.2.5/recutils-1.8.90/src/rec.c"
void rec_fini(void) 
{ 


  {
#line 52
  return;
}
}
