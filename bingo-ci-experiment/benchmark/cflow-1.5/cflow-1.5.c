/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef unsigned long size_t;
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef long ptrdiff_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef int wchar_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 805 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 99 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[20] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 823 "/usr/include/stdio.h"
struct obstack ;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
typedef struct _IO_FILE __FILE;
#line 16 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion_68 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct_69 {
   int __count ;
   union __anonunion_68 __value ;
};
#line 21 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct_69 __mbstate_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 90 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.h"
typedef int arg_type;
#line 96 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.h"
union __anonunion_90 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 93 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.h"
struct __anonstruct_91 {
   arg_type type ;
   union __anonunion_90 a ;
};
#line 138 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.h"
typedef struct __anonstruct_91 argument;
#line 143 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.h"
struct __anonstruct_92 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
#line 149 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.h"
typedef struct __anonstruct_92 arguments;
#line 55 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-parse.h"
struct __anonstruct_93 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 69 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-parse.h"
typedef struct __anonstruct_93 char_directive;
#line 72 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-parse.h"
struct __anonstruct_94 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
#line 80 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-parse.h"
typedef struct __anonstruct_94 char_directives;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 223 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 50 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
typedef size_t (*Hash_hasher)(void const   * , size_t  );
#line 51 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
typedef int (*Hash_comparator)(void const   * , void const   * );
#line 52 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
typedef void (*Hash_data_freer)(void * );
#line 53 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
typedef int (*Hash_processor)(void * , void * );
#line 55 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   int is_n_buckets ;
};
#line 67 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 69
struct hash_table ;
#line 71 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
typedef struct hash_table Hash_table;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 48 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 54 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning *tuning ;
   Hash_hasher hasher ;
   Hash_comparator comparator ;
   Hash_data_freer data_freer ;
   struct hash_entry *free_entry_list ;
};
#line 200 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 64 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt_int.h"
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 70 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 52 "/usr/include/errno.h"
typedef int error_t;
#line 79 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 153
struct argp ;
#line 154
struct argp_state ;
#line 155
struct argp_child ;
#line 158 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
typedef error_t (*argp_parser_t)(int  , char * , struct argp_state * );
#line 227 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
struct argp {
   struct argp_option *options ;
   argp_parser_t parser ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 295 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
struct argp_child {
   struct argp *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 320 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
struct argp_state {
   struct argp *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 196 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
struct group {
   argp_parser_t parser ;
   struct argp *argp ;
   char *short_end ;
   unsigned int args_processed ;
   struct group *parent ;
   unsigned int parent_index ;
   void *input ;
   void **child_inputs ;
   void *hook ;
};
#line 243 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
struct parser {
   struct argp *argp ;
   char *short_opts ;
   struct rpl_option *long_opts ;
   struct _getopt_data opt_data ;
   struct group *groups ;
   struct group *egroup ;
   void **child_inputs ;
   int try_getopt ;
   struct argp_state state ;
   void *storage ;
};
#line 278 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
struct parser_convert_state {
   struct parser *parser ;
   char *short_end ;
   struct rpl_option *long_end ;
   void **child_inputs_end ;
};
#line 419 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
struct parser_sizes {
   size_t short_len ;
   size_t long_len ;
   size_t num_groups ;
   size_t num_child_inputs ;
};
#line 93 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
struct argp_fmtstream {
   FILE *stream ;
   size_t lmargin ;
   size_t rmargin ;
   ssize_t wmargin ;
   size_t point_offs ;
   ssize_t point_col ;
   char *buf ;
   char *p ;
   char *end ;
};
#line 110 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
typedef struct argp_fmtstream *argp_fmtstream_t;
#line 80 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
struct uparams {
   int dup_args ;
   int dup_args_note ;
   int short_opt_col ;
   int long_opt_col ;
   int doc_opt_col ;
   int opt_doc_col ;
   int header_col ;
   int usage_indent ;
   int rmargin ;
   int valid ;
};
#line 114 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
struct uparam_name {
   char const   *name ;
   int is_bool ;
   size_t uparams_offs ;
};
#line 353
struct hol_cluster ;
#line 355 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
struct hol_entry {
   struct argp_option *opt ;
   unsigned int num ;
   char *short_options ;
   int group ;
   struct hol_cluster *cluster ;
   struct argp *argp ;
   unsigned int ord ;
};
#line 386 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
struct hol_cluster {
   char const   *header ;
   int index ;
   int group ;
   struct hol_cluster *parent ;
   struct argp *argp ;
   int depth ;
   struct hol_cluster *next ;
};
#line 416 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
struct hol {
   struct hol_entry *entries ;
   unsigned int num_entries ;
   char *short_options ;
   struct hol_cluster *clusters ;
};
#line 983 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
struct hol_help_state {
   struct hol_entry *prev_entry ;
   int sep_groups ;
   int suppressed_dup_arg ;
};
#line 1000 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
struct pentry_state {
   struct hol_entry *entry ;
   argp_fmtstream_t stream ;
   struct hol_help_state *hhstate ;
   int first ;
   struct argp_state *state ;
};
#line 46 "./wordsplit.h"
struct wordsplit_node ;
#line 22 "./wordsplit.h"
struct wordsplit {
   size_t ws_wordc ;
   char **ws_wordv ;
   size_t ws_offs ;
   size_t ws_wordn ;
   int ws_flags ;
   char const   *ws_delim ;
   char const   *ws_comment ;
   char const   *ws_escape ;
   void (*ws_alloc_die)(void *wsp ) ;
   void (*ws_error)(char const   *  , ...) ;
   void (*ws_debug)(char const   *  , ...) ;
   char const   **ws_env ;
   char const   *(*ws_getvar)(char const   * , size_t  , void * ) ;
   void *ws_closure ;
   char const   *ws_input ;
   size_t ws_len ;
   size_t ws_endp ;
   int ws_errno ;
   struct wordsplit_node *ws_head ;
   struct wordsplit_node *ws_tail ;
};
#line 224 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
struct __anonstruct_481 {
   size_t beg ;
   size_t end ;
};
#line 222 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
union __anonunion_482 {
   struct __anonstruct_481 segm ;
   char *word ;
};
#line 217 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
struct wordsplit_node {
   struct wordsplit_node *prev ;
   struct wordsplit_node *next ;
   int flags ;
   union __anonunion_482 v ;
};
#line 612
enum __anonenum__483 {
    st_init = 0,
    st_squote = 1,
    st_dquote = 2
} ;
#line 144 "../gnu/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 158 "../gnu/obstack.h"
union __anonunion_508 {
   long tempint ;
   void *tempptr ;
};
#line 55 "./cflow.h"
struct linked_list ;
#line 53 "./cflow.h"
struct linked_list_entry {
   struct linked_list_entry *next ;
   struct linked_list_entry *prev ;
   struct linked_list *list ;
   void *data ;
};
#line 59 "./cflow.h"
typedef void (*linked_list_free_data_fp)(void * );
#line 61 "./cflow.h"
struct linked_list {
   linked_list_free_data_fp free_data ;
   struct linked_list_entry *head ;
   struct linked_list_entry *tail ;
};
#line 68
enum symtype {
    SymUndefined = 0,
    SymToken = 1,
    SymIdentifier = 2
} ;
#line 74
enum storage {
    ExternStorage = 0,
    ExplicitExternStorage = 1,
    StaticStorage = 2,
    AutoStorage = 3,
    AnyStorage = 4
} ;
#line 87
enum symbol_flag {
    symbol_none = 0,
    symbol_temp = 1,
    symbol_parm = 2,
    symbol_alias = 3
} ;
#line 95
struct symbol ;
#line 95 "./cflow.h"
typedef struct symbol Symbol;
#line 98
struct table_entry ;
#line 97 "./cflow.h"
struct symbol {
   struct table_entry *owner ;
   Symbol *next ;
   struct linked_list_entry *entry ;
   enum symtype type ;
   char *name ;
   enum symbol_flag flag ;
   struct symbol *alias ;
   int active ;
   int expand_line ;
   int token_type ;
   char *source ;
   int def_line ;
   struct linked_list *ref_line ;
   int level ;
   char *decl ;
   enum storage storage ;
   int arity ;
   int recursive ;
   size_t ord ;
   struct linked_list *caller ;
   struct linked_list *callee ;
};
#line 40 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
struct table_entry {
   Symbol *sym ;
};
#line 278 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
struct collect_data {
   Symbol **sym ;
   int (*sel)(Symbol *p ) ;
   size_t index ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 168 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt64_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 119 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 230 "./cflow.h"
typedef int cflow_output_command;
#line 232 "./cflow.h"
struct output_symbol {
   int direct ;
   int level ;
   int last ;
   Symbol *sym ;
};
#line 82 "./cflow.h"
struct __anonstruct_593 {
   int line ;
   char *source ;
};
#line 85 "./cflow.h"
typedef struct __anonstruct_593 Ref;
#line 38 "./parser.h"
struct __anonstruct_594 {
   char *str ;
};
#line 40 "./parser.h"
typedef struct __anonstruct_594 YYSTYPE;
#line 21 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
struct __anonstruct_595 {
   char *name ;
   int type_end ;
   int parmcnt ;
   int line ;
   enum storage storage ;
};
#line 27 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
typedef struct __anonstruct_595 Ident;
#line 56 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
struct __anonstruct_596 {
   int type ;
   char *token ;
   int line ;
};
#line 60 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
typedef struct __anonstruct_596 TOKSTK;
#line 62 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
typedef int Stackpos[1];
#line 255 "./cflow.h"
struct cflow_depmap ;
#line 255 "./cflow.h"
typedef struct cflow_depmap *cflow_depmap_t;
#line 61 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
struct output_driver {
   char *name ;
   int (*handler)(cflow_output_command cmd , FILE *outfile , int line , void *data ,
                  void *handler_data ) ;
   void *handler_data ;
};
#line 169 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
struct option_type {
   char *str ;
   int min_match ;
   int type ;
};
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int16_t int16_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 34 "/usr/include/inttypes.h"
typedef int __gwchar_t;
#line 76 "c.c"
typedef int16_t flex_int16_t;
#line 78 "c.c"
typedef int32_t flex_int32_t;
#line 202
struct yy_buffer_state ;
#line 202 "c.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 207 "c.c"
typedef size_t yy_size_t;
#line 244 "c.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   yy_size_t yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 417 "c.c"
typedef unsigned char YY_CHAR;
#line 421 "c.c"
typedef int yy_state_type;
#line 65 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xsize.h"
__inline size_t xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 67
  sum = size1 + size2;
#line 68
  if (sum >= size1) {
#line 68
    tmp = sum;
  } else {
#line 68
    tmp = 0xffffffffffffffffUL;
  }
#line 68
  return (tmp);
}
}
#line 76 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xsize.h"
__inline size_t xsum3(size_t size1 , size_t size2 , size_t size3 ) 
{ 
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;

  {
  {
#line 78
  __cil_tmp4 = xsum(size1, size2);
#line 78
  __cil_tmp5 = xsum(__cil_tmp4, size3);
  }
#line 78
  return (__cil_tmp5);
}
}
#line 86 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xsize.h"
__inline size_t xsum4(size_t size1 , size_t size2 , size_t size3 , size_t size4 ) 
{ 
  size_t __cil_tmp5 ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
  {
#line 88
  __cil_tmp5 = xsum(size1, size2);
#line 88
  __cil_tmp6 = xsum(__cil_tmp5, size3);
#line 88
  __cil_tmp7 = xsum(__cil_tmp6, size4);
  }
#line 88
  return (__cil_tmp7);
}
}
#line 96 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xsize.h"
__inline size_t xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 100
  if (size1 >= size2) {
#line 100
    tmp = size1;
  } else {
#line 100
    tmp = size2;
  }
#line 100
  return (tmp);
}
}
#line 57 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xalloc.h"
void xalloc_die(void) ;
#line 59
void *xmalloc(size_t n ) ;
#line 61
void *xzalloc(size_t s ) ;
#line 63
void *xcalloc(size_t n , size_t s ) ;
#line 65
void *xrealloc(void *p , size_t n ) ;
#line 67
void *x2realloc(void *p , size_t *pn ) ;
#line 68
void *xmemdup(void const   *p , size_t s ) ;
#line 70
char *xstrdup(char const   *string ) ;
#line 102
__inline void *xnmalloc(size_t n , size_t s ) ;
#line 105 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *__cil_tmp4 ;

  {
#line 107
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 107
    tmp = - 1;
  } else {
#line 107
    tmp = - 2;
  }
#line 107
  if ((size_t )tmp / s < n) {
    {
#line 108
    xalloc_die();
    }
  }
  {
#line 109
  __cil_tmp4 = xmalloc(n * s);
  }
#line 109
  return (__cil_tmp4);
}
}
#line 115
__inline void *xnrealloc(void *p , size_t n , size_t s ) ;
#line 118 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *__cil_tmp5 ;

  {
#line 120
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 120
    tmp = - 1;
  } else {
#line 120
    tmp = - 2;
  }
#line 120
  if ((size_t )tmp / s < n) {
    {
#line 121
    xalloc_die();
    }
  }
  {
#line 122
  __cil_tmp5 = xrealloc(p, n * s);
  }
#line 122
  return (__cil_tmp5);
}
}
#line 181 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *__cil_tmp5 ;

  {
#line 183
  n = *pn;
#line 185
  if (! p) {
#line 187
    if (! n) {
#line 195
      n = 128UL / s;
#line 196
      n += (unsigned long )(! n);
    }
  } else {
#line 205
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 206
      xalloc_die();
      }
    }
#line 207
    n += (n + 1UL) / 2UL;
  }
  {
#line 210
  *pn = n;
#line 211
  __cil_tmp5 = xrealloc(p, n * s);
  }
#line 211
  return (__cil_tmp5);
}
}
#line 217
__inline char *xcharalloc(size_t n ) ;
#line 220 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;
  void *tmp ;

  {
#line 222
  if (sizeof(char ) == 1UL) {
    {
#line 222
    __cil_tmp2 = xmalloc(n);
#line 222
    tmp = __cil_tmp2;
    }
  } else {
    {
#line 222
    __cil_tmp3 = xnmalloc(n, sizeof(char ));
#line 222
    tmp = __cil_tmp3;
    }
  }
#line 222
  return ((char *)tmp);
}
}
#line 101 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 104
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 107
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 112
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 117
extern  __attribute__((__nothrow__)) double strtod(char const   *__nptr , char **__endptr ) ;
#line 176
extern  __attribute__((__nothrow__)) long strtol(char const   *__nptr , char **__endptr ,
                                                 int __base ) ;
#line 200
extern  __attribute__((__nothrow__)) long long strtoll(char const   *__nptr , char **__endptr ,
                                                       int __base ) ;
#line 361
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 361 "/usr/include/stdlib.h"
__inline extern int atoi(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 363
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 363
  return ((int )__cil_tmp2);
}
}
#line 366
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 366 "/usr/include/stdlib.h"
__inline extern long atol(char const   *__nptr ) 
{ 
  long __cil_tmp2 ;

  {
  {
#line 368
  __cil_tmp2 = strtol(__nptr, (char **)((void *)0), 10);
  }
#line 368
  return (__cil_tmp2);
}
}
#line 373
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/stdlib.h"
__inline extern long long atoll(char const   *__nptr ) 
{ 
  long long __cil_tmp2 ;

  {
  {
#line 375
  __cil_tmp2 = strtoll(__nptr, (char **)((void *)0), 10);
  }
#line 375
  return (__cil_tmp2);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_major(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major |= 0UL;
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(__dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int gnu_dev_minor(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor |= (__dev & 17592184995840UL) >> 12;
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t gnu_dev_makedev(unsigned int __major ,
                                                                      unsigned int __minor )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *malloc(size_t __size ) ;
#line 541
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size ) ;
#line 549
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 797
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__)) ;
#line 817
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar )  __attribute__((__gnu_inline__)) ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h"
__inline extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                              size_t __size , __compar_fn_t __compar ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
#line 27
  __l = (size_t )0;
#line 28
  __u = __nmemb;
  {
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;

#line 29
    if (! (__l < __u)) {
#line 29
      goto while_break;
    }
    {
#line 31
    __idx = (__l + __u) / 2UL;
#line 32
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
#line 33
    __comparison = (*__compar)(__key, __p);
    }
#line 34
    if (__comparison < 0) {
#line 35
      __u = __idx;
    } else
#line 36
    if (__comparison > 0) {
#line 37
      __l = __idx + 1UL;
    } else {
#line 39
      return ((void *)__p);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((void *)0);
}
}
#line 926 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 930
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 933
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 995
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__gnu_inline__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double atof(char const   *__nptr ) 
{ 
  double __cil_tmp2 ;

  {
  {
#line 27
  __cil_tmp2 = strtod(__nptr, (char **)((void *)0));
  }
#line 27
  return (__cil_tmp2);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk(char const   *__name , char *__resolved ,
                                                          size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *__realpath_alias(char const   *__name ,
                                                            char *__resolved ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void const   *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 45
    __cil_tmp4 = __builtin_object_size((void const   *)__resolved, 1);
#line 45
    __cil_tmp5 = __realpath_chk(__name, __resolved, __cil_tmp4);
    }
#line 45
    return (__cil_tmp5);
  }
  {
#line 48
  __cil_tmp6 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp6);
}
}
#line 52
extern  __attribute__((__nothrow__)) int __ptsname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int __ptsname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 57
extern  __attribute__((__nothrow__)) int __ptsname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 64
__inline extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 64 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ptsname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 66
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 66
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 68
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 68
    if (! __cil_tmp5) {
      {
#line 69
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 69
      __cil_tmp7 = __ptsname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 69
      return (__cil_tmp7);
    }
    {
#line 70
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 70
    if (__buflen > __cil_tmp8) {
      {
#line 71
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 71
      __cil_tmp10 = __ptsname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 71
      return (__cil_tmp10);
    }
  }
  {
#line 73
  __cil_tmp11 = __ptsname_r_alias(__fd, __buf, __buflen);
  }
#line 73
  return (__cil_tmp11);
}
}
#line 77
extern  __attribute__((__nothrow__)) int __wctomb_chk(char *__s , wchar_t __wchar ,
                                                      size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int __wctomb_alias(char *__s , wchar_t __wchar ) ;
#line 83
__inline extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar )  __attribute__((__gnu_inline__)) ;
#line 83 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int wctomb(char *__s , wchar_t __wchar ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 92
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
  {
#line 92
  __cil_tmp3 = __builtin_object_size((void const   *)__s, 1);
  }
#line 92
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
#line 92
    if (16UL > __cil_tmp4) {
      {
#line 93
      __cil_tmp5 = __builtin_object_size((void const   *)__s, 1);
#line 93
      __cil_tmp6 = __wctomb_chk(__s, __wchar, __cil_tmp5);
      }
#line 93
      return (__cil_tmp6);
    }
  }
  {
#line 94
  __cil_tmp7 = __wctomb_alias(__s, __wchar);
  }
#line 94
  return (__cil_tmp7);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t *__dst , char const   *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t *__dst , char const   *__src ,
                                                             size_t __len ) ;
#line 105
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t *__dst , char const   *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 113
__inline extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t *__dst , char const   *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t mbstowcs(wchar_t *__dst , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 116
  __cil_tmp4 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 116
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 118
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 118
    if (! __cil_tmp5) {
      {
#line 119
      __cil_tmp6 = __builtin_object_size((void const   *)__dst, 1);
#line 119
      __cil_tmp7 = __mbstowcs_chk(__dst, __src, __len, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 119
      return (__cil_tmp7);
    }
    {
#line 122
    __cil_tmp8 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 122
    if (__len > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 123
      __cil_tmp9 = __builtin_object_size((void const   *)__dst, 1);
#line 123
      __cil_tmp10 = __mbstowcs_chk_warn(__dst, __src, __len, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 123
      return (__cil_tmp10);
    }
  }
  {
#line 126
  __cil_tmp11 = __mbstowcs_alias(__dst, __src, __len);
  }
#line 126
  return (__cil_tmp11);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char *__dst , wchar_t *__src ,
                                                           size_t __len , size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char *__dst , wchar_t *__src ,
                                                             size_t __len ) ;
#line 137
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char *__dst , wchar_t *__src ,
                                                                size_t __len , size_t __dstlen ) ;
#line 144
__inline extern  __attribute__((__nothrow__)) size_t wcstombs(char *__dst , wchar_t *__src ,
                                                              size_t __len )  __attribute__((__gnu_inline__)) ;
#line 144 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t wcstombs(char *__dst , wchar_t *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 147
  __cil_tmp4 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 147
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 149
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 149
    if (! __cil_tmp5) {
      {
#line 150
      __cil_tmp6 = __builtin_object_size((void const   *)__dst, 1);
#line 150
      __cil_tmp7 = __wcstombs_chk(__dst, __src, __len, __cil_tmp6);
      }
#line 150
      return (__cil_tmp7);
    }
    {
#line 151
    __cil_tmp8 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 151
    if (__len > __cil_tmp8) {
      {
#line 152
      __cil_tmp9 = __builtin_object_size((void const   *)__dst, 1);
#line 152
      __cil_tmp10 = __wcstombs_chk_warn(__dst, __src, __len, __cil_tmp9);
      }
#line 152
      return (__cil_tmp10);
    }
  }
  {
#line 154
  __cil_tmp11 = __wcstombs_alias(__dst, __src, __len);
  }
#line 154
  return (__cil_tmp11);
}
}
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 60
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 121
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 124
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 132
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 377
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 384
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s ) ;
#line 38 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 42
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                         size_t __len )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bcopy(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 25
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 25
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
}
}
#line 29
__inline extern  __attribute__((__nothrow__)) void bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 29 "/usr/include/x86_64-linux-gnu/bits/strings_fortified.h"
__inline extern void bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 31
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 0);
#line 31
  __cil_tmp4 = __builtin___memset_chk(__dest, '\000', __len, __cil_tmp3);
  }
}
}
#line 435 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 451
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 459
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern  __attribute__((__nothrow__)) void *memcpy(void *__dest , void const   *__src ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 34
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 34
  __cil_tmp5 = __builtin___memcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 34
  return (__cil_tmp5);
}
}
#line 38
__inline extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 38 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memmove(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 40
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 40
  __cil_tmp5 = __builtin___memmove_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 40
  return (__cil_tmp5);
}
}
#line 45
__inline extern  __attribute__((__nothrow__)) void *mempcpy(void *__dest , void const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 45 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *mempcpy(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 48
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 48
  __cil_tmp5 = __builtin___mempcpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 48
  return (__cil_tmp5);
}
}
#line 59
__inline extern  __attribute__((__nothrow__)) void *memset(void *__dest , int __ch ,
                                                           size_t __len )  __attribute__((__gnu_inline__)) ;
#line 59 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void *memset(void *__dest , int __ch , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 71
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 0);
#line 71
  __cil_tmp5 = __builtin___memset_chk(__dest, __ch, __len, __cil_tmp4);
  }
#line 71
  return (__cil_tmp5);
}
}
#line 77
 __attribute__((__nothrow__)) void __explicit_bzero_chk(void *__dest , size_t __len ,
                                                        size_t __destlen ) ;
#line 81
__inline extern  __attribute__((__nothrow__)) void explicit_bzero(void *__dest , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern void explicit_bzero(void *__dest , size_t __len ) 
{ 
  unsigned long __cil_tmp3 ;

  {
  {
#line 83
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 0);
#line 83
  __explicit_bzero_chk(__dest, __len, __cil_tmp3);
  }
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) char *strcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
#line 90
  __cil_tmp4 = __builtin___strcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 90
  return (__cil_tmp4);
}
}
#line 95
__inline extern  __attribute__((__nothrow__)) char *stpcpy(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpcpy(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
#line 97
  __cil_tmp4 = __builtin___stpcpy_chk(__dest, __src, __cil_tmp3);
  }
#line 97
  return (__cil_tmp4);
}
}
#line 103
__inline extern  __attribute__((__nothrow__)) char *strncpy(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncpy(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 106
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
#line 106
  __cil_tmp5 = __builtin___strncpy_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 106
  return (__cil_tmp5);
}
}
#line 110
extern  __attribute__((__nothrow__)) char *__stpncpy_chk(char *__dest , char const   *__src ,
                                                         size_t __n , size_t __destlen ) ;
#line 112
extern  __attribute__((__nothrow__)) char *__stpncpy_alias(char *__dest , char const   *__src ,
                                                           size_t __n ) ;
#line 116
__inline extern  __attribute__((__nothrow__)) char *stpncpy(char *__dest , char const   *__src ,
                                                            size_t __n )  __attribute__((__gnu_inline__)) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *stpncpy(char *__dest , char const   *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 118
  __cil_tmp6 = __builtin_object_size((void const   *)__dest, 1);
  }
  {
#line 118
  __cil_tmp5 = __builtin_constant_p(__n);
  }
  {
#line 118
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 118
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 118
    if (! __cil_tmp5) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void const   *)__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    } else
#line 118
    if (__n > __cil_tmp6) {
      {
      {
#line 120
      __cil_tmp7 = __builtin_object_size((void const   *)__dest, 1);
      }
      {
#line 120
      __cil_tmp8 = __stpncpy_chk(__dest, __src, __n, __cil_tmp7);
      }
      }
#line 120
      return (__cil_tmp8);
    }
  }
  {
#line 121
  __cil_tmp9 = __stpncpy_alias(__dest, __src, __n);
  }
#line 121
  return (__cil_tmp9);
}
}
#line 126
__inline extern  __attribute__((__nothrow__)) char *strcat(char *__dest , char const   *__src )  __attribute__((__gnu_inline__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strcat(char *__dest , char const   *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 128
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
#line 128
  __cil_tmp4 = __builtin___strcat_chk(__dest, __src, __cil_tmp3);
  }
#line 128
  return (__cil_tmp4);
}
}
#line 133
__inline extern  __attribute__((__nothrow__)) char *strncat(char *__dest , char const   *__src ,
                                                            size_t __len )  __attribute__((__gnu_inline__)) ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/string_fortified.h"
__inline extern char *strncat(char *__dest , char const   *__src , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 136
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
#line 136
  __cil_tmp5 = __builtin___strncat_chk(__dest, __src, __len, __cil_tmp4);
  }
#line 136
  return (__cil_tmp5);
}
}
#line 41 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *__cil_tmp3 ;

  {
  {
#line 43
  __cil_tmp3 = malloc(n);
#line 43
  p = __cil_tmp3;
  }
#line 44
  if (! p) {
#line 44
    if (n != 0UL) {
      {
#line 45
      xalloc_die();
      }
    }
  }
#line 46
  return (p);
}
}
#line 53 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 55
  if (! n) {
#line 55
    if (p) {
      {
#line 59
      free(p);
      }
#line 60
      return ((void *)0);
    }
  }
  {
#line 63
  p = realloc(p, n);
  }
#line 64
  if (! p) {
#line 64
    if (n) {
      {
#line 65
      xalloc_die();
      }
    }
  }
#line 66
  return (p);
}
}
#line 76 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 78
  __cil_tmp3 = x2nrealloc(p, pn, (size_t )1);
  }
#line 78
  return (__cil_tmp3);
}
}
#line 86 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *__cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 88
  __cil_tmp2 = xmalloc(s);
#line 88
  __cil_tmp3 = memset(__cil_tmp2, 0, s);
  }
#line 88
  return (__cil_tmp3);
}
}
#line 95 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;
  int tmp ;

  {
  {
#line 102
  p = calloc(n, s);
  }
#line 102
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 102
    tmp = - 1;
  } else {
#line 102
    tmp = - 2;
  }
#line 102
  if (! p) {
    {
#line 104
    xalloc_die();
    }
  }
#line 105
  return (p);
}
}
#line 113 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *__cil_tmp3 ;
  void *__cil_tmp4 ;

  {
  {
#line 115
  __cil_tmp3 = xmalloc(s);
#line 115
  __cil_tmp4 = memcpy(__cil_tmp3, p, s);
  }
#line 115
  return (__cil_tmp4);
}
}
#line 121 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t __cil_tmp2 ;
  void *__cil_tmp3 ;

  {
  {
#line 123
  __cil_tmp2 = strlen(string);
#line 123
  __cil_tmp3 = xmemdup((void const   *)string, __cil_tmp2 + 1UL);
  }
#line 123
  return ((char *)__cil_tmp3);
}
}
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void abort(void) ;
#line 44 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/error.h"
extern void error(int __status , int __errnum , char const   *__format  , ...) ;
#line 20 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/exitfail.h"
int exit_failure ;
#line 51 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category ) ;
#line 34 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 36
  __cil_tmp1 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"memory exhausted"),
                         5);
#line 36
  error(exit_failure, 0, (char const   *)((char *)"%s"), __cil_tmp1);
#line 42
  abort();
  }
}
}
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern _IO_FILE *stdin ;
#line 136
extern _IO_FILE *stdout ;
#line 312
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 318
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 320
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 327
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 333
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 335
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 340
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 352
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 355
__inline extern  __attribute__((__nothrow__)) int __asprintf(char **__ptr , char const   *__fmt 
                                                             , ...)  __attribute__((__gnu_inline__)) ;
#line 358
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 365
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 368
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 484
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 495
__inline extern int getc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 496
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 506
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 524
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 537
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 545
__inline extern int putc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 546
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 564
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 587
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 603
extern __ssize_t __getdelim(char **__lineptr , size_t *__n , int __delimiter , FILE *__stream ) ;
#line 616
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 626
extern int fputs(char const   *__s , FILE *__stream ) ;
#line 646
__inline extern size_t fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 673
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 767
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 826
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 829
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void)  __attribute__((__gnu_inline__)) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int __cil_tmp1 ;

  {
  {
#line 46
  __cil_tmp1 = _IO_getc(stdin);
  }
#line 46
  return (__cil_tmp1);
}
}
#line 53
__inline extern int fgetc_unlocked(FILE *__fp )  __attribute__((__gnu_inline__)) ;
#line 53 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 55
  __cil_tmp2 = __builtin_expect((long )(__fp->_IO_read_ptr >= __fp->_IO_read_end),
                                (long )0);
  }
#line 55
  if (__cil_tmp2) {
    {
#line 55
    __cil_tmp3 = __uflow(__fp);
#line 55
    tmp = __cil_tmp3;
    }
  } else {
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp = (int )*((unsigned char *)__fp->_IO_read_ptr);
  }
#line 55
  return (tmp);
}
}
#line 70
__inline extern int getchar_unlocked(void)  __attribute__((__gnu_inline__)) ;
#line 70 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  long __cil_tmp1 ;
  int __cil_tmp2 ;
  int tmp ;

  {
  {
#line 72
  __cil_tmp1 = __builtin_expect((long )(stdin->_IO_read_ptr >= stdin->_IO_read_end),
                                (long )0);
  }
#line 72
  if (__cil_tmp1) {
    {
#line 72
    __cil_tmp2 = __uflow(stdin);
#line 72
    tmp = __cil_tmp2;
    }
  } else {
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp = (int )*((unsigned char *)stdin->_IO_read_ptr);
  }
#line 72
  return (tmp);
}
}
#line 79
__inline extern int putchar(int __c )  __attribute__((__gnu_inline__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 81
  __cil_tmp2 = _IO_putc(__c, stdout);
  }
#line 81
  return (__cil_tmp2);
}
}
#line 88
__inline extern int fputc_unlocked(int __c , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  long __cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;
  int tmp ;

  {
  {
#line 90
  __cil_tmp3 = __builtin_expect((long )(__stream->_IO_write_ptr >= __stream->_IO_write_end),
                                (long )0);
  }
#line 90
  if (__cil_tmp3) {
    {
#line 90
    __cil_tmp4 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp = __cil_tmp4;
    }
  } else {
#line 90
    __cil_tmp5 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    *__cil_tmp5 = (char )__c;
#line 90
    tmp = (int )((unsigned char )*__cil_tmp5);
  }
#line 90
  return (tmp);
}
}
#line 105
__inline extern int putchar_unlocked(int __c )  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  long __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int tmp ;

  {
  {
#line 107
  __cil_tmp2 = __builtin_expect((long )(stdout->_IO_write_ptr >= stdout->_IO_write_end),
                                (long )0);
  }
#line 107
  if (__cil_tmp2) {
    {
#line 107
    __cil_tmp3 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp = __cil_tmp3;
    }
  } else {
#line 107
    __cil_tmp4 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    *__cil_tmp4 = (char )__c;
#line 107
    tmp = (int )((unsigned char )*__cil_tmp4);
  }
#line 107
  return (tmp);
}
}
#line 115
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 115 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t getline(char **__lineptr , size_t *__n , FILE *__stream ) 
{ 
  __ssize_t __cil_tmp4 ;

  {
  {
#line 117
  __cil_tmp4 = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 117
  return (__cil_tmp4);
}
}
#line 125
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 132
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 132 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 31 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int sprintf(char *__s , char const   *__fmt 
                                                          , ...)  __attribute__((__gnu_inline__)) ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int sprintf(char *__s , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 33
  __cil_tmp3 = __builtin_object_size((void const   *)__s, 1);
  }
  {
#line 33
  __cil_tmp4 = __builtin_va_arg_pack();
#line 33
  __cil_tmp5 = __builtin___sprintf_chk(__s, 1, __cil_tmp3, __fmt, __cil_tmp4);
  }
#line 33
  return (__cil_tmp5);
}
}
#line 43
__inline extern  __attribute__((__nothrow__)) int vsprintf(char *__s , char const   *__fmt ,
                                                           __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsprintf(char *__s , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 46
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
#line 46
  __cil_tmp5 = __builtin___vsprintf_chk(__s, 1, __cil_tmp4, __fmt, __ap);
  }
#line 46
  return (__cil_tmp5);
}
}
#line 61
__inline extern  __attribute__((__nothrow__)) int snprintf(char *__s , size_t __n ,
                                                           char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 61 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int snprintf(char *__s , size_t __n , char const   *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 64
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
  {
#line 64
  __cil_tmp5 = __builtin_va_arg_pack();
#line 64
  __cil_tmp6 = __builtin___snprintf_chk(__s, __n, 1, __cil_tmp4, __fmt, __cil_tmp5);
  }
#line 64
  return (__cil_tmp6);
}
}
#line 74
__inline extern  __attribute__((__nothrow__)) int vsnprintf(char *__s , size_t __n ,
                                                            char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 74 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vsnprintf(char *__s , size_t __n , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 77
  __cil_tmp5 = __builtin_object_size((void const   *)__s, 1);
#line 77
  __cil_tmp6 = __builtin___vsnprintf_chk(__s, __n, 1, __cil_tmp5, __fmt, __ap);
  }
#line 77
  return (__cil_tmp6);
}
}
#line 85
extern int __fprintf_chk(FILE *__stream , int __flag , char const   *__format  , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   *__format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE *__stream , int __flag , char const   *__format , __gnuc_va_list __ap ) ;
#line 95
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 95 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int fprintf(FILE *__stream , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 97
  __cil_tmp3 = __builtin_va_arg_pack();
#line 97
  __cil_tmp4 = __fprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 97
  return (__cil_tmp4);
}
}
#line 102
__inline extern int printf(char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 102 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int printf(char const   *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 104
  __cil_tmp2 = __builtin_va_arg_pack();
#line 104
  __cil_tmp3 = __printf_chk(1, __fmt, __cil_tmp2);
  }
#line 104
  return (__cil_tmp3);
}
}
#line 114
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 114 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vprintf(char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 117
  __cil_tmp3 = __vfprintf_chk(stdout, 1, __fmt, __ap);
  }
#line 117
  return (__cil_tmp3);
}
}
#line 124
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vfprintf(FILE *__stream , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 127
  __cil_tmp4 = __vfprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 127
  return (__cil_tmp4);
}
}
#line 131
extern int __dprintf_chk(int __fd , int __flag , char const   *__fmt  , ...) ;
#line 133
extern int __vdprintf_chk(int __fd , int __flag , char const   *__fmt , __gnuc_va_list __arg ) ;
#line 139
__inline extern int dprintf(int __fd , char const   *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int dprintf(int __fd , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 141
  __cil_tmp3 = __builtin_va_arg_pack();
#line 141
  __cil_tmp4 = __dprintf_chk(__fd, 1, __fmt, __cil_tmp3);
  }
#line 141
  return (__cil_tmp4);
}
}
#line 150
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vdprintf(int __fd , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 152
  __cil_tmp4 = __vdprintf_chk(__fd, 1, __fmt, __ap);
  }
#line 152
  return (__cil_tmp4);
}
}
#line 158
extern  __attribute__((__nothrow__)) int __asprintf_chk(char **__ptr , int __flag ,
                                                        char const   *__fmt  , ...) ;
#line 161
extern  __attribute__((__nothrow__)) int __vasprintf_chk(char **__ptr , int __flag ,
                                                         char const   *__fmt , __gnuc_va_list __arg ) ;
#line 164
extern  __attribute__((__nothrow__)) int __obstack_printf_chk(struct obstack *__obstack ,
                                                              int __flag , char const   *__format 
                                                              , ...) ;
#line 168
extern  __attribute__((__nothrow__)) int __obstack_vprintf_chk(struct obstack *__obstack ,
                                                               int __flag , char const   *__format ,
                                                               __gnuc_va_list __args ) ;
#line 176
__inline extern  __attribute__((__nothrow__)) int asprintf(char **__ptr , char const   *__fmt 
                                                           , ...)  __attribute__((__gnu_inline__)) ;
#line 176 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int asprintf(char **__ptr , char const   *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 178
  __cil_tmp3 = __builtin_va_arg_pack();
#line 178
  __cil_tmp4 = __asprintf_chk(__ptr, 1, __fmt, __cil_tmp3);
  }
#line 178
  return (__cil_tmp4);
}
}
#line 191
__inline extern  __attribute__((__nothrow__)) int obstack_printf(struct obstack *__obstack ,
                                                                 char const   *__fmt 
                                                                 , ...)  __attribute__((__gnu_inline__)) ;
#line 191 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_printf(struct obstack *__obstack , char const   *__fmt 
                                   , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 194
  __cil_tmp3 = __builtin_va_arg_pack();
#line 194
  __cil_tmp4 = __obstack_printf_chk(__obstack, 1, __fmt, __cil_tmp3);
  }
#line 194
  return (__cil_tmp4);
}
}
#line 207
__inline extern  __attribute__((__nothrow__)) int vasprintf(char **__ptr , char const   *__fmt ,
                                                            __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int vasprintf(char **__ptr , char const   *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 210
  __cil_tmp4 = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  }
#line 210
  return (__cil_tmp4);
}
}
#line 214
__inline extern  __attribute__((__nothrow__)) int obstack_vprintf(struct obstack *__obstack ,
                                                                  char const   *__fmt ,
                                                                  __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 214 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int obstack_vprintf(struct obstack *__obstack , char const   *__fmt ,
                                    __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 217
  __cil_tmp4 = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  }
#line 217
  return (__cil_tmp4);
}
}
#line 240
extern char *__fgets_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 242
extern char *__fgets_alias(char *__s , int __n , FILE *__stream ) ;
#line 245
extern char *__fgets_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 252
__inline extern char *fgets(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 254
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 254
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 256
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 256
    if (! __cil_tmp5) {
      {
      {
#line 257
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 257
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 257
      return (__cil_tmp7);
    } else
#line 256
    if (__n <= 0) {
      {
      {
#line 257
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 257
      __cil_tmp7 = __fgets_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 257
      return (__cil_tmp7);
    }
    {
#line 259
    __cil_tmp8 = __builtin_object_size((void const   *)__s, 1);
    }
#line 259
    if ((size_t )__n > __cil_tmp8) {
      {
#line 260
      __cil_tmp9 = __builtin_object_size((void const   *)__s, 1);
#line 260
      __cil_tmp10 = __fgets_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 260
      return (__cil_tmp10);
    }
  }
  {
#line 262
  __cil_tmp11 = __fgets_alias(__s, __n, __stream);
  }
#line 262
  return (__cil_tmp11);
}
}
#line 265
extern size_t __fread_chk(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                          FILE *__stream ) ;
#line 268
extern size_t __fread_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 272
extern size_t __fread_chk_warn(void *__ptr , size_t __ptrlen , size_t __size , size_t __n ,
                               FILE *__stream ) ;
#line 281
__inline extern size_t fread(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 284
  __cil_tmp5 = __builtin_object_size((void const   *)__ptr, 0);
  }
#line 284
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 286
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 286
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 286
    if (! __cil_tmp6) {
      {
      {
      {
#line 289
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 289
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 289
      return (__cil_tmp9);
    } else
#line 286
    if (! __cil_tmp7) {
      {
      {
      {
#line 289
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 289
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 289
      return (__cil_tmp9);
    } else
#line 286
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 289
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 289
      __cil_tmp9 = __fread_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 289
      return (__cil_tmp9);
    }
    {
#line 291
    __cil_tmp10 = __builtin_object_size((void const   *)__ptr, 0);
    }
#line 291
    if (__size * __n > __cil_tmp10) {
      {
#line 292
      __cil_tmp11 = __builtin_object_size((void const   *)__ptr, 0);
#line 292
      __cil_tmp12 = __fread_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 292
      return (__cil_tmp12);
    }
  }
  {
#line 294
  __cil_tmp13 = __fread_alias(__ptr, __size, __n, __stream);
  }
#line 294
  return (__cil_tmp13);
}
}
#line 298
extern char *__fgets_unlocked_chk(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 300
extern char *__fgets_unlocked_alias(char *__s , int __n , FILE *__stream ) ;
#line 303
extern char *__fgets_unlocked_chk_warn(char *__s , size_t __size , int __n , FILE *__stream ) ;
#line 310
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 310 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *fgets_unlocked(char *__s , int __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  char *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 312
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 312
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 314
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 314
    if (! __cil_tmp5) {
      {
      {
#line 315
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 315
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 315
      return (__cil_tmp7);
    } else
#line 314
    if (__n <= 0) {
      {
      {
#line 315
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 315
      __cil_tmp7 = __fgets_unlocked_chk(__s, __cil_tmp6, __n, __stream);
      }
      }
#line 315
      return (__cil_tmp7);
    }
    {
#line 317
    __cil_tmp8 = __builtin_object_size((void const   *)__s, 1);
    }
#line 317
    if ((size_t )__n > __cil_tmp8) {
      {
#line 318
      __cil_tmp9 = __builtin_object_size((void const   *)__s, 1);
#line 318
      __cil_tmp10 = __fgets_unlocked_chk_warn(__s, __cil_tmp9, __n, __stream);
      }
#line 318
      return (__cil_tmp10);
    }
  }
  {
#line 320
  __cil_tmp11 = __fgets_unlocked_alias(__s, __n, __stream);
  }
#line 320
  return (__cil_tmp11);
}
}
#line 326
extern size_t __fread_unlocked_chk(void *__ptr , size_t __ptrlen , size_t __size ,
                                   size_t __n , FILE *__stream ) ;
#line 329
extern size_t __fread_unlocked_alias(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 333
extern size_t __fread_unlocked_chk_warn(void *__ptr , size_t __ptrlen , size_t __size ,
                                        size_t __n , FILE *__stream ) ;
#line 342
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t fread_unlocked(void *__ptr , size_t __size , size_t __n , FILE *__stream ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  int __cil_tmp13 ;
  int __cil_tmp14 ;
  size_t __cnt ;
  char *__cptr ;
  int __c ;
  long __cil_tmp18 ;
  int __cil_tmp19 ;
  int tmp ;
  char *__cil_tmp22 ;
  size_t __cil_tmp23 ;

  {
  {
#line 345
  __cil_tmp5 = __builtin_object_size((void const   *)__ptr, 0);
  }
#line 345
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 347
    __cil_tmp7 = __builtin_constant_p(__n);
    }
    {
#line 347
    __cil_tmp6 = __builtin_constant_p(__size);
    }
#line 347
    if (! __cil_tmp6) {
      {
      {
      {
#line 350
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 350
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 350
      return (__cil_tmp9);
    } else
#line 347
    if (! __cil_tmp7) {
      {
      {
      {
#line 350
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 350
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 350
      return (__cil_tmp9);
    } else
#line 347
    if ((__size | __n) >= 1UL << (8UL * sizeof(size_t )) / 2UL) {
      {
      {
      {
#line 350
      __cil_tmp8 = __builtin_object_size((void const   *)__ptr, 0);
      }
      }
      {
      {
#line 350
      __cil_tmp9 = __fread_unlocked_chk(__ptr, __cil_tmp8, __size, __n, __stream);
      }
      }
      }
#line 350
      return (__cil_tmp9);
    }
    {
#line 353
    __cil_tmp10 = __builtin_object_size((void const   *)__ptr, 0);
    }
#line 353
    if (__size * __n > __cil_tmp10) {
      {
#line 354
      __cil_tmp11 = __builtin_object_size((void const   *)__ptr, 0);
#line 354
      __cil_tmp12 = __fread_unlocked_chk_warn(__ptr, __cil_tmp11, __size, __n, __stream);
      }
#line 354
      return (__cil_tmp12);
    }
  }
  {
#line 359
  __cil_tmp14 = __builtin_constant_p(__n);
  }
  {
#line 359
  __cil_tmp13 = __builtin_constant_p(__size);
  }
#line 359
  if (__cil_tmp13) {
#line 359
    if (__cil_tmp14) {
#line 359
      if ((__size | __n) < 1UL << (8UL * sizeof(size_t )) / 2UL) {
#line 359
        if (__size * __n <= 8UL) {
#line 364
          __cnt = __size * __n;
#line 365
          __cptr = (char *)__ptr;
#line 366
          if (__cnt == 0UL) {
#line 367
            return ((size_t )0);
          }
          {
          {
#line 369
          while (1) {
            while_continue: /* CIL Label */ ;

#line 369
            if (! (__cnt > 0UL)) {
#line 369
              goto while_break;
            }
            {
#line 371
            __cil_tmp18 = __builtin_expect((long )(__stream->_IO_read_ptr >= __stream->_IO_read_end),
                                           (long )0);
            }
#line 371
            if (__cil_tmp18) {
              {
#line 371
              __cil_tmp19 = __uflow(__stream);
#line 371
              tmp = __cil_tmp19;
              }
            } else {
#line 371
              (__stream->_IO_read_ptr) ++;
#line 371
              tmp = (int )*((unsigned char *)__stream->_IO_read_ptr);
            }
#line 371
            __c = tmp;
#line 372
            if (__c == -1) {
#line 373
              goto while_break;
            }
#line 374
            __cil_tmp22 = __cptr;
#line 374
            __cptr ++;
#line 374
            *__cil_tmp22 = (char )__c;
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
#line 369
          __cnt --;
#line 376
          return ((unsigned long )(__cptr - (char *)__ptr) / __size);
        }
      }
    }
  }
  {
#line 379
  __cil_tmp23 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  }
#line 379
  return (__cil_tmp23);
}
}
#line 36 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/version-etc.h"
char const   version_etc_copyright[] ;
#line 54
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 60
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 65
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 71
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) ;
#line 78
void emit_bug_reporting_address(void) ;
#line 64 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 69
  if (command_name) {
    {
#line 70
    fprintf(stream, (char const   *)((char *)"%s (%s) %s\n"), command_name, package,
            version);
    }
  } else {
    {
#line 72
    fprintf(stream, (char const   *)((char *)"%s %s\n"), package, version);
    }
  }
  {
#line 86
  __cil_tmp7 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"(C)"),
                         5);
#line 86
  fprintf(stream, (char const   *)version_etc_copyright, __cil_tmp7, 2014);
#line 88
  __cil_tmp8 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"),
                         5);
#line 88
  fputs((char const   *)__cil_tmp8, stream);
  }
  {
#line 99
  if (n_authors == (size_t )0) {
#line 99
    goto case_0;
  }
#line 102
  if (n_authors == (size_t )1) {
#line 102
    goto case_1;
  }
#line 106
  if (n_authors == (size_t )2) {
#line 106
    goto case_2;
  }
#line 110
  if (n_authors == (size_t )3) {
#line 110
    goto case_3;
  }
#line 115
  if (n_authors == (size_t )4) {
#line 115
    goto case_4;
  }
#line 122
  if (n_authors == (size_t )5) {
#line 122
    goto case_5;
  }
#line 129
  if (n_authors == (size_t )6) {
#line 129
    goto case_6;
  }
#line 137
  if (n_authors == (size_t )7) {
#line 137
    goto case_7;
  }
#line 145
  if (n_authors == (size_t )8) {
#line 145
    goto case_8;
  }
#line 154
  if (n_authors == (size_t )9) {
#line 154
    goto case_9;
  }
#line 163
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 101
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 104
  __cil_tmp9 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s.\n"),
                         5);
#line 104
  fprintf(stream, (char const   *)__cil_tmp9, (char const   *)*(authors + 0));
  }
#line 105
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 108
  __cil_tmp10 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s and %s.\n"),
                          5);
#line 108
  fprintf(stream, (char const   *)__cil_tmp10, (char const   *)*(authors + 0), (char const   *)*(authors + 1));
  }
#line 109
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 112
  __cil_tmp11 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, and %s.\n"),
                          5);
#line 112
  fprintf(stream, (char const   *)__cil_tmp11, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2));
  }
#line 114
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 119
  __cil_tmp12 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, %s,\nand %s.\n"),
                          5);
#line 119
  fprintf(stream, (char const   *)__cil_tmp12, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2), (char const   *)*(authors + 3));
  }
#line 121
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 126
  __cil_tmp13 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, %s,\n%s, and %s.\n"),
                          5);
#line 126
  fprintf(stream, (char const   *)__cil_tmp13, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2), (char const   *)*(authors + 3), (char const   *)*(authors + 4));
  }
#line 128
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 133
  __cil_tmp14 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, %s,\n%s, %s, and %s.\n"),
                          5);
#line 133
  fprintf(stream, (char const   *)__cil_tmp14, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2), (char const   *)*(authors + 3), (char const   *)*(authors + 4),
          (char const   *)*(authors + 5));
  }
#line 136
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 141
  __cil_tmp15 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"),
                          5);
#line 141
  fprintf(stream, (char const   *)__cil_tmp15, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2), (char const   *)*(authors + 3), (char const   *)*(authors + 4),
          (char const   *)*(authors + 5), (char const   *)*(authors + 6));
  }
#line 144
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 149
  __cil_tmp16 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"),
                          5);
#line 149
  fprintf(stream, (char const   *)__cil_tmp16, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2), (char const   *)*(authors + 3), (char const   *)*(authors + 4),
          (char const   *)*(authors + 5), (char const   *)*(authors + 6), (char const   *)*(authors + 7));
  }
#line 153
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 158
  __cil_tmp17 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"),
                          5);
#line 158
  fprintf(stream, (char const   *)__cil_tmp17, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2), (char const   *)*(authors + 3), (char const   *)*(authors + 4),
          (char const   *)*(authors + 5), (char const   *)*(authors + 6), (char const   *)*(authors + 7),
          (char const   *)*(authors + 8));
  }
#line 162
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 169
  __cil_tmp18 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"),
                          5);
#line 169
  fprintf(stream, (char const   *)__cil_tmp18, (char const   *)*(authors + 0), (char const   *)*(authors + 1),
          (char const   *)*(authors + 2), (char const   *)*(authors + 3), (char const   *)*(authors + 4),
          (char const   *)*(authors + 5), (char const   *)*(authors + 6), (char const   *)*(authors + 7),
          (char const   *)*(authors + 8));
  }
#line 173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 182 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 188
  n_authors = (size_t )0;
  {
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;

#line 188
    if (! ((char const   *)*(authors + n_authors))) {
#line 188
      goto while_break;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  n_authors ++;
#line 190
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
}
}
#line 198 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;

  {
#line 205
  n_authors = (size_t )0;
  {
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;

#line 205
    if (! (n_authors < 10UL && authtab[n_authors] != (char const   *)((void *)0))) {
#line 205
      goto while_break;
    }

  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  n_authors ++;
#line 210
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)((char const   **)authtab),
                  n_authors);
  }
}
}
#line 229 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 235
  __builtin_va_start((__builtin_va_list *)authors, version);
#line 236
  version_etc_va(stream, command_name, package, version, (__builtin_va_list *)authors);
#line 237
  __builtin_va_end((__builtin_va_list *)authors);
  }
}
}
#line 241 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 247
  __cil_tmp1 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"\nReport bugs to: %s\n"),
                         5);
#line 247
  printf((char const   *)__cil_tmp1, (char *)"bug-cflow@gnu.org");
#line 253
  __cil_tmp2 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s home page: <%s>\n"),
                         5);
#line 253
  printf((char const   *)__cil_tmp2, (char *)"GNU cflow", (char *)"http://www.gnu.org/software/cflow/");
#line 258
  __cil_tmp3 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"General help using GNU software: <http://www.gnu.org/gethelp/>\n"),
                         5);
#line 258
  fputs((char const   *)__cil_tmp3, stdout);
  }
}
}
#line 74 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/vasnprintf.h"
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void) ;
#line 87 "/usr/include/wchar.h"
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__)) ;
#line 92
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 97
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscat(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__)) ;
#line 101
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncat(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 262
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 267
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemmove(wchar_t *__s1 , wchar_t *__s2 ,
                                                                size_t __n )  __attribute__((__gnu_inline__)) ;
#line 271
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemset(wchar_t *__s , wchar_t __c ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 276
__inline extern  __attribute__((__nothrow__)) wchar_t *wmempcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                                size_t __n )  __attribute__((__gnu_inline__)) ;
#line 284
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c )  __attribute__((__gnu_inline__)) ;
#line 288
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc )  __attribute__((__gnu_inline__)) ;
#line 296
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t *__pwc , char const   *__s ,
                                                    size_t __n , mbstate_t *__p ) ;
#line 301
__inline extern  __attribute__((__nothrow__)) size_t wcrtomb(char *__s , wchar_t __wchar ,
                                                             mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 305
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   *__s , size_t __n ,
                                                     mbstate_t *__ps ) ;
#line 307
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   *__s , size_t __n ,
                                                            mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 316
extern wint_t __btowc_alias(int __c ) ;
#line 318
__inline extern  __attribute__((__nothrow__)) wint_t btowc(int __c )  __attribute__((__gnu_inline__)) ;
#line 318 "/usr/include/wchar.h"
__inline extern wint_t btowc(int __c ) 
{ 
  int __cil_tmp2 ;
  wint_t __cil_tmp3 ;
  wint_t tmp ;

  {
  {
#line 319
  __cil_tmp2 = __builtin_constant_p(__c);
  }
#line 319
  if ((__cil_tmp2 && __c >= 0) && __c <= 127) {
#line 319
    tmp = (wint_t )__c;
  } else {
    {
#line 319
    __cil_tmp3 = __btowc_alias(__c);
#line 319
    tmp = __cil_tmp3;
    }
  }
#line 319
  return (tmp);
}
}
#line 322
extern int __wctob_alias(wint_t __c ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) int wctob(wint_t __wc )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/wchar.h"
__inline extern int wctob(wint_t __wc ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int tmp ;

  {
  {
#line 325
  __cil_tmp2 = __builtin_constant_p(__wc);
  }
#line 325
  if ((__cil_tmp2 && __wc >= 0U) && __wc <= 127U) {
#line 325
    tmp = (int )__wc;
  } else {
    {
#line 325
    __cil_tmp3 = __wctob_alias(__wc);
#line 325
    tmp = __cil_tmp3;
    }
  }
#line 325
  return (tmp);
}
}
#line 329
__inline extern  __attribute__((__nothrow__)) size_t mbrlen(char const   *__s , size_t __n ,
                                                            mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 329 "/usr/include/wchar.h"
__inline extern size_t mbrlen(char const   *__s , size_t __n , mbstate_t *__ps ) 
{ 
  size_t __cil_tmp4 ;
  size_t __cil_tmp5 ;
  size_t tmp ;

  {
#line 331
  if (__ps != (mbstate_t *)((void *)0)) {
    {
#line 331
    __cil_tmp4 = mbrtowc((wchar_t *)((void *)0), __s, __n, __ps);
#line 331
    tmp = __cil_tmp4;
    }
  } else {
    {
#line 331
    __cil_tmp5 = __mbrlen(__s, __n, (mbstate_t *)((void *)0));
#line 331
    tmp = __cil_tmp5;
    }
  }
#line 331
  return (tmp);
}
}
#line 337
__inline extern  __attribute__((__nothrow__)) size_t mbsrtowcs(wchar_t *__dst , char const   **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 343
__inline extern  __attribute__((__nothrow__)) size_t wcsrtombs(char *__dst , wchar_t **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 351
__inline extern  __attribute__((__nothrow__)) size_t mbsnrtowcs(wchar_t *__dst , char const   **__src ,
                                                                size_t __nmc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 357
__inline extern  __attribute__((__nothrow__)) size_t wcsnrtombs(char *__dst , wchar_t **__src ,
                                                                size_t __nwc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 551
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpcpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__)) ;
#line 556
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 580
__inline extern int fwprintf(__FILE *__stream , wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 587
__inline extern int wprintf(wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 590
__inline extern  __attribute__((__nothrow__)) int swprintf(wchar_t *__s , size_t __n ,
                                                           wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 598
__inline extern int vfwprintf(__FILE *__stream , wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 606
__inline extern int vwprintf(wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 611
__inline extern  __attribute__((__nothrow__)) int vswprintf(wchar_t *__s , size_t __n ,
                                                            wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 756
__inline extern wchar_t *fgetws(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 818
__inline extern wchar_t *fgetws_unlocked(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk(wchar_t *__s1 , wchar_t *__s2 ,
                                                            size_t __n , size_t __ns1 ) ;
#line 27
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_alias(wchar_t *__s1 , wchar_t *__s2 ,
                                                              size_t __n ) ;
#line 31
extern  __attribute__((__nothrow__)) wchar_t *__wmemcpy_chk_warn(wchar_t *__s1 , wchar_t *__s2 ,
                                                                 size_t __n , size_t __ns1 ) ;
#line 39
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 39 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wmemcpy(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 42
  __cil_tmp4 = __builtin_object_size((void const   *)__s1, 0);
  }
#line 42
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 44
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 44
    if (! __cil_tmp5) {
      {
#line 45
      __cil_tmp6 = __builtin_object_size((void const   *)__s1, 0);
#line 45
      __cil_tmp7 = __wmemcpy_chk(__s1, __s2, __n, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 45
      return (__cil_tmp7);
    }
    {
#line 48
    __cil_tmp8 = __builtin_object_size((void const   *)__s1, 0);
    }
#line 48
    if (__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 49
      __cil_tmp9 = __builtin_object_size((void const   *)__s1, 0);
#line 49
      __cil_tmp10 = __wmemcpy_chk_warn(__s1, __s2, __n, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 49
      return (__cil_tmp10);
    }
  }
  {
#line 52
  __cil_tmp11 = __wmemcpy_alias(__s1, __s2, __n);
  }
#line 52
  return (__cil_tmp11);
}
}
#line 56
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk(wchar_t *__s1 , wchar_t *__s2 ,
                                                             size_t __n , size_t __ns1 ) ;
#line 58
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_alias(wchar_t *__s1 , wchar_t *__s2 ,
                                                               size_t __n ) ;
#line 61
extern  __attribute__((__nothrow__)) wchar_t *__wmemmove_chk_warn(wchar_t *__s1 ,
                                                                  wchar_t *__s2 ,
                                                                  size_t __n , size_t __ns1 ) ;
#line 68
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemmove(wchar_t *__s1 , wchar_t *__s2 ,
                                                                size_t __n )  __attribute__((__gnu_inline__)) ;
#line 68 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wmemmove(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 70
  __cil_tmp4 = __builtin_object_size((void const   *)__s1, 0);
  }
#line 70
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 72
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 72
    if (! __cil_tmp5) {
      {
#line 73
      __cil_tmp6 = __builtin_object_size((void const   *)__s1, 0);
#line 73
      __cil_tmp7 = __wmemmove_chk(__s1, __s2, __n, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 73
      return (__cil_tmp7);
    }
    {
#line 76
    __cil_tmp8 = __builtin_object_size((void const   *)__s1, 0);
    }
#line 76
    if (__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 77
      __cil_tmp9 = __builtin_object_size((void const   *)__s1, 0);
#line 77
      __cil_tmp10 = __wmemmove_chk_warn(__s1, __s2, __n, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 77
      return (__cil_tmp10);
    }
  }
  {
#line 80
  __cil_tmp11 = __wmemmove_alias(__s1, __s2, __n);
  }
#line 80
  return (__cil_tmp11);
}
}
#line 85
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk(wchar_t *__s1 , wchar_t *__s2 ,
                                                             size_t __n , size_t __ns1 ) ;
#line 88
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_alias(wchar_t *__s1 , wchar_t *__s2 ,
                                                               size_t __n ) ;
#line 92
extern  __attribute__((__nothrow__)) wchar_t *__wmempcpy_chk_warn(wchar_t *__s1 ,
                                                                  wchar_t *__s2 ,
                                                                  size_t __n , size_t __ns1 ) ;
#line 100
__inline extern  __attribute__((__nothrow__)) wchar_t *wmempcpy(wchar_t *__s1 , wchar_t *__s2 ,
                                                                size_t __n )  __attribute__((__gnu_inline__)) ;
#line 100 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wmempcpy(wchar_t *__s1 , wchar_t *__s2 , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 103
  __cil_tmp4 = __builtin_object_size((void const   *)__s1, 0);
  }
#line 103
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 105
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 105
    if (! __cil_tmp5) {
      {
#line 106
      __cil_tmp6 = __builtin_object_size((void const   *)__s1, 0);
#line 106
      __cil_tmp7 = __wmempcpy_chk(__s1, __s2, __n, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 106
      return (__cil_tmp7);
    }
    {
#line 109
    __cil_tmp8 = __builtin_object_size((void const   *)__s1, 0);
    }
#line 109
    if (__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 110
      __cil_tmp9 = __builtin_object_size((void const   *)__s1, 0);
#line 110
      __cil_tmp10 = __wmempcpy_chk_warn(__s1, __s2, __n, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 110
      return (__cil_tmp10);
    }
  }
  {
#line 113
  __cil_tmp11 = __wmempcpy_alias(__s1, __s2, __n);
  }
#line 113
  return (__cil_tmp11);
}
}
#line 118
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk(wchar_t *__s , wchar_t __c ,
                                                            size_t __n , size_t __ns ) ;
#line 120
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_alias(wchar_t *__s , wchar_t __c ,
                                                              size_t __n ) ;
#line 122
extern  __attribute__((__nothrow__)) wchar_t *__wmemset_chk_warn(wchar_t *__s , wchar_t __c ,
                                                                 size_t __n , size_t __ns ) ;
#line 129
__inline extern  __attribute__((__nothrow__)) wchar_t *wmemset(wchar_t *__s , wchar_t __c ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wmemset(wchar_t *__s , wchar_t __c , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 131
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 0);
  }
#line 131
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 133
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 133
    if (! __cil_tmp5) {
      {
#line 134
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 0);
#line 134
      __cil_tmp7 = __wmemset_chk(__s, __c, __n, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 134
      return (__cil_tmp7);
    }
    {
#line 136
    __cil_tmp8 = __builtin_object_size((void const   *)__s, 0);
    }
#line 136
    if (__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 137
      __cil_tmp9 = __builtin_object_size((void const   *)__s, 0);
#line 137
      __cil_tmp10 = __wmemset_chk_warn(__s, __c, __n, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 137
      return (__cil_tmp10);
    }
  }
  {
#line 140
  __cil_tmp11 = __wmemset_alias(__s, __c, __n);
  }
#line 140
  return (__cil_tmp11);
}
}
#line 144
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                           size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) wchar_t *__wcscpy_alias(wchar_t *__dest , wchar_t *__src ) ;
#line 152
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__)) ;
#line 152 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcscpy(wchar_t *__dest , wchar_t *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  wchar_t *__cil_tmp5 ;
  wchar_t *__cil_tmp6 ;

  {
  {
#line 154
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 154
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 155
    __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
#line 155
    __cil_tmp5 = __wcscpy_chk(__dest, __src, __cil_tmp4 / sizeof(wchar_t ));
    }
#line 155
    return (__cil_tmp5);
  }
  {
#line 156
  __cil_tmp6 = __wcscpy_alias(__dest, __src);
  }
#line 156
  return (__cil_tmp6);
}
}
#line 160
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                           size_t __destlen ) ;
#line 163
extern  __attribute__((__nothrow__)) wchar_t *__wcpcpy_alias(wchar_t *__dest , wchar_t *__src ) ;
#line 168
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpcpy(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__)) ;
#line 168 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcpcpy(wchar_t *__dest , wchar_t *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  wchar_t *__cil_tmp5 ;
  wchar_t *__cil_tmp6 ;

  {
  {
#line 170
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 170
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 171
    __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
#line 171
    __cil_tmp5 = __wcpcpy_chk(__dest, __src, __cil_tmp4 / sizeof(wchar_t ));
    }
#line 171
    return (__cil_tmp5);
  }
  {
#line 172
  __cil_tmp6 = __wcpcpy_alias(__dest, __src);
  }
#line 172
  return (__cil_tmp6);
}
}
#line 176
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                            size_t __n , size_t __destlen ) ;
#line 179
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_alias(wchar_t *__dest , wchar_t *__src ,
                                                              size_t __n ) ;
#line 183
extern  __attribute__((__nothrow__)) wchar_t *__wcsncpy_chk_warn(wchar_t *__dest ,
                                                                 wchar_t *__src ,
                                                                 size_t __n , size_t __destlen ) ;
#line 191
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 191 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcsncpy(wchar_t *__dest , wchar_t *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 194
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 194
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 196
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 196
    if (! __cil_tmp5) {
      {
#line 197
      __cil_tmp6 = __builtin_object_size((void const   *)__dest, 1);
#line 197
      __cil_tmp7 = __wcsncpy_chk(__dest, __src, __n, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 197
      return (__cil_tmp7);
    }
    {
#line 199
    __cil_tmp8 = __builtin_object_size((void const   *)__dest, 1);
    }
#line 199
    if (__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 200
      __cil_tmp9 = __builtin_object_size((void const   *)__dest, 1);
#line 200
      __cil_tmp10 = __wcsncpy_chk_warn(__dest, __src, __n, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 200
      return (__cil_tmp10);
    }
  }
  {
#line 203
  __cil_tmp11 = __wcsncpy_alias(__dest, __src, __n);
  }
#line 203
  return (__cil_tmp11);
}
}
#line 207
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk(wchar_t *__dest , wchar_t *__src ,
                                                            size_t __n , size_t __destlen ) ;
#line 210
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_alias(wchar_t *__dest , wchar_t *__src ,
                                                              size_t __n ) ;
#line 214
extern  __attribute__((__nothrow__)) wchar_t *__wcpncpy_chk_warn(wchar_t *__dest ,
                                                                 wchar_t *__src ,
                                                                 size_t __n , size_t __destlen ) ;
#line 222
__inline extern  __attribute__((__nothrow__)) wchar_t *wcpncpy(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 222 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcpncpy(wchar_t *__dest , wchar_t *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 225
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 225
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 227
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 227
    if (! __cil_tmp5) {
      {
#line 228
      __cil_tmp6 = __builtin_object_size((void const   *)__dest, 1);
#line 228
      __cil_tmp7 = __wcpncpy_chk(__dest, __src, __n, __cil_tmp6 / sizeof(wchar_t ));
      }
#line 228
      return (__cil_tmp7);
    }
    {
#line 230
    __cil_tmp8 = __builtin_object_size((void const   *)__dest, 1);
    }
#line 230
    if (__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 231
      __cil_tmp9 = __builtin_object_size((void const   *)__dest, 1);
#line 231
      __cil_tmp10 = __wcpncpy_chk_warn(__dest, __src, __n, __cil_tmp9 / sizeof(wchar_t ));
      }
#line 231
      return (__cil_tmp10);
    }
  }
  {
#line 234
  __cil_tmp11 = __wcpncpy_alias(__dest, __src, __n);
  }
#line 234
  return (__cil_tmp11);
}
}
#line 238
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_chk(wchar_t *__dest , wchar_t *__src ,
                                                           size_t __destlen ) ;
#line 241
extern  __attribute__((__nothrow__)) wchar_t *__wcscat_alias(wchar_t *__dest , wchar_t *__src ) ;
#line 246
__inline extern  __attribute__((__nothrow__)) wchar_t *wcscat(wchar_t *__dest , wchar_t *__src )  __attribute__((__gnu_inline__)) ;
#line 246 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcscat(wchar_t *__dest , wchar_t *__src ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  wchar_t *__cil_tmp5 ;
  wchar_t *__cil_tmp6 ;

  {
  {
#line 248
  __cil_tmp3 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 248
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 249
    __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
#line 249
    __cil_tmp5 = __wcscat_chk(__dest, __src, __cil_tmp4 / sizeof(wchar_t ));
    }
#line 249
    return (__cil_tmp5);
  }
  {
#line 250
  __cil_tmp6 = __wcscat_alias(__dest, __src);
  }
#line 250
  return (__cil_tmp6);
}
}
#line 254
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_chk(wchar_t *__dest , wchar_t *__src ,
                                                            size_t __n , size_t __destlen ) ;
#line 257
extern  __attribute__((__nothrow__)) wchar_t *__wcsncat_alias(wchar_t *__dest , wchar_t *__src ,
                                                              size_t __n ) ;
#line 263
__inline extern  __attribute__((__nothrow__)) wchar_t *wcsncat(wchar_t *__dest , wchar_t *__src ,
                                                               size_t __n )  __attribute__((__gnu_inline__)) ;
#line 263 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *wcsncat(wchar_t *__dest , wchar_t *__src , size_t __n ) 
{ 
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  wchar_t *__cil_tmp6 ;
  wchar_t *__cil_tmp7 ;

  {
  {
#line 266
  __cil_tmp4 = __builtin_object_size((void const   *)__dest, 1);
  }
#line 266
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 267
    __cil_tmp5 = __builtin_object_size((void const   *)__dest, 1);
#line 267
    __cil_tmp6 = __wcsncat_chk(__dest, __src, __n, __cil_tmp5 / sizeof(wchar_t ));
    }
#line 267
    return (__cil_tmp6);
  }
  {
#line 269
  __cil_tmp7 = __wcsncat_alias(__dest, __src, __n);
  }
#line 269
  return (__cil_tmp7);
}
}
#line 273
extern  __attribute__((__nothrow__)) int __swprintf_chk(wchar_t *__s , size_t __n ,
                                                        int __flag , size_t __s_len ,
                                                        wchar_t *__format  , ...) ;
#line 278
extern  __attribute__((__nothrow__)) int __swprintf_alias(wchar_t *__s , size_t __n ,
                                                          wchar_t *__fmt  , ...) ;
#line 285
__inline extern  __attribute__((__nothrow__)) int swprintf(wchar_t *__s , size_t __n ,
                                                           wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 285 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int swprintf(wchar_t *__s , size_t __n , wchar_t *__fmt  , ...) 
{ 
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
  {
#line 288
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 288
  if (1) {
    {
#line 289
    __cil_tmp5 = __builtin_object_size((void const   *)__s, 1);
    }
    {
#line 289
    __cil_tmp6 = __builtin_va_arg_pack();
#line 289
    __cil_tmp7 = __swprintf_chk(__s, __n, 1, __cil_tmp5 / sizeof(wchar_t ), __fmt,
                                __cil_tmp6);
    }
#line 289
    return (__cil_tmp7);
  }
  {
#line 292
  __cil_tmp8 = __builtin_va_arg_pack();
#line 292
  __cil_tmp9 = __swprintf_alias(__s, __n, __fmt, __cil_tmp8);
  }
#line 292
  return (__cil_tmp9);
}
}
#line 303
extern  __attribute__((__nothrow__)) int __vswprintf_chk(wchar_t *__s , size_t __n ,
                                                         int __flag , size_t __s_len ,
                                                         wchar_t *__format , __gnuc_va_list __arg ) ;
#line 309
extern  __attribute__((__nothrow__)) int __vswprintf_alias(wchar_t *__s , size_t __n ,
                                                           wchar_t *__fmt , __gnuc_va_list __ap ) ;
#line 315
__inline extern  __attribute__((__nothrow__)) int vswprintf(wchar_t *__s , size_t __n ,
                                                            wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 315 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int vswprintf(wchar_t *__s , size_t __n , wchar_t *__fmt , __gnuc_va_list __ap ) 
{ 
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
  {
#line 318
  __cil_tmp5 = __builtin_object_size((void const   *)__s, 1);
  }
#line 318
  if (1) {
    {
#line 319
    __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
#line 319
    __cil_tmp7 = __vswprintf_chk(__s, __n, 1, __cil_tmp6 / sizeof(wchar_t ), __fmt,
                                 __ap);
    }
#line 319
    return (__cil_tmp7);
  }
  {
#line 321
  __cil_tmp8 = __vswprintf_alias(__s, __n, __fmt, __ap);
  }
#line 321
  return (__cil_tmp8);
}
}
#line 327
extern int __fwprintf_chk(__FILE *__stream , int __flag , wchar_t *__format  , ...) ;
#line 329
extern int __wprintf_chk(int __flag , wchar_t *__format  , ...) ;
#line 331
extern int __vfwprintf_chk(__FILE *__stream , int __flag , wchar_t *__format , __gnuc_va_list __ap ) ;
#line 334
extern int __vwprintf_chk(int __flag , wchar_t *__format , __gnuc_va_list __ap ) ;
#line 339
__inline extern int wprintf(wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 339 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int wprintf(wchar_t *__fmt  , ...) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;

  {
  {
#line 341
  __cil_tmp2 = __builtin_va_arg_pack();
#line 341
  __cil_tmp3 = __wprintf_chk(1, __fmt, __cil_tmp2);
  }
#line 341
  return (__cil_tmp3);
}
}
#line 345
__inline extern int fwprintf(__FILE *__stream , wchar_t *__fmt  , ...)  __attribute__((__gnu_inline__)) ;
#line 345 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int fwprintf(__FILE *__stream , wchar_t *__fmt  , ...) 
{ 
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 347
  __cil_tmp3 = __builtin_va_arg_pack();
#line 347
  __cil_tmp4 = __fwprintf_chk(__stream, 1, __fmt, __cil_tmp3);
  }
#line 347
  return (__cil_tmp4);
}
}
#line 358
__inline extern int vwprintf(wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 358 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int vwprintf(wchar_t *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 360
  __cil_tmp3 = __vwprintf_chk(1, __fmt, __ap);
  }
#line 360
  return (__cil_tmp3);
}
}
#line 364
__inline extern int vfwprintf(__FILE *__stream , wchar_t *__fmt , __gnuc_va_list __ap )  __attribute__((__gnu_inline__)) ;
#line 364 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern int vfwprintf(__FILE *__stream , wchar_t *__fmt , __gnuc_va_list __ap ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 367
  __cil_tmp4 = __vfwprintf_chk(__stream, 1, __fmt, __ap);
  }
#line 367
  return (__cil_tmp4);
}
}
#line 372
extern wchar_t *__fgetws_chk(wchar_t *__s , size_t __size , int __n , __FILE *__stream ) ;
#line 374
extern wchar_t *__fgetws_alias(wchar_t *__s , int __n , __FILE *__stream ) ;
#line 377
extern wchar_t *__fgetws_chk_warn(wchar_t *__s , size_t __size , int __n , __FILE *__stream ) ;
#line 384
__inline extern wchar_t *fgetws(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 384 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *fgetws(wchar_t *__s , int __n , __FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 386
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 386
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 388
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 388
    if (! __cil_tmp5) {
      {
      {
#line 389
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 389
      __cil_tmp7 = __fgetws_chk(__s, __cil_tmp6 / sizeof(wchar_t ), __n, __stream);
      }
      }
#line 389
      return (__cil_tmp7);
    } else
#line 388
    if (__n <= 0) {
      {
      {
#line 389
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 389
      __cil_tmp7 = __fgetws_chk(__s, __cil_tmp6 / sizeof(wchar_t ), __n, __stream);
      }
      }
#line 389
      return (__cil_tmp7);
    }
    {
#line 392
    __cil_tmp8 = __builtin_object_size((void const   *)__s, 1);
    }
#line 392
    if ((size_t )__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 393
      __cil_tmp9 = __builtin_object_size((void const   *)__s, 1);
#line 393
      __cil_tmp10 = __fgetws_chk_warn(__s, __cil_tmp9 / sizeof(wchar_t ), __n, __stream);
      }
#line 393
      return (__cil_tmp10);
    }
  }
  {
#line 396
  __cil_tmp11 = __fgetws_alias(__s, __n, __stream);
  }
#line 396
  return (__cil_tmp11);
}
}
#line 400
extern wchar_t *__fgetws_unlocked_chk(wchar_t *__s , size_t __size , int __n , __FILE *__stream ) ;
#line 403
extern wchar_t *__fgetws_unlocked_alias(wchar_t *__s , int __n , __FILE *__stream ) ;
#line 407
extern wchar_t *__fgetws_unlocked_chk_warn(wchar_t *__s , size_t __size , int __n ,
                                           __FILE *__stream ) ;
#line 415
__inline extern wchar_t *fgetws_unlocked(wchar_t *__s , int __n , __FILE *__stream )  __attribute__((__gnu_inline__)) ;
#line 415 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern wchar_t *fgetws_unlocked(wchar_t *__s , int __n , __FILE *__stream ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  wchar_t *__cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  wchar_t *__cil_tmp10 ;
  wchar_t *__cil_tmp11 ;

  {
  {
#line 417
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 417
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 419
    __cil_tmp5 = __builtin_constant_p(__n);
    }
#line 419
    if (! __cil_tmp5) {
      {
      {
#line 420
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 420
      __cil_tmp7 = __fgetws_unlocked_chk(__s, __cil_tmp6 / sizeof(wchar_t ), __n,
                                         __stream);
      }
      }
#line 420
      return (__cil_tmp7);
    } else
#line 419
    if (__n <= 0) {
      {
      {
#line 420
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
      }
      {
#line 420
      __cil_tmp7 = __fgetws_unlocked_chk(__s, __cil_tmp6 / sizeof(wchar_t ), __n,
                                         __stream);
      }
      }
#line 420
      return (__cil_tmp7);
    }
    {
#line 423
    __cil_tmp8 = __builtin_object_size((void const   *)__s, 1);
    }
#line 423
    if ((size_t )__n > __cil_tmp8 / sizeof(wchar_t )) {
      {
#line 424
      __cil_tmp9 = __builtin_object_size((void const   *)__s, 1);
#line 424
      __cil_tmp10 = __fgetws_unlocked_chk_warn(__s, __cil_tmp9 / sizeof(wchar_t ),
                                               __n, __stream);
      }
#line 424
      return (__cil_tmp10);
    }
  }
  {
#line 427
  __cil_tmp11 = __fgetws_unlocked_alias(__s, __n, __stream);
  }
#line 427
  return (__cil_tmp11);
}
}
#line 432
extern  __attribute__((__nothrow__)) size_t __wcrtomb_chk(char *__s , wchar_t __wchar ,
                                                          mbstate_t *__p , size_t __buflen ) ;
#line 435
extern  __attribute__((__nothrow__)) size_t __wcrtomb_alias(char *__s , wchar_t __wchar ,
                                                            mbstate_t *__ps ) ;
#line 440
__inline extern  __attribute__((__nothrow__)) size_t wcrtomb(char *__s , wchar_t __wchar ,
                                                             mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 440 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t wcrtomb(char *__s , wchar_t __wchar , mbstate_t *__ps ) 
{ 
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
  {
#line 450
  __cil_tmp5 = __builtin_object_size((void const   *)__s, 1);
  }
  {
#line 450
  __cil_tmp4 = __builtin_object_size((void const   *)__s, 1);
  }
#line 450
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
#line 450
    if (16UL > __cil_tmp5) {
      {
#line 451
      __cil_tmp6 = __builtin_object_size((void const   *)__s, 1);
#line 451
      __cil_tmp7 = __wcrtomb_chk(__s, __wchar, __ps, __cil_tmp6);
      }
#line 451
      return (__cil_tmp7);
    }
  }
  {
#line 452
  __cil_tmp8 = __wcrtomb_alias(__s, __wchar, __ps);
  }
#line 452
  return (__cil_tmp8);
}
}
#line 456
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk(wchar_t *__dst , char const   **__src ,
                                                            size_t __len , mbstate_t *__ps ,
                                                            size_t __dstlen ) ;
#line 460
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_alias(wchar_t *__dst , char const   **__src ,
                                                              size_t __len , mbstate_t *__ps ) ;
#line 465
extern  __attribute__((__nothrow__)) size_t __mbsrtowcs_chk_warn(wchar_t *__dst ,
                                                                 char const   **__src ,
                                                                 size_t __len , mbstate_t *__ps ,
                                                                 size_t __dstlen ) ;
#line 474
__inline extern  __attribute__((__nothrow__)) size_t mbsrtowcs(wchar_t *__dst , char const   **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 474 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t mbsrtowcs(wchar_t *__dst , char const   **__src , size_t __len ,
                                 mbstate_t *__ps ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
  {
#line 477
  __cil_tmp5 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 477
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 479
    __cil_tmp6 = __builtin_constant_p(__len);
    }
#line 479
    if (! __cil_tmp6) {
      {
#line 480
      __cil_tmp7 = __builtin_object_size((void const   *)__dst, 1);
#line 480
      __cil_tmp8 = __mbsrtowcs_chk(__dst, __src, __len, __ps, __cil_tmp7 / sizeof(wchar_t ));
      }
#line 480
      return (__cil_tmp8);
    }
    {
#line 483
    __cil_tmp9 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 483
    if (__len > __cil_tmp9 / sizeof(wchar_t )) {
      {
#line 484
      __cil_tmp10 = __builtin_object_size((void const   *)__dst, 1);
#line 484
      __cil_tmp11 = __mbsrtowcs_chk_warn(__dst, __src, __len, __ps, __cil_tmp10 / sizeof(wchar_t ));
      }
#line 484
      return (__cil_tmp11);
    }
  }
  {
#line 487
  __cil_tmp12 = __mbsrtowcs_alias(__dst, __src, __len, __ps);
  }
#line 487
  return (__cil_tmp12);
}
}
#line 491
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk(char *__dst , wchar_t **__src ,
                                                            size_t __len , mbstate_t *__ps ,
                                                            size_t __dstlen ) ;
#line 495
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_alias(char *__dst , wchar_t **__src ,
                                                              size_t __len , mbstate_t *__ps ) ;
#line 500
extern  __attribute__((__nothrow__)) size_t __wcsrtombs_chk_warn(char *__dst , wchar_t **__src ,
                                                                 size_t __len , mbstate_t *__ps ,
                                                                 size_t __dstlen ) ;
#line 508
__inline extern  __attribute__((__nothrow__)) size_t wcsrtombs(char *__dst , wchar_t **__src ,
                                                               size_t __len , mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 508 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t wcsrtombs(char *__dst , wchar_t **__src , size_t __len , mbstate_t *__ps ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  size_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  size_t __cil_tmp11 ;
  size_t __cil_tmp12 ;

  {
  {
#line 511
  __cil_tmp5 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 511
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 513
    __cil_tmp6 = __builtin_constant_p(__len);
    }
#line 513
    if (! __cil_tmp6) {
      {
#line 514
      __cil_tmp7 = __builtin_object_size((void const   *)__dst, 1);
#line 514
      __cil_tmp8 = __wcsrtombs_chk(__dst, __src, __len, __ps, __cil_tmp7);
      }
#line 514
      return (__cil_tmp8);
    }
    {
#line 516
    __cil_tmp9 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 516
    if (__len > __cil_tmp9) {
      {
#line 517
      __cil_tmp10 = __builtin_object_size((void const   *)__dst, 1);
#line 517
      __cil_tmp11 = __wcsrtombs_chk_warn(__dst, __src, __len, __ps, __cil_tmp10);
      }
#line 517
      return (__cil_tmp11);
    }
  }
  {
#line 519
  __cil_tmp12 = __wcsrtombs_alias(__dst, __src, __len, __ps);
  }
#line 519
  return (__cil_tmp12);
}
}
#line 524
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk(wchar_t *__dst , char const   **__src ,
                                                             size_t __nmc , size_t __len ,
                                                             mbstate_t *__ps , size_t __dstlen ) ;
#line 528
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_alias(wchar_t *__dst , char const   **__src ,
                                                               size_t __nmc , size_t __len ,
                                                               mbstate_t *__ps ) ;
#line 533
extern  __attribute__((__nothrow__)) size_t __mbsnrtowcs_chk_warn(wchar_t *__dst ,
                                                                  char const   **__src ,
                                                                  size_t __nmc , size_t __len ,
                                                                  mbstate_t *__ps ,
                                                                  size_t __dstlen ) ;
#line 542
__inline extern  __attribute__((__nothrow__)) size_t mbsnrtowcs(wchar_t *__dst , char const   **__src ,
                                                                size_t __nmc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 542 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t mbsnrtowcs(wchar_t *__dst , char const   **__src , size_t __nmc ,
                                  size_t __len , mbstate_t *__ps ) 
{ 
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 545
  __cil_tmp6 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 545
  if (__cil_tmp6 != 0xffffffffffffffffUL) {
    {
#line 547
    __cil_tmp7 = __builtin_constant_p(__len);
    }
#line 547
    if (! __cil_tmp7) {
      {
#line 548
      __cil_tmp8 = __builtin_object_size((void const   *)__dst, 1);
#line 548
      __cil_tmp9 = __mbsnrtowcs_chk(__dst, __src, __nmc, __len, __ps, __cil_tmp8 / sizeof(wchar_t ));
      }
#line 548
      return (__cil_tmp9);
    }
    {
#line 551
    __cil_tmp10 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 551
    if (__len > __cil_tmp10 / sizeof(wchar_t )) {
      {
#line 552
      __cil_tmp11 = __builtin_object_size((void const   *)__dst, 1);
#line 552
      __cil_tmp12 = __mbsnrtowcs_chk_warn(__dst, __src, __nmc, __len, __ps, __cil_tmp11 / sizeof(wchar_t ));
      }
#line 552
      return (__cil_tmp12);
    }
  }
  {
#line 555
  __cil_tmp13 = __mbsnrtowcs_alias(__dst, __src, __nmc, __len, __ps);
  }
#line 555
  return (__cil_tmp13);
}
}
#line 559
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk(char *__dst , wchar_t **__src ,
                                                             size_t __nwc , size_t __len ,
                                                             mbstate_t *__ps , size_t __dstlen ) ;
#line 564
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_alias(char *__dst , wchar_t **__src ,
                                                               size_t __nwc , size_t __len ,
                                                               mbstate_t *__ps ) ;
#line 569
extern  __attribute__((__nothrow__)) size_t __wcsnrtombs_chk_warn(char *__dst , wchar_t **__src ,
                                                                  size_t __nwc , size_t __len ,
                                                                  mbstate_t *__ps ,
                                                                  size_t __dstlen ) ;
#line 578
__inline extern  __attribute__((__nothrow__)) size_t wcsnrtombs(char *__dst , wchar_t **__src ,
                                                                size_t __nwc , size_t __len ,
                                                                mbstate_t *__ps )  __attribute__((__gnu_inline__)) ;
#line 578 "/usr/include/x86_64-linux-gnu/bits/wchar2.h"
__inline extern size_t wcsnrtombs(char *__dst , wchar_t **__src , size_t __nwc , size_t __len ,
                                  mbstate_t *__ps ) 
{ 
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  size_t __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  unsigned long __cil_tmp11 ;
  size_t __cil_tmp12 ;
  size_t __cil_tmp13 ;

  {
  {
#line 581
  __cil_tmp6 = __builtin_object_size((void const   *)__dst, 1);
  }
#line 581
  if (__cil_tmp6 != 0xffffffffffffffffUL) {
    {
#line 583
    __cil_tmp7 = __builtin_constant_p(__len);
    }
#line 583
    if (! __cil_tmp7) {
      {
#line 584
      __cil_tmp8 = __builtin_object_size((void const   *)__dst, 1);
#line 584
      __cil_tmp9 = __wcsnrtombs_chk(__dst, __src, __nwc, __len, __ps, __cil_tmp8);
      }
#line 584
      return (__cil_tmp9);
    }
    {
#line 587
    __cil_tmp10 = __builtin_object_size((void const   *)__dst, 1);
    }
#line 587
    if (__len > __cil_tmp10) {
      {
#line 588
      __cil_tmp11 = __builtin_object_size((void const   *)__dst, 1);
#line 588
      __cil_tmp12 = __wcsnrtombs_chk_warn(__dst, __src, __nwc, __len, __ps, __cil_tmp11);
      }
#line 588
      return (__cil_tmp12);
    }
  }
  {
#line 591
  __cil_tmp13 = __wcsnrtombs_alias(__dst, __src, __nwc, __len, __ps);
  }
#line 591
  return (__cil_tmp13);
}
}
#line 158 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 192 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 1775 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/vasnprintf.c"
char *vasnprintf(char *resultbuf , size_t *lengthp , char const   *format , va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int *__cil_tmp9 ;
  size_t buf_neededlength ;
  char *buf ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  void *__cil_tmp20 ;
  size_t buf_memsize ;
  unsigned long tmp ;
  void *__cil_tmp23 ;
  size_t n ;
  size_t augmented_length ;
  size_t __cil_tmp26 ;
  size_t memory_size ;
  char *memory ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  size_t __cil_tmp34 ;
  char const   *__cil_tmp35 ;
  size_t augmented_length___0 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  size_t n___0 ;
  char const   *mp ;
  char *__cil_tmp61 ;
  char const   *__cil_tmp62 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *__cil_tmp65 ;
  char const   *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  unsigned int __cil_tmp70 ;
  unsigned int __cil_tmp71 ;
  size_t __cil_tmp72 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  size_t __cil_tmp77 ;
  unsigned long tmp___8 ;
  void *__cil_tmp80 ;
  void *__cil_tmp81 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int *__cil_tmp86 ;
  int arg___0 ;
  unsigned int arg___1 ;
  int arg___2 ;
  unsigned int arg___3 ;
  int arg___4 ;
  unsigned int arg___5 ;
  long arg___6 ;
  unsigned long arg___7 ;
  long long arg___8 ;
  unsigned long long arg___9 ;
  double arg___10 ;
  long double arg___11 ;
  int arg___12 ;
  wint_t arg___13 ;
  char const   *arg___14 ;
  wchar_t *arg___15 ;
  void *arg___16 ;
  int saved_errno ;
  int *__cil_tmp156 ;
  int *__cil_tmp157 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t n___2 ;
  size_t __cil_tmp161 ;
  unsigned long tmp___11 ;
  size_t __cil_tmp163 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___14 ;
  void *__cil_tmp169 ;
  void *__cil_tmp170 ;
  int *__cil_tmp171 ;
  size_t __cil_tmp172 ;
  char_directive *__cil_tmp173 ;
  size_t __cil_tmp174 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  size_t __cil_tmp179 ;
  unsigned long tmp___17 ;
  void *__cil_tmp182 ;
  void *__cil_tmp183 ;
  char *memory___4 ;
  void *__cil_tmp185 ;
  int *__cil_tmp186 ;
  int *__cil_tmp187 ;

  {
  {
#line 1781
  __cil_tmp7 = printf_parse(format, & d, & a);
  }
#line 1781
  if (__cil_tmp7 < 0) {
#line 1783
    return ((char *)((void *)0));
  }
  {
#line 1791
  __cil_tmp8 = printf_fetchargs(args, & a);
  }
#line 1791
  if (__cil_tmp8 < 0) {
#line 1793
    if (d.dir != (char_directive *)d.direct_alloc_dir) {
      {
#line 1793
      free((void *)d.dir);
      }
    }
#line 1793
    if (a.arg != (argument *)a.direct_alloc_arg) {
      {
#line 1793
      free((void *)a.arg);
      }
    }
    {
#line 1794
    __cil_tmp9 = __errno_location();
#line 1794
    *__cil_tmp9 = 22;
    }
#line 1795
    return ((char *)((void *)0));
  }
  {
#line 1812
  buf_neededlength = xsum4((size_t )7, d.max_width_length, d.max_precision_length,
                           (size_t )6);
  }
#line 1815
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1817
    __cil_tmp20 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1817
    buf = (char *)__cil_tmp20;
#line 1818
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1823
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1823
      tmp = buf_neededlength * sizeof(char );
    } else {
#line 1823
      tmp = 0xffffffffffffffffUL;
    }
#line 1823
    buf_memsize = tmp;
#line 1824
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1825
      goto out_of_memory_1;
    }
    {
#line 1826
    __cil_tmp23 = malloc(buf_memsize);
#line 1826
    buf = (char *)__cil_tmp23;
    }
#line 1827
    if (buf == (char *)((void *)0)) {
#line 1828
      goto out_of_memory_1;
    }
#line 1829
    buf_malloced = buf;
  }
#line 1832
  if (resultbuf != (char *)((void *)0)) {
#line 1834
    result = resultbuf;
#line 1835
    allocated = *lengthp;
  } else {
#line 1839
    result = (char *)((void *)0);
#line 1840
    allocated = (size_t )0;
  }
#line 1842
  length = (size_t )0;
#line 1872
  dp = & *(d.dir + 0);
#line 1872
  i = (size_t )0;
#line 1872
  cp = format;
  {
  {
#line 1872
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1872
    if (! 1) {
#line 1872
      goto while_break;
    }
#line 1874
    if (cp != dp->dir_start) {
      {
#line 1876
      n = (size_t )(dp->dir_start - cp);
#line 1877
      __cil_tmp26 = xsum(length, n);
#line 1877
      augmented_length = __cil_tmp26;
      }
#line 1879
      if (augmented_length > allocated) {
#line 1879
        if (allocated > 0UL) {
#line 1879
          if (allocated <= 9223372036854775807UL) {
#line 1879
            tmp___0 = allocated * 2UL;
          } else {
#line 1879
            tmp___0 = 0xffffffffffffffffUL;
          }
#line 1879
          tmp___1 = tmp___0;
        } else {
#line 1879
          tmp___1 = (unsigned long )12;
        }
#line 1879
        allocated = tmp___1;
#line 1879
        if (augmented_length > allocated) {
#line 1879
          allocated = augmented_length;
        }
#line 1879
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1879
          tmp___2 = allocated * sizeof(char );
        } else {
#line 1879
          tmp___2 = 0xffffffffffffffffUL;
        }
#line 1879
        memory_size = tmp___2;
#line 1879
        if (memory_size == 0xffffffffffffffffUL) {
#line 1879
          goto out_of_memory;
        }
#line 1879
        if (result == resultbuf) {
          {
          {
#line 1879
          __cil_tmp32 = malloc(memory_size);
          }
#line 1879
          memory = (char *)__cil_tmp32;
          }
        } else
#line 1879
        if (result == (char *)((void *)0)) {
          {
          {
#line 1879
          __cil_tmp32 = malloc(memory_size);
          }
#line 1879
          memory = (char *)__cil_tmp32;
          }
        } else {
          {
#line 1879
          __cil_tmp33 = realloc((void *)result, memory_size);
#line 1879
          memory = (char *)__cil_tmp33;
          }
        }
#line 1879
        if (memory == (char *)((void *)0)) {
#line 1879
          goto out_of_memory;
        }
#line 1879
        if (result == resultbuf) {
#line 1879
          if (length > 0UL) {
            {
#line 1879
            memcpy((void *)memory, (void const   *)result, length);
            }
          }
        }
#line 1879
        result = memory;
      }

#line 1883
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1885
        memcpy((void *)(result + length), (void const   *)cp, n);
#line 1886
        length = augmented_length;
        }
      } else {
        {
        {
#line 1890
        while (1) {
          while_continue___4: /* CIL Label */ ;

#line 1891
          __cil_tmp35 = cp;
#line 1891
          cp ++;
#line 1891
          __cil_tmp34 = length;
#line 1891
          length ++;
#line 1891
          *(result + __cil_tmp34) = (char )((unsigned char )((char )*__cil_tmp35));
#line 1890
          if (! (n > 0UL)) {
#line 1890
            goto while_break___0;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1895
    if (i == d.count) {
#line 1896
      goto while_break;
    }
#line 1899
    if ((int )dp->conversion == 37) {
#line 1903
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
#line 1904
        abort();
        }
      }
      {
#line 1905
      augmented_length___0 = xsum(length, (size_t )1);
      }
#line 1906
      if (augmented_length___0 > allocated) {
#line 1906
        if (allocated > 0UL) {
#line 1906
          if (allocated <= 9223372036854775807UL) {
#line 1906
            tmp___3 = allocated * 2UL;
          } else {
#line 1906
            tmp___3 = 0xffffffffffffffffUL;
          }
#line 1906
          tmp___4 = tmp___3;
        } else {
#line 1906
          tmp___4 = (unsigned long )12;
        }
#line 1906
        allocated = tmp___4;
#line 1906
        if (augmented_length___0 > allocated) {
#line 1906
          allocated = augmented_length___0;
        }
#line 1906
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1906
          tmp___5 = allocated * sizeof(char );
        } else {
#line 1906
          tmp___5 = 0xffffffffffffffffUL;
        }
#line 1906
        memory_size___0 = tmp___5;
#line 1906
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1906
          goto out_of_memory;
        }
#line 1906
        if (result == resultbuf) {
          {
          {
#line 1906
          __cil_tmp43 = malloc(memory_size___0);
          }
#line 1906
          memory___0 = (char *)__cil_tmp43;
          }
        } else
#line 1906
        if (result == (char *)((void *)0)) {
          {
          {
#line 1906
          __cil_tmp43 = malloc(memory_size___0);
          }
#line 1906
          memory___0 = (char *)__cil_tmp43;
          }
        } else {
          {
#line 1906
          __cil_tmp44 = realloc((void *)result, memory_size___0);
#line 1906
          memory___0 = (char *)__cil_tmp44;
          }
        }
#line 1906
        if (memory___0 == (char *)((void *)0)) {
#line 1906
          goto out_of_memory;
        }
#line 1906
        if (result == resultbuf) {
#line 1906
          if (length > 0UL) {
            {
#line 1906
            memcpy((void *)memory___0, (void const   *)result, length);
            }
          }
        }
#line 1906
        result = memory___0;
      }
#line 1907
      *(result + length) = (char )'%';
#line 1908
      length = augmented_length___0;
    } else {
#line 1912
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
#line 1913
        abort();
        }
      }
#line 1915
      if ((int )dp->conversion == 110) {
        {
#line 1919
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )18) {
#line 1919
          goto case_18;
        }
#line 1922
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )19) {
#line 1922
          goto case_19;
        }
#line 1925
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )20) {
#line 1925
          goto case_20;
        }
#line 1928
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )21) {
#line 1928
          goto case_21;
        }
#line 1932
        if ((unsigned int )(a.arg + dp->arg_index)->type == (unsigned int )22) {
#line 1932
          goto case_22;
        }
#line 1936
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1920
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1921
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1923
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1924
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1926
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1927
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1929
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1930
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1933
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1934
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1937
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4608
        type = (a.arg + dp->arg_index)->type;
#line 4609
        flags = dp->flags;
#line 4770
        fbp = buf;
#line 4771
        __cil_tmp51 = fbp;
#line 4771
        fbp ++;
#line 4771
        *__cil_tmp51 = (char )'%';
#line 4777
        if (flags & 1) {
#line 4778
          __cil_tmp52 = fbp;
#line 4778
          fbp ++;
#line 4778
          *__cil_tmp52 = (char )'\'';
        }
#line 4780
        if (flags & 2) {
#line 4781
          __cil_tmp53 = fbp;
#line 4781
          fbp ++;
#line 4781
          *__cil_tmp53 = (char )'-';
        }
#line 4782
        if (flags & 4) {
#line 4783
          __cil_tmp54 = fbp;
#line 4783
          fbp ++;
#line 4783
          *__cil_tmp54 = (char )'+';
        }
#line 4784
        if (flags & 8) {
#line 4785
          __cil_tmp55 = fbp;
#line 4785
          fbp ++;
#line 4785
          *__cil_tmp55 = (char )' ';
        }
#line 4786
        if (flags & 16) {
#line 4787
          __cil_tmp56 = fbp;
#line 4787
          fbp ++;
#line 4787
          *__cil_tmp56 = (char )'#';
        }
#line 4789
        if (flags & 64) {
#line 4790
          __cil_tmp57 = fbp;
#line 4790
          fbp ++;
#line 4790
          *__cil_tmp57 = (char )'I';
        }
#line 4792
        if (! 0) {
#line 4794
          if (flags & 32) {
#line 4795
            __cil_tmp58 = fbp;
#line 4795
            fbp ++;
#line 4795
            *__cil_tmp58 = (char )'0';
          }
#line 4796
          if (dp->width_start != dp->width_end) {
#line 4798
            n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4801
            if (sizeof(char ) == sizeof(char )) {
              {
#line 4803
              memcpy((void *)fbp, (void const   *)dp->width_start, n___0 * sizeof(char ));
#line 4804
              fbp += n___0;
              }
            } else {
#line 4808
              mp = dp->width_start;
              {
              {
#line 4809
              while (1) {
                while_continue___5: /* CIL Label */ ;

#line 4810
                __cil_tmp62 = mp;
#line 4810
                mp ++;
#line 4810
                __cil_tmp61 = fbp;
#line 4810
                fbp ++;
#line 4810
                *__cil_tmp61 = (char )((unsigned char )((char )*__cil_tmp62));
#line 4809
                if (! (n___0 > 0UL)) {
#line 4809
                  goto while_break___1;
                }
              }
              while_break___6: /* CIL Label */ ;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
          }
        }
#line 4815
        if (! 0) {
#line 4817
          if (dp->precision_start != dp->precision_end) {
#line 4819
            n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4822
            if (sizeof(char ) == sizeof(char )) {
              {
#line 4824
              memcpy((void *)fbp, (void const   *)dp->precision_start, n___1 * sizeof(char ));
#line 4825
              fbp += n___1;
              }
            } else {
#line 4829
              mp___0 = dp->precision_start;
              {
              {
#line 4830
              while (1) {
                while_continue___6: /* CIL Label */ ;

#line 4831
                __cil_tmp66 = mp___0;
#line 4831
                mp___0 ++;
#line 4831
                __cil_tmp65 = fbp;
#line 4831
                fbp ++;
#line 4831
                *__cil_tmp65 = (char )((unsigned char )((char )*__cil_tmp66));
#line 4830
                if (! (n___1 > 0UL)) {
#line 4830
                  goto while_break___2;
                }
              }
              while_break___7: /* CIL Label */ ;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 4841
        if ((unsigned int )type == (unsigned int )10) {
#line 4841
          goto case_10;
        }
#line 4841
        if ((unsigned int )type == (unsigned int )9) {
#line 4841
          goto case_10;
        }
#line 4858
        if ((unsigned int )type == (unsigned int )16) {
#line 4858
          goto case_16;
        }
#line 4858
        if ((unsigned int )type == (unsigned int )14) {
#line 4858
          goto case_16;
        }
#line 4858
        if ((unsigned int )type == (unsigned int )8) {
#line 4858
          goto case_16;
        }
#line 4858
        if ((unsigned int )type == (unsigned int )7) {
#line 4858
          goto case_16;
        }
#line 4862
        if ((unsigned int )type == (unsigned int )12) {
#line 4862
          goto case_12;
        }
#line 4865
        goto switch_default___0;
        case_10: /* CIL Label */ 
#line 4848
        __cil_tmp67 = fbp;
#line 4848
        fbp ++;
#line 4848
        *__cil_tmp67 = (char )'l';
        case_16: /* CIL Label */ 
#line 4860
        __cil_tmp68 = fbp;
#line 4860
        fbp ++;
#line 4860
        *__cil_tmp68 = (char )'l';
#line 4861
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4863
        __cil_tmp69 = fbp;
#line 4863
        fbp ++;
#line 4863
        *__cil_tmp69 = (char )'L';
#line 4864
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4866
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4873
        *fbp = dp->conversion;
#line 4904
        *(fbp + 1) = (char )'\000';
#line 4911
        prefix_count = (unsigned int )0;
#line 4912
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4914
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4915
            abort();
            }
          }
#line 4916
          __cil_tmp70 = prefix_count;
#line 4916
          prefix_count ++;
#line 4916
          prefixes[__cil_tmp70] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4918
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4920
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4921
            abort();
            }
          }
#line 4922
          __cil_tmp71 = prefix_count;
#line 4922
          prefix_count ++;
#line 4922
          prefixes[__cil_tmp71] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4934
        __cil_tmp72 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        }
#line 4934
        if (__cil_tmp72 > allocated) {
#line 4934
          if (allocated > 0UL) {
#line 4934
            if (allocated <= 9223372036854775807UL) {
#line 4934
              tmp___6 = allocated * 2UL;
            } else {
#line 4934
              tmp___6 = 0xffffffffffffffffUL;
            }
#line 4934
            tmp___7 = tmp___6;
          } else {
#line 4934
            tmp___7 = (unsigned long )12;
          }
          {
#line 4934
          allocated = tmp___7;
#line 4934
          __cil_tmp77 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          }
#line 4934
          if (__cil_tmp77 > allocated) {
            {
#line 4934
            allocated = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
            }
          }
#line 4934
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4934
            tmp___8 = allocated * sizeof(char );
          } else {
#line 4934
            tmp___8 = 0xffffffffffffffffUL;
          }
#line 4934
          memory_size___1 = tmp___8;
#line 4934
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4934
            goto out_of_memory;
          }
#line 4934
          if (result == resultbuf) {
            {
            {
#line 4934
            __cil_tmp80 = malloc(memory_size___1);
            }
#line 4934
            memory___1 = (char *)__cil_tmp80;
            }
          } else
#line 4934
          if (result == (char *)((void *)0)) {
            {
            {
#line 4934
            __cil_tmp80 = malloc(memory_size___1);
            }
#line 4934
            memory___1 = (char *)__cil_tmp80;
            }
          } else {
            {
#line 4934
            __cil_tmp81 = realloc((void *)result, memory_size___1);
#line 4934
            memory___1 = (char *)__cil_tmp81;
            }
          }
#line 4934
          if (memory___1 == (char *)((void *)0)) {
#line 4934
            goto out_of_memory;
          }
#line 4934
          if (result == resultbuf) {
#line 4934
            if (length > 0UL) {
              {
#line 4934
              memcpy((void *)memory___1, (void const   *)result, length);
              }
            }
          }
#line 4934
          result = memory___1;
        }
        {
#line 4939
        *(result + length) = (char )'\000';
#line 4942
        orig_errno = (int )__errno_location();
        }
        {
        {
#line 4944
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 4944
          if (! 1) {
#line 4944
            goto while_break___3;
          }
#line 4946
          count = - 1;
#line 4949
          retcount = 0;
#line 4950
          maxlen = allocated - length;
#line 4953
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4954
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
          {
#line 4955
          maxlen *= sizeof(char ) / sizeof(char );
#line 4997
          __cil_tmp86 = __errno_location();
#line 4997
          *__cil_tmp86 = 0;
          }
          {
#line 5000
          if ((unsigned int )type == (unsigned int )1) {
#line 5000
            goto case_1;
          }
#line 5003
          if ((unsigned int )type == (unsigned int )0) {
#line 5003
            goto case_0;
          }
#line 5003
          if ((unsigned int )type == (unsigned int )1) {
#line 5003
            goto case_1___0;
          }
#line 5003
          if ((unsigned int )type == (unsigned int )2) {
#line 5003
            goto case_2;
          }
#line 5006
          if ((unsigned int )type == (unsigned int )2) {
#line 5006
            goto case_2___0;
          }
#line 5009
          if ((unsigned int )type == (unsigned int )0) {
#line 5009
            goto case_0___0;
          }
#line 5009
          if ((unsigned int )type == (unsigned int )1) {
#line 5009
            goto case_1___1;
          }
#line 5009
          if ((unsigned int )type == (unsigned int )2) {
#line 5009
            goto case_2___1;
          }
#line 5012
          if ((unsigned int )type == (unsigned int )3) {
#line 5012
            goto case_3;
          }
#line 5015
          if ((unsigned int )type == (unsigned int )0) {
#line 5015
            goto case_0___1;
          }
#line 5015
          if ((unsigned int )type == (unsigned int )1) {
#line 5015
            goto case_1___2;
          }
#line 5015
          if ((unsigned int )type == (unsigned int )2) {
#line 5015
            goto case_2___2;
          }
#line 5018
          if ((unsigned int )type == (unsigned int )4) {
#line 5018
            goto case_4;
          }
#line 5021
          if ((unsigned int )type == (unsigned int )0) {
#line 5021
            goto case_0___2;
          }
#line 5021
          if ((unsigned int )type == (unsigned int )1) {
#line 5021
            goto case_1___3;
          }
#line 5021
          if ((unsigned int )type == (unsigned int )2) {
#line 5021
            goto case_2___3;
          }
#line 5024
          if ((unsigned int )type == (unsigned int )5) {
#line 5024
            goto case_5;
          }
#line 5027
          if ((unsigned int )type == (unsigned int )0) {
#line 5027
            goto case_0___3;
          }
#line 5027
          if ((unsigned int )type == (unsigned int )1) {
#line 5027
            goto case_1___4;
          }
#line 5027
          if ((unsigned int )type == (unsigned int )2) {
#line 5027
            goto case_2___4;
          }
#line 5030
          if ((unsigned int )type == (unsigned int )6) {
#line 5030
            goto case_6;
          }
#line 5033
          if ((unsigned int )type == (unsigned int )0) {
#line 5033
            goto case_0___4;
          }
#line 5033
          if ((unsigned int )type == (unsigned int )1) {
#line 5033
            goto case_1___5;
          }
#line 5033
          if ((unsigned int )type == (unsigned int )2) {
#line 5033
            goto case_2___5;
          }
#line 5036
          if ((unsigned int )type == (unsigned int )7) {
#line 5036
            goto case_7___0;
          }
#line 5039
          if ((unsigned int )type == (unsigned int )0) {
#line 5039
            goto case_0___5;
          }
#line 5039
          if ((unsigned int )type == (unsigned int )1) {
#line 5039
            goto case_1___6;
          }
#line 5039
          if ((unsigned int )type == (unsigned int )2) {
#line 5039
            goto case_2___6;
          }
#line 5042
          if ((unsigned int )type == (unsigned int )8) {
#line 5042
            goto case_8___0;
          }
#line 5045
          if ((unsigned int )type == (unsigned int )0) {
#line 5045
            goto case_0___6;
          }
#line 5045
          if ((unsigned int )type == (unsigned int )1) {
#line 5045
            goto case_1___7;
          }
#line 5045
          if ((unsigned int )type == (unsigned int )2) {
#line 5045
            goto case_2___7;
          }
#line 5049
          if ((unsigned int )type == (unsigned int )9) {
#line 5049
            goto case_9___0;
          }
#line 5052
          if ((unsigned int )type == (unsigned int )0) {
#line 5052
            goto case_0___7;
          }
#line 5052
          if ((unsigned int )type == (unsigned int )1) {
#line 5052
            goto case_1___8;
          }
#line 5052
          if ((unsigned int )type == (unsigned int )2) {
#line 5052
            goto case_2___8;
          }
#line 5055
          if ((unsigned int )type == (unsigned int )10) {
#line 5055
            goto case_10___0;
          }
#line 5058
          if ((unsigned int )type == (unsigned int )0) {
#line 5058
            goto case_0___8;
          }
#line 5058
          if ((unsigned int )type == (unsigned int )1) {
#line 5058
            goto case_1___9;
          }
#line 5058
          if ((unsigned int )type == (unsigned int )2) {
#line 5058
            goto case_2___9;
          }
#line 5062
          if ((unsigned int )type == (unsigned int )11) {
#line 5062
            goto case_11;
          }
#line 5065
          if ((unsigned int )type == (unsigned int )0) {
#line 5065
            goto case_0___9;
          }
#line 5065
          if ((unsigned int )type == (unsigned int )1) {
#line 5065
            goto case_1___10;
          }
#line 5065
          if ((unsigned int )type == (unsigned int )2) {
#line 5065
            goto case_2___10;
          }
#line 5068
          if ((unsigned int )type == (unsigned int )12) {
#line 5068
            goto case_12___0;
          }
#line 5071
          if ((unsigned int )type == (unsigned int )0) {
#line 5071
            goto case_0___10;
          }
#line 5071
          if ((unsigned int )type == (unsigned int )1) {
#line 5071
            goto case_1___11;
          }
#line 5071
          if ((unsigned int )type == (unsigned int )2) {
#line 5071
            goto case_2___11;
          }
#line 5074
          if ((unsigned int )type == (unsigned int )13) {
#line 5074
            goto case_13;
          }
#line 5077
          if ((unsigned int )type == (unsigned int )0) {
#line 5077
            goto case_0___11;
          }
#line 5077
          if ((unsigned int )type == (unsigned int )1) {
#line 5077
            goto case_1___12;
          }
#line 5077
          if ((unsigned int )type == (unsigned int )2) {
#line 5077
            goto case_2___12;
          }
#line 5081
          if ((unsigned int )type == (unsigned int )14) {
#line 5081
            goto case_14___0;
          }
#line 5084
          if ((unsigned int )type == (unsigned int )0) {
#line 5084
            goto case_0___12;
          }
#line 5084
          if ((unsigned int )type == (unsigned int )1) {
#line 5084
            goto case_1___13;
          }
#line 5084
          if ((unsigned int )type == (unsigned int )2) {
#line 5084
            goto case_2___13;
          }
#line 5088
          if ((unsigned int )type == (unsigned int )15) {
#line 5088
            goto case_15;
          }
#line 5091
          if ((unsigned int )type == (unsigned int )0) {
#line 5091
            goto case_0___13;
          }
#line 5091
          if ((unsigned int )type == (unsigned int )1) {
#line 5091
            goto case_1___14;
          }
#line 5091
          if ((unsigned int )type == (unsigned int )2) {
#line 5091
            goto case_2___14;
          }
#line 5095
          if ((unsigned int )type == (unsigned int )16) {
#line 5095
            goto case_16___0;
          }
#line 5098
          if ((unsigned int )type == (unsigned int )0) {
#line 5098
            goto case_0___14;
          }
#line 5098
          if ((unsigned int )type == (unsigned int )1) {
#line 5098
            goto case_1___15;
          }
#line 5098
          if ((unsigned int )type == (unsigned int )2) {
#line 5098
            goto case_2___15;
          }
#line 5102
          if ((unsigned int )type == (unsigned int )17) {
#line 5102
            goto case_17;
          }
#line 5105
          if ((unsigned int )type == (unsigned int )0) {
#line 5105
            goto case_0___15;
          }
#line 5105
          if ((unsigned int )type == (unsigned int )1) {
#line 5105
            goto case_1___16;
          }
#line 5105
          if ((unsigned int )type == (unsigned int )2) {
#line 5105
            goto case_2___16;
          }
#line 5108
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 5002
          arg___0 = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 5003
          if (prefix_count == (unsigned int )0) {
#line 5003
            goto case_0;
          }
#line 5003
          if (prefix_count == (unsigned int )1) {
#line 5003
            goto case_1___0;
          }
#line 5003
          if (prefix_count == (unsigned int )2) {
#line 5003
            goto case_2;
          }
#line 5003
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 5003
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___0,
                              & count);
          }
#line 5003
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 5003
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___0, & count);
          }
#line 5003
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 5003
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___0, & count);
          }
#line 5003
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 5003
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }

#line 5005
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 5008
          arg___1 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 5009
          if (prefix_count == (unsigned int )0) {
#line 5009
            goto case_0___0;
          }
#line 5009
          if (prefix_count == (unsigned int )1) {
#line 5009
            goto case_1___1;
          }
#line 5009
          if (prefix_count == (unsigned int )2) {
#line 5009
            goto case_2___1;
          }
#line 5009
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 5009
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___1,
                              & count);
          }
#line 5009
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 5009
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___1, & count);
          }
#line 5009
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 5009
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___1, & count);
          }
#line 5009
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 5009
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }

#line 5011
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 5014
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 5015
          if (prefix_count == (unsigned int )0) {
#line 5015
            goto case_0___1;
          }
#line 5015
          if (prefix_count == (unsigned int )1) {
#line 5015
            goto case_1___2;
          }
#line 5015
          if (prefix_count == (unsigned int )2) {
#line 5015
            goto case_2___2;
          }
#line 5015
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___2,
                              & count);
          }
#line 5015
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___2, & count);
          }
#line 5015
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 5015
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___2, & count);
          }
#line 5015
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 5015
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }

#line 5017
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 5020
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 5021
          if (prefix_count == (unsigned int )0) {
#line 5021
            goto case_0___2;
          }
#line 5021
          if (prefix_count == (unsigned int )1) {
#line 5021
            goto case_1___3;
          }
#line 5021
          if (prefix_count == (unsigned int )2) {
#line 5021
            goto case_2___3;
          }
#line 5021
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 5021
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___3,
                              & count);
          }
#line 5021
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 5021
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___3, & count);
          }
#line 5021
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 5021
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___3, & count);
          }
#line 5021
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 5021
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }

#line 5023
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 5026
          arg___4 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 5027
          if (prefix_count == (unsigned int )0) {
#line 5027
            goto case_0___3;
          }
#line 5027
          if (prefix_count == (unsigned int )1) {
#line 5027
            goto case_1___4;
          }
#line 5027
          if (prefix_count == (unsigned int )2) {
#line 5027
            goto case_2___4;
          }
#line 5027
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 5027
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___4,
                              & count);
          }
#line 5027
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 5027
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___4, & count);
          }
#line 5027
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 5027
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___4, & count);
          }
#line 5027
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 5027
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }

#line 5029
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 5032
          arg___5 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 5033
          if (prefix_count == (unsigned int )0) {
#line 5033
            goto case_0___4;
          }
#line 5033
          if (prefix_count == (unsigned int )1) {
#line 5033
            goto case_1___5;
          }
#line 5033
          if (prefix_count == (unsigned int )2) {
#line 5033
            goto case_2___5;
          }
#line 5033
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 5033
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___5,
                              & count);
          }
#line 5033
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 5033
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___5, & count);
          }
#line 5033
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 5033
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___5, & count);
          }
#line 5033
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 5033
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }

#line 5035
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 5038
          arg___6 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 5039
          if (prefix_count == (unsigned int )0) {
#line 5039
            goto case_0___5;
          }
#line 5039
          if (prefix_count == (unsigned int )1) {
#line 5039
            goto case_1___6;
          }
#line 5039
          if (prefix_count == (unsigned int )2) {
#line 5039
            goto case_2___6;
          }
#line 5039
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 5039
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___6,
                              & count);
          }
#line 5039
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 5039
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___6, & count);
          }
#line 5039
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 5039
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___6, & count);
          }
#line 5039
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 5039
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }

#line 5041
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 5044
          arg___7 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 5045
          if (prefix_count == (unsigned int )0) {
#line 5045
            goto case_0___6;
          }
#line 5045
          if (prefix_count == (unsigned int )1) {
#line 5045
            goto case_1___7;
          }
#line 5045
          if (prefix_count == (unsigned int )2) {
#line 5045
            goto case_2___7;
          }
#line 5045
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 5045
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___7,
                              & count);
          }
#line 5045
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 5045
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___7, & count);
          }
#line 5045
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 5045
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___7, & count);
          }
#line 5045
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 5045
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }

#line 5047
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 5051
          arg___8 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 5052
          if (prefix_count == (unsigned int )0) {
#line 5052
            goto case_0___7;
          }
#line 5052
          if (prefix_count == (unsigned int )1) {
#line 5052
            goto case_1___8;
          }
#line 5052
          if (prefix_count == (unsigned int )2) {
#line 5052
            goto case_2___8;
          }
#line 5052
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 5052
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___8,
                              & count);
          }
#line 5052
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 5052
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___8, & count);
          }
#line 5052
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 5052
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___8, & count);
          }
#line 5052
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 5052
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }

#line 5054
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 5057
          arg___9 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 5058
          if (prefix_count == (unsigned int )0) {
#line 5058
            goto case_0___8;
          }
#line 5058
          if (prefix_count == (unsigned int )1) {
#line 5058
            goto case_1___9;
          }
#line 5058
          if (prefix_count == (unsigned int )2) {
#line 5058
            goto case_2___9;
          }
#line 5058
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 5058
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___9,
                              & count);
          }
#line 5058
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 5058
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___9, & count);
          }
#line 5058
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 5058
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___9, & count);
          }
#line 5058
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 5058
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }

#line 5060
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 5064
          arg___10 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 5065
          if (prefix_count == (unsigned int )0) {
#line 5065
            goto case_0___9;
          }
#line 5065
          if (prefix_count == (unsigned int )1) {
#line 5065
            goto case_1___10;
          }
#line 5065
          if (prefix_count == (unsigned int )2) {
#line 5065
            goto case_2___10;
          }
#line 5065
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 5065
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___10,
                              & count);
          }
#line 5065
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 5065
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___10, & count);
          }
#line 5065
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 5065
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___10, & count);
          }
#line 5065
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 5065
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }

#line 5067
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 5070
          arg___11 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 5071
          if (prefix_count == (unsigned int )0) {
#line 5071
            goto case_0___10;
          }
#line 5071
          if (prefix_count == (unsigned int )1) {
#line 5071
            goto case_1___11;
          }
#line 5071
          if (prefix_count == (unsigned int )2) {
#line 5071
            goto case_2___11;
          }
#line 5071
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 5071
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___11,
                              & count);
          }
#line 5071
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 5071
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___11, & count);
          }
#line 5071
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 5071
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___11, & count);
          }
#line 5071
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 5071
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }

#line 5073
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5076
          arg___12 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5077
          if (prefix_count == (unsigned int )0) {
#line 5077
            goto case_0___11;
          }
#line 5077
          if (prefix_count == (unsigned int )1) {
#line 5077
            goto case_1___12;
          }
#line 5077
          if (prefix_count == (unsigned int )2) {
#line 5077
            goto case_2___12;
          }
#line 5077
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___12,
                              & count);
          }
#line 5077
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___12, & count);
          }
#line 5077
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___12, & count);
          }
#line 5077
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5077
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }

#line 5079
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5083
          arg___13 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5084
          if (prefix_count == (unsigned int )0) {
#line 5084
            goto case_0___12;
          }
#line 5084
          if (prefix_count == (unsigned int )1) {
#line 5084
            goto case_1___13;
          }
#line 5084
          if (prefix_count == (unsigned int )2) {
#line 5084
            goto case_2___13;
          }
#line 5084
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5084
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___13,
                              & count);
          }
#line 5084
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5084
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___13, & count);
          }
#line 5084
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5084
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___13, & count);
          }
#line 5084
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5084
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }

#line 5086
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5090
          arg___14 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5091
          if (prefix_count == (unsigned int )0) {
#line 5091
            goto case_0___13;
          }
#line 5091
          if (prefix_count == (unsigned int )1) {
#line 5091
            goto case_1___14;
          }
#line 5091
          if (prefix_count == (unsigned int )2) {
#line 5091
            goto case_2___14;
          }
#line 5091
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5091
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___14,
                              & count);
          }
#line 5091
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5091
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___14, & count);
          }
#line 5091
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5091
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___14, & count);
          }
#line 5091
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5091
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }

#line 5093
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5097
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5098
          if (prefix_count == (unsigned int )0) {
#line 5098
            goto case_0___14;
          }
#line 5098
          if (prefix_count == (unsigned int )1) {
#line 5098
            goto case_1___15;
          }
#line 5098
          if (prefix_count == (unsigned int )2) {
#line 5098
            goto case_2___15;
          }
#line 5098
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5098
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___15,
                              & count);
          }
#line 5098
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5098
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___15, & count);
          }
#line 5098
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5098
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___15, & count);
          }
#line 5098
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5098
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }

#line 5100
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5104
          arg___16 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5105
          if (prefix_count == (unsigned int )0) {
#line 5105
            goto case_0___15;
          }
#line 5105
          if (prefix_count == (unsigned int )1) {
#line 5105
            goto case_1___16;
          }
#line 5105
          if (prefix_count == (unsigned int )2) {
#line 5105
            goto case_2___16;
          }
#line 5105
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5105
          retcount = snprintf(result + length, maxlen, (char const   *)buf, arg___16,
                              & count);
          }
#line 5105
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5105
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              arg___16, & count);
          }
#line 5105
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5105
          retcount = snprintf(result + length, maxlen, (char const   *)buf, prefixes[0],
                              prefixes[1], arg___16, & count);
          }
#line 5105
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5105
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }

#line 5107
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5109
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5117
          if (count >= 0) {
#line 5121
            if ((unsigned long )count < maxlen) {
#line 5121
              if ((int )*((result + length) + count) != 0) {
                {
#line 5123
                abort();
                }
              }
            }
#line 5125
            if (retcount > count) {
#line 5126
              count = retcount;
            }
          } else
#line 5132
          if ((int )*(fbp + 1) != 0) {
#line 5136
            *(fbp + 1) = (char )'\000';
#line 5137
            goto while_continue___3;
          } else
#line 5142
          if (! (retcount < 0)) {
#line 5185
            count = retcount;
          }
#line 5191
          if (count < 0) {
            {
#line 5195
            __cil_tmp156 = __errno_location();
#line 5195
            saved_errno = *__cil_tmp156;
            }
#line 5197
            if (! (result == resultbuf || result == (char *)((void *)0))) {
              {
#line 5198
              free((void *)result);
              }
            }
#line 5199
            if (buf_malloced != (char *)((void *)0)) {
              {
#line 5200
              free((void *)buf_malloced);
              }
            }
#line 5201
            if (d.dir != (char_directive *)d.direct_alloc_dir) {
              {
#line 5201
              free((void *)d.dir);
              }
            }
#line 5201
            if (a.arg != (argument *)a.direct_alloc_arg) {
              {
#line 5201
              free((void *)a.arg);
              }
            }

#line 5202
            if (saved_errno != 0) {
#line 5202
              tmp___10 = saved_errno;
            } else {
#line 5202
              if ((int )dp->conversion == 99 || (int )dp->conversion == 115) {
#line 5202
                tmp___9 = 84;
              } else {
#line 5202
                tmp___9 = 22;
              }
#line 5202
              tmp___10 = tmp___9;
            }
            {
#line 5202
            __cil_tmp157 = __errno_location();
#line 5202
            *__cil_tmp157 = tmp___10;
            }
#line 5208
            return ((char *)((void *)0));
          }
#line 5217
          if ((unsigned long )((unsigned int )count + 1U) >= maxlen) {
#line 5222
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5223
              goto overflow;
            } else {
              {
#line 5235
              __cil_tmp161 = xsum(length, (((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
              }
#line 5235
              if (allocated <= 9223372036854775807UL) {
#line 5235
                tmp___11 = allocated * 2UL;
              } else {
#line 5235
                tmp___11 = 0xffffffffffffffffUL;
              }
              {
#line 5235
              __cil_tmp163 = xmax(__cil_tmp161, tmp___11);
#line 5235
              n___2 = __cil_tmp163;
              }
#line 5242
              if (n___2 > allocated) {
#line 5242
                if (allocated > 0UL) {
#line 5242
                  if (allocated <= 9223372036854775807UL) {
#line 5242
                    tmp___12 = allocated * 2UL;
                  } else {
#line 5242
                    tmp___12 = 0xffffffffffffffffUL;
                  }
#line 5242
                  tmp___13 = tmp___12;
                } else {
#line 5242
                  tmp___13 = (unsigned long )12;
                }
#line 5242
                allocated = tmp___13;
#line 5242
                if (n___2 > allocated) {
#line 5242
                  allocated = n___2;
                }
#line 5242
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5242
                  tmp___14 = allocated * sizeof(char );
                } else {
#line 5242
                  tmp___14 = 0xffffffffffffffffUL;
                }
#line 5242
                memory_size___2 = tmp___14;
#line 5242
                if (memory_size___2 == 0xffffffffffffffffUL) {
#line 5242
                  goto out_of_memory;
                }
#line 5242
                if (result == resultbuf) {
                  {
                  {
#line 5242
                  __cil_tmp169 = malloc(memory_size___2);
                  }
#line 5242
                  memory___2 = (char *)__cil_tmp169;
                  }
                } else
#line 5242
                if (result == (char *)((void *)0)) {
                  {
                  {
#line 5242
                  __cil_tmp169 = malloc(memory_size___2);
                  }
#line 5242
                  memory___2 = (char *)__cil_tmp169;
                  }
                } else {
                  {
#line 5242
                  __cil_tmp170 = realloc((void *)result, memory_size___2);
#line 5242
                  memory___2 = (char *)__cil_tmp170;
                  }
                }
#line 5242
                if (memory___2 == (char *)((void *)0)) {
#line 5242
                  goto out_of_memory;
                }
#line 5242
                if (result == resultbuf) {
#line 5242
                  if (length > 0UL) {
                    {
#line 5242
                    memcpy((void *)memory___2, (void const   *)result, length);
                    }
                  }
                }
#line 5242
                result = memory___2;
              }

#line 5243
              goto while_continue___3;
            }
          }
#line 5539
          length += (unsigned long )count;
#line 5540
          goto while_break___3;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 5542
        __cil_tmp171 = __errno_location();
#line 5542
        *__cil_tmp171 = orig_errno;
        }
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1872
  __cil_tmp173 = dp;
#line 1872
  dp ++;
#line 1872
  __cil_tmp172 = i;
#line 1872
  i ++;
  {
#line 1872
  cp = dp->dir_end;
#line 5550
  __cil_tmp174 = xsum(length, (size_t )1);
  }
#line 5550
  if (__cil_tmp174 > allocated) {
#line 5550
    if (allocated > 0UL) {
#line 5550
      if (allocated <= 9223372036854775807UL) {
#line 5550
        tmp___15 = allocated * 2UL;
      } else {
#line 5550
        tmp___15 = 0xffffffffffffffffUL;
      }
#line 5550
      tmp___16 = tmp___15;
    } else {
#line 5550
      tmp___16 = (unsigned long )12;
    }
    {
#line 5550
    allocated = tmp___16;
#line 5550
    __cil_tmp179 = xsum(length, (size_t )1);
    }
#line 5550
    if (__cil_tmp179 > allocated) {
      {
#line 5550
      allocated = xsum(length, (size_t )1);
      }
    }
#line 5550
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5550
      tmp___17 = allocated * sizeof(char );
    } else {
#line 5550
      tmp___17 = 0xffffffffffffffffUL;
    }
#line 5550
    memory_size___3 = tmp___17;
#line 5550
    if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5550
      goto out_of_memory;
    }
#line 5550
    if (result == resultbuf) {
      {
      {
#line 5550
      __cil_tmp182 = malloc(memory_size___3);
      }
#line 5550
      memory___3 = (char *)__cil_tmp182;
      }
    } else
#line 5550
    if (result == (char *)((void *)0)) {
      {
      {
#line 5550
      __cil_tmp182 = malloc(memory_size___3);
      }
#line 5550
      memory___3 = (char *)__cil_tmp182;
      }
    } else {
      {
#line 5550
      __cil_tmp183 = realloc((void *)result, memory_size___3);
#line 5550
      memory___3 = (char *)__cil_tmp183;
      }
    }
#line 5550
    if (memory___3 == (char *)((void *)0)) {
#line 5550
      goto out_of_memory;
    }
#line 5550
    if (result == resultbuf) {
#line 5550
      if (length > 0UL) {
        {
#line 5550
        memcpy((void *)memory___3, (void const   *)result, length);
        }
      }
    }
#line 5550
    result = memory___3;
  }
#line 5551
  *(result + length) = (char )'\000';
#line 5553
  if (result != resultbuf) {
#line 5553
    if (length + 1UL < allocated) {
      {
#line 5558
      __cil_tmp185 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5558
      memory___4 = (char *)__cil_tmp185;
      }
#line 5559
      if (memory___4 != (char *)((void *)0)) {
#line 5560
        result = memory___4;
      }
    }
  }
#line 5563
  if (buf_malloced != (char *)((void *)0)) {
    {
#line 5564
    free((void *)buf_malloced);
    }
  }
#line 5565
  if (d.dir != (char_directive *)d.direct_alloc_dir) {
    {
#line 5565
    free((void *)d.dir);
    }
  }
#line 5565
  if (a.arg != (argument *)a.direct_alloc_arg) {
    {
#line 5565
    free((void *)a.arg);
    }
  }
#line 5566
  *lengthp = length;
#line 5571
  return (result);
  overflow: 
#line 5575
  if (! (result == resultbuf || result == (char *)((void *)0))) {
    {
#line 5576
    free((void *)result);
    }
  }
#line 5577
  if (buf_malloced != (char *)((void *)0)) {
    {
#line 5578
    free((void *)buf_malloced);
    }
  }
#line 5579
  if (d.dir != (char_directive *)d.direct_alloc_dir) {
    {
#line 5579
    free((void *)d.dir);
    }
  }
#line 5579
  if (a.arg != (argument *)a.direct_alloc_arg) {
    {
#line 5579
    free((void *)a.arg);
    }
  }
  {
#line 5580
  __cil_tmp186 = __errno_location();
#line 5580
  *__cil_tmp186 = 75;
  }
#line 5581
  return ((char *)((void *)0));
  out_of_memory: 
#line 5585
  if (! (result == resultbuf || result == (char *)((void *)0))) {
    {
#line 5586
    free((void *)result);
    }
  }
#line 5587
  if (buf_malloced != (char *)((void *)0)) {
    {
#line 5588
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
#line 5590
  if (d.dir != (char_directive *)d.direct_alloc_dir) {
    {
#line 5590
    free((void *)d.dir);
    }
  }
#line 5590
  if (a.arg != (argument *)a.direct_alloc_arg) {
    {
#line 5590
    free((void *)a.arg);
    }
  }
  {
#line 5591
  __cil_tmp187 = __errno_location();
#line 5591
  *__cil_tmp187 = 12;
  }
#line 5592
  return ((char *)((void *)0));
}
}
#line 363 "/usr/include/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 379
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 407
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 514
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__)) ;
#line 528
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__)) ;
#line 626
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 692
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 777
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 811
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 822
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 859
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 880
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 898
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t __read_chk(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 25
extern ssize_t __read_alias(int __fd , void *__buf , size_t __nbytes ) ;
#line 27
extern ssize_t __read_chk_warn(int __fd , void *__buf , size_t __nbytes , size_t __buflen ) ;
#line 34
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes )  __attribute__((__gnu_inline__)) ;
#line 34 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 36
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 36
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 38
    __cil_tmp5 = __builtin_constant_p(__nbytes);
    }
#line 38
    if (! __cil_tmp5) {
      {
#line 39
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 0);
#line 39
      __cil_tmp7 = __read_chk(__fd, __buf, __nbytes, __cil_tmp6);
      }
#line 39
      return (__cil_tmp7);
    }
    {
#line 41
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 41
    if (__nbytes > __cil_tmp8) {
      {
#line 42
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
#line 42
      __cil_tmp10 = __read_chk_warn(__fd, __buf, __nbytes, __cil_tmp9);
      }
#line 42
      return (__cil_tmp10);
    }
  }
  {
#line 44
  __cil_tmp11 = __read_alias(__fd, __buf, __nbytes);
  }
#line 44
  return (__cil_tmp11);
}
}
#line 48
extern ssize_t __pread_chk(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                           size_t __bufsize ) ;
#line 50
extern ssize_t __pread64_chk(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                             size_t __bufsize ) ;
#line 52
extern ssize_t __pread_alias(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
#line 55
extern ssize_t __pread64_alias(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 58
extern ssize_t __pread_chk_warn(int __fd , void *__buf , size_t __nbytes , __off_t __offset ,
                                size_t __bufsize ) ;
#line 63
extern ssize_t __pread64_chk_warn(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ,
                                  size_t __bufsize ) ;
#line 72
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset )  __attribute__((__gnu_inline__)) ;
#line 72 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 74
  __cil_tmp5 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 74
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 76
    __cil_tmp6 = __builtin_constant_p(__nbytes);
    }
#line 76
    if (! __cil_tmp6) {
      {
#line 77
      __cil_tmp7 = __builtin_object_size((void const   *)__buf, 0);
#line 77
      __cil_tmp8 = __pread_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 77
      return (__cil_tmp8);
    }
    {
#line 79
    __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 79
    if (__nbytes > __cil_tmp9) {
      {
#line 80
      __cil_tmp10 = __builtin_object_size((void const   *)__buf, 0);
#line 80
      __cil_tmp11 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 80
      return (__cil_tmp11);
    }
  }
  {
#line 83
  __cil_tmp12 = __pread_alias(__fd, __buf, __nbytes, __offset);
  }
#line 83
  return (__cil_tmp12);
}
}
#line 105
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __attribute__((__gnu_inline__)) ;
#line 105 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 107
  __cil_tmp5 = __builtin_object_size((void const   *)__buf, 0);
  }
#line 107
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 109
    __cil_tmp6 = __builtin_constant_p(__nbytes);
    }
#line 109
    if (! __cil_tmp6) {
      {
#line 110
      __cil_tmp7 = __builtin_object_size((void const   *)__buf, 0);
#line 110
      __cil_tmp8 = __pread64_chk(__fd, __buf, __nbytes, __offset, __cil_tmp7);
      }
#line 110
      return (__cil_tmp8);
    }
    {
#line 112
    __cil_tmp9 = __builtin_object_size((void const   *)__buf, 0);
    }
#line 112
    if (__nbytes > __cil_tmp9) {
      {
#line 113
      __cil_tmp10 = __builtin_object_size((void const   *)__buf, 0);
#line 113
      __cil_tmp11 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, __cil_tmp10);
      }
#line 113
      return (__cil_tmp11);
    }
  }
  {
#line 117
  __cil_tmp12 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  }
#line 117
  return (__cil_tmp12);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk(char const   *__path ,
                                                            char *__buf , size_t __len ,
                                                            size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t __readlink_alias(char const   *__path ,
                                                              char *__buf , size_t __len ) ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t __readlink_chk_warn(char const   *__path ,
                                                                 char *__buf , size_t __len ,
                                                                 size_t __buflen ) ;
#line 139
__inline extern  __attribute__((__nothrow__)) ssize_t readlink(char const   *__path ,
                                                               char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlink(char const   *__path , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  ssize_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  ssize_t __cil_tmp10 ;
  ssize_t __cil_tmp11 ;

  {
  {
#line 142
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 142
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 144
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 144
    if (! __cil_tmp5) {
      {
#line 145
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 145
      __cil_tmp7 = __readlink_chk(__path, __buf, __len, __cil_tmp6);
      }
#line 145
      return (__cil_tmp7);
    }
    {
#line 147
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 147
    if (__len > __cil_tmp8) {
      {
#line 148
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 148
      __cil_tmp10 = __readlink_chk_warn(__path, __buf, __len, __cil_tmp9);
      }
#line 148
      return (__cil_tmp10);
    }
  }
  {
#line 150
  __cil_tmp11 = __readlink_alias(__path, __buf, __len);
  }
#line 150
  return (__cil_tmp11);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk(int __fd , char const   *__path ,
                                                              char *__buf , size_t __len ,
                                                              size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_alias(int __fd , char const   *__path ,
                                                                char *__buf , size_t __len ) ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t __readlinkat_chk_warn(int __fd , char const   *__path ,
                                                                   char *__buf , size_t __len ,
                                                                   size_t __buflen ) ;
#line 173
__inline extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   *__path ,
                                                                 char *__buf , size_t __len )  __attribute__((__gnu_inline__)) ;
#line 173 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t readlinkat(int __fd , char const   *__path , char *__buf ,
                                   size_t __len ) 
{ 
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  ssize_t __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  unsigned long __cil_tmp10 ;
  ssize_t __cil_tmp11 ;
  ssize_t __cil_tmp12 ;

  {
  {
#line 176
  __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 176
  if (__cil_tmp5 != 0xffffffffffffffffUL) {
    {
#line 178
    __cil_tmp6 = __builtin_constant_p(__len);
    }
#line 178
    if (! __cil_tmp6) {
      {
#line 179
      __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
#line 179
      __cil_tmp8 = __readlinkat_chk(__fd, __path, __buf, __len, __cil_tmp7);
      }
#line 179
      return (__cil_tmp8);
    }
    {
#line 181
    __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 181
    if (__len > __cil_tmp9) {
      {
#line 182
      __cil_tmp10 = __builtin_object_size((void const   *)__buf, 1);
#line 182
      __cil_tmp11 = __readlinkat_chk_warn(__fd, __path, __buf, __len, __cil_tmp10);
      }
#line 182
      return (__cil_tmp11);
    }
  }
  {
#line 185
  __cil_tmp12 = __readlinkat_alias(__fd, __path, __buf, __len);
  }
#line 185
  return (__cil_tmp12);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *__getcwd_chk(char *__buf , size_t __size ,
                                                        size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *__getcwd_alias(char *__buf , size_t __size ) ;
#line 193
extern  __attribute__((__nothrow__)) char *__getcwd_chk_warn(char *__buf , size_t __size ,
                                                             size_t __buflen ) ;
#line 200
__inline extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size )  __attribute__((__gnu_inline__)) ;
#line 200 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getcwd(char *__buf , size_t __size ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 202
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 202
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 204
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 204
    if (! __cil_tmp4) {
      {
#line 205
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 205
      __cil_tmp6 = __getcwd_chk(__buf, __size, __cil_tmp5);
      }
#line 205
      return (__cil_tmp6);
    }
    {
#line 207
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 207
    if (__size > __cil_tmp7) {
      {
#line 208
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 208
      __cil_tmp9 = __getcwd_chk_warn(__buf, __size, __cil_tmp8);
      }
#line 208
      return (__cil_tmp9);
    }
  }
  {
#line 210
  __cil_tmp10 = __getcwd_alias(__buf, __size);
  }
#line 210
  return (__cil_tmp10);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *__getwd_chk(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *__getwd_warn(char *__buf ) ;
#line 221
__inline extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__gnu_inline__)) ;
#line 221 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *getwd(char *__buf ) 
{ 
  unsigned long __cil_tmp2 ;
  unsigned long __cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 223
  __cil_tmp2 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 223
  if (__cil_tmp2 != 0xffffffffffffffffUL) {
    {
#line 224
    __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
#line 224
    __cil_tmp4 = __getwd_chk(__buf, __cil_tmp3);
    }
#line 224
    return (__cil_tmp4);
  }
  {
#line 225
  __cil_tmp5 = __getwd_warn(__buf);
  }
#line 225
  return (__cil_tmp5);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen ) ;
#line 240
__inline extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf ,
                                                             size_t __len )  __attribute__((__gnu_inline__)) ;
#line 240 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t confstr(int __name , char *__buf , size_t __len ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  size_t __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  size_t __cil_tmp10 ;
  size_t __cil_tmp11 ;

  {
  {
#line 242
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 242
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 244
    __cil_tmp5 = __builtin_constant_p(__len);
    }
#line 244
    if (! __cil_tmp5) {
      {
#line 245
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 245
      __cil_tmp7 = __confstr_chk(__name, __buf, __len, __cil_tmp6);
      }
#line 245
      return (__cil_tmp7);
    }
    {
#line 247
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 247
    if (__cil_tmp8 < __len) {
      {
#line 248
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 248
      __cil_tmp10 = __confstr_chk_warn(__name, __buf, __len, __cil_tmp9);
      }
#line 248
      return (__cil_tmp10);
    }
  }
  {
#line 250
  __cil_tmp11 = __confstr_alias(__name, __buf, __len);
  }
#line 250
  return (__cil_tmp11);
}
}
#line 254
extern  __attribute__((__nothrow__)) int __getgroups_chk(int __size , __gid_t __list[] ,
                                                         size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int __getgroups_alias(int __size , __gid_t __list[] ) ;
#line 258
extern  __attribute__((__nothrow__)) int __getgroups_chk_warn(int __size , __gid_t __list[] ,
                                                              size_t __listlen ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t __list[] )  __attribute__((__gnu_inline__)) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getgroups(int __size , __gid_t __list[] ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 267
  __cil_tmp3 = __builtin_object_size((void const   *)__list, 1);
  }
#line 267
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 269
    __cil_tmp4 = __builtin_constant_p(__size);
    }
#line 269
    if (! __cil_tmp4) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void const   *)__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    } else
#line 269
    if (__size < 0) {
      {
      {
#line 270
      __cil_tmp5 = __builtin_object_size((void const   *)__list, 1);
      }
      {
#line 270
      __cil_tmp6 = __getgroups_chk(__size, __list, __cil_tmp5);
      }
      }
#line 270
      return (__cil_tmp6);
    }
    {
#line 272
    __cil_tmp7 = __builtin_object_size((void const   *)__list, 1);
    }
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > __cil_tmp7) {
      {
#line 273
      __cil_tmp8 = __builtin_object_size((void const   *)__list, 1);
#line 273
      __cil_tmp9 = __getgroups_chk_warn(__size, __list, __cil_tmp8);
      }
#line 273
      return (__cil_tmp9);
    }
  }
  {
#line 275
  __cil_tmp10 = __getgroups_alias(__size, __list);
  }
#line 275
  return (__cil_tmp10);
}
}
#line 279
extern  __attribute__((__nothrow__)) int __ttyname_r_chk(int __fd , char *__buf ,
                                                         size_t __buflen , size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int __ttyname_r_alias(int __fd , char *__buf ,
                                                           size_t __buflen ) ;
#line 284
extern  __attribute__((__nothrow__)) int __ttyname_r_chk_warn(int __fd , char *__buf ,
                                                              size_t __buflen , size_t __nreal ) ;
#line 291
__inline extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf ,
                                                            size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 291 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ttyname_r(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp4 ;
  int __cil_tmp5 ;
  unsigned long __cil_tmp6 ;
  int __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  unsigned long __cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp11 ;

  {
  {
#line 293
  __cil_tmp4 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 293
  if (__cil_tmp4 != 0xffffffffffffffffUL) {
    {
#line 295
    __cil_tmp5 = __builtin_constant_p(__buflen);
    }
#line 295
    if (! __cil_tmp5) {
      {
#line 296
      __cil_tmp6 = __builtin_object_size((void const   *)__buf, 1);
#line 296
      __cil_tmp7 = __ttyname_r_chk(__fd, __buf, __buflen, __cil_tmp6);
      }
#line 296
      return (__cil_tmp7);
    }
    {
#line 298
    __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 298
    if (__buflen > __cil_tmp8) {
      {
#line 299
      __cil_tmp9 = __builtin_object_size((void const   *)__buf, 1);
#line 299
      __cil_tmp10 = __ttyname_r_chk_warn(__fd, __buf, __buflen, __cil_tmp9);
      }
#line 299
      return (__cil_tmp10);
    }
  }
  {
#line 301
  __cil_tmp11 = __ttyname_r_alias(__fd, __buf, __buflen);
  }
#line 301
  return (__cil_tmp11);
}
}
#line 306
extern int __getlogin_r_chk(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 308
extern int __getlogin_r_alias(char *__buf , size_t __buflen ) ;
#line 310
extern int __getlogin_r_chk_warn(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 317
__inline extern int getlogin_r(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 317 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getlogin_r(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 319
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 319
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 321
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 321
    if (! __cil_tmp4) {
      {
#line 322
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 322
      __cil_tmp6 = __getlogin_r_chk(__buf, __buflen, __cil_tmp5);
      }
#line 322
      return (__cil_tmp6);
    }
    {
#line 324
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 324
    if (__buflen > __cil_tmp7) {
      {
#line 325
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 325
      __cil_tmp9 = __getlogin_r_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 325
      return (__cil_tmp9);
    }
  }
  {
#line 327
  __cil_tmp10 = __getlogin_r_alias(__buf, __buflen);
  }
#line 327
  return (__cil_tmp10);
}
}
#line 333
extern  __attribute__((__nothrow__)) int __gethostname_chk(char *__buf , size_t __buflen ,
                                                           size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int __gethostname_alias(char *__buf , size_t __buflen ) ;
#line 337
extern  __attribute__((__nothrow__)) int __gethostname_chk_warn(char *__buf , size_t __buflen ,
                                                                size_t __nreal ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int gethostname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 344 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int gethostname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 346
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 346
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 348
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 348
    if (! __cil_tmp4) {
      {
#line 349
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 349
      __cil_tmp6 = __gethostname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 349
      return (__cil_tmp6);
    }
    {
#line 351
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 351
    if (__buflen > __cil_tmp7) {
      {
#line 352
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 352
      __cil_tmp9 = __gethostname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 352
      return (__cil_tmp9);
    }
  }
  {
#line 354
  __cil_tmp10 = __gethostname_alias(__buf, __buflen);
  }
#line 354
  return (__cil_tmp10);
}
}
#line 360
extern  __attribute__((__nothrow__)) int __getdomainname_chk(char *__buf , size_t __buflen ,
                                                             size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int __getdomainname_alias(char *__buf , size_t __buflen ) ;
#line 365
extern  __attribute__((__nothrow__)) int __getdomainname_chk_warn(char *__buf , size_t __buflen ,
                                                                  size_t __nreal ) ;
#line 373
__inline extern  __attribute__((__nothrow__)) int getdomainname(char *__buf , size_t __buflen )  __attribute__((__gnu_inline__)) ;
#line 373 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int getdomainname(char *__buf , size_t __buflen ) 
{ 
  unsigned long __cil_tmp3 ;
  int __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  int __cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  unsigned long __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 375
  __cil_tmp3 = __builtin_object_size((void const   *)__buf, 1);
  }
#line 375
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 377
    __cil_tmp4 = __builtin_constant_p(__buflen);
    }
#line 377
    if (! __cil_tmp4) {
      {
#line 378
      __cil_tmp5 = __builtin_object_size((void const   *)__buf, 1);
#line 378
      __cil_tmp6 = __getdomainname_chk(__buf, __buflen, __cil_tmp5);
      }
#line 378
      return (__cil_tmp6);
    }
    {
#line 380
    __cil_tmp7 = __builtin_object_size((void const   *)__buf, 1);
    }
#line 380
    if (__buflen > __cil_tmp7) {
      {
#line 381
      __cil_tmp8 = __builtin_object_size((void const   *)__buf, 1);
#line 381
      __cil_tmp9 = __getdomainname_chk_warn(__buf, __buflen, __cil_tmp8);
      }
#line 381
      return (__cil_tmp9);
    }
  }
  {
#line 383
  __cil_tmp10 = __getdomainname_alias(__buf, __buflen);
  }
#line 383
  return (__cil_tmp10);
}
}
#line 42 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/dirname.h"
size_t base_len(char const   *name ) ;
#line 44
char *last_component(char const   *name ) ;
#line 46
int strip_trailing_slashes(char *file ) ;
#line 33 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/stripslash.c"
int strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *__cil_tmp3 ;
  char *base_lim ;
  int had_slash ;
  size_t __cil_tmp6 ;

  {
  {
#line 35
  __cil_tmp3 = last_component((char const   *)file);
#line 35
  base = __cil_tmp3;
  }
#line 41
  if (! *base) {
#line 42
    base = file;
  }
  {
#line 43
  __cil_tmp6 = base_len((char const   *)base);
#line 43
  base_lim = base + __cil_tmp6;
#line 44
  had_slash = (int )*base_lim != 0;
#line 45
  *base_lim = (char )'\000';
  }
#line 46
  return (had_slash);
}
}
#line 34 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/progname.h"
char const   *program_name ;
#line 39
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern _IO_FILE *stderr ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n ) ;
#line 252
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c ) ;
#line 35 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 41 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *__cil_tmp4 ;
  char const   *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 53
  if (argv0 == (char const   *)((void *)0)) {
    {
#line 56
    fputs((char const   *)((char *)"A NULL argv[0] was passed through an exec system call.\n"),
          stderr);
#line 58
    abort();
    }
  }
  {
#line 61
  __cil_tmp4 = strrchr(argv0, '/');
#line 61
  slash = (char const   *)__cil_tmp4;
  }
#line 62
  if (slash != (char const   *)((void *)0)) {
#line 62
    tmp = slash + 1;
  } else {
#line 62
    tmp = argv0;
  }
  {
#line 62
  base = tmp;
#line 63
  __cil_tmp6 = strncmp(base - 7, (char const   *)((char *)"/.libs/"), (unsigned long )7);
  }
#line 63
  if (base - argv0 >= 7L) {
#line 63
    if (__cil_tmp6 == 0) {
      {
#line 65
      argv0 = base;
#line 66
      __cil_tmp7 = strncmp(base, (char const   *)((char *)"lt-"), (unsigned long )3);
      }
#line 66
      if (__cil_tmp7 == 0) {
#line 68
        argv0 = base + 3;
#line 72
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 86
  program_name = argv0;
#line 92
  program_invocation_name = (char *)argv0;
}
}
#line 85 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *__cil_tmp11 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  unsigned long tmp ;
  size_t __cil_tmp18 ;
  char const   *np___0 ;
  size_t n___0 ;
  unsigned long tmp___0 ;
  size_t __cil_tmp32 ;
  size_t __cil_tmp34 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  unsigned long tmp___1 ;
  unsigned long tmp___12 ;
  void *__cil_tmp41 ;
  void *__cil_tmp42 ;
  void *tmp___13 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  unsigned long tmp___14 ;
  size_t __cil_tmp53 ;
  size_t __cil_tmp55 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  void *__cil_tmp62 ;
  void *__cil_tmp63 ;
  void *tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *__cil_tmp76 ;
  size_t __cil_tmp77 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  unsigned long tmp___18 ;
  unsigned long tmp___19 ;
  void *__cil_tmp84 ;
  void *__cil_tmp85 ;
  void *tmp___20 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  unsigned long tmp___21 ;
  unsigned long tmp___22 ;
  void *__cil_tmp93 ;
  void *__cil_tmp94 ;
  void *tmp___23 ;
  int *__cil_tmp96 ;
  int *__cil_tmp97 ;

  {
#line 87
  cp = format;
#line 88
  arg_posn = (size_t )0;
#line 91
  max_width_length = (size_t )0;
#line 92
  max_precision_length = (size_t )0;
#line 94
  d->count = (size_t )0;
#line 95
  d_allocated = (size_t )7;
#line 96
  d->dir = (char_directive *)d->direct_alloc_dir;
#line 98
  a->count = (size_t )0;
#line 99
  a_allocated = (size_t )7;
#line 100
  a->arg = (argument *)a->direct_alloc_arg;
  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;

#line 136
    if (! ((int )((char )*cp) != 0)) {
#line 136
      goto while_break;
    }
#line 138
    __cil_tmp11 = cp;
#line 138
    cp ++;
#line 138
    c = (char )*__cil_tmp11;
#line 139
    if ((int )c == 37) {
#line 141
      arg_index = ~ ((size_t )0);
#line 142
      dp = & *(d->dir + d->count);
#line 145
      dp->dir_start = cp - 1;
#line 146
      dp->flags = 0;
#line 147
      dp->width_start = (char const   *)((void *)0);
#line 148
      dp->width_end = (char const   *)((void *)0);
#line 149
      dp->width_arg_index = ~ ((size_t )0);
#line 150
      dp->precision_start = (char const   *)((void *)0);
#line 151
      dp->precision_end = (char const   *)((void *)0);
#line 152
      dp->precision_arg_index = ~ ((size_t )0);
#line 153
      dp->arg_index = ~ ((size_t )0);
#line 156
      if ((int )((char )*cp) >= 48) {
#line 156
        if ((int )((char )*cp) <= 57) {
#line 160
          np = cp;
          {
          {
#line 160
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 160
            if (! ((int )((char )*np) >= 48 && (int )((char )*np) <= 57)) {
#line 160
              goto while_break___0;
            }

          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 160
          np ++;
#line 162
          if ((int )((char )*np) == 36) {
#line 164
            n = (size_t )0;
#line 166
            np = cp;
            {
            {
#line 166
            while (1) {
              while_continue___1: /* CIL Label */ ;

#line 166
              if (! ((int )((char )*np) >= 48 && (int )((char )*np) <= 57)) {
#line 166
                goto while_break___1;
              }
#line 167
              if (n <= 1844674407370955161UL) {
#line 167
                tmp = n * 10UL;
              } else {
#line 167
                tmp = 0xffffffffffffffffUL;
              }
              {
#line 167
              __cil_tmp18 = xsum(tmp, (size_t )((int )((char )*np) - 48));
#line 167
              n = __cil_tmp18;
              }
            }
            while_break___15: /* CIL Label */ ;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 166
            np ++;
#line 168
            if (n == 0UL) {
#line 170
              goto error;
            }
#line 171
            if (n == 0xffffffffffffffffUL) {
#line 173
              goto error;
            }
#line 174
            arg_index = n - 1UL;
#line 175
            cp = np + 1;
          }
        }
      }
      {
      {
#line 180
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 180
        if (! 1) {
#line 180
          goto while_break___2;
        }
#line 182
        if ((int )((char )*cp) == 39) {
#line 184
          dp->flags |= 1;
#line 185
          cp ++;
        } else
#line 187
        if ((int )((char )*cp) == 45) {
#line 189
          dp->flags |= 2;
#line 190
          cp ++;
        } else
#line 192
        if ((int )((char )*cp) == 43) {
#line 194
          dp->flags |= 4;
#line 195
          cp ++;
        } else
#line 197
        if ((int )((char )*cp) == 32) {
#line 199
          dp->flags |= 8;
#line 200
          cp ++;
        } else
#line 202
        if ((int )((char )*cp) == 35) {
#line 204
          dp->flags |= 16;
#line 205
          cp ++;
        } else
#line 207
        if ((int )((char )*cp) == 48) {
#line 209
          dp->flags |= 32;
#line 210
          cp ++;
        } else
#line 213
        if ((int )((char )*cp) == 73) {
#line 215
          dp->flags |= 64;
#line 216
          cp ++;
        } else {
#line 220
          goto while_break___2;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 224
      if ((int )((char )*cp) == 42) {
#line 226
        dp->width_start = cp;
#line 227
        cp ++;
#line 228
        dp->width_end = cp;
#line 229
        if (max_width_length < 1UL) {
#line 230
          max_width_length = (size_t )1;
        }
#line 233
        if ((int )((char )*cp) >= 48) {
#line 233
          if ((int )((char )*cp) <= 57) {
#line 237
            np___0 = cp;
            {
            {
#line 237
            while (1) {
              while_continue___3: /* CIL Label */ ;

#line 237
              if (! ((int )((char )*np___0) >= 48 && (int )((char )*np___0) <= 57)) {
#line 237
                goto while_break___3;
              }

            }
            while_break___17: /* CIL Label */ ;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 237
            np___0 ++;
#line 239
            if ((int )((char )*np___0) == 36) {
#line 241
              n___0 = (size_t )0;
#line 243
              np___0 = cp;
              {
              {
#line 243
              while (1) {
                while_continue___4: /* CIL Label */ ;

#line 243
                if (! ((int )((char )*np___0) >= 48 && (int )((char )*np___0) <= 57)) {
#line 243
                  goto while_break___4;
                }
#line 244
                if (n___0 <= 1844674407370955161UL) {
#line 244
                  tmp___0 = n___0 * 10UL;
                } else {
#line 244
                  tmp___0 = 0xffffffffffffffffUL;
                }
                {
#line 244
                __cil_tmp32 = xsum(tmp___0, (size_t )((int )((char )*np___0) - 48));
#line 244
                n___0 = __cil_tmp32;
                }
              }
              while_break___18: /* CIL Label */ ;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 243
              np___0 ++;
#line 245
              if (n___0 == 0UL) {
#line 247
                goto error;
              }
#line 248
              if (n___0 == 0xffffffffffffffffUL) {
#line 250
                goto error;
              }
#line 251
              dp->width_arg_index = n___0 - 1UL;
#line 252
              cp = np___0 + 1;
            }
          }
        }
#line 255
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 257
          __cil_tmp34 = arg_posn;
#line 257
          arg_posn ++;
#line 257
          dp->width_arg_index = __cil_tmp34;
#line 258
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 260
            goto error;
          }
        }
#line 262
        n___1 = dp->width_arg_index;
#line 262
        if (n___1 >= a_allocated) {
#line 262
          if (a_allocated <= 9223372036854775807UL) {
#line 262
            tmp___1 = a_allocated * 2UL;
          } else {
#line 262
            tmp___1 = 0xffffffffffffffffUL;
          }
#line 262
          a_allocated = tmp___1;
#line 262
          if (a_allocated <= n___1) {
            {
#line 262
            a_allocated = xsum(n___1, (size_t )1);
            }
          }
#line 262
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 262
            tmp___12 = a_allocated * sizeof(argument );
          } else {
#line 262
            tmp___12 = 0xffffffffffffffffUL;
          }
#line 262
          memory_size = tmp___12;
#line 262
          if (memory_size == 0xffffffffffffffffUL) {
#line 262
            goto out_of_memory;
          }
#line 262
          if (a->arg != (argument *)a->direct_alloc_arg) {
            {
#line 262
            __cil_tmp41 = realloc((void *)a->arg, memory_size);
#line 262
            tmp___13 = __cil_tmp41;
            }
          } else {
            {
#line 262
            __cil_tmp42 = malloc(memory_size);
#line 262
            tmp___13 = __cil_tmp42;
            }
          }
#line 262
          memory = (argument *)tmp___13;
#line 262
          if (memory == (argument *)((void *)0)) {
#line 262
            goto out_of_memory;
          }
#line 262
          if (a->arg == (argument *)a->direct_alloc_arg) {
            {
#line 262
            memcpy((void *)memory, (void const   *)a->arg, a->count * sizeof(argument ));
            }
          }
#line 262
          a->arg = memory;
        }
        {
        {
#line 262
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 262
          if (! (a->count <= n___1)) {
#line 262
            goto while_break___5;
          }
#line 262
          (a->arg + a->count)->type = (arg_type )0;
        }
        while_break___19: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 262
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 262
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 262
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 262
          goto error;
        }

      } else
#line 264
      if ((int )((char )*cp) >= 48) {
#line 264
        if ((int )((char )*cp) <= 57) {
#line 268
          dp->width_start = cp;
          {
          {
#line 269
          while (1) {
            while_continue___6: /* CIL Label */ ;

#line 269
            if (! ((int )((char )*cp) >= 48 && (int )((char )*cp) <= 57)) {
#line 269
              goto while_break___6;
            }

          }
          while_break___20: /* CIL Label */ ;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 269
          cp ++;
#line 271
          dp->width_end = cp;
#line 272
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 273
          if (max_width_length < width_length) {
#line 274
            max_width_length = width_length;
          }
        }
      }
#line 278
      if ((int )((char )*cp) == 46) {
#line 280
        cp ++;
#line 281
        if ((int )((char )*cp) == 42) {
#line 283
          dp->precision_start = cp - 1;
#line 284
          cp ++;
#line 285
          dp->precision_end = cp;
#line 286
          if (max_precision_length < 2UL) {
#line 287
            max_precision_length = (size_t )2;
          }
#line 290
          if ((int )((char )*cp) >= 48) {
#line 290
            if ((int )((char )*cp) <= 57) {
#line 294
              np___1 = cp;
              {
              {
#line 294
              while (1) {
                while_continue___7: /* CIL Label */ ;

#line 294
                if (! ((int )((char )*np___1) >= 48 && (int )((char )*np___1) <= 57)) {
#line 294
                  goto while_break___7;
                }

              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 294
              np___1 ++;
#line 296
              if ((int )((char )*np___1) == 36) {
#line 298
                n___2 = (size_t )0;
#line 300
                np___1 = cp;
                {
                {
#line 300
                while (1) {
                  while_continue___8: /* CIL Label */ ;

#line 300
                  if (! ((int )((char )*np___1) >= 48 && (int )((char )*np___1) <= 57)) {
#line 300
                    goto while_break___8;
                  }
#line 301
                  if (n___2 <= 1844674407370955161UL) {
#line 301
                    tmp___14 = n___2 * 10UL;
                  } else {
#line 301
                    tmp___14 = 0xffffffffffffffffUL;
                  }
                  {
#line 301
                  __cil_tmp53 = xsum(tmp___14, (size_t )((int )((char )*np___1) - 48));
#line 301
                  n___2 = __cil_tmp53;
                  }
                }
                while_break___22: /* CIL Label */ ;
                }
                while_break___8: /* CIL Label */ ;
                }
#line 300
                np___1 ++;
#line 302
                if (n___2 == 0UL) {
#line 304
                  goto error;
                }
#line 305
                if (n___2 == 0xffffffffffffffffUL) {
#line 308
                  goto error;
                }
#line 309
                dp->precision_arg_index = n___2 - 1UL;
#line 310
                cp = np___1 + 1;
              }
            }
          }
#line 313
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 315
            __cil_tmp55 = arg_posn;
#line 315
            arg_posn ++;
#line 315
            dp->precision_arg_index = __cil_tmp55;
#line 316
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 318
              goto error;
            }
          }
#line 320
          n___3 = dp->precision_arg_index;
#line 320
          if (n___3 >= a_allocated) {
#line 320
            if (a_allocated <= 9223372036854775807UL) {
#line 320
              tmp___15 = a_allocated * 2UL;
            } else {
#line 320
              tmp___15 = 0xffffffffffffffffUL;
            }
#line 320
            a_allocated = tmp___15;
#line 320
            if (a_allocated <= n___3) {
              {
#line 320
              a_allocated = xsum(n___3, (size_t )1);
              }
            }
#line 320
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 320
              tmp___16 = a_allocated * sizeof(argument );
            } else {
#line 320
              tmp___16 = 0xffffffffffffffffUL;
            }
#line 320
            memory_size___0 = tmp___16;
#line 320
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 320
              goto out_of_memory;
            }
#line 320
            if (a->arg != (argument *)a->direct_alloc_arg) {
              {
#line 320
              __cil_tmp62 = realloc((void *)a->arg, memory_size___0);
#line 320
              tmp___17 = __cil_tmp62;
              }
            } else {
              {
#line 320
              __cil_tmp63 = malloc(memory_size___0);
#line 320
              tmp___17 = __cil_tmp63;
              }
            }
#line 320
            memory___0 = (argument *)tmp___17;
#line 320
            if (memory___0 == (argument *)((void *)0)) {
#line 320
              goto out_of_memory;
            }
#line 320
            if (a->arg == (argument *)a->direct_alloc_arg) {
              {
#line 320
              memcpy((void *)memory___0, (void const   *)a->arg, a->count * sizeof(argument ));
              }
            }
#line 320
            a->arg = memory___0;
          }
          {
          {
#line 320
          while (1) {
            while_continue___9: /* CIL Label */ ;

#line 320
            if (! (a->count <= n___3)) {
#line 320
              goto while_break___9;
            }
#line 320
            (a->arg + a->count)->type = (arg_type )0;
          }
          while_break___23: /* CIL Label */ ;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 320
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 320
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 320
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 320
            goto error;
          }

        } else {
#line 326
          dp->precision_start = cp - 1;
          {
          {
#line 327
          while (1) {
            while_continue___10: /* CIL Label */ ;

#line 327
            if (! ((int )((char )*cp) >= 48 && (int )((char )*cp) <= 57)) {
#line 327
              goto while_break___10;
            }

          }
          while_break___24: /* CIL Label */ ;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 327
          cp ++;
#line 329
          dp->precision_end = cp;
#line 330
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 331
          if (max_precision_length < precision_length) {
#line 332
            max_precision_length = precision_length;
          }
        }
      }
#line 341
      flags = 0;
      {
      {
#line 343
      while (1) {
        while_continue___11: /* CIL Label */ ;

#line 343
        if (! 1) {
#line 343
          goto while_break___11;
        }
#line 345
        if ((int )((char )*cp) == 104) {
#line 347
          flags |= 1 << (flags & 1);
#line 348
          cp ++;
        } else
#line 350
        if ((int )((char )*cp) == 76) {
#line 352
          flags |= 4;
#line 353
          cp ++;
        } else
#line 355
        if ((int )((char )*cp) == 108) {
#line 357
          flags += 8;
#line 358
          cp ++;
        } else
#line 360
        if ((int )((char )*cp) == 106) {
#line 362
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 365
            flags += 16;
          } else
#line 367
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 370
            flags += 8;
          }
#line 372
          cp ++;
        } else
#line 374
        if ((int )((char )*cp) == 122) {
          _L: /* CIL Label */ 
#line 379
          if (sizeof(size_t ) > sizeof(long )) {
#line 382
            flags += 16;
          } else
#line 384
          if (sizeof(size_t ) > sizeof(int )) {
#line 387
            flags += 8;
          }
#line 389
          cp ++;
        } else
#line 374
        if ((int )((char )*cp) == 90) {
#line 374
          goto _L;
        } else
#line 391
        if ((int )((char )*cp) == 116) {
#line 393
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 396
            flags += 16;
          } else
#line 398
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 401
            flags += 8;
          }
#line 403
          cp ++;
        } else {
#line 444
          goto while_break___11;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 448
      __cil_tmp76 = cp;
#line 448
      cp ++;
#line 448
      c = (char )*__cil_tmp76;
      {
#line 451
      if ((int )c == 'i') {
#line 451
        goto case_105;
      }
#line 451
      if ((int )c == 'd') {
#line 451
        goto case_105;
      }
#line 469
      if ((int )c == 'X') {
#line 469
        goto case_88;
      }
#line 469
      if ((int )c == 'x') {
#line 469
        goto case_88;
      }
#line 469
      if ((int )c == 'u') {
#line 469
        goto case_88;
      }
#line 469
      if ((int )c == 'o') {
#line 469
        goto case_88;
      }
#line 488
      if ((int )c == 'A') {
#line 488
        goto case_65;
      }
#line 488
      if ((int )c == 'a') {
#line 488
        goto case_65;
      }
#line 488
      if ((int )c == 'G') {
#line 488
        goto case_65;
      }
#line 488
      if ((int )c == 'g') {
#line 488
        goto case_65;
      }
#line 488
      if ((int )c == 'E') {
#line 488
        goto case_65;
      }
#line 488
      if ((int )c == 'e') {
#line 488
        goto case_65;
      }
#line 488
      if ((int )c == 'F') {
#line 488
        goto case_65;
      }
#line 488
      if ((int )c == 'f') {
#line 488
        goto case_65;
      }
#line 494
      if ((int )c == 'c') {
#line 494
        goto case_99;
      }
#line 505
      if ((int )c == 'C') {
#line 505
        goto case_67;
      }
#line 510
      if ((int )c == 's') {
#line 510
        goto case_115;
      }
#line 521
      if ((int )c == 'S') {
#line 521
        goto case_83;
      }
#line 526
      if ((int )c == 'p') {
#line 526
        goto case_112;
      }
#line 529
      if ((int )c == 'n') {
#line 529
        goto case_110;
      }
#line 558
      if ((int )c == '%') {
#line 558
        goto case_37;
      }
#line 561
      goto switch_default;
      case_105: /* CIL Label */ 
#line 454
      if (flags >= 16) {
#line 455
        type = (arg_type )9;
      } else
#line 454
      if (flags & 4) {
#line 455
        type = (arg_type )9;
      } else
#line 460
      if (flags >= 8) {
#line 461
        type = (arg_type )7;
      } else
#line 462
      if (flags & 2) {
#line 463
        type = (arg_type )1;
      } else
#line 464
      if (flags & 1) {
#line 465
        type = (arg_type )3;
      } else {
#line 467
        type = (arg_type )5;
      }
#line 468
      goto switch_break;
      case_88: /* CIL Label */ 
#line 472
      if (flags >= 16) {
#line 473
        type = (arg_type )10;
      } else
#line 472
      if (flags & 4) {
#line 473
        type = (arg_type )10;
      } else
#line 478
      if (flags >= 8) {
#line 479
        type = (arg_type )8;
      } else
#line 480
      if (flags & 2) {
#line 481
        type = (arg_type )2;
      } else
#line 482
      if (flags & 1) {
#line 483
        type = (arg_type )4;
      } else {
#line 485
        type = (arg_type )6;
      }
#line 486
      goto switch_break;
      case_65: /* CIL Label */ 
#line 489
      if (flags >= 16) {
#line 490
        type = (arg_type )12;
      } else
#line 489
      if (flags & 4) {
#line 490
        type = (arg_type )12;
      } else {
#line 492
        type = (arg_type )11;
      }
#line 493
      goto switch_break;
      case_99: /* CIL Label */ 
#line 495
      if (flags >= 8) {
#line 497
        type = (arg_type )14;
      } else {
#line 502
        type = (arg_type )13;
      }
#line 503
      goto switch_break;
      case_67: /* CIL Label */ 
#line 506
      type = (arg_type )14;
#line 507
      c = (char )'c';
#line 508
      goto switch_break;
      case_115: /* CIL Label */ 
#line 511
      if (flags >= 8) {
#line 513
        type = (arg_type )16;
      } else {
#line 518
        type = (arg_type )15;
      }
#line 519
      goto switch_break;
      case_83: /* CIL Label */ 
#line 522
      type = (arg_type )16;
#line 523
      c = (char )'s';
#line 524
      goto switch_break;
      case_112: /* CIL Label */ 
#line 527
      type = (arg_type )17;
#line 528
      goto switch_break;
      case_110: /* CIL Label */ 
#line 532
      if (flags >= 16) {
#line 533
        type = (arg_type )22;
      } else
#line 532
      if (flags & 4) {
#line 533
        type = (arg_type )22;
      } else
#line 538
      if (flags >= 8) {
#line 539
        type = (arg_type )21;
      } else
#line 540
      if (flags & 2) {
#line 541
        type = (arg_type )18;
      } else
#line 542
      if (flags & 1) {
#line 543
        type = (arg_type )19;
      } else {
#line 545
        type = (arg_type )20;
      }
#line 546
      goto switch_break;
      case_37: /* CIL Label */ 
#line 559
      type = (arg_type )0;
#line 560
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 563
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 567
      if ((unsigned int )type != 0U) {
#line 569
        dp->arg_index = arg_index;
#line 570
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 572
          __cil_tmp77 = arg_posn;
#line 572
          arg_posn ++;
#line 572
          dp->arg_index = __cil_tmp77;
#line 573
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 575
            goto error;
          }
        }
#line 577
        n___4 = dp->arg_index;
#line 577
        if (n___4 >= a_allocated) {
#line 577
          if (a_allocated <= 9223372036854775807UL) {
#line 577
            tmp___18 = a_allocated * 2UL;
          } else {
#line 577
            tmp___18 = 0xffffffffffffffffUL;
          }
#line 577
          a_allocated = tmp___18;
#line 577
          if (a_allocated <= n___4) {
            {
#line 577
            a_allocated = xsum(n___4, (size_t )1);
            }
          }
#line 577
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 577
            tmp___19 = a_allocated * sizeof(argument );
          } else {
#line 577
            tmp___19 = 0xffffffffffffffffUL;
          }
#line 577
          memory_size___1 = tmp___19;
#line 577
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 577
            goto out_of_memory;
          }
#line 577
          if (a->arg != (argument *)a->direct_alloc_arg) {
            {
#line 577
            __cil_tmp84 = realloc((void *)a->arg, memory_size___1);
#line 577
            tmp___20 = __cil_tmp84;
            }
          } else {
            {
#line 577
            __cil_tmp85 = malloc(memory_size___1);
#line 577
            tmp___20 = __cil_tmp85;
            }
          }
#line 577
          memory___1 = (argument *)tmp___20;
#line 577
          if (memory___1 == (argument *)((void *)0)) {
#line 577
            goto out_of_memory;
          }
#line 577
          if (a->arg == (argument *)a->direct_alloc_arg) {
            {
#line 577
            memcpy((void *)memory___1, (void const   *)a->arg, a->count * sizeof(argument ));
            }
          }
#line 577
          a->arg = memory___1;
        }
        {
        {
#line 577
        while (1) {
          while_continue___12: /* CIL Label */ ;

#line 577
          if (! (a->count <= n___4)) {
#line 577
            goto while_break___12;
          }
#line 577
          (a->arg + a->count)->type = (arg_type )0;
        }
        while_break___26: /* CIL Label */ ;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 577
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 577
          (a->arg + n___4)->type = type;
        } else
#line 577
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 577
          goto error;
        }

      }
#line 579
      dp->conversion = c;
#line 580
      dp->dir_end = cp;
#line 583
      (d->count) ++;
#line 584
      if (d->count >= d_allocated) {
#line 589
        if (d_allocated <= 9223372036854775807UL) {
#line 589
          tmp___21 = d_allocated * 2UL;
        } else {
#line 589
          tmp___21 = 0xffffffffffffffffUL;
        }
#line 589
        d_allocated = tmp___21;
#line 590
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 590
          tmp___22 = d_allocated * sizeof(char_directive );
        } else {
#line 590
          tmp___22 = 0xffffffffffffffffUL;
        }
#line 590
        memory_size___2 = tmp___22;
#line 591
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 593
          goto out_of_memory;
        }
#line 594
        if (d->dir != (char_directive *)d->direct_alloc_dir) {
          {
#line 594
          __cil_tmp93 = realloc((void *)d->dir, memory_size___2);
#line 594
          tmp___23 = __cil_tmp93;
          }
        } else {
          {
#line 594
          __cil_tmp94 = malloc(memory_size___2);
#line 594
          tmp___23 = __cil_tmp94;
          }
        }
#line 594
        memory___2 = (char_directive *)tmp___23;
#line 597
        if (memory___2 == (char_directive *)((void *)0)) {
#line 599
          goto out_of_memory;
        }
#line 600
        if (d->dir == (char_directive *)d->direct_alloc_dir) {
          {
#line 601
          memcpy((void *)memory___2, (void const   *)d->dir, d->count * sizeof(char_directive ));
          }
        }
#line 602
        d->dir = memory___2;
      }
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 613
  (d->dir + d->count)->dir_start = cp;
#line 615
  d->max_width_length = max_width_length;
#line 616
  d->max_precision_length = max_precision_length;
#line 617
  return (0);
  error: 
#line 620
  if (a->arg != (argument *)a->direct_alloc_arg) {
    {
#line 621
    free((void *)a->arg);
    }
  }
#line 622
  if (d->dir != (char_directive *)d->direct_alloc_dir) {
    {
#line 623
    free((void *)d->dir);
    }
  }
  {
#line 624
  __cil_tmp96 = __errno_location();
#line 624
  *__cil_tmp96 = 22;
  }
#line 625
  return (- 1);
  out_of_memory: 
#line 628
  if (a->arg != (argument *)a->direct_alloc_arg) {
    {
#line 629
    free((void *)a->arg);
    }
  }
#line 630
  if (d->dir != (char_directive *)d->direct_alloc_dir) {
    {
#line 631
    free((void *)d->dir);
    }
  }
  {
#line 632
  __cil_tmp97 = __errno_location();
#line 632
  *__cil_tmp97 = 12;
  }
#line 633
  return (- 1);
}
}
#line 38 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  wint_t tmp ;
  static wchar_t wide_null_string[] ;
  size_t __cil_tmp7 ;
  argument *__cil_tmp8 ;

  {
#line 43
  ap = & *(a->arg + 0);
#line 43
  i = (size_t )0;
  {
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;

#line 43
    if (! (i < a->count)) {
#line 43
      goto while_break;
    }
    {
#line 46
    if ((unsigned int )ap->type == (unsigned int )1) {
#line 46
      goto case_1;
    }
#line 49
    if ((unsigned int )ap->type == (unsigned int )2) {
#line 49
      goto case_2;
    }
#line 52
    if ((unsigned int )ap->type == (unsigned int )3) {
#line 52
      goto case_3;
    }
#line 55
    if ((unsigned int )ap->type == (unsigned int )4) {
#line 55
      goto case_4;
    }
#line 58
    if ((unsigned int )ap->type == (unsigned int )5) {
#line 58
      goto case_5;
    }
#line 61
    if ((unsigned int )ap->type == (unsigned int )6) {
#line 61
      goto case_6;
    }
#line 64
    if ((unsigned int )ap->type == (unsigned int )7) {
#line 64
      goto case_7;
    }
#line 67
    if ((unsigned int )ap->type == (unsigned int )8) {
#line 67
      goto case_8;
    }
#line 71
    if ((unsigned int )ap->type == (unsigned int )9) {
#line 71
      goto case_9;
    }
#line 74
    if ((unsigned int )ap->type == (unsigned int )10) {
#line 74
      goto case_10;
    }
#line 78
    if ((unsigned int )ap->type == (unsigned int )11) {
#line 78
      goto case_11;
    }
#line 81
    if ((unsigned int )ap->type == (unsigned int )12) {
#line 81
      goto case_12;
    }
#line 84
    if ((unsigned int )ap->type == (unsigned int )13) {
#line 84
      goto case_13;
    }
#line 88
    if ((unsigned int )ap->type == (unsigned int )14) {
#line 88
      goto case_14;
    }
#line 98
    if ((unsigned int )ap->type == (unsigned int )15) {
#line 98
      goto case_15;
    }
#line 107
    if ((unsigned int )ap->type == (unsigned int )16) {
#line 107
      goto case_16;
    }
#line 125
    if ((unsigned int )ap->type == (unsigned int )17) {
#line 125
      goto case_17;
    }
#line 128
    if ((unsigned int )ap->type == (unsigned int )18) {
#line 128
      goto case_18;
    }
#line 131
    if ((unsigned int )ap->type == (unsigned int )19) {
#line 131
      goto case_19;
    }
#line 134
    if ((unsigned int )ap->type == (unsigned int )20) {
#line 134
      goto case_20;
    }
#line 137
    if ((unsigned int )ap->type == (unsigned int )21) {
#line 137
      goto case_21;
    }
#line 141
    if ((unsigned int )ap->type == (unsigned int )22) {
#line 141
      goto case_22;
    }
#line 184
    goto switch_default;
    case_1: /* CIL Label */ 
#line 47
    ap->a.a_schar = (signed char )0;
#line 48
    goto switch_break;
    case_2: /* CIL Label */ 
#line 50
    ap->a.a_uchar = (unsigned char )0;
#line 51
    goto switch_break;
    case_3: /* CIL Label */ 
#line 53
    ap->a.a_short = (short )0;
#line 54
    goto switch_break;
    case_4: /* CIL Label */ 
#line 56
    ap->a.a_ushort = (unsigned short )0;
#line 57
    goto switch_break;
    case_5: /* CIL Label */ 
#line 59
    ap->a.a_int = 0;
#line 60
    goto switch_break;
    case_6: /* CIL Label */ 
#line 62
    ap->a.a_uint = 0;
#line 63
    goto switch_break;
    case_7: /* CIL Label */ 
#line 65
    ap->a.a_longint = 0;
#line 66
    goto switch_break;
    case_8: /* CIL Label */ 
#line 68
    ap->a.a_ulongint = 0;
#line 69
    goto switch_break;
    case_9: /* CIL Label */ 
#line 72
    ap->a.a_longlongint = 0;
#line 73
    goto switch_break;
    case_10: /* CIL Label */ 
#line 75
    ap->a.a_ulonglongint = 0;
#line 76
    goto switch_break;
    case_11: /* CIL Label */ 
#line 79
    ap->a.a_double = 0;
#line 80
    goto switch_break;
    case_12: /* CIL Label */ 
#line 82
    ap->a.a_longdouble = 0;
#line 83
    goto switch_break;
    case_13: /* CIL Label */ 
#line 85
    ap->a.a_char = 0;
#line 86
    goto switch_break;
    case_14: /* CIL Label */ 
#line 92
    if (sizeof(wint_t ) < sizeof(int )) {
#line 92
      tmp = (wint_t )0;
    } else {
#line 92
      tmp = (wint_t )0;
    }
#line 92
    ap->a.a_wide_char = (int )tmp;
#line 96
    goto switch_break;
    case_15: /* CIL Label */ 
#line 99
    ap->a.a_string = 0;
#line 103
    if (ap->a.a_string == (char const   *)((void *)0)) {
#line 104
      ap->a.a_string = (char const   *)((char *)"(NULL)");
    }
#line 105
    goto switch_break;
    case_16: /* CIL Label */ 
#line 108
    ap->a.a_wide_string = 0;
#line 112
    if (ap->a.a_wide_string == (wchar_t *)((void *)0)) {
#line 121
      ap->a.a_wide_string = (wchar_t *)wide_null_string;
    }
#line 123
    goto switch_break;
    case_17: /* CIL Label */ 
#line 126
    ap->a.a_pointer = 0;
#line 127
    goto switch_break;
    case_18: /* CIL Label */ 
#line 129
    ap->a.a_count_schar_pointer = 0;
#line 130
    goto switch_break;
    case_19: /* CIL Label */ 
#line 132
    ap->a.a_count_short_pointer = 0;
#line 133
    goto switch_break;
    case_20: /* CIL Label */ 
#line 135
    ap->a.a_count_int_pointer = 0;
#line 136
    goto switch_break;
    case_21: /* CIL Label */ 
#line 138
    ap->a.a_count_longint_pointer = 0;
#line 139
    goto switch_break;
    case_22: /* CIL Label */ 
#line 142
    ap->a.a_count_longlongint_pointer = 0;
#line 143
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 186
    return (- 1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 43
  __cil_tmp8 = ap;
#line 43
  ap ++;
#line 43
  __cil_tmp7 = i;
#line 43
  i ++;
#line 188
  return (0);
}
}
#line 74 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.h"
size_t hash_get_n_buckets(Hash_table *table ) ;
#line 75
size_t hash_get_n_buckets_used(Hash_table *table ) ;
#line 76
size_t hash_get_n_entries(Hash_table *table ) ;
#line 77
size_t hash_get_max_bucket_length(Hash_table *table ) ;
#line 78
int hash_table_ok(Hash_table *table ) ;
#line 79
void hash_print_statistics(Hash_table *table , FILE *stream ) ;
#line 80
void *hash_lookup(Hash_table *table , void const   *entry ) ;
#line 83
void *hash_get_first(Hash_table *table ) ;
#line 84
void *hash_get_next(Hash_table *table , void const   *entry ) ;
#line 85
size_t hash_get_entries(Hash_table *table , void **buffer , size_t buffer_size ) ;
#line 86
size_t hash_do_for_each(Hash_table *table , Hash_processor processor , void *processor_data ) ;
#line 89
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 90
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 91
Hash_table *hash_initialize(size_t candidate , Hash_tuning *tuning , Hash_hasher hasher ,
                            Hash_comparator comparator , Hash_data_freer data_freer ) ;
#line 94
void hash_clear(Hash_table *table ) ;
#line 95
void hash_free(Hash_table *table ) ;
#line 98
int hash_rehash(Hash_table *table , size_t candidate ) ;
#line 99
void *hash_insert(Hash_table *table , void const   *entry ) ;
#line 102
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 105
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) ;
#line 107
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 41 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint64_t rotl64(uint64_t x , int n ) 
{ 


  {
#line 43
  return (((x << n) | (x >> (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 50 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint64_t rotr64(uint64_t x , int n ) 
{ 


  {
#line 52
  return (((x >> n) | (x << (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 60 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint32_t rotl32(uint32_t x , int n ) 
{ 


  {
#line 62
  return (((x << n) | (x >> (32 - n))) & 4294967295U);
}
}
#line 69 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint32_t rotr32(uint32_t x , int n ) 
{ 


  {
#line 71
  return (((x >> n) | (x << (32 - n))) & 4294967295U);
}
}
#line 78 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline size_t rotl_sz(size_t x , int n ) 
{ 


  {
#line 80
  return (((x << n) | (x >> (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 87 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 89
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 98 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint16_t rotl16(uint16_t x , int n ) 
{ 


  {
#line 100
  return ((uint16_t )((((int )x << n) | ((int )x >> (16 - n))) & 65535));
}
}
#line 109 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint16_t rotr16(uint16_t x , int n ) 
{ 


  {
#line 111
  return ((uint16_t )((((int )x >> n) | ((int )x << (16 - n))) & 65535));
}
}
#line 120 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint8_t rotl8(uint8_t x , int n ) 
{ 


  {
#line 122
  return ((uint8_t )((((int )x << n) | ((int )x >> (8 - n))) & 255));
}
}
#line 131 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/bitrotate.h"
__inline uint8_t rotr8(uint8_t x , int n ) 
{ 


  {
#line 133
  return ((uint8_t )((((int )x >> n) | ((int )x << (8 - n))) & 255));
}
}
#line 29 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *__realpath_chk_warn(char const   *__name ,
                                                               char *__resolved ,
                                                               size_t __resolvedlen ) ;
#line 37
__inline extern  __attribute__((__nothrow__)) char *realpath(char const   *__name ,
                                                             char *__resolved )  __attribute__((__gnu_inline__)) ;
#line 37 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *realpath(char const   *__name , char *__resolved ) 
{ 
  unsigned long __cil_tmp3 ;
  unsigned long __cil_tmp4 ;
  unsigned long __cil_tmp5 ;
  char *__cil_tmp6 ;
  unsigned long __cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 39
  __cil_tmp3 = __builtin_object_size((void const   *)__resolved, 1);
  }
#line 39
  if (__cil_tmp3 != 0xffffffffffffffffUL) {
    {
#line 42
    __cil_tmp4 = __builtin_object_size((void const   *)__resolved, 1);
    }
#line 42
    if (__cil_tmp4 < 4096UL) {
      {
#line 43
      __cil_tmp5 = __builtin_object_size((void const   *)__resolved, 1);
#line 43
      __cil_tmp6 = __realpath_chk_warn(__name, __resolved, __cil_tmp5);
      }
#line 43
      return (__cil_tmp6);
    }
    {
#line 45
    __cil_tmp7 = __builtin_object_size((void const   *)__resolved, 1);
#line 45
    __cil_tmp8 = __realpath_chk(__name, __resolved, __cil_tmp7);
    }
#line 45
    return (__cil_tmp8);
  }
  {
#line 48
  __cil_tmp9 = __realpath_alias(__name, __resolved);
  }
#line 48
  return (__cil_tmp9);
}
}
#line 132 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static Hash_tuning default_tuning  =    {0.f, 1.f, 0.800000011921f, 1.41400003434f, 0};
#line 152 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
size_t hash_get_n_buckets(Hash_table *table ) 
{ 


  {
#line 154
  return (table->n_buckets);
}
}
#line 160 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
size_t hash_get_n_buckets_used(Hash_table *table ) 
{ 


  {
#line 162
  return (table->n_buckets_used);
}
}
#line 168 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
size_t hash_get_n_entries(Hash_table *table ) 
{ 


  {
#line 170
  return (table->n_entries);
}
}
#line 176 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
size_t hash_get_max_bucket_length(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  size_t max_bucket_length ;
  struct hash_entry *cursor ;
  size_t bucket_length ;

  {
#line 179
  max_bucket_length = (size_t )0;
#line 181
  bucket = table->bucket;
  {
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;

#line 181
    if (! (bucket < table->bucket_limit)) {
#line 181
      goto while_break;
    }
#line 183
    if (bucket->data) {
#line 185
      cursor = bucket;
#line 186
      bucket_length = (size_t )1;
      {
      {
#line 188
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 188
        if (! cursor) {
#line 188
          goto while_break___0;
        }
#line 189
        bucket_length ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 191
      if (bucket_length > max_bucket_length) {
#line 192
        max_bucket_length = bucket_length;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  bucket ++;
#line 196
  return (max_bucket_length);
}
}
#line 203 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
int hash_table_ok(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry *cursor ;

  {
#line 206
  n_buckets_used = (size_t )0;
#line 207
  n_entries = (size_t )0;
#line 209
  bucket = table->bucket;
  {
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;

#line 209
    if (! (bucket < table->bucket_limit)) {
#line 209
      goto while_break;
    }
#line 211
    if (bucket->data) {
#line 213
      cursor = bucket;
#line 216
      n_buckets_used ++;
#line 217
      n_entries ++;
      {
      {
#line 220
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 220
        if (! cursor) {
#line 220
          goto while_break___0;
        }
#line 221
        n_entries ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  bucket ++;
#line 225
  if (n_buckets_used == table->n_buckets_used) {
#line 225
    if (n_entries == table->n_entries) {
#line 226
      return (1);
    }
  }
#line 228
  return (0);
}
}
#line 232 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void hash_print_statistics(Hash_table *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t __cil_tmp4 ;
  size_t n_buckets ;
  size_t __cil_tmp6 ;
  size_t n_buckets_used ;
  size_t __cil_tmp8 ;
  size_t max_bucket_length ;
  size_t __cil_tmp10 ;

  {
  {
#line 234
  __cil_tmp4 = hash_get_n_entries(table);
#line 234
  n_entries = __cil_tmp4;
#line 235
  __cil_tmp6 = hash_get_n_buckets(table);
#line 235
  n_buckets = __cil_tmp6;
#line 236
  __cil_tmp8 = hash_get_n_buckets_used(table);
#line 236
  n_buckets_used = __cil_tmp8;
#line 237
  __cil_tmp10 = hash_get_max_bucket_length(table);
#line 237
  max_bucket_length = __cil_tmp10;
#line 239
  fprintf(stream, (char const   *)((char *)"# entries:         %lu\n"), n_entries);
#line 240
  fprintf(stream, (char const   *)((char *)"# buckets:         %lu\n"), n_buckets);
#line 241
  fprintf(stream, (char const   *)((char *)"# buckets used:    %lu (%.2f%%)\n"), n_buckets_used,
          (100. * (double )n_buckets_used) / (double )n_buckets);
#line 244
  fprintf(stream, (char const   *)((char *)"max bucket length: %lu\n"), max_bucket_length);
  }
}
}
#line 251 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static struct hash_entry *safe_hasher(Hash_table *table , void const   *key ) 
{ 
  size_t n ;
  size_t __cil_tmp4 ;

  {
  {
#line 253
  __cil_tmp4 = (table->hasher)(key, table->n_buckets);
#line 253
  n = __cil_tmp4;
  }
#line 254
  if (! (n < table->n_buckets)) {
    {
#line 255
    abort();
    }
  }
#line 256
  return (table->bucket + n);
}
}
#line 263 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void *hash_lookup(Hash_table *table , void const   *entry ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *__cil_tmp4 ;
  struct hash_entry *cursor ;
  int __cil_tmp6 ;

  {
  {
#line 265
  __cil_tmp4 = safe_hasher(table, entry);
#line 265
  bucket = __cil_tmp4;
  }
#line 268
  if (bucket->data == (void *)0) {
#line 269
    return ((void *)0);
  }
#line 271
  cursor = bucket;
  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;

#line 271
    if (! cursor) {
#line 271
      goto while_break;
    }
    {
#line 272
    __cil_tmp6 = (table->comparator)(entry, (void const   *)cursor->data);
    }
#line 272
    if (entry == (void const   *)cursor->data) {
#line 273
      return (cursor->data);
    } else
#line 272
    if (__cil_tmp6) {
#line 273
      return (cursor->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  cursor = cursor->next;
#line 275
  return ((void *)0);
}
}
#line 290 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void *hash_get_first(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;

  {
#line 294
  if (table->n_entries == 0UL) {
#line 295
    return ((void *)0);
  }
#line 297
  bucket = table->bucket;
  {
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;

#line 297
    if (! 1) {
#line 297
      goto while_break;
    }
#line 298
    if (! (bucket < table->bucket_limit)) {
      {
#line 299
      abort();
      }
    } else
#line 300
    if (bucket->data) {
#line 301
      return (bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  bucket ++;
}
}
#line 309 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void *hash_get_next(Hash_table *table , void const   *entry ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *__cil_tmp4 ;
  struct hash_entry *cursor ;

  {
  {
#line 311
  __cil_tmp4 = safe_hasher(table, entry);
#line 311
  bucket = __cil_tmp4;
#line 315
  cursor = bucket;
  }
  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;

#line 318
    if (cursor->data == (void *)entry) {
#line 318
      if (cursor->next) {
#line 319
        return ((cursor->next)->data);
      }
    }
#line 320
    cursor = cursor->next;
#line 316
    if (! (cursor != (struct hash_entry *)((void *)0))) {
#line 316
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 325
    if (! (bucket < table->bucket_limit)) {
#line 325
      goto while_break___0;
    }
#line 326
    if (bucket->data) {
#line 327
      return (bucket->data);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 330
  return ((void *)0);
}
}
#line 338 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
size_t hash_get_entries(Hash_table *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  size_t __cil_tmp7 ;

  {
#line 341
  counter = (size_t )0;
#line 345
  bucket = table->bucket;
  {
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 345
    if (! (bucket < table->bucket_limit)) {
#line 345
      goto while_break;
    }
#line 347
    if (bucket->data) {
#line 349
      cursor = bucket;
      {
      {
#line 349
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 349
        if (! cursor) {
#line 349
          goto while_break___0;
        }
#line 351
        if (counter >= buffer_size) {
#line 352
          return (counter);
        }
#line 353
        __cil_tmp7 = counter;
#line 353
        counter ++;
#line 353
        *(buffer + __cil_tmp7) = cursor->data;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 349
      cursor = cursor->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  bucket ++;
#line 358
  return (counter);
}
}
#line 370 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
size_t hash_do_for_each(Hash_table *table , Hash_processor processor , void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  int __cil_tmp7 ;

  {
#line 373
  counter = (size_t )0;
#line 377
  bucket = table->bucket;
  {
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;

#line 377
    if (! (bucket < table->bucket_limit)) {
#line 377
      goto while_break;
    }
#line 379
    if (bucket->data) {
#line 381
      cursor = bucket;
      {
      {
#line 381
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 381
        if (! cursor) {
#line 381
          goto while_break___0;
        }
        {
#line 383
        __cil_tmp7 = processor(cursor->data, processor_data);
        }
#line 383
        if (! __cil_tmp7) {
#line 384
          return (counter);
        }
#line 385
        counter ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 381
      cursor = cursor->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  bucket ++;
#line 390
  return (counter);
}
}
#line 430 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 432
  value = (size_t )0;
  {
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;

#line 435
    if (! ch) {
#line 435
      goto while_break;
    }
#line 436
    value = (value * 31UL + (unsigned long )ch) % n_buckets;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  string ++;
#line 437
  return (value);
}
}
#line 465 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  int __cil_tmp2 ;

  {
#line 468
  if (candidate < 10UL) {
#line 469
    candidate = (size_t )10;
  }
#line 472
  candidate |= (unsigned long )1;
  {
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;

#line 474
    if (! (0xffffffffffffffffUL != candidate && ! __cil_tmp2)) {
#line 474
      goto while_break;
    }
#line 475
    candidate += (unsigned long )2;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return (candidate);
}
}
#line 481 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 483
  *tuning = default_tuning;
}
}
#line 488 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t __cil_tmp4 ;

  {
  {
#line 495
  __cil_tmp4 = rotr_sz((size_t )data, 3);
#line 495
  val = __cil_tmp4;
  }
#line 496
  return (val % n);
}
}
#line 501 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static int raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 503
  return (a == b);
}
}
#line 514 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static int check_tuning(Hash_table *table ) 
{ 
  Hash_tuning *tuning ;
  float epsilon ;

  {
#line 516
  tuning = table->tuning;
#line 518
  if (tuning == & default_tuning) {
#line 519
    return (1);
  }
#line 526
  epsilon = 0.100000001491f;
#line 528
  if (epsilon < tuning->growth_threshold) {
#line 528
    if (tuning->growth_threshold < (float )1 - epsilon) {
#line 528
      if ((float )1 + epsilon < tuning->growth_factor) {
#line 528
        if ((float )0 <= tuning->shrink_threshold) {
#line 528
          if (tuning->shrink_threshold + epsilon < tuning->shrink_factor) {
#line 528
            if (tuning->shrink_factor <= (float )1) {
#line 528
              if (tuning->shrink_threshold + epsilon < tuning->growth_threshold) {
#line 535
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 537
  table->tuning = & default_tuning;
#line 538
  return (0);
}
}
#line 546 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 548
  if (! tuning->is_n_buckets) {
#line 550
    new_candidate = (float )candidate / tuning->growth_threshold;
#line 551
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 552
      return ((size_t )0);
    }
#line 553
    candidate = (size_t )new_candidate;
  }
  {
#line 555
  candidate = next_prime(candidate);
  }
#line 556
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 556
    tmp = - 1;
  } else {
#line 556
    tmp = - 2;
  }
#line 556
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 557
    return ((size_t )0);
  }
#line 558
  return (candidate);
}
}
#line 596 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
Hash_table *hash_initialize(size_t candidate , Hash_tuning *tuning , Hash_hasher hasher ,
                            Hash_comparator comparator , Hash_data_freer data_freer ) 
{ 
  Hash_table *table ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp10 ;

  {
#line 602
  if (hasher == (Hash_hasher )((void *)0)) {
#line 603
    hasher = raw_hasher;
  }
#line 604
  if (comparator == (Hash_comparator )((void *)0)) {
#line 605
    comparator = raw_comparator;
  }
  {
#line 607
  __cil_tmp7 = malloc(sizeof(*table));
#line 607
  table = (Hash_table *)__cil_tmp7;
  }
#line 608
  if (table == (Hash_table *)((void *)0)) {
#line 609
    return ((Hash_table *)((void *)0));
  }
#line 611
  if (! tuning) {
#line 612
    tuning = & default_tuning;
  }
  {
#line 613
  table->tuning = tuning;
#line 614
  __cil_tmp8 = check_tuning(table);
  }
#line 614
  if (! __cil_tmp8) {
#line 621
    goto fail;
  }
  {
#line 624
  table->n_buckets = compute_bucket_size(candidate, tuning);
  }
#line 625
  if (! table->n_buckets) {
#line 626
    goto fail;
  }
  {
#line 628
  __cil_tmp10 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 628
  table->bucket = (struct hash_entry *)__cil_tmp10;
  }
#line 629
  if (table->bucket == (struct hash_entry *)((void *)0)) {
#line 630
    goto fail;
  }
#line 631
  table->bucket_limit = table->bucket + table->n_buckets;
#line 632
  table->n_buckets_used = (size_t )0;
#line 633
  table->n_entries = (size_t )0;
#line 635
  table->hasher = hasher;
#line 636
  table->comparator = comparator;
#line 637
  table->data_freer = data_freer;
#line 639
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 643
  return (table);
  fail: 
  {
#line 646
  free((void *)table);
  }
#line 647
  return ((Hash_table *)((void *)0));
}
}
#line 655 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 659
  bucket = table->bucket;
  {
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;

#line 659
    if (! (bucket < table->bucket_limit)) {
#line 659
      goto while_break;
    }
#line 661
    if (bucket->data) {
#line 667
      cursor = bucket->next;
      {
      {
#line 667
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 667
        if (! cursor) {
#line 667
          goto while_break___0;
        }
#line 669
        if (table->data_freer) {
          {
#line 670
          (table->data_freer)(cursor->data);
          }
        }
#line 671
        cursor->data = (void *)0;
#line 673
        next = cursor->next;
#line 676
        cursor->next = table->free_entry_list;
#line 677
        table->free_entry_list = cursor;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 667
      cursor = next;
#line 681
      if (table->data_freer) {
        {
#line 682
        (table->data_freer)(bucket->data);
        }
      }
#line 683
      bucket->data = (void *)0;
#line 684
      bucket->next = (struct hash_entry *)((void *)0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  bucket ++;
#line 688
  table->n_buckets_used = (size_t )0;
#line 689
  table->n_entries = (size_t )0;
}
}
#line 698 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 705
  if (table->data_freer) {
#line 705
    if (table->n_entries) {
#line 707
      bucket = table->bucket;
      {
      {
#line 707
      while (1) {
        while_continue: /* CIL Label */ ;

#line 707
        if (! (bucket < table->bucket_limit)) {
#line 707
          goto while_break;
        }
#line 709
        if (bucket->data) {
#line 711
          cursor = bucket;
          {
          {
#line 711
          while (1) {
            while_continue___0: /* CIL Label */ ;

#line 711
            if (! cursor) {
#line 711
              goto while_break___0;
            }
            {
#line 712
            (table->data_freer)(cursor->data);
            }
          }
          while_break___5: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 711
          cursor = cursor->next;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 707
      bucket ++;
    }
  }
#line 724
  bucket = table->bucket;
  {
  {
#line 724
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 724
    if (! (bucket < table->bucket_limit)) {
#line 724
      goto while_break___1;
    }
#line 726
    cursor = bucket->next;
    {
    {
#line 726
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 726
      if (! cursor) {
#line 726
        goto while_break___2;
      }
      {
#line 728
      next = cursor->next;
#line 729
      free((void *)cursor);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 726
    cursor = next;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 724
  bucket ++;
#line 734
  cursor = table->free_entry_list;
  {
  {
#line 734
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 734
    if (! cursor) {
#line 734
      goto while_break___3;
    }
    {
#line 736
    next = cursor->next;
#line 737
    free((void *)cursor);
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 734
  cursor = next;
#line 743
  free((void *)table->bucket);
#line 744
  free((void *)table);
  }
}
}
#line 753 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *__cil_tmp3 ;

  {
#line 757
  if (table->free_entry_list) {
#line 759
    new = table->free_entry_list;
#line 760
    table->free_entry_list = new->next;
  } else {
    {
#line 767
    __cil_tmp3 = malloc(sizeof(*new));
#line 767
    new = (struct hash_entry *)__cil_tmp3;
    }
  }
#line 771
  return (new);
}
}
#line 778 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 780
  entry->data = (void *)0;
#line 781
  entry->next = table->free_entry_list;
#line 782
  table->free_entry_list = entry;
}
}
#line 792 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             int delete ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *__cil_tmp6 ;
  struct hash_entry *cursor ;
  int __cil_tmp8 ;
  void *data ;
  struct hash_entry *next ;
  int __cil_tmp11 ;
  void *data___0 ;
  struct hash_entry *next___0 ;

  {
  {
#line 795
  __cil_tmp6 = safe_hasher(table, entry);
#line 795
  bucket = __cil_tmp6;
#line 798
  *bucket_head = bucket;
  }
#line 801
  if (bucket->data == (void *)0) {
#line 802
    return ((void *)0);
  }
  {
#line 805
  __cil_tmp8 = (table->comparator)(entry, (void const   *)bucket->data);
  }
#line 805
  if (entry == (void const   *)bucket->data) {
    _L: /* CIL Label */ 
#line 807
    data = bucket->data;
#line 809
    if (delete) {
#line 811
      if (bucket->next) {
        {
#line 813
        next = bucket->next;
#line 817
        *bucket = *next;
#line 818
        free_entry(table, next);
        }
      } else {
#line 822
        bucket->data = (void *)0;
      }
    }
#line 826
    return (data);
  } else
#line 805
  if (__cil_tmp8) {
#line 805
    goto _L;
  }
#line 830
  cursor = bucket;
  {
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;

#line 830
    if (! cursor->next) {
#line 830
      goto while_break;
    }
    {
#line 832
    __cil_tmp11 = (table->comparator)(entry, (void const   *)(cursor->next)->data);
    }
#line 832
    if (entry == (void const   *)(cursor->next)->data) {
      _L___20: /* CIL Label */ 
#line 835
      data___0 = (cursor->next)->data;
#line 837
      if (delete) {
        {
#line 839
        next___0 = cursor->next;
#line 843
        cursor->next = next___0->next;
#line 844
        free_entry(table, next___0);
        }
      }
#line 847
      return (data___0);
    } else
#line 832
    if (__cil_tmp11) {
#line 832
      goto _L___20;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 830
  cursor = cursor->next;
#line 852
  return ((void *)0);
}
}
#line 862 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
static int transfer_entries(Hash_table *dst , Hash_table *src , int safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *__cil_tmp13 ;
  size_t __cil_tmp15 ;

  {
#line 867
  bucket = src->bucket;
  {
  {
#line 867
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 867
    if (! (bucket < src->bucket_limit)) {
#line 867
      goto while_break;
    }
#line 868
    if (bucket->data) {
#line 879
      cursor = bucket->next;
      {
      {
#line 879
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 879
        if (! cursor) {
#line 879
          goto while_break___0;
        }
        {
#line 881
        data = cursor->data;
#line 882
        new_bucket = safe_hasher(dst, (void const   *)data);
#line 884
        next = cursor->next;
        }
#line 886
        if (new_bucket->data) {
#line 890
          cursor->next = new_bucket->next;
#line 891
          new_bucket->next = cursor;
        } else {
          {
#line 897
          new_bucket->data = data;
#line 898
          (dst->n_buckets_used) ++;
#line 899
          free_entry(dst, cursor);
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 879
      cursor = next;
#line 905
      data = bucket->data;
#line 906
      bucket->next = (struct hash_entry *)((void *)0);
#line 907
      if (safe) {
#line 908
        goto while_continue;
      }
      {
#line 909
      new_bucket = safe_hasher(dst, (void const   *)data);
      }
#line 911
      if (new_bucket->data) {
        {
#line 915
        __cil_tmp13 = allocate_entry(dst);
#line 915
        new_entry = __cil_tmp13;
        }
#line 917
        if (new_entry == (struct hash_entry *)((void *)0)) {
#line 918
          return (0);
        }
#line 920
        new_entry->data = data;
#line 921
        new_entry->next = new_bucket->next;
#line 922
        new_bucket->next = new_entry;
      } else {
#line 927
        new_bucket->data = data;
#line 928
        (dst->n_buckets_used) ++;
      }
#line 930
      bucket->data = (void *)0;
#line 931
      __cil_tmp15 = src->n_buckets_used;
#line 931
      (src->n_buckets_used) --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 867
  bucket ++;
#line 933
  return (1);
}
}
#line 945 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
int hash_rehash(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __cil_tmp6 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 949
  __cil_tmp6 = compute_bucket_size(candidate, table->tuning);
#line 949
  new_size = __cil_tmp6;
  }
#line 951
  if (! new_size) {
#line 952
    return (0);
  }
#line 953
  if (new_size == table->n_buckets) {
#line 954
    return (1);
  }
  {
#line 955
  new_table = & storage;
#line 956
  __cil_tmp7 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 956
  new_table->bucket = (struct hash_entry *)__cil_tmp7;
  }
#line 957
  if (new_table->bucket == (struct hash_entry *)((void *)0)) {
#line 958
    return (0);
  }
  {
#line 959
  new_table->n_buckets = new_size;
#line 960
  new_table->bucket_limit = new_table->bucket + new_size;
#line 961
  new_table->n_buckets_used = (size_t )0;
#line 962
  new_table->n_entries = (size_t )0;
#line 963
  new_table->tuning = table->tuning;
#line 964
  new_table->hasher = table->hasher;
#line 965
  new_table->comparator = table->comparator;
#line 966
  new_table->data_freer = table->data_freer;
#line 986
  new_table->free_entry_list = table->free_entry_list;
#line 988
  __cil_tmp8 = transfer_entries(new_table, table, 0);
  }
#line 988
  if (__cil_tmp8) {
    {
#line 991
    free((void *)table->bucket);
#line 992
    table->bucket = new_table->bucket;
#line 993
    table->bucket_limit = new_table->bucket_limit;
#line 994
    table->n_buckets = new_table->n_buckets;
#line 995
    table->n_buckets_used = new_table->n_buckets_used;
#line 996
    table->free_entry_list = new_table->free_entry_list;
    }
#line 998
    return (1);
  }
  {
#line 1014
  table->free_entry_list = new_table->free_entry_list;
#line 1015
  __cil_tmp10 = transfer_entries(table, new_table, 0);
  }
  {
#line 1015
  __cil_tmp9 = transfer_entries(table, new_table, 1);
  }
#line 1015
  if (! (__cil_tmp9 && __cil_tmp10)) {
    {
#line 1017
    abort();
    }
  }
  {
#line 1019
  free((void *)new_table->bucket);
  }
#line 1020
  return (0);
}
}
#line 1040 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning *tuning ;
  float candidate ;
  float tmp ;
  int __cil_tmp10 ;
  void *__cil_tmp11 ;
  struct hash_entry *new_entry ;
  struct hash_entry *__cil_tmp13 ;

  {
#line 1049
  if (! entry) {
    {
#line 1050
    abort();
    }
  }
  {
#line 1053
  data = hash_find_entry(table, entry, & bucket, 0);
  }
#line 1053
  if (data != (void *)0) {
#line 1055
    if (matched_ent) {
#line 1056
      *matched_ent = (void const   *)data;
    }
#line 1057
    return (0);
  }
#line 1065
  if ((float )table->n_buckets_used > (table->tuning)->growth_threshold * (float )table->n_buckets) {
    {
#line 1070
    check_tuning(table);
    }
#line 1071
    if ((float )table->n_buckets_used > (table->tuning)->growth_threshold * (float )table->n_buckets) {
#line 1074
      tuning = table->tuning;
#line 1075
      if (tuning->is_n_buckets) {
#line 1075
        tmp = (float )table->n_buckets * tuning->growth_factor;
      } else {
#line 1075
        tmp = ((float )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1075
      candidate = tmp;
#line 1081
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1082
        return (- 1);
      }
      {
#line 1085
      __cil_tmp10 = hash_rehash(table, (size_t )candidate);
      }
#line 1085
      if (! __cil_tmp10) {
#line 1086
        return (- 1);
      }
      {
#line 1089
      __cil_tmp11 = hash_find_entry(table, entry, & bucket, 0);
      }
#line 1089
      if (__cil_tmp11 != (void *)0) {
        {
#line 1090
        abort();
        }
      }
    }
  }
#line 1096
  if (bucket->data) {
    {
#line 1098
    __cil_tmp13 = allocate_entry(table);
#line 1098
    new_entry = __cil_tmp13;
    }
#line 1100
    if (new_entry == (struct hash_entry *)((void *)0)) {
#line 1101
      return (- 1);
    }
#line 1105
    new_entry->data = (void *)entry;
#line 1106
    new_entry->next = bucket->next;
#line 1107
    bucket->next = new_entry;
#line 1108
    (table->n_entries) ++;
#line 1109
    return (1);
  }
#line 1114
  bucket->data = (void *)entry;
#line 1115
  (table->n_entries) ++;
#line 1116
  (table->n_buckets_used) ++;
#line 1118
  return (1);
}
}
#line 1124 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
int hash_insert0(Hash_table *table , void const   *entry , void const   **matched_ent ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 1126
  __cil_tmp4 = hash_insert_if_absent(table, entry, matched_ent);
  }
#line 1126
  return (__cil_tmp4);
}
}
#line 1136 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void *hash_insert(Hash_table *table , void const   *entry ) 
{ 
  void const   *matched_ent ;
  int err ;
  int __cil_tmp5 ;
  void const   *tmp ;
  void *tmp___21 ;

  {
  {
#line 1139
  __cil_tmp5 = hash_insert_if_absent(table, entry, & matched_ent);
#line 1139
  err = __cil_tmp5;
  }
#line 1140
  if (err == -1) {
#line 1140
    tmp___21 = (void *)0;
  } else {
#line 1140
    if (err == 0) {
#line 1140
      tmp = matched_ent;
    } else {
#line 1140
      tmp = entry;
    }
#line 1140
    tmp___21 = (void *)tmp;
  }
#line 1140
  return (tmp___21);
}
}
#line 1150 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  Hash_tuning *tuning ;
  size_t candidate ;
  float tmp ;
  int __cil_tmp11 ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
  {
#line 1155
  data = hash_find_entry(table, entry, & bucket, 1);
  }
#line 1156
  if (! data) {
#line 1157
    return ((void *)0);
  }
#line 1159
  __cil_tmp6 = table->n_entries;
#line 1159
  (table->n_entries) --;
#line 1160
  if (! bucket->data) {
#line 1162
    __cil_tmp7 = table->n_buckets_used;
#line 1162
    (table->n_buckets_used) --;
#line 1167
    if ((float )table->n_buckets_used < (table->tuning)->shrink_threshold * (float )table->n_buckets) {
      {
#line 1172
      check_tuning(table);
      }
#line 1173
      if ((float )table->n_buckets_used < (table->tuning)->shrink_threshold * (float )table->n_buckets) {
#line 1176
        tuning = table->tuning;
#line 1177
        if (tuning->is_n_buckets) {
#line 1177
          tmp = (float )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1177
          tmp = ((float )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1177
        candidate = (size_t )tmp;
#line 1183
        __cil_tmp11 = hash_rehash(table, candidate);
        }
#line 1183
        if (! __cil_tmp11) {
#line 1191
          cursor = table->free_entry_list;
          {
          {
#line 1193
          while (1) {
            while_continue: /* CIL Label */ ;

#line 1193
            if (! cursor) {
#line 1193
              goto while_break;
            }
            {
#line 1195
            next = cursor->next;
#line 1196
            free((void *)cursor);
#line 1197
            cursor = next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
#line 1199
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1206
  return (data);
}
}
#line 249 "./getopt.h"
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options___0 ,
                                                  struct rpl_option *long_options ,
                                                  int *opt_index ) ;
#line 253
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options___0 ,
                                                       struct rpl_option *long_options ,
                                                       int *opt_index ) ;
#line 26 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
#line 120
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
#line 126
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option *long_options ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 131
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option *long_options ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 42 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt1.c"
 __attribute__((__nothrow__)) int rpl_getopt_long(int argc , char **argv , char const   *options___0 ,
                                                  struct rpl_option *long_options ,
                                                  int *opt_index ) ;
#line 42 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt1.c"
int rpl_getopt_long(int argc , char **argv , char const   *options___0 , struct rpl_option *long_options ,
                    int *opt_index ) 
{ 
  int __cil_tmp6 ;

  {
  {
#line 45
  __cil_tmp6 = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index,
                                   0, 0);
  }
#line 45
  return (__cil_tmp6);
}
}
#line 50 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option *long_options ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 54
  __cil_tmp7 = _getopt_internal_r(argc, argv, options___0, long_options, opt_index,
                                  0, d, 0);
  }
#line 54
  return (__cil_tmp7);
}
}
#line 64
 __attribute__((__nothrow__)) int rpl_getopt_long_only(int argc , char **argv , char const   *options___0 ,
                                                       struct rpl_option *long_options ,
                                                       int *opt_index ) ;
#line 64 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt1.c"
int rpl_getopt_long_only(int argc , char **argv , char const   *options___0 , struct rpl_option *long_options ,
                         int *opt_index ) 
{ 
  int __cil_tmp6 ;

  {
  {
#line 68
  __cil_tmp6 = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index,
                                   1, 0);
  }
#line 68
  return (__cil_tmp6);
}
}
#line 73 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option *long_options ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int __cil_tmp7 ;

  {
  {
#line 77
  __cil_tmp7 = _getopt_internal_r(argc, argv, options___0, long_options, opt_index,
                                  1, d, 0);
  }
#line 77
  return (__cil_tmp7);
}
}
#line 152 "./getopt.h"
char *rpl_optarg ;
#line 166
int rpl_optind ;
#line 171
int rpl_opterr ;
#line 175
int rpl_optopt ;
#line 245
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 517 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name ) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 ) ;
#line 225
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c ) ;
#line 84 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
int rpl_optind  =    1;
#line 89 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
int rpl_opterr  =    1;
#line 95 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
int rpl_optopt  =    '?';
#line 99
static struct _getopt_data getopt_data ;
#line 146 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 148
  bottom = d->__first_nonopt;
#line 149
  middle = d->__last_nonopt;
#line 150
  top = d->rpl_optind;
  {
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;

#line 180
    if (! (top > middle && middle > bottom)) {
#line 180
      goto while_break;
    }
#line 182
    if (top - middle > middle - bottom) {
#line 185
      len = middle - bottom;
#line 189
      i = 0;
      {
      {
#line 189
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 189
        if (! (i < len)) {
#line 189
          goto while_break___0;
        }
#line 191
        tem = *(argv + (bottom + i));
#line 192
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 193
        *(argv + ((top - (middle - bottom)) + i)) = tem;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      i ++;
#line 197
      top -= len;
    } else {
#line 202
      len___0 = top - middle;
#line 206
      i___0 = 0;
      {
      {
#line 206
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 206
        if (! (i___0 < len___0)) {
#line 206
          goto while_break___1;
        }
#line 208
        tem = *(argv + (bottom + i___0));
#line 209
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 210
        *(argv + (middle + i___0)) = tem;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 206
      i___0 ++;
#line 214
      bottom += len___0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 221
  d->__last_nonopt = d->rpl_optind;
}
}
#line 227 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
static char const   *_getopt_initialize(int argc , char **argv , char const   *optstring ,
                                        struct _getopt_data *d , int posixly_correct ) 
{ 
  char *__cil_tmp6 ;

  {
  {
#line 235
  d->__last_nonopt = d->rpl_optind;
#line 235
  d->__first_nonopt = d->__last_nonopt;
#line 237
  d->__nextchar = (char *)((void *)0);
#line 239
  __cil_tmp6 = getenv((char const   *)((char *)"POSIXLY_CORRECT"));
#line 239
  d->__posixly_correct = posixly_correct || ! (! __cil_tmp6);
  }
#line 243
  if ((int )((char )*(optstring + 0)) == 45) {
#line 245
    d->__ordering = (enum __ord )2;
#line 246
    optstring ++;
  } else
#line 248
  if ((int )((char )*(optstring + 0)) == 43) {
#line 250
    d->__ordering = (enum __ord )0;
#line 251
    optstring ++;
  } else
#line 253
  if (d->__posixly_correct) {
#line 254
    d->__ordering = (enum __ord )0;
  } else {
#line 256
    d->__ordering = (enum __ord )1;
  }
#line 288
  return (optstring);
}
}
#line 348 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) 
{ 
  int print_errors ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;
  char *nameend ;
  unsigned int namelen ;
  struct rpl_option *p ;
  struct rpl_option *pfound ;
  struct option_list *ambig_list ;
  int exact ;
  int indfound ;
  int option_index ;
  int __cil_tmp26 ;
  size_t __cil_tmp27 ;
  struct option_list *newp ;
  void *__cil_tmp29 ;
  struct rpl_option *__cil_tmp30 ;
  int __cil_tmp31 ;
  struct option_list first ;
  char *__cil_tmp33 ;
  size_t __cil_tmp34 ;
  struct option_list *pn ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  size_t __cil_tmp40 ;
  int __cil_tmp41 ;
  char *__cil_tmp42 ;
  size_t __cil_tmp43 ;
  int tmp ;
  size_t __cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char c ;
  char *__cil_tmp51 ;
  char const   *temp ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *nameend___0 ;
  struct rpl_option *p___0 ;
  struct rpl_option *pfound___0 ;
  int exact___0 ;
  int ambig ;
  int indfound___0 ;
  int option_index___0 ;
  char *__cil_tmp63 ;
  int __cil_tmp64 ;
  int __cil_tmp66 ;
  size_t __cil_tmp67 ;
  struct rpl_option *__cil_tmp68 ;
  int __cil_tmp69 ;
  char *__cil_tmp70 ;
  size_t __cil_tmp71 ;
  char *__cil_tmp73 ;
  size_t __cil_tmp74 ;
  int __cil_tmp75 ;
  char *__cil_tmp76 ;
  size_t __cil_tmp77 ;
  int tmp___0 ;
  size_t __cil_tmp79 ;
  char *__cil_tmp82 ;
  int __cil_tmp83 ;

  {
#line 352
  print_errors = d->rpl_opterr;
#line 354
  if (argc < 1) {
#line 355
    return (- 1);
  }
#line 357
  d->rpl_optarg = (char *)((void *)0);
#line 359
  if (d->rpl_optind == 0) {
    _L: /* CIL Label */ 
#line 361
    if (d->rpl_optind == 0) {
#line 362
      d->rpl_optind = 1;
    }
    {
#line 363
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
#line 365
    d->__initialized = 1;
    }
  } else
#line 359
  if (! d->__initialized) {
#line 359
    goto _L;
  } else
#line 367
  if ((int )((char )*(optstring + 0)) == 45) {
#line 368
    optstring ++;
  } else
#line 367
  if ((int )((char )*(optstring + 0)) == 43) {
#line 368
    optstring ++;
  }
#line 369
  if ((int )((char )*(optstring + 0)) == 58) {
#line 370
    print_errors = 0;
  }
#line 384
  if (d->__nextchar == (char *)((void *)0)) {
    _L___25: /* CIL Label */ 
#line 390
    if (d->__last_nonopt > d->rpl_optind) {
#line 391
      d->__last_nonopt = d->rpl_optind;
    }
#line 392
    if (d->__first_nonopt > d->rpl_optind) {
#line 393
      d->__first_nonopt = d->rpl_optind;
    }
#line 395
    if ((unsigned int )d->__ordering == 1U) {
#line 400
      if (d->__first_nonopt != d->__last_nonopt) {
#line 400
        if (d->__last_nonopt != d->rpl_optind) {
          {
#line 402
          exchange(argv, d);
          }
        } else {
#line 400
          goto _L___22;
        }
      } else
      _L___22: /* CIL Label */ 
#line 403
      if (d->__last_nonopt != d->rpl_optind) {
#line 404
        d->__first_nonopt = d->rpl_optind;
      }
      {
      {
#line 409
      while (1) {
        while_continue: /* CIL Label */ ;

#line 409
        if (! (d->rpl_optind < argc && ((int )*(*(argv + d->rpl_optind) + 0) != 45 || (int )*(*(argv + d->rpl_optind) + 1) == 0))) {
#line 409
          goto while_break;
        }
#line 410
        (d->rpl_optind) ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 411
      d->__last_nonopt = d->rpl_optind;
    }
    {
#line 419
    __cil_tmp13 = strcmp((char const   *)*(argv + d->rpl_optind), (char const   *)((char *)"--"));
    }
#line 419
    if (d->rpl_optind != argc) {
#line 419
      if (! __cil_tmp13) {
#line 421
        (d->rpl_optind) ++;
#line 423
        if (d->__first_nonopt != d->__last_nonopt) {
#line 423
          if (d->__last_nonopt != d->rpl_optind) {
            {
#line 425
            exchange(argv, d);
            }
          } else {
#line 423
            goto _L___23;
          }
        } else
        _L___23: /* CIL Label */ 
#line 426
        if (d->__first_nonopt == d->__last_nonopt) {
#line 427
          d->__first_nonopt = d->rpl_optind;
        }
#line 428
        d->__last_nonopt = argc;
#line 430
        d->rpl_optind = argc;
      }
    }
#line 436
    if (d->rpl_optind == argc) {
#line 440
      if (d->__first_nonopt != d->__last_nonopt) {
#line 441
        d->rpl_optind = d->__first_nonopt;
      }
#line 442
      return (- 1);
    }
#line 448
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
      _L___24: /* CIL Label */ 
#line 450
      if ((unsigned int )d->__ordering == 0U) {
#line 451
        return (- 1);
      }
#line 452
      __cil_tmp15 = d->rpl_optind;
#line 452
      (d->rpl_optind) ++;
#line 452
      d->rpl_optarg = *(argv + __cil_tmp15);
#line 453
      return (1);
    } else
#line 448
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
#line 448
      goto _L___24;
    }
#line 459
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + (longopts != (struct rpl_option *)((void *)0) && (int )*(*(argv + d->rpl_optind) + 1) == 45);
  } else
#line 384
  if ((int )*(d->__nextchar) == 0) {
#line 384
    goto _L___25;
  }
  {
#line 478
  __cil_tmp16 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
  }
#line 478
  if (longopts != (struct rpl_option *)((void *)0)) {
#line 478
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
      _L___28: /* CIL Label */ 
#line 486
      pfound = (struct rpl_option *)((void *)0);
#line 487
      ambig_list = (struct option_list *)((void *)0);
#line 492
      exact = 0;
#line 493
      indfound = - 1;
#line 496
      nameend = d->__nextchar;
      {
      {
#line 496
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 496
        if (! ((int )*nameend && (int )*nameend != 61)) {
#line 496
          goto while_break___0;
        }

      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 496
      nameend ++;
#line 498
      namelen = (unsigned int )(nameend - d->__nextchar);
#line 502
      option_index = 0;
#line 502
      p = longopts;
      {
      {
#line 502
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 502
        if (! p->name) {
#line 502
          goto while_break___1;
        }
        {
#line 503
        __cil_tmp26 = strncmp(p->name, (char const   *)d->__nextchar, (unsigned long )namelen);
        }
#line 503
        if (! __cil_tmp26) {
          {
#line 505
          __cil_tmp27 = strlen(p->name);
          }
#line 505
          if (namelen == (unsigned int )__cil_tmp27) {
#line 508
            pfound = p;
#line 509
            indfound = option_index;
#line 510
            exact = 1;
#line 511
            goto while_break___1;
          } else
#line 513
          if (pfound == (struct rpl_option *)((void *)0)) {
#line 516
            pfound = p;
#line 517
            indfound = option_index;
          } else
#line 519
          if (long_only) {
            {
            {
            {
            {
#line 525
            __cil_tmp29 = malloc(sizeof(*newp));
            }
            }
            }
#line 525
            newp = (struct option_list *)__cil_tmp29;
#line 526
            newp->p = p;
#line 527
            newp->next = ambig_list;
#line 528
            ambig_list = newp;
            }
          } else
#line 519
          if (pfound->has_arg != p->has_arg) {
            {
            {
            {
            {
#line 525
            __cil_tmp29 = malloc(sizeof(*newp));
            }
            }
            }
#line 525
            newp = (struct option_list *)__cil_tmp29;
#line 526
            newp->p = p;
#line 527
            newp->next = ambig_list;
#line 528
            ambig_list = newp;
            }
          } else
#line 519
          if (pfound->flag != p->flag) {
            {
            {
            {
            {
#line 525
            __cil_tmp29 = malloc(sizeof(*newp));
            }
            }
            }
#line 525
            newp = (struct option_list *)__cil_tmp29;
#line 526
            newp->p = p;
#line 527
            newp->next = ambig_list;
#line 528
            ambig_list = newp;
            }
          } else
#line 519
          if (pfound->val != p->val) {
            {
            {
            {
            {
#line 525
            __cil_tmp29 = malloc(sizeof(*newp));
            }
            }
            }
#line 525
            newp = (struct option_list *)__cil_tmp29;
#line 526
            newp->p = p;
#line 527
            newp->next = ambig_list;
#line 528
            ambig_list = newp;
            }
          }
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 502
      __cil_tmp31 = option_index;
#line 502
      option_index ++;
#line 502
      __cil_tmp30 = p;
#line 502
      p ++;
#line 532
      if (ambig_list != (struct option_list *)((void *)0)) {
#line 532
        if (! exact) {
#line 534
          if (print_errors) {
            {
#line 537
            first.p = pfound;
#line 538
            first.next = ambig_list;
#line 539
            ambig_list = & first;
#line 577
            __cil_tmp33 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option \'%s\' is ambiguous; possibilities:"),
                                    5);
#line 577
            fprintf(stderr, (char const   *)__cil_tmp33, *(argv + 0), *(argv + d->rpl_optind));
            }
            {
            {
#line 580
            while (1) {
              while_continue___2: /* CIL Label */ ;

              {
#line 582
              fprintf(stderr, (char const   *)((char *)" \'--%s\'"), (ambig_list->p)->name);
#line 583
              ambig_list = ambig_list->next;
              }
#line 580
              if (! (ambig_list != (struct option_list *)((void *)0))) {
#line 580
                goto while_break___2;
              }
            }
            while_break___9: /* CIL Label */ ;
            }
            while_break___2: /* CIL Label */ ;
            }
            {
#line 587
            fputc('\n', stderr);
            }
          }
          {
#line 590
          __cil_tmp34 = strlen((char const   *)d->__nextchar);
          }
#line 590
          d->__nextchar += __cil_tmp34;
#line 591
          (d->rpl_optind) ++;
#line 592
          d->rpl_optopt = 0;
#line 593
          return ('?');
        }
      }
      {
      {
#line 596
      while (1) {
        while_continue___3: /* CIL Label */ ;

#line 596
        if (! (ambig_list != (struct option_list *)((void *)0))) {
#line 596
          goto while_break___3;
        }
        {
#line 598
        pn = ambig_list->next;
#line 599
        free((void *)ambig_list);
#line 600
        ambig_list = pn;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 603
      if (pfound != (struct rpl_option *)((void *)0)) {
#line 605
        option_index = indfound;
#line 606
        (d->rpl_optind) ++;
#line 607
        if (*nameend) {
#line 611
          if (pfound->has_arg) {
#line 612
            d->rpl_optarg = nameend + 1;
          } else {
#line 615
            if (print_errors) {
#line 622
              if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                {
#line 630
                __cil_tmp38 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option \'--%s\' doesn\'t allow an argument\n"),
                                        5);
#line 630
                fprintf(stderr, (char const   *)__cil_tmp38, *(argv + 0), pfound->name);
                }
              } else {
                {
#line 644
                __cil_tmp39 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option \'%c%s\' doesn\'t allow an argument\n"),
                                        5);
#line 644
                fprintf(stderr, (char const   *)__cil_tmp39, *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                        pfound->name);
                }
              }
            }
            {
#line 670
            __cil_tmp40 = strlen((char const   *)d->__nextchar);
            }
#line 670
            d->__nextchar += __cil_tmp40;
#line 672
            d->rpl_optopt = pfound->val;
#line 673
            return ('?');
          }
        } else
#line 676
        if (pfound->has_arg == 1) {
#line 678
          if (d->rpl_optind < argc) {
#line 679
            __cil_tmp41 = d->rpl_optind;
#line 679
            (d->rpl_optind) ++;
#line 679
            d->rpl_optarg = *(argv + __cil_tmp41);
          } else {
#line 682
            if (print_errors) {
              {
#line 705
              __cil_tmp42 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option \'--%s\' requires an argument\n"),
                                      5);
#line 705
              fprintf(stderr, (char const   *)__cil_tmp42, *(argv + 0), pfound->name);
              }
            }
            {
#line 710
            __cil_tmp43 = strlen((char const   *)d->__nextchar);
            }
#line 710
            d->__nextchar += __cil_tmp43;
#line 711
            d->rpl_optopt = pfound->val;
#line 712
            if ((int )((char )*(optstring + 0)) == 58) {
#line 712
              tmp = ':';
            } else {
#line 712
              tmp = '?';
            }
#line 712
            return (tmp);
          }
        }
        {
#line 715
        __cil_tmp45 = strlen((char const   *)d->__nextchar);
        }
#line 715
        d->__nextchar += __cil_tmp45;
#line 716
        if (longind != (int *)((void *)0)) {
#line 717
          *longind = option_index;
        }
#line 718
        if (pfound->flag) {
#line 720
          *(pfound->flag) = pfound->val;
#line 721
          return (0);
        }
#line 723
        return (pfound->val);
      }
      {
#line 730
      __cil_tmp46 = strchr(optstring, (int )*(d->__nextchar));
      }
#line 730
      if (! long_only) {
        _L___26: /* CIL Label */ 
#line 733
        if (print_errors) {
#line 740
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
            {
#line 747
            __cil_tmp47 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: unrecognized option \'--%s\'\n"),
                                    5);
#line 747
            fprintf(stderr, (char const   *)__cil_tmp47, *(argv + 0), d->__nextchar);
            }
          } else {
            {
#line 758
            __cil_tmp48 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: unrecognized option \'%c%s\'\n"),
                                    5);
#line 758
            fprintf(stderr, (char const   *)__cil_tmp48, *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0),
                    d->__nextchar);
            }
          }
        }
#line 780
        d->__nextchar = (char *)"";
#line 781
        (d->rpl_optind) ++;
#line 782
        d->rpl_optopt = 0;
#line 783
        return ('?');
      } else
#line 730
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 730
        goto _L___26;
      } else
#line 730
      if (__cil_tmp46 == (char *)((void *)0)) {
#line 730
        goto _L___26;
      }
    } else
#line 478
    if (long_only) {
#line 478
      if ((int )*(*(argv + d->rpl_optind) + 2)) {
#line 478
        goto _L___28;
      } else
#line 478
      if (! __cil_tmp16) {
#line 478
        goto _L___28;
      }
    }
  }
  {
#line 790
  __cil_tmp51 = d->__nextchar;
#line 790
  (d->__nextchar) ++;
#line 790
  c = *__cil_tmp51;
#line 791
  __cil_tmp53 = strchr(optstring, (int )c);
#line 791
  temp = (char const   *)__cil_tmp53;
  }
#line 794
  if ((int )*(d->__nextchar) == 0) {
#line 795
    (d->rpl_optind) ++;
  }
#line 797
  if (temp == (char const   *)((void *)0)) {
    _L___29: /* CIL Label */ 
#line 799
    if (print_errors) {
      {
#line 810
      __cil_tmp54 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: invalid option -- \'%c\'\n"),
                              5);
#line 810
      fprintf(stderr, (char const   *)__cil_tmp54, *(argv + 0), (int )c);
      }
    }
#line 830
    d->rpl_optopt = (int )c;
#line 831
    return ('?');
  } else
#line 797
  if ((int )c == 58) {
#line 797
    goto _L___29;
  } else
#line 797
  if ((int )c == 59) {
#line 797
    goto _L___29;
  }
#line 834
  if ((int )((char )*(temp + 0)) == 87) {
#line 834
    if ((int )((char )*(temp + 1)) == 59) {
#line 838
      pfound___0 = (struct rpl_option *)((void *)0);
#line 839
      exact___0 = 0;
#line 840
      ambig = 0;
#line 841
      indfound___0 = 0;
#line 844
      if (longopts == (struct rpl_option *)((void *)0)) {
#line 845
        goto no_longs;
      }
#line 848
      if ((int )*(d->__nextchar) != 0) {
#line 850
        d->rpl_optarg = d->__nextchar;
#line 853
        (d->rpl_optind) ++;
      } else
#line 855
      if (d->rpl_optind == argc) {
#line 857
        if (print_errors) {
          {
#line 879
          __cil_tmp63 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option requires an argument -- \'%c\'\n"),
                                  5);
#line 879
          fprintf(stderr, (char const   *)__cil_tmp63, *(argv + 0), (int )c);
          }
        }
#line 884
        d->rpl_optopt = (int )c;
#line 885
        if ((int )((char )*(optstring + 0)) == 58) {
#line 886
          c = (char )':';
        } else {
#line 888
          c = (char )'?';
        }
#line 889
        return ((int )c);
      } else {
#line 894
        __cil_tmp64 = d->rpl_optind;
#line 894
        (d->rpl_optind) ++;
#line 894
        d->rpl_optarg = *(argv + __cil_tmp64);
      }
#line 899
      nameend___0 = d->rpl_optarg;
#line 899
      d->__nextchar = nameend___0;
      {
      {
#line 899
      while (1) {
        while_continue___4: /* CIL Label */ ;

#line 899
        if (! ((int )*nameend___0 && (int )*nameend___0 != 61)) {
#line 899
          goto while_break___4;
        }

      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 900
      nameend___0 ++;
#line 905
      option_index___0 = 0;
#line 905
      p___0 = longopts;
      {
      {
#line 905
      while (1) {
        while_continue___5: /* CIL Label */ ;

#line 905
        if (! p___0->name) {
#line 905
          goto while_break___5;
        }
        {
#line 906
        __cil_tmp66 = strncmp(p___0->name, (char const   *)d->__nextchar, (unsigned long )(nameend___0 - d->__nextchar));
        }
#line 906
        if (! __cil_tmp66) {
          {
#line 908
          __cil_tmp67 = strlen(p___0->name);
          }
#line 908
          if ((unsigned long )((unsigned int )(nameend___0 - d->__nextchar)) == __cil_tmp67) {
#line 911
            pfound___0 = p___0;
#line 912
            indfound___0 = option_index___0;
#line 913
            exact___0 = 1;
#line 914
            goto while_break___5;
          } else
#line 916
          if (pfound___0 == (struct rpl_option *)((void *)0)) {
#line 919
            pfound___0 = p___0;
#line 920
            indfound___0 = option_index___0;
          } else
#line 922
          if (long_only) {
#line 927
            ambig = 1;
          } else
#line 922
          if (pfound___0->has_arg != p___0->has_arg) {
#line 927
            ambig = 1;
          } else
#line 922
          if (pfound___0->flag != p___0->flag) {
#line 927
            ambig = 1;
          } else
#line 922
          if (pfound___0->val != p___0->val) {
#line 927
            ambig = 1;
          }
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 905
      __cil_tmp69 = option_index___0;
#line 905
      option_index___0 ++;
#line 905
      __cil_tmp68 = p___0;
#line 905
      p___0 ++;
#line 929
      if (ambig) {
#line 929
        if (! exact___0) {
#line 931
          if (print_errors) {
            {
#line 952
            __cil_tmp70 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option \'-W %s\' is ambiguous\n"),
                                    5);
#line 952
            fprintf(stderr, (char const   *)__cil_tmp70, *(argv + 0), d->rpl_optarg);
            }
          }
          {
#line 956
          __cil_tmp71 = strlen((char const   *)d->__nextchar);
          }
#line 956
          d->__nextchar += __cil_tmp71;
#line 957
          (d->rpl_optind) ++;
#line 958
          return ('?');
        }
      }
#line 960
      if (pfound___0 != (struct rpl_option *)((void *)0)) {
#line 962
        option_index___0 = indfound___0;
#line 963
        if (*nameend___0) {
#line 967
          if (pfound___0->has_arg) {
#line 968
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 971
            if (print_errors) {
              {
#line 994
              __cil_tmp73 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option \'-W %s\' doesn\'t allow an argument\n"),
                                      5);
#line 994
              fprintf(stderr, (char const   *)__cil_tmp73, *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1000
            __cil_tmp74 = strlen((char const   *)d->__nextchar);
            }
#line 1000
            d->__nextchar += __cil_tmp74;
#line 1001
            return ('?');
          }
        } else
#line 1004
        if (pfound___0->has_arg == 1) {
#line 1006
          if (d->rpl_optind < argc) {
#line 1007
            __cil_tmp75 = d->rpl_optind;
#line 1007
            (d->rpl_optind) ++;
#line 1007
            d->rpl_optarg = *(argv + __cil_tmp75);
          } else {
#line 1010
            if (print_errors) {
              {
#line 1033
              __cil_tmp76 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option \'-W %s\' requires an argument\n"),
                                      5);
#line 1033
              fprintf(stderr, (char const   *)__cil_tmp76, *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1038
            __cil_tmp77 = strlen((char const   *)d->__nextchar);
            }
#line 1038
            d->__nextchar += __cil_tmp77;
#line 1039
            if ((int )((char )*(optstring + 0)) == 58) {
#line 1039
              tmp___0 = ':';
            } else {
#line 1039
              tmp___0 = '?';
            }
#line 1039
            return (tmp___0);
          }
        } else {
#line 1043
          d->rpl_optarg = (char *)((void *)0);
        }
        {
#line 1044
        __cil_tmp79 = strlen((char const   *)d->__nextchar);
        }
#line 1044
        d->__nextchar += __cil_tmp79;
#line 1045
        if (longind != (int *)((void *)0)) {
#line 1046
          *longind = option_index___0;
        }
#line 1047
        if (pfound___0->flag) {
#line 1049
          *(pfound___0->flag) = pfound___0->val;
#line 1050
          return (0);
        }
#line 1052
        return (pfound___0->val);
      }
      no_longs: 
#line 1056
      d->__nextchar = (char *)((void *)0);
#line 1057
      return ('W');
    }
  }
#line 1059
  if ((int )((char )*(temp + 1)) == 58) {
#line 1061
    if ((int )((char )*(temp + 2)) == 58) {
#line 1064
      if ((int )*(d->__nextchar) != 0) {
#line 1066
        d->rpl_optarg = d->__nextchar;
#line 1067
        (d->rpl_optind) ++;
      } else {
#line 1070
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1071
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1076
      if ((int )*(d->__nextchar) != 0) {
#line 1078
        d->rpl_optarg = d->__nextchar;
#line 1081
        (d->rpl_optind) ++;
      } else
#line 1083
      if (d->rpl_optind == argc) {
#line 1085
        if (print_errors) {
          {
#line 1107
          __cil_tmp82 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: option requires an argument -- \'%c\'\n"),
                                  5);
#line 1107
          fprintf(stderr, (char const   *)__cil_tmp82, *(argv + 0), (int )c);
          }
        }
#line 1112
        d->rpl_optopt = (int )c;
#line 1113
        if ((int )((char )*(optstring + 0)) == 58) {
#line 1114
          c = (char )':';
        } else {
#line 1116
          c = (char )'?';
        }
      } else {
#line 1121
        __cil_tmp83 = d->rpl_optind;
#line 1121
        (d->rpl_optind) ++;
#line 1121
        d->rpl_optarg = *(argv + __cil_tmp83);
      }
#line 1122
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1125
  return ((int )c);
}
}
#line 1130 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option *longopts ,
                        int *longind , int long_only , int posixly_correct ) 
{ 
  int result ;

  {
  {
#line 1136
  getopt_data.rpl_optind = rpl_optind;
#line 1137
  getopt_data.rpl_opterr = rpl_opterr;
#line 1139
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
#line 1143
  rpl_optind = getopt_data.rpl_optind;
#line 1144
  rpl_optarg = getopt_data.rpl_optarg;
#line 1145
  rpl_optopt = getopt_data.rpl_optopt;
  }
#line 1147
  return (result);
}
}
#line 1159
 __attribute__((__nothrow__)) int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) ;
#line 1159 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/getopt.c"
int rpl_getopt(int argc , char * const  *argv , char const   *optstring ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 1161
  __cil_tmp4 = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option *)0,
                                   (int *)0, 0, 1);
  }
#line 1161
  return (__cil_tmp4);
}
}
#line 26 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/exitfail.c"
int exit_failure  =    1;
#line 41 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/dirname.h"
char *mdir_name(char const   *file ) ;
#line 43
size_t dir_len(char const   *file ) ;
#line 34 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___31 ;
  int tmp___32 ;
  char *__cil_tmp7 ;
  size_t __cil_tmp8 ;

  {
#line 36
  prefix_length = (size_t )0;
#line 40
  if (prefix_length != 0UL) {
#line 40
    tmp___32 = 0;
  } else {
#line 40
    if ((int )((char )*(file + 0)) == 47) {
#line 40
      tmp = 1;
#line 40
      tmp___31 = tmp;
    } else {
#line 40
      tmp___31 = 0;
    }
#line 40
    tmp___32 = tmp___31;
  }
  {
#line 40
  prefix_length += (unsigned long )tmp___32;
#line 50
  __cil_tmp7 = last_component(file);
#line 50
  length = (size_t )(__cil_tmp7 - file);
  }
  {
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;

#line 50
    if (! (prefix_length < length)) {
#line 50
      goto while_break;
    }
#line 52
    if (! ((int )((char )*(file + (length - 1UL))) == 47)) {
#line 53
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  __cil_tmp8 = length;
#line 51
  length --;
#line 54
  return (length);
}
}
#line 73 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t __cil_tmp3 ;
  int append_dot ;
  char *dir ;
  void *__cil_tmp6 ;
  size_t __cil_tmp7 ;

  {
  {
#line 75
  __cil_tmp3 = dir_len(file);
#line 75
  length = __cil_tmp3;
#line 76
  append_dot = length == 0UL;
#line 80
  __cil_tmp6 = malloc((length + (unsigned long )append_dot) + 1UL);
#line 80
  dir = (char *)__cil_tmp6;
  }
#line 81
  if (! dir) {
#line 82
    return ((char *)((void *)0));
  }
  {
#line 83
  memcpy((void *)dir, (void const   *)file, length);
  }
#line 84
  if (append_dot) {
#line 85
    __cil_tmp7 = length;
#line 85
    length ++;
#line 85
    *(dir + __cil_tmp7) = (char )'.';
  }
#line 86
  *(dir + length) = (char )'\000';
#line 87
  return (dir);
}
}
#line 32 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  int saw_slash ;

  {
#line 34
  base = name + 0;
#line 36
  saw_slash = 0;
  {
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;

#line 38
    if (! ((int )((char )*base) == 47)) {
#line 38
      goto while_break;
    }
#line 39
    base ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  p = base;
  {
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 41
    if (! ((char )*p)) {
#line 41
      goto while_break___0;
    }
#line 43
    if ((int )((char )*p) == 47) {
#line 44
      saw_slash = 1;
    } else
#line 45
    if (saw_slash) {
#line 47
      base = p;
#line 48
      saw_slash = 0;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 41
  p ++;
#line 52
  return ((char *)base);
}
}
#line 60 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;
  size_t __cil_tmp5 ;

  {
  {
#line 63
  prefix_len = (size_t )0;
#line 65
  len = strlen(name);
  }
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    if (! (1UL < len && (int )((char )*(name + (len - 1UL))) == 47)) {
#line 65
      goto while_break;
    }
#line 66
    goto while_continue;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  __cil_tmp5 = len;
#line 65
  len --;
#line 68
  if (0) {
#line 70
    return ((size_t )2);
  }
#line 72
  if (0) {
#line 74
    return (prefix_len + 1UL);
  }
#line 76
  return (len);
}
}
#line 72 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/vasnprintf.h"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) ;
#line 27 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/asnprintf.c"
char *asnprintf(char *resultbuf , size_t *lengthp , char const   *format  , ...) 
{ 
  va_list args ;
  char *result ;

  {
  {
#line 32
  __builtin_va_start((__builtin_va_list *)args, format);
#line 33
  result = vasnprintf(resultbuf, lengthp, format, (__builtin_va_list *)args);
#line 34
  __builtin_va_end((__builtin_va_list *)args);
  }
#line 35
  return (result);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t **__ctype_tolower_loc(void) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t **__ctype_toupper_loc(void) ;
#line 122
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 207
__inline extern  __attribute__((__nothrow__)) int tolower(int __c )  __attribute__((__gnu_inline__)) ;
#line 207 "/usr/include/ctype.h"
__inline extern int tolower(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 209
  if (__c >= -128 && __c < 256) {
    {
#line 209
    __cil_tmp2 = __ctype_tolower_loc();
#line 209
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 209
    tmp = __c;
  }
#line 209
  return (tmp);
}
}
#line 213
__inline extern  __attribute__((__nothrow__)) int toupper(int __c )  __attribute__((__gnu_inline__)) ;
#line 213 "/usr/include/ctype.h"
__inline extern int toupper(int __c ) 
{ 
  __int32_t **__cil_tmp2 ;
  __int32_t tmp ;

  {
#line 215
  if (__c >= -128 && __c < 256) {
    {
#line 215
    __cil_tmp2 = __ctype_toupper_loc();
#line 215
    tmp = *(*__cil_tmp2 + __c);
    }
  } else {
#line 215
    tmp = __c;
  }
#line 215
  return (tmp);
}
}
#line 517 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
void argp_state_help(struct argp_state *state , FILE *stream , unsigned int flags ) ;
#line 619 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
__inline void argp_usage(struct argp_state *__state ) 
{ 


  {
  {
#line 621
  argp_state_help(__state, stderr, (unsigned int )262);
  }
}
}
#line 625
__inline  __attribute__((__nothrow__)) int _option_is_short(struct argp_option *__opt ) ;
#line 625 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
__inline int _option_is_short(struct argp_option *__opt ) 
{ 
  int __key___33 ;
  unsigned short const   **__cil_tmp3 ;

  {
#line 627
  if (__opt->flags & 8) {
#line 628
    return (0);
  } else {
    {
#line 631
    __key___33 = __opt->key;
#line 632
    __cil_tmp3 = __ctype_b_loc();
    }
#line 632
    return ((__key___33 > 0 && __key___33 <= 255) && (int )((unsigned short )*(*__cil_tmp3 + __key___33)) & 16384);
  }
}
}
#line 637
__inline  __attribute__((__nothrow__)) int _option_is_end(struct argp_option *__opt ) ;
#line 637 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
__inline int _option_is_end(struct argp_option *__opt ) 
{ 


  {
#line 639
  return (((! __opt->key && ! __opt->name) && ! __opt->doc) && ! __opt->group);
}
}
#line 453 "./argp.h"
void (*argp_program_version_hook)(FILE *__stream , struct argp_state *__state ) ;
#line 36 "./argp-version-etc.h"
void argp_version_setup(char const   *name , char const   * const  *authors ) ;
#line 24 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-version-etc.c"
static char const   *program_canonical_name ;
#line 25
static char const   * const  *program_authors___0 ;
#line 28 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-version-etc.c"
static void version_etc_hook(FILE *stream , struct argp_state *state ) 
{ 


  {
  {
#line 30
  version_etc_ar(stream, program_canonical_name, (char const   *)((char *)"GNU cflow"),
                 (char const   *)((char *)"1.5"), program_authors___0);
  }
}
}
#line 35 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-version-etc.c"
void argp_version_setup(char const   *name , char const   * const  *authors ) 
{ 


  {
#line 37
  argp_program_version_hook = version_etc_hook;
#line 38
  program_canonical_name = name;
#line 39
  program_authors___0 = authors;
}
}
#line 33 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-pvh.c"
void (*argp_program_version_hook)(FILE *__stream , struct argp_state *__state )  =    (void *)0;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void exit(int __status ) ;
#line 447 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 417 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
error_t argp_parse(struct argp *argp___0 , int argc , char **argv , unsigned int flags ,
                   int *end_index , void *input___0 ) ;
#line 446
extern char const   *argp_program_version ;
#line 533
void argp_error(struct argp_state *state , char const   *fmt  , ...) ;
#line 570
 __attribute__((__nothrow__)) void *_argp_input(struct argp *argp___0 , struct argp_state *state ) ;
#line 75 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static int _argp_hang ;
#line 81 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static struct argp_option argp_default_options[]  = {      {(char const   *)((char *)"help"), '?', (char const   *)0, 0, (char const   *)((char *)"give this help list"),
      - 1}, 
        {(char const   *)((char *)"usage"), - 3, (char const   *)0, 0, (char const   *)((char *)"give a short usage message"),
      0}, 
        {(char const   *)((char *)"program-name"), - 2, (char const   *)((char *)"NAME"),
      2, (char const   *)((char *)"set the program name"), 0}, 
        {(char const   *)((char *)"HANG"), - 4, (char const   *)((char *)"SECS"), 3,
      (char const   *)((char *)"hang for SECS seconds (default 3600)"), 0}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 92 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t argp_default_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 96
  if (key == '?') {
#line 96
    goto case_63;
  }
#line 99
  if (key == - 3) {
#line 99
    goto case_exp;
  }
#line 104
  if (key == - 2) {
#line 104
    goto case_exp___0;
  }
#line 126
  if (key == - 4) {
#line 126
    goto case_exp___1;
  }
#line 132
  goto switch_default;
  case_63: /* CIL Label */ 
  {
#line 97
  argp_state_help(state, state->out_stream, (unsigned int )634);
  }
#line 98
  goto switch_break;
  case_exp: /* CIL Label */ 
  {
#line 100
  argp_state_help(state, state->out_stream, (unsigned int )513);
  }
#line 102
  goto switch_break;
  case_exp___0: /* CIL Label */ 
#line 106
  program_invocation_name = arg___0;
  {
#line 113
  state->name = last_component((char const   *)arg___0);
#line 116
  program_invocation_short_name = state->name;
  }
#line 119
  if ((state->flags & 3U) == 1U) {
#line 122
    *(state->argv + 0) = arg___0;
  }
#line 124
  goto switch_break;
  case_exp___1: /* CIL Label */ 
#line 127
  if (arg___0) {
#line 127
    tmp = arg___0;
  } else {
#line 127
    tmp = (char *)"3600";
  }
  {
#line 127
  __cil_tmp6 = atoi((char const   *)tmp);
#line 127
  _argp_hang = __cil_tmp6;
  }
  {
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;

#line 128
    if (! (__cil_tmp7 > 0)) {
#line 128
      goto while_break;
    }
    {
#line 129
    sleep((unsigned int )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 133
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 135
  return (0);
}
}
#line 138 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static struct argp argp_default_argp  =    {(struct argp_option *)argp_default_options, & argp_default_parser, (char const   *)((void *)0),
    (char const   *)((void *)0), (struct argp_child *)((void *)0), (void *)0, (char const   *)((char *)"libc")};
#line 142 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static struct argp_option argp_version_options[]  = {      {(char const   *)((char *)"version"), 'V', (char const   *)0, 0, (char const   *)((char *)"print program version"),
      - 1}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 149 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t argp_version_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 153
  if (key == 'V') {
#line 153
    goto case_86;
  }
#line 165
  goto switch_default;
  case_86: /* CIL Label */ 
#line 154
  if (argp_program_version_hook) {
    {
#line 155
    (*argp_program_version_hook)(state->out_stream, state);
    }
  } else
#line 156
  if (argp_program_version) {
    {
#line 157
    fprintf(state->out_stream, (char const   *)((char *)"%s\n"), argp_program_version);
    }
  } else {
    {
#line 159
    __cil_tmp4 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"(PROGRAM ERROR) No version known!?"),
                           5);
#line 159
    argp_error(state, (char const   *)((char *)"%s"), __cil_tmp4);
    }
  }
#line 162
  if (! (state->flags & 32U)) {
    {
#line 163
    exit(0);
    }
  }
#line 164
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 166
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 168
  return (0);
}
}
#line 171 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static struct argp argp_version_argp  =    {(struct argp_option *)argp_version_options, & argp_version_parser, (char const   *)((void *)0),
    (char const   *)((void *)0), (struct argp_child *)((void *)0), (void *)0, (char const   *)((char *)"libc")};
#line 178 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static int find_long_option(struct rpl_option *long_options , char const   *name ) 
{ 
  struct rpl_option *l ;
  int __cil_tmp4 ;

  {
#line 180
  l = long_options;
  {
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;

#line 181
    if (! (l->name != (char const   *)((void *)0))) {
#line 181
      goto while_break;
    }
    {
#line 182
    __cil_tmp4 = strcmp(l->name, name);
    }
#line 182
    if (name != (char const   *)((void *)0)) {
#line 182
      if (__cil_tmp4 == 0) {
#line 183
        return ((int )(l - long_options));
      } else {
#line 185
        l ++;
      }
    } else {
#line 185
      l ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if (name == (char const   *)((void *)0)) {
#line 187
    return ((int )(l - long_options));
  } else {
#line 189
    return (- 1);
  }
}
}
#line 226 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t group_parse(struct group *group , struct argp_state *state , int key ,
                           char *arg___0 ) 
{ 
  error_t err ;

  {
#line 228
  if (group->parser) {
    {
#line 231
    state->hook = group->hook;
#line 232
    state->input = group->input;
#line 233
    state->child_inputs = group->child_inputs;
#line 234
    state->arg_num = group->args_processed;
#line 235
    err = (*(group->parser))(key, arg___0, state);
#line 236
    group->hook = state->hook;
    }
#line 237
    return (err);
  } else {
#line 240
    return (7);
  }
}
}
#line 291 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static struct group *convert_options(struct argp *argp___0 , struct group *parent ,
                                     unsigned int parent_index , struct group *group ,
                                     struct parser_convert_state *cvt ) 
{ 
  struct argp_option *real ;
  struct argp_child *children ;
  struct argp_option *opt ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  int __cil_tmp14 ;
  int tmp ;
  int tmp___37 ;
  int tmp___38 ;
  unsigned int num_children ;
  struct group *__cil_tmp21 ;
  unsigned int index___39 ;
  unsigned int __cil_tmp24 ;
  struct group *__cil_tmp25 ;

  {
#line 296
  real = argp___0->options;
#line 297
  children = argp___0->children;
#line 299
  if (real) {
    _L: /* CIL Label */ 
#line 303
    if (real) {
#line 304
      opt = real;
      {
      {
#line 304
      while (1) {
        while_continue: /* CIL Label */ ;

#line 304
        if (! (! __cil_tmp9)) {
#line 304
          goto while_break;
        }
#line 306
        if (! (opt->flags & 4)) {
#line 308
          real = opt;
        }
#line 310
        if (! (real->flags & 8)) {
          {
#line 313
          __cil_tmp10 = _option_is_short(opt);
          }
#line 313
          if (__cil_tmp10) {
#line 316
            __cil_tmp11 = cvt->short_end;
#line 316
            (cvt->short_end) ++;
#line 316
            *__cil_tmp11 = (char )opt->key;
#line 317
            if (real->arg) {
#line 319
              __cil_tmp12 = cvt->short_end;
#line 319
              (cvt->short_end) ++;
#line 319
              *__cil_tmp12 = (char )':';
#line 320
              if (real->flags & 1) {
#line 321
                __cil_tmp13 = cvt->short_end;
#line 321
                (cvt->short_end) ++;
#line 321
                *__cil_tmp13 = (char )':';
              }
            }
#line 323
            *(cvt->short_end) = (char )'\000';
          }
          {
#line 326
          __cil_tmp14 = find_long_option((cvt->parser)->long_opts, opt->name);
          }
#line 326
          if (opt->name) {
#line 326
            if (__cil_tmp14 < 0) {
#line 330
              (cvt->long_end)->name = opt->name;
#line 331
              if (real->arg) {
#line 331
                if (real->flags & 1) {
#line 331
                  tmp = 2;
                } else {
#line 331
                  tmp = 1;
                }
#line 331
                tmp___37 = tmp;
              } else {
#line 331
                tmp___37 = 0;
              }
#line 331
              (cvt->long_end)->has_arg = tmp___37;
#line 337
              (cvt->long_end)->flag = (int *)0;
#line 344
              if (opt->key) {
#line 344
                tmp___38 = opt->key;
              } else {
#line 344
                tmp___38 = real->key;
              }
#line 344
              (cvt->long_end)->val = (int )((long )(tmp___38 & ((1 << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)) - 1)) + (((group - (cvt->parser)->groups) + 1L) << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)));
#line 349
              (cvt->long_end)->name = (char const   *)((void *)0);
            }
          }
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 304
      opt ++;
    }
#line 354
    group->parser = argp___0->parser;
#line 355
    group->argp = argp___0;
#line 356
    group->short_end = cvt->short_end;
#line 357
    group->args_processed = (unsigned int )0;
#line 358
    group->parent = parent;
#line 359
    group->parent_index = parent_index;
#line 360
    group->input = (void *)0;
#line 361
    group->hook = (void *)0;
#line 362
    group->child_inputs = (void **)0;
#line 364
    if (children) {
#line 368
      num_children = (unsigned int )0;
      {
      {
#line 369
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 369
        if (! (children + num_children)->argp) {
#line 369
          goto while_break___0;
        }
#line 370
        num_children ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 371
      group->child_inputs = cvt->child_inputs_end;
#line 372
      cvt->child_inputs_end += num_children;
    }
#line 375
    __cil_tmp21 = group;
#line 375
    group ++;
#line 375
    parent = __cil_tmp21;
  } else
#line 299
  if (argp___0->parser) {
#line 299
    goto _L;
  } else {
#line 378
    parent = (struct group *)0;
  }
#line 380
  if (children) {
#line 382
    index___39 = (unsigned int )0;
    {
    {
#line 383
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 383
      if (! children->argp) {
#line 383
        goto while_break___1;
      }
      {
#line 384
      __cil_tmp24 = index___39;
#line 384
      index___39 ++;
#line 384
      __cil_tmp25 = convert_options(children->argp, parent, __cil_tmp24, group, cvt);
#line 384
      group = __cil_tmp25;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 388
  return (group);
}
}
#line 393 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static void parser_convert(struct parser *parser , struct argp *argp___0 , int flags ) 
{ 
  struct parser_convert_state cvt ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 397
  cvt.parser = parser;
#line 398
  cvt.short_end = parser->short_opts;
#line 399
  cvt.long_end = parser->long_opts;
#line 400
  cvt.child_inputs_end = parser->child_inputs;
#line 402
  if (flags & 8) {
#line 403
    __cil_tmp5 = cvt.short_end;
#line 403
    (cvt.short_end) ++;
#line 403
    *__cil_tmp5 = (char )'-';
  } else
#line 404
  if (flags & 4) {
#line 405
    __cil_tmp6 = cvt.short_end;
#line 405
    (cvt.short_end) ++;
#line 405
    *__cil_tmp6 = (char )'+';
  }
#line 406
  *(cvt.short_end) = (char )'\000';
#line 408
  (cvt.long_end)->name = (char const   *)((void *)0);
#line 410
  parser->argp = argp___0;
#line 412
  if (argp___0) {
    {
#line 413
    parser->egroup = convert_options(argp___0, (struct group *)0, (unsigned int )0,
                                     parser->groups, & cvt);
    }
  } else {
#line 415
    parser->egroup = parser->groups;
  }
}
}
#line 432 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static void calc_sizes(struct argp *argp___0 , struct parser_sizes *szs ) 
{ 
  struct argp_child *child ;
  struct argp_option *opt ;
  int num_opts ;
  int __cil_tmp8 ;

  {
#line 434
  child = argp___0->children;
#line 435
  opt = argp___0->options;
#line 437
  if (opt) {
    _L: /* CIL Label */ 
#line 439
    (szs->num_groups) ++;
#line 440
    if (opt) {
#line 442
      num_opts = 0;
      {
      {
#line 443
      while (1) {
        while_continue: /* CIL Label */ ;

#line 443
        if (! (! __cil_tmp8)) {
#line 443
          goto while_break;
        }
#line 444
        num_opts ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 445
      szs->short_len += (unsigned long )(num_opts * 3);
#line 446
      szs->long_len += (unsigned long )num_opts;
    }
  } else
#line 437
  if (argp___0->parser) {
#line 437
    goto _L;
  }
#line 450
  if (child) {
    {
    {
#line 451
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 451
      if (! child->argp) {
#line 451
        goto while_break___0;
      }
      {
#line 453
      calc_sizes(child->argp, szs);
#line 454
      (szs->num_child_inputs) ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
}
}
#line 460 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t parser_init(struct parser *parser , struct argp *argp___0 , int argc ,
                           char **argv , int flags , void *input___0 ) 
{ 
  error_t err ;
  struct group *group ;
  struct parser_sizes szs ;
  struct _getopt_data opt_data ;
  char *storage ;
  size_t glen ;
  size_t gsum ;
  size_t clen ;
  size_t csum ;
  size_t llen ;
  size_t lsum ;
  size_t slen ;
  size_t ssum ;
  int tmp ;
  char **__cil_tmp24 ;
  int __cil_tmp25 ;

  {
#line 463
  err = 0;
#line 466
  opt_data.rpl_optind = 1;
#line 466
  opt_data.rpl_opterr = 1;
#line 466
  opt_data.rpl_optopt = 0;
#line 466
  opt_data.rpl_optarg = (char *)0;
#line 466
  opt_data.__initialized = 0;
#line 466
  opt_data.__nextchar = (char *)0;
#line 466
  opt_data.__ordering = 0;
#line 466
  opt_data.__posixly_correct = 0;
#line 466
  opt_data.__first_nonopt = 0;
#line 466
  opt_data.__last_nonopt = 0;
#line 473
  if (flags & 4) {
#line 473
    tmp = 0;
  } else {
#line 473
    tmp = 1;
  }
#line 473
  szs.short_len = (size_t )tmp;
#line 474
  szs.long_len = (size_t )0;
#line 475
  szs.num_groups = (size_t )0;
#line 476
  szs.num_child_inputs = (size_t )0;
#line 478
  if (argp___0) {
    {
#line 479
    calc_sizes(argp___0, & szs);
    }
  }
  {
#line 482
  glen = (szs.num_groups + 1UL) * sizeof(struct group );
#line 483
  clen = szs.num_child_inputs * sizeof(void *);
#line 484
  llen = (szs.long_len + 1UL) * sizeof(struct rpl_option );
#line 485
  slen = szs.short_len + 1UL;
#line 492
  gsum = glen;
#line 493
  csum = ((((gsum + clen) + __alignof__(struct rpl_option )) - 1UL) / __alignof__(struct rpl_option )) * __alignof__(struct rpl_option );
#line 494
  lsum = csum + llen;
#line 495
  ssum = lsum + slen;
#line 497
  parser->storage = malloc(ssum);
  }
#line 498
  if (! parser->storage) {
#line 499
    return (12);
  }
  {
#line 501
  storage = (char *)parser->storage;
#line 502
  parser->groups = (struct group *)parser->storage;
#line 503
  parser->child_inputs = (void **)(storage + gsum);
#line 504
  parser->long_opts = (struct rpl_option *)(storage + csum);
#line 505
  parser->short_opts = storage + lsum;
#line 506
  parser->opt_data = opt_data;
#line 508
  memset((void *)parser->child_inputs, 0, clen);
#line 509
  parser_convert(parser, argp___0, flags);
#line 511
  memset((void *)(& parser->state), 0, sizeof(struct argp_state ));
#line 512
  parser->state.root_argp = parser->argp;
#line 513
  parser->state.argc = argc;
#line 514
  parser->state.argv = argv;
#line 515
  parser->state.flags = (unsigned int )flags;
#line 516
  parser->state.err_stream = stderr;
#line 517
  parser->state.out_stream = stdout;
#line 518
  parser->state.next = 0;
#line 519
  parser->state.pstate = (void *)parser;
#line 521
  parser->try_getopt = 1;
  }
#line 525
  if (parser->groups < parser->egroup) {
#line 526
    (parser->groups)->input = input___0;
  }
#line 527
  group = parser->groups;
  {
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;

#line 527
    if (! (group < parser->egroup && (! err || err == 7))) {
#line 527
      goto while_break;
    }
#line 531
    if (group->parent) {
#line 533
      group->input = *((group->parent)->child_inputs + group->parent_index);
    }
#line 535
    if (! group->parser) {
#line 535
      if ((group->argp)->children) {
#line 535
        if (((group->argp)->children)->argp) {
#line 540
          *(group->child_inputs + 0) = group->input;
        }
      }
    }
    {
#line 542
    err = group_parse(group, & parser->state, 16777219, (char *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  group ++;
#line 544
  if (err == 7) {
#line 545
    err = 0;
  }
#line 547
  if (err) {
#line 548
    return (err);
  }
#line 550
  if (parser->state.flags & 2U) {
#line 552
    parser->opt_data.rpl_opterr = 0;
#line 553
    if (parser->state.flags & 1U) {
#line 556
      __cil_tmp25 = parser->state.argc;
#line 556
      (parser->state.argc) ++;
#line 556
      __cil_tmp24 = parser->state.argv;
#line 556
      (parser->state.argv) --;
    }
  } else {
#line 559
    parser->opt_data.rpl_opterr = 1;
  }
#line 561
  if (parser->state.argv == argv) {
#line 561
    if (*(argv + 0)) {
      {
#line 563
      parser->state.name = last_component((char const   *)*(argv + 0));
      }
    } else {
#line 565
      parser->state.name = program_invocation_short_name;
    }
  } else {
#line 565
    parser->state.name = program_invocation_short_name;
  }
#line 567
  return (0);
}
}
#line 572 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t parser_finalize(struct parser *parser , error_t err , int arg_ebadkey ,
                               int *end_index ) 
{ 
  struct group *group ;
  struct group *__cil_tmp9 ;
  char *__cil_tmp10 ;
  struct group *__cil_tmp13 ;
  struct group *__cil_tmp14 ;

  {
#line 577
  if (err == 7) {
#line 577
    if (arg_ebadkey) {
#line 579
      err = 0;
    }
  }
#line 581
  if (! err) {
#line 583
    if (parser->state.next == parser->state.argc) {
#line 587
      group = parser->groups;
      {
      {
#line 587
      while (1) {
        while_continue: /* CIL Label */ ;

#line 587
        if (! (group < parser->egroup && (! err || err == 7))) {
#line 587
          goto while_break;
        }
#line 590
        if (group->args_processed == 0U) {
          {
#line 591
          err = group_parse(group, & parser->state, 16777218, (char *)0);
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 589
      group ++;
#line 592
      group = parser->egroup - 1;
      {
      {
#line 592
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 592
        if (! (group >= parser->groups && (! err || err == 7))) {
#line 592
          goto while_break___0;
        }
        {
#line 595
        err = group_parse(group, & parser->state, 16777217, (char *)0);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 594
      __cil_tmp9 = group;
#line 594
      group --;
#line 597
      if (err == 7) {
#line 598
        err = 0;
      }
#line 601
      if (end_index) {
#line 602
        *end_index = parser->state.next;
      }
    } else
#line 604
    if (end_index) {
#line 606
      *end_index = parser->state.next;
    } else {
#line 610
      if (! (parser->state.flags & 2U)) {
#line 610
        if (parser->state.err_stream) {
          {
#line 612
          __cil_tmp10 = dcgettext((parser->argp)->argp_domain, (char const   *)((char *)"%s: Too many arguments\n"),
                                  5);
#line 612
          fprintf(parser->state.err_stream, (char const   *)__cil_tmp10, parser->state.name);
          }
        }
      }
#line 616
      err = 7;
    }
  }
#line 623
  if (err) {
#line 626
    if (err == 7) {
      {
#line 629
      argp_state_help(& parser->state, parser->state.err_stream, (unsigned int )260);
      }
    }
#line 633
    group = parser->groups;
    {
    {
#line 633
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 633
      if (! (group < parser->egroup)) {
#line 633
        goto while_break___1;
      }
      {
#line 634
      group_parse(group, & parser->state, 16777221, (char *)0);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 633
    group ++;
  } else {
#line 642
    group = parser->egroup - 1;
    {
    {
#line 642
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 642
      if (! (group >= parser->groups && (! err || err == 7))) {
#line 642
        goto while_break___2;
      }
      {
#line 645
      err = group_parse(group, & parser->state, 16777220, (char *)0);
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 644
    __cil_tmp13 = group;
#line 644
    group --;
#line 646
    if (err == 7) {
#line 647
      err = 0;
    }
  }
#line 651
  group = parser->egroup - 1;
  {
  {
#line 651
  while (1) {
    while_continue___3: /* CIL Label */ ;

#line 651
    if (! (group >= parser->groups)) {
#line 651
      goto while_break___3;
    }
    {
#line 652
    group_parse(group, & parser->state, 16777223, (char *)0);
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 651
  __cil_tmp14 = group;
#line 651
  group --;
#line 654
  if (err == 7) {
#line 655
    err = 22;
  }
  {
#line 657
  free(parser->storage);
  }
#line 659
  return (err);
}
}
#line 668 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t parser_parse_arg(struct parser *parser , char *val ) 
{ 
  int index___40 ;
  error_t err ;
  struct group *group ;
  int key ;
  int __cil_tmp9 ;

  {
#line 672
  (parser->state.next) --;
#line 672
  index___40 = parser->state.next;
#line 673
  err = 7;
#line 675
  key = 0;
#line 678
  group = parser->groups;
  {
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;

#line 678
    if (! (group < parser->egroup && err == 7)) {
#line 678
      goto while_break;
    }
    {
#line 682
    (parser->state.next) ++;
#line 683
    key = 0;
#line 684
    err = group_parse(group, & parser->state, key, val);
    }
#line 686
    if (err == 7) {
      {
#line 689
      __cil_tmp9 = parser->state.next;
#line 689
      (parser->state.next) --;
#line 690
      key = 16777222;
#line 691
      err = group_parse(group, & parser->state, key, (char *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  group ++;
#line 695
  if (! err) {
#line 697
    if (key == 16777222) {
#line 701
      parser->state.next = parser->state.argc;
    }
#line 703
    if (parser->state.next > index___40) {
#line 707
      group->args_processed += (unsigned int )(parser->state.next - index___40);
    } else {
#line 710
      parser->try_getopt = 1;
    }
  }
#line 713
  return (err);
}
}
#line 719 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t parser_parse_opt(struct parser *parser , int opt , char *val ) 
{ 
  int group_key ;
  error_t err ;
  struct group *group ;
  char *short_index ;
  char *__cil_tmp8 ;
  static char const   bad_key_err[] ;
  char *__cil_tmp13 ;
  struct rpl_option *long_opt ;
  char const   *tmp ;
  char *__cil_tmp17 ;

  {
#line 723
  group_key = opt >> (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL);
#line 724
  err = 7;
#line 726
  if (group_key == 0) {
    {
#line 732
    __cil_tmp8 = strchr((char const   *)parser->short_opts, opt);
#line 732
    short_index = __cil_tmp8;
    }
#line 734
    if (short_index) {
#line 735
      group = parser->groups;
      {
      {
#line 735
      while (1) {
        while_continue: /* CIL Label */ ;

#line 735
        if (! (group < parser->egroup)) {
#line 735
          goto while_break;
        }
#line 736
        if (group->short_end > short_index) {
          {
#line 738
          err = group_parse(group, & parser->state, opt, parser->opt_data.rpl_optarg);
          }
#line 740
          goto while_break;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 735
      group ++;
    }
  } else {
    {
#line 746
    err = group_parse(& *(parser->groups + (group_key - 1)), & parser->state, (opt << 8) >> 8,
                      parser->opt_data.rpl_optarg);
    }
  }
#line 751
  if (err == 7) {
#line 756
    bad_key_err = "(PROGRAM ERROR) Option should have been recognized!?";
#line 758
    if (group_key == 0) {
      {
#line 759
      __cil_tmp13 = dcgettext((parser->argp)->argp_domain, (char const   *)bad_key_err,
                              5);
#line 759
      argp_error(& parser->state, (char const   *)((char *)"-%c: %s"), opt, __cil_tmp13);
      }
    } else {
#line 763
      long_opt = parser->long_opts;
      {
      {
#line 764
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 764
        if (! (long_opt->val != opt && long_opt->name)) {
#line 764
          goto while_break___0;
        }
#line 765
        long_opt ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 766
      if (long_opt->name) {
#line 766
        tmp = long_opt->name;
      } else {
#line 766
        tmp = (char const   *)((char *)"???");
      }
      {
#line 766
      __cil_tmp17 = dcgettext((parser->argp)->argp_domain, (char const   *)bad_key_err,
                              5);
#line 766
      argp_error(& parser->state, (char const   *)((char *)"--%s: %s"), tmp, __cil_tmp17);
      }
    }
  }
#line 772
  return (err);
}
}
#line 780 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
static error_t parser_parse_next(struct parser *parser , int *arg_ebadkey ) 
{ 
  int opt ;
  error_t err ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;

  {
#line 783
  err = 0;
#line 785
  if (parser->state.quoted) {
#line 785
    if (parser->state.next < parser->state.quoted) {
#line 790
      parser->state.quoted = 0;
    }
  }
#line 792
  if (parser->try_getopt) {
#line 792
    if (! parser->state.quoted) {
#line 796
      parser->opt_data.rpl_optind = parser->state.next;
#line 798
      parser->opt_data.rpl_optopt = - 1;
#line 799
      if (parser->state.flags & 64U) {
        {
#line 800
        opt = _getopt_long_only_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                                  parser->long_opts, (int *)0, & parser->opt_data);
        }
      } else {
        {
#line 804
        opt = _getopt_long_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                             parser->long_opts, (int *)0, & parser->opt_data);
        }
      }
#line 808
      parser->state.next = parser->opt_data.rpl_optind;
#line 810
      if (opt == -1) {
        {
#line 814
        parser->try_getopt = 0;
#line 815
        __cil_tmp7 = strcmp((char const   *)*(parser->state.argv + (parser->state.next - 1)),
                            (char const   *)((char *)"--"));
        }
#line 815
        if (parser->state.next > 1) {
#line 815
          if (__cil_tmp7 == 0) {
#line 822
            parser->state.quoted = parser->state.next;
          }
        }
      } else
#line 824
      if (opt == 63) {
#line 824
        if (parser->opt_data.rpl_optopt != -1) {
#line 829
          *arg_ebadkey = 0;
#line 830
          return (7);
        }
      }
    } else {
#line 834
      opt = - 1;
    }
  } else {
#line 834
    opt = - 1;
  }
#line 836
  if (opt == -1) {
#line 839
    if (parser->state.next >= parser->state.argc) {
#line 843
      *arg_ebadkey = 1;
#line 844
      return (7);
    } else
#line 839
    if (parser->state.flags & 4U) {
#line 843
      *arg_ebadkey = 1;
#line 844
      return (7);
    } else {
#line 849
      opt = 1;
#line 850
      __cil_tmp8 = parser->state.next;
#line 850
      (parser->state.next) ++;
#line 850
      parser->opt_data.rpl_optarg = *(parser->state.argv + __cil_tmp8);
    }
  }
#line 854
  if (opt == 1) {
    {
#line 856
    err = parser_parse_arg(parser, parser->opt_data.rpl_optarg);
    }
  } else {
    {
#line 858
    err = parser_parse_opt(parser, opt, parser->opt_data.rpl_optarg);
    }
  }
#line 860
  if (err == 7) {
#line 861
    *arg_ebadkey = opt == -1 || opt == 1;
  }
#line 863
  return (err);
}
}
#line 872 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
error_t argp_parse(struct argp *argp___0 , int argc , char **argv , unsigned int flags ,
                   int *end_index , void *input___0 ) 
{ 
  error_t err ;
  struct parser parser ;
  int arg_ebadkey ;
  struct argp_child *child ;
  void *__cil_tmp12 ;
  struct argp *top_argp ;
  void *__cil_tmp14 ;

  {
#line 880
  arg_ebadkey = 0;
#line 883
  if (! (flags & 1U)) {
#line 886
    if (! program_invocation_name) {
#line 887
      program_invocation_name = *(argv + 0);
    }
#line 890
    if (! program_invocation_short_name) {
      {
#line 891
      program_invocation_short_name = last_component((char const   *)*(argv + 0));
      }
    }
  }
#line 896
  if (! (flags & 16U)) {
    {
#line 899
    __cil_tmp12 = __builtin_alloca(4UL * sizeof(struct argp_child ));
#line 899
    child = (struct argp_child *)__cil_tmp12;
#line 900
    __cil_tmp14 = __builtin_alloca(sizeof(struct argp ));
#line 900
    top_argp = (struct argp *)__cil_tmp14;
#line 904
    memset((void *)top_argp, 0, sizeof(*top_argp));
#line 905
    top_argp->children = child;
#line 907
    memset((void *)child, 0, 4UL * sizeof(struct argp_child ));
    }
#line 909
    if (argp___0) {
#line 910
      child->argp = argp___0;
    }
#line 911
    child->argp = & argp_default_argp;
#line 912
    if (argp_program_version) {
#line 913
      child->argp = & argp_version_argp;
    } else
#line 912
    if (argp_program_version_hook) {
#line 913
      child->argp = & argp_version_argp;
    }
#line 914
    child->argp = (struct argp *)0;
#line 916
    argp___0 = top_argp;
  }
  {
#line 920
  err = parser_init(& parser, argp___0, argc, argv, (int )flags, input___0);
  }
#line 922
  if (! err) {
    {
    {
#line 925
    while (1) {
      while_continue: /* CIL Label */ ;

#line 925
      if (! (! err)) {
#line 925
        goto while_break;
      }
      {
#line 926
      err = parser_parse_next(& parser, & arg_ebadkey);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 927
    err = parser_finalize(& parser, err, arg_ebadkey, end_index);
    }
  }
#line 930
  return (err);
}
}
#line 939
 __attribute__((__nothrow__)) void *_argp_input(struct argp *argp___0 , struct argp_state *state ) ;
#line 939 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-parse.c"
void *_argp_input(struct argp *argp___0 , struct argp_state *state ) 
{ 
  struct group *group ;
  struct parser *parser ;

  {
#line 941
  if (state) {
#line 944
    parser = (struct parser *)state->pstate;
#line 946
    group = parser->groups;
    {
    {
#line 946
    while (1) {
      while_continue: /* CIL Label */ ;

#line 946
      if (! (group < parser->egroup)) {
#line 946
        goto while_break;
      }
#line 947
      if (group->argp == argp___0) {
#line 948
        return (group->input);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 946
    group ++;
  }
#line 951
  return ((void *)0);
}
}
#line 827 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , __compar_fn_t __compar ) ;
#line 174 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n ) ;
#line 265
extern  __attribute__((__nothrow__)) char *strchrnul(char const   *__s , int __c ) ;
#line 396
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 420
extern  __attribute__((__nothrow__)) char *strerror_r(int __errnum , char *__buf ,
                                                      size_t __buflen ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 ) ;
#line 662 "/usr/include/stdio.h"
extern int fputs_unlocked(char const   *__s , FILE *__stream ) ;
#line 840
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 462 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp.h"
char const   *argp_program_bug_address ;
#line 467
error_t argp_err_exit_status ;
#line 500
void argp_help(struct argp *argp___0 , FILE *stream , unsigned int flags , char *name ) ;
#line 548
void argp_failure(struct argp_state *state , int status , int errnum , char const   *fmt 
                  , ...) ;
#line 122 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) ;
#line 129
void argp_fmtstream_free(argp_fmtstream_t fs ) ;
#line 134
ssize_t argp_fmtstream_printf(struct argp_fmtstream *fs , char const   *fmt  , ...) ;
#line 184
void _argp_fmtstream_update(argp_fmtstream_t fs ) ;
#line 186
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) ;
#line 267 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_write(argp_fmtstream_t __fs , char const   *__str ,
                                     size_t __len ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 270
  __cil_tmp4 = _argp_fmtstream_ensure(__fs, __len);
  }
#line 270
  if (__fs->p + __len <= __fs->end) {
    {
    {
#line 272
    memcpy((void *)__fs->p, (void const   *)__str, __len);
    }
#line 273
    __fs->p += __len;
    }
#line 274
    return (__len);
  } else
#line 270
  if (__cil_tmp4) {
    {
    {
#line 272
    memcpy((void *)__fs->p, (void const   *)__str, __len);
    }
#line 273
    __fs->p += __len;
    }
#line 274
    return (__len);
  } else {
#line 277
    return ((size_t )0);
  }
}
}
#line 281 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
__inline int argp_fmtstream_puts(argp_fmtstream_t __fs , char const   *__str ) 
{ 
  size_t __len ;
  size_t __cil_tmp4 ;
  size_t __wrote ;
  size_t __cil_tmp6 ;
  int tmp ;

  {
  {
#line 283
  __cil_tmp4 = strlen(__str);
#line 283
  __len = __cil_tmp4;
  }
#line 284
  if (__len) {
    {
#line 286
    __cil_tmp6 = argp_fmtstream_write(__fs, __str, __len);
#line 286
    __wrote = __cil_tmp6;
    }
#line 287
    if (__wrote == __len) {
#line 287
      tmp = 0;
    } else {
#line 287
      tmp = - 1;
    }
#line 287
    return (tmp);
  } else {
#line 290
    return (0);
  }
}
}
#line 294 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
__inline int argp_fmtstream_putc(argp_fmtstream_t __fs , int __ch ) 
{ 
  int __cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 296
  __cil_tmp3 = _argp_fmtstream_ensure(__fs, (size_t )1);
  }
#line 296
  if (__fs->p < __fs->end) {
#line 297
    __cil_tmp4 = __fs->p;
#line 297
    (__fs->p) ++;
#line 297
    *__cil_tmp4 = (char )__ch;
#line 297
    return ((int )*__cil_tmp4);
  } else
#line 296
  if (__cil_tmp3) {
#line 297
    __cil_tmp4 = __fs->p;
#line 297
    (__fs->p) ++;
#line 297
    *__cil_tmp4 = (char )__ch;
#line 297
    return ((int )*__cil_tmp4);
  } else {
#line 299
    return (- 1);
  }
}
}
#line 304 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_set_lmargin(argp_fmtstream_t __fs , size_t __lmargin ) 
{ 
  size_t __old ;

  {
#line 307
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 308
    _argp_fmtstream_update(__fs);
    }
  }
#line 309
  __old = __fs->lmargin;
#line 310
  __fs->lmargin = __lmargin;
#line 311
  return (__old);
}
}
#line 316 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_set_rmargin(argp_fmtstream_t __fs , size_t __rmargin ) 
{ 
  size_t __old ;

  {
#line 319
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 320
    _argp_fmtstream_update(__fs);
    }
  }
#line 321
  __old = __fs->rmargin;
#line 322
  __fs->rmargin = __rmargin;
#line 323
  return (__old);
}
}
#line 328 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_set_wmargin(argp_fmtstream_t __fs , size_t __wmargin ) 
{ 
  size_t __old ;

  {
#line 331
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 332
    _argp_fmtstream_update(__fs);
    }
  }
#line 333
  __old = (size_t )__fs->wmargin;
#line 334
  __fs->wmargin = (ssize_t )__wmargin;
#line 335
  return (__old);
}
}
#line 340 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_point(argp_fmtstream_t __fs ) 
{ 
  ssize_t tmp ;

  {
#line 342
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 343
    _argp_fmtstream_update(__fs);
    }
  }
#line 344
  if (__fs->point_col >= 0L) {
#line 344
    tmp = __fs->point_col;
  } else {
#line 344
    tmp = (long )0;
  }
#line 344
  return ((size_t )tmp);
}
}
#line 106 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static struct uparams uparams  = 
#line 106 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
     {0, 1, 2, 6, 2, 29, 1, 12, 79, 0};
#line 122 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static struct uparam_name uparam_names[]  = 
#line 122
  {      {(char const   *)((char *)"dup-args"), 1, 0}, 
        {(char const   *)((char *)"dup-args-note"), 1, 0}, 
        {(char const   *)((char *)"short-opt-col"), 0, 0}, 
        {(char const   *)((char *)"long-opt-col"), 0, 0}, 
        {(char const   *)((char *)"doc-opt-col"), 0, 0}, 
        {(char const   *)((char *)"opt-doc-col"), 0, 0}, 
        {(char const   *)((char *)"header-col"), 0, 0}, 
        {(char const   *)((char *)"usage-indent"), 0, 0}, 
        {(char const   *)((char *)"rmargin"), 0, 0}, 
        {(char const   *)0, 0, 0UL}};
#line 137 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void validate_uparams(struct argp_state *state , struct uparams *upptr ) 
{ 
  struct uparam_name *up ;
  char *__cil_tmp4 ;

  {
#line 141
  up = (struct uparam_name *)uparam_names;
  {
  {
#line 141
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 141
    if (! up->name) {
#line 141
      goto while_break;
    }
#line 143
    if (up->is_bool) {
#line 145
      goto while_continue;
    } else
#line 143
    if (up->uparams_offs == 0) {
#line 145
      goto while_continue;
    }
#line 146
    if (*((int *)((char *)upptr + up->uparams_offs)) >= upptr->rmargin) {
      {
#line 148
      __cil_tmp4 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"ARGP_HELP_FMT: %s value is less than or equal to %s"),
                             5);
#line 148
      argp_failure(state, 0, 0, (char const   *)__cil_tmp4, (char *)"rmargin", up->name);
      }
#line 153
      return;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  up ++;
#line 156
  uparams = *upptr;
#line 157
  uparams.valid = 1;
}
}
#line 162 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void fill_in_uparams(struct argp_state *state ) 
{ 
  char const   *var ;
  char *__cil_tmp3 ;
  struct uparams new_params ;
  unsigned short const   **__cil_tmp5 ;
  unsigned short const   **__cil_tmp7 ;
  size_t var_len ;
  struct uparam_name *un ;
  int unspec ;
  int val ;
  char const   *arg___0 ;
  unsigned short const   **__cil_tmp13 ;
  unsigned short const   **__cil_tmp15 ;
  unsigned short const   **__cil_tmp18 ;
  unsigned short const   **__cil_tmp20 ;
  unsigned short const   **__cil_tmp22 ;
  unsigned short const   **__cil_tmp24 ;
  size_t __cil_tmp26 ;
  int __cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp31 ;
  char *__cil_tmp33 ;

  {
  {
#line 164
  __cil_tmp3 = getenv((char const   *)((char *)"ARGP_HELP_FMT"));
#line 164
  var = (char const   *)__cil_tmp3;
#line 165
  new_params = uparams;
  }
#line 169
  if (var) {
    {
    {
#line 172
    while (1) {
      while_continue: /* CIL Label */ ;

#line 172
      if (! ((char )*var)) {
#line 172
        goto while_break;
      }
      {
      {
#line 174
      while (1) {
        while_continue___0: /* CIL Label */ ;

        {
        {
#line 174
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 174
          if (! ((int )((unsigned short )*(*__cil_tmp5 + (int )((unsigned char )((char )*var)))) & 8192)) {
#line 174
            goto while_break___1;
          }
#line 174
          var ++;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 174
        goto while_break___0;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 176
      __cil_tmp7 = __ctype_b_loc();
      }
#line 176
      if ((int )((unsigned short )*(*__cil_tmp7 + (int )((unsigned char )((char )*var)))) & 1024) {
#line 180
        unspec = 0;
#line 180
        val = 0;
#line 181
        arg___0 = var;
        {
        {
#line 183
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 183
          if (! (((int )((unsigned short )*(*__cil_tmp13 + (int )((unsigned char )((char )*arg___0)))) & 8 || (int )((char )*arg___0) == 45) || (int )((char )*arg___0) == 95)) {
#line 183
            goto while_break___2;
          }
#line 184
          arg___0 ++;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 185
        var_len = (size_t )(arg___0 - var);
        {
        {
#line 187
        while (1) {
          while_continue___3: /* CIL Label */ ;

          {
          {
#line 187
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 187
            if (! ((int )((unsigned short )*(*__cil_tmp15 + (int )((unsigned char )((char )*arg___0)))) & 8192)) {
#line 187
              goto while_break___4;
            }
#line 187
            arg___0 ++;
          }
          while_break___16: /* CIL Label */ ;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 187
          goto while_break___3;
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }

#line 189
        if ((int )((char )*arg___0) == 0) {
#line 190
          unspec = 1;
        } else
#line 189
        if ((int )((char )*arg___0) == 44) {
#line 190
          unspec = 1;
        } else
#line 191
        if ((int )((char )*arg___0) == 61) {
#line 193
          arg___0 ++;
          {
          {
#line 194
          while (1) {
            while_continue___5: /* CIL Label */ ;

            {
            {
#line 194
            while (1) {
              while_continue___6: /* CIL Label */ ;

#line 194
              if (! ((int )((unsigned short )*(*__cil_tmp18 + (int )((unsigned char )((char )*arg___0)))) & 8192)) {
#line 194
                goto while_break___6;
              }
#line 194
              arg___0 ++;
            }
            while_break___18: /* CIL Label */ ;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 194
            goto while_break___5;
          }
          while_break___17: /* CIL Label */ ;
          }
          while_break___5: /* CIL Label */ ;
          }

        }
#line 197
        if (unspec) {
#line 199
          if ((int )((char )*(var + 0)) == 110) {
#line 199
            if ((int )((char )*(var + 1)) == 111) {
#line 199
              if ((int )((char )*(var + 2)) == 45) {
#line 201
                val = 0;
#line 202
                var += 3;
#line 203
                var_len -= (unsigned long )3;
              } else {
#line 206
                val = 1;
              }
            } else {
#line 206
              val = 1;
            }
          } else {
#line 206
            val = 1;
          }
        } else {
          {
#line 208
          __cil_tmp20 = __ctype_b_loc();
          }
#line 208
          if ((int )((unsigned short )*(*__cil_tmp20 + (int )((unsigned char )((char )*arg___0)))) & 2048) {
            {
#line 210
            val = atoi(arg___0);
            }
            {
            {
#line 211
            while (1) {
              while_continue___7: /* CIL Label */ ;

#line 211
              if (! ((int )((unsigned short )*(*__cil_tmp22 + (int )((unsigned char )((char )*arg___0)))) & 2048)) {
#line 211
                goto while_break___7;
              }
#line 212
              arg___0 ++;
            }
            while_break___19: /* CIL Label */ ;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
            {
#line 213
            while (1) {
              while_continue___8: /* CIL Label */ ;

              {
              {
#line 213
              while (1) {
                while_continue___9: /* CIL Label */ ;

#line 213
                if (! ((int )((unsigned short )*(*__cil_tmp24 + (int )((unsigned char )((char )*arg___0)))) & 8192)) {
#line 213
                  goto while_break___9;
                }
#line 213
                arg___0 ++;
              }
              while_break___21: /* CIL Label */ ;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 213
              goto while_break___8;
            }
            while_break___20: /* CIL Label */ ;
            }
            while_break___8: /* CIL Label */ ;
            }

          }
        }
#line 216
        un = (struct uparam_name *)uparam_names;
        {
        {
#line 216
        while (1) {
          while_continue___10: /* CIL Label */ ;

#line 216
          if (! un->name) {
#line 216
            goto while_break___10;
          }
          {
#line 217
          __cil_tmp27 = strncmp(var, un->name, var_len);
          }
          {
#line 217
          __cil_tmp26 = strlen(un->name);
          }
#line 217
          if (__cil_tmp26 == var_len) {
#line 217
            if (__cil_tmp27 == 0) {
#line 220
              if (unspec) {
#line 220
                if (! un->is_bool) {
                  {
#line 221
                  __cil_tmp28 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"%.*s: ARGP_HELP_FMT parameter requires a value"),
                                          5);
#line 221
                  argp_failure(state, 0, 0, (char const   *)__cil_tmp28, (int )var_len,
                               var);
                  }
                } else {
#line 220
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 226
              if (val < 0) {
                {
#line 227
                __cil_tmp29 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"%.*s: ARGP_HELP_FMT parameter must be positive"),
                                        5);
#line 227
                argp_failure(state, 0, 0, (char const   *)__cil_tmp29, (int )var_len,
                             var);
                }
              } else {
#line 233
                *((int *)((char *)(& new_params) + un->uparams_offs)) = val;
              }
#line 234
              goto while_break___10;
            }
          }
        }
        while_break___22: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 216
        un ++;
#line 236
        if (! un->name) {
          {
#line 237
          __cil_tmp31 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"%.*s: Unknown ARGP_HELP_FMT parameter"),
                                  5);
#line 237
          argp_failure(state, 0, 0, (char const   *)__cil_tmp31, (int )var_len, var);
          }
        }
#line 242
        var = arg___0;
#line 243
        if ((int )((char )*var) == 44) {
#line 244
          var ++;
        }
      } else
#line 246
      if ((char )*var) {
        {
#line 248
        __cil_tmp33 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"Garbage in ARGP_HELP_FMT: %s"),
                                5);
#line 248
        argp_failure(state, 0, 0, (char const   *)__cil_tmp33, var);
        }
#line 251
        goto while_break;
      }
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 254
    validate_uparams(state, & new_params);
    }
  }
}
}
#line 343 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int find_char(char ch , char *beg , char *end___0 ) 
{ 


  {
  {
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;

#line 345
    if (! (beg < end___0)) {
#line 345
      goto while_break;
    }
#line 346
    if ((int )*beg == (int )ch) {
#line 347
      return (1);
    } else {
#line 349
      beg ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return (0);
}
}
#line 435 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static struct hol *make_hol(struct argp *argp___0 , struct hol_cluster *cluster ) 
{ 
  char *so ;
  struct argp_option *o ;
  struct argp_option *opts ;
  struct hol_entry *entry ;
  unsigned int num_short_options ;
  struct hol *hol ;
  void *__cil_tmp9 ;
  int cur_group ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  int __cil_tmp22 ;
  int tmp___45 ;
  int tmp___46 ;
  int __cil_tmp25 ;
  int __cil_tmp27 ;
  int __cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 439
  opts = argp___0->options;
#line 441
  num_short_options = (unsigned int )0;
#line 442
  __cil_tmp9 = malloc(sizeof(struct hol ));
#line 442
  hol = (struct hol *)__cil_tmp9;
#line 446
  hol->num_entries = (unsigned int )0;
#line 447
  hol->clusters = (struct hol_cluster *)0;
  }
#line 449
  if (opts) {
#line 451
    cur_group = 0;
#line 457
    o = opts;
    {
    {
#line 457
    while (1) {
      while_continue: /* CIL Label */ ;

#line 457
      if (! (! __cil_tmp13)) {
#line 457
        goto while_break;
      }
#line 459
      if (! (o->flags & 4)) {
#line 460
        (hol->num_entries) ++;
      }
      {
#line 461
      __cil_tmp15 = _option_is_short(o);
      }
#line 461
      if (__cil_tmp15) {
#line 462
        num_short_options ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 457
    o ++;
#line 465
    __cil_tmp18 = malloc(sizeof(struct hol_entry ) * (unsigned long )hol->num_entries);
#line 465
    hol->entries = (struct hol_entry *)__cil_tmp18;
#line 466
    __cil_tmp19 = malloc((unsigned long )(num_short_options + 1U));
#line 466
    hol->short_options = (char *)__cil_tmp19;
    }
#line 469
    if (0) {

    }
#line 473
    so = hol->short_options;
#line 474
    entry = hol->entries;
#line 474
    o = opts;
    {
    {
#line 474
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 474
      if (! (! __cil_tmp22)) {
#line 474
        goto while_break___0;
      }
#line 476
      entry->opt = o;
#line 477
      entry->num = (unsigned int )0;
#line 478
      entry->short_options = so;
#line 479
      if (o->group) {
#line 479
        tmp___46 = o->group;
      } else {
#line 479
        if (! o->name && ! o->key) {
#line 479
          tmp___45 = cur_group + 1;
        } else {
#line 479
          tmp___45 = cur_group;
        }
#line 479
        tmp___46 = tmp___45;
      }
#line 479
      cur_group = tmp___46;
#line 479
      entry->group = cur_group;
#line 485
      entry->cluster = cluster;
#line 486
      entry->argp = argp___0;
      {
      {
#line 488
      while (1) {
        while_continue___1: /* CIL Label */ ;

        {
#line 490
        (entry->num) ++;
#line 491
        __cil_tmp28 = find_char((char )o->key, hol->short_options, so);
        }
        {
#line 491
        __cil_tmp27 = _option_is_short(o);
        }
#line 491
        if (__cil_tmp27) {
#line 491
          if (! __cil_tmp28) {
#line 493
            __cil_tmp29 = so;
#line 493
            so ++;
#line 493
            *__cil_tmp29 = (char )o->key;
          }
        }
#line 494
        o ++;
#line 488
        if (! (! __cil_tmp25 && o->flags & 4)) {
#line 488
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 474
    entry ++;
#line 498
    *so = (char )'\000';
  }
#line 501
  return (hol);
}
}
#line 508 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static struct hol_cluster *hol_add_cluster(struct hol *hol , int group , char const   *header ,
                                           int index , struct hol_cluster *parent ,
                                           struct argp *argp___0 ) 
{ 
  struct hol_cluster *cl ;
  void *__cil_tmp8 ;
  int tmp ;

  {
  {
#line 511
  __cil_tmp8 = malloc(sizeof(struct hol_cluster ));
#line 511
  cl = (struct hol_cluster *)__cil_tmp8;
  }
#line 512
  if (cl) {
#line 514
    cl->group = group;
#line 515
    cl->header = header;
#line 517
    cl->index = index;
#line 518
    cl->parent = parent;
#line 519
    cl->argp = argp___0;
#line 520
    if (parent) {
#line 520
      tmp = parent->depth + 1;
    } else {
#line 520
      tmp = 0;
    }
#line 520
    cl->depth = tmp;
#line 522
    cl->next = hol->clusters;
#line 523
    hol->clusters = cl;
  }
#line 525
  return (cl);
}
}
#line 530 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void hol_free(struct hol *hol ) 
{ 
  struct hol_cluster *cl ;
  struct hol_cluster *next ;

  {
#line 532
  cl = hol->clusters;
  {
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;

#line 534
    if (! cl) {
#line 534
      goto while_break;
    }
    {
#line 536
    next = cl->next;
#line 537
    free((void *)cl);
#line 538
    cl = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  if (hol->num_entries > 0U) {
    {
#line 543
    free((void *)hol->entries);
#line 544
    free((void *)hol->short_options);
    }
  }
  {
#line 547
  free((void *)hol);
  }
}
}
#line 551 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int hol_entry_short_iterate(struct hol_entry *entry , int (*func)(struct argp_option *opt ,
                                                                         struct argp_option *real ,
                                                                         char const   *domain ,
                                                                         void *cookie ) ,
                                   char const   *domain , void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option *opt___47 ;
  struct argp_option *real___48 ;
  char *so ;
  int __cil_tmp10 ;
  struct argp_option *__cil_tmp13 ;
  unsigned int __cil_tmp14 ;

  {
#line 558
  val = 0;
#line 559
  real___48 = entry->opt;
#line 560
  so = entry->short_options;
#line 562
  nopts = entry->num;
#line 562
  opt___47 = real___48;
  {
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;

#line 562
    if (! (nopts > 0U && ! val)) {
#line 562
      goto while_break;
    }
    {
#line 563
    __cil_tmp10 = _option_is_short(opt___47);
    }
#line 563
    if (__cil_tmp10) {
#line 563
      if ((int )*so == opt___47->key) {
#line 565
        if (! (opt___47->flags & 4)) {
#line 566
          real___48 = opt___47;
        }
#line 567
        if (! (opt___47->flags & 2)) {
          {
#line 568
          val = (*func)(opt___47, real___48, domain, cookie);
          }
        }
#line 569
        so ++;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  __cil_tmp14 = nopts;
#line 562
  nopts --;
#line 562
  __cil_tmp13 = opt___47;
#line 562
  opt___47 ++;
#line 572
  return (val);
}
}
#line 579 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
__inline static int hol_entry_long_iterate(struct hol_entry *entry , int (*func)(struct argp_option *opt ,
                                                                                 struct argp_option *real ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) ,
                                           char const   *domain , void *cookie ) 
{ 
  unsigned int nopts ;
  int val ;
  struct argp_option *opt___49 ;
  struct argp_option *real___50 ;
  struct argp_option *__cil_tmp10 ;
  unsigned int __cil_tmp11 ;

  {
#line 586
  val = 0;
#line 587
  real___50 = entry->opt;
#line 589
  nopts = entry->num;
#line 589
  opt___49 = real___50;
  {
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;

#line 589
    if (! (nopts > 0U && ! val)) {
#line 589
      goto while_break;
    }
#line 590
    if (opt___49->name) {
#line 592
      if (! (opt___49->flags & 4)) {
#line 593
        real___50 = opt___49;
      }
#line 594
      if (! (opt___49->flags & 2)) {
        {
#line 595
        val = (*func)(opt___49, real___50, domain, cookie);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  __cil_tmp11 = nopts;
#line 589
  nopts --;
#line 589
  __cil_tmp10 = opt___49;
#line 589
  opt___49 ++;
#line 598
  return (val);
}
}
#line 603 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int until_short(struct argp_option *opt , struct argp_option *real , char const   *domain ,
                       void *cookie ) 
{ 
  int __cil_tmp5 ;
  int tmp ;

  {
  {
#line 606
  __cil_tmp5 = _option_is_short(opt);
  }
#line 606
  if (__cil_tmp5) {
#line 606
    tmp = opt->key;
  } else {
#line 606
    tmp = 0;
  }
#line 606
  return (tmp);
}
}
#line 611 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static char hol_entry_first_short(struct hol_entry *entry ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 613
  __cil_tmp2 = hol_entry_short_iterate(entry, until_short, (entry->argp)->argp_domain,
                                       (void *)0);
  }
#line 613
  return ((char )__cil_tmp2);
}
}
#line 619 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static char const   *hol_entry_first_long(struct hol_entry *entry ) 
{ 
  struct argp_option *opt ;
  unsigned int num ;
  struct argp_option *__cil_tmp4 ;
  unsigned int __cil_tmp5 ;

  {
#line 623
  num = entry->num;
#line 623
  opt = entry->opt;
  {
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;

#line 623
    if (! (num > 0U)) {
#line 623
      goto while_break;
    }
#line 624
    if (opt->name) {
#line 624
      if (! (opt->flags & 2)) {
#line 625
        return (opt->name);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 623
  __cil_tmp5 = num;
#line 623
  num --;
#line 623
  __cil_tmp4 = opt;
#line 623
  opt ++;
#line 626
  return ((char const   *)0);
}
}
#line 632 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static struct hol_entry *hol_find_entry(struct hol *hol , char const   *name ) 
{ 
  struct hol_entry *entry ;
  unsigned int num_entries ;
  unsigned int __cil_tmp5 ;
  struct argp_option *opt ;
  unsigned int num_opts ;
  unsigned int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 634
  entry = hol->entries;
#line 635
  num_entries = hol->num_entries;
  {
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;

#line 637
    if (! (__cil_tmp5 > 0U)) {
#line 637
      goto while_break;
    }
#line 639
    opt = entry->opt;
#line 640
    num_opts = entry->num;
    {
    {
#line 642
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 642
      if (! (__cil_tmp8 > 0U)) {
#line 642
        goto while_break___0;
      }
      {
#line 643
      __cil_tmp9 = strcmp(opt->name, name);
      }
#line 643
      if (opt->name) {
#line 643
        if (! (opt->flags & 2)) {
#line 643
          if (__cil_tmp9 == 0) {
#line 644
            return (entry);
          } else {
#line 646
            opt ++;
          }
        } else {
#line 646
          opt ++;
        }
      } else {
#line 646
        opt ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 648
    entry ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 651
  return ((struct hol_entry *)0);
}
}
#line 657 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void hol_set_group(struct hol *hol , char const   *name , int group ) 
{ 
  struct hol_entry *entry ;
  struct hol_entry *__cil_tmp5 ;

  {
  {
#line 659
  __cil_tmp5 = hol_find_entry(hol, name);
#line 659
  entry = __cil_tmp5;
  }
#line 660
  if (entry) {
#line 661
    entry->group = group;
  }
}
}
#line 667 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int group_cmp(int group1 , int group2 , int eq ) 
{ 


  {
#line 669
  if (group1 == group2) {
#line 670
    return (eq);
  } else
#line 671
  if (group1 < 0) {
#line 671
    if (group2 < 0) {
#line 672
      return (group1 - group2);
    } else {
#line 671
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 671
  if (group1 >= 0) {
#line 671
    if (group2 >= 0) {
#line 672
      return (group1 - group2);
    } else {
#line 674
      return (group2 - group1);
    }
  } else {
#line 674
    return (group2 - group1);
  }
}
}
#line 680 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int hol_cluster_cmp(struct hol_cluster *cl1 , struct hol_cluster *cl2 ) 
{ 
  int __cil_tmp3 ;

  {
  {
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;

#line 686
    if (! (cl1->depth > cl2->depth)) {
#line 686
      goto while_break;
    }
#line 687
    cl1 = cl1->parent;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 688
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 688
    if (! (cl2->depth > cl1->depth)) {
#line 688
      goto while_break___0;
    }
#line 689
    cl2 = cl2->parent;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 693
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 693
    if (! (cl1->parent != cl2->parent)) {
#line 693
      goto while_break___1;
    }
#line 694
    cl2 = cl2->parent;
#line 694
    cl1 = cl1->parent;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 696
  __cil_tmp3 = group_cmp(cl1->group, cl2->group, cl2->index - cl1->index);
  }
#line 696
  return (__cil_tmp3);
}
}
#line 711 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int hol_cluster_is_child(struct hol_cluster *cl1 , struct hol_cluster *cl2 ) 
{ 


  {
  {
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;

#line 714
    if (! (cl1 && cl1 != cl2)) {
#line 714
      goto while_break;
    }
#line 715
    cl1 = cl1->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 716
  return (cl1 == cl2);
}
}
#line 723 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int canon_doc_option(char const   **name ) 
{ 
  int non_opt ;
  unsigned short const   **__cil_tmp3 ;
  unsigned short const   **__cil_tmp5 ;

  {
#line 727
  if (! *name) {
#line 728
    non_opt = 1;
  } else {
    {
    {
#line 732
    while (1) {
      while_continue: /* CIL Label */ ;

#line 732
      if (! ((int )((unsigned short )*(*__cil_tmp3 + (int )((unsigned char )((char )*(*name))))) & 8192)) {
#line 732
        goto while_break;
      }
#line 733
      (*name) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 735
    non_opt = (int )((char )*(*name)) != 45;
    {
    {
#line 737
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 737
      if (! ((int )((char )*(*name)) && ! ((int )((unsigned short )*(*__cil_tmp5 + (int )((unsigned char )((char )*(*name))))) & 8))) {
#line 737
        goto while_break___0;
      }
#line 738
      (*name) ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 740
  return (non_opt);
}
}
#line 748 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int hol_entry_cmp(struct hol_entry *entry1 , struct hol_entry *entry2 ) 
{ 
  int group1 ;
  int group2 ;
  int rc ;
  struct hol_cluster *__cil_tmp6 ;
  int __cil_tmp7 ;
  struct hol_cluster *__cil_tmp8 ;
  int __cil_tmp9 ;
  int tmp ;
  int tmp___51 ;
  int short1 ;
  char __cil_tmp14 ;
  int short2 ;
  char __cil_tmp16 ;
  int doc1 ;
  int doc2 ;
  char const   *long1 ;
  char const   *__cil_tmp20 ;
  char const   *long2 ;
  char const   *__cil_tmp22 ;
  int tmp___52 ;
  int tmp___53 ;
  unsigned char first1 ;
  int tmp___54 ;
  int tmp___55 ;
  unsigned char first2 ;
  int tmp___56 ;
  int tmp___57 ;
  int lower_cmp ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int __cil_tmp39 ;

  {
#line 753
  group1 = entry1->group;
#line 753
  group2 = entry2->group;
#line 756
  if (entry1->cluster != entry2->cluster) {
#line 760
    if (! entry1->cluster) {
      {
#line 765
      __cil_tmp7 = group_cmp(group1, __cil_tmp6->group, - 1);
      }
#line 765
      return (__cil_tmp7);
    } else
#line 766
    if (! entry2->cluster) {
      {
#line 768
      __cil_tmp9 = group_cmp(__cil_tmp8->group, group2, 1);
      }
#line 768
      return (__cil_tmp9);
    } else {
      {
#line 771
      rc = hol_cluster_cmp(entry1->cluster, entry2->cluster);
      }
#line 771
      if (rc) {
#line 771
        tmp___51 = rc;
      } else {
#line 771
        if (entry1->ord < entry2->ord) {
#line 771
          tmp = - 1;
        } else {
#line 771
          tmp = 1;
        }
#line 771
        tmp___51 = tmp;
      }
#line 771
      return (tmp___51);
    }
  } else
#line 774
  if (group1 == group2) {
    {
#line 778
    __cil_tmp14 = hol_entry_first_short(entry1);
#line 778
    short1 = (int )__cil_tmp14;
#line 779
    __cil_tmp16 = hol_entry_first_short(entry2);
#line 779
    short2 = (int )__cil_tmp16;
#line 780
    doc1 = (entry1->opt)->flags & 8;
#line 781
    doc2 = (entry2->opt)->flags & 8;
#line 782
    __cil_tmp20 = hol_entry_first_long(entry1);
#line 782
    long1 = __cil_tmp20;
#line 783
    __cil_tmp22 = hol_entry_first_long(entry2);
#line 783
    long2 = __cil_tmp22;
    }
#line 785
    if (doc1) {
      {
#line 786
      doc1 = canon_doc_option(& long1);
      }
    }
#line 787
    if (doc2) {
      {
#line 788
      doc2 = canon_doc_option(& long2);
      }
    }
#line 790
    if (doc1 != doc2) {
#line 793
      return (doc1 - doc2);
    } else
#line 794
    if (! short1) {
#line 794
      if (! short2) {
#line 794
        if (long1) {
#line 794
          if (long2) {
            {
#line 796
            rc = strcasecmp(long1, long2);
            }
#line 796
            if (rc) {
#line 796
              tmp___53 = rc;
            } else {
#line 796
              if (entry1->ord < entry2->ord) {
#line 796
                tmp___52 = - 1;
              } else {
#line 796
                tmp___52 = 1;
              }
#line 796
              tmp___53 = tmp___52;
            }
#line 796
            return (tmp___53);
          } else {
#line 794
            goto _L;
          }
        } else {
#line 794
          goto _L;
        }
      } else {
#line 794
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 805
      if (short1) {
#line 805
        tmp___55 = short1;
      } else {
#line 805
        if (long1) {
#line 805
          tmp___54 = (int )((char )*long1);
        } else {
#line 805
          tmp___54 = 0;
        }
#line 805
        tmp___55 = tmp___54;
      }
#line 805
      first1 = (unsigned char )tmp___55;
#line 806
      if (short2) {
#line 806
        tmp___57 = short2;
      } else {
#line 806
        if (long2) {
#line 806
          tmp___56 = (int )((char )*long2);
        } else {
#line 806
          tmp___56 = 0;
        }
#line 806
        tmp___57 = tmp___56;
      }
#line 806
      first2 = (unsigned char )tmp___57;
#line 809
      lower_cmp = 0;
#line 812
      if (lower_cmp) {
#line 812
        tmp___60 = lower_cmp;
      } else {
#line 812
        rc = (int )first2 - (int )first1;
#line 812
        if (rc) {
#line 812
          tmp___59 = rc;
        } else {
#line 812
          if (entry1->ord < entry2->ord) {
#line 812
            tmp___58 = - 1;
          } else {
#line 812
            tmp___58 = 1;
          }
#line 812
          tmp___59 = tmp___58;
        }
#line 812
        tmp___60 = tmp___59;
      }
#line 812
      return (tmp___60);
    }
  } else {
#line 820
    if (entry1->ord < entry2->ord) {
#line 820
      tmp___61 = - 1;
    } else {
#line 820
      tmp___61 = 1;
    }
    {
#line 820
    __cil_tmp39 = group_cmp(group1, group2, tmp___61);
    }
#line 820
    return (__cil_tmp39);
  }
}
}
#line 825 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int hol_entry_qcmp(void const   *entry1_v , void const   *entry2_v ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 827
  __cil_tmp3 = hol_entry_cmp((struct hol_entry *)entry1_v, (struct hol_entry *)entry2_v);
  }
#line 827
  return (__cil_tmp3);
}
}
#line 834 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void hol_sort(struct hol *hol ) 
{ 
  unsigned int i ;
  struct hol_entry *e ;
  unsigned int __cil_tmp4 ;
  struct hol_entry *__cil_tmp5 ;

  {
#line 836
  if (hol->num_entries > 0U) {
#line 840
    e = hol->entries;
#line 840
    i = (unsigned int )0;
    {
    {
#line 840
    while (1) {
      while_continue: /* CIL Label */ ;

#line 840
      if (! (i < hol->num_entries)) {
#line 840
        goto while_break;
      }
#line 841
      e->ord = i;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 840
    __cil_tmp5 = e;
#line 840
    e ++;
    {
#line 840
    __cil_tmp4 = i;
#line 840
    i ++;
#line 842
    qsort((void *)hol->entries, (size_t )hol->num_entries, sizeof(struct hol_entry ),
          hol_entry_qcmp);
    }
  }
}
}
#line 850 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void hol_append(struct hol *hol , struct hol *more ) 
{ 
  struct hol_cluster **cl_end ;
  unsigned int left ;
  char *so ;
  char *more_so ;
  struct hol_entry *e ;
  unsigned int num_entries ;
  struct hol_entry *entries ;
  void *__cil_tmp10 ;
  unsigned int hol_so_len ;
  size_t __cil_tmp12 ;
  char *short_options ;
  size_t __cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp18 ;
  struct hol_entry *__cil_tmp19 ;
  unsigned int __cil_tmp20 ;
  int opts_left ;
  struct argp_option *opt ;
  int ch ;
  int __cil_tmp24 ;
  int __cil_tmp25 ;
  char *__cil_tmp26 ;
  struct argp_option *__cil_tmp28 ;
  int __cil_tmp29 ;
  struct hol_entry *__cil_tmp30 ;
  unsigned int __cil_tmp31 ;

  {
#line 852
  cl_end = & hol->clusters;
  {
  {
#line 855
  while (1) {
    while_continue: /* CIL Label */ ;

#line 855
    if (! *cl_end) {
#line 855
      goto while_break;
    }
#line 856
    cl_end = & (*cl_end)->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  *cl_end = more->clusters;
#line 858
  more->clusters = (struct hol_cluster *)0;
#line 861
  if (more->num_entries > 0U) {
#line 863
    if (hol->num_entries == 0U) {
#line 865
      hol->num_entries = more->num_entries;
#line 866
      hol->entries = more->entries;
#line 867
      hol->short_options = more->short_options;
#line 868
      more->num_entries = (unsigned int )0;
    } else {
      {
#line 877
      num_entries = hol->num_entries + more->num_entries;
#line 878
      __cil_tmp10 = malloc((unsigned long )num_entries * sizeof(struct hol_entry ));
#line 878
      entries = (struct hol_entry *)__cil_tmp10;
#line 880
      __cil_tmp12 = strlen((char const   *)hol->short_options);
#line 880
      hol_so_len = (unsigned int )__cil_tmp12;
#line 881
      __cil_tmp14 = strlen((char const   *)more->short_options);
#line 881
      __cil_tmp15 = malloc(((unsigned long )hol_so_len + __cil_tmp14) + 1UL);
#line 881
      short_options = (char *)__cil_tmp15;
      }
#line 885
      if (0) {

      }
      {
#line 888
      __cil_tmp18 = mempcpy((void *)entries, (void const   *)hol->entries, (unsigned long )hol->num_entries * sizeof(struct hol_entry ));
#line 888
      mempcpy(__cil_tmp18, (void const   *)more->entries, (unsigned long )more->num_entries * sizeof(struct hol_entry ));
#line 893
      mempcpy((void *)short_options, (void const   *)hol->short_options, (size_t )hol_so_len);
#line 896
      left = hol->num_entries;
      }
#line 896
      e = entries;
      {
      {
#line 896
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 896
        if (! (left > 0U)) {
#line 896
          goto while_break___0;
        }
#line 897
        e->short_options = short_options + (e->short_options - hol->short_options);
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 896
      __cil_tmp20 = left;
#line 896
      left --;
#line 896
      __cil_tmp19 = e;
#line 896
      e ++;
#line 902
      so = short_options + hol_so_len;
#line 903
      more_so = more->short_options;
#line 904
      left = more->num_entries;
      {
      {
#line 904
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 904
        if (! (left > 0U)) {
#line 904
          goto while_break___1;
        }
#line 909
        e->short_options = so;
#line 911
        opt = e->opt;
#line 911
        opts_left = (int )e->num;
        {
        {
#line 911
        while (1) {
          while_continue___2: /* CIL Label */ ;

#line 911
          if (! opts_left) {
#line 911
            goto while_break___2;
          }
          {
#line 913
          ch = (int )*more_so;
#line 914
          __cil_tmp24 = _option_is_short(opt);
          }
#line 914
          if (__cil_tmp24) {
#line 914
            if (ch == opt->key) {
              {
#line 917
              __cil_tmp25 = find_char((char )ch, short_options, short_options + hol_so_len);
              }
#line 917
              if (! __cil_tmp25) {
#line 921
                __cil_tmp26 = so;
#line 921
                so ++;
#line 921
                *__cil_tmp26 = (char )ch;
              }
#line 922
              more_so ++;
            }
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 911
        __cil_tmp29 = opts_left;
#line 911
        opts_left --;
#line 911
        __cil_tmp28 = opt;
#line 911
        opt ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 904
      __cil_tmp31 = left;
#line 904
      left --;
      {
#line 904
      __cil_tmp30 = e;
#line 904
      e ++;
#line 927
      *so = (char )'\000';
#line 929
      free((void *)hol->entries);
#line 930
      free((void *)hol->short_options);
#line 932
      hol->entries = entries;
#line 933
      hol->num_entries = num_entries;
#line 934
      hol->short_options = short_options;
      }
    }
  }
  {
#line 938
  hol_free(more);
  }
}
}
#line 943 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void indent_to(argp_fmtstream_t stream , unsigned int col ) 
{ 
  int needed ;
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 945
  __cil_tmp4 = argp_fmtstream_point(stream);
#line 945
  needed = (int )((unsigned long )col - __cil_tmp4);
  }
  {
  {
#line 946
  while (1) {
    while_continue: /* CIL Label */ ;

#line 946
    if (! (__cil_tmp5 > 0)) {
#line 946
      goto while_break;
    }
    {
#line 947
    argp_fmtstream_putc(stream, ' ');
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 953 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void space(argp_fmtstream_t stream , size_t ensure ) 
{ 
  size_t __cil_tmp3 ;

  {
  {
#line 955
  __cil_tmp3 = argp_fmtstream_point(stream);
  }
#line 955
  if (__cil_tmp3 + ensure >= stream->rmargin) {
    {
#line 957
    argp_fmtstream_putc(stream, '\n');
    }
  } else {
    {
#line 959
    argp_fmtstream_putc(stream, ' ');
    }
  }
}
}
#line 966 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void arg(struct argp_option *real , char const   *req_fmt , char const   *opt_fmt ,
                char const   *domain , argp_fmtstream_t stream ) 
{ 
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 969
  if (real->arg) {
#line 971
    if (real->flags & 1) {
      {
#line 972
      __cil_tmp6 = dcgettext(domain, real->arg, 5);
#line 972
      argp_fmtstream_printf(stream, opt_fmt, __cil_tmp6);
      }
    } else {
      {
#line 975
      __cil_tmp7 = dcgettext(domain, real->arg, 5);
#line 975
      argp_fmtstream_printf(stream, req_fmt, __cil_tmp7);
      }
    }
  }
}
}
#line 1015 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static char const   *filter_doc(char const   *doc___0 , int key , struct argp *argp___0 ,
                                struct argp_state *state ) 
{ 
  void *input___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1018
  if (argp___0->help_filter) {
    {
#line 1021
    __cil_tmp6 = _argp_input(argp___0, state);
#line 1021
    input___0 = __cil_tmp6;
#line 1022
    __cil_tmp7 = (*(argp___0->help_filter))(key, doc___0, input___0);
    }
#line 1022
    return ((char const   *)__cil_tmp7);
  } else {
#line 1026
    return (doc___0);
  }
}
}
#line 1035 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void print_header(char const   *str , struct argp *argp___0 , struct pentry_state *pest ) 
{ 
  char const   *tstr ;
  char *__cil_tmp5 ;
  char const   *fstr ;
  char const   *__cil_tmp7 ;

  {
  {
#line 1038
  __cil_tmp5 = dcgettext(argp___0->argp_domain, str, 5);
#line 1038
  tstr = (char const   *)__cil_tmp5;
#line 1039
  __cil_tmp7 = filter_doc(tstr, 33554435, argp___0, pest->state);
#line 1039
  fstr = __cil_tmp7;
  }
#line 1041
  if (fstr) {
#line 1043
    if ((char )*fstr) {
#line 1045
      if ((pest->hhstate)->prev_entry) {
        {
#line 1047
        argp_fmtstream_putc(pest->stream, '\n');
        }
      }
      {
#line 1048
      indent_to(pest->stream, (unsigned int )uparams.header_col);
#line 1049
      argp_fmtstream_set_lmargin(pest->stream, (size_t )uparams.header_col);
#line 1050
      argp_fmtstream_set_wmargin(pest->stream, (size_t )uparams.header_col);
#line 1051
      argp_fmtstream_puts(pest->stream, fstr);
#line 1052
      argp_fmtstream_set_lmargin(pest->stream, (size_t )0);
#line 1053
      argp_fmtstream_putc(pest->stream, '\n');
      }
    }
#line 1056
    (pest->hhstate)->sep_groups = 1;
  }
#line 1059
  if (fstr != tstr) {
    {
#line 1060
    free((void *)((char *)fstr));
    }
  }
}
}
#line 1068 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void comma(unsigned int col , struct pentry_state *pest ) 
{ 
  struct hol_entry *pe ;
  struct hol_cluster *cl ;
  int __cil_tmp5 ;
  int old_wm ;

  {
#line 1070
  if (pest->first) {
#line 1072
    pe = (pest->hhstate)->prev_entry;
#line 1073
    cl = (pest->entry)->cluster;
#line 1075
    if ((pest->hhstate)->sep_groups) {
#line 1075
      if (pe) {
#line 1075
        if ((pest->entry)->group != pe->group) {
          {
#line 1076
          argp_fmtstream_putc(pest->stream, '\n');
          }
        }
      }
    }
    {
#line 1078
    __cil_tmp5 = hol_cluster_is_child(pe->cluster, cl);
    }
#line 1078
    if (cl) {
#line 1078
      if (cl->header) {
#line 1078
        if ((int )((char )*(cl->header))) {
#line 1078
          if (! pe) {
            {
#line 1087
            old_wm = (int )(pest->stream)->wmargin;
            {
#line 1088
            print_header(cl->header, cl->argp, pest);
            }
            {
#line 1089
            argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
            }
            }
          } else
#line 1078
          if (pe->cluster != cl) {
#line 1078
            if (! __cil_tmp5) {
              {
#line 1087
              old_wm = (int )(pest->stream)->wmargin;
              {
#line 1088
              print_header(cl->header, cl->argp, pest);
              }
              {
#line 1089
              argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
              }
              }
            }
          }
        }
      }
    }
#line 1092
    pest->first = 0;
  } else {
    {
#line 1095
    argp_fmtstream_puts(pest->stream, (char const   *)((char *)", "));
    }
  }
  {
#line 1097
  indent_to(pest->stream, col);
  }
}
}
#line 1102 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void hol_entry_help(struct hol_entry *entry , struct argp_state *state , argp_fmtstream_t stream ,
                           struct hol_help_state *hhstate ) 
{ 
  unsigned int num ;
  struct argp_option *real ;
  struct argp_option *opt ;
  char *so ;
  int have_long_opt ;
  int old_lm ;
  size_t __cil_tmp11 ;
  int old_wm ;
  struct pentry_state pest ;
  struct argp_option *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;
  int __cil_tmp16 ;
  struct argp_option *__cil_tmp18 ;
  unsigned int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char const   *tmp ;
  struct argp_option *__cil_tmp22 ;
  unsigned int __cil_tmp23 ;
  int first_long_opt ;
  struct argp_option *__cil_tmp25 ;
  unsigned int __cil_tmp26 ;
  int __cil_tmp27 ;
  char const   *tstr ;
  char *__cil_tmp29 ;
  char *tmp___0 ;
  char const   *fstr ;
  char const   *__cil_tmp32 ;
  unsigned int col ;
  size_t __cil_tmp34 ;

  {
  {
#line 1106
  real = entry->opt;
#line 1107
  so = entry->short_options;
#line 1108
  have_long_opt = 0;
#line 1110
  __cil_tmp11 = argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1110
  old_lm = (int )__cil_tmp11;
#line 1111
  old_wm = (int )stream->wmargin;
#line 1116
  pest.entry = entry;
#line 1117
  pest.stream = stream;
#line 1118
  pest.hhstate = hhstate;
#line 1119
  pest.first = 1;
#line 1120
  pest.state = state;
  }
#line 1122
  if (! (real->flags & 8)) {
#line 1123
    num = entry->num;
#line 1123
    opt = real;
    {
    {
#line 1123
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1123
      if (! (num > 0U)) {
#line 1123
        goto while_break;
      }
#line 1124
      if (opt->name) {
#line 1124
        if (! (opt->flags & 2)) {
#line 1126
          have_long_opt = 1;
#line 1127
          goto while_break;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1123
    __cil_tmp15 = num;
#line 1123
    num --;
#line 1123
    __cil_tmp14 = opt;
#line 1123
    opt ++;
  }
  {
#line 1131
  argp_fmtstream_set_wmargin(stream, (size_t )uparams.short_opt_col);
#line 1132
  num = entry->num;
  }
#line 1132
  opt = real;
  {
  {
#line 1132
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 1132
    if (! (num > 0U)) {
#line 1132
      goto while_break___0;
    }
    {
#line 1133
    __cil_tmp16 = _option_is_short(opt);
    }
#line 1133
    if (__cil_tmp16) {
#line 1133
      if (opt->key == (int )*so) {
#line 1136
        if (! (opt->flags & 2)) {
          {
#line 1138
          comma((unsigned int )uparams.short_opt_col, & pest);
#line 1139
          argp_fmtstream_putc(stream, '-');
#line 1140
          argp_fmtstream_putc(stream, (int )*so);
          }
#line 1141
          if (! have_long_opt) {
            {
            {
#line 1142
            arg(real, (char const   *)((char *)" %s"), (char const   *)((char *)"[%s]"),
                (state->root_argp)->argp_domain, stream);
            }
            }
          } else
#line 1141
          if (uparams.dup_args) {
            {
            {
#line 1142
            arg(real, (char const   *)((char *)" %s"), (char const   *)((char *)"[%s]"),
                (state->root_argp)->argp_domain, stream);
            }
            }
          } else
#line 1143
          if (real->arg) {
#line 1144
            hhstate->suppressed_dup_arg = 1;
          }
        }
#line 1146
        so ++;
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1132
  __cil_tmp19 = num;
#line 1132
  num --;
#line 1132
  __cil_tmp18 = opt;
#line 1132
  opt ++;
#line 1150
  if (real->flags & 8) {
    {
#line 1153
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.doc_opt_col);
#line 1154
    num = entry->num;
    }
#line 1154
    opt = real;
    {
    {
#line 1154
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1154
      if (! (num > 0U)) {
#line 1154
        goto while_break___1;
      }
#line 1155
      if (opt->name) {
#line 1155
        if ((int )((char )*(opt->name))) {
#line 1155
          if (! (opt->flags & 2)) {
            {
#line 1157
            comma((unsigned int )uparams.doc_opt_col, & pest);
            }
#line 1161
            if (opt->flags & 32) {
#line 1161
              tmp = opt->name;
            } else {
              {
#line 1161
              __cil_tmp20 = dcgettext((state->root_argp)->argp_domain, opt->name,
                                      5);
#line 1161
              tmp = (char const   *)__cil_tmp20;
              }
            }
            {
#line 1161
            argp_fmtstream_puts(stream, tmp);
            }
          }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1154
    __cil_tmp23 = num;
#line 1154
    num --;
#line 1154
    __cil_tmp22 = opt;
#line 1154
    opt ++;
  } else {
    {
#line 1171
    first_long_opt = 1;
#line 1173
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.long_opt_col);
#line 1174
    num = entry->num;
    }
#line 1174
    opt = real;
    {
    {
#line 1174
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 1174
      if (! (num > 0U)) {
#line 1174
        goto while_break___2;
      }
#line 1175
      if (opt->name) {
#line 1175
        if (! (opt->flags & 2)) {
          {
#line 1177
          comma((unsigned int )uparams.long_opt_col, & pest);
#line 1178
          argp_fmtstream_printf(stream, (char const   *)((char *)"--%s"), opt->name);
          }
#line 1179
          if (first_long_opt) {
            {
            {
#line 1180
            arg(real, (char const   *)((char *)"=%s"), (char const   *)((char *)"[=%s]"),
                (state->root_argp)->argp_domain, stream);
            }
            }
          } else
#line 1179
          if (uparams.dup_args) {
            {
            {
#line 1180
            arg(real, (char const   *)((char *)"=%s"), (char const   *)((char *)"[=%s]"),
                (state->root_argp)->argp_domain, stream);
            }
            }
          } else
#line 1182
          if (real->arg) {
#line 1183
            hhstate->suppressed_dup_arg = 1;
          }
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1174
    __cil_tmp26 = num;
#line 1174
    num --;
#line 1174
    __cil_tmp25 = opt;
#line 1174
    opt ++;
  }
  {
#line 1188
  argp_fmtstream_set_lmargin(stream, (size_t )0);
  }
#line 1190
  if (pest.first) {
    {
#line 1193
    __cil_tmp27 = _option_is_short(real);
    }
#line 1193
    if (! __cil_tmp27) {
#line 1193
      if (! real->name) {
        {
#line 1195
        print_header(real->doc, entry->argp, & pest);
        }
      } else {
#line 1198
        goto cleanup;
      }
    } else {
#line 1198
      goto cleanup;
    }
  } else {
#line 1202
    if (real->doc) {
      {
#line 1202
      __cil_tmp29 = dcgettext((state->root_argp)->argp_domain, real->doc, 5);
#line 1202
      tmp___0 = __cil_tmp29;
      }
    } else {
#line 1202
      tmp___0 = (char *)0;
    }
    {
#line 1202
    tstr = (char const   *)tmp___0;
#line 1204
    __cil_tmp32 = filter_doc(tstr, real->key, entry->argp, state);
#line 1204
    fstr = __cil_tmp32;
    }
#line 1205
    if (fstr) {
#line 1205
      if ((int )((char )*fstr)) {
        {
#line 1207
        __cil_tmp34 = argp_fmtstream_point(stream);
#line 1207
        col = (unsigned int )__cil_tmp34;
#line 1209
        argp_fmtstream_set_lmargin(stream, (size_t )uparams.opt_doc_col);
#line 1210
        argp_fmtstream_set_wmargin(stream, (size_t )uparams.opt_doc_col);
        }
#line 1212
        if (col > (unsigned int )(uparams.opt_doc_col + 3)) {
          {
#line 1213
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1214
        if (col >= (unsigned int )uparams.opt_doc_col) {
          {
#line 1215
          argp_fmtstream_puts(stream, (char const   *)((char *)"   "));
          }
        } else {
          {
#line 1217
          indent_to(stream, (unsigned int )uparams.opt_doc_col);
          }
        }
        {
#line 1219
        argp_fmtstream_puts(stream, fstr);
        }
      }
    }
#line 1221
    if (fstr) {
#line 1221
      if (fstr != tstr) {
        {
#line 1222
        free((void *)((char *)fstr));
        }
      }
    }
    {
#line 1225
    argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1226
    argp_fmtstream_putc(stream, '\n');
    }
  }
#line 1229
  hhstate->prev_entry = entry;
  cleanup: 
  {
#line 1232
  argp_fmtstream_set_lmargin(stream, (size_t )old_lm);
  }
  {
#line 1233
  argp_fmtstream_set_wmargin(stream, (size_t )old_wm);
  }
}
}
#line 1238 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void hol_help(struct hol *hol , struct argp_state *state , argp_fmtstream_t stream ) 
{ 
  unsigned int num ;
  struct hol_entry *entry ;
  struct hol_help_state hhstate ;
  struct hol_entry *__cil_tmp7 ;
  unsigned int __cil_tmp8 ;
  char const   *tstr ;
  char *__cil_tmp10 ;
  char const   *fstr ;
  struct argp *tmp ;
  char const   *__cil_tmp13 ;

  {
#line 1243
  hhstate.prev_entry = (struct hol_entry *)0;
#line 1243
  hhstate.sep_groups = 0;
#line 1243
  hhstate.suppressed_dup_arg = 0;
#line 1245
  num = hol->num_entries;
#line 1245
  entry = hol->entries;
  {
  {
#line 1245
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1245
    if (! (num > 0U)) {
#line 1245
      goto while_break;
    }
    {
#line 1246
    hol_entry_help(entry, state, stream, & hhstate);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1245
  __cil_tmp8 = num;
#line 1245
  num --;
#line 1245
  __cil_tmp7 = entry;
#line 1245
  entry ++;
#line 1248
  if (hhstate.suppressed_dup_arg) {
#line 1248
    if (uparams.dup_args_note) {
      {
#line 1250
      __cil_tmp10 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options."),
                              5);
#line 1250
      tstr = (char const   *)__cil_tmp10;
      }
#line 1253
      if (state) {
#line 1253
        tmp = state->root_argp;
      } else {
#line 1253
        tmp = (struct argp *)0;
      }
      {
#line 1253
      __cil_tmp13 = filter_doc(tstr, 33554437, tmp, state);
#line 1253
      fstr = __cil_tmp13;
      }
#line 1255
      if (fstr) {
#line 1255
        if ((int )((char )*fstr)) {
          {
#line 1257
          argp_fmtstream_putc(stream, '\n');
#line 1258
          argp_fmtstream_puts(stream, fstr);
#line 1259
          argp_fmtstream_putc(stream, '\n');
          }
        }
      }
#line 1261
      if (fstr) {
#line 1261
        if (fstr != tstr) {
          {
#line 1262
          free((void *)((char *)fstr));
          }
        }
      }
    }
  }
}
}
#line 1271 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int add_argless_short_opt(struct argp_option *opt , struct argp_option *real ,
                                 char const   *domain , void *cookie ) 
{ 
  char **snao_end ;
  char *__cil_tmp6 ;

  {
#line 1275
  snao_end = (char **)cookie;
#line 1276
  if (! (opt->arg || real->arg)) {
#line 1276
    if (! ((opt->flags | real->flags) & 16)) {
#line 1278
      __cil_tmp6 = *snao_end;
#line 1278
      (*snao_end) ++;
#line 1278
      *__cil_tmp6 = (char )opt->key;
    }
  }
#line 1279
  return (0);
}
}
#line 1285 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int usage_argful_short_opt(struct argp_option *opt , struct argp_option *real ,
                                  char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___63 ;
  int flags ;
  char *__cil_tmp8 ;
  size_t __cil_tmp9 ;

  {
#line 1289
  stream = (argp_fmtstream_t )cookie;
#line 1290
  arg___63 = opt->arg;
#line 1291
  flags = opt->flags | real->flags;
#line 1293
  if (! arg___63) {
#line 1294
    arg___63 = real->arg;
  }
#line 1296
  if (arg___63) {
#line 1296
    if (! (flags & 16)) {
      {
#line 1298
      __cil_tmp8 = dcgettext(domain, arg___63, 5);
#line 1298
      arg___63 = (char const   *)__cil_tmp8;
      }
#line 1300
      if (flags & 1) {
        {
#line 1301
        argp_fmtstream_printf(stream, (char const   *)((char *)" [-%c[%s]]"), opt->key,
                              arg___63);
        }
      } else {
        {
#line 1306
        __cil_tmp9 = strlen(arg___63);
#line 1306
        space(stream, 6UL + __cil_tmp9);
#line 1307
        argp_fmtstream_printf(stream, (char const   *)((char *)"[-%c %s]"), opt->key,
                              arg___63);
        }
      }
    }
  }
#line 1311
  return (0);
}
}
#line 1317 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int usage_long_opt(struct argp_option *opt , struct argp_option *real , char const   *domain ,
                          void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___64 ;
  int flags ;
  char *__cil_tmp8 ;

  {
#line 1321
  stream = (argp_fmtstream_t )cookie;
#line 1322
  arg___64 = opt->arg;
#line 1323
  flags = opt->flags | real->flags;
#line 1325
  if (! arg___64) {
#line 1326
    arg___64 = real->arg;
  }
#line 1328
  if (! (flags & 16)) {
#line 1328
    if (! (opt->flags & 8)) {
#line 1330
      if (arg___64) {
        {
#line 1332
        __cil_tmp8 = dcgettext(domain, arg___64, 5);
#line 1332
        arg___64 = (char const   *)__cil_tmp8;
        }
#line 1333
        if (flags & 1) {
          {
#line 1334
          argp_fmtstream_printf(stream, (char const   *)((char *)" [--%s[=%s]]"),
                                opt->name, arg___64);
          }
        } else {
          {
#line 1336
          argp_fmtstream_printf(stream, (char const   *)((char *)" [--%s=%s]"), opt->name,
                                arg___64);
          }
        }
      } else {
        {
#line 1339
        argp_fmtstream_printf(stream, (char const   *)((char *)" [--%s]"), opt->name);
        }
      }
    }
  }
#line 1342
  return (0);
}
}
#line 1347 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void hol_usage(struct hol *hol , argp_fmtstream_t stream ) 
{ 
  unsigned int nentries ;
  struct hol_entry *entry ;
  char *short_no_arg_opts ;
  size_t __cil_tmp6 ;
  void *__cil_tmp7 ;
  char *snao_end ;
  struct hol_entry *__cil_tmp9 ;
  unsigned int __cil_tmp10 ;
  char *__cil_tmp11 ;
  struct hol_entry *__cil_tmp12 ;
  unsigned int __cil_tmp13 ;
  struct hol_entry *__cil_tmp14 ;
  unsigned int __cil_tmp15 ;

  {
#line 1349
  if (hol->num_entries > 0U) {
    {
#line 1353
    __cil_tmp6 = strlen((char const   *)hol->short_options);
#line 1353
    __cil_tmp7 = __builtin_alloca(__cil_tmp6 + 1UL);
#line 1353
    short_no_arg_opts = (char *)__cil_tmp7;
#line 1354
    snao_end = short_no_arg_opts;
#line 1357
    nentries = hol->num_entries;
    }
#line 1357
    entry = hol->entries;
    {
    {
#line 1357
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1357
      if (! (nentries > 0U)) {
#line 1357
        goto while_break;
      }
      {
#line 1360
      hol_entry_short_iterate(entry, add_argless_short_opt, (entry->argp)->argp_domain,
                              (void *)(& snao_end));
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1359
    __cil_tmp10 = nentries;
#line 1359
    nentries --;
#line 1359
    __cil_tmp9 = entry;
#line 1359
    entry ++;
#line 1362
    if (snao_end > short_no_arg_opts) {
      {
#line 1364
      __cil_tmp11 = snao_end;
#line 1364
      snao_end ++;
#line 1364
      *__cil_tmp11 = (char )0;
#line 1365
      argp_fmtstream_printf(stream, (char const   *)((char *)" [-%s]"), short_no_arg_opts);
      }
    }
#line 1369
    nentries = hol->num_entries;
#line 1369
    entry = hol->entries;
    {
    {
#line 1369
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1369
      if (! (nentries > 0U)) {
#line 1369
        goto while_break___0;
      }
      {
#line 1372
      hol_entry_short_iterate(entry, usage_argful_short_opt, (entry->argp)->argp_domain,
                              (void *)stream);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1371
    __cil_tmp13 = nentries;
#line 1371
    nentries --;
#line 1371
    __cil_tmp12 = entry;
#line 1371
    entry ++;
#line 1376
    nentries = hol->num_entries;
#line 1376
    entry = hol->entries;
    {
    {
#line 1376
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 1376
      if (! (nentries > 0U)) {
#line 1376
        goto while_break___1;
      }
      {
#line 1379
      hol_entry_long_iterate(entry, usage_long_opt, (entry->argp)->argp_domain, (void *)stream);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1378
    __cil_tmp15 = nentries;
#line 1378
    nentries --;
#line 1378
    __cil_tmp14 = entry;
#line 1378
    entry ++;
  }
}
}
#line 1387 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static struct hol *argp_hol(struct argp *argp___0 , struct hol_cluster *cluster ) 
{ 
  struct argp_child *child ;
  struct hol *hol ;
  struct hol *__cil_tmp5 ;
  struct hol_cluster *child_cluster ;
  struct hol_cluster *__cil_tmp7 ;
  struct hol_cluster *tmp ;
  struct hol *__cil_tmp9 ;

  {
  {
#line 1389
  child = argp___0->children;
#line 1390
  __cil_tmp5 = make_hol(argp___0, cluster);
#line 1390
  hol = __cil_tmp5;
  }
#line 1391
  if (child) {
    {
    {
#line 1392
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1392
      if (! child->argp) {
#line 1392
        goto while_break;
      }
#line 1394
      if (child->group || child->header) {
        {
#line 1394
        __cil_tmp7 = hol_add_cluster(hol, child->group, child->header, (int )(child - argp___0->children),
                                     cluster, argp___0);
#line 1394
        tmp = __cil_tmp7;
        }
      } else {
#line 1394
        tmp = cluster;
      }
      {
#line 1394
      child_cluster = tmp;
#line 1401
      __cil_tmp9 = argp_hol(child->argp, child_cluster);
#line 1401
      hol_append(hol, __cil_tmp9);
#line 1402
      child ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1404
  return (hol);
}
}
#line 1410 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static size_t argp_args_levels(struct argp *argp___0 ) 
{ 
  size_t levels ;
  struct argp_child *child ;
  char *__cil_tmp4 ;
  size_t __cil_tmp7 ;

  {
  {
#line 1412
  levels = (size_t )0;
#line 1413
  child = argp___0->children;
#line 1415
  __cil_tmp4 = strchr(argp___0->args_doc, '\n');
  }
#line 1415
  if (argp___0->args_doc) {
#line 1415
    if (__cil_tmp4) {
#line 1416
      levels ++;
    }
  }
#line 1418
  if (child) {
    {
    {
#line 1419
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1419
      if (! child->argp) {
#line 1419
        goto while_break;
      }
      {
#line 1420
      __cil_tmp7 = argp_args_levels(child->argp);
      }
#line 1420
      levels += __cil_tmp7;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1422
  return (levels);
}
}
#line 1431 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int argp_args_usage(struct argp *argp___0 , struct argp_state *state , char **levels ,
                           int advance , argp_fmtstream_t stream ) 
{ 
  char *our_level ;
  int multiple ;
  struct argp_child *child ;
  char const   *tdoc ;
  char *__cil_tmp10 ;
  char const   *nl ;
  char const   *fdoc ;
  char const   *__cil_tmp13 ;
  char const   *cp ;
  char *__cil_tmp15 ;
  int i ;
  char *__cil_tmp17 ;
  int __cil_tmp21 ;

  {
  {
#line 1434
  our_level = *levels;
#line 1435
  multiple = 0;
#line 1436
  child = argp___0->children;
#line 1437
  __cil_tmp10 = dcgettext(argp___0->argp_domain, argp___0->args_doc, 5);
#line 1437
  tdoc = (char const   *)__cil_tmp10;
  }
  {
#line 1437
  nl = (char const   *)0;
#line 1438
  __cil_tmp13 = filter_doc(tdoc, 33554438, argp___0, state);
#line 1438
  fdoc = __cil_tmp13;
  }
#line 1440
  if (fdoc) {
    {
#line 1442
    cp = fdoc;
#line 1443
    __cil_tmp15 = strchrnul(cp, '\n');
#line 1443
    nl = (char const   *)__cil_tmp15;
    }
#line 1444
    if ((int )((char )*nl) != 0) {
#line 1449
      multiple = 1;
#line 1450
      i = 0;
      {
      {
#line 1450
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1450
        if (! (i < (int )*our_level)) {
#line 1450
          goto while_break;
        }
        {
#line 1451
        __cil_tmp17 = strchrnul(cp, '\n');
#line 1451
        nl = (char const   *)__cil_tmp17;
        }
#line 1451
        cp = nl + 1;
      }
      while_break___1: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 1450
      i ++;
#line 1452
      (*levels) ++;
    }
    {
#line 1457
    space(stream, (size_t )((1 + nl) - cp));
#line 1459
    argp_fmtstream_write(stream, cp, (size_t )(nl - cp));
    }
  }
#line 1461
  if (fdoc) {
#line 1461
    if (fdoc != tdoc) {
      {
#line 1462
      free((void *)((char *)fdoc));
      }
    }
  }
#line 1464
  if (child) {
    {
    {
#line 1465
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1465
      if (! child->argp) {
#line 1465
        goto while_break___0;
      }
      {
#line 1466
      __cil_tmp21 = argp_args_usage(child->argp, state, levels, advance, stream);
#line 1466
      advance = ! __cil_tmp21;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1468
  if (advance) {
#line 1468
    if (multiple) {
#line 1471
      if ((char )*nl) {
#line 1474
        (*our_level) ++;
#line 1475
        advance = 0;
      } else
#line 1477
      if ((int )*our_level > 0) {
#line 1479
        *our_level = (char )0;
      }
    }
  }
#line 1482
  return (! advance);
}
}
#line 1493 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static int argp_doc(struct argp *argp___0 , struct argp_state *state , int post ,
                    int pre_blank , int first_only , argp_fmtstream_t stream ) 
{ 
  char const   *text ;
  char const   *inp_text ;
  size_t inp_text_len ;
  char const   *trans_text ;
  void *input___0 ;
  int anything ;
  struct argp_child *child ;
  char *vt ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char const   *tmp ;
  char *__cil_tmp18 ;
  char *tmp___65 ;
  int tmp___66 ;
  char *__cil_tmp22 ;
  size_t __cil_tmp23 ;
  char *__cil_tmp24 ;
  size_t __cil_tmp25 ;
  int __cil_tmp27 ;

  {
#line 1499
  inp_text_len = (size_t )0;
#line 1501
  input___0 = (void *)0;
#line 1502
  anything = 0;
#line 1503
  child = argp___0->children;
#line 1505
  if (argp___0->doc) {
    {
#line 1507
    __cil_tmp15 = strchr(argp___0->doc, '\v');
#line 1507
    vt = __cil_tmp15;
    }
#line 1508
    if (vt) {
#line 1510
      if (post) {
#line 1511
        inp_text = (char const   *)(vt + 1);
      } else {
        {
#line 1514
        inp_text_len = (size_t )(vt - argp___0->doc);
#line 1515
        __cil_tmp16 = strndup(argp___0->doc, inp_text_len);
#line 1515
        inp_text = (char const   *)__cil_tmp16;
        }
      }
    } else {
#line 1519
      if (post) {
#line 1519
        tmp = (char const   *)0;
      } else {
#line 1519
        tmp = argp___0->doc;
      }
#line 1519
      inp_text = tmp;
    }
#line 1520
    if (inp_text) {
      {
#line 1520
      __cil_tmp18 = dcgettext(argp___0->argp_domain, inp_text, 5);
#line 1520
      tmp___65 = __cil_tmp18;
      }
    } else {
#line 1520
      tmp___65 = (char *)((void *)0);
    }
#line 1520
    trans_text = (char const   *)tmp___65;
  } else {
#line 1523
    inp_text = (char const   *)0;
#line 1523
    trans_text = inp_text;
  }
#line 1525
  if (argp___0->help_filter) {
    {
#line 1528
    input___0 = _argp_input(argp___0, state);
    }
#line 1529
    if (post) {
#line 1529
      tmp___66 = 33554434;
    } else {
#line 1529
      tmp___66 = 33554433;
    }
    {
#line 1529
    __cil_tmp22 = (*(argp___0->help_filter))(tmp___66, trans_text, input___0);
#line 1529
    text = (char const   *)__cil_tmp22;
    }
  } else {
#line 1536
    text = trans_text;
  }
#line 1538
  if (text) {
#line 1540
    if (pre_blank) {
      {
#line 1541
      argp_fmtstream_putc(stream, '\n');
      }
    }
    {
#line 1543
    argp_fmtstream_puts(stream, text);
#line 1545
    __cil_tmp23 = argp_fmtstream_point(stream);
    }
#line 1545
    if (__cil_tmp23 > stream->lmargin) {
      {
#line 1546
      argp_fmtstream_putc(stream, '\n');
      }
    }
#line 1548
    anything = 1;
  }
#line 1551
  if (text) {
#line 1551
    if (text != trans_text) {
      {
#line 1552
      free((void *)((char *)text));
      }
    }
  }
#line 1554
  if (inp_text) {
#line 1554
    if (inp_text_len) {
      {
#line 1555
      free((void *)((char *)inp_text));
      }
    }
  }
#line 1557
  if (post) {
#line 1557
    if (argp___0->help_filter) {
      {
#line 1560
      __cil_tmp24 = (*(argp___0->help_filter))(33554436, (char const   *)0, input___0);
#line 1560
      text = (char const   *)__cil_tmp24;
      }
#line 1561
      if (text) {
#line 1563
        if (anything) {
          {
          {
#line 1564
          argp_fmtstream_putc(stream, '\n');
          }
          }
        } else
#line 1563
        if (pre_blank) {
          {
          {
#line 1564
          argp_fmtstream_putc(stream, '\n');
          }
          }
        }
        {
#line 1565
        argp_fmtstream_puts(stream, text);
#line 1566
        free((void *)((char *)text));
#line 1567
        __cil_tmp25 = argp_fmtstream_point(stream);
        }
#line 1567
        if (__cil_tmp25 > stream->lmargin) {
          {
#line 1569
          argp_fmtstream_putc(stream, '\n');
          }
        }
#line 1570
        anything = 1;
      }
    }
  }
#line 1574
  if (child) {
    {
    {
#line 1575
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1575
      if (! (child->argp && ! (first_only && anything))) {
#line 1575
        goto while_break;
      }
      {
#line 1576
      __cil_tmp27 = argp_doc(child->argp, state, post, anything || pre_blank, first_only,
                             stream);
      }
#line 1576
      anything |= __cil_tmp27;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1581
  return (anything);
}
}
#line 1589 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
static void _help(struct argp *argp___0 , struct argp_state *state , FILE *stream ,
                  unsigned int flags , char *name ) 
{ 
  int anything ;
  struct hol *hol ;
  argp_fmtstream_t fs ;
  int first_pattern ;
  int more_patterns ;
  size_t num_pattern_levels ;
  size_t __cil_tmp14 ;
  char *pattern_levels ;
  void *__cil_tmp16 ;
  int old_lm ;
  int old_wm ;
  size_t __cil_tmp19 ;
  char *levels ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  size_t __cil_tmp23 ;
  char *__cil_tmp24 ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  int __cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1592
  anything = 0;
#line 1593
  hol = (struct hol *)0;
#line 1596
  if (! stream) {
#line 1597
    return;
  }
  {
#line 1600
  flockfile(stream);
  }
#line 1603
  if (! uparams.valid) {
    {
#line 1604
    fill_in_uparams(state);
    }
  }
  {
#line 1606
  fs = argp_make_fmtstream(stream, (size_t )0, (size_t )uparams.rmargin, (ssize_t )0);
  }
#line 1607
  if (! fs) {
    {
#line 1610
    funlockfile(stream);
    }
#line 1612
    return;
  }
#line 1615
  if (flags & 11U) {
    {
#line 1617
    hol = argp_hol(argp___0, (struct hol_cluster *)0);
#line 1620
    hol_set_group(hol, (char const   *)((char *)"help"), - 1);
#line 1621
    hol_set_group(hol, (char const   *)((char *)"version"), - 1);
#line 1623
    hol_sort(hol);
    }
  }
#line 1626
  if (flags & 3U) {
    {
#line 1629
    first_pattern = 1;
#line 1630
    __cil_tmp14 = argp_args_levels(argp___0);
#line 1630
    num_pattern_levels = __cil_tmp14;
#line 1631
    __cil_tmp16 = __builtin_alloca(num_pattern_levels);
#line 1631
    pattern_levels = (char *)__cil_tmp16;
#line 1633
    memset((void *)pattern_levels, 0, num_pattern_levels);
    }
    {
    {
#line 1635
    while (1) {
      while_continue: /* CIL Label */ ;

      {
#line 1638
      __cil_tmp19 = argp_fmtstream_set_wmargin(fs, (size_t )uparams.usage_indent);
#line 1638
      old_wm = (int )__cil_tmp19;
#line 1639
      levels = pattern_levels;
      }
#line 1641
      if (first_pattern) {
        {
#line 1642
        __cil_tmp21 = dcgettext(argp___0->argp_domain, (char const   *)((char *)"Usage:"),
                                5);
#line 1642
        argp_fmtstream_printf(fs, (char const   *)((char *)"%s %s"), __cil_tmp21,
                              name);
        }
      } else {
        {
#line 1646
        __cil_tmp22 = dcgettext(argp___0->argp_domain, (char const   *)((char *)"  or: "),
                                5);
#line 1646
        argp_fmtstream_printf(fs, (char const   *)((char *)"%s %s"), __cil_tmp22,
                              name);
        }
      }
      {
#line 1652
      __cil_tmp23 = argp_fmtstream_set_lmargin(fs, (size_t )uparams.usage_indent);
#line 1652
      old_lm = (int )__cil_tmp23;
      }
#line 1654
      if (flags & 2U) {
#line 1657
        if (hol->num_entries > 0U) {
          {
#line 1658
          __cil_tmp24 = dcgettext(argp___0->argp_domain, (char const   *)((char *)" [OPTION...]"),
                                  5);
#line 1658
          argp_fmtstream_puts(fs, (char const   *)__cil_tmp24);
          }
        }
      } else {
        {
#line 1664
        hol_usage(hol, fs);
#line 1665
        flags |= (unsigned int )2;
        }
      }
      {
#line 1668
      more_patterns = argp_args_usage(argp___0, state, & levels, 1, fs);
#line 1670
      argp_fmtstream_set_wmargin(fs, (size_t )old_wm);
#line 1671
      argp_fmtstream_set_lmargin(fs, (size_t )old_lm);
#line 1673
      argp_fmtstream_putc(fs, '\n');
#line 1674
      anything = 1;
#line 1676
      first_pattern = 0;
      }
#line 1635
      if (! more_patterns) {
#line 1635
        goto while_break;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1681
  if (flags & 16U) {
    {
#line 1682
    __cil_tmp26 = argp_doc(argp___0, state, 0, 0, 1, fs);
    }
#line 1682
    anything |= __cil_tmp26;
  }
#line 1684
  if (flags & 4U) {
    {
#line 1686
    __cil_tmp27 = dcgettext(argp___0->argp_domain, (char const   *)((char *)"Try \'%s --help\' or \'%s --usage\' for more information.\n"),
                            5);
#line 1686
    argp_fmtstream_printf(fs, (char const   *)__cil_tmp27, name, name);
#line 1689
    anything = 1;
    }
  }
#line 1692
  if (flags & 8U) {
#line 1696
    if (hol->num_entries > 0U) {
#line 1698
      if (anything) {
        {
#line 1699
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1700
      hol_help(hol, state, fs);
#line 1701
      anything = 1;
      }
    }
  }
#line 1705
  if (flags & 32U) {
    {
#line 1707
    __cil_tmp28 = argp_doc(argp___0, state, 1, anything, 0, fs);
    }
#line 1707
    anything |= __cil_tmp28;
  }
#line 1709
  if (flags & 64U) {
#line 1709
    if (argp_program_bug_address) {
#line 1711
      if (anything) {
        {
#line 1712
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1713
      __cil_tmp29 = dcgettext(argp___0->argp_domain, (char const   *)((char *)"Report bugs to %s.\n"),
                              5);
#line 1713
      argp_fmtstream_printf(fs, (char const   *)__cil_tmp29, argp_program_bug_address);
#line 1716
      anything = 1;
      }
    }
  }
  {
#line 1720
  funlockfile(stream);
  }
#line 1723
  if (hol) {
    {
#line 1724
    hol_free(hol);
    }
  }
  {
#line 1726
  argp_fmtstream_free(fs);
  }
}
}
#line 1731 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
void argp_help(struct argp *argp___0 , FILE *stream , unsigned int flags , char *name ) 
{ 
  struct argp_state state ;

  {
  {
#line 1735
  memset((void *)(& state), 0, sizeof(state));
#line 1736
  state.root_argp = argp___0;
#line 1737
  _help(argp___0, & state, stream, flags, name);
  }
}
}
#line 1764 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
void argp_state_help(struct argp_state *state , FILE *stream , unsigned int flags ) 
{ 
  struct argp *tmp ;
  char *tmp___66 ;

  {
#line 1766
  if (! state) {
    _L___67: /* CIL Label */ 
#line 1766
    if (stream) {
#line 1768
      if (state) {
#line 1768
        if (state->flags & 64U) {
#line 1769
          flags |= (unsigned int )128;
        }
      }
#line 1771
      if (state) {
#line 1771
        tmp = state->root_argp;
      } else {
#line 1771
        tmp = (struct argp *)0;
      }
#line 1771
      if (state) {
#line 1771
        tmp___66 = state->name;
      } else {
#line 1771
        tmp___66 = program_invocation_short_name;
      }
      {
#line 1771
      _help(tmp, state, stream, flags, tmp___66);
      }
#line 1774
      if (! state) {
        _L: /* CIL Label */ 
#line 1776
        if (flags & 256U) {
          {
#line 1777
          exit(argp_err_exit_status);
          }
        }
#line 1778
        if (flags & 512U) {
          {
#line 1779
          exit(0);
          }
        }
      } else
#line 1774
      if (! (state->flags & 32U)) {
#line 1774
        goto _L;
      }
    }
  } else
#line 1766
  if (! (state->flags & 2U)) {
#line 1766
    goto _L___67;
  }
}
}
#line 1791 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
void argp_error(struct argp_state *state , char const   *fmt  , ...) 
{ 
  FILE *stream ;
  FILE *tmp ;
  va_list ap ;
  char *tmp___68 ;

  {
#line 1793
  if (! state) {
    _L: /* CIL Label */ 
#line 1795
    if (state) {
#line 1795
      tmp = state->err_stream;
    } else {
#line 1795
      tmp = stderr;
    }
#line 1795
    stream = tmp;
#line 1797
    if (stream) {
      {
#line 1802
      flockfile(stream);
#line 1805
      __builtin_va_start((__builtin_va_list *)ap, fmt);
      }
#line 1824
      if (state) {
#line 1824
        tmp___68 = state->name;
      } else {
#line 1824
        tmp___68 = program_invocation_short_name;
      }
      {
#line 1824
      fputs_unlocked((char const   *)tmp___68, stream);
#line 1827
      fputc_unlocked(':', stream);
#line 1828
      fputc_unlocked(' ', stream);
#line 1830
      vfprintf(stream, fmt, (__builtin_va_list *)ap);
#line 1832
      fputc_unlocked('\n', stream);
#line 1835
      argp_state_help(state, stream, (unsigned int )260);
#line 1837
      __builtin_va_end((__builtin_va_list *)ap);
#line 1840
      funlockfile(stream);
      }
    }
  } else
#line 1793
  if (! (state->flags & 2U)) {
#line 1793
    goto _L;
  }
}
}
#line 1858 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-help.c"
void argp_failure(struct argp_state *state , int status , int errnum , char const   *fmt 
                  , ...) 
{ 
  FILE *stream ;
  FILE *tmp ;
  char *tmp___69 ;
  va_list ap ;
  char buf[200] ;
  char const   *s ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1861
  if (! state) {
    _L: /* CIL Label */ 
#line 1863
    if (state) {
#line 1863
      tmp = state->err_stream;
    } else {
#line 1863
      tmp = stderr;
    }
#line 1863
    stream = tmp;
#line 1865
    if (stream) {
      {
#line 1868
      flockfile(stream);
      }
#line 1877
      if (state) {
#line 1877
        tmp___69 = state->name;
      } else {
#line 1877
        tmp___69 = program_invocation_short_name;
      }
      {
#line 1877
      fputs_unlocked((char const   *)tmp___69, stream);
      }
#line 1881
      if (fmt) {
        {
#line 1885
        __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 1901
        fputc_unlocked(':', stream);
#line 1902
        fputc_unlocked(' ', stream);
#line 1904
        vfprintf(stream, fmt, (__builtin_va_list *)ap);
#line 1907
        __builtin_va_end((__builtin_va_list *)ap);
        }
      }
#line 1910
      if (errnum) {
        {
#line 1921
        s = (char const   *)((void *)0);
#line 1922
        fputc_unlocked(':', stream);
#line 1923
        fputc_unlocked(' ', stream);
#line 1925
        __cil_tmp11 = strerror_r(errnum, (char *)buf, sizeof(buf));
#line 1925
        s = (char const   *)__cil_tmp11;
#line 1931
        __cil_tmp12 = strerror(errnum);
#line 1931
        s = (char const   *)__cil_tmp12;
        }
#line 1931
        if (! s) {
#line 1931
          if (! s) {
            {
#line 1932
            __cil_tmp13 = dcgettext((state->root_argp)->argp_domain, (char const   *)((char *)"Unknown system error"),
                                    5);
#line 1932
            s = (char const   *)__cil_tmp13;
            }
          }
        }
        {
#line 1935
        fputs(s, stream);
        }
      }
      {
#line 1944
      fputc_unlocked('\n', stream);
#line 1947
      funlockfile(stream);
      }
#line 1950
      if (status) {
#line 1950
        if (! state) {
          {
          {
#line 1951
          exit(status);
          }
          }
        } else
#line 1950
        if (! (state->flags & 32U)) {
          {
          {
#line 1951
          exit(status);
          }
          }
        }
      }
    }
  } else
#line 1861
  if (! (state->flags & 2U)) {
#line 1861
    goto _L;
  }
}
}
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n ) ;
#line 675 "/usr/include/stdio.h"
extern size_t fwrite_unlocked(void const   *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
#line 60 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.c"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) 
{ 
  argp_fmtstream_t fs ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 65
  __cil_tmp6 = malloc(sizeof(struct argp_fmtstream ));
#line 65
  fs = (struct argp_fmtstream *)__cil_tmp6;
  }
#line 66
  if (fs != (argp_fmtstream_t )((void *)0)) {
    {
#line 68
    fs->stream = stream;
#line 70
    fs->lmargin = lmargin;
#line 71
    fs->rmargin = rmargin;
#line 72
    fs->wmargin = wmargin;
#line 73
    fs->point_col = (ssize_t )0;
#line 74
    fs->point_offs = (size_t )0;
#line 76
    __cil_tmp7 = malloc((unsigned long )200);
#line 76
    fs->buf = (char *)__cil_tmp7;
    }
#line 77
    if (! fs->buf) {
      {
#line 79
      free((void *)fs);
#line 80
      fs = (argp_fmtstream_t )0;
      }
    } else {
#line 84
      fs->p = fs->buf;
#line 85
      fs->end = fs->buf + 200;
    }
  }
#line 89
  return (fs);
}
}
#line 100 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.c"
void argp_fmtstream_free(argp_fmtstream_t fs ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  size_t __cil_tmp6 ;
  size_t tmp ;
  int tmp___70 ;

  {
  {
#line 102
  _argp_fmtstream_update(fs);
  }
#line 103
  if (fs->p > fs->buf) {
    {
#line 108
    __cil_tmp3 = __builtin_constant_p(fs->p - fs->buf);
    }
    {
#line 108
    __cil_tmp2 = __builtin_constant_p(1);
    }
#line 108
    if ((__cil_tmp2 && __cil_tmp3) && (size_t )(fs->p - fs->buf) <= 8UL) {
#line 108
      tmp___70 = 0;
    } else {
      {
#line 108
      __cil_tmp5 = __builtin_constant_p(fs->p - fs->buf);
      }
      {
#line 108
      __cil_tmp4 = __builtin_constant_p(1);
      }
#line 108
      if (__cil_tmp5 && (size_t )(fs->p - fs->buf) == 0UL) {
#line 108
        tmp = (size_t )0;
      } else {
        {
#line 108
        __cil_tmp6 = fwrite_unlocked((void const   *)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                                     fs->stream);
#line 108
        tmp = __cil_tmp6;
        }
      }
#line 108
      tmp___70 = (int )tmp;
    }
  }
  {
#line 111
  free((void *)fs->buf);
#line 112
  free((void *)fs);
  }
}
}
#line 124 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.c"
void _argp_fmtstream_update(argp_fmtstream_t fs ) 
{ 
  char *buf ;
  char *nl ;
  size_t len ;
  size_t r ;
  size_t pad ;
  size_t i ;
  void *__cil_tmp9 ;
  char *p ;
  char *nextline ;
  int i___0 ;
  unsigned short const   **__cil_tmp13 ;
  unsigned short const   **__cil_tmp14 ;
  unsigned short const   **__cil_tmp15 ;
  unsigned short const   **__cil_tmp16 ;
  int tmp ;
  size_t mv ;
  char *__cil_tmp19 ;
  int __cil_tmp20 ;
  int __cil_tmp21 ;
  int __cil_tmp22 ;
  int __cil_tmp23 ;
  size_t __cil_tmp24 ;
  size_t tmp___71 ;
  int tmp___72 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  ssize_t tmp___74 ;

  {
#line 130
  buf = fs->buf + fs->point_offs;
  {
  {
#line 131
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 131
    if (! (buf < fs->p)) {
#line 131
      goto while_break;
    }
#line 135
    if (fs->point_col == 0L) {
#line 135
      if (fs->lmargin != 0UL) {
#line 138
        pad = fs->lmargin;
#line 139
        if (fs->p + pad < fs->end) {
          {
#line 143
          memmove((void *)(buf + pad), (void const   *)buf, (unsigned long )(fs->p - buf));
#line 144
          fs->p += pad;
#line 145
          memset((void *)buf, ' ', pad);
#line 146
          buf += pad;
          }
        } else {
#line 152
          i = (size_t )0;
          {
          {
#line 152
          while (1) {
            while_continue___1: /* CIL Label */ ;

#line 152
            if (! (i < pad)) {
#line 152
              goto while_break___0;
            }
            {
#line 159
            fputc_unlocked(' ', fs->stream);
            }
          }
          while_break___8: /* CIL Label */ ;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 152
          i ++;
        }
#line 162
        fs->point_col = (ssize_t )pad;
      }
    }
    {
#line 165
    len = (size_t )(fs->p - buf);
#line 166
    __cil_tmp9 = memchr((void const   *)buf, '\n', len);
#line 166
    nl = (char *)__cil_tmp9;
    }
#line 168
    if (fs->point_col < 0L) {
#line 169
      fs->point_col = (ssize_t )0;
    }
#line 171
    if (! nl) {
#line 175
      if ((unsigned long )fs->point_col + len < fs->rmargin) {
#line 180
        fs->point_col += len;
#line 181
        goto while_break;
      } else {
#line 186
        nl = fs->p;
      }
    } else
#line 188
    if (fs->point_col + (nl - buf) < (ssize_t )fs->rmargin) {
#line 192
      fs->point_col = (ssize_t )0;
#line 193
      buf = nl + 1;
#line 194
      goto while_continue;
    }
#line 198
    r = fs->rmargin - 1UL;
#line 200
    if (fs->wmargin < 0L) {
#line 204
      if (nl < fs->p) {
        {
#line 206
        memmove((void *)(buf + (r - (unsigned long )fs->point_col)), (void const   *)nl,
                (unsigned long )(fs->p - nl));
#line 207
        fs->p -= (buf + (r - (unsigned long )fs->point_col)) - nl;
#line 209
        fs->point_col = (ssize_t )0;
#line 210
        buf += r + 1UL;
        }
      } else {
#line 217
        fs->point_col += len;
#line 218
        fs->p -= (unsigned long )fs->point_col - r;
#line 219
        goto while_break;
      }
    } else {
#line 231
      p = buf + ((r + 1UL) - (unsigned long )fs->point_col);
      {
      {
#line 232
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 232
        if (! (p >= buf && ! ((int )((unsigned short )*(*__cil_tmp13 + (int )((unsigned char )*p))) & 1))) {
#line 232
          goto while_break___1;
        }
#line 233
        p --;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 234
      nextline = p + 1;
#line 236
      if (nextline > buf) {
#line 239
        if (p >= buf) {
          {
          {
#line 240
          while (1) {
            while_continue___3: /* CIL Label */ ;

#line 241
            p --;
#line 240
            if (! (p >= buf && (int )((unsigned short )*(*__cil_tmp14 + (int )((unsigned char )*p))) & 1)) {
#line 240
              goto while_break___2;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 243
        nl = p + 1;
      } else {
#line 249
        p = buf + ((r + 1UL) - (unsigned long )fs->point_col);
#line 251
        if (p < nl) {
          {
          {
#line 252
          while (1) {
            while_continue___4: /* CIL Label */ ;

#line 253
            p ++;
#line 252
            if (! (p < nl && ! ((int )((unsigned short )*(*__cil_tmp15 + (int )((unsigned char )*p))) & 1))) {
#line 252
              goto while_break___3;
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 255
        if (p == nl) {
#line 258
          fs->point_col = (ssize_t )0;
#line 259
          buf = nl + 1;
#line 260
          goto while_continue;
        }
#line 263
        nl = p;
        {
        {
#line 265
        while (1) {
          while_continue___5: /* CIL Label */ ;

#line 266
          p ++;
#line 265
          if (! ((int )((unsigned short )*(*__cil_tmp16 + (int )((unsigned char )*p))) & 1)) {
#line 265
            goto while_break___4;
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 269
        nextline = p;
      }
#line 277
      if (nextline == (buf + len) + 1) {
#line 277
        tmp = fs->end - nl < fs->wmargin + 1L;
      } else {
#line 277
        tmp = nextline - (nl + 1) < fs->wmargin;
      }
#line 277
      if (tmp) {
#line 277
        if (fs->p > nextline) {
#line 283
          if (fs->end - fs->p > fs->wmargin + 1L) {
            {
#line 286
            mv = (size_t )(fs->p - nextline);
#line 287
            memmove((void *)((nl + 1) + fs->wmargin), (void const   *)nextline, mv);
#line 288
            nextline = (nl + 1) + fs->wmargin;
#line 289
            len = (size_t )((nextline + mv) - buf);
#line 290
            __cil_tmp19 = nl;
#line 290
            nl ++;
#line 290
            *__cil_tmp19 = (char )'\n';
            }
          } else {
#line 299
            if (nl > fs->buf) {
              {
#line 300
              __cil_tmp21 = __builtin_constant_p(nl - fs->buf);
              }
              {
#line 300
              __cil_tmp20 = __builtin_constant_p(1);
              }
#line 300
              if ((__cil_tmp20 && __cil_tmp21) && (size_t )(nl - fs->buf) <= 8UL) {
#line 300
                tmp___72 = 0;
              } else {
                {
#line 300
                __cil_tmp23 = __builtin_constant_p(nl - fs->buf);
                }
                {
#line 300
                __cil_tmp22 = __builtin_constant_p(1);
                }
#line 300
                if (__cil_tmp23 && (size_t )(nl - fs->buf) == 0UL) {
#line 300
                  tmp___71 = (size_t )0;
                } else {
                  {
#line 300
                  __cil_tmp24 = fwrite_unlocked((void const   *)fs->buf, (size_t )1,
                                                (size_t )(nl - fs->buf), fs->stream);
#line 300
                  tmp___71 = __cil_tmp24;
                  }
                }
#line 300
                tmp___72 = (int )tmp___71;
              }
            }
            {
#line 301
            fputc_unlocked('\n', fs->stream);
#line 304
            len += (unsigned long )(buf - fs->buf);
#line 305
            buf = fs->buf;
#line 305
            nl = buf;
            }
          }
        } else {
#line 311
          __cil_tmp27 = nl;
#line 311
          nl ++;
#line 311
          *__cil_tmp27 = (char )'\n';
        }
      } else {
#line 311
        __cil_tmp27 = nl;
#line 311
        nl ++;
#line 311
        *__cil_tmp27 = (char )'\n';
      }
#line 313
      if (nextline - nl >= fs->wmargin) {
        _L: /* CIL Label */ 
#line 316
        i___0 = 0;
        {
        {
#line 316
        while (1) {
          while_continue___6: /* CIL Label */ ;

#line 316
          if (! ((long )i___0 < fs->wmargin)) {
#line 316
            goto while_break___5;
          }
#line 317
          __cil_tmp28 = nl;
#line 317
          nl ++;
#line 317
          *__cil_tmp28 = (char )' ';
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 316
        i___0 ++;
      } else
#line 313
      if (nextline == (buf + len) + 1) {
#line 313
        if (fs->end - nextline >= fs->wmargin) {
#line 313
          goto _L;
        } else {
#line 313
          goto _L___73;
        }
      } else {
        _L___73: /* CIL Label */ 
#line 319
        i___0 = 0;
        {
        {
#line 319
        while (1) {
          while_continue___7: /* CIL Label */ ;

#line 319
          if (! ((long )i___0 < fs->wmargin)) {
#line 319
            goto while_break___6;
          }
          {
#line 325
          fputc_unlocked(' ', fs->stream);
          }
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 319
        i___0 ++;
      }
#line 329
      if (nl < nextline) {
        {
#line 330
        memmove((void *)nl, (void const   *)nextline, (unsigned long )((buf + len) - nextline));
        }
      }
#line 331
      len -= (unsigned long )(nextline - buf);
#line 334
      buf = nl;
#line 337
      fs->p = nl + len;
#line 342
      if (fs->wmargin) {
#line 342
        tmp___74 = fs->wmargin;
      } else {
#line 342
        tmp___74 = (long )(- 1);
      }
#line 342
      fs->point_col = tmp___74;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  fs->point_offs = (size_t )(fs->p - fs->buf);
}
}
#line 353 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.c"
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) 
{ 
  ssize_t wrote ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  size_t __cil_tmp8 ;
  size_t tmp ;
  int tmp___75 ;
  size_t old_size ;
  size_t new_size ;
  char *new_buf ;
  void *__cil_tmp14 ;
  int *__cil_tmp15 ;

  {
#line 355
  if ((size_t )(fs->end - fs->p) < amount) {
    {
#line 360
    _argp_fmtstream_update(fs);
#line 366
    __cil_tmp5 = __builtin_constant_p(fs->p - fs->buf);
    }
    {
#line 366
    __cil_tmp4 = __builtin_constant_p(1);
    }
#line 366
    if ((__cil_tmp4 && __cil_tmp5) && (size_t )(fs->p - fs->buf) <= 8UL) {
#line 366
      tmp___75 = 0;
    } else {
      {
#line 366
      __cil_tmp7 = __builtin_constant_p(fs->p - fs->buf);
      }
      {
#line 366
      __cil_tmp6 = __builtin_constant_p(1);
      }
#line 366
      if (__cil_tmp7 && (size_t )(fs->p - fs->buf) == 0UL) {
#line 366
        tmp = (size_t )0;
      } else {
        {
#line 366
        __cil_tmp8 = fwrite_unlocked((void const   *)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                                     fs->stream);
#line 366
        tmp = __cil_tmp8;
        }
      }
#line 366
      tmp___75 = (int )tmp;
    }
#line 366
    wrote = (ssize_t )((int )tmp___75);
#line 368
    if (wrote == fs->p - fs->buf) {
#line 370
      fs->p = fs->buf;
#line 371
      fs->point_offs = (size_t )0;
    } else {
      {
#line 375
      fs->p -= wrote;
#line 376
      fs->point_offs -= (unsigned long )wrote;
#line 377
      memmove((void *)fs->buf, (void const   *)(fs->buf + wrote), (unsigned long )(fs->p - fs->buf));
      }
#line 378
      return (0);
    }
#line 381
    if ((size_t )(fs->end - fs->buf) < amount) {
      {
#line 384
      old_size = (size_t )(fs->end - fs->buf);
#line 385
      new_size = old_size + amount;
#line 388
      __cil_tmp14 = realloc((void *)fs->buf, new_size);
#line 388
      new_buf = (char *)__cil_tmp14;
      }
#line 388
      if (new_size < old_size) {
        {
        {
#line 390
        __cil_tmp15 = __errno_location();
        }
#line 390
        *__cil_tmp15 = 12;
        }
#line 391
        return (0);
      } else
#line 388
      if (! new_buf) {
        {
        {
#line 390
        __cil_tmp15 = __errno_location();
        }
#line 390
        *__cil_tmp15 = 12;
        }
#line 391
        return (0);
      }
#line 394
      fs->buf = new_buf;
#line 395
      fs->end = new_buf + new_size;
#line 396
      fs->p = fs->buf;
    }
  }
#line 400
  return (1);
}
}
#line 404 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-fmtstream.c"
ssize_t argp_fmtstream_printf(struct argp_fmtstream *fs , char const   *fmt  , ...) 
{ 
  int out ;
  size_t avail ;
  size_t size_guess ;
  va_list args ;
  int __cil_tmp7 ;

  {
#line 408
  size_guess = (size_t )150;
  {
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 414
    __cil_tmp7 = _argp_fmtstream_ensure(fs, size_guess);
    }
#line 414
    if (! __cil_tmp7) {
#line 415
      return ((ssize_t )(- 1));
    }
    {
#line 417
    __builtin_va_start((__builtin_va_list *)args, fmt);
#line 418
    avail = (size_t )(fs->end - fs->p);
#line 419
    out = vsnprintf(fs->p, avail, fmt, (__builtin_va_list *)args);
#line 420
    __builtin_va_end((__builtin_va_list *)args);
    }
#line 421
    if ((size_t )out >= avail) {
#line 422
      size_guess = (size_t )(out + 1);
    }
#line 410
    if (! ((size_t )out >= avail)) {
#line 410
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  fs->p += out;
#line 428
  return ((ssize_t )out);
}
}
#line 32 "/home/hyunsu/workspace/cr-bench/cflow-1.5/gnu/argp-eexst.c"
error_t argp_err_exit_status  =    64;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n ) ;
#line 166
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s ) ;
#line 139 "./wordsplit.h"
int wordsplit(char const   *command , struct wordsplit *ws , int flags ) ;
#line 140
int wordsplit_len(char const   *command , size_t length , struct wordsplit *wsp ,
                  int flags ) ;
#line 142
void wordsplit_free(struct wordsplit *ws ) ;
#line 143
void wordsplit_free_words(struct wordsplit *ws ) ;
#line 145
int wordsplit_c_unquote_char(int c ) ;
#line 146
int wordsplit_c_quote_char(int c ) ;
#line 147
size_t wordsplit_c_quoted_length(char const   *str , int quote_hex , int *quote ) ;
#line 149
void wordsplit_general_unquote_copy(char *dst , char const   *src , size_t n , char const   *escapable ) ;
#line 151
void wordsplit_sh_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 152
void wordsplit_c_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 153
void wordsplit_c_quote_copy(char *dst , char const   *src , int quote_hex ) ;
#line 155
void wordsplit_perror(struct wordsplit *wsp ) ;
#line 156
char const   *wordsplit_strerror(struct wordsplit *ws ) ;
#line 55 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void _wsplt_alloc_die(struct wordsplit *wsp ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 57
  __cil_tmp2 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"memory exhausted"),
                         5);
#line 57
  (wsp->ws_error)((char const   *)__cil_tmp2);
#line 58
  abort();
  }
}
}
#line 62 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void _wsplt_error(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 66
  __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 67
  vfprintf(stderr, fmt, (__builtin_va_list *)ap);
#line 68
  __builtin_va_end((__builtin_va_list *)ap);
#line 69
  fputc('\n', stderr);
  }
}
}
#line 72
static void wordsplit_free_nodes(struct wordsplit *wsp ) ;
#line 75 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int _wsplt_nomem(struct wordsplit *wsp ) 
{ 
  int *__cil_tmp2 ;

  {
  {
#line 77
  __cil_tmp2 = __errno_location();
#line 77
  *__cil_tmp2 = 12;
#line 78
  wsp->ws_errno = 2;
  }
#line 79
  if (wsp->ws_flags & 128) {
    {
#line 80
    (wsp->ws_alloc_die)(wsp);
    }
  }
#line 81
  if (wsp->ws_flags & 16) {
    {
#line 82
    wordsplit_perror(wsp);
    }
  }
#line 83
  if (! (wsp->ws_flags & 8)) {
    {
#line 84
    wordsplit_free(wsp);
    }
  }
  {
#line 85
  wordsplit_free_nodes(wsp);
  }
#line 86
  return (wsp->ws_errno);
}
}
#line 90 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wordsplit_init0(struct wordsplit *wsp ) 
{ 


  {
#line 92
  if (wsp->ws_flags & 8) {
#line 94
    if (! (wsp->ws_flags & 1)) {
      {
#line 95
      wordsplit_free_words(wsp);
      }
    }
  } else {
#line 99
    wsp->ws_wordv = (char **)((void *)0);
#line 100
    wsp->ws_wordc = (size_t )0;
#line 101
    wsp->ws_wordn = (size_t )0;
  }
#line 104
  wsp->ws_errno = 0;
#line 105
  wsp->ws_tail = (struct wordsplit_node *)((void *)0);
#line 105
  wsp->ws_head = wsp->ws_tail;
}
}
#line 109 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wordsplit_init(struct wordsplit *wsp , char const   *input___0 , size_t len ,
                          int flags ) 
{ 
  int *__cil_tmp5 ;
  int *__cil_tmp6 ;

  {
#line 112
  wsp->ws_flags = flags;
#line 114
  if (! (wsp->ws_flags & 65536)) {
#line 115
    wsp->ws_alloc_die = _wsplt_alloc_die;
  }
#line 116
  if (! (wsp->ws_flags & 131072)) {
#line 117
    wsp->ws_error = _wsplt_error;
  }
#line 119
  if (! (wsp->ws_flags & 64)) {
#line 119
    if (! (wsp->ws_flags & 1572864)) {
      {
#line 122
      __cil_tmp5 = __errno_location();
#line 122
      *__cil_tmp5 = 22;
#line 123
      wsp->ws_errno = 4;
      }
#line 124
      if (wsp->ws_flags & 16) {
        {
#line 125
        wordsplit_perror(wsp);
        }
      }
#line 126
      return (wsp->ws_errno);
    }
  }
#line 129
  if (! (wsp->ws_flags & 4)) {
    {
#line 131
    __cil_tmp6 = __errno_location();
#line 131
    *__cil_tmp6 = 22;
#line 132
    wsp->ws_errno = 3;
    }
#line 133
    if (wsp->ws_flags & 16) {
      {
#line 134
      wordsplit_perror(wsp);
      }
    }
#line 135
    return (wsp->ws_errno);
  }
#line 138
  if (wsp->ws_flags & 2097152) {
#line 140
    if (! (wsp->ws_flags & 262144)) {
#line 142
      if (wsp->ws_flags & 131072) {
#line 143
        wsp->ws_debug = wsp->ws_error;
      } else
#line 144
      if (wsp->ws_flags & 16) {
#line 145
        wsp->ws_debug = _wsplt_error;
      } else {
#line 147
        wsp->ws_flags &= ~ 2097152;
      }
    }
  }
#line 151
  wsp->ws_input = input___0;
#line 152
  wsp->ws_len = len;
#line 154
  if (! (wsp->ws_flags & 2)) {
#line 155
    wsp->ws_offs = (size_t )0;
  }
#line 157
  if (! (wsp->ws_flags & 16384)) {
#line 158
    wsp->ws_delim = (char const   *)((char *)" \t\n");
  }
#line 160
  if (! (wsp->ws_flags & 32768)) {
#line 161
    wsp->ws_comment = (char const   *)((void *)0);
  }
#line 163
  if (! (wsp->ws_flags & 67108864)) {
#line 164
    wsp->ws_closure = (void *)0;
  }
  {
#line 166
  wsp->ws_endp = (size_t )0;
#line 168
  wordsplit_init0(wsp);
  }
#line 170
  return (0);
}
}
#line 174 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int alloc_space(struct wordsplit *wsp , size_t count ) 
{ 
  size_t offs ;
  size_t tmp ;
  char **ptr ;
  size_t newalloc ;
  size_t tmp___77 ;
  void *__cil_tmp8 ;
  size_t tmp___78 ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 176
  if (wsp->ws_flags & 2) {
#line 176
    tmp = wsp->ws_offs;
  } else {
#line 176
    tmp = (unsigned long )0;
  }
#line 176
  offs = tmp;
#line 180
  if (wsp->ws_wordv == (char **)((void *)0)) {
#line 182
    if (offs + count > 128UL) {
#line 182
      tmp___77 = count;
    } else {
#line 182
      tmp___77 = (unsigned long )128;
    }
    {
#line 182
    newalloc = tmp___77;
#line 183
    __cil_tmp8 = calloc(newalloc, sizeof(*(ptr + 0)));
#line 183
    ptr = (char **)__cil_tmp8;
    }
  } else
#line 185
  if (wsp->ws_wordn < (offs + wsp->ws_wordc) + count) {
#line 187
    if (count > 128UL) {
#line 187
      tmp___78 = count;
    } else {
#line 187
      tmp___78 = (unsigned long )128;
    }
    {
#line 187
    newalloc = (offs + wsp->ws_wordc) + tmp___78;
#line 189
    __cil_tmp10 = realloc((void *)wsp->ws_wordv, newalloc * sizeof(*(ptr + 0)));
#line 189
    ptr = (char **)__cil_tmp10;
    }
  } else {
#line 192
    return (0);
  }
#line 194
  if (ptr) {
#line 196
    wsp->ws_wordn = newalloc;
#line 197
    wsp->ws_wordv = ptr;
  } else {
    {
#line 200
    __cil_tmp11 = _wsplt_nomem(wsp);
    }
#line 200
    return (__cil_tmp11);
  }
#line 201
  return (0);
}
}
#line 234 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static char const   *wsnode_flagstr(int flags ) 
{ 
  static char retbuf[6] ;
  char *p ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 237
  p = (char *)retbuf;
#line 239
  if (flags & 2) {
#line 240
    __cil_tmp4 = p;
#line 240
    p ++;
#line 240
    *__cil_tmp4 = (char )'w';
  } else
#line 241
  if (flags & 1) {
#line 242
    __cil_tmp5 = p;
#line 242
    p ++;
#line 242
    *__cil_tmp5 = (char )'n';
  } else {
#line 244
    __cil_tmp6 = p;
#line 244
    p ++;
#line 244
    *__cil_tmp6 = (char )'-';
  }
#line 245
  if (flags & 4) {
#line 246
    __cil_tmp7 = p;
#line 246
    p ++;
#line 246
    *__cil_tmp7 = (char )'q';
  } else {
#line 248
    __cil_tmp8 = p;
#line 248
    p ++;
#line 248
    *__cil_tmp8 = (char )'-';
  }
#line 249
  if (flags & 8) {
#line 250
    __cil_tmp9 = p;
#line 250
    p ++;
#line 250
    *__cil_tmp9 = (char )'E';
  } else {
#line 252
    __cil_tmp10 = p;
#line 252
    p ++;
#line 252
    *__cil_tmp10 = (char )'-';
  }
#line 253
  if (flags & 16) {
#line 254
    __cil_tmp11 = p;
#line 254
    p ++;
#line 254
    *__cil_tmp11 = (char )'j';
  } else {
#line 256
    __cil_tmp12 = p;
#line 256
    p ++;
#line 256
    *__cil_tmp12 = (char )'-';
  }
#line 257
  if (flags & 32) {
#line 258
    __cil_tmp13 = p;
#line 258
    p ++;
#line 258
    *__cil_tmp13 = (char )'s';
  } else {
#line 260
    __cil_tmp14 = p;
#line 260
    p ++;
#line 260
    *__cil_tmp14 = (char )'-';
  }
#line 261
  *p = (char )0;
#line 262
  return ((char const   *)((char *)retbuf));
}
}
#line 266 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static char const   *wsnode_ptr(struct wordsplit *wsp , struct wordsplit_node *p ) 
{ 


  {
#line 268
  if (p->flags & 1) {
#line 269
    return ((char const   *)((char *)""));
  } else
#line 270
  if (p->flags & 2) {
#line 271
    return ((char const   *)p->v.word);
  } else {
#line 273
    return (wsp->ws_input + p->v.segm.beg);
  }
}
}
#line 277 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static size_t wsnode_len(struct wordsplit_node *p ) 
{ 
  size_t __cil_tmp2 ;

  {
#line 279
  if (p->flags & 1) {
#line 280
    return ((size_t )0);
  } else
#line 281
  if (p->flags & 2) {
    {
#line 282
    __cil_tmp2 = strlen((char const   *)p->v.word);
    }
#line 282
    return (__cil_tmp2);
  } else {
#line 284
    return (p->v.segm.end - p->v.segm.beg);
  }
}
}
#line 288 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wsnode_new(struct wordsplit *wsp , struct wordsplit_node **pnode ) 
{ 
  struct wordsplit_node *node ;
  void *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 290
  __cil_tmp4 = calloc((unsigned long )1, sizeof(*node));
#line 290
  node = (struct wordsplit_node *)__cil_tmp4;
  }
#line 291
  if (! node) {
    {
#line 292
    __cil_tmp5 = _wsplt_nomem(wsp);
    }
#line 292
    return (__cil_tmp5);
  }
#line 293
  *pnode = node;
#line 294
  return (0);
}
}
#line 298 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wsnode_free(struct wordsplit_node *p ) 
{ 


  {
#line 300
  if (p->flags & 2) {
    {
#line 301
    free((void *)p->v.word);
    }
  }
  {
#line 302
  free((void *)p);
  }
}
}
#line 306 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wsnode_append(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 


  {
#line 308
  node->next = (struct wordsplit_node *)((void *)0);
#line 309
  node->prev = wsp->ws_tail;
#line 310
  if (wsp->ws_tail) {
#line 311
    (wsp->ws_tail)->next = node;
  } else {
#line 313
    wsp->ws_head = node;
  }
#line 314
  wsp->ws_tail = node;
}
}
#line 318 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wsnode_remove(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 
  struct wordsplit_node *p ;

  {
#line 322
  p = node->prev;
#line 323
  if (p) {
#line 325
    p->next = node->next;
#line 326
    if (! node->next) {
#line 327
      p->flags &= ~ 16;
    }
  } else {
#line 330
    wsp->ws_head = node->next;
  }
#line 332
  p = node->next;
#line 333
  if (p) {
#line 334
    p->prev = node->prev;
  } else {
#line 336
    wsp->ws_tail = node->prev;
  }
#line 338
  node->prev = (struct wordsplit_node *)((void *)0);
#line 338
  node->next = node->prev;
}
}
#line 342 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wsnode_insert(struct wordsplit *wsp , struct wordsplit_node *node , struct wordsplit_node *anchor ,
                          int before ) 
{ 
  struct wordsplit_node *p ;

  {
#line 345
  if (! wsp->ws_head) {
#line 347
    node->prev = (struct wordsplit_node *)((void *)0);
#line 347
    node->next = node->prev;
#line 348
    wsp->ws_tail = node;
#line 348
    wsp->ws_head = wsp->ws_tail;
  } else
#line 350
  if (before) {
#line 352
    if (anchor->prev) {
      {
#line 353
      wsnode_insert(wsp, node, anchor->prev, 0);
      }
    } else {
#line 356
      node->prev = (struct wordsplit_node *)((void *)0);
#line 357
      node->next = anchor;
#line 358
      anchor->prev = node;
#line 359
      wsp->ws_head = node;
    }
  } else {
#line 366
    p = anchor->next;
#line 367
    if (p) {
#line 368
      p->prev = node;
    } else {
#line 370
      wsp->ws_tail = node;
    }
#line 371
    node->next = p;
#line 372
    node->prev = anchor;
#line 373
    anchor->next = node;
  }
}
}
#line 378 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wordsplit_add_segm(struct wordsplit *wsp , size_t beg , size_t end___0 ,
                              int flg ) 
{ 
  struct wordsplit_node *node ;
  int rc ;

  {
#line 383
  if (end___0 == beg) {
#line 383
    if (! (flg & 256)) {
#line 384
      return (0);
    }
  }
  {
#line 385
  rc = wsnode_new(wsp, & node);
  }
#line 386
  if (rc) {
#line 387
    return (rc);
  }
  {
#line 388
  node->flags = flg & -259;
#line 389
  node->v.segm.beg = beg;
#line 390
  node->v.segm.end = end___0;
#line 391
  wsnode_append(wsp, node);
  }
#line 392
  return (0);
}
}
#line 396 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wordsplit_free_nodes(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *next ;

  {
#line 400
  p = wsp->ws_head;
  {
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;

#line 400
    if (! p) {
#line 400
      goto while_break;
    }
    {
#line 402
    next = p->next;
#line 403
    wsnode_free(p);
#line 404
    p = next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  wsp->ws_tail = (struct wordsplit_node *)((void *)0);
#line 406
  wsp->ws_head = wsp->ws_tail;
}
}
#line 410 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wordsplit_dump_nodes(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  int n ;
  char const   *__cil_tmp4 ;
  char const   *__cil_tmp5 ;
  int __cil_tmp6 ;

  {
#line 413
  n = 0;
#line 415
  n = 0;
#line 415
  p = wsp->ws_head;
  {
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;

#line 415
    if (! p) {
#line 415
      goto while_break;
    }
#line 417
    if (p->flags & 2) {
      {
#line 418
      __cil_tmp4 = wsnode_flagstr(p->flags);
#line 418
      (wsp->ws_debug)((char const   *)((char *)"%4d: %p: %#04x (%s):%s;"), n, p, p->flags,
                      __cil_tmp4, p->v.word);
      }
    } else {
      {
#line 421
      __cil_tmp5 = wsnode_flagstr(p->flags);
#line 421
      (wsp->ws_debug)((char const   *)((char *)"%4d: %p: %#04x (%s):%.*s;"), n, p,
                      p->flags, __cil_tmp5, (int )(p->v.segm.end - p->v.segm.beg),
                      wsp->ws_input + p->v.segm.beg);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  __cil_tmp6 = n;
#line 415
  n ++;
#line 415
  p = p->next;
}
}
#line 429 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int coalesce_segment(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *end___0 ;
  size_t len ;
  char *buf ;
  char *cur ;
  int stop ;
  size_t __cil_tmp9 ;
  size_t __cil_tmp10 ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  struct wordsplit_node *next ;
  char const   *str ;
  char const   *__cil_tmp15 ;
  size_t slen ;
  size_t __cil_tmp17 ;

  {
#line 432
  len = (size_t )0;
#line 436
  p = node;
  {
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;

#line 436
    if (! (p && p->flags & 16)) {
#line 436
      goto while_break;
    }
    {
#line 438
    __cil_tmp9 = wsnode_len(p);
    }
#line 438
    len += __cil_tmp9;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  p = p->next;
#line 440
  if (p) {
    {
#line 441
    __cil_tmp10 = wsnode_len(p);
    }
#line 441
    len += __cil_tmp10;
  }
  {
#line 442
  end___0 = p;
#line 444
  __cil_tmp11 = malloc(len + 1UL);
#line 444
  buf = (char *)__cil_tmp11;
  }
#line 445
  if (! buf) {
    {
#line 446
    __cil_tmp12 = _wsplt_nomem(wsp);
    }
#line 446
    return (__cil_tmp12);
  }
#line 447
  cur = buf;
#line 449
  p = node;
#line 450
  stop = 0;
  {
  {
#line 450
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 450
    if (! (! stop)) {
#line 450
      goto while_break___0;
    }
    {
#line 452
    next = p->next;
#line 453
    __cil_tmp15 = wsnode_ptr(wsp, p);
#line 453
    str = __cil_tmp15;
#line 454
    __cil_tmp17 = wsnode_len(p);
#line 454
    slen = __cil_tmp17;
#line 456
    memcpy((void *)cur, (void const   *)str, slen);
#line 457
    cur += slen;
    }
#line 458
    if (p != node) {
      {
#line 460
      wsnode_remove(wsp, p);
#line 461
      stop = p == end___0;
#line 462
      wsnode_free(p);
      }
    }
#line 464
    p = next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 467
  *cur = (char )0;
#line 469
  node->flags &= ~ 16;
#line 471
  if (node->flags & 2) {
    {
#line 472
    free((void *)node->v.word);
    }
  } else {
#line 474
    node->flags |= 2;
  }
#line 475
  node->v.word = buf;
#line 476
  return (0);
}
}
#line 480 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wsnode_quoteremoval(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  void (*uqfn)(char * , char const   * , size_t  ) ;
  void tmp(char *dst , char const   *src , size_t n ) ;
  char const   *str ;
  char const   *__cil_tmp6 ;
  size_t slen ;
  size_t __cil_tmp8 ;
  int unquote ;
  char *newstr ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 483
  if (wsp->ws_flags & 33554432) {
#line 483
    tmp = wordsplit_c_unquote_copy;
  } else {
#line 483
    tmp = wordsplit_sh_unquote_copy;
  }
#line 483
  uqfn = tmp;
#line 487
  p = wsp->ws_head;
  {
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;

#line 487
    if (! p) {
#line 487
      goto while_break;
    }
    {
#line 489
    __cil_tmp6 = wsnode_ptr(wsp, p);
#line 489
    str = __cil_tmp6;
#line 490
    __cil_tmp8 = wsnode_len(p);
#line 490
    slen = __cil_tmp8;
    }
#line 493
    if (wsp->ws_flags & 1536) {
#line 495
      unquote = ! (p->flags & 8);
    } else {
#line 498
      unquote = 0;
    }
#line 500
    if (unquote) {
#line 502
      if (! (p->flags & 2)) {
        {
#line 504
        __cil_tmp11 = malloc(slen + 1UL);
#line 504
        newstr = (char *)__cil_tmp11;
        }
#line 505
        if (! newstr) {
          {
#line 506
          __cil_tmp12 = _wsplt_nomem(wsp);
          }
#line 506
          return (__cil_tmp12);
        }
        {
#line 507
        memcpy((void *)newstr, (void const   *)str, slen);
#line 508
        *(newstr + slen) = (char )0;
#line 509
        p->v.word = newstr;
#line 510
        p->flags |= 2;
        }
      }
#line 513
      if (wsp->ws_flags & 268435456) {
        {
#line 514
        wordsplit_general_unquote_copy(p->v.word, str, slen, wsp->ws_escape);
        }
      } else {
        {
#line 517
        uqfn(p->v.word, str, slen);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  p = p->next;
#line 520
  return (0);
}
}
#line 524 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wsnode_coalesce(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  int __cil_tmp3 ;

  {
#line 528
  p = wsp->ws_head;
  {
  {
#line 528
  while (1) {
    while_continue: /* CIL Label */ ;

#line 528
    if (! p) {
#line 528
      goto while_break;
    }
#line 530
    if (p->flags & 16) {
      {
#line 531
      __cil_tmp3 = coalesce_segment(wsp, p);
      }
#line 531
      if (__cil_tmp3) {
#line 532
        return (1);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  p = p->next;
#line 534
  return (0);
}
}
#line 538 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wordsplit_finish(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  size_t n ;
  int __cil_tmp5 ;
  char const   *str ;
  char const   *__cil_tmp7 ;
  size_t slen ;
  size_t __cil_tmp9 ;
  char *newstr ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;

  {
#line 543
  n = (size_t )0;
#line 545
  p = wsp->ws_head;
  {
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;

#line 545
    if (! p) {
#line 545
      goto while_break;
    }
#line 546
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 545
  p = p->next;
#line 548
  __cil_tmp5 = alloc_space(wsp, n + 1UL);
  }
#line 548
  if (__cil_tmp5) {
#line 549
    return (1);
  }
#line 551
  p = wsp->ws_head;
  {
  {
#line 551
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 551
    if (! p) {
#line 551
      goto while_break___0;
    }
    {
#line 553
    __cil_tmp7 = wsnode_ptr(wsp, p);
#line 553
    str = __cil_tmp7;
#line 554
    __cil_tmp9 = wsnode_len(p);
#line 554
    slen = __cil_tmp9;
#line 555
    __cil_tmp11 = malloc(slen + 1UL);
#line 555
    newstr = (char *)__cil_tmp11;
#line 560
    *(wsp->ws_wordv + (wsp->ws_offs + wsp->ws_wordc)) = newstr;
    }
#line 561
    if (! newstr) {
      {
#line 562
      __cil_tmp12 = _wsplt_nomem(wsp);
      }
#line 562
      return (__cil_tmp12);
    }
    {
#line 563
    memcpy((void *)newstr, (void const   *)str, slen);
#line 564
    *(newstr + slen) = (char )0;
#line 566
    (wsp->ws_wordc) ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 551
  p = p->next;
#line 569
  *(wsp->ws_wordv + (wsp->ws_offs + wsp->ws_wordc)) = (char *)((void *)0);
#line 570
  return (0);
}
}
#line 576 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int node_split_prefix(struct wordsplit *wsp , struct wordsplit_node **ptail ,
                             struct wordsplit_node *node , size_t beg , size_t len ,
                             int flg ) 
{ 
  struct wordsplit_node *newnode ;
  int __cil_tmp8 ;
  char const   *str ;
  char const   *__cil_tmp10 ;
  char *newstr ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;

  {
#line 583
  if (len == 0UL) {
#line 584
    return (0);
  }
  {
#line 585
  __cil_tmp8 = wsnode_new(wsp, & newnode);
  }
#line 585
  if (__cil_tmp8) {
#line 586
    return (1);
  }
  {
#line 587
  wsnode_insert(wsp, newnode, *ptail, 0);
  }
#line 588
  if (node->flags & 2) {
    {
#line 590
    __cil_tmp10 = wsnode_ptr(wsp, node);
#line 590
    str = __cil_tmp10;
#line 591
    __cil_tmp12 = malloc(len + 1UL);
#line 591
    newstr = (char *)__cil_tmp12;
    }
#line 592
    if (! newstr) {
      {
#line 593
      __cil_tmp13 = _wsplt_nomem(wsp);
      }
#line 593
      return (__cil_tmp13);
    }
    {
#line 594
    memcpy((void *)newstr, (void const   *)(str + beg), len);
#line 595
    *(newstr + len) = (char )0;
#line 596
    newnode->flags = 2;
#line 597
    newnode->v.word = newstr;
    }
  } else {
#line 601
    newnode->v.segm.beg = node->v.segm.beg + beg;
#line 602
    newnode->v.segm.end = newnode->v.segm.beg + len;
  }
#line 604
  newnode->flags |= flg;
#line 605
  *ptail = newnode;
#line 606
  return (0);
}
}
#line 610 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int find_closing_cbrace(char const   *str , size_t i , size_t len , size_t *poff ) 
{ 
  enum __anonenum__483 state ;
  size_t level___0 ;

  {
#line 612
  state = (enum __anonenum__483 )0;
#line 614
  level___0 = (size_t )1;
  {
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;

#line 616
    if (! (i < len)) {
#line 616
      goto while_break;
    }
    {
#line 620
    if ((unsigned int )state == (unsigned int )0) {
#line 620
      goto case_0;
    }
#line 623
    if ((unsigned int )state == '{') {
#line 623
      goto case_123;
    }
#line 627
    if ((unsigned int )state == '}') {
#line 627
      goto case_125;
    }
#line 635
    if ((unsigned int )state == '\"') {
#line 635
      goto case_34;
    }
#line 639
    if ((unsigned int )state == '\'') {
#line 639
      goto case_39;
    }
#line 645
    if ((unsigned int )state == (unsigned int )1) {
#line 645
      goto case_1;
    }
#line 650
    if ((unsigned int )state == (unsigned int )2) {
#line 650
      goto case_2;
    }
#line 618
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 623
    if ((int )((char )*(str + i)) == '{') {
#line 623
      goto case_123;
    }
#line 627
    if ((int )((char )*(str + i)) == '}') {
#line 627
      goto case_125;
    }
#line 635
    if ((int )((char )*(str + i)) == '\"') {
#line 635
      goto case_34;
    }
#line 639
    if ((int )((char )*(str + i)) == '\'') {
#line 639
      goto case_39;
    }
#line 621
    goto switch_break___0;
    case_123: /* CIL Label */ 
#line 624
    level___0 ++;
#line 625
    goto switch_break___0;
    case_125: /* CIL Label */ 
#line 628
    level___0 --;
#line 628
    if (level___0 == 0UL) {
#line 630
      *poff = i;
#line 631
      return (0);
    }
#line 633
    goto switch_break___0;
    case_34: /* CIL Label */ 
#line 636
    state = (enum __anonenum__483 )2;
#line 637
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 640
    state = (enum __anonenum__483 )1;
#line 641
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 643
    goto switch_break;
    case_1: /* CIL Label */ 
#line 646
    if ((int )((char )*(str + i)) == 39) {
#line 647
      state = (enum __anonenum__483 )0;
    }
#line 648
    goto switch_break;
    case_2: /* CIL Label */ 
#line 651
    if ((int )((char )*(str + i)) == 92) {
#line 652
      i ++;
    } else
#line 653
    if ((int )((char )*(str + i)) == 34) {
#line 654
      state = (enum __anonenum__483 )0;
    }
#line 655
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  i ++;
#line 658
  return (1);
}
}
#line 662 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static char const   *wordsplit_find_env(struct wordsplit *wsp , char const   *name ,
                                        size_t len ) 
{ 
  size_t i ;
  size_t elen ;
  size_t __cil_tmp6 ;
  int __cil_tmp7 ;
  size_t j ;
  char const   *var ;

  {
#line 666
  if (! (wsp->ws_flags & 524288)) {
#line 667
    return ((char const   *)((void *)0));
  }
#line 669
  if (wsp->ws_flags & 134217728) {
#line 672
    i = (size_t )0;
    {
    {
#line 672
    while (1) {
      while_continue: /* CIL Label */ ;

#line 672
      if (! *(wsp->ws_env + i)) {
#line 672
        goto while_break;
      }
      {
#line 674
      __cil_tmp6 = strlen(*(wsp->ws_env + i));
#line 674
      elen = __cil_tmp6;
#line 675
      __cil_tmp7 = memcmp((void const   *)*(wsp->ws_env + i), (void const   *)name,
                          elen);
      }
#line 675
      if (elen == len) {
#line 675
        if (__cil_tmp7 == 0) {
#line 676
          return (*(wsp->ws_env + (i + 1UL)));
        }
      }
#line 678
      i ++;
#line 679
      if (*(wsp->ws_env + i) == (char const   *)((void *)0)) {
#line 680
        goto while_break;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 672
    i ++;
  } else {
#line 686
    i = (size_t )0;
    {
    {
#line 686
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 686
      if (! *(wsp->ws_env + i)) {
#line 686
        goto while_break___0;
      }
#line 689
      var = *(wsp->ws_env + i);
#line 691
      j = (size_t )0;
      {
      {
#line 691
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 691
        if (! (j < len)) {
#line 691
          goto while_break___1;
        }
#line 692
        if ((int )((char )*(name + j)) != (int )((char )*(var + j))) {
#line 693
          goto while_break___1;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 691
      j ++;
#line 694
      if (j == len) {
#line 694
        if ((int )((char )*(var + j)) == 61) {
#line 695
          return ((var + j) + 1);
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 686
    i ++;
  }
#line 698
  return ((char const   *)((void *)0));
}
}
#line 702 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int expvar(struct wordsplit *wsp , char const   *str , size_t len , struct wordsplit_node **ptail ,
                  char const   **pend , int flg ) 
{ 
  size_t i ;
  char const   *defstr ;
  char const   *value ;
  char const   *vptr ;
  struct wordsplit_node *newnode ;
  char const   *start ;
  size_t __cil_tmp15 ;
  size_t j ;
  int __cil_tmp18 ;
  int __cil_tmp19 ;
  void *__cil_tmp20 ;
  int __cil_tmp21 ;
  char *__cil_tmp23 ;
  int __cil_tmp24 ;
  char *__cil_tmp26 ;
  int __cil_tmp27 ;
  int __cil_tmp29 ;
  int __cil_tmp30 ;
  struct wordsplit ws ;
  int i___82 ;
  int __cil_tmp33 ;
  int __cil_tmp34 ;
  int tmp ;
  int __cil_tmp37 ;
  size_t size ;
  int __cil_tmp40 ;
  void *__cil_tmp41 ;
  int __cil_tmp42 ;
  int __cil_tmp43 ;

  {
#line 705
  i = (size_t )0;
#line 706
  defstr = (char const   *)((void *)0);
#line 710
  start = str - 1;
#line 712
  if (65U <= (unsigned int )((char )*(str + 0))) {
#line 712
    if ((unsigned int )((char )*(str + 0)) <= 90U) {
      _L: /* CIL Label */ 
#line 714
      i = (size_t )1;
      {
      {
#line 714
      while (1) {
        while_continue: /* CIL Label */ ;

#line 714
        if (! (i < len)) {
#line 714
          goto while_break;
        }
#line 715
        if (! ((((65U <= (unsigned int )((char )*(str + i)) && (unsigned int )((char )*(str + i)) <= 90U) || (97U <= (unsigned int )((char )*(str + i)) && (unsigned int )((char )*(str + i)) <= 122U)) || (48U <= (unsigned int )((char )*(str + i)) && (unsigned int )((char )*(str + i)) <= 57U)) || (int )((char )*(str + i)) == 95)) {
#line 716
          goto while_break;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 714
      i ++;
#line 717
      *pend = (str + i) - 1;
    } else {
#line 712
      goto _L___81;
    }
  } else
  _L___81: /* CIL Label */ 
#line 712
  if (97U <= (unsigned int )((char )*(str + 0))) {
#line 712
    if ((unsigned int )((char )*(str + 0)) <= 122U) {
#line 712
      goto _L;
    } else {
#line 712
      goto _L___80;
    }
  } else
  _L___80: /* CIL Label */ 
#line 712
  if ((int )((char )*(str + 0)) == 95) {
#line 712
    goto _L;
  } else
#line 719
  if ((int )((char )*(str + 0)) == 123) {
#line 721
    str ++;
#line 722
    __cil_tmp15 = len;
#line 722
    len --;
#line 723
    i = (size_t )1;
    {
    {
#line 723
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 723
      if (! (i < len)) {
#line 723
        goto while_break___0;
      }
#line 724
      if ((int )((char )*(str + i)) == 125) {
#line 725
        goto while_break___0;
      } else
#line 724
      if ((int )((char )*(str + i)) == 58) {
#line 725
        goto while_break___0;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 723
    i ++;
#line 726
    if ((int )((char )*(str + i)) == 58) {
      {
#line 730
      defstr = (str + i) + 1;
#line 731
      __cil_tmp18 = find_closing_cbrace(str, i + 1UL, len, & j);
      }
#line 731
      if (__cil_tmp18) {
#line 733
        wsp->ws_errno = 5;
#line 734
        return (1);
      }
#line 736
      *pend = str + j;
    } else
#line 738
    if ((int )((char )*(str + i)) == 125) {
#line 740
      defstr = (char const   *)((void *)0);
#line 741
      *pend = str + i;
    } else {
#line 745
      wsp->ws_errno = 5;
#line 746
      return (1);
    }
  } else {
    {
#line 751
    __cil_tmp19 = wsnode_new(wsp, & newnode);
    }
#line 751
    if (__cil_tmp19) {
#line 752
      return (1);
    }
    {
#line 753
    wsnode_insert(wsp, newnode, *ptail, 0);
#line 754
    *ptail = newnode;
#line 755
    newnode->flags = 2 | flg;
#line 756
    __cil_tmp20 = malloc((unsigned long )3);
#line 756
    newnode->v.word = (char *)__cil_tmp20;
    }
#line 757
    if (! newnode->v.word) {
      {
#line 758
      __cil_tmp21 = _wsplt_nomem(wsp);
      }
#line 758
      return (__cil_tmp21);
    }
#line 759
    *(newnode->v.word + 0) = (char )'$';
#line 760
    *(newnode->v.word + 1) = (char )*(str + 0);
#line 761
    *(newnode->v.word + 2) = (char )0;
#line 762
    *pend = str;
#line 763
    return (0);
  }
  {
#line 771
  vptr = wordsplit_find_env(wsp, str, i);
  }
#line 772
  if (vptr) {
    {
#line 774
    __cil_tmp23 = strdup(vptr);
#line 774
    value = (char const   *)__cil_tmp23;
    }
#line 775
    if (! value) {
      {
#line 776
      __cil_tmp24 = _wsplt_nomem(wsp);
      }
#line 776
      return (__cil_tmp24);
    }
  } else
#line 778
  if (wsp->ws_flags & 1048576) {
    {
#line 779
    value = (wsp->ws_getvar)(str, i, wsp->ws_closure);
    }
  } else
#line 780
  if (wsp->ws_flags & 32) {
#line 782
    wsp->ws_errno = 6;
#line 783
    if (wsp->ws_flags & 16) {
      {
#line 784
      wordsplit_perror(wsp);
      }
    }
#line 785
    return (1);
  } else {
#line 789
    if (wsp->ws_flags & 16777216) {
      {
#line 790
      __cil_tmp26 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"warning: undefined variable `%.*s\'"),
                              5);
#line 790
      (wsp->ws_error)((char const   *)__cil_tmp26, (int )i, str);
      }
    }
#line 791
    if (wsp->ws_flags & 8388608) {
#line 792
      value = (char const   *)((void *)0);
    } else {
#line 794
      value = (char const   *)((char *)"");
    }
  }
#line 797
  if (value) {
#line 799
    if (flg & 4) {
      {
#line 801
      __cil_tmp27 = wsnode_new(wsp, & newnode);
      }
#line 801
      if (__cil_tmp27) {
#line 802
        return (1);
      }
      {
#line 803
      wsnode_insert(wsp, newnode, *ptail, 0);
#line 804
      *ptail = newnode;
#line 805
      newnode->flags = 10 | flg;
#line 806
      newnode->v.word = strdup(value);
      }
#line 807
      if (! newnode->v.word) {
        {
#line 808
        __cil_tmp29 = _wsplt_nomem(wsp);
        }
#line 808
        return (__cil_tmp29);
      }
    } else
#line 810
    if ((int )((char )*value) == 0) {
      {
#line 813
      __cil_tmp30 = wsnode_new(wsp, & newnode);
      }
#line 813
      if (__cil_tmp30) {
#line 814
        return (1);
      }
      {
#line 815
      wsnode_insert(wsp, newnode, *ptail, 0);
#line 816
      *ptail = newnode;
#line 817
      newnode->flags = 1;
      }
    } else {
      {
#line 824
      ws.ws_delim = wsp->ws_delim;
#line 825
      __cil_tmp33 = wordsplit(value, & ws, 16708);
      }
#line 825
      if (__cil_tmp33) {
        {
#line 828
        wordsplit_free(& ws);
        }
#line 829
        return (1);
      }
#line 831
      i___82 = 0;
      {
      {
#line 831
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 831
        if (! ((unsigned long )i___82 < ws.ws_wordc)) {
#line 831
          goto while_break___1;
        }
        {
#line 833
        __cil_tmp34 = wsnode_new(wsp, & newnode);
        }
#line 833
        if (__cil_tmp34) {
#line 834
          return (1);
        }
        {
#line 835
        wsnode_insert(wsp, newnode, *ptail, 0);
#line 836
        *ptail = newnode;
        }
#line 837
        if ((unsigned long )(i___82 + 1) < ws.ws_wordc) {
#line 837
          tmp = flg & -17;
        } else {
#line 837
          tmp = flg;
        }
        {
#line 837
        newnode->flags = 10 | tmp;
#line 840
        newnode->v.word = strdup((char const   *)*(ws.ws_wordv + i___82));
        }
#line 841
        if (! newnode->v.word) {
          {
#line 842
          __cil_tmp37 = _wsplt_nomem(wsp);
          }
#line 842
          return (__cil_tmp37);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 831
      i___82 ++;
#line 844
      wordsplit_free(& ws);
      }
    }
  } else
#line 847
  if (wsp->ws_flags & 8388608) {
    {
#line 849
    size = (size_t )((*pend - start) + 1L);
#line 851
    __cil_tmp40 = wsnode_new(wsp, & newnode);
    }
#line 851
    if (__cil_tmp40) {
#line 852
      return (1);
    }
    {
#line 853
    wsnode_insert(wsp, newnode, *ptail, 0);
#line 854
    *ptail = newnode;
#line 855
    newnode->flags = 10 | flg;
#line 856
    __cil_tmp41 = malloc(size + 1UL);
#line 856
    newnode->v.word = (char *)__cil_tmp41;
    }
#line 857
    if (! newnode->v.word) {
      {
#line 858
      __cil_tmp42 = _wsplt_nomem(wsp);
      }
#line 858
      return (__cil_tmp42);
    }
    {
#line 859
    memcpy((void *)newnode->v.word, (void const   *)start, size);
#line 860
    *(newnode->v.word + size) = (char )0;
    }
  } else {
    {
#line 864
    __cil_tmp43 = wsnode_new(wsp, & newnode);
    }
#line 864
    if (__cil_tmp43) {
#line 865
      return (1);
    }
    {
#line 866
    wsnode_insert(wsp, newnode, *ptail, 0);
#line 867
    *ptail = newnode;
#line 868
    newnode->flags = 1;
    }
  }
#line 870
  return (0);
}
}
#line 874 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int node_expand_vars(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 
  char const   *str ;
  char const   *__cil_tmp4 ;
  size_t slen ;
  size_t __cil_tmp6 ;
  char const   *end___0 ;
  char const   *p ;
  size_t off ;
  struct wordsplit_node *tail ;
  size_t n ;
  int __cil_tmp13 ;
  int __cil_tmp15 ;
  int __cil_tmp17 ;

  {
  {
#line 876
  __cil_tmp4 = wsnode_ptr(wsp, node);
#line 876
  str = __cil_tmp4;
#line 877
  __cil_tmp6 = wsnode_len(node);
#line 877
  slen = __cil_tmp6;
#line 878
  end___0 = str + slen;
#line 880
  off = (size_t )0;
#line 881
  tail = node;
#line 883
  p = str;
  }
  {
  {
#line 883
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 883
    if (! (p < end___0)) {
#line 883
      goto while_break;
    }
#line 885
    if ((int )((char )*p) == 92) {
#line 887
      p ++;
#line 888
      goto while_continue;
    }
#line 890
    if ((int )((char )*p) == 36) {
#line 892
      n = (size_t )(p - str);
#line 894
      if (tail != node) {
#line 895
        tail->flags |= 16;
      }
      {
#line 896
      __cil_tmp13 = node_split_prefix(wsp, & tail, node, off, n, 16);
      }
#line 896
      if (__cil_tmp13) {
#line 897
        return (1);
      }
      {
#line 898
      p ++;
#line 899
      __cil_tmp15 = expvar(wsp, p, slen - n, & tail, & p, node->flags & 20);
      }
#line 899
      if (__cil_tmp15) {
#line 901
        return (1);
      }
#line 902
      off += (unsigned long )((p - str) + 1L);
#line 903
      str = p + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  p ++;
#line 906
  if (p > str) {
#line 908
    if (tail != node) {
#line 909
      tail->flags |= 16;
    }
    {
#line 910
    __cil_tmp17 = node_split_prefix(wsp, & tail, node, off, (size_t )(p - str), node->flags & 16);
    }
#line 910
    if (__cil_tmp17) {
#line 912
      return (1);
    }
  }
#line 914
  if (tail != node) {
    {
#line 916
    wsnode_remove(wsp, node);
#line 917
    wsnode_free(node);
    }
  }
#line 919
  return (0);
}
}
#line 924 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wsnode_nullelim(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *next ;

  {
#line 928
  p = wsp->ws_head;
  {
  {
#line 928
  while (1) {
    while_continue: /* CIL Label */ ;

#line 928
    if (! p) {
#line 928
      goto while_break;
    }
#line 930
    next = p->next;
#line 931
    if (p->flags & 1) {
      {
#line 933
      wsnode_remove(wsp, p);
#line 934
      wsnode_free(p);
      }
    }
#line 936
    p = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 941 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wordsplit_varexp(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *next ;
  int __cil_tmp4 ;

  {
#line 945
  p = wsp->ws_head;
  {
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;

#line 945
    if (! p) {
#line 945
      goto while_break;
    }
#line 947
    next = p->next;
#line 948
    if (! (p->flags & 8)) {
      {
#line 949
      __cil_tmp4 = node_expand_vars(wsp, p);
      }
#line 949
      if (__cil_tmp4) {
#line 950
        return (1);
      }
    }
#line 951
    p = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 954
  wsnode_nullelim(wsp);
  }
#line 955
  return (0);
}
}
#line 962 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static void wordsplit_trimws(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  size_t n ;
  size_t __cil_tmp5 ;

  {
#line 966
  p = wsp->ws_head;
  {
  {
#line 966
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 966
    if (! p) {
#line 966
      goto while_break;
    }
#line 970
    if (p->flags & 4) {
#line 971
      goto while_continue;
    }
#line 974
    n = p->v.segm.beg;
    {
    {
#line 974
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 974
      if (! (n < p->v.segm.end && (((int )((char )*(wsp->ws_input + n)) == 32 || (int )((char )*(wsp->ws_input + n)) == 9) || (int )((char )*(wsp->ws_input + n)) == 10))) {
#line 974
        goto while_break___0;
      }

    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 975
    n ++;
#line 977
    p->v.segm.beg = n;
#line 979
    n = p->v.segm.end;
    {
    {
#line 979
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 979
      if (! (n > p->v.segm.beg && (((int )((char )*(wsp->ws_input + (n - 1UL))) == 32 || (int )((char )*(wsp->ws_input + (n - 1UL))) == 9) || (int )((char )*(wsp->ws_input + (n - 1UL))) == 10))) {
#line 979
        goto while_break___1;
      }

    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 980
    __cil_tmp5 = n;
#line 980
    n --;
#line 981
    p->v.segm.end = n;
#line 982
    if (p->v.segm.beg == p->v.segm.end) {
#line 983
      p->flags |= 1;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 966
  p = p->next;
#line 986
  wsnode_nullelim(wsp);
  }
}
}
#line 1023 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static size_t skip_delim(struct wordsplit *wsp ) 
{ 
  size_t start ;
  char *__cil_tmp3 ;
  int delim ;
  char *__cil_tmp6 ;
  size_t __cil_tmp8 ;

  {
#line 1025
  start = wsp->ws_endp;
#line 1026
  if (wsp->ws_flags & 2048) {
    {
#line 1028
    __cil_tmp3 = strchr(wsp->ws_delim, (int )((char )*(wsp->ws_input + start)));
    }
#line 1028
    if (wsp->ws_flags & 4096) {
#line 1028
      if (__cil_tmp3 != (char *)((void *)0)) {
#line 1031
        delim = (int )((char )*(wsp->ws_input + start));
        {
        {
#line 1032
        while (1) {
          while_continue: /* CIL Label */ ;

#line 1033
          start ++;
#line 1032
          if (! (start < wsp->ws_len && delim == (int )((char )*(wsp->ws_input + start)))) {
#line 1032
            goto while_break;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 1028
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 1038
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1039
        start ++;
#line 1038
        if (! (start < wsp->ws_len && __cil_tmp6 != (char *)((void *)0))) {
#line 1038
          goto while_break___0;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1042
    __cil_tmp8 = start;
#line 1042
    start --;
  }
#line 1045
  if (! (wsp->ws_flags & 4096)) {
#line 1046
    start ++;
  }
#line 1048
  return (start);
}
}
#line 1173 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static char quote_transtab[]  =    "\\\\\"\"a\ab\bf\fn\nr\rt\tv\v";
#line 1176 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
int wordsplit_c_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 1180
  p = (char *)quote_transtab;
  {
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1180
    if (! *p) {
#line 1180
      goto while_break;
    }
#line 1182
    if ((int )*p == c) {
#line 1183
      return ((int )*(p + 1));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1180
  p += 2;
#line 1185
  return (c);
}
}
#line 1189 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
int wordsplit_c_quote_char(int c ) 
{ 
  char *p ;

  {
#line 1193
  p = ((char *)quote_transtab + sizeof(quote_transtab)) - 2;
  {
  {
#line 1193
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1193
    if (! (p > (char *)quote_transtab)) {
#line 1193
      goto while_break;
    }
#line 1196
    if ((int )*p == c) {
#line 1197
      return ((int )*(p + - 1));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1194
  p -= 2;
#line 1199
  return (- 1);
}
}
#line 1206 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int xtonum(int *pval , char const   *src , int base , int cnt ) 
{ 
  int i ;
  int val ;
  int n ;
  char *__cil_tmp8 ;
  int tmp ;
  int tmp___87 ;
  int __cil_tmp11 ;
  char const   *__cil_tmp12 ;

  {
#line 1210
  val = 0;
#line 1210
  i = 0;
  {
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1210
    if (! (i < cnt)) {
#line 1210
      goto while_break;
    }
#line 1212
    n = (int )*((unsigned char *)src);
#line 1213
    if (48U <= (unsigned int )n && (unsigned int )n <= 57U) {
#line 1213
      tmp___87 = n - 48;
    } else {
      {
#line 1213
      __cil_tmp8 = strchr((char const   *)((char *)"abcdefABCDEF"), n);
      }
#line 1213
      if (__cil_tmp8 != (char *)((void *)0)) {
#line 1213
        tmp = -55;
      } else {
#line 1213
        tmp = 255;
      }
#line 1213
      tmp___87 = tmp;
    }
#line 1213
    n = tmp___87;
#line 1213
    if (n > 127) {
#line 1214
      goto while_break;
    } else
#line 1213
    if (n >= base) {
#line 1214
      goto while_break;
    }
#line 1215
    val = val * base + n;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  __cil_tmp12 = src;
#line 1210
  src ++;
#line 1210
  __cil_tmp11 = i;
#line 1210
  i ++;
#line 1217
  *pval = val;
#line 1218
  return (i);
}
}
#line 1222 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
size_t wordsplit_c_quoted_length(char const   *str , int quote_hex , int *quote ) 
{ 
  size_t len ;
  char *__cil_tmp5 ;
  int __cil_tmp8 ;

  {
#line 1224
  len = (size_t )0;
#line 1226
  *quote = 0;
  {
  {
#line 1227
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1227
    if (! ((char )*str)) {
#line 1227
      goto while_break;
    }
    {
#line 1229
    __cil_tmp5 = strchr((char const   *)((char *)" \""), (int )((char )*str));
    }
#line 1229
    if (__cil_tmp5) {
#line 1230
      *quote = 1;
    }
#line 1232
    if ((int )((char )*str) == 32) {
#line 1233
      len ++;
    } else
#line 1234
    if ((int )((char )*str) == 34) {
#line 1235
      len += (unsigned long )2;
    } else
#line 1236
    if ((int )((char )*str) != 9) {
#line 1236
      if ((int )((char )*str) != 92) {
#line 1236
        if (32U <= (unsigned int )((char )*str)) {
#line 1236
          if ((unsigned int )((char )*str) <= 127U) {
#line 1237
            len ++;
          } else {
#line 1236
            goto _L;
          }
        } else {
#line 1236
          goto _L;
        }
      } else {
#line 1236
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1238
    if (quote_hex) {
#line 1239
      len += (unsigned long )3;
    } else {
      {
#line 1242
      __cil_tmp8 = wordsplit_c_quote_char((int )((char )*str));
      }
#line 1242
      if (__cil_tmp8 != -1) {
#line 1243
        len += (unsigned long )2;
      } else {
#line 1245
        len += (unsigned long )4;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  str ++;
#line 1248
  return (len);
}
}
#line 1252 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
void wordsplit_general_unquote_copy(char *dst , char const   *src , size_t n , char const   *escapable ) 
{ 
  int i ;
  char *__cil_tmp6 ;
  char *__cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1257
  i = 0;
  {
  {
#line 1257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1257
    if (! ((unsigned long )i < n)) {
#line 1257
      goto while_break;
    }
    {
#line 1259
    __cil_tmp6 = strchr(escapable, (int )((char )*(src + (i + 1))));
    }
#line 1259
    if ((int )((char )*(src + i)) == 92) {
#line 1259
      if ((unsigned long )i < n) {
#line 1259
        if (__cil_tmp6) {
#line 1260
          i ++;
        }
      }
    }
#line 1261
    __cil_tmp9 = i;
#line 1261
    i ++;
#line 1261
    __cil_tmp8 = dst;
#line 1261
    dst ++;
#line 1261
    *__cil_tmp8 = (char )*(src + __cil_tmp9);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  *dst = (char )0;
}
}
#line 1267 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
void wordsplit_sh_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i ;
  char *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 1271
  i = 0;
  {
  {
#line 1271
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1271
    if (! ((unsigned long )i < n)) {
#line 1271
      goto while_break;
    }
#line 1273
    if ((int )((char )*(src + i)) == 92) {
#line 1274
      i ++;
    }
#line 1275
    __cil_tmp7 = i;
#line 1275
    i ++;
#line 1275
    __cil_tmp6 = dst;
#line 1275
    dst ++;
#line 1275
    *__cil_tmp6 = (char )*(src + __cil_tmp7);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  *dst = (char )0;
}
}
#line 1281 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
void wordsplit_c_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i ;
  int c ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  int off ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  int __cil_tmp17 ;
  int off___0 ;
  int __cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  int __cil_tmp25 ;
  int __cil_tmp26 ;
  char *__cil_tmp27 ;
  int __cil_tmp28 ;

  {
#line 1283
  i = 0;
  {
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1286
    if (! ((unsigned long )i < n)) {
#line 1286
      goto while_break;
    }
#line 1288
    if ((int )((char )*(src + i)) == 92) {
#line 1290
      i ++;
#line 1291
      if ((int )((char )*(src + i)) == 120) {
        _L___89: /* CIL Label */ 
#line 1293
        if (n - (unsigned long )i < 2UL) {
#line 1295
          __cil_tmp6 = dst;
#line 1295
          dst ++;
#line 1295
          *__cil_tmp6 = (char )'\\';
#line 1296
          __cil_tmp8 = i;
#line 1296
          i ++;
#line 1296
          __cil_tmp7 = dst;
#line 1296
          dst ++;
#line 1296
          *__cil_tmp7 = (char )*(src + __cil_tmp8);
        } else {
          {
#line 1300
          __cil_tmp10 = xtonum(& c, (src + i) + 1, 16, 2);
#line 1300
          off = __cil_tmp10;
          }
#line 1302
          if (off == 0) {
#line 1304
            __cil_tmp11 = dst;
#line 1304
            dst ++;
#line 1304
            *__cil_tmp11 = (char )'\\';
#line 1305
            __cil_tmp13 = i;
#line 1305
            i ++;
#line 1305
            __cil_tmp12 = dst;
#line 1305
            dst ++;
#line 1305
            *__cil_tmp12 = (char )*(src + __cil_tmp13);
          } else {
#line 1309
            __cil_tmp14 = dst;
#line 1309
            dst ++;
#line 1309
            *__cil_tmp14 = (char )c;
#line 1310
            i += off + 1;
          }
        }
      } else
#line 1291
      if ((int )((char )*(src + i)) == 88) {
#line 1291
        goto _L___89;
      } else
#line 1314
      if ((int )((unsigned char )((char )*(src + i))) < 128) {
#line 1314
        if (48U <= (unsigned int )((char )*(src + i))) {
#line 1314
          if ((unsigned int )((char )*(src + i)) <= 57U) {
#line 1316
            if (n - (unsigned long )i < 1UL) {
#line 1318
              __cil_tmp15 = dst;
#line 1318
              dst ++;
#line 1318
              *__cil_tmp15 = (char )'\\';
#line 1319
              __cil_tmp17 = i;
#line 1319
              i ++;
#line 1319
              __cil_tmp16 = dst;
#line 1319
              dst ++;
#line 1319
              *__cil_tmp16 = (char )*(src + __cil_tmp17);
            } else {
              {
#line 1323
              __cil_tmp19 = xtonum(& c, src + i, 8, 3);
#line 1323
              off___0 = __cil_tmp19;
              }
#line 1324
              if (off___0 == 0) {
#line 1326
                __cil_tmp20 = dst;
#line 1326
                dst ++;
#line 1326
                *__cil_tmp20 = (char )'\\';
#line 1327
                __cil_tmp22 = i;
#line 1327
                i ++;
#line 1327
                __cil_tmp21 = dst;
#line 1327
                dst ++;
#line 1327
                *__cil_tmp21 = (char )*(src + __cil_tmp22);
              } else {
#line 1331
                __cil_tmp23 = dst;
#line 1331
                dst ++;
#line 1331
                *__cil_tmp23 = (char )c;
#line 1332
                i += off___0;
              }
            }
          } else {
#line 1314
            goto _L;
          }
        } else {
#line 1314
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1337
        __cil_tmp25 = i;
#line 1337
        i ++;
#line 1337
        __cil_tmp26 = wordsplit_c_unquote_char((int )((char )*(src + __cil_tmp25)));
        }
#line 1337
        __cil_tmp24 = dst;
#line 1337
        dst ++;
#line 1337
        *__cil_tmp24 = (char )__cil_tmp26;
      }
    } else {
#line 1340
      __cil_tmp28 = i;
#line 1340
      i ++;
#line 1340
      __cil_tmp27 = dst;
#line 1340
      dst ++;
#line 1340
      *__cil_tmp27 = (char )*(src + __cil_tmp28);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1342
  *dst = (char )0;
}
}
#line 1346 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
void wordsplit_c_quote_copy(char *dst , char const   *src , int quote_hex ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char tmp[4] ;
  int c ;
  int __cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 1348
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1348
    if (! ((char )*src)) {
#line 1348
      goto while_break;
    }
#line 1350
    if ((int )((char )*src) == 34) {
#line 1352
      __cil_tmp4 = dst;
#line 1352
      dst ++;
#line 1352
      *__cil_tmp4 = (char )'\\';
#line 1353
      __cil_tmp5 = dst;
#line 1353
      dst ++;
#line 1353
      *__cil_tmp5 = (char )*src;
    } else
#line 1355
    if ((int )((char )*src) != 9) {
#line 1355
      if ((int )((char )*src) != 92) {
#line 1355
        if (32U <= (unsigned int )((char )*src)) {
#line 1355
          if ((unsigned int )((char )*src) <= 127U) {
#line 1356
            __cil_tmp6 = dst;
#line 1356
            dst ++;
#line 1356
            *__cil_tmp6 = (char )*src;
          } else {
#line 1355
            goto _L;
          }
        } else {
#line 1355
          goto _L;
        }
      } else {
#line 1355
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1361
    if (quote_hex) {
      {
#line 1363
      snprintf((char *)tmp, sizeof(tmp), (char const   *)((char *)"%%%02X"), (int )*((unsigned char *)src));
#line 1364
      memcpy((void *)dst, (void const   *)((char *)tmp), (unsigned long )3);
#line 1365
      dst += 3;
      }
    } else {
      {
#line 1369
      __cil_tmp9 = wordsplit_c_quote_char((int )((char )*src));
#line 1369
      c = __cil_tmp9;
#line 1370
      __cil_tmp10 = dst;
#line 1370
      dst ++;
#line 1370
      *__cil_tmp10 = (char )'\\';
      }
#line 1371
      if (c != -1) {
#line 1372
        __cil_tmp11 = dst;
#line 1372
        dst ++;
#line 1372
        *__cil_tmp11 = (char )c;
      } else {
        {
#line 1375
        snprintf((char *)tmp, sizeof(tmp), (char const   *)((char *)"%03o"), (int )*((unsigned char *)src));
#line 1376
        memcpy((void *)dst, (void const   *)((char *)tmp), (unsigned long )3);
#line 1377
        dst += 3;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1348
  src ++;
}
}
#line 1385 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
static int wordsplit_process_list(struct wordsplit *wsp , size_t start ) 
{ 
  int __cil_tmp3 ;
  int rc ;
  int __cil_tmp7 ;
  int __cil_tmp8 ;
  int __cil_tmp9 ;

  {
#line 1387
  if (wsp->ws_flags & 4194304) {
    {
#line 1390
    __cil_tmp3 = wordsplit_add_segm(wsp, start, wsp->ws_len, 4);
    }
#line 1390
    if (__cil_tmp3) {
#line 1391
      return (wsp->ws_errno);
    }
  } else {
    {
    {
#line 1397
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1397
      if (! (rc == 1)) {
#line 1397
        goto while_break;
      }
      {
#line 1398
      start = skip_delim(wsp);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1400
    if (wsp->ws_tail) {
#line 1401
      (wsp->ws_tail)->flags &= ~ 16;
    }
#line 1402
    if (rc == 2) {
#line 1403
      return (wsp->ws_errno);
    }
  }
#line 1406
  if (wsp->ws_flags & 2097152) {
    {
#line 1408
    (wsp->ws_debug)((char const   *)((char *)"Initial list:"));
#line 1409
    wordsplit_dump_nodes(wsp);
    }
  }
#line 1412
  if (wsp->ws_flags & 256) {
    {
#line 1415
    wordsplit_trimws(wsp);
    }
#line 1416
    if (wsp->ws_flags & 2097152) {
      {
#line 1418
      (wsp->ws_debug)((char const   *)((char *)"After WS trimming:"));
#line 1419
      wordsplit_dump_nodes(wsp);
      }
    }
  }
#line 1424
  if (! (wsp->ws_flags & 64)) {
    {
#line 1426
    __cil_tmp7 = wordsplit_varexp(wsp);
    }
#line 1426
    if (__cil_tmp7) {
      {
#line 1428
      wordsplit_free_nodes(wsp);
      }
#line 1429
      return (wsp->ws_errno);
    }
#line 1431
    if (wsp->ws_flags & 2097152) {
      {
#line 1433
      (wsp->ws_debug)((char const   *)((char *)"Expanded list:"));
#line 1434
      wordsplit_dump_nodes(wsp);
      }
    }
  }
  {
  {
#line 1438
  while (1) {
    while_continue___0: /* CIL Label */ ;

    {
#line 1440
    __cil_tmp8 = wsnode_quoteremoval(wsp);
    }
#line 1440
    if (__cil_tmp8) {
#line 1441
      goto while_break___0;
    }
#line 1442
    if (wsp->ws_flags & 2097152) {
      {
#line 1444
      (wsp->ws_debug)((char const   *)((char *)"After quote removal:"));
#line 1445
      wordsplit_dump_nodes(wsp);
      }
    }
    {
#line 1448
    __cil_tmp9 = wsnode_coalesce(wsp);
    }
#line 1448
    if (__cil_tmp9) {
#line 1449
      goto while_break___0;
    }
#line 1451
    if (wsp->ws_flags & 2097152) {
      {
#line 1453
      (wsp->ws_debug)((char const   *)((char *)"Coalesced list:"));
#line 1454
      wordsplit_dump_nodes(wsp);
      }
    }
#line 1438
    goto while_break___0;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1458
  return (wsp->ws_errno);
}
}
#line 1462 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
int wordsplit_len(char const   *command , size_t length , struct wordsplit *wsp ,
                  int flags ) 
{ 
  int rc ;
  size_t start ;
  char const   *cmdptr ;
  size_t cmdlen ;

  {
#line 1470
  if (! command) {
#line 1472
    if (! (flags & 536870912)) {
#line 1473
      return (22);
    }
    {
#line 1475
    start = skip_delim(wsp);
    }
#line 1476
    if (wsp->ws_endp == wsp->ws_len) {
#line 1478
      wsp->ws_errno = 7;
#line 1479
      if (wsp->ws_flags & 16) {
        {
#line 1480
        wordsplit_perror(wsp);
        }
      }
#line 1481
      return (wsp->ws_errno);
    }
    {
#line 1484
    cmdptr = wsp->ws_input + wsp->ws_endp;
#line 1485
    cmdlen = wsp->ws_len - wsp->ws_endp;
#line 1486
    wsp->ws_flags |= 8;
#line 1487
    wordsplit_init0(wsp);
    }
  } else {
    {
#line 1491
    cmdptr = command;
#line 1492
    cmdlen = length;
#line 1493
    start = (size_t )0;
#line 1494
    rc = wordsplit_init(wsp, cmdptr, cmdlen, flags);
    }
#line 1495
    if (rc) {
#line 1496
      return (rc);
    }
  }
#line 1499
  if (wsp->ws_flags & 2097152) {
    {
#line 1500
    (wsp->ws_debug)((char const   *)((char *)"Input:%.*s;"), (int )cmdlen, cmdptr);
    }
  }
  {
#line 1502
  rc = wordsplit_process_list(wsp, start);
  }
#line 1503
  if (rc == 0) {
#line 1503
    if (flags & 536870912) {
      {
      {
#line 1505
      while (1) {
        while_continue: /* CIL Label */ ;

#line 1505
        if (! (! wsp->ws_head && wsp->ws_endp < wsp->ws_len)) {
#line 1505
          goto while_break;
        }
        {
#line 1507
        start = skip_delim(wsp);
        }
#line 1508
        if (wsp->ws_flags & 2097152) {
          {
#line 1510
          cmdptr = wsp->ws_input + wsp->ws_endp;
#line 1511
          cmdlen = wsp->ws_len - wsp->ws_endp;
#line 1512
          (wsp->ws_debug)((char const   *)((char *)"Restart:%.*s;"), (int )cmdlen,
                          cmdptr);
          }
        }
        {
#line 1514
        rc = wordsplit_process_list(wsp, start);
        }
#line 1515
        if (rc) {
#line 1516
          goto while_break;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1519
  if (rc) {
    {
#line 1521
    wordsplit_free_nodes(wsp);
    }
#line 1522
    return (rc);
  }
  {
#line 1524
  wordsplit_finish(wsp);
#line 1525
  wordsplit_free_nodes(wsp);
  }
#line 1526
  return (wsp->ws_errno);
}
}
#line 1530 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
int wordsplit(char const   *command , struct wordsplit *ws , int flags ) 
{ 
  size_t __cil_tmp4 ;
  size_t tmp ;
  int __cil_tmp6 ;

  {
#line 1532
  if (command) {
    {
#line 1532
    __cil_tmp4 = strlen(command);
#line 1532
    tmp = __cil_tmp4;
    }
  } else {
#line 1532
    tmp = (unsigned long )0;
  }
  {
#line 1532
  __cil_tmp6 = wordsplit_len(command, tmp, ws, flags);
  }
#line 1532
  return (__cil_tmp6);
}
}
#line 1537 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
void wordsplit_free_words(struct wordsplit *ws ) 
{ 
  size_t i ;
  char *p ;

  {
#line 1541
  i = (size_t )0;
  {
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1541
    if (! (i < ws->ws_wordc)) {
#line 1541
      goto while_break;
    }
#line 1543
    p = *(ws->ws_wordv + (ws->ws_offs + i));
#line 1544
    if (p) {
      {
#line 1546
      free((void *)p);
#line 1547
      *(ws->ws_wordv + (ws->ws_offs + i)) = (char *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1541
  i ++;
#line 1550
  ws->ws_wordc = (size_t )0;
}
}
#line 1554 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
void wordsplit_free(struct wordsplit *ws ) 
{ 


  {
  {
#line 1556
  wordsplit_free_words(ws);
#line 1557
  free((void *)ws->ws_wordv);
#line 1558
  ws->ws_wordv = (char **)((void *)0);
  }
}
}
#line 1562 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
void wordsplit_perror(struct wordsplit *wsp ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1566
  if (wsp->ws_errno == 0) {
#line 1566
    goto case_0;
  }
#line 1570
  if (wsp->ws_errno == 1) {
#line 1570
    goto case_1;
  }
#line 1576
  if (wsp->ws_errno == 2) {
#line 1576
    goto case_2;
  }
#line 1580
  if (wsp->ws_errno == 3) {
#line 1580
    goto case_3;
  }
#line 1584
  if (wsp->ws_errno == 4) {
#line 1584
    goto case_4;
  }
#line 1588
  if (wsp->ws_errno == 5) {
#line 1588
    goto case_5;
  }
#line 1592
  if (wsp->ws_errno == 6) {
#line 1592
    goto case_6;
  }
#line 1596
  if (wsp->ws_errno == 7) {
#line 1596
    goto case_7;
  }
#line 1600
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1567
  __cil_tmp2 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"no error"),
                         5);
#line 1567
  (wsp->ws_error)((char const   *)__cil_tmp2);
  }
#line 1568
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1571
  __cil_tmp3 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"missing closing %c (start near #%lu)"),
                         5);
#line 1571
  (wsp->ws_error)((char const   *)__cil_tmp3, (int )((char )*(wsp->ws_input + wsp->ws_endp)),
                  wsp->ws_endp);
  }
#line 1574
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1577
  __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"memory exhausted"),
                         5);
#line 1577
  (wsp->ws_error)((char const   *)__cil_tmp4);
  }
#line 1578
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1581
  __cil_tmp5 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"command substitution is not yet supported"),
                         5);
#line 1581
  (wsp->ws_error)((char const   *)__cil_tmp5);
  }
#line 1582
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 1585
  __cil_tmp6 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"invalid wordsplit usage"),
                         5);
#line 1585
  (wsp->ws_error)((char const   *)__cil_tmp6);
  }
#line 1586
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1589
  __cil_tmp7 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unbalanced curly brace"),
                         5);
#line 1589
  (wsp->ws_error)((char const   *)__cil_tmp7);
  }
#line 1590
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1593
  __cil_tmp8 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"undefined variable"),
                         5);
#line 1593
  (wsp->ws_error)((char const   *)__cil_tmp8);
  }
#line 1594
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1597
  __cil_tmp9 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"input exhausted"),
                         5);
#line 1597
  (wsp->ws_error)((char const   *)__cil_tmp9);
  }
#line 1598
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1601
  __cil_tmp10 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unknown error"),
                          5);
#line 1601
  (wsp->ws_error)((char const   *)__cil_tmp10);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1605 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
char const   *_wordsplit_errstr[]  = 
#line 1605
  {      (char const   *)((char *)"no error"),      (char const   *)((char *)"missing closing quote"),      (char const   *)((char *)"memory exhausted"),      (char const   *)((char *)"command substitution is not yet supported"), 
        (char const   *)((char *)"invalid wordsplit usage"),      (char const   *)((char *)"unbalanced curly brace"),      (char const   *)((char *)"undefined variable"),      (char const   *)((char *)"input exhausted")};
#line 1615 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
int _wordsplit_nerrs  =    (int )(sizeof(_wordsplit_errstr) / sizeof(_wordsplit_errstr[0]));
#line 1619 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/wordsplit.c"
char const   *wordsplit_strerror(struct wordsplit *ws ) 
{ 


  {
#line 1621
  if (ws->ws_errno < _wordsplit_nerrs) {
#line 1622
    return (_wordsplit_errstr[ws->ws_errno]);
  }
#line 1623
  return ((char const   *)((char *)"unknown error"));
}
}
#line 162 "./cflow.h"
int reverse_tree ;
#line 183
Symbol *lookup(char const   *name ) ;
#line 184
Symbol *install(char *name , int flags ) ;
#line 185
Symbol *install_ident(char *name , enum storage storage ) ;
#line 186
void ident_change_storage(Symbol *sp , enum storage storage ) ;
#line 187
void delete_autos(int level___0 ) ;
#line 188
void delete_statics(void) ;
#line 189
void delete_parms(int level___0 ) ;
#line 190
void move_parms(int level___0 ) ;
#line 191
size_t collect_symbols(Symbol ***return_sym , int (*sel)(Symbol *p ) , size_t reserved_slots ) ;
#line 192
size_t collect_functions(Symbol ***return_sym ) ;
#line 194
void linked_list_destroy(struct linked_list **plist ) ;
#line 195
void linked_list_append(struct linked_list **plist , void *data ) ;
#line 197
void linked_list_iterate(struct linked_list **plist , int (*itr)(void * , void * ) ,
                         void *data ) ;
#line 199
void linked_list_unlink(struct linked_list *list , struct linked_list_entry *ent ) ;
#line 202
int data_in_list(void *data , struct linked_list *list ) ;
#line 218
int symbol_is_function(Symbol *symp ) ;
#line 43 "./parser.h"
char *filename ;
#line 44
char *canonical_filename ;
#line 21 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static Hash_table *symbol_table ;
#line 23
static struct linked_list *static_symbol_list ;
#line 24
static struct linked_list *auto_symbol_list ;
#line 25
static struct linked_list *static_func_list ;
#line 28 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static void append_symbol(struct linked_list **plist , Symbol *sp ) 
{ 
  int __cil_tmp3 ;

  {
#line 30
  if (sp->entry) {
    {
#line 31
    linked_list_unlink((sp->entry)->list, sp->entry);
#line 32
    sp->entry = (struct linked_list_entry *)((void *)0);
    }
  }
  {
#line 34
  __cil_tmp3 = data_in_list((void *)sp, *plist);
  }
#line 34
  if (! __cil_tmp3) {
    {
#line 35
    linked_list_append(plist, (void *)sp);
#line 36
    sp->entry = (*plist)->tail;
    }
  }
}
}
#line 46 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static size_t hash_symbol_hasher(void const   *data , size_t n_buckets ) 
{ 
  struct table_entry *t ;
  size_t __cil_tmp4 ;

  {
#line 48
  t = (struct table_entry *)data;
#line 49
  if (! t->sym) {
#line 50
    return ((size_t )data % n_buckets);
  }
  {
#line 51
  __cil_tmp4 = hash_string((char const   *)(t->sym)->name, n_buckets);
  }
#line 51
  return (__cil_tmp4);
}
}
#line 56 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static int hash_symbol_compare(void const   *data1 , void const   *data2 ) 
{ 
  struct table_entry *t1 ;
  struct table_entry *t2 ;
  int __cil_tmp5 ;

  {
  {
#line 58
  t1 = (struct table_entry *)data1;
#line 59
  t2 = (struct table_entry *)data2;
#line 60
  __cil_tmp5 = strcmp((char const   *)(t1->sym)->name, (char const   *)(t2->sym)->name);
  }
#line 60
  return ((t1->sym && t2->sym) && __cil_tmp5 == 0);
}
}
#line 64 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
Symbol *lookup(char const   *name ) 
{ 
  Symbol s ;
  Symbol *sym ;
  struct table_entry t ;
  struct table_entry *tp ;
  void *__cil_tmp6 ;

  {
#line 69
  if (! symbol_table) {
#line 70
    return ((Symbol *)((void *)0));
  }
  {
#line 71
  s.name = (char *)name;
#line 72
  t.sym = & s;
#line 73
  __cil_tmp6 = hash_lookup(symbol_table, (void const   *)(& t));
#line 73
  tp = (struct table_entry *)__cil_tmp6;
  }
#line 74
  if (tp) {
#line 75
    sym = tp->sym;
    {
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;

#line 76
      if (! ((unsigned int )sym->type == 1U && (unsigned int )sym->flag == 3U)) {
#line 76
        goto while_break;
      }
#line 77
      sym = sym->alias;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 79
    sym = (Symbol *)((void *)0);
  }
#line 80
  return (sym);
}
}
#line 86 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
Symbol *install(char *name , int flags ) 
{ 
  Symbol *sym ;
  struct table_entry *tp ;
  struct table_entry *ret ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  int __cil_tmp8 ;
  void *__cil_tmp10 ;

  {
  {
#line 91
  __cil_tmp6 = xmalloc(sizeof(*sym));
#line 91
  sym = (Symbol *)__cil_tmp6;
#line 92
  memset((void *)sym, 0, sizeof(*sym));
#line 93
  sym->type = (enum symtype )0;
#line 94
  sym->name = name;
#line 96
  __cil_tmp7 = xmalloc(sizeof(*tp));
#line 96
  tp = (struct table_entry *)__cil_tmp7;
#line 97
  tp->sym = sym;
#line 99
  __cil_tmp8 = strcmp((char const   *)filename, (char const   *)canonical_filename);
  }
#line 99
  if (flags & 2) {
#line 99
    if (canonical_filename) {
#line 99
      if (__cil_tmp8) {
        {
#line 102
        sym->flag = (enum symbol_flag )1;
        {
#line 103
        append_symbol(& static_symbol_list, sym);
        }
        }
      } else {
#line 99
        goto _L;
      }
    } else {
#line 99
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 99
  if (flags & 4) {
    {
#line 102
    sym->flag = (enum symbol_flag )1;
    {
#line 103
    append_symbol(& static_symbol_list, sym);
    }
    }
  } else {
#line 105
    sym->flag = (enum symbol_flag )0;
  }
  {
#line 107
  __cil_tmp10 = hash_insert(symbol_table, (void const   *)tp);
#line 107
  ret = (struct table_entry *)__cil_tmp10;
  }
  {
#line 107
  symbol_table = hash_initialize((size_t )0, (Hash_tuning *)0, hash_symbol_hasher,
                                 hash_symbol_compare, (Hash_data_freer )0);
  }
#line 107
  if (! ((symbol_table || symbol_table) && ret)) {
    {
#line 112
    xalloc_die();
    }
  }
#line 114
  if (ret != tp) {
#line 115
    if (flags & 1) {
      {
#line 116
      free((void *)sym);
#line 117
      free((void *)tp);
      }
#line 118
      return (ret->sym);
    }
#line 120
    if ((unsigned int )(ret->sym)->type != 0U) {
#line 121
      sym->next = ret->sym;
    }
    {
#line 122
    ret->sym = sym;
#line 123
    free((void *)tp);
    }
  }
#line 125
  sym->owner = ret;
#line 126
  return (sym);
}
}
#line 130 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
void ident_change_storage(Symbol *sp , enum storage storage ) 
{ 


  {
#line 132
  if ((unsigned int )sp->storage == (unsigned int )storage) {
#line 133
    return;
  }
#line 134
  if ((unsigned int )sp->storage == 2U) {

  }
  {
#line 138
  if ((unsigned int )storage == (unsigned int )2) {
#line 138
    goto case_2;
  }
#line 141
  if ((unsigned int )storage == (unsigned int )3) {
#line 141
    goto case_3;
  }
#line 144
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 139
  append_symbol(& static_symbol_list, sp);
  }
#line 140
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 142
  append_symbol(& auto_symbol_list, sp);
  }
#line 143
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 145
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 147
  sp->storage = storage;
}
}
#line 151 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
Symbol *install_ident(char *name , enum storage storage ) 
{ 
  Symbol *sp ;
  int tmp ;
  Symbol *__cil_tmp5 ;

  {
#line 155
  if ((unsigned int )storage != 3U) {
#line 155
    tmp = 2;
  } else {
#line 155
    tmp = 0;
  }
  {
#line 155
  __cil_tmp5 = install(name, tmp);
#line 155
  sp = __cil_tmp5;
#line 158
  sp->type = (enum symtype )2;
#line 159
  sp->arity = - 1;
#line 160
  sp->storage = (enum storage )0;
#line 161
  sp->decl = (char *)((void *)0);
#line 162
  sp->source = (char *)((void *)0);
#line 163
  sp->def_line = - 1;
#line 164
  sp->ref_line = (struct linked_list *)((void *)0);
#line 165
  sp->callee = (struct linked_list *)((void *)0);
#line 165
  sp->caller = sp->callee;
#line 166
  sp->level = - 1;
#line 167
  ident_change_storage(sp, storage);
  }
#line 168
  return (sp);
}
}
#line 173 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static void unlink_symbol(Symbol *sym ) 
{ 
  Symbol *s ;
  Symbol *prev ;
  struct table_entry *tp ;
  Symbol *next ;

  {
#line 175
  prev = (Symbol *)((void *)0);
#line 176
  tp = sym->owner;
#line 177
  s = tp->sym;
  {
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;

#line 177
    if (! s) {
#line 177
      goto while_break;
    }
#line 178
    next = s->next;
#line 179
    if (s == sym) {
#line 180
      if (prev) {
#line 181
        prev->next = next;
      } else {
#line 183
        tp->sym = next;
      }
#line 184
      goto while_break;
    } else {
#line 186
      prev = s;
    }
#line 187
    s = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  sym->owner = (struct table_entry *)((void *)0);
}
}
#line 195 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static void delete_symbol(Symbol *sym ) 
{ 


  {
  {
#line 197
  unlink_symbol(sym);
  }
#line 200
  if (sym->ref_line == (struct linked_list *)((void *)0)) {
#line 200
    if (! (reverse_tree && sym->callee)) {
      {
#line 201
      linked_list_destroy(& sym->ref_line);
#line 202
      linked_list_destroy(& sym->caller);
#line 203
      linked_list_destroy(& sym->callee);
#line 204
      free((void *)sym);
      }
    }
  }
}
}
#line 218 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static void static_free(void *data ) 
{ 
  Symbol *sym ;
  struct table_entry *t ;
  int __cil_tmp4 ;

  {
#line 220
  sym = (Symbol *)data;
#line 221
  t = sym->owner;
#line 223
  if (! t) {
#line 224
    return;
  }
#line 225
  if ((unsigned int )sym->flag == 1U) {
    {
#line 226
    delete_symbol(sym);
    }
  } else {
    {
#line 228
    unlink_symbol(sym);
#line 229
    __cil_tmp4 = symbol_is_function(sym);
    }
#line 229
    if (__cil_tmp4) {
      {
#line 230
      linked_list_append(& static_func_list, (void *)sym);
      }
    }
  }
}
}
#line 235 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
void delete_statics(void) 
{ 


  {
#line 237
  if (static_symbol_list) {
    {
#line 238
    static_symbol_list->free_data = static_free;
#line 239
    linked_list_destroy(& static_symbol_list);
    }
  }
}
}
#line 248 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
int delete_level_autos(void *data , void *call_data ) 
{ 
  int level___0 ;
  Symbol *s ;

  {
#line 250
  level___0 = *((int *)call_data);
#line 251
  s = (Symbol *)data;
#line 252
  if (s->level == level___0) {
    {
#line 253
    delete_symbol(s);
    }
#line 254
    return (1);
  }
#line 256
  return (0);
}
}
#line 260 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
int delete_level_statics(void *data , void *call_data ) 
{ 
  int level___0 ;
  Symbol *s ;

  {
#line 262
  level___0 = *((int *)call_data);
#line 263
  s = (Symbol *)data;
#line 264
  if (s->level == level___0) {
    {
#line 265
    unlink_symbol(s);
    }
#line 266
    return (1);
  }
#line 268
  return (0);
}
}
#line 272 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
void delete_autos(int level___0 ) 
{ 


  {
  {
#line 274
  linked_list_iterate(& auto_symbol_list, delete_level_autos, (void *)(& level___0));
#line 275
  linked_list_iterate(& static_symbol_list, delete_level_statics, (void *)(& level___0));
  }
}
}
#line 285 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
static int collect_processor(void *data , void *proc_data ) 
{ 
  struct table_entry *t ;
  struct collect_data *cd ;
  Symbol *s ;
  int __cil_tmp6 ;

  {
#line 287
  t = (struct table_entry *)data;
#line 288
  cd = (struct collect_data *)proc_data;
#line 290
  s = t->sym;
  {
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;

#line 290
    if (! s) {
#line 290
      goto while_break;
    }
    {
#line 291
    __cil_tmp6 = (cd->sel)(s);
    }
#line 291
    if (__cil_tmp6) {
#line 292
      if (cd->sym) {
#line 293
        *(cd->sym + cd->index) = s;
      }
#line 294
      (cd->index) ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  s = s->next;
#line 297
  return (1);
}
}
#line 301 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
size_t collect_symbols(Symbol ***return_sym , int (*sel)(Symbol *p ) , size_t reserved_slots ) 
{ 
  struct collect_data cdata ;
  void *__cil_tmp5 ;

  {
  {
#line 306
  cdata.sym = (Symbol **)((void *)0);
#line 307
  cdata.index = (size_t )0;
#line 308
  cdata.sel = sel;
#line 309
  hash_do_for_each(symbol_table, collect_processor, (void *)(& cdata));
#line 310
  __cil_tmp5 = calloc(cdata.index + reserved_slots, sizeof(*(cdata.sym)));
#line 310
  cdata.sym = (Symbol **)__cil_tmp5;
  }
#line 311
  if (! cdata.sym) {
    {
#line 312
    xalloc_die();
    }
  }
  {
#line 313
  cdata.index = (size_t )0;
#line 314
  hash_do_for_each(symbol_table, collect_processor, (void *)(& cdata));
#line 315
  *return_sym = cdata.sym;
  }
#line 316
  return (cdata.index);
}
}
#line 320 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
size_t collect_functions(Symbol ***return_sym ) 
{ 
  Symbol **symbols ;
  size_t num ;
  size_t snum ;
  struct linked_list_entry *p___92 ;
  struct linked_list_entry *tmp ;
  struct linked_list_entry *tmp___0 ;
  size_t __cil_tmp10 ;

  {
#line 327
  snum = (size_t )0;
#line 328
  if (static_func_list) {
#line 329
    if (static_func_list) {
#line 329
      tmp = static_func_list->head;
    } else {
#line 329
      tmp = (struct linked_list_entry *)((void *)0);
    }
#line 329
    p___92 = tmp;
    {
    {
#line 329
    while (1) {
      while_continue: /* CIL Label */ ;

#line 329
      if (! p___92) {
#line 329
        goto while_break;
      }
#line 330
      snum ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 329
    p___92 = p___92->next;
  }
  {
#line 333
  num = collect_symbols(& symbols, symbol_is_function, snum);
  }
#line 336
  if (snum) {
#line 337
    if (static_func_list) {
#line 337
      tmp___0 = static_func_list->head;
    } else {
#line 337
      tmp___0 = (struct linked_list_entry *)((void *)0);
    }
#line 337
    p___92 = tmp___0;
    {
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 337
      if (! p___92) {
#line 337
        goto while_break___0;
      }
#line 338
      __cil_tmp10 = num;
#line 338
      num ++;
#line 338
      *(symbols + __cil_tmp10) = (Symbol *)p___92->data;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 337
    p___92 = p___92->next;
  }
#line 339
  *return_sym = symbols;
#line 340
  return (num);
}
}
#line 348 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
int delete_parms_itr(void *data , void *call_data ) 
{ 
  int level___0 ;
  Symbol *s ;
  struct table_entry *t ;

  {
#line 350
  level___0 = *((int *)call_data);
#line 351
  s = (Symbol *)data;
#line 352
  t = s->owner;
#line 354
  if (! t) {
#line 355
    return (1);
  }
#line 356
  if ((unsigned int )s->type == 2U) {
#line 356
    if ((unsigned int )s->storage == 3U) {
#line 356
      if ((unsigned int )s->flag == 2U) {
#line 356
        if (s->level > level___0) {
          {
#line 358
          delete_symbol(s);
          }
#line 359
          return (1);
        }
      }
    }
  }
#line 361
  return (0);
}
}
#line 366 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
void delete_parms(int level___0 ) 
{ 


  {
  {
#line 368
  linked_list_iterate(& auto_symbol_list, delete_parms_itr, (void *)(& level___0));
  }
}
}
#line 374 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/symbol.c"
void move_parms(int level___0 ) 
{ 
  struct linked_list_entry *p___93 ;
  struct linked_list_entry *tmp ;
  Symbol *s ;

  {
#line 378
  if (auto_symbol_list) {
#line 378
    tmp = auto_symbol_list->head;
  } else {
#line 378
    tmp = (struct linked_list_entry *)((void *)0);
  }
#line 378
  p___93 = tmp;
  {
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;

#line 378
    if (! p___93) {
#line 378
      goto while_break;
    }
#line 379
    s = (Symbol *)p___93->data;
#line 381
    if ((unsigned int )s->type == 2U) {
#line 381
      if ((unsigned int )s->storage == 3U) {
#line 381
        if ((unsigned int )s->flag == 2U) {
#line 383
          s->level = level___0;
#line 384
          s->flag = (enum symbol_flag )0;
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  p___93 = p___93->next;
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   *__filename , char const   *__modes ) ;
#line 335 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char *__s , char const   *__delim ) ;
#line 220 "./cflow.h"
void sourcerc(int *argc_ptr , char ***argv_ptr ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 210
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 224
__inline extern  __attribute__((__nothrow__)) int stat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 226
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 234
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 249
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__filename ,
                                                            struct stat64 *__statbuf ,
                                                            int __flag )  __attribute__((__gnu_inline__)) ;
#line 259
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 272
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 332
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 339
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 395
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 397
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf ) ;
#line 399
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf ) ;
#line 401
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag ) ;
#line 428
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf ) ;
#line 430
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf ) ;
#line 432
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf ) ;
#line 434
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag ) ;
#line 438
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev ) ;
#line 441
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev ) ;
#line 449
__inline extern  __attribute__((__nothrow__)) int stat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 449 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 451
  __cil_tmp3 = __xstat(1, __path, __statbuf);
  }
#line 451
  return (__cil_tmp3);
}
}
#line 456
__inline extern  __attribute__((__nothrow__)) int lstat(char const   *__path , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 456 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat(char const   *__path , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 458
  __cil_tmp3 = __lxstat(1, __path, __statbuf);
  }
#line 458
  return (__cil_tmp3);
}
}
#line 463
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 463 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 465
  __cil_tmp3 = __fxstat(1, __fd, __statbuf);
  }
#line 465
  return (__cil_tmp3);
}
}
#line 470
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   *__filename ,
                                                          struct stat *__statbuf ,
                                                          int __flag )  __attribute__((__gnu_inline__)) ;
#line 470 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat(int __fd , char const   *__filename , struct stat *__statbuf ,
                            int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 473
  __cil_tmp5 = __fxstatat(1, __fd, __filename, __statbuf, __flag);
  }
#line 473
  return (__cil_tmp5);
}
}
#line 479
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 479 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp4 ;

  {
  {
#line 481
  __cil_tmp4 = __xmknod(0, __path, __mode, & __dev);
  }
#line 481
  return (__cil_tmp4);
}
}
#line 487
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__gnu_inline__)) ;
#line 487 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 490
  __cil_tmp5 = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 490
  return (__cil_tmp5);
}
}
#line 498
__inline extern  __attribute__((__nothrow__)) int stat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 498 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int stat64(char const   *__path , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 500
  __cil_tmp3 = __xstat64(1, __path, __statbuf);
  }
#line 500
  return (__cil_tmp3);
}
}
#line 505
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   *__path , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 505 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int lstat64(char const   *__path , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 507
  __cil_tmp3 = __lxstat64(1, __path, __statbuf);
  }
#line 507
  return (__cil_tmp3);
}
}
#line 512
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__gnu_inline__)) ;
#line 512 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 514
  __cil_tmp3 = __fxstat64(1, __fd, __statbuf);
  }
#line 514
  return (__cil_tmp3);
}
}
#line 519
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   *__filename ,
                                                            struct stat64 *__statbuf ,
                                                            int __flag )  __attribute__((__gnu_inline__)) ;
#line 519 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int fstatat64(int __fd , char const   *__filename , struct stat64 *__statbuf ,
                              int __flag ) 
{ 
  int __cil_tmp5 ;

  {
  {
#line 522
  __cil_tmp5 = __fxstatat64(1, __fd, __filename, __statbuf, __flag);
  }
#line 522
  return (__cil_tmp5);
}
}
#line 28 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/rc.c"
static void expand_argcv(int *argc_ptr , char ***argv_ptr , int argc , char **argv ) 
{ 
  int i ;
  void *__cil_tmp6 ;

  {
  {
#line 32
  __cil_tmp6 = xrealloc((void *)*argv_ptr, (unsigned long )((*argc_ptr + argc) + 1) * sizeof(*(*argv_ptr)));
#line 32
  *argv_ptr = (char **)__cil_tmp6;
#line 34
  i = 0;
  }
  {
  {
#line 34
  while (1) {
    while_continue: /* CIL Label */ ;

#line 34
    if (! (i < argc)) {
#line 34
      goto while_break;
    }
    {
#line 35
    *(*argv_ptr + (*argc_ptr + i)) = xstrdup((char const   *)*(argv + i));
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  i ++;
#line 36
  *(*argv_ptr + (*argc_ptr + i)) = (char *)((void *)0);
#line 37
  *argc_ptr += argc;
}
}
#line 43 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/rc.c"
void parse_rc(int *argc_ptr , char ***argv_ptr , char *name ) 
{ 
  struct stat st ;
  FILE *rcfile ;
  int size ;
  char *buf ;
  char *p ;
  struct wordsplit ws ;
  int wsflags ;
  int line ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  int *__cil_tmp15 ;
  char *__cil_tmp16 ;
  size_t __cil_tmp17 ;
  int __cil_tmp19 ;
  char const   *__cil_tmp20 ;

  {
  {
#line 53
  __cil_tmp12 = stat((char const   *)name, & st);
  }
#line 53
  if (__cil_tmp12) {
#line 54
    return;
  }
  {
#line 55
  __cil_tmp13 = xmalloc((size_t )(st.st_size + 1L));
#line 55
  buf = (char *)__cil_tmp13;
#line 56
  rcfile = fopen((char const   *)name, (char const   *)((char *)"r"));
  }
#line 57
  if (! rcfile) {
    {
#line 58
    __cil_tmp15 = __errno_location();
    }
    {
#line 58
    __cil_tmp16 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"cannot open `%s\'"),
                            5);
#line 58
    error(1, *__cil_tmp15, (char const   *)__cil_tmp16, name);
    }
#line 59
    return;
  }
  {
#line 61
  __cil_tmp17 = fread((void *)buf, (unsigned long )1, (unsigned long )st.st_size,
                      rcfile);
#line 61
  size = (int )__cil_tmp17;
#line 62
  *(buf + size) = (char )0;
#line 63
  fclose(rcfile);
#line 65
  ws.ws_comment = (char const   *)((char *)"#");
#line 66
  wsflags = 33590852;
#line 67
  line = 0;
#line 68
  p = strtok(buf, (char const   *)((char *)"\n"));
  }
  {
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;

#line 68
    if (! p) {
#line 68
      goto while_break;
    }
    {
#line 69
    line ++;
#line 70
    __cil_tmp19 = wordsplit((char const   *)p, & ws, wsflags);
    }
#line 70
    if (__cil_tmp19) {
      {
#line 71
      __cil_tmp20 = wordsplit_strerror(& ws);
#line 71
      error(1, 0, (char const   *)((char *)"%s:%d: %s"), name, line, __cil_tmp20);
      }
    }
#line 73
    wsflags |= 8;
#line 74
    if (ws.ws_wordc) {
      {
#line 75
      expand_argcv(argc_ptr, argv_ptr, (int )ws.ws_wordc, ws.ws_wordv);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  p = strtok((char *)((void *)0), (char const   *)((char *)"\n"));
  }
#line 77
  if (wsflags & 8) {
    {
#line 78
    wordsplit_free(& ws);
    }
  }
  {
#line 79
  free((void *)buf);
  }
}
}
#line 91 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/rc.c"
void sourcerc(int *argc_ptr , char ***argv_ptr ) 
{ 
  char *env ;
  int xargc ;
  char **xargv ;
  void *__cil_tmp6 ;
  struct wordsplit ws ;
  int __cil_tmp9 ;
  char const   *__cil_tmp10 ;
  char *home ;
  char *__cil_tmp13 ;
  int len ;
  size_t __cil_tmp15 ;
  char *buf ;
  void *__cil_tmp17 ;
  int __cil_tmp18 ;

  {
  {
#line 94
  xargc = 1;
#line 97
  __cil_tmp6 = xmalloc(2UL * sizeof(*xargv));
#line 97
  xargv = (char **)__cil_tmp6;
#line 98
  *(xargv + 0) = *(*argv_ptr);
#line 99
  *(xargv + 1) = (char *)((void *)0);
#line 101
  env = getenv((char const   *)((char *)"CFLOW_OPTIONS"));
  }
#line 102
  if (env) {
    {
#line 105
    ws.ws_comment = (char const   *)((char *)"#");
#line 106
    __cil_tmp9 = wordsplit((char const   *)env, & ws, 33590852);
    }
#line 106
    if (__cil_tmp9) {
      {
#line 107
      __cil_tmp10 = wordsplit_strerror(& ws);
#line 107
      error(1, 0, (char const   *)((char *)"failed to parse CFLOW_OPTIONS: %s"), __cil_tmp10);
      }
    }
#line 109
    if (ws.ws_wordc) {
      {
#line 110
      expand_argcv(& xargc, & xargv, (int )ws.ws_wordc, ws.ws_wordv);
      }
    }
    {
#line 111
    wordsplit_free(& ws);
    }
  }
  {
#line 114
  env = getenv((char const   *)((char *)"CFLOWRC"));
  }
#line 115
  if (env) {
    {
#line 116
    parse_rc(& xargc, & xargv, env);
    }
  } else {
    {
#line 118
    __cil_tmp13 = getenv((char const   *)((char *)"HOME"));
#line 118
    home = __cil_tmp13;
    }
#line 119
    if (home) {
      {
#line 120
      __cil_tmp15 = strlen((char const   *)home);
#line 120
      len = (int )__cil_tmp15;
#line 121
      __cil_tmp17 = malloc(((unsigned long )len + sizeof(".cflowrc")) + (unsigned long )((int )*(home + (len - 1)) != 47));
#line 121
      buf = (char *)__cil_tmp17;
      }
#line 123
      if (! buf) {
#line 124
        return;
      }
      {
#line 125
      strcpy(buf, (char const   *)home);
      }
#line 126
      if ((int )*(home + (len - 1)) != 47) {
#line 127
        __cil_tmp18 = len;
#line 127
        len ++;
#line 127
        *(buf + __cil_tmp18) = (char )'/';
      }
      {
#line 128
      strcpy(buf + len, (char const   *)((char *)".cflowrc"));
#line 129
      parse_rc(& xargc, & xargv, buf);
#line 130
      free((void *)buf);
      }
    }
  }
#line 134
  if (xargc > 1) {
    {
#line 135
    expand_argcv(& xargc, & xargv, *argc_ptr - 1, *argv_ptr + 1);
#line 136
    *argc_ptr = xargc;
#line 137
    *argv_ptr = xargv;
    }
  }
}
}
#line 159 "./cflow.h"
int print_line_numbers ;
#line 161
int brief_listing ;
#line 166
int emacs_option ;
#line 170
int omit_symbol_names_option ;
#line 215
void print_level(int lev , int last ) ;
#line 250
int posix_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line ,
                         void *data , void *handler_data ) ;
#line 21 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/posix.c"
static void print_symbol_type(FILE *outfile___0 , Symbol *sym ) 
{ 


  {
#line 23
  if (sym->decl) {
    {
#line 24
    fprintf(outfile___0, (char const   *)((char *)"%s, <%s %d>"), sym->decl, sym->source,
            sym->def_line);
    }
  } else {
    {
#line 29
    fprintf(outfile___0, (char const   *)((char *)"<>"));
    }
  }
}
}
#line 33 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/posix.c"
static int print_symbol(FILE *outfile___0 , int line , struct output_symbol *s ) 
{ 


  {
  {
#line 35
  print_level(s->level, s->last);
#line 36
  fprintf(outfile___0, (char const   *)((char *)"%s: "), (s->sym)->name);
  }
#line 38
  if (brief_listing) {
#line 39
    if ((s->sym)->expand_line) {
      {
#line 40
      fprintf(outfile___0, (char const   *)((char *)"%d"), (s->sym)->expand_line);
      }
#line 41
      return (1);
    } else
#line 42
    if ((s->sym)->callee) {
#line 43
      (s->sym)->expand_line = line;
    }
  }
  {
#line 45
  print_symbol_type(outfile___0, s->sym);
  }
#line 46
  return (0);
}
}
#line 50 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/posix.c"
int posix_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line ,
                         void *data , void *handler_data ) 
{ 
  char *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 55
  if ((unsigned int )cmd == (unsigned int )0) {
#line 55
    goto case_0;
  }
#line 64
  if ((unsigned int )cmd == (unsigned int )4) {
#line 64
    goto case_4;
  }
#line 64
  if ((unsigned int )cmd == (unsigned int )2) {
#line 64
    goto case_4;
  }
#line 64
  if ((unsigned int )cmd == (unsigned int )1) {
#line 64
    goto case_4;
  }
#line 66
  if ((unsigned int )cmd == (unsigned int )3) {
#line 66
    goto case_3;
  }
#line 69
  if ((unsigned int )cmd == (unsigned int )6) {
#line 69
    goto case_6;
  }
#line 72
  if ((unsigned int )cmd == (unsigned int )5) {
#line 72
    goto case_5;
  }
#line 54
  goto switch_break;
  case_0: /* CIL Label */ 
#line 57
  if (emacs_option) {
    {
#line 58
    __cil_tmp6 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"--format=posix is not compatible with --emacs"),
                           5);
#line 58
    error(3, 0, (char const   *)__cil_tmp6);
    }
  }
#line 60
  omit_symbol_names_option = 1;
#line 60
  print_line_numbers = omit_symbol_names_option;
#line 60
  brief_listing = print_line_numbers;
#line 61
  goto switch_break;
  case_4: /* CIL Label */ 
#line 65
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 67
  fprintf(outfile___0, (char const   *)((char *)"\n"));
  }
#line 68
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 70
  fprintf(outfile___0, (char const   *)((char *)"%s"), (char *)data);
  }
#line 71
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 73
  __cil_tmp7 = print_symbol(outfile___0, line, (struct output_symbol *)data);
  }
#line 73
  return (__cil_tmp7);
  switch_break: /* CIL Label */ ;
  }
#line 75
  return (0);
}
}
#line 183 "../gnu/obstack.h"
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 47 "../gnu/error.h"
extern void error_at_line(int __status , int __errnum , char const   *__fname , unsigned int __lineno ,
                          char const   *__format  , ...) ;
#line 149 "./cflow.h"
int verbose ;
#line 151
int use_indentation ;
#line 154
int strict_ansi ;
#line 167
int debug ;
#line 169
int omit_arguments_option ;
#line 172
int token_stack_length ;
#line 173
int token_stack_increase ;
#line 193
struct linked_list *linked_list_create(linked_list_free_data_fp fun ) ;
#line 204
int get_token(void) ;
#line 210
void init_parse(void) ;
#line 211
int yyparse(void) ;
#line 216
int globals_only(void) ;
#line 42 "./parser.h"
YYSTYPE yylval ;
#line 45
int line_num ;
#line 29 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void parse_declaration(Ident *ident___0 , int parm ) ;
#line 30
void parse_variable_declaration(Ident *ident___0 , int parm ) ;
#line 31
void parse_function_declaration(Ident *ident___0 , int parm ) ;
#line 32
void parse_dcl(Ident *ident___0 , int maybe_knr ) ;
#line 33
void parse_knr_dcl(Ident *ident___0 ) ;
#line 34
void parse_typedef(void) ;
#line 35
void expression(void) ;
#line 36
void initializer_list(void) ;
#line 37
void func_body(void) ;
#line 38
void declare(Ident *ident___0 , int maybe_knr ) ;
#line 39
void declare_type(Ident *ident___0 ) ;
#line 40
int dcl(Ident *idptr ) ;
#line 41
int parmdcl(Ident *idptr ) ;
#line 42
int dirdcl(Ident *idptr ) ;
#line 43
void skip_struct(void) ;
#line 44
Symbol *get_symbol(char *name ) ;
#line 45
void maybe_parm_list(int *parm_cnt_return ) ;
#line 47
void call(char *name , int line ) ;
#line 48
void reference(char *name , int line ) ;
#line 50
int level ;
#line 51
Symbol *caller ;
#line 52
struct obstack text_stk ;
#line 54
int parm_level ;
#line 64
TOKSTK tok ;
#line 65
TOKSTK *token_stack ;
#line 66
int tos ;
#line 67
int curs ;
#line 68 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int token_stack_length  =    64;
#line 69 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int token_stack_increase  =    32;
#line 70
static int need_space ;
#line 72
void mark(Stackpos pos ) ;
#line 73
void restore(Stackpos pos ) ;
#line 74
void tokpush(int type , int line , char *token ) ;
#line 75
void save_token(TOKSTK *tokptr ) ;
#line 78 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
static void print_token(TOKSTK *tokptr ) 
{ 


  {
  {
#line 88
  if (tokptr->type == 266) {
#line 88
    goto case_266;
  }
#line 88
  if (tokptr->type == 273) {
#line 88
    goto case_266;
  }
#line 88
  if (tokptr->type == 272) {
#line 88
    goto case_266;
  }
#line 88
  if (tokptr->type == 264) {
#line 88
    goto case_266;
  }
#line 88
  if (tokptr->type == 265) {
#line 88
    goto case_266;
  }
#line 88
  if (tokptr->type == 257) {
#line 88
    goto case_266;
  }
#line 88
  if (tokptr->type == 270) {
#line 88
    goto case_266;
  }
#line 88
  if (tokptr->type == 260) {
#line 88
    goto case_266;
  }
#line 92
  if (tokptr->type == '{') {
#line 92
    goto case_123;
  }
#line 92
  if (tokptr->type == 258) {
#line 92
    goto case_123;
  }
#line 96
  if (tokptr->type == '}') {
#line 96
    goto case_125;
  }
#line 96
  if (tokptr->type == 259) {
#line 96
    goto case_125;
  }
#line 99
  if (tokptr->type == 261) {
#line 99
    goto case_261;
  }
#line 102
  if (tokptr->type == 262) {
#line 102
    goto case_262;
  }
#line 105
  if (tokptr->type == 263) {
#line 105
    goto case_263;
  }
#line 108
  if (tokptr->type == 271) {
#line 108
    goto case_271;
  }
#line 111
  goto switch_default;
  case_266: /* CIL Label */ 
  {
#line 89
  fprintf(stderr, (char const   *)((char *)"`%s\'"), tokptr->token);
  }
#line 90
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 93
  fprintf(stderr, (char const   *)((char *)"`{\'"));
  }
#line 94
  goto switch_break;
  case_125: /* CIL Label */ 
  {
#line 97
  fprintf(stderr, (char const   *)((char *)"`}\'"));
  }
#line 98
  goto switch_break;
  case_261: /* CIL Label */ 
  {
#line 100
  fprintf(stderr, (char const   *)((char *)"`extern\'"));
  }
#line 101
  goto switch_break;
  case_262: /* CIL Label */ 
  {
#line 103
  fprintf(stderr, (char const   *)((char *)"`static\'"));
  }
#line 104
  goto switch_break;
  case_263: /* CIL Label */ 
  {
#line 106
  fprintf(stderr, (char const   *)((char *)"`typedef\'"));
  }
#line 107
  goto switch_break;
  case_271: /* CIL Label */ 
  {
#line 109
  fprintf(stderr, (char const   *)((char *)"\"%s\""), tokptr->token);
  }
#line 110
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 112
  fprintf(stderr, (char const   *)((char *)"`%c\'"), tokptr->type);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 117 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
static char *token_type_str(int t ) 
{ 
  static char buf[80] ;
  unsigned short const   **__cil_tmp3 ;

  {
  {
#line 121
  if (t == 0) {
#line 121
    goto case_0;
  }
#line 123
  if (t == 257) {
#line 123
    goto case_257;
  }
#line 125
  if (t == 258) {
#line 125
    goto case_258;
  }
#line 127
  if (t == 259) {
#line 127
    goto case_259;
  }
#line 129
  if (t == 260) {
#line 129
    goto case_260;
  }
#line 131
  if (t == 261) {
#line 131
    goto case_261;
  }
#line 133
  if (t == 262) {
#line 133
    goto case_262;
  }
#line 135
  if (t == 263) {
#line 135
    goto case_263;
  }
#line 137
  if (t == 264) {
#line 137
    goto case_264;
  }
#line 139
  if (t == 265) {
#line 139
    goto case_265;
  }
#line 141
  if (t == 266) {
#line 141
    goto case_266;
  }
#line 143
  if (t == 267) {
#line 143
    goto case_267;
  }
#line 145
  if (t == 268) {
#line 145
    goto case_268;
  }
#line 147
  if (t == '{') {
#line 147
    goto case_123;
  }
#line 149
  if (t == '}') {
#line 149
    goto case_125;
  }
#line 151
  if (t == 269) {
#line 151
    goto case_269;
  }
#line 153
  if (t == 270) {
#line 153
    goto case_270;
  }
#line 155
  if (t == 271) {
#line 155
    goto case_271;
  }
#line 157
  if (t == 272) {
#line 157
    goto case_272;
  }
#line 159
  if (t == 273) {
#line 159
    goto case_273;
  }
#line 120
  goto switch_break;
  case_0: /* CIL Label */ 
#line 122
  return ((char *)"EOF");
  case_257: /* CIL Label */ 
#line 124
  return ((char *)"WORD");
  case_258: /* CIL Label */ 
#line 126
  return ((char *)"\'{\'");
  case_259: /* CIL Label */ 
#line 128
  return ((char *)"\'}\'");
  case_260: /* CIL Label */ 
#line 130
  return ((char *)"IDENTIFIER");
  case_261: /* CIL Label */ 
#line 132
  return ((char *)"EXTERN");
  case_262: /* CIL Label */ 
#line 134
  return ((char *)"STATIC");
  case_263: /* CIL Label */ 
#line 136
  return ((char *)"TYPEDEF");
  case_264: /* CIL Label */ 
#line 138
  return ((char *)"STRUCT");
  case_265: /* CIL Label */ 
#line 140
  return ((char *)"MODIFIER");
  case_266: /* CIL Label */ 
#line 142
  return ((char *)"OP");
  case_267: /* CIL Label */ 
#line 144
  return ((char *)"UNION");
  case_268: /* CIL Label */ 
#line 146
  return ((char *)"ENUM");
  case_123: /* CIL Label */ 
#line 148
  return ((char *)"\' {\'");
  case_125: /* CIL Label */ 
#line 150
  return ((char *)"\' }\'");
  case_269: /* CIL Label */ 
#line 152
  return ((char *)"MEMBER_OF");
  case_270: /* CIL Label */ 
#line 154
  return ((char *)"TYPE");
  case_271: /* CIL Label */ 
#line 156
  return ((char *)"STRING");
  case_272: /* CIL Label */ 
#line 158
  return ((char *)"PARM_WRAPPER");
  case_273: /* CIL Label */ 
#line 160
  return ((char *)"QUALIFIER");
  switch_break: /* CIL Label */ ;
  }
  {
#line 162
  __cil_tmp3 = __ctype_b_loc();
  }
#line 162
  if ((int )((unsigned short )*(*__cil_tmp3 + t)) & 16384) {
    {
#line 163
    snprintf((char *)buf, sizeof(buf), (char const   *)((char *)"\'%c\'(%d)"), t,
             t);
    }
  } else {
    {
#line 165
    snprintf((char *)buf, sizeof(buf), (char const   *)((char *)"%d"), t);
    }
  }
#line 166
  return ((char *)buf);
}
}
#line 170 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
static void dbgtok(TOKSTK *t , int delim ) 
{ 
  char *__cil_tmp3 ;
  char *tmp ;

  {
#line 172
  if (delim) {
    {
#line 173
    fputc(delim, stderr);
    }
  }
  {
#line 174
  __cil_tmp3 = token_type_str(t->type);
#line 174
  fprintf(stderr, (char const   *)((char *)"{ %s "), __cil_tmp3);
  }
#line 175
  if (t->type) {
#line 176
    if (t->token) {
#line 176
      tmp = t->token;
    } else {
#line 176
      tmp = (char *)"NULL";
    }
    {
#line 176
    fprintf(stderr, (char const   *)((char *)", %s, %d "), tmp, t->line);
    }
  }
  {
#line 177
  fputc('}', stderr);
  }
}
}
#line 181 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
static void debugtoken(TOKSTK *t , char *fmt  , ...) 
{ 
  va_list ap ;
  int i ;
  int tmp ;

  {
#line 183
  if (debug > 1) {
#line 187
    if (fmt) {
      {
#line 188
      __builtin_va_start((__builtin_va_list *)ap, fmt);
#line 189
      vfprintf(stderr, (char const   *)fmt, (__builtin_va_list *)ap);
#line 190
      __builtin_va_end((__builtin_va_list *)ap);
#line 191
      fprintf(stderr, (char const   *)((char *)": "));
      }
    }
#line 193
    if (t) {
      {
#line 194
      dbgtok(t, 0);
#line 195
      fprintf(stderr, (char const   *)((char *)"; "));
      }
    }
    {
#line 197
    fprintf(stderr, (char const   *)((char *)"%d: {"), curs);
#line 198
    i = curs;
    }
    {
    {
#line 198
    while (1) {
      while_continue: /* CIL Label */ ;

#line 198
      if (! (i < tos)) {
#line 198
        goto while_break;
      }
#line 199
      if (i == curs) {
#line 199
        tmp = 0;
      } else {
#line 199
        tmp = ',';
      }
      {
#line 199
      dbgtok(token_stack + i, tmp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 198
    i ++;
#line 200
    fprintf(stderr, (char const   *)((char *)"}\n"));
    }
  }
}
}
#line 205 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
static void file_error(char *msg , TOKSTK *tokptr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 207
  fprintf(stderr, (char const   *)((char *)"%s:%d: %s"), filename, tok.line, msg);
  }
#line 208
  if (tokptr) {
    {
#line 209
    __cil_tmp3 = dcgettext((char const   *)((void *)0), (char const   *)((char *)" near "),
                           5);
#line 209
    fprintf(stderr, (char const   *)__cil_tmp3);
#line 210
    print_token(tokptr);
    }
  }
  {
#line 212
  fprintf(stderr, (char const   *)((char *)"\n"));
  }
}
}
#line 216 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void mark(Stackpos pos ) 
{ 


  {
#line 218
  pos[0] = curs;
#line 219
  if (debug > 1) {
    {
#line 220
    fprintf(stderr, (char const   *)((char *)"marking stack at %d\n"), curs);
    }
  }
}
}
#line 224 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void restore(Stackpos pos ) 
{ 


  {
#line 226
  curs = pos[0];
#line 227
  if (curs) {
    {
#line 228
    tok = *(token_stack + (curs - 1));
#line 229
    debugtoken(& tok, (char *)"restored stack");
    }
  }
}
}
#line 234 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void tokdel(int beg , int end___0 ) 
{ 


  {
#line 236
  if (end___0 >= beg) {
#line 237
    if (end___0 < tos) {
      {
#line 238
      memmove((void *)(token_stack + beg), (void const   *)((token_stack + end___0) + 1),
              (unsigned long )((end___0 - beg) + 1) * sizeof(*(token_stack + 0)));
      }
    }
#line 240
    tos -= (end___0 - beg) + 1;
  }
}
}
#line 245 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void tokins(int pos , int type , int line , char *token ) 
{ 
  void *__cil_tmp5 ;

  {
#line 247
  tos ++;
#line 247
  if (tos == token_stack_length) {
    {
#line 248
    token_stack_length += token_stack_increase;
#line 249
    __cil_tmp5 = xrealloc((void *)token_stack, (unsigned long )token_stack_length * sizeof(*token_stack));
#line 249
    token_stack = (TOKSTK *)__cil_tmp5;
    }
  }
  {
#line 252
  memmove((void *)((token_stack + pos) + 1), (void const   *)(token_stack + pos),
          (unsigned long )((tos - pos) - 1) * sizeof(*(token_stack + 0)));
#line 254
  (token_stack + pos)->type = type;
#line 255
  (token_stack + pos)->token = token;
#line 256
  (token_stack + pos)->line = line;
#line 257
  debugtoken(& *(token_stack + pos), (char *)"insert at %d", pos);
  }
}
}
#line 261 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void tokpush(int type , int line , char *token ) 
{ 
  void *__cil_tmp4 ;

  {
#line 263
  (token_stack + tos)->type = type;
#line 264
  (token_stack + tos)->token = token;
#line 265
  (token_stack + tos)->line = line;
#line 266
  tos ++;
#line 266
  if (tos == token_stack_length) {
    {
#line 267
    token_stack_length += token_stack_increase;
#line 268
    __cil_tmp4 = xrealloc((void *)token_stack, (unsigned long )token_stack_length * sizeof(*token_stack));
#line 268
    token_stack = (TOKSTK *)__cil_tmp4;
    }
  }
}
}
#line 274 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void cleanup_stack(void) 
{ 
  int delta ;

  {
#line 276
  delta = tos - curs;
#line 278
  if (delta > 0) {
    {
#line 279
    memmove((void *)token_stack, (void const   *)(token_stack + curs), (unsigned long )delta * sizeof(*(token_stack + 0)));
    }
  } else
#line 280
  if (delta < 0) {
#line 281
    delta = 0;
  }
#line 282
  tos = delta;
#line 283
  curs = 0;
}
}
#line 287 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void clearstack(void) 
{ 


  {
#line 289
  curs = 0;
#line 289
  tos = curs;
}
}
#line 293 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int nexttoken(void) 
{ 
  int type ;

  {
#line 297
  if (curs == tos) {
    {
#line 298
    type = get_token();
#line 299
    tokpush(type, line_num, yylval.str);
#line 300
    yylval.str = (char *)((void *)0);
    }
  }
  {
#line 302
  tok = *(token_stack + curs);
#line 303
  curs ++;
#line 304
  debugtoken(& tok, (char *)"next token");
  }
#line 305
  return (tok.type);
}
}
#line 309 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int putback(void) 
{ 
  char *__cil_tmp1 ;
  int __cil_tmp2 ;

  {
#line 311
  if (curs == 0) {
    {
#line 312
    __cil_tmp1 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"INTERNAL ERROR: cannot return token to stream"),
                           5);
#line 312
    error(0, 0, (char const   *)__cil_tmp1);
#line 313
    abort();
    }
  }
#line 315
  __cil_tmp2 = curs;
#line 315
  curs --;
#line 316
  if (curs > 0) {
#line 317
    tok = *(token_stack + (curs - 1));
  } else {
#line 319
    tok.type = 0;
  }
  {
#line 320
  debugtoken(& tok, (char *)"putback");
  }
#line 321
  return (tok.type);
}
}
#line 325 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void init_parse(void) 
{ 
  void *__cil_tmp1 ;

  {
  {
#line 327
  _obstack_begin(& text_stk, 0, 0, (void *(*)(long  ))xmalloc, (void (*)(void * ))free);
#line 328
  __cil_tmp1 = xmalloc((unsigned long )token_stack_length * sizeof(*token_stack));
#line 328
  token_stack = (TOKSTK *)__cil_tmp1;
#line 329
  clearstack();
  }
}
}
#line 333 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void save_token(TOKSTK *tokptr ) 
{ 
  int len ;
  size_t __cil_tmp3 ;
  size_t __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 343
  if (tokptr->type == 273) {
#line 343
    goto case_273;
  }
#line 343
  if (tokptr->type == 257) {
#line 343
    goto case_273;
  }
#line 343
  if (tokptr->type == 272) {
#line 343
    goto case_273;
  }
#line 343
  if (tokptr->type == 264) {
#line 343
    goto case_273;
  }
#line 343
  if (tokptr->type == 270) {
#line 343
    goto case_273;
  }
#line 343
  if (tokptr->type == 260) {
#line 343
    goto case_273;
  }
#line 350
  if (tokptr->type == 265) {
#line 350
    goto case_265;
  }
#line 361
  if (tokptr->type == 262) {
#line 361
    goto case_262;
  }
#line 361
  if (tokptr->type == 261) {
#line 361
    goto case_262;
  }
#line 367
  if (tokptr->type == '(') {
#line 367
    goto case_40;
  }
#line 387
  goto switch_default;
  case_273: /* CIL Label */ 
#line 344
  if (need_space) {

  }
  {
#line 346
  __cil_tmp3 = strlen((char const   *)tokptr->token);
#line 346
  len = (int )__cil_tmp3;
#line 348
  need_space = 1;
  }
#line 349
  goto switch_break;
  case_265: /* CIL Label */ 
#line 351
  if (need_space) {

  }
#line 353
  if ((int )*(tokptr->token + 0) == 42) {
#line 354
    need_space = 0;
  } else {
#line 356
    need_space = 1;
  }
  {
#line 357
  __cil_tmp4 = strlen((char const   *)tokptr->token);
#line 357
  len = (int )__cil_tmp4;
  }
#line 359
  goto switch_break;
  case_262: /* CIL Label */ 
#line 362
  goto switch_break;
#line 365
  need_space = 1;
#line 366
  goto switch_break;
  case_40: /* CIL Label */ 
#line 368
  if (need_space) {

  }
#line 371
  need_space = 0;
#line 372
  goto switch_break;
#line 375
  need_space = 1;
#line 376
  goto switch_break;
#line 380
  need_space = 0;
#line 381
  goto switch_break;
#line 385
  need_space = 1;
#line 386
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 388
  if (verbose) {
    {
#line 389
    __cil_tmp5 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unrecognized definition"),
                           5);
#line 389
    file_error(__cil_tmp5, tokptr);
    }
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 393
static Stackpos start_pos ;
#line 394
static int save_end ;
#line 397 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void save_stack(void) 
{ 


  {
  {
#line 399
  mark((int *)start_pos);
#line 400
  save_end = curs - 1;
  }
}
}
#line 404 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void undo_save_stack(void) 
{ 


  {
#line 406
  save_end = - 1;
}
}
#line 410 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
char *finish_save_stack(char *name ) 
{ 
  int i ;
  int level___94 ;
  int found_ident ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;

  {
#line 413
  level___94 = 0;
#line 414
  found_ident = ! omit_symbol_names_option;
#line 416
  need_space = 0;
#line 417
  i = 0;
  {
  {
#line 417
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 417
    if (! (i < save_end)) {
#line 417
      goto while_break;
    }
    {
#line 419
    if ((token_stack + i)->type == '(') {
#line 419
      goto case_40;
    }
#line 427
    if ((token_stack + i)->type == ')') {
#line 427
      goto case_41;
    }
#line 431
    if ((token_stack + i)->type == 260) {
#line 431
      goto case_260;
    }
#line 418
    goto switch_break;
    case_40: /* CIL Label */ 
#line 420
    if (omit_arguments_option) {
#line 421
      if (level___94 == 0) {
        {
#line 422
        save_token(token_stack + i);
        }
      }
#line 424
      level___94 ++;
    }
#line 426
    goto switch_break;
    case_41: /* CIL Label */ 
#line 428
    if (omit_arguments_option) {
#line 429
      __cil_tmp6 = level___94;
#line 429
      level___94 --;
    }
#line 430
    goto switch_break;
    case_260: /* CIL Label */ 
    {
#line 432
    __cil_tmp7 = strcmp((char const   *)name, (char const   *)(token_stack + i)->token);
    }
#line 432
    if (! found_ident) {
#line 432
      if (__cil_tmp7 == 0) {
#line 433
        need_space = 1;
#line 434
        found_ident = 1;
#line 435
        goto while_continue;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 438
    if (level___94 == 0) {
      {
#line 439
      save_token(token_stack + i);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  i ++;
#line 442
  return ((char *)0);
}
}
#line 446 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void skip_to(int c ) 
{ 
  int __cil_tmp2 ;

  {
  {
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;

#line 448
    if (! __cil_tmp2) {
#line 448
      goto while_break;
    }
#line 449
    if (tok.type == c) {
#line 450
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 455 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int skip_balanced(int open_tok , int close_tok , int level___0 ) 
{ 
  int __cil_tmp4 ;
  int __cil_tmp6 ;

  {
#line 457
  if (level___0 == 0) {
    {
#line 458
    __cil_tmp4 = nexttoken();
    }
#line 458
    if (__cil_tmp4 != open_tok) {
#line 459
      return (1);
    }
#line 461
    level___0 ++;
  }
  {
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;

#line 463
    if (! __cil_tmp6) {
#line 463
      goto while_break;
    }
#line 464
    if (tok.type == 258) {
#line 464
      if (open_tok == 123) {
#line 465
        tok.type = '{';
      } else {
#line 464
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 466
    if (tok.type == 259) {
#line 466
      if (close_tok == 125) {
#line 467
        tok.type = '}';
      }
    }
#line 469
    if (tok.type == open_tok) {
#line 470
      level___0 ++;
    } else
#line 471
    if (tok.type == close_tok) {
#line 472
      level___0 --;
#line 472
      if (level___0 == 0) {
        {
#line 473
        nexttoken();
        }
#line 474
        return (0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  return (- 1);
}
}
#line 482 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int yyparse(void) 
{ 
  Ident identifier ;
  int __cil_tmp2 ;

  {
  {
#line 486
  level = 0;
#line 487
  caller = (Symbol *)((void *)0);
#line 488
  clearstack();
  }
  {
  {
#line 489
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 489
    if (! __cil_tmp2) {
#line 489
      goto while_break;
    }
#line 490
    identifier.storage = (enum storage )0;
    {
#line 492
    if (tok.type == 0) {
#line 492
      goto case_0;
    }
#line 494
    if (tok.type == 273) {
#line 494
      goto case_273;
    }
#line 496
    if (tok.type == 263) {
#line 496
      goto case_263;
    }
#line 499
    if (tok.type == 261) {
#line 499
      goto case_261;
    }
#line 503
    if (tok.type == 262) {
#line 503
      goto case_262;
    }
#line 507
    goto switch_default;
    case_0: /* CIL Label */ 
#line 493
    return (0);
    case_273: /* CIL Label */ 
#line 495
    goto while_continue;
    case_263: /* CIL Label */ 
    {
#line 497
    parse_typedef();
    }
#line 498
    goto switch_break;
    case_261: /* CIL Label */ 
#line 500
    identifier.storage = (enum storage )1;
    {
#line 501
    parse_declaration(& identifier, 0);
    }
#line 502
    goto switch_break;
    case_262: /* CIL Label */ 
#line 504
    identifier.storage = (enum storage )2;
    {
#line 505
    nexttoken();
    }
    switch_default: /* CIL Label */ 
    {
#line 508
    parse_declaration(& identifier, 0);
    }
#line 509
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 511
    cleanup_stack();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return (0);
}
}
#line 517 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
static int is_function(void) 
{ 
  Stackpos sp ;
  int res ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int __cil_tmp5 ;

  {
  {
#line 520
  res = 0;
#line 522
  mark((int *)sp);
  }
  {
  {
#line 523
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 533
    if (tok.type == 268) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 267) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 264) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 261) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 262) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 265) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 260) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 270) {
#line 533
      goto case_268;
    }
#line 533
    if (tok.type == 273) {
#line 533
      goto case_268;
    }
#line 536
    if (tok.type == 272) {
#line 536
      goto case_272;
    }
#line 541
    if (tok.type == '(') {
#line 541
      goto case_40;
    }
#line 544
    goto switch_default;
    case_268: /* CIL Label */ 
    {
#line 534
    nexttoken();
    }
#line 535
    goto while_continue;
    case_272: /* CIL Label */ 
    {
#line 537
    __cil_tmp3 = skip_balanced('(', ')', 0);
    }
#line 537
    if (__cil_tmp3 == -1) {
      {
#line 538
      __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in declaration"),
                             5);
#line 538
      file_error(__cil_tmp4, (TOKSTK *)((void *)0));
      }
    }
#line 540
    goto while_continue;
    case_40: /* CIL Label */ 
    {
#line 542
    __cil_tmp5 = nexttoken();
#line 542
    res = __cil_tmp5 != 265;
    }
#line 543
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 545
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 547
    goto while_break;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  restore((int *)sp);
  }
#line 551
  return (res);
}
}
#line 555 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void parse_declaration(Ident *ident___0 , int parm ) 
{ 
  int __cil_tmp3 ;

  {
  {
#line 557
  __cil_tmp3 = is_function();
  }
#line 557
  if (__cil_tmp3) {
    {
#line 558
    parse_function_declaration(ident___0, parm);
    }
  } else {
    {
#line 560
    parse_variable_declaration(ident___0, parm);
    }
  }
  {
#line 561
  delete_parms(parm_level);
  }
}
}
#line 566 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void expression(void) 
{ 
  char *name ;
  int line ;
  int parens_lev ;
  char *__cil_tmp4 ;
  int __cil_tmp6 ;
  int __cil_tmp8 ;

  {
#line 572
  parens_lev = 0;
  {
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 575
    if (tok.type == ';') {
#line 575
      goto case_59;
    }
#line 580
    if (tok.type == 259) {
#line 580
      goto case_259;
    }
#line 580
    if (tok.type == '}') {
#line 580
      goto case_259;
    }
#line 580
    if (tok.type == 258) {
#line 580
      goto case_259;
    }
#line 580
    if (tok.type == '{') {
#line 580
      goto case_259;
    }
#line 583
    if (tok.type == ',') {
#line 583
      goto case_44;
    }
#line 587
    if (tok.type == 0) {
#line 587
      goto case_0;
    }
#line 593
    if (tok.type == 260) {
#line 593
      goto case_260;
    }
#line 610
    if (tok.type == '(') {
#line 610
      goto case_40;
    }
#line 619
    if (tok.type == ')') {
#line 619
      goto case_41;
    }
#line 574
    goto switch_break;
    case_59: /* CIL Label */ 
#line 576
    return;
    case_259: /* CIL Label */ 
    {
#line 581
    putback();
    }
#line 582
    return;
    case_44: /* CIL Label */ 
#line 584
    if (parens_lev == 0) {
#line 585
      return;
    }
#line 586
    goto switch_break;
    case_0: /* CIL Label */ 
#line 588
    if (verbose) {
      {
#line 589
      __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in expression"),
                             5);
#line 589
      file_error(__cil_tmp4, (TOKSTK *)((void *)0));
      }
    }
#line 591
    return;
    case_260: /* CIL Label */ 
#line 594
    name = tok.token;
    {
#line 595
    line = tok.line;
#line 596
    nexttoken();
    }
#line 597
    if (tok.type == 40) {
      {
#line 598
      call(name, line);
#line 599
      parens_lev ++;
      }
    } else {
      {
#line 601
      reference(name, line);
      }
#line 602
      if (tok.type == 269) {
        {
        {
#line 603
        while (1) {
          while_continue___0: /* CIL Label */ ;

#line 603
          if (! (tok.type == 269)) {
#line 603
            goto while_break___0;
          }
          {
#line 604
          nexttoken();
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 606
        putback();
        }
      }
    }
#line 609
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 612
    __cil_tmp6 = nexttoken();
    }
#line 612
    if (__cil_tmp6 == 270) {
      {
#line 613
      skip_to(')');
      }
    } else {
      {
#line 615
      putback();
#line 616
      parens_lev ++;
      }
    }
#line 618
    goto switch_break;
    case_41: /* CIL Label */ 
#line 620
    __cil_tmp8 = parens_lev;
#line 620
    parens_lev --;
#line 621
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 623
    nexttoken();
    }
  }
  while_break: /* CIL Label */ ;
  }

  }
}
}
#line 628 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void parse_function_declaration(Ident *ident___0 , int parm ) 
{ 
  int error_recovery ;
  char *__cil_tmp4 ;
  char *__cil_tmp6 ;

  {
  {
#line 630
  error_recovery = 0;
#line 631
  ident___0->type_end = - 1;
#line 632
  parse_knr_dcl(ident___0);
  }
  restart: 
  {
#line 636
  if (tok.type == ')') {
#line 636
    goto case_41;
  }
#line 651
  if (tok.type == ',') {
#line 651
    goto case_44;
  }
#line 651
  if (tok.type == ';') {
#line 651
    goto case_44;
  }
#line 654
  if (tok.type == '{') {
#line 654
    goto case_123;
  }
#line 654
  if (tok.type == 258) {
#line 654
    goto case_123;
  }
#line 662
  if (tok.type == 0) {
#line 662
    goto case_0;
  }
#line 640
  goto switch_default;
  case_41: /* CIL Label */ 
#line 637
  if (parm) {
#line 638
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 641
  if (error_recovery) {
    {
#line 642
    nexttoken();
    }
  } else {
#line 644
    if (verbose) {
      {
#line 645
      __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"expected `;\'"),
                             5);
#line 645
      file_error(__cil_tmp4, & tok);
      }
    }
#line 646
    error_recovery = 1;
  }
#line 648
  goto restart;
  case_44: /* CIL Label */ 
#line 652
  goto switch_break;
  case_123: /* CIL Label */ 
#line 655
  if (ident___0->name) {
    {
#line 656
    caller = lookup((char const   *)ident___0->name);
    }
#line 657
    if (caller) {
#line 657
      if ((unsigned int )caller->storage == 3U) {
#line 658
        caller = (Symbol *)((void *)0);
      }
    }
    {
#line 659
    func_body();
    }
  }
#line 661
  goto switch_break;
  case_0: /* CIL Label */ 
#line 663
  if (verbose) {
    {
#line 664
    __cil_tmp6 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in declaration"),
                           5);
#line 664
    file_error(__cil_tmp6, (TOKSTK *)((void *)0));
    }
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 669 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int fake_struct(Ident *ident___0 ) 
{ 
  Stackpos sp ;
  int __cil_tmp3 ;
  int pos ;
  char *__cil_tmp5 ;

  {
  {
#line 673
  mark((int *)sp);
#line 674
  ident___0->type_end = - 1;
  }
#line 675
  if (tok.type == 264) {
    {
#line 676
    __cil_tmp3 = nexttoken();
    }
#line 676
    if (__cil_tmp3 == 260) {
#line 677
      ident___0->type_end = curs;
    }
    {
#line 679
    putback();
#line 680
    skip_struct();
    }
#line 681
    if (tok.type == 260) {
      _L: /* CIL Label */ 
      {
#line 682
      pos = curs - 1;
#line 683
      restore((int *)sp);
      }
#line 684
      if (ident___0->type_end == -1) {
        {
#line 686
        tokdel(curs, pos - 1);
#line 687
        tokins(curs, 260, tok.line, (char *)"{ ... }");
#line 688
        debugtoken(& tok, (char *)"modified stack");
        }
      }
    } else
#line 681
    if (tok.type == 265) {
#line 681
      goto _L;
    } else
#line 690
    if (tok.type == 40) {
#line 691
      return (0);
    } else
#line 692
    if (tok.type != 59) {
      {
#line 693
      __cil_tmp5 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"missing `;\' after struct declaration"),
                             5);
#line 693
      file_error(__cil_tmp5, & tok);
      }
    }
#line 694
    return (1);
  }
#line 696
  return (0);
}
}
#line 700 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void parse_variable_declaration(Ident *ident___0 , int parm ) 
{ 
  Stackpos sp ;
  int __cil_tmp4 ;
  int pos ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 704
  mark((int *)sp);
#line 705
  ident___0->type_end = - 1;
  }
#line 706
  if (tok.type == 264) {
    _L: /* CIL Label */ 
    {
#line 707
    __cil_tmp4 = nexttoken();
    }
#line 707
    if (__cil_tmp4 == 260) {
#line 708
      ident___0->type_end = curs;
    }
    {
#line 710
    putback();
#line 711
    skip_struct();
    }
    {
    {
#line 712
    while (1) {
      while_continue: /* CIL Label */ ;

#line 712
      if (! (tok.type == 265 || tok.type == 273)) {
#line 712
        goto while_break;
      }
      {
#line 713
      nexttoken();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 714
    if (tok.type == 260) {
      {
#line 715
      pos = curs - 1;
#line 716
      restore((int *)sp);
      }
#line 717
      if (ident___0->type_end == -1) {
        {
#line 719
        tokdel(curs, pos - 1);
#line 720
        tokins(curs, 260, tok.line, (char *)"{ ... }");
#line 721
        debugtoken(& tok, (char *)"modified stack");
        }
      }
    } else {
#line 724
      if (tok.type == 59) {
#line 725
        return;
      }
      {
#line 726
      restore((int *)sp);
      }
    }
  } else
#line 706
  if (tok.type == 267) {
#line 706
    goto _L;
  }
  again: 
  {
#line 730
  parse_dcl(ident___0, 0);
  }
  select: 
  {
#line 734
  if (tok.type == ')') {
#line 734
    goto case_41;
  }
#line 743
  if (tok.type == ';') {
#line 743
    goto case_59;
  }
#line 745
  if (tok.type == ',') {
#line 745
    goto case_44;
  }
#line 751
  if (tok.type == '=') {
#line 751
    goto case_61;
  }
#line 760
  if (tok.type == '{') {
#line 760
    goto case_123;
  }
#line 760
  if (tok.type == 258) {
#line 760
    goto case_123;
  }
#line 763
  if (tok.type == 0) {
#line 763
    goto case_0;
  }
#line 738
  goto switch_default;
  case_41: /* CIL Label */ 
#line 735
  if (parm) {
#line 736
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 739
  if (verbose) {
    {
#line 740
    __cil_tmp6 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"expected `;\'"),
                           5);
#line 740
    file_error(__cil_tmp6, & tok);
    }
  }
  case_59: /* CIL Label */ 
#line 744
  goto switch_break;
  case_44: /* CIL Label */ 
#line 746
  if (parm) {
#line 747
    goto switch_break;
  }
  {
#line 748
  tos = ident___0->type_end;
#line 749
  restore((int *)sp);
  }
#line 750
  goto again;
  case_61: /* CIL Label */ 
  {
#line 752
  nexttoken();
  }
#line 753
  if (tok.type == 123) {
    {
    {
#line 754
    initializer_list();
    }
    }
  } else
#line 753
  if (tok.type == 258) {
    {
    {
#line 754
    initializer_list();
    }
    }
  } else {
    {
#line 756
    expression();
    }
  }
#line 757
  goto select;
#line 758
  goto switch_break;
  case_123: /* CIL Label */ 
  {
#line 761
  func_body();
  }
#line 762
  goto switch_break;
  case_0: /* CIL Label */ 
#line 764
  if (verbose) {
    {
#line 765
    __cil_tmp7 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in declaration"),
                           5);
#line 765
    file_error(__cil_tmp7, (TOKSTK *)((void *)0));
    }
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 770 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void initializer_list(void) 
{ 
  int lev ;
  char *__cil_tmp3 ;

  {
#line 772
  lev = 0;
  {
  {
#line 773
  while (1) {
    while_continue: /* CIL Label */ ;

    {
#line 776
    if (tok.type == 258) {
#line 776
      goto case_258;
    }
#line 776
    if (tok.type == '{') {
#line 776
      goto case_258;
    }
#line 780
    if (tok.type == 259) {
#line 780
      goto case_259;
    }
#line 780
    if (tok.type == '}') {
#line 780
      goto case_259;
    }
#line 786
    if (tok.type == 0) {
#line 786
      goto case_0;
    }
#line 790
    if (tok.type == ',') {
#line 790
      goto case_44;
    }
#line 792
    goto switch_default;
    case_258: /* CIL Label */ 
#line 777
    lev ++;
#line 778
    goto switch_break;
    case_259: /* CIL Label */ 
#line 781
    lev --;
#line 781
    if (lev <= 0) {
      {
#line 782
      nexttoken();
      }
#line 783
      return;
    }
#line 785
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 787
    __cil_tmp3 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in initializer list"),
                           5);
#line 787
    file_error(__cil_tmp3, (TOKSTK *)((void *)0));
    }
#line 789
    return;
    case_44: /* CIL Label */ 
#line 791
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 793
    expression();
    }
#line 794
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 796
    nexttoken();
    }
  }
  while_break: /* CIL Label */ ;
  }

  }
}
}
#line 801 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void parse_knr_dcl(Ident *ident___0 ) 
{ 


  {
  {
#line 803
  ident___0->type_end = - 1;
#line 804
  parse_dcl(ident___0, ! strict_ansi);
  }
}
}
#line 808 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void skip_struct(void) 
{ 
  int __cil_tmp1 ;
  int __cil_tmp2 ;
  char *__cil_tmp3 ;
  int __cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 810
  __cil_tmp1 = nexttoken();
  }
#line 810
  if (__cil_tmp1 == 260) {
    {
#line 811
    nexttoken();
    }
  } else
#line 812
  if (tok.type == 59) {
#line 813
    return;
  }
#line 815
  if (tok.type == 123) {
    _L: /* CIL Label */ 
    {
#line 816
    __cil_tmp2 = skip_balanced('{', '}', 1);
    }
#line 816
    if (__cil_tmp2 == -1) {
      {
#line 817
      __cil_tmp3 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in struct"),
                             5);
#line 817
      file_error(__cil_tmp3, (TOKSTK *)((void *)0));
      }
#line 818
      return;
    }
  } else
#line 815
  if (tok.type == 258) {
#line 815
    goto _L;
  }
  {
  {
#line 822
  while (1) {
    while_continue: /* CIL Label */ ;

#line 822
    if (! (tok.type == 272)) {
#line 822
      goto while_break;
    }
    {
#line 823
    __cil_tmp4 = skip_balanced('(', ')', 0);
    }
#line 823
    if (__cil_tmp4 == -1) {
      {
#line 824
      __cil_tmp5 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in struct"),
                             5);
#line 824
      file_error(__cil_tmp5, (TOKSTK *)((void *)0));
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 829 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void parse_typedef(void) 
{ 
  Ident ident___0 ;
  int __cil_tmp2 ;

  {
  {
#line 833
  ident___0.name = (char *)((void *)0);
#line 834
  ident___0.type_end = - 1;
#line 835
  ident___0.parmcnt = - 1;
#line 836
  ident___0.line = - 1;
#line 837
  ident___0.storage = (enum storage )4;
#line 839
  nexttoken();
#line 840
  __cil_tmp2 = fake_struct(& ident___0);
  }
#line 840
  if (! __cil_tmp2) {
    {
#line 841
    putback();
    }
  }
  {
#line 843
  dcl(& ident___0);
  }
#line 844
  if (ident___0.name) {
    {
#line 845
    declare_type(& ident___0);
    }
  }
}
}
#line 849 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void parse_dcl(Ident *ident___0 , int maybe_knr ) 
{ 


  {
  {
#line 851
  ident___0->parmcnt = - 1;
#line 852
  ident___0->name = (char *)((void *)0);
#line 853
  putback();
#line 854
  dcl(ident___0);
#line 855
  save_stack();
  }
#line 856
  if (ident___0->name) {
    {
#line 857
    declare(ident___0, maybe_knr);
    }
  } else {
    {
#line 859
    undo_save_stack();
    }
  }
}
}
#line 863 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int dcl(Ident *idptr ) 
{ 
  int __cil_tmp2 ;
  int __cil_tmp3 ;
  char *__cil_tmp4 ;
  int type ;
  int __cil_tmp6 ;

  {
  {
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;

#line 865
    if (! (__cil_tmp2 != 0 && tok.type != 40)) {
#line 865
      goto while_break;
    }
#line 866
    if (tok.type == 265) {
#line 867
      if (idptr) {
#line 867
        if (idptr->type_end == -1) {
#line 868
          idptr->type_end = curs - 1;
        }
      }
    } else
#line 869
    if (tok.type == 272) {
      {
#line 870
      __cil_tmp3 = skip_balanced('(', ')', 0);
      }
#line 870
      if (__cil_tmp3 == -1) {
        {
#line 871
        __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in function declaration"),
                               5);
#line 871
        file_error(__cil_tmp4, (TOKSTK *)((void *)0));
        }
#line 873
        return (1);
      }
    } else
#line 875
    if (tok.type == 260) {
      {
      {
#line 878
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 878
        if (! (tok.type == 260)) {
#line 878
          goto while_break___0;
        }
        {
#line 879
        nexttoken();
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 880
      type = tok.type;
#line 881
      putback();
      }
#line 882
      if (! ((type == 270 || type == 265) || type == 273)) {
#line 884
        goto while_break;
      }
    } else
#line 885
    if (tok.type == 41) {
#line 886
      return (1);
    } else
#line 885
    if (tok.type == 59) {
#line 886
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 889
  if (idptr) {
#line 889
    if (idptr->type_end == -1) {
#line 890
      idptr->type_end = curs - 1;
    }
  }
  {
#line 891
  __cil_tmp6 = dirdcl(idptr);
  }
#line 891
  return (__cil_tmp6);
}
}
#line 895 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int dirdcl(Ident *idptr ) 
{ 
  int wrapper ;
  int *parm_ptr ;
  char *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 897
  wrapper = 0;
#line 898
  parm_ptr = (int *)((void *)0);
#line 900
  if (tok.type == 40) {
    {
#line 901
    dcl(idptr);
    }
#line 902
    if (tok.type != 41) {
#line 902
      if (verbose) {
        {
#line 903
        __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"expected `)\'"),
                               5);
#line 903
        file_error(__cil_tmp4, & tok);
        }
#line 904
        return (1);
      }
    }
  } else
#line 906
  if (tok.type == 260) {
#line 907
    if (idptr) {
#line 908
      idptr->name = tok.token;
#line 909
      idptr->line = tok.line;
#line 910
      parm_ptr = & idptr->parmcnt;
    }
  }
  {
#line 914
  __cil_tmp5 = nexttoken();
  }
#line 914
  if (__cil_tmp5 == 272) {
    {
#line 915
    wrapper = 1;
#line 916
    nexttoken();
    }
  } else {
    {
#line 918
    putback();
    }
  }
  {
  {
#line 920
  while (1) {
    while_continue: /* CIL Label */ ;

#line 920
    if (! (__cil_tmp6 == 91 || tok.type == 40)) {
#line 920
      goto while_break;
    }
#line 921
    if (tok.type == 91) {
      {
#line 922
      skip_to(']');
      }
    } else {
      {
#line 924
      maybe_parm_list(parm_ptr);
      }
#line 925
      if (tok.type != 41) {
#line 925
        if (verbose) {
          {
#line 926
          __cil_tmp7 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"expected `)\'"),
                                 5);
#line 926
          file_error(__cil_tmp7, & tok);
          }
#line 927
          return (1);
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  if (wrapper) {
    {
#line 932
    nexttoken();
    }
  }
  {
  {
#line 934
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 934
    if (! (tok.type == 272)) {
#line 934
      goto while_break___0;
    }
    {
#line 935
    __cil_tmp8 = skip_balanced('(', ')', 0);
    }
#line 935
    if (__cil_tmp8 == -1) {
      {
#line 936
      __cil_tmp9 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in function declaration"),
                             5);
#line 936
      file_error(__cil_tmp9, (TOKSTK *)((void *)0));
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 940
  return (0);
}
}
#line 944 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int parmdcl(Ident *idptr ) 
{ 
  int type ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
  {
#line 948
  while (1) {
    while_continue: /* CIL Label */ ;

#line 948
    if (! (__cil_tmp3 != 0 && tok.type != 40)) {
#line 948
      goto while_break;
    }
#line 949
    if (tok.type == 265) {
#line 950
      if (idptr) {
#line 950
        if (idptr->type_end == -1) {
#line 951
          idptr->type_end = curs - 1;
        }
      }
    } else
#line 952
    if (tok.type == 260) {
      {
      {
#line 953
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 953
        if (! (tok.type == 260)) {
#line 953
          goto while_break___0;
        }
        {
#line 954
        nexttoken();
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 955
      type = tok.type;
#line 956
      putback();
      }
#line 957
      if (type != 265) {
#line 958
        goto while_break;
      }
    } else
#line 959
    if (tok.type == 41) {
#line 960
      return (0);
    } else
#line 959
    if (tok.type == 44) {
#line 960
      return (0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 962
  if (idptr) {
#line 962
    if (idptr->type_end == -1) {
#line 963
      idptr->type_end = curs - 1;
    }
  }
  {
#line 964
  __cil_tmp4 = dirdcl(idptr);
  }
#line 964
  return (__cil_tmp4);
}
}
#line 969 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void maybe_parm_list(int *parm_cnt_return ) 
{ 
  int parmcnt ;
  Ident ident___0 ;
  int level___95 ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  char *__cil_tmp9 ;
  int __cil_tmp10 ;
  int __cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 971
  parmcnt = 0;
#line 975
  parm_level ++;
  {
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;

#line 976
    if (! __cil_tmp6) {
#line 976
      goto while_break;
    }
    {
#line 978
    if (tok.type == ')') {
#line 978
      goto case_41;
    }
#line 983
    if (tok.type == ',') {
#line 983
      goto case_44;
    }
#line 990
    if (tok.type == 270) {
#line 990
      goto case_270;
    }
#line 990
    if (tok.type == 267) {
#line 990
      goto case_270;
    }
#line 990
    if (tok.type == 264) {
#line 990
      goto case_270;
    }
#line 990
    if (tok.type == 265) {
#line 990
      goto case_270;
    }
#line 990
    if (tok.type == 260) {
#line 990
      goto case_270;
    }
#line 990
    if (tok.type == 273) {
#line 990
      goto case_270;
    }
#line 996
    goto switch_default;
    case_41: /* CIL Label */ 
#line 979
    if (parm_cnt_return) {
#line 980
      *parm_cnt_return = parmcnt;
    }
#line 981
    __cil_tmp7 = parm_level;
#line 981
    parm_level --;
#line 982
    return;
    case_44: /* CIL Label */ 
#line 984
    goto switch_break;
    case_270: /* CIL Label */ 
#line 991
    parmcnt ++;
    {
#line 992
    ident___0.storage = (enum storage )3;
#line 993
    parse_declaration(& ident___0, 1);
#line 994
    putback();
    }
#line 995
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 997
    if (verbose) {
      {
#line 998
      __cil_tmp9 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected token in parameter list"),
                             5);
#line 998
      file_error(__cil_tmp9, & tok);
      }
    }
#line 1000
    level___95 = 0;
    {
    {
#line 1001
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1002
      if (tok.type == 40) {
#line 1003
        level___95 ++;
      } else
#line 1004
      if (tok.type == 41) {
#line 1005
        __cil_tmp12 = level___95;
#line 1005
        level___95 --;
#line 1005
        if (__cil_tmp12 == 0) {
#line 1006
          goto while_break___0;
        }
      }
#line 1001
      if (! __cil_tmp10) {
#line 1001
        goto while_break___0;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1010
    putback();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  if (verbose) {
    {
#line 1014
    __cil_tmp13 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in parameter list"),
                            5);
#line 1014
    file_error(__cil_tmp13, (TOKSTK *)((void *)0));
    }
  }
}
}
#line 1018 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void func_body(void) 
{ 
  Ident ident___0 ;
  char *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1022
  level ++;
#line 1023
  move_parms(level);
  }
  {
  {
#line 1024
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1024
    if (! level) {
#line 1024
      goto while_break;
    }
    {
#line 1025
    cleanup_stack();
#line 1026
    nexttoken();
    }
    {
#line 1031
    if (tok.type == 262) {
#line 1031
      goto case_262;
    }
#line 1037
    if (tok.type == 264) {
#line 1037
      goto case_264;
    }
#line 1037
    if (tok.type == 270) {
#line 1037
      goto case_264;
    }
#line 1041
    if (tok.type == 261) {
#line 1041
      goto case_261;
    }
#line 1046
    if (tok.type == '{') {
#line 1046
      goto case_123;
    }
#line 1046
    if (tok.type == 258) {
#line 1046
      goto case_123;
    }
#line 1049
    if (tok.type == 259) {
#line 1049
      goto case_259;
    }
#line 1060
    if (tok.type == '}') {
#line 1060
      goto case_125;
    }
#line 1064
    if (tok.type == 0) {
#line 1064
      goto case_0;
    }
#line 1028
    goto switch_default;
    switch_default: /* CIL Label */ 
    {
#line 1029
    expression();
    }
#line 1030
    goto switch_break;
    case_262: /* CIL Label */ 
#line 1032
    ident___0.storage = (enum storage )2;
    {
#line 1033
    nexttoken();
#line 1034
    parse_variable_declaration(& ident___0, 0);
    }
#line 1035
    goto switch_break;
    case_264: /* CIL Label */ 
#line 1038
    ident___0.storage = (enum storage )3;
    {
#line 1039
    parse_variable_declaration(& ident___0, 0);
    }
#line 1040
    goto switch_break;
    case_261: /* CIL Label */ 
#line 1042
    ident___0.storage = (enum storage )1;
    {
#line 1043
    parse_declaration(& ident___0, 0);
    }
#line 1044
    goto switch_break;
    case_123: /* CIL Label */ 
#line 1047
    level ++;
#line 1048
    goto switch_break;
    case_259: /* CIL Label */ 
#line 1050
    if (use_indentation) {
#line 1051
      if (verbose) {
#line 1051
        if (level != 1) {
          {
#line 1052
          __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"forced function body close"),
                                 5);
#line 1052
          file_error(__cil_tmp4, (TOKSTK *)((void *)0));
          }
        }
      }
      {
      {
#line 1053
      while (1) {
        while_continue___0: /* CIL Label */ ;

#line 1053
        if (! level) {
#line 1053
          goto while_break___0;
        }
        {
#line 1054
        delete_autos(level);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1053
      __cil_tmp5 = level;
#line 1053
      level --;
#line 1056
      goto switch_break;
    }
    case_125: /* CIL Label */ 
    {
#line 1061
    delete_autos(level);
    }
#line 1062
    __cil_tmp6 = level;
#line 1062
    level --;
#line 1063
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1065
    if (verbose) {
      {
#line 1066
      __cil_tmp7 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unexpected end of file in function body"),
                             5);
#line 1066
      file_error(__cil_tmp7, (TOKSTK *)((void *)0));
      }
    }
#line 1068
    caller = (Symbol *)((void *)0);
#line 1069
    return;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1072
  caller = (Symbol *)((void *)0);
}
}
#line 1076 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
int get_knr_args(Ident *ident___0 ) 
{ 
  int parmcnt ;
  int stop ;
  Stackpos sp ;
  Stackpos new_sp ;
  Ident id ;
  int __cil_tmp7 ;

  {
  {
#line 1085
  if (tok.type == 264) {
#line 1085
    goto case_264;
  }
#line 1085
  if (tok.type == 270) {
#line 1085
    goto case_264;
  }
#line 1085
  if (tok.type == 260) {
#line 1085
    goto case_264;
  }
#line 1096
  if (tok.type == 258) {
#line 1096
    goto case_258;
  }
#line 1096
  if (tok.type == '{') {
#line 1096
    goto case_258;
  }
#line 1102
  if (tok.type == 264) {
#line 1102
    goto case_264___0;
  }
#line 1102
  if (tok.type == 260) {
#line 1102
    goto case_264___0;
  }
#line 1102
  if (tok.type == 270) {
#line 1102
    goto case_264___0;
  }
#line 1119
  goto switch_default;
  case_264: /* CIL Label */ 
  {
#line 1088
  mark((int *)sp);
  }
#line 1089
  parmcnt = 0;
#line 1091
  stop = 0;
  {
  {
#line 1091
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1091
    if (! (! stop && parmcnt < ident___0->parmcnt)) {
#line 1091
      goto while_break;
    }
#line 1093
    id.type_end = - 1;
    {
#line 1096
    if (tok.type == 258) {
#line 1096
      goto case_258;
    }
#line 1096
    if (tok.type == '{') {
#line 1096
      goto case_258;
    }
#line 1102
    if (tok.type == 264) {
#line 1102
      goto case_264___0;
    }
#line 1102
    if (tok.type == 260) {
#line 1102
      goto case_264___0;
    }
#line 1102
    if (tok.type == 270) {
#line 1102
      goto case_264___0;
    }
#line 1119
    goto switch_default;
    case_258: /* CIL Label */ 
    {
#line 1097
    putback();
    }
#line 1098
    stop = 1;
#line 1099
    goto switch_break___0;
    case_264___0: /* CIL Label */ 
    {
#line 1103
    putback();
    }
    {
#line 1104
    mark((int *)new_sp);
#line 1105
    __cil_tmp7 = dcl(& id);
    }
#line 1105
    if (__cil_tmp7 == 0) {
#line 1106
      parmcnt ++;
#line 1107
      if (tok.type == 44) {
        {
        {
#line 1108
        while (1) {
          while_continue___0: /* CIL Label */ ;

          {
#line 1109
          tos = id.type_end;
#line 1110
          restore((int *)new_sp);
#line 1111
          dcl(& id);
          }
#line 1108
          if (! (tok.type == 44)) {
#line 1108
            goto while_break___0;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
      } else
#line 1113
      if (tok.type != 59) {
        {
#line 1114
        putback();
        }
      }
#line 1115
      goto switch_break___0;
    }
    switch_default: /* CIL Label */ 
    {
#line 1120
    restore((int *)sp);
    }
#line 1121
    return (1);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1092
  nexttoken();
  }

  }
#line 1125
  return (0);
}
}
#line 1129 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void declare(Ident *ident___0 , int maybe_knr ) 
{ 
  Symbol *sp ;
  int __cil_tmp5 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  unsigned int tmp ;
  char *__cil_tmp13 ;

  {
#line 1133
  if ((unsigned int )ident___0->storage == 3U) {
    {
#line 1134
    undo_save_stack();
#line 1135
    sp = install_ident(ident___0->name, ident___0->storage);
    }
#line 1136
    if (parm_level) {
#line 1137
      sp->level = parm_level;
#line 1138
      sp->flag = (enum symbol_flag )2;
    } else {
#line 1140
      sp->level = level;
    }
#line 1141
    sp->arity = - 1;
#line 1142
    return;
  }
  {
#line 1145
  __cil_tmp5 = get_knr_args(ident___0);
  }
#line 1145
  if (ident___0->parmcnt >= 0) {
#line 1145
    if (! maybe_knr) {
      _L___97: /* CIL Label */ 
#line 1145
      if (! (((tok.type == 123 || tok.type == 258) || tok.type == 270) || tok.type == 272)) {
        {
        {
#line 1150
        undo_save_stack();
        }
        }
#line 1152
        return;
      } else {
#line 1145
        goto _L;
      }
    } else
#line 1145
    if (__cil_tmp5 == 0) {
#line 1145
      goto _L___97;
    } else {
#line 1145
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1145
  if (ident___0->parmcnt < 0) {
#line 1145
    if ((unsigned int )ident___0->storage == 1U) {
      {
      {
#line 1150
      undo_save_stack();
      }
      }
#line 1152
      return;
    }
  }
  {
#line 1155
  sp = get_symbol(ident___0->name);
  }
#line 1156
  if (sp->source) {
#line 1157
    if ((unsigned int )ident___0->storage == 2U) {
#line 1157
      if ((unsigned int )sp->storage != 2U) {
        {
        {
#line 1159
        sp = install_ident(ident___0->name, ident___0->storage);
        }
        }
      } else
#line 1157
      if (level > 0) {
        {
        {
#line 1159
        sp = install_ident(ident___0->name, ident___0->storage);
        }
        }
      } else {
#line 1157
        goto _L___98;
      }
    } else {
      _L___98: /* CIL Label */ 
#line 1161
      if (sp->arity >= 0) {
        {
#line 1162
        __cil_tmp8 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s/%d redefined"),
                               5);
#line 1162
        error_at_line(0, 0, (char const   *)filename, (unsigned int )ident___0->line,
                      (char const   *)__cil_tmp8, ident___0->name, sp->arity);
        }
      } else {
        {
#line 1166
        __cil_tmp9 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s redefined"),
                               5);
#line 1166
        error_at_line(0, 0, (char const   *)filename, (unsigned int )ident___0->line,
                      (char const   *)__cil_tmp9, ident___0->name);
        }
      }
      {
#line 1169
      __cil_tmp10 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"this is the place of previous definition"),
                              5);
#line 1169
      error_at_line(0, 0, (char const   *)sp->source, (unsigned int )sp->def_line,
                    (char const   *)__cil_tmp10);
      }
    }
  }
#line 1174
  sp->type = (enum symtype )2;
#line 1175
  sp->arity = ident___0->parmcnt;
#line 1176
  if ((unsigned int )ident___0->storage == 1U) {
#line 1176
    tmp = (unsigned int )0;
  } else {
#line 1176
    tmp = (unsigned int )ident___0->storage;
  }
  {
#line 1176
  ident_change_storage(sp, (enum storage )tmp);
#line 1179
  sp->decl = finish_save_stack(ident___0->name);
#line 1180
  sp->source = filename;
#line 1181
  sp->def_line = ident___0->line;
#line 1182
  sp->level = level;
  }
#line 1183
  if (debug) {
    {
#line 1184
    __cil_tmp13 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s:%d: %s/%d defined to %s\n"),
                            5);
#line 1184
    fprintf(stderr, (char const   *)__cil_tmp13, filename, line_num, ident___0->name,
            ident___0->parmcnt, sp->decl);
    }
  }
}
}
#line 1192 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void declare_type(Ident *ident___0 ) 
{ 
  Symbol *sp ;
  char *__cil_tmp5 ;

  {
  {
#line 1196
  undo_save_stack();
#line 1197
  sp = lookup((char const   *)ident___0->name);
  }
  {
  {
#line 1198
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1198
    if (! sp) {
#line 1198
      goto while_break;
    }
#line 1199
    if ((unsigned int )sp->type == 1U) {
#line 1199
      if (sp->token_type == 270) {
#line 1200
        goto while_break;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  sp = sp->next;
#line 1201
  if (! sp) {
    {
#line 1202
    sp = install(ident___0->name, 4);
    }
  }
#line 1203
  sp->type = (enum symtype )1;
#line 1204
  sp->token_type = 270;
#line 1205
  sp->source = filename;
#line 1206
  sp->def_line = ident___0->line;
#line 1207
  sp->ref_line = (struct linked_list *)((void *)0);
#line 1208
  if (debug) {
    {
#line 1209
    __cil_tmp5 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s:%d: type %s\n"),
                           5);
#line 1209
    fprintf(stderr, (char const   *)__cil_tmp5, filename, line_num, ident___0->name);
    }
  }
}
}
#line 1214 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
Symbol *get_symbol(char *name ) 
{ 
  Symbol *sp ;
  Symbol *__cil_tmp3 ;
  int __cil_tmp4 ;
  Symbol *__cil_tmp5 ;

  {
  {
#line 1216
  __cil_tmp3 = lookup((char const   *)name);
#line 1216
  sp = __cil_tmp3;
  }
#line 1218
  if (sp) {
    {
    {
#line 1219
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1219
      if (! sp) {
#line 1219
        goto while_break;
      }
      {
#line 1220
      __cil_tmp4 = strcmp((char const   *)sp->name, (char const   *)name);
      }
#line 1220
      if ((unsigned int )sp->type == 2U) {
#line 1220
        if (__cil_tmp4 == 0) {
#line 1221
          goto while_break;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1219
    sp = sp->next;
#line 1223
    if (sp) {
#line 1224
      return (sp);
    }
  }
  {
#line 1226
  __cil_tmp5 = install_ident(name, (enum storage )0);
  }
#line 1226
  return (__cil_tmp5);
}
}
#line 1230 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
Symbol *add_reference(char *name , int line ) 
{ 
  Symbol *sp ;
  Symbol *__cil_tmp4 ;
  Ref *refptr ;
  int __cil_tmp6 ;
  void *__cil_tmp7 ;

  {
  {
#line 1232
  __cil_tmp4 = get_symbol(name);
#line 1232
  sp = __cil_tmp4;
#line 1235
  __cil_tmp6 = globals_only();
  }
#line 1235
  if ((unsigned int )sp->storage == 3U) {
#line 1237
    return ((Symbol *)((void *)0));
  } else
#line 1235
  if ((unsigned int )sp->storage == 2U) {
#line 1235
    if (__cil_tmp6) {
#line 1237
      return ((Symbol *)((void *)0));
    }
  }
  {
#line 1238
  __cil_tmp7 = xmalloc(sizeof(*refptr));
#line 1238
  refptr = (Ref *)__cil_tmp7;
#line 1239
  refptr->source = filename;
#line 1240
  refptr->line = line;
  }
#line 1241
  if (! sp->ref_line) {
    {
#line 1242
    sp->ref_line = linked_list_create(free);
    }
  }
  {
#line 1243
  linked_list_append(& sp->ref_line, (void *)refptr);
  }
#line 1244
  return (sp);
}
}
#line 1249 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void call(char *name , int line ) 
{ 
  Symbol *sp ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1253
  sp = add_reference(name, line);
  }
#line 1254
  if (! sp) {
#line 1255
    return;
  }
#line 1256
  if (sp->arity < 0) {
#line 1257
    sp->arity = 0;
  }
#line 1258
  if (caller) {
    {
#line 1259
    __cil_tmp5 = data_in_list((void *)caller, sp->caller);
    }
#line 1259
    if (! __cil_tmp5) {
      {
#line 1260
      linked_list_append(& sp->caller, (void *)caller);
      }
    }
    {
#line 1261
    __cil_tmp6 = data_in_list((void *)sp, caller->callee);
    }
#line 1261
    if (! __cil_tmp6) {
      {
#line 1262
      linked_list_append(& caller->callee, (void *)sp);
      }
    }
  }
}
}
#line 1267 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/parser.c"
void reference(char *name , int line ) 
{ 
  Symbol *sp ;
  Symbol *__cil_tmp4 ;
  int __cil_tmp5 ;
  int __cil_tmp6 ;

  {
  {
#line 1269
  __cil_tmp4 = add_reference(name, line);
#line 1269
  sp = __cil_tmp4;
  }
#line 1270
  if (! sp) {
#line 1271
    return;
  }
#line 1272
  if (caller) {
    {
#line 1273
    __cil_tmp5 = data_in_list((void *)caller, sp->caller);
    }
#line 1273
    if (! __cil_tmp5) {
      {
#line 1274
      linked_list_append(& sp->caller, (void *)caller);
      }
    }
    {
#line 1275
    __cil_tmp6 = data_in_list((void *)sp, caller->callee);
    }
#line 1275
    if (! __cil_tmp6) {
      {
#line 1276
      linked_list_append(& caller->callee, (void *)sp);
      }
    }
  }
}
}
#line 145 "./cflow.h"
unsigned char *level_mark ;
#line 146
FILE *outfile ;
#line 147
char *outname ;
#line 150
int print_option ;
#line 155
char *level_indent[] ;
#line 156
char *level_end[] ;
#line 157
char *level_begin ;
#line 158
int print_levels ;
#line 163
int out_line ;
#line 164
char *start_name ;
#line 165
int max_depth ;
#line 213
void output(void) ;
#line 214
void newline(void) ;
#line 217
int include_symbol(Symbol *sym ) ;
#line 239
int register_output(char const   *name , int (*handler)(cflow_output_command cmd ,
                                                        FILE *outfile , int line ,
                                                        void *data , void *handler_data ) ,
                    void *handler_data ) ;
#line 244
int select_output_driver(char const   *name ) ;
#line 245
void output_init(void) ;
#line 256
cflow_depmap_t depmap_alloc(size_t count ) ;
#line 257
void depmap_set(cflow_depmap_t dmap , size_t row , size_t col ) ;
#line 258
int depmap_isset(cflow_depmap_t dmap , size_t row , size_t col ) ;
#line 259
void depmap_tc(cflow_depmap_t dmap ) ;
#line 25 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
int level_mark_size  =    0;
#line 26 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
int level_mark_incr  =    128;
#line 28 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
int out_line  =    1;
#line 32 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void set_level_mark(int lev , int mark___0 ) 
{ 
  void *__cil_tmp3 ;

  {
#line 34
  if (lev >= level_mark_size) {
    {
#line 35
    level_mark_size += level_mark_incr;
#line 36
    __cil_tmp3 = xrealloc((void *)level_mark, (size_t )level_mark_size);
#line 36
    level_mark = (unsigned char *)__cil_tmp3;
    }
  }
#line 38
  *(level_mark + lev) = (unsigned char )mark___0;
}
}
#line 44 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
void print_level(int lev , int last ) 
{ 
  int i ;

  {
#line 48
  if (print_line_numbers) {
    {
#line 49
    fprintf(outfile, (char const   *)((char *)"%5d "), out_line);
    }
  }
#line 50
  if (print_levels) {
    {
#line 51
    fprintf(outfile, (char const   *)((char *)"{%4d} "), lev);
    }
  }
  {
#line 52
  fprintf(outfile, (char const   *)((char *)"%s"), level_begin);
#line 53
  i = 0;
  }
  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;

#line 53
    if (! (i < lev)) {
#line 53
      goto while_break;
    }
    {
#line 54
    fprintf(outfile, (char const   *)((char *)"%s"), level_indent[*(level_mark + i)]);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 53
  i ++;
#line 55
  fprintf(outfile, (char const   *)((char *)"%s"), level_end[last]);
  }
}
}
#line 69
static int driver_index ;
#line 70 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static int driver_max  =    0;
#line 71
struct output_driver output_driver[8] ;
#line 74 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
int register_output(char const   *name , int (*handler)(cflow_output_command cmd ,
                                                        FILE *outfile , int line ,
                                                        void *data , void *handler_data ) ,
                    void *handler_data ) 
{ 
  int __cil_tmp5 ;

  {
#line 80
  if (driver_max == 7) {
    {
#line 81
    abort();
    }
  }
  {
#line 82
  output_driver[driver_max].name = strdup(name);
#line 83
  output_driver[driver_max].handler = handler;
#line 84
  output_driver[driver_max].handler_data = handler_data;
#line 85
  __cil_tmp5 = driver_max;
#line 85
  driver_max ++;
  }
#line 85
  return (__cil_tmp5);
}
}
#line 89 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
int select_output_driver(char const   *name ) 
{ 
  int i ;
  int __cil_tmp3 ;

  {
#line 92
  i = 0;
  {
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;

#line 92
    if (! (i < driver_max)) {
#line 92
      goto while_break;
    }
    {
#line 93
    __cil_tmp3 = strcmp((char const   *)output_driver[i].name, name);
    }
#line 93
    if (__cil_tmp3 == 0) {
#line 94
      driver_index = i;
#line 95
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i ++;
#line 97
  return (- 1);
}
}
#line 101 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
void output_init(void) 
{ 


  {
  {
#line 103
  output_driver[driver_index].handler((cflow_output_command )0, (FILE *)((void *)0),
                                      0, (void *)0, output_driver[driver_index].handler_data);
  }
}
}
#line 110 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
void newline(void) 
{ 


  {
  {
#line 112
  output_driver[driver_index].handler((cflow_output_command )3, outfile, out_line,
                                      (void *)0, output_driver[driver_index].handler_data);
#line 116
  out_line ++;
  }
}
}
#line 120 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void begin(void) 
{ 


  {
  {
#line 122
  output_driver[driver_index].handler((cflow_output_command )1, outfile, out_line,
                                      (void *)0, output_driver[driver_index].handler_data);
  }
}
}
#line 129 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void end(void) 
{ 


  {
  {
#line 131
  output_driver[driver_index].handler((cflow_output_command )2, outfile, out_line,
                                      (void *)0, output_driver[driver_index].handler_data);
  }
}
}
#line 138 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void separator(void) 
{ 


  {
  {
#line 140
  output_driver[driver_index].handler((cflow_output_command )4, outfile, out_line,
                                      (void *)0, output_driver[driver_index].handler_data);
  }
}
}
#line 158 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static int print_symbol___0(int direct , int level___0 , int last , Symbol *sym ) 
{ 
  struct output_symbol output_symbol ;
  int __cil_tmp6 ;

  {
  {
#line 162
  output_symbol.direct = direct;
#line 163
  output_symbol.level = level___0;
#line 164
  output_symbol.last = last;
#line 165
  output_symbol.sym = sym;
#line 167
  __cil_tmp6 = output_driver[driver_index].handler((cflow_output_command )5, outfile,
                                                   out_line, (void *)(& output_symbol),
                                                   output_driver[driver_index].handler_data);
  }
#line 167
  return (__cil_tmp6);
}
}
#line 175 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static int compare(void const   *ap , void const   *bp ) 
{ 
  Symbol * const  *a ;
  Symbol * const  *b ;
  int __cil_tmp5 ;

  {
  {
#line 177
  a = (Symbol * const  *)ap;
#line 178
  b = (Symbol * const  *)bp;
#line 179
  __cil_tmp5 = strcmp((char const   *)((Symbol *)*a)->name, (char const   *)((Symbol *)*b)->name);
  }
#line 179
  return (__cil_tmp5);
}
}
#line 183 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static int is_var(Symbol *symp ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 185
  __cil_tmp2 = include_symbol(symp);
  }
#line 185
  if (__cil_tmp2) {
#line 186
    if ((unsigned int )symp->type == 2U) {
#line 187
      return ((unsigned int )symp->storage == 0U || (unsigned int )symp->storage == 2U);
    } else {
#line 190
      return (1);
    }
  }
#line 192
  return (0);
}
}
#line 196 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
int symbol_is_function(Symbol *symp ) 
{ 


  {
#line 198
  return ((unsigned int )symp->type == 2U && symp->arity >= 0);
}
}
#line 202 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void clear_active(Symbol *sym ) 
{ 


  {
#line 204
  sym->active = 0;
}
}
#line 210 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
void print_refs(char *name , struct linked_list *reflist ) 
{ 
  Ref *refptr ;
  struct linked_list_entry *p ;
  struct linked_list_entry *tmp ;

  {
#line 215
  if (reflist) {
#line 215
    tmp = reflist->head;
  } else {
#line 215
    tmp = (struct linked_list_entry *)((void *)0);
  }
#line 215
  p = tmp;
  {
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 215
    if (! p) {
#line 215
      goto while_break;
    }
    {
#line 216
    refptr = (Ref *)p->data;
#line 217
    fprintf(outfile, (char const   *)((char *)"%s   %s:%d\n"), name, refptr->source,
            refptr->line);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  p = p->next;
}
}
#line 225 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void print_function(Symbol *symp ) 
{ 


  {
#line 227
  if (symp->source) {
    {
#line 228
    fprintf(outfile, (char const   *)((char *)"%s * %s:%d %s\n"), symp->name, symp->source,
            symp->def_line, symp->decl);
    }
  }
  {
#line 234
  print_refs(symp->name, symp->ref_line);
  }
}
}
#line 238 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void print_type(Symbol *symp ) 
{ 


  {
#line 240
  if (symp->source) {
    {
#line 241
    fprintf(outfile, (char const   *)((char *)"%s t %s:%d\n"), symp->name, symp->source,
            symp->def_line);
    }
  }
}
}
#line 248 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
void xref_output(void) 
{ 
  Symbol **symbols ;
  Symbol *symp ;
  size_t i ;
  size_t num ;

  {
  {
#line 253
  num = collect_symbols(& symbols, is_var, (size_t )0);
#line 254
  qsort((void *)symbols, num, sizeof(*symbols), compare);
#line 257
  i = (size_t )0;
  }
  {
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;

#line 257
    if (! (i < num)) {
#line 257
      goto while_break;
    }
#line 258
    symp = *(symbols + i);
    {
#line 260
    if ((unsigned int )symp->type == (unsigned int )2) {
#line 260
      goto case_2;
    }
#line 263
    if ((unsigned int )symp->type == (unsigned int )1) {
#line 263
      goto case_1;
    }
#line 266
    if ((unsigned int )symp->type == (unsigned int )0) {
#line 266
      goto case_0;
    }
#line 259
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 261
    print_function(symp);
    }
#line 262
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 264
    print_type(symp);
    }
#line 265
    goto switch_break;
    case_0: /* CIL Label */ 
#line 267
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  i ++;
#line 270
  free((void *)symbols);
  }
}
}
#line 278 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void set_active(Symbol *sym ) 
{ 


  {
#line 280
  sym->active = out_line;
}
}
#line 284 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static int is_printable(struct linked_list_entry *p ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 286
  __cil_tmp2 = include_symbol((Symbol *)p->data);
  }
#line 286
  return (p != (struct linked_list_entry *)((void *)0) && __cil_tmp2);
}
}
#line 290 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static int is_last(struct linked_list_entry *p ) 
{ 
  int __cil_tmp2 ;

  {
  {
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;

#line 292
    if (! p) {
#line 292
      goto while_break;
    }
    {
#line 293
    __cil_tmp2 = is_printable(p);
    }
#line 293
    if (__cil_tmp2) {
#line 294
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return (1);
}
}
#line 301 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void direct_tree(int lev , int last , Symbol *sym ) 
{ 
  struct linked_list_entry *p ;
  int rc ;
  int __cil_tmp6 ;
  struct linked_list_entry *tmp ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 306
  __cil_tmp6 = include_symbol(sym);
  }
#line 306
  if ((unsigned int )sym->type == 0U) {
#line 309
    return;
  } else
#line 306
  if (max_depth) {
#line 306
    if (lev >= max_depth) {
#line 309
      return;
    } else {
#line 306
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 306
  if (! __cil_tmp6) {
#line 309
    return;
  }
  {
#line 311
  rc = print_symbol___0(1, lev, last, sym);
#line 312
  newline();
  }
#line 313
  if (rc) {
#line 314
    return;
  } else
#line 313
  if (sym->active) {
#line 314
    return;
  }
  {
#line 315
  set_active(sym);
  }
#line 316
  if (sym->callee) {
#line 316
    tmp = (sym->callee)->head;
  } else {
#line 316
    tmp = (struct linked_list_entry *)((void *)0);
  }
#line 316
  p = tmp;
  {
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;

#line 316
    if (! p) {
#line 316
      goto while_break;
    }
    {
#line 317
    __cil_tmp9 = is_last(p);
#line 317
    set_level_mark(lev + 1, ! __cil_tmp9);
#line 318
    __cil_tmp10 = is_last(p);
#line 318
    direct_tree(lev + 1, __cil_tmp10, (Symbol *)p->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 316
  p = p->next;
#line 320
  clear_active(sym);
  }
}
}
#line 326 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void inverted_tree(int lev , int last , Symbol *sym ) 
{ 
  struct linked_list_entry *p ;
  int rc ;
  int __cil_tmp6 ;
  struct linked_list_entry *tmp ;
  int __cil_tmp9 ;
  int __cil_tmp10 ;

  {
  {
#line 331
  __cil_tmp6 = include_symbol(sym);
  }
#line 331
  if ((unsigned int )sym->type == 0U) {
#line 334
    return;
  } else
#line 331
  if (max_depth) {
#line 331
    if (lev >= max_depth) {
#line 334
      return;
    } else {
#line 331
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 331
  if (! __cil_tmp6) {
#line 334
    return;
  }
  {
#line 335
  rc = print_symbol___0(0, lev, last, sym);
#line 336
  newline();
  }
#line 337
  if (rc) {
#line 338
    return;
  } else
#line 337
  if (sym->active) {
#line 338
    return;
  }
  {
#line 339
  set_active(sym);
  }
#line 340
  if (sym->caller) {
#line 340
    tmp = (sym->caller)->head;
  } else {
#line 340
    tmp = (struct linked_list_entry *)((void *)0);
  }
#line 340
  p = tmp;
  {
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;

#line 340
    if (! p) {
#line 340
      goto while_break;
    }
    {
#line 341
    __cil_tmp9 = is_last(p);
#line 341
    set_level_mark(lev + 1, ! __cil_tmp9);
#line 342
    __cil_tmp10 = is_last(p);
#line 342
    inverted_tree(lev + 1, __cil_tmp10, (Symbol *)p->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 340
  p = p->next;
#line 344
  clear_active(sym);
  }
}
}
#line 348 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
static void tree_output(void) 
{ 
  Symbol **symbols ;
  Symbol *main_sym ;
  size_t i ;
  size_t num ;
  cflow_depmap_t depmap ;
  struct linked_list_entry *p ;
  struct linked_list_entry *tmp ;
  Symbol *s ;
  int __cil_tmp12 ;
  int __cil_tmp14 ;

  {
  {
#line 355
  num = collect_functions(& symbols);
#line 356
  i = (size_t )0;
  }
  {
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;

#line 356
    if (! (i < num)) {
#line 356
      goto while_break;
    }
#line 357
    (*(symbols + i))->ord = i;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 356
  i ++;
#line 360
  depmap = depmap_alloc(num);
#line 361
  i = (size_t )0;
  }
  {
  {
#line 361
  while (1) {
    while_continue___5: /* CIL Label */ ;

#line 361
    if (! (i < num)) {
#line 361
      goto while_break___0;
    }
#line 362
    if ((*(symbols + i))->callee) {
#line 365
      if ((*(symbols + i))->callee) {
#line 365
        tmp = ((*(symbols + i))->callee)->head;
      } else {
#line 365
        tmp = (struct linked_list_entry *)((void *)0);
      }
#line 365
      p = tmp;
      {
      {
#line 365
      while (1) {
        while_continue___6: /* CIL Label */ ;

#line 365
        if (! p) {
#line 365
          goto while_break___1;
        }
        {
#line 367
        s = (Symbol *)p->data;
#line 368
        __cil_tmp12 = symbol_is_function(s);
        }
#line 368
        if (__cil_tmp12) {
          {
#line 369
          depmap_set(depmap, i, ((Symbol *)p->data)->ord);
          }
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      p = p->next;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 361
  i ++;
#line 374
  depmap_tc(depmap);
#line 377
  i = (size_t )0;
  }
  {
  {
#line 377
  while (1) {
    while_continue___7: /* CIL Label */ ;

#line 377
    if (! (i < num)) {
#line 377
      goto while_break___2;
    }
    {
#line 378
    __cil_tmp14 = depmap_isset(depmap, i, i);
    }
#line 378
    if (__cil_tmp14) {
#line 379
      (*(symbols + i))->recursive = 1;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 377
  i ++;
#line 380
  free((void *)depmap);
#line 381
  free((void *)symbols);
#line 384
  num = collect_symbols(& symbols, is_var, (size_t )0);
#line 385
  qsort((void *)symbols, num, sizeof(*symbols), compare);
#line 388
  begin();
  }
#line 390
  if (reverse_tree) {
#line 391
    i = (size_t )0;
    {
    {
#line 391
    while (1) {
      while_continue___8: /* CIL Label */ ;

#line 391
      if (! (i < num)) {
#line 391
        goto while_break___3;
      }
      {
#line 392
      inverted_tree(0, 0, *(symbols + i));
#line 393
      separator();
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 391
    i ++;
  } else {
    {
#line 396
    main_sym = lookup((char const   *)start_name);
    }
#line 397
    if (main_sym) {
      {
#line 398
      direct_tree(0, 0, main_sym);
#line 399
      separator();
      }
    } else {
#line 401
      i = (size_t )0;
      {
      {
#line 401
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 401
        if (! (i < num)) {
#line 401
          goto while_break___4;
        }
#line 402
        if ((*(symbols + i))->callee == (struct linked_list *)((void *)0)) {
#line 403
          goto while_continue___4;
        }
        {
#line 404
        direct_tree(0, 0, *(symbols + i));
#line 405
        separator();
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 401
      i ++;
    }
  }
  {
#line 410
  end();
#line 412
  free((void *)symbols);
  }
}
}
#line 416 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/output.c"
void output(void) 
{ 
  int __cil_tmp1 ;
  int *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 418
  __cil_tmp1 = strcmp((char const   *)outname, (char const   *)((char *)"-"));
  }
#line 418
  if (__cil_tmp1 == 0) {
#line 419
    outfile = stdout;
  } else {
    {
#line 421
    outfile = fopen((char const   *)outname, (char const   *)((char *)"w"));
    }
#line 422
    if (! outfile) {
      {
#line 423
      __cil_tmp3 = __errno_location();
      }
      {
#line 423
      __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"cannot open file `%s\'"),
                             5);
#line 423
      error(1, *__cil_tmp3, (char const   *)__cil_tmp4, outname);
      }
    }
  }
  {
#line 426
  set_level_mark(0, 0);
  }
#line 427
  if (print_option & 1) {
    {
#line 428
    xref_output();
    }
  }
#line 430
  if (print_option & 2) {
    {
#line 431
    tree_output();
    }
  }
  {
#line 433
  fclose(outfile);
  }
}
}
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 153 "./cflow.h"
int record_defines ;
#line 160
int print_as_tree ;
#line 168
int preprocess_option ;
#line 176
unsigned int input_file_count ;
#line 205
int source(char *name ) ;
#line 206
void init_lex(int debug_level ) ;
#line 207
void set_preprocessor(char const   *arg___0 ) ;
#line 208
void pp_option(char const   *arg___0 ) ;
#line 247
int gnu_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line , void *data ,
                       void *handler_data ) ;
#line 26 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char const   *argp_program_bug_address  =    (char const   *)((char *)"<bug-cflow@gnu.org>");
#line 27 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static char doc[]  =    "generate a program flowgraph\v* The effect of each option marked with an asterisk is reversed if the option\'s long name is prefixed with `no-\'. For example, --no-cpp cancels --cpp.";
#line 30 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char const   *program_authors[]  = {      (char const   *)((char *)"Sergey Poznyakoff"),      (char const   *)((void *)0)};
#line 57 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static struct argp_option options[]  = 
#line 57
  {      {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((char *)"General options:"),
      0}, 
        {(char const   *)((char *)"depth"), 'd', (char const   *)((char *)"NUMBER"),
      0, (char const   *)((char *)"Set the depth at which the flowgraph is cut off"),
      1}, 
        {(char const   *)((char *)"include"), 'i', (char const   *)((char *)"CLASSES"),
      0, (char const   *)((char *)"Include specified classes of symbols (see below). Prepend CLASSES with ^ or - to exclude them from the output"),
      1}, 
        {(char const   *)((char *)"format"), 'f', (char const   *)((char *)"NAME"), 0,
      (char const   *)((char *)"Use given output format NAME. Valid names are `gnu\' (default) and `posix\'"),
      1}, 
        {(char const   *)((char *)"reverse"), 'r', (char const   *)((void *)0), 0, (char const   *)((char *)"* Print reverse call tree"),
      1}, 
        {(char const   *)((char *)"xref"), 'x', (char const   *)((void *)0), 0, (char const   *)((char *)"Produce cross-reference listing only"),
      1}, 
        {(char const   *)((char *)"print"), 'P', (char const   *)((char *)"OPT"), 2,
      (char const   *)((char *)"Set printing option to OPT. Valid OPT values are: xref (or cross-ref), tree. Any unambiguous abbreviation of the above is also accepted"),
      1}, 
        {(char const   *)((char *)"output"), 'o', (char const   *)((char *)"FILE"), 0,
      (char const   *)((char *)"Set output file name (default -, meaning stdout)"),
      1}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((char *)"Symbols classes for --include argument"),
      2}, 
        {(char const   *)((char *)"  x"), 0, (char const   *)((void *)0), 40, (char const   *)((char *)"all data symbols, both external and static"),
      3}, 
        {(char const   *)((char *)"  _"), 0, (char const   *)((void *)0), 40, (char const   *)((char *)"symbols whose names begin with an underscore"),
      3}, 
        {(char const   *)((char *)"  s"), 0, (char const   *)((void *)0), 40, (char const   *)((char *)"static symbols"),
      3}, 
        {(char const   *)((char *)"  t"), 0, (char const   *)((void *)0), 40, (char const   *)((char *)"typedefs (for cross-references only)"),
      3}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((char *)"Parser control:"),
      10}, 
        {(char const   *)((char *)"use-indentation"), 'S', (char const   *)((void *)0),
      0, (char const   *)((char *)"* Rely on indentation"), 11}, 
        {(char const   *)((char *)"no-use-indentation"), 262, (char const   *)((void *)0),
      2, (char const   *)((char *)""), 11}, 
        {(char const   *)((char *)"ansi"), 'a', (char const   *)((void *)0), 0, (char const   *)((char *)"* Accept only sources in ANSI C"),
      11}, 
        {(char const   *)((char *)"no-ansi"), 263, (char const   *)((void *)0), 2, (char const   *)((char *)""),
      11}, 
        {(char const   *)((char *)"pushdown"), 'p', (char const   *)((char *)"NUMBER"),
      0, (char const   *)((char *)"Set initial token stack size to NUMBER"), 11}, 
        {(char const   *)((char *)"symbol"), 's', (char const   *)((char *)"SYMBOL:[=]TYPE"),
      0, (char const   *)((char *)"Register SYMBOL with given TYPE, or define an alias (if := is used). Valid types are: keyword (or kw), modifier, qualifier, identifier, type, wrapper. Any unambiguous abbreviation of the above is also accepted"),
      11}, 
        {(char const   *)((char *)"main"), 'm', (char const   *)((char *)"NAME"), 0,
      (char const   *)((char *)"Assume main function to be called NAME"), 11}, 
        {(char const   *)((char *)"define"), 'D', (char const   *)((char *)"NAME[=DEFN]"),
      0, (char const   *)((char *)"Predefine NAME as a macro"), 11}, 
        {(char const   *)((char *)"undefine"), 'U', (char const   *)((char *)"NAME"),
      0, (char const   *)((char *)"Cancel any previous definition of NAME"), 11}, 
        {(char const   *)((char *)"include-dir"), 'I', (char const   *)((char *)"DIR"),
      0, (char const   *)((char *)"Add the directory DIR to the list of directories to be searched for header files."),
      11}, 
        {(char const   *)((char *)"preprocess"), 259, (char const   *)((char *)"COMMAND"),
      1, (char const   *)((char *)"* Run the specified preprocessor command"), 11}, 
        {(char const   *)((char *)"cpp"),
      0, (char const   *)((void *)0), 4, (char const   *)((void *)0), 11}, 
        {(char const   *)((char *)"no-preprocess"), 260, (char const   *)((void *)0),
      2, (char const   *)((char *)""), 11}, 
        {(char const   *)((char *)"no-cpp"), 0, (char const   *)((void *)0), 6, (char const   *)((void *)0),
      11}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((char *)"Output control:"),
      20}, 
        {(char const   *)((char *)"number"), 'n', (char const   *)((void *)0), 0, (char const   *)((char *)"* Print line numbers"),
      21}, 
        {(char const   *)((char *)"no-number"), 268, (char const   *)((void *)0), 2,
      (char const   *)((char *)""), 21}, 
        {(char const   *)((char *)"print-level"), 'l', (char const   *)((void *)0), 0,
      (char const   *)((char *)"* Print nesting level along with the call tree"),
      21}, 
        {(char const   *)((char *)"no-print-level"), 269, (char const   *)((void *)0),
      2, (char const   *)((char *)""), 21}, 
        {(char const   *)((char *)"level-indent"), 257, (char const   *)((char *)"ELEMENT"),
      0, (char const   *)((char *)"Control graph appearance"), 21}, 
        {(char const   *)((char *)"tree"), 'T', (char const   *)((void *)0), 0, (char const   *)((char *)"* Draw ASCII art tree"),
      21}, 
        {(char const   *)((char *)"no-tree"), 264, (char const   *)((void *)0), 2, (char const   *)((char *)""),
      21}, 
        {(char const   *)((char *)"brief"), 'b', (char const   *)((void *)0), 0, (char const   *)((char *)"* Brief output"),
      21}, 
        {(char const   *)((char *)"no-brief"), 265, (char const   *)((void *)0), 2, (char const   *)((char *)""),
      21}, 
        {(char const   *)((char *)"emacs"), 261, (char const   *)((void *)0), 0, (char const   *)((char *)"* Additionally format output for use with GNU Emacs"),
      21}, 
        {(char const   *)((char *)"no-emacs"), 266, (char const   *)((void *)0), 2, (char const   *)((char *)""),
      21}, 
        {(char const   *)((char *)"omit-arguments"), 271, (char const   *)((void *)0),
      0, (char const   *)((char *)"* Do not print argument lists in function declarations"),
      21}, 
        {(char const   *)((char *)"no-ignore-arguments"), 272, (char const   *)((void *)0),
      2, (char const   *)((char *)""), 21}, 
        {(char const   *)((char *)"omit-symbol-names"), 273, (char const   *)((void *)0),
      0, (char const   *)((char *)"* Do not print symbol names in declaration strings"),
      21}, 
        {(char const   *)((char *)"no-omit-symbol-names"), 274, (char const   *)((void *)0),
      2, (char const   *)((char *)""), 21}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (char const   *)((char *)"Informational options:"),
      30}, 
        {(char const   *)((char *)"verbose"), 'v', (char const   *)((void *)0), 0, (char const   *)((char *)"* Verbose error diagnostics"),
      31}, 
        {(char const   *)((char *)"no-verbose"), 267, (char const   *)((void *)0), 2,
      (char const   *)((char *)""), 31}, 
        {(char const   *)((char *)"debug"), 258, (char const   *)((char *)"NUMBER"),
      1, (char const   *)((char *)"Set debugging level"), 31}, 
        {(char const   *)0, 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 176 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char *outname  =    (char *)"-";
#line 177 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
int print_option  =    0;
#line 210
int symbol_map ;
#line 212 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char *level_indent[]  = {      (char *)((void *)0),      (char *)((void *)0)};
#line 213 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char *level_end[]  = {      (char *)"",      (char *)""};
#line 214 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char *level_begin  =    (char *)"";
#line 216 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
int preprocess_option  =    0;
#line 218 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char *start_name  =    (char *)"main";
#line 220
struct linked_list *arglist ;
#line 227 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static int find_option_type(struct option_type *optype , char const   *str , int len ) 
{ 
  size_t __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 229
  if (len == 0) {
    {
#line 230
    __cil_tmp4 = strlen(str);
#line 230
    len = (int )__cil_tmp4;
    }
  }
  {
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;

#line 231
    if (! optype->str) {
#line 231
      goto while_break;
    }
    {
#line 232
    __cil_tmp5 = memcmp((void const   *)str, (void const   *)optype->str, (unsigned long )len);
    }
#line 232
    if (len >= optype->min_match) {
#line 232
      if (__cil_tmp5 == 0) {
#line 234
        return (optype->type);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  optype ++;
#line 237
  return (0);
}
}
#line 241 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static struct option_type symbol_optype[]  = 
#line 241
  {      {(char *)"keyword", 2, 257}, 
        {(char *)"kw", 2, 257}, 
        {(char *)"modifier", 1, 265}, 
        {(char *)"identifier", 1, 260}, 
        {(char *)"type", 1, 270}, 
        {(char *)"wrapper", 1, 272}, 
        {(char *)"qualifier", 1, 273}, 
        {(char *)0, 0, 0}};
#line 257 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static void symbol_override(char const   *str ) 
{ 
  char const   *ptr ;
  char *name ;
  Symbol *sp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  Symbol *alias ;
  Symbol *__cil_tmp9 ;
  char *__cil_tmp10 ;
  Symbol *__cil_tmp11 ;
  int type ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 263
  __cil_tmp5 = strchr(str, ':');
#line 263
  ptr = (char const   *)__cil_tmp5;
  }
#line 264
  if (! ptr) {
    {
#line 265
    __cil_tmp6 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: no symbol type supplied"),
                           5);
#line 265
    error(3, 0, (char const   *)__cil_tmp6, str);
    }
  } else {
    {
#line 267
    name = strndup(str, (unsigned long )(ptr - str));
    }
#line 268
    if ((int )((char )*(ptr + 1)) == 61) {
      {
#line 269
      __cil_tmp9 = lookup(ptr + 2);
#line 269
      alias = __cil_tmp9;
      }
#line 270
      if (! alias) {
        {
#line 271
        __cil_tmp10 = xstrdup(ptr + 2);
#line 271
        __cil_tmp11 = install(__cil_tmp10, 1);
#line 271
        alias = __cil_tmp11;
#line 272
        alias->type = (enum symtype )1;
#line 273
        alias->token_type = 0;
#line 274
        alias->source = (char *)((void *)0);
#line 275
        alias->def_line = - 1;
#line 276
        alias->ref_line = (struct linked_list *)((void *)0);
        }
      }
      {
#line 278
      sp = install(name, 1);
#line 279
      sp->type = (enum symtype )1;
#line 280
      sp->alias = alias;
#line 281
      sp->flag = (enum symbol_flag )3;
      }
    } else {
      {
#line 283
      __cil_tmp14 = find_option_type((struct option_type *)symbol_optype, ptr + 1,
                                     0);
#line 283
      type = __cil_tmp14;
      }
#line 284
      if (type == 0) {
        {
#line 285
        __cil_tmp15 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unknown symbol type: %s"),
                                5);
#line 285
        error(3, 0, (char const   *)__cil_tmp15, ptr + 1);
        }
      }
      {
#line 286
      sp = install(name, 1);
#line 287
      sp->type = (enum symtype )1;
#line 288
      sp->token_type = type;
      }
    }
#line 290
    sp->source = (char *)((void *)0);
#line 291
    sp->def_line = - 1;
#line 292
    sp->ref_line = (struct linked_list *)((void *)0);
  }
}
}
#line 297 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static struct option_type print_optype[]  = {      {(char *)"xref", 1, 1}, 
        {(char *)"cross-ref", 1, 1}, 
        {(char *)"tree", 1, 2}, 
        {(char *)0, 0, 0}};
#line 305 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static void set_print_option(char *str ) 
{ 
  int opt ;
  char *__cil_tmp4 ;

  {
  {
#line 309
  opt = find_option_type((struct option_type *)print_optype, (char const   *)str,
                         0);
  }
#line 310
  if (opt == 0) {
    {
#line 311
    __cil_tmp4 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unknown print option: %s"),
                           5);
#line 311
    error(3, 0, (char const   *)__cil_tmp4, str);
    }
#line 312
    return;
  }
#line 314
  print_option |= opt;
}
}
#line 323 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static int number(char const   **str_ptr , int base , int count ) 
{ 
  int c ;
  int n ;
  unsigned int i ;
  char const   *str ;
  char const   *__cil_tmp8 ;
  unsigned short const   **__cil_tmp9 ;
  int __cil_tmp10 ;

  {
#line 327
  str = *str_ptr;
#line 329
  n = 0;
  {
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;

#line 329
    if (! ((int )((char )*str) && count)) {
#line 329
      goto while_break;
    }
    {
#line 330
    __cil_tmp8 = str;
#line 330
    str ++;
#line 330
    c = (int )((char )*__cil_tmp8);
#line 331
    __cil_tmp9 = __ctype_b_loc();
    }
#line 331
    if ((int )((unsigned short )*(*__cil_tmp9 + c)) & 2048) {
#line 332
      i = (unsigned int )(c - 48);
    } else {
#line 334
      i = (unsigned int )-55;
    }
#line 335
    if (i > (unsigned int )base) {
#line 336
      goto while_break;
    }
#line 338
    n = (int )((unsigned int )(n * base) + i);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  __cil_tmp10 = count;
#line 329
  count --;
#line 340
  *str_ptr = str - 1;
#line 341
  return (n);
}
}
#line 366 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static struct option_type level_indent_optype[]  = {      {(char *)"begin", 1, 1}, 
        {(char *)"start", 1, 1}, 
        {(char *)"0", 1, 2}, 
        {(char *)"1", 1, 3}, 
        {(char *)"end0", 4, 4}, 
        {(char *)"end1", 4, 5}};
#line 376 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static void parse_level_string(char const   *str , char **return_ptr ) 
{ 
  static char text[216] ;
  char *p ;
  int i ;
  int c ;
  int num ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  int __cil_tmp18 ;
  char *__cil_tmp19 ;
  long __cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp24 ;
  char const   *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 382
  p = (char *)text;
#line 383
  memset((void *)((char *)text), ' ', sizeof(text));
#line 384
  text[sizeof(text) - 1UL] = (char )0;
  }
  {
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;

#line 386
    if (! ((char )*str)) {
#line 386
      goto while_break;
    }
    {
#line 388
    if ((int )((char )*str) == '\\') {
#line 388
      goto case_92;
    }
#line 390
    if ((int )((char )*str) == 'a') {
#line 390
      goto case_97;
    }
#line 393
    if ((int )((char )*str) == 'b') {
#line 393
      goto case_98;
    }
#line 396
    if ((int )((char )*str) == 'e') {
#line 396
      goto case_101;
    }
#line 399
    if ((int )((char )*str) == 'f') {
#line 399
      goto case_102;
    }
#line 402
    if ((int )((char )*str) == 'n') {
#line 402
      goto case_110;
    }
#line 405
    if ((int )((char )*str) == 'r') {
#line 405
      goto case_114;
    }
#line 408
    if ((int )((char )*str) == 't') {
#line 408
      goto case_116;
    }
#line 412
    if ((int )((char )*str) == 'X') {
#line 412
      goto case_88;
    }
#line 412
    if ((int )((char )*str) == 'x') {
#line 412
      goto case_88;
    }
#line 416
    if ((int )((char )*str) == '0') {
#line 416
      goto case_48;
    }
#line 425
    if ((int )((char )*str) == 'x') {
#line 425
      goto case_120___0;
    }
#line 438
    goto copy;
    case_92: /* CIL Label */ 
#line 389
    str ++;
    {
#line 390
    if ((int )((char )*str) == 'a') {
#line 390
      goto case_97;
    }
#line 393
    if ((int )((char )*str) == 'b') {
#line 393
      goto case_98;
    }
#line 396
    if ((int )((char )*str) == 'e') {
#line 396
      goto case_101;
    }
#line 399
    if ((int )((char )*str) == 'f') {
#line 399
      goto case_102;
    }
#line 402
    if ((int )((char )*str) == 'n') {
#line 402
      goto case_110;
    }
#line 405
    if ((int )((char )*str) == 'r') {
#line 405
      goto case_114;
    }
#line 408
    if ((int )((char )*str) == 't') {
#line 408
      goto case_116;
    }
#line 412
    if ((int )((char )*str) == 'X') {
#line 412
      goto case_88;
    }
#line 412
    if ((int )((char )*str) == 'x') {
#line 412
      goto case_88;
    }
#line 416
    if ((int )((char )*str) == '0') {
#line 416
      goto case_48;
    }
#line 420
    goto switch_default;
    case_97: /* CIL Label */ 
#line 391
    __cil_tmp8 = p;
#line 391
    p ++;
#line 391
    *__cil_tmp8 = (char )'\a';
#line 392
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 394
    __cil_tmp9 = p;
#line 394
    p ++;
#line 394
    *__cil_tmp9 = (char )'\b';
#line 395
    goto switch_break___0;
    case_101: /* CIL Label */ 
#line 397
    __cil_tmp10 = p;
#line 397
    p ++;
#line 397
    *__cil_tmp10 = (char )'\033';
#line 398
    goto switch_break___0;
    case_102: /* CIL Label */ 
#line 400
    __cil_tmp11 = p;
#line 400
    p ++;
#line 400
    *__cil_tmp11 = (char )'\f';
#line 401
    goto switch_break___0;
    case_110: /* CIL Label */ 
#line 403
    __cil_tmp12 = p;
#line 403
    p ++;
#line 403
    *__cil_tmp12 = (char )'\n';
#line 404
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 406
    __cil_tmp13 = p;
#line 406
    p ++;
#line 406
    *__cil_tmp13 = (char )'\r';
#line 407
    goto switch_break___0;
    case_116: /* CIL Label */ 
#line 409
    __cil_tmp14 = p;
#line 409
    p ++;
#line 409
    *__cil_tmp14 = (char )'\t';
#line 410
    goto switch_break___0;
    case_88: /* CIL Label */ 
#line 413
    str ++;
    {
#line 414
    __cil_tmp16 = number(& str, 16, 2);
    }
#line 414
    __cil_tmp15 = p;
#line 414
    p ++;
#line 414
    *__cil_tmp15 = (char )__cil_tmp16;
#line 415
    goto switch_break___0;
    case_48: /* CIL Label */ 
#line 417
    str ++;
    {
#line 418
    __cil_tmp18 = number(& str, 8, 3);
    }
#line 418
    __cil_tmp17 = p;
#line 418
    p ++;
#line 418
    *__cil_tmp17 = (char )__cil_tmp18;
#line 419
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 421
    __cil_tmp19 = p;
#line 421
    p ++;
#line 421
    *__cil_tmp19 = (char )*str;
    switch_break___0: /* CIL Label */ ;
    }
#line 423
    str ++;
#line 424
    goto switch_break;
    case_120___0: /* CIL Label */ 
#line 426
    if (p == (char *)text) {
#line 427
      goto copy;
    }
    {
#line 429
    __cil_tmp20 = strtol(str + 1, (char **)(& str), 10);
#line 429
    num = (int )__cil_tmp20;
#line 430
    c = (int )*(p + - 1);
#line 431
    i = 1;
    }
    {
    {
#line 431
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 431
      if (! (i < num)) {
#line 431
        goto while_break___0;
      }
#line 432
      __cil_tmp21 = p;
#line 432
      p ++;
#line 432
      *__cil_tmp21 = (char )c;
#line 433
      if ((int )*p == 0) {
        {
#line 434
        __cil_tmp22 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"level indent string is too long"),
                                5);
#line 434
        error(3, 0, (char const   *)__cil_tmp22);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 431
    i ++;
#line 437
    goto switch_break;
    copy: 
#line 440
    __cil_tmp25 = str;
#line 440
    str ++;
#line 440
    __cil_tmp24 = p;
#line 440
    p ++;
#line 440
    *__cil_tmp24 = (char )*__cil_tmp25;
#line 441
    if ((int )*p == 0) {
      {
#line 442
      __cil_tmp26 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"level indent string is too long"),
                              5);
#line 442
      error(3, 0, (char const   *)__cil_tmp26);
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 445
  *p = (char )0;
#line 446
  *return_ptr = strdup((char const   *)((char *)text));
  }
}
}
#line 450 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static void set_level_indent(char const   *str ) 
{ 
  long n ;
  char const   *p ;
  char *q ;
  char *s ;
  void *__cil_tmp7 ;
  char *__cil_tmp8 ;
  int __cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 456
  n = strtol(str, & q, 0);
  }
#line 457
  if ((int )*q == 0) {
#line 457
    if (n > 0L) {
      {
#line 458
      __cil_tmp7 = xmalloc((size_t )(n + 1L));
#line 458
      s = (char *)__cil_tmp7;
#line 459
      memset((void *)s, ' ', (unsigned long )(n - 1L));
#line 460
      *(s + (n - 1L)) = (char )0;
#line 461
      level_indent[1] = s;
#line 461
      level_indent[0] = level_indent[1];
      }
#line 462
      return;
    }
  }
#line 465
  p = str;
  {
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;

#line 466
    if (! ((int )((char )*p) != 61)) {
#line 466
      goto while_break;
    }
#line 467
    if ((int )((char )*p) == 0) {
      {
#line 468
      __cil_tmp8 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"level-indent syntax"),
                             5);
#line 468
      error(3, 0, (char const   *)__cil_tmp8);
      }
    }
#line 469
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 471
  p ++;
#line 473
  __cil_tmp10 = find_option_type((struct option_type *)level_indent_optype, str, (int )((p - str) - 1L));
  }
  {
#line 474
  if (__cil_tmp10 == 1) {
#line 474
    goto case_1;
  }
#line 477
  if (__cil_tmp10 == 2) {
#line 477
    goto case_2;
  }
#line 480
  if (__cil_tmp10 == 3) {
#line 480
    goto case_3;
  }
#line 483
  if (__cil_tmp10 == 4) {
#line 483
    goto case_4;
  }
#line 486
  if (__cil_tmp10 == 5) {
#line 486
    goto case_5;
  }
#line 489
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 475
  parse_level_string(p, & level_begin);
  }
#line 476
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 478
  parse_level_string(p, & level_indent[0]);
  }
#line 479
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 481
  parse_level_string(p, & level_indent[1]);
  }
#line 482
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 484
  parse_level_string(p, & level_end[0]);
  }
#line 485
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 487
  parse_level_string(p, & level_end[1]);
  }
#line 488
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 490
  __cil_tmp11 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unknown level indent option: %s"),
                          5);
#line 490
  error(3, 0, (char const   *)__cil_tmp11, str);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 495 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static void add_name(char const   *name ) 
{ 


  {
  {
#line 497
  linked_list_append(& arglist, (void *)name);
  }
}
}
#line 501 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static void add_preproc_option(int key , char const   *arg___0 ) 
{ 
  char *opt ;
  size_t __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 503
  __cil_tmp4 = strlen(arg___0);
#line 503
  __cil_tmp5 = xmalloc(3UL + __cil_tmp4);
#line 503
  opt = (char *)__cil_tmp5;
#line 504
  sprintf(opt, (char const   *)((char *)"-%c%s"), key, arg___0);
#line 505
  add_name((char const   *)opt);
#line 506
  preprocess_option = 1;
  }
}
}
#line 510 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static error_t parse_opt(int key , char *arg___0 , struct argp_state *state ) 
{ 
  int num ;
  int __cil_tmp5 ;
  int tmp ;
  int __cil_tmp8 ;
  char *__cil_tmp9 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  char *__cil_tmp20 ;
  char *tmp___110 ;

  {
  {
#line 515
  if (key == 'a') {
#line 515
    goto case_97;
  }
#line 518
  if (key == 263) {
#line 518
    goto case_263;
  }
#line 521
  if (key == 258) {
#line 521
    goto case_258;
  }
#line 524
  if (key == 'P') {
#line 524
    goto case_80;
  }
#line 527
  if (key == 'S') {
#line 527
    goto case_83;
  }
#line 530
  if (key == 262) {
#line 530
    goto case_262;
  }
#line 533
  if (key == 'T') {
#line 533
    goto case_84;
  }
#line 540
  if (key == 264) {
#line 540
    goto case_264;
  }
#line 545
  if (key == 'b') {
#line 545
    goto case_98;
  }
#line 548
  if (key == 265) {
#line 548
    goto case_265;
  }
#line 551
  if (key == 'd') {
#line 551
    goto case_100;
  }
#line 556
  if (key == 256) {
#line 556
    goto case_256;
  }
#line 559
  if (key == 261) {
#line 559
    goto case_261;
  }
#line 562
  if (key == 266) {
#line 562
    goto case_266;
  }
#line 565
  if (key == 'f') {
#line 565
    goto case_102;
  }
#line 570
  if (key == 257) {
#line 570
    goto case_257;
  }
#line 573
  if (key == 'i') {
#line 573
    goto case_105;
  }
#line 578
  if (key == '^') {
#line 578
    goto case_94;
  }
#line 578
  if (key == '-') {
#line 578
    goto case_94;
  }
#line 581
  if (key == '+') {
#line 581
    goto case_43;
  }
#line 588
  if (key == 'u') {
#line 588
    goto case_117;
  }
#line 588
  if (key == 't') {
#line 588
    goto case_117;
  }
#line 588
  if (key == 's') {
#line 588
    goto case_117;
  }
#line 588
  if (key == '_') {
#line 588
    goto case_117;
  }
#line 588
  if (key == 'x') {
#line 588
    goto case_117;
  }
#line 598
  if (key == 271) {
#line 598
    goto case_271;
  }
#line 601
  if (key == 272) {
#line 601
    goto case_272;
  }
#line 604
  if (key == 273) {
#line 604
    goto case_273;
  }
#line 607
  if (key == 274) {
#line 607
    goto case_274;
  }
#line 610
  if (key == 'l') {
#line 610
    goto case_108;
  }
#line 613
  if (key == 269) {
#line 613
    goto case_269;
  }
#line 616
  if (key == 'm') {
#line 616
    goto case_109;
  }
#line 619
  if (key == 'n') {
#line 619
    goto case_110;
  }
#line 622
  if (key == 268) {
#line 622
    goto case_268;
  }
#line 625
  if (key == 'o') {
#line 625
    goto case_111;
  }
#line 628
  if (key == 'p') {
#line 628
    goto case_112;
  }
#line 633
  if (key == 'r') {
#line 633
    goto case_114;
  }
#line 636
  if (key == 270) {
#line 636
    goto case_270;
  }
#line 639
  if (key == 's') {
#line 639
    goto case_115___0;
  }
#line 642
  if (key == 'v') {
#line 642
    goto case_118;
  }
#line 645
  if (key == 267) {
#line 645
    goto case_267;
  }
#line 648
  if (key == 'x') {
#line 648
    goto case_120___0;
  }
#line 651
  if (key == 259) {
#line 651
    goto case_259;
  }
#line 655
  if (key == 260) {
#line 655
    goto case_260;
  }
#line 658
  if (key == 0) {
#line 658
    goto case_0;
  }
#line 663
  if (key == 'U') {
#line 663
    goto case_85;
  }
#line 663
  if (key == 'D') {
#line 663
    goto case_85;
  }
#line 663
  if (key == 'I') {
#line 663
    goto case_85;
  }
#line 666
  goto switch_default___0;
  case_97: /* CIL Label */ 
#line 516
  strict_ansi = 1;
#line 517
  goto switch_break;
  case_263: /* CIL Label */ 
#line 519
  strict_ansi = 0;
#line 520
  goto switch_break;
  case_258: /* CIL Label */ 
#line 522
  if (arg___0) {
    {
#line 522
    __cil_tmp5 = atoi((char const   *)arg___0);
#line 522
    tmp = __cil_tmp5;
    }
  } else {
#line 522
    tmp = 1;
  }
#line 522
  debug = tmp;
#line 523
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 525
  set_print_option(arg___0);
  }
#line 526
  goto switch_break;
  case_83: /* CIL Label */ 
#line 528
  use_indentation = 1;
#line 529
  goto switch_break;
  case_262: /* CIL Label */ 
#line 531
  use_indentation = 0;
#line 532
  goto switch_break;
  case_84: /* CIL Label */ 
#line 534
  print_as_tree = 1;
  {
#line 535
  set_level_indent((char const   *)((char *)"0=  "));
#line 536
  set_level_indent((char const   *)((char *)"1=| "));
#line 537
  set_level_indent((char const   *)((char *)"end0=+-"));
#line 538
  set_level_indent((char const   *)((char *)"end1=\\\\-"));
  }
#line 539
  goto switch_break;
  case_264: /* CIL Label */ 
#line 541
  print_as_tree = 0;
#line 542
  level_indent[1] = (char *)((void *)0);
#line 542
  level_indent[0] = level_indent[1];
#line 543
  level_end[1] = (char *)((void *)0);
#line 543
  level_end[0] = level_end[1];
#line 544
  goto switch_break;
  case_98: /* CIL Label */ 
#line 546
  brief_listing = 1;
#line 547
  goto switch_break;
  case_265: /* CIL Label */ 
#line 549
  brief_listing = 0;
#line 550
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 552
  max_depth = atoi((char const   *)arg___0);
  }
#line 553
  if (max_depth < 0) {
#line 554
    max_depth = 0;
  }
#line 555
  goto switch_break;
  case_256: /* CIL Label */ 
#line 557
  record_defines = 1;
#line 558
  goto switch_break;
  case_261: /* CIL Label */ 
#line 560
  emacs_option = 1;
#line 561
  goto switch_break;
  case_266: /* CIL Label */ 
#line 563
  emacs_option = 0;
#line 564
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 566
  __cil_tmp8 = select_output_driver((char const   *)arg___0);
  }
#line 566
  if (__cil_tmp8) {
    {
#line 567
    __cil_tmp9 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"%s: No such output driver"),
                           5);
#line 567
    error(3, 0, (char const   *)__cil_tmp9, rpl_optarg);
    }
  }
  {
#line 568
  output_init();
  }
#line 569
  goto switch_break;
  case_257: /* CIL Label */ 
  {
#line 571
  set_level_indent((char const   *)arg___0);
  }
#line 572
  goto switch_break;
  case_105: /* CIL Label */ 
#line 574
  num = 1;
  {
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;

#line 575
    if (! *arg___0) {
#line 575
      goto while_break;
    }
    {
#line 578
    if ((int )*arg___0 == '^') {
#line 578
      goto case_94;
    }
#line 578
    if ((int )*arg___0 == '-') {
#line 578
      goto case_94;
    }
#line 581
    if ((int )*arg___0 == '+') {
#line 581
      goto case_43;
    }
#line 588
    if ((int )*arg___0 == 'u') {
#line 588
      goto case_117;
    }
#line 588
    if ((int )*arg___0 == 't') {
#line 588
      goto case_117;
    }
#line 588
    if ((int )*arg___0 == 's') {
#line 588
      goto case_117;
    }
#line 588
    if ((int )*arg___0 == '_') {
#line 588
      goto case_117;
    }
#line 588
    if ((int )*arg___0 == 'x') {
#line 588
      goto case_117;
    }
#line 594
    goto switch_default;
    case_94: /* CIL Label */ 
#line 579
    num = 0;
#line 580
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 582
    num = 1;
#line 583
    goto switch_break___0;
    case_117: /* CIL Label */ 
#line 589
    if (num) {
#line 590
      if ((int )*arg___0 == 120) {
#line 590
        tmp___104 = 2;
      } else {
#line 590
        if ((int )*arg___0 == 95) {
#line 590
          tmp___103 = 8;
        } else {
#line 590
          if ((int )*arg___0 == 115) {
#line 590
            tmp___102 = 4;
          } else {
#line 590
            if ((int )*arg___0 == 116) {
#line 590
              tmp___101 = 16;
            } else {
#line 590
              if ((int )*arg___0 == 117) {
#line 590
                tmp___100 = 32;
              } else {
#line 590
                tmp___100 = 0;
              }
#line 590
              tmp___101 = tmp___100;
            }
#line 590
            tmp___102 = tmp___101;
          }
#line 590
          tmp___103 = tmp___102;
        }
#line 590
        tmp___104 = tmp___103;
      }
#line 590
      symbol_map |= tmp___104;
    } else {
#line 592
      if ((int )*arg___0 == 120) {
#line 592
        tmp___109 = 2;
      } else {
#line 592
        if ((int )*arg___0 == 95) {
#line 592
          tmp___108 = 8;
        } else {
#line 592
          if ((int )*arg___0 == 115) {
#line 592
            tmp___107 = 4;
          } else {
#line 592
            if ((int )*arg___0 == 116) {
#line 592
              tmp___106 = 16;
            } else {
#line 592
              if ((int )*arg___0 == 117) {
#line 592
                tmp___105 = 32;
              } else {
#line 592
                tmp___105 = 0;
              }
#line 592
              tmp___106 = tmp___105;
            }
#line 592
            tmp___107 = tmp___106;
          }
#line 592
          tmp___108 = tmp___107;
        }
#line 592
        tmp___109 = tmp___108;
      }
#line 592
      symbol_map &= ~ tmp___109;
    }
#line 593
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 595
    __cil_tmp20 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Unknown symbol class: %c"),
                            5);
#line 595
    error(3, 0, (char const   *)__cil_tmp20, (int )*arg___0);
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 575
  arg___0 ++;
#line 597
  goto switch_break;
  case_271: /* CIL Label */ 
#line 599
  omit_arguments_option = 1;
#line 600
  goto switch_break;
  case_272: /* CIL Label */ 
#line 602
  omit_arguments_option = 0;
#line 603
  goto switch_break;
  case_273: /* CIL Label */ 
#line 605
  omit_symbol_names_option = 1;
#line 606
  goto switch_break;
  case_274: /* CIL Label */ 
#line 608
  omit_symbol_names_option = 0;
#line 609
  goto switch_break;
  case_108: /* CIL Label */ 
#line 611
  print_levels = 1;
#line 612
  goto switch_break;
  case_269: /* CIL Label */ 
#line 614
  print_levels = 0;
#line 615
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 617
  start_name = strdup((char const   *)arg___0);
  }
#line 618
  goto switch_break;
  case_110: /* CIL Label */ 
#line 620
  print_line_numbers = 1;
#line 621
  goto switch_break;
  case_268: /* CIL Label */ 
#line 623
  print_line_numbers = 0;
#line 624
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 626
  outname = strdup((char const   *)arg___0);
  }
#line 627
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 629
  num = atoi((char const   *)arg___0);
  }
#line 630
  if (num > 0) {
#line 631
    token_stack_length = num;
  }
#line 632
  goto switch_break;
  case_114: /* CIL Label */ 
#line 634
  reverse_tree = 1;
#line 635
  goto switch_break;
  case_270: /* CIL Label */ 
#line 637
  reverse_tree = 0;
#line 638
  goto switch_break;
  case_115___0: /* CIL Label */ 
  {
#line 640
  symbol_override((char const   *)arg___0);
  }
#line 641
  goto switch_break;
  case_118: /* CIL Label */ 
#line 643
  verbose = 1;
#line 644
  goto switch_break;
  case_267: /* CIL Label */ 
#line 646
  verbose = 0;
#line 647
  goto switch_break;
  case_120___0: /* CIL Label */ 
#line 649
  print_option = 1;
#line 650
  goto switch_break;
  case_259: /* CIL Label */ 
#line 652
  preprocess_option = 1;
#line 653
  if (arg___0) {
#line 653
    tmp___110 = arg___0;
  } else {
#line 653
    tmp___110 = (char *)"/usr/bin/cpp";
  }
  {
#line 653
  set_preprocessor((char const   *)tmp___110);
  }
#line 654
  goto switch_break;
  case_260: /* CIL Label */ 
#line 656
  preprocess_option = 0;
#line 657
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 659
  add_name((char const   *)arg___0);
  }
#line 660
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 664
  add_preproc_option(key, (char const   *)arg___0);
  }
#line 665
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 667
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 669
  return (0);
}
}
#line 672 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
static struct argp argp  =    {(struct argp_option *)options, parse_opt, (char const   *)((char *)"[FILE]..."),
    (char const   *)((char *)doc), (struct argp_child *)((void *)0), (void *)0, (char const   *)((void *)0)};
#line 683 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
int globals_only(void) 
{ 


  {
#line 685
  return (! (symbol_map & 4));
}
}
#line 689 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
int include_symbol(Symbol *sym ) 
{ 
  int type ;

  {
#line 691
  type = 0;
#line 693
  if (! sym) {
#line 694
    return (0);
  }
#line 696
  if ((unsigned int )sym->type == 2U) {
#line 697
    if ((int )*(sym->name + 0) == 95) {
#line 697
      if (! (symbol_map & 8)) {
#line 698
        return (0);
      }
    }
#line 700
    if ((unsigned int )sym->storage == 2U) {
#line 701
      type |= 4;
    }
#line 702
    if (sym->arity == -1) {
#line 702
      if ((unsigned int )sym->storage != 3U) {
#line 703
        type |= 2;
      } else {
#line 702
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 704
    if (sym->arity >= 0) {
#line 705
      type |= 1;
    }
#line 707
    if (! sym->source) {
#line 708
      type |= 32;
    }
  } else
#line 710
  if ((unsigned int )sym->type == 1U) {
#line 711
    if (sym->token_type == 270) {
#line 711
      if (sym->source) {
#line 712
        type |= 16;
      } else {
#line 714
        return (0);
      }
    } else {
#line 714
      return (0);
    }
  }
#line 716
  return ((symbol_map & type) == type);
}
}
#line 726 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
void init(void) 
{ 


  {
#line 728
  if (level_indent[0] == (char *)((void *)0)) {
#line 729
    level_indent[0] = (char *)"    ";
  }
#line 730
  if (level_indent[1] == (char *)((void *)0)) {
#line 731
    level_indent[1] = level_indent[0];
  }
#line 732
  if (level_end[0] == (char *)((void *)0)) {
#line 733
    level_end[0] = (char *)"";
  }
#line 734
  if (level_end[1] == (char *)((void *)0)) {
#line 735
    level_end[1] = (char *)"";
  }
  {
#line 737
  init_lex(debug > 2);
#line 738
  init_parse();
  }
}
}
#line 741 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
char const   version_etc_copyright[]  =    "Copyright %s 2005, 2006, 2009, 2010, 2011, 2014 %d Sergey Poznyakoff";
#line 748 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/main.c"
int main(int argc , char **argv ) 
{ 
  int index___111 ;
  int status ;
  char *__cil_tmp5 ;
  int __cil_tmp6 ;
  char *__cil_tmp7 ;
  error_t __cil_tmp8 ;
  struct linked_list_entry *p ;
  char *s ;
  int __cil_tmp11 ;
  int __cil_tmp12 ;
  char **__cil_tmp13 ;
  int __cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 751
  status = 0;
#line 753
  set_program_name((char const   *)*(argv + 0));
#line 754
  argp_version_setup((char const   *)((char *)"cflow"), (char const   * const  *)((char const   **)program_authors));
#line 756
  setlocale(6, (char const   *)((char *)""));
#line 757
  bindtextdomain((char const   *)((char *)"cflow"), (char const   *)((char *)"/usr/local/share/locale"));
#line 758
  textdomain((char const   *)((char *)"cflow"));
#line 760
  register_output((char const   *)((char *)"gnu"), gnu_output_handler, (void *)0);
#line 761
  register_output((char const   *)((char *)"posix"), posix_output_handler, (void *)0);
#line 763
  symbol_map = 37;
#line 765
  __cil_tmp5 = getenv((char const   *)((char *)"POSIXLY_CORRECT"));
  }
#line 765
  if (__cil_tmp5) {
    {
#line 766
    __cil_tmp6 = select_output_driver((char const   *)((char *)"posix"));
    }
#line 766
    if (__cil_tmp6) {
      {
#line 767
      __cil_tmp7 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"INTERNAL ERROR: %s: No such output driver"),
                             5);
#line 767
      error(0, 0, (char const   *)__cil_tmp7, (char *)"posix");
#line 769
      abort();
      }
    }
    {
#line 771
    output_init();
    }
  }
  {
#line 774
  sourcerc(& argc, & argv);
#line 775
  __cil_tmp8 = argp_parse(& argp, argc, argv, (unsigned int )8, & index___111, (void *)0);
  }
#line 775
  if (__cil_tmp8) {
    {
#line 776
    exit(3);
    }
  }
#line 778
  if (print_option == 0) {
#line 779
    print_option = 2;
  }
  {
#line 781
  init();
  }
#line 783
  if (arglist) {
#line 786
    p = arglist->head;
    {
    {
#line 786
    while (1) {
      while_continue: /* CIL Label */ ;

#line 786
      if (! p) {
#line 786
        goto while_break;
      }
#line 787
      s = (char *)p->data;
#line 788
      if ((int )*(s + 0) == 45) {
        {
#line 789
        pp_option((char const   *)s);
        }
      } else {
        {
#line 790
        __cil_tmp11 = source(s);
        }
#line 790
        if (__cil_tmp11 == 0) {
          {
#line 791
          yyparse();
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 786
    p = p->next;
  }
#line 795
  argc -= index___111;
#line 796
  argv += index___111;
  {
  {
#line 798
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 798
    if (! __cil_tmp12) {
#line 798
      goto while_break___0;
    }
    {
#line 799
    __cil_tmp13 = argv;
#line 799
    argv ++;
#line 799
    __cil_tmp14 = source(*__cil_tmp13);
    }
#line 799
    if (__cil_tmp14 == 0) {
      {
#line 800
      yyparse();
      }
    } else {
#line 802
      status = 2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 805
  if (input_file_count == 0U) {
    {
#line 806
    __cil_tmp15 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"no input files"),
                            5);
#line 806
    error(3, 0, (char const   *)__cil_tmp15);
    }
  }
  {
#line 808
  output();
  }
#line 809
  return (status);
}
}
#line 20 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/linked-list.c"
static struct linked_list *deref_linked_list(struct linked_list **plist ) 
{ 
  struct linked_list *list ;
  void *__cil_tmp3 ;

  {
#line 22
  if (! *plist) {
    {
#line 23
    __cil_tmp3 = xmalloc(sizeof(*list));
#line 23
    list = (struct linked_list *)__cil_tmp3;
#line 24
    list->free_data = (linked_list_free_data_fp )((void *)0);
#line 25
    list->tail = (struct linked_list_entry *)((void *)0);
#line 25
    list->head = list->tail;
#line 26
    *plist = list;
    }
  }
#line 28
  return (*plist);
}
}
#line 33 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/linked-list.c"
struct linked_list *linked_list_create(linked_list_free_data_fp fun ) 
{ 
  struct linked_list *list ;
  void *__cil_tmp3 ;

  {
  {
#line 35
  __cil_tmp3 = xmalloc(sizeof(*list));
#line 35
  list = (struct linked_list *)__cil_tmp3;
#line 36
  list->free_data = fun;
#line 37
  list->tail = (struct linked_list_entry *)((void *)0);
#line 37
  list->head = list->tail;
  }
#line 38
  return (list);
}
}
#line 42 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/linked-list.c"
void linked_list_append(struct linked_list **plist , void *data ) 
{ 
  struct linked_list *list ;
  struct linked_list *__cil_tmp4 ;
  struct linked_list_entry *entry ;
  void *__cil_tmp6 ;

  {
  {
#line 44
  __cil_tmp4 = deref_linked_list(plist);
#line 44
  list = __cil_tmp4;
#line 45
  __cil_tmp6 = xmalloc(sizeof(*entry));
#line 45
  entry = (struct linked_list_entry *)__cil_tmp6;
#line 47
  entry->list = list;
#line 48
  entry->data = data;
#line 49
  entry->next = (struct linked_list_entry *)((void *)0);
#line 50
  entry->prev = list->tail;
  }
#line 51
  if (list->tail) {
#line 52
    (list->tail)->next = entry;
  } else {
#line 54
    list->head = entry;
  }
#line 55
  list->tail = entry;
}
}
#line 78 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/linked-list.c"
void linked_list_destroy(struct linked_list **plist ) 
{ 
  struct linked_list *list ;
  struct linked_list_entry *p ;
  struct linked_list_entry *next ;

  {
#line 80
  if (plist) {
#line 80
    if (*plist) {
#line 81
      list = *plist;
#line 84
      p = list->head;
      {
      {
#line 84
      while (1) {
        while_continue: /* CIL Label */ ;

#line 84
        if (! p) {
#line 84
          goto while_break;
        }
#line 85
        next = p->next;
#line 86
        if (list->free_data) {
          {
#line 87
          (list->free_data)(p->data);
          }
        }
        {
#line 88
        free((void *)p);
#line 89
        p = next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 91
      free((void *)list);
#line 92
      *plist = (struct linked_list *)((void *)0);
      }
    }
  }
}
}
#line 97 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/linked-list.c"
void linked_list_unlink(struct linked_list *list , struct linked_list_entry *ent ) 
{ 
  struct linked_list_entry *p ;

  {
#line 101
  p = ent->prev;
#line 101
  if (p) {
#line 102
    p->next = ent->next;
  } else {
#line 104
    list->head = ent->next;
  }
#line 106
  p = ent->next;
#line 106
  if (p) {
#line 107
    p->prev = ent->prev;
  } else {
#line 109
    list->tail = ent->prev;
  }
#line 110
  if (list->free_data) {
    {
#line 111
    (list->free_data)(ent->data);
    }
  }
  {
#line 112
  free((void *)ent);
  }
}
}
#line 116 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/linked-list.c"
void linked_list_iterate(struct linked_list **plist , int (*itr)(void * , void * ) ,
                         void *data ) 
{ 
  struct linked_list *list ;
  struct linked_list_entry *p ;
  struct linked_list_entry *tmp ;
  struct linked_list_entry *next ;
  int __cil_tmp8 ;

  {
#line 122
  if (! *plist) {
#line 123
    return;
  }
#line 124
  list = *plist;
#line 125
  if (list) {
#line 125
    tmp = list->head;
  } else {
#line 125
    tmp = (struct linked_list_entry *)((void *)0);
  }
#line 125
  p = tmp;
  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;

#line 125
    if (! p) {
#line 125
      goto while_break;
    }
    {
#line 126
    next = p->next;
#line 128
    __cil_tmp8 = itr(p->data, data);
    }
#line 128
    if (__cil_tmp8) {
      {
#line 129
      linked_list_unlink(list, p);
      }
    }
#line 130
    p = next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 132
  if (! list->head) {
    {
#line 133
    linked_list_destroy(& list);
    }
  }
#line 134
  *plist = list;
}
}
#line 138 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/linked-list.c"
int data_in_list(void *data , struct linked_list *list ) 
{ 
  struct linked_list_entry *p ;
  struct linked_list_entry *tmp ;

  {
#line 142
  if (list) {
#line 142
    tmp = list->head;
  } else {
#line 142
    tmp = (struct linked_list_entry *)((void *)0);
  }
#line 142
  p = tmp;
  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;

#line 142
    if (! p) {
#line 142
      goto while_break;
    }
#line 143
    if (p->data == data) {
#line 144
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  p = p->next;
#line 145
  return (0);
}
}
#line 20 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/gnu.c"
void print_function_name(Symbol *sym , int has_subtree ) 
{ 


  {
  {
#line 22
  fprintf(outfile, (char const   *)((char *)"%s"), sym->name);
  }
#line 23
  if (sym->arity >= 0) {
    {
#line 24
    fprintf(outfile, (char const   *)((char *)"()"));
    }
  }
#line 25
  if (sym->decl) {
    {
#line 26
    fprintf(outfile, (char const   *)((char *)" <%s at %s:%d>"), sym->decl, sym->source,
            sym->def_line);
    }
  }
#line 30
  if (sym->active) {
    {
#line 31
    fprintf(outfile, (char const   *)((char *)" (recursive: see %d)"), sym->active - 1);
    }
#line 32
    return;
  }
#line 34
  if (sym->recursive) {
    {
#line 35
    fprintf(outfile, (char const   *)((char *)" (R)"));
    }
  }
#line 36
  if (! print_as_tree) {
#line 36
    if (has_subtree) {
      {
#line 37
      fprintf(outfile, (char const   *)((char *)":"));
      }
    }
  }
}
}
#line 42 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/gnu.c"
static int print_symbol___1(FILE *outfile___0 , int line , struct output_symbol *s ) 
{ 
  int has_subtree ;
  int tmp ;

  {
#line 44
  if (s->direct) {
#line 44
    tmp = (s->sym)->callee != (struct linked_list *)((void *)0);
  } else {
#line 44
    tmp = (s->sym)->caller != (struct linked_list *)((void *)0);
  }
  {
#line 44
  has_subtree = tmp;
#line 48
  print_level(s->level, s->last);
#line 49
  print_function_name(s->sym, has_subtree);
  }
#line 51
  if (brief_listing) {
#line 52
    if ((s->sym)->expand_line) {
      {
#line 53
      fprintf(outfile___0, (char const   *)((char *)" [see %d]"), (s->sym)->expand_line);
      }
#line 54
      return (1);
    } else
#line 55
    if ((s->sym)->callee) {
#line 56
      (s->sym)->expand_line = line;
    }
  }
#line 58
  return (0);
}
}
#line 62 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/gnu.c"
int gnu_output_handler(cflow_output_command cmd , FILE *outfile___0 , int line , void *data ,
                       void *handler_data ) 
{ 
  int __cil_tmp6 ;

  {
  {
#line 67
  if ((unsigned int )cmd == (unsigned int )1) {
#line 67
    goto case_1;
  }
#line 76
  if ((unsigned int )cmd == (unsigned int )4) {
#line 76
    goto case_4;
  }
#line 76
  if ((unsigned int )cmd == (unsigned int )2) {
#line 76
    goto case_4;
  }
#line 76
  if ((unsigned int )cmd == (unsigned int )0) {
#line 76
    goto case_4;
  }
#line 78
  if ((unsigned int )cmd == (unsigned int )3) {
#line 78
    goto case_3;
  }
#line 81
  if ((unsigned int )cmd == (unsigned int )6) {
#line 81
    goto case_6;
  }
#line 84
  if ((unsigned int )cmd == (unsigned int )5) {
#line 84
    goto case_5;
  }
#line 66
  goto switch_break;
  case_1: /* CIL Label */ 
#line 68
  if (emacs_option) {
    {
#line 69
    fprintf(outfile___0, (char const   *)((char *)";; This file is generated by %s. -*- cflow -*-"),
            (char *)"GNU cflow 1.5");
#line 71
    newline();
    }
  }
#line 73
  goto switch_break;
  case_4: /* CIL Label */ 
#line 77
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 79
  fprintf(outfile___0, (char const   *)((char *)"\n"));
  }
#line 80
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 82
  fprintf(outfile___0, (char const   *)((char *)"%s"), (char *)data);
  }
#line 83
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 85
  __cil_tmp6 = print_symbol___1(outfile___0, line, (struct output_symbol *)data);
  }
#line 85
  return (__cil_tmp6);
  switch_break: /* CIL Label */ ;
  }
#line 87
  return (0);
}
}
#line 30 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/depmap.c"
static void transitive_closure(unsigned int *R , int n ) 
{ 
  register size_t rowsize ;
  register unsigned int mask ;
  register unsigned int *rowj ;
  register unsigned int *rp ;
  register unsigned int *rend ;
  register unsigned int *ccol ;
  unsigned int *relend ;
  unsigned int *cword ;
  unsigned int *rowi ;
  unsigned int *__cil_tmp12 ;
  unsigned int *__cil_tmp13 ;

  {
#line 43
  rowsize = ((((unsigned long )n + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL)) * sizeof(unsigned int );
#line 44
  relend = (unsigned int *)((char *)R + (unsigned long )n * rowsize);
#line 46
  cword = R;
#line 47
  mask = (unsigned int )1;
#line 48
  rowi = R;
  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;

#line 49
    if (! (rowi < relend)) {
#line 49
      goto while_break;
    }
#line 50
    ccol = cword;
#line 51
    rowj = R;
    {
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 53
      if (! (rowj < relend)) {
#line 53
        goto while_break___0;
      }
#line 54
      if (*ccol & mask) {
#line 55
        rp = rowi;
#line 56
        rend = (unsigned int *)((char *)rowj + rowsize);
        {
        {
#line 58
        while (1) {
          while_continue___1: /* CIL Label */ ;

#line 58
          if (! (rowj < rend)) {
#line 58
            goto while_break___1;
          }
#line 59
          __cil_tmp13 = rp;
#line 59
          rp ++;
#line 59
          __cil_tmp12 = rowj;
#line 59
          rowj ++;
#line 59
          *__cil_tmp12 |= *__cil_tmp13;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 61
        rowj = (unsigned int *)((char *)rowj + rowsize);
      }
#line 64
      ccol = (unsigned int *)((char *)ccol + rowsize);
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 67
    mask <<= 1;
#line 68
    if (mask == 0U) {
#line 69
      mask = (unsigned int )1;
#line 70
      cword ++;
    }
#line 72
    rowi = (unsigned int *)((char *)rowi + rowsize);
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 83 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/depmap.c"
cflow_depmap_t depmap_alloc(size_t count ) 
{ 
  size_t size ;
  cflow_depmap_t dmap ;
  void *__cil_tmp4 ;

  {
  {
#line 85
  size = ((count + sizeof(unsigned int ) * 8UL) - 1UL) / (sizeof(unsigned int ) * 8UL);
#line 86
  __cil_tmp4 = xzalloc((sizeof(*dmap) - 1UL) + (count * size) * sizeof(unsigned int ));
#line 86
  dmap = (cflow_depmap_t )__cil_tmp4;
#line 88
  dmap->nrows = count;
#line 89
  dmap->rowlen = size;
  }
#line 90
  return (dmap);
}
}
#line 94 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/depmap.c"
static unsigned int *depmap_rowptr(cflow_depmap_t dmap , size_t row ) 
{ 


  {
#line 96
  return ((unsigned int *)dmap->r + dmap->rowlen * row);
}
}
#line 100 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/depmap.c"
void depmap_set(cflow_depmap_t dmap , size_t row , size_t col ) 
{ 
  unsigned int *rptr ;
  unsigned int *__cil_tmp5 ;

  {
  {
#line 102
  __cil_tmp5 = depmap_rowptr(dmap, row);
#line 102
  rptr = __cil_tmp5;
#line 103
  *(rptr + col / (sizeof(unsigned int ) * 8UL)) |= (unsigned int )(1 << col % (sizeof(unsigned int ) * 8UL));
  }
}
}
#line 107 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/depmap.c"
int depmap_isset(cflow_depmap_t dmap , size_t row , size_t col ) 
{ 
  unsigned int *rptr ;
  unsigned int *__cil_tmp5 ;

  {
  {
#line 109
  __cil_tmp5 = depmap_rowptr(dmap, row);
#line 109
  rptr = __cil_tmp5;
  }
#line 110
  return ((*(rptr + col / (sizeof(unsigned int ) * 8UL)) & (unsigned int )(1 << col % (sizeof(unsigned int ) * 8UL))) != 0U);
}
}
#line 114 "/home/hyunsu/workspace/cr-bench/cflow-1.5/src/depmap.c"
void depmap_tc(cflow_depmap_t dmap ) 
{ 


  {
  {
#line 116
  transitive_closure((unsigned int *)dmap->r, (int )dmap->nrows);
  }
}
}
#line 652 "/usr/include/stdio.h"
extern size_t fwrite(void const   *__ptr , size_t __size , size_t __n , FILE *__s ) ;
#line 757
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   *__nptr ,
                                                           char **__endptr , int __base ) ;
#line 782 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 47 "./parser.h"
int yylex(void) ;
#line 297 "/usr/include/inttypes.h"
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 301
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 305
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 310
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 318
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   *__nptr ,
                                                            char **__endptr , int __base ,
                                                            int __group ) ;
#line 324
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   *nptr ,
                                                                 char **endptr , int base )  __attribute__((__gnu_inline__)) ;
#line 324 "/usr/include/inttypes.h"
__inline extern intmax_t strtoimax(char const   *nptr , char **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 327
  __cil_tmp4 = __strtol_internal(nptr, endptr, base, 0);
  }
#line 327
  return (__cil_tmp4);
}
}
#line 330
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   *__nptr ,
                                                                      char **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 336
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   *nptr ,
                                                                  char **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 336 "/usr/include/inttypes.h"
__inline extern uintmax_t strtoumax(char const   *nptr , char **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 339
  __cil_tmp4 = __strtoul_internal(nptr, endptr, base, 0);
  }
#line 339
  return (__cil_tmp4);
}
}
#line 342
extern  __attribute__((__nothrow__)) long __wcstol_internal(__gwchar_t *__nptr , __gwchar_t **__endptr ,
                                                            int __base , int __group ) ;
#line 348
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t *nptr ,
                                                                 __gwchar_t **endptr ,
                                                                 int base )  __attribute__((__gnu_inline__)) ;
#line 348 "/usr/include/inttypes.h"
__inline extern intmax_t wcstoimax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  long __cil_tmp4 ;

  {
  {
#line 351
  __cil_tmp4 = __wcstol_internal(nptr, endptr, base, 0);
  }
#line 351
  return (__cil_tmp4);
}
}
#line 354
extern  __attribute__((__nothrow__)) unsigned long __wcstoul_internal(__gwchar_t *__nptr ,
                                                                      __gwchar_t **__endptr ,
                                                                      int __base ,
                                                                      int __group ) ;
#line 362
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t *nptr ,
                                                                  __gwchar_t **endptr ,
                                                                  int base )  __attribute__((__gnu_inline__)) ;
#line 362 "/usr/include/inttypes.h"
__inline extern uintmax_t wcstoumax(__gwchar_t *nptr , __gwchar_t **endptr , int base ) 
{ 
  unsigned long __cil_tmp4 ;

  {
  {
#line 365
  __cil_tmp4 = __wcstoul_internal(nptr, endptr, base, 0);
  }
#line 365
  return (__cil_tmp4);
}
}
#line 211 "c.c"
yy_size_t yyleng ;
#line 216
FILE *yyin ;
#line 216
FILE *yyout ;
#line 318 "c.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 319 "c.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 320 "c.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 347
static char yy_hold_char ;
#line 348
static yy_size_t yy_n_chars ;
#line 352 "c.c"
static char *yy_c_buf_p  =    (char *)0;
#line 353 "c.c"
static int yy_init  =    0;
#line 354 "c.c"
static int yy_start  =    0;
#line 359
static int yy_did_buffer_switch_on_eof ;
#line 364
void yyrestart(FILE *input_file ) ;
#line 365
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 366
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 367
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 368
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 369
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 370
void yypop_buffer_state(void) ;
#line 372
static void yyensure_buffer_stack(void) ;
#line 373
static void yy_load_buffer_state(void) ;
#line 374
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 378
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 379
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 380
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , yy_size_t _yybytes_len ) ;
#line 384
void *yyalloc(yy_size_t size ) ;
#line 385
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 386
void yyfree(void *ptr ) ;
#line 419 "c.c"
FILE *yyin  =    (FILE *)0;
#line 419 "c.c"
FILE *yyout  =    (FILE *)0;
#line 423
int yylineno ;
#line 425 "c.c"
int yylineno  =    1;
#line 427
char *yytext ;
#line 432
static yy_state_type yy_get_previous_state(void) ;
#line 433
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 434
static int yy_get_next_buffer(void) ;
#line 435
static void yy_fatal_error(char const   *msg ) ;
#line 461 "c.c"
static flex_int16_t yy_accept[191]  = 
#line 461
  {      (flex_int16_t )0,      (flex_int16_t )77,      (flex_int16_t )77,      (flex_int16_t )3, 
        (flex_int16_t )3,      (flex_int16_t )67,      (flex_int16_t )67,      (flex_int16_t )72, 
        (flex_int16_t )72,      (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )82, 
        (flex_int16_t )80,      (flex_int16_t )77,      (flex_int16_t )76,      (flex_int16_t )46, 
        (flex_int16_t )66,      (flex_int16_t )80,      (flex_int16_t )28,      (flex_int16_t )42, 
        (flex_int16_t )80,      (flex_int16_t )21,      (flex_int16_t )30,      (flex_int16_t )32, 
        (flex_int16_t )23,      (flex_int16_t )26,      (flex_int16_t )61,      (flex_int16_t )80, 
        (flex_int16_t )50,      (flex_int16_t )44,      (flex_int16_t )48,      (flex_int16_t )60, 
        (flex_int16_t )38,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )40,      (flex_int16_t )77, 
        (flex_int16_t )80,      (flex_int16_t )78,      (flex_int16_t )79,      (flex_int16_t )3, 
        (flex_int16_t )4,      (flex_int16_t )5,      (flex_int16_t )67,      (flex_int16_t )68, 
        (flex_int16_t )71,      (flex_int16_t )81,      (flex_int16_t )75,      (flex_int16_t )72, 
        (flex_int16_t )73,      (flex_int16_t )74,      (flex_int16_t )81,      (flex_int16_t )13, 
        (flex_int16_t )81,      (flex_int16_t )77,      (flex_int16_t )0,      (flex_int16_t )45, 
        (flex_int16_t )0,      (flex_int16_t )11,      (flex_int16_t )27,      (flex_int16_t )41, 
        (flex_int16_t )35,      (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )24, 
        (flex_int16_t )53,      (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )0, 
        (flex_int16_t )29,      (flex_int16_t )54,      (flex_int16_t )31,      (flex_int16_t )22, 
        (flex_int16_t )0,      (flex_int16_t )64,      (flex_int16_t )2,      (flex_int16_t )0, 
        (flex_int16_t )25,      (flex_int16_t )65,      (flex_int16_t )61,      (flex_int16_t )0, 
        (flex_int16_t )63,      (flex_int16_t )62,      (flex_int16_t )62,      (flex_int16_t )51, 
        (flex_int16_t )49,      (flex_int16_t )43,      (flex_int16_t )47,      (flex_int16_t )52, 
        (flex_int16_t )60,      (flex_int16_t )37,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )36,      (flex_int16_t )39,      (flex_int16_t )77,      (flex_int16_t )0, 
        (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )0, 
        (flex_int16_t )0,      (flex_int16_t )3,      (flex_int16_t )4,      (flex_int16_t )5, 
        (flex_int16_t )6,      (flex_int16_t )5,      (flex_int16_t )7,      (flex_int16_t )67, 
        (flex_int16_t )69,      (flex_int16_t )70,      (flex_int16_t )72,      (flex_int16_t )0, 
        (flex_int16_t )13,      (flex_int16_t )0,      (flex_int16_t )12,      (flex_int16_t )55, 
        (flex_int16_t )0,      (flex_int16_t )55,      (flex_int16_t )0,      (flex_int16_t )0, 
        (flex_int16_t )59,      (flex_int16_t )64,      (flex_int16_t )0,      (flex_int16_t )0, 
        (flex_int16_t )1,      (flex_int16_t )0,      (flex_int16_t )63,      (flex_int16_t )33, 
        (flex_int16_t )34,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )0,      (flex_int16_t )9,      (flex_int16_t )0,      (flex_int16_t )0, 
        (flex_int16_t )10,      (flex_int16_t )0,      (flex_int16_t )56,      (flex_int16_t )0, 
        (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )64,      (flex_int16_t )0, 
        (flex_int16_t )65,      (flex_int16_t )14,      (flex_int16_t )20,      (flex_int16_t )60, 
        (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )9,      (flex_int16_t )0,      (flex_int16_t )57,      (flex_int16_t )0, 
        (flex_int16_t )58,      (flex_int16_t )0,      (flex_int16_t )64,      (flex_int16_t )65, 
        (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )19,      (flex_int16_t )0,      (flex_int16_t )15,      (flex_int16_t )16, 
        (flex_int16_t )18,      (flex_int16_t )60,      (flex_int16_t )0,      (flex_int16_t )0, 
        (flex_int16_t )17,      (flex_int16_t )0,      (flex_int16_t )8,      (flex_int16_t )0, 
        (flex_int16_t )0,      (flex_int16_t )8,      (flex_int16_t )0};
#line 485 "c.c"
static flex_int32_t yy_ec[256]  = 
#line 485
  {      0,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      2,      3,      1, 
        2,      2,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        2,      4,      5,      6, 
        1,      7,      8,      9, 
        1,      1,      10,      11, 
        1,      12,      13,      14, 
        15,      16,      16,      16, 
        16,      16,      16,      16, 
        17,      17,      1,      1, 
        18,      19,      20,      1, 
        1,      21,      21,      21, 
        21,      22,      21,      23, 
        23,      23,      23,      23, 
        23,      23,      23,      23, 
        23,      23,      23,      23, 
        23,      23,      23,      23, 
        24,      23,      23,      1, 
        25,      1,      26,      23, 
        1,      27,      21,      28, 
        29,      30,      31,      23, 
        23,      32,      23,      23, 
        33,      34,      35,      36, 
        37,      23,      38,      39, 
        40,      41,      23,      23, 
        42,      43,      23,      44, 
        45,      46,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
#line 517 "c.c"
static flex_int32_t yy_meta[47]  = 
#line 517
  {      0,      1,      1,      2, 
        1,      3,      1,      1, 
        1,      4,      5,      1, 
        1,      1,      1,      6, 
        6,      6,      1,      1, 
        1,      6,      7,      8, 
        8,      3,      1,      6, 
        6,      6,      7,      6, 
        8,      8,      8,      8, 
        8,      8,      8,      8, 
        8,      8,      8,      8, 
        1,      1,      1};
#line 526 "c.c"
static flex_int16_t yy_base[212]  = 
#line 526
  {      (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )45,      (flex_int16_t )45, 
        (flex_int16_t )46,      (flex_int16_t )47,      (flex_int16_t )54,      (flex_int16_t )58, 
        (flex_int16_t )62,      (flex_int16_t )50,      (flex_int16_t )51,      (flex_int16_t )469, 
        (flex_int16_t )484,      (flex_int16_t )56,      (flex_int16_t )484,      (flex_int16_t )424, 
        (flex_int16_t )484,      (flex_int16_t )417,      (flex_int16_t )400,      (flex_int16_t )58, 
        (flex_int16_t )381,      (flex_int16_t )370,      (flex_int16_t )67,      (flex_int16_t )80, 
        (flex_int16_t )88,      (flex_int16_t )71,      (flex_int16_t )93,      (flex_int16_t )98, 
        (flex_int16_t )50,      (flex_int16_t )357,      (flex_int16_t )51,      (flex_int16_t )0, 
        (flex_int16_t )314,      (flex_int16_t )291,      (flex_int16_t )52,      (flex_int16_t )291, 
        (flex_int16_t )287,      (flex_int16_t )294,      (flex_int16_t )79,      (flex_int16_t )110, 
        (flex_int16_t )134,      (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )325, 
        (flex_int16_t )484,      (flex_int16_t )115,      (flex_int16_t )0,      (flex_int16_t )484, 
        (flex_int16_t )484,      (flex_int16_t )324,      (flex_int16_t )484,      (flex_int16_t )321, 
        (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )116,      (flex_int16_t )484, 
        (flex_int16_t )117,      (flex_int16_t )120,      (flex_int16_t )319,      (flex_int16_t )484, 
        (flex_int16_t )318,      (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )484, 
        (flex_int16_t )484,      (flex_int16_t )311,      (flex_int16_t )123,      (flex_int16_t )484, 
        (flex_int16_t )484,      (flex_int16_t )128,      (flex_int16_t )139,      (flex_int16_t )145, 
        (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )484, 
        (flex_int16_t )305,      (flex_int16_t )153,      (flex_int16_t )484,      (flex_int16_t )314, 
        (flex_int16_t )484,      (flex_int16_t )156,      (flex_int16_t )164,      (flex_int16_t )172, 
        (flex_int16_t )0,      (flex_int16_t )484,      (flex_int16_t )177,      (flex_int16_t )296, 
        (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )295, 
        (flex_int16_t )0,      (flex_int16_t )484,      (flex_int16_t )262,      (flex_int16_t )260, 
        (flex_int16_t )258,      (flex_int16_t )96,      (flex_int16_t )258,      (flex_int16_t )254, 
        (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )125,      (flex_int16_t )193, 
        (flex_int16_t )173,      (flex_int16_t )225,      (flex_int16_t )188,      (flex_int16_t )181, 
        (flex_int16_t )197,      (flex_int16_t )272,      (flex_int16_t )484,      (flex_int16_t )143, 
        (flex_int16_t )484,      (flex_int16_t )209,      (flex_int16_t )484,      (flex_int16_t )0, 
        (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )270,      (flex_int16_t )196, 
        (flex_int16_t )484,      (flex_int16_t )199,      (flex_int16_t )484,      (flex_int16_t )484, 
        (flex_int16_t )259,      (flex_int16_t )226,      (flex_int16_t )216,      (flex_int16_t )225, 
        (flex_int16_t )484,      (flex_int16_t )221,      (flex_int16_t )237,      (flex_int16_t )227, 
        (flex_int16_t )484,      (flex_int16_t )244,      (flex_int16_t )0,      (flex_int16_t )484, 
        (flex_int16_t )484,      (flex_int16_t )184,      (flex_int16_t )173,      (flex_int16_t )171, 
        (flex_int16_t )157,      (flex_int16_t )141,      (flex_int16_t )144,      (flex_int16_t )130, 
        (flex_int16_t )208,      (flex_int16_t )484,      (flex_int16_t )254,      (flex_int16_t )214, 
        (flex_int16_t )484,      (flex_int16_t )241,      (flex_int16_t )484,      (flex_int16_t )258, 
        (flex_int16_t )155,      (flex_int16_t )199,      (flex_int16_t )230,      (flex_int16_t )247, 
        (flex_int16_t )265,      (flex_int16_t )0,      (flex_int16_t )0,      (flex_int16_t )125, 
        (flex_int16_t )116,      (flex_int16_t )112,      (flex_int16_t )104,      (flex_int16_t )95, 
        (flex_int16_t )484,      (flex_int16_t )262,      (flex_int16_t )484,      (flex_int16_t )119, 
        (flex_int16_t )484,      (flex_int16_t )112,      (flex_int16_t )268,      (flex_int16_t )273, 
        (flex_int16_t )72,      (flex_int16_t )74,      (flex_int16_t )48,      (flex_int16_t )44, 
        (flex_int16_t )0,      (flex_int16_t )291,      (flex_int16_t )0,      (flex_int16_t )0, 
        (flex_int16_t )0,      (flex_int16_t )42,      (flex_int16_t )294,      (flex_int16_t )288, 
        (flex_int16_t )0,      (flex_int16_t )274,      (flex_int16_t )484,      (flex_int16_t )309, 
        (flex_int16_t )275,      (flex_int16_t )484,      (flex_int16_t )484,      (flex_int16_t )334, 
        (flex_int16_t )342,      (flex_int16_t )350,      (flex_int16_t )358,      (flex_int16_t )366, 
        (flex_int16_t )374,      (flex_int16_t )382,      (flex_int16_t )385,      (flex_int16_t )393, 
        (flex_int16_t )401,      (flex_int16_t )409,      (flex_int16_t )417,      (flex_int16_t )425, 
        (flex_int16_t )433,      (flex_int16_t )441,      (flex_int16_t )449,      (flex_int16_t )452, 
        (flex_int16_t )459,      (flex_int16_t )464,      (flex_int16_t )468,      (flex_int16_t )475};
#line 554 "c.c"
static flex_int16_t yy_def[212]  = 
#line 554
  {      (flex_int16_t )0,      (flex_int16_t )190,      (flex_int16_t )1,      (flex_int16_t )191, 
        (flex_int16_t )191,      (flex_int16_t )192,      (flex_int16_t )192,      (flex_int16_t )193, 
        (flex_int16_t )193,      (flex_int16_t )194,      (flex_int16_t )194,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )195,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )196,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )197, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )198, 
        (flex_int16_t )190,      (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )199,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )200, 
        (flex_int16_t )190,      (flex_int16_t )201,      (flex_int16_t )202,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )203,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )204,      (flex_int16_t )190, 
        (flex_int16_t )204,      (flex_int16_t )190,      (flex_int16_t )195,      (flex_int16_t )190, 
        (flex_int16_t )195,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )205,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )197, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )206, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )207,      (flex_int16_t )190,      (flex_int16_t )197,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )198,      (flex_int16_t )190,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )199, 
        (flex_int16_t )199,      (flex_int16_t )199,      (flex_int16_t )208,      (flex_int16_t )199, 
        (flex_int16_t )199,      (flex_int16_t )200,      (flex_int16_t )190,      (flex_int16_t )201, 
        (flex_int16_t )190,      (flex_int16_t )201,      (flex_int16_t )190,      (flex_int16_t )202, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )204, 
        (flex_int16_t )190,      (flex_int16_t )204,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )209, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )206, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )207,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )208,      (flex_int16_t )190,      (flex_int16_t )208,      (flex_int16_t )208, 
        (flex_int16_t )190,      (flex_int16_t )199,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )210,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )190,      (flex_int16_t )199,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )198,      (flex_int16_t )199,      (flex_int16_t )198,      (flex_int16_t )198, 
        (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )199,      (flex_int16_t )211, 
        (flex_int16_t )198,      (flex_int16_t )211,      (flex_int16_t )190,      (flex_int16_t )211, 
        (flex_int16_t )211,      (flex_int16_t )190,      (flex_int16_t )0,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190};
#line 582 "c.c"
static flex_int16_t yy_nxt[531]  = 
#line 582
  {      (flex_int16_t )0,      (flex_int16_t )12,      (flex_int16_t )13,      (flex_int16_t )14, 
        (flex_int16_t )15,      (flex_int16_t )16,      (flex_int16_t )17,      (flex_int16_t )18, 
        (flex_int16_t )19,      (flex_int16_t )20,      (flex_int16_t )21,      (flex_int16_t )22, 
        (flex_int16_t )23,      (flex_int16_t )24,      (flex_int16_t )25,      (flex_int16_t )26, 
        (flex_int16_t )27,      (flex_int16_t )27,      (flex_int16_t )28,      (flex_int16_t )29, 
        (flex_int16_t )30,      (flex_int16_t )31,      (flex_int16_t )31,      (flex_int16_t )31, 
        (flex_int16_t )31,      (flex_int16_t )12,      (flex_int16_t )32,      (flex_int16_t )33, 
        (flex_int16_t )31,      (flex_int16_t )31,      (flex_int16_t )34,      (flex_int16_t )31, 
        (flex_int16_t )31,      (flex_int16_t )31,      (flex_int16_t )31,      (flex_int16_t )31, 
        (flex_int16_t )31,      (flex_int16_t )31,      (flex_int16_t )31,      (flex_int16_t )35, 
        (flex_int16_t )36,      (flex_int16_t )37,      (flex_int16_t )31,      (flex_int16_t )31, 
        (flex_int16_t )12,      (flex_int16_t )38,      (flex_int16_t )12,      (flex_int16_t )39, 
        (flex_int16_t )44,      (flex_int16_t )44,      (flex_int16_t )47,      (flex_int16_t )40, 
        (flex_int16_t )48,      (flex_int16_t )55,      (flex_int16_t )55,      (flex_int16_t )45, 
        (flex_int16_t )45,      (flex_int16_t )47,      (flex_int16_t )57,      (flex_int16_t )48, 
        (flex_int16_t )51,      (flex_int16_t )52,      (flex_int16_t )58,      (flex_int16_t )53, 
        (flex_int16_t )51,      (flex_int16_t )52,      (flex_int16_t )63,      (flex_int16_t )53, 
        (flex_int16_t )87,      (flex_int16_t )88,      (flex_int16_t )90,      (flex_int16_t )91, 
        (flex_int16_t )49,      (flex_int16_t )184,      (flex_int16_t )181,      (flex_int16_t )56, 
        (flex_int16_t )56,      (flex_int16_t )64,      (flex_int16_t )68,      (flex_int16_t )49, 
        (flex_int16_t )69,      (flex_int16_t )78,      (flex_int16_t )70,      (flex_int16_t )71, 
        (flex_int16_t )71,      (flex_int16_t )79,      (flex_int16_t )72,      (flex_int16_t )95, 
        (flex_int16_t )180,      (flex_int16_t )41,      (flex_int16_t )80,      (flex_int16_t )42, 
        (flex_int16_t )73,      (flex_int16_t )69,      (flex_int16_t )96,      (flex_int16_t )70, 
        (flex_int16_t )71,      (flex_int16_t )71,      (flex_int16_t )100,      (flex_int16_t )74, 
        (flex_int16_t )75,      (flex_int16_t )76,      (flex_int16_t )179,      (flex_int16_t )77, 
        (flex_int16_t )77,      (flex_int16_t )77,      (flex_int16_t )81,      (flex_int16_t )178, 
        (flex_int16_t )82,      (flex_int16_t )82,      (flex_int16_t )83,      (flex_int16_t )81, 
        (flex_int16_t )102,      (flex_int16_t )86,      (flex_int16_t )86,      (flex_int16_t )86, 
        (flex_int16_t )103,      (flex_int16_t )84,      (flex_int16_t )112,      (flex_int16_t )120, 
        (flex_int16_t )122,      (flex_int16_t )168,      (flex_int16_t )57,      (flex_int16_t )140, 
        (flex_int16_t )101,      (flex_int16_t )113,      (flex_int16_t )58,      (flex_int16_t )102, 
        (flex_int16_t )166,      (flex_int16_t )114,      (flex_int16_t )176,      (flex_int16_t )103, 
        (flex_int16_t )125,      (flex_int16_t )175,      (flex_int16_t )141,      (flex_int16_t )84, 
        (flex_int16_t )105,      (flex_int16_t )61,      (flex_int16_t )126,      (flex_int16_t )126, 
        (flex_int16_t )174,      (flex_int16_t )121,      (flex_int16_t )121,      (flex_int16_t )77, 
        (flex_int16_t )77,      (flex_int16_t )77,      (flex_int16_t )112,      (flex_int16_t )127, 
        (flex_int16_t )173,      (flex_int16_t )106,      (flex_int16_t )106,      (flex_int16_t )106, 
        (flex_int16_t )81,      (flex_int16_t )190,      (flex_int16_t )83,      (flex_int16_t )83, 
        (flex_int16_t )83,      (flex_int16_t )190,      (flex_int16_t )81,      (flex_int16_t )107, 
        (flex_int16_t )86,      (flex_int16_t )86,      (flex_int16_t )86,      (flex_int16_t )172, 
        (flex_int16_t )168,      (flex_int16_t )127,      (flex_int16_t )163,      (flex_int16_t )108, 
        (flex_int16_t )129,      (flex_int16_t )129,      (flex_int16_t )129,      (flex_int16_t )77, 
        (flex_int16_t )77,      (flex_int16_t )77,      (flex_int16_t )162,      (flex_int16_t )130, 
        (flex_int16_t )61,      (flex_int16_t )81,      (flex_int16_t )133,      (flex_int16_t )82, 
        (flex_int16_t )82,      (flex_int16_t )83,      (flex_int16_t )161,      (flex_int16_t )130, 
        (flex_int16_t )148,      (flex_int16_t )81,      (flex_int16_t )133,      (flex_int16_t )83, 
        (flex_int16_t )83,      (flex_int16_t )83,      (flex_int16_t )81,      (flex_int16_t )145, 
        (flex_int16_t )86,      (flex_int16_t )86,      (flex_int16_t )86,      (flex_int16_t )105, 
        (flex_int16_t )61,      (flex_int16_t )160,      (flex_int16_t )107,      (flex_int16_t )120, 
        (flex_int16_t )61,      (flex_int16_t )159,      (flex_int16_t )122,      (flex_int16_t )146, 
        (flex_int16_t )146,      (flex_int16_t )146,      (flex_int16_t )107,      (flex_int16_t )158, 
        (flex_int16_t )106,      (flex_int16_t )106,      (flex_int16_t )106,      (flex_int16_t )145, 
        (flex_int16_t )112,      (flex_int16_t )147,      (flex_int16_t )154,      (flex_int16_t )154, 
        (flex_int16_t )154,      (flex_int16_t )164,      (flex_int16_t )107,      (flex_int16_t )113, 
        (flex_int16_t )157,      (flex_int16_t )121,      (flex_int16_t )107,      (flex_int16_t )114, 
        (flex_int16_t )121,      (flex_int16_t )150,      (flex_int16_t )108,      (flex_int16_t )105, 
        (flex_int16_t )61,      (flex_int16_t )149,      (flex_int16_t )132,      (flex_int16_t )151, 
        (flex_int16_t )151,      (flex_int16_t )147,      (flex_int16_t )150,      (flex_int16_t )150, 
        (flex_int16_t )129,      (flex_int16_t )129,      (flex_int16_t )129,      (flex_int16_t )147, 
        (flex_int16_t )106,      (flex_int16_t )106,      (flex_int16_t )106,      (flex_int16_t )130, 
        (flex_int16_t )61,      (flex_int16_t )170,      (flex_int16_t )170,      (flex_int16_t )170, 
        (flex_int16_t )153,      (flex_int16_t )153,      (flex_int16_t )107,      (flex_int16_t )130, 
        (flex_int16_t )154,      (flex_int16_t )154,      (flex_int16_t )154,      (flex_int16_t )155, 
        (flex_int16_t )155,      (flex_int16_t )145,      (flex_int16_t )108,      (flex_int16_t )156, 
        (flex_int16_t )156,      (flex_int16_t )156,      (flex_int16_t )156,      (flex_int16_t )156, 
        (flex_int16_t )156,      (flex_int16_t )61,      (flex_int16_t )107,      (flex_int16_t )166, 
        (flex_int16_t )150,      (flex_int16_t )146,      (flex_int16_t )146,      (flex_int16_t )146, 
        (flex_int16_t )118,      (flex_int16_t )167,      (flex_int16_t )167,      (flex_int16_t )110, 
        (flex_int16_t )165,      (flex_int16_t )186,      (flex_int16_t )189,      (flex_int16_t )147, 
        (flex_int16_t )171,      (flex_int16_t )171,      (flex_int16_t )171,      (flex_int16_t )170, 
        (flex_int16_t )170,      (flex_int16_t )170,      (flex_int16_t )143,      (flex_int16_t )107, 
        (flex_int16_t )171,      (flex_int16_t )171,      (flex_int16_t )171,      (flex_int16_t )186, 
        (flex_int16_t )177,      (flex_int16_t )182,      (flex_int16_t )61,      (flex_int16_t )142, 
        (flex_int16_t )182,      (flex_int16_t )61,      (flex_int16_t )139,      (flex_int16_t )188, 
        (flex_int16_t )188,      (flex_int16_t )138,      (flex_int16_t )137,      (flex_int16_t )187, 
        (flex_int16_t )187,      (flex_int16_t )187,      (flex_int16_t )183,      (flex_int16_t )183, 
        (flex_int16_t )183,      (flex_int16_t )183,      (flex_int16_t )183,      (flex_int16_t )183, 
        (flex_int16_t )186,      (flex_int16_t )188,      (flex_int16_t )136,      (flex_int16_t )135, 
        (flex_int16_t )107,      (flex_int16_t )132,      (flex_int16_t )128,      (flex_int16_t )107, 
        (flex_int16_t )123,      (flex_int16_t )61,      (flex_int16_t )61,      (flex_int16_t )118, 
        (flex_int16_t )187,      (flex_int16_t )187,      (flex_int16_t )187,      (flex_int16_t )117, 
        (flex_int16_t )110,      (flex_int16_t )99,      (flex_int16_t )98,      (flex_int16_t )97, 
        (flex_int16_t )94,      (flex_int16_t )93,      (flex_int16_t )188,      (flex_int16_t )43, 
        (flex_int16_t )43,      (flex_int16_t )43,      (flex_int16_t )43,      (flex_int16_t )43, 
        (flex_int16_t )43,      (flex_int16_t )43,      (flex_int16_t )43,      (flex_int16_t )46, 
        (flex_int16_t )46,      (flex_int16_t )46,      (flex_int16_t )46,      (flex_int16_t )46, 
        (flex_int16_t )46,      (flex_int16_t )46,      (flex_int16_t )46,      (flex_int16_t )50, 
        (flex_int16_t )50,      (flex_int16_t )50,      (flex_int16_t )50,      (flex_int16_t )50, 
        (flex_int16_t )50,      (flex_int16_t )50,      (flex_int16_t )50,      (flex_int16_t )54, 
        (flex_int16_t )54,      (flex_int16_t )54,      (flex_int16_t )54,      (flex_int16_t )54, 
        (flex_int16_t )54,      (flex_int16_t )54,      (flex_int16_t )54,      (flex_int16_t )60, 
        (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60, 
        (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )60,      (flex_int16_t )65, 
        (flex_int16_t )89,      (flex_int16_t )65,      (flex_int16_t )65,      (flex_int16_t )65, 
        (flex_int16_t )65,      (flex_int16_t )65,      (flex_int16_t )65,      (flex_int16_t )85, 
        (flex_int16_t )85,      (flex_int16_t )85,      (flex_int16_t )85,      (flex_int16_t )85, 
        (flex_int16_t )85,      (flex_int16_t )67,      (flex_int16_t )85,      (flex_int16_t )92, 
        (flex_int16_t )92,      (flex_int16_t )92,      (flex_int16_t )104,      (flex_int16_t )104, 
        (flex_int16_t )104,      (flex_int16_t )104,      (flex_int16_t )104,      (flex_int16_t )104, 
        (flex_int16_t )104,      (flex_int16_t )104,      (flex_int16_t )109,      (flex_int16_t )109, 
        (flex_int16_t )109,      (flex_int16_t )109,      (flex_int16_t )66,      (flex_int16_t )109, 
        (flex_int16_t )109,      (flex_int16_t )109,      (flex_int16_t )111,      (flex_int16_t )111, 
        (flex_int16_t )111,      (flex_int16_t )111,      (flex_int16_t )111,      (flex_int16_t )111, 
        (flex_int16_t )111,      (flex_int16_t )111,      (flex_int16_t )115,      (flex_int16_t )62, 
        (flex_int16_t )61,      (flex_int16_t )115,      (flex_int16_t )115,      (flex_int16_t )115, 
        (flex_int16_t )115,      (flex_int16_t )115,      (flex_int16_t )116,      (flex_int16_t )116, 
        (flex_int16_t )116,      (flex_int16_t )116,      (flex_int16_t )116,      (flex_int16_t )116, 
        (flex_int16_t )116,      (flex_int16_t )116,      (flex_int16_t )119,      (flex_int16_t )119, 
        (flex_int16_t )119,      (flex_int16_t )119,      (flex_int16_t )119,      (flex_int16_t )119, 
        (flex_int16_t )119,      (flex_int16_t )119,      (flex_int16_t )124,      (flex_int16_t )59, 
        (flex_int16_t )124,      (flex_int16_t )124,      (flex_int16_t )124,      (flex_int16_t )124, 
        (flex_int16_t )124,      (flex_int16_t )124,      (flex_int16_t )131,      (flex_int16_t )131, 
        (flex_int16_t )131,      (flex_int16_t )131,      (flex_int16_t )131,      (flex_int16_t )131, 
        (flex_int16_t )131,      (flex_int16_t )131,      (flex_int16_t )134,      (flex_int16_t )134, 
        (flex_int16_t )144,      (flex_int16_t )144,      (flex_int16_t )144,      (flex_int16_t )144, 
        (flex_int16_t )144,      (flex_int16_t )144,      (flex_int16_t )144,      (flex_int16_t )144, 
        (flex_int16_t )152,      (flex_int16_t )190,      (flex_int16_t )152,      (flex_int16_t )152, 
        (flex_int16_t )169,      (flex_int16_t )190,      (flex_int16_t )169,      (flex_int16_t )169, 
        (flex_int16_t )185,      (flex_int16_t )185,      (flex_int16_t )185,      (flex_int16_t )185, 
        (flex_int16_t )185,      (flex_int16_t )185,      (flex_int16_t )185,      (flex_int16_t )185, 
        (flex_int16_t )11,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190};
#line 644 "c.c"
static flex_int16_t yy_chk[531]  = 
#line 644
  {      (flex_int16_t )0,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1, 
        (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )1,      (flex_int16_t )2, 
        (flex_int16_t )3,      (flex_int16_t )4,      (flex_int16_t )5,      (flex_int16_t )2, 
        (flex_int16_t )5,      (flex_int16_t )9,      (flex_int16_t )10,      (flex_int16_t )3, 
        (flex_int16_t )4,      (flex_int16_t )6,      (flex_int16_t )13,      (flex_int16_t )6, 
        (flex_int16_t )7,      (flex_int16_t )7,      (flex_int16_t )13,      (flex_int16_t )7, 
        (flex_int16_t )8,      (flex_int16_t )8,      (flex_int16_t )19,      (flex_int16_t )8, 
        (flex_int16_t )28,      (flex_int16_t )28,      (flex_int16_t )30,      (flex_int16_t )30, 
        (flex_int16_t )5,      (flex_int16_t )181,      (flex_int16_t )175,      (flex_int16_t )9, 
        (flex_int16_t )10,      (flex_int16_t )19,      (flex_int16_t )22,      (flex_int16_t )6, 
        (flex_int16_t )22,      (flex_int16_t )25,      (flex_int16_t )22,      (flex_int16_t )22, 
        (flex_int16_t )22,      (flex_int16_t )25,      (flex_int16_t )22,      (flex_int16_t )34, 
        (flex_int16_t )174,      (flex_int16_t )2,      (flex_int16_t )25,      (flex_int16_t )2, 
        (flex_int16_t )23,      (flex_int16_t )23,      (flex_int16_t )34,      (flex_int16_t )23, 
        (flex_int16_t )23,      (flex_int16_t )23,      (flex_int16_t )38,      (flex_int16_t )23, 
        (flex_int16_t )23,      (flex_int16_t )24,      (flex_int16_t )173,      (flex_int16_t )24, 
        (flex_int16_t )24,      (flex_int16_t )24,      (flex_int16_t )26,      (flex_int16_t )172, 
        (flex_int16_t )26,      (flex_int16_t )26,      (flex_int16_t )26,      (flex_int16_t )27, 
        (flex_int16_t )39,      (flex_int16_t )27,      (flex_int16_t )27,      (flex_int16_t )27, 
        (flex_int16_t )39,      (flex_int16_t )26,      (flex_int16_t )45,      (flex_int16_t )54, 
        (flex_int16_t )56,      (flex_int16_t )169,      (flex_int16_t )57,      (flex_int16_t )97, 
        (flex_int16_t )38,      (flex_int16_t )45,      (flex_int16_t )57,      (flex_int16_t )102, 
        (flex_int16_t )167,      (flex_int16_t )45,      (flex_int16_t )163,      (flex_int16_t )102, 
        (flex_int16_t )66,      (flex_int16_t )162,      (flex_int16_t )97,      (flex_int16_t )26, 
        (flex_int16_t )40,      (flex_int16_t )40,      (flex_int16_t )66,      (flex_int16_t )66, 
        (flex_int16_t )161,      (flex_int16_t )54,      (flex_int16_t )56,      (flex_int16_t )69, 
        (flex_int16_t )69,      (flex_int16_t )69,      (flex_int16_t )111,      (flex_int16_t )66, 
        (flex_int16_t )160,      (flex_int16_t )40,      (flex_int16_t )40,      (flex_int16_t )40, 
        (flex_int16_t )70,      (flex_int16_t )111,      (flex_int16_t )70,      (flex_int16_t )70, 
        (flex_int16_t )70,      (flex_int16_t )111,      (flex_int16_t )71,      (flex_int16_t )40, 
        (flex_int16_t )71,      (flex_int16_t )71,      (flex_int16_t )71,      (flex_int16_t )159, 
        (flex_int16_t )152,      (flex_int16_t )66,      (flex_int16_t )143,      (flex_int16_t )40, 
        (flex_int16_t )77,      (flex_int16_t )77,      (flex_int16_t )77,      (flex_int16_t )81, 
        (flex_int16_t )81,      (flex_int16_t )81,      (flex_int16_t )142,      (flex_int16_t )77, 
        (flex_int16_t )104,      (flex_int16_t )82,      (flex_int16_t )81,      (flex_int16_t )82, 
        (flex_int16_t )82,      (flex_int16_t )82,      (flex_int16_t )141,      (flex_int16_t )77, 
        (flex_int16_t )107,      (flex_int16_t )83,      (flex_int16_t )81,      (flex_int16_t )83, 
        (flex_int16_t )83,      (flex_int16_t )83,      (flex_int16_t )86,      (flex_int16_t )106, 
        (flex_int16_t )86,      (flex_int16_t )86,      (flex_int16_t )86,      (flex_int16_t )103, 
        (flex_int16_t )103,      (flex_int16_t )140,      (flex_int16_t )104,      (flex_int16_t )119, 
        (flex_int16_t )108,      (flex_int16_t )139,      (flex_int16_t )121,      (flex_int16_t )106, 
        (flex_int16_t )106,      (flex_int16_t )106,      (flex_int16_t )107,      (flex_int16_t )138, 
        (flex_int16_t )103,      (flex_int16_t )103,      (flex_int16_t )103,      (flex_int16_t )144, 
        (flex_int16_t )113,      (flex_int16_t )106,      (flex_int16_t )153,      (flex_int16_t )153, 
        (flex_int16_t )153,      (flex_int16_t )147,      (flex_int16_t )103,      (flex_int16_t )113, 
        (flex_int16_t )137,      (flex_int16_t )119,      (flex_int16_t )108,      (flex_int16_t )113, 
        (flex_int16_t )121,      (flex_int16_t )126,      (flex_int16_t )103,      (flex_int16_t )105, 
        (flex_int16_t )105,      (flex_int16_t )108,      (flex_int16_t )131,      (flex_int16_t )126, 
        (flex_int16_t )126,      (flex_int16_t )144,      (flex_int16_t )127,      (flex_int16_t )125, 
        (flex_int16_t )129,      (flex_int16_t )129,      (flex_int16_t )129,      (flex_int16_t )147, 
        (flex_int16_t )105,      (flex_int16_t )105,      (flex_int16_t )105,      (flex_int16_t )129, 
        (flex_int16_t )149,      (flex_int16_t )154,      (flex_int16_t )154,      (flex_int16_t )154, 
        (flex_int16_t )130,      (flex_int16_t )130,      (flex_int16_t )105,      (flex_int16_t )129, 
        (flex_int16_t )130,      (flex_int16_t )130,      (flex_int16_t )130,      (flex_int16_t )133, 
        (flex_int16_t )133,      (flex_int16_t )146,      (flex_int16_t )105,      (flex_int16_t )133, 
        (flex_int16_t )133,      (flex_int16_t )133,      (flex_int16_t )155,      (flex_int16_t )155, 
        (flex_int16_t )155,      (flex_int16_t )165,      (flex_int16_t )149,      (flex_int16_t )151, 
        (flex_int16_t )124,      (flex_int16_t )146,      (flex_int16_t )146,      (flex_int16_t )146, 
        (flex_int16_t )118,      (flex_int16_t )151,      (flex_int16_t )151,      (flex_int16_t )109, 
        (flex_int16_t )149,      (flex_int16_t )185,      (flex_int16_t )188,      (flex_int16_t )146, 
        (flex_int16_t )156,      (flex_int16_t )156,      (flex_int16_t )156,      (flex_int16_t )170, 
        (flex_int16_t )170,      (flex_int16_t )170,      (flex_int16_t )99,      (flex_int16_t )165, 
        (flex_int16_t )171,      (flex_int16_t )171,      (flex_int16_t )171,      (flex_int16_t )183, 
        (flex_int16_t )165,      (flex_int16_t )177,      (flex_int16_t )177,      (flex_int16_t )98, 
        (flex_int16_t )182,      (flex_int16_t )182,      (flex_int16_t )96,      (flex_int16_t )185, 
        (flex_int16_t )188,      (flex_int16_t )95,      (flex_int16_t )94,      (flex_int16_t )183, 
        (flex_int16_t )183,      (flex_int16_t )183,      (flex_int16_t )177,      (flex_int16_t )177, 
        (flex_int16_t )177,      (flex_int16_t )182,      (flex_int16_t )182,      (flex_int16_t )182, 
        (flex_int16_t )187,      (flex_int16_t )183,      (flex_int16_t )91,      (flex_int16_t )87, 
        (flex_int16_t )177,      (flex_int16_t )79,      (flex_int16_t )76,      (flex_int16_t )182, 
        (flex_int16_t )65,      (flex_int16_t )60,      (flex_int16_t )58,      (flex_int16_t )51, 
        (flex_int16_t )187,      (flex_int16_t )187,      (flex_int16_t )187,      (flex_int16_t )49, 
        (flex_int16_t )43,      (flex_int16_t )37,      (flex_int16_t )36,      (flex_int16_t )35, 
        (flex_int16_t )33,      (flex_int16_t )32,      (flex_int16_t )187,      (flex_int16_t )191, 
        (flex_int16_t )191,      (flex_int16_t )191,      (flex_int16_t )191,      (flex_int16_t )191, 
        (flex_int16_t )191,      (flex_int16_t )191,      (flex_int16_t )191,      (flex_int16_t )192, 
        (flex_int16_t )192,      (flex_int16_t )192,      (flex_int16_t )192,      (flex_int16_t )192, 
        (flex_int16_t )192,      (flex_int16_t )192,      (flex_int16_t )192,      (flex_int16_t )193, 
        (flex_int16_t )193,      (flex_int16_t )193,      (flex_int16_t )193,      (flex_int16_t )193, 
        (flex_int16_t )193,      (flex_int16_t )193,      (flex_int16_t )193,      (flex_int16_t )194, 
        (flex_int16_t )194,      (flex_int16_t )194,      (flex_int16_t )194,      (flex_int16_t )194, 
        (flex_int16_t )194,      (flex_int16_t )194,      (flex_int16_t )194,      (flex_int16_t )195, 
        (flex_int16_t )195,      (flex_int16_t )195,      (flex_int16_t )195,      (flex_int16_t )195, 
        (flex_int16_t )195,      (flex_int16_t )195,      (flex_int16_t )195,      (flex_int16_t )196, 
        (flex_int16_t )29,      (flex_int16_t )196,      (flex_int16_t )196,      (flex_int16_t )196, 
        (flex_int16_t )196,      (flex_int16_t )196,      (flex_int16_t )196,      (flex_int16_t )197, 
        (flex_int16_t )197,      (flex_int16_t )197,      (flex_int16_t )197,      (flex_int16_t )197, 
        (flex_int16_t )197,      (flex_int16_t )21,      (flex_int16_t )197,      (flex_int16_t )198, 
        (flex_int16_t )198,      (flex_int16_t )198,      (flex_int16_t )199,      (flex_int16_t )199, 
        (flex_int16_t )199,      (flex_int16_t )199,      (flex_int16_t )199,      (flex_int16_t )199, 
        (flex_int16_t )199,      (flex_int16_t )199,      (flex_int16_t )200,      (flex_int16_t )200, 
        (flex_int16_t )200,      (flex_int16_t )200,      (flex_int16_t )20,      (flex_int16_t )200, 
        (flex_int16_t )200,      (flex_int16_t )200,      (flex_int16_t )201,      (flex_int16_t )201, 
        (flex_int16_t )201,      (flex_int16_t )201,      (flex_int16_t )201,      (flex_int16_t )201, 
        (flex_int16_t )201,      (flex_int16_t )201,      (flex_int16_t )202,      (flex_int16_t )18, 
        (flex_int16_t )17,      (flex_int16_t )202,      (flex_int16_t )202,      (flex_int16_t )202, 
        (flex_int16_t )202,      (flex_int16_t )202,      (flex_int16_t )203,      (flex_int16_t )203, 
        (flex_int16_t )203,      (flex_int16_t )203,      (flex_int16_t )203,      (flex_int16_t )203, 
        (flex_int16_t )203,      (flex_int16_t )203,      (flex_int16_t )204,      (flex_int16_t )204, 
        (flex_int16_t )204,      (flex_int16_t )204,      (flex_int16_t )204,      (flex_int16_t )204, 
        (flex_int16_t )204,      (flex_int16_t )204,      (flex_int16_t )205,      (flex_int16_t )15, 
        (flex_int16_t )205,      (flex_int16_t )205,      (flex_int16_t )205,      (flex_int16_t )205, 
        (flex_int16_t )205,      (flex_int16_t )205,      (flex_int16_t )206,      (flex_int16_t )206, 
        (flex_int16_t )206,      (flex_int16_t )206,      (flex_int16_t )206,      (flex_int16_t )206, 
        (flex_int16_t )206,      (flex_int16_t )206,      (flex_int16_t )207,      (flex_int16_t )207, 
        (flex_int16_t )208,      (flex_int16_t )208,      (flex_int16_t )208,      (flex_int16_t )208, 
        (flex_int16_t )208,      (flex_int16_t )208,      (flex_int16_t )208,      (flex_int16_t )208, 
        (flex_int16_t )209,      (flex_int16_t )11,      (flex_int16_t )209,      (flex_int16_t )209, 
        (flex_int16_t )210,      (flex_int16_t )0,      (flex_int16_t )210,      (flex_int16_t )210, 
        (flex_int16_t )211,      (flex_int16_t )211,      (flex_int16_t )211,      (flex_int16_t )211, 
        (flex_int16_t )211,      (flex_int16_t )211,      (flex_int16_t )211,      (flex_int16_t )211, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190, 
        (flex_int16_t )190,      (flex_int16_t )190,      (flex_int16_t )190};
#line 706
static yy_state_type yy_last_accepting_state ;
#line 707
static char *yy_last_accepting_cpos ;
#line 709
int yy_flex_debug ;
#line 710 "c.c"
int yy_flex_debug  =    1;
#line 712 "c.c"
static flex_int16_t yy_rule_linenum[81]  = 
#line 712
  {      (flex_int16_t )0,      (flex_int16_t )56,      (flex_int16_t )57,      (flex_int16_t )58, 
        (flex_int16_t )59,      (flex_int16_t )60,      (flex_int16_t )61,      (flex_int16_t )62, 
        (flex_int16_t )64,      (flex_int16_t )65,      (flex_int16_t )67,      (flex_int16_t )68, 
        (flex_int16_t )69,      (flex_int16_t )70,      (flex_int16_t )72,      (flex_int16_t )73, 
        (flex_int16_t )74,      (flex_int16_t )75,      (flex_int16_t )76,      (flex_int16_t )77, 
        (flex_int16_t )78,      (flex_int16_t )79,      (flex_int16_t )85,      (flex_int16_t )86, 
        (flex_int16_t )87,      (flex_int16_t )88,      (flex_int16_t )89,      (flex_int16_t )90, 
        (flex_int16_t )91,      (flex_int16_t )92,      (flex_int16_t )93,      (flex_int16_t )94, 
        (flex_int16_t )95,      (flex_int16_t )96,      (flex_int16_t )97,      (flex_int16_t )98, 
        (flex_int16_t )99,      (flex_int16_t )100,      (flex_int16_t )101,      (flex_int16_t )102, 
        (flex_int16_t )103,      (flex_int16_t )104,      (flex_int16_t )105,      (flex_int16_t )106, 
        (flex_int16_t )107,      (flex_int16_t )108,      (flex_int16_t )109,      (flex_int16_t )110, 
        (flex_int16_t )111,      (flex_int16_t )112,      (flex_int16_t )113,      (flex_int16_t )114, 
        (flex_int16_t )115,      (flex_int16_t )116,      (flex_int16_t )117,      (flex_int16_t )118, 
        (flex_int16_t )119,      (flex_int16_t )120,      (flex_int16_t )121,      (flex_int16_t )125, 
        (flex_int16_t )126,      (flex_int16_t )127,      (flex_int16_t )131,      (flex_int16_t )135, 
        (flex_int16_t )136,      (flex_int16_t )137,      (flex_int16_t )150,      (flex_int16_t )151, 
        (flex_int16_t )152,      (flex_int16_t )153,      (flex_int16_t )154,      (flex_int16_t )155, 
        (flex_int16_t )156,      (flex_int16_t )157,      (flex_int16_t )158,      (flex_int16_t )159, 
        (flex_int16_t )164,      (flex_int16_t )165,      (flex_int16_t )167,      (flex_int16_t )168, 
        (flex_int16_t )169};
#line 29 "c.l"
struct obstack string_stk ;
#line 37
int ident(void) ;
#line 38
void update_loc(void) ;
#line 44
static int prev_token ;
#line 800 "c.c"
static int yy_init_globals(void) ;
#line 810
int yylex_destroy(void) ;
#line 812
int yyget_debug(void) ;
#line 814
void yyset_debug(int bdebug ) ;
#line 820
FILE *yyget_in(void) ;
#line 822
void yyset_in(FILE *in_str ) ;
#line 824
FILE *yyget_out(void) ;
#line 826
void yyset_out(FILE *out_str ) ;
#line 828
yy_size_t yyget_leng(void) ;
#line 830
char *yyget_text(void) ;
#line 832
int yyget_lineno(void) ;
#line 834
void yyset_lineno(int line_number ) ;
#line 847
int yywrap(void) ;
#line 853
static void yyunput(int c , char *yy_bp ) ;
#line 874
static int input(void) ;
#line 1014 "c.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  int __cil_tmp8 ;
  int yyless_macro_arg ;
  char *__cil_tmp10 ;
  int yyless_macro_arg___0 ;
  size_t __cil_tmp12 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int __cil_tmp17 ;
  int __cil_tmp18 ;

  {
#line 1026
  if (! yy_init) {
#line 1028
    yy_init = 1;
#line 1034
    if (! yy_start) {
#line 1035
      yy_start = 1;
    }
#line 1037
    if (! yyin) {
#line 1039
      yyin = stdin;
    }
#line 1044
    if (! yyout) {
#line 1046
      yyout = stdout;
    }
#line 1051
    if (yy_buffer_stack) {
#line 1051
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1051
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1051
    if (! tmp) {
      {
#line 1052
      yyensure_buffer_stack();
#line 1053
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 1057
    yy_load_buffer_state();
    }
  }
  {
  {
#line 1060
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1063
    yy_cp = yy_c_buf_p;
#line 1066
    *yy_cp = yy_hold_char;
#line 1071
    yy_bp = yy_cp;
#line 1074
    yy_current_state = yy_start;
#line 1075
    yy_current_state += (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol;
    yy_match: 
    {
    {
#line 1077
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1079
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 1080
      if (yy_accept[yy_current_state]) {
#line 1082
        yy_last_accepting_state = yy_current_state;
#line 1083
        yy_last_accepting_cpos = yy_cp;
      }
      {
      {
#line 1085
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1085
        if (! ((int )yy_chk[(int )yy_base[yy_current_state] + (int )yy_c] != yy_current_state)) {
#line 1085
          goto while_break___1;
        }
#line 1087
        yy_current_state = (int )yy_def[yy_current_state];
#line 1088
        if (yy_current_state >= 191) {
#line 1089
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1091
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1092
      yy_cp ++;
#line 1077
      if (! ((int )yy_base[yy_current_state] != 484)) {
#line 1077
        goto while_break___0;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1098
    yy_act = (int )yy_accept[yy_current_state];
#line 1099
    if (yy_act == 0) {
#line 1101
      yy_cp = yy_last_accepting_cpos;
#line 1102
      yy_current_state = yy_last_accepting_state;
#line 1103
      yy_act = (int )yy_accept[yy_current_state];
    }
#line 1106
    yytext = yy_bp;
#line 1106
    yyleng = (size_t )(yy_cp - yy_bp);
#line 1106
    yy_hold_char = *yy_cp;
#line 1106
    *yy_cp = (char )'\000';
#line 1106
    yy_c_buf_p = yy_cp;
    do_action: 
#line 1113
    if (yy_flex_debug) {
#line 1115
      if (yy_act == 0) {
        {
#line 1116
        fprintf(stderr, (char const   *)((char *)"--scanner backing up\n"));
        }
      } else
#line 1117
      if (yy_act < 81) {
        {
#line 1118
        fprintf(stderr, (char const   *)((char *)"--accepting rule at line %ld (\"%s\")\n"),
                (long )yy_rule_linenum[yy_act], yytext);
        }
      } else
#line 1120
      if (yy_act == 81) {
        {
#line 1121
        fprintf(stderr, (char const   *)((char *)"--accepting default rule (\"%s\")\n"),
                yytext);
        }
      } else
#line 1123
      if (yy_act == 82) {
        {
#line 1124
        fprintf(stderr, (char const   *)((char *)"--(end of buffer or a NUL)\n"));
        }
      } else {
        {
#line 1126
        fprintf(stderr, (char const   *)((char *)"--EOF (start condition %d)\n"),
                (yy_start - 1) / 2);
        }
      }
    }
    {
#line 1132
    if (yy_act == 0) {
#line 1132
      goto case_0;
    }
#line 1139
    if (yy_act == 1) {
#line 1139
      goto case_1;
    }
#line 58
    if (yy_act == 2) {
#line 58 "c.l"
      goto case_2;
    }
#line 59
    if (yy_act == 3) {
#line 59
      goto case_3;
    }
#line 60
    if (yy_act == 4) {
#line 60
      goto case_4;
    }
#line 61
    if (yy_act == 5) {
#line 61
      goto case_5;
    }
#line 62
    if (yy_act == 6) {
#line 62
      goto case_6;
    }
#line 63
    if (yy_act == 7) {
#line 63
      goto case_7;
    }
#line 65
    if (yy_act == 9) {
#line 65
      goto case_9;
    }
#line 65
    if (yy_act == 8) {
#line 65
      goto case_9;
    }
#line 68
    if (yy_act == 10) {
#line 68
      goto case_10;
    }
#line 69
    if (yy_act == 11) {
#line 69
      goto case_11;
    }
#line 70
    if (yy_act == 12) {
#line 70
      goto case_12;
    }
#line 71
    if (yy_act == 13) {
#line 71
      goto case_13;
    }
#line 73
    if (yy_act == 14) {
#line 73
      goto case_14;
    }
#line 74
    if (yy_act == 15) {
#line 74
      goto case_15;
    }
#line 75
    if (yy_act == 16) {
#line 75
      goto case_16;
    }
#line 76
    if (yy_act == 17) {
#line 76
      goto case_17;
    }
#line 77
    if (yy_act == 18) {
#line 77
      goto case_18;
    }
#line 78
    if (yy_act == 19) {
#line 78
      goto case_19;
    }
#line 79
    if (yy_act == 20) {
#line 79
      goto case_20;
    }
#line 80
    if (yy_act == 21) {
#line 80
      goto case_21;
    }
#line 86
    if (yy_act == 22) {
#line 86
      goto case_22;
    }
#line 87
    if (yy_act == 23) {
#line 87
      goto case_23;
    }
#line 88
    if (yy_act == 24) {
#line 88
      goto case_24;
    }
#line 89
    if (yy_act == 25) {
#line 89
      goto case_25;
    }
#line 90
    if (yy_act == 26) {
#line 90
      goto case_26;
    }
#line 91
    if (yy_act == 27) {
#line 91
      goto case_27;
    }
#line 92
    if (yy_act == 28) {
#line 92
      goto case_28;
    }
#line 93
    if (yy_act == 29) {
#line 93
      goto case_29;
    }
#line 94
    if (yy_act == 30) {
#line 94
      goto case_30;
    }
#line 95
    if (yy_act == 31) {
#line 95
      goto case_31;
    }
#line 96
    if (yy_act == 32) {
#line 96
      goto case_32;
    }
#line 97
    if (yy_act == 33) {
#line 97
      goto case_33;
    }
#line 98
    if (yy_act == 34) {
#line 98
      goto case_34;
    }
#line 99
    if (yy_act == 35) {
#line 99
      goto case_35;
    }
#line 100
    if (yy_act == 36) {
#line 100
      goto case_36;
    }
#line 101
    if (yy_act == 37) {
#line 101
      goto case_37;
    }
#line 102
    if (yy_act == 38) {
#line 102
      goto case_38;
    }
#line 103
    if (yy_act == 39) {
#line 103
      goto case_39;
    }
#line 104
    if (yy_act == 40) {
#line 104
      goto case_40;
    }
#line 105
    if (yy_act == 41) {
#line 105
      goto case_41;
    }
#line 106
    if (yy_act == 42) {
#line 106
      goto case_42;
    }
#line 107
    if (yy_act == 43) {
#line 107
      goto case_43;
    }
#line 108
    if (yy_act == 44) {
#line 108
      goto case_44;
    }
#line 109
    if (yy_act == 45) {
#line 109
      goto case_45;
    }
#line 110
    if (yy_act == 46) {
#line 110
      goto case_46;
    }
#line 111
    if (yy_act == 47) {
#line 111
      goto case_47;
    }
#line 112
    if (yy_act == 48) {
#line 112
      goto case_48;
    }
#line 113
    if (yy_act == 49) {
#line 113
      goto case_49;
    }
#line 114
    if (yy_act == 50) {
#line 114
      goto case_50;
    }
#line 115
    if (yy_act == 51) {
#line 115
      goto case_51;
    }
#line 116
    if (yy_act == 52) {
#line 116
      goto case_52;
    }
#line 117
    if (yy_act == 53) {
#line 117
      goto case_53;
    }
#line 118
    if (yy_act == 54) {
#line 118
      goto case_54;
    }
#line 121
    if (yy_act == 58) {
#line 121
      goto case_58;
    }
#line 121
    if (yy_act == 57) {
#line 121
      goto case_58;
    }
#line 121
    if (yy_act == 56) {
#line 121
      goto case_58;
    }
#line 121
    if (yy_act == 55) {
#line 121
      goto case_58;
    }
#line 126
    if (yy_act == 60) {
#line 126
      goto case_60;
    }
#line 126
    if (yy_act == 59) {
#line 126
      goto case_60;
    }
#line 128
    if (yy_act == 61) {
#line 128
      goto case_61;
    }
#line 132
    if (yy_act == 62) {
#line 132
      goto case_62;
    }
#line 137
    if (yy_act == 65) {
#line 137
      goto case_65;
    }
#line 137
    if (yy_act == 64) {
#line 137
      goto case_65;
    }
#line 137
    if (yy_act == 63) {
#line 137
      goto case_65;
    }
#line 150
    if (yy_act == 66) {
#line 150
      goto case_66;
    }
#line 152
    if (yy_act == 67) {
#line 152
      goto case_67;
    }
#line 153
    if (yy_act == 68) {
#line 153
      goto case_68;
    }
#line 154
    if (yy_act == 69) {
#line 154
      goto case_69;
    }
#line 155
    if (yy_act == 70) {
#line 155
      goto case_70;
    }
#line 156
    if (yy_act == 71) {
#line 156
      goto case_71;
    }
#line 157
    if (yy_act == 72) {
#line 157
      goto case_72;
    }
#line 158
    if (yy_act == 73) {
#line 158
      goto case_73;
    }
#line 159
    if (yy_act == 74) {
#line 159
      goto case_74;
    }
#line 160
    if (yy_act == 75) {
#line 160
      goto case_75;
    }
#line 165
    if (yy_act == 76) {
#line 165
      goto case_76;
    }
#line 166
    if (yy_act == 77) {
#line 166
      goto case_77;
    }
#line 168
    if (yy_act == 78) {
#line 168
      goto case_78;
    }
#line 169
    if (yy_act == 79) {
#line 169
      goto case_79;
    }
#line 170
    if (yy_act == 80) {
#line 170
      goto case_80;
    }
#line 171
    if (yy_act == 81) {
#line 171
      goto case_81;
    }
#line 1575
    if (yy_act == 87) {
#line 1575 "c.c"
      goto case_87;
    }
#line 1575
    if (yy_act == 86) {
#line 1575
      goto case_87;
    }
#line 1575
    if (yy_act == 85) {
#line 1575
      goto case_87;
    }
#line 1575
    if (yy_act == 84) {
#line 1575
      goto case_87;
    }
#line 1575
    if (yy_act == 83) {
#line 1575
      goto case_87;
    }
#line 1578
    if (yy_act == 82) {
#line 1578
      goto case_82;
    }
#line 1649
    if (yy_act == 1) {
#line 1649
      goto case_1___0;
    }
#line 1678
    if (yy_act == 0) {
#line 1678
      goto case_0___0;
    }
#line 1688
    if (yy_act == 2) {
#line 1688
      goto case_2___0;
    }
#line 1701
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1134
    *yy_cp = yy_hold_char;
#line 1135
    yy_cp = yy_last_accepting_cpos;
#line 1136
    yy_current_state = yy_last_accepting_state;
#line 1137
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 1141
    if (yyleng > 0UL) {
#line 1141
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 56 "c.l"
    line_num ++;
#line 57
    goto switch_break;
    case_2: /* CIL Label */ 
#line 59
    if (yyleng > 0UL) {
#line 59
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 57
    yy_start = 3;
#line 58
    goto switch_break;
    case_3: /* CIL Label */ 
#line 60
    if (yyleng > 0UL) {
#line 60
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }

#line 59
    goto switch_break;
    case_4: /* CIL Label */ 
#line 62
    if (yyleng > 0UL) {
#line 62
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 59
    line_num ++;
#line 60
    goto switch_break;
    case_5: /* CIL Label */ 
#line 62
    if (yyleng > 0UL) {
#line 62
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }

#line 61
    goto switch_break;
    case_6: /* CIL Label */ 
#line 64
    if (yyleng > 0UL) {
#line 64
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 61
    line_num ++;
#line 62
    goto switch_break;
    case_7: /* CIL Label */ 
#line 64
    if (yyleng > 0UL) {
#line 64
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 62
    yy_start = 1;
#line 63
    goto switch_break;
    case_9: /* CIL Label */ 
#line 67
    if (yyleng > 0UL) {
#line 67
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
    {
#line 65
    update_loc();
    }
#line 66
    goto switch_break;
    case_10: /* CIL Label */ 
#line 70
    if (yyleng > 0UL) {
#line 70
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 67
    yy_start = 9;
#line 67
    line_num ++;
#line 68
    goto switch_break;
    case_11: /* CIL Label */ 
#line 71
    if (yyleng > 0UL) {
#line 71
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 68
    line_num ++;
#line 69
    goto switch_break;
    case_12: /* CIL Label */ 
#line 72
    if (yyleng > 0UL) {
#line 72
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 69
    line_num ++;
#line 70
    goto switch_break;
    case_13: /* CIL Label */ 
#line 73
    if (yyleng > 0UL) {
#line 73
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 70
    yy_start = 1;
#line 70
    line_num ++;
#line 71
    goto switch_break;
    case_14: /* CIL Label */ 
#line 74
    if (yyleng > 0UL) {
#line 74
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }

#line 73
    goto switch_break;
    case_15: /* CIL Label */ 
#line 75
    if (yyleng > 0UL) {
#line 75
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 73
    return (261);
#line 74
    goto switch_break;
    case_16: /* CIL Label */ 
#line 76
    if (yyleng > 0UL) {
#line 76
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 74
    return (262);
#line 75
    goto switch_break;
    case_17: /* CIL Label */ 
#line 77
    if (yyleng > 0UL) {
#line 77
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 75
    return (263);
#line 76
    goto switch_break;
    case_18: /* CIL Label */ 
#line 78
    if (yyleng > 0UL) {
#line 78
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 76
    yylval.str = (char *)"struct";
#line 76
    return (264);
#line 77
    goto switch_break;
    case_19: /* CIL Label */ 
#line 79
    if (yyleng > 0UL) {
#line 79
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 77
    yylval.str = (char *)"union";
#line 77
    return (264);
#line 78
    goto switch_break;
    case_20: /* CIL Label */ 
#line 80
    if (yyleng > 0UL) {
#line 80
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 78
    yylval.str = (char *)"enum";
#line 78
    return (264);
#line 79
    goto switch_break;
    case_21: /* CIL Label */ 
#line 81
    if (yyleng > 0UL) {
#line 81
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 79
    yylval.str = (char *)"*";
#line 80
    return (265);
#line 82
    goto switch_break;
    case_22: /* CIL Label */ 
#line 87
    if (yyleng > 0UL) {
#line 87
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 85
    yylval.str = (char *)"->";
#line 85
    return (269);
#line 86
    goto switch_break;
    case_23: /* CIL Label */ 
#line 88
    if (yyleng > 0UL) {
#line 88
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 86
    yylval.str = (char *)".";
#line 86
    return (269);
#line 87
    goto switch_break;
    case_24: /* CIL Label */ 
#line 89
    if (yyleng > 0UL) {
#line 89
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 87
    yylval.str = (char *)"*=";
#line 87
    return (266);
#line 88
    goto switch_break;
    case_25: /* CIL Label */ 
#line 90
    if (yyleng > 0UL) {
#line 90
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 88
    yylval.str = (char *)"/=";
#line 88
    return (266);
#line 89
    goto switch_break;
    case_26: /* CIL Label */ 
#line 91
    if (yyleng > 0UL) {
#line 91
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 89
    yylval.str = (char *)"/";
#line 89
    return (266);
#line 90
    goto switch_break;
    case_27: /* CIL Label */ 
#line 92
    if (yyleng > 0UL) {
#line 92
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 90
    yylval.str = (char *)"%=";
#line 90
    return (266);
#line 91
    goto switch_break;
    case_28: /* CIL Label */ 
#line 93
    if (yyleng > 0UL) {
#line 93
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 91
    yylval.str = (char *)"%";
#line 91
    return (266);
#line 92
    goto switch_break;
    case_29: /* CIL Label */ 
#line 94
    if (yyleng > 0UL) {
#line 94
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 92
    yylval.str = (char *)"+=";
#line 92
    return (266);
#line 93
    goto switch_break;
    case_30: /* CIL Label */ 
#line 95
    if (yyleng > 0UL) {
#line 95
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 93
    yylval.str = (char *)"+";
#line 93
    return (266);
#line 94
    goto switch_break;
    case_31: /* CIL Label */ 
#line 96
    if (yyleng > 0UL) {
#line 96
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 94
    yylval.str = (char *)"-=";
#line 94
    return (266);
#line 95
    goto switch_break;
    case_32: /* CIL Label */ 
#line 97
    if (yyleng > 0UL) {
#line 97
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 95
    yylval.str = (char *)"-";
#line 95
    return (266);
#line 96
    goto switch_break;
    case_33: /* CIL Label */ 
#line 98
    if (yyleng > 0UL) {
#line 98
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 96
    yylval.str = (char *)"<<=";
#line 96
    return (266);
#line 97
    goto switch_break;
    case_34: /* CIL Label */ 
#line 99
    if (yyleng > 0UL) {
#line 99
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 97
    yylval.str = (char *)">>=";
#line 97
    return (266);
#line 98
    goto switch_break;
    case_35: /* CIL Label */ 
#line 100
    if (yyleng > 0UL) {
#line 100
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 98
    yylval.str = (char *)"&=";
#line 98
    return (266);
#line 99
    goto switch_break;
    case_36: /* CIL Label */ 
#line 101
    if (yyleng > 0UL) {
#line 101
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 99
    yylval.str = (char *)"|=";
#line 99
    return (266);
#line 100
    goto switch_break;
    case_37: /* CIL Label */ 
#line 102
    if (yyleng > 0UL) {
#line 102
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 100
    yylval.str = (char *)"^=";
#line 100
    return (266);
#line 101
    goto switch_break;
    case_38: /* CIL Label */ 
#line 103
    if (yyleng > 0UL) {
#line 103
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 101
    yylval.str = (char *)"^";
#line 101
    return (266);
#line 102
    goto switch_break;
    case_39: /* CIL Label */ 
#line 104
    if (yyleng > 0UL) {
#line 104
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 102
    yylval.str = (char *)"||";
#line 102
    return (266);
#line 103
    goto switch_break;
    case_40: /* CIL Label */ 
#line 105
    if (yyleng > 0UL) {
#line 105
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 103
    yylval.str = (char *)"|";
#line 103
    return (266);
#line 104
    goto switch_break;
    case_41: /* CIL Label */ 
#line 106
    if (yyleng > 0UL) {
#line 106
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 104
    yylval.str = (char *)"&&";
#line 104
    return (266);
#line 105
    goto switch_break;
    case_42: /* CIL Label */ 
#line 107
    if (yyleng > 0UL) {
#line 107
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 105
    yylval.str = (char *)"&";
#line 105
    return (266);
#line 106
    goto switch_break;
    case_43: /* CIL Label */ 
#line 108
    if (yyleng > 0UL) {
#line 108
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 106
    yylval.str = (char *)"==";
#line 106
    return (266);
#line 107
    goto switch_break;
    case_44: /* CIL Label */ 
#line 109
    if (yyleng > 0UL) {
#line 109
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 107
    yylval.str = (char *)"=";
#line 107
    return ('=');
#line 108
    goto switch_break;
    case_45: /* CIL Label */ 
#line 110
    if (yyleng > 0UL) {
#line 110
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 108
    yylval.str = (char *)"!=";
#line 108
    return (266);
#line 109
    goto switch_break;
    case_46: /* CIL Label */ 
#line 111
    if (yyleng > 0UL) {
#line 111
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 109
    yylval.str = (char *)"!";
#line 109
    return (266);
#line 110
    goto switch_break;
    case_47: /* CIL Label */ 
#line 112
    if (yyleng > 0UL) {
#line 112
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 110
    yylval.str = (char *)">=";
#line 110
    return (266);
#line 111
    goto switch_break;
    case_48: /* CIL Label */ 
#line 113
    if (yyleng > 0UL) {
#line 113
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 111
    yylval.str = (char *)">";
#line 111
    return (266);
#line 112
    goto switch_break;
    case_49: /* CIL Label */ 
#line 114
    if (yyleng > 0UL) {
#line 114
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 112
    yylval.str = (char *)"<=";
#line 112
    return (266);
#line 113
    goto switch_break;
    case_50: /* CIL Label */ 
#line 115
    if (yyleng > 0UL) {
#line 115
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 113
    yylval.str = (char *)"<";
#line 113
    return (266);
#line 114
    goto switch_break;
    case_51: /* CIL Label */ 
#line 116
    if (yyleng > 0UL) {
#line 116
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 114
    yylval.str = (char *)"<<";
#line 114
    return (266);
#line 115
    goto switch_break;
    case_52: /* CIL Label */ 
#line 117
    if (yyleng > 0UL) {
#line 117
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 115
    yylval.str = (char *)">>";
#line 115
    return (266);
#line 116
    goto switch_break;
    case_53: /* CIL Label */ 
#line 118
    if (yyleng > 0UL) {
#line 118
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 116
    yylval.str = (char *)"++";
#line 116
    return (266);
#line 117
    goto switch_break;
    case_54: /* CIL Label */ 
#line 119
    if (yyleng > 0UL) {
#line 119
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 117
    yylval.str = (char *)"--";
#line 117
    return (266);
#line 118
    goto switch_break;
    case_58: /* CIL Label */ 
#line 122
    if (yyleng > 0UL) {
#line 122
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 121
    return (271);
#line 122
    goto switch_break;
    case_60: /* CIL Label */ 
#line 127
    if (yyleng > 0UL) {
#line 127
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
    {
#line 126
    __cil_tmp8 = ident();
    }
#line 126
    return (__cil_tmp8);
#line 127
    goto switch_break;
    case_61: /* CIL Label */ 
#line 129
    if (yyleng > 0UL) {
#line 129
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 128
    yylval.str = (char *)0;
#line 129
    return (257);
#line 131
    goto switch_break;
    case_62: /* CIL Label */ 
#line 134
    if (yyleng > 0UL) {
#line 134
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
    {
    {
#line 131
    while (1) {
      while_continue___2: /* CIL Label */ ;

#line 131
      yyless_macro_arg = (int )(yyleng - 1UL);
#line 131
      *yy_cp = yy_hold_char;
#line 131
      yy_cp = (yy_bp + yyless_macro_arg) - 0;
#line 131
      yy_c_buf_p = yy_cp;
#line 131
      yytext = yy_bp;
#line 131
      yyleng = (size_t )(yy_cp - yy_bp);
#line 131
      yy_hold_char = *yy_cp;
#line 131
      *yy_cp = (char )'\000';
#line 131
      yy_c_buf_p = yy_cp;
#line 131
      goto while_break___2;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 133
    yylval.str = (char *)0;
#line 134
    return (257);
#line 135
    goto switch_break;
    case_65: /* CIL Label */ 
#line 138
    if (yyleng > 0UL) {
#line 138
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 139
    yylval.str = (char *)0;
#line 140
    return (257);
#line 142
    goto switch_break;
    case_66: /* CIL Label */ 
#line 151
    if (yyleng > 0UL) {
#line 151
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 150
    yy_start = 5;
#line 151
    goto switch_break;
    case_67: /* CIL Label */ 
#line 153
    if (yyleng > 0UL) {
#line 153
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }

#line 152
    goto switch_break;
    case_68: /* CIL Label */ 
#line 155
    if (yyleng > 0UL) {
#line 155
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
    {
#line 152
    line_num ++;
#line 152
    __cil_tmp10 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"unterminated string?"),
                            5);
#line 152
    error_at_line(0, 0, (char const   *)filename, (unsigned int )line_num, (char const   *)((char *)"%s"),
                  __cil_tmp10);
    }
#line 153
    goto switch_break;
    case_69: /* CIL Label */ 
#line 155
    if (yyleng > 0UL) {
#line 155
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }

#line 154
    goto switch_break;
    case_70: /* CIL Label */ 
#line 157
    if (yyleng > 0UL) {
#line 157
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 154
    line_num ++;
#line 155
    goto switch_break;
    case_71: /* CIL Label */ 
#line 157
    if (yyleng > 0UL) {
#line 157
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 155
    yy_start = 7;
#line 156
    goto switch_break;
    case_72: /* CIL Label */ 
#line 158
    if (yyleng > 0UL) {
#line 158
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }

#line 157
    goto switch_break;
    case_73: /* CIL Label */ 
#line 160
    if (yyleng > 0UL) {
#line 160
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 157
    line_num ++;
#line 158
    goto switch_break;
    case_74: /* CIL Label */ 
#line 160
    if (yyleng > 0UL) {
#line 160
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 158
    yy_start = 5;
#line 159
    goto switch_break;
    case_75: /* CIL Label */ 
#line 161
    if (yyleng > 0UL) {
#line 161
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 160
    yy_start = 1;
    {
    {
#line 161
    while (1) {
      while_continue___3: /* CIL Label */ ;

#line 161
      yyless_macro_arg___0 = 0;
#line 161
      *yy_cp = yy_hold_char;
#line 161
      yy_cp = (yy_bp + yyless_macro_arg___0) - 0;
#line 161
      yy_c_buf_p = yy_cp;
#line 161
      yytext = yy_bp;
#line 161
      yyleng = (size_t )(yy_cp - yy_bp);
#line 161
      yy_hold_char = *yy_cp;
#line 161
      *yy_cp = (char )'\000';
#line 161
      yy_c_buf_p = yy_cp;
#line 161
      goto while_break___3;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 162
    return (271);
#line 164
    goto switch_break;
    case_76: /* CIL Label */ 
#line 167
    if (yyleng > 0UL) {
#line 167
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 164
    line_num ++;
#line 165
    goto switch_break;
    case_77: /* CIL Label */ 
#line 167
    if (yyleng > 0UL) {
#line 167
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }

#line 166
    goto switch_break;
    case_78: /* CIL Label */ 
#line 169
    if (yyleng > 0UL) {
#line 169
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 167
    return (258);
#line 168
    goto switch_break;
    case_79: /* CIL Label */ 
#line 170
    if (yyleng > 0UL) {
#line 170
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 168
    return (259);
#line 169
    goto switch_break;
    case_80: /* CIL Label */ 
#line 171
    if (yyleng > 0UL) {
#line 171
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
#line 169
    return ((int )*(yytext + 0));
#line 170
    goto switch_break;
    case_81: /* CIL Label */ 
#line 172
    if (yyleng > 0UL) {
#line 172
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = (int )*(yytext + (yyleng - 1UL)) == 10;
    }
    {
    {
#line 170
    while (1) {
      while_continue___4: /* CIL Label */ ;

      {
#line 170
      __cil_tmp12 = fwrite((void const   *)yytext, yyleng, (unsigned long )1, yyout);
      }
#line 170
      if (__cil_tmp12) {

      }
#line 170
      goto while_break___4;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 171
    goto switch_break;
    case_87: /* CIL Label */ 
#line 1576 "c.c"
    return (0);
    case_82: /* CIL Label */ 
#line 1581
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1584
    *yy_cp = yy_hold_char;
#line 1587
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1598
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1599
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 1600
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1610
    if (yy_c_buf_p <= & *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1614
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1616
      yy_current_state = yy_get_previous_state();
#line 1627
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1629
      yy_bp = yytext + 0;
      }
#line 1631
      if (yy_next_state) {
#line 1634
        yy_c_buf_p ++;
#line 1634
        yy_cp = yy_c_buf_p;
#line 1635
        yy_current_state = yy_next_state;
#line 1636
        goto yy_match;
      } else {
#line 1642
        yy_cp = yy_c_buf_p;
#line 1643
        goto yy_find_action;
      }
    } else {
      {
#line 1647
      __cil_tmp17 = yy_get_next_buffer();
      }
      {
#line 1649
      if (__cil_tmp17 == 1) {
#line 1649
        goto case_1___0;
      }
#line 1678
      if (__cil_tmp17 == 0) {
#line 1678
        goto case_0___0;
      }
#line 1688
      if (__cil_tmp17 == 2) {
#line 1688
        goto case_2___0;
      }
#line 1647
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1651
      yy_did_buffer_switch_on_eof = 0;
#line 1653
      __cil_tmp18 = yywrap();
      }
#line 1653
      if (__cil_tmp18) {
#line 1664
        yy_c_buf_p = yytext + 0;
#line 1666
        yy_act = (82 + (yy_start - 1) / 2) + 1;
#line 1667
        goto do_action;
      } else
#line 1672
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1673
        yyrestart(yyin);
        }
      }
#line 1675
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
#line 1679
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
      {
#line 1682
      yy_current_state = yy_get_previous_state();
#line 1684
      yy_cp = yy_c_buf_p;
#line 1685
      yy_bp = yytext + 0;
      }
#line 1686
      goto yy_match;
      case_2___0: /* CIL Label */ 
#line 1689
      yy_c_buf_p = & *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars);
      {
#line 1692
      yy_current_state = yy_get_previous_state();
#line 1694
      yy_cp = yy_c_buf_p;
#line 1695
      yy_bp = yytext + 0;
      }
#line 1696
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1698
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1702
    yy_fatal_error((char const   [])((char *)"fatal flex scanner internal error--no action found"));
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }

  }
}
}
#line 1724 "c.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source___112 ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  yy_size_t num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  yy_size_t new_size ;
  void *__cil_tmp12 ;
  int c ;
  size_t n ;
  size_t __cil_tmp16 ;
  int __cil_tmp17 ;
  int *__cil_tmp18 ;
  int __cil_tmp20 ;
  int *__cil_tmp21 ;
  int *__cil_tmp22 ;
  yy_size_t new_size___0 ;
  void *__cil_tmp24 ;

  {
#line 1729
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1730
  source___112 = yytext;
#line 1734
  if (yy_c_buf_p > & *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1UL))) {
    {
#line 1735
    yy_fatal_error((char const   [])((char *)"fatal flex scanner internal error--end of buffer missed"));
    }
  }
#line 1738
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1740
    if (yy_c_buf_p - yytext == 1L) {
#line 1745
      return (1);
    } else {
#line 1753
      return (2);
    }
  }
#line 1760
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1762
  i = 0;
  {
  {
#line 1762
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1762
    if (! (i < number_to_move)) {
#line 1762
      goto while_break;
    }
#line 1763
    __cil_tmp7 = source___112;
#line 1763
    source___112 ++;
#line 1763
    __cil_tmp6 = dest;
#line 1763
    dest ++;
#line 1763
    *__cil_tmp6 = *__cil_tmp7;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1762
  i ++;
#line 1765
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1769
    yy_n_chars = (yy_size_t )0;
#line 1769
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1773
    num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (unsigned long )number_to_move) - 1UL;
    {
    {
#line 1776
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1776
      if (! (num_to_read <= 0UL)) {
#line 1776
        goto while_break___0;
      }
#line 1780
      b = *(yy_buffer_stack + yy_buffer_stack_top);
#line 1782
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1785
      if (b->yy_is_our_buffer) {
#line 1787
        new_size = b->yy_buf_size * 2UL;
#line 1789
        if (new_size <= 0UL) {
#line 1790
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1792
          b->yy_buf_size *= (unsigned long )2;
        }
        {
#line 1794
        __cil_tmp12 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1794
        b->yy_ch_buf = (char *)__cil_tmp12;
        }
      } else {
#line 1800
        b->yy_ch_buf = (char *)0;
      }
#line 1802
      if (! b->yy_ch_buf) {
        {
#line 1803
        yy_fatal_error((char const   [])((char *)"fatal error - scanner input buffer overflow"));
        }
      }
#line 1806
      yy_c_buf_p = & *(b->yy_ch_buf + yy_c_buf_p_offset);
#line 1808
      num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (unsigned long )number_to_move) - 1UL;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1813
    if (num_to_read > 8192UL) {
#line 1814
      num_to_read = (yy_size_t )8192;
    }
#line 1817
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1817
      c = '*';
#line 1817
      n = (size_t )0;
      {
      {
#line 1817
      while (1) {
        while_continue___1: /* CIL Label */ ;

#line 1817
        if (! ((n < num_to_read && c != -1) && c != 10)) {
#line 1817
          goto while_break___1;
        }
#line 1817
        *(& *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1817
      n ++;
#line 1817
      if (c == 10) {
#line 1817
        __cil_tmp16 = n;
#line 1817
        n ++;
#line 1817
        *(& *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + __cil_tmp16) = (char )c;
      }
      {
#line 1817
      __cil_tmp17 = ferror(yyin);
      }
#line 1817
      if (c == -1) {
#line 1817
        if (__cil_tmp17) {
          {
#line 1817
          yy_fatal_error((char const   [])((char *)"input in flex scanner failed"));
          }
        }
      }
#line 1817
      yy_n_chars = n;
    } else {
      {
#line 1817
      __cil_tmp18 = __errno_location();
#line 1817
      *__cil_tmp18 = 0;
      }
      {
      {
#line 1817
      while (1) {
        while_continue___2: /* CIL Label */ ;

#line 1817
        if (! (yy_n_chars == 0UL && __cil_tmp20)) {
#line 1817
          goto while_break___2;
        }
        {
#line 1817
        __cil_tmp21 = __errno_location();
        }
#line 1817
        if (*__cil_tmp21 != 4) {
          {
#line 1817
          yy_fatal_error((char const   [])((char *)"input in flex scanner failed"));
          }
#line 1817
          goto while_break___2;
        }
        {
#line 1817
        __cil_tmp22 = __errno_location();
#line 1817
        *__cil_tmp22 = 0;
#line 1817
        clearerr(yyin);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1820
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1823
  if (yy_n_chars == 0UL) {
#line 1825
    if (number_to_move == 0) {
      {
#line 1827
      ret_val = 1;
#line 1828
      yyrestart(yyin);
      }
    } else {
#line 1833
      ret_val = 2;
#line 1834
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1840
    ret_val = 0;
  }
#line 1842
  if (yy_n_chars + (unsigned long )number_to_move > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1844
    new_size___0 = (yy_n_chars + (unsigned long )number_to_move) + (yy_n_chars >> 1);
#line 1845
    __cil_tmp24 = yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                            new_size___0);
#line 1845
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)__cil_tmp24;
    }
#line 1846
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1847
      yy_fatal_error((char const   [])((char *)"out of dynamic memory in yy_get_next_buffer()"));
      }
    }
  }
#line 1850
  yy_n_chars += (unsigned long )number_to_move;
#line 1851
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char )0;
#line 1852
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1UL)) = (char )0;
#line 1854
  yytext = & *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0);
#line 1856
  return (ret_val);
}
}
#line 1864 "c.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1873
  yy_current_state = yy_start;
#line 1874
  yy_current_state += (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol;
#line 1876
  yy_cp = yytext + 0;
  {
  {
#line 1876
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1876
    if (! (yy_cp < yy_c_buf_p)) {
#line 1876
      goto while_break;
    }
#line 1879
    if ((int )*yy_cp) {
#line 1879
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1879
      tmp = 1;
    }
#line 1879
    yy_c = (YY_CHAR )tmp;
#line 1880
    if (yy_accept[yy_current_state]) {
#line 1882
      yy_last_accepting_state = yy_current_state;
#line 1883
      yy_last_accepting_cpos = yy_cp;
    }
    {
    {
#line 1885
    while (1) {
      while_continue___0: /* CIL Label */ ;

#line 1885
      if (! ((int )yy_chk[(int )yy_base[yy_current_state] + (int )yy_c] != yy_current_state)) {
#line 1885
        goto while_break___0;
      }
#line 1887
      yy_current_state = (int )yy_def[yy_current_state];
#line 1888
      if (yy_current_state >= 191) {
#line 1889
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1891
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1876
  yy_cp ++;
#line 1894
  return (yy_current_state);
}
}
#line 1903 "c.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1910
  yy_cp = yy_c_buf_p;
#line 1912
  yy_c = (YY_CHAR )1;
#line 1913
  if (yy_accept[yy_current_state]) {
#line 1915
    yy_last_accepting_state = yy_current_state;
#line 1916
    yy_last_accepting_cpos = yy_cp;
  }
  {
  {
#line 1918
  while (1) {
    while_continue: /* CIL Label */ ;

#line 1918
    if (! ((int )yy_chk[(int )yy_base[yy_current_state] + (int )yy_c] != yy_current_state)) {
#line 1918
      goto while_break;
    }
#line 1920
    yy_current_state = (int )yy_def[yy_current_state];
#line 1921
    if (yy_current_state >= 191) {
#line 1922
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1924
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1925
  yy_is_jam = yy_current_state == 190;
#line 1927
  if (yy_is_jam) {
#line 1927
    tmp = 0;
  } else {
#line 1927
    tmp = yy_current_state;
  }
#line 1927
  return (tmp);
}
}
#line 1932 "c.c"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register yy_size_t number_to_move ;
  register char *dest ;
  register char *source___113 ;

  {
#line 1939
  yy_cp = yy_c_buf_p;
#line 1942
  *yy_cp = yy_hold_char;
#line 1944
  if (yy_cp < (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2) {
#line 1947
    number_to_move = yy_n_chars + 2UL;
#line 1948
    dest = & *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2UL));
#line 1950
    source___113 = & *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move);
    {
    {
#line 1953
    while (1) {
      while_continue: /* CIL Label */ ;

#line 1953
      if (! (source___113 > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1953
        goto while_break;
      }
#line 1954
      source___113 --;
#line 1954
      dest --;
#line 1954
      *dest = *source___113;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 1956
    yy_cp += (int )(dest - source___113);
#line 1957
    yy_bp += (int )(dest - source___113);
#line 1958
    yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1958
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1961
    if (yy_cp < (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2) {
      {
#line 1962
      yy_fatal_error((char const   [])((char *)"flex scanner push-back overflow"));
      }
    }
  }
#line 1965
  yy_cp --;
#line 1965
  *yy_cp = (char )c;
#line 1969
  yytext = yy_bp;
#line 1970
  yy_hold_char = *yy_cp;
#line 1971
  yy_c_buf_p = yy_cp;
}
}
#line 1982 "c.c"
static int input(void) 
{ 
  int c ;
  yy_size_t offset ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;
  int __cil_tmp5 ;

  {
#line 1991
  *yy_c_buf_p = yy_hold_char;
#line 1993
  if ((int )*yy_c_buf_p == 0) {
#line 1999
    if (yy_c_buf_p < & *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
#line 2001
      *yy_c_buf_p = (char )'\000';
    } else {
      {
#line 2005
      offset = (yy_size_t )(yy_c_buf_p - yytext);
#line 2006
      yy_c_buf_p ++;
#line 2008
      __cil_tmp3 = yy_get_next_buffer();
      }
      {
#line 2010
      if (__cil_tmp3 == 2) {
#line 2010
        goto case_2;
      }
#line 2026
      if (__cil_tmp3 == 1) {
#line 2026
        goto case_1;
      }
#line 2040
      if (__cil_tmp3 == 0) {
#line 2040
        goto case_0;
      }
#line 2008
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 2022
      yyrestart(yyin);
      }
      case_1: /* CIL Label */ 
      {
#line 2028
      __cil_tmp4 = yywrap();
      }
#line 2028
      if (__cil_tmp4) {
#line 2029
        return (- 1);
      }
#line 2031
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 2032
        yyrestart(yyin);
        }
      }
      {
#line 2036
      __cil_tmp5 = input();
      }
#line 2036
      return (__cil_tmp5);
      case_0: /* CIL Label */ 
#line 2041
      yy_c_buf_p = yytext + offset;
#line 2042
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 2047
  c = (int )*((unsigned char *)yy_c_buf_p);
#line 2048
  *yy_c_buf_p = (char )'\000';
#line 2049
  yy_c_buf_p ++;
#line 2049
  yy_hold_char = *yy_c_buf_p;
#line 2052
  (*(yy_buffer_stack + yy_buffer_stack_top))->yy_at_bol = c == 10;
#line 2054
  return (c);
}
}
#line 2066 "c.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___114 ;

  {
#line 2072
  if (yy_buffer_stack) {
#line 2072
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2072
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2072
  if (! tmp) {
    {
#line 2073
    yyensure_buffer_stack();
#line 2074
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 2078
  if (yy_buffer_stack) {
#line 2078
    tmp___114 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2078
    tmp___114 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2078
  yy_init_buffer(tmp___114, input_file);
#line 2079
  yy_load_buffer_state();
  }
}
}
#line 2087 "c.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___115 ;

  {
  {
#line 2098
  yyensure_buffer_stack();
  }
#line 2099
  if (yy_buffer_stack) {
#line 2099
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2099
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2099
  if (tmp == new_buffer) {
#line 2100
    return;
  }
#line 2102
  if (yy_buffer_stack) {
#line 2102
    tmp___115 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2102
    tmp___115 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2102
  if (tmp___115) {
#line 2105
    *yy_c_buf_p = yy_hold_char;
#line 2106
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 2107
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 2110
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 2111
  yy_load_buffer_state();
#line 2118
  yy_did_buffer_switch_on_eof = 1;
  }
}
}
#line 2122 "c.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 2127
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 2128
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 2128
  yytext = yy_c_buf_p;
#line 2129
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 2130
  yy_hold_char = *yy_c_buf_p;
}
}
#line 2140 "c.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 2147
  __cil_tmp4 = yyalloc(sizeof(struct yy_buffer_state ));
#line 2147
  b = (YY_BUFFER_STATE )__cil_tmp4;
  }
#line 2148
  if (! b) {
    {
#line 2149
    yy_fatal_error((char const   [])((char *)"out of dynamic memory in yy_create_buffer()"));
    }
  }
  {
#line 2151
  b->yy_buf_size = (yy_size_t )size;
#line 2156
  __cil_tmp5 = yyalloc(b->yy_buf_size + 2UL);
#line 2156
  b->yy_ch_buf = (char *)__cil_tmp5;
  }
#line 2157
  if (! b->yy_ch_buf) {
    {
#line 2158
    yy_fatal_error((char const   [])((char *)"out of dynamic memory in yy_create_buffer()"));
    }
  }
  {
#line 2160
  b->yy_is_our_buffer = 1;
#line 2162
  yy_init_buffer(b, file);
  }
#line 2164
  return (b);
}
}
#line 2172 "c.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2178
  if (! b) {
#line 2179
    return;
  }
#line 2181
  if (yy_buffer_stack) {
#line 2181
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2181
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2181
  if (b == tmp) {
#line 2182
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2184
  if (b->yy_is_our_buffer) {
    {
#line 2185
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 2187
  yyfree((void *)b);
  }
}
}
#line 2195 "c.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *__cil_tmp4 ;
  YY_BUFFER_STATE tmp ;
  int __cil_tmp6 ;
  int __cil_tmp7 ;
  int tmp___116 ;
  int *__cil_tmp9 ;

  {
  {
#line 2201
  __cil_tmp4 = __errno_location();
#line 2201
  oerrno = *__cil_tmp4;
#line 2203
  yy_flush_buffer(b);
#line 2205
  b->yy_input_file = file;
#line 2206
  b->yy_fill_buffer = 1;
  }
#line 2212
  if (yy_buffer_stack) {
#line 2212
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2212
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2212
  if (b != tmp) {
#line 2213
    b->yy_bs_lineno = 1;
#line 2214
    b->yy_bs_column = 0;
  }
#line 2219
  if (file) {
    {
#line 2219
    __cil_tmp6 = fileno(file);
#line 2219
    __cil_tmp7 = isatty(__cil_tmp6);
#line 2219
    tmp___116 = __cil_tmp7 > 0;
    }
  } else {
#line 2219
    tmp___116 = 0;
  }
  {
#line 2219
  b->yy_is_interactive = tmp___116;
#line 2224
  __cil_tmp9 = __errno_location();
#line 2224
  *__cil_tmp9 = oerrno;
  }
}
}
#line 2232 "c.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2237
  if (! b) {
#line 2238
    return;
  }
#line 2240
  b->yy_n_chars = (yy_size_t )0;
#line 2246
  *(b->yy_ch_buf + 0) = (char )0;
#line 2247
  *(b->yy_ch_buf + 1) = (char )0;
#line 2249
  b->yy_buf_pos = & *(b->yy_ch_buf + 0);
#line 2251
  b->yy_at_bol = 1;
#line 2252
  b->yy_buffer_status = 0;
#line 2254
  if (yy_buffer_stack) {
#line 2254
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2254
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2254
  if (b == tmp) {
    {
#line 2255
    yy_load_buffer_state();
    }
  }
}
}
#line 2266 "c.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___117 ;

  {
#line 2271
  if (new_buffer == (YY_BUFFER_STATE )((void *)0)) {
#line 2272
    return;
  }
  {
#line 2274
  yyensure_buffer_stack();
  }
#line 2277
  if (yy_buffer_stack) {
#line 2277
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2277
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2277
  if (tmp) {
#line 2280
    *yy_c_buf_p = yy_hold_char;
#line 2281
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 2282
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 2286
  if (yy_buffer_stack) {
#line 2286
    tmp___117 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2286
    tmp___117 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2286
  if (tmp___117) {
#line 2287
    yy_buffer_stack_top ++;
  }
  {
#line 2288
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 2291
  yy_load_buffer_state();
#line 2292
  yy_did_buffer_switch_on_eof = 1;
  }
}
}
#line 2302 "c.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___118 ;
  YY_BUFFER_STATE tmp___119 ;

  {
#line 2307
  if (yy_buffer_stack) {
#line 2307
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2307
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2307
  if (! tmp) {
#line 2308
    return;
  }
#line 2310
  if (yy_buffer_stack) {
#line 2310
    tmp___118 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2310
    tmp___118 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2310
  yy_delete_buffer(tmp___118);
#line 2311
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2312
  if (yy_buffer_stack_top > 0UL) {
#line 2313
    yy_buffer_stack_top --;
  }
#line 2315
  if (yy_buffer_stack) {
#line 2315
    tmp___119 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2315
    tmp___119 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2315
  if (tmp___119) {
    {
#line 2316
    yy_load_buffer_state();
#line 2317
    yy_did_buffer_switch_on_eof = 1;
    }
  }
}
}
#line 2327 "c.c"
static void yyensure_buffer_stack(void) 
{ 
  yy_size_t num_to_alloc ;
  void *__cil_tmp2 ;
  int grow_size ;
  void *__cil_tmp4 ;

  {
#line 2334
  if (! yy_buffer_stack) {
    {
#line 2340
    num_to_alloc = (yy_size_t )1;
#line 2341
    __cil_tmp2 = yyalloc(num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2341
    yy_buffer_stack = (struct yy_buffer_state **)__cil_tmp2;
    }
#line 2344
    if (! yy_buffer_stack) {
      {
#line 2345
      yy_fatal_error((char const   [])((char *)"out of dynamic memory in yyensure_buffer_stack()"));
      }
    }
    {
#line 2347
    memset((void *)yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2349
    yy_buffer_stack_max = num_to_alloc;
#line 2350
    yy_buffer_stack_top = (size_t )0;
    }
#line 2351
    return;
  }
#line 2354
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 2357
    grow_size = 8;
#line 2359
    num_to_alloc = yy_buffer_stack_max + (unsigned long )grow_size;
#line 2360
    __cil_tmp4 = yyrealloc((void *)yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2360
    yy_buffer_stack = (struct yy_buffer_state **)__cil_tmp4;
    }
#line 2364
    if (! yy_buffer_stack) {
      {
#line 2365
      yy_fatal_error((char const   [])((char *)"out of dynamic memory in yyensure_buffer_stack()"));
      }
    }
    {
#line 2368
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2369
    yy_buffer_stack_max = num_to_alloc;
    }
  }
}
}
#line 2381 "c.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *__cil_tmp4 ;

  {
#line 2385
  if (size < 2UL) {
#line 2389
    return ((YY_BUFFER_STATE )0);
  } else
#line 2385
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2389
    return ((YY_BUFFER_STATE )0);
  } else
#line 2385
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2389
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2391
  __cil_tmp4 = yyalloc(sizeof(struct yy_buffer_state ));
#line 2391
  b = (YY_BUFFER_STATE )__cil_tmp4;
  }
#line 2392
  if (! b) {
    {
#line 2393
    yy_fatal_error((char const   [])((char *)"out of dynamic memory in yy_scan_buffer()"));
    }
  }
  {
#line 2395
  b->yy_buf_size = size - 2UL;
#line 2396
  b->yy_ch_buf = base;
#line 2396
  b->yy_buf_pos = b->yy_ch_buf;
#line 2397
  b->yy_is_our_buffer = 0;
#line 2398
  b->yy_input_file = (FILE *)0;
#line 2399
  b->yy_n_chars = b->yy_buf_size;
#line 2400
  b->yy_is_interactive = 0;
#line 2401
  b->yy_at_bol = 1;
#line 2402
  b->yy_fill_buffer = 0;
#line 2403
  b->yy_buffer_status = 0;
#line 2405
  yy_switch_to_buffer(b);
  }
#line 2407
  return (b);
}
}
#line 2420 "c.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t __cil_tmp2 ;
  YY_BUFFER_STATE __cil_tmp3 ;

  {
  {
#line 2423
  __cil_tmp2 = strlen(yystr);
#line 2423
  __cil_tmp3 = yy_scan_bytes(yystr, __cil_tmp2);
  }
#line 2423
  return (__cil_tmp3);
}
}
#line 2435 "c.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , yy_size_t _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *__cil_tmp7 ;

  {
  {
#line 2443
  n = _yybytes_len + 2UL;
#line 2444
  __cil_tmp7 = yyalloc(n);
#line 2444
  buf = (char *)__cil_tmp7;
  }
#line 2445
  if (! buf) {
    {
#line 2446
    yy_fatal_error((char const   [])((char *)"out of dynamic memory in yy_scan_bytes()"));
    }
  }
#line 2448
  i = 0;
  {
  {
#line 2448
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2448
    if (! ((unsigned long )i < _yybytes_len)) {
#line 2448
      goto while_break;
    }
#line 2449
    *(buf + i) = (char )*(yybytes + i);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2448
  i ++;
#line 2451
  *(buf + (_yybytes_len + 1UL)) = (char )0;
#line 2451
  *(buf + _yybytes_len) = *(buf + (_yybytes_len + 1UL));
#line 2453
  b = yy_scan_buffer(buf, n);
  }
#line 2454
  if (! b) {
    {
#line 2455
    yy_fatal_error((char const   [])((char *)"bad buffer in yy_scan_bytes()"));
    }
  }
#line 2460
  b->yy_is_our_buffer = 1;
#line 2462
  return (b);
}
}
#line 2471 "c.c"
static void yy_fatal_error(char const   *msg ) 
{ 
  int __cil_tmp2 ;

  {
  {
#line 2473
  __cil_tmp2 = fprintf(stderr, (char const   *)((char *)"%s\n"), msg);
#line 2474
  exit(2);
  }
}
}
#line 2506 "c.c"
int yyget_lineno(void) 
{ 


  {
#line 2509
  return (yylineno);
}
}
#line 2515 "c.c"
FILE *yyget_in(void) 
{ 


  {
#line 2517
  return (yyin);
}
}
#line 2523 "c.c"
FILE *yyget_out(void) 
{ 


  {
#line 2525
  return (yyout);
}
}
#line 2531 "c.c"
yy_size_t yyget_leng(void) 
{ 


  {
#line 2533
  return (yyleng);
}
}
#line 2540 "c.c"
char *yyget_text(void) 
{ 


  {
#line 2542
  return (yytext);
}
}
#line 2552 "c.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 2555
  yylineno = line_number;
}
}
#line 2564 "c.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 2566
  yyin = in_str;
}
}
#line 2569 "c.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 2571
  yyout = out_str;
}
}
#line 2574 "c.c"
int yyget_debug(void) 
{ 


  {
#line 2576
  return (yy_flex_debug);
}
}
#line 2579 "c.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 2581
  yy_flex_debug = bdebug;
}
}
#line 2592 "c.c"
static int yy_init_globals(void) 
{ 


  {
#line 2598
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2599
  yy_buffer_stack_top = (size_t )0;
#line 2600
  yy_buffer_stack_max = (size_t )0;
#line 2601
  yy_c_buf_p = (char *)0;
#line 2602
  yy_init = 0;
#line 2603
  yy_start = 0;
#line 2610
  yyin = (FILE *)0;
#line 2611
  yyout = (FILE *)0;
#line 2617
  return (0);
}
}
#line 2623 "c.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___120 ;

  {
  {
  {
#line 2627
  while (1) {
    while_continue: /* CIL Label */ ;

#line 2627
    if (! tmp) {
#line 2627
      goto while_break;
    }
#line 2628
    if (yy_buffer_stack) {
#line 2628
      tmp___120 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2628
      tmp___120 = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2628
    yy_delete_buffer(tmp___120);
#line 2629
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2630
    yypop_buffer_state();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2634
  yyfree((void *)yy_buffer_stack);
#line 2635
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2639
  yy_init_globals();
  }
#line 2643
  return (0);
}
}
#line 2671 "c.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *__cil_tmp2 ;

  {
  {
#line 2673
  __cil_tmp2 = malloc(size);
  }
#line 2673
  return (__cil_tmp2);
}
}
#line 2676 "c.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *__cil_tmp3 ;

  {
  {
#line 2685
  __cil_tmp3 = realloc((void *)((char *)ptr), size);
  }
#line 2685
  return (__cil_tmp3);
}
}
#line 2688 "c.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 2690
  free((void *)((char *)ptr));
  }
}
}
#line 173 "c.l"
static char *keywords[]  = 
#line 173 "c.l"
  {      (char *)"break",      (char *)"case",      (char *)"continue",      (char *)"default", 
        (char *)"do",      (char *)"else",      (char *)"for",      (char *)"goto", 
        (char *)"if",      (char *)"return",      (char *)"sizeof",      (char *)"switch", 
        (char *)"while"};
#line 189 "c.l"
static char *types[]  = {      (char *)"char",      (char *)"double",      (char *)"float",      (char *)"int", 
        (char *)"void"};
#line 197 "c.l"
static char *qualifiers[]  = 
#line 197
  {      (char *)"long",      (char *)"const",      (char *)"register",      (char *)"restrict", 
        (char *)"short",      (char *)"signed",      (char *)"unsigned",      (char *)"volatile", 
        (char *)"inline"};
#line 210 "c.l"
void init_tokens(void) 
{ 
  int i ;
  Symbol *sp ;

  {
#line 215
  i = 0;
  {
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;

#line 215
    if (! ((unsigned long )i < sizeof(keywords) / sizeof(keywords[0]))) {
#line 215
      goto while_break;
    }
    {
#line 216
    sp = install(keywords[i], 1);
#line 217
    sp->type = (enum symtype )1;
#line 218
    sp->token_type = 257;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  i ++;
#line 221
  i = 0;
  {
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 221
    if (! ((unsigned long )i < sizeof(types) / sizeof(types[0]))) {
#line 221
      goto while_break___0;
    }
    {
#line 222
    sp = install(types[i], 1);
#line 223
    sp->type = (enum symtype )1;
#line 224
    sp->token_type = 270;
#line 225
    sp->source = (char *)((void *)0);
#line 226
    sp->def_line = - 1;
#line 227
    sp->ref_line = (struct linked_list *)((void *)0);
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 221
  i ++;
#line 230
  i = 0;
  {
  {
#line 230
  while (1) {
    while_continue___1: /* CIL Label */ ;

#line 230
    if (! ((unsigned long )i < sizeof(qualifiers) / sizeof(qualifiers[0]))) {
#line 230
      goto while_break___1;
    }
    {
#line 231
    sp = install(qualifiers[i], 1);
#line 232
    sp->type = (enum symtype )1;
#line 233
    sp->token_type = 273;
#line 234
    sp->source = (char *)((void *)0);
#line 235
    sp->def_line = - 1;
#line 236
    sp->ref_line = (struct linked_list *)((void *)0);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 230
  i ++;
#line 238
  sp = install((char *)"...", 1);
#line 239
  sp->type = (enum symtype )1;
#line 240
  sp->token_type = 260;
#line 241
  sp->source = (char *)((void *)0);
#line 242
  sp->def_line = - 1;
#line 243
  sp->ref_line = (struct linked_list *)((void *)0);
  }
}
}
#line 247 "c.l"
void init_lex(int debug_level ) 
{ 


  {
  {
#line 249
  yy_flex_debug = debug_level;
#line 250
  _obstack_begin(& string_stk, 0, 0, (void *(*)(long  ))xmalloc, (void (*)(void * ))free);
#line 251
  init_tokens();
  }
}
}
#line 255 "c.l"
int ident(void) 
{ 
  Symbol *sp ;
  Symbol *__cil_tmp2 ;

  {
#line 265
  if (prev_token != 264) {
    {
#line 266
    __cil_tmp2 = lookup((char const   *)yytext);
#line 266
    sp = __cil_tmp2;
    }
#line 267
    if (sp) {
#line 267
      if ((unsigned int )sp->type == 1U) {
#line 268
        yylval.str = sp->name;
#line 269
        return (sp->token_type);
      }
    }
  }
#line 274
  yylval.str = (char *)0;
#line 275
  return (260);
}
}
#line 280
char *pp_bin ;
#line 281
char *pp_opts ;
#line 282
static struct obstack *opt_stack ;
#line 285 "c.l"
void set_preprocessor(char const   *arg___0 ) 
{ 
  char *__cil_tmp2 ;
  char *tmp ;

  {
#line 287
  if (arg___0) {
    {
#line 287
    __cil_tmp2 = xstrdup(arg___0);
#line 287
    tmp = __cil_tmp2;
    }
  } else {
#line 287
    tmp = (char *)((void *)0);
  }
#line 287
  pp_bin = tmp;
}
}
#line 291 "c.l"
void pp_option(char const   *arg___0 ) 
{ 
  void *__cil_tmp2 ;

  {
#line 293
  if (! opt_stack) {
#line 294
    if (! pp_bin) {
#line 295
      pp_bin = (char *)"/usr/bin/cpp";
    }
    {
#line 296
    __cil_tmp2 = xmalloc(sizeof(*opt_stack));
#line 296
    opt_stack = (struct obstack *)__cil_tmp2;
#line 297
    _obstack_begin(opt_stack, 0, 0, (void *(*)(long  ))xmalloc, (void (*)(void * ))free);
    }
  }
}
}
#line 304 "c.l"
void pp_finalize(void) 
{ 
  char *s ;
  size_t __cil_tmp3 ;
  size_t __cil_tmp4 ;
  void *__cil_tmp5 ;

  {
#line 306
  s = (char *)0;
#line 307
  if (! pp_opts) {
    {
#line 308
    pp_opts = xstrdup((char const   *)s);
    }
  } else {
    {
#line 310
    __cil_tmp4 = strlen((char const   *)s);
    }
    {
#line 310
    __cil_tmp3 = strlen((char const   *)pp_opts);
#line 310
    __cil_tmp5 = xrealloc((void *)pp_opts, (__cil_tmp3 + __cil_tmp4) + 1UL);
#line 310
    pp_opts = (char *)__cil_tmp5;
#line 311
    strcat(pp_opts, (char const   *)s);
    }
  }
  {
#line 314
  free((void *)opt_stack);
#line 315
  opt_stack = (struct obstack *)((void *)0);
  }
}
}
#line 319 "c.l"
FILE *pp_open(char const   *name ) 
{ 
  FILE *fp ;
  char *s ;
  size_t size ;
  size_t __cil_tmp5 ;
  size_t __cil_tmp6 ;
  size_t __cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  int *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 325
  if (opt_stack) {
    {
#line 326
    pp_finalize();
    }
  }
  {
#line 327
  __cil_tmp6 = strlen(name);
  }
  {
#line 327
  __cil_tmp5 = strlen((char const   *)pp_bin);
#line 327
  size = ((__cil_tmp5 + 1UL) + __cil_tmp6) + 1UL;
  }
#line 328
  if (pp_opts) {
    {
#line 329
    __cil_tmp7 = strlen((char const   *)pp_opts);
    }
#line 329
    size += __cil_tmp7;
  }
  {
#line 330
  __cil_tmp8 = xmalloc(size);
#line 330
  s = (char *)__cil_tmp8;
#line 331
  strcpy(s, (char const   *)pp_bin);
  }
#line 332
  if (pp_opts) {
    {
#line 333
    strcat(s, (char const   *)pp_opts);
    }
  }
  {
#line 334
  strcat(s, (char const   *)((char *)" "));
#line 335
  strcat(s, name);
  }
#line 336
  if (debug) {
    {
#line 337
    __cil_tmp9 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"Command line: %s\n"),
                           5);
#line 337
    fprintf(stderr, (char const   *)__cil_tmp9, s);
    }
  }
  {
#line 338
  fp = popen((char const   *)s, (char const   *)((char *)"r"));
  }
#line 339
  if (! fp) {
    {
#line 340
    __cil_tmp11 = __errno_location();
    }
    {
#line 340
    __cil_tmp12 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"cannot execute `%s\'"),
                            5);
#line 340
    error(0, *__cil_tmp11, (char const   *)__cil_tmp12, s);
    }
  }
  {
#line 341
  free((void *)s);
  }
#line 342
  return (fp);
}
}
#line 346 "c.l"
void pp_close(FILE *fp ) 
{ 


  {
  {
#line 348
  pclose(fp);
  }
}
}
#line 354 "c.l"
int yywrap(void) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 356
  if (! yyin) {
#line 357
    return (1);
  }
#line 358
  if (preprocess_option) {
    {
#line 359
    pp_close(yyin);
    }
  } else {
    {
#line 361
    fclose(yyin);
    }
  }
#line 362
  yyin = (FILE *)((void *)0);
#line 364
  if (yy_buffer_stack) {
#line 364
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 364
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 364
  yy_delete_buffer(tmp);
#line 366
  delete_statics();
  }
#line 367
  return (1);
}
}
#line 370
static int hit_eof ;
#line 373 "c.l"
int get_token(void) 
{ 
  int tok___0 ;

  {
#line 377
  if (hit_eof) {
#line 378
    tok___0 = 0;
  } else {
    {
#line 380
    tok___0 = yylex();
#line 381
    prev_token = tok___0;
    }
#line 382
    if (! tok___0) {
#line 383
      hit_eof = 1;
    }
  }
#line 385
  return (tok___0);
}
}
#line 389 "c.l"
int source(char *name ) 
{ 
  FILE *fp ;
  int *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 393
  fp = fopen((char const   *)name, (char const   *)((char *)"r"));
  }
#line 394
  if (! fp) {
    {
#line 395
    __cil_tmp4 = __errno_location();
    }
    {
#line 395
    __cil_tmp5 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"cannot open `%s\'"),
                           5);
#line 395
    error(0, *__cil_tmp4, (char const   *)__cil_tmp5, name);
    }
#line 396
    return (1);
  }
#line 398
  if (preprocess_option) {
    {
#line 399
    fclose(fp);
#line 400
    fp = pp_open((char const   *)name);
    }
#line 401
    if (! fp) {
#line 402
      return (1);
    }
  }
  {
#line 405
  filename = (char *)0;
#line 406
  canonical_filename = filename;
#line 407
  line_num = 1;
#line 408
  input_file_count ++;
#line 409
  hit_eof = 0;
#line 411
  yyrestart(fp);
  }
#line 412
  return (0);
}
}
#line 416 "c.l"
static int getnum(unsigned int base , int count ) 
{ 
  int c ;
  int n ;
  unsigned int i ;
  unsigned short const   **__cil_tmp6 ;
  int __cil_tmp8 ;

  {
#line 421
  n = 0;
  {
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;

#line 421
    if (! count) {
#line 421
      goto while_break;
    }
    {
#line 422
    __cil_tmp6 = __ctype_b_loc();
    }
    {
#line 422
    c = input();
    }
#line 422
    if ((int )((unsigned short )*(*__cil_tmp6 + c)) & 2048) {
#line 423
      i = (unsigned int )(c - 48);
    } else {
#line 425
      i = (unsigned int )-55;
    }
#line 426
    if (i > base) {
      {
#line 427
      yyunput(c, yytext);
      }
#line 428
      goto while_break;
    }
#line 430
    n = (int )((unsigned int )n * base + i);
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 421
  __cil_tmp8 = count;
#line 421
  count --;
#line 432
  return (n);
}
}
#line 436 "c.l"
int backslash(void) 
{ 
  int c ;
  int __cil_tmp3 ;
  int __cil_tmp4 ;

  {
  {
#line 440
  c = input();
  }
  {
#line 441
  if (c == 'a') {
#line 441
    goto case_97;
  }
#line 442
  if (c == 'b') {
#line 442
    goto case_98;
  }
#line 443
  if (c == 'f') {
#line 443
    goto case_102;
  }
#line 444
  if (c == 'n') {
#line 444
    goto case_110;
  }
#line 445
  if (c == 'r') {
#line 445
    goto case_114;
  }
#line 446
  if (c == 't') {
#line 446
    goto case_116;
  }
#line 447
  if (c == 'x') {
#line 447
    goto case_120;
  }
#line 448
  if (c == '0') {
#line 448
    goto case_48;
  }
#line 440
  goto switch_break;
  case_97: /* CIL Label */ 
#line 441
  return ('\a');
  case_98: /* CIL Label */ 
#line 442
  return ('\b');
  case_102: /* CIL Label */ 
#line 443
  return ('\f');
  case_110: /* CIL Label */ 
#line 444
  return ('\n');
  case_114: /* CIL Label */ 
#line 445
  return ('\r');
  case_116: /* CIL Label */ 
#line 446
  return ('\t');
  case_120: /* CIL Label */ 
  {
#line 447
  __cil_tmp3 = getnum((unsigned int )16, 2);
  }
#line 447
  return (__cil_tmp3);
  case_48: /* CIL Label */ 
  {
#line 448
  __cil_tmp4 = getnum((unsigned int )8, 3);
  }
#line 448
  return (__cil_tmp4);
  switch_break: /* CIL Label */ ;
  }
#line 450
  return (c);
}
}
#line 454 "c.l"
void update_loc(void) 
{ 
  char *p ;
  char *__cil_tmp2 ;
  unsigned short const   **__cil_tmp3 ;
  unsigned long __cil_tmp5 ;
  unsigned short const   **__cil_tmp6 ;
  int n ;
  char *__cil_tmp9 ;
  char *__cil_tmp11 ;

  {
  {
#line 458
  __cil_tmp2 = strchr((char const   *)yytext, '#');
#line 458
  p = __cil_tmp2 + 1;
  }
  {
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;

#line 458
    if (! ((int )*p && (int )((unsigned short )*(*__cil_tmp3 + (int )*p)) & 8192)) {
#line 458
      goto while_break;
    }

  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  p ++;
#line 460
  if ((int )*(p + 0) == 108) {
#line 461
    p += 4;
  }
  {
#line 463
  __cil_tmp5 = strtoul((char const   *)p, & p, 10);
#line 463
  line_num = (int )__cil_tmp5;
  }
  {
  {
#line 464
  while (1) {
    while_continue___0: /* CIL Label */ ;

#line 464
    if (! ((int )*p && (int )((unsigned short )*(*__cil_tmp6 + (int )*p)) & 8192)) {
#line 464
      goto while_break___0;
    }

  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 464
  p ++;
#line 466
  if ((int )*(p + 0) == 34) {
#line 469
    n = 0;
#line 469
    __cil_tmp9 = p;
#line 469
    p ++;
    {
    {
#line 469
    while (1) {
      while_continue___1: /* CIL Label */ ;

#line 469
      if (! ((int )*(p + n) && (int )*(p + n) != 34)) {
#line 469
        goto while_break___1;
      }

    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 469
    n ++;
#line 473
    filename = (char *)0;
  }
#line 475
  if (debug > 1) {
    {
#line 476
    __cil_tmp11 = dcgettext((char const   *)((void *)0), (char const   *)((char *)"New location: %s:%d\n"),
                            5);
#line 476
    fprintf(stderr, (char const   *)__cil_tmp11, filename, line_num);
    }
  }
}
}
